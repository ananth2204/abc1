{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012642000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1998724, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE714.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE714.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x1f\\n'", "DS1TRBAL": "b'\\x08\\x80'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xf2\\x00\\x00\\x04\\xf4\\x00\\x01\\x00 '", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x08\\x0f\\x01\\x05\\x08\\x0f\\t)\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-03-21T00:00:00", "modifydate": "2005-03-21T09:29:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-469"}, "text": "REGULAR CBT TAPE - VERSION 469    FILE:  714\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT469.FILE714\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 18,555 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/21/05    09:29:50    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00(\\x01\\x05\\x08\\x0f\\x01\\x05\\x08\\x0f\\t(\\x005\\x00*\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2005-03-21T00:00:00", "modifydate": "2005-03-21T09:28:28", "lines": 53, "newlines": 42, "modlines": 0, "user": "SBGOLOB"}, "text": "Normal disclaimer, this program is provided free of charge\nand no warranty is made as to its fitness for any particular\npurpose.  The author assumes no liability resulting from\nthe use or misuse of these programs.\n\n\nThis distribution contains 3 files.\n\nflexcli.notes - this file\n\nflexcli.xmi   - the mvs side of the program.\n                ftp this program to an mvs system\n                run\n                RECEIVE INDS(flexcli.xmi)\n                to recreate the PDS.  The PDS contains\n                the programs, JCL to compile the program,\n                sample JCL to use the program, and a sample\n                listing truncated to 80 bytes wide.\n\n    (Note:  The MVS part has already been received, and consists\n            of members:\n\n            $COMPILE $SAMPOUT $SAMPRUN ASMSRC COS001A\n            COS001B  DSSDUMP  LINKDATE PLISRC             )\n\nflexescli_inetd.tar  - The unix (linux) side of the program\n                designed to run under xinetd.  The comments at\n                the beginning of flexescli_inetd.c describe how\n                to set the program up for use with xinetd.\n\n    (Note:  This tar file is member TAR in this pds.  In order\n            to use it, you have to download it to the Linux side\n            of the FLEX-ES system in BINARY and un-tar it\n            there.    SBG 03/05)\n\nNote:  The flexescli_inetd program, by way of xinetd is listening\non a port.  The MVS side of the program will contact the\nflexescli_inetd program using the IP address of the UNIX side\nof the system and the port.  The MVS side has the port 19999 coded\ninto it as a default although it can be overridden with the\nport= parameter to the main parm string.\n\nThe port on the Unix side is specified in /etc/services.  The\nupdate to /etc/services is shown in flexescli_inetd.c using the\nport 19999.  You may wish to use a different port.  If you use a\ndifferent port, update the MVS program (member PLISRC) to reflect\nthe new port.  You will probably update it to change the default IP\naddress to the correct value on your system.\n\nIf you have any questions, feel free to contact me:\n\nRobert Styma    stymar@lucent.com,    styma@swlink.net\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$COMPILE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00)\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x08\\t\\x00\\xe6\\x00\\xdb\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T08:09:29", "lines": 230, "newlines": 219, "modlines": 0, "user": "QC22505"}, "text": "//QC22505R JOB (),'FLEXCLI',CLASS=E,MSGCLASS=X,\n//         MSGLEVEL=(1,1),NOTIFY=QC22505,PRTY=0\n/*JOBPARM LINES=999\n//*\n//**********************************************************************\n//*\n//*  THIS JOB COMPILES AND LINKS THE FLEXCLI PROGRAM\n//*\n//*  TO USE THIS JCL:\n//*  1.  ADJUST THE JOB CARD TO YOUR SYSTEMS SPECIFICATIONS\n//*  2.  CHANGE QC22505 TO YOUR USERID GLOBALLY\n//*  3.  THIS JCL ASSUMES IT IS PART OF PDS QC22505.FLEXCLI.JCL\n//*      ADJUST THIS NAME GLOBALLY IF NEEDED.\n//*  4.  CREATED LOAD MODULE WILL BE IN QC22505.FLEXCLI.LOADLIB\n//*      (YOUR ID AFTER THE GLOBAL CHANGE)\n//*\n//*  5.  YOU WILL PROBABLY WANT TO EDIT THE PLISRC MEMBER TO CHANGE\n//*      THE DEFAULT IP ADDRESS OF THE UNIX SIDE OF THE FLEX BOX.\n//*      THE DEFAULT IS SET TO 192.168.123.45, YOU WILL WANT TO\n//*      CHANGE THIS.\n//*\n//*  6.  IN THE SAME SOURCE FILE THE DEFAULT PORT USED IS 19999\n//*      WHICH IS THE SAME PORT IN DEFAULTED ON THE UNIX SIDE.\n//*      IF YOU CHANGE THE PORT NUMBER ON THE UNIX SIDE, YOU NEED\n//*      TO CHANGE IT IN THE PROGRAM.\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*    STEP PLI                                                      ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//PLI      EXEC PGM=IEL0AA,       <COMPILE THE SOURCE>\n//             REGION=1200K,\n//             TIME=999,\n//             PARM=('MAP,LC(80),NEST',\n//             'TEST(STMT,SYM)',\n//  'GS,OPT(2),AG,A,X,C,STG,INT')\n//*\n//SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(PLISRC),\n//             DISP=SHR\n//*\n//SYSLIN  DD   DSN=&&OBJECT,       <OBTECT MODULE>\n//             DISP=(MOD,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(40,2)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//*\n//SYSUT1   DD  DSN=&&SYSUT1,       <PL/I WORK FILE>\n//             DISP=NEW,\n//             DCB=BLKSIZE=1024,\n//             SPACE=(CYL,5,,CONTIG),\n//             UNIT=SYSDA\n//*\n//SYSPUNCH DD  DSN=&&SYSPUNCH,\n//             DISP=(NEW,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(10,1)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=9040)\n//*\n//SYSPRINT DD  SYSOUT=*\n//*SYSPRINT DD  DSN=QC22505.FLEXCLI.LIST,\n//*             DISP=(NEW,CATLG),\n//*             UNIT=SYSDA,SPACE=(CYL,(80,10),RLSE),\n//*             DCB=BLKSIZE=23476\n//*\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*    STEP ASM                                                      ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//ASM     EXEC PGM=ASMA90,    <ASSEMBLE BAL SOURCE WITH HL ASM>\n//             REGION=4000K,\n//             TIME=999,\n//             PARM=('NODECK,ASA,BATCH',\n//             'XREF(SHORT),')\n//*\n//SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(ASMSRC),\n//             DISP=SHR\n//*\n//SYSLIB   DD  DSN=SYS1.MACLIB,    <GENERAL MACROS>\n//             DCB=BLKSIZE=27920,\n//             DISP=SHR\n//*\n//         DD  DSN=SYS1.AMODGEN,\n//             DISP=SHR\n//*\n//SYSLIN   DD  DSN=&OBJECT,       <ASSEMBLED OBJECT CODE>\n//             DISP=(MOD,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(40,2)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//*\n//SYSUT1   DD  DSN=&SYSUT1,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(5,1))\n//*\n//SYSPRINT DD  SYSOUT=*\n//*SYSPRINT DD  DSN=&ASMPRINT,\n//*             DISP=(NEW,PASS),\n//*             UNIT=SYSDA,SPACE=(CYL,(80,10),RLSE),\n//*             DCB=BLKSIZE=23476\n//*\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*    STEP ASM2  COMPILE THE LINKDATE PROGRAM                       ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//ASM0    EXEC PGM=ASMA90,    <ASSEMBLE BAL SOURCE WITH HL ASM>\n//             REGION=4000K,\n//             TIME=999,\n//             PARM=('NODECK,ASA,BATCH',\n//             'XREF(SHORT),')\n//*\n//SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(LINKDATE),\n//             DISP=SHR\n//*\n//SYSLIB   DD  DSN=SYS1.MACLIB,    <GENERAL MACROS>\n//             DCB=BLKSIZE=27920,\n//             DISP=SHR\n//*\n//SYSLIN   DD  DSN=&OBJECT0,      <ASSEMBLED OBJECT CODE>\n//             DISP=(MOD,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(TRK,(1,1)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//*\n//SYSUT1   DD  DSN=&SYSUT1,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(5,1))\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     STEP LKED LINK LINKDATE SO WE CAN USE IT IN LATER STEPS      ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//LKED0    EXEC  PGM=IEWL,      < EXEC LINK EDITOR TO GEN LOAD MODULE >\n//             REGION=4000K,\n//             TIME=999,\n//             PARM=('LET,DCBS,LIST,MAP,MSGLEVEL(4)')\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//SYSUT1   DD  UNIT=SYSDA,           < LINKAGE EDITOR WORK FILE       >\n//             SPACE=(CYL,(6,1))\n//*\n//SYSLIN   DD  DSN=&&OBJECT0,      < OBJECT FORM PREVIOUS COMPILE   >\n//             DISP=(OLD,DELETE)     < STEP                           >\n//*\n//SYSLMOD  DD  DSN=&&LINKDATE(LINKDATE), < TEMPORARY LOAD LIBRARY    >\n//             DISP=(NEW,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(22,1,6)),\n//             DCB=(RECFM=U,BLKSIZE=23476)\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     STEP LINKDATE                                                ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//LINKDATE EXEC  PGM=LINKDATE,  < EXEC LINK EDITOR TO GEN LOAD MODULE >\n//             PARM='L,IEFBR14'\n//*\n//STEPLIB  DD  DSN=&&LINKDATE,       < LOAD LIBRARY FOR LINKDATE >\n//             DISP=(OLD,PASS)\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//SYSUDUMP DD  SYSOUT=*\n//*\n//SETSSI   DD  DSN=&&SSICARD,        < SSI CARD GENERATED BY THIS   >\n//             UNIT=SYSDA,\n//             DISP=(NEW,PASS),\n//             SPACE=(TRK,1),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=800)\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     STEP LKED                                                    ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//LKED     EXEC  PGM=IEWL,      < EXEC LINK EDITOR TO GEN LOAD MODULE >\n//             REGION=4000K,\n//             TIME=999,\n//             PARM=('LET,DCBS,LIST,MAP,MSGLEVEL(4)',\n//             'RMODE=ANY,AMODE=31')\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//SYSUDUMP DD  SYSOUT=*\n//*\n//SYSLIB   DD  DSN=CEE.SCEELKED,\n//             DISP=SHR\n//*\n//         DD  DSN=SYS1.CSSLIB,\n//             DISP=SHR\n//*\n//SYSUT1   DD  UNIT=SYSDA,           < LINKAGE EDITOR WORK FILE       >\n//             SPACE=(CYL,(6,1))\n//*\n//SYSLIN   DD  DSN=&&SSICARD,\n//             DISP=(OLD,DELETE)\n//*\n//         DD  DSN=&&OBJECT,       < OBJECT FORM PREVIOUS COMPILE   >\n//             DISP=(OLD,DELETE)     < STEP                           >\n//*\n//SYSLMOD  DD  DSN=QC22505.FLEXCLI.LOADLIB(FLEXCLI),\n//             DISP=(MOD,CATLG),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(22,1,6)),\n//             DCB=(RECFM=U,BLKSIZE=23476)\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     END OF JOB                                                   ***\n//*                                                                  ***\n//**********************************************************************\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SAMPOUT": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x070\\x01I\\x01I\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T07:30:26", "lines": 329, "newlines": 329, "modlines": 0, "user": "QC22505"}, "text": "1                   J E S 2  J O B  L O G  --  S Y S T E M  S Y S 1  --  N O D E\n0\n 07.22.09 JOB01337 ---- FRIDAY,    18 MAR 2005 ----\n 07.22.09 JOB01337  IRR010I  USERID QC22505  IS ASSIGNED TO THIS JOB.\n 07.22.09 JOB01337  ICH70001I QC22505  LAST ACCESS AT 07:13:04 ON FRIDAY, MARCH\n 07.22.09 JOB01337  $HASP373 QC22505R STARTED - INIT 1    - CLASS E - SYS SYS1\n 07.22.09 JOB01337  IEF403I QC22505R - STARTED - TIME=07.22.09\n 07.22.21 JOB01337  IEC705I TAPE ON 0570,000011,SL,COMP,QC22505R,DSSDUMP.COS001,\n 07.22.29 JOB01337  IEF234E K 0570,000011,PVT,QC22505R,DSSDUMP\n 07.28.41 JOB01337  IEF404I QC22505R - ENDED - TIME=07.28.41\n 07.28.41 JOB01337  $HASP395 QC22505R ENDED\n0------ JES2 JOB STATISTICS ------\n-  18 MAR 2005 JOB EXECUTION DATE\n-          122 CARDS READ\n-          329 SYSOUT PRINT RECORDS\n-            0 SYSOUT PUNCH RECORDS\n-           18 SYSOUT SPOOL KBYTES\n-         6.53 MINUTES EXECUTION TIME\n         1 //QC22505R JOB (),'FLEXCLI',CLASS=E,MSGCLASS=X,\n           //         MSGLEVEL=(1,1),NOTIFY=QC22505,PRTY=0\n           /*JOBPARM LINES=999\n           //*\n           //*******************************************************************\n           //*\n           //*  THIS JOB COMPILES AND LINKS THE FLEXCLI PROGRAM\n           //*\n           //*  TO USE THIS JCL:\n           //*  1.  ADJUST THE JOB CARD TO YOUR SYSTEMS SPECIFICATIONS\n           //*  2.  CHANGE QC22505 TO YOUR USERID GLOBALLY\n           //*  3.  THIS JCL ASSUMES IT IS PART OF PDS QC22505.FLEXCLI.JCL\n           //*      ADJUST THIS NAME GLOBALLY IF NEEDED.\n           //*\n           //*  4.  CREATED LOAD MODULE WILL BE IN QC22505.FLEXCLI.LOADLIB\n           //*      (YOUR ID AFTER THE GLOBAL CHANGE)\n           //*\n           //*******************************************************************\n           //*\n         2 //FLEXBKUP PROC VOL='?',\n           //*                                  < VOLSER  TO BACKUP\n           //*                                  < EG.  COS001\n           //             UNIT=570\n           //*                                  < TAPE UNIT ID, USUALLY 570\n           //*\n           //*\n           //*******************************************************************\n           //*\n           //*  PROJECT:  SDE - SOFTWARE DEVELOPMENT ENVIRONMENT\n           //*  RESPONSIBLE GROUP:  SDE SUPPORT SOFTWARE\n           //*  DATE OF LAST MAINTENANCE --- 04-22-2004  BY  R. E. STYMA\n           //*  FUNCTION:\n           //*     THIS PROCEDURE USES THE ADRDSSU (DSS) TO BACK UP A DISK\n           //*     VOLUME TO AN EMULATED TAPE WHICH IS ACTUALLY A UNIX FILE.\n           //*     THE FLEXCLI PROGRAM IS USED TO INITIALIZE THE TAPE DATASET,\n           //*     MOUNT THE TAPE, AND THEN AFTER THE BACKUP TO COMPRESS THE\n           //*     EMULATED TAPE AND MOVE IT TO AN NFS PARTITION WHICH IS\n           //*     BACKED UP BY OTHER MEANS.\n           //*\n           //*\n           //*\n           //*  CHANGE HISTORY:\n           //*  04/22/2004 -  INITIAL RELEASE\n           //*\n           //*\n           //*******************************************************************\n           //*\n           //*******************************************************************\n           //*\n           //*  STEP FLEXCLI1 - INITIALIZE THE SIMULATED TAPE DATASET\n           //*                  MOUNT THE TAPE WITH THE FLEXCLI CONSOLE.\n           //*\n           //*******************************************************************\n           //*\n           //FLEXCLI1 EXEC PGM=FLEXCLI,\n           //             REGION=4000K\n           //*\n           //STEPLIB  DD  DSN=QC22505.FLEXCLI.LOADLIB,           < 0 >\n           //             DISP=SHR\n           //*\n           //* SYSIN CONTAINS THE UNIX COMMANDS TO INITIALIZE THE TAPE AND THE\n           //* FLEXESCLI COMMAND TO MOUNT IT.\n           //*\n           //SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(&VOL.A),\n           //             DISP=SHR\n           //*\n           //SYSPRINT DD  SYSOUT=*\n           //*\n           //*******************************************************************\n           //*\n           //*  STEP DSSDUMP  - DUMP THE VOLUME TO THE SIMULATED TAPE\n           //*\n           //*  NOTE:\n           //*      TAPE POINTS TO A CATALOGED TAPE DATASET WHICH IDENTIFIES\n           //*      A PARTICULAR TAPE VOLSER.  THE &VOL.A AND &VOL.B\n           //*      MEMBERS OF 'QC22505.FLEXCLI.JCL' HAVE REFERENCES TO THIS\n           //*      THE SAME TAPE VOLSER.  THESE HAVE TO MATCH.\n           //*      IF THEY DO NOT, YOU WILL GET A DISMOUNT MESSAGE ON THE\n           //*      CONSOLE AND MOUNT FOR THE CATALOGED TAPE VOLSER.  YOU\n           //*      CAN KILL THE JOB AND FIX THE MISMATCH OR MANUALLY SET UP\n           //*      THE TAPE DATASET.\n           //*******************************************************************\n           //*\n           //DSSDUMP  EXEC PGM=ADRDSSU,COND=(4,LT),\n           //             REGION=4000K\n           //*\n           //SYSPRINT DD SYSOUT=*\n           //*\n           //DASD     DD UNIT=SYSDA,VOL=SER=&VOL,DISP=SHR\n           //*\n           //TAPE     DD DSN=HSS.FLEX.DSS.DUMP.&VOL,\n           //           UNIT=&UNIT,\n           //           LABEL=RETPD=1,\n           //           BLKSIZE=32760,\n           //           DISP=(OLD,KEEP)\n           //*\n           //SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(DSSDUMP),\n           //             DISP=SHR\n           //*\n           //*******************************************************************\n           //*\n           //*  STEP FLEXCLI2 - INITIALIZE THE SIMULATED TAPE DATASET\n           //*                  MOUNT THE TAPE WITH THE FLEXCLI CONSOLE.\n           //*\n           //*******************************************************************\n           //*\n           //FLEXCLI2 EXEC PGM=FLEXCLI,COND=(4,LT),\n           //             REGION=4000K\n           //*\n           //STEPLIB  DD  DSN=QC22505.FLEXCLI.LOADLIB,           < 0 >\n           //             DISP=SHR\n           //*\n           //* SYSIN CONTAINS THE UNIX COMMANDS TO INITIALIZE THE TAPE AND THE\n           //* FLEXESCLI COMMAND TO MOUNT IT.\n           //*\n           //SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(&VOL.B),\n           //             DISP=SHR\n           //*\n           //SYSPRINT DD  SYSOUT=*\n           //*\n           //   PEND\n         3 //COS001  EXEC FLEXBKUP,VOL=COS001\n         4 ++FLEXBKUP PROC VOL='?',\n           ++*                                  < VOLSER  TO BACKUP\n           ++*                                  < EG.  COS001\n           ++             UNIT=570\n           ++*                                  < TAPE UNIT ID, USUALLY 570\n           ++*\n           ++*\n           ++*******************************************************************\n           ++*\n           ++*  PROJECT:  SDE - SOFTWARE DEVELOPMENT ENVIRONMENT\n           ++*  RESPONSIBLE GROUP:  SDE SUPPORT SOFTWARE\n           ++*  DATE OF LAST MAINTENANCE --- 04-22-2004  BY  R. E. STYMA\n           ++*  FUNCTION:\n           ++*     THIS PROCEDURE USES THE ADRDSSU (DSS) TO BACK UP A DISK\n           ++*     VOLUME TO AN EMULATED TAPE WHICH IS ACTUALLY A UNIX FILE.\n           ++*     THE FLEXCLI PROGRAM IS USED TO INITIALIZE THE TAPE DATASET,\n           ++*     MOUNT THE TAPE, AND THEN AFTER THE BACKUP TO COMPRESS THE\n           ++*     EMULATED TAPE AND MOVE IT TO AN NFS PARTITION WHICH IS\n           ++*     BACKED UP BY OTHER MEANS.\n           ++*\n           ++*\n           ++*\n           ++*  CHANGE HISTORY:\n           ++*  04/22/2004 -  INITIAL RELEASE\n           ++*\n           ++*\n           ++*******************************************************************\n           ++*\n           ++*******************************************************************\n           ++*\n           ++*  STEP FLEXCLI1 - INITIALIZE THE SIMULATED TAPE DATASET\n           ++*                  MOUNT THE TAPE WITH THE FLEXCLI CONSOLE.\n           ++*\n           ++*******************************************************************\n           ++*\n         5 ++FLEXCLI1 EXEC PGM=FLEXCLI,\n           ++             REGION=4000K\n           ++*\n         6 ++STEPLIB  DD  DSN=QC22505.FLEXCLI.LOADLIB,           < 0 >\n           ++             DISP=SHR\n           ++*\n           ++* SYSIN CONTAINS THE UNIX COMMANDS TO INITIALIZE THE TAPE AND THE\n           ++* FLEXESCLI COMMAND TO MOUNT IT.\n           ++*\n         7 ++SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(&VOL.A),\n           ++             DISP=SHR\n           ++*\n           IEFC653I SUBSTITUTION JCL - DSN=QC22505.FLEXCLI.JCL(COS001A),DISP=SHR\n         8 ++SYSPRINT DD  SYSOUT=*\n           ++*\n           ++*******************************************************************\n           ++*\n           ++*  STEP DSSDUMP  - DUMP THE VOLUME TO THE SIMULATED TAPE\n           ++*\n           ++*  NOTE:\n           ++*      TAPE POINTS TO A CATALOGED TAPE DATASET WHICH IDENTIFIES\n           ++*      A PARTICULAR TAPE VOLSER.  THE &VOL.A AND &VOL.B\n           ++*      MEMBERS OF 'QC22505.FLEXCLI.JCL' HAVE REFERENCES TO THIS\n           ++*      THE SAME TAPE VOLSER.  THESE HAVE TO MATCH.\n           ++*      IF THEY DO NOT, YOU WILL GET A DISMOUNT MESSAGE ON THE\n           ++*      CONSOLE AND MOUNT FOR THE CATALOGED TAPE VOLSER.  YOU\n           ++*      CAN KILL THE JOB AND FIX THE MISMATCH OR MANUALLY SET UP\n           ++*      THE TAPE DATASET.\n           ++*******************************************************************\n           ++*\n         9 ++DSSDUMP  EXEC PGM=ADRDSSU,COND=(4,LT),\n           ++             REGION=4000K\n           ++*\n        10 ++SYSPRINT DD SYSOUT=*\n           ++*\n        11 ++DASD     DD UNIT=SYSDA,VOL=SER=&VOL,DISP=SHR\n           ++*\n           IEFC653I SUBSTITUTION JCL - UNIT=SYSDA,VOL=SER=COS001,DISP=SHR\n        12 ++TAPE     DD DSN=HSS.FLEX.DSS.DUMP.&VOL,\n           ++           UNIT=&UNIT,\n           ++           LABEL=RETPD=1,\n           ++           BLKSIZE=32760,\n           ++           DISP=(OLD,KEEP)\n           ++*\n           IEFC653I SUBSTITUTION JCL - DSN=HSS.FLEX.DSS.DUMP.COS001,UNIT=570,LAB\n        13 ++SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(DSSDUMP),\n           ++             DISP=SHR\n           ++*\n           ++*******************************************************************\n           ++*\n           ++*  STEP FLEXCLI2 - INITIALIZE THE SIMULATED TAPE DATASET\n           ++*                  MOUNT THE TAPE WITH THE FLEXCLI CONSOLE.\n           ++*\n           ++*******************************************************************\n           ++*\n        14 ++FLEXCLI2 EXEC PGM=FLEXCLI,COND=(4,LT),\n           ++             REGION=4000K\n           ++*\n        15 ++STEPLIB  DD  DSN=QC22505.FLEXCLI.LOADLIB,           < 0 >\n           ++             DISP=SHR\n           ++*\n           ++* SYSIN CONTAINS THE UNIX COMMANDS TO INITIALIZE THE TAPE AND THE\n           ++* FLEXESCLI COMMAND TO MOUNT IT.\n           ++*\n        16 ++SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(&VOL.B),\n           ++             DISP=SHR\n           ++*\n           IEFC653I SUBSTITUTION JCL - DSN=QC22505.FLEXCLI.JCL(COS001B),DISP=SHR\n        17 ++SYSPRINT DD  SYSOUT=*\n           ++*\n  STMT NO. MESSAGE\n         3 IEFC001I PROCEDURE FLEXBKUP WAS EXPANDED USING INSTREAM PROCEDURE DEF\n ICH70001I QC22505  LAST ACCESS AT 07:13:04 ON FRIDAY, MARCH 18, 2005\n IEF236I ALLOC. FOR QC22505R FLEXCLI1 COS001\n IEF237I 0A89 ALLOCATED TO STEPLIB\n IEF237I 0A8F ALLOCATED TO SYSIN\n IEF237I JES2 ALLOCATED TO SYSPRINT\n IEF142I QC22505R FLEXCLI1 COS001 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   QC22505.FLEXCLI.LOADLIB                      KEPT\n IEF285I   VOL SER NOS= WRK102.\n IEF285I   QC22505.FLEXCLI.JCL                          KEPT\n IEF285I   VOL SER NOS= COS002.\n IEF285I   QC22505.QC22505R.JOB01337.D0000101.?         SYSOUT\n IEF373I STEP/FLEXCLI1/START 2005077.0722\n IEF374I STEP/FLEXCLI1/STOP  2005077.0722 CPU    0MIN 00.18SEC SRB    0MIN 00.01\n IEF236I ALLOC. FOR QC22505R DSSDUMP COS001\n IEF237I JES2 ALLOCATED TO SYSPRINT\n IEF237I 0A9D ALLOCATED TO DASD\n IEF237I 0570 ALLOCATED TO TAPE\n IEF237I 0A8F ALLOCATED TO SYSIN\n IEF142I QC22505R DSSDUMP COS001 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   QC22505.QC22505R.JOB01337.D0000102.?         SYSOUT\n IEF285I   SYS05077.T072209.RA000.QC22505R.R0102454     KEPT\n IEF285I   VOL SER NOS= COS001.\n IEF285I   HSS.FLEX.DSS.DUMP.COS001                     KEPT\n IEF285I   VOL SER NOS= 000011.\n IEF285I   QC22505.FLEXCLI.JCL                          KEPT\n IEF285I   VOL SER NOS= COS002.\n IEF373I STEP/DSSDUMP /START 2005077.0722\n IEF374I STEP/DSSDUMP /STOP  2005077.0722 CPU    0MIN 04.17SEC SRB    0MIN 01.08\n IEF236I ALLOC. FOR QC22505R FLEXCLI2 COS001\n IEF237I 0A89 ALLOCATED TO STEPLIB\n IEF237I 0A8F ALLOCATED TO SYSIN\n IEF237I JES2 ALLOCATED TO SYSPRINT\n IEF142I QC22505R FLEXCLI2 COS001 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   QC22505.FLEXCLI.LOADLIB                      KEPT\n IEF285I   VOL SER NOS= WRK102.\n IEF285I   QC22505.FLEXCLI.JCL                          KEPT\n IEF285I   VOL SER NOS= COS002.\n IEF285I   QC22505.QC22505R.JOB01337.D0000103.?         SYSOUT\n IEF373I STEP/FLEXCLI2/START 2005077.0722\n IEF374I STEP/FLEXCLI2/STOP  2005077.0728 CPU    0MIN 00.18SEC SRB    0MIN 00.01\n IEF375I  JOB/QC22505R/START 2005077.0722\n IEF376I  JOB/QC22505R/STOP  2005077.0728 CPU    0MIN 04.53SEC SRB    0MIN 01.10\n1FLEXCLI CONSOLE INTERFACE              RELEASE 1.0 AS OF 03/18/05  07:13\n sh-2.05b$ rm -f /faketape/COS001.tape.000011;echo \"CC=$?\"\n CC=0\n sh-2.05b$  cp /faketape/backup/mt/tape.000011 /faketape/COS001.tape.000011;echo\n CC=0\n sh-2.05b$ mount 0570 offline\n flexes> mount 0570 /faketape/COS001.tape.000011\n flexes> quit\n Process exited, code 0\n exit\n exit\n Process exited, code 0\n1PAGE 0001     5695-DF175  DFSMSDSS V2R10.0 DATA SET SERVICES     2005.077 07:22\n-  DUMP FULL INDDNAME(DASD) OUTDDNAME(TAPE)\n ADR101I (R/I)-RI01 (01), TASKID 001 HAS BEEN ASSIGNED TO COMMAND 'DUMP '\n ADR109I (R/I)-RI01 (01), 2005.077 07:22:21 INITIAL SCAN OF USER CONTROL STATEME\n ADR016I (001)-PRIME(01), RACF LOGGING OPTION IN EFFECT FOR THIS TASK\n0ADR006I (001)-STEND(01), 2005.077 07:22:21 EXECUTION BEGINS\n0ADR006I (001)-STEND(02), 2005.077 07:22:29 EXECUTION ENDS\n0ADR013I (001)-CLTSK(01), 2005.077 07:22:29 TASK COMPLETED WITH RETURN CODE 0000\n0ADR012I (SCH)-DSSU (01), 2005.077 07:22:29 DFSMSDSS PROCESSING COMPLETE. HIGHES\n1FLEXCLI CONSOLE INTERFACE              RELEASE 1.0 AS OF 03/18/05  07:13\n sh-2.05b$ mount 0570 offline\n flexes> /bin/rm -f /faketape/COS001.tape.000011.gz;echo \"CC=$?\"\n CC=0\n sh-2.05b$ /bin/gzip /faketape/COS001.tape.000011;echo \"CC=$?\"\n mv /faketape/COS001.tape.000011.gz /nfstape/COS001.tape.000011.gz;echo \"CC=$?\"\n quit\n exit\n\n Process exited, code 0\n CC=0\n sh-2.05b$ mv /faketape/COS001.tape.000011.gz /nfstape/COS001.tape.000011.gz;ech\n mv: overwrite `/nfstape/COS001.tape.000011.gz', overriding mode 0644? exit\n\n CC=0\n sh-2.05b$\n sh-2.05b$ exit\n exit\n Process exited, code 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SAMPRUN": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x07)\\x00\\x84\\x00\\x84\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T07:29:40", "lines": 132, "newlines": 132, "modlines": 0, "user": "QC22505"}, "text": "//QC22505R JOB (),'FLEXCLI',CLASS=E,MSGCLASS=X,\n//         MSGLEVEL=(1,1),NOTIFY=QC22505,PRTY=0\n/*JOBPARM LINES=999\n//*\n//**********************************************************************\n//*\n//*  THIS JOB COMPILES AND LINKS THE FLEXCLI PROGRAM\n//*\n//*  TO USE THIS JCL:\n//*  1.  ADJUST THE JOB CARD TO YOUR SYSTEMS SPECIFICATIONS\n//*  2.  CHANGE QC22505 TO YOUR USERID GLOBALLY\n//*  3.  THIS JCL ASSUMES IT IS PART OF PDS QC22505.FLEXCLI.JCL\n//*      ADJUST THIS NAME GLOBALLY IF NEEDED.\n//*\n//*  4.  THIS JOB EXPECTS TO BACK UP A VOLUME NAMED COS001\n//*      THE NAME COS001 APPEARS IN THIS JCL AND ALSO IN THE CONTROL\n//*      CARD MEMBERS COS001A AND COS001B.  TO DUMP A DIFFERENT\n//*      VOLUME, DUPLICATE COS001A AND COS001B USING THE VOLUME\n//*      NAME OF THE DISK TO BE BACKED UP.  THEN ADJUST THE CONTENTS\n//*      OF THE NEW CONTROL CARD MEMBERS TO REFLECT THE VOLSER OF\n//*      THE DASD AND THE VOLSER OF THE TAPE.\n//*\n//*  5.  THE UNIX DIRECTORY /FAKETAPE/BACKUP/MT CONTAINS A BUNCH\n//*      OF EMPTY(MT) INITIALIZED (IEHINITT) FAKETAPE FILES.\n//*      TAPE.000011 IS A TAPE INITIALIZED TO VOLSER 000011\n//*      ADJUST THESE TO MATCH THE TAPES YOU CREATED.\n//*\n//**********************************************************************\n//*                                                                  ***\n//FLEXBKUP PROC VOL='?',\n//*                                  < VOLSER  TO BACKUP              >\n//*                                  < EG.  COS001                    >\n//             UNIT=570\n//*                                  < TAPE UNIT ID, USUALLY 570      >\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*  PROJECT:  SDE - SOFTWARE DEVELOPMENT ENVIRONMENT                ***\n//*  RESPONSIBLE GROUP:  SDE SUPPORT SOFTWARE                        ***\n//*  DATE OF LAST MAINTENANCE --- 04-22-2004  BY  R. E. STYMA        ***\n//*  FUNCTION:                                                       ***\n//*     THIS PROCEDURE USES THE ADRDSSU (DSS) TO BACK UP A DISK      ***\n//*     VOLUME TO AN EMULATED TAPE WHICH IS ACTUALLY A UNIX FILE.    ***\n//*     THE FLEXCLI PROGRAM IS USED TO INITIALIZE THE TAPE DATASET,  ***\n//*     MOUNT THE TAPE, AND THEN AFTER THE BACKUP TO COMPRESS THE    ***\n//*     EMULATED TAPE AND MOVE IT TO AN NFS PARTITION WHICH IS       ***\n//*     BACKED UP BY OTHER MEANS.                                    ***\n//*                                                                  ***\n//*                                                                  ***\n//*                                                                  ***\n//*  CHANGE HISTORY:                                                 ***\n//*  04/22/2004 -  INITIAL RELEASE                                   ***\n//*                                                                  ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//**********************************************************************\n//*                                                                  ***\n//*  STEP FLEXCLI1 - INITIALIZE THE SIMULATED TAPE DATASET           ***\n//*                  MOUNT THE TAPE WITH THE FLEXCLI CONSOLE.        ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//FLEXCLI1 EXEC PGM=FLEXCLI,\n//             REGION=4000K\n//*\n//STEPLIB  DD  DSN=QC22505.FLEXCLI.LOADLIB,           < 0 >\n//             DISP=SHR\n//*\n//* SYSIN CONTAINS THE UNIX COMMANDS TO INITIALIZE THE TAPE AND THE\n//* FLEXESCLI COMMAND TO MOUNT IT.\n//*\n//SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(&VOL.A),\n//             DISP=SHR\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*  STEP DSSDUMP  - DUMP THE VOLUME TO THE SIMULATED TAPE           ***\n//*                                                                  ***\n//*  NOTE:                                                           ***\n//*      TAPE POINTS TO A CATALOGED TAPE DATASET WHICH IDENTIFIES    ***\n//*      A PARTICULAR TAPE VOLSER.  THE &VOL.A AND &VOL.B            ***\n//*      MEMBERS OF 'QC22505.FLEXCLI.JCL' HAVE REFERENCES TO THIS    ***\n//*      THE SAME TAPE VOLSER.  THESE HAVE TO MATCH.                 ***\n//*      IF THEY DO NOT, YOU WILL GET A DISMOUNT MESSAGE ON THE      ***\n//*      CONSOLE AND MOUNT FOR THE CATALOGED TAPE VOLSER.  YOU       ***\n//*      CAN KILL THE JOB AND FIX THE MISMATCH OR MANUALLY SET UP    ***\n//*      THE TAPE DATASET.                                           ***\n//**********************************************************************\n//*\n//DSSDUMP  EXEC PGM=ADRDSSU,COND=(4,LT),\n//             REGION=4000K\n//*\n//SYSPRINT DD SYSOUT=*\n//*\n//DASD     DD UNIT=SYSDA,VOL=SER=&VOL,DISP=SHR\n//*\n//TAPE     DD DSN=HSS.FLEX.DSS.DUMP.&VOL,\n//           UNIT=&UNIT,\n//           LABEL=RETPD=1,\n//           BLKSIZE=32760,\n//           DISP=(OLD,KEEP)\n//*\n//SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(DSSDUMP),\n//             DISP=SHR\n//*\n//**********************************************************************\n//*                                                                  ***\n//*  STEP FLEXCLI2 - INITIALIZE THE SIMULATED TAPE DATASET           ***\n//*                  MOUNT THE TAPE WITH THE FLEXCLI CONSOLE.        ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//FLEXCLI2 EXEC PGM=FLEXCLI,COND=(4,LT),\n//             REGION=4000K\n//*\n//STEPLIB  DD  DSN=QC22505.FLEXCLI.LOADLIB,           < 0 >\n//             DISP=SHR\n//*\n//* SYSIN CONTAINS THE UNIX COMMANDS TO INITIALIZE THE TAPE AND THE\n//* FLEXESCLI COMMAND TO MOUNT IT.\n//*\n//SYSIN    DD  DSN=QC22505.FLEXCLI.JCL(&VOL.B),\n//             DISP=SHR\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//   PEND\n//COS001  EXEC FLEXBKUP,VOL=COS001\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE714": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x08\\x0f\\x01\\x05\\x08\\x0f\\t)\\x005\\x005\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-03-21T00:00:00", "modifydate": "2005-03-21T09:29:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "CBT-469"}, "text": "//***FILE 714 is from Bob Styma and contains a set of programs      *   FILE 714\n//*           to enable an MVS system that is running under         *   FILE 714\n//*           FLEX-ES to issue flexes commands to the Linux         *   FILE 714\n//*           system it is running on.                              *   FILE 714\n//*                                                                 *   FILE 714\n//*        If you have any questions, feel free to contact me:      *   FILE 714\n//*                                                                 *   FILE 714\n//*        Robert Styma    stymar@lucent.com,   styma@swlink.net    *   FILE 714\n//*                                                                 *   FILE 714\n//*     Normal disclaimer, this program is provided free of         *   FILE 714\n//*     charge and no warranty is made as to its fitness for        *   FILE 714\n//*     any particular purpose.  The author assumes no              *   FILE 714\n//*     liability resulting from the use or misuse of these         *   FILE 714\n//*     programs.                                                   *   FILE 714\n//*                                                                 *   FILE 714\n//*     This distribution contains 3 parts.                         *   FILE 714\n//*                                                                 *   FILE 714\n//*     1.  $$NOTE1 - general description of the package            *   FILE 714\n//*                                                                 *   FILE 714\n//*     2.  The MVS side of the program -                           *   FILE 714\n//*                                                                 *   FILE 714\n//*          Note:  This consists of members:                       *   FILE 714\n//*           $COMPILE $SAMPOUT $SAMPRUN ASMSRC COS001A             *   FILE 714\n//*           COS001B  DSSDUMP  LINKDATE PLISRC                     *   FILE 714\n//*                                                                 *   FILE 714\n//*     3.  TAR     - (download this to the Linux side of the       *   FILE 714\n//*                    FLEX-ES system and un-tar it there.)         *   FILE 714\n//*                                                                 *   FILE 714\n//*        flexescli_inetd.tar  - The unix (linux) side of the      *   FILE 714\n//*                     program designed to run under xinetd.       *   FILE 714\n//*                     The comments at the beginning of            *   FILE 714\n//*                     flexescli_inetd.c describe how to set       *   FILE 714\n//*                     the program up for use with xinetd.         *   FILE 714\n//*                                                                 *   FILE 714\n//*     General program description:                                *   FILE 714\n//*                                                                 *   FILE 714\n//*        Note:  The flexescli_inetd program, by way of xinetd     *   FILE 714\n//*        is listening on a port.  The MVS side of the program     *   FILE 714\n//*        will contact the flexescli_inetd program using the       *   FILE 714\n//*        IP address of the UNIX side of the system and the        *   FILE 714\n//*        port.  The MVS side has the port 19999 coded into it     *   FILE 714\n//*        as a default although it can be overridden with the      *   FILE 714\n//*        port= parameter to the main parm string.                 *   FILE 714\n//*                                                                 *   FILE 714\n//*        The port on the Unix side is specified in                *   FILE 714\n//*        /etc/services.  The update to /etc/services is shown     *   FILE 714\n//*        in flexescli_inetd.c using the port 19999.  You may      *   FILE 714\n//*        wish to use a different port.  If you use a              *   FILE 714\n//*        different port, update the MVS program (member           *   FILE 714\n//*        PLISRC) to reflect the new port.  You will probably      *   FILE 714\n//*        update it to change the default IP address to the        *   FILE 714\n//*        correct value on your system.                            *   FILE 714\n//*                                                                 *   FILE 714\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMSRC": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x07\\x125\\xe35\\xdb\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T07:12:57", "lines": 13795, "newlines": 13787, "modlines": 0, "user": "QC22505"}, "text": "*          DATA SET FG20188710 AT LEVEL 030 AS OF 02/13/04\nGETDSN   TITLE 'GET DATASET NAME OR VOLUME SERIAL NUMBER'               00001\n*********************************************************************** 00006\n*                                                                     * 00006\n* SEGMENT NAME:                                                       * 00006\n*                                                                     * 00006\n*    GETDSN                                                           * 00006\n*                                                                     * 00030\n* INPUTS (*TO FUNCTIONS):                                             * 00030\n*                                                                     * 00007\n*    DDNAME -- A CHARACTER(8) PL/I STRING PASSED AS INPUT. (*2)       * 00007\n*                                                                     * 00010\n*    MEMBER -- A CHARACTER(8) PL/I STRING WHERE WE HAVE TO PUT THE    * 00010\n*       DATASET MEMBER NAME, IF IT EXISTS. (*2)                       * 00010\n*                                                                     * 00022\n*    TIOTADDR -- THE ADDRESS OF THE TASK INPUT OUTPUT TABLE. (*2)     * 00022\n*                                                                     * 00014\n*    STATUSFL -- A BYTE WITH INTERNAL STATUS FLAGS (*3)               * 00014\n*                                                                     * 00015\n*       NAME     PATTERN  DESCRIPITION                                * 00015\n*                                                                     * 00016\n*       GETDSNC  1....... GETDSN CALLED                               * 00017\n*                         SET WHEN ENTRY POINT GETDSN GETS CALLED,    * 00018\n*       GETMEMC  .1...... GETMEM CALLED                               * 00019\n*                         SET WHEN ENTRY POINT GETMEM GETS CALLED,    * 00020\n*                         RESET WHEN ENTRY POINT GETVOL GETS CALLLED  * 00020\n*                                                                     * 00023\n* FUNCTIONS:                                                          * 00023\n*                                                                     * 00023\n*    1. DEPENDING ON WHICH ENTRY POINT GETS CALLED, SET/RESET THE     * 00023\n*       GETDSNC BIT.                                                  * 00023\n*                                                                     * 00026\n*    2. GET THE TASK INPUT OUTPUT TABLE ADDRESS.  SCAN THROUGH THE DD * 00026\n*       ENTRIES UNTIL THE DDNAME IS FOUND, OR UNTIL THE END OF THE    * 00026\n*       TIOT IS REACHED.  GET THE JOB FILE CONTROL BLOCK ADDRESS.     * 00026\n*       BLANK OUT DSNAME, MEMBER, OR VOLSER.                          * 00026\n*                                                                     * 00038\n*    3. DEPENDING ON THE ENTRY POINT CALLED, MOVE THE DATASET NAME,   * 00038\n*       MEMBER NAME, OR THE VOLUME SERIAL NUMBER IN THE PL/I STRING   * 00038\n*       PASSED TO US.                                                 * 00038\n*                                                                     * 00025\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00025\n*                                                                     * 00014\n*    STATUSFL -- A BYTE WITH INTERNAL STATUS FLAGS (*1,2)             * 00014\n*                                                                     * 00015\n*       NAME     PATTERN  DESCRIPITION                                * 00015\n*                                                                     * 00016\n*       GETDSNC  1....... GETDSN CALLED                               * 00017\n*                         SET WHEN ENTRY POINT GETDSN GETS CALLED,    * 00018\n*       GETMEMC  .1...... GETMEM CALLED                               * 00019\n*                         SET WHEN ENTRY POINT GETMEM GETS CALLED,    * 00020\n*                         RESET WHEN ENTRY POINT GETVOL GETS CALLLED  * 00020\n*                                                                     * 00008\n*    DSNAME -- A CHARACTER(44) PL/I STRING WHERE WE HAVE TO PUT THE   * 00008\n*       DATASET NAME. (*2,3)                                          * 00008\n*                                                                     * 00010\n*    MEMBER -- A CHARACTER(8) PL/I STRING WHERE WE HAVE TO PUT THE    * 00010\n*       DATASET MEMBER NAME, IF IT EXISTS. (*2,3)                     * 00010\n*                                                                     * 00022\n*    TIOTADDR -- THE ADDRESS OF THE TASK INPUT OUTPUT TABLE. (*2)     * 00022\n*                                                                     * 00012\n*    VOLSER -- A CHARACTER(6) PL/I STRING WHERE WE HAVE TO PUT THE    * 00012\n*       VOLUME SERIAL NUMBER. (*2,3)                                  * 00012\n*                                                                     * 00046\n* NOTES:                                                              * 00046\n*                                                                     * 00046\n*    1. SAMPLE DECLARES AND CALLS:                                    * 00046\n*                                                                     * 00047\n*       DECLARE  GETDSN  ENTRY(CHAR(8)) RETURNS(CHAR(44));            * 00047\n*       DECLARE  DDNAME  CHAR(8) INIT('DD1');                         * 00048\n*       DECLARE  DSNAME  CHAR(8);                                     * 00049\n*                                                                     * 00050\n*       DSNAME = GETDSN(DDNAME);                                      * 00050\n*                                                                     * 00051\n*       DECLARE  GETVOL  ENTRY(CHAR(8)) RETURNS(CHAR(6));             * 00051\n*       DECLARE  VOLUME  CHAR(6);                                     * 00052\n*                                                                     * 00053\n*       VOLUME = GETVOL(DDNAME);                                      * 00053\n*                                                                     * 00054\n*       DECLARE  GETMEM  ENTRY(CHAR(8)) RETURNS(CHAR(8));             * 00054\n*       DECLARE  MEMBER  CHAR(8);                                     * 00055\n*                                                                     * 00056\n*       MEMBER = GETMEM(DDNAME);                                      * 00056\n*       DECLARE  MODE    FIXED BINARY(15);                            * 00057\n*                                                                     * 00058\n*       MODE   = GETMODE();                                           * 00058\n*                                                                     * 00060\n*    2. EACH FUNCTION RETURNS A BLANK STRING IF THE DDNAME IS NOT     * 00060\n*       FOUND.                                                        * 00060\n*                                                                     * 00061\n*    3. ISSUE HISTORY:                                                * 00061\n*                                                                     * 00062\n*       REASON FOR ISSUE 07:                                          * 00062\n*       MAKE REENTRANT, MAKE 31 BIT COMPATIBLE                        * 00063\n*                                                                     * 00064\n*       REASON FOR ISSUE 08:                                          * 00064\n*       ADD ENTRY POINT GETMODE TO GET THE CURRENT ADDRESSING MODE.   * 00065\n*                                                                     * 00066\n*       REASON FOR ISSUE 09:                                          * 00066\n*       THE JFCB MOVES ABOVE THE LINE WITH ESA, USE THE SWAREQ        * 00067\n*       ROUTINE TO TRANSLATE THE 3 BYTE TOKEN IN THE TIOT TO THE 4    * 00067\n*       BYTE ADDRESS. THIS NEW ROUTINE CALLS THE SWAREQ MACRO IN RL   * 00067\n*       MODE.                                                         * 00067\n*                                                                     * 00070\n*       REASON FOR ISSUE 10:  11/14/2003                              * 00070\n*       ADD AMODE AND RMODE CARDS TO GET RID OF LINKER MESSAGES       * 00071\n*                                                                     * 00072\n*********************************************************************** 00072\n         EJECT                                                          00073\n         PRINT OFF                                                      00074\n         GBLC  &XA                                                      00075\n&XA      SETC  'YES'                                                    00076\n         AIF   ('&XA' NE 'YES').NOXA1                                   00077\n*          DATA SET TESTSYS    AT LEVEL 000 AS OF 09/18/86\n         MACRO                                                          00001\n&LABL    TESTSYS  &XAADDR,&S370ADDR                                     00002\n.*                                                                      00003\n.*     THIS MACRO WILL TEST THE SYSTEM ENVIRONMENT TO DETERMINE         00004\n.*     IF THE PROGRAM IS RUNNING UNDER MVS XA OR MVS 370.               00005\n.*     THE TWO POSITIONAL PARAMETERS ARE THE BRANCH ADDRESS IF          00006\n.*     THIS IS AN XA ENVIRONMENT AND THE BRANCH ADDRESS IF THIS         00007\n.*     IS A SYSTEM 370 ENVIRONMENT.  EITHER OR BOTH OF THE PARMS        00008\n.*     MAY BE OMMITTED.                                                 00009\n.*                                                                      00010\n.*     THIS MACRO USES REGISTER 15                                      00011\n.*                                                                      00012\n.*     EXAMPLES:                                                        00013\n.*********************************************************************  00014\n.*               TESTSYS LABELXA,LABEL370                               00015\n.*                 . THIS POINT WILL NEVER BE REACHED                   00016\n.*     LABELXA   DS    0H                                               00017\n.*                 .                                                    00018\n.*               MVS XA SPECIFIC CODE                                   00019\n.*                 .                                                    00020\n.*     LABEL370  DS    0H                                               00021\n.*                 .                                                    00022\n.*               MVS 370 SPECIFIC CODE                                  00023\n.*                 .                                                    00024\n.*********************************************************************  00025\n.*               TESTSYS LABELXA                                        00026\n.*                 .                                                    00027\n.*               MVS 370 SPECIFIC CODE                                  00028\n.*                 .                                                    00029\n.*     LABELXA   DS    0H                                               00030\n.*                 .                                                    00031\n.*               MVS XA SPECIFIC CODE                                   00032\n.*                 .                                                    00033\n.*********************************************************************  00034\n.*               TESTSYS ,LABEL370                                      00035\n.*                 .                                                    00036\n.*               MVS XA SPECIFIC CODE                                   00037\n.*                 .                                                    00038\n.*     LABEL370  DS    0H                                               00039\n.*                 .                                                    00040\n.*               MVS 370 SPECIFIC CODE                                  00041\n.*                 .                                                    00042\n.*********************************************************************  00043\n         L    15,16               POINT TO CVT                          00044\n         TM    CVTDCB-CVT(15),CVTMVSE                                   00045\n         AIF   ('&XAADDR' EQ '').NOXA                                   00046\n         BO    &XAADDR                                                  00047\n.NOXA    ANOP                                                           00048\n         AIF   ('&S370ADDR' EQ '').NO370                                00049\n         BZ    &S370ADDR                                                00050\n.NO370   ANOP                                                           00051\n         MEND                                                           00052\n*          DATA SET SMODE      AT LEVEL 000 AS OF 02/26/93\n         MACRO                                                          00001\n&LABL    SMODE  &MODE,&CLEAR=YES                                        00002\n.*                                                                      00003\n.*       THIS MACRO WILL SWITCH TO 24 OR 31 BIT ADDRESSING MODE IN      00004\n.*       AN MVS XA ENVIRONMENT.  THE CURRENT ADDRESSING MODE IS         00005\n.*       SAVED IN THE HIGH BIT OF REGISTER 14.                          00006\n.*                                                                      00007\n.*       VALID VALUES FOR &MODE MODE ARE:                               00008\n.*       24  -  SWITCH TO 24 BIT ADDRESSING MODE                        00009\n.*       31  -  SWITCH TO 31 BIT ADDRESSING MODE                        00010\n.*       (R0)-(R14) SWITCH TO THE ADDRESSING MODE SPECIFIED IN THE      00011\n.*              HIGH BIT OF THE SPECIFIED REGISTER.  OTHER BITS CLEARED 00012\n.*              BY THIS MACRO.                                          00013\n.*       CLEAR - IF YES (THE DEFAULT) AND A REGISTER VALUE IS SPECIFIED 00014\n.*               FOR MODE, THE LOW ORDER 31 BITS IN THE WORD ARE        00015\n.*               CLEARED PRIOR TO ORING IN THE HIGH BIT.  CLEAR SHOULD  00016\n.*               REMAIN YES UNLESS THE USER IS SURE OTHER BITS IN THE   00017\n.*               REGISTER SPECIFIED BY MODE ARE ZERO                    00018\n.*                                                                      00019\n.*       THIS MACRO USES REGISTERS 14 AND 15                            00020\n.*                                                                      00021\n         AIF   (('&MODE' EQ '24') OR                                   X00022\n               ('&MODE' EQ '31')  OR                                   X00023\n               ('&MODE'(1,1) EQ '(')).PARMOK                            00024\n         MNOTE 8,'INVALID MODE SPECIFIED, 24 AND 31 ARE VALID VALUES'   00025\n         MEXIT                                                          00026\n.PARMOK  ANOP                                                           00027\n         AIF   ('&MODE'(1,1) EQ '(').REGPARM                            00028\n         CNOP  0,4                  MAKE SURE \"A\" CON IS ALIGNED        00029\n         L     15,*+8               LOAD NEW AMODE                      00030\n         SLR   14,14                CLEAR OLD AMODE REGISTER            00031\n         BSM   14,15                BRANCH AROUND CONST AND SET AMODE   00032\n         AIF   ('&MODE' EQ '31').MODE31                                 00033\n         DC    A(X'00000000'+(*+4))                                     00034\n         MEXIT                                                          00035\n.MODE31  ANOP                                                           00036\n         DC    A(X'80000000'+(*+4))                                     00037\n         MEXIT                                                          00038\n.REGPARM ANOP                                                           00039\n         AIF   ('&CLEAR' NE 'YES').NOCLEAR                              00040\n         SRL   &MODE(1),31          SHIFT OUT ALL BUT HIGH BYTE         00041\n         SLL   &MODE(1),31          SHIFT IN ZEROS FOR THE OR INSTR     00042\n.NOCLEAR ANOP                                                           00043\n         LA    15,*+10              ADDR JUST PAST BSM INSTR            00044\n         OR    15,&MODE(1)          SET HIGH ORDER BIT FROM PARM        00045\n         SLR   14,14                CLEAR OLD AMODE REGISTER            00046\n         BSM   14,15                BRANCH AROUND CONST AND SET AMODE   00047\n         MEND                                                           00048\n.NOXA1   ANOP                                                           00080\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00084\nGETDSN1  AMODE ANY                                                      00085\nGETDSN1  RMODE ANY                                                      00086\nGETDSN   RENTR BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA)                  00087\n         SPACE 2                                                        00088\n         L     R11,COMBASE              EXTABLISH                       00089\n         DROP  R11                      COMMON                          00090\n         USING GETDSN,R11               ADDRESSABILITY                  00091\n         SPACE 2                                                        00092\n         MVI   STATUSFL,CGETDSN         INDICATE THAT GETDSN WAS CALLED 00093\n         B     COMCODE                  GO TO THE COMMON CODE           00094\n         EJECT                                                          00095\n         DS    0D                                                       00096\nGETMEM   RENTR *,BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA)                00097\n         SPACE 2                                                        00098\n         L     R11,COMBASE              ESTABLISH                       00099\n         DROP  R11                      COMMON                          00100\n         USING GETDSN,R11               ADDRESSABILITY                  00101\n         SPACE 2                                                        00102\n         MVI   STATUSFL,CGETMEM         INDICATE THAT GETMEM WAS CALLED 00103\n         B     COMCODE                  GO TO THE COMMON CODE           00104\n         EJECT                                                          00105\n         DS    0D                                                       00106\nGETVOL   RENTR *,BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA)                00107\n         SPACE 2                                                        00108\n         L     R11,COMBASE              ESTABLISH                       00109\n         DROP  R11                      COMMON                          00110\n         USING GETDSN,R11               ADDRESSABILITY                  00111\n         SPACE 2                                                        00112\n         MVI   STATUSFL,CGETVOL         INDICATE THAT GETVOL WAS CALLED 00113\n         EJECT                                                          00114\n*********************************************************************** 00115\n*                                                                     * 00115\n* COMMON EXECUTION CODE STARTS HERE. A FLAG HAS BEEN SET IN THE       * 00115\n* PROLOG CODE TO SHOW WHETHER WE WANT THE DATASET NAME, MEMBER NAME,  * 00115\n* OR VOLSER FROM THE JFCB. USE THIS FLAG TO CLEAR THE CORRECT LENGTH  * 00115\n* IN THE TARGET PARM.                                                 * 00115\n*                                                                     * 00120\n*      REGISTER USAGE:                                                * 00120\n*              R4  -> DDNAME                                          * 00121\n*              R5  -> TARGET DSNAME, MEMBER, OR VOLSER                * 00122\n*              R6  -> THE TIOT                                        * 00123\n*              R9  -  CURRENT ADDRESSING MODE IN THE HIGH BIT         * 00124\n*              R11 -  BASE REGISTER                                   * 00125\n*              R12 -  PL/I TCA, DO NOT MODIFY                         * 00126\n*              R13 -> LOWER DSA AND SAVE AREA                         * 00127\n*                                                                     * 00128\n*********************************************************************** 00128\n         SPACE                                                          00129\nCOMCODE  DS    0H                       HERE STARTS THE COMMON CODE     00130\n         LM    R4,R5,0(R10)             LOAD PARAMETER LOCATOR ADDR.    00131\n*                                       R4 -> LOCATOR -> DDNAME         00132\n*                                       R5 -> LOCATOR -> DSN./VOL. SER. 00133\n         L     R4,0(R4)                 LOAD DDNAME ADDRESS             00134\n         L     R5,0(R5)                 LOAD DSN. OR VOL. SER. ADDRESS  00135\n         MVI   0(R5),C' '               FILL OUT A BLANK AS FIRST       00136\n*                                       DSNAME OR VOL. SER. CHARACTER   00137\n         MVC   1(5,R5),0(R5)            PROPAGATE THAT BLANK FOR 5 MORE 00138\n*                                       CHARACTERS, THEREBY BLANKING    00139\n*                                       OUT THE VOLSER                  00140\n         AIF   ('&XA' NE 'YES').NOXA3                                   00141\n         SLR   R9,R9                                                    00142\n         BSM   R9,0                     SAVE CURRENT ADDRESSING MODE    00143\n.NOXA3   ANOP                                                           00144\n         SPACE                                                          00145\n         TM    STATUSFL,CGETDSN         IS THIS A GETDSN CALL?          00146\n         BNO   MEMCK                    NO, THEN CHECK FOR GETMEM       00147\n         MVC   6(38,R5),5(R5)           PROPAGATE THE SIXTH BLANK FOR   00148\n         B     GETTIOT                  38 MORE SPACES                  00149\n         SPACE 2                                                        00150\nMEMCK    DS    0H                                                       00151\n         TM    STATUSFL,CGETMEM         IS THIS A GETMEM CALL ?         00152\n         BNO   GETTIOT                  NO, THEN GOTO GETTIOT           00153\n         MVC   6(2,R5),5(R5)            BLANK TWO MORE SPACES FOR MEM   00154\n         SPACE 2                                                        00155\nGETTIOT  DS    0H                                                       00156\n         L     R6,16                    POINT TO THE CVT                00157\n         L     R6,0(R6)                 POINT TO THE TCB DOUBLEWORD     00158\n         L     R6,0(R6)                 POINT TO OUR TCB                00159\n         USING TCB,R6                   ADDRESS THE TCB                 00160\n         SPACE                                                          00161\n         L     R6,TCBTIO                GET ADDR OF THE TIOT            00162\n         DROP  R6                       DON'T NEED THE TCB ANY MORE     00163\n         USING TIOT1,R6                 ADDRESS THE TIOT                00164\n         EJECT                                                          00165\n*********************************************************************** 00166\n*                                                                     * 00166\n* SCAN THE TIOT ENTRIES LOOKING FOR THE DDNAME WE WANT.               * 00166\n*                                                                     * 00168\n*      REGISTER USAGE:                                                * 00168\n*              R4  -> DDNAME                                          * 00169\n*              R5  -> TARGET DSNAME, MEMBER, OR VOLSER                * 00170\n*              R6  -> THE TIOT ENTRY UNDER CONSIDERATION              * 00171\n*              R7  -  WORK REGISTER USED TO BUMP TIOT POINTER TO NEXT * 00172\n*                     ENTRY                                           * 00172\n*              R9  -  CURRENT ADDRESSING MODE IN THE HIGH BIT         * 00173\n*              R11 -  BASE REGISTER                                   * 00174\n*              R12 -  PL/I TCA, DO NOT MODIFY                         * 00175\n*              R13 -> LOWER DSA AND SAVE AREA                         * 00176\n*                                                                     * 00177\n*********************************************************************** 00177\n         SPACE                                                          00178\nTIOTSCAN DS    0H                                                       00179\n         CLI   TIOELNGH,X'00'           IS THIS THE END OF THE TIOT ?   00180\n         BE    RETURN                   YES, SO WE DIDN'T FIND THE DD   00181\n*                                       ENTRY AND WE RETURN             00182\n         CLC   0(8,R4),TIOEDDNM         IS THIS DD ENTRY THE ONE ?      00183\n         BE    DDFOUND                  YES, SO GO TO DDFOUND           00184\n         SLR   R7,R7                    NO, SO CLEAR R7                 00185\n         IC    R7,TIOELNGH              AND LOAD THE DDENTRY LENGTH     00186\n         AR    R6,R7                    AND POSITION R6 TO POINT TO     00187\n*                                       THE NEXT DD ENTRY               00188\n         B     TIOTSCAN                 AND SCAN THE NEXT TIOT DD ENTRY 00189\n         EJECT                                                          00190\n*********************************************************************** 00191\n*                                                                     * 00191\n* WE HAVE FOUND THE DDNAME WE ARE LOOKING FOR IN THE TIOT. CONVERT    * 00191\n* THE JCFB TOKEN IN THE TIOT TO THE REAL JCFB ADDRESS WHICH IS 4      * 00191\n* BYTES LONG.                                                         * 00191\n*                                                                     * 00195\n*      REGISTER USAGE:                                                * 00195\n*              R4  -> DDNAME                                          * 00196\n*              R5  -> TARGET DSNAME, MEMBER, OR VOLSER                * 00197\n*              R6  -> THE TIOT ENTRY UNDER CONSIDERATION              * 00198\n*              R7  -> JFCB FOR DDNAME                                 * 00199\n*              R9  -  CURRENT ADDRESSING MODE IN THE HIGH BIT         * 00200\n*              R11 -  BASE REGISTER                                   * 00201\n*              R12 -  PL/I TCA, DO NOT MODIFY                         * 00202\n*              R13 -> LOWER DSA AND SAVE AREA                         * 00203\n*                                                                     * 00204\n*********************************************************************** 00204\n         SPACE                                                          00205\nDDFOUND  DS    0H                                                       00206\n         AIF   ('&XA' NE 'YES').NOXA5                                   00207\n         SMODE 31                                                       00208\n         SPACE                                                          00209\n         LA    R1,TIOEJFCB              POINT TO THE JFCB TOKEN         00210\n         L     R15,=V(SWAREQ)           POINT TO THE CONVERT ROUTINE    00211\n         BALR  R14,R15                  CONVERT TOKEN TO ADDRESS        00212\n         SPACE                                                          00213\n         LR    R7,R0                    RETURNED JFCB ADDR IN R0        00214\n         AGO   .XA5                                                     00215\n.NOXA5   ANOP                                                           00216\n         SLR   R7,R7                    CLEAR R7 FOR LOADING JFCB ADDR  00217\n         ICM   R7,X'7',TIOEJFCB         GET THE JFCB ADDRESS            00218\n         LA    R7,16(R7)                                                00219\n.XA5     ANOP                                                           00220\n         DROP  R6                                                       00221\n         USING INFMJFCB,R7              WE USE R7 AS THE JFCB           00222\n*                                       BASE REGISTER                   00223\n         TM    STATUSFL,CGETDSN         WAS GETDSN CALLED ?             00224\n         BNO   MEMNAM                   NO, THEN CHECK THE MEMNAM       00225\n         MVC   0(44,R5),JFCBDSNM        GET THE DATASET NAME            00226\n         B     RETURN                   AND RETURN                      00227\n         SPACE 2                                                        00228\nMEMNAM   DS    0H                                                       00229\n         TM    STATUSFL,CGETMEM         WAS GETMEM CALLED ?             00230\n         BNO   VOLSER                   NO, SO THE VOL. SER. IS NEEDED  00231\n         TM    JFCBIND1,JFCPDS          IS THIS DATASET A PDS?          00232\n         BNO   RETURN                   NO, THEN RETURN                 00233\n         MVC   0(8,R5),JFCBELNM         GET THE MEMBER                  00234\n         B     RETURN                   AND RETURN                      00235\n         SPACE 2                                                        00236\nVOLSER   DS    0H                                                       00237\n         MVC   0(6,R5),JFCBVOLS         GET THE FIRST VOL. SER. NUMBER  00238\n         EJECT                                                          00239\n*********************************************************************** 00240\n*                                                                     * 00240\n* WE ARE DONE, RESTORE THE ADDRESSING MODE AND RETURN TO THE CALLER.  * 00240\n*                                                                     * 00243\n*********************************************************************** 00243\n         SPACE                                                          00244\nRETURN   DS    0H                                                       00245\n         AIF   ('&XA' NE 'YES').NOXA4                                   00246\n         SMODE (R9)                     RESTORE THE ADDRESSING MODE     00247\n.NOXA4   ANOP                                                           00248\n         REXIT                          RETURN                          00249\n         SPACE                                                          00250\nCOMBASE  DC    V(GETDSN)                THE COMMON BASE ADDRESS         00251\n         LTORG                                                          00252\n         TITLE 'GETMODE - GET CURRENT ADDRESSING MODE FOR PL/I'         00253\n*********************************************************************** 00254\n*                                                                     * 00254\n* SEGMENT NAME:                                                       * 00254\n*                                                                     * 00254\n*    GETMODE -- GET CURRENT ADDRESSING MODE FOR PL/I                  * 00254\n*                                                                     * 00262\n* FUNCTIONS:                                                          * 00262\n*                                                                     * 00262\n*    1. INITIALIZE THE TARGET PARM TO ZERO (AMODE=24).                * 00262\n*                                                                     * 00264\n*    2. IF THIS IS NOT AN XA SYSTEM, RETURN ZERO.                     * 00264\n*                                                                     * 00266\n*    3. CURRENT ADDRESSING MODE FROM THE PSW IS ZERO, THEN RETURN     * 00266\n*       ZERO.                                                         * 00266\n*                                                                     * 00268\n*    4. IF THE CURRENT INSTRUCTION ADDRESS IS GREATER THAN 16 MEG,    * 00268\n*       RETURN 2, OTHERWISE, RETURN 1.                                * 00268\n*                                                                     * 00263\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00263\n*                                                                     * 00255\n*    MODE -- ADDRESSING MODE (*1,2,3)                                 * 00255\n*       THE CURRENT ADDRESSING MODE IS RETURNED IN A FIXED BINARY 15  * 00256\n*       VARIABLE                                                      * 00256\n*       VALUES: 0  -  ADDRESSING MODE 24                              * 00258\n*               1  -  ADDRESSING MODE 31                              * 00259\n*               2  -  RESIDENTCY MODE 31                              * 00260\n*                                                                     * 00270\n*********************************************************************** 00270\n         SPACE                                                          00271\nGETMODE1 AMODE 31                                                       00272\nGETMODE1 RMODE ANY                                                      00273\nGETMODE  RENTR BASE=11,PARM=10                                          00274\n         L     R10,0(R10)               POINT TO FIXED BIN 15           00275\n         XC    0(2,R10),0(R10)          INITIALIZE IT TO ZERO.          00276\n         SPACE                                                          00277\n         AIF   ('&XA' NE 'YES').NOXA2                                   00278\n         TESTSYS ,MODERET               RETURN IF NOT XA SYSTEM         00279\n         SPACE                                                          00280\n         SLR   R2,R2                    CLEAR WORK REGISTER             00281\n         BSM   R2,0                     GET CURRENT ADDRESSING MODE     00282\n         LTR   R2,R2                    IS THE MODE ZERO?               00283\n         BZ    MODERET                  IF SO, RETURN ZERO              00284\n         SPACE                                                          00285\n         BASR  R2,0                     SAVE INSTRUCTION ADDRESS        00286\n         LA    R2,0(R2)                 CLEAR HIGH BIT                  00287\n         C     R2,=X'00FFFFFF'          COMPARE TO MAX 24 BIT ADDR      00288\n         BNH   RET1                                                     00289\n         SPACE                                                          00290\n         LA    R2,2                     SHOW RMODE=31                   00291\n         STH   R2,0(R10)                AND PUT IN RETURNED PARM        00292\n         B     MODERET                                                  00293\n         SPACE                                                          00294\nRET1     DS    0H                                                       00295\n         LA    R2,1                     SHOW AMODE=31 RMODE=24          00296\n         STH   R2,0(R10)                AND PUT IN RETURNED PARM        00297\n.NOXA2   ANOP                                                           00298\n         SPACE                                                          00299\nMODERET  DS    0H                                                       00300\n         REXIT                          RETURN                          00301\n         LTORG                                                          00302\n         DROP  R11                                                      00303\n         EJECT                                                          00304\n*********************************************************************** 00305\n*                                                                     * 00305\n* THIS WORKAREA IS USED FOR THE GETDSN, GETVOL, AND GETMEM ROUTINES.  * 00305\n*                                                                     * 00308\n*********************************************************************** 00308\n         SPACE 2                                                        00309\nWORKAREA DSECT                                                          00310\n         DS    30F                      SAVE AREA                       00311\nSTATUSFL DS    XL1                      X'80' INDICATES                 00312\n*                                       ENTRY POINT GETDSN WAS CALLED   00313\n*                                       X'40' INDICATES                 00314\n*                                       ENTRY POINT GETMEM WAS CALLED   00315\n*                                       X'00' INDICATES                 00316\n*                                       ENTRY POINT GETVOL WAS CALLED   00317\nCGETDSN  EQU   X'80'                                                    00318\nCGETMEM  EQU   X'40'                                                    00319\nCGETVOL  EQU   X'00'                                                    00320\n         DS    0D                                                       00321\nWORKLEN  EQU   *-WORKAREA                                               00322\n         SPACE 2                                                        00323\n         PRINT NOGEN                                                    00324\nMYTIOD   DSECT                                                          00325\n         IEFTIOT1                       TASK INPUT OUTPUT TABLE MACRO   00326\n         SPACE 2                                                        00327\n         IEFJFCBN                       JOB FILE CONTROL BLOCK MACRO    00328\n         SPACE 2                                                        00329\n         IKJTCB                         TASK CONTROL BLOCK MACRO        00330\n         SPACE                                                          00331\n         CVT    DSECT=YES                                               00332\n         SPACE                                                          00333\n         SYMBAR MODE=DEC                                                00334\n         END                                                            00335\n*          DATA SET FG50129201 AT LEVEL 015 AS OF 04/01/04\nSTRREA   TITLE 'OMVS_STR_REASON'                                        00001\n         PRINT OFF                                                      00002\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n*          DATA SET CONTROL    AT LEVEL 000 AS OF 06/28/04\n         MACRO ,                                                        00001\n         CONTROL &DSECT=YES,&LIT=YES                                    00002\n.*                                                                      00003\n.*   MACRO/SUBSET CONTROL  IN FG501285                                  00004\n.*                                                                      00005\n.*  THIS DSECT DESCRIBES THE HFS /PAN/<PAN_HFS_NAME>/.CONTROL/.CONTROL  00006\n.*  DATASET.                                                            00007\n.*                                                                      00008\n         SPACE                                                          00009\n          AIF   ('&DSECT' EQ 'NO').NODSECT                              00010\nCONTROL  DSECT                                                          00011\n.NODSECT ANOP                                                           00012\nCNTLREV  DS    F                     REVISION CODE                      00013\nCNTLCC   DS    F                     LIBRARY CONTROL CODE               00014\nCNTLFLG  DS    2F                    ++SUPRESS FLAGS WORD 1             00015\n         DS    0D                    FORCE ALIGNMENT TO DOUBLEWORD LEN  00016\nCONTROLL EQU   *-CNTLREV                                                00017\n         SPACE                                                          00018\n          AIF   ('&LIT' EQ 'NO').NOLIT                                  00019\n* CURRENT REVSION CODE                                                  00020\nCREVCODE EQU   1                                                        00021\n         SPACE                                                          00022\n* CURRENT REVSION CODE ERROR CODE                                       00023\nJRREVERR EQU   29183                                                    00024\n         SPACE                                                          00025\n* SUPRESS FLAG VALUES, WORD 1  (SUPFLG0)                                00026\nSUPADD   EQU   X'00000001'           ++SUPRESS ADD                      00027\nSUPALLOC EQU   X'00000002'           ++SUPRESS ALLOCATE                 00028\nSUPATTCH EQU   X'00000004'           ++SUPRESS ATTACH                   00029\nSUPCOMNT EQU   X'00000008'           ++SUPRESS COMMENT                  00030\nSUPCOPY  EQU   X'00000010'           ++SUPRESS COPY                     00031\nSUPDETCH EQU   X'00000020'           ++SUPRESS DETACH                   00032\nSUPEXEC  EQU   X'00000040'           ++SUPRESS EXEC                     00033\nSUPFORMT EQU   X'00000080'           ++SUPRESS FORMAT                   00034\nSUPINSRT EQU   X'00000100'           ++SUPRESS INSERT                   00035\nSUPLEVEL EQU   X'00000200'           ++SUPRESS LEVEL                    00036\nSUPOPTN  EQU   X'00000400'           ++SUPRESS OPTION                   00037\nSUPREN   EQU   X'00000800'           ++SUPRESS RENAME                   00038\nSUPRESEQ EQU   X'00001000'           ++SUPRESS RESEQ                    00039\nSUPSELCT EQU   X'00002000'           ++SUPRESS SELECT                   00040\nSUPSTATU EQU   X'00004000'           ++SUPRESS STATUS                   00041\nSUPUPDTE EQU   X'00008000'           ++SUPRESS UPDATE                   00042\nSUPUSER  EQU   X'00010000'           ++SUPRESS USER                     00043\nSUPUSING EQU   X'00020000'           ++SUPRESS USING                    00044\nSUPWRITE EQU   X'00040000'           ++SUPRESS WRITE                    00045\n         SPACE                                                          00046\n* SUPRESS FLAG VALUES, WORD 2  (SUPFLG1)                                00047\nSUPACTIV EQU   X'00000001'           ++SUPRESS ACTIVE                   00048\nSUPALL   EQU   X'00000002'           ++SUPRESS ALL                      00049\nSUPDISAB EQU   X'00000004'           ++SUPRESS DISABLE                  00050\nSUPENABL EQU   X'00000008'           ++SUPRESS ENABLE                   00051\nSUPINACT EQU   X'00000010'           ++SUPRESS INACTIVE                 00052\nSUPPREFX EQU   X'00000020'           ++SUPRESS PREFIX                   00053\nSUPPRINT EQU   X'00000040'           ++SUPRESS PRINT                    00054\nSUPPROD  EQU   X'00000080'           ++SUPRESS PROD                     00055\nSUPPUNCH EQU   X'00000100'           ++SUPRESS PUNCH                    00056\nSUPTEMP  EQU   X'00000200'           ++SUPRESS TEMP                     00057\nSUPWORK  EQU   X'00000400'           ++SUPRESS WORK                     00058\nSUPSTAR  EQU   X'00000800'           ++SUPRESS *                        00059\n.NOLIT   ANOP                                                           00060\n         MEND  , LIBDATA                                   RES 10/2003  00061\n         PRINT ON                                                       00007\n*********************************************************************** 00022\n*                                                                     * 00022\n* SEGMENT NAME:                                                       * 00022\n*                                                                     * 00022\n*    STRREA -- OMVS_STR_REASON                                        * 00022\n*                                                                     * 00023\n*       THIS MODULE RETURNS THE ERROR MESSSAGE CORRESPONDING TO A     * 00023\n*       PASSED ERRNOJR UNDER OPEN MVS.                                * 00023\n*                                                                     * 00041\n* INPUTS (*TO FUNCTIONS):                                             * 00041\n*                                                                     * 00026\n*    ERRNOJR -- FULLWORD INT (*1,3,4)                                 * 00026\n*       THIS IS THE ADDRESS OF A FULLWORD CONTAINING  THE REASON CODE * 00027\n*       TO BE INTERPRETED.                                            * 00027\n*                                                                     * 00040\n* FUNCTIONS:                                                          * 00040\n*                                                                     * 00040\n*    1. LOAD THE PARM LIST INTO REGISTERS                             * 00040\n*                                                                     * 00045\n*    2. ZERO THE LENGTH IN CASE OF ERROR.                             * 00045\n*                                                                     * 00048\n*    3. DETERMINE WHICH TABLE TO USE.  ERRORS > 29000 ARE IN A        * 00048\n*       SEPARATE TABLE.                                               * 00048\n*                                                                     * 00052\n*    4. CONVERT THE ERRO TO AN OFFSET IN THE TABLE AND SEE IF IT IS   * 00052\n*       IN IN RANGE.                                                  * 00052\n*                                                                     * 00057\n*    5. LOAD THE ADDRESS OF THE MESSAGE AND SEE IF IT IS ZERO THIS    * 00057\n*       MEANS UNKNOWN ERRNOJR, NO MESSAGE,.                           * 00057\n*                                                                     * 00060\n*    6. FIND THE END OF THE MESSAGE AND CALCULATE THE LENGTH.         * 00060\n*                                                                     * 00062\n*    7. PLACE THE LENGTH AND THE MESSAGE ADDRESS IN THE RETURNED      * 00062\n*       PARMS.                                                        * 00062\n*                                                                     * 00042\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00042\n*                                                                     * 00030\n*    LEN -- PONTER TO FULLWORD INT (*1,2,4,7)                         * 00030\n*       THIS IS THE ADDRESS OF A FULLWORD TO CONTAIN THE LENGTH OF    * 00031\n*       THE RETURNED MESSAGE.  IF NO MESSAGE IS RETURNED, THE LENGTH  * 00031\n*       IS SET TO ZERO.                                               * 00031\n*                                                                     * 00035\n*    MSG -- POINTER TO FULLWORD ADDR E   THIS IS THE ADDRESS OF A     * 00035\n*       FULLWORD TO CONTAIN THE MESSAGE ADDRESS. THE MESSAGE ADDRESS  * 00035\n*       IS A STATIC STRING WHICH IS TERMINATED BY A BYTE OF ZEROS.    * 00035\n*       (*1,7)                                                        * 00035\n*                                                                     * 00067\n* NOTES:                                                              * 00067\n*                                                                     * 00067\n*    1. SAMPLE CALL:                                                  * 00067\n*                 CALL  STRREA,(ERRNOJR,LEN,MSGADDR)                  * 00068\n*       ERRNO    DC  F'123'                                           * 00069\n*       LEN      DC  F'0'                                             * 00070\n*       MSGADDR  DC  A(0)                                             * 00071\n*                                                                     * 00072\n*********************************************************************** 00072\n         EJECT                                                          00073\nSTRREA   RENTR  BASE=11,PARM=(10,PARMS),WORK=(WORKLEN,WORKAREA),       X00074\n               ENV=OS,MAIN=YES                                          00075\nSTRREA   AMODE 31                                                       00076\nSTRREA   RMODE ANY                                                      00077\n         EJECT                                                          00078\n         LM    R4,R6,0(R10)        LOAD PARM LIST INTO REGS             00079\n         L     R4,0(R4)            R4 CONTAINS THE ERRNOJR (REASON)     00080\n*                                  R5 POINTS TO LEN FULLWORD            00081\n*                                  R6 POINTS TO MSG ADDR                00082\n         N     R4,=X'0000FFFF'     ONLY THE LOW HALFWORD COUNTS         00083\n         XC    0(4,R5),0(R5)       ZERO THE LEN                         00084\n         L     R15,=A(PLINULL)                                          00085\n         ST    R15,0(,R6)                                               00086\n         SPACE                                                          00087\n         L     R7,=A(ETAB)                                              00088\n         L     R8,=A(LASTMSG)                                           00089\n         C     R4,=F'29000'                                             00090\n         BL    KEEP1                                                    00091\n         SPACE                                                          00092\n         L     R7,=A(ETAB2)                                             00093\n         L     R8,=A(LASTMSG2)                                          00094\n         S     R4,=F'29000'                                             00095\n         SPACE                                                          00096\nKEEP1    DS    0H                                                       00097\n         SLA   R4,2                MULTIPLY ERRNO BY 4                  00098\n         LA    R14,0(R4,R7)        POINT TO THE ERROR ADDR              00099\n         CR    R14,R8              ARE WE PAST THE TABLE?               00100\n         BH    RETURN              YES, NO MESSAGE                      00101\n         SPACE                                                          00102\n         L     R15,0(R14)          LOAD THE MESSAGE ADDR                00103\n         LTR   R15,R15             IS IT ZERO?                          00104\n         BZ    RETURN              IF SO, NO MESSAGE                    00105\n         SPACE                                                          00106\n*        NOTE THAT ALL MESSAGES ARE LESS THAN 255 CHARACTERS            00107\n         TRT   0(256,R15),FINDNUL  FIND END OF MESSAGE                  00108\n         SR    R1,R15              CALCULATE THE LENGTH                 00109\n         ST    R1,0(,R5)           SAVE THE LENGTH                      00110\n         ST    R15,0(,R6)          SAVE THE MESSAGE ADDR                00111\n         EJECT                                                          00112\nRETURN   DS    0H                                                       00113\n         REXIT ENV=BOTH                                                 00114\n         EJECT                                                          00115\n*                    0 1 2 3 4 5 6 7 8 9 A B C D E F                    00116\nFINDNUL  DC    XL16'FF000000000000000000000000000000'  00               00117\n         DC    XL16'00000000000000000000000000000000'  10               00118\n         DC    XL16'00000000000000000000000000000000'  20               00119\n         DC    XL16'00000000000000000000000000000000'  30               00120\n         DC    XL16'00000000000000000000000000000000'  40               00121\n         DC    XL16'00000000000000000000000000000000'  50               00122\n         DC    XL16'00000000000000000000000000000000'  60               00123\n         DC    XL16'00000000000000000000000000000000'  70               00124\n         DC    XL16'00000000000000000000000000000000'  80               00125\n         DC    XL16'00000000000000000000000000000000'  90               00126\n         DC    XL16'00000000000000000000000000000000'  A0               00127\n         DC    XL16'00000000000000000000000000000000'  B0               00128\n         DC    XL16'00000000000000000000000000000000'  C0               00129\n         DC    XL16'00000000000000000000000000000000'  D0               00130\n         DC    XL16'00000000000000000000000000000000'  E0               00131\n         DC    XL16'00000000000000000000000000000000'  F0               00132\n         EJECT                                                          00133\n*****************************************************************       00134\n*                                                               *       00135\n* REASON CODE TABLES  ETAB 0 - 1480   ETAB2  29000 29700        *       00136\n*                                                               *       00137\n*****************************************************************       00138\n         LTORG                                                          00139\nPLINULL  EQU   X'FF000000'                                              00140\n         SPACE                                                          00141\nETAB     DC    1480A(0)                                                 00142\nLASTMSG  EQU   *                                                        00143\nETAB2    DC    700A(0)                                                  00144\nLASTMSG2 EQU   *                                                        00145\n         EJECT                                                          00146\n*****************************************************************       00147\n*                                                               *       00148\n* R E A S O N   C O D E S  =  E R R N O  J R.                   *       00149\n*                                                               *       00150\n*                                                               *       00151\n*****************************************************************       00152\n*         ORG   ETAB+(4*JROK)                                           00153\n*         DC    A(MJROK)                                                00154\n*         ORG                                                           00155\n*MJROK DC C'The return code value describes the error'                  00156\n*         DC    X'00'                                                   00157\n         ORG   ETAB+(4*JRNOTKEY8)                                       00158\n         DC    A(MJRNOTKEY8)                                            00159\n         ORG                                                            00160\nMJRNOTKEY8 DC C'The task is not in PSW key 8'                           00161\n         DC    X'00'                                                    00162\n         ORG   ETAB+(4*JRMAXCHILD)                                      00163\n         DC    A(MJRMAXCHILD)                                           00164\n         ORG                                                            00165\nMJRMAXCHILD DC C'The maximum number of processes for this user ID has ' 00166\n         DC    C'been exceeded'                                         00167\n         DC    X'00'                                                    00168\n         ORG   ETAB+(4*JRMAXUIDS)                                       00169\n         DC    A(MJRMAXUIDS)                                            00170\n         ORG                                                            00171\nMJRMAXUIDS DC C'The maximum number of OpenMVS user IDs is exceeded'     00172\n         DC    X'00'                                                    00173\n         ORG   ETAB+(4*JRAPPCERRALLOC)                                  00174\n         DC    A(MJRAPPCERRALLOC)                                       00175\n         ORG                                                            00176\nMJRAPPCERRALLOC DC C'An APPC/MVS Allocate Conversation error occurred'  00177\n         DC    X'00'                                                    00178\n         ORG   ETAB+(4*JRAPPCERRSEND)                                   00179\n         DC    A(MJRAPPCERRSEND)                                        00180\n         ORG                                                            00181\nMJRAPPCERRSEND DC C'An APPC/MVS Send_Data error occurred'               00182\n         DC    X'00'                                                    00183\n         ORG   ETAB+(4*JRAPPCERRRECV)                                   00184\n         DC    A(MJRAPPCERRRECV)                                        00185\n         ORG                                                            00186\nMJRAPPCERRRECV DC C'An APPC/MVS Receive_and_Wait error occurred'        00187\n         DC    X'00'                                                    00188\n         ORG   ETAB+(4*JRAPPCERRACCEPT)                                 00189\n         DC    A(MJRAPPCERRACCEPT)                                      00190\n         ORG                                                            00191\nMJRAPPCERRACCEPT DC C'An APPC/MVS Accept_Conversation error occurred'   00192\n         DC    X'00'                                                    00193\n         ORG   ETAB+(4*JRFORKEXITRCPARENTNOROOM)                        00194\n         DC    A(MJRFORKEXITRCPARENTNOROOM)                             00195\n         ORG                                                            00196\nMJRFORKEXITRCPARENTNOROOM DC C'Not enough work space exists for a pare' 00197\n         DC    C'nt fork exit'                                          00198\n         DC    X'00'                                                    00199\n         ORG   ETAB+(4*JRFORKEXITRCPARENTBADENV)                        00200\n         DC    A(MJRFORKEXITRCPARENTBADENV)                             00201\n         ORG                                                            00202\nMJRFORKEXITRCPARENTBADENV DC C'Forking is not supported under the curr' 00203\n         DC    C'ent parent environment'                                00204\n         DC    X'00'                                                    00205\n         ORG   ETAB+(4*JRFORKVSMLISTTOOLARGE)                           00206\n         DC    A(MJRFORKVSMLISTTOOLARGE)                                00207\n         ORG                                                            00208\nMJRFORKVSMLISTTOOLARGE DC C'The storage is insufficient to hold VSMLIS' 00209\n         DC    C'T output'                                              00210\n         DC    X'00'                                                    00211\n         ORG   ETAB+(4*JRKERNELREADY)                                   00212\n         DC    A(MJRKERNELREADY)                                        00213\n         ORG                                                            00214\nMJRKERNELREADY DC C'The system is not in a ready state'                 00215\n         DC    X'00'                                                    00216\n         ORG   ETAB+(4*JRMAXPROC)                                       00217\n         DC    A(MJRMAXPROC)                                            00218\n         ORG                                                            00219\nMJRMAXPROC DC C'The maximum number of processes was exceeded'           00220\n         DC    X'00'                                                    00221\n         ORG   ETAB+(4*JRNOSECURITYPRODUCT)                             00222\n         DC    A(MJRNOSECURITYPRODUCT)                                  00223\n         ORG                                                            00224\nMJRNOSECURITYPRODUCT DC C'A security product is not installed'          00225\n         DC    X'00'                                                    00226\n         ORG   ETAB+(4*JRFILESYSNOTTHERE)                               00227\n         DC    A(MJRFILESYSNOTTHERE)                                    00228\n         ORG                                                            00229\nMJRFILESYSNOTTHERE DC C'The file system named does not exist'           00230\n         DC    X'00'                                                    00231\n         ORG   ETAB+(4*JRFILESYSWASRESET)                               00232\n         DC    A(MJRFILESYSWASRESET)                                    00233\n         ORG                                                            00234\nMJRFILESYSWASRESET DC C'The file system named was reset by another use' 00235\n         DC    C'r'                                                     00236\n         DC    X'00'                                                    00237\n         ORG   ETAB+(4*JRNEGATIVEVALUEINVALID)                          00238\n         DC    A(MJRNEGATIVEVALUEINVALID)                               00239\n         ORG                                                            00240\nMJRNEGATIVEVALUEINVALID DC C'A negative value cannot be supplied for o' 00241\n         DC    C'ne of the parameters'                                  00242\n         DC    X'00'                                                    00243\n         ORG   ETAB+(4*JRUNLMOUNTRO)                                    00244\n         DC    A(MJRUNLMOUNTRO)                                         00245\n         ORG                                                            00246\nMJRUNLMOUNTRO DC C'The unlink call was on a read-only file system'      00247\n         DC    X'00'                                                    00248\n         ORG   ETAB+(4*JRRFILEWRONLY)                                   00249\n         DC    A(MJRRFILEWRONLY)                                        00250\n         ORG                                                            00251\nMJRRFILEWRONLY DC C'A call tried to read a file opened as write-only'   00252\n         DC    X'00'                                                    00253\n         ORG   ETAB+(4*JRWFILERDONLY)                                   00254\n         DC    A(MJRWFILERDONLY)                                        00255\n         ORG                                                            00256\nMJRWFILERDONLY DC C'A call tried to write to a file opened as read-onl' 00257\n         DC    C'y'                                                     00258\n         DC    X'00'                                                    00259\n         ORG   ETAB+(4*JRNEGFILEDES)                                    00260\n         DC    A(MJRNEGFILEDES)                                         00261\n         ORG                                                            00262\nMJRNEGFILEDES DC C'A negative file descriptor was requested'            00263\n         DC    X'00'                                                    00264\n         ORG   ETAB+(4*JRFILEDESNOTINUSE)                               00265\n         DC    A(MJRFILEDESNOTINUSE)                                    00266\n         ORG                                                            00267\nMJRFILEDESNOTINUSE DC C'The requested file descriptor is not in use'    00268\n         DC    X'00'                                                    00269\n         ORG   ETAB+(4*JRMKDIREXIST)                                    00270\n         DC    A(MJRMKDIREXIST)                                         00271\n         ORG                                                            00272\nMJRMKDIREXIST DC C'The requested file directory already exists'         00273\n         DC    X'00'                                                    00274\n         ORG   ETAB+(4*JRPATHTOOLONG)                                   00275\n         DC    A(MJRPATHTOOLONG)                                        00276\n         ORG                                                            00277\nMJRPATHTOOLONG DC C'The pathname is too long'                           00278\n         DC    X'00'                                                    00279\n         ORG   ETAB+(4*JRNULLINPATH)                                    00280\n         DC    A(MJRNULLINPATH)                                         00281\n         ORG                                                            00282\nMJRNULLINPATH DC C'The pathname or file name contains a null'           00283\n         DC    X'00'                                                    00284\n         ORG   ETAB+(4*JRCOMPNOTDIR)                                    00285\n         DC    A(MJRCOMPNOTDIR)                                         00286\n         ORG                                                            00287\nMJRCOMPNOTDIR DC C'A node in the pathname is not a directory'           00288\n         DC    X'00'                                                    00289\n         ORG   ETAB+(4*JRDIRNOTFOUND)                                   00290\n         DC    A(MJRDIRNOTFOUND)                                        00291\n         ORG                                                            00292\nMJRDIRNOTFOUND DC C'A directory in the pathname was not found'          00293\n         DC    X'00'                                                    00294\n         ORG   ETAB+(4*JRCOMPNAMETOOLONG)                               00295\n         DC    A(MJRCOMPNAMETOOLONG)                                    00296\n         ORG                                                            00297\nMJRCOMPNAMETOOLONG DC C'A component in the pathname was too long'       00298\n         DC    X'00'                                                    00299\n         ORG   ETAB+(4*JRINVOPENFLAGS)                                  00300\n         DC    A(MJRINVOPENFLAGS)                                       00301\n         ORG                                                            00302\nMJRINVOPENFLAGS DC C'The open call detected incorrect open flags'       00303\n         DC    X'00'                                                    00304\n         ORG   ETAB+(4*JRTRNOTREGFILE)                                  00305\n         DC    A(MJRTRNOTREGFILE)                                       00306\n         ORG                                                            00307\nMJRTRNOTREGFILE DC C'Truncate is valid only on a regular file'          00308\n         DC    X'00'                                                    00309\n         ORG   ETAB+(4*JRCLNEEDCLOSE)                                   00310\n         DC    A(MJRCLNEEDCLOSE)                                        00311\n         ORG                                                            00312\nMJRCLNEEDCLOSE DC C'The closedir call was for a file that was opened w' 00313\n         DC    C'ith the open call'                                     00314\n         DC    X'00'                                                    00315\n         ORG   ETAB+(4*JRPFSDEAD)                                       00316\n         DC    A(MJRPFSDEAD)                                            00317\n         ORG                                                            00318\nMJRPFSDEAD DC C'The file system owning the file is no longer active'    00319\n         DC    X'00'                                                    00320\n         ORG   ETAB+(4*JRMKDIR)                                         00321\n         DC    A(MJRMKDIR)                                              00322\n         ORG                                                            00323\nMJRMKDIR DC C'The mkdir service is not supported by this file system'   00324\n         DC    X'00'                                                    00325\n         ORG   ETAB+(4*JRCLOSE)                                         00326\n         DC    A(MJRCLOSE)                                              00327\n         ORG                                                            00328\nMJRCLOSE DC C'The vnode operation CLOSE is not supported by this file ' 00329\n         DC    C'system'                                                00330\n         DC    X'00'                                                    00331\n         ORG   ETAB+(4*JRRDWR)                                          00332\n         DC    A(MJRRDWR)                                               00333\n         ORG                                                            00334\nMJRRDWR DC C'Vnode operation RDWR is not supported by this file system' 00335\n         DC    X'00'                                                    00336\n         ORG   ETAB+(4*JRLOOKUP)                                        00337\n         DC    A(MJRLOOKUP)                                             00338\n         ORG                                                            00339\nMJRLOOKUP DC C'Lookup is not supported by this file system'             00340\n         DC    X'00'                                                    00341\n         ORG   ETAB+(4*JRAPPCCHECKSTATE)                                00342\n         DC    A(MJRAPPCCHECKSTATE)                                     00343\n         ORG                                                            00344\nMJRAPPCCHECKSTATE DC C'An APPC/MVS receive error occurred while the AP' 00345\n         DC    C'PC/MVS status was being checked'                       00346\n         DC    X'00'                                                    00347\n         ORG   ETAB+(4*JROPEN)                                          00348\n         DC    A(MJROPEN)                                               00349\n         ORG                                                            00350\nMJROPEN DC C'The open service is not supported by this file system'     00351\n         DC    X'00'                                                    00352\n         ORG   ETAB+(4*JRCREATE)                                        00353\n         DC    A(MJRCREATE)                                             00354\n         ORG                                                            00355\nMJRCREATE DC C'The create service is not supported by this file system' 00356\n         DC    X'00'                                                    00357\n         ORG   ETAB+(4*JRNOPATH)                                        00358\n         DC    A(MJRNOPATH)                                             00359\n         ORG                                                            00360\nMJRNOPATH DC C'The path length is not greater than 0'                   00361\n         DC    X'00'                                                    00362\n         ORG   ETAB+(4*JRNOTACTIVE)                                     00363\n         DC    A(MJRNOTACTIVE)                                          00364\n         ORG                                                            00365\nMJRNOTACTIVE DC C'The OpenMVS kernel is not active'                     00366\n         DC    X'00'                                                    00367\n         ORG   ETAB+(4*JRCHDNOTDIR)                                     00368\n         DC    A(MJRCHDNOTDIR)                                          00369\n         ORG                                                            00370\nMJRCHDNOTDIR DC C'The chdir, fchdir, or chroot service is valid only f' 00371\n         DC    C'or directory files'                                    00372\n         DC    X'00'                                                    00373\n         ORG   ETAB+(4*JRCHDNOENT)                                      00374\n         DC    A(MJRCHDNOENT)                                           00375\n         ORG                                                            00376\nMJRCHDNOENT DC C'The chdir or chroot service was invoked with the name' 00377\n         DC    C' of a nonexisting file'                                00378\n         DC    X'00'                                                    00379\n         ORG   ETAB+(4*JRINVALIDNAME)                                   00380\n         DC    A(MJRINVALIDNAME)                                        00381\n         ORG                                                            00382\nMJRINVALIDNAME DC C'File system name characters must be greater than 4' 00383\n         DC    C'0 (hex) and less than FF (hex)'                        00384\n         DC    X'00'                                                    00385\n         ORG   ETAB+(4*JRMKDIRRONLY)                                    00386\n         DC    A(MJRMKDIRRONLY)                                         00387\n         ORG                                                            00388\nMJRMKDIRRONLY DC C'The directory cannot be created in a read-only file' 00389\n         DC    C' system'                                               00390\n         DC    X'00'                                                    00391\n         ORG   ETAB+(4*JRLNKDIR)                                        00392\n         DC    A(MJRLNKDIR)                                             00393\n         ORG                                                            00394\nMJRLNKDIR DC C'Hard links cannot be made to directory files'            00395\n         DC    X'00'                                                    00396\n         ORG   ETAB+(4*JRLSKONPIPE)                                     00397\n         DC    A(MJRLSKONPIPE)                                          00398\n         ORG                                                            00399\nMJRLSKONPIPE DC C'The lseek service cannot be performed on a pipe or s' 00400\n         DC    C'ocket'                                                 00401\n         DC    X'00'                                                    00402\n         ORG   ETAB+(4*JRLSKOFFSETISINVALID)                            00403\n         DC    A(MJRLSKOFFSETISINVALID)                                 00404\n         ORG                                                            00405\nMJRLSKOFFSETISINVALID DC C'The offset given for lseek service is incor' 00406\n         DC    C'rect'                                                  00407\n         DC    X'00'                                                    00408\n         ORG   ETAB+(4*JRLSKWHENCEISINVALID)                            00409\n         DC    A(MJRLSKWHENCEISINVALID)                                 00410\n         ORG                                                            00411\nMJRLSKWHENCEISINVALID DC C'The whence given for the lseek service is i' 00412\n         DC    C'ncorrect'                                              00413\n         DC    X'00'                                                    00414\n         ORG   ETAB+(4*JRFSNOTSTART)                                    00415\n         DC    A(MJRFSNOTSTART)                                         00416\n         ORG                                                            00417\nMJRFSNOTSTART DC C'The file system specified was not started'           00418\n         DC    X'00'                                                    00419\n         ORG   ETAB+(4*JRISMOUNTED)                                     00420\n         DC    A(MJRISMOUNTED)                                          00421\n         ORG                                                            00422\nMJRISMOUNTED DC C'The file system is already mounted'                   00423\n         DC    X'00'                                                    00424\n         ORG   ETAB+(4*JRMOUNTPT)                                       00425\n         DC    A(MJRMOUNTPT)                                            00426\n         ORG                                                            00427\nMJRMOUNTPT DC C'A problem was found with the mount point specified'     00428\n         DC    X'00'                                                    00429\n         ORG   ETAB+(4*JRUNLNOENT)                                      00430\n         DC    A(MJRUNLNOENT)                                           00431\n         ORG                                                            00432\nMJRUNLNOENT DC C'The file to be unlinked does not exist'                00433\n         DC    X'00'                                                    00434\n         ORG   ETAB+(4*JRUNLDIR)                                        00435\n         DC    A(MJRUNLDIR)                                             00436\n         ORG                                                            00437\nMJRUNLDIR DC C'The unlink service was requested on a directory file'    00438\n         DC    X'00'                                                    00439\n         ORG   ETAB+(4*JRREADONLYFILESETWRITEREQ)                       00440\n         DC    A(MJRREADONLYFILESETWRITEREQ)                            00441\n         ORG                                                            00442\nMJRREADONLYFILESETWRITEREQ DC C'An open request for write was entered ' 00443\n         DC    C'for a file system that was mounted read-only'          00444\n         DC    X'00'                                                    00445\n         ORG   ETAB+(4*JRREADONLYFILESETCREATREQ)                       00446\n         DC    A(MJRREADONLYFILESETCREATREQ)                            00447\n         ORG                                                            00448\nMJRREADONLYFILESETCREATREQ DC C'A file cannot be created in a read-onl' 00449\n         DC    C'y file system'                                         00450\n         DC    X'00'                                                    00451\n         ORG   ETAB+(4*JRNOFILENOCREATFLAG)                             00452\n         DC    A(MJRNOFILENOCREATFLAG)                                  00453\n         ORG                                                            00454\nMJRNOFILENOCREATFLAG DC C'A service tried to open a nonexistent file w' 00455\n         DC    C'ithout O_CREAT'                                        00456\n         DC    X'00'                                                    00457\n         ORG   ETAB+(4*JRFILEEXISTSEXCLFLAGSET)                         00458\n         DC    A(MJRFILEEXISTSEXCLFLAGSET)                              00459\n         ORG                                                            00460\nMJRFILEEXISTSEXCLFLAGSET DC C'The file exists, but O_EXCL is specified' 00461\n         DC    C' on the open call'                                     00462\n         DC    X'00'                                                    00463\n         ORG   ETAB+(4*JRDIRWRITEREQUEST)                               00464\n         DC    A(MJRDIRWRITEREQUEST)                                    00465\n         ORG                                                            00466\nMJRDIRWRITEREQUEST DC C'The service tried to open a directory for writ' 00467\n         DC    C'e access'                                              00468\n         DC    X'00'                                                    00469\n         ORG   ETAB+(4*JROPENFLAGCONFLICT)                              00470\n         DC    A(MJROPENFLAGCONFLICT)                                   00471\n         ORG                                                            00472\nMJROPENFLAGCONFLICT DC C'The call tried to open a file with O_RDONLY a' 00473\n         DC    C'nd O_TRUNC specified'                                  00474\n         DC    X'00'                                                    00475\n         ORG   ETAB+(4*JRPARMTOOLONG)                                   00476\n         DC    A(MJRPARMTOOLONG)                                        00477\n         ORG                                                            00478\nMJRPARMTOOLONG DC C'On the mount, a parameter field longer than 1024 w' 00479\n         DC    C'as specified'                                          00480\n         DC    X'00'                                                    00481\n         ORG   ETAB+(4*JRREMOVE)                                        00482\n         DC    A(MJRREMOVE)                                             00483\n         ORG                                                            00484\nMJRREMOVE DC C'Vn_Remove is not supported by the physical file system'  00485\n         DC    X'00'                                                    00486\n         ORG   ETAB+(4*JRBOTHMODE)                                      00487\n         DC    A(MJRBOTHMODE)                                           00488\n         ORG                                                            00489\nMJRBOTHMODE DC C'On the mount service, both read and read/write were s' 00490\n         DC    C'pecified'                                              00491\n         DC    X'00'                                                    00492\n         ORG   ETAB+(4*JRNEITHERMODE)                                   00493\n         DC    A(MJRNEITHERMODE)                                        00494\n         ORG                                                            00495\nMJRNEITHERMODE DC C'On the mount service, neither read nor read/write ' 00496\n         DC    C'were specified'                                        00497\n         DC    X'00'                                                    00498\n         ORG   ETAB+(4*JRBUFFTOOSMALL)                                  00499\n         DC    A(MJRBUFFTOOSMALL)                                       00500\n         ORG                                                            00501\nMJRBUFFTOOSMALL DC C'The buffer for return information is too small'    00502\n         DC    X'00'                                                    00503\n         ORG   ETAB+(4*JRFILENOTTHERE)                                  00504\n         DC    A(MJRFILENOTTHERE)                                       00505\n         ORG                                                            00506\nMJRFILENOTTHERE DC C'The requested file does not exist'                 00507\n         DC    X'00'                                                    00508\n         ORG   ETAB+(4*JRREADDIR)                                       00509\n         DC    A(MJRREADDIR)                                            00510\n         ORG                                                            00511\nMJRREADDIR DC C'The readdir service vnode operation is not supported'   00512\n         DC    X'00'                                                    00513\n         ORG   ETAB+(4*JRGETATTR)                                       00514\n         DC    A(MJRGETATTR)                                            00515\n         ORG                                                            00516\nMJRGETATTR DC C'GetAttr is not supported by this file system'           00517\n         DC    X'00'                                                    00518\n         ORG   ETAB+(4*JRRDDFILENOTDIR)                                 00519\n         DC    A(MJRRDDFILENOTDIR)                                      00520\n         ORG                                                            00521\nMJRRDDFILENOTDIR DC C'The readdir service request was on a file that w' 00522\n         DC    C'as not opened as a directory'                          00523\n         DC    X'00'                                                    00524\n         ORG   ETAB+(4*JRTARGETNOTDIR)                                  00525\n         DC    A(MJRTARGETNOTDIR)                                       00526\n         ORG                                                            00527\nMJRTARGETNOTDIR DC C'The opendir service did not specify a directory'   00528\n         DC    X'00'                                                    00529\n         ORG   ETAB+(4*JROPENDIRNOTFOUND)                               00530\n         DC    A(MJROPENDIRNOTFOUND)                                    00531\n         ORG                                                            00532\nMJROPENDIRNOTFOUND DC C'The directory specified on the opendir service' 00533\n         DC    C' did not exist'                                        00534\n         DC    X'00'                                                    00535\n         ORG   ETAB+(4*JRNOTPRB)                                        00536\n         DC    A(MJRNOTPRB)                                             00537\n         ORG                                                            00538\nMJRNOTPRB DC C'The current request block is not a program request bloc' 00539\n         DC    C'k'                                                     00540\n         DC    X'00'                                                    00541\n         ORG   ETAB+(4*JRSPFILEEXISTS)                                  00542\n         DC    A(MJRSPFILEEXISTS)                                       00543\n         ORG                                                            00544\nMJRSPFILEEXISTS DC C'The file specified on the mknod service already e' 00545\n         DC    C'xisted'                                                00546\n         DC    X'00'                                                    00547\n         ORG   ETAB+(4*JRREADONLYFILESETMKNODREQ)                       00548\n         DC    A(MJRREADONLYFILESETMKNODREQ)                            00549\n         ORG                                                            00550\nMJRREADONLYFILESETMKNODREQ DC C'A special file cannot be created on a ' 00551\n         DC    C'read-only file system'                                 00552\n         DC    X'00'                                                    00553\n         ORG   ETAB+(4*JRRMDIR)                                         00554\n         DC    A(MJRRMDIR)                                              00555\n         ORG                                                            00556\nMJRRMDIR DC C'The rmdir service vnode operation is not supported'       00557\n         DC    X'00'                                                    00558\n         ORG   ETAB+(4*JRPATHNOTDIR)                                    00559\n         DC    A(MJRPATHNOTDIR)                                         00560\n         ORG                                                            00561\nMJRPATHNOTDIR DC C'The pathname does not specify a directory'           00562\n         DC    X'00'                                                    00563\n         ORG   ETAB+(4*JRREADONLYFS)                                    00564\n         DC    A(MJRREADONLYFS)                                         00565\n         ORG                                                            00566\nMJRREADONLYFS DC C'This operation does not work on a read-only file sy' 00567\n         DC    C'stem'                                                  00568\n         DC    X'00'                                                    00569\n         ORG   ETAB+(4*JRDIFFFILESETS)                                  00570\n         DC    A(MJRDIFFFILESETS)                                       00571\n         ORG                                                            00572\nMJRDIFFFILESETS DC C'The rename service is not supported across file s' 00573\n         DC    C'ystems'                                                00574\n         DC    X'00'                                                    00575\n         ORG   ETAB+(4*JRNEWNOTDIR)                                     00576\n         DC    A(MJRNEWNOTDIR)                                          00577\n         ORG                                                            00578\nMJRNEWNOTDIR DC C'The new name specified on the rename service is not ' 00579\n         DC    C'a directory'                                           00580\n         DC    X'00'                                                    00581\n         ORG   ETAB+(4*JRNEWISDIR)                                      00582\n         DC    A(MJRNEWISDIR)                                           00583\n         ORG                                                            00584\nMJRNEWISDIR DC C'The new name specified on the rename service is a dir' 00585\n         DC    C'ectory'                                                00586\n         DC    X'00'                                                    00587\n         ORG   ETAB+(4*JROLDNOEXIST)                                    00588\n         DC    A(MJROLDNOEXIST)                                         00589\n         ORG                                                            00590\nMJROLDNOEXIST DC C'The old name specified on the rename service does n' 00591\n         DC    C'ot exist'                                              00592\n         DC    X'00'                                                    00593\n         ORG   ETAB+(4*JRISFSROOT)                                      00594\n         DC    A(MJRISFSROOT)                                           00595\n         ORG                                                            00596\nMJRISFSROOT DC C'The name specified is in use as a file system root'    00597\n         DC    X'00'                                                    00598\n         ORG   ETAB+(4*JRRENAME)                                        00599\n         DC    A(MJRRENAME)                                             00600\n         ORG                                                            00601\nMJRRENAME DC C'The rename service vnode operation is not supported'     00602\n         DC    X'00'                                                    00603\n         ORG   ETAB+(4*JRDOTORDOTDOT)                                   00604\n         DC    A(MJRDOTORDOTDOT)                                        00605\n         ORG                                                            00606\nMJRDOTORDOTDOT DC C'The requested function cannot be performed against' 00607\n         DC    C' dot (.) or dot-dot (..)'                              00608\n         DC    X'00'                                                    00609\n         ORG   ETAB+(4*JRKERNELDOWN)                                    00610\n         DC    A(MJRKERNELDOWN)                                         00611\n         ORG                                                            00612\nMJRKERNELDOWN DC C'The kernel has ended during this service'            00613\n         DC    X'00'                                                    00614\n         ORG   ETAB+(4*JRBADENTRYCODE)                                  00615\n         DC    A(MJRBADENTRYCODE)                                       00616\n         ORG                                                            00617\nMJRBADENTRYCODE DC C'An incorrect entry code was specified on this req' 00618\n         DC    C'uest'                                                  00619\n         DC    X'00'                                                    00620\n         ORG   ETAB+(4*JRFDALLOCERR)                                    00621\n         DC    A(MJRFDALLOCERR)                                         00622\n         ORG                                                            00623\nMJRFDALLOCERR DC C'An error occurred while trying to allocate a file d' 00624\n         DC    C'escriptor page.'                                       00625\n         DC    X'00'                                                    00626\n         ORG   ETAB+(4*JRBYTES2RWZERO)                                  00627\n         DC    A(MJRBYTES2RWZERO)                                       00628\n         ORG                                                            00629\nMJRBYTES2RWZERO DC C'The number of bytes requested to read or write is' 00630\n         DC    C' negative'                                             00631\n         DC    X'00'                                                    00632\n         ORG   ETAB+(4*JRRWDFILENOTDIR)                                 00633\n         DC    A(MJRRWDFILENOTDIR)                                      00634\n         ORG                                                            00635\nMJRRWDFILENOTDIR DC C'The rewinddir service was on a file that is not ' 00636\n         DC    C'a directory'                                           00637\n         DC    X'00'                                                    00638\n         ORG   ETAB+(4*JRROOTNODE)                                      00639\n         DC    A(MJRROOTNODE)                                           00640\n         ORG                                                            00641\nMJRROOTNODE DC C'The requested operation cannot be done on a root'      00642\n         DC    X'00'                                                    00643\n         ORG   ETAB+(4*JRINVALIDSIGNAL)                                 00644\n         DC    A(MJRINVALIDSIGNAL)                                      00645\n         ORG                                                            00646\nMJRINVALIDSIGNAL DC C'A signal number specified is incorrect      '     00647\n         DC    X'00'                                                    00648\n         ORG   ETAB+(4*JRINVALIDSIGACT)                                 00649\n         DC    A(MJRINVALIDSIGACT)                                      00650\n         ORG                                                            00651\nMJRINVALIDSIGACT DC C'The action is incorrect for the specified signal' 00652\n         DC    X'00'                                                    00653\n         ORG   ETAB+(4*JRINVALIDSIGHOW)                                 00654\n         DC    A(MJRINVALIDSIGHOW)                                      00655\n         ORG                                                            00656\nMJRINVALIDSIGHOW DC C'The how operand specified is incorrect'           00657\n         DC    X'00'                                                    00658\n         ORG   ETAB+(4*JRNOTFORDIR)                                     00659\n         DC    A(MJRNOTFORDIR)                                          00660\n         ORG                                                            00661\nMJRNOTFORDIR DC C'The system cannot perform the requested function on ' 00662\n         DC    C'a directory'                                           00663\n         DC    X'00'                                                    00664\n         ORG   ETAB+(4*JROLDPARTOFNEW)                                  00665\n         DC    A(MJROLDPARTOFNEW)                                       00666\n         ORG                                                            00667\nMJROLDPARTOFNEW DC C'The old name specified on the rename service is p' 00668\n         DC    C'art of the new name'                                   00669\n         DC    X'00'                                                    00670\n         ORG   ETAB+(4*JRTROPENEDRO)                                    00671\n         DC    A(MJRTROPENEDRO)                                         00672\n         ORG                                                            00673\nMJRTROPENEDRO DC C'The ftruncate service was for a file opened in read' 00674\n         DC    C'-only mode'                                            00675\n         DC    X'00'                                                    00676\n         ORG   ETAB+(4*JRTRMOUNTEDRO)                                   00677\n         DC    A(MJRTRMOUNTEDRO)                                        00678\n         ORG                                                            00679\nMJRTRMOUNTEDRO DC C'The ftruncate service was for a file on a file sys' 00680\n         DC    C'tem mounted in read-only mode'                         00681\n         DC    X'00'                                                    00682\n         ORG   ETAB+(4*JRTRNEGOFFSET)                                   00683\n         DC    A(MJRTRNEGOFFSET)                                        00684\n         ORG                                                            00685\nMJRTRNEGOFFSET DC C'A negative offset was given to a file truncate ser' 00686\n         DC    C'vice'                                                  00687\n         DC    X'00'                                                    00688\n         ORG   ETAB+(4*JROUTOFLOCKS)                                    00689\n         DC    A(MJROUTOFLOCKS)                                         00690\n         ORG                                                            00691\nMJROUTOFLOCKS DC C'The file system has run out of locks'                00692\n         DC    X'00'                                                    00693\n         ORG   ETAB+(4*JRMOUNT)                                         00694\n         DC    A(MJRMOUNT)                                              00695\n         ORG                                                            00696\nMJRMOUNT DC C'The mount service VFS operation is not supported'         00697\n         DC    X'00'                                                    00698\n         ORG   ETAB+(4*JRUMOUNT)                                        00699\n         DC    A(MJRUMOUNT)                                             00700\n         ORG                                                            00701\nMJRUMOUNT DC C'The unmount service VFS operation is not supported'      00702\n         DC    X'00'                                                    00703\n         ORG   ETAB+(4*JRSYNC)                                          00704\n         DC    A(MJRSYNC)                                               00705\n         ORG                                                            00706\nMJRSYNC DC C'The Sync VFS operation is not supported'                   00707\n         DC    X'00'                                                    00708\n         ORG   ETAB+(4*JRSTATFS)                                        00709\n         DC    A(MJRSTATFS)                                             00710\n         ORG                                                            00711\nMJRSTATFS DC C'The StatFS VFS operation is not supported'               00712\n         DC    X'00'                                                    00713\n         ORG   ETAB+(4*JRVGET)                                          00714\n         DC    A(MJRVGET)                                               00715\n         ORG                                                            00716\nMJRVGET DC C'The VGet VFS operation is not supported'                   00717\n         DC    X'00'                                                    00718\n         ORG   ETAB+(4*JRINVALIDPARMS)                                  00719\n         DC    A(MJRINVALIDPARMS)                                       00720\n         ORG                                                            00721\nMJRINVALIDPARMS DC C'An incorrect combination of parameters was specif' 00722\n         DC    C'ied'                                                   00723\n         DC    X'00'                                                    00724\n         ORG   ETAB+(4*JRFSPARENTFS)                                    00725\n         DC    A(MJRFSPARENTFS)                                         00726\n         ORG                                                            00727\nMJRFSPARENTFS DC C'The file system has file systems mounted on it'      00728\n         DC    X'00'                                                    00729\n         ORG   ETAB+(4*JRFSUNMOUNTINPROGRESS)                           00730\n         DC    A(MJRFSUNMOUNTINPROGRESS)                                00731\n         ORG                                                            00732\nMJRFSUNMOUNTINPROGRESS DC C'An unmount service is already in progress'  00733\n         DC    X'00'                                                    00734\n         ORG   ETAB+(4*JRFSMUSTRESET)                                   00735\n         DC    A(MJRFSMUSTRESET)                                        00736\n         ORG                                                            00737\nMJRFSMUSTRESET DC C'An unmount service must specify reset when already' 00738\n         DC    C' unmounting'                                           00739\n         DC    X'00'                                                    00740\n         ORG   ETAB+(4*JRFSFORCEUMOUNT)                                 00741\n         DC    A(MJRFSFORCEUMOUNT)                                      00742\n         ORG                                                            00743\nMJRFSFORCEUMOUNT DC C'Reset fails when the file system is forced to un' 00744\n         DC    C'mount'                                                 00745\n         DC    X'00'                                                    00746\n         ORG   ETAB+(4*JRAUDIT)                                         00747\n         DC    A(MJRAUDIT)                                              00748\n         ORG                                                            00749\nMJRAUDIT DC C'The audit vnode operation is not supported'               00750\n         DC    X'00'                                                    00751\n         ORG   ETAB+(4*JRUSERNOTPRIVILEGED)                             00752\n         DC    A(MJRUSERNOTPRIVILEGED)                                  00753\n         ORG                                                            00754\nMJRUSERNOTPRIVILEGED DC C'The requester of the service is not privileg' 00755\n         DC    C'ed'                                                    00756\n         DC    X'00'                                                    00757\n         ORG   ETAB+(4*JRMUSTUMOUNTIMMED)                               00758\n         DC    A(MJRMUSTUMOUNTIMMED)                                    00759\n         ORG                                                            00760\nMJRMUSTUMOUNTIMMED DC C'An immediate unmount must precede a forced unm' 00761\n         DC    C'ount'                                                  00762\n         DC    X'00'                                                    00763\n         ORG   ETAB+(4*JRNOTQUIESCED)                                   00764\n         DC    A(MJRNOTQUIESCED)                                        00765\n         ORG                                                            00766\nMJRNOTQUIESCED DC C'A quiesce service must precede an unquiesce'        00767\n         DC    X'00'                                                    00768\n         ORG   ETAB+(4*JRQUIESCED)                                      00769\n         DC    A(MJRQUIESCED)                                           00770\n         ORG                                                            00771\nMJRQUIESCED DC C'There was a previous quiesce request'                  00772\n         DC    X'00'                                                    00773\n         ORG   ETAB+(4*JRINVALIDREQUESTER)                              00774\n         DC    A(MJRINVALIDREQUESTER)                                   00775\n         ORG                                                            00776\nMJRINVALIDREQUESTER DC C'The requester of the function cannot make the' 00777\n         DC    C' request'                                              00778\n         DC    X'00'                                                    00779\n         ORG   ETAB+(4*JRPFSSUSPEND)                                    00780\n         DC    A(MJRPFSSUSPEND)                                         00781\n         ORG                                                            00782\nMJRPFSSUSPEND DC C'The PFS is waiting to restart.'                      00783\n         DC    X'00'                                                    00784\n         ORG   ETAB+(4*JRPFSABEND)                                      00785\n         DC    A(MJRPFSABEND)                                           00786\n         ORG                                                            00787\nMJRPFSABEND DC C'The physical file system abended'                      00788\n         DC    X'00'                                                    00789\n         ORG   ETAB+(4*JRNOSTORAGE)                                     00790\n         DC    A(MJRNOSTORAGE)                                          00791\n         ORG                                                            00792\nMJRNOSTORAGE DC C'Insufficient storage to copy user parameters'         00793\n         DC    X'00'                                                    00794\n         ORG   ETAB+(4*JRACTIVEPROCESS)                                 00795\n         DC    A(MJRACTIVEPROCESS)                                      00796\n         ORG                                                            00797\nMJRACTIVEPROCESS DC C'Multiple processes in the address space prevent ' 00798\n         DC    C'the termination of the job step process'               00799\n         DC    X'00'                                                    00800\n         ORG   ETAB+(4*JRPFSCTL)                                        00801\n         DC    A(MJRPFSCTL)                                             00802\n         ORG                                                            00803\nMJRPFSCTL DC C'The Pfsctl operation is not supported'                   00804\n         DC    X'00'                                                    00805\n         ORG   ETAB+(4*JRPFSINITFAILED)                                 00806\n         DC    A(MJRPFSINITFAILED)                                      00807\n         ORG                                                            00808\nMJRPFSINITFAILED DC C'The file system did not initialize'               00809\n         DC    X'00'                                                    00810\n         ORG   ETAB+(4*JRSPAWNNOCOMMONSTG)                              00811\n         DC    A(MJRSPAWNNOCOMMONSTG)                                   00812\n         ORG                                                            00813\nMJRSPAWNNOCOMMONSTG DC C'Spawn cannot be completed because not enough ' 00814\n         DC    C'common storage is available to complete the request'   00815\n         DC    X'00'                                                    00816\n         ORG   ETAB+(4*JRSPAWNARGSTOOBIG)                               00817\n         DC    A(MJRSPAWNARGSTOOBIG)                                    00818\n         ORG                                                            00819\nMJRSPAWNARGSTOOBIG DC C'Spawn cannot be completed because the total le' 00820\n         DC    C'ngth of arguments specified by the caller exceeds the' 00821\n         DC    C' system imposed limit of 1 finespace.000 finespace.00' 00822\n         DC    C'0 bytes'                                               00823\n         DC    X'00'                                                    00824\n         ORG   ETAB+(4*JRFUNCUNDEFINED)                                 00825\n         DC    A(MJRFUNCUNDEFINED)                                      00826\n         ORG                                                            00827\nMJRFUNCUNDEFINED DC C'The oe_env_np (BPX1ENV) service cannot be comple' 00828\n         DC    C'ted because the Function_code specified is undefined'  00829\n         DC    X'00'                                                    00830\n         ORG   ETAB+(4*JRBADARGCOUNT)                                   00831\n         DC    A(MJRBADARGCOUNT)                                        00832\n         ORG                                                            00833\nMJRBADARGCOUNT DC C'The oe_env_np (BPX1ENV) service cannot be complete' 00834\n         DC    C'd because the number of input or output arguments are' 00835\n         DC    C' incorrect for the Function_code specified'            00836\n         DC    X'00'                                                    00837\n         ORG   ETAB+(4*JRBADINPUTVALUE)                                 00838\n         DC    A(MJRBADINPUTVALUE)                                      00839\n         ORG                                                            00840\nMJRBADINPUTVALUE DC C'The oe_env_np (BPX1ENV) service cannot be comple' 00841\n         DC    C'ted because an input argument contained an undefined ' 00842\n         DC    C'value'                                                 00843\n         DC    X'00'                                                    00844\n         ORG   ETAB+(4*JRNOUSEREXIT)                                    00845\n         DC    A(MJRNOUSEREXIT)                                         00846\n         ORG                                                            00847\nMJRNOUSEREXIT DC C'A pthread_quiesce (BPX1PTQ) service FREEZE_EXIT req' 00848\n         DC    C'uest cannot complete because no user exit has been re' 00849\n         DC    C'gistered with the oe_env_np (BPX1ENV) service'         00850\n         DC    X'00'                                                    00851\n         ORG   ETAB+(4*JRPROCESSNOTFROZEN)                              00852\n         DC    A(MJRPROCESSNOTFROZEN)                                   00853\n         ORG                                                            00854\nMJRPROCESSNOTFROZEN DC C'A pthread_quiesce (BPX1PTQ) service FREEZE_EX' 00855\n         DC    C'IT request cannot complete because the process is  no' 00856\n         DC    C't frozen'                                              00857\n         DC    X'00'                                                    00858\n         ORG   ETAB+(4*JRFREEZEEXITTOOSLOW)                             00859\n         DC    A(MJRFREEZEEXITTOOSLOW)                                  00860\n         ORG                                                            00861\nMJRFREEZEEXITTOOSLOW DC C'A pthread_quiesce (BPX1PTQ) service FREEZE_E' 00862\n         DC    C'XIT request cannot complete because user exits did no' 00863\n         DC    C't return in the expected time'                         00864\n         DC    X'00'                                                    00865\n         ORG   ETAB+(4*JRRESRPORTSPECIFIED)                             00866\n         DC    A(MJRRESRPORTSPECIFIED)                                  00867\n         ORG                                                            00868\nMJRRESRPORTSPECIFIED DC C'During a Socket Bind request, a Reserved Por' 00869\n         DC    C't was incorrectly specified'                           00870\n         DC    X'00'                                                    00871\n         ORG   ETAB+(4*JRRESRPORTNOTAVAIL)                              00872\n         DC    A(MJRRESRPORTNOTAVAIL)                                   00873\n         ORG                                                            00874\nMJRRESRPORTNOTAVAIL DC C'All port zero, INADDR_ANY, reserved ports are' 00875\n         DC    C' in use'                                               00876\n         DC    X'00'                                                    00877\n         ORG   ETAB+(4*JRRESRPORTUSED)                                  00878\n         DC    A(MJRRESRPORTUSED)                                       00879\n         ORG                                                            00880\nMJRRESRPORTUSED DC C'A sockets port assignment conflict exists between' 00881\n         DC    C' OMVS and a Transport Provider'                        00882\n         DC    X'00'                                                    00883\n         ORG   ETAB+(4*JRTLSREQUESTINVALID)                             00884\n         DC    A(MJRTLSREQUESTINVALID)                                  00885\n         ORG                                                            00886\nMJRTLSREQUESTINVALID DC C'An invalid request has been passed for Task ' 00887\n         DC    C'Level Security.'                                       00888\n         DC    X'00'                                                    00889\n         ORG   ETAB+(4*JRNORESERVEDPORTS)                               00890\n         DC    A(MJRNORESERVEDPORTS)                                    00891\n         ORG                                                            00892\nMJRNORESERVEDPORTS DC C'A bind() syscall that specified port number ze' 00893\n         DC    C'ro and IP address INADDR_ANY, failed because no ports' 00894\n         DC    C' were reserved.'                                       00895\n         DC    X'00'                                                    00896\n         ORG   ETAB+(4*JRTLSIDTYPEINVALID)                              00897\n         DC    A(MJRTLSIDTYPEINVALID)                                   00898\n         ORG                                                            00899\nMJRTLSIDTYPEINVALID DC C'An invalid ID type has been passed for Task L' 00900\n         DC    C'evel Security.'                                        00901\n         DC    X'00'                                                    00902\n         ORG   ETAB+(4*JRTLSIDLENGTHINVALID)                            00903\n         DC    A(MJRTLSIDLENGTHINVALID)                                 00904\n         ORG                                                            00905\nMJRTLSIDLENGTHINVALID DC C'An invalid ID length has been passed for Ta' 00906\n         DC    C'sk Level Security.'                                    00907\n         DC    X'00'                                                    00908\n         ORG   ETAB+(4*JRTLSADDRESSLENGTHINVALID)                       00909\n         DC    A(MJRTLSADDRESSLENGTHINVALID)                            00910\n         ORG                                                            00911\nMJRTLSADDRESSLENGTHINVALID DC C'An invalid address length has been pas' 00912\n         DC    C'sed for Task Level Security.'                          00913\n         DC    X'00'                                                    00914\n         ORG   ETAB+(4*JRTLSCALLERISIPT)                                00915\n         DC    A(MJRTLSCALLERISIPT)                                     00916\n         ORG                                                            00917\nMJRTLSCALLERISIPT DC C'The calling task is IPT.'                        00918\n         DC    X'00'                                                    00919\n         ORG   ETAB+(4*JRTLSNOTDONEBYOE)                                00920\n         DC    A(MJRTLSNOTDONEBYOE)                                     00921\n         ORG                                                            00922\nMJRTLSNOTDONEBYOE DC C'Task level security already exists, but it was ' 00923\n         DC    C'not created by a previous call to pthread_security_np' 00924\n         DC    C'.'                                                     00925\n         DC    X'00'                                                    00926\n         ORG   ETAB+(4*JRNOPTRACETASKSEC)                               00927\n         DC    A(MJRNOPTRACETASKSEC)                                    00928\n         ORG                                                            00929\nMJRNOPTRACETASKSEC DC C'Ptrace is active in the caller apos.s address ' 00930\n         DC    C'space, task level security not allowed concurrently w' 00931\n         DC    C'ith Ptrace.'                                           00932\n         DC    X'00'                                                    00933\n         ORG   ETAB+(4*JRSAFRESOURCEUNDEFINED)                          00934\n         DC    A(MJRSAFRESOURCEUNDEFINED)                               00935\n         ORG                                                            00936\nMJRSAFRESOURCEUNDEFINED DC C'The resource specified by the caller is n' 00937\n         DC    C'ot defined to RACF.'                                   00938\n         DC    X'00'                                                    00939\n         ORG   ETAB+(4*JRSAFNOUUIDTOUSER)                               00940\n         DC    A(MJRSAFNOUUIDTOUSER)                                    00941\n         ORG                                                            00942\nMJRSAFNOUUIDTOUSER DC C'No mapping to a RACF userid exists for the DCE' 00943\n         DC    C' UUID specified.'                                      00944\n         DC    X'00'                                                    00945\n         ORG   ETAB+(4*JRSAFNOUSERTOUUID)                               00946\n         DC    A(MJRSAFNOUSERTOUUID)                                    00947\n         ORG                                                            00948\nMJRSAFNOUSERTOUUID DC C'No mapping to a DCE UUID exists for the RACF U' 00949\n         DC    C'serid specified.'                                      00950\n         DC    X'00'                                                    00951\n         ORG   ETAB+(4*JRSAFNODCECLASS)                                 00952\n         DC    A(MJRSAFNODCECLASS)                                      00953\n         ORG                                                            00954\nMJRSAFNODCECLASS DC C'The RACF DCEUUIDS class is not active.'           00955\n         DC    X'00'                                                    00956\n         ORG   ETAB+(4*JRSAFNOCELLUUID)                                 00957\n         DC    A(MJRSAFNOCELLUUID)                                      00958\n         ORG                                                            00959\nMJRSAFNOCELLUUID DC C'The local cell UUID could not be determined for ' 00960\n         DC    C'this RACF userid to DCE UUID conversion request.'      00961\n         DC    X'00'                                                    00962\n         ORG   ETAB+(4*JRCLASSLENERR)                                   00963\n         DC    A(MJRCLASSLENERR)                                        00964\n         ORG                                                            00965\nMJRCLASSLENERR DC C'The length of the RACF class name is outside of th' 00966\n         DC    C'e allowable range of 1 to 8.'                          00967\n         DC    X'00'                                                    00968\n         ORG   ETAB+(4*JRENTITYLENERR)                                  00969\n         DC    A(MJRENTITYLENERR)                                       00970\n         ORG                                                            00971\nMJRENTITYLENERR DC C'The length of the RACF entity name is outside of ' 00972\n         DC    C'the allowable range of 1 to 246.'                      00973\n         DC    X'00'                                                    00974\n         ORG   ETAB+(4*JRACCESSUNDEFINED)                               00975\n         DC    A(MJRACCESSUNDEFINED)                                    00976\n         ORG                                                            00977\nMJRACCESSUNDEFINED DC C'The access type specified is undefined.'        00978\n         DC    X'00'                                                    00979\n         ORG   ETAB+(4*JRNOTSERVERAUTHORIZED)                           00980\n         DC    A(MJRNOTSERVERAUTHORIZED)                                00981\n         ORG                                                            00982\nMJRNOTSERVERAUTHORIZED DC C'The calling address space is not permitted' 00983\n         DC    C' to the BPX.SERVER Facility class or the BPX.SERVER F' 00984\n         DC    C'acility class is undefined and caller not a superuser' 00985\n         DC    C' (UID=0)'                                              00986\n         DC    X'00'                                                    00987\n         ORG   ETAB+(4*JRNORESOURCEACCESS)                              00988\n         DC    A(MJRNORESOURCEACCESS)                                   00989\n         ORG                                                            00990\nMJRNORESOURCEACCESS DC C'The user specified by the caller does not hav' 00991\n         DC    C'e the access specified to the resource'                00992\n         DC    X'00'                                                    00993\n         ORG   ETAB+(4*JRSURROGATEUNDEFINED)                            00994\n         DC    A(MJRSURROGATEUNDEFINED)                                 00995\n         ORG                                                            00996\nMJRSURROGATEUNDEFINED DC C'The RACF SURROGAT class has not been activa' 00997\n         DC    C'ted or no SURROGAT class profile has been defined for' 00998\n         DC    C' the client'                                           00999\n         DC    X'00'                                                    01000\n         ORG   ETAB+(4*JRNOSURROGATEPERM)                               01001\n         DC    A(MJRNOSURROGATEPERM)                                    01002\n         ORG                                                            01003\nMJRNOSURROGATEPERM DC C'The server is not permitted to the SURROGAT cl' 01004\n         DC    C'ass profile defined for the client'                    01005\n         DC    X'00'                                                    01006\n         ORG   ETAB+(4*JRSAFNOTAUTHORIZED)                              01007\n         DC    A(MJRSAFNOTAUTHORIZED)                                   01008\n         ORG                                                            01009\nMJRSAFNOTAUTHORIZED DC C'The calling address space is not authorized t' 01010\n         DC    C'o use this service'                                    01011\n         DC    X'00'                                                    01012\n         ORG   ETAB+(4*JRNOBUFSTORAGE)                                  01013\n         DC    A(MJRNOBUFSTORAGE)                                       01014\n         ORG                                                            01015\nMJRNOBUFSTORAGE DC C'Storage could not be obtained for I/O buffers    ' 01016\n         DC    C'   '                                                   01017\n         DC    X'00'                                                    01018\n         ORG   ETAB+(4*JRNOVSMLIST)                                     01019\n         DC    A(MJRNOVSMLIST)                                          01020\n         ORG                                                            01021\nMJRNOVSMLIST DC C'Fork cannot be completed because the parent process ' 01022\n         DC    C'ended prematurely'                                     01023\n         DC    X'00'                                                    01024\n         ORG   ETAB+(4*JRFORKNORESOURCE)                                01025\n         DC    A(MJRFORKNORESOURCE)                                     01026\n         ORG                                                            01027\nMJRFORKNORESOURCE DC C'Fork cannot be processed for lack of resource'   01028\n         DC    X'00'                                                    01029\n         ORG   ETAB+(4*JRSAFNOUSER)                                     01030\n         DC    A(MJRSAFNOUSER)                                          01031\n         ORG                                                            01032\nMJRSAFNOUSER DC C'The user ID is not defined to the security product'   01033\n         DC    X'00'                                                    01034\n         ORG   ETAB+(4*JRSAFGROUPNOOMVS)                                01035\n         DC    A(MJRSAFGROUPNOOMVS)                                     01036\n         ORG                                                            01037\nMJRSAFGROUPNOOMVS DC C'The current group does not have a GID defined i' 01038\n         DC    C'n the OMVS segment.'                                   01039\n         DC    X'00'                                                    01040\n         ORG   ETAB+(4*JRSAFUSERNOOMVS)                                 01041\n         DC    A(MJRSAFUSERNOOMVS)                                      01042\n         ORG                                                            01043\nMJRSAFUSERNOOMVS DC C'The user ID is not authorized to use OMVS'        01044\n         DC    X'00'                                                    01045\n         ORG   ETAB+(4*JRSAFNOUID)                                      01046\n         DC    A(MJRSAFNOUID)                                           01047\n         ORG                                                            01048\nMJRSAFNOUID DC C'The user ID has no UID'                                01049\n         DC    X'00'                                                    01050\n         ORG   ETAB+(4*JRSAFNOGID)                                      01051\n         DC    A(MJRSAFNOGID)                                           01052\n         ORG                                                            01053\nMJRSAFNOGID DC C'The user ID is in a group that has no GID'             01054\n         DC    X'00'                                                    01055\n         ORG   ETAB+(4*JRSAFINTERNAL)                                   01056\n         DC    A(MJRSAFINTERNAL)                                        01057\n         ORG                                                            01058\nMJRSAFINTERNAL DC C'An internal error occurred in the security product' 01059\n         DC    X'00'                                                    01060\n         ORG   ETAB+(4*JRSTATUSPOSTED)                                  01061\n         DC    A(MJRSTATUSPOSTED)                                       01062\n         ORG                                                            01063\nMJRSTATUSPOSTED DC C'A request was received to dub a thread for a proc' 01064\n         DC    C'ess that is stopped or has ended'                      01065\n         DC    X'00'                                                    01066\n         ORG   ETAB+(4*JRTRUNC)                                         01067\n         DC    A(MJRTRUNC)                                              01068\n         ORG                                                            01069\nMJRTRUNC DC C'Vnode operation trunc is not supported by this file syst' 01070\n         DC    C'em'                                                    01071\n         DC    X'00'                                                    01072\n         ORG   ETAB+(4*JRFSYNC)                                         01073\n         DC    A(MJRFSYNC)                                              01074\n         ORG                                                            01075\nMJRFSYNC DC C'Vnode operation fsync is not supported by this file syst' 01076\n         DC    C'em'                                                    01077\n         DC    X'00'                                                    01078\n         ORG   ETAB+(4*JRSETATTR)                                       01079\n         DC    A(MJRSETATTR)                                            01080\n         ORG                                                            01081\nMJRSETATTR DC C'Vnode operation setattr is not supported by this file ' 01082\n         DC    C'system'                                                01083\n         DC    X'00'                                                    01084\n         ORG   ETAB+(4*JRSYMFILEALREADYEXISTS)                          01085\n         DC    A(MJRSYMFILEALREADYEXISTS)                               01086\n         ORG                                                            01087\nMJRSYMFILEALREADYEXISTS DC C'The file requested for creation as a symb' 01088\n         DC    C'olic link already exists'                              01089\n         DC    X'00'                                                    01090\n         ORG   ETAB+(4*JRSYMLINK)                                       01091\n         DC    A(MJRSYMLINK)                                            01092\n         ORG                                                            01093\nMJRSYMLINK DC C'The symbolic link vnode operation is not supported'     01094\n         DC    X'00'                                                    01095\n         ORG   ETAB+(4*JRFILENOTSYMLINK)                                01096\n         DC    A(MJRFILENOTSYMLINK)                                     01097\n         ORG                                                            01098\nMJRFILENOTSYMLINK DC C'The file requested for readlink service is not ' 01099\n         DC    C'a symbolic link'                                       01100\n         DC    X'00'                                                    01101\n         ORG   ETAB+(4*JRREADLINK)                                      01102\n         DC    A(MJRREADLINK)                                           01103\n         ORG                                                            01104\nMJRREADLINK DC C'The readlink vnode operation is not supported'         01105\n         DC    X'00'                                                    01106\n         ORG   ETAB+(4*JRMKNODINVALIDTYPE)                              01107\n         DC    A(MJRMKNODINVALIDTYPE)                                   01108\n         ORG                                                            01109\nMJRMKNODINVALIDTYPE DC C'The mknod service invoked with incorrect file' 01110\n         DC    C' type parameter'                                       01111\n         DC    X'00'                                                    01112\n         ORG   ETAB+(4*JRENDINGSLASHMKNOD)                              01113\n         DC    A(MJRENDINGSLASHMKNOD)                                   01114\n         ORG                                                            01115\nMJRENDINGSLASHMKNOD DC C'The pathname ended with a slash on the mknod ' 01116\n         DC    C'service'                                               01117\n         DC    X'00'                                                    01118\n         ORG   ETAB+(4*JRENDINGSLASHOCREAT)                             01119\n         DC    A(MJRENDINGSLASHOCREAT)                                  01120\n         ORG                                                            01121\nMJRENDINGSLASHOCREAT DC C'The pathname in the open service, with the O' 01122\n         DC    C'_CREAT option, ended with slash'                       01123\n         DC    X'00'                                                    01124\n         ORG   ETAB+(4*JRLNKNOENT)                                      01125\n         DC    A(MJRLNKNOENT)                                           01126\n         ORG                                                            01127\nMJRLNKNOENT DC C'The service tried to link to nonexistent file'         01128\n         DC    X'00'                                                    01129\n         ORG   ETAB+(4*JRLNKNEWPATHEXISTS)                              01130\n         DC    A(MJRLNKNEWPATHEXISTS)                                   01131\n         ORG                                                            01132\nMJRLNKNEWPATHEXISTS DC C'The service tried to add a link whose name al' 01133\n         DC    C'ready exists'                                          01134\n         DC    X'00'                                                    01135\n         ORG   ETAB+(4*JRLNKACROSSFILESETS)                             01136\n         DC    A(MJRLNKACROSSFILESETS)                                  01137\n         ORG                                                            01138\nMJRLNKACROSSFILESETS DC C'The service tried to link across file system' 01139\n         DC    C's'                                                     01140\n         DC    X'00'                                                    01141\n         ORG   ETAB+(4*JRLNKROFILESET)                                  01142\n         DC    A(MJRLNKROFILESET)                                       01143\n         ORG                                                            01144\nMJRLNKROFILESET DC C'The service tried to add a directory entry on a r' 01145\n         DC    C'ead-only file system'                                  01146\n         DC    X'00'                                                    01147\n         ORG   ETAB+(4*JRLINK)                                          01148\n         DC    A(MJRLINK)                                               01149\n         ORG                                                            01150\nMJRLINK DC C'Vn_Link is not supported by this physical file system'     01151\n         DC    X'00'                                                    01152\n         ORG   ETAB+(4*JREXECNMLENZERO)                                 01153\n         DC    A(MJREXECNMLENZERO)                                      01154\n         ORG                                                            01155\nMJREXECNMLENZERO DC C'The length of the executable name passed was zer' 01156\n         DC    C'o'                                                     01157\n         DC    X'00'                                                    01158\n         ORG   ETAB+(4*JRFSFAILQUIESCE)                                 01159\n         DC    A(MJRFSFAILQUIESCE)                                      01160\n         ORG                                                            01161\nMJRFSFAILQUIESCE DC C'Dub or fork cannot complete, because the working' 01162\n         DC    C' directory is unmounted'                               01163\n         DC    X'00'                                                    01164\n         ORG   ETAB+(4*JRNOTPERMITTED)                                  01165\n         DC    A(MJRNOTPERMITTED)                                       01166\n         ORG                                                            01167\nMJRNOTPERMITTED DC C'You are not permitted to signal to the specified ' 01168\n         DC    C'process ID (PID)'                                      01169\n         DC    X'00'                                                    01170\n         ORG   ETAB+(4*JRBUFFLENINVALID)                                01171\n         DC    A(MJRBUFFLENINVALID)                                     01172\n         ORG                                                            01173\nMJRBUFFLENINVALID DC C'The length of the buffer is less than or equal ' 01174\n         DC    C'to zero or less than a minimum length'                 01175\n         DC    X'00'                                                    01176\n         ORG   ETAB+(4*JRNOTREGISTERED)                                 01177\n         DC    A(MJRNOTREGISTERED)                                      01178\n         ORG                                                            01179\nMJRNOTREGISTERED DC C'The call is not registered for signals'           01180\n         DC    X'00'                                                    01181\n         ORG   ETAB+(4*JRNOTSUPPORTEDFORFILETYPE)                       01182\n         DC    A(MJRNOTSUPPORTEDFORFILETYPE)                            01183\n         ORG                                                            01184\nMJRNOTSUPPORTEDFORFILETYPE DC C'The requested service is not supported' 01185\n         DC    C' for this file type'                                   01186\n         DC    X'00'                                                    01187\n         ORG   ETAB+(4*JRINVALIDSYMLINKLEN)                             01188\n         DC    A(MJRINVALIDSYMLINKLEN)                                  01189\n         ORG                                                            01190\nMJRINVALIDSYMLINKLEN DC C'The contents specified for the symbolic link' 01191\n         DC    C' has an incorrect length'                              01192\n         DC    X'00'                                                    01193\n         ORG   ETAB+(4*JRINVALIDSYMLINKCOMP)                            01194\n         DC    A(MJRINVALIDSYMLINKCOMP)                                 01195\n         ORG                                                            01196\nMJRINVALIDSYMLINKCOMP DC C'The contents specified for symbolic link ha' 01197\n         DC    C's an incorrect component'                              01198\n         DC    X'00'                                                    01199\n         ORG   ETAB+(4*JRFILENOTOPEN)                                   01200\n         DC    A(MJRFILENOTOPEN)                                        01201\n         ORG                                                            01202\nMJRFILENOTOPEN DC C'The file is not opened'                             01203\n         DC    X'00'                                                    01204\n         ORG   ETAB+(4*JRTOOMANYSYMLINKS)                               01205\n         DC    A(MJRTOOMANYSYMLINKS)                                    01206\n         ORG                                                            01207\nMJRTOOMANYSYMLINKS DC C'Too many symbolic links were encountered in th' 01208\n         DC    C'e pathname'                                            01209\n         DC    X'00'                                                    01210\n         ORG   ETAB+(4*JRMVSARGTOOBIG)                                  01211\n         DC    A(MJRMVSARGTOOBIG)                                       01212\n         ORG                                                            01213\nMJRMVSARGTOOBIG DC C'The execMVS argument string was too long'          01214\n         DC    X'00'                                                    01215\n         ORG   ETAB+(4*JREXECNOTREGFILE)                                01216\n         DC    A(MJREXECNOTREGFILE)                                     01217\n         ORG                                                            01218\nMJREXECNOTREGFILE DC C'The filename specified on the exec is not a reg' 01219\n         DC    C'ular file'                                             01220\n         DC    X'00'                                                    01221\n         ORG   ETAB+(4*JRAPPCERRRECVINCOMP)                             01222\n         DC    A(MJRAPPCERRRECVINCOMP)                                  01223\n         ORG                                                            01224\nMJRAPPCERRRECVINCOMP DC C'An APPC/MVS Receive_and_Wait error occurred.' 01225\n         DC    C'  The data is incomplete'                              01226\n         DC    X'00'                                                    01227\n         ORG   ETAB+(4*JRFORKNOACCESS)                                  01228\n         DC    A(MJRFORKNOACCESS)                                       01229\n         ORG                                                            01230\nMJRFORKNOACCESS DC C'The call tried an unauthorized access to a fork c' 01231\n         DC    C'hild transaction program'                              01232\n         DC    X'00'                                                    01233\n         ORG   ETAB+(4*JRINACTIVE)                                      01234\n         DC    A(MJRINACTIVE)                                           01235\n         ORG                                                            01236\nMJRINACTIVE DC C'The vnode operation inactive is not supported by the ' 01237\n         DC    C'file system'                                           01238\n         DC    X'00'                                                    01239\n         ORG   ETAB+(4*JRINVALIDMAJORNUMBER)                            01240\n         DC    A(MJRINVALIDMAJORNUMBER)                                 01241\n         ORG                                                            01242\nMJRINVALIDMAJORNUMBER DC C'Character special file system detected an i' 01243\n         DC    C'ncorrect device major number'                          01244\n         DC    X'00'                                                    01245\n         ORG   ETAB+(4*JRRDANDWRTFORPIPE)                               01246\n         DC    A(MJRRDANDWRTFORPIPE)                                    01247\n         ORG                                                            01248\nMJRRDANDWRTFORPIPE DC C'The open call on a pipe was for read/write'     01249\n         DC    X'00'                                                    01250\n         ORG   ETAB+(4*JROPENFORWRITENOREADERS)                         01251\n         DC    A(MJROPENFORWRITENOREADERS)                              01252\n         ORG                                                            01253\nMJROPENFORWRITENOREADERS DC C'Open for write was done before any open ' 01254\n         DC    C'for read'                                              01255\n         DC    X'00'                                                    01256\n         ORG   ETAB+(4*JRNOREADERS)                                     01257\n         DC    A(MJRNOREADERS)                                          01258\n         ORG                                                            01259\nMJRNOREADERS DC C'The service tried to write before any open for reads' 01260\n         DC    X'00'                                                    01261\n         ORG   ETAB+(4*JRINVPARMLENGTH)                                 01262\n         DC    A(MJRINVPARMLENGTH)                                      01263\n         ORG                                                            01264\nMJRINVPARMLENGTH DC C'The parameter length is incorrect or negative'    01265\n         DC    X'00'                                                    01266\n         ORG   ETAB+(4*JRBADADDRESS)                                    01267\n         DC    A(MJRBADADDRESS)                                         01268\n         ORG                                                            01269\nMJRBADADDRESS DC C'An incorrect address was encountered when the syste' 01270\n         DC    C'm tried to access data'                                01271\n         DC    X'00'                                                    01272\n         ORG   ETAB+(4*JRSIGDURINGWAIT)                                 01273\n         DC    A(MJRSIGDURINGWAIT)                                      01274\n         ORG                                                            01275\nMJRSIGDURINGWAIT DC C'A signal occurred during a wait'                  01276\n         DC    X'00'                                                    01277\n         ORG   ETAB+(4*JRRDNORWRTFORPIPE)                               01278\n         DC    A(MJRRDNORWRTFORPIPE)                                    01279\n         ORG                                                            01280\nMJRRDNORWRTFORPIPE DC C'The open service on a pipe was for neither rea' 01281\n         DC    C'd nor write'                                           01282\n         DC    X'00'                                                    01283\n         ORG   ETAB+(4*JRNODATA)                                        01284\n         DC    A(MJRNODATA)                                             01285\n         ORG                                                            01286\nMJRNODATA DC C'There is no data in this pipe'                           01287\n         DC    X'00'                                                    01288\n         ORG   ETAB+(4*JRUSERNOTAUTHORIZED)                             01289\n         DC    A(MJRUSERNOTAUTHORIZED)                                  01290\n         ORG                                                            01291\nMJRUSERNOTAUTHORIZED DC C'The user is not authorized for the requested' 01292\n         DC    C' file descriptor'                                      01293\n         DC    X'00'                                                    01294\n         ORG   ETAB+(4*JRFILEISBLOCKED)                                 01295\n         DC    A(MJRFILEISBLOCKED)                                      01296\n         ORG                                                            01297\nMJRFILEISBLOCKED DC C'The file is blocked'                              01298\n         DC    X'00'                                                    01299\n         ORG   ETAB+(4*JRIOCTL)                                         01300\n         DC    A(MJRIOCTL)                                              01301\n         ORG                                                            01302\nMJRIOCTL DC C'The ioctl service is not supported by this file system'   01303\n         DC    X'00'                                                    01304\n         ORG   ETAB+(4*JRINVALIDPID)                                    01305\n         DC    A(MJRINVALIDPID)                                         01306\n         ORG                                                            01307\nMJRINVALIDPID DC C'The process ID (PID) was not found, so the signal w' 01308\n         DC    C'as not sent'                                           01309\n         DC    X'00'                                                    01310\n         AIF   ('&SYSTEM_ID'(1,4) NE 'z/OS').NOTZOS1                    01311\n         ORG   ETAB+(4*JRVFSIOCTL)                                      01312\n         DC    A(MJRVFSIOCTL)                                           01313\n         ORG                                                            01314\nMJRVFSIOCTL DC C'The Vfsioctl service is not supported by this file sy' 01315\n         DC    C'stem'                                                  01316\n         DC    X'00'                                                    01317\n.NOTZOS1 ANOP                                                           01318\n         ORG   ETAB+(4*JRINVRBSTATE)                                    01319\n         DC    A(MJRINVRBSTATE)                                         01320\n         ORG                                                            01321\nMJRINVRBSTATE DC C'Callable services cannot be nested'                  01322\n         DC    X'00'                                                    01323\n         ORG   ETAB+(4*JRWRONGINSTANCE)                                 01324\n         DC    A(MJRWRONGINSTANCE)                                      01325\n         ORG                                                            01326\nMJRWRONGINSTANCE DC C'The process is not known to current kernel insta' 01327\n         DC    C'nce'                                                   01328\n         DC    X'00'                                                    01329\n         ORG   ETAB+(4*JRINVTERMSTAT)                                   01330\n         DC    A(MJRINVTERMSTAT)                                        01331\n         ORG                                                            01332\nMJRINVTERMSTAT DC C'An incorrect process termination status was passed' 01333\n         DC    C' to BPX1MPC'                                           01334\n         DC    X'00'                                                    01335\n         ORG   ETAB+(4*JRACTIVETHREADS)                                 01336\n         DC    A(MJRACTIVETHREADS)                                      01337\n         ORG                                                            01338\nMJRACTIVETHREADS DC C'The process could not be terminated because ther' 01339\n         DC    C'e are multiple threads still running in the process.'  01340\n         DC    X'00'                                                    01341\n         ORG   ETAB+(4*JRBADEXITSTATUSADDR)                             01342\n         DC    A(MJRBADEXITSTATUSADDR)                                  01343\n         ORG                                                            01344\nMJRBADEXITSTATUSADDR DC C'An incorrect exit status address was passed ' 01345\n         DC    C'to the wait call'                                      01346\n         DC    X'00'                                                    01347\n         ORG   ETAB+(4*JRPROCESSENDING)                                 01348\n         DC    A(MJRPROCESSENDING)                                      01349\n         ORG                                                            01350\nMJRPROCESSENDING DC C'The current process is ending'                    01351\n         DC    X'00'                                                    01352\n         ORG   ETAB+(4*JRSIGNALSNOTBLOCKED)                             01353\n         DC    A(MJRSIGNALSNOTBLOCKED)                                  01354\n         ORG                                                            01355\nMJRSIGNALSNOTBLOCKED DC C'The service did not complete because signals' 01356\n         DC    C' are not blocked'                                      01357\n         DC    X'00'                                                    01358\n         ORG   ETAB+(4*JRFDTOOBIG)                                      01359\n         DC    A(MJRFDTOOBIG)                                           01360\n         ORG                                                            01361\nMJRFDTOOBIG DC C'The requested file descriptor exceeds the Open_max li' 01362\n         DC    C'mit'                                                   01363\n         DC    X'00'                                                    01364\n         ORG   ETAB+(4*JROPENMAX)                                       01365\n         DC    A(MJROPENMAX)                                            01366\n         ORG                                                            01367\nMJROPENMAX DC C'The maximum number of open files for this process was ' 01368\n         DC    C'reached'                                               01369\n         DC    X'00'                                                    01370\n         ORG   ETAB+(4*JRIOBUFLENGTHINVALID)                            01371\n         DC    A(MJRIOBUFLENGTHINVALID)                                 01372\n         ORG                                                            01373\nMJRIOBUFLENGTHINVALID DC C'The input argument buffer length was incorr' 01374\n         DC    C'ect'                                                   01375\n         DC    X'00'                                                    01376\n         ORG   ETAB+(4*JRINVALIDAMODE)                                  01377\n         DC    A(MJRINVALIDAMODE)                                       01378\n         ORG                                                            01379\nMJRINVALIDAMODE DC C'An incorrect access mode was specified on the acc' 01380\n         DC    C'ess service'                                           01381\n         DC    X'00'                                                    01382\n         ORG   ETAB+(4*JRACCESS)                                        01383\n         DC    A(MJRACCESS)                                             01384\n         ORG                                                            01385\nMJRACCESS DC C'The access vnode operation is not supported'             01386\n         DC    X'00'                                                    01387\n         ORG   ETAB+(4*JRFSFAILCHDIR)                                   01388\n         DC    A(MJRFSFAILCHDIR)                                        01389\n         ORG                                                            01390\nMJRFSFAILCHDIR DC C'The dub failed, due to an error with the initial h' 01391\n         DC    C'ome directory'                                         01392\n         DC    X'00'                                                    01393\n         ORG   ETAB+(4*JRBADAUDITOPTION)                                01394\n         DC    A(MJRBADAUDITOPTION)                                     01395\n         ORG                                                            01396\nMJRBADAUDITOPTION DC C'An incorrect option code was specified for the ' 01397\n         DC    C'chaudit service'                                       01398\n         DC    X'00'                                                    01399\n         ORG   ETAB+(4*JREXECFILETOOBIG)                                01400\n         DC    A(MJREXECFILETOOBIG)                                     01401\n         ORG                                                            01402\nMJREXECFILETOOBIG DC C'The size of the specified file exceeds the priv' 01403\n         DC    C'ate region of the caller'                              01404\n         DC    X'00'                                                    01405\n         ORG   ETAB+(4*JRINVALIDCURSOR)                                 01406\n         DC    A(MJRINVALIDCURSOR)                                      01407\n         ORG                                                            01408\nMJRINVALIDCURSOR DC C'The cursor value passed to the w_getmntent call ' 01409\n         DC    C'is incorrect'                                          01410\n         DC    X'00'                                                    01411\n         ORG   ETAB+(4*JRPTYSLAVEOPENED)                                01412\n         DC    A(MJRPTYSLAVEOPENED)                                     01413\n         ORG                                                            01414\nMJRPTYSLAVEOPENED DC C'The open of the master pseudo-TTY failed, becau' 01415\n         DC    C'se the associated slave pseudo-TTY is still open'      01416\n         DC    X'00'                                                    01417\n         ORG   ETAB+(4*JRPTYMINORINVALID)                               01418\n         DC    A(MJRPTYMINORINVALID)                                    01419\n         ORG                                                            01420\nMJRPTYMINORINVALID DC C'The device minor number is larger than the MAX' 01421\n         DC    C'PTYS parameter in the BPXPRMxx member.'                01422\n         DC    X'00'                                                    01423\n         ORG   ETAB+(4*JRPTYALREADYACTIVE)                              01424\n         DC    A(MJRPTYALREADYACTIVE)                                   01425\n         ORG                                                            01426\nMJRPTYALREADYACTIVE DC C'The device minor number is already active'     01427\n         DC    X'00'                                                    01428\n         ORG   ETAB+(4*JRSIGNALRECEIVED)                                01429\n         DC    A(MJRSIGNALRECEIVED)                                     01430\n         ORG                                                            01431\nMJRSIGNALRECEIVED DC C'The call was interrupted by a signal'            01432\n         DC    X'00'                                                    01433\n         ORG   ETAB+(4*JRPTYDIFFERENTUID)                               01434\n         DC    A(MJRPTYDIFFERENTUID)                                    01435\n         ORG                                                            01436\nMJRPTYDIFFERENTUID DC C'The process UID is different from the UID of t' 01437\n         DC    C'he process that opened the master pseudo-TTY'          01438\n         DC    X'00'                                                    01439\n         ORG   ETAB+(4*JRPTYMASTERCLOSED)                               01440\n         DC    A(MJRPTYMASTERCLOSED)                                    01441\n         ORG                                                            01442\nMJRPTYMASTERCLOSED DC C'There is no corresponding master pseudo-TTY fi' 01443\n         DC    C'le open'                                               01444\n         DC    X'00'                                                    01445\n         ORG   ETAB+(4*JRPTYDIFFERENTFILE)                              01446\n         DC    A(MJRPTYDIFFERENTFILE)                                   01447\n         ORG                                                            01448\nMJRPTYDIFFERENTFILE DC C'A slave pseudo-TTY file for this minor number' 01449\n         DC    C' with a different filename is already open'            01450\n         DC    X'00'                                                    01451\n         ORG   ETAB+(4*JRPTYSLAVENOTINIT)                               01452\n         DC    A(MJRPTYSLAVENOTINIT)                                    01453\n         ORG                                                            01454\nMJRPTYSLAVENOTINIT DC C'The slave pseudo-TTY support did not complete ' 01455\n         DC    C'successfully'                                          01456\n         DC    X'00'                                                    01457\n         ORG   ETAB+(4*JRPTYINPUTSTOPPED)                               01458\n         DC    A(MJRPTYINPUTSTOPPED)                                    01459\n         ORG                                                            01460\nMJRPTYINPUTSTOPPED DC C'The nonblocked write failed, because input is ' 01461\n         DC    C'stopped'                                               01462\n         DC    X'00'                                                    01463\n         ORG   ETAB+(4*JREOFALREADYSENT)                                01464\n         DC    A(MJREOFALREADYSENT)                                     01465\n         ORG                                                            01466\nMJREOFALREADYSENT DC C'The write to the master pseudo-TTY failed, beca' 01467\n         DC    C'use all slaves are closed and HUPCL was set'           01468\n         DC    X'00'                                                    01469\n         ORG   ETAB+(4*JRPTYORPHANEDWRITE)                              01470\n         DC    A(MJRPTYORPHANEDWRITE)                                   01471\n         ORG                                                            01472\nMJRPTYORPHANEDWRITE DC C'The write service is processing in a backgrou' 01473\n         DC    C'nd, orphaned process group'                            01474\n         DC    X'00'                                                    01475\n         ORG   ETAB+(4*JRPTYOUTPUTSTOPPED)                              01476\n         DC    A(MJRPTYOUTPUTSTOPPED)                                   01477\n         ORG                                                            01478\nMJRPTYOUTPUTSTOPPED DC C'Write cannot be processed, because output has' 01479\n         DC    C' stopped'                                              01480\n         DC    X'00'                                                    01481\n         ORG   ETAB+(4*JRPTYNODATA)                                     01482\n         DC    A(MJRPTYNODATA)                                          01483\n         ORG                                                            01484\nMJRPTYNODATA DC C'Data or room is not available on the queue'           01485\n         DC    X'00'                                                    01486\n         ORG   ETAB+(4*JRPTYORPHANEDREAD)                               01487\n         DC    A(MJRPTYORPHANEDREAD)                                    01488\n         ORG                                                            01489\nMJRPTYORPHANEDREAD DC C'The read service is processing in a background' 01490\n         DC    C', orphaned process group'                              01491\n         DC    X'00'                                                    01492\n         ORG   ETAB+(4*JRPTYSIGTTINBLOCKED)                             01493\n         DC    A(MJRPTYSIGTTINBLOCKED)                                  01494\n         ORG                                                            01495\nMJRPTYSIGTTINBLOCKED DC C'The process is in a background process group' 01496\n         DC    C' and SIGTTIN is blocked or ignored'                    01497\n         DC    X'00'                                                    01498\n         ORG   ETAB+(4*JRPTYNOBUFSTORAGE)                               01499\n         DC    A(MJRPTYNOBUFSTORAGE)                                    01500\n         ORG                                                            01501\nMJRPTYNOBUFSTORAGE DC C'Storage is not available for pseudo-TTY buffer' 01502\n         DC    C's'                                                     01503\n         DC    X'00'                                                    01504\n         ORG   ETAB+(4*JRPTATTEMPTEDCRSTORE)                            01505\n         DC    A(MJRPTATTEMPTEDCRSTORE)                                 01506\n         ORG                                                            01507\nMJRPTATTEMPTEDCRSTORE DC C'Ptrace attempted to store into a control re' 01508\n         DC    C'gister'                                                01509\n         DC    X'00'                                                    01510\n         ORG   ETAB+(4*JRPTATTEMPTEDPSW0STORE)                          01511\n         DC    A(MJRPTATTEMPTEDPSW0STORE)                               01512\n         ORG                                                            01513\nMJRPTATTEMPTEDPSW0STORE DC C'Ptrace attempted to store into the left h' 01514\n         DC    C'alf of PSW'                                            01515\n         DC    X'00'                                                    01516\n         ORG   ETAB+(4*JRPTDBDEQUALSDBR)                                01517\n         DC    A(MJRPTDBDEQUALSDBR)                                     01518\n         ORG                                                            01519\nMJRPTDBDEQUALSDBR DC C'The ptrace debugger process ID (PID) is the sam' 01520\n         DC    C'e as the debugged PID'                                 01521\n         DC    X'00'                                                    01522\n         ORG   ETAB+(4*JRPTDBDPARENTTERM)                               01523\n         DC    A(MJRPTDBDPARENTTERM)                                    01524\n         ORG                                                            01525\nMJRPTDBDPARENTTERM DC C'The ptrace debugged parent (debugger) ended'    01526\n         DC    X'00'                                                    01527\n         ORG   ETAB+(4*JRPTDBDPIDNOTFOUND)                              01528\n         DC    A(MJRPTDBDPIDNOTFOUND)                                   01529\n         ORG                                                            01530\nMJRPTDBDPIDNOTFOUND DC C'The ptrace target debugged process ID (PID) i' 01531\n         DC    C's incorrect'                                           01532\n         DC    X'00'                                                    01533\n         ORG   ETAB+(4*JRPTDBRPIDNOTFOUND)                              01534\n         DC    A(MJRPTDBRPIDNOTFOUND)                                   01535\n         ORG                                                            01536\nMJRPTDBRPIDNOTFOUND DC C'The ptrace debugger ended'                     01537\n         DC    X'00'                                                    01538\n         ORG   ETAB+(4*JRPTDBRZOMBIE)                                   01539\n         DC    A(MJRPTDBRZOMBIE)                                        01540\n         ORG                                                            01541\nMJRPTDBRZOMBIE DC C'Ptrace debugger is ending'                          01542\n         DC    X'00'                                                    01543\n         ORG   ETAB+(4*JRPTINVCALLINGMODE)                              01544\n         DC    A(MJRPTINVCALLINGMODE)                                   01545\n         ORG                                                            01546\nMJRPTINVCALLINGMODE DC C'The ptrace caller mode is incorrect'           01547\n         DC    X'00'                                                    01548\n         ORG   ETAB+(4*JRPTINVDBDADDRESS)                               01549\n         DC    A(MJRPTINVDBDADDRESS)                                    01550\n         ORG                                                            01551\nMJRPTINVDBDADDRESS DC C'An incorrect address was supplied for the debu' 01552\n         DC    C'gged process'                                          01553\n         DC    X'00'                                                    01554\n         ORG   ETAB+(4*JRPTINVDBRADDRESS)                               01555\n         DC    A(MJRPTINVDBRADDRESS)                                    01556\n         ORG                                                            01557\nMJRPTINVDBRADDRESS DC C'An incorrect address was supplied for the debu' 01558\n         DC    C'gger process'                                          01559\n         DC    X'00'                                                    01560\n         ORG   ETAB+(4*JRPTINVFPRNUMBER)                                01561\n         DC    A(MJRPTINVFPRNUMBER)                                     01562\n         ORG                                                            01563\nMJRPTINVFPRNUMBER DC C'The ptrace call has an incorrect floating point' 01564\n         DC    C' register number'                                      01565\n         DC    X'00'                                                    01566\n         ORG   ETAB+(4*JRPTINVGPRNUMBER)                                01567\n         DC    A(MJRPTINVGPRNUMBER)                                     01568\n         ORG                                                            01569\nMJRPTINVGPRNUMBER DC C'The ptrace call has an incorrect general regist' 01570\n         DC    C'er number'                                             01571\n         DC    X'00'                                                    01572\n         ORG   ETAB+(4*JRPTINVLENGTH)                                   01573\n         DC    A(MJRPTINVLENGTH)                                        01574\n         ORG                                                            01575\nMJRPTINVLENGTH DC C'The ptrace length is incorrect'                     01576\n         DC    X'00'                                                    01577\n         ORG   ETAB+(4*JRPTINVNUMBERTHREADS)                            01578\n         DC    A(MJRPTINVNUMBERTHREADS)                                 01579\n         ORG                                                            01580\nMJRPTINVNUMBERTHREADS DC C'The ptrace target process has no threads   ' 01581\n         DC    C'   '                                                   01582\n         DC    X'00'                                                    01583\n         ORG   ETAB+(4*JRPTINVPTRACESTATE)                              01584\n         DC    A(MJRPTINVPTRACESTATE)                                   01585\n         ORG                                                            01586\nMJRPTINVPTRACESTATE DC C'The ptrace mode of target process is incorrec' 01587\n         DC    C't'                                                     01588\n         DC    X'00'                                                    01589\n         ORG   ETAB+(4*JRPTINVREQUEST)                                  01590\n         DC    A(MJRPTINVREQUEST)                                       01591\n         ORG                                                            01592\nMJRPTINVREQUEST DC C'The ptrace request was not valid'                  01593\n         DC    X'00'                                                    01594\n         ORG   ETAB+(4*JRPTINVSIGNALNUMBER)                             01595\n         DC    A(MJRPTINVSIGNALNUMBER)                                  01596\n         ORG                                                            01597\nMJRPTINVSIGNALNUMBER DC C'The ptrace service does not have a valid sig' 01598\n         DC    C'nal number'                                            01599\n         DC    X'00'                                                    01600\n         ORG   ETAB+(4*JRPTINVUAREAOFFSET)                              01601\n         DC    A(MJRPTINVUAREAOFFSET)                                   01602\n         ORG                                                            01603\nMJRPTINVUAREAOFFSET DC C'The ptrace service does not have a valid offs' 01604\n         DC    C'et into the user area'                                 01605\n         DC    X'00'                                                    01606\n         ORG   ETAB+(4*JRPTOLDDBRPIDNOTFOUND)                           01607\n         DC    A(MJRPTOLDDBRPIDNOTFOUND)                                01608\n         ORG                                                            01609\nMJRPTOLDDBRPIDNOTFOUND DC C'The ptrace original debugger ended'         01610\n         DC    X'00'                                                    01611\n         ORG   ETAB+(4*JRPTPROCESSNOTPTRACED)                           01612\n         DC    A(MJRPTPROCESSNOTPTRACED)                                01613\n         ORG                                                            01614\nMJRPTPROCESSNOTPTRACED DC C'The ptrace target process is not in ptrace' 01615\n         DC    C' mode'                                                 01616\n         DC    X'00'                                                    01617\n         ORG   ETAB+(4*JRPTPROCESSNOTSTOPPED)                           01618\n         DC    A(MJRPTPROCESSNOTSTOPPED)                                01619\n         ORG                                                            01620\nMJRPTPROCESSNOTSTOPPED DC C'The ptrace target process was not stopped ' 01621\n         DC    C'for ptrace'                                            01622\n         DC    X'00'                                                    01623\n         ORG   ETAB+(4*JRPTPROCESSTERM)                                 01624\n         DC    A(MJRPTPROCESSTERM)                                      01625\n         ORG                                                            01626\nMJRPTPROCESSTERM DC C'The ptrace target process ended'                  01627\n         DC    X'00'                                                    01628\n         ORG   ETAB+(4*JRPTRESTRICTEDPROCESS)                           01629\n         DC    A(MJRPTRESTRICTEDPROCESS)                                01630\n         ORG                                                            01631\nMJRPTRESTRICTEDPROCESS DC C'The ptrace target process is restricted fr' 01632\n         DC    C'om debugging'                                          01633\n         DC    X'00'                                                    01634\n         ORG   ETAB+(4*JRPTSIGINTERRUPT)                                01635\n         DC    A(MJRPTSIGINTERRUPT)                                     01636\n         ORG                                                            01637\nMJRPTSIGINTERRUPT DC C'The ptrace request was interrupted by a signal ' 01638\n         DC    C'for the debugger'                                      01639\n         DC    X'00'                                                    01640\n         ORG   ETAB+(4*JREXECPARMERR)                                   01641\n         DC    A(MJREXECPARMERR)                                        01642\n         ORG                                                            01643\nMJREXECPARMERR DC C'An error occurred when copying parameters passed t' 01644\n         DC    C'o the exec service'                                    01645\n         DC    X'00'                                                    01646\n         ORG   ETAB+(4*JRCHOWNTOPIPE)                                   01647\n         DC    A(MJRCHOWNTOPIPE)                                        01648\n         ORG                                                            01649\nMJRCHOWNTOPIPE DC C'The fchown service was issued against a pipe'       01650\n         DC    X'00'                                                    01651\n         ORG   ETAB+(4*JRCHAUDTOPIPE)                                   01652\n         DC    A(MJRCHAUDTOPIPE)                                        01653\n         ORG                                                            01654\nMJRCHAUDTOPIPE DC C'The fchaudit service was issued against a pipe'     01655\n         DC    X'00'                                                    01656\n         ORG   ETAB+(4*JRBADRBSTATE)                                    01657\n         DC    A(MJRBADRBSTATE)                                         01658\n         ORG                                                            01659\nMJRBADRBSTATE DC C'The caller apos.s request block state was incorrect' 01660\n         DC    X'00'                                                    01661\n         ORG   ETAB+(4*JRINVALIDSIGPROC)                                01662\n         DC    A(MJRINVALIDSIGPROC)                                     01663\n         ORG                                                            01664\nMJRINVALIDSIGPROC DC C'The mask address was incorrect'                  01665\n         DC    X'00'                                                    01666\n         ORG   ETAB+(4*JRBADALET)                                       01667\n         DC    A(MJRBADALET)                                            01668\n         ORG                                                            01669\nMJRBADALET DC C'An incorrect ALET was given as input'                   01670\n         DC    X'00'                                                    01671\n         ORG   ETAB+(4*JRQUIESCING)                                     01672\n         DC    A(MJRQUIESCING)                                          01673\n         ORG                                                            01674\nMJRQUIESCING DC C'The call did not complete.  The file system is unmou' 01675\n         DC    C'nting'                                                 01676\n         DC    X'00'                                                    01677\n         ORG   ETAB+(4*JRPTYINVALIDACTION)                              01678\n         DC    A(MJRPTYINVALIDACTION)                                   01679\n         ORG                                                            01680\nMJRPTYINVALIDACTION DC C'The action code is incorrect'                  01681\n         DC    X'00'                                                    01682\n         ORG   ETAB+(4*JRPTYINVALIDCCFLAG)                              01683\n         DC    A(MJRPTYINVALIDCCFLAG)                                   01684\n         ORG                                                            01685\nMJRPTYINVALIDCCFLAG DC C'The c_cflag bits are incorrect'                01686\n         DC    X'00'                                                    01687\n         ORG   ETAB+(4*JRPTYINVALIDCLFLAG)                              01688\n         DC    A(MJRPTYINVALIDCLFLAG)                                   01689\n         ORG                                                            01690\nMJRPTYINVALIDCLFLAG DC C'The c_lflag bits are incorrect'                01691\n         DC    X'00'                                                    01692\n         ORG   ETAB+(4*JRPTYINVALIDCIFLAG)                              01693\n         DC    A(MJRPTYINVALIDCIFLAG)                                   01694\n         ORG                                                            01695\nMJRPTYINVALIDCIFLAG DC C'The c_iflag bits are incorrect'                01696\n         DC    X'00'                                                    01697\n         ORG   ETAB+(4*JRPTYINVALIDCOFLAG)                              01698\n         DC    A(MJRPTYINVALIDCOFLAG)                                   01699\n         ORG                                                            01700\nMJRPTYINVALIDCOFLAG DC C'The c_oflag bits are incorrect'                01701\n         DC    X'00'                                                    01702\n         ORG   ETAB+(4*JRPTYINVALIDOUTBAUD)                             01703\n         DC    A(MJRPTYINVALIDOUTBAUD)                                  01704\n         ORG                                                            01705\nMJRPTYINVALIDOUTBAUD DC C'The output baud rate is incorrect'            01706\n         DC    X'00'                                                    01707\n         ORG   ETAB+(4*JRPTYINVALIDINBAUD)                              01708\n         DC    A(MJRPTYINVALIDINBAUD)                                   01709\n         ORG                                                            01710\nMJRPTYINVALIDINBAUD DC C'The input baud rate is incorrect'              01711\n         DC    X'00'                                                    01712\n         ORG   ETAB+(4*JRPTYBGCALL)                                     01713\n         DC    A(MJRPTYBGCALL)                                          01714\n         ORG                                                            01715\nMJRPTYBGCALL DC C'This is a background process'                         01716\n         DC    X'00'                                                    01717\n         ORG   ETAB+(4*JRINVIOCTLCMD)                                   01718\n         DC    A(MJRINVIOCTLCMD)                                        01719\n         ORG                                                            01720\nMJRINVIOCTLCMD DC C'The input command value is incorrect'               01721\n         DC    X'00'                                                    01722\n         ORG   ETAB+(4*JRPTYNOCNTLTERM)                                 01723\n         DC    A(MJRPTYNOCNTLTERM)                                      01724\n         ORG                                                            01725\nMJRPTYNOCNTLTERM DC C'The caller has no controlling terminal'           01726\n         DC    X'00'                                                    01727\n         ORG   ETAB+(4*JRPTYDIFFSESSION)                                01728\n         DC    A(MJRPTYDIFFSESSION)                                     01729\n         ORG                                                            01730\nMJRPTYDIFFSESSION DC C'This is not the caller apos.s controlling termi' 01731\n         DC    C'nal'                                                   01732\n         DC    X'00'                                                    01733\n         ORG   ETAB+(4*JRPTEDISAUTHORIZED)                              01734\n         DC    A(MJRPTEDISAUTHORIZED)                                   01735\n         ORG                                                            01736\nMJRPTEDISAUTHORIZED DC C'The ptrace debugged process is running in sup' 01737\n         DC    C'ervisor state'                                         01738\n         DC    X'00'                                                    01739\n         ORG   ETAB+(4*JRPTLDBUFFERTOOSMALL)                            01740\n         DC    A(MJRPTLDBUFFERTOOSMALL)                                 01741\n         ORG                                                            01742\nMJRPTLDBUFFERTOOSMALL DC C'The ptrace loader information request buffe' 01743\n         DC    C'r is too small'                                        01744\n         DC    X'00'                                                    01745\n         ORG   ETAB+(4*JRPTDBRPARENTEQUALSDBD)                          01746\n         DC    A(MJRPTDBRPARENTEQUALSDBD)                               01747\n         ORG                                                            01748\nMJRPTDBRPARENTEQUALSDBD DC C'The ptrace debugger parent PID is the sam' 01749\n         DC    C'e as debugged PID'                                     01750\n         DC    X'00'                                                    01751\n         ORG   ETAB+(4*JRPTYNOTPGLEADER)                                01752\n         DC    A(MJRPTYNOTPGLEADER)                                     01753\n         ORG                                                            01754\nMJRPTYNOTPGLEADER DC C'The process is not a process group leader'       01755\n         DC    X'00'                                                    01756\n         ORG   ETAB+(4*JRPTYNOTSLAVE)                                   01757\n         DC    A(MJRPTYNOTSLAVE)                                        01758\n         ORG                                                            01759\nMJRPTYNOTSLAVE DC C'Unsupported function against master TTY'            01760\n         DC    X'00'                                                    01761\n         ORG   ETAB+(4*JRPTYBADQUESEL)                                  01762\n         DC    A(MJRPTYBADQUESEL)                                       01763\n         ORG                                                            01764\nMJRPTYBADQUESEL DC C'The queue selector is not valid'                   01765\n         DC    X'00'                                                    01766\n         ORG   ETAB+(4*JRPTYNOSESSLEADER)                               01767\n         DC    A(MJRPTYNOSESSLEADER)                                    01768\n         ORG                                                            01769\nMJRPTYNOSESSLEADER DC C'The system is unable to locate the session lea' 01770\n         DC    C'der'                                                   01771\n         DC    X'00'                                                    01772\n         ORG   ETAB+(4*JRNOCTTY)                                        01773\n         DC    A(MJRNOCTTY)                                             01774\n         ORG                                                            01775\nMJRNOCTTY DC C'There is no controlling terminal for this process'       01776\n         DC    X'00'                                                    01777\n         ORG   ETAB+(4*JRPTYHUPCLCLOSE)                                 01778\n         DC    A(MJRPTYHUPCLCLOSE)                                      01779\n         ORG                                                            01780\nMJRPTYHUPCLCLOSE DC C'The slave pseudo-TTY file was previously closed ' 01781\n         DC    C'with the termios HUPCL flag set'                       01782\n         DC    X'00'                                                    01783\n         ORG   ETAB+(4*JRFSINUSE)                                       01784\n         DC    A(MJRFSINUSE)                                            01785\n         ORG                                                            01786\nMJRFSINUSE DC C'The requested file system is still in use'              01787\n         DC    X'00'                                                    01788\n         ORG   ETAB+(4*JRPTYINVALIDPGID)                                01789\n         DC    A(MJRPTYINVALIDPGID)                                     01790\n         ORG                                                            01791\nMJRPTYINVALIDPGID DC C'The requested process group ID is not valid'     01792\n         DC    X'00'                                                    01793\n         ORG   ETAB+(4*JRPTYNOTINSESSION)                               01794\n         DC    A(MJRPTYNOTINSESSION)                                    01795\n         ORG                                                            01796\nMJRPTYNOTINSESSION DC C'The process group ID (PGID) does not exist in ' 01797\n         DC    C'the caller apos.s session'                             01798\n         DC    X'00'                                                    01799\n         ORG   ETAB+(4*JRBRLMNOTACTIVE)                                 01800\n         DC    A(MJRBRLMNOTACTIVE)                                      01801\n         ORG                                                            01802\nMJRBRLMNOTACTIVE DC C'The byte-range lock manager is not active'        01803\n         DC    X'00'                                                    01804\n         ORG   ETAB+(4*JRBRLMFILELOCKRECYCLING)                         01805\n         DC    A(MJRBRLMFILELOCKRECYCLING)                              01806\n         ORG                                                            01807\nMJRBRLMFILELOCKRECYCLING DC C'File lock is being recycled. Do not use ' 01808\n         DC    C'until the file is closed by all users'                 01809\n         DC    X'00'                                                    01810\n         ORG   ETAB+(4*JRBRLMBADFILETYPE)                               01811\n         DC    A(MJRBRLMBADFILETYPE)                                    01812\n         ORG                                                            01813\nMJRBRLMBADFILETYPE DC C'Byte-range locking can be performed only on re' 01814\n         DC    C'gular files'                                           01815\n         DC    X'00'                                                    01816\n         ORG   ETAB+(4*JRBRLMNOREADACCESS)                              01817\n         DC    A(MJRBRLMNOREADACCESS)                                   01818\n         ORG                                                            01819\nMJRBRLMNOREADACCESS DC C'Shared byte-range locks are only for files op' 01820\n         DC    C'en for read'                                           01821\n         DC    X'00'                                                    01822\n         ORG   ETAB+(4*JRBRLMNOWRITEACCESS)                             01823\n         DC    A(MJRBRLMNOWRITEACCESS)                                  01824\n         ORG                                                            01825\nMJRBRLMNOWRITEACCESS DC C'Exclusive byte-range locks are only for file' 01826\n         DC    C's open for write'                                      01827\n         DC    X'00'                                                    01828\n         ORG   ETAB+(4*JRBRLMBADL_TYPE)                                 01829\n         DC    A(MJRBRLMBADL_TYPE)                                      01830\n         ORG                                                            01831\nMJRBRLMBADL_TYPE DC C'A byte-range lock request specified an l_type th' 01832\n         DC    C'at is not valid'                                       01833\n         DC    X'00'                                                    01834\n         ORG   ETAB+(4*JRBRLMINVALIDRANGE)                              01835\n         DC    A(MJRBRLMINVALIDRANGE)                                   01836\n         ORG                                                            01837\nMJRBRLMINVALIDRANGE DC C'A byte-range lock extends to before the start' 01838\n         DC    C' of the file'                                          01839\n         DC    X'00'                                                    01840\n         ORG   ETAB+(4*JRBRLMBADL_WHENCE)                               01841\n         DC    A(MJRBRLMBADL_WHENCE)                                    01842\n         ORG                                                            01843\nMJRBRLMBADL_WHENCE DC C'A byte-range lock request specified an l_whenc' 01844\n         DC    C'e that is not valid'                                   01845\n         DC    X'00'                                                    01846\n         ORG   ETAB+(4*JRBRLMRANGENOTAVAILABLE)                         01847\n         DC    A(MJRBRLMRANGENOTAVAILABLE)                              01848\n         ORG                                                            01849\nMJRBRLMRANGENOTAVAILABLE DC C'All or part of requested range is held b' 01850\n         DC    C'y another user'                                        01851\n         DC    X'00'                                                    01852\n         ORG   ETAB+(4*JRBRLMDEADLOCKDETECTED)                          01853\n         DC    A(MJRBRLMDEADLOCKDETECTED)                               01854\n         ORG                                                            01855\nMJRBRLMDEADLOCKDETECTED DC C'Waiting on the specified range causes a d' 01856\n         DC    C'eadlock'                                               01857\n         DC    X'00'                                                    01858\n         ORG   ETAB+(4*JRBRLMSIGNALPOSTED)                              01859\n         DC    A(MJRBRLMSIGNALPOSTED)                                   01860\n         ORG                                                            01861\nMJRBRLMSIGNALPOSTED DC C'While the process was waiting for a byte-rang' 01862\n         DC    C'e lock, a signal was posted'                           01863\n         DC    X'00'                                                    01864\n         ORG   ETAB+(4*JRBRLMBADL_LEN)                                  01865\n         DC    A(MJRBRLMBADL_LEN)                                       01866\n         ORG                                                            01867\nMJRBRLMBADL_LEN DC C'A byte-range lock request specified an incorrect ' 01868\n         DC    C'l_len'                                                 01869\n         DC    X'00'                                                    01870\n         ORG   ETAB+(4*JRREADUSERSTORAGEFAILED)                         01871\n         DC    A(MJRREADUSERSTORAGEFAILED)                              01872\n         ORG                                                            01873\nMJRREADUSERSTORAGEFAILED DC C'A read error occurred on the user data a' 01874\n         DC    C'rea passed to the service'                             01875\n         DC    X'00'                                                    01876\n         ORG   ETAB+(4*JRWRITEUSERSTORAGEFAILED)                        01877\n         DC    A(MJRWRITEUSERSTORAGEFAILED)                             01878\n         ORG                                                            01879\nMJRWRITEUSERSTORAGEFAILED DC C'A write error occurred on the user data' 01880\n         DC    C' area passed to the service'                           01881\n         DC    X'00'                                                    01882\n         ORG   ETAB+(4*JRBRLMALREADYWAITING)                            01883\n         DC    A(MJRBRLMALREADYWAITING)                                 01884\n         ORG                                                            01885\nMJRBRLMALREADYWAITING DC C'Request includes a range already being wait' 01886\n         DC    C'ed on'                                                 01887\n         DC    X'00'                                                    01888\n         ORG   ETAB+(4*JRBRLMPROMOTEPENDING)                            01889\n         DC    A(MJRBRLMPROMOTEPENDING)                                 01890\n         ORG                                                            01891\nMJRBRLMPROMOTEPENDING DC C'Another user is waiting to promote the requ' 01892\n         DC    C'ested range'                                           01893\n         DC    X'00'                                                    01894\n         ORG   ETAB+(4*JRPTYNOPTYRSTORAGE)                              01895\n         DC    A(MJRPTYNOPTYRSTORAGE)                                   01896\n         ORG                                                            01897\nMJRPTYNOPTYRSTORAGE DC C'There is not enough storage in the kernel add' 01898\n         DC    C'ress space'                                            01899\n         DC    X'00'                                                    01900\n         ORG   ETAB+(4*JRBRLMPROCESSBROKEN)                             01901\n         DC    A(MJRBRLMPROCESSBROKEN)                                  01902\n         ORG                                                            01903\nMJRBRLMPROCESSBROKEN DC C'This process has been marked broken for byte' 01904\n         DC    C' locking'                                              01905\n         DC    X'00'                                                    01906\n         ORG   ETAB+(4*JRPTYCONNECTIONINOP)                             01907\n         DC    A(MJRPTYCONNECTIONINOP)                                  01908\n         ORG                                                            01909\nMJRPTYCONNECTIONINOP DC C'The pseudo-TTY connection is inoperative'     01910\n         DC    X'00'                                                    01911\n         ORG   ETAB+(4*JRBRLMUNLOCKWHILEWAIT)                           01912\n         DC    A(MJRBRLMUNLOCKWHILEWAIT)                                01913\n         ORG                                                            01914\nMJRBRLMUNLOCKWHILEWAIT DC C'The unlock service is not valid while the ' 01915\n         DC    C'process is waiting for a lock'                         01916\n         DC    X'00'                                                    01917\n         ORG   ETAB+(4*JRBRLMOBJANDPROCBROKEN)                          01918\n         DC    A(MJRBRLMOBJANDPROCBROKEN)                               01919\n         ORG                                                            01920\nMJRBRLMOBJANDPROCBROKEN DC C'The object and process are marked broken ' 01921\n         DC    C'for byte locking'                                      01922\n         DC    X'00'                                                    01923\n         ORG   ETAB+(4*JRFD2TOOSMALL)                                   01924\n         DC    A(MJRFD2TOOSMALL)                                        01925\n         ORG                                                            01926\nMJRFD2TOOSMALL DC C'The second file descriptor cannot be smaller than ' 01927\n         DC    C'the first'                                             01928\n         DC    X'00'                                                    01929\n         ORG   ETAB+(4*JRNOTAUTHORIZED)                                 01930\n         DC    A(MJRNOTAUTHORIZED)                                      01931\n         ORG                                                            01932\nMJRNOTAUTHORIZED DC C'Unauthorized caller of BPX1PTC in an authorized ' 01933\n         DC    C'environment'                                           01934\n         DC    X'00'                                                    01935\n         ORG   ETAB+(4*JRPTATEYE)                                       01936\n         DC    A(MJRPTATEYE)                                            01937\n         ORG                                                            01938\nMJRPTATEYE DC C'The pthread attribute area contains an incorrect eyeca' 01939\n         DC    C'tcher'                                                 01940\n         DC    X'00'                                                    01941\n         ORG   ETAB+(4*JRPTATADDRERROR)                                 01942\n         DC    A(MJRPTATADDRERROR)                                      01943\n         ORG                                                            01944\nMJRPTATADDRERROR DC C'The pthread attribute area address is incorrect'  01945\n         DC    X'00'                                                    01946\n         ORG   ETAB+(4*JRPTCNOTSUPP)                                    01947\n         DC    A(MJRPTCNOTSUPP)                                         01948\n         ORG                                                            01949\nMJRPTCNOTSUPP DC C'BPX1PTC is not supported from the calling task'      01950\n         DC    X'00'                                                    01951\n         ORG   ETAB+(4*JRALLFILESNOTCLOSED)                             01952\n         DC    A(MJRALLFILESNOTCLOSED)                                  01953\n         ORG                                                            01954\nMJRALLFILESNOTCLOSED DC C'All requested files were not closed'          01955\n         DC    X'00'                                                    01956\n         ORG   ETAB+(4*JREXITRTNERROR)                                  01957\n         DC    A(MJREXITRTNERROR)                                       01958\n         ORG                                                            01959\nMJREXITRTNERROR DC C'An error occurred in the user exit called by the ' 01960\n         DC    C'exec'                                                  01961\n         DC    X'00'                                                    01962\n         ORG   ETAB+(4*JRTHREADTERM)                                    01963\n         DC    A(MJRTHREADTERM)                                         01964\n         ORG                                                            01965\nMJRTHREADTERM DC C'The service was rejected because the requesting thr' 01966\n         DC    C'ead is terminating'                                    01967\n         DC    X'00'                                                    01968\n         ORG   ETAB+(4*JRLIGHTWEIGHTTHID)                               01969\n         DC    A(MJRLIGHTWEIGHTTHID)                                    01970\n         ORG                                                            01971\nMJRLIGHTWEIGHTTHID DC C'The thread specified is a lightweight thread'   01972\n         DC    X'00'                                                    01973\n         ORG   ETAB+(4*JRALREADYDETACHED)                               01974\n         DC    A(MJRALREADYDETACHED)                                    01975\n         ORG                                                            01976\nMJRALREADYDETACHED DC C'The thread specified is already detached'       01977\n         DC    X'00'                                                    01978\n         ORG   ETAB+(4*JRTHREADNOTFOUND)                                01979\n         DC    A(MJRTHREADNOTFOUND)                                     01980\n         ORG                                                            01981\nMJRTHREADNOTFOUND DC C'The thread specified was not found'              01982\n         DC    X'00'                                                    01983\n         ORG   ETAB+(4*JRHEAVYWEIGHT)                                   01984\n         DC    A(MJRHEAVYWEIGHT)                                        01985\n         ORG                                                            01986\nMJRHEAVYWEIGHT DC C'The new thread was not started and the existing th' 01987\n         DC    C'read is a heavyweight thread'                          01988\n         DC    X'00'                                                    01989\n         ORG   ETAB+(4*JRGETFIRST)                                      01990\n         DC    A(MJRGETFIRST)                                           01991\n         ORG                                                            01992\nMJRGETFIRST DC C'The first call did not specify PTGetNewThread'         01993\n         DC    X'00'                                                    01994\n         ORG   ETAB+(4*JRALREADYJOINED)                                 01995\n         DC    A(MJRALREADYJOINED)                                      01996\n         ORG                                                            01997\nMJRALREADYJOINED DC C'The thread specified was already joined by anoth' 01998\n         DC    C'er thread'                                             01999\n         DC    X'00'                                                    02000\n         ORG   ETAB+(4*JRJOINEXITSTATPTR)                               02001\n         DC    A(MJRJOINEXITSTATPTR)                                    02002\n         ORG                                                            02003\nMJRJOINEXITSTATPTR DC C'The address of the exit status parameter is no' 02004\n         DC    C't correct'                                             02005\n         DC    X'00'                                                    02006\n         ORG   ETAB+(4*JRJOINTOSELF)                                    02007\n         DC    A(MJRJOINTOSELF)                                         02008\n         ORG                                                            02009\nMJRJOINTOSELF DC C'The thread attempted to join to itself'              02010\n         DC    X'00'                                                    02011\n         ORG   ETAB+(4*JRJOINLOOP)                                      02012\n         DC    A(MJRJOINLOOP)                                           02013\n         ORG                                                            02014\nMJRJOINLOOP DC C'The connection would result in thread waiting for its' 02015\n         DC    C'elf'                                                   02016\n         DC    X'00'                                                    02017\n         ORG   ETAB+(4*JRALREADYPTEXITED)                               02018\n         DC    A(MJRALREADYPTEXITED)                                    02019\n         ORG                                                            02020\nMJRALREADYPTEXITED DC C'The calling thread has already been exited thr' 02021\n         DC    C'ough a call to the BPX1PTX service'                    02022\n         DC    X'00'                                                    02023\n         ORG   ETAB+(4*JRALREADYTERMINATED)                             02024\n         DC    A(MJRALREADYTERMINATED)                                  02025\n         ORG                                                            02026\nMJRALREADYTERMINATED DC C'The thread specified has already ended'       02027\n         DC    X'00'                                                    02028\n         ORG   ETAB+(4*JRBROKENBRLMRECYCLING)                           02029\n         DC    A(MJRBROKENBRLMRECYCLING)                                02030\n         ORG                                                            02031\nMJRBROKENBRLMRECYCLING DC C'The byte-range-lock manager is broken and ' 02032\n         DC    C'is currently recycling'                                02033\n         DC    X'00'                                                    02034\n         ORG   ETAB+(4*JRPTATSYSOFF)                                    02035\n         DC    A(MJRPTATSYSOFF)                                         02036\n         ORG                                                            02037\nMJRPTATSYSOFF DC C'The system offset value in the pthread attribute ar' 02038\n         DC    C'ea is incorrect'                                       02039\n         DC    X'00'                                                    02040\n         ORG   ETAB+(4*JRPTATSYSLEN)                                    02041\n         DC    A(MJRPTATSYSLEN)                                         02042\n         ORG                                                            02043\nMJRPTATSYSLEN DC C'The system length value in the pthread attribute ar' 02044\n         DC    C'ea is incorrect'                                       02045\n         DC    X'00'                                                    02046\n         ORG   ETAB+(4*JRPTATLEN)                                       02047\n         DC    A(MJRPTATLEN)                                            02048\n         ORG                                                            02049\nMJRPTATLEN DC C'The total length value in the pthread attribute area i' 02050\n         DC    C's incorrect'                                           02051\n         DC    X'00'                                                    02052\n         ORG   ETAB+(4*JRRMGWRONGDATALEN)                               02053\n         DC    A(MJRRMGWRONGDATALEN)                                    02054\n         ORG                                                            02055\nMJRRMGWRONGDATALEN DC C'Resource data area length is not correct for t' 02056\n         DC    C'his release'                                           02057\n         DC    X'00'                                                    02058\n         ORG   ETAB+(4*JRINVOPTION)                                     02059\n         DC    A(MJRINVOPTION)                                          02060\n         ORG                                                            02061\nMJRINVOPTION DC C'Incorrect option specified on call to BPX1PTX'        02062\n         DC    X'00'                                                    02063\n         ORG   ETAB+(4*JRINITRTN)                                       02064\n         DC    A(MJRINITRTN)                                            02065\n         ORG                                                            02066\nMJRINITRTN DC C'The initialization routine is not valid for the curren' 02067\n         DC    C't environment'                                         02068\n         DC    X'00'                                                    02069\n         ORG   ETAB+(4*JRPTATWEIGHT)                                    02070\n         DC    A(MJRPTATWEIGHT)                                         02071\n         ORG                                                            02072\nMJRPTATWEIGHT DC C'The pthread attribute area contains an incorrect we' 02073\n         DC    C'ight value'                                            02074\n         DC    X'00'                                                    02075\n         ORG   ETAB+(4*JRPTATSYNCTYPE)                                  02076\n         DC    A(MJRPTATSYNCTYPE)                                       02077\n         ORG                                                            02078\nMJRPTATSYNCTYPE DC C'The pthread attribute area contains an incorrect ' 02079\n         DC    C'Sync Type value'                                       02080\n         DC    X'00'                                                    02081\n         ORG   ETAB+(4*JRPTATDETACHSTATE)                               02082\n         DC    A(MJRPTATDETACHSTATE)                                    02083\n         ORG                                                            02084\nMJRPTATDETACHSTATE DC C'The pthread attribute area contains an incorre' 02085\n         DC    C'ct detach state value'                                 02086\n         DC    X'00'                                                    02087\n         ORG   ETAB+(4*JRNOSUCHPID)                                     02088\n         DC    A(MJRNOSUCHPID)                                          02089\n         ORG                                                            02090\nMJRNOSUCHPID DC C'The process ID is incorrect'                          02091\n         DC    X'00'                                                    02092\n         ORG   ETAB+(4*JRPIDEQSESSLEADER)                               02093\n         DC    A(MJRPIDEQSESSLEADER)                                    02094\n         ORG                                                            02095\nMJRPIDEQSESSLEADER DC C'The process ID is a session leader'             02096\n         DC    X'00'                                                    02097\n         ORG   ETAB+(4*JRTOOMANY)                                       02098\n         DC    A(MJRTOOMANY)                                            02099\n         ORG                                                            02100\nMJRTOOMANY DC C'The event list specified contained more than one event' 02101\n         DC    X'00'                                                    02102\n         ORG   ETAB+(4*JRPIDDIFFERENTSESSION)                           02103\n         DC    A(MJRPIDDIFFERENTSESSION)                                02104\n         ORG                                                            02105\nMJRPIDDIFFERENTSESSION DC C'The process ID is in a session different f' 02106\n         DC    C'rom the caller'                                        02107\n         DC    X'00'                                                    02108\n         ORG   ETAB+(4*JREXECAFTERFORK)                                 02109\n         DC    A(MJREXECAFTERFORK)                                      02110\n         ORG                                                            02111\nMJREXECAFTERFORK DC C'The process ID was called by the exec service af' 02112\n         DC    C'ter the fork service'                                  02113\n         DC    X'00'                                                    02114\n         ORG   ETAB+(4*JRTIMEOUTNOTAUTH)                                02115\n         DC    A(MJRTIMEOUTNOTAUTH)                                     02116\n         ORG                                                            02117\nMJRTIMEOUTNOTAUTH DC C'The caller to BPX1CPO service specified the CW_' 02118\n         DC    C'TIMEOUT event but is not authorized'                   02119\n         DC    X'00'                                                    02120\n         ORG   ETAB+(4*JRNOTDESCENDANT)                                 02121\n         DC    A(MJRNOTDESCENDANT)                                      02122\n         ORG                                                            02123\nMJRNOTDESCENDANT DC C'The process ID is not an immediate descendant of' 02124\n         DC    C' the caller.'                                          02125\n         DC    X'00'                                                    02126\n         ORG   ETAB+(4*JRPGIDDIFFERENTSESSION)                          02127\n         DC    A(MJRPGIDDIFFERENTSESSION)                               02128\n         ORG                                                            02129\nMJRPGIDDIFFERENTSESSION DC C'Process group ID is in a session differen' 02130\n         DC    C't from the caller'                                     02131\n         DC    X'00'                                                    02132\n         ORG   ETAB+(4*JRCALLERISPGLEADER)                              02133\n         DC    A(MJRCALLERISPGLEADER)                                   02134\n         ORG                                                            02135\nMJRCALLERISPGLEADER DC C'The caller is already a process group leader'  02136\n         DC    X'00'                                                    02137\n         ORG   ETAB+(4*JRNULLMASK)                                      02138\n         DC    A(MJRNULLMASK)                                           02139\n         ORG                                                            02140\nMJRNULLMASK DC C'The caller specified a null signal mask'               02141\n         DC    X'00'                                                    02142\n         ORG   ETAB+(4*JRRDLBUFFLENINVALID)                             02143\n         DC    A(MJRRDLBUFFLENINVALID)                                  02144\n         ORG                                                            02145\nMJRRDLBUFFLENINVALID DC C'The length of the buffer is less than zero'   02146\n         DC    X'00'                                                    02147\n         ORG   ETAB+(4*JRPSWKEYNOTVALID)                                02148\n         DC    A(MJRPSWKEYNOTVALID)                                     02149\n         ORG                                                            02150\nMJRPSWKEYNOTVALID DC C'The PSW key of the caller is not a valid key'    02151\n         DC    X'00'                                                    02152\n         ORG   ETAB+(4*JRALREADYSIGSETUP)                               02153\n         DC    A(MJRALREADYSIGSETUP)                                    02154\n         ORG                                                            02155\nMJRALREADYSIGSETUP DC C'BPX1MSS found the process already set up for s' 02156\n         DC    C'ignals'                                                02157\n         DC    X'00'                                                    02158\n         ORG   ETAB+(4*JRNOTSIGSETUP)                                   02159\n         DC    A(MJRNOTSIGSETUP)                                        02160\n         ORG                                                            02161\nMJRNOTSIGSETUP DC C'The service found the current task was not set up ' 02162\n         DC    C'for signals'                                           02163\n         DC    X'00'                                                    02164\n         ORG   ETAB+(4*JRENDINGSLASHSYMLINK)                            02165\n         DC    A(MJRENDINGSLASHSYMLINK)                                 02166\n         ORG                                                            02167\nMJRENDINGSLASHSYMLINK DC C'The pathname ended with slash on the symlin' 02168\n         DC    C'k service'                                             02169\n         DC    X'00'                                                    02170\n         ORG   ETAB+(4*JRUNDEFEVENTS)                                   02171\n         DC    A(MJRUNDEFEVENTS)                                        02172\n         ORG                                                            02173\nMJRUNDEFEVENTS DC C'The specified event list contains undefined events' 02174\n         DC    X'00'                                                    02175\n         ORG   ETAB+(4*JRNOEVENTS)                                      02176\n         DC    A(MJRNOEVENTS)                                           02177\n         ORG                                                            02178\nMJRNOEVENTS DC C'The specified event list is zero'                      02179\n         DC    X'00'                                                    02180\n         ORG   ETAB+(4*JRIPTCANNOTLEAVE)                                02181\n         DC    A(MJRIPTCANNOTLEAVE)                                     02182\n         ORG                                                            02183\nMJRIPTCANNOTLEAVE DC C'The caller has daughter tasks. Termination is d' 02184\n         DC    C'enied'                                                 02185\n         DC    X'00'                                                    02186\n         ORG   ETAB+(4*JRNOTSETUP)                                      02187\n         DC    A(MJRNOTSETUP)                                           02188\n         ORG                                                            02189\nMJRNOTSETUP DC C'The thread is not set up for cond_wait or cond_timed_' 02190\n         DC    C'wait'                                                  02191\n         DC    X'00'                                                    02192\n         ORG   ETAB+(4*JRALREADYSETUP)                                  02193\n         DC    A(MJRALREADYSETUP)                                       02194\n         ORG                                                            02195\nMJRALREADYSETUP DC C'The thread is already set up for cond_setup, cond' 02196\n         DC    C'_wait, or cond_timed_wait'                             02197\n         DC    X'00'                                                    02198\n         ORG   ETAB+(4*JROUTOFRANGE)                                    02199\n         DC    A(MJROUTOFRANGE)                                         02200\n         ORG                                                            02201\nMJROUTOFRANGE DC C'The value specified for a parameter is outside the ' 02202\n         DC    C'allowable range'                                       02203\n         DC    X'00'                                                    02204\n         ORG   ETAB+(4*JRNANOSECONDSTOOBIG)                             02205\n         DC    A(MJRNANOSECONDSTOOBIG)                                  02206\n         ORG                                                            02207\nMJRNANOSECONDSTOOBIG DC C'The value specified for nanoseconds is outsi' 02208\n         DC    C'de the allowable range'                                02209\n         DC    X'00'                                                    02210\n         ORG   ETAB+(4*JRTIMEOUT)                                       02211\n         DC    A(MJRTIMEOUT)                                            02212\n         ORG                                                            02213\nMJRTIMEOUT DC C'The time for the service to wait has expired'           02214\n         DC    X'00'                                                    02215\n         ORG   ETAB+(4*JRDUP2ERROR)                                     02216\n         DC    A(MJRDUP2ERROR)                                          02217\n         ORG                                                            02218\nMJRDUP2ERROR DC C'A problem occurred with the requested file descripto' 02219\n         DC    C'r'                                                     02220\n         DC    X'00'                                                    02221\n         ORG   ETAB+(4*JRACCEPT)                                        02222\n         DC    A(MJRACCEPT)                                             02223\n         ORG                                                            02224\nMJRACCEPT DC C'Vnode operation accept is not supported by this file sy' 02225\n         DC    C'stem'                                                  02226\n         DC    X'00'                                                    02227\n         ORG   ETAB+(4*JRBIND)                                          02228\n         DC    A(MJRBIND)                                               02229\n         ORG                                                            02230\nMJRBIND DC C'Vnode operation bind is not supported by this file system' 02231\n         DC    X'00'                                                    02232\n         ORG   ETAB+(4*JRCONNECT)                                       02233\n         DC    A(MJRCONNECT)                                            02234\n         ORG                                                            02235\nMJRCONNECT DC C'Vnode operation connect is not supported by this file ' 02236\n         DC    C'system'                                                02237\n         DC    X'00'                                                    02238\n         ORG   ETAB+(4*JRGETHOST)                                       02239\n         DC    A(MJRGETHOST)                                            02240\n         ORG                                                            02241\nMJRGETHOST DC C'Vnode operation gethost is not supported by this file ' 02242\n         DC    C'system'                                                02243\n         DC    X'00'                                                    02244\n         ORG   ETAB+(4*JRGETNAME)                                       02245\n         DC    A(MJRGETNAME)                                            02246\n         ORG                                                            02247\nMJRGETNAME DC C'Vnode operation getname is not supported by this file ' 02248\n         DC    C'system'                                                02249\n         DC    X'00'                                                    02250\n         ORG   ETAB+(4*JRSOCKOPT)                                       02251\n         DC    A(MJRSOCKOPT)                                            02252\n         ORG                                                            02253\nMJRSOCKOPT DC C'Vnode operation sockopt is not supported by this file ' 02254\n         DC    C'system'                                                02255\n         DC    X'00'                                                    02256\n         ORG   ETAB+(4*JRLISTEN)                                        02257\n         DC    A(MJRLISTEN)                                             02258\n         ORG                                                            02259\nMJRLISTEN DC C'Vnode operation listen is not supported by this file sy' 02260\n         DC    C'stem'                                                  02261\n         DC    X'00'                                                    02262\n         ORG   ETAB+(4*JRREADWRITEV)                                    02263\n         DC    A(MJRREADWRITEV)                                         02264\n         ORG                                                            02265\nMJRREADWRITEV DC C'Vnode operation readwritev is not supported by this' 02266\n         DC    C' file system'                                          02267\n         DC    X'00'                                                    02268\n         ORG   ETAB+(4*JRSNDRCV)                                        02269\n         DC    A(MJRSNDRCV)                                             02270\n         ORG                                                            02271\nMJRSNDRCV DC C'Vnode operation sndrcv is not supported by this file sy' 02272\n         DC    C'stem'                                                  02273\n         DC    X'00'                                                    02274\n         ORG   ETAB+(4*JRSNDTORCVFM)                                    02275\n         DC    A(MJRSNDTORCVFM)                                         02276\n         ORG                                                            02277\nMJRSNDTORCVFM DC C'Vnode operation sndtorcvfm is not supported by this' 02278\n         DC    C' file system'                                          02279\n         DC    X'00'                                                    02280\n         ORG   ETAB+(4*JRSRMSG)                                         02281\n         DC    A(MJRSRMSG)                                              02282\n         ORG                                                            02283\nMJRSRMSG DC C'Vnode operation srmsg is not supported by this file syst' 02284\n         DC    C'em'                                                    02285\n         DC    X'00'                                                    02286\n         ORG   ETAB+(4*JRSELECT)                                        02287\n         DC    A(MJRSELECT)                                             02288\n         ORG                                                            02289\nMJRSELECT DC C'Vnode operation select is not supported by this file sy' 02290\n         DC    C'stem'                                                  02291\n         DC    X'00'                                                    02292\n         ORG   ETAB+(4*JRSETPEER)                                       02293\n         DC    A(MJRSETPEER)                                            02294\n         ORG                                                            02295\nMJRSETPEER DC C'Vnode operation setpeer is not supported by this file ' 02296\n         DC    C'system'                                                02297\n         DC    X'00'                                                    02298\n         ORG   ETAB+(4*JRSHUTDOWN)                                      02299\n         DC    A(MJRSHUTDOWN)                                           02300\n         ORG                                                            02301\nMJRSHUTDOWN DC C'Vnode operation shutdown is not supported by this fil' 02302\n         DC    C'e system'                                              02303\n         DC    X'00'                                                    02304\n         ORG   ETAB+(4*JRSOCKET)                                        02305\n         DC    A(MJRSOCKET)                                             02306\n         ORG                                                            02307\nMJRSOCKET DC C'VFS operation socket is not supported by this file syst' 02308\n         DC    C'em'                                                    02309\n         DC    X'00'                                                    02310\n         ORG   ETAB+(4*JRNOSOCKET)                                      02311\n         DC    A(MJRNOSOCKET)                                           02312\n         ORG                                                            02313\nMJRNOSOCKET DC C'The requested operation cannot be performed on a sock' 02314\n         DC    C'et file descriptor'                                    02315\n         DC    X'00'                                                    02316\n         ORG   ETAB+(4*JRMUSTBESOCKET)                                  02317\n         DC    A(MJRMUSTBESOCKET)                                       02318\n         ORG                                                            02319\nMJRMUSTBESOCKET DC C'The requested operation is only valid on a socket' 02320\n         DC    C' file descriptor'                                      02321\n         DC    X'00'                                                    02322\n         ORG   ETAB+(4*JRTARGETENDING)                                  02323\n         DC    A(MJRTARGETENDING)                                       02324\n         ORG                                                            02325\nMJRTARGETENDING DC C'The target process is ending'                      02326\n         DC    X'00'                                                    02327\n         ORG   ETAB+(4*JRQUIESCETYPEINVALID)                            02328\n         DC    A(MJRQUIESCETYPEINVALID)                                 02329\n         ORG                                                            02330\nMJRQUIESCETYPEINVALID DC C'The quiescetype specified by the caller is ' 02331\n         DC    C'invalid'                                               02332\n         DC    X'00'                                                    02333\n         ORG   ETAB+(4*JRLASTTHREAD)                                    02334\n         DC    A(MJRLASTTHREAD)                                         02335\n         ORG                                                            02336\nMJRLASTTHREAD DC C'The last pthread is exiting when the PTFAILIFLASTTH' 02337\n         DC    C'READ option is specified'                              02338\n         DC    X'00'                                                    02339\n         ORG   ETAB+(4*JRDOMAINNOTSUPPORTED)                            02340\n         DC    A(MJRDOMAINNOTSUPPORTED)                                 02341\n         ORG                                                            02342\nMJRDOMAINNOTSUPPORTED DC C'The requested domain is not supported'       02343\n         DC    X'00'                                                    02344\n         ORG   ETAB+(4*JRNETWORK)                                       02345\n         DC    A(MJRNETWORK)                                            02346\n         ORG                                                            02347\nMJRNETWORK DC C'Vfs operation network is not supported by this file sy' 02348\n         DC    C'stem'                                                  02349\n         DC    X'00'                                                    02350\n         ORG   ETAB+(4*JROUTOFVDECELLS)                                 02351\n         DC    A(MJROUTOFVDECELLS)                                      02352\n         ORG                                                            02353\nMJROUTOFVDECELLS DC C'All Vde cells have been allocated'                02354\n         DC    X'00'                                                    02355\n         ORG   ETAB+(4*JRTOKENMAX)                                      02356\n         DC    A(MJRTOKENMAX)                                           02357\n         ORG                                                            02358\nMJRTOKENMAX DC C'The maximum number of Vnode tokens have been allocate' 02359\n         DC    C'd for this process'                                    02360\n         DC    X'00'                                                    02361\n         ORG   ETAB+(4*JRVTOKENFREED)                                   02362\n         DC    A(MJRVTOKENFREED)                                        02363\n         ORG                                                            02364\nMJRVTOKENFREED DC C'The Vnode token has already been released'          02365\n         DC    X'00'                                                    02366\n         ORG   ETAB+(4*JRWRONGPID)                                      02367\n         DC    A(MJRWRONGPID)                                           02368\n         ORG                                                            02369\nMJRWRONGPID DC C'The process does not own this Vde'                     02370\n         DC    X'00'                                                    02371\n         ORG   ETAB+(4*JRSTALEVNODETOK)                                 02372\n         DC    A(MJRSTALEVNODETOK)                                      02373\n         ORG                                                            02374\nMJRSTALEVNODETOK DC C'The Vnode token is stale'                         02375\n         DC    X'00'                                                    02376\n         ORG   ETAB+(4*JRINVALIDVNODETOK)                               02377\n         DC    A(MJRINVALIDVNODETOK)                                    02378\n         ORG                                                            02379\nMJRINVALIDVNODETOK DC C'The Vnode token does not point to a Vde'        02380\n         DC    X'00'                                                    02381\n         ORG   ETAB+(4*JRNOTREGISTEREDSERVER)                           02382\n         DC    A(MJRNOTREGISTEREDSERVER)                                02383\n         ORG                                                            02384\nMJRNOTREGISTEREDSERVER DC C'The process is not a registered server'     02385\n         DC    X'00'                                                    02386\n         ORG   ETAB+(4*JRINVALIDREGTYPE)                                02387\n         DC    A(MJRINVALIDREGTYPE)                                     02388\n         ORG                                                            02389\nMJRINVALIDREGTYPE DC C'The server type supplied in NRegSType is not va' 02390\n         DC    C'lid'                                                   02391\n         DC    X'00'                                                    02392\n         ORG   ETAB+(4*JRNAMETOOLONG)                                   02393\n         DC    A(MJRNAMETOOLONG)                                        02394\n         ORG                                                            02395\nMJRNAMETOOLONG DC C'The name supplied is longer than the allowed maxim' 02396\n         DC    C'um'                                                    02397\n         DC    X'00'                                                    02398\n         ORG   ETAB+(4*JRALREADYREGISTERED)                             02399\n         DC    A(MJRALREADYREGISTERED)                                  02400\n         ORG                                                            02401\nMJRALREADYREGISTERED DC C'The process is already registered as a serve' 02402\n         DC    C'r'                                                     02403\n         DC    X'00'                                                    02404\n         ORG   ETAB+(4*JRINVALIDNREG)                                   02405\n         DC    A(MJRINVALIDNREG)                                        02406\n         ORG                                                            02407\nMJRINVALIDNREG DC C'An incorrect NReg parameter list was passed'        02408\n         DC    X'00'                                                    02409\n         ORG   ETAB+(4*JRNOLEADINGSLASH)                                02410\n         DC    A(MJRNOLEADINGSLASH)                                     02411\n         ORG                                                            02412\nMJRNOLEADINGSLASH DC C'The pathname does not begin with /'              02413\n         DC    X'00'                                                    02414\n         ORG   ETAB+(4*JRSTALEVFSTOK)                                   02415\n         DC    A(MJRSTALEVFSTOK)                                        02416\n         ORG                                                            02417\nMJRSTALEVFSTOK DC C'The VFS token is stale'                             02418\n         DC    X'00'                                                    02419\n         ORG   ETAB+(4*JRSMALLATTR)                                     02420\n         DC    A(MJRSMALLATTR)                                          02421\n         ORG                                                            02422\nMJRSMALLATTR DC C'The Attr length parameter was too small'              02423\n         DC    X'00'                                                    02424\n         ORG   ETAB+(4*JRSMALLMNTE)                                     02425\n         DC    A(MJRSMALLMNTE)                                          02426\n         ORG                                                            02427\nMJRSMALLMNTE DC C'The Mnte length parameter was too small'              02428\n         DC    X'00'                                                    02429\n         ORG   ETAB+(4*JRRWNOTREGFILE)                                  02430\n         DC    A(MJRRWNOTREGFILE)                                       02431\n         ORG                                                            02432\nMJRRWNOTREGFILE DC C'The rdwr call is valid only on a regular file'     02433\n         DC    X'00'                                                    02434\n         ORG   ETAB+(4*JRDUBSETTING)                                    02435\n         DC    A(MJRDUBSETTING)                                         02436\n         ORG                                                            02437\nMJRDUBSETTING DC C'The dub setting value specified on the BPX1SDD serv' 02438\n         DC    C'ice call is not correct'                               02439\n         DC    X'00'                                                    02440\n         ORG   ETAB+(4*JRINVALIDATT)                                    02441\n         DC    A(MJRINVALIDATT)                                         02442\n         ORG                                                            02443\nMJRINVALIDATT DC C'The Attribute structure passed to BPX1CHR or BPX1FC' 02444\n         DC    C'R was not valid'                                       02445\n         DC    X'00'                                                    02446\n         ORG   ETAB+(4*JRINVALIDOSS)                                    02447\n         DC    A(MJRINVALIDOSS)                                         02448\n         ORG                                                            02449\nMJRINVALIDOSS DC C'The OSS is not valid'                                02450\n         DC    X'00'                                                    02451\n         ORG   ETAB+(4*JRSMALLFSATTR)                                   02452\n         DC    A(MJRSMALLFSATTR)                                        02453\n         ORG                                                            02454\nMJRSMALLFSATTR DC C'The FSAttr length parameter was too small'          02455\n         DC    X'00'                                                    02456\n         ORG   ETAB+(4*JRAPFAUTHCHANGE)                                 02457\n         DC    A(MJRAPFAUTHCHANGE)                                      02458\n         ORG                                                            02459\nMJRAPFAUTHCHANGE DC C'A local process exec tried to change APF authori' 02460\n         DC    C'zation'                                                02461\n         DC    X'00'                                                    02462\n         ORG   ETAB+(4*JRIDCHANGE)                                      02463\n         DC    A(MJRIDCHANGE)                                           02464\n         ORG                                                            02465\nMJRIDCHANGE DC C'A local process exec tried to change the UID / GID   ' 02466\n         DC    C'   '                                                   02467\n         DC    X'00'                                                    02468\n         ORG   ETAB+(4*JROTHERPROCESSES)                                02469\n         DC    A(MJROTHERPROCESSES)                                     02470\n         ORG                                                            02471\nMJROTHERPROCESSES DC C'An exec was attempted that would terminate the ' 02472\n         DC    C'other processes in the address space'                  02473\n         DC    X'00'                                                    02474\n         ORG   ETAB+(4*JRPTREQUESTDENIED)                               02475\n         DC    A(MJRPTREQUESTDENIED)                                    02476\n         ORG                                                            02477\nMJRPTREQUESTDENIED DC C'The ptrace request is not allowed for the curr' 02478\n         DC    C'ent debugged program environment'                      02479\n         DC    X'00'                                                    02480\n         ORG   ETAB+(4*JRINVALIDFUIO)                                   02481\n         DC    A(MJRINVALIDFUIO)                                        02482\n         ORG                                                            02483\nMJRINVALIDFUIO DC C'An incorrect FUio area was passed'                  02484\n         DC    X'00'                                                    02485\n         ORG   ETAB+(4*JRTOKDIR)                                        02486\n         DC    A(MJRTOKDIR)                                             02487\n         ORG                                                            02488\nMJRTOKDIR DC C'The VNODE token specifies a directory'                   02489\n         DC    X'00'                                                    02490\n         ORG   ETAB+(4*JRTOKNOTDIR)                                     02491\n         DC    A(MJRTOKNOTDIR)                                          02492\n         ORG                                                            02493\nMJRTOKNOTDIR DC C'The VNODE token does not specify a directory'         02494\n         DC    X'00'                                                    02495\n         ORG   ETAB+(4*JRINVALIDATTR)                                   02496\n         DC    A(MJRINVALIDATTR)                                        02497\n         ORG                                                            02498\nMJRINVALIDATTR DC C'The supplied Attribute structure was not valid'     02499\n         DC    X'00'                                                    02500\n         ORG   ETAB+(4*JRMAXTASKS)                                      02501\n         DC    A(MJRMAXTASKS)                                           02502\n         ORG                                                            02503\nMJRMAXTASKS DC C'The number of tasks in the process is greater than th' 02504\n         DC    C'e maximum allowable limit'                             02505\n         DC    X'00'                                                    02506\n         ORG   ETAB+(4*JRMAXSOCKETS)                                    02507\n         DC    A(MJRMAXSOCKETS)                                         02508\n         ORG                                                            02509\nMJRMAXSOCKETS DC C'The number of active sockets is equal to the value ' 02510\n         DC    C'specified on the MAXSOCKETS parmlib statement'         02511\n         DC    X'00'                                                    02512\n         ORG   ETAB+(4*JRNOTDIR)                                        02513\n         DC    A(MJRNOTDIR)                                             02514\n         ORG                                                            02515\nMJRNOTDIR DC C'The name does not specify a directory'                   02516\n         DC    X'00'                                                    02517\n         ORG   ETAB+(4*JREXTERNALLINK)                                  02518\n         DC    A(MJREXTERNALLINK)                                       02519\n         ORG                                                            02520\nMJREXTERNALLINK DC C'An external symbolic link was found but is not su' 02521\n         DC    C'pported'                                               02522\n         DC    X'00'                                                    02523\n         ORG   ETAB+(4*JRSOCKETNAMED)                                   02524\n         DC    A(MJRSOCKETNAMED)                                        02525\n         ORG                                                            02526\nMJRSOCKETNAMED DC C'A Bind request was received for a socket that was ' 02527\n         DC    C'previously named'                                      02528\n         DC    X'00'                                                    02529\n         ORG   ETAB+(4*JRSOCANWKBITON)                                  02530\n         DC    A(MJRSOCANWKBITON)                                       02531\n         ORG                                                            02532\nMJRSOCANWKBITON DC C'Duplicate NETWORK parmlib statements exist'        02533\n         DC    X'00'                                                    02534\n         ORG   ETAB+(4*JRLISTENNOTACCEPTED)                             02535\n         DC    A(MJRLISTENNOTACCEPTED)                                  02536\n         ORG                                                            02537\nMJRLISTENNOTACCEPTED DC C'A listen syscall was issued for a socket tha' 02538\n         DC    C't has not been bound, for a socket that is already a ' 02539\n         DC    C'server, or for a socket that is already connected'     02540\n         DC    X'00'                                                    02541\n         ORG   ETAB+(4*JRSOCKETCLOSED)                                  02542\n         DC    A(MJRSOCKETCLOSED)                                       02543\n         ORG                                                            02544\nMJRSOCKETCLOSED DC C'An attempt was made to read, write or connect to ' 02545\n         DC    C'a socket that is closed'                               02546\n         DC    X'00'                                                    02547\n         ORG   ETAB+(4*JRTOOMANYTHDS)                                   02548\n         DC    A(MJRTOOMANYTHDS)                                        02549\n         ORG                                                            02550\nMJRTOOMANYTHDS DC C'An attempt was made to create another thread but t' 02551\n         DC    C'he process limit for pthreads has already been reache' 02552\n         DC    C'd'                                                     02553\n         DC    X'00'                                                    02554\n         ORG   ETAB+(4*JRSOCKETCALLPARMERROR)                           02555\n         DC    A(MJRSOCKETCALLPARMERROR)                                02556\n         ORG                                                            02557\nMJRSOCKETCALLPARMERROR DC C'A socket syscall contains incorrect parame' 02558\n         DC    C'ters'                                                  02559\n         DC    X'00'                                                    02560\n         ORG   ETAB+(4*JRRECOVERY)                                      02561\n         DC    A(MJRRECOVERY)                                           02562\n         ORG                                                            02563\nMJRRECOVERY DC C'The recovery VFS operation is not supported      '     02564\n         DC    X'00'                                                    02565\n         ORG   ETAB+(4*JRINVALIDROUTINE)                                02566\n         DC    A(MJRINVALIDROUTINE)                                     02567\n         ORG                                                            02568\nMJRINVALIDROUTINE DC C'An incorrect routine address was passed      '   02569\n         DC    X'00'                                                    02570\n         ORG   ETAB+(4*JRROUTINEERROR)                                  02571\n         DC    A(MJRROUTINEERROR)                                       02572\n         ORG                                                            02573\nMJRROUTINEERROR DC C'An error occurred while the user-provided routine' 02574\n         DC    C' was in control      '                                 02575\n         DC    X'00'                                                    02576\n         ORG   ETAB+(4*JRNOLISTS)                                       02577\n         DC    A(MJRNOLISTS)                                            02578\n         ORG                                                            02579\nMJRNOLISTS DC C'A Select request was issued without a read, write or e' 02580\n         DC    C'xception list      '                                   02581\n         DC    X'00'                                                    02582\n         ORG   ETAB+(4*JRLISTTOOLONG)                                   02583\n         DC    A(MJRLISTTOOLONG)                                        02584\n         ORG                                                            02585\nMJRLISTTOOLONG DC C'The read, write or exception list is too long     ' 02586\n         DC    C' '                                                     02587\n         DC    X'00'                                                    02588\n         ORG   ETAB+(4*JRLISTTOOSHORT)                                  02589\n         DC    A(MJRLISTTOOSHORT)                                       02590\n         ORG                                                            02591\nMJRLISTTOOSHORT DC C'The read, write or exception list is too short to' 02592\n         DC    C' contain the specified number of file descriptorsand ' 02593\n         DC    C'message queue identifiers      '                       02594\n         DC    X'00'                                                    02595\n         ORG   ETAB+(4*JRMSOUTOFRANGE)                                  02596\n         DC    A(MJRMSOUTOFRANGE)                                       02597\n         ORG                                                            02598\nMJRMSOUTOFRANGE DC C'The value specified for microseconds is outside t' 02599\n         DC    C'he allowable range      '                              02600\n         DC    X'00'                                                    02601\n         ORG   ETAB+(4*JRSECOUTOFRANGE)                                 02602\n         DC    A(MJRSECOUTOFRANGE)                                      02603\n         ORG                                                            02604\nMJRSECOUTOFRANGE DC C'The value specified for seconds is outside the a' 02605\n         DC    C'llowable range'                                        02606\n         DC    X'00'                                                    02607\n         ORG   ETAB+(4*JRNOFDS)                                         02608\n         DC    A(MJRNOFDS)                                              02609\n         ORG                                                            02610\nMJRNOFDS DC C'The read, write or exception list did not contain any fi' 02611\n         DC    C'le descriptors, or the Number_FDs parameter was not g' 02612\n         DC    C'reater than 0'                                         02613\n         DC    X'00'                                                    02614\n*****************************************************************       02615\n         ORG   ETAB+(4*JRINCORRECTSOCKETTYPE)                           02616\n         DC    A(MJRINCORRECTSOCKETTYPE)                                02617\n         ORG                                                            02618\nMJRINCORRECTSOCKETTYPE DC C'The socket type is incorrect for the reque' 02619\n         DC    C'st'                                                    02620\n         DC    X'00'                                                    02621\n         ORG   ETAB+(4*JRWOULDBLOCK)                                    02622\n         DC    A(MJRWOULDBLOCK)                                         02623\n         ORG                                                            02624\nMJRWOULDBLOCK DC C'The O_NONBLOCK flag is set and this request would b' 02625\n         DC    C'lock'                                                  02626\n         DC    X'00'                                                    02627\n         ORG   ETAB+(4*JREXCEEDSBACKLOGCOUNT)                           02628\n         DC    A(MJREXCEEDSBACKLOGCOUNT)                                02629\n         ORG                                                            02630\nMJREXCEEDSBACKLOGCOUNT DC C'This connect request exceeds the connect b' 02631\n         DC    C'acklog count that was specified on the Listen request' 02632\n         DC    X'00'                                                    02633\n         ORG   ETAB+(4*JRLEVELNOTSUPP)                                  02634\n         DC    A(MJRLEVELNOTSUPP)                                       02635\n         ORG                                                            02636\nMJRLEVELNOTSUPP DC C'The value specified for Level is not supported by' 02637\n         DC    C' the physical file system'                             02638\n         DC    X'00'                                                    02639\n         ORG   ETAB+(4*JRINVOPOPT)                                      02640\n         DC    A(MJRINVOPOPT)                                           02641\n         ORG                                                            02642\nMJRINVOPOPT DC C'The Option name specified is not valid'                02643\n         DC    X'00'                                                    02644\n         ORG   ETAB+(4*JRBUFF)                                          02645\n         DC    A(MJRBUFF)                                               02646\n         ORG                                                            02647\nMJRBUFF DC C'The buffer for return information is too small'            02648\n         DC    X'00'                                                    02649\n         ORG   ETAB+(4*JROPTNOTSUPP)                                    02650\n         DC    A(MJROPTNOTSUPP)                                         02651\n         ORG                                                            02652\nMJROPTNOTSUPP DC C'The Option name specified is not supported'          02653\n         DC    X'00'                                                    02654\n         ORG   ETAB+(4*JRPTASYNCTHREAD)                                 02655\n         DC    A(MJRPTASYNCTHREAD)                                      02656\n         ORG                                                            02657\nMJRPTASYNCTHREAD DC C'The ptrace request is not allowed because the ta' 02658\n         DC    C'rget thread is asynchronous'                           02659\n         DC    X'00'                                                    02660\n         ORG   ETAB+(4*JRSOCKETNOTCON)                                  02661\n         DC    A(MJRSOCKETNOTCON)                                       02662\n         ORG                                                            02663\nMJRSOCKETNOTCON DC C'The requested socket is not connected'             02664\n         DC    X'00'                                                    02665\n         ORG   ETAB+(4*JRPTYNOPTYSSTORAGE)                              02666\n         DC    A(MJRPTYNOPTYSSTORAGE)                                   02667\n         ORG                                                            02668\nMJRPTYNOPTYSSTORAGE DC C'There is insufficient storage in the kernel a' 02669\n         DC    C'ddress space'                                          02670\n         DC    X'00'                                                    02671\n         ORG   ETAB+(4*JRSOCKRDWRSIGNAL)                                02672\n         DC    A(MJRSOCKRDWRSIGNAL)                                     02673\n         ORG                                                            02674\nMJRSOCKRDWRSIGNAL DC C'Signal interrupt during socket read or write pr' 02675\n         DC    C'ocessing'                                              02676\n         DC    X'00'                                                    02677\n         ORG   ETAB+(4*JRSOCKBUFMAX)                                    02678\n         DC    A(MJRSOCKBUFMAX)                                         02679\n         ORG                                                            02680\nMJRSOCKBUFMAX DC C'There is insufficient storage for the socket messag' 02681\n         DC    C'e'                                                     02682\n         DC    X'00'                                                    02683\n         ORG   ETAB+(4*JRINVALIDMSGH)                                   02684\n         DC    A(MJRINVALIDMSGH)                                        02685\n         ORG                                                            02686\nMJRINVALIDMSGH DC C'The socket message header is not correct'           02687\n         DC    X'00'                                                    02688\n         ORG   ETAB+(4*JRSOCKNONAME)                                    02689\n         DC    A(MJRSOCKNONAME)                                         02690\n         ORG                                                            02691\nMJRSOCKNONAME DC C'The request requires a socket name structure'        02692\n         DC    X'00'                                                    02693\n         ORG   ETAB+(4*JRINVALIDSERVERNAMELEN)                          02694\n         DC    A(MJRINVALIDSERVERNAMELEN)                               02695\n         ORG                                                            02696\nMJRINVALIDSERVERNAMELEN DC C'The server name length supplied in NRegSN' 02697\n         DC    C'ameLen is too long or negative'                        02698\n         DC    X'00'                                                    02699\n         ORG   ETAB+(4*JRNOOOBDATAAVAIL)                                02700\n         DC    A(MJRNOOOBDATAAVAIL)                                     02701\n         ORG                                                            02702\nMJRNOOOBDATAAVAIL DC C'The MSG_OOB flag is set but no OOB data is avai' 02703\n         DC    C'lable or OOB data is inline'                           02704\n         DC    X'00'                                                    02705\n         ORG   ETAB+(4*JRINCORRECTTYPEFORFLAG)                          02706\n         DC    A(MJRINCORRECTTYPEFORFLAG)                               02707\n         ORG                                                            02708\nMJRINCORRECTTYPEFORFLAG DC C'MSG_OOB flag is set but socket is not a s' 02709\n         DC    C'tream socket'                                          02710\n         DC    X'00'                                                    02711\n         ORG   ETAB+(4*JRSOCKSHUTDOWN)                                  02712\n         DC    A(MJRSOCKSHUTDOWN)                                       02713\n         ORG                                                            02714\nMJRSOCKSHUTDOWN DC C'Socket has been shutdown'                          02715\n         DC    X'00'                                                    02716\n         ORG   ETAB+(4*JRMSGHINVALID)                                   02717\n         DC    A(MJRMSGHINVALID)                                        02718\n         ORG                                                            02719\nMJRMSGHINVALID DC C'msg_controllen or a cmsg_len has an incorrect leng' 02720\n         DC    C'th'                                                    02721\n         DC    X'00'                                                    02722\n         ORG   ETAB+(4*JRNOADDRSPACE)                                   02723\n         DC    A(MJRNOADDRSPACE)                                        02724\n         ORG                                                            02725\nMJRNOADDRSPACE DC C'The caller apos.s address space name cannot be det' 02726\n         DC    C'ermined'                                               02727\n         DC    X'00'                                                    02728\n         ORG   ETAB+(4*JRNONAME)                                        02729\n         DC    A(MJRNONAME)                                             02730\n         ORG                                                            02731\nMJRNONAME DC C'The name length is zero'                                 02732\n         DC    X'00'                                                    02733\n         ORG   ETAB+(4*JRLISTLENBAD)                                    02734\n         DC    A(MJRLISTLENBAD)                                         02735\n         ORG                                                            02736\nMJRLISTLENBAD DC C'The length of one or all of the input bit lists is ' 02737\n         DC    C'not a multiple of four or is not more than 256 bytes'  02738\n         DC    X'00'                                                    02739\n         ORG   ETAB+(4*JRINVUSEROP)                                     02740\n         DC    A(MJRINVUSEROP)                                          02741\n         ORG                                                            02742\nMJRINVUSEROP DC C'The value specifed for the User Option was not 0 or ' 02743\n         DC    C'1'                                                     02744\n         DC    X'00'                                                    02745\n         ORG   ETAB+(4*JRSOCKETPROTOCOLINVALID)                         02746\n         DC    A(MJRSOCKETPROTOCOLINVALID)                              02747\n         ORG                                                            02748\nMJRSOCKETPROTOCOLINVALID DC C'The protocol argument on the socket or s' 02749\n         DC    C'ocketpair syscall was not 0.  The physical file syste' 02750\n         DC    C'm only supports a value of 0 for the protocol'         02751\n         DC    X'00'                                                    02752\n         ORG   ETAB+(4*JRNAMEEXISTS)                                    02753\n         DC    A(MJRNAMEEXISTS)                                         02754\n         ORG                                                            02755\nMJRNAMEEXISTS DC C'The name specified in the request is already in use' 02756\n         DC    X'00'                                                    02757\n         ORG   ETAB+(4*JRLISTENNOTDONE)                                 02758\n         DC    A(MJRLISTENNOTDONE)                                      02759\n         ORG                                                            02760\nMJRLISTENNOTDONE DC C'The socket is not ready to accept connections'    02761\n         DC    X'00'                                                    02762\n         ORG   ETAB+(4*JRLISTENNOTSTREAM)                               02763\n         DC    A(MJRLISTENNOTSTREAM)                                    02764\n         ORG                                                            02765\nMJRLISTENNOTSTREAM DC C'A listen syscall was issued for a socket that ' 02766\n         DC    C'is not a stream socket.  Listen is only valid for str' 02767\n         DC    C'eam sockets'                                           02768\n         DC    X'00'                                                    02769\n         ORG   ETAB+(4*JRLISTENALREADYDONE)                             02770\n         DC    A(MJRLISTENALREADYDONE)                                  02771\n         ORG                                                            02772\nMJRLISTENALREADYDONE DC C'A listen request has already been completed'  02773\n         DC    X'00'                                                    02774\n         ORG   ETAB+(4*JRSTLACTIONINVALID)                              02775\n         DC    A(MJRSTLACTIONINVALID)                                   02776\n         ORG                                                            02777\nMJRSTLACTIONINVALID DC C'The value specified for the action parameter ' 02778\n         DC    C'is not valid'                                          02779\n         DC    X'00'                                                    02780\n         ORG   ETAB+(4*JRSTLTASKSINVALID)                               02781\n         DC    A(MJRSTLTASKSINVALID)                                    02782\n         ORG                                                            02783\nMJRSTLTASKSINVALID DC C'The value specified for the task limit is not ' 02784\n         DC    C'valid'                                                 02785\n         DC    X'00'                                                    02786\n         ORG   ETAB+(4*JRSTLTHREADSINVALID)                             02787\n         DC    A(MJRSTLTHREADSINVALID)                                  02788\n         ORG                                                            02789\nMJRSTLTHREADSINVALID DC C'The value specified for the thread limit is ' 02790\n         DC    C'not valid'                                             02791\n         DC    X'00'                                                    02792\n         ORG   ETAB+(4*JRTCPERROR)                                      02793\n         DC    A(MJRTCPERROR)                                           02794\n         ORG                                                            02795\nMJRTCPERROR DC C'Tcp returned an error identified by the return code'   02796\n         DC    X'00'                                                    02797\n         ORG   ETAB+(4*JRNOSPACE)                                       02798\n         DC    A(MJRNOSPACE)                                            02799\n         ORG                                                            02800\nMJRNOSPACE DC C'Pthread_create failed, due to unavailable user address' 02801\n         DC    C' space storage'                                        02802\n         DC    X'00'                                                    02803\n         ORG   ETAB+(4*JRMAXTCPPATHIDS)                                 02804\n         DC    A(MJRMAXTCPPATHIDS)                                      02805\n         ORG                                                            02806\nMJRMAXTCPPATHIDS DC C'The maximum number of Tcp/Ip path IDs has been e' 02807\n         DC    C'xceeded'                                               02808\n         DC    X'00'                                                    02809\n         ORG   ETAB+(4*JRPTNOTXTDEVENT)                                 02810\n         DC    A(MJRPTNOTXTDEVENT)                                      02811\n         ORG                                                            02812\nMJRPTNOTXTDEVENT DC C'The ptrace request is not allowed because the ta' 02813\n         DC    C'rget process is not stopped for an extended event'     02814\n         DC    X'00'                                                    02815\n         ORG   ETAB+(4*JRPTTOOMANYEVENTS)                               02816\n         DC    A(MJRPTTOOMANYEVENTS)                                    02817\n         ORG                                                            02818\nMJRPTTOOMANYEVENTS DC C'The ptrace PT_EVENTS request attempted to add ' 02819\n         DC    C'more events than the specified maximum'                02820\n         DC    X'00'                                                    02821\n         ORG   ETAB+(4*JRTCPNOTACTIVE)                                  02822\n         DC    A(MJRTCPNOTACTIVE)                                       02823\n         ORG                                                            02824\nMJRTCPNOTACTIVE DC C'No AF_INET socket provider is active'              02825\n         DC    X'00'                                                    02826\n         ORG   ETAB+(4*JRMAXINETSOCKETS)                                02827\n         DC    A(MJRMAXINETSOCKETS)                                     02828\n         ORG                                                            02829\nMJRMAXINETSOCKETS DC C'The number of active INET sockets is equal to t' 02830\n         DC    C'he value specified on the MAXSOCKETS parmlib statemen' 02831\n         DC    C't'                                                     02832\n         DC    X'00'                                                    02833\n         ORG   ETAB+(4*JRECBERROR)                                      02834\n         DC    A(MJRECBERROR)                                           02835\n         ORG                                                            02836\nMJRECBERROR DC C'The last ECB pointer in the list of ECB pointers does' 02837\n         DC    C' not have the high order bit ( apos.80000000 apos.x) ' 02838\n         DC    C'set on to indicate that it is the last ECB pointer in' 02839\n         DC    C' the list'                                             02840\n         DC    X'00'                                                    02841\n         ORG   ETAB+(4*JRECBLISTBAD)                                    02842\n         DC    A(MJRECBLISTBAD)                                         02843\n         ORG                                                            02844\nMJRECBLISTBAD DC C'An error occurred accessing the list of pointers to' 02845\n         DC    C' ECBs on a call to the MVSpauseInit service'           02846\n         DC    X'00'                                                    02847\n         ORG   ETAB+(4*JRECBSTATEBAD)                                   02848\n         DC    A(MJRECBSTATEBAD)                                        02849\n         ORG                                                            02850\nMJRECBSTATEBAD DC C'An error occurred accessing one or more of the inp' 02851\n         DC    C'ut ECBs on a call to the MVSpauseInit or MVSpause ser' 02852\n         DC    C'vice'                                                  02853\n         DC    X'00'                                                    02854\n         ORG   ETAB+(4*JRECBLISTNOTSETUP)                               02855\n         DC    A(MJRECBLISTNOTSETUP)                                    02856\n         ORG                                                            02857\nMJRECBLISTNOTSETUP DC C'The MVSpause service was called but the MVSpau' 02858\n         DC    C'seInit service was never called to prepare for an MVS' 02859\n         DC    C'pause'                                                 02860\n         DC    X'00'                                                    02861\n         ORG   ETAB+(4*JRSOCKETTYPENOTSUPPORTED)                        02862\n         DC    A(MJRSOCKETTYPENOTSUPPORTED)                             02863\n         ORG                                                            02864\nMJRSOCKETTYPENOTSUPPORTED DC C'The requested socket type is not suppor' 02865\n         DC    C'ted'                                                   02866\n         DC    X'00'                                                    02867\n         ORG   ETAB+(4*JRECBWAITBITON)                                  02868\n         DC    A(MJRECBWAITBITON)                                       02869\n         ORG                                                            02870\nMJRECBWAITBITON DC C'The wait bit (the high order bit) was on in the s' 02871\n         DC    C'pecified event control block (ECB)'                    02872\n         DC    X'00'                                                    02873\n         ORG   ETAB+(4*JRINVALIDVLOK)                                   02874\n         DC    A(MJRINVALIDVLOK)                                        02875\n         ORG                                                            02876\nMJRINVALIDVLOK DC C'The supplied VLock structure was not valid'         02877\n         DC    X'00'                                                    02878\n         ORG   ETAB+(4*JRINVALIDSERVERPID)                              02879\n         DC    A(MJRINVALIDSERVERPID)                                   02880\n         ORG                                                            02881\nMJRINVALIDSERVERPID DC C'The supplied VLokServerPID value was not vali' 02882\n         DC    C'd'                                                     02883\n         DC    X'00'                                                    02884\n         ORG   ETAB+(4*JRNOLOCKERTOKEN)                                 02885\n         DC    A(MJRNOLOCKERTOKEN)                                      02886\n         ORG                                                            02887\nMJRNOLOCKERTOKEN DC C'No Locker token was specified in the Vlock struc' 02888\n         DC    C'ture'                                                  02889\n         DC    X'00'                                                    02890\n         ORG   ETAB+(4*JRBRLMOBJECTMISSING)                             02891\n         DC    A(MJRBRLMOBJECTMISSING)                                  02892\n         ORG                                                            02893\nMJRBRLMOBJECTMISSING DC C'No Object was specified in the Vlock structu' 02894\n         DC    C're'                                                    02895\n         DC    X'00'                                                    02896\n         ORG   ETAB+(4*JRBRLMWRONGLEVEL)                                02897\n         DC    A(MJRBRLMWRONGLEVEL)                                     02898\n         ORG                                                            02899\nMJRBRLMWRONGLEVEL DC C'The byte-range lock manager does not support th' 02900\n         DC    C'e request'                                             02901\n         DC    X'00'                                                    02902\n         ORG   ETAB+(4*JRBRLMLOCKERNOTREGISTERED)                       02903\n         DC    A(MJRBRLMLOCKERNOTREGISTERED)                            02904\n         ORG                                                            02905\nMJRBRLMLOCKERNOTREGISTERED DC C'The Locker token specified in the Vloc' 02906\n         DC    C'k structure is not registered'                         02907\n         DC    X'00'                                                    02908\n         ORG   ETAB+(4*JRMULTIPROC)                                     02909\n         DC    A(MJRMULTIPROC)                                          02910\n         ORG                                                            02911\nMJRMULTIPROC DC C'The specified function is not supported in an addres' 02912\n         DC    C's space running multiple processes'                    02913\n         DC    X'00'                                                    02914\n         ORG   ETAB+(4*JRTASKACEE)                                      02915\n         DC    A(MJRTASKACEE)                                           02916\n         ORG                                                            02917\nMJRTASKACEE DC C'The specified function is not supported when a task l' 02918\n         DC    C'evel ACEE is active for the calling task'              02919\n         DC    X'00'                                                    02920\n         ORG   ETAB+(4*JRUSERNAMELENERROR)                              02921\n         DC    A(MJRUSERNAMELENERROR)                                   02922\n         ORG                                                            02923\nMJRUSERNAMELENERROR DC C'The user name length value was incorrect.'     02924\n         DC    X'00'                                                    02925\n         ORG   ETAB+(4*JRPASSWORDLENERROR)                              02926\n         DC    A(MJRPASSWORDLENERROR)                                   02927\n         ORG                                                            02928\nMJRPASSWORDLENERROR DC C'The password length value was incorrect.'      02929\n         DC    X'00'                                                    02930\n         ORG   ETAB+(4*JRNEWPASSWORDLENERROR)                           02931\n         DC    A(MJRNEWPASSWORDLENERROR)                                02932\n         ORG                                                            02933\nMJRNEWPASSWORDLENERROR DC C'The password length value was incorrect.'   02934\n         DC    X'00'                                                    02935\n         ORG   ETAB+(4*JRMIXEDSECURITYENV)                              02936\n         DC    A(MJRMIXEDSECURITYENV)                                   02937\n         ORG                                                            02938\nMJRMIXEDSECURITYENV DC C'The specified function is not supported after' 02939\n         DC    C' a seteuid has changed the security environment of th' 02940\n         DC    C'e caller'                                              02941\n         DC    X'00'                                                    02942\n         ORG   ETAB+(4*JRTSO)                                           02943\n         DC    A(MJRTSO)                                                02944\n         ORG                                                            02945\nMJRTSO DC C'The specified function is not supported in a TSO space run' 02946\n         DC    C'ning multiple processes'                               02947\n         DC    X'00'                                                    02948\n         ORG   ETAB+(4*JRENVDIRTY)                                      02949\n         DC    A(MJRENVDIRTY)                                           02950\n         ORG                                                            02951\nMJRENVDIRTY DC C'The specified function is not supported in an address' 02952\n         DC    C' space where a load was done that is not program cont' 02953\n         DC    C'rolled.'                                               02954\n         DC    X'00'                                                    02955\n         ORG   ETAB+(4*JRIPCBADID)                                      02956\n         DC    A(MJRIPCBADID)                                           02957\n         ORG                                                            02958\nMJRIPCBADID DC C'The ID is not valid or has been removed from the syst' 02959\n         DC    C'em'                                                    02960\n         DC    X'00'                                                    02961\n         ORG   ETAB+(4*JRIPCDENIED)                                     02962\n         DC    A(MJRIPCDENIED)                                          02963\n         ORG                                                            02964\nMJRIPCDENIED DC C'Access was denied because the caller does not have t' 02965\n         DC    C'he correct permission'                                 02966\n         DC    X'00'                                                    02967\n         ORG   ETAB+(4*JRIPCEXISTS)                                     02968\n         DC    A(MJRIPCEXISTS)                                          02969\n         ORG                                                            02970\nMJRIPCEXISTS DC C'The caller issued CREATE, EXCL and the key was alrea' 02971\n         DC    C'dy defined to InterProcess Communications'             02972\n         DC    X'00'                                                    02973\n         ORG   ETAB+(4*JRIPCMAXIDS)                                     02974\n         DC    A(MJRIPCMAXIDS)                                          02975\n         ORG                                                            02976\nMJRIPCMAXIDS DC C'The number of IDs exceeds the system limit and the c' 02977\n         DC    C'reate fails'                                           02978\n         DC    X'00'                                                    02979\n         ORG   ETAB+(4*JRIPCNOEXIST)                                    02980\n         DC    A(MJRIPCNOEXIST)                                         02981\n         ORG                                                            02982\nMJRIPCNOEXIST DC C'The caller tried to locate a member for the key spe' 02983\n         DC    C'cified but it does not exist'                          02984\n         DC    X'00'                                                    02985\n         ORG   ETAB+(4*JRIPCRETRY)                                      02986\n         DC    A(MJRIPCRETRY)                                           02987\n         ORG                                                            02988\nMJRIPCRETRY DC C'NOWAIT was specified but the operation could not be p' 02989\n         DC    C'erformed immediately'                                  02990\n         DC    X'00'                                                    02991\n         ORG   ETAB+(4*JRIPCSIGNALED)                                   02992\n         DC    A(MJRIPCSIGNALED)                                        02993\n         ORG                                                            02994\nMJRIPCSIGNALED DC C'An IPC wait was interrupted by a signal'            02995\n         DC    X'00'                                                    02996\n         ORG   ETAB+(4*JRIPCBADFLAGS)                                   02997\n         DC    A(MJRIPCBADFLAGS)                                        02998\n         ORG                                                            02999\nMJRIPCBADFLAGS DC C'Extraneous bits were set in the flags word paramet' 03000\n         DC    C'er or in the mode flag bit field.'                     03001\n         DC    X'00'                                                    03002\n         ORG   ETAB+(4*JRMSQBADTYPE)                                    03003\n         DC    A(MJRMSQBADTYPE)                                         03004\n         ORG                                                            03005\nMJRMSQBADTYPE DC C'Message type must be greater than zero'              03006\n         DC    X'00'                                                    03007\n         ORG   ETAB+(4*JRMSQBADSIZE)                                    03008\n         DC    A(MJRMSQBADSIZE)                                         03009\n         ORG                                                            03010\nMJRMSQBADSIZE DC C'The message length exceeds the system limit or is l' 03011\n         DC    C'ess than zero.'                                        03012\n         DC    X'00'                                                    03013\n         ORG   ETAB+(4*JRMSQNOMSG)                                      03014\n         DC    A(MJRMSQNOMSG)                                           03015\n         ORG                                                            03016\nMJRMSQNOMSG DC C'No message of the type requested was found'            03017\n         DC    X'00'                                                    03018\n         ORG   ETAB+(4*JRMSQ2BIG)                                       03019\n         DC    A(MJRMSQ2BIG)                                            03020\n         ORG                                                            03021\nMJRMSQ2BIG DC C'The message to receive was too large for the buffer an' 03022\n         DC    C'd MSG_NOERROR was not specified'                       03023\n         DC    X'00'                                                    03024\n         ORG   ETAB+(4*JRSEMA4BADADJ)                                   03025\n         DC    A(MJRSEMA4BADADJ)                                        03026\n         ORG                                                            03027\nMJRSEMA4BADADJ DC C'The value specified would exceed the system limit ' 03028\n         DC    C'for semadj'                                            03029\n         DC    X'00'                                                    03030\n         ORG   ETAB+(4*JRSEMA4BADNOPS)                                  03031\n         DC    A(MJRSEMA4BADNOPS)                                       03032\n         ORG                                                            03033\nMJRSEMA4BADNOPS DC C'Number of semaphore operation exceeds the system ' 03034\n         DC    C'limit'                                                 03035\n         DC    X'00'                                                    03036\n         ORG   ETAB+(4*JRSEMA4BADNSEMS)                                 03037\n         DC    A(MJRSEMA4BADNSEMS)                                      03038\n         ORG                                                            03039\nMJRSEMA4BADNSEMS DC C'Semaphore ID already exists for the KEY, but the' 03040\n         DC    C' number of semaphores is less than requested'          03041\n         DC    X'00'                                                    03042\n         ORG   ETAB+(4*JRTYPENOTPID)                                    03043\n         DC    A(MJRTYPENOTPID)                                         03044\n         ORG                                                            03045\nMJRTYPENOTPID DC C'A msgrcv or msgsnd did not have its process ID as t' 03046\n         DC    C'ype'                                                   03047\n         DC    X'00'                                                    03048\n         ORG   ETAB+(4*JRSEMA4BADSEMN)                                  03049\n         DC    A(MJRSEMA4BADSEMN)                                       03050\n         ORG                                                            03051\nMJRSEMA4BADSEMN DC C'The semaphore number is invalid'                   03052\n         DC    X'00'                                                    03053\n         ORG   ETAB+(4*JRSEMA4BADVALUE)                                 03054\n         DC    A(MJRSEMA4BADVALUE)                                      03055\n         ORG                                                            03056\nMJRSEMA4BADVALUE DC C'The value specified would exceed the system limi' 03057\n         DC    C't'                                                     03058\n         DC    X'00'                                                    03059\n         ORG   ETAB+(4*JRSEMA4BIGNSEMS)                                 03060\n         DC    A(MJRSEMA4BIGNSEMS)                                      03061\n         ORG                                                            03062\nMJRSEMA4BIGNSEMS DC C'The number of semaphores exceeds the system maxi' 03063\n         DC    C'mum'                                                   03064\n         DC    X'00'                                                    03065\n         ORG   ETAB+(4*JRSEMA4ZERONSEMS)                                03066\n         DC    A(MJRSEMA4ZERONSEMS)                                     03067\n         ORG                                                            03068\nMJRSEMA4ZERONSEMS DC C'The number of semaphores specified was zero and' 03069\n         DC    C' the semaphore does not exist'                         03070\n         DC    X'00'                                                    03071\n         ORG   ETAB+(4*JRSHMBADSIZE)                                    03072\n         DC    A(MJRSHMBADSIZE)                                         03073\n         ORG                                                            03074\nMJRSHMBADSIZE DC C'The shared memory segment size is incorrect or outs' 03075\n         DC    C'ide the system defined range of valid segment sizes.'  03076\n         DC    X'00'                                                    03077\n         ORG   ETAB+(4*JRSHMMAXATTACH)                                  03078\n         DC    A(MJRSHMMAXATTACH)                                       03079\n         ORG                                                            03080\nMJRSHMMAXATTACH DC C'The number of shared memory attaches for the curr' 03081\n         DC    C'ent process exceeds the system defined maximum.'       03082\n         DC    X'00'                                                    03083\n         ORG   ETAB+(4*JRIPCREMOVED)                                    03084\n         DC    A(MJRIPCREMOVED)                                         03085\n         ORG                                                            03086\nMJRIPCREMOVED DC C'During a wait, the IPC member ID was removed from t' 03087\n         DC    C'he system'                                             03088\n         DC    X'00'                                                    03089\n         ORG   ETAB+(4*JRMSQQBYTES)                                     03090\n         DC    A(MJRMSQQBYTES)                                          03091\n         ORG                                                            03092\nMJRMSQQBYTES DC C'Not permitted to increase message qbytes or attempt ' 03093\n         DC    C'by superuser to set message qbytes exceeds system lim' 03094\n         DC    C'it.'                                                   03095\n         DC    X'00'                                                    03096\n         ORG   ETAB+(4*JRBADPERFGROUP)                                  03097\n         DC    A(MJRBADPERFGROUP)                                       03098\n         ORG                                                            03099\nMJRBADPERFGROUP DC C'The specified priority or nice value represents a' 03100\n         DC    C' performance group that could not be used.'            03101\n         DC    X'00'                                                    03102\n         ORG   ETAB+(4*JRBADSERVCLASS)                                  03103\n         DC    A(MJRBADSERVCLASS)                                       03104\n         ORG                                                            03105\nMJRBADSERVCLASS DC C'The specified priority or nice value represents a' 03106\n         DC    C' service class that could not be used.'                03107\n         DC    X'00'                                                    03108\n         ORG   ETAB+(4*JRMSQQUEUEFULLMESSAGES)                          03109\n         DC    A(MJRMSQQUEUEFULLMESSAGES)                               03110\n         ORG                                                            03111\nMJRMSQQUEUEFULLMESSAGES DC C'IPC_NOWAIT was specified but the operatio' 03112\n         DC    C'n was not done because there was no room in the messa' 03113\n         DC    C'ge queue due to the number of messages in the message' 03114\n         DC    C' queue'                                                03115\n         DC    X'00'                                                    03116\n         ORG   ETAB+(4*JRMSQQUEUEFULLBYTES)                             03117\n         DC    A(MJRMSQQUEUEFULLBYTES)                                  03118\n         ORG                                                            03119\nMJRMSQQUEUEFULLBYTES DC C'IPC_NOWAIT was specified and the operation w' 03120\n         DC    C'as not done because there was no room in the message ' 03121\n         DC    C'queue due to the number of bytes in the message queue' 03122\n         DC    X'00'                                                    03123\n         ORG   ETAB+(4*JRRFILENOREAD)                                   03124\n         DC    A(MJRRFILENOREAD)                                        03125\n         ORG                                                            03126\nMJRRFILENOREAD DC C'A call tried to read a file opened without read ac' 03127\n         DC    C'cess'                                                  03128\n         DC    X'00'                                                    03129\n         ORG   ETAB+(4*JRSEMSTORAGELIMIT)                               03130\n         DC    A(MJRSEMSTORAGELIMIT)                                    03131\n         ORG                                                            03132\nMJRSEMSTORAGELIMIT DC C'The semget or semop failed because the semapho' 03133\n         DC    C're storage limit was reached'                          03134\n         DC    X'00'                                                    03135\n         ORG   ETAB+(4*JRINHEEYE)                                       03136\n         DC    A(MJRINHEEYE)                                            03137\n         ORG                                                            03138\nMJRINHEEYE DC C'The inheritance area contains an incorrect eyecatcher ' 03139\n         DC    C'value'                                                 03140\n         DC    X'00'                                                    03141\n         ORG   ETAB+(4*JRINHELENGTH)                                    03142\n         DC    A(MJRINHELENGTH)                                         03143\n         ORG                                                            03144\nMJRINHELENGTH DC C'The length specified for the inheritance area conta' 03145\n         DC    C'ins an incorrect value'                                03146\n         DC    X'00'                                                    03147\n         ORG   ETAB+(4*JRINHEVERSION)                                   03148\n         DC    A(MJRINHEVERSION)                                        03149\n         ORG                                                            03150\nMJRINHEVERSION DC C'The inheritance area contains an incorrect version' 03151\n         DC    C' number'                                               03152\n         DC    X'00'                                                    03153\n         ORG   ETAB+(4*JRSPAWNTOOMANYFDS)                               03154\n         DC    A(MJRSPAWNTOOMANYFDS)                                    03155\n         ORG                                                            03156\nMJRSPAWNTOOMANYFDS DC C'The count of file descriptors specified is gre' 03157\n         DC    C'ater than the maximum supported by the system.'        03158\n         DC    X'00'                                                    03159\n         ORG   ETAB+(4*JRSHMMAXSPAGES)                                  03160\n         DC    A(MJRSHMMAXSPAGES)                                       03161\n         ORG                                                            03162\nMJRSHMMAXSPAGES DC C'The operation was not done because the system wid' 03163\n         DC    C'e limit for shared memory segment pages was exceeded'  03164\n         DC    X'00'                                                    03165\n         ORG   ETAB+(4*JRNOACCESS)                                      03166\n         DC    A(MJRNOACCESS)                                           03167\n         ORG                                                            03168\nMJRNOACCESS DC C'Caller does not have access to function'               03169\n         DC    X'00'                                                    03170\n         ORG   ETAB+(4*JRFDLISTTOOBIG)                                  03171\n         DC    A(MJRFDLISTTOOBIG)                                       03172\n         ORG                                                            03173\nMJRFDLISTTOOBIG DC C'The size of the file descriptor list is larger th' 03174\n         DC    C'an can be currently supported.'                        03175\n         DC    X'00'                                                    03176\n         ORG   ETAB+(4*JRBADFDLIST)                                     03177\n         DC    A(MJRBADFDLIST)                                          03178\n         ORG                                                            03179\nMJRBADFDLIST DC C'The file descriptor list supplied on the call to BPX' 03180\n         DC    C'1SPN is not accessible by the caller.'                 03181\n         DC    X'00'                                                    03182\n         ORG   ETAB+(4*JRNOTMAPPED)                                     03183\n         DC    A(MJRNOTMAPPED)                                          03184\n         ORG                                                            03185\nMJRNOTMAPPED DC C'One or more specified pages are not mapped'           03186\n         DC    X'00'                                                    03187\n         ORG   ETAB+(4*JRCLNYASCREFAILED)                               03188\n         DC    A(MJRCLNYASCREFAILED)                                    03189\n         ORG                                                            03190\nMJRCLNYASCREFAILED DC C'The ASCRE macro issued to start a colony addre' 03191\n         DC    C'ss space returned a failing return code.'              03192\n         DC    X'00'                                                    03193\n         ORG   ETAB+(4*JRCLNYSTARTFAILED)                               03194\n         DC    A(MJRCLNYSTARTFAILED)                                    03195\n         ORG                                                            03196\nMJRCLNYSTARTFAILED DC C'A colony address space failed to initialize.'   03197\n         DC    X'00'                                                    03198\n         ORG   ETAB+(4*JRCLNYNOTSTOPPED)                                03199\n         DC    A(MJRCLNYNOTSTOPPED)                                     03200\n         ORG                                                            03201\nMJRCLNYNOTSTOPPED DC C'The colony address space could not be stopped.'  03202\n         DC    X'00'                                                    03203\n         ORG   ETAB+(4*JRCLNYNOCOMMONSTORAGE)                           03204\n         DC    A(MJRCLNYNOCOMMONSTORAGE)                                03205\n         ORG                                                            03206\nMJRCLNYNOCOMMONSTORAGE DC C'The system was unable to obtain storage in' 03207\n         DC    C' common for a control block to represent a colony add' 03208\n         DC    C'ress space.'                                           03209\n         DC    X'00'                                                    03210\n         ORG   ETAB+(4*JRPFSNOTDUBBED)                                  03211\n         DC    A(MJRPFSNOTDUBBED)                                       03212\n         ORG                                                            03213\nMJRPFSNOTDUBBED DC C'The PFS task calling an OSI service is not dubbed' 03214\n         DC    C'.'                                                     03215\n         DC    X'00'                                                    03216\n         ORG   ETAB+(4*JRCLNYNOTSTARTED)                                03217\n         DC    A(MJRCLNYNOTSTARTED)                                     03218\n         ORG                                                            03219\nMJRCLNYNOTSTARTED DC C'An attempt was made to start a PFS within a col' 03220\n         DC    C'ony address space.  The colony was either not complet' 03221\n         DC    C'ely initialized or it was being terminated.'           03222\n         DC    X'00'                                                    03223\n         ORG   ETAB+(4*JRPTYCHGFROMSLAVE)                               03224\n         DC    A(MJRPTYCHGFROMSLAVE)                                    03225\n         ORG                                                            03226\nMJRPTYCHGFROMSLAVE DC C'An attempt was made to change a termios flag f' 03227\n         DC    C'rom the slave pty, which is only allowed from the mas' 03228\n         DC    C'ter.'                                                  03229\n         DC    X'00'                                                    03230\n         ORG   ETAB+(4*JRCLNYPFSNOTSTARTED)                             03231\n         DC    A(MJRCLNYPFSNOTSTARTED)                                  03232\n         ORG                                                            03233\nMJRCLNYPFSNOTSTARTED DC C'An attempt was made to stop or clean up a co' 03234\n         DC    C'lony PFS that was not previously started.'             03235\n         DC    X'00'                                                    03236\n         ORG   ETAB+(4*JRCLNYPFSNOTDONE)                                03237\n         DC    A(MJRCLNYPFSNOTDONE)                                     03238\n         ORG                                                            03239\nMJRCLNYPFSNOTDONE DC C'An attempt was made to clean up a colony PFS th' 03240\n         DC    C'at was not completely terminated.'                     03241\n         DC    X'00'                                                    03242\n         ORG   ETAB+(4*JRDEVCONFIGTYPEERROR)                            03243\n         DC    A(MJRDEVCONFIGTYPEERROR)                                 03244\n         ORG                                                            03245\nMJRDEVCONFIGTYPEERROR DC C'An attempt was made to configure a device d' 03246\n         DC    C'river that was not defined.'                           03247\n         DC    X'00'                                                    03248\n         ORG   ETAB+(4*JRPTYNEEDPKT3270)                                03249\n         DC    A(MJRPTYNEEDPKT3270)                                     03250\n         ORG                                                            03251\nMJRPTYNEEDPKT3270 DC C'An attempt was made to set 3270 Passthru mode w' 03252\n         DC    C'ithout 3270 Packet mode.'                              03253\n         DC    X'00'                                                    03254\n         ORG   ETAB+(4*JRMMAPOVEREOF)                                   03255\n         DC    A(MJRMMAPOVEREOF)                                        03256\n         ORG                                                            03257\nMJRMMAPOVEREOF DC C'The extended file cannot be mapped over its EOF po' 03258\n         DC    C'int'                                                   03259\n         DC    X'00'                                                    03260\n         ORG   ETAB+(4*JRRAISEHARDLIMIT)                                03261\n         DC    A(MJRRAISEHARDLIMIT)                                     03262\n         ORG                                                            03263\nMJRRAISEHARDLIMIT DC C'An attempt was made to raise a hard limit witho' 03264\n         DC    C'ut superuser authority.'                               03265\n         DC    X'00'                                                    03266\n         ORG   ETAB+(4*JRINVALIDRESOURCE)                               03267\n         DC    A(MJRINVALIDRESOURCE)                                    03268\n         ORG                                                            03269\nMJRINVALIDRESOURCE DC C'The input resource value is not valid.'         03270\n         DC    X'00'                                                    03271\n         ORG   ETAB+(4*JRSOFTEXCEEDSHARD)                               03272\n         DC    A(MJRSOFTEXCEEDSHARD)                                    03273\n         ORG                                                            03274\nMJRSOFTEXCEEDSHARD DC C'An attempt was made to raise a soft limit abov' 03275\n         DC    C'e its hard limit.'                                     03276\n         DC    X'00'                                                    03277\n         ORG   ETAB+(4*JRSOFTBELOWUSAGE)                                03278\n         DC    A(MJRSOFTBELOWUSAGE)                                     03279\n         ORG                                                            03280\nMJRSOFTBELOWUSAGE DC C'An attempt was made to lower a soft limit below' 03281\n         DC    C' the current usage for the resource.'                  03282\n         DC    X'00'                                                    03283\n         ORG   ETAB+(4*JRINVALIDWHO)                                    03284\n         DC    A(MJRINVALIDWHO)                                         03285\n         ORG                                                            03286\nMJRINVALIDWHO DC C'The input who value is not valid.'                   03287\n         DC    X'00'                                                    03288\n         ORG   ETAB+(4*JRPTYMUTUALLYEXCLUSIVE)                          03289\n         DC    A(MJRPTYMUTUALLYEXCLUSIVE)                               03290\n         ORG                                                            03291\nMJRPTYMUTUALLYEXCLUSIVE DC C'An attempt was made to set mutually exclu' 03292\n         DC    C'sive bits.'                                            03293\n         DC    X'00'                                                    03294\n         ORG   ETAB+(4*JRMMAPSTGEXCEEDED)                               03295\n         DC    A(MJRMMAPSTGEXCEEDED)                                    03296\n         ORG                                                            03297\nMJRMMAPSTGEXCEEDED DC C'The system-wide limit on the amount of memory ' 03298\n         DC    C'consumed by memory mapped areas is exceeded'           03299\n         DC    X'00'                                                    03300\n         ORG   ETAB+(4*JRPATHCONF)                                      03301\n         DC    A(MJRPATHCONF)                                           03302\n         ORG                                                            03303\nMJRPATHCONF DC C'The Vnode operation pathconf is not supported by this' 03304\n         DC    C' file system'                                          03305\n         DC    X'00'                                                    03306\n         ORG   ETAB+(4*JRNOTPAGE)                                       03307\n         DC    A(MJRNOTPAGE)                                            03308\n         ORG                                                            03309\nMJRNOTPAGE DC C'A location specified or generated is not on a page bou' 03310\n         DC    C'ndary'                                                 03311\n         DC    X'00'                                                    03312\n         ORG   ETAB+(4*JRMMAPBADTYPE)                                   03313\n         DC    A(MJRMMAPBADTYPE)                                        03314\n         ORG                                                            03315\nMJRMMAPBADTYPE DC C'The value of the map_type is not valid'             03316\n         DC    X'00'                                                    03317\n         ORG   ETAB+(4*JRHARDWARE)                                      03318\n         DC    A(MJRHARDWARE)                                           03319\n         ORG                                                            03320\nMJRHARDWARE DC C'A request was made for a hardware that is not availab' 03321\n         DC    C'le'                                                    03322\n         DC    X'00'                                                    03323\n         ORG   ETAB+(4*JRADDRESSNOTAVAILABLE)                           03324\n         DC    A(MJRADDRESSNOTAVAILABLE)                                03325\n         ORG                                                            03326\nMJRADDRESSNOTAVAILABLE DC C'A request was made for a storage address, ' 03327\n         DC    C'but it could not be satisfied'                         03328\n         DC    X'00'                                                    03329\n         ORG   ETAB+(4*JRPROCMAXMMAP)                                   03330\n         DC    A(MJRPROCMAXMMAP)                                        03331\n         ORG                                                            03332\nMJRPROCMAXMMAP DC C'The process has exceeded the maximum number of mma' 03333\n         DC    C'ps'                                                    03334\n         DC    X'00'                                                    03335\n         ORG   ETAB+(4*JRMMAPFILEADDRESS)                               03336\n         DC    A(MJRMMAPFILEADDRESS)                                    03337\n         ORG                                                            03338\nMJRMMAPFILEADDRESS DC C'File_offset + map_length exceeds file size'     03339\n         DC    X'00'                                                    03340\n         ORG   ETAB+(4*JRIARVSERV)                                      03341\n         DC    A(MJRIARVSERV)                                           03342\n         ORG                                                            03343\nMJRIARVSERV DC C'An invocation of IARVSERV service failed.'             03344\n         DC    X'00'                                                    03345\n         ORG   ETAB+(4*JRPTYPENDINGCONTROLINFO)                         03346\n         DC    A(MJRPTYPENDINGCONTROLINFO)                              03347\n         ORG                                                            03348\nMJRPTYPENDINGCONTROLINFO DC C'An attempt was made to write to a master' 03349\n         DC    C' pty in 3270 packet mode when control information was' 03350\n         DC    C' pending'                                              03351\n         DC    X'00'                                                    03352\n         ORG   ETAB+(4*JRZEROORNEGATIVE)                                03353\n         DC    A(MJRZEROORNEGATIVE)                                     03354\n         ORG                                                            03355\nMJRZEROORNEGATIVE DC C'An input parameter must be greater than zero'    03356\n         DC    X'00'                                                    03357\n         ORG   ETAB+(4*JRNOUSERSTORAGE)                                 03358\n         DC    A(MJRNOUSERSTORAGE)                                      03359\n         ORG                                                            03360\nMJRNOUSERSTORAGE DC C'The service could not obtain enough storage in u' 03361\n         DC    C'ser address space subpool 129.'                        03362\n         DC    X'00'                                                    03363\n         ORG   ETAB+(4*JRASYNCHMOUNT)                                   03364\n         DC    A(MJRASYNCHMOUNT)                                        03365\n         ORG                                                            03366\nMJRASYNCHMOUNT DC C'The request to mount a file system will complete a' 03367\n         DC    C'synchronously.  The system rejects all vnode (file) o' 03368\n         DC    C'perations against the file system.'                    03369\n         DC    X'00'                                                    03370\n         ORG   ETAB+(4*JRPFSOPNOTSUPPORTED)                             03371\n         DC    A(MJRPFSOPNOTSUPPORTED)                                  03372\n         ORG                                                            03373\nMJRPFSOPNOTSUPPORTED DC C'The pfsctl command is not supported by this ' 03374\n         DC    C'PFS.'                                                  03375\n         DC    X'00'                                                    03376\n         ORG   ETAB+(4*JRPFSOPNOTPERMITTED)                             03377\n         DC    A(MJRPFSOPNOTPERMITTED)                                  03378\n         ORG                                                            03379\nMJRPFSOPNOTPERMITTED DC C'Not authorized to perform this pfsctl operat' 03380\n         DC    C'ion.'                                                  03381\n         DC    X'00'                                                    03382\n         ORG   ETAB+(4*JRPFSARGLENBAD)                                  03383\n         DC    A(MJRPFSARGLENBAD)                                       03384\n         ORG                                                            03385\nMJRPFSARGLENBAD DC C'The argument length is not valid for this pfsctl ' 03386\n         DC    C'operation.'                                            03387\n         DC    X'00'                                                    03388\n         ORG   ETAB+(4*JRCAPTUREFAILURE)                                03389\n         DC    A(MJRCAPTUREFAILURE)                                     03390\n         ORG                                                            03391\nMJRCAPTUREFAILURE DC C'A memory capture (IARVSERV) failed'              03392\n         DC    X'00'                                                    03393\n         ORG   ETAB+(4*JRBADSIGINFOADDR)                                03394\n         DC    A(MJRBADSIGINFOADDR)                                     03395\n         ORG                                                            03396\nMJRBADSIGINFOADDR DC C'An incorrect siginfo_t address was passed to th' 03397\n         DC    C'e waitid call'                                         03398\n         DC    X'00'                                                    03399\n         ORG   ETAB+(4*JRBADRUSAGEADDR)                                 03400\n         DC    A(MJRBADRUSAGEADDR)                                      03401\n         ORG                                                            03402\nMJRBADRUSAGEADDR DC C'An incorrect rusage address was passed to the wa' 03403\n         DC    C'it3 call'                                              03404\n         DC    X'00'                                                    03405\n         ORG   ETAB+(4*JRPTYNOTRTSTORAGE)                               03406\n         DC    A(MJRPTYNOTRTSTORAGE)                                    03407\n         ORG                                                            03408\nMJRPTYNOTRTSTORAGE DC C'Storage is not available for pseudo-TTY scan t' 03409\n         DC    C'ables'                                                 03410\n         DC    X'00'                                                    03411\n         ORG   ETAB+(4*JRBADSTDEV)                                      03412\n         DC    A(MJRBADSTDEV)                                           03413\n         ORG                                                            03414\nMJRBADSTDEV DC C'The device number specified to osi_mountstatus does n' 03415\n         DC    C'ot refer to a mounted file system.'                    03416\n         DC    X'00'                                                    03417\n         ORG   ETAB+(4*JROPENFILELIMITMAX)                              03418\n         DC    A(MJROPENFILELIMITMAX)                                   03419\n         ORG                                                            03420\nMJROPENFILELIMITMAX DC C'The Open file limit cannot exceed 64K'         03421\n         DC    X'00'                                                    03422\n         ORG   ETAB+(4*JRFDOPENABOVELIMIT)                              03423\n         DC    A(MJRFDOPENABOVELIMIT)                                   03424\n         ORG                                                            03425\nMJRFDOPENABOVELIMIT DC C'A file descriptor is open above requested lim' 03426\n         DC    C'it      '                                              03427\n         DC    X'00'                                                    03428\n         ORG   ETAB+(4*JRWRITEBEYONDLIMIT)                              03429\n         DC    A(MJRWRITEBEYONDLIMIT)                                   03430\n         ORG                                                            03431\nMJRWRITEBEYONDLIMIT DC C'Cannot write beyond the file size limit      ' 03432\n         DC    X'00'                                                    03433\n         ORG   ETAB+(4*JRSYSCALLFAILALL)                                03434\n         DC    A(MJRSYSCALLFAILALL)                                     03435\n         ORG                                                            03436\nMJRSYSCALLFAILALL DC C'An attempt to process a syscall for a socket fa' 03437\n         DC    C'iled on all of the transport providers supporting the' 03438\n         DC    C' socket.'                                              03439\n         DC    X'00'                                                    03440\n         ORG   ETAB+(4*JRSYSCALLFAILONE)                                03441\n         DC    A(MJRSYSCALLFAILONE)                                     03442\n         ORG                                                            03443\nMJRSYSCALLFAILONE DC C'An attempt to process a syscall for a socket fa' 03444\n         DC    C'iled on one of the transport providers supporting the' 03445\n         DC    C' socket.'                                              03446\n         DC    X'00'                                                    03447\n         ORG   ETAB+(4*JRSYSCALLFAILSOME)                               03448\n         DC    A(MJRSYSCALLFAILSOME)                                    03449\n         ORG                                                            03450\nMJRSYSCALLFAILSOME DC C'An attempt to process a syscall for a socket f' 03451\n         DC    C'ailed on some of the transport providers supporting t' 03452\n         DC    C'he socket.'                                            03453\n         DC    X'00'                                                    03454\n         ORG   ETAB+(4*JRSETSOCKOPTFAILALL)                             03455\n         DC    A(MJRSETSOCKOPTFAILALL)                                  03456\n         ORG                                                            03457\nMJRSETSOCKOPTFAILALL DC C'An attempt to set socket options failed on a' 03458\n         DC    C'll of the transport providers supporting the socket. ' 03459\n         DC    C'     '                                                 03460\n         DC    X'00'                                                    03461\n         ORG   ETAB+(4*JRSETSOCKOPTFAILONE)                             03462\n         DC    A(MJRSETSOCKOPTFAILONE)                                  03463\n         ORG                                                            03464\nMJRSETSOCKOPTFAILONE DC C'An attempt to set socket options failed on o' 03465\n         DC    C'ne of the transport providers supporting the socket. ' 03466\n         DC    C'     '                                                 03467\n         DC    X'00'                                                    03468\n         ORG   ETAB+(4*JRSETSOCKOPTFAILSOME)                            03469\n         DC    A(MJRSETSOCKOPTFAILSOME)                                 03470\n         ORG                                                            03471\nMJRSETSOCKOPTFAILSOME DC C'An attempt to set socket options failed on ' 03472\n         DC    C'some of the transport providers supporting the socket' 03473\n         DC    C'.      '                                               03474\n         DC    X'00'                                                    03475\n         ORG   ETAB+(4*JRRLIMITCANTCREATE)                              03476\n         DC    A(MJRRLIMITCANTCREATE)                                   03477\n         ORG                                                            03478\nMJRRLIMITCANTCREATE DC C'You cannot create files when RLIMIT_FSIZE is ' 03479\n         DC    C'0.'                                                    03480\n         DC    X'00'                                                    03481\n         ORG   ETAB+(4*JRNOTSTDFILE)                                    03482\n         DC    A(MJRNOTSTDFILE)                                         03483\n         ORG                                                            03484\nMJRNOTSTDFILE DC C'Only standard files can be mmap'                     03485\n         DC    X'00'                                                    03486\n         ORG   ETAB+(4*JRBADIDTYPE)                                     03487\n         DC    A(MJRBADIDTYPE)                                          03488\n         ORG                                                            03489\nMJRBADIDTYPE DC C'An invalid ID type was passed.'                       03490\n         DC    X'00'                                                    03491\n         ORG   ETAB+(4*JRBADOPTIONS)                                    03492\n         DC    A(MJRBADOPTIONS)                                         03493\n         ORG                                                            03494\nMJRBADOPTIONS DC C'Incorrect options were passed on the options parame' 03495\n         DC    C'ter.'                                                  03496\n         DC    X'00'                                                    03497\n         ORG   ETAB+(4*JRPTYNOTCNTLTERM)                                03498\n         DC    A(MJRPTYNOTCNTLTERM)                                     03499\n         ORG                                                            03500\nMJRPTYNOTCNTLTERM DC C'The device is not associated with a controlling' 03501\n         DC    C' terminal'                                             03502\n         DC    X'00'                                                    03503\n         ORG   ETAB+(4*JRPREVSOCKERROR)                                 03504\n         DC    A(MJRPREVSOCKERROR)                                      03505\n         ORG                                                            03506\nMJRPREVSOCKERROR DC C'A previous error caused this socket to become un' 03507\n         DC    C'usable.'                                               03508\n         DC    X'00'                                                    03509\n         ORG   ETAB+(4*JRBADOSI)                                        03510\n         DC    A(MJRBADOSI)                                             03511\n         ORG                                                            03512\nMJRBADOSI DC C'The Osi structure passed is not valid'                   03513\n         DC    X'00'                                                    03514\n         ORG   ETAB+(4*JRBADPFSID)                                      03515\n         DC    A(MJRBADPFSID)                                           03516\n         ORG                                                            03517\nMJRBADPFSID DC C'The value of the OsiPfsId field is not valid'          03518\n         DC    X'00'                                                    03519\n         ORG   ETAB+(4*JRFRRACTIVE)                                     03520\n         DC    A(MJRFRRACTIVE)                                          03521\n         ORG                                                            03522\nMJRFRRACTIVE DC C'An FRR is established'                                03523\n         DC    X'00'                                                    03524\n         ORG   ETAB+(4*JRPTYQUEUECHANGE)                                03525\n         DC    A(MJRPTYQUEUECHANGE)                                     03526\n         ORG                                                            03527\nMJRPTYQUEUECHANGE DC C'A termios option change requires all output be ' 03528\n         DC    C'read or flushed before further writes'                 03529\n         DC    X'00'                                                    03530\n         ORG   ETAB+(4*JRINTERVALTYPEINVALID)                           03531\n         DC    A(MJRINTERVALTYPEINVALID)                                03532\n         ORG                                                            03533\nMJRINTERVALTYPEINVALID DC C'The IntervalType is not valid'              03534\n         DC    X'00'                                                    03535\n         ORG   ETAB+(4*JRPTYORPHANED)                                   03536\n         DC    A(MJRPTYORPHANED)                                        03537\n         ORG                                                            03538\nMJRPTYORPHANED DC C'The syscall is processing in an orphaned process g' 03539\n         DC    C'roup'                                                  03540\n         DC    X'00'                                                    03541\n         ORG   ETAB+(4*JRTRANSPORTDRIVERNOTACCESSIBLE)                  03542\n         DC    A(MJRTRANSPORTDRIVERNOTACCESSIBLE)                       03543\n         ORG                                                            03544\nMJRTRANSPORTDRIVERNOTACCESSIBLE DC C'The transport driver specified is' 03545\n         DC    C' not being used by the socket specified.'              03546\n         DC    X'00'                                                    03547\n         AIF   ('&SYSTEM_ID'(1,4) NE 'z/OS').NOTZOS2                    03548\n         ORG   ETAB+(4*JRINVSIGNALFORPROCESS)                           03549\n         DC    A(MJRINVSIGNALFORPROCESS)                                03550\n         ORG                                                            03551\nMJRINVSIGNALFORPROCESS DC C'The specified signal number is incorrect'   03552\n         DC    X'00'                                                    03553\n         ORG   ETAB+(4*JRUSERNAMEBAD)                                   03554\n         DC    A(MJRUSERNAMEBAD)                                        03555\n         ORG                                                            03556\nMJRUSERNAMEBAD DC C'The user name is not a valid MVS user name.'        03557\n         DC    X'00'                                                    03558\n.NOTZOS2 ANOP                                                           03559\n         ORG   ETAB+(4*JRTOOMANYFDS)                                    03560\n         DC    A(MJRTOOMANYFDS)                                         03561\n         ORG                                                            03562\nMJRTOOMANYFDS DC C'Too many Fds were specified'                         03563\n         DC    X'00'                                                    03564\n         ORG   ETAB+(4*JRMICROSECONDSTOOBIG)                            03565\n         DC    A(MJRMICROSECONDSTOOBIG)                                 03566\n         ORG                                                            03567\nMJRMICROSECONDSTOOBIG DC C'The value specified for microseconds is out' 03568\n         DC    C'side the allowable range'                              03569\n         DC    X'00'                                                    03570\n         ORG   ETAB+(4*JRSTIMERMMAX)                                    03571\n         DC    A(MJRSTIMERMMAX)                                         03572\n         ORG                                                            03573\nMJRSTIMERMMAX DC C'A 32E system abend has been intercepted by the sysc' 03574\n         DC    C'all. See the appropriate MVS System Codes manual'      03575\n         DC    X'00'                                                    03576\n         ORG   ETAB+(4*JRNOCLNYTHREADSPPT)                              03577\n         DC    A(MJRNOCLNYTHREADSPPT)                                   03578\n         ORG                                                            03579\nMJRNOCLNYTHREADSPPT DC C'Colony thread support has not been built'      03580\n         DC    X'00'                                                    03581\n         ORG   ETAB+(4*JRSHSPMASK)                                      03582\n         DC    A(MJRSHSPMASK)                                           03583\n         ORG                                                            03584\nMJRSHSPMASK DC C'The shared subpool mask is not valid for the current ' 03585\n         DC    C'environment'                                           03586\n         DC    X'00'                                                    03587\n         ORG   ETAB+(4*JRBADOPTNFLAGS)                                  03588\n         DC    A(MJRBADOPTNFLAGS)                                       03589\n         ORG                                                            03590\nMJRBADOPTNFLAGS DC C'Extraneous bits were set in the option flags para' 03591\n         DC    C'meter.'                                                03592\n         DC    X'00'                                                    03593\n         ORG   ETAB+(4*JRNEGFILESIZELIMIT)                              03594\n         DC    A(MJRNEGFILESIZELIMIT)                                   03595\n         ORG                                                            03596\nMJRNEGFILESIZELIMIT DC C'One of the file size limits specified is nega' 03597\n         DC    C'tive.'                                                 03598\n         DC    X'00'                                                    03599\n         ORG   ETAB+(4*JRNOSAFSUPPORT)                                  03600\n         DC    A(MJRNOSAFSUPPORT)                                       03601\n         ORG                                                            03602\nMJRNOSAFSUPPORT DC C'The installed Security product does not support t' 03603\n         DC    C'his function.'                                         03604\n         DC    X'00'                                                    03605\n         ORG   ETAB+(4*JRPTNOSTORAGE)                                   03606\n         DC    A(MJRPTNOSTORAGE)                                        03607\n         ORG                                                            03608\nMJRPTNOSTORAGE DC C'Not enough storage is available for ptrace'         03609\n         DC    X'00'                                                    03610\n         ORG   ETAB+(4*JRPTBUFNOTFOUND)                                 03611\n         DC    A(MJRPTBUFNOTFOUND)                                      03612\n         ORG                                                            03613\nMJRPTBUFNOTFOUND DC C'A Pt_Uncapture ptrace request was issued for a s' 03614\n         DC    C'pecific buffer but the buffer was not previously capt' 03615\n         DC    C'ured with a Pt_Capture request.'                       03616\n         DC    X'00'                                                    03617\n         ORG   ETAB+(4*JRPTTSO)                                         03618\n         DC    A(MJRPTTSO)                                              03619\n         ORG                                                            03620\nMJRPTTSO DC C'The specified ptrace function is not supported in a TSO ' 03621\n         DC    C'address space.'                                        03622\n         DC    X'00'                                                    03623\n         ORG   ETAB+(4*JRAUTHCALLER)                                    03624\n         DC    A(MJRAUTHCALLER)                                         03625\n         ORG                                                            03626\nMJRAUTHCALLER DC C'The caller of this service is authorized.  Authoriz' 03627\n         DC    C'ed callers are not permitted to load or call unauthor' 03628\n         DC    C'ized programs.'                                        03629\n         DC    X'00'                                                    03630\n         ORG   ETAB+(4*JRSINGLETDREQD)                                  03631\n         DC    A(MJRSINGLETDREQD)                                       03632\n         ORG                                                            03633\nMJRSINGLETDREQD DC C'The Common Inet Sockets ioctl command requires th' 03634\n         DC    C'at a single transport driver be connected to the sock' 03635\n         DC    C'et.'                                                   03636\n         DC    X'00'                                                    03637\n         ORG   ETAB+(4*JRBATSEL)                                        03638\n         DC    A(MJRBATSEL)                                             03639\n         ORG                                                            03640\nMJRBATSEL DC C'The batch-select VFS operation is not supported.      '  03641\n         DC    X'00'                                                    03642\n         ORG   ETAB+(4*JRREALPAGENOTSUPPORTED)                          03643\n         DC    A(MJRREALPAGENOTSUPPORTED)                               03644\n         ORG                                                            03645\nMJRREALPAGENOTSUPPORTED DC C'A Fuio area containing a real page addres' 03646\n         DC    C's was passed.'                                         03647\n         DC    X'00'                                                    03648\n         ORG   ETAB+(4*JRBADMVSPGMNAME)                                 03649\n         DC    A(MJRBADMVSPGMNAME)                                      03650\n         ORG                                                            03651\nMJRBADMVSPGMNAME DC C'A call to the exec or loadHFS service specified ' 03652\n         DC    C'a file that resolves to an MVS program name that is n' 03653\n         DC    C'ot valid.'                                             03654\n         DC    X'00'                                                    03655\n         ORG   ETAB+(4*JRMVSLOADFAILURE)                                03656\n         DC    A(MJRMVSLOADFAILURE)                                     03657\n         ORG                                                            03658\nMJRMVSLOADFAILURE DC C'A call to the loadHFS service resulted in a fai' 03659\n         DC    C'lure in the MVS Load service.'                         03660\n         DC    X'00'                                                    03661\n         ORG   ETAB+(4*JRMVSPGMNOTFOUND)                                03662\n         DC    A(MJRMVSPGMNOTFOUND)                                     03663\n         ORG                                                            03664\nMJRMVSPGMNOTFOUND DC C'A call to the exec or loadHFS service specified' 03665\n         DC    C' a file that resolves to an MVS program that cannot b' 03666\n         DC    C'e found.'                                              03667\n         DC    X'00'                                                    03668\n         ORG   ETAB+(4*JRNOCONSOLEBUFFERS)                              03669\n         DC    A(MJRNOCONSOLEBUFFERS)                                   03670\n         ORG                                                            03671\nMJRNOCONSOLEBUFFERS DC C'The write to /dev/console cannot complete'     03672\n         DC    X'00'                                                    03673\n         ORG   ETAB+(4*JRPTMAXCAPTURE)                                  03674\n         DC    A(MJRPTMAXCAPTURE)                                       03675\n         ORG                                                            03676\nMJRPTMAXCAPTURE DC C'The ptrace capture request would exceed maximum a' 03677\n         DC    C'llowed'                                                03678\n         DC    X'00'                                                    03679\n         ORG   ETAB+(4*JRCPCNNOTENABLED)                                03680\n         DC    A(MJRCPCNNOTENABLED)                                     03681\n         ORG                                                            03682\nMJRCPCNNOTENABLED DC C'Code Page Change Notification is not enabled'    03683\n         DC    X'00'                                                    03684\n         ORG   ETAB+(4*JRSHRSTGSHORTAGE)                                03685\n         DC    A(MJRSHRSTGSHORTAGE)                                     03686\n         ORG                                                            03687\nMJRSHRSTGSHORTAGE DC C'Request for shared storage exceeds amount avail' 03688\n         DC    C'able'                                                  03689\n         DC    X'00'                                                    03690\n         ORG   ETAB+(4*JRPTYNEEDPKTXTND)                                03691\n         DC    A(MJRPTYNEEDPKTXTND)                                     03692\n         ORG                                                            03693\nMJRPTYNEEDPKTXTND DC C'An attempt was made to set 3270 Passthru mode w' 03694\n         DC    C'ithout 3270 Packet mode.'                              03695\n         DC    X'00'                                                    03696\n******************************************************************      03697\n         ORG   ETAB+(4*JRWAITFOREVER)                                   03698\n         DC    A(MJRWAITFOREVER)                                        03699\n         ORG                                                            03700\nMJRWAITFOREVER DC C'The timeout value specified wait forever, but ther' 03701\n         DC    C'e were no events to wait for.'                         03702\n         DC    X'00'                                                    03703\n         ORG   ETAB+(4*JRINVALIDNFDS)                                   03704\n         DC    A(MJRINVALIDNFDS)                                        03705\n         ORG                                                            03706\nMJRINVALIDNFDS DC C'The NFDS parameter is larger than the OPEN_MAX(MAX' 03707\n         DC    C'FILEPROC) value.'                                      03708\n         DC    X'00'                                                    03709\n         ORG   ETAB+(4*JRPTYNOTMASTER)                                  03710\n         DC    A(MJRPTYNOTMASTER)                                       03711\n         ORG                                                            03712\nMJRPTYNOTMASTER DC C'Unsupported function against slave TTY'            03713\n         DC    X'00'                                                    03714\n         ORG   ETAB+(4*JRFSUNAUTHCLNT)                                  03715\n         DC    A(MJRFSUNAUTHCLNT)                                       03716\n         ORG                                                            03717\nMJRFSUNAUTHCLNT DC C'An unauthenticated client is denied access.'       03718\n         DC    X'00'                                                    03719\n         ORG   ETAB+(4*JRBADBUFLEN)                                     03720\n         DC    A(MJRBADBUFLEN)                                          03721\n         ORG                                                            03722\nMJRBADBUFLEN DC C'The length of the buffer is not valid      '          03723\n         DC    X'00'                                                    03724\n         ORG   ETAB+(4*JRBADSTGKEY)                                     03725\n         DC    A(MJRBADSTGKEY)                                          03726\n         ORG                                                            03727\nMJRBADSTGKEY DC C'The message data could not be fetched using the spec' 03728\n         DC    C'ified storage key'                                     03729\n         DC    X'00'                                                    03730\n         ORG   ETAB+(4*JRNOFDSTOOMANYQIDS)                              03731\n         DC    A(MJRNOFDSTOOMANYQIDS)                                   03732\n         ORG                                                            03733\nMJRNOFDSTOOMANYQIDS DC C'The number of Fds specified is negative or to' 03734\n         DC    C'o many Msg Q Ids specified on select or poll service'  03735\n         DC    X'00'                                                    03736\n         ORG   ETAB+(4*JRINVHDR)                                        03737\n         DC    A(MJRINVHDR)                                             03738\n         ORG                                                            03739\nMJRINVHDR DC C'Invalid parameter list header'                           03740\n         DC    X'00'                                                    03741\n         ORG   ETAB+(4*JROUTOFMOUNTENTRIES)                             03742\n         DC    A(MJROUTOFMOUNTENTRIES)                                  03743\n         ORG                                                            03744\nMJROUTOFMOUNTENTRIES DC C'The system is unable to obtain an entry in t' 03745\n         DC    C'he file system mount table in the OMVS couple data se' 03746\n         DC    C't'                                                     03747\n         DC    X'00'                                                    03748\n         ORG   ETAB+(4*JRPTYUNSUPPORTEDATTR)                            03749\n         DC    A(MJRPTYUNSUPPORTEDATTR)                                 03750\n         ORG                                                            03751\nMJRPTYUNSUPPORTEDATTR DC C'Attempt to change attribute to unsupported ' 03752\n         DC    C'value      '                                           03753\n         DC    X'00'                                                    03754\n         ORG   ETAB+(4*JRTGTMEMBERINACTIVE)                             03755\n         DC    A(MJRTGTMEMBERINACTIVE)                                  03756\n         ORG                                                            03757\nMJRTGTMEMBERINACTIVE DC C'The XCF member represented by the input memb' 03758\n         DC    C'er token is not active'                                03759\n         DC    X'00'                                                    03760\n         ORG   ETAB+(4*JRSTALEVFS)                                      03761\n         DC    A(MJRSTALEVFS)                                           03762\n         ORG                                                            03763\nMJRSTALEVFS DC C'The Vfs passed to complete asynchronous mount does no' 03764\n         DC    C't represent an outstanding asynchronous mount.'        03765\n         DC    X'00'                                                    03766\n         ORG   ETAB+(4*JRNOAREA)                                        03767\n         DC    A(MJRNOAREA)                                             03768\n         ORG                                                            03769\nMJRNOAREA DC C'The State Area has not been established.'                03770\n         DC    X'00'                                                    03771\n         ORG   ETAB+(4*JRBADSUBFIELD)                                   03772\n         DC    A(MJRBADSUBFIELD)                                        03773\n         ORG                                                            03774\nMJRBADSUBFIELD DC C'A subfield of the Argument is not valid.'           03775\n         DC    X'00'                                                    03776\n         ORG   ETAB+(4*JRNOCHANGEIDENTITY)                              03777\n         DC    A(MJRNOCHANGEIDENTITY)                                   03778\n         ORG                                                            03779\nMJRNOCHANGEIDENTITY DC C'The invoker is not authorized to change MVS u' 03780\n         DC    C'serids.'                                               03781\n         DC    X'00'                                                    03782\n         ORG   ETAB+(4*JRBADID)                                         03783\n         DC    A(MJRBADID)                                              03784\n         ORG                                                            03785\nMJRBADID DC C'An incorrect ID value was passed to the BPX1WTE service.' 03786\n         DC    X'00'                                                    03787\n         ORG   ETAB+(4*JRNOWORKUNIT)                                    03788\n         DC    A(MJRNOWORKUNIT)                                         03789\n         ORG                                                            03790\nMJRNOWORKUNIT DC C'Attempt to transfer work via BPX1SPW call failed'    03791\n         DC    X'00'                                                    03792\n         ORG   ETAB+(4*JRNOWLMCONN)                                     03793\n         DC    A(MJRNOWLMCONN)                                          03794\n         ORG                                                            03795\nMJRNOWLMCONN DC C'Attempt to refresh work via BPX1SPW call failed'      03796\n         DC    X'00'                                                    03797\n         ORG   ETAB+(4*JRNOMULTI)                                       03798\n         DC    A(MJRNOMULTI)                                            03799\n         ORG                                                            03800\nMJRNOMULTI DC C'Attempt to issue multiple BPX1CCS calls      '          03801\n         DC    X'00'                                                    03802\n         ORG   ETAB+(4*JRMSGLENGTHERR)                                  03803\n         DC    A(MJRMSGLENGTHERR)                                       03804\n         ORG                                                            03805\nMJRMSGLENGTHERR DC C'Message length to the console was exceeded      '  03806\n         DC    X'00'                                                    03807\n         ORG   ETAB+(4*JRINVALIDCLASSIFY)                               03808\n         DC    A(MJRINVALIDCLASSIFY)                                    03809\n         ORG                                                            03810\nMJRINVALIDCLASSIFY DC C'The classification area is not accessible to t' 03811\n         DC    C'he current caller'                                     03812\n         DC    X'00'                                                    03813\n         ORG   ETAB+(4*JRNOENCLAVE)                                     03814\n         DC    A(MJRNOENCLAVE)                                          03815\n         ORG                                                            03816\nMJRNOENCLAVE DC C'No enclave is associated with the calling thread or ' 03817\n         DC    C'process.'                                              03818\n         DC    X'00'                                                    03819\n         ORG   ETAB+(4*JRSUBSYSNOTFND)                                  03820\n         DC    A(MJRSUBSYSNOTFND)                                       03821\n         ORG                                                            03822\nMJRSUBSYSNOTFND DC C'No process was found with the associated subsyste' 03823\n         DC    C'mtype and subsystem name.'                             03824\n         DC    X'00'                                                    03825\n         ORG   ETAB+(4*JRAPPLDATALENERR)                                03826\n         DC    A(MJRAPPLDATALENERR)                                     03827\n         ORG                                                            03828\nMJRAPPLDATALENERR DC C'The application data area is too large to be pr' 03829\n         DC    C'ocessed'                                               03830\n         DC    X'00'                                                    03831\n         ORG   ETAB+(4*JRINVALIDAPPLDATA)                               03832\n         DC    A(MJRINVALIDAPPLDATA)                                    03833\n         ORG                                                            03834\nMJRINVALIDAPPLDATA DC C'The application data area passed was not acces' 03835\n         DC    C'sible'                                                 03836\n         DC    X'00'                                                    03837\n         ORG   ETAB+(4*JRINVALIDAPPLDATA2)                              03838\n         DC    A(MJRINVALIDAPPLDATA2)                                   03839\n         ORG                                                            03840\nMJRINVALIDAPPLDATA2 DC C'The application data area is not accessible t' 03841\n         DC    C'o the current caller'                                  03842\n         DC    X'00'                                                    03843\n         ORG   ETAB+(4*JRINVALIDSFDL)                                   03844\n         DC    A(MJRINVALIDSFDL)                                        03845\n         ORG                                                            03846\nMJRINVALIDSFDL DC C'The file descriptor list passed was not accessible' 03847\n         DC    X'00'                                                    03848\n         ORG   ETAB+(4*JRNEWLOCATIONERR)                                03849\n         DC    A(MJRNEWLOCATIONERR)                                     03850\n         ORG                                                            03851\nMJRNEWLOCATIONERR DC C'The new tag data area passed was not accessible' 03852\n         DC    X'00'                                                    03853\n         ORG   ETAB+(4*JROLDLOCATIONERR)                                03854\n         DC    A(MJROLDLOCATIONERR)                                     03855\n         ORG                                                            03856\nMJROLDLOCATIONERR DC C'The old tag data area passed was not accessible' 03857\n         DC    X'00'                                                    03858\n         ORG   ETAB+(4*JRNEWLENBAD)                                     03859\n         DC    A(MJRNEWLENBAD)                                          03860\n         ORG                                                            03861\nMJRNEWLENBAD DC C'The new tag data length was not valid'                03862\n         DC    X'00'                                                    03863\n         ORG   ETAB+(4*JRMSGATTRERR)                                    03864\n         DC    A(MJRMSGATTRERR)                                         03865\n         ORG                                                            03866\nMJRMSGATTRERR DC C'Message attribute error detected'                    03867\n         DC    X'00'                                                    03868\n         ORG   ETAB+(4*JRNOACK)                                         03869\n         DC    A(MJRNOACK)                                              03870\n         ORG                                                            03871\nMJRNOACK DC C'No acknowledgement signal from remote system      '       03872\n         DC    X'00'                                                    03873\n         ORG   ETAB+(4*JRINACCESSIBLE)                                  03874\n         DC    A(MJRINACCESSIBLE)                                       03875\n         ORG                                                            03876\nMJRINACCESSIBLE DC C'The user storage is inaccessible      '            03877\n         DC    X'00'                                                    03878\n         ORG   ETAB+(4*JRIEFDDSRVFAILED)                                03879\n         DC    A(MJRIEFDDSRVFAILED)                                     03880\n         ORG                                                            03881\nMJRIEFDDSRVFAILED DC C'The macro IEFDDSRV failed'                       03882\n         DC    X'00'                                                    03883\n         ORG   ETAB+(4*JRSVC99FAILED)                                   03884\n         DC    A(MJRSVC99FAILED)                                        03885\n         ORG                                                            03886\nMJRSVC99FAILED DC C'SVC 99 (Allocate) failed'                           03887\n         DC    X'00'                                                    03888\n         ORG   ETAB+(4*JRDEVNOTONLINE)                                  03889\n         DC    A(MJRDEVNOTONLINE)                                       03890\n         ORG                                                            03891\nMJRDEVNOTONLINE DC C'Specified device is not online'                    03892\n         DC    X'00'                                                    03893\n         ORG   ETAB+(4*JRDEVNOTFOUND)                                   03894\n         DC    A(MJRDEVNOTFOUND)                                        03895\n         ORG                                                            03896\nMJRDEVNOTFOUND DC C'Specified device is not found'                      03897\n         DC    X'00'                                                    03898\n         ORG   ETAB+(4*JRALREADYINPROGRESS)                             03899\n         DC    A(MJRALREADYINPROGRESS)                                  03900\n         ORG                                                            03901\nMJRALREADYINPROGRESS DC C'Another config request is in progress      '  03902\n         DC    X'00'                                                    03903\n         ORG   ETAB+(4*JRINVALIDVERSION)                                03904\n         DC    A(MJRINVALIDVERSION)                                     03905\n         ORG                                                            03906\nMJRINVALIDVERSION DC C'Config request has invalid version number      ' 03907\n         DC    X'00'                                                    03908\n         ORG   ETAB+(4*JRNOTAUTHWLM)                                    03909\n         DC    A(MJRNOTAUTHWLM)                                         03910\n         ORG                                                            03911\nMJRNOTAUTHWLM DC C'Server_init service call failed permission check fo' 03912\n         DC    C'r BPX.WLMSERVER facility class profile.'               03913\n         DC    X'00'                                                    03914\n         ORG   ETAB+(4*JRTARGETIPNOTFOUND)                              03915\n         DC    A(MJRTARGETIPNOTFOUND)                                   03916\n         ORG                                                            03917\nMJRTARGETIPNOTFOUND DC C'Target IP address cannot be found'             03918\n         DC    X'00'                                                    03919\n         ORG   ETAB+(4*JRESCONNOTCONFIGURED)                            03920\n         DC    A(MJRESCONNOTCONFIGURED)                                 03921\n         ORG                                                            03922\nMJRESCONNOTCONFIGURED DC C'The ESCON connection is not configured     ' 03923\n         DC    C' '                                                     03924\n         DC    X'00'                                                    03925\n         ORG   ETAB+(4*JRPTYSLAVELOCKED)                                03926\n         DC    A(MJRPTYSLAVELOCKED)                                     03927\n         ORG                                                            03928\nMJRPTYSLAVELOCKED DC C'A grantpt() was issued against the master pty b' 03929\n         DC    C'ut an unlockpt() has not yet been issued.'             03930\n         DC    X'00'                                                    03931\n         ORG   ETAB+(4*JRPTYSLAVENOTLOCKED)                             03932\n         DC    A(MJRPTYSLAVENOTLOCKED)                                  03933\n         ORG                                                            03934\nMJRPTYSLAVENOTLOCKED DC C'The slave pty is not locked either because g' 03935\n         DC    C'rantpt was not done or because grantpt has already be' 03936\n         DC    C'en issued.'                                            03937\n         DC    X'00'                                                    03938\n         ORG   ETAB+(4*JRPTYGRANTPTDONE)                                03939\n         DC    A(MJRPTYGRANTPTDONE)                                     03940\n         ORG                                                            03941\nMJRPTYGRANTPTDONE DC C'grantpt() has already been issued.  This grantp' 03942\n         DC    C't is redundant.'                                       03943\n         DC    X'00'                                                    03944\n         ORG   ETAB+(4*JRSRBSNOTALLOWED)                                03945\n         DC    A(MJRSRBSNOTALLOWED)                                     03946\n         ORG                                                            03947\nMJRSRBSNOTALLOWED DC C'Issuing syscalls from an SRB is not allowed'     03948\n         DC    X'00'                                                    03949\n         ORG   ETAB+(4*JRNOTSRBSYSCALL)                                 03950\n         DC    A(MJRNOTSRBSYSCALL)                                      03951\n         ORG                                                            03952\nMJRNOTSRBSYSCALL DC C'The syscall requested is not supported in SRB mo' 03953\n         DC    C'de'                                                    03954\n         DC    X'00'                                                    03955\n         ORG   ETAB+(4*JRRTSSCONNERR)                                   03956\n         DC    A(MJRRTSSCONNERR)                                        03957\n         ORG                                                            03958\nMJRRTSSCONNERR DC C'Fork child processing failed due to a RTSS connect' 03959\n         DC    C'ion error.'                                            03960\n         DC    X'00'                                                    03961\n         ORG   ETAB+(4*JRRTSSENVERR)                                    03962\n         DC    A(MJRRTSSENVERR)                                         03963\n         ORG                                                            03964\nMJRRTSSENVERR DC C'Fork parent processing failed due to a RTSS environ' 03965\n         DC    C'ment error.'                                           03966\n         DC    X'00'                                                    03967\n         ORG   ETAB+(4*JRASYNCAUTHERR)                                  03968\n         DC    A(MJRASYNCAUTHERR)                                       03969\n         ORG                                                            03970\nMJRASYNCAUTHERR DC C'User is not authorized for asynchronous i/o.'      03971\n         DC    X'00'                                                    03972\n         ORG   ETAB+(4*JRASYNCRWLENZERO)                                03973\n         DC    A(MJRASYNCRWLENZERO)                                     03974\n         ORG                                                            03975\nMJRASYNCRWLENZERO DC C'Zero length asynchronous read or write not perm' 03976\n         DC    C'itted.'                                                03977\n         DC    X'00'                                                    03978\n         ORG   ETAB+(4*JRASYNCBADMSGHDRLEN)                             03979\n         DC    A(MJRASYNCBADMSGHDRLEN)                                  03980\n         ORG                                                            03981\nMJRASYNCBADMSGHDRLEN DC C'AioBuffSize is not set to correct message he' 03982\n         DC    C'ader length.'                                          03983\n         DC    X'00'                                                    03984\n         ORG   ETAB+(4*JRASYNCBADCMD)                                   03985\n         DC    A(MJRASYNCBADCMD)                                        03986\n         ORG                                                            03987\nMJRASYNCBADCMD DC C'AioCmd is not set to a supported value.'            03988\n         DC    X'00'                                                    03989\n         ORG   ETAB+(4*JRASYNCBADNOTIFYTYPE)                            03990\n         DC    A(MJRASYNCBADNOTIFYTYPE)                                 03991\n         ORG                                                            03992\nMJRASYNCBADNOTIFYTYPE DC C'AioNotifyType is not set to a supported val' 03993\n         DC    C'ue.'                                                   03994\n         DC    X'00'                                                    03995\n         ORG   ETAB+(4*JRASYNCBADOFFSET)                                03996\n         DC    A(MJRASYNCBADOFFSET)                                     03997\n         ORG                                                            03998\nMJRASYNCBADOFFSET DC C'AioOffset is a negative value.'                  03999\n         DC    X'00'                                                    04000\n         ORG   ETAB+(4*JRASYNCBADAIOCBLEN)                              04001\n         DC    A(MJRASYNCBADAIOCBLEN)                                   04002\n         ORG                                                            04003\nMJRASYNCBADAIOCBLEN DC C'The input length for the AioCb is not a suppo' 04004\n         DC    C'rted length.'                                          04005\n         DC    X'00'                                                    04006\n         ORG   ETAB+(4*JRASYNCBADSOCKADDR)                              04007\n         DC    A(MJRASYNCBADSOCKADDR)                                   04008\n         ORG                                                            04009\nMJRASYNCBADSOCKADDR DC C'The AioSockAddr or AioSockAddrLen contains a ' 04010\n         DC    C'bad value.'                                            04011\n         DC    X'00'                                                    04012\n         ORG   ETAB+(4*JRCANCEL)                                        04013\n         DC    A(MJRCANCEL)                                             04014\n         ORG                                                            04015\nMJRCANCEL DC C'Vnode operation CANCEL is not supported by this file sy' 04016\n         DC    C'stem'                                                  04017\n         DC    X'00'                                                    04018\n         ORG   ETAB+(4*JRDUPLICATECANCEL)                               04019\n         DC    A(MJRDUPLICATECANCEL)                                    04020\n         ORG                                                            04021\nMJRDUPLICATECANCEL DC C'A cancel operation is already in progress for ' 04022\n         DC    C'the target asyncio request.'                           04023\n         DC    X'00'                                                    04024\n         ORG   ETAB+(4*JRASYNCNOTSINGLETD)                              04025\n         DC    A(MJRASYNCNOTSINGLETD)                                   04026\n         ORG                                                            04027\nMJRASYNCNOTSINGLETD DC C'The AsyncIO operation can not be performed be' 04028\n         DC    C'cause this socket does not have a chosen transport st' 04029\n         DC    C'ack.'                                                  04030\n         DC    X'00'                                                    04031\n         ORG   ETAB+(4*JRSMFNOTAUTHORIZED)                              04032\n         DC    A(MJRSMFNOTAUTHORIZED)                                   04033\n         ORG                                                            04034\nMJRSMFNOTAUTHORIZED DC C'The __smf_record function can not be performe' 04035\n         DC    C'd because the caller is not permitted to the BPX.SMF ' 04036\n         DC    C'facility class.'                                       04037\n         DC    X'00'                                                    04038\n         ORG   ETAB+(4*JRSMFNOTACCEPTING)                               04039\n         DC    A(MJRSMFNOTACCEPTING)                                    04040\n         ORG                                                            04041\nMJRSMFNOTACCEPTING DC C'SMF is not recording SMF records of the type a' 04042\n         DC    C'nd subtype requested.'                                 04043\n         DC    X'00'                                                    04044\n         ORG   ETAB+(4*JRSMFNOTACTIVE)                                  04045\n         DC    A(MJRSMFNOTACTIVE)                                       04046\n         ORG                                                            04047\nMJRSMFNOTACTIVE DC C'SMF is not active.'                                04048\n         DC    X'00'                                                    04049\n         ORG   ETAB+(4*JRSMFBADRECORDLENGTH)                            04050\n         DC    A(MJRSMFBADRECORDLENGTH)                                 04051\n         ORG                                                            04052\nMJRSMFBADRECORDLENGTH DC C'The the length of the SMF record passed to ' 04053\n         DC    C'__smf_recordis either too large or too small.'         04054\n         DC    X'00'                                                    04055\n         ORG   ETAB+(4*JRENCLAVESEXIST)                                 04056\n         DC    A(MJRENCLAVESEXIST)                                      04057\n         ORG                                                            04058\nMJRENCLAVESEXIST DC C'The calling work manager has enclaves that it cr' 04059\n         DC    C'eated that have yet to be serviced.'                   04060\n         DC    X'00'                                                    04061\n         ORG   ETAB+(4*JRBINDNOTDONE)                                   04062\n         DC    A(MJRBINDNOTDONE)                                        04063\n         ORG                                                            04064\nMJRBINDNOTDONE DC C'Bind() must be issued before issuing read/write'    04065\n         DC    X'00'                                                    04066\n         ORG   ETAB+(4*JRPINGSELF)                                      04067\n         DC    A(MJRPINGSELF)                                           04068\n         ORG                                                            04069\nMJRPINGSELF DC C'Ping to self is not supported'                         04070\n         DC    X'00'                                                    04071\n         ORG   ETAB+(4*JRDUPLICATEREQ)                                  04072\n         DC    A(MJRDUPLICATEREQ)                                       04073\n         ORG                                                            04074\nMJRDUPLICATEREQ DC C'Requested connection already exists'               04075\n         DC    X'00'                                                    04076\n         ORG   ETAB+(4*JRTRLENOTFOUND)                                  04077\n         DC    A(MJRTRLENOTFOUND)                                       04078\n         ORG                                                            04079\nMJRTRLENOTFOUND DC C'Target TRLE name cannot be found'                  04080\n         DC    X'00'                                                    04081\n         ORG   ETAB+(4*JRFASTPATHRANGE)                                 04082\n         DC    A(MJRFASTPATHRANGE)                                      04083\n         ORG                                                            04084\nMJRFASTPATHRANGE DC C'A new socket descriptor is too large for Fastpat' 04085\n         DC    C'h.'                                                    04086\n         DC    X'00'                                                    04087\n         ORG   ETAB+(4*JRROSALREADYREG)                                 04088\n         DC    A(MJRROSALREADYREG)                                      04089\n         ORG                                                            04090\nMJRROSALREADYREG DC C'An error occurred during process signal initiali' 04091\n         DC    C'zation'                                                04092\n         DC    X'00'                                                    04093\n         ORG   ETAB+(4*JRASYNCSIGKEY0ERR)                               04094\n         DC    A(MJRASYNCSIGKEY0ERR)                                    04095\n         ORG                                                            04096\nMJRASYNCSIGKEY0ERR DC C'A caller in key 0 cannot request signals for a' 04097\n         DC    C'sync i/o.'                                             04098\n         DC    X'00'                                                    04099\n         ORG   ETAB+(4*JRASYNCEXITMODETCB)                              04100\n         DC    A(MJRASYNCEXITMODETCB)                                   04101\n         ORG                                                            04102\nMJRASYNCEXITMODETCB DC C'A request for ExitMode of TCB was requested f' 04103\n         DC    C'or a user who is either not running on a TCB or runni' 04104\n         DC    C'ng in key 0.'                                          04105\n         DC    X'00'                                                    04106\n         ORG   ETAB+(4*JRASYNCOPNOTSUPP)                                04107\n         DC    A(MJRASYNCOPNOTSUPP)                                     04108\n         ORG                                                            04109\nMJRASYNCOPNOTSUPP DC C'The AsyncIO operation can not be performed beca' 04110\n         DC    C'use the socket transport does not support asynchronou' 04111\n         DC    C's I/O or asynchronous select included a physical file' 04112\n         DC    C' system that could not support this operation.'        04113\n         DC    X'00'                                                    04114\n         ORG   ETAB+(4*JRASYNCBADSIGNO)                                 04115\n         DC    A(MJRASYNCBADSIGNO)                                      04116\n         ORG                                                            04117\nMJRASYNCBADSIGNO DC C'The AsyncIO operation specified a signal number ' 04118\n         DC    C'that   does not fall within the valid range of values' 04119\n         DC    C'.'                                                     04120\n         DC    X'00'                                                    04121\n         ORG   ETAB+(4*JRPRIVILIGEDFILE)                                04122\n         DC    A(MJRPRIVILIGEDFILE)                                     04123\n         ORG                                                            04124\nMJRPRIVILIGEDFILE DC C'The operation is not allowed on a priviliged fi' 04125\n         DC    C'le'                                                    04126\n         DC    X'00'                                                    04127\n         ORG   ETAB+(4*JRROUTEEXISTS)                                   04128\n         DC    A(MJRROUTEEXISTS)                                        04129\n         ORG                                                            04130\nMJRROUTEEXISTS DC C'The oeifconfig contained a duplicate destination I' 04131\n         DC    C'P address'                                             04132\n         DC    X'00'                                                    04133\n         ORG   ETAB+(4*JRHOMEEXISTS)                                    04134\n         DC    A(MJRHOMEEXISTS)                                         04135\n         ORG                                                            04136\nMJRHOMEEXISTS DC C'The oeifconfig contained a duplicate home IP addres' 04137\n         DC    C's'                                                     04138\n         DC    X'00'                                                    04139\n         ORG   ETAB+(4*JRAPFNOTAUTHORIZED)                              04140\n         DC    A(MJRAPFNOTAUTHORIZED)                                   04141\n         ORG                                                            04142\nMJRAPFNOTAUTHORIZED DC C'The chattr function can not be performed to c' 04143\n         DC    C'hange the APF attribute because the caller is not per' 04144\n         DC    C'mitted to the BPX.FILEATTR.APF facility class.'        04145\n         DC    X'00'                                                    04146\n         ORG   ETAB+(4*JRPGMNOTAUTHORIZED)                              04147\n         DC    A(MJRPGMNOTAUTHORIZED)                                   04148\n         ORG                                                            04149\nMJRPGMNOTAUTHORIZED DC C'The chattr function can not be performed to c' 04150\n         DC    C'hange the program control attribute because the calle' 04151\n         DC    C'r is not permitted to the BPX.FILEATTR.PROGCTL facili' 04152\n         DC    C'ty class.'                                             04153\n         DC    X'00'                                                    04154\n         ORG   ETAB+(4*JRPROGCNTL)                                      04155\n         DC    A(MJRPROGCNTL)                                           04156\n         ORG                                                            04157\nMJRPROGCNTL DC C'A request to load an HFS executable that is not progr' 04158\n         DC    C'am controlled was made into an environment that must ' 04159\n         DC    C'be kept clean.'                                        04160\n         DC    X'00'                                                    04161\n         ORG   ETAB+(4*JRFILESZEXCDLIMIT)                               04162\n         DC    A(MJRFILESZEXCDLIMIT)                                    04163\n         ORG                                                            04164\nMJRFILESZEXCDLIMIT DC C'A request to load a file into the LFS Cache wa' 04165\n         DC    C's made for a file that exceeds the size limit of the ' 04166\n         DC    C'cache.'                                                04167\n         DC    X'00'                                                    04168\n         ORG   ETAB+(4*JRFILEISEMPTY)                                   04169\n         DC    A(MJRFILEISEMPTY)                                        04170\n         ORG                                                            04171\nMJRFILEISEMPTY DC C'A request to load a file into the LFS Cache was ma' 04172\n         DC    C'de for a file that is empty.'                          04173\n         DC    X'00'                                                    04174\n         ORG   ETAB+(4*JRCACHENOTREGFILE)                               04175\n         DC    A(MJRCACHENOTREGFILE)                                    04176\n         ORG                                                            04177\nMJRCACHENOTREGFILE DC C'Requests to load a file into the LFS Cache are' 04178\n         DC    C' valid for only regular files.'                        04179\n         DC    X'00'                                                    04180\n         ORG   ETAB+(4*JRNOTMVSLOCALFILE)                               04181\n         DC    A(MJRNOTMVSLOCALFILE)                                    04182\n         ORG                                                            04183\nMJRNOTMVSLOCALFILE DC C'Requests to load a file into the LFS Cache are' 04184\n         DC    C' valid for only OS/390 local files.'                   04185\n         DC    X'00'                                                    04186\n         ORG   ETAB+(4*JRFILEINUSE)                                     04187\n         DC    A(MJRFILEINUSE)                                          04188\n         ORG                                                            04189\nMJRFILEINUSE DC C'The file cannot be loaded into the LFS Cache because' 04190\n         DC    C' the file is currently in use or the cleanup daemon h' 04191\n         DC    C'as not completed.'                                     04192\n         DC    X'00'                                                    04193\n         ORG   ETAB+(4*JRNOFREEENTRY)                                   04194\n         DC    A(MJRNOFREEENTRY)                                        04195\n         ORG                                                            04196\nMJRNOFREEENTRY DC C'No free entries in the interface control array'     04197\n         DC    X'00'                                                    04198\n         ORG   ETAB+(4*JRINHEUSERID)                                    04199\n         DC    A(MJRINHEUSERID)                                         04200\n         ORG                                                            04201\nMJRINHEUSERID DC C'User Id specified in Inheritance structure is not v' 04202\n         DC    C'alid.'                                                 04203\n         DC    X'00'                                                    04204\n         ORG   ETAB+(4*JRINHEREGION)                                    04205\n         DC    A(MJRINHEREGION)                                         04206\n         ORG                                                            04207\nMJRINHEREGION DC C'Region size specified in Inheritance structure is n' 04208\n         DC    C'ot valid.'                                             04209\n         DC    X'00'                                                    04210\n         ORG   ETAB+(4*JRINHECPUTIME)                                   04211\n         DC    A(MJRINHECPUTIME)                                        04212\n         ORG                                                            04213\nMJRINHECPUTIME DC C'CPU Time specified in Inheritance structure is not' 04214\n         DC    C' valid.'                                               04215\n         DC    X'00'                                                    04216\n         ORG   ETAB+(4*JRINHEACCTDATAPTR)                               04217\n         DC    A(MJRINHEACCTDATAPTR)                                    04218\n         ORG                                                            04219\nMJRINHEACCTDATAPTR DC C'The account data pointer in the Inheritance st' 04220\n         DC    C'ructurepoints to a location not addressable by the ca' 04221\n         DC    C'ller'                                                  04222\n         DC    X'00'                                                    04223\n         ORG   ETAB+(4*JRINHECWD)                                       04224\n         DC    A(MJRINHECWD)                                            04225\n         ORG                                                            04226\nMJRINHECWD DC C'CWD specified in Inheritance structure is not valid.'   04227\n         DC    X'00'                                                    04228\n         ORG   ETAB+(4*JRTOOMANYINTF)                                   04229\n         DC    A(MJRTOOMANYINTF)                                        04230\n         ORG                                                            04231\nMJRTOOMANYINTF DC C'Too many configured interfaces already exist'       04232\n         DC    X'00'                                                    04233\n         ORG   ETAB+(4*JRBADIPADDR)                                     04234\n         DC    A(MJRBADIPADDR)                                          04235\n         ORG                                                            04236\nMJRBADIPADDR DC C'An IP address in the configured interface is incorre' 04237\n         DC    C'ct'                                                    04238\n         DC    X'00'                                                    04239\n         ORG   ETAB+(4*JRDATANOTAVAIL)                                  04240\n         DC    A(MJRDATANOTAVAIL)                                       04241\n         ORG                                                            04242\nMJRDATANOTAVAIL DC C'There are no elements to read on ESCON receive qu' 04243\n         DC    C'eue'                                                   04244\n         DC    X'00'                                                    04245\n         ORG   ETAB+(4*JRREQDENIED)                                     04246\n         DC    A(MJRREQDENIED)                                          04247\n         ORG                                                            04248\nMJRREQDENIED DC C'The oeifconfig request is not accepted'               04249\n         DC    X'00'                                                    04250\n         ORG   ETAB+(4*JRBADMTUSIZE)                                    04251\n         DC    A(MJRBADMTUSIZE)                                         04252\n         ORG                                                            04253\nMJRBADMTUSIZE DC C'The specified MTU size for the interface is incorre' 04254\n         DC    C'ct'                                                    04255\n         DC    X'00'                                                    04256\n         ORG   ETAB+(4*JRNOTOSA)                                        04257\n         DC    A(MJRNOTOSA)                                             04258\n         ORG                                                            04259\nMJRNOTOSA DC C'Current interface is not an OSA adapter'                 04260\n         DC    X'00'                                                    04261\n         ORG   ETAB+(4*JRBADOSAPORT)                                    04262\n         DC    A(MJRBADOSAPORT)                                         04263\n         ORG                                                            04264\nMJRBADOSAPORT DC C'Incorrect OSA port number specified'                 04265\n         DC    X'00'                                                    04266\n         ORG   ETAB+(4*JRFORKEXITRCOVERLAYPGMNOTVALID)                  04267\n         DC    A(MJRFORKEXITRCOVERLAYPGMNOTVALID)                       04268\n         ORG                                                            04269\nMJRFORKEXITRCOVERLAYPGMNOTVALID DC C'Contents Supervisor Fork Exit can' 04270\n         DC    C'not fork overlay programs'                             04271\n         DC    X'00'                                                    04272\n         ORG   ETAB+(4*JRMSGMAXLINES)                                   04273\n         DC    A(MJRMSGMAXLINES)                                        04274\n         ORG                                                            04275\nMJRMSGMAXLINES DC C'Maximum number of lines was exceeded      '         04276\n         DC    X'00'                                                    04277\n         ORG   ETAB+(4*JRRDDPLUSNOCURSORSUPP)                           04278\n         DC    A(MJRRDDPLUSNOCURSORSUPP)                                04279\n         ORG                                                            04280\nMJRRDDPLUSNOCURSORSUPP DC C'FuioRddPlus is only supported with the ind' 04281\n         DC    C'ex protocol, not the cursor protocol.'                 04282\n         DC    X'00'                                                    04283\n         ORG   ETAB+(4*JRBADMAXSENDRCVSIZE)                             04284\n         DC    A(MJRBADMAXSENDRCVSIZE)                                  04285\n         ORG                                                            04286\nMJRBADMAXSENDRCVSIZE DC C'Incorrect Maximum send/receive size value sp' 04287\n         DC    C'ecified'                                               04288\n         DC    X'00'                                                    04289\n         ORG   ETAB+(4*JRPTLDTOOMANYEXTENTS)                            04290\n         DC    A(MJRPTLDTOOMANYEXTENTS)                                 04291\n         ORG                                                            04292\nMJRPTLDTOOMANYEXTENTS DC C'The ptrace loader information request faile' 04293\n         DC    C'd because a load module had more than 16 extents'      04294\n         DC    X'00'                                                    04295\n         ORG   ETAB+(4*JRBADHANDLE)                                     04296\n         DC    A(MJRBADHANDLE)                                          04297\n         ORG                                                            04298\nMJRBADHANDLE DC C'The lock handle on the lock parameter is not 0'       04299\n         DC    X'00'                                                    04300\n         ORG   ETAB+(4*JRNODEFAULT)                                     04301\n         DC    A(MJRNODEFAULT)                                          04302\n         ORG                                                            04303\nMJRNODEFAULT DC C'Common Inet is running, but there are no transport p' 04304\n         DC    C'roviders active to run as a Default.'                  04305\n         DC    X'00'                                                    04306\n         ORG   ETAB+(4*JRBLOCKSINFLUX)                                  04307\n         DC    A(MJRBLOCKSINFLUX)                                       04308\n         ORG                                                            04309\nMJRBLOCKSINFLUX DC C'Unable to access internal blocks without lock'     04310\n         DC    X'00'                                                    04311\n         ORG   ETAB+(4*JRLINETFAIL)                                     04312\n         DC    A(MJRLINETFAIL)                                          04313\n         ORG                                                            04314\nMJRLINETFAIL DC C'Local inet not correctly set up.'                     04315\n         DC    X'00'                                                    04316\n         ORG   ETAB+(4*JRNOEPHEMERALPORTS)                              04317\n         DC    A(MJRNOEPHEMERALPORTS)                                   04318\n         ORG                                                            04319\nMJRNOEPHEMERALPORTS DC C'The supply of ephemeral port numbers is exhau' 04320\n         DC    C'sted.'                                                 04321\n         DC    X'00'                                                    04322\n         ORG   ETAB+(4*JRSOCKETSYNRECEIVED)                             04323\n         DC    A(MJRSOCKETSYNRECEIVED)                                  04324\n         ORG                                                            04325\nMJRSOCKETSYNRECEIVED DC C'A SYN was received on the socket connection.' 04326\n         DC    X'00'                                                    04327\n         ORG   ETAB+(4*JRSOCKETRSTRECEIVED)                             04328\n         DC    A(MJRSOCKETRSTRECEIVED)                                  04329\n         ORG                                                            04330\nMJRSOCKETRSTRECEIVED DC C'A RST was received on the socket connection.' 04331\n         DC    X'00'                                                    04332\n         ORG   ETAB+(4*JRSELFCONNECT)                                   04333\n         DC    A(MJRSELFCONNECT)                                        04334\n         ORG                                                            04335\nMJRSELFCONNECT DC C'Connect to self is not allowed'                     04336\n         DC    X'00'                                                    04337\n         ORG   ETAB+(4*JRALREADYCONN)                                   04338\n         DC    A(MJRALREADYCONN)                                        04339\n         ORG                                                            04340\nMJRALREADYCONN DC C'The socket is already connected'                    04341\n         DC    X'00'                                                    04342\n         ORG   ETAB+(4*JRNOTSTREAM)                                     04343\n         DC    A(MJRNOTSTREAM)                                          04344\n         ORG                                                            04345\nMJRNOTSTREAM DC C'The socket operation is only valid for a stream sock' 04346\n         DC    C'et.'                                                   04347\n         DC    X'00'                                                    04348\n         ORG   ETAB+(4*JRSOCKETCONDROPPED)                              04349\n         DC    A(MJRSOCKETCONDROPPED)                                   04350\n         ORG                                                            04351\nMJRSOCKETCONDROPPED DC C'The socket connection was severed.'            04352\n         DC    X'00'                                                    04353\n         ORG   ETAB+(4*JRMPMUPROCESS)                                   04354\n         DC    A(MJRMPMUPROCESS)                                        04355\n         ORG                                                            04356\nMJRMPMUPROCESS DC C'Operation not permitted in a Multiproc/Multiuser p' 04357\n         DC    C'rocess'                                                04358\n         DC    X'00'                                                    04359\n         ORG   ETAB+(4*JRTLSCERTIDLENINVALID)                           04360\n         DC    A(MJRTLSCERTIDLENINVALID)                                04361\n         ORG                                                            04362\nMJRTLSCERTIDLENINVALID DC C'The certificate structure has an incorrect' 04363\n         DC    C' length associated with it.'                           04364\n         DC    X'00'                                                    04365\n         ORG   ETAB+(4*JRTLSCERTTYPEINVALID)                            04366\n         DC    A(MJRTLSCERTTYPEINVALID)                                 04367\n         ORG                                                            04368\nMJRTLSCERTTYPEINVALID DC C'The type of certificate used is not valid.'  04369\n         DC    X'00'                                                    04370\n         ORG   ETAB+(4*JRTLSCERTLENGTHINVALID)                          04371\n         DC    A(MJRTLSCERTLENGTHINVALID)                               04372\n         ORG                                                            04373\nMJRTLSCERTLENGTHINVALID DC C'The length of the certificate is not vali' 04374\n         DC    C'd.'                                                    04375\n         DC    X'00'                                                    04376\n         ORG   ETAB+(4*JRNOINITACEE)                                    04377\n         DC    A(MJRNOINITACEE)                                         04378\n         ORG                                                            04379\nMJRNOINITACEE DC C'There is no SAF service available to manage a certi' 04380\n         DC    C'ficate authorization.'                                 04381\n         DC    X'00'                                                    04382\n         ORG   ETAB+(4*JRNOCERTFORUSER)                                 04383\n         DC    A(MJRNOCERTFORUSER)                                      04384\n         ORG                                                            04385\nMJRNOCERTFORUSER DC C'There is no userid defined for this certificate.' 04386\n         DC    X'00'                                                    04387\n         ORG   ETAB+(4*JRCERTINVALID)                                   04388\n         DC    A(MJRCERTINVALID)                                        04389\n         ORG                                                            04390\nMJRCERTINVALID DC C'The certificate is not valid to the security servi' 04391\n         DC    C'ce.'                                                   04392\n         DC    X'00'                                                    04393\n         ORG   ETAB+(4*JRKEEPALIVETO)                                   04394\n         DC    A(MJRKEEPALIVETO)                                        04395\n         ORG                                                            04396\nMJRKEEPALIVETO DC C'The socket connection was severed.'                 04397\n         DC    X'00'                                                    04398\n         ORG   ETAB+(4*JRINETRECYCLED)                                  04399\n         DC    A(MJRINETRECYCLED)                                       04400\n         ORG                                                            04401\nMJRINETRECYCLED DC C'One of the Transport Providers was activated afte' 04402\n         DC    C'r the socket was opened.'                              04403\n         DC    X'00'                                                    04404\n         ORG   ETAB+(4*JRSWAPMISMATCH)                                  04405\n         DC    A(MJRSWAPMISMATCH)                                       04406\n         ORG                                                            04407\nMJRSWAPMISMATCH DC C'An attempt was made to make the address space swa' 04408\n         DC    C'ppablewhen no previous attempt to make the address sp' 04409\n         DC    C'acenon-swappable was made.'                            04410\n         DC    X'00'                                                    04411\n         ORG   ETAB+(4*JRNOBACKLOGQ)                                    04412\n         DC    A(MJRNOBACKLOGQ)                                         04413\n         ORG                                                            04414\nMJRNOBACKLOGQ DC C'An accept() request was issued for a serversocket t' 04415\n         DC    C'hat does not have a backlog queue.'                    04416\n         DC    X'00'                                                    04417\n         ORG   ETAB+(4*JRFUNCTIONCODE)                                  04418\n         DC    A(MJRFUNCTIONCODE)                                       04419\n         ORG                                                            04420\nMJRFUNCTIONCODE DC C'The function code for syscall is not valid.'       04421\n         DC    X'00'                                                    04422\n         ORG   ETAB+(4*JRIDENTITYTYPE)                                  04423\n         DC    A(MJRIDENTITYTYPE)                                       04424\n         ORG                                                            04425\nMJRIDENTITYTYPE DC C'The identity type for the syscall is not valid.'   04426\n         DC    X'00'                                                    04427\n         ORG   ETAB+(4*JRCERTIFICATE)                                   04428\n         DC    A(MJRCERTIFICATE)                                        04429\n         ORG                                                            04430\nMJRCERTIFICATE DC C'The security certificate was either not specified ' 04431\n         DC    C'orthe length was not valid.'                           04432\n         DC    X'00'                                                    04433\n         ORG   ETAB+(4*JRCWDPLUSFILENAME)                               04434\n         DC    A(MJRCWDPLUSFILENAME)                                    04435\n         ORG                                                            04436\nMJRCWDPLUSFILENAME DC C'The combined length of the CWD specified in th' 04437\n         DC    C'e INHE and the filename parameter exceeded 1023 bytes' 04438\n         DC    C'.'                                                     04439\n         DC    X'00'                                                    04440\n         ORG   ETAB+(4*JRFILECHANGEDDURINGLOAD)                         04441\n         DC    A(MJRFILECHANGEDDURINGLOAD)                              04442\n         ORG                                                            04443\nMJRFILECHANGEDDURINGLOAD DC C'The file or its attributes changed while' 04444\n         DC    C' the file was in the process of being loaded.'         04445\n         DC    X'00'                                                    04446\n         ORG   ETAB+(4*JRSECURITYENV)                                   04447\n         DC    A(MJRSECURITYENV)                                        04448\n         ORG                                                            04449\nMJRSECURITYENV DC C'The syscall is prohibited with the caller:apos.s c' 04450\n         DC    C'urrent security environment.'                          04451\n         DC    X'00'                                                    04452\n         ORG   ETAB+(4*JRSTORNOTAVAIL)                                  04453\n         DC    A(MJRSTORNOTAVAIL)                                       04454\n         ORG                                                            04455\nMJRSTORNOTAVAIL DC C'An address was specified which is not available'   04456\n         DC    X'00'                                                    04457\n         ORG   ETAB+(4*JRNOTSEGMENT)                                    04458\n         DC    A(MJRNOTSEGMENT)                                         04459\n         ORG                                                            04460\nMJRNOTSEGMENT DC C'A location specified or generated is not on a segme' 04461\n         DC    C'nt boundary'                                           04462\n         DC    X'00'                                                    04463\n         ORG   ETAB+(4*JRMMAPTYPEMISMATCH)                              04464\n         DC    A(MJRMMAPTYPEMISMATCH)                                   04465\n         ORG                                                            04466\nMJRMMAPTYPEMISMATCH DC C'A request specified the MAP_MEGA option but w' 04467\n         DC    C'as already mapped without the option or did not speci' 04468\n         DC    C'fy the  MAP_MEGA option but was already mapped with t' 04469\n         DC    C'hat option.'                                           04470\n         DC    X'00'                                                    04471\n         ORG   ETAB+(4*JRWFILEMAPRDONLY)                                04472\n         DC    A(MJRWFILEMAPRDONLY)                                     04473\n         ORG                                                            04474\nMJRWFILEMAPRDONLY DC C'A request tried to write to a file that is mapp' 04475\n         DC    C'ed  as read-only'                                      04476\n         DC    X'00'                                                    04477\n         ORG   ETAB+(4*JRPTTYPENOTTRIED)                                04478\n         DC    A(MJRPTTYPENOTTRIED)                                     04479\n         ORG                                                            04480\nMJRPTTYPENOTTRIED DC C'The entry in a ptrace PT_BlockReq request conta' 04481\n         DC    C'ining this value in the status field was not processe' 04482\n         DC    C'd because of an unexpected error'                      04483\n         DC    X'00'                                                    04484\n         ORG   ETAB+(4*JRPTBADBLKREQSTRUC)                              04485\n         DC    A(MJRPTBADBLKREQSTRUC)                                   04486\n         ORG                                                            04487\nMJRPTBADBLKREQSTRUC DC C'The PtBRInfo block or related structure passe' 04488\n         DC    C'd as input for a ptrace Pt_BlockReq request is not va' 04489\n         DC    C'lid.'                                                  04490\n         DC    X'00'                                                    04491\n         ORG   ETAB+(4*JRPTSOMEBLKEDFAILED)                             04492\n         DC    A(MJRPTSOMEBLKEDFAILED)                                  04493\n         ORG                                                            04494\nMJRPTSOMEBLKEDFAILED DC C'One or more entries in a Pt_BlockReq request' 04495\n         DC    C' was not processed.'                                   04496\n         DC    X'00'                                                    04497\n         ORG   ETAB+(4*JRPTTYPENOTBLOCKABLE)                            04498\n         DC    A(MJRPTTYPENOTBLOCKABLE)                                 04499\n         ORG                                                            04500\nMJRPTTYPENOTBLOCKABLE DC C'The entry in a ptrace PT_BlockReq request c' 04501\n         DC    C'ontaining this value in the status field was not proc' 04502\n         DC    C'essed because the type specified is not allowed in a ' 04503\n         DC    C'blocked request.'                                      04504\n         DC    X'00'                                                    04505\n         ORG   ETAB+(4*JRTARGETPID)                                     04506\n         DC    A(MJRTARGETPID)                                          04507\n         ORG                                                            04508\nMJRTARGETPID DC C'A target pid specified is incorrect'                  04509\n         DC    X'00'                                                    04510\n         ORG   ETAB+(4*JRSIGNALPID)                                     04511\n         DC    A(MJRSIGNALPID)                                          04512\n         ORG                                                            04513\nMJRSIGNALPID DC C'A signal pid specified is incorrect'                  04514\n         DC    X'00'                                                    04515\n         ORG   ETAB+(4*JRNOCALLERPID)                                   04516\n         DC    A(MJRNOCALLERPID)                                        04517\n         ORG                                                            04518\nMJRNOCALLERPID DC C'The Signal_Pid or Target_Pid did not containthe pi' 04519\n         DC    C'd of the caller'                                       04520\n         DC    X'00'                                                    04521\n         ORG   ETAB+(4*JRANR)                                           04522\n         DC    A(MJRANR)                                                04523\n         ORG                                                            04524\nMJRANR DC C'Vnode operation ACCEPT_AND_RECEIVE is not supported by thi' 04525\n         DC    C's file system'                                         04526\n         DC    X'00'                                                    04527\n         ORG   ETAB+(4*JRSRX)                                           04528\n         DC    A(MJRSRX)                                                04529\n         ORG                                                            04530\nMJRSRX DC C'Vnode operation SR_CSM is not supported by this file syste' 04531\n         DC    C'm'                                                     04532\n         DC    X'00'                                                    04533\n         ORG   ETAB+(4*JRWRONGKEY)                                      04534\n         DC    A(MJRWRONGKEY)                                           04535\n         ORG                                                            04536\nMJRWRONGKEY DC C'An error occurred during process signal initializatio' 04537\n         DC    C'n'                                                     04538\n         DC    X'00'                                                    04539\n         ORG   ETAB+(4*JRPTBADBLKOFFSET)                                04540\n         DC    A(MJRPTBADBLKOFFSET)                                     04541\n         ORG                                                            04542\nMJRPTBADBLKOFFSET DC C'A PtBRInfo entry has an offset that either poin' 04543\n         DC    C'ts to within the PtBRInfo block or past the end of th' 04544\n         DC    C'e area provided by the user.'                          04545\n         DC    X'00'                                                    04546\n         ORG   ETAB+(4*JRSSETTOOSMALL)                                  04547\n         DC    A(MJRSSETTOOSMALL)                                       04548\n         ORG                                                            04549\nMJRSSETTOOSMALL DC C'The OldCount value supplied was too smallto accom' 04550\n         DC    C'odate the number of built entries   '                  04551\n         DC    X'00'                                                    04552\n         ORG   ETAB+(4*JRINVALIDRANGE)                                  04553\n         DC    A(MJRINVALIDRANGE)                                       04554\n         ORG                                                            04555\nMJRINVALIDRANGE DC C'The NewCount or OldCount was greater thanthe maxi' 04556\n         DC    C'mum number of signals allowed'                         04557\n         DC    X'00'                                                    04558\n         ORG   ETAB+(4*JRINVALIDOPTION)                                 04559\n         DC    A(MJRINVALIDOPTION)                                      04560\n         ORG                                                            04561\nMJRINVALIDOPTION DC C'The option specified is not supported'            04562\n         DC    X'00'                                                    04563\n         ORG   ETAB+(4*JRINVALIDBINSEMUNDO)                             04564\n         DC    A(MJRINVALIDBINSEMUNDO)                                  04565\n         ORG                                                            04566\nMJRINVALIDBINSEMUNDO DC C'The requested operation violates binary sema' 04567\n         DC    C'phore rules by specifying UNDO option.'                04568\n         DC    X'00'                                                    04569\n         ORG   ETAB+(4*JRINVALIDBINSEMNUMSEMOPS)                        04570\n         DC    A(MJRINVALIDBINSEMNUMSEMOPS)                             04571\n         ORG                                                            04572\nMJRINVALIDBINSEMNUMSEMOPS DC C'The requested operation violates binary' 04573\n         DC    C' semaphore rulesby specifying more than one operation' 04574\n         DC    C' per semop.'                                           04575\n         DC    X'00'                                                    04576\n         ORG   ETAB+(4*JRINVALIDBINSEMNOTBINOP)                         04577\n         DC    A(MJRINVALIDBINSEMNOTBINOP)                              04578\n         ORG                                                            04579\nMJRINVALIDBINSEMNOTBINOP DC C'The requested operation violates binary ' 04580\n         DC    C'semaphore rulesby specifying too large a semop or sem' 04581\n         DC    C'ctl value for the semval.'                             04582\n         DC    X'00'                                                    04583\n         ORG   ETAB+(4*JRINVALIDBINSEMFLAG)                             04584\n         DC    A(MJRINVALIDBINSEMFLAG)                                  04585\n         ORG                                                            04586\nMJRINVALIDBINSEMFLAG DC C'A semgt request matched an existing key or I' 04587\n         DC    C'D but the __IPC_BINSEM flag operand does not match.'   04588\n         DC    X'00'                                                    04589\n         ORG   ETAB+(4*JRINVALIDBINSEMSETALL)                           04590\n         DC    A(MJRINVALIDBINSEMSETALL)                                04591\n         ORG                                                            04592\nMJRINVALIDBINSEMSETALL DC C'A requested semctl SETALL is being done af' 04593\n         DC    C'ter a semop for a __IPC_BINSEM semaphore set.'         04594\n         DC    X'00'                                                    04595\n         ORG   ETAB+(4*JRNEGATIVELENGTH)                                04596\n         DC    A(MJRNEGATIVELENGTH)                                     04597\n         ORG                                                            04598\nMJRNEGATIVELENGTH DC C'A negative length was specified for either the ' 04599\n         DC    C' header length or trailer length on the SEND_FILESysc' 04600\n         DC    C'all.'                                                  04601\n         DC    X'00'                                                    04602\n         ORG   ETAB+(4*JRINVALIDOFFSET)                                 04603\n         DC    A(MJRINVALIDOFFSET)                                      04604\n         ORG                                                            04605\nMJRINVALIDOFFSET DC C'The offset parameter specified on the SEND_FILE ' 04606\n         DC    C'syscall is not correct. It is either a negative numbe' 04607\n         DC    C'r or it specifies an offset past the end   of the fil' 04608\n         DC    C'e.'                                                    04609\n         DC    X'00'                                                    04610\n         ORG   ETAB+(4*JRTOOMANYBYTES)                                  04611\n         DC    A(MJRTOOMANYBYTES)                                       04612\n         ORG                                                            04613\nMJRTOOMANYBYTES DC C'The FILE_BYTES parameter specified on the SEND_FI' 04614\n         DC    C'LE syscall is larger than the file size.'              04615\n         DC    X'00'                                                    04616\n         ORG   ETAB+(4*JRSOCKETNONBLOCK)                                04617\n         DC    A(MJRSOCKETNONBLOCK)                                     04618\n         ORG                                                            04619\nMJRSOCKETNONBLOCK DC C'The socket descriptor specified on the SEND_FIL' 04620\n         DC    C'Esyscall is a non-blocking socket. SEND_FILE requires' 04621\n         DC    C' a blocking socket.'                                   04622\n         DC    X'00'                                                    04623\n         ORG   ETAB+(4*JRLOCALSPAWNNOTALLOWED)                          04624\n         DC    A(MJRLOCALSPAWNNOTALLOWED)                               04625\n         ORG                                                            04626\nMJRLOCALSPAWNNOTALLOWED DC C'A request to spawn a local child process ' 04627\n         DC    C'could not be completed.'                               04628\n         DC    X'00'                                                    04629\n         ORG   ETAB+(4*JRINVALIDSFPLLEN)                                04630\n         DC    A(MJRINVALIDSFPLLEN)                                     04631\n         ORG                                                            04632\nMJRINVALIDSFPLLEN DC C'The SFPL_LENGTH parameter specified on the SEND' 04633\n         DC    C'_FILE syscall is not correct.'                         04634\n         DC    X'00'                                                    04635\n         ORG   ETAB+(4*JRPTINVFPCWRITE)                                 04636\n         DC    A(MJRPTINVFPCWRITE)                                      04637\n         ORG                                                            04638\nMJRPTINVFPCWRITE DC C'The value specified for writing into the Floatin' 04639\n         DC    C'g Point Control Register is not valid.'                04640\n         DC    X'00'                                                    04641\n         ORG   ETAB+(4*JRMAXAIOCBECB)                                   04642\n         DC    A(MJRMAXAIOCBECB)                                        04643\n         ORG                                                            04644\nMJRMAXAIOCBECB DC C'The maximum number of AIOCBs with user defined ECB' 04645\n         DC    C's was exceeded on the requested function.'             04646\n         DC    X'00'                                                    04647\n         ORG   ETAB+(4*JRCERTALREADYDEFINED)                            04648\n         DC    A(MJRCERTALREADYDEFINED)                                 04649\n         ORG                                                            04650\nMJRCERTALREADYDEFINED DC C'The certificate being registered/deregister' 04651\n         DC    C'ed     is already defined for another user.'           04652\n         DC    X'00'                                                    04653\n         ORG   ETAB+(4*JRCERTDOESNOTMEETREQ)                            04654\n         DC    A(MJRCERTDOESNOTMEETREQ)                                 04655\n         ORG                                                            04656\nMJRCERTDOESNOTMEETREQ DC C'The certificate being registered/deregister' 04657\n         DC    C'ed does not meet RACF requirements.'                   04658\n         DC    X'00'                                                    04659\n         ORG   ETAB+(4*JRLOCKFCNCODE)                                   04660\n         DC    A(MJRLOCKFCNCODE)                                        04661\n         ORG                                                            04662\nMJRLOCKFCNCODE DC C'The value specified for the LockFcnCode parameter ' 04663\n         DC    C'for the BPX1SLK service is not valid.'                 04664\n         DC    X'00'                                                    04665\n         ORG   ETAB+(4*JRLOCKREQTYPE)                                   04666\n         DC    A(MJRLOCKREQTYPE)                                        04667\n         ORG                                                            04668\nMJRLOCKREQTYPE DC C'The value specified for the LockReqType parameter ' 04669\n         DC    C'for the BPX1SLK service is not valid.'                 04670\n         DC    X'00'                                                    04671\n         ORG   ETAB+(4*JRLOCKTYPE)                                      04672\n         DC    A(MJRLOCKTYPE)                                           04673\n         ORG                                                            04674\nMJRLOCKTYPE DC C'The value specified for the LockType parameter for th' 04675\n         DC    C'e BPX1SLK service is not valid.'                       04676\n         DC    X'00'                                                    04677\n         ORG   ETAB+(4*JRLOCKADDR)                                      04678\n         DC    A(MJRLOCKADDR)                                           04679\n         ORG                                                            04680\nMJRLOCKADDR DC C'The address specified for the LockAddr parameter for ' 04681\n         DC    C'the BPX1SLK service is not a valid shared memory addr' 04682\n         DC    C'ess.'                                                  04683\n         DC    X'00'                                                    04684\n         ORG   ETAB+(4*JRLOCKTOKEN)                                     04685\n         DC    A(MJRLOCKTOKEN)                                          04686\n         ORG                                                            04687\nMJRLOCKTOKEN DC C'The value specified for the LockToken parameter for ' 04688\n         DC    C'the BPX1SLK service is not valid.'                     04689\n         DC    X'00'                                                    04690\n         ORG   ETAB+(4*JRLOCKEDALREADY)                                 04691\n         DC    A(MJRLOCKEDALREADY)                                      04692\n         ORG                                                            04693\nMJRLOCKEDALREADY DC C'The lock represented by the specified lock token' 04694\n         DC    C'  is already in a held state.'                         04695\n         DC    X'00'                                                    04696\n         ORG   ETAB+(4*JRLOCKINUSE)                                     04697\n         DC    A(MJRLOCKINUSE)                                          04698\n         ORG                                                            04699\nMJRLOCKINUSE DC C'The lock represented by the specified lock token  is' 04700\n         DC    C' in use for a condition wait.'                         04701\n         DC    X'00'                                                    04702\n         ORG   ETAB+(4*JRLOCKSHMACC)                                    04703\n         DC    A(MJRLOCKSHMACC)                                         04704\n         ORG                                                            04705\nMJRLOCKSHMACC DC C'The caller does not have read/write access to the s' 04706\n         DC    C'hared memory in which the specified lock resides.'     04707\n         DC    X'00'                                                    04708\n         ORG   ETAB+(4*JRLOCKNOTOWNER)                                  04709\n         DC    A(MJRLOCKNOTOWNER)                                       04710\n         ORG                                                            04711\nMJRLOCKNOTOWNER DC C'The calling thread does not own the lock represen' 04712\n         DC    C'ted by the specified lock token.'                      04713\n         DC    X'00'                                                    04714\n         ORG   ETAB+(4*JRLOCKMAXCNTSYS)                                 04715\n         DC    A(MJRLOCKMAXCNTSYS)                                      04716\n         ORG                                                            04717\nMJRLOCKMAXCNTSYS DC C'The maximum number of shared memory locks for th' 04718\n         DC    C'e system have been initialized.'                       04719\n         DC    X'00'                                                    04720\n         ORG   ETAB+(4*JRLOCKMAXCNTTHD)                                 04721\n         DC    A(MJRLOCKMAXCNTTHD)                                      04722\n         ORG                                                            04723\nMJRLOCKMAXCNTTHD DC C'The maximum number of shared memory locks for th' 04724\n         DC    C'e calling thread have been obtained.'                  04725\n         DC    X'00'                                                    04726\n         ORG   ETAB+(4*JRLOCKMAXCNTRECURSE)                             04727\n         DC    A(MJRLOCKMAXCNTRECURSE)                                  04728\n         ORG                                                            04729\nMJRLOCKMAXCNTRECURSE DC C'The maximum number of recursive lock obtains' 04730\n         DC    C' for a given lock has been reached.'                   04731\n         DC    X'00'                                                    04732\n         ORG   ETAB+(4*JRLOCKSHMREMOVED)                                04733\n         DC    A(MJRLOCKSHMREMOVED)                                     04734\n         ORG                                                            04735\nMJRLOCKSHMREMOVED DC C'The specified lock cannot be obtained because i' 04736\n         DC    C't is in shared memory that has been removed.'          04737\n         DC    X'00'                                                    04738\n         ORG   ETAB+(4*JRBADAIOECB)                                     04739\n         DC    A(MJRBADAIOECB)                                          04740\n         ORG                                                            04741\nMJRBADAIOECB DC C'An Ecb represented by AioEcbPtr in one of the input ' 04742\n         DC    C'Aiocbs was found to be bad.'                           04743\n         DC    X'00'                                                    04744\n         ORG   ETAB+(4*JRNOPTSECENV)                                    04745\n         DC    A(MJRNOPTSECENV)                                         04746\n         ORG                                                            04747\nMJRNOPTSECENV DC C'Only a thread level identity created with pthread_s' 04748\n         DC    C'ecurity_np (BPX1TLS) can be propagated over a socket.' 04749\n         DC    X'00'                                                    04750\n         ORG   ETAB+(4*JRMULTITHREADED)                                 04751\n         DC    A(MJRMULTITHREADED)                                      04752\n         ORG                                                            04753\nMJRMULTITHREADED DC C'The requested service cannot be performed in an ' 04754\n         DC    C'address space with multiple user threads.'             04755\n         DC    X'00'                                                    04756\n         ORG   ETAB+(4*JRACTACCEPTUSERID)                               04757\n         DC    A(MJRACTACCEPTUSERID)                                    04758\n         ORG                                                            04759\nMJRACTACCEPTUSERID DC C'The active identity for the caller/process was' 04760\n         DC    C' propagated over a socket via accept(). The propagate' 04761\n         DC    C'd identity must be cleaned up before another identity' 04762\n         DC    C' can be propagted.'                                    04763\n         DC    X'00'                                                    04764\n         ORG   ETAB+(4*JRLOCKTOKENADDR)                                 04765\n         DC    A(MJRLOCKTOKENADDR)                                      04766\n         ORG                                                            04767\nMJRLOCKTOKENADDR DC C'The address specified in the LockTokenAddr param' 04768\n         DC    C'eter for the BPX1SLK service is not accessible.'       04769\n         DC    X'00'                                                    04770\n         ORG   ETAB+(4*JRNOTINWLMENCLAVE)                               04771\n         DC    A(MJRNOTINWLMENCLAVE)                                    04772\n         ORG                                                            04773\nMJRNOTINWLMENCLAVE DC C'The unit of work is not in a WLM enclave. BPX1' 04774\n         DC    C'WLM did not return an enclave token  .'                04775\n         DC    X'00'                                                    04776\n         ORG   ETAB+(4*JRCSMFAILURE)                                    04777\n         DC    A(MJRCSMFAILURE)                                         04778\n         ORG                                                            04779\nMJRCSMFAILURE DC C'The get_buffer request to get a CSM buffer failed.'  04780\n         DC    X'00'                                                    04781\n         ORG   ETAB+(4*JRMAXQUEUEDSIGS)                                 04782\n         DC    A(MJRMAXQUEUEDSIGS)                                      04783\n         ORG                                                            04784\nMJRMAXQUEUEDSIGS DC C'Maximum number of queued signal exceeded by the ' 04785\n         DC    C'  invoking process.'                                   04786\n         DC    X'00'                                                    04787\n         ORG   ETAB+(4*JRSIGINFOLEN)                                    04788\n         DC    A(MJRSIGINFOLEN)                                         04789\n         ORG                                                            04790\nMJRSIGINFOLEN DC C'The value specified for the SigInfo_Len parameter o' 04791\n         DC    C'n a BPX1STW (sigtimedwait) syscall was not valid.'     04792\n         DC    X'00'                                                    04793\n         ORG   ETAB+(4*JRLEVELTOOHIGH)                                  04794\n         DC    A(MJRLEVELTOOHIGH)                                       04795\n         ORG                                                            04796\nMJRLEVELTOOHIGH DC C'The load module format of the target executable f' 04797\n         DC    C'ile is at a level higher than the current system supp' 04798\n         DC    C'orts.'                                                 04799\n         DC    X'00'                                                    04800\n         ORG   ETAB+(4*JRBPXOINITSTARTED)                               04801\n         DC    A(MJRBPXOINITSTARTED)                                    04802\n         ORG                                                            04803\nMJRBPXOINITSTARTED DC C'The OMVS initial process must be started by th' 04804\n         DC    C'e system. Do not use the START operator command to st' 04805\n         DC    C'art the OMVS initial process.'                         04806\n         DC    X'00'                                                    04807\n         ORG   ETAB+(4*JRBPXOINITNOTUID0)                               04808\n         DC    A(MJRBPXOINITNOTUID0)                                    04809\n         ORG                                                            04810\nMJRBPXOINITNOTUID0 DC C'The userid associated with system procedure, B' 04811\n         DC    C'PXOINIT, must have uid=0 in the OMVS segment in the s' 04812\n         DC    C'ecurity database.'                                     04813\n         DC    X'00'                                                    04814\n         ORG   ETAB+(4*JRSTICKYBIT)                                     04815\n         DC    A(MJRSTICKYBIT)                                          04816\n         ORG                                                            04817\nMJRSTICKYBIT DC C'A program with the sticky bit was found but it is no' 04818\n         DC    C't supported on this call.'                             04819\n         DC    X'00'                                                    04820\n         ORG   ETAB+(4*JRMAXASYNCIO)                                    04821\n         DC    A(MJRMAXASYNCIO)                                         04822\n         ORG                                                            04823\nMJRMAXASYNCIO DC C'The maximum number of outstanding async I/O request' 04824\n         DC    C's has been exceeded by the invoking process.'          04825\n         DC    X'00'                                                    04826\n         ORG   ETAB+(4*JRNOTPTCREATED)                                  04827\n         DC    A(MJRNOTPTCREATED)                                       04828\n         ORG                                                            04829\nMJRNOTPTCREATED DC C'Invoking task is not pthread created'              04830\n         DC    X'00'                                                    04831\n         ORG   ETAB+(4*JRNOTPTSECURITY)                                 04832\n         DC    A(MJRNOTPTSECURITY)                                      04833\n         ORG                                                            04834\nMJRNOTPTSECURITY DC C'Current task security environment is not set up ' 04835\n         DC    C'via pthread_security_np'                               04836\n         DC    X'00'                                                    04837\n         ORG   ETAB+(4*JRALREADYACTIVE)                                 04838\n         DC    A(MJRALREADYACTIVE)                                      04839\n         ORG                                                            04840\nMJRALREADYACTIVE DC C'Requested function is already active'             04841\n         DC    X'00'                                                    04842\n         ORG   ETAB+(4*JRSECACTIVE)                                     04843\n         DC    A(MJRSECACTIVE)                                          04844\n         ORG                                                            04845\nMJRSECACTIVE DC C'Task level security environment already active'       04846\n         DC    X'00'                                                    04847\n         ORG   ETAB+(4*JRINVOSENVTOK)                                   04848\n         DC    A(MJRINVOSENVTOK)                                        04849\n         ORG                                                            04850\nMJRINVOSENVTOK DC C'Input osenv token is incorrect'                     04851\n         DC    X'00'                                                    04852\n         ORG   ETAB+(4*JRNOPERSIST)                                     04853\n         DC    A(MJRNOPERSIST)                                          04854\n         ORG                                                            04855\nMJRNOPERSIST DC C'Unpersist requested but persist count is 0'           04856\n         DC    X'00'                                                    04857\n         ORG   ETAB+(4*JROSENVWLMMISMATCH)                              04858\n         DC    A(MJROSENVWLMMISMATCH)                                   04859\n         ORG                                                            04860\nMJROSENVWLMMISMATCH DC C'osenv WLM Enclave membership does not match t' 04861\n         DC    C'he current pthread WLM Enclave membership'             04862\n         DC    X'00'                                                    04863\n         ORG   ETAB+(4*JROSENVWRONGENCLAVE)                             04864\n         DC    A(MJROSENVWRONGENCLAVE)                                  04865\n         ORG                                                            04866\nMJROSENVWRONGENCLAVE DC C'Current task is not associated with the osen' 04867\n         DC    C'v WLM enclave'                                         04868\n         DC    X'00'                                                    04869\n         ORG   ETAB+(4*JROSENVBEGINENVOUTSTANDING)                      04870\n         DC    A(MJROSENVBEGINENVOUTSTANDING)                           04871\n         ORG                                                            04872\nMJROSENVBEGINENVOUTSTANDING DC C'Current task is operating under an ou' 04873\n         DC    C'tstanding WLM Begin environment. Enclave leave is not' 04874\n         DC    C' allowed'                                              04875\n         DC    X'00'                                                    04876\n         ORG   ETAB+(4*JROSENVNOTEJOINEDTCB)                            04877\n         DC    A(MJROSENVNOTEJOINEDTCB)                                 04878\n         ORG                                                            04879\nMJROSENVNOTEJOINEDTCB DC C'Current task did not issue WLM Enclave Join' 04880\n         DC    C', but only inherited Enclave attribute from mother ta' 04881\n         DC    C'sk'                                                    04882\n         DC    X'00'                                                    04883\n         ORG   ETAB+(4*JROSENVENCLAVESUBTASKEXISTS)                     04884\n         DC    A(MJROSENVENCLAVESUBTASKEXISTS)                          04885\n         ORG                                                            04886\nMJROSENVENCLAVESUBTASKEXISTS DC C'Current task has residual subtasks p' 04887\n         DC    C'ropagated to the enclave which are still associated w' 04888\n         DC    C'ith the Enclave'                                       04889\n         DC    X'00'                                                    04890\n         ORG   ETAB+(4*JROSENVSECURITYMISMATCH)                         04891\n         DC    A(MJROSENVSECURITYMISMATCH)                              04892\n         ORG                                                            04893\nMJROSENVSECURITYMISMATCH DC C'Current security environment does not ma' 04894\n         DC    C'tch the value specified in the osenv token'            04895\n         DC    X'00'                                                    04896\n         ORG   ETAB+(4*JROSENVNOTACTIVE)                                04897\n         DC    A(MJROSENVNOTACTIVE)                                     04898\n         ORG                                                            04899\nMJROSENVNOTACTIVE DC C'Osenv environment is not active'                 04900\n         DC    X'00'                                                    04901\n         ORG   ETAB+(4*JROSENVPERSISTCNTBAD)                            04902\n         DC    A(MJROSENVPERSISTCNTBAD)                                 04903\n         ORG                                                            04904\nMJROSENVPERSISTCNTBAD DC C'There are no outstanding persist requests'   04905\n         DC    X'00'                                                    04906\n         ORG   ETAB+(4*JRWLMJOINERROR)                                  04907\n         DC    A(MJRWLMJOINERROR)                                       04908\n         ORG                                                            04909\nMJRWLMJOINERROR DC C'Bad return code from IWMEJOIN macro'               04910\n         DC    X'00'                                                    04911\n         ORG   ETAB+(4*JRIWMELEAVERROR)                                 04912\n         DC    A(MJRIWMELEAVERROR)                                      04913\n         ORG                                                            04914\nMJRIWMELEAVERROR DC C'Bad return code from IWMELEAV macro'              04915\n         DC    X'00'                                                    04916\n         ORG   ETAB+(4*JRNOTSUPINSYSPLEX)                               04917\n         DC    A(MJRNOTSUPINSYSPLEX)                                    04918\n         ORG                                                            04919\nMJRNOTSUPINSYSPLEX DC C'Remount is not supported in sysplex. Unmount d' 04920\n         DC    C'rain istried as unmount normal, but if it cannot comp' 04921\n         DC    C'lete,an error is returned.'                            04922\n         DC    X'00'                                                    04923\n         ORG   ETAB+(4*JRSYSPLEXRECOVERYINPROG)                         04924\n         DC    A(MJRSYSPLEXRECOVERYINPROG)                              04925\n         ORG                                                            04926\nMJRSYSPLEXRECOVERYINPROG DC C'An unmount was attempted while sysplex s' 04927\n         DC    C'ystem recoverywas in progress.'                        04928\n         DC    X'00'                                                    04929\n         ORG   ETAB+(4*JRMUSTBEIMMED)                                   04930\n         DC    A(MJRMUSTBEIMMED)                                        04931\n         ORG                                                            04932\nMJRMUSTBEIMMED DC C'An unmount was attempted in a sysplex for a filesy' 04933\n         DC    C'stemthat is unowned, and Immed was not specified.'     04934\n         DC    X'00'                                                    04935\n         ORG   ETAB+(4*JRRESETALREADYINPROG)                            04936\n         DC    A(MJRRESETALREADYINPROG)                                 04937\n         ORG                                                            04938\nMJRRESETALREADYINPROG DC C'Unmount reset is already in progress.'       04939\n         DC    X'00'                                                    04940\n         ORG   ETAB+(4*JRINVALIDSIZE)                                   04941\n         DC    A(MJRINVALIDSIZE)                                        04942\n         ORG                                                            04943\nMJRINVALIDSIZE DC C'Buffer received by mount was too small.'            04944\n         DC    X'00'                                                    04945\n         ORG   ETAB+(4*JRUNKNOWNBLOCK)                                  04946\n         DC    A(MJRUNKNOWNBLOCK)                                       04947\n         ORG                                                            04948\nMJRUNKNOWNBLOCK DC C'Control block received is unrecognized.'           04949\n         DC    X'00'                                                    04950\n         ORG   ETAB+(4*JRBADCOMBO)                                      04951\n         DC    A(MJRBADCOMBO)                                           04952\n         ORG                                                            04953\nMJRBADCOMBO DC C'Conflicting values have been received.'                04954\n         DC    X'00'                                                    04955\n         ORG   ETAB+(4*JRNOWILDFROMSYS)                                 04956\n         DC    A(MJRNOWILDFROMSYS)                                      04957\n         ORG                                                            04958\nMJRNOWILDFROMSYS DC C'Conflicting values have been received.'           04959\n         DC    X'00'                                                    04960\n         ORG   ETAB+(4*JRNOVALUES)                                      04961\n         DC    A(MJRNOVALUES)                                           04962\n         ORG                                                            04963\nMJRNOVALUES DC C'No values for the chmount request have been given.'    04964\n         DC    X'00'                                                    04965\n         ORG   ETAB+(4*JRMUSTBESYSPLEX)                                 04966\n         DC    A(MJRMUSTBESYSPLEX)                                      04967\n         ORG                                                            04968\nMJRMUSTBESYSPLEX DC C'This request only possible in a sysplex enivornm' 04969\n         DC    C'ent.'                                                  04970\n         DC    X'00'                                                    04971\n         ORG   ETAB+(4*JRATTEMPTSEXHAUSTED)                             04972\n         DC    A(MJRATTEMPTSEXHAUSTED)                                  04973\n         ORG                                                            04974\nMJRATTEMPTSEXHAUSTED DC C'Every attempt to move the filesystem has fai' 04975\n         DC    C'led.'                                                  04976\n         DC    X'00'                                                    04977\n         ORG   ETAB+(4*JRLOSTSTATE)                                     04978\n         DC    A(MJRLOSTSTATE)                                          04979\n         ORG                                                            04980\nMJRLOSTSTATE DC C'The filesystem can no longer be moved by this proces' 04981\n         DC    C's.'                                                    04982\n         DC    X'00'                                                    04983\n         ORG   ETAB+(4*JRNOFROMSYS)                                     04984\n         DC    A(MJRNOFROMSYS)                                          04985\n         ORG                                                            04986\nMJRNOFROMSYS DC C'The system specified as the FROMSYS can not be found' 04987\n         DC    C'.'                                                     04988\n         DC    X'00'                                                    04989\n         ORG   ETAB+(4*JRNOFSFOUND)                                     04990\n         DC    A(MJRNOFSFOUND)                                          04991\n         ORG                                                            04992\nMJRNOFSFOUND DC C'The filesystem requested to be moved can not be foun' 04993\n         DC    C'd.'                                                    04994\n         DC    X'00'                                                    04995\n         ORG   ETAB+(4*JRINRECOVERY)                                    04996\n         DC    A(MJRINRECOVERY)                                         04997\n         ORG                                                            04998\nMJRINRECOVERY DC C'The filesystem requested to be moved is in recovery' 04999\n         DC    C'.'                                                     05000\n         DC    X'00'                                                    05001\n         ORG   ETAB+(4*JRNOMOUNTPOINTFOUND)                             05002\n         DC    A(MJRNOMOUNTPOINTFOUND)                                  05003\n         ORG                                                            05004\nMJRNOMOUNTPOINTFOUND DC C'The mountpoint requested to be moved can not' 05005\n         DC    C' be found.'                                            05006\n         DC    X'00'                                                    05007\n         ORG   ETAB+(4*JRBLACKHOLE)                                     05008\n         DC    A(MJRBLACKHOLE)                                          05009\n         ORG                                                            05010\nMJRBLACKHOLE DC C'Filesystem is unowned.'                               05011\n         DC    X'00'                                                    05012\n         ORG   ETAB+(4*JRNOPLACE)                                       05013\n         DC    A(MJRNOPLACE)                                            05014\n         ORG                                                            05015\nMJRNOPLACE DC C'This filesystem can not be placed.'                     05016\n         DC    X'00'                                                    05017\n         ORG   ETAB+(4*JRNOSYSTEMFOUND)                                 05018\n         DC    A(MJRNOSYSTEMFOUND)                                      05019\n         ORG                                                            05020\nMJRNOSYSTEMFOUND DC C'There is no system with that name.'               05021\n         DC    X'00'                                                    05022\n         ORG   ETAB+(4*JRSYSPLEXDATASYNCLOST)                           05023\n         DC    A(MJRSYSPLEXDATASYNCLOST)                                05024\n         ORG                                                            05025\nMJRSYSPLEXDATASYNCLOST DC C'The I/O request is rejected because the fi' 05026\n         DC    C'le integritywas lost due to the failure of the file s' 05027\n         DC    C'ystem server.'                                         05028\n         DC    X'00'                                                    05029\n         ORG   ETAB+(4*JRTDGONE)                                        05030\n         DC    A(MJRTDGONE)                                             05031\n         ORG                                                            05032\nMJRTDGONE DC C'The socket Transport Driver has terminated and restarte' 05033\n         DC    C'd.'                                                    05034\n         DC    X'00'                                                    05035\n         ORG   ETAB+(4*JRNODEVICEFOUND)                                 05036\n         DC    A(MJRNODEVICEFOUND)                                      05037\n         ORG                                                            05038\nMJRNODEVICEFOUND DC C'The is no longer any device with that device num' 05039\n         DC    C'ber.'                                                  05040\n         DC    X'00'                                                    05041\n         ORG   ETAB+(4*JRNOTMOVEABLE)                                   05042\n         DC    A(MJRNOTMOVEABLE)                                        05043\n         ORG                                                            05044\nMJRNOTMOVEABLE DC C'This filesystem can not be moved.'                  05045\n         DC    X'00'                                                    05046\n         ORG   ETAB+(4*JRNOLONGERSERVER)                                05047\n         DC    A(MJRNOLONGERSERVER)                                     05048\n         ORG                                                            05049\nMJRNOLONGERSERVER DC C'The server detected it is no longer the server.' 05050\n         DC    X'00'                                                    05051\n         ORG   ETAB+(4*JRLOCKCTL)                                       05052\n         DC    A(MJRLOCKCTL)                                            05053\n         ORG                                                            05054\nMJRLOCKCTL DC C'The lockctl service vnode operation is not supported'   05055\n         DC    X'00'                                                    05056\n         ORG   ETAB+(4*JRCPLNOTAUTH)                                    05057\n         DC    A(MJRCPLNOTAUTH)                                         05058\n         ORG                                                            05059\nMJRCPLNOTAUTH DC C'__cpl service call failed permission check for BPX.' 05060\n         DC    C'CF facility class profile.'                            05061\n         DC    X'00'                                                    05062\n         ORG   ETAB+(4*JRCPLINVFCNCODE)                                 05063\n         DC    A(MJRCPLINVFCNCODE)                                      05064\n         ORG                                                            05065\nMJRCPLINVFCNCODE DC C'__cpl service call failed because the supplied f' 05066\n         DC    C'unction code is not valid.'                            05067\n         DC    X'00'                                                    05068\n         ORG   ETAB+(4*JRCPLINVBUFFLEN)                                 05069\n         DC    A(MJRCPLINVBUFFLEN)                                      05070\n         ORG                                                            05071\nMJRCPLINVBUFFLEN DC C'__cpl service call failed because the supplied b' 05072\n         DC    C'uffer length is not valid.'                            05073\n         DC    X'00'                                                    05074\n         ORG   ETAB+(4*JRCPLBUFFTOOSMALL)                               05075\n         DC    A(MJRCPLBUFFTOOSMALL)                                    05076\n         ORG                                                            05077\nMJRCPLBUFFTOOSMALL DC C'__cpl service call failed because the supplied' 05078\n         DC    C' buffer was too small for the data to be returned.'    05079\n         DC    X'00'                                                    05080\n         ORG   ETAB+(4*JRSYSPLEXBLACKHOLEIO)                            05081\n         DC    A(MJRSYSPLEXBLACKHOLEIO)                                 05082\n         ORG                                                            05083\nMJRSYSPLEXBLACKHOLEIO DC C'The I/O request is rejected because access ' 05084\n         DC    C'to the owning file system was lost.  This is a tempor' 05085\n         DC    C'ary condition.'                                        05086\n         DC    X'00'                                                    05087\n         ORG   ETAB+(4*JRCPLINVSTRUCTYPE)                               05088\n         DC    A(MJRCPLINVSTRUCTYPE)                                    05089\n         ORG                                                            05090\nMJRCPLINVSTRUCTYPE DC C'__cpl service call failed because one of the s' 05091\n         DC    C'upplied structure entries is defined with an incorrec' 05092\n         DC    C't type.'                                               05093\n         DC    X'00'                                                    05094\n         ORG   ETAB+(4*JRCPLCFNOTFOUND)                                 05095\n         DC    A(MJRCPLCFNOTFOUND)                                      05096\n         ORG                                                            05097\nMJRCPLCFNOTFOUND DC C'__cpl service call failed because a Coupling Fac' 05098\n         DC    C'ility at the appropriate level (level 8 or greater) c' 05099\n         DC    C'ould not be found in the sysplex where this __cpl cal' 05100\n         DC    C'lable service routine is running.'                     05101\n         DC    X'00'                                                    05102\n         ORG   ETAB+(4*JRSHRLIBNOTAUTHORIZED)                           05103\n         DC    A(MJRSHRLIBNOTAUTHORIZED)                                05104\n         ORG                                                            05105\nMJRSHRLIBNOTAUTHORIZED DC C'The chattr function can not be performed t' 05106\n         DC    C'o change the shared library attribute because the cal' 05107\n         DC    C'ler is not permitted to the BPX.FILEATTR.SHRLIB facil' 05108\n         DC    C'ity class.'                                            05109\n         DC    X'00'                                                    05110\n         ORG   ETAB+(4*JROUTOFAUTOMOUNTENTRIES)                         05111\n         DC    A(MJROUTOFAUTOMOUNTENTRIES)                              05112\n         ORG                                                            05113\nMJROUTOFAUTOMOUNTENTRIES DC C'The system is unable to obtain an entry ' 05114\n         DC    C'in the file system automount table in the OMVS couple' 05115\n         DC    C' data set'                                             05116\n         DC    X'00'                                                    05117\n         ORG   ETAB+(4*JRNEEDABSPATH)                                   05118\n         DC    A(MJRNEEDABSPATH)                                        05119\n         ORG                                                            05120\nMJRNEEDABSPATH DC C'An absolute path name must be used when performing' 05121\n         DC    C'  a mount command from a userid that has changed root' 05122\n         DC    C's.'                                                    05123\n         DC    X'00'                                                    05124\n         ORG   ETAB+(4*JRMAPBADFUNCTION)                                05125\n         DC    A(MJRMAPBADFUNCTION)                                     05126\n         ORG                                                            05127\nMJRMAPBADFUNCTION DC C'The __Map function or sub-function code was not' 05128\n         DC    C' valid.'                                               05129\n         DC    X'00'                                                    05130\n         ORG   ETAB+(4*JRNOTAUTHMAP)                                    05131\n         DC    A(MJRNOTAUTHMAP)                                         05132\n         ORG                                                            05133\nMJRNOTAUTHMAP DC C'__map_init call failed permission check for BPX.MAP' 05134\n         DC    C' facility class profile.'                              05135\n         DC    X'00'                                                    05136\n         ORG   ETAB+(4*JRBADBLKADDR)                                    05137\n         DC    A(MJRBADBLKADDR)                                         05138\n         ORG                                                            05139\nMJRBADBLKADDR DC C'__map service was passed a bad block address.The bl' 05140\n         DC    C'ock address specified was not within the map area, or' 05141\n         DC    C' was not on a block boundary.'                         05142\n         DC    X'00'                                                    05143\n         ORG   ETAB+(4*JRMAPALREADYACTIVE)                              05144\n         DC    A(MJRMAPALREADYACTIVE)                                   05145\n         ORG                                                            05146\nMJRMAPALREADYACTIVE DC C'__map_init requested for a process that alrea' 05147\n         DC    C'dy had an __map environment active.'                   05148\n         DC    X'00'                                                    05149\n         ORG   ETAB+(4*JRMAPOUTOFBLOCKS)                                05150\n         DC    A(MJRMAPOUTOFBLOCKS)                                     05151\n         ORG                                                            05152\nMJRMAPOUTOFBLOCKS DC C'__map service,  processing for a new block or c' 05153\n         DC    C'onnect request, was asked to select a map block that ' 05154\n         DC    C'was not currently in use, but none was available as a' 05155\n         DC    C'll blocks were currently in use.'                      05156\n         DC    X'00'                                                    05157\n         ORG   ETAB+(4*JRMAPNOTACTIVE)                                  05158\n         DC    A(MJRMAPNOTACTIVE)                                       05159\n         ORG                                                            05160\nMJRMAPNOTACTIVE DC C'__map service was requested but either no map env' 05161\n         DC    C'ironment is active or the current map environment is ' 05162\n         DC    C'being shut down.'                                      05163\n         DC    X'00'                                                    05164\n         ORG   ETAB+(4*JRMAPTOKENNOTFOUND)                              05165\n         DC    A(MJRMAPTOKENNOTFOUND)                                   05166\n         ORG                                                            05167\nMJRMAPTOKENNOTFOUND DC C'__map service data block token not defined.'   05168\n         DC    X'00'                                                    05169\n         ORG   ETAB+(4*JRMAPBLOCKNOTINUSE)                              05170\n         DC    A(MJRMAPBLOCKNOTINUSE)                                   05171\n         ORG                                                            05172\nMJRMAPBLOCKNOTINUSE DC C'__map service disconnect is issued for a map ' 05173\n         DC    C'block that is not currently in use'                    05174\n         DC    X'00'                                                    05175\n         ORG   ETAB+(4*JRMAPBLOCKINUSE)                                 05176\n         DC    A(MJRMAPBLOCKINUSE)                                      05177\n         ORG                                                            05178\nMJRMAPBLOCKINUSE DC C'__map service new block or connect specified a m' 05179\n         DC    C'ap block that is currently in use.'                    05180\n         DC    X'00'                                                    05181\n         ORG   ETAB+(4*JRMAPBLOCKFREEPENDING)                           05182\n         DC    A(MJRMAPBLOCKFREEPENDING)                                05183\n         ORG                                                            05184\nMJRMAPBLOCKFREEPENDING DC C'__map service connect request specified a ' 05185\n         DC    C'data block that is currently being freed.'             05186\n         DC    X'00'                                                    05187\n         ORG   ETAB+(4*JRMAPBADSTORAGE)                                 05188\n         DC    A(MJRMAPBADSTORAGE)                                      05189\n         ORG                                                            05190\nMJRMAPBADSTORAGE DC C'The parameter list either could not be accessed ' 05191\n         DC    C'or was in read only storage and could not be updated.' 05192\n         DC    X'00'                                                    05193\n         ORG   ETAB+(4*JRRESERVEDVALUEINVALID)                          05194\n         DC    A(MJRRESERVEDVALUEINVALID)                               05195\n         ORG                                                            05196\nMJRRESERVEDVALUEINVALID DC C'A reserved field contained a value other ' 05197\n         DC    C'than zero'                                             05198\n         DC    X'00'                                                    05199\n         ORG   ETAB+(4*JRMAPARRAYCOUNTERR)                              05200\n         DC    A(MJRMAPARRAYCOUNTERR)                                   05201\n         ORG                                                            05202\nMJRMAPARRAYCOUNTERR DC C'The array count was outside the valid values'  05203\n         DC    X'00'                                                    05204\n         ORG   ETAB+(4*JRNOTCLIENT)                                     05205\n         DC    A(MJRNOTCLIENT)                                          05206\n         ORG                                                            05207\nMJRNOTCLIENT DC C'This system is not a client of the requested filesys' 05208\n         DC    C'tem'                                                   05209\n         DC    X'00'                                                    05210\n         ORG   ETAB+(4*JRJOINTMSGSENT)                                  05211\n         DC    A(MJRJOINTMSGSENT)                                       05212\n         ORG                                                            05213\nMJRJOINTMSGSENT DC C'The joint LFS/PFS message requested for osi_xmsg ' 05214\n         DC    C'to send has already been sent'                         05215\n         DC    X'00'                                                    05216\n         ORG   ETAB+(4*JRNOWILDAUTOMOVE)                                05217\n         DC    A(MJRNOWILDAUTOMOVE)                                     05218\n         ORG                                                            05219\nMJRNOWILDAUTOMOVE DC C'The automove setting can not be changed while m' 05220\n         DC    C'ovinga collection of filesystems.'                     05221\n         DC    X'00'                                                    05222\n         ORG   ETAB+(4*JRINVALIDFSP)                                    05223\n         DC    A(MJRINVALIDFSP)                                         05224\n         ORG                                                            05225\nMJRINVALIDFSP DC C'The file does not have a valid FSP.'                 05226\n         DC    X'00'                                                    05227\n         ORG   ETAB+(4*JRNOROOT)                                        05228\n         DC    A(MJRNOROOT)                                             05229\n         ORG                                                            05230\nMJRNOROOT DC C'There is no system root mounted.'                        05231\n         DC    X'00'                                                    05232\n         ORG   ETAB+(4*JRMOVEINPROGRESS)                                05233\n         DC    A(MJRMOVEINPROGRESS)                                     05234\n         ORG                                                            05235\nMJRMOVEINPROGRESS DC C'The filesystem is in the process of being moved' 05236\n         DC    C' toa different server.'                                05237\n         DC    X'00'                                                    05238\n         ORG   ETAB+(4*JRBADBODYLENGTH)                                 05239\n         DC    A(MJRBADBODYLENGTH)                                      05240\n         ORG                                                            05241\nMJRBADBODYLENGTH DC C'The MNTE2 does not have a correct body length co' 05242\n         DC    C'dedinto the body length field in the MNTE header.'     05243\n         DC    X'00'                                                    05244\n         ORG   ETAB+(4*JRXCFNOSTORAGE)                                  05245\n         DC    A(MJRXCFNOSTORAGE)                                       05246\n         ORG                                                            05247\nMJRXCFNOSTORAGE DC C'I/O buffer shortage for writing data through XCF'  05248\n         DC    X'00'                                                    05249\n         ORG   ETAB+(4*JRPFSFAILED)                                     05250\n         DC    A(MJRPFSFAILED)                                          05251\n         ORG                                                            05252\nMJRPFSFAILED DC C'A PFS returned a RetVal of -1 with an errno and errn' 05253\n         DC    C'ojrof zero.'                                           05254\n         DC    X'00'                                                    05255\n         ORG   ETAB+(4*JRPTINVGPRHNUMBER)                               05256\n         DC    A(MJRPTINVGPRHNUMBER)                                    05257\n         ORG                                                            05258\nMJRPTINVGPRHNUMBER DC C'The ptrace call has an incorrect general regis' 05259\n         DC    C'ter number'                                            05260\n         DC    X'00'                                                    05261\n         ORG   ETAB+(4*JRFILETOOLARGE)                                  05262\n         DC    A(MJRFILETOOLARGE)                                       05263\n         ORG                                                            05264\nMJRFILETOOLARGE DC C'File size exceeded the value that can be held ino' 05265\n         DC    C'bject of type off_t.'                                  05266\n         DC    X'00'                                                    05267\n         ORG   ETAB+(4*JRCANTEXPCLIENT)                                 05268\n         DC    A(MJRCANTEXPCLIENT)                                      05269\n         ORG                                                            05270\nMJRCANTEXPCLIENT DC C'V_export of a sysplex client file system is not ' 05271\n         DC    C'allowed.'                                              05272\n         DC    X'00'                                                    05273\n         ORG   ETAB+(4*JRISEXPORTED)                                    05274\n         DC    A(MJRISEXPORTED)                                         05275\n         ORG                                                            05276\nMJRISEXPORTED DC C'Moving a file system that is exported is not allowe' 05277\n         DC    C'd.'                                                    05278\n         DC    X'00'                                                    05279\n         ORG   ETAB+(4*JRFSQUIESCEDMT)                                  05280\n         DC    A(MJRFSQUIESCEDMT)                                       05281\n         ORG                                                            05282\nMJRFSQUIESCEDMT DC C'A file system operation was rejected  because the' 05283\n         DC    C' owning file system is quiescedand the operation cann' 05284\n         DC    C'ot be delayed.order to prevent a latch deadlock.'      05285\n         DC    X'00'                                                    05286\n         ORG   ETAB+(4*JRMPTFSQUIESCED)                                 05287\n         DC    A(MJRMPTFSQUIESCED)                                      05288\n         ORG                                                            05289\nMJRMPTFSQUIESCED DC C'A mount request was rejected because a file syst' 05290\n         DC    C'em in the mount path is quiesced.'                     05291\n         DC    X'00'                                                    05292\n         ORG   ETAB+(4*JRMMAPSUSPENDED)                                 05293\n         DC    A(MJRMMAPSUSPENDED)                                      05294\n         ORG                                                            05295\nMJRMMAPSUSPENDED DC C'A memory map request was rejected because the me' 05296\n         DC    C'mory map function is suspended'                        05297\n         DC    X'00'                                                    05298\n         AIF   ('&SYSTEM_ID'(1,4) NE 'z/OS').NOTZOS3                    05299\n         ORG   ETAB+(4*JRSFSDIAGACT)                                    05300\n         DC    A(MJRSFSDIAGACT)                                         05301\n         ORG                                                            05302\nMJRSFSDIAGACT DC C'A Shared-FS diagnostic operation is  already in pro' 05303\n         DC    C'gress.'                                                05304\n         DC    X'00'                                                    05305\n         ORG   ETAB+(4*JRINVALIDFILETAG)                                05306\n         DC    A(MJRINVALIDFILETAG)                                     05307\n         ORG                                                            05308\nMJRINVALIDFILETAG DC C'The file tag supplied is invalid        '        05309\n         DC    X'00'                                                    05310\n         ORG   ETAB+(4*JRDOMPARMS)                                      05311\n         DC    A(MJRDOMPARMS)                                           05312\n         ORG                                                            05313\nMJRDOMPARMS DC C'The CCADOMToken and CCAMsgIdList are mutually exclusi' 05314\n         DC    C've, both were specified.'                              05315\n         DC    X'00'                                                    05316\n         ORG   ETAB+(4*JRTOOMANYMSGIDS)                                 05317\n         DC    A(MJRTOOMANYMSGIDS)                                      05318\n         ORG                                                            05319\nMJRTOOMANYMSGIDS DC C'The maximum number of messages that can be delet' 05320\n         DC    C'ed in one operation is 60, more then 60 were specifie' 05321\n         DC    C'd.'                                                    05322\n         DC    X'00'                                                    05323\n         ORG   ETAB+(4*JRAUTHROUTINGCODE)                               05324\n         DC    A(MJRAUTHROUTINGCODE)                                    05325\n         ORG                                                            05326\nMJRAUTHROUTINGCODE DC C'An unauthorized caller (not UID=0) specified a' 05327\n         DC    C' message routing code reserved for authorized caller.' 05328\n         DC    X'00'                                                    05329\n         ORG   ETAB+(4*JRROUTCODE)                                      05330\n         DC    A(MJRROUTCODE)                                           05331\n         ORG                                                            05332\nMJRROUTCODE DC C'An invalid message routing code was specified.       ' 05333\n         DC    X'00'                                                    05334\n         ORG   ETAB+(4*JRDESCCODE)                                      05335\n         DC    A(MJRDESCCODE)                                           05336\n         ORG                                                            05337\nMJRDESCCODE DC C'An invalid message descriptor code was specified.'     05338\n         DC    X'00'                                                    05339\n         ORG   ETAB+(4*JRROUTINGLIST)                                   05340\n         DC    A(MJRROUTINGLIST)                                        05341\n         ORG                                                            05342\nMJRROUTINGLIST DC C'All or part of the list of routing codes pointed t' 05343\n         DC    C'o by CCARoutCdeList is not addressable by the caller.' 05344\n         DC    X'00'                                                    05345\n         ORG   ETAB+(4*JRDESCLIST)                                      05346\n         DC    A(MJRDESCLIST)                                           05347\n         ORG                                                            05348\nMJRDESCLIST DC C'All or part of the list of descriptor codes pointed t' 05349\n         DC    C'o by CCADescList is not addressable by the caller.'    05350\n         DC    X'00'                                                    05351\n         ORG   ETAB+(4*JRMSGIDLIST)                                     05352\n         DC    A(MJRMSGIDLIST)                                          05353\n         ORG                                                            05354\nMJRMSGIDLIST DC C'All or part of the list of message ids to be deleted' 05355\n         DC    C' pointed to by CCAMsgIdList is not addressable by the' 05356\n         DC    C' caller.'                                              05357\n         DC    X'00'                                                    05358\n         ORG   ETAB+(4*JRTOOMANYROUTCODES)                              05359\n         DC    A(MJRTOOMANYROUTCODES)                                   05360\n         ORG                                                            05361\nMJRTOOMANYROUTCODES DC C'The maximum number of routing codes that can ' 05362\n         DC    C'be specified is 128 but was exceeded.'                 05363\n         DC    X'00'                                                    05364\n         ORG   ETAB+(4*JRTOOMANYDESCCODES)                              05365\n         DC    A(MJRTOOMANYDESCCODES)                                   05366\n         ORG                                                            05367\nMJRTOOMANYDESCCODES DC C'The maximum number of descriptor codes that c' 05368\n         DC    C'an be specified is 6 but was exceeded.'                05369\n         DC    X'00'                                                    05370\n         ORG   ETAB+(4*JRMSGID)                                         05371\n         DC    A(MJRMSGID)                                              05372\n         ORG                                                            05373\nMJRMSGID DC C'All or part of the location specified by the caller for ' 05374\n         DC    C'the returned message id (CCAMsgIDPtr) is not addressa' 05375\n         DC    C'ble by the caller.'                                    05376\n         DC    X'00'                                                    05377\n         ORG   ETAB+(4*JRMEMBERLISTBAD)                                 05378\n         DC    A(MJRMEMBERLISTBAD)                                      05379\n         ORG                                                            05380\nMJRMEMBERLISTBAD DC C'An inconsistency between the XCF representationo' 05381\n         DC    C'f the BPXGRP member group and the local representatio' 05382\n         DC    C'n exists.'                                             05383\n         DC    X'00'                                                    05384\n         ORG   ETAB+(4*JRRCVBUFTOOSMALL)                                05385\n         DC    A(MJRRCVBUFTOOSMALL)                                     05386\n         ORG                                                            05387\nMJRRCVBUFTOOSMALL DC C'A message will not fit in the receive buffer.Th' 05388\n         DC    C'e size of the receive buffer for the receiving socket' 05389\n         DC    C',which was set by the setsockopt syscallwith the so_r' 05390\n         DC    C'cvbuf option, is too smallto contain the data being s' 05391\n         DC    C'ent to it.Truncation would occur.'                     05392\n         DC    X'00'                                                    05393\n         ORG   ETAB+(4*JRMUTUALEXCLINPROGRESS)                          05394\n         DC    A(MJRMUTUALEXCLINPROGRESS)                               05395\n         ORG                                                            05396\nMJRMUTUALEXCLINPROGRESS DC C'Mutually-exclusive operations are current' 05397\n         DC    C'ly in progress in the sysplex. The request cannot pro' 05398\n         DC    C'ceed.'                                                 05399\n         DC    X'00'                                                    05400\n         ORG   ETAB+(4*JRUNMOUNTALLINPROG)                              05401\n         DC    A(MJRUNMOUNTALLINPROG)                                   05402\n         ORG                                                            05403\nMJRUNMOUNTALLINPROG DC C'MODIFY FILESYS=UNMOUNTALL is in progress. MOU' 05404\n         DC    C'NT cannot proceed.'                                    05405\n         DC    X'00'                                                    05406\n         ORG   ETAB+(4*JRQUIESCEINPROG)                                 05407\n         DC    A(MJRQUIESCEINPROG)                                      05408\n         ORG                                                            05409\nMJRQUIESCEINPROG DC C'A pthread quiesce operation is already in progre' 05410\n         DC    C'ss'                                                    05411\n         DC    X'00'                                                    05412\n         ORG   ETAB+(4*JRREQUESTTYPEERR)                                05413\n         DC    A(MJRREQUESTTYPEERR)                                     05414\n         ORG                                                            05415\nMJRREQUESTTYPEERR DC C'The request type contains an incorrect value   ' 05416\n         DC    C'   '                                                   05417\n         DC    X'00'                                                    05418\n         ORG   ETAB+(4*JRNOFREEZEEXIT)                                  05419\n         DC    A(MJRNOFREEZEEXIT)                                       05420\n         ORG                                                            05421\nMJRNOFREEZEEXIT DC C'The pthread_quiesce_and_get_np service (BPX1PQG) ' 05422\n         DC    C'cannot be performed because the Quick_freeze_exit has' 05423\n         DC    C' not been registered'                                  05424\n         DC    X'00'                                                    05425\n         ORG   ETAB+(4*JRNOTEXITKEY)                                    05426\n         DC    A(MJRNOTEXITKEY)                                         05427\n         ORG                                                            05428\nMJRNOTEXITKEY DC C'The PSW key of the caller is not same as key regist' 05429\n         DC    C'ered under Quick_freeze_exit'                          05430\n         DC    X'00'                                                    05431\n         ORG   ETAB+(4*JRINVTHDQ)                                       05432\n         DC    A(MJRINVTHDQ)                                            05433\n         ORG                                                            05434\nMJRINVTHDQ DC C'Incorrect quick pthread quiesce data structure      '   05435\n         DC    X'00'                                                    05436\n         ORG   ETAB+(4*JRNOTFROZEN)                                     05437\n         DC    A(MJRNOTFROZEN)                                          05438\n         ORG                                                            05439\nMJRNOTFROZEN DC C'A pthread_quiesce_and_get_np (BPX1PQG) unfreeze_all ' 05440\n         DC    C'request cannot complete because the process is  not f' 05441\n         DC    C'rozen'                                                 05442\n         DC    X'00'                                                    05443\n         ORG   ETAB+(4*JRQFRZEXITERROR)                                 05444\n         DC    A(MJRQFRZEXITERROR)                                      05445\n         ORG                                                            05446\nMJRQFRZEXITERROR DC C'A pthread_quiesce_and_get_np (BPX1PQG) service c' 05447\n         DC    C'all failed because the language environment quick   f' 05448\n         DC    C'reeze exit abnormally ended.'                          05449\n         DC    X'00'                                                    05450\n         ORG   ETAB+(4*JREXITALREADYREG)                                05451\n         DC    A(MJREXITALREADYREG)                                     05452\n         ORG                                                            05453\nMJREXITALREADYREG DC C'The quick freeze exit has already been register' 05454\n         DC    C'ed'                                                    05455\n         DC    X'00'                                                    05456\n         ORG   ETAB+(4*JRCANNOTDEREGISTER)                              05457\n         DC    A(MJRCANNOTDEREGISTER)                                   05458\n         ORG                                                            05459\nMJRCANNOTDEREGISTER DC C'The quick freeze exit cannot be deregistered'  05460\n         DC    X'00'                                                    05461\n         ORG   ETAB+(4*JRREQUESTORTHREAD)                               05462\n         DC    A(MJRREQUESTORTHREAD)                                    05463\n         ORG                                                            05464\nMJRREQUESTORTHREAD DC C'The requestor thread cannot be frozen'          05465\n         DC    X'00'                                                    05466\n         ORG   ETAB+(4*JRTHDSNOTSAFE)                                   05467\n         DC    A(MJRTHDSNOTSAFE)                                        05468\n         ORG                                                            05469\nMJRTHDSNOTSAFE DC C'Specified threads cannot be frozen in a safe state' 05470\n         DC    X'00'                                                    05471\n         ORG   ETAB+(4*JRDUPTHREADS)                                    05472\n         DC    A(MJRDUPTHREADS)                                         05473\n         ORG                                                            05474\nMJRDUPTHREADS DC C'Duplicate threads specified in data structure'       05475\n         DC    X'00'                                                    05476\n         ORG   ETAB+(4*JRSYSENTRYBAD)                                   05477\n         DC    A(MJRSYSENTRYBAD)                                        05478\n         ORG                                                            05479\nMJRSYSENTRYBAD DC C'An inconsistency between the XCF representationand' 05480\n         DC    C' the file system representation of a member in the BP' 05481\n         DC    C'XGRP group exists.'                                    05482\n         DC    X'00'                                                    05483\n         ORG   ETAB+(4*JRFILENOTEMPTY)                                  05484\n         DC    A(MJRFILENOTEMPTY)                                       05485\n         ORG                                                            05486\nMJRFILENOTEMPTY DC C'The file is not empty'                             05487\n         DC    X'00'                                                    05488\n         ORG   ETAB+(4*JRNODELREQUESTED)                                05489\n         DC    A(MJRNODELREQUESTED)                                     05490\n         ORG                                                            05491\nMJRNODELREQUESTED DC C'The directory does not allow unlinks       '     05492\n         DC    X'00'                                                    05493\n         ORG   ETAB+(4*JRCONVERSIONERR)                                 05494\n         DC    A(MJRCONVERSIONERR)                                      05495\n         ORG                                                            05496\nMJRCONVERSIONERR DC C'Unicode/390 conversion error'                     05497\n         DC    X'00'                                                    05498\n         ORG   ETAB+(4*JRUNCONVERTIBLECHAR)                             05499\n         DC    A(MJRUNCONVERTIBLECHAR)                                  05500\n         ORG                                                            05501\nMJRUNCONVERTIBLECHAR DC C'Character is not convertible'                 05502\n         DC    X'00'                                                    05503\n         ORG   ETAB+(4*JRINVALIDCCSID)                                  05504\n         DC    A(MJRINVALIDCCSID)                                       05505\n         ORG                                                            05506\nMJRINVALIDCCSID DC C'CCSID not supported'                               05507\n         DC    X'00'                                                    05508\n         ORG   ETAB+(4*JRCONVERSIONENV)                                 05509\n         DC    A(MJRCONVERSIONENV)                                      05510\n         ORG                                                            05511\nMJRCONVERSIONENV DC C'Unicode/390 environmental error'                  05512\n         DC    X'00'                                                    05513\n         ORG   ETAB+(4*JRUNKNOWNCONVERSION)                             05514\n         DC    A(MJRUNKNOWNCONVERSION)                                  05515\n         ORG                                                            05516\nMJRUNKNOWNCONVERSION DC C'Unicode/390 environmental error'              05517\n         DC    X'00'                                                    05518\n         ORG   ETAB+(4*JRNOTASKACEE)                                    05519\n         DC    A(MJRNOTASKACEE)                                         05520\n         ORG                                                            05521\nMJRNOTASKACEE DC C'Invoker must have task level ACEE'                   05522\n         DC    X'00'                                                    05523\n         ORG   ETAB+(4*JRNOTWLMACEE)                                    05524\n         DC    A(MJRNOTWLMACEE)                                         05525\n         ORG                                                            05526\nMJRNOTWLMACEE DC C'ACEE must be WLM created'                            05527\n         DC    X'00'                                                    05528\n         ORG   ETAB+(4*JRTLSDONEONIPT)                                  05529\n         DC    A(MJRTLSDONEONIPT)                                       05530\n         ORG                                                            05531\nMJRTLSDONEONIPT DC C'IPT already invoked TLS_TASK_ACEE#'                05532\n         DC    X'00'                                                    05533\n         ORG   ETAB+(4*JRAMODE64)                                       05534\n         DC    A(MJRAMODE64)                                            05535\n         ORG                                                            05536\nMJRAMODE64 DC C'Invalid addressing mode'                                05537\n         DC    X'00'                                                    05538\n         ORG   ETAB+(4*JRALREADYINSHUTDOWN)                             05539\n         DC    A(MJRALREADYINSHUTDOWN)                                  05540\n         ORG                                                            05541\nMJRALREADYINSHUTDOWN DC C'The block or permanent process cannot be reg' 05542\n         DC    C'istered'                                               05543\n         DC    X'00'                                                    05544\n         ORG   ETAB+(4*JRBLOCKPERMALREADYREGISTERED)                    05545\n         DC    A(MJRBLOCKPERMALREADYREGISTERED)                         05546\n         ORG                                                            05547\nMJRBLOCKPERMALREADYREGISTERED DC C'The process or job is already regis' 05548\n         DC    C'tered'                                                 05549\n         DC    X'00'                                                    05550\n         ORG   ETAB+(4*JRBLOCKPERMNOTREGISTERED)                        05551\n         DC    A(MJRBLOCKPERMNOTREGISTERED)                             05552\n         ORG                                                            05553\nMJRBLOCKPERMNOTREGISTERED DC C'The process or job is not registered'    05554\n         DC    X'00'                                                    05555\n         ORG   ETAB+(4*JRJOBNAMENOTVALID)                               05556\n         DC    A(MJRJOBNAMENOTVALID)                                    05557\n         ORG                                                            05558\nMJRJOBNAMENOTVALID DC C'The Job Name was not found'                     05559\n         DC    X'00'                                                    05560\n         ORG   ETAB+(4*JRJSTMUSTBEREGISTERED)                           05561\n         DC    A(MJRJSTMUSTBEREGISTERED)                                05562\n         ORG                                                            05563\nMJRJSTMUSTBEREGISTERED DC C'The Job Step Process must be registered'    05564\n         DC    X'00'                                                    05565\n         ORG   ETAB+(4*JRNOTAUTHSHUTDOWN)                               05566\n         DC    A(MJRNOTAUTHSHUTDOWN)                                    05567\n         ORG                                                            05568\nMJRNOTAUTHSHUTDOWN DC C'SHUTDOWN_REG call failed permission check for ' 05569\n         DC    C'BPX.SHUTDOWN facility class profile'                   05570\n         DC    X'00'                                                    05571\n         ORG   ETAB+(4*JRUNSUPPORTEDENV)                                05572\n         DC    A(MJRUNSUPPORTEDENV)                                     05573\n         ORG                                                            05574\nMJRUNSUPPORTEDENV DC C'Caller attempted to call a USS Service in an un' 05575\n         DC    C'supported environment'                                 05576\n         DC    X'00'                                                    05577\n         ORG   ETAB+(4*JRRESTARTEDFD)                                   05578\n         DC    A(MJRRESTARTEDFD)                                        05579\n         ORG                                                            05580\nMJRRESTARTEDFD DC C'The file descriptor is left over after OMVS Restar' 05581\n         DC    C't'                                                     05582\n         DC    X'00'                                                    05583\n         ORG   ETAB+(4*JRFILESLOCKED)                                   05584\n         DC    A(MJRFILESLOCKED)                                        05585\n         ORG                                                            05586\nMJRFILESLOCKED DC C'Command not allowed because one or more applicatio' 05587\n         DC    C'ns have byte range locks on files in the filesystem.'  05588\n         DC    X'00'                                                    05589\n         ORG   ETAB+(4*JRINVIOCTLARG)                                   05590\n         DC    A(MJRINVIOCTLARG)                                        05591\n         ORG                                                            05592\nMJRINVIOCTLARG DC C'The argument value used in the ioctl is not valid ' 05593\n         DC    C'for the command'                                       05594\n         DC    X'00'                                                    05595\n         ORG   ETAB+(4*JRINVIOCTLARGLEN)                                05596\n         DC    A(MJRINVIOCTLARGLEN)                                     05597\n         ORG                                                            05598\nMJRINVIOCTLARGLEN DC C'The length of the argument used with the ioctl ' 05599\n         DC    C'command is not valid for the command'                  05600\n         DC    X'00'                                                    05601\n         ORG   ETAB+(4*JRSHUTDOWNINPROGRESS)                            05602\n         DC    A(MJRSHUTDOWNINPROGRESS)                                 05603\n         ORG                                                            05604\nMJRSHUTDOWNINPROGRESS DC C'Kernel Shutdown is in progress on this syst' 05605\n         DC    C'em.'                                                   05606\n         DC    X'00'                                                    05607\n         ORG   ETAB+(4*JRCDSFAILURE)                                    05608\n         DC    A(MJRCDSFAILURE)                                         05609\n         ORG                                                            05610\nMJRCDSFAILURE DC C'A failure was encountered while trying to access th' 05611\n         DC    C'e CDS.'                                                05612\n         DC    X'00'                                                    05613\n         ORG   ETAB+(4*JRCANNOTBEOWNER)                                 05614\n         DC    A(MJRCANNOTBEOWNER)                                      05615\n         ORG                                                            05616\nMJRCANNOTBEOWNER DC C'This system can not be a file system owner thru ' 05617\n         DC    C'a move or recovery operation.'                         05618\n         DC    X'00'                                                    05619\n         ORG   ETAB+(4*JRISMOUNTEDREALNAME)                             05620\n         DC    A(MJRISMOUNTEDREALNAME)                                  05621\n         ORG                                                            05622\nMJRISMOUNTEDREALNAME DC C'A mounted file system has a real or alias na' 05623\n         DC    C'me that conflicts with this mount request.'            05624\n         DC    X'00'                                                    05625\n.NOTZOS3 ANOP                                                           05626\n******************************************************************      05627\n*  ERRNOJR'S 7100-710F RESERVED FOR SNACKETS PFS             @PCA*      05628\n******************************************************************      05629\n******************************************************************      05630\n*  ERRNOJR'S 7110-71FF Are available                         @PMA*      05631\n******************************************************************      05632\n         ORG   ETAB2+(4*(JRREVERR-29000))                               05633\n         DC    A(MJRREVERR)                                             05634\n         ORG                                                            05635\nMJRREVERR DC C'revision code of library greater than program.'          05636\n         DC    X'00'                                                    05637\n******************************************************************      05638\n*  ERRNOJR'S 7200-73FF RESERVED FOR TCP/IP               @QAC@PMA*      05639\n******************************************************************      05640\n         ORG   ETAB2+(4*(JRACKLENFAILURE-29000))                        05641\n         DC    A(MJRACKLENFAILURE)                                      05642\n         ORG                                                            05643\nMJRACKLENFAILURE DC C'The size of the TPI data is not large enough to ' 05644\n         DC    C'support the Prim_type field.'                          05645\n         DC    X'00'                                                    05646\n         ORG   ETAB2+(4*(JRUNEXPECTEDACK-29000))                        05647\n         DC    A(MJRUNEXPECTEDACK)                                      05648\n         ORG                                                            05649\nMJRUNEXPECTEDACK DC C'The Prim_type received from the TPI request does' 05650\n         DC    C' not match the request.'                               05651\n         DC    X'00'                                                    05652\n         ORG   ETAB2+(4*(JRALREADYBOUND-29000))                         05653\n         DC    A(MJRALREADYBOUND)                                       05654\n         ORG                                                            05655\nMJRALREADYBOUND DC C'The Socket has already been bound by a previous r' 05656\n         DC    C'equest.'                                               05657\n         DC    X'00'                                                    05658\n         ORG   ETAB2+(4*(JRNOTBOUND-29000))                             05659\n         DC    A(MJRNOTBOUND)                                           05660\n         ORG                                                            05661\nMJRNOTBOUND DC C'Read not allowed on unbound socket unless it is RAW.'  05662\n         DC    X'00'                                                    05663\n         ORG   ETAB2+(4*(JRWRONGBAND-29000))                            05664\n         DC    A(MJRWRONGBAND)                                          05665\n         ORG                                                            05666\nMJRWRONGBAND DC C'Message received on wrong band.'                      05667\n         DC    X'00'                                                    05668\n         ORG   ETAB2+(4*(JRTLIERROR-29000))                             05669\n         DC    A(MJRTLIERROR)                                           05670\n         ORG                                                            05671\nMJRTLIERROR DC C'ERRNO returned by the transport layer interface.'      05672\n         DC    X'00'                                                    05673\n         ORG   ETAB2+(4*(JRCONNFAIL-29000))                             05674\n         DC    A(MJRCONNFAIL)                                           05675\n         ORG                                                            05676\nMJRCONNFAIL DC C'Previous connection request on this socket failed.'    05677\n         DC    X'00'                                                    05678\n         ORG   ETAB2+(4*(JRCFGMREQLENERR-29000))                        05679\n         DC    A(MJRCFGMREQLENERR)                                      05680\n         ORG                                                            05681\nMJRCFGMREQLENERR DC C'The size of the returned buffer is not large eno' 05682\n         DC    C'ugh to support a CFGMREQ structure.'                   05683\n         DC    X'00'                                                    05684\n         ORG   ETAB2+(4*(JRBULKMODEERR-29000))                          05685\n         DC    A(MJRBULKMODEERR)                                        05686\n         ORG                                                            05687\nMJRBULKMODEERR DC C'The type of socket request specified is not valid ' 05688\n         DC    C'for a Bulkmode socket.'                                05689\n         DC    X'00'                                                    05690\n         ORG   ETAB2+(4*(JRIOCTLACCESSAUTHORIZATION-29000))             05691\n         DC    A(MJRIOCTLACCESSAUTHORIZATION)                           05692\n         ORG                                                            05693\nMJRIOCTLACCESSAUTHORIZATION DC C'The user does not have access authori' 05694\n         DC    C'ty for the requested ioctl.'                           05695\n         DC    X'00'                                                    05696\n         ORG   ETAB2+(4*(JRIOCTLSIZEINCORRECT-29000))                   05697\n         DC    A(MJRIOCTLSIZEINCORRECT)                                 05698\n         ORG                                                            05699\nMJRIOCTLSIZEINCORRECT DC C'The size of the structure used in the ioctl' 05700\n         DC    C' is not correct.'                                      05701\n         DC    X'00'                                                    05702\n         ORG   ETAB2+(4*(JRIOCTLAFNOTSUPPORTED-29000))                  05703\n         DC    A(MJRIOCTLAFNOTSUPPORTED)                                05704\n         ORG                                                            05705\nMJRIOCTLAFNOTSUPPORTED DC C'The address family is not supported for th' 05706\n         DC    C'e specified ioctl.'                                    05707\n         DC    X'00'                                                    05708\n         ORG   ETAB2+(4*(JRIOCTLRTTABLESIZE-29000))                     05709\n         DC    A(MJRIOCTLRTTABLESIZE)                                   05710\n         ORG                                                            05711\nMJRIOCTLRTTABLESIZE DC C'The TCP/IP Route table does not fit in the bu' 05712\n         DC    C'ffer provided.'                                        05713\n         DC    X'00'                                                    05714\n         ORG   ETAB2+(4*(JRIOCTLTPRIMNOTSET-29000))                     05715\n         DC    A(MJRIOCTLTPRIMNOTSET)                                   05716\n         ORG                                                            05717\nMJRIOCTLTPRIMNOTSET DC C'No primary interface is defined to TCP/IP.'    05718\n         DC    X'00'                                                    05719\n         ORG   ETAB2+(4*(JRIOCTLLINKNAME-29000))                        05720\n         DC    A(MJRIOCTLLINKNAME)                                      05721\n         ORG                                                            05722\nMJRIOCTLLINKNAME DC C'The ifr_name specified was not found to be a val' 05723\n         DC    C'id, defined link name.'                                05724\n         DC    X'00'                                                    05725\n         ORG   ETAB2+(4*(JRDEVNUMINVALID-29000))                        05726\n         DC    A(MJRDEVNUMINVALID)                                      05727\n         ORG                                                            05728\nMJRDEVNUMINVALID DC C'The device number specified is not valid for the' 05729\n         DC    C' operation.'                                           05730\n         DC    X'00'                                                    05731\n         ORG   ETAB2+(4*(JRIPADDRINVALID-29000))                        05732\n         DC    A(MJRIPADDRINVALID)                                      05733\n         ORG                                                            05734\nMJRIPADDRINVALID DC C'The IP address specified is not valid for the op' 05735\n         DC    C'eration.'                                              05736\n         DC    X'00'                                                    05737\n         ORG   ETAB2+(4*(JRLINKNAMEINVALID-29000))                      05738\n         DC    A(MJRLINKNAMEINVALID)                                    05739\n         ORG                                                            05740\nMJRLINKNAMEINVALID DC C'The link name specified is not valid for the o' 05741\n         DC    C'peration.'                                             05742\n         DC    X'00'                                                    05743\n         ORG   ETAB2+(4*(JRINTERFACEINVALID-29000))                     05744\n         DC    A(MJRINTERFACEINVALID)                                   05745\n         ORG                                                            05746\nMJRINTERFACEINVALID DC C'The interface specified is not valid for the ' 05747\n         DC    C'operation.'                                            05748\n         DC    X'00'                                                    05749\n         ORG   ETAB2+(4*(JRDEVICECTCINVALID-29000))                     05750\n         DC    A(MJRDEVICECTCINVALID)                                   05751\n         ORG                                                            05752\nMJRDEVICECTCINVALID DC C'The device conflicts with a CTC device.'       05753\n         DC    X'00'                                                    05754\n         ORG   ETAB2+(4*(JRDEVICECLAWINVALID-29000))                    05755\n         DC    A(MJRDEVICECLAWINVALID)                                  05756\n         ORG                                                            05757\nMJRDEVICECLAWINVALID DC C'The device conflicts with a CLAW device.'     05758\n         DC    X'00'                                                    05759\n         ORG   ETAB2+(4*(JRDEVICELCSINVALID-29000))                     05760\n         DC    A(MJRDEVICELCSINVALID)                                   05761\n         ORG                                                            05762\nMJRDEVICELCSINVALID DC C'The device conflicts with a LCS device.'       05763\n         DC    X'00'                                                    05764\n         ORG   ETAB2+(4*(JRLINKSMAXEXCEEDED-29000))                     05765\n         DC    A(MJRLINKSMAXEXCEEDED)                                   05766\n         ORG                                                            05767\nMJRLINKSMAXEXCEEDED DC C'The number of link names has been exceeded.'   05768\n         DC    X'00'                                                    05769\n         ORG   ETAB2+(4*(JRINTERFACEALREADYSTOPPED-29000))              05770\n         DC    A(MJRINTERFACEALREADYSTOPPED)                            05771\n         ORG                                                            05772\nMJRINTERFACEALREADYSTOPPED DC C'The Interface is already stopped.'      05773\n         DC    X'00'                                                    05774\n         ORG   ETAB2+(4*(JRINTERFACEALREADYSTARTED-29000))              05775\n         DC    A(MJRINTERFACEALREADYSTARTED)                            05776\n         ORG                                                            05777\nMJRINTERFACEALREADYSTARTED DC C'The interface is already started.'      05778\n         DC    X'00'                                                    05779\n         ORG   ETAB2+(4*(JRDEVICENOTDEFINED-29000))                     05780\n         DC    A(MJRDEVICENOTDEFINED)                                   05781\n         ORG                                                            05782\nMJRDEVICENOTDEFINED DC C'The device number specified is not defined.'   05783\n         DC    X'00'                                                    05784\n         ORG   ETAB2+(4*(JRDEVICEALREADYDEFINED-29000))                 05785\n         DC    A(MJRDEVICEALREADYDEFINED)                               05786\n         ORG                                                            05787\nMJRDEVICEALREADYDEFINED DC C'The device is already defined.'            05788\n         DC    X'00'                                                    05789\n         ORG   ETAB2+(4*(JRDEVICEUNSUPPORTED-29000))                    05790\n         DC    A(MJRDEVICEUNSUPPORTED)                                  05791\n         ORG                                                            05792\nMJRDEVICEUNSUPPORTED DC C'The device type is unsupported.'              05793\n         DC    X'00'                                                    05794\n         ORG   ETAB2+(4*(JRDEVICEACTIVE-29000))                         05795\n         DC    A(MJRDEVICEACTIVE)                                       05796\n         ORG                                                            05797\nMJRDEVICEACTIVE DC C'The device type is active.'                        05798\n         DC    X'00'                                                    05799\n         ORG   ETAB2+(4*(JRCONFIGERR-29000))                            05800\n         DC    A(MJRCONFIGERR)                                          05801\n         ORG                                                            05802\nMJRCONFIGERR DC C'Config statement is outside of Beg/End Statement.'    05803\n         DC    X'00'                                                    05804\n         ORG   ETAB2+(4*(JRAFNOTSUPPORTED-29000))                       05805\n         DC    A(MJRAFNOTSUPPORTED)                                     05806\n         ORG                                                            05807\nMJRAFNOTSUPPORTED DC C'Address Family is not supported.'                05808\n         DC    X'00'                                                    05809\n         ORG   ETAB2+(4*(JRTCPNOTUP-29000))                             05810\n         DC    A(MJRTCPNOTUP)                                           05811\n         ORG                                                            05812\nMJRTCPNOTUP DC C'TCP/IP is not initialized.'                            05813\n         DC    X'00'                                                    05814\n         ORG   ETAB2+(4*(JRUDPNOTUP-29000))                             05815\n         DC    A(MJRUDPNOTUP)                                           05816\n         ORG                                                            05817\nMJRUDPNOTUP DC C'TCP/IP is not initialized.'                            05818\n         DC    X'00'                                                    05819\n         ORG   ETAB2+(4*(JRGETCONNERR-29000))                           05820\n         DC    A(MJRGETCONNERR)                                         05821\n         ORG                                                            05822\nMJRGETCONNERR DC C'The connection was not in the proper state for retr' 05823\n         DC    C'ieving.'                                               05824\n         DC    X'00'                                                    05825\n         ORG   ETAB2+(4*(JRPATFNDERR-29000))                            05826\n         DC    A(MJRPATFNDERR)                                          05827\n         ORG                                                            05828\nMJRPATFNDERR DC C'Search for a restricted port failed.'                 05829\n         DC    X'00'                                                    05830\n         ORG   ETAB2+(4*(JRPATFNXERR-29000))                            05831\n         DC    A(MJRPATFNXERR)                                          05832\n         ORG                                                            05833\nMJRPATFNXERR DC C'Search for restricted ports failed.'                  05834\n         DC    X'00'                                                    05835\n         ORG   ETAB2+(4*(JRPATADDERR-29000))                            05836\n         DC    A(MJRPATADDERR)                                          05837\n         ORG                                                            05838\nMJRPATADDERR DC C'Add new restricted port failed.'                      05839\n         DC    X'00'                                                    05840\n         ORG   ETAB2+(4*(JRPATDELERR-29000))                            05841\n         DC    A(MJRPATDELERR)                                          05842\n         ORG                                                            05843\nMJRPATDELERR DC C'Delete a restricted port failed.'                     05844\n         DC    X'00'                                                    05845\n         ORG   ETAB2+(4*(JRPATEXISTERR-29000))                          05846\n         DC    A(MJRPATEXISTERR)                                        05847\n         ORG                                                            05848\nMJRPATEXISTERR DC C'Restricted port entry already existed.'             05849\n         DC    X'00'                                                    05850\n         ORG   ETAB2+(4*(JRPATNOTFOUND-29000))                          05851\n         DC    A(MJRPATNOTFOUND)                                        05852\n         ORG                                                            05853\nMJRPATNOTFOUND DC C'Restricted port entry is not found.'                05854\n         DC    X'00'                                                    05855\n         ORG   ETAB2+(4*(JRINVALIDDADDR-29000))                         05856\n         DC    A(MJRINVALIDDADDR)                                       05857\n         ORG                                                            05858\nMJRINVALIDDADDR DC C'Specified address is not valid.'                   05859\n         DC    X'00'                                                    05860\n         ORG   ETAB2+(4*(JRPORTRERR-29000))                             05861\n         DC    A(MJRPORTRERR)                                           05862\n         ORG                                                            05863\nMJRPORTRERR DC C'The input specified in the port range statement is no' 05864\n         DC    C't valid.'                                              05865\n         DC    X'00'                                                    05866\n         ORG   ETAB2+(4*(JRINTERFACEDEFINEDBYHOME-29000))               05867\n         DC    A(MJRINTERFACEDEFINEDBYHOME)                             05868\n         ORG                                                            05869\nMJRINTERFACEDEFINEDBYHOME DC C'The interface has been used within a Ho' 05870\n         DC    C'me statement.'                                         05871\n         DC    X'00'                                                    05872\n         ORG   ETAB2+(4*(JRDEVICEDEFINEDBYLINK-29000))                  05873\n         DC    A(MJRDEVICEDEFINEDBYLINK)                                05874\n         ORG                                                            05875\nMJRDEVICEDEFINEDBYLINK DC C'The device is defined by a Link statement.' 05876\n         DC    X'00'                                                    05877\n         ORG   ETAB2+(4*(JRDEVICETYPEINVALID-29000))                    05878\n         DC    A(MJRDEVICETYPEINVALID)                                  05879\n         ORG                                                            05880\nMJRDEVICETYPEINVALID DC C'The device type is not valid for the operati' 05881\n         DC    C'on requested.'                                         05882\n         DC    X'00'                                                    05883\n         ORG   ETAB2+(4*(JRBSDROUTINGPARMSNEVERUSED-29000))             05884\n         DC    A(MJRBSDROUTINGPARMSNEVERUSED)                           05885\n         ORG                                                            05886\nMJRBSDROUTINGPARMSNEVERUSED DC C'BSDRoutingParms were never configured' 05887\n         DC    C' for TCP/IP.'                                          05888\n         DC    X'00'                                                    05889\n         ORG   ETAB2+(4*(JRBINDOUTSTATE-29000))                         05890\n         DC    A(MJRBINDOUTSTATE)                                       05891\n         ORG                                                            05892\nMJRBINDOUTSTATE DC C'The current TPL state is not unbound when doing a' 05893\n         DC    C' bind request.'                                        05894\n         DC    X'00'                                                    05895\n         ORG   ETAB2+(4*(JRBINDBADSOCKADDR-29000))                      05896\n         DC    A(MJRBINDBADSOCKADDR)                                    05897\n         ORG                                                            05898\nMJRBINDBADSOCKADDR DC C'Bad Socket Address data present in the source ' 05899\n         DC    C'IP address.'                                           05900\n         DC    X'00'                                                    05901\n         ORG   ETAB2+(4*(JRBINDADDRNACTIVE-29000))                      05902\n         DC    A(MJRBINDADDRNACTIVE)                                    05903\n         ORG                                                            05904\nMJRBINDADDRNACTIVE DC C'Local address was not active when processing t' 05905\n         DC    C'he bind request.'                                      05906\n         DC    X'00'                                                    05907\n         ORG   ETAB2+(4*(JRBINDNOPORT-29000))                           05908\n         DC    A(MJRBINDNOPORT)                                         05909\n         ORG                                                            05910\nMJRBINDNOPORT DC C'No port is available. Port entries have reached the' 05911\n         DC    C' maximum number.'                                      05912\n         DC    X'00'                                                    05913\n         ORG   ETAB2+(4*(JRBINDADDRINUSED-29000))                       05914\n         DC    A(MJRBINDADDRINUSED)                                     05915\n         ORG                                                            05916\nMJRBINDADDRINUSED DC C'The INADDR_ANY is being used by other users. Th' 05917\n         DC    C'e bind request fails.'                                 05918\n         DC    X'00'                                                    05919\n         ORG   ETAB2+(4*(JRUNBINDNOTIDLE-29000))                        05920\n         DC    A(MJRUNBINDNOTIDLE)                                      05921\n         ORG                                                            05922\nMJRUNBINDNOTIDLE DC C'The requested connection was not in the proper s' 05923\n         DC    C'tate for the request.'                                 05924\n         DC    X'00'                                                    05925\n         ORG   ETAB2+(4*(JROPTLERR-29000))                              05926\n         DC    A(MJROPTLERR)                                            05927\n         ORG                                                            05928\nMJROPTLERR DC C'The value specified for option_length is not valid.'    05929\n         DC    X'00'                                                    05930\n         ORG   ETAB2+(4*(JRSENDLIMIT-29000))                            05931\n         DC    A(MJRSENDLIMIT)                                          05932\n         ORG                                                            05933\nMJRSENDLIMIT DC C'The send buffer size is not valid. It is too big.'    05934\n         DC    X'00'                                                    05935\n         ORG   ETAB2+(4*(JRRCVDLIMIT-29000))                            05936\n         DC    A(MJRRCVDLIMIT)                                          05937\n         ORG                                                            05938\nMJRRCVDLIMIT DC C'The received buffer size is not valid. It is too big' 05939\n         DC    C'.'                                                     05940\n         DC    X'00'                                                    05941\n         ORG   ETAB2+(4*(JRBSTOPT-29000))                               05942\n         DC    A(MJRBSTOPT)                                             05943\n         ORG                                                            05944\nMJRBSTOPT DC C'The value specified for option_value is not valid.'      05945\n         DC    X'00'                                                    05946\n         ORG   ETAB2+(4*(JRBRTOPT-29000))                               05947\n         DC    A(MJRBRTOPT)                                             05948\n         ORG                                                            05949\nMJRBRTOPT DC C'The value specified for option_value is not valid.'      05950\n         DC    X'00'                                                    05951\n         ORG   ETAB2+(4*(JRIPOPT-29000))                                05952\n         DC    A(MJRIPOPT)                                              05953\n         ORG                                                            05954\nMJRIPOPT DC C'The value specified for option_value is not valid.'       05955\n         DC    X'00'                                                    05956\n         ORG   ETAB2+(4*(JRTOSOPT-29000))                               05957\n         DC    A(MJRTOSOPT)                                             05958\n         ORG                                                            05959\nMJRTOSOPT DC C'The value specified for type of service is not valid.'   05960\n         DC    X'00'                                                    05961\n         ORG   ETAB2+(4*(JRTTLOPT-29000))                               05962\n         DC    A(MJRTTLOPT)                                             05963\n         ORG                                                            05964\nMJRTTLOPT DC C'The value specifed for time to live is not valid.'       05965\n         DC    X'00'                                                    05966\n         ORG   ETAB2+(4*(JRIPOPTLERR-29000))                            05967\n         DC    A(MJRIPOPTLERR)                                          05968\n         ORG                                                            05969\nMJRIPOPTLERR DC C'The value specified for option_length is not valid.'  05970\n         DC    X'00'                                                    05971\n         ORG   ETAB2+(4*(JRTOSOPTLERR-29000))                           05972\n         DC    A(MJRTOSOPTLERR)                                         05973\n         ORG                                                            05974\nMJRTOSOPTLERR DC C'The value specified for option_length is not valid.' 05975\n         DC    X'00'                                                    05976\n         ORG   ETAB2+(4*(JRTTLOPTLERR-29000))                           05977\n         DC    A(MJRTTLOPTLERR)                                         05978\n         ORG                                                            05979\nMJRTTLOPTLERR DC C'The value specified for option_length is not valid.' 05980\n         DC    X'00'                                                    05981\n         ORG   ETAB2+(4*(JRCONNNOTIDLE-29000))                          05982\n         DC    A(MJRCONNNOTIDLE)                                        05983\n         ORG                                                            05984\nMJRCONNNOTIDLE DC C'Connect request not in idle state.'                 05985\n         DC    X'00'                                                    05986\n         ORG   ETAB2+(4*(JRBROADCASTDEST-29000))                        05987\n         DC    A(MJRBROADCASTDEST)                                      05988\n         ORG                                                            05989\nMJRBROADCASTDEST DC C'Cannot connect to a broadcast address.'           05990\n         DC    X'00'                                                    05991\n         ORG   ETAB2+(4*(JRCONNECTTOSELF-29000))                        05992\n         DC    A(MJRCONNECTTOSELF)                                      05993\n         ORG                                                            05994\nMJRCONNECTTOSELF DC C'Connect address is the same as the source addres' 05995\n         DC    C's.'                                                    05996\n         DC    X'00'                                                    05997\n         ORG   ETAB2+(4*(JRCONNTCBNOTFOUND-29000))                      05998\n         DC    A(MJRCONNTCBNOTFOUND)                                    05999\n         ORG                                                            06000\nMJRCONNTCBNOTFOUND DC C'A TCB was not found for the specified socket.'  06001\n         DC    X'00'                                                    06002\n         ORG   ETAB2+(4*(JRBADTCBEYE-29000))                            06003\n         DC    A(MJRBADTCBEYE)                                          06004\n         ORG                                                            06005\nMJRBADTCBEYE DC C'The TCB has been freed or overlaid.'                  06006\n         DC    X'00'                                                    06007\n         ORG   ETAB2+(4*(JRNOACCEPTTCB-29000))                          06008\n         DC    A(MJRNOACCEPTTCB)                                        06009\n         ORG                                                            06010\nMJRNOACCEPTTCB DC C'There is no valid TCB on the accept queue.'         06011\n         DC    X'00'                                                    06012\n         ORG   ETAB2+(4*(JRDISCONTCBNOTFOUND-29000))                    06013\n         DC    A(MJRDISCONTCBNOTFOUND)                                  06014\n         ORG                                                            06015\nMJRDISCONTCBNOTFOUND DC C'The TCB could not be found for disconnect.'   06016\n         DC    X'00'                                                    06017\n         ORG   ETAB2+(4*(JRPORTACCESSAUTH-29000))                       06018\n         DC    A(MJRPORTACCESSAUTH)                                     06019\n         ORG                                                            06020\nMJRPORTACCESSAUTH DC C'User does not have authority to access this por' 06021\n         DC    C't.'                                                    06022\n         DC    X'00'                                                    06023\n         ORG   ETAB2+(4*(JRPORTBUSY-29000))                             06024\n         DC    A(MJRPORTBUSY)                                           06025\n         ORG                                                            06026\nMJRPORTBUSY DC C'Specified port is in use.'                             06027\n         DC    X'00'                                                    06028\n         ORG   ETAB2+(4*(JRSENDOPTLERR-29000))                          06029\n         DC    A(MJRSENDOPTLERR)                                        06030\n         ORG                                                            06031\nMJRSENDOPTLERR DC C'The value specified for option_length is not valid' 06032\n         DC    C'.'                                                     06033\n         DC    X'00'                                                    06034\n         ORG   ETAB2+(4*(JRRECVOPTLERR-29000))                          06035\n         DC    A(MJRRECVOPTLERR)                                        06036\n         ORG                                                            06037\nMJRRECVOPTLERR DC C'The value specified for option_length is not valid' 06038\n         DC    C'.'                                                     06039\n         DC    X'00'                                                    06040\n         ORG   ETAB2+(4*(JRBSTOPTLERR-29000))                           06041\n         DC    A(MJRBSTOPTLERR)                                         06042\n         ORG                                                            06043\nMJRBSTOPTLERR DC C'The value specified for option_length is not valid.' 06044\n         DC    X'00'                                                    06045\n         ORG   ETAB2+(4*(JRBRTOPTLERR-29000))                           06046\n         DC    A(MJRBRTOPTLERR)                                         06047\n         ORG                                                            06048\nMJRBRTOPTLERR DC C'The value specified for option_length is not valid.' 06049\n         DC    X'00'                                                    06050\n         ORG   ETAB2+(4*(JRRTINVALIDTOS-29000))                         06051\n         DC    A(MJRRTINVALIDTOS)                                       06052\n         ORG                                                            06053\nMJRRTINVALIDTOS DC C'Specified route type of service is not valid.'     06054\n         DC    X'00'                                                    06055\n         ORG   ETAB2+(4*(JRRTINVALIDGATEWAYADDR-29000))                 06056\n         DC    A(MJRRTINVALIDGATEWAYADDR)                               06057\n         ORG                                                            06058\nMJRRTINVALIDGATEWAYADDR DC C'Specified route gateway address is not va' 06059\n         DC    C'lid.'                                                  06060\n         DC    X'00'                                                    06061\n         ORG   ETAB2+(4*(JRRTINVALIDPROTOCOL-29000))                    06062\n         DC    A(MJRRTINVALIDPROTOCOL)                                  06063\n         ORG                                                            06064\nMJRRTINVALIDPROTOCOL DC C'Specified route protocol is not valid.'       06065\n         DC    X'00'                                                    06066\n         ORG   ETAB2+(4*(JRRTINVALIDTYPE-29000))                        06067\n         DC    A(MJRRTINVALIDTYPE)                                      06068\n         ORG                                                            06069\nMJRRTINVALIDTYPE DC C'Specified route type is not valid.'               06070\n         DC    X'00'                                                    06071\n         ORG   ETAB2+(4*(JRRTINVALIDDEST-29000))                        06072\n         DC    A(MJRRTINVALIDDEST)                                      06073\n         ORG                                                            06074\nMJRRTINVALIDDEST DC C'Specified route destination is not valid.'        06075\n         DC    X'00'                                                    06076\n         ORG   ETAB2+(4*(JRRTINVALIDMASK-29000))                        06077\n         DC    A(MJRRTINVALIDMASK)                                      06078\n         ORG                                                            06079\nMJRRTINVALIDMASK DC C'Specified route subnet mask is not valid.'        06080\n         DC    X'00'                                                    06081\n         ORG   ETAB2+(4*(JRRTINVALIDHOSTADDR-29000))                    06082\n         DC    A(MJRRTINVALIDHOSTADDR)                                  06083\n         ORG                                                            06084\nMJRRTINVALIDHOSTADDR DC C'Specified route host ip address is not valid' 06085\n         DC    C'.'                                                     06086\n         DC    X'00'                                                    06087\n         ORG   ETAB2+(4*(JRHARDWARETYPENOTSUPPORTED-29000))             06088\n         DC    A(MJRHARDWARETYPENOTSUPPORTED)                           06089\n         ORG                                                            06090\nMJRHARDWARETYPENOTSUPPORTED DC C'Specified hardware type is not suppor' 06091\n         DC    C'ted.'                                                  06092\n         DC    X'00'                                                    06093\n         ORG   ETAB2+(4*(JRLINKTYPEINVALID-29000))                      06094\n         DC    A(MJRLINKTYPEINVALID)                                    06095\n         ORG                                                            06096\nMJRLINKTYPEINVALID DC C'The link type is not valid for the operation r' 06097\n         DC    C'equested.'                                             06098\n         DC    X'00'                                                    06099\n         ORG   ETAB2+(4*(JRNOHOMESTATEMENT-29000))                      06100\n         DC    A(MJRNOHOMESTATEMENT)                                    06101\n         ORG                                                            06102\nMJRNOHOMESTATEMENT DC C'The link name does not have an associated home' 06103\n         DC    C' statement.'                                           06104\n         DC    X'00'                                                    06105\n         ORG   ETAB2+(4*(JRIOCTLNOTSUPPORTED-29000))                    06106\n         DC    A(MJRIOCTLNOTSUPPORTED)                                  06107\n         ORG                                                            06108\nMJRIOCTLNOTSUPPORTED DC C'The specified ioctl is not supported in this' 06109\n         DC    C' version of TCP/IP.'                                   06110\n         DC    X'00'                                                    06111\n         ORG   ETAB2+(4*(JRLVLSOCNOSUP-29000))                          06112\n         DC    A(MJRLVLSOCNOSUP)                                        06113\n         ORG                                                            06114\nMJRLVLSOCNOSUP DC C'The option_name that was specified is not supporte' 06115\n         DC    C'd.'                                                    06116\n         DC    X'00'                                                    06117\n         ORG   ETAB2+(4*(JRLVLTCPNOSUP-29000))                          06118\n         DC    A(MJRLVLTCPNOSUP)                                        06119\n         ORG                                                            06120\nMJRLVLTCPNOSUP DC C'The level that was specified is not supported.'     06121\n         DC    X'00'                                                    06122\n         ORG   ETAB2+(4*(JRLVLIPNOSUP-29000))                           06123\n         DC    A(MJRLVLIPNOSUP)                                         06124\n         ORG                                                            06125\nMJRLVLIPNOSUP DC C'The option_name that was specified is not supported' 06126\n         DC    C'.'                                                     06127\n         DC    X'00'                                                    06128\n         ORG   ETAB2+(4*(JRINVOPTLEN-29000))                            06129\n         DC    A(MJRINVOPTLEN)                                          06130\n         ORG                                                            06131\nMJRINVOPTLEN DC C'The option length is not valid'                       06132\n         DC    X'00'                                                    06133\n         ORG   ETAB2+(4*(JRINVOPTVAL-29000))                            06134\n         DC    A(MJRINVOPTVAL)                                          06135\n         ORG                                                            06136\nMJRINVOPTVAL DC C'The option value is not valid'                        06137\n         DC    X'00'                                                    06138\n         ORG   ETAB2+(4*(JRCONNALREADYEXISTS-29000))                    06139\n         DC    A(MJRCONNALREADYEXISTS)                                  06140\n         ORG                                                            06141\nMJRCONNALREADYEXISTS DC C'The address is already in use.'               06142\n         DC    X'00'                                                    06143\n         ORG   ETAB2+(4*(JRSTARTNONDEVICEINVALID-29000))                06144\n         DC    A(MJRSTARTNONDEVICEINVALID)                              06145\n         ORG                                                            06146\nMJRSTARTNONDEVICEINVALID DC C'An attempt was made to start an interfac' 06147\n         DC    C'e which isnot a device.'                               06148\n         DC    X'00'                                                    06149\n         ORG   ETAB2+(4*(JRBADIOCTLTOIF-29000))                         06150\n         DC    A(MJRBADIOCTLTOIF)                                       06151\n         ORG                                                            06152\nMJRBADIOCTLTOIF DC C'An internal error occurred between the ioctl and ' 06153\n         DC    C'Interface layer.'                                      06154\n         DC    X'00'                                                    06155\n         ORG   ETAB2+(4*(JRLINKNOTDEFINED-29000))                       06156\n         DC    A(MJRLINKNOTDEFINED)                                     06157\n         ORG                                                            06158\nMJRLINKNOTDEFINED DC C'The link name specified is not defined.'         06159\n         DC    X'00'                                                    06160\n         ORG   ETAB2+(4*(JRMAXSTARTSEXCEEDED-29000))                    06161\n         DC    A(MJRMAXSTARTSEXCEEDED)                                  06162\n         ORG                                                            06163\nMJRMAXSTARTSEXCEEDED DC C'An internal limit of START DEVICEs has been ' 06164\n         DC    C'exceeded.'                                             06165\n         DC    X'00'                                                    06166\n         ORG   ETAB2+(4*(JRDEVICEHASLINKS-29000))                       06167\n         DC    A(MJRDEVICEHASLINKS)                                     06168\n         ORG                                                            06169\nMJRDEVICEHASLINKS DC C'An attempt was made to DELETE a device, but the' 06170\n         DC    C' device has at least one LINK defined to it.'          06171\n         DC    X'00'                                                    06172\n         ORG   ETAB2+(4*(JRDEVICEHASNOLINKS-29000))                     06173\n         DC    A(MJRDEVICEHASNOLINKS)                                   06174\n         ORG                                                            06175\nMJRDEVICEHASNOLINKS DC C'An attempt was made to START a device, but th' 06176\n         DC    C'e device has no LINKs defined to it.'                  06177\n         DC    X'00'                                                    06178\n         ORG   ETAB2+(4*(JRINTERFACENOTDEFINED-29000))                  06179\n         DC    A(MJRINTERFACENOTDEFINED)                                06180\n         ORG                                                            06181\nMJRINTERFACENOTDEFINED DC C'The interface specified is not defined.'    06182\n         DC    X'00'                                                    06183\n         ORG   ETAB2+(4*(JRRTALREADYEXISTS-29000))                      06184\n         DC    A(MJRRTALREADYEXISTS)                                    06185\n         ORG                                                            06186\nMJRRTALREADYEXISTS DC C'The route already exists.'                      06187\n         DC    X'00'                                                    06188\n         ORG   ETAB2+(4*(JRRTNOTDEFINED-29000))                         06189\n         DC    A(MJRRTNOTDEFINED)                                       06190\n         ORG                                                            06191\nMJRRTNOTDEFINED DC C'The route is not defined.'                         06192\n         DC    X'00'                                                    06193\n         ORG   ETAB2+(4*(JRRTREMOVEDIRECTERROR-29000))                  06194\n         DC    A(MJRRTREMOVEDIRECTERROR)                                06195\n         ORG                                                            06196\nMJRRTREMOVEDIRECTERROR DC C'The route to be removed is a direct route.' 06197\n         DC    X'00'                                                    06198\n         ORG   ETAB2+(4*(JRGATEWAYUNREACHABLE-29000))                   06199\n         DC    A(MJRGATEWAYUNREACHABLE)                                 06200\n         ORG                                                            06201\nMJRGATEWAYUNREACHABLE DC C'The gateway is unreachable by any routes.'   06202\n         DC    X'00'                                                    06203\n         ORG   ETAB2+(4*(JRRTREMOVEINDIRECTERROR-29000))                06204\n         DC    A(MJRRTREMOVEINDIRECTERROR)                              06205\n         ORG                                                            06206\nMJRRTREMOVEINDIRECTERROR DC C'The route to be removed is an indirect r' 06207\n         DC    C'oute.'                                                 06208\n         DC    X'00'                                                    06209\n         ORG   ETAB2+(4*(JRARPSVMULT-29000))                            06210\n         DC    A(MJRARPSVMULT)                                          06211\n         ORG                                                            06212\nMJRARPSVMULT DC C'Multiple ATMARP servers are defined for the same lin' 06213\n         DC    C'k.'                                                    06214\n         DC    X'00'                                                    06215\n         ORG   ETAB2+(4*(JRDEVICEMPCPTPINVALID-29000))                  06216\n         DC    A(MJRDEVICEMPCPTPINVALID)                                06217\n         ORG                                                            06218\nMJRDEVICEMPCPTPINVALID DC C'A MPCPTP link was defined for an incorrect' 06219\n         DC    C' device type.'                                         06220\n         DC    X'00'                                                    06221\n         ORG   ETAB2+(4*(JRDEVICEHCHINVALID-29000))                     06222\n         DC    A(MJRDEVICEHCHINVALID)                                   06223\n         ORG                                                            06224\nMJRDEVICEHCHINVALID DC C'An HCH link was defined for an incorrect devi' 06225\n         DC    C'ce type.'                                              06226\n         DC    X'00'                                                    06227\n         ORG   ETAB2+(4*(JRDEVICECDLCINVALID-29000))                    06228\n         DC    A(MJRDEVICECDLCINVALID)                                  06229\n         ORG                                                            06230\nMJRDEVICECDLCINVALID DC C'A CDLC link was defined for an incorrect dev' 06231\n         DC    C'ice type.'                                             06232\n         DC    X'00'                                                    06233\n         ORG   ETAB2+(4*(JRDEVICEX25INVALID-29000))                     06234\n         DC    A(MJRDEVICEX25INVALID)                                   06235\n         ORG                                                            06236\nMJRDEVICEX25INVALID DC C'An X.25 link was defined for an incorrect dev' 06237\n         DC    C'ice type.'                                             06238\n         DC    X'00'                                                    06239\n         ORG   ETAB2+(4*(JRDEVICEATMINVALID-29000))                     06240\n         DC    A(MJRDEVICEATMINVALID)                                   06241\n         ORG                                                            06242\nMJRDEVICEATMINVALID DC C'An ATM link was defined for an incorrect devi' 06243\n         DC    C'ce type.'                                              06244\n         DC    X'00'                                                    06245\n         ORG   ETAB2+(4*(JRLINKALREADYDEFINED-29000))                   06246\n         DC    A(MJRLINKALREADYDEFINED)                                 06247\n         ORG                                                            06248\nMJRLINKALREADYDEFINED DC C'The link is already defined.'                06249\n         DC    X'00'                                                    06250\n         ORG   ETAB2+(4*(JRPVCALREADYDEFINED-29000))                    06251\n         DC    A(MJRPVCALREADYDEFINED)                                  06252\n         ORG                                                            06253\nMJRPVCALREADYDEFINED DC C'The PVC is already defined.'                  06254\n         DC    X'00'                                                    06255\n         ORG   ETAB2+(4*(JRPVCNOTDEFINED-29000))                        06256\n         DC    A(MJRPVCNOTDEFINED)                                      06257\n         ORG                                                            06258\nMJRPVCNOTDEFINED DC C'The PVC name specified is not defined.'           06259\n         DC    X'00'                                                    06260\n         ORG   ETAB2+(4*(JRLISNOTDEFINED-29000))                        06261\n         DC    A(MJRLISNOTDEFINED)                                      06262\n         ORG                                                            06263\nMJRLISNOTDEFINED DC C'The LIS name specified is not defined.'           06264\n         DC    X'00'                                                    06265\n         ORG   ETAB2+(4*(JRARPSVNOTDEFINED-29000))                      06266\n         DC    A(MJRARPSVNOTDEFINED)                                    06267\n         ORG                                                            06268\nMJRARPSVNOTDEFINED DC C'The ATMARPSV name specified is not defined.'    06269\n         DC    X'00'                                                    06270\n         ORG   ETAB2+(4*(JRLISINUSEFORDEVICE-29000))                    06271\n         DC    A(MJRLISINUSEFORDEVICE)                                  06272\n         ORG                                                            06273\nMJRLISINUSEFORDEVICE DC C'Another LINK for this device already specifi' 06274\n         DC    C'es this LIS.'                                          06275\n         DC    X'00'                                                    06276\n         ORG   ETAB2+(4*(JRPVCLINKNOTATM-29000))                        06277\n         DC    A(MJRPVCLINKNOTATM)                                      06278\n         ORG                                                            06279\nMJRPVCLINKNOTATM DC C'An ATMPVC was defined for an incorrect link type' 06280\n         DC    C'.'                                                     06281\n         DC    X'00'                                                    06282\n         ORG   ETAB2+(4*(JRLISINCONSISTENT-29000))                      06283\n         DC    A(MJRLISINCONSISTENT)                                    06284\n         ORG                                                            06285\nMJRLISINCONSISTENT DC C'The LIS name is already defined with a differe' 06286\n         DC    C'nt subnet value/mask.'                                 06287\n         DC    X'00'                                                    06288\n         ORG   ETAB2+(4*(JRLISOPTIONSUPDATED-29000))                    06289\n         DC    A(MJRLISOPTIONSUPDATED)                                  06290\n         ORG                                                            06291\nMJRLISOPTIONSUPDATED DC C'An ATMLIS redefiniton caused the LIS options' 06292\n         DC    C' to be updated.'                                       06293\n         DC    X'00'                                                    06294\n         ORG   ETAB2+(4*(JRPVCINUSEASARPSV-29000))                      06295\n         DC    A(MJRPVCINUSEASARPSV)                                    06296\n         ORG                                                            06297\nMJRPVCINUSEASARPSV DC C'An attempt was made to delete an ATMPVC which ' 06298\n         DC    C'is in use as an ATMARP server.'                        06299\n         DC    X'00'                                                    06300\n         ORG   ETAB2+(4*(JRLINKHASPVCS-29000))                          06301\n         DC    A(MJRLINKHASPVCS)                                        06302\n         ORG                                                            06303\nMJRLINKHASPVCS DC C'An attempt was made to DELETE a LINK, but the LINK' 06304\n         DC    C' has at least one ATMPVC defined to it.'               06305\n         DC    X'00'                                                    06306\n         ORG   ETAB2+(4*(JRLISHASLINKS-29000))                          06307\n         DC    A(MJRLISHASLINKS)                                        06308\n         ORG                                                            06309\nMJRLISHASLINKS DC C'An attempt was made to DELETE an ATMLIS, but the A' 06310\n         DC    C'TMLIS has at least one LINK defined to it.'            06311\n         DC    X'00'                                                    06312\n         ORG   ETAB2+(4*(JRLISHASARPSVS-29000))                         06313\n         DC    A(MJRLISHASARPSVS)                                       06314\n         ORG                                                            06315\nMJRLISHASARPSVS DC C'An attempt was made to DELETE an ATMLIS, but the ' 06316\n         DC    C'ATMLIS has at least one ATMARPSV defined to it.'       06317\n         DC    X'00'                                                    06318\n         ORG   ETAB2+(4*(JRARPSVINUSE-29000))                           06319\n         DC    A(MJRARPSVINUSE)                                         06320\n         ORG                                                            06321\nMJRARPSVINUSE DC C'An attempt was made to DELETE an ATMARPSV, but at a' 06322\n         DC    C't least one ATM device is using the ATMARPSV.'         06323\n         DC    X'00'                                                    06324\n         ORG   ETAB2+(4*(JRNOTINLIS-29000))                             06325\n         DC    A(MJRNOTINLIS)                                           06326\n         ORG                                                            06327\nMJRNOTINLIS DC C'The IP address of a defined ATMARPSV is not in the sp' 06328\n         DC    C'ecified LIS.'                                          06329\n         DC    X'00'                                                    06330\n         ORG   ETAB2+(4*(JRTELSTATERR-29000))                           06331\n         DC    A(MJRTELSTATERR)                                         06332\n         ORG                                                            06333\nMJRTELSTATERR DC C'Attempt to update the telnet attributes when the co' 06334\n         DC    C'nnection is not yet established.'                      06335\n         DC    X'00'                                                    06336\n         ORG   ETAB2+(4*(JRTELNFNDERR-29000))                           06337\n         DC    A(MJRTELNFNDERR)                                         06338\n         ORG                                                            06339\nMJRTELNFNDERR DC C'Telnet session is not found'                         06340\n         DC    X'00'                                                    06341\n         ORG   ETAB2+(4*(JRARPSVALREADYDEFINED-29000))                  06342\n         DC    A(MJRARPSVALREADYDEFINED)                                06343\n         ORG                                                            06344\nMJRARPSVALREADYDEFINED DC C'The ATMARPSV is already defined.'           06345\n         DC    X'00'                                                    06346\n         ORG   ETAB2+(4*(JRLISMISMATCH-29000))                          06347\n         DC    A(MJRLISMISMATCH)                                        06348\n         ORG                                                            06349\nMJRLISMISMATCH DC C'The LIS name on the ATMARPSV PVC statement does no' 06350\n         DC    C't match the LIS defined on the link to which the spec' 06351\n         DC    C'ified PVC is defined.'                                 06352\n         DC    X'00'                                                    06353\n         ORG   ETAB2+(4*(JRDEVICESNAINVALID-29000))                     06354\n         DC    A(MJRDEVICESNAINVALID)                                   06355\n         ORG                                                            06356\nMJRDEVICESNAINVALID DC C'A SNA link was defined for an incorrect devic' 06357\n         DC    C'e type.'                                               06358\n         DC    X'00'                                                    06359\n         ORG   ETAB2+(4*(JRLINKHASNOPVCORLIS-29000))                    06360\n         DC    A(MJRLINKHASNOPVCORLIS)                                  06361\n         ORG                                                            06362\nMJRLINKHASNOPVCORLIS DC C'An ATM link was defined but did not specify ' 06363\n         DC    C'a LIS and has no PVCs defined to it.'                  06364\n         DC    X'00'                                                    06365\n         ORG   ETAB2+(4*(JRRTINVALIDMASKHOST-29000))                    06366\n         DC    A(MJRRTINVALIDMASKHOST)                                  06367\n         ORG                                                            06368\nMJRRTINVALIDMASKHOST DC C'A host route with a non-zero mask was receiv' 06369\n         DC    C'ed'                                                    06370\n         DC    X'00'                                                    06371\n         ORG   ETAB2+(4*(JRRTINVALIDMASKDEFAULT-29000))                 06372\n         DC    A(MJRRTINVALIDMASKDEFAULT)                               06373\n         ORG                                                            06374\nMJRRTINVALIDMASKDEFAULT DC C'A non-default route was received with a d' 06375\n         DC    C'estination of 0'                                       06376\n         DC    X'00'                                                    06377\n         ORG   ETAB2+(4*(JRRTNOBSDROUTINGPARMSSET-29000))               06378\n         DC    A(MJRRTNOBSDROUTINGPARMSSET)                             06379\n         ORG                                                            06380\nMJRRTNOBSDROUTINGPARMSSET DC C'A route was added for a link without BS' 06381\n         DC    C'DRoutingParms'                                         06382\n         DC    X'00'                                                    06383\n         ORG   ETAB2+(4*(JRRTINVALIDMASKCIDR-29000))                    06384\n         DC    A(MJRRTINVALIDMASKCIDR)                                  06385\n         ORG                                                            06386\nMJRRTINVALIDMASKCIDR DC C'The mask does not conform to CIDR requiremen' 06387\n         DC    C't'                                                     06388\n         DC    X'00'                                                    06389\n         ORG   ETAB2+(4*(JRMSGINVALIDFLAG-29000))                       06390\n         DC    A(MJRMSGINVALIDFLAG)                                     06391\n         ORG                                                            06392\nMJRMSGINVALIDFLAG DC C'The socket does not support the function that w' 06393\n         DC    C'as specified with the flags parameter.'                06394\n         DC    X'00'                                                    06395\n         ORG   ETAB2+(4*(JRVARIABLESUBNETTINGNOTALLOWED-29000))         06396\n         DC    A(MJRVARIABLESUBNETTINGNOTALLOWED)                       06397\n         ORG                                                            06398\nMJRVARIABLESUBNETTINGNOTALLOWED DC C'IPCONFIG did not specify RIPV2 or' 06399\n         DC    C' length of rtentry is wrong.'                          06400\n         DC    X'00'                                                    06401\n         ORG   ETAB2+(4*(JRSYSPLEXADDRNOTFOUND-29000))                  06402\n         DC    A(MJRSYSPLEXADDRNOTFOUND)                                06403\n         ORG                                                            06404\nMJRSYSPLEXADDRNOTFOUND DC C'The sysplex loopback address 127.0.0.128 c' 06405\n         DC    C'ould not be resolved to the sysplex domain name by  t' 06406\n         DC    C'he gethostbyaddr() syscall.'                           06407\n         DC    X'00'                                                    06408\n         ORG   ETAB2+(4*(JRRESNOTFOUNDINDNS-29000))                     06409\n         DC    A(MJRRESNOTFOUNDINDNS)                                   06410\n         ORG                                                            06411\nMJRRESNOTFOUNDINDNS DC C'The specified group or server+group name coul' 06412\n         DC    C'd  not be found within the sysplex domain.'            06413\n         DC    X'00'                                                    06414\n         ORG   ETAB2+(4*(JRGROUPNAMEREQUIRED-29000))                    06415\n         DC    A(MJRGROUPNAMEREQUIRED)                                  06416\n         ORG                                                            06417\nMJRGROUPNAMEREQUIRED DC C'A server name was specified in the sysplexFq' 06418\n         DC    C'DnDatastructure without a group name.'                 06419\n         DC    X'00'                                                    06420\n         ORG   ETAB2+(4*(JRINVALIDBUFTOKN-29000))                       06421\n         DC    A(MJRINVALIDBUFTOKN)                                     06422\n         ORG                                                            06423\nMJRINVALIDBUFTOKN DC C'An incorrect CSM buffer token was provided.'     06424\n         DC    X'00'                                                    06425\n         ORG   ETAB2+(4*(JRMCTTLOPT-29000))                             06426\n         DC    A(MJRMCTTLOPT)                                           06427\n         ORG                                                            06428\nMJRMCTTLOPT DC C'The value specified for multicast time to live isnot ' 06429\n         DC    C'valid.'                                                06430\n         DC    X'00'                                                    06431\n         ORG   ETAB2+(4*(JRMCTTLOPTLERR-29000))                         06432\n         DC    A(MJRMCTTLOPTLERR)                                       06433\n         ORG                                                            06434\nMJRMCTTLOPTLERR DC C'The value specified for option length is not vali' 06435\n         DC    C'd.'                                                    06436\n         DC    X'00'                                                    06437\n         ORG   ETAB2+(4*(JRMCLOOPOPT-29000))                            06438\n         DC    A(MJRMCLOOPOPT)                                          06439\n         ORG                                                            06440\nMJRMCLOOPOPT DC C'The value specified for multicast loopback is not va' 06441\n         DC    C'lid.'                                                  06442\n         DC    X'00'                                                    06443\n         ORG   ETAB2+(4*(JRMCLOOPOPTLERR-29000))                        06444\n         DC    A(MJRMCLOOPOPTLERR)                                      06445\n         ORG                                                            06446\nMJRMCLOOPOPTLERR DC C'The value specified for option length is not val' 06447\n         DC    C'id.'                                                   06448\n         DC    X'00'                                                    06449\n         ORG   ETAB2+(4*(JRMCIFOPT-29000))                              06450\n         DC    A(MJRMCIFOPT)                                            06451\n         ORG                                                            06452\nMJRMCIFOPT DC C'The value specified for multicast interface is not val' 06453\n         DC    C'id.'                                                   06454\n         DC    X'00'                                                    06455\n         ORG   ETAB2+(4*(JRMCIFOPTLERR-29000))                          06456\n         DC    A(MJRMCIFOPTLERR)                                        06457\n         ORG                                                            06458\nMJRMCIFOPTLERR DC C'The value specified for option length is not valid' 06459\n         DC    C'.'                                                     06460\n         DC    X'00'                                                    06461\n         ORG   ETAB2+(4*(JRMCADDMEMOPT-29000))                          06462\n         DC    A(MJRMCADDMEMOPT)                                        06463\n         ORG                                                            06464\nMJRMCADDMEMOPT DC C'The value specified for multicast add membership i' 06465\n         DC    C's not valid.'                                          06466\n         DC    X'00'                                                    06467\n         ORG   ETAB2+(4*(JRMCADDMEMOPTLERR-29000))                      06468\n         DC    A(MJRMCADDMEMOPTLERR)                                    06469\n         ORG                                                            06470\nMJRMCADDMEMOPTLERR DC C'The value specified for option length is not v' 06471\n         DC    C'alid.'                                                 06472\n         DC    X'00'                                                    06473\n         ORG   ETAB2+(4*(JRMCDROPMEMOPT-29000))                         06474\n         DC    A(MJRMCDROPMEMOPT)                                       06475\n         ORG                                                            06476\nMJRMCDROPMEMOPT DC C'The value specified for multicast drop membership' 06477\n         DC    C' is not valid.'                                        06478\n         DC    X'00'                                                    06479\n         ORG   ETAB2+(4*(JRMCDROPMEMOPTLERR-29000))                     06480\n         DC    A(MJRMCDROPMEMOPTLERR)                                   06481\n         ORG                                                            06482\nMJRMCDROPMEMOPTLERR DC C'The value specified for option length is not ' 06483\n         DC    C'valid.'                                                06484\n         DC    X'00'                                                    06485\n         ORG   ETAB2+(4*(JRMCMAXMEM-29000))                             06486\n         DC    A(MJRMCMAXMEM)                                           06487\n         ORG                                                            06488\nMJRMCMAXMEM DC C'The maximum number of groups per socket has been exce' 06489\n         DC    C'eded.'                                                 06490\n         DC    X'00'                                                    06491\n         ORG   ETAB2+(4*(JRIESIZEMISMATCHADD-29000))                    06492\n         DC    A(MJRIESIZEMISMATCHADD)                                  06493\n         ORG                                                            06494\nMJRIESIZEMISMATCHADD DC C'Request area was not large enough on add/rem' 06495\n         DC    C'ove'                                                   06496\n         DC    X'00'                                                    06497\n         ORG   ETAB2+(4*(JRIESIZEMISMATCHGET-29000))                    06498\n         DC    A(MJRIESIZEMISMATCHGET)                                  06499\n         ORG                                                            06500\nMJRIESIZEMISMATCHGET DC C'Request area was not large enough on get'     06501\n         DC    X'00'                                                    06502\n         ORG   ETAB2+(4*(JRIESIZEMISMATCHGETTABLE-29000))               06503\n         DC    A(MJRIESIZEMISMATCHGETTABLE)                             06504\n         ORG                                                            06505\nMJRIESIZEMISMATCHGETTABLE DC C'Request area was not large enough on Ge' 06506\n         DC    C't Table'                                               06507\n         DC    X'00'                                                    06508\n         ORG   ETAB2+(4*(JRIESIZEMISMATCHSETTABLE-29000))               06509\n         DC    A(MJRIESIZEMISMATCHSETTABLE)                             06510\n         ORG                                                            06511\nMJRIESIZEMISMATCHSETTABLE DC C'Request area was not large enough on Se' 06512\n         DC    C't Table'                                               06513\n         DC    X'00'                                                    06514\n         ORG   ETAB2+(4*(JRIEOUTCNTINVALID-29000))                      06515\n         DC    A(MJRIEOUTCNTINVALID)                                    06516\n         ORG                                                            06517\nMJRIEOUTCNTINVALID DC C'cOutCnt is zero or less than the cInCnt'        06518\n         DC    X'00'                                                    06519\n         ORG   ETAB2+(4*(JRIEINCNTINVALID-29000))                       06520\n         DC    A(MJRIEINCNTINVALID)                                     06521\n         ORG                                                            06522\nMJRIEINCNTINVALID DC C'cInCnt is zero'                                  06523\n         DC    X'00'                                                    06524\n         ORG   ETAB2+(4*(JRIEGETTABLEFLAGS-29000))                      06525\n         DC    A(MJRIEGETTABLEFLAGS)                                    06526\n         ORG                                                            06527\nMJRIEGETTABLEFLAGS DC C'Flags set on a GetTable'                        06528\n         DC    X'00'                                                    06529\n         ORG   ETAB2+(4*(JRIEGETFLAGS-29000))                           06530\n         DC    A(MJRIEGETFLAGS)                                         06531\n         ORG                                                            06532\nMJRIEGETFLAGS DC C'Flags set on a Get'                                  06533\n         DC    X'00'                                                    06534\n         ORG   ETAB2+(4*(JRIESETTABLEFLAGS-29000))                      06535\n         DC    A(MJRIESETTABLEFLAGS)                                    06536\n         ORG                                                            06537\nMJRIESETTABLEFLAGS DC C'Flags set on a SetTable'                        06538\n         DC    X'00'                                                    06539\n         ORG   ETAB2+(4*(JRIESETFLAGS-29000))                           06540\n         DC    A(MJRIESETFLAGS)                                         06541\n         ORG                                                            06542\nMJRIESETFLAGS DC C'Flags set on a Set'                                  06543\n         DC    X'00'                                                    06544\n         ORG   ETAB2+(4*(JRIEGETTABLEUNEXPECTED-29000))                 06545\n         DC    A(MJRIEGETTABLEUNEXPECTED)                               06546\n         ORG                                                            06547\nMJRIEGETTABLEUNEXPECTED DC C'Unexpected error on GetTable'              06548\n         DC    X'00'                                                    06549\n         ORG   ETAB2+(4*(JRIEGETUNEXPECTED-29000))                      06550\n         DC    A(MJRIEGETUNEXPECTED)                                    06551\n         ORG                                                            06552\nMJRIEGETUNEXPECTED DC C'Unexpected error on Get'                        06553\n         DC    X'00'                                                    06554\n         ORG   ETAB2+(4*(JRIESETTABLEUNEXPECTED-29000))                 06555\n         DC    A(MJRIESETTABLEUNEXPECTED)                               06556\n         ORG                                                            06557\nMJRIESETTABLEUNEXPECTED DC C'Unexpected error on SetTable'              06558\n         DC    X'00'                                                    06559\n         ORG   ETAB2+(4*(JRIESETUNEXPECTED-29000))                      06560\n         DC    A(MJRIESETUNEXPECTED)                                    06561\n         ORG                                                            06562\nMJRIESETUNEXPECTED DC C'Unexpected error on Set'                        06563\n         DC    X'00'                                                    06564\n         ORG   ETAB2+(4*(JRIERECOVERYERROR-29000))                      06565\n         DC    A(MJRIERECOVERYERROR)                                    06566\n         ORG                                                            06567\nMJRIERECOVERYERROR DC C'Unexpected error on Recovery'                   06568\n         DC    X'00'                                                    06569\n         ORG   ETAB2+(4*(JRIEPROFILEERROR-29000))                       06570\n         DC    A(MJRIEPROFILEERROR)                                     06571\n         ORG                                                            06572\nMJRIEPROFILEERROR DC C'Unexpected error during profile processing'      06573\n         DC    X'00'                                                    06574\n         ORG   ETAB2+(4*(JRIEADDIFCIOCTLTYPE-29000))                    06575\n         DC    A(MJRIEADDIFCIOCTLTYPE)                                  06576\n         ORG                                                            06577\nMJRIEADDIFCIOCTLTYPE DC C'Attempt to add an ifcioctl with ifhtype not ' 06578\n         DC    C'iflifc'                                                06579\n         DC    X'00'                                                    06580\n         ORG   ETAB2+(4*(JRIEUNKNOWNIFCIOCTLTYPE-29000))                06581\n         DC    A(MJRIEUNKNOWNIFCIOCTLTYPE)                              06582\n         ORG                                                            06583\nMJRIEUNKNOWNIFCIOCTLTYPE DC C'Unknown ifcioctl Type attempted'          06584\n         DC    X'00'                                                    06585\n         ORG   ETAB2+(4*(JRTCPTCPIPERROR-29000))                        06586\n         DC    A(MJRTCPTCPIPERROR)                                      06587\n         ORG                                                            06588\nMJRTCPTCPIPERROR DC C'Refer to TSRB return and reason codes'            06589\n         DC    X'00'                                                    06590\n         ORG   ETAB2+(4*(JRTCPINVALIDTCPIPNAME-29000))                  06591\n         DC    A(MJRTCPINVALIDTCPIPNAME)                                06592\n         ORG                                                            06593\nMJRTCPINVALIDTCPIPNAME DC C'Invalid Tsrb_Tcpip_Name'                    06594\n         DC    X'00'                                                    06595\n         ORG   ETAB2+(4*(JRTCPINVALIDREQUESTCODE-29000))                06596\n         DC    A(MJRTCPINVALIDREQUESTCODE)                              06597\n         ORG                                                            06598\nMJRTCPINVALIDREQUESTCODE DC C'Invalid Tsrb_Request_Code'                06599\n         DC    X'00'                                                    06600\n         ORG   ETAB2+(4*(JRTCPNOTINSTALLEDORUP-29000))                  06601\n         DC    A(MJRTCPNOTINSTALLEDORUP)                                06602\n         ORG                                                            06603\nMJRTCPNOTINSTALLEDORUP DC C'TCPIP not installed or active'              06604\n         DC    X'00'                                                    06605\n         ORG   ETAB2+(4*(JRTCPINVDELETE-29000))                         06606\n         DC    A(MJRTCPINVDELETE)                                       06607\n         ORG                                                            06608\nMJRTCPINVDELETE DC C'The delete requestor did not create the connectio' 06609\n         DC    C'n'                                                     06610\n         DC    X'00'                                                    06611\n         ORG   ETAB2+(4*(JRTCPINVUSERDATA-29000))                       06612\n         DC    A(MJRTCPINVUSERDATA)                                     06613\n         ORG                                                            06614\nMJRTCPINVUSERDATA DC C'Request contained invalid user data'             06615\n         DC    X'00'                                                    06616\n         ORG   ETAB2+(4*(JRSKCIBINVALIDMESSAGE-29000))                  06617\n         DC    A(MJRSKCIBINVALIDMESSAGE)                                06618\n         ORG                                                            06619\nMJRSKCIBINVALIDMESSAGE DC C'Invalid IOCTL message type'                 06620\n         DC    X'00'                                                    06621\n         ORG   ETAB2+(4*(JRSKCIBALREADYSLEEPING1-29000))                06622\n         DC    A(MJRSKCIBALREADYSLEEPING1)                              06623\n         ORG                                                            06624\nMJRSKCIBALREADYSLEEPING1 DC C'Recursive context sleep'                  06625\n         DC    X'00'                                                    06626\n         ORG   ETAB2+(4*(JRSKDKINOTREADQUEUE-29000))                    06627\n         DC    A(MJRSKDKINOTREADQUEUE)                                  06628\n         ORG                                                            06629\nMJRSKDKINOTREADQUEUE DC C'Invalid queue for find open/close'            06630\n         DC    X'00'                                                    06631\n         ORG   ETAB2+(4*(JRSKDKINOTWRITEQUEUE-29000))                   06632\n         DC    A(MJRSKDKINOTWRITEQUEUE)                                 06633\n         ORG                                                            06634\nMJRSKDKINOTWRITEQUEUE DC C'Invalid queue for find poll/iocport'         06635\n         DC    X'00'                                                    06636\n         ORG   ETAB2+(4*(JRSKDKIBADFINDTYPE-29000))                     06637\n         DC    A(MJRSKDKIBADFINDTYPE)                                   06638\n         ORG                                                            06639\nMJRSKDKIBADFINDTYPE DC C'Invalid type for find'                         06640\n         DC    X'00'                                                    06641\n         ORG   ETAB2+(4*(JRSKDKINOTFOUND-29000))                        06642\n         DC    A(MJRSKDKINOTFOUND)                                      06643\n         ORG                                                            06644\nMJRSKDKINOTFOUND DC C'No such device/module for find'                   06645\n         DC    X'00'                                                    06646\n         ORG   ETAB2+(4*(JRSKDKIBADQGETTYPE-29000))                     06647\n         DC    A(MJRSKDKIBADQGETTYPE)                                   06648\n         ORG                                                            06649\nMJRSKDKIBADQGETTYPE DC C'Invalid type for queue get info'               06650\n         DC    X'00'                                                    06651\n         ORG   ETAB2+(4*(JRSKDKIBADQSETTYPE-29000))                     06652\n         DC    A(MJRSKDKIBADQSETTYPE)                                   06653\n         ORG                                                            06654\nMJRSKDKIBADQSETTYPE DC C'Invalid type for queue set info'               06655\n         DC    X'00'                                                    06656\n         ORG   ETAB2+(4*(JRSKHEDBADOPEN-29000))                         06657\n         DC    A(MJRSKHEDBADOPEN)                                       06658\n         ORG                                                            06659\nMJRSKHEDBADOPEN DC C'Open of stream head driver not allowed'            06660\n         DC    X'00'                                                    06661\n         ORG   ETAB2+(4*(JRSKMNTBADMESSAGE-29000))                      06662\n         DC    A(MJRSKMNTBADMESSAGE)                                    06663\n         ORG                                                            06664\nMJRSKMNTBADMESSAGE DC C'Invalid message type'                           06665\n         DC    X'00'                                                    06666\n         ORG   ETAB2+(4*(JRSKMNTSNOOPERALREADYACTIVE-29000))            06667\n         DC    A(MJRSKMNTSNOOPERALREADYACTIVE)                          06668\n         ORG                                                            06669\nMJRSKMNTSNOOPERALREADYACTIVE DC C'Snooper module previously pushed'     06670\n         DC    X'00'                                                    06671\n         ORG   ETAB2+(4*(JRSKMNTSNOOPERNOTACTIVE-29000))                06672\n         DC    A(MJRSKMNTSNOOPERNOTACTIVE)                              06673\n         ORG                                                            06674\nMJRSKMNTSNOOPERNOTACTIVE DC C'Snooper module not previously pushed'     06675\n         DC    X'00'                                                    06676\n         ORG   ETAB2+(4*(JRSKSTOBADINDEX-29000))                        06677\n         DC    A(MJRSKSTOBADINDEX)                                      06678\n         ORG                                                            06679\nMJRSKSTOBADINDEX DC C'Invalid starting index for STREAMOP'              06680\n         DC    X'00'                                                    06681\n         ORG   ETAB2+(4*(JRSKSTOBADSTREAM-29000))                       06682\n         DC    A(MJRSKSTOBADSTREAM)                                     06683\n         ORG                                                            06684\nMJRSKSTOBADSTREAM DC C'Invalid stream address for STREAMOP'             06685\n         DC    X'00'                                                    06686\n         ORG   ETAB2+(4*(JRSKSTOBADMESSAGETYPE-29000))                  06687\n         DC    A(MJRSKSTOBADMESSAGETYPE)                                06688\n         ORG                                                            06689\nMJRSKSTOBADMESSAGETYPE DC C'Invalid message type for read'              06690\n         DC    X'00'                                                    06691\n         ORG   ETAB2+(4*(JRSKSTONOEMPTYMESSAGES-29000))                 06692\n         DC    A(MJRSKSTONOEMPTYMESSAGES)                               06693\n         ORG                                                            06694\nMJRSKSTONOEMPTYMESSAGES DC C'Zero message length invalid for write'     06695\n         DC    X'00'                                                    06696\n         ORG   ETAB2+(4*(JRSKSTOMESSAGETOOSHORT-29000))                 06697\n         DC    A(MJRSKSTOMESSAGETOOSHORT)                               06698\n         ORG                                                            06699\nMJRSKSTOMESSAGETOOSHORT DC C'Message length too short for write'        06700\n         DC    X'00'                                                    06701\n         ORG   ETAB2+(4*(JRSKSTONOCONTROLPART1-29000))                  06702\n         DC    A(MJRSKSTONOCONTROLPART1)                                06703\n         ORG                                                            06704\nMJRSKSTONOCONTROLPART1 DC C'No control part for putpmsg'                06705\n         DC    X'00'                                                    06706\n         ORG   ETAB2+(4*(JRSKSTOBADMESSAGELENGTH1-29000))               06707\n         DC    A(MJRSKSTOBADMESSAGELENGTH1)                             06708\n         ORG                                                            06709\nMJRSKSTOBADMESSAGELENGTH1 DC C'Invalid message length for putpmsg'      06710\n         DC    X'00'                                                    06711\n         ORG   ETAB2+(4*(JRSKSTOBADMESSAGELENGTH2-29000))               06712\n         DC    A(MJRSKSTOBADMESSAGELENGTH2)                             06713\n         ORG                                                            06714\nMJRSKSTOBADMESSAGELENGTH2 DC C'Invalid message length for lputpmsg'     06715\n         DC    X'00'                                                    06716\n         ORG   ETAB2+(4*(JRSKSTOBADCONTROLINFORMATION-29000))           06717\n         DC    A(MJRSKSTOBADCONTROLINFORMATION)                         06718\n         ORG                                                            06719\nMJRSKSTOBADCONTROLINFORMATION DC C'Invalid control information for fdi' 06720\n         DC    C'nsert'                                                 06721\n         DC    X'00'                                                    06722\n         ORG   ETAB2+(4*(JRSKSTONOMESSAGES-29000))                      06723\n         DC    A(MJRSKSTONOMESSAGES)                                    06724\n         ORG                                                            06725\nMJRSKSTONOMESSAGES DC C'No queued messages for getband'                 06726\n         DC    X'00'                                                    06727\n         ORG   ETAB2+(4*(JRSKSTORESOURCESHORTAGE2-29000))               06728\n         DC    A(MJRSKSTORESOURCESHORTAGE2)                             06729\n         ORG                                                            06730\nMJRSKSTORESOURCESHORTAGE2 DC C'Unable to get triple for M_READ message' 06731\n         DC    X'00'                                                    06732\n         ORG   ETAB2+(4*(JRSKSTORESOURCESHORTAGE3-29000))               06733\n         DC    A(MJRSKSTORESOURCESHORTAGE3)                             06734\n         ORG                                                            06735\nMJRSKSTORESOURCESHORTAGE3 DC C'Unable to get triple for M_IOCTL messag' 06736\n         DC    C'e'                                                     06737\n         DC    X'00'                                                    06738\n         ORG   ETAB2+(4*(JRSKVRBBADOPTION1-29000))                      06739\n         DC    A(MJRSKVRBBADOPTION1)                                    06740\n         ORG                                                            06741\nMJRSKVRBBADOPTION1 DC C'Invalid option for open'                        06742\n         DC    X'00'                                                    06743\n         ORG   ETAB2+(4*(JRSKVRBNOTUP-29000))                           06744\n         DC    A(MJRSKVRBNOTUP)                                         06745\n         ORG                                                            06746\nMJRSKVRBNOTUP DC C'System not initialized'                              06747\n         DC    X'00'                                                    06748\n         ORG   ETAB2+(4*(JRSKVRBBADNAME-29000))                         06749\n         DC    A(MJRSKVRBBADNAME)                                       06750\n         ORG                                                            06751\nMJRSKVRBBADNAME DC C'Invalid name for push'                             06752\n         DC    X'00'                                                    06753\n         ORG   ETAB2+(4*(JRSKVRBNORESOURCES1-29000))                    06754\n         DC    A(MJRSKVRBNORESOURCES1)                                  06755\n         ORG                                                            06756\nMJRSKVRBNORESOURCES1 DC C'Unable to allocate queues for push'           06757\n         DC    X'00'                                                    06758\n         ORG   ETAB2+(4*(JRSKVRBNOTHINGPUSHED1-29000))                  06759\n         DC    A(MJRSKVRBNOTHINGPUSHED1)                                06760\n         ORG                                                            06761\nMJRSKVRBNOTHINGPUSHED1 DC C'No pushed module exists for pop'            06762\n         DC    X'00'                                                    06763\n         ORG   ETAB2+(4*(JRSKVRBNOTMULTIPLEXED-29000))                  06764\n         DC    A(MJRSKVRBNOTMULTIPLEXED)                                06765\n         ORG                                                            06766\nMJRSKVRBNOTMULTIPLEXED DC C'Driver not multiplexed for link'            06767\n         DC    X'00'                                                    06768\n         ORG   ETAB2+(4*(JRSKVRBNOTLINKED-29000))                       06769\n         DC    A(MJRSKVRBNOTLINKED)                                     06770\n         ORG                                                            06771\nMJRSKVRBNOTLINKED DC C'No linked driver/module for unlink'              06772\n         DC    X'00'                                                    06773\n         ORG   ETAB2+(4*(JRSKVRBBADTYPE-29000))                         06774\n         DC    A(MJRSKVRBBADTYPE)                                       06775\n         ORG                                                            06776\nMJRSKVRBBADTYPE DC C'Invalid type for flush'                            06777\n         DC    X'00'                                                    06778\n         ORG   ETAB2+(4*(JRSKVRBNORESOURCES2-29000))                    06779\n         DC    A(MJRSKVRBNORESOURCES2)                                  06780\n         ORG                                                            06781\nMJRSKVRBNORESOURCES2 DC C'Unable to get triple for M_FLUSH message'     06782\n         DC    X'00'                                                    06783\n         ORG   ETAB2+(4*(JRSKVRBBADMASK-29000))                         06784\n         DC    A(MJRSKVRBBADMASK)                                       06785\n         ORG                                                            06786\nMJRSKVRBBADMASK DC C'Invalid signal mask for setsig'                    06787\n         DC    X'00'                                                    06788\n         ORG   ETAB2+(4*(JRSKVRBBADACTION-29000))                       06789\n         DC    A(MJRSKVRBBADACTION)                                     06790\n         ORG                                                            06791\nMJRSKVRBBADACTION DC C'Invalid action for setsig'                       06792\n         DC    X'00'                                                    06793\n         ORG   ETAB2+(4*(JRSKVRBBADID-29000))                           06794\n         DC    A(MJRSKVRBBADID)                                         06795\n         ORG                                                            06796\nMJRSKVRBBADID DC C'Invalid identifier for spgrp'                        06797\n         DC    X'00'                                                    06798\n         ORG   ETAB2+(4*(JRSKVRBBADFLAG-29000))                         06799\n         DC    A(MJRSKVRBBADFLAG)                                       06800\n         ORG                                                            06801\nMJRSKVRBBADFLAG DC C'Invalid flag for spgrp'                            06802\n         DC    X'00'                                                    06803\n         ORG   ETAB2+(4*(JRSKVRBNOERRNO-29000))                         06804\n         DC    A(MJRSKVRBNOERRNO)                                       06805\n         ORG                                                            06806\nMJRSKVRBNOERRNO DC C'No error number for spgrp'                         06807\n         DC    X'00'                                                    06808\n         ORG   ETAB2+(4*(JRSKVRBBADOPTION2-29000))                      06809\n         DC    A(MJRSKVRBBADOPTION2)                                    06810\n         ORG                                                            06811\nMJRSKVRBBADOPTION2 DC C'Invalid behavior option for srdopt'             06812\n         DC    X'00'                                                    06813\n         ORG   ETAB2+(4*(JRSKVRBBADOPTION3-29000))                      06814\n         DC    A(MJRSKVRBBADOPTION3)                                    06815\n         ORG                                                            06816\nMJRSKVRBBADOPTION3 DC C'Invalid message option for srdopt'              06817\n         DC    X'00'                                                    06818\n         ORG   ETAB2+(4*(JRSKVRBBADOPTION4-29000))                      06819\n         DC    A(MJRSKVRBBADOPTION4)                                    06820\n         ORG                                                            06821\nMJRSKVRBBADOPTION4 DC C'Invalid length option for swropt'               06822\n         DC    X'00'                                                    06823\n         ORG   ETAB2+(4*(JRSKVRBBADCLASS1-29000))                       06824\n         DC    A(MJRSKVRBBADCLASS1)                                     06825\n         ORG                                                            06826\nMJRSKVRBBADCLASS1 DC C'Invalid IOCTL class for str'                     06827\n         DC    X'00'                                                    06828\n         ORG   ETAB2+(4*(JRSKVRBBADCLASS2-29000))                       06829\n         DC    A(MJRSKVRBBADCLASS2)                                     06830\n         ORG                                                            06831\nMJRSKVRBBADCLASS2 DC C'Invalid IOCTL class for transprnt'               06832\n         DC    X'00'                                                    06833\n         ORG   ETAB2+(4*(JRSKVRBNORESOURCES3-29000))                    06834\n         DC    A(MJRSKVRBNORESOURCES3)                                  06835\n         ORG                                                            06836\nMJRSKVRBNORESOURCES3 DC C'Unable to get triple for M_IOCTL message'     06837\n         DC    X'00'                                                    06838\n         ORG   ETAB2+(4*(JRSKVRBNOTHINGPUSHED2-29000))                  06839\n         DC    A(MJRSKVRBNOTHINGPUSHED2)                                06840\n         ORG                                                            06841\nMJRSKVRBNOTHINGPUSHED2 DC C'No module pushed for look'                  06842\n         DC    X'00'                                                    06843\n         ORG   ETAB2+(4*(JRSKASMBADTYPE-29000))                         06844\n         DC    A(MJRSKASMBADTYPE)                                       06845\n         ORG                                                            06846\nMJRSKASMBADTYPE DC C'Invalid type for ?SKASM(*RANGE)'                   06847\n         DC    X'00'                                                    06848\n         ORG   ETAB2+(4*(JRSKSACNOSTREAM-29000))                        06849\n         DC    A(MJRSKSACNOSTREAM)                                      06850\n         ORG                                                            06851\nMJRSKSACNOSTREAM DC C'Invalid stream @ for ?SKSAC(*ACCESS)'             06852\n         DC    X'00'                                                    06853\n         ORG   ETAB2+(4*(JRSKSACLINKEDSTREAM-29000))                    06854\n         DC    A(MJRSKSACLINKEDSTREAM)                                  06855\n         ORG                                                            06856\nMJRSKSACLINKEDSTREAM DC C'Invalid stream for ?SKSAC(*ACCESS)'           06857\n         DC    X'00'                                                    06858\n         ORG   ETAB2+(4*(JRMULTIPLEREAD-29000))                         06859\n         DC    A(MJRMULTIPLEREAD)                                       06860\n         ORG                                                            06861\nMJRMULTIPLEREAD DC C'A request to receive data is already outstanding.' 06862\n         DC    C')'                                                     06863\n         DC    X'00'                                                    06864\n         ORG   ETAB2+(4*(JRDEVICEMPCHLCSINVALID-29000))                 06865\n         DC    A(MJRDEVICEMPCHLCSINVALID)                               06866\n         ORG                                                            06867\nMJRDEVICEMPCHLCSINVALID DC C'A MPC HPDT/LCS link was defined for an in' 06868\n         DC    C'correct device type.'                                  06869\n         DC    X'00'                                                    06870\n         ORG   ETAB2+(4*(JRCMCONFIGURED-29000))                         06871\n         DC    A(MJRCMCONFIGURED)                                       06872\n         ORG                                                            06873\nMJRCMCONFIGURED DC C'Cache Manager has been configured for this server' 06874\n         DC    C' socket.'                                              06875\n         DC    X'00'                                                    06876\n         ORG   ETAB2+(4*(JRCMNOLOG-29000))                              06877\n         DC    A(MJRCMNOLOG)                                            06878\n         ORG                                                            06879\nMJRCMNOLOG DC C'Cache Manager Configuration parameter does not include' 06880\n         DC    C' the size of the log file.'                            06881\n         DC    X'00'                                                    06882\n         ORG   ETAB2+(4*(JRCMNOCACHE-29000))                            06883\n         DC    A(MJRCMNOCACHE)                                          06884\n         ORG                                                            06885\nMJRCMNOCACHE DC C'Cache Manager Configuration parameter does not inclu' 06886\n         DC    C'de the size of the cache file.'                        06887\n         DC    X'00'                                                    06888\n         ORG   ETAB2+(4*(JRCMSERVERNOTFOUND-29000))                     06889\n         DC    A(MJRCMSERVERNOTFOUND)                                   06890\n         ORG                                                            06891\nMJRCMSERVERNOTFOUND DC C'Cache Manager has not been configured for thi' 06892\n         DC    C's server socket.'                                      06893\n         DC    X'00'                                                    06894\n         ORG   ETAB2+(4*(JRCMCANTLOAD-29000))                           06895\n         DC    A(MJRCMCANTLOAD)                                         06896\n         ORG                                                            06897\nMJRCMCANTLOAD DC C'Invalid Dynamic Exit load module name specified in ' 06898\n         DC    C'the Config IOCTL parameters.'                          06899\n         DC    X'00'                                                    06900\n         ORG   ETAB2+(4*(JRCMNOSTORAGE-29000))                          06901\n         DC    A(MJRCMNOSTORAGE)                                        06902\n         ORG                                                            06903\nMJRCMNOSTORAGE DC C'Cache Manager encountered storage shortage.'        06904\n         DC    X'00'                                                    06905\n         ORG   ETAB2+(4*(JRCMNOCSM-29000))                              06906\n         DC    A(MJRCMNOCSM)                                            06907\n         ORG                                                            06908\nMJRCMNOCSM DC C'Cache Manager encountered a CSM storage shortage.'      06909\n         DC    X'00'                                                    06910\n         ORG   ETAB2+(4*(JRCMNOTCONFIGURED-29000))                      06911\n         DC    A(MJRCMNOTCONFIGURED)                                    06912\n         ORG                                                            06913\nMJRCMNOTCONFIGURED DC C'Cache Manager has not been configured for this' 06914\n         DC    C' server socket.'                                       06915\n         DC    X'00'                                                    06916\n         ORG   ETAB2+(4*(JRNOTCMAUTHORIZED-29000))                      06917\n         DC    A(MJRNOTCMAUTHORIZED)                                    06918\n         ORG                                                            06919\nMJRNOTCMAUTHORIZED DC C'User is not allowed to use Cache Manager funct' 06920\n         DC    C'ion.'                                                  06921\n         DC    X'00'                                                    06922\n         ORG   ETAB2+(4*(JRCMPARMNOTVALID-29000))                       06923\n         DC    A(MJRCMPARMNOTVALID)                                     06924\n         ORG                                                            06925\nMJRCMPARMNOTVALID DC C'Invalid parameters used in Cache Manager IOCTL ' 06926\n         DC    C'call.'                                                 06927\n         DC    X'00'                                                    06928\n         ORG   ETAB2+(4*(JRCMLOADMODBAD-29000))                         06929\n         DC    A(MJRCMLOADMODBAD)                                       06930\n         ORG                                                            06931\nMJRCMLOADMODBAD DC C'Invalid Dynamic Exit load module name specified i' 06932\n         DC    C'n the Config IOCTL parameters.'                        06933\n         DC    X'00'                                                    06934\n         ORG   ETAB2+(4*(JRUWCONOTFOUND-29000))                         06935\n         DC    A(MJRUWCONOTFOUND)                                       06936\n         ORG                                                            06937\nMJRUWCONOTFOUND DC C'Cache Manager has not been configured for this se' 06938\n         DC    C'rver socket.'                                          06939\n         DC    X'00'                                                    06940\n         ORG   ETAB2+(4*(JRUWCOSTORAGEFAILED-29000))                    06941\n         DC    A(MJRUWCOSTORAGEFAILED)                                  06942\n         ORG                                                            06943\nMJRUWCOSTORAGEFAILED DC C'Cache Manager encountered storage shortage.'  06944\n         DC    X'00'                                                    06945\n         ORG   ETAB2+(4*(JRUWCTSTORAGEFAILED-29000))                    06946\n         DC    A(MJRUWCTSTORAGEFAILED)                                  06947\n         ORG                                                            06948\nMJRUWCTSTORAGEFAILED DC C'Cache Manager encountered storage shortage.'  06949\n         DC    X'00'                                                    06950\n         ORG   ETAB2+(4*(JRUWHTSTORAGEFAILED-29000))                    06951\n         DC    A(MJRUWHTSTORAGEFAILED)                                  06952\n         ORG                                                            06953\nMJRUWHTSTORAGEFAILED DC C'Cache Manager encountered storage shortage.'  06954\n         DC    X'00'                                                    06955\n         ORG   ETAB2+(4*(JRUWCTFULL-29000))                             06956\n         DC    A(MJRUWCTFULL)                                           06957\n         ORG                                                            06958\nMJRUWCTFULL DC C'Cache Manager table has been filled.'                  06959\n         DC    X'00'                                                    06960\n         ORG   ETAB2+(4*(JRCMNOOBJECTS-29000))                          06961\n         DC    A(MJRCMNOOBJECTS)                                        06962\n         ORG                                                            06963\nMJRCMNOOBJECTS DC C'Maximum number of objects has been reached.'        06964\n         DC    X'00'                                                    06965\n         ORG   ETAB2+(4*(JRCMDISABLE-29000))                            06966\n         DC    A(MJRCMDISABLE)                                          06967\n         ORG                                                            06968\nMJRCMDISABLE DC C'Cache Manager is not allowed for this TCP/IP stack'   06969\n         DC    X'00'                                                    06970\n         ORG   ETAB2+(4*(JRCMLSOCKBADSTATE-29000))                      06971\n         DC    A(MJRCMLSOCKBADSTATE)                                    06972\n         ORG                                                            06973\nMJRCMLSOCKBADSTATE DC C'Cache Manager Server is not in the LISTEN stat' 06974\n         DC    C'e'                                                     06975\n         DC    X'00'                                                    06976\n         ORG   ETAB2+(4*(JRCMDESTROYFAILURE-29000))                     06977\n         DC    A(MJRCMDESTROYFAILURE)                                   06978\n         ORG                                                            06979\nMJRCMDESTROYFAILURE DC C'Cache Manager Storage cannot be removed'       06980\n         DC    X'00'                                                    06981\n         ORG   ETAB2+(4*(JRCMBADCONFIGDATA-29000))                      06982\n         DC    A(MJRCMBADCONFIGDATA)                                    06983\n         ORG                                                            06984\nMJRCMBADCONFIGDATA DC C'Cache Manager cannot call the DGW exits'        06985\n         DC    X'00'                                                    06986\n         ORG   ETAB2+(4*(JRCMCACHEOBJLIMIT-29000))                      06987\n         DC    A(MJRCMCACHEOBJLIMIT)                                    06988\n         ORG                                                            06989\nMJRCMCACHEOBJLIMIT DC C'Cache Manager maximum number of objects has be' 06990\n         DC    C'en reached.'                                           06991\n         DC    X'00'                                                    06992\n         ORG   ETAB2+(4*(JRCMCACHESPACELIMIT-29000))                    06993\n         DC    A(MJRCMCACHESPACELIMIT)                                  06994\n         ORG                                                            06995\nMJRCMCACHESPACELIMIT DC C'Cache Manager Buffer is filled.'              06996\n         DC    X'00'                                                    06997\n         ORG   ETAB2+(4*(JRCMCACHEOBJNOTFOUND-29000))                   06998\n         DC    A(MJRCMCACHEOBJNOTFOUND)                                 06999\n         ORG                                                            07000\nMJRCMCACHEOBJNOTFOUND DC C'Cache Manager Object is not found'           07001\n         DC    X'00'                                                    07002\n         ORG   ETAB2+(4*(JRDYNADDCXFAILURE-29000))                      07003\n         DC    A(MJRDYNADDCXFAILURE)                                    07004\n         ORG                                                            07005\nMJRDYNADDCXFAILURE DC C'Cannot add new connection to Dynnamic exits'    07006\n         DC    X'00'                                                    07007\n         ORG   ETAB2+(4*(JRDYNDELCXFAILURE-29000))                      07008\n         DC    A(MJRDYNDELCXFAILURE)                                    07009\n         ORG                                                            07010\nMJRDYNDELCXFAILURE DC C'Cannot delete a connection from Dynnamic exits' 07011\n         DC    X'00'                                                    07012\n         ORG   ETAB2+(4*(JRDYNTIMERFAILURE-29000))                      07013\n         DC    A(MJRDYNTIMERFAILURE)                                    07014\n         ORG                                                            07015\nMJRDYNTIMERFAILURE DC C'Cannot start the timer from Dynnamic exits'     07016\n         DC    X'00'                                                    07017\n         ORG   ETAB2+(4*(JRDYNRECOVERYFAILURE-29000))                   07018\n         DC    A(MJRDYNRECOVERYFAILURE)                                 07019\n         ORG                                                            07020\nMJRDYNRECOVERYFAILURE DC C'Cannot start the recovery from Dynnamic exi' 07021\n         DC    C'ts'                                                    07022\n         DC    X'00'                                                    07023\n         ORG   ETAB2+(4*(JRCMIOVPNOTVALID-29000))                       07024\n         DC    A(MJRCMIOVPNOTVALID)                                     07025\n         ORG                                                            07026\nMJRCMIOVPNOTVALID DC C'Invalid IOV buffer passed in the load request'   07027\n         DC    X'00'                                                    07028\n         ORG   ETAB2+(4*(JRCMLOGFULL-29000))                            07029\n         DC    A(MJRCMLOGFULL)                                          07030\n         ORG                                                            07031\nMJRCMLOGFULL DC C'LogBuffer is Full'                                    07032\n         DC    X'00'                                                    07033\n         ORG   ETAB2+(4*(JRCMSGDATAINVALID-29000))                      07034\n         DC    A(MJRCMSGDATAINVALID)                                    07035\n         ORG                                                            07036\nMJRCMSGDATAINVALID DC C'cmsghdr data has an incorrect value'            07037\n         DC    X'00'                                                    07038\n         ORG   ETAB2+(4*(JRDVIPAALREADYACTIVE-29000))                   07039\n         DC    A(MJRDVIPAALREADYACTIVE)                                 07040\n         ORG                                                            07041\nMJRDVIPAALREADYACTIVE DC C'The Dynamic VIPA activated via IOCTL was al' 07042\n         DC    C'ready active.'                                         07043\n         DC    X'00'                                                    07044\n         ORG   ETAB2+(4*(JRDVIPANOTINVIPARANGE-29000))                  07045\n         DC    A(MJRDVIPANOTINVIPARANGE)                                07046\n         ORG                                                            07047\nMJRDVIPANOTINVIPARANGE DC C'The Dynamic VIPA was not in any defined VI' 07048\n         DC    C'PARange.'                                              07049\n         DC    X'00'                                                    07050\n         ORG   ETAB2+(4*(JRDVIPACONFLICTDVIPA-29000))                   07051\n         DC    A(MJRDVIPACONFLICTDVIPA)                                 07052\n         ORG                                                            07053\nMJRDVIPACONFLICTDVIPA DC C'The Dynamic VIPA selected is already define' 07054\n         DC    C'd via VIPADEFine or VIPABackup.'                       07055\n         DC    X'00'                                                    07056\n         ORG   ETAB2+(4*(JRDVIPACONFLICTIPADDR-29000))                  07057\n         DC    A(MJRDVIPACONFLICTIPADDR)                                07058\n         ORG                                                            07059\nMJRDVIPACONFLICTIPADDR DC C'The Dynamic VIPA selected is already activ' 07060\n         DC    C'e as a standard IP address.'                           07061\n         DC    X'00'                                                    07062\n         ORG   ETAB2+(4*(JRTOOMANYDVIPAS-29000))                        07063\n         DC    A(MJRTOOMANYDVIPAS)                                      07064\n         ORG                                                            07065\nMJRTOOMANYDVIPAS DC C'The maximum allowed number of DVIPAs is already ' 07066\n         DC    C'defined.'                                              07067\n         DC    X'00'                                                    07068\n         ORG   ETAB2+(4*(JRDVIPANOTDEFINED-29000))                      07069\n         DC    A(MJRDVIPANOTDEFINED)                                    07070\n         ORG                                                            07071\nMJRDVIPANOTDEFINED DC C'The Dynamic VIPA selected for deletion was not' 07072\n         DC    C' defined here.'                                        07073\n         DC    X'00'                                                    07074\n         ORG   ETAB2+(4*(JRNODUAVAILABLE-29000))                        07075\n         DC    A(MJRNODUAVAILABLE)                                      07076\n         ORG                                                            07077\nMJRNODUAVAILABLE DC C'TCP/IP cannot create a dispatchable unit to proc' 07078\n         DC    C'ess the request.  Either TCP/IP is not active or ther' 07079\n         DC    C'e is insufficient common storage available.'           07080\n         DC    X'00'                                                    07081\n         ORG   ETAB2+(4*(JRPORTUNAVAILABLE-29000))                      07082\n         DC    A(MJRPORTUNAVAILABLE)                                    07083\n         ORG                                                            07084\nMJRPORTUNAVAILABLE DC C'The requested port is marked reserved and is n' 07085\n         DC    C'ot available to any application.'                      07086\n         DC    X'00'                                                    07087\n         ORG   ETAB2+(4*(JRAFOPNOTSUPPORTED-29000))                     07088\n         DC    A(MJRAFOPNOTSUPPORTED)                                   07089\n         ORG                                                            07090\nMJRAFOPNOTSUPPORTED DC C'The operation is not supported for a socket i' 07091\n         DC    C'n this address family.'                                07092\n         DC    X'00'                                                    07093\n         ORG   ETAB2+(4*(JRCANNOTMAPSOCKADDR-29000))                    07094\n         DC    A(MJRCANNOTMAPSOCKADDR)                                  07095\n         ORG                                                            07096\nMJRCANNOTMAPSOCKADDR DC C'The socket address provided by the applicati' 07097\n         DC    C'on on this call cannot be mapped to an IPv4 socket ad' 07098\n         DC    C'dress.'                                                07099\n         DC    X'00'                                                    07100\n         ORG   ETAB2+(4*(JRNETACCESSDENIED-29000))                      07101\n         DC    A(MJRNETACCESSDENIED)                                    07102\n         ORG                                                            07103\nMJRNETACCESSDENIED DC C'The user is not permitted to communicate with ' 07104\n         DC    C'the specified network.'                                07105\n         DC    X'00'                                                    07106\n         ORG   ETAB2+(4*(JRNOTAUTHSTACK-29000))                         07107\n         DC    A(MJRNOTAUTHSTACK)                                       07108\n         ORG                                                            07109\nMJRNOTAUTHSTACK DC C'Userid is not authorized to access the TCP/IP Sta' 07110\n         DC    C'ck'                                                    07111\n         DC    X'00'                                                    07112\n         ORG   ETAB2+(4*(JRNOTAUTHPORT-29000))                          07113\n         DC    A(MJRNOTAUTHPORT)                                        07114\n         ORG                                                            07115\nMJRNOTAUTHPORT DC C'Userid is not authorized to access the reserved  T' 07116\n         DC    C'CP/IP Port'                                            07117\n         DC    X'00'                                                    07118\n         ORG   ETAB2+(4*(JRFRCARESET-29000))                            07119\n         DC    A(MJRFRCARESET)                                          07120\n         ORG                                                            07121\nMJRFRCARESET DC C'FRCA connection timer expired. Connection is being d' 07122\n         DC    C'ropped.'                                               07123\n         DC    X'00'                                                    07124\n         AIF   ('&SYSTEM_ID'(1,4) NE 'z/OS').NOTZOS4                    07125\n         ORG   ETAB2+(4*(JRNOCSASTORAGE-29000))                         07126\n         DC    A(MJRNOCSASTORAGE)                                       07127\n         ORG                                                            07128\nMJRNOCSASTORAGE DC C'TCP/IP cannot process the request because there i' 07129\n         DC    C's insufficient common storage available'               07130\n         DC    X'00'                                                    07131\n         ORG   ETAB2+(4*(JRZEROPORTDVIPA-29000))                        07132\n         DC    A(MJRZEROPORTDVIPA)                                      07133\n         ORG                                                            07134\nMJRZEROPORTDVIPA DC C'No Distributed VIPA/port match was found.'        07135\n         DC    X'00'                                                    07136\n         ORG   ETAB2+(4*(JRRACFBLANKEXISTS-29000))                      07137\n         DC    A(MJRRACFBLANKEXISTS)                                    07138\n         ORG                                                            07139\nMJRRACFBLANKEXISTS DC C'Blanks exist in the entity buffer passed on a ' 07140\n         DC    C'RACROUTE call.'                                        07141\n         DC    X'00'                                                    07142\n.NOTZOS4 ANOP                                                           07143\n         EJECT                                                          07144\nWORKAREA DSECT                                                          07145\n         DS    26F                                                      07146\nWORKLEN  EQU   *-WORKAREA                                               07147\n         SPACE                                                          07148\nPARMS    DSECT                                                          07149\nPERRNO   DS    A        THE ERRNO TO UNRAVEL                            07150\nPLEN     DS    A        POINTS TO AN INT TO RECIEVE THE LENGTH          07151\nPMSG     DS    A        POINTS TO AN POINTER TO RECIEVE THE MSG ADDR    07152\n         SPACE                                                          07153\n         SYMBAR MODE=DEC                                                07154\n         BPXYERNO                                                       07155\n         CONTROL DSECT=NO                                               07156\n         END                                                            07157\n*          DATA SET FG50129101 AT LEVEL 018 AS OF 10/09/03\nSTRERR   TITLE 'OMVS_STRERR'                                            00001\n         PRINT OFF                                                      00002\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00006\n*********************************************************************** 00020\n*                                                                     * 00020\n* SEGMENT NAME:                                                       * 00020\n*                                                                     * 00020\n*    STRERR -- OMVS_STRERR                                            * 00020\n*                                                                     * 00021\n*       THIS MODULE RETURNS THE ERROR MESSSAGE CORRESPONDING TO A     * 00021\n*       PASSED ERRNO UNDER OPEN MVS.                                  * 00021\n*                                                                     * 00039\n* INPUTS (*TO FUNCTIONS):                                             * 00039\n*                                                                     * 00024\n*    ERRNO -- FULLWORD INT (*1,3)                                     * 00024\n*       THIS IS THE ADDRESS OF A FULLWORD CONTAINING  THE ERRNO TO BE * 00025\n*       INTERPRETED.                                                  * 00025\n*                                                                     * 00038\n* FUNCTIONS:                                                          * 00038\n*                                                                     * 00038\n*    1. LOAD THE PARM LIST INTO REGISTERS                             * 00038\n*                                                                     * 00043\n*    2. ZERO THE LENGTH IN CASE OF ERROR.                             * 00043\n*                                                                     * 00046\n*    3. CONVERT THE ERRO TO AN OFFSET IN THE TABLE AND SEE IF IT IS   * 00046\n*       IN IN RANGE.                                                  * 00046\n*                                                                     * 00051\n*    4. LOAD THE ADDRESS OF THE MESSAGE AND SEE IF IT IS ZERO THIS    * 00051\n*       MEANS UNKNOWN ERRNO, NO MESSAGE,.                             * 00051\n*                                                                     * 00054\n*    5. FIND THE END OF THE MESSAGE AND CALCULATE THE LENGTH.         * 00054\n*                                                                     * 00056\n*    6. PLACE THE LENGTH AND THE MESSAGE ADDRESS IN THE RETURNED      * 00056\n*       PARMS.                                                        * 00056\n*                                                                     * 00040\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00040\n*                                                                     * 00028\n*    LEN -- PONTER TO FULLWORD INT (*1,2,3,6)                         * 00028\n*       THIS IS THE ADDRESS OF A FULLWORD TO CONTAIN THE LENGTH OF    * 00029\n*       THE RETURNED MESSAGE.  IF NO MESSAGE IS RETURNED, THE LENGTH  * 00029\n*       IS SET TO ZERO.                                               * 00029\n*                                                                     * 00033\n*    MSG -- POINTER TO FULLWORD ADDR E   THIS IS THE ADDRESS OF A     * 00033\n*       FULLWORD TO CONTAIN THE MESSAGE ADDRESS. THE MESSAGE ADDRESS  * 00033\n*       IS A STATIC STRING WHICH IS TERMINATED BY A BYTE OF ZEROS.    * 00033\n*       (*1,6)                                                        * 00033\n*                                                                     * 00061\n* NOTES:                                                              * 00061\n*                                                                     * 00061\n*    1. SAMPLE CALL:                                                  * 00061\n*                 CALL  STRERR,(ERRNO,LEN,MSGADDR)                    * 00062\n*       ERRNO    DC  F'123'                                           * 00063\n*       LEN      DC  F'0'                                             * 00064\n*       MSGADDR  DC  A(0)                                             * 00065\n*                                                                     * 00066\n*********************************************************************** 00066\n         EJECT                                                          00067\nSTRERR   RENTR  BASE=11,PARM=(10,PARMS),WORK=(WORKLEN,WORKAREA),       X00068\n               ENV=OS,MAIN=YES                                          00069\nSTRERR   AMODE 31                                                       00070\nSTRERR   RMODE ANY                                                      00071\n         EJECT                                                          00072\n         LM    R4,R6,0(R10)        LOAD PARM LIST INTO REGS             00073\n         L     R4,0(R4)            R4 CONTAINS THE ERRNO                00074\n*                                  R5 POINTS TO LEN FULLWORD            00075\n*                                  R6 POINTS TO MSG ADDR                00076\n         XC    0(4,R5),0(R5)       ZERO THE LEN                         00077\n         L     R15,=A(PLINULL)                                          00078\n         ST    R15,0(,R6)                                               00079\n         SPACE                                                          00080\n         SLA   R4,2                MULTIPLY ERRNO BY 4                  00081\n         LA    R14,ETAB(R4)        POINT TO THE ERROR ADDR              00082\n         L     R15,=A(LASTMSG)     POINT TO END OF TABLE                00083\n         CR    R14,R15             ARE WE PAST THE TABLE?               00084\n         BH    RETURN              YES, NO MESSAGE                      00085\n         SPACE                                                          00086\n         L     R15,0(R14)          LOAD THE MESSAGE ADDR                00087\n         LTR   R15,R15             IS IT ZERO?                          00088\n         BZ    RETURN              IF SO, NO MESSAGE                    00089\n         SPACE                                                          00090\n*        NOTE THAT ALL MESSAGES ARE LESS THAN 255 CHARACTERS            00091\n         TRT   0(256,R15),FINDNUL  FIND END OF MESSAGE                  00092\n         SR    R1,R15              CALCULATE THE LENGTH                 00093\n         ST    R1,0(,R5)           SAVE THE LENGTH                      00094\n         ST    R15,0(,R6)          SAVE THE MESSAGE ADDR                00095\n         EJECT                                                          00096\nRETURN   DS    0H                                                       00097\n         REXIT ENV=BOTH                                                 00098\n         EJECT                                                          00099\n*                    0 1 2 3 4 5 6 7 8 9 A B C D E F                    00100\nFINDNUL  DC    XL16'FF000000000000000000000000000000'  00               00101\n         DC    XL16'00000000000000000000000000000000'  10               00102\n         DC    XL16'00000000000000000000000000000000'  20               00103\n         DC    XL16'00000000000000000000000000000000'  30               00104\n         DC    XL16'00000000000000000000000000000000'  40               00105\n         DC    XL16'00000000000000000000000000000000'  50               00106\n         DC    XL16'00000000000000000000000000000000'  60               00107\n         DC    XL16'00000000000000000000000000000000'  70               00108\n         DC    XL16'00000000000000000000000000000000'  80               00109\n         DC    XL16'00000000000000000000000000000000'  90               00110\n         DC    XL16'00000000000000000000000000000000'  A0               00111\n         DC    XL16'00000000000000000000000000000000'  B0               00112\n         DC    XL16'00000000000000000000000000000000'  C0               00113\n         DC    XL16'00000000000000000000000000000000'  D0               00114\n         DC    XL16'00000000000000000000000000000000'  E0               00115\n         DC    XL16'00000000000000000000000000000000'  F0               00116\n         EJECT                                                          00117\n*****************************************************************       00118\n*                                                               *       00119\n* ERRNO TABLE                                                   *       00120\n*                                                               *       00121\n*****************************************************************       00122\n         LTORG                                                          00123\nPLINULL  EQU   X'FF000000'                                              00124\n         SPACE                                                          00125\nETAB     DC    1170A(0)                                                 00126\nLASTMSG  EQU   *                                                        00127\n*****************************************************************       00128\n*                                                               *       00129\n* E R R N O   V A L U E S   D E F I N E D   B Y   C / 3 7 0     *       00130\n*                                                               *       00131\n*****************************************************************       00132\n         ORG   ETAB+(4*EDOM)                                            00133\n         DC    A(MEDOM)                                                 00134\n         ORG                                                            00135\nMEDOM                        DC    C'Error in the domain',X'00'         00136\n         ORG   ETAB+(4*ERANGE)                                          00137\n         DC    A(MERANGE)                                               00138\n         ORG                                                            00139\nMERANGE                      DC    C'Result is too large',X'00'         00140\n*****************************************************************       00141\n*                                                               *       00142\n* P O S I X   E R R N O   V A L U E S                           *       00143\n*                                                               *       00144\n*****************************************************************       00145\n         ORG   ETAB+(4*EACCES)                                          00146\n         DC    A(MEACCES)                                               00147\n         ORG                                                            00148\nMEACCES                      DC    C'Permission is denied',X'00'        00149\n         ORG   ETAB+(4*EAGAIN)                                          00150\n         DC    A(MEAGAIN)                                               00151\n         ORG                                                            00152\nMEAGAIN  DC    C'The resource is temporarily unavailable',X'00'         00153\n         ORG   ETAB+(4*EBADF)                                           00154\n         DC    A(MEBADF)                                                00155\n         ORG                                                            00156\nMEBADF   DC    C'The file descriptor is incorrect',X'00'                00157\n         ORG   ETAB+(4*EBUSY)                                           00158\n         DC    A(MEBUSY)                                                00159\n         ORG                                                            00160\nMEBUSY   DC    C'The resource is busy',X'00'                            00161\n         ORG   ETAB+(4*ECHILD)                                          00162\n         DC    A(MECHILD)                                               00163\n         ORG                                                            00164\nMECHILD  DC    C'No child process exists',X'00'                         00165\n         ORG   ETAB+(4*EDEADLK)                                         00166\n         DC    A(MEDEADLK)                                              00167\n         ORG                                                            00168\nMEDEADLK DC    C'A resource deadlock is avoided',X'00'                  00169\n         ORG   ETAB+(4*EEXIST)                                          00170\n         DC    A(MEEXIST)                                               00171\n         ORG                                                            00172\nMEEXIST  DC    C'The file exists',X'00'                                 00173\n         ORG   ETAB+(4*EFAULT)                                          00174\n         DC    A(MEFAULT)                                               00175\n         ORG                                                            00176\nMEFAULT  DC    C'The address is incorrect',X'00'                        00177\n         ORG   ETAB+(4*EFBIG)                                           00178\n         DC    A(MEFBIG)                                                00179\n         ORG                                                            00180\nMEFBIG   DC    C'The file is too large',X'00'                           00181\n         ORG   ETAB+(4*EINTR)                                           00182\n         DC    A(MEINTR)                                                00183\n         ORG                                                            00184\nMEINTR   DC    C'A function call is interrupted',X'00'                  00185\n         ORG   ETAB+(4*EINVAL)                                          00186\n         DC    A(MEINVAL)                                               00187\n         ORG                                                            00188\nMEINVAL  DC    C'The parameter is incorrect',X'00'                      00189\n         ORG   ETAB+(4*EIO)                                             00190\n         DC    A(MEIO)                                                  00191\n         ORG                                                            00192\nMEIO     DC    C'An I/O error occurred',X'00'                           00193\n         ORG   ETAB+(4*EISDIR)                                          00194\n         DC    A(MEISDIR)                                               00195\n         ORG                                                            00196\nMEISDIR  DC    C'The file specified is a directory',X'00'               00197\n         ORG   ETAB+(4*EMFILE)                                          00198\n         DC    A(MEMFILE)                                               00199\n         ORG                                                            00200\nMEMFILE  DC    C'Too many files are open for this process',X'00'        00201\n         ORG   ETAB+(4*EMLINK)                                          00202\n         DC    A(MEMLINK)                                               00203\n         ORG                                                            00204\nMEMLINK  DC    C'Too many links occurred',X'00'                         00205\n         ORG   ETAB+(4*ENAMETOOLONG)                                    00206\n         DC    A(MENAMETOOLONG)                                         00207\n         ORG                                                            00208\nMENAMETOOLONG  DC    C'The filename is too long',X'00'                  00209\n         ORG   ETAB+(4*ENFILE)                                          00210\n         DC    A(MENFILE)                                               00211\n         ORG                                                            00212\nMENFILE  DC    C'Too many files are open in the system',X'00'           00213\n         ORG   ETAB+(4*ENODEV)                                          00214\n         DC    A(MENODEV)                                               00215\n         ORG                                                            00216\nMENODEV  DC    C'No such device exists',X'00'                           00217\n         ORG   ETAB+(4*ENOENT)                                          00218\n         DC    A(MENOENT)                                               00219\n         ORG                                                            00220\nMENOENT  DC    C'No such file, directory, or IPC member exists',X'00'   00221\n         ORG   ETAB+(4*ENOEXEC)                                         00222\n         DC    A(MENOEXEC)                                              00223\n         ORG                                                            00224\nMENOEXEC DC    C'The exec call contained a format error.The target'     00225\n         DC    C' module on an exec call was not a valid  executable'   00226\n         DC    C' module.',X'00'                                        00227\n         ORG   ETAB+(4*ENOLCK)                                          00228\n         DC    A(MENOLCK)                                               00229\n         ORG                                                            00230\nMENOLCK  DC    C'No locks are available',X'00'                          00231\n         ORG   ETAB+(4*ENOMEM)                                          00232\n         DC    A(MENOMEM)                                               00233\n         ORG                                                            00234\nMENOMEM  DC    C'Not enough space is available',X'00'                   00235\n         ORG   ETAB+(4*ENOSPC)                                          00236\n         DC    A(MENOSPC)                                               00237\n         ORG                                                            00238\nMENOSPC  DC    C'No space is left on the device, or no space is '       00239\n         DC    C'available to create the IPC member ID',X'00'           00240\n         ORG   ETAB+(4*ENOSYS)                                          00241\n         DC    A(MENOSYS)                                               00242\n         ORG                                                            00243\nMENOSYS  DC    C'The function is not implemented',X'00'                 00244\n         ORG   ETAB+(4*ENOTDIR)                                         00245\n         DC    A(MENOTDIR)                                              00246\n         ORG                                                            00247\nMENOTDIR DC    C'Not a directory',X'00'                                 00248\n         ORG   ETAB+(4*ENOTEMPTY)                                       00249\n         DC    A(MENOTEMPTY)                                            00250\n         ORG                                                            00251\nMENOTEMPTY DC    C'The directory is not empty',X'00'                    00252\n         ORG   ETAB+(4*ENOTTY)                                          00253\n         DC    A(MENOTTY)                                               00254\n         ORG                                                            00255\nMENOTTY  DC    C'The I/O control operator is inappropriate',X'00'       00256\n         ORG   ETAB+(4*ENXIO)                                           00257\n         DC    A(MENXIO)                                                00258\n         ORG                                                            00259\nMENXIO   DC    C'No such device or address exists',X'00'                00260\n         ORG   ETAB+(4*EPERM)                                           00261\n         DC    A(MEPERM)                                                00262\n         ORG                                                            00263\nMEPERM   DC    C'The operation is not permitted',X'00'                  00264\n         ORG   ETAB+(4*EPIPE)                                           00265\n         DC    A(MEPIPE)                                                00266\n         ORG                                                            00267\nMEPIPE   DC    C'The pipe is broken',X'00'                              00268\n         ORG   ETAB+(4*EROFS)                                           00269\n         DC    A(MEROFS)                                                00270\n         ORG                                                            00271\nMEROFS   DC    C'The specified file system is read only',X'00'          00272\n         ORG   ETAB+(4*ESPIPE)                                          00273\n         DC    A(MESPIPE)                                               00274\n         ORG                                                            00275\nMESPIPE  DC    C'The seek is incorrect',X'00'                           00276\n         ORG   ETAB+(4*ESRCH)                                           00277\n         DC    A(MESRCH)                                                00278\n         ORG                                                            00279\nMESRCH   DC    C'No such process or thread exists',X'00'                00280\n         ORG   ETAB+(4*EXDEV)                                           00281\n         DC    A(MEXDEV)                                                00282\n         ORG                                                            00283\nMEXDEV   DC    C'A link to a file on another file system was '          00284\n         DC    C'attempted',X'00'                                       00285\n         ORG   ETAB+(4*E2BIG)                                           00286\n         DC    A(ME2BIG)                                                00287\n         ORG                                                            00288\nME2BIG   DC    C'The parameter list is too long, or the message to'     00289\n         DC    C' receive was too large for the buffer',X'00'           00290\n         ORG   ETAB+(4*ELOOP)                                           00291\n         DC    A(MELOOP)                                                00292\n         ORG                                                            00293\nMELOOP   DC    C'A loop is encountered in symbolic links',X'00'         00294\n         ORG   ETAB+(4*EILSEQ)                                          00295\n         DC    A(MEILSEQ)                                               00296\n         ORG                                                            00297\nMEILSEQ  DC    C'The byte sequence is illegal',X'00'                    00298\n         ORG   ETAB+(4*EOVERFLOW)                                       00299\n         DC    A(MEOVERFLOW)                                            00300\n         ORG                                                            00301\nMEOVERFLOW DC    C'A value is too large to be stored in the data type'  00302\n         DC      X'00'                                                  00303\n*****************************************************************       00304\n*                                                               *       00305\n* M V S   U N I Q U E   E R R N O   V A L U E S                 *       00306\n*                                                               *       00307\n*****************************************************************       00308\n         ORG   ETAB+(4*EMVSNOTUP)                                       00309\n         DC    A(MEMVSNOTUP)                                            00310\n         ORG                                                            00311\nMEMVSNOTUP DC    C'OpenMVS kernel is not active',X'00'                  00312\n         ORG   ETAB+(4*EMVSDYNALC)                                      00313\n         DC    A(MEMVSDYNALC)                                           00314\n         ORG                                                            00315\nMEMVSDYNALC DC    C'Dynamic allocation error',X'00'                     00316\n         ORG   ETAB+(4*EMVSCVAF)                                        00317\n         DC    A(MEMVSCVAF)                                             00318\n         ORG                                                            00319\nMEMVSCVAF DC    C'Catalog Volume Access Facility error',X'00'           00320\n         ORG   ETAB+(4*EMVSCATLG)                                       00321\n         DC    A(MEMVSCATLG)                                            00322\n         ORG                                                            00323\nMEMVSCATLG DC    C'Catalog obtain error',X'00'                          00324\n         ORG   ETAB+(4*EMVSINITIAL)                                     00325\n         DC    A(MEMVSINITIAL)                                          00326\n         ORG                                                            00327\nMEMVSINITIAL DC    C'Process Initialization error',X'00'                00328\n         ORG   ETAB+(4*EMVSERR)                                         00329\n         DC    A(MEMVSERR)                                              00330\n         ORG                                                            00331\nMEMVSERR DC    C'A MVS environmental or internal error has occurred'    00332\n         DC    X'00'                                                    00333\n         ORG   ETAB+(4*EMVSPARM)                                        00334\n         DC    A(MEMVSPARM)                                             00335\n         ORG                                                            00336\nMEMVSPARM DC    C'Bad parameters were passed to the service',X'00'      00337\n         ORG   ETAB+(4*EMVSPFSFILE)                                     00338\n         DC    A(MEMVSPFSFILE)                                          00339\n         ORG                                                            00340\nMEMVSPFSFILE DC    C'HFS encountered a permanent file error',X'00'      00341\n         ORG   ETAB+(4*EMVSPFSPERM)                                     00342\n         DC    A(MEMVSPFSPERM)                                          00343\n         ORG                                                            00344\nMEMVSPFSPERM DC    C'HFS encountered a system error',X'00'              00345\n         ORG   ETAB+(4*EMVSSAFEXTRERR)                                  00346\n         DC    A(MEMVSSAFEXTRERR)                                       00347\n         ORG                                                            00348\nMEMVSSAFEXTRERR DC    C'SAF/RACF extract error',X'00'                   00349\n         ORG   ETAB+(4*EMVSSAF2ERR)                                     00350\n         DC    A(MEMVSSAF2ERR)                                          00351\n         ORG                                                            00352\nMEMVSSAF2ERR DC    C'SAF/RACF error',X'00'                              00353\n         ORG   ETAB+(4*EMVSNORTL)                                       00354\n         DC    A(MEMVSNORTL)                                            00355\n         ORG                                                            00356\nMEMVSNORTL DC    C'Access to the OpenMVS version of the C RTL is'       00357\n         DC    C' denied',X'00'                                         00358\n         ORG   ETAB+(4*EMVSEXPIRE)                                      00359\n         DC    A(MEMVSEXPIRE)                                           00360\n         ORG                                                            00361\nMEMVSEXPIRE DC    C'The password for the specified resource has '       00362\n         DC    C'expired',X'00'                                         00363\n         ORG   ETAB+(4*EMVSPASSWORD)                                    00364\n         DC    A(MEMVSPASSWORD)                                         00365\n         ORG                                                            00366\nMEMVSPASSWORD DC    C'The new password specified is not valid',X'00'    00367\n         ORG   ETAB+(4*EMVSWLMERROR)                                    00368\n         DC    A(MEMVSWLMERROR)                                         00369\n         ORG                                                            00370\nMEMVSWLMERROR DC    C'A WLM service ended in error',X'00'               00371\n         ORG   ETAB+(4*EMVSCPLERROR)                                    00372\n         DC    A(MEMVSCPLERROR)                                         00373\n         ORG                                                            00374\nMEMVSCPLERROR DC    C'A Coupling Facility service ended in error',X'00' 00375\n*****************************************************************       00376\n*                                                               *       00377\n* O P E N   S Y S T E M S   E R R N O   V A L U E S             *       00378\n*                                                               *       00379\n*****************************************************************       00380\n         ORG   ETAB+(4*EIBMSOCKOUTOFRANGE)                              00381\n         DC    A(MEIBMSOCKOUTOFRANGE)                                   00382\n         ORG                                                            00383\nMEIBMSOCKOUTOFRANGE DC    C'Socket number assigned by client interface' 00384\n         DC    C' code (for socket() and accept()) is out of range'     00385\n         DC    X'00'                                                    00386\n         ORG   ETAB+(4*EIBMSOCKINUSE)                                   00387\n         DC    A(MEIBMSOCKINUSE)                                        00388\n         ORG                                                            00389\nMEIBMSOCKINUSE DC    C'Socket number assigned by client interface'      00390\n         DC    C' code is already in use',X'00'                         00391\n         ORG   ETAB+(4*EOFFLOADBOXERROR)                                00392\n         DC    A(MEOFFLOADBOXERROR)                                     00393\n         ORG                                                            00394\nMEOFFLOADBOXERROR DC    C'Offload box error',X'00'                      00395\n         ORG   ETAB+(4*EOFFLOADBOXRESTART)                              00396\n         DC    A(MEOFFLOADBOXRESTART)                                   00397\n         ORG                                                            00398\nMEOFFLOADBOXRESTART DC    C'Offload box restarted',X'00'                00399\n         ORG   ETAB+(4*EOFFLOADBOXDOWN)                                 00400\n         DC    A(MEOFFLOADBOXDOWN)                                      00401\n         ORG                                                            00402\nMEOFFLOADBOXDOWN DC    C'Offload box down',X'00'                        00403\n         ORG   ETAB+(4*EIBMCONFLICT)                                    00404\n         DC    A(MEIBMCONFLICT)                                         00405\n         ORG                                                            00406\nMEIBMCONFLICT  DC    C'Already a conflicting call outstanding on'       00407\n         DC    C' socket',X'00'                                         00408\n         ORG   ETAB+(4*EIBMCANCELLED)                                   00409\n         DC    A(MEIBMCANCELLED)                                        00410\n         ORG                                                            00411\nMEIBMCANCELLED DC    C'Request cancelled via SOCKcallCANCEL request'    00412\n         DC    X'00'                                                    00413\n         ORG   ETAB+(4*EIBMBADTCPNAME)                                  00414\n         DC    A(MEIBMBADTCPNAME)                                       00415\n         ORG                                                            00416\nMEIBMBADTCPNAME DC    C'SetIbmOpt specified a name of a PFS that'       00417\n         DC    C' either was not configured or was not a Sockets PFS.'  00418\n         DC    X'00'                                                    00419\n         ORG   ETAB+(4*ENOTBLK)                                         00420\n         DC    A(MENOTBLK)                                              00421\n         ORG                                                            00422\nMENOTBLK DC    C'Block device required',X'00'                           00423\n         ORG   ETAB+(4*ETXTBSY)                                         00424\n         DC    A(METXTBSY)                                              00425\n         ORG                                                            00426\nMETXTBSY DC    C'Text file busy',X'00'                                  00427\n         ORG   ETAB+(4*EWOULDBLOCK)                                     00428\n         DC    A(MEWOULDBLOCK)                                          00429\n         ORG                                                            00430\nMEWOULDBLOCK DC    C'The descriptor is marked nonblocking, and the'     00431\n         DC    C' requested function cannot complete immediately',X'00' 00432\n         ORG   ETAB+(4*EINPROGRESS)                                     00433\n         DC    A(MEINPROGRESS)                                          00434\n         ORG                                                            00435\nMEINPROGRESS DC    C'Operation now in progress',X'00'                   00436\n         ORG   ETAB+(4*EALREADY)                                        00437\n         DC    A(MEALREADY)                                             00438\n         ORG                                                            00439\nMEALREADY DC    C'Operation already in progress',X'00'                  00440\n         ORG   ETAB+(4*ENOTSOCK)                                        00441\n         DC    A(MENOTSOCK)                                             00442\n         ORG                                                            00443\nMENOTSOCK DC    C'Socket operation on a non-socket',X'00'               00444\n         ORG   ETAB+(4*EDESTADDRREQ)                                    00445\n         DC    A(MEDESTADDRREQ)                                         00446\n         ORG                                                            00447\nMEDESTADDRREQ DC    C'Destination address required',X'00'               00448\n         ORG   ETAB+(4*EMSGSIZE)                                        00449\n         DC    A(MEMSGSIZE)                                             00450\n         ORG                                                            00451\nMEMSGSIZE DC    C'The message is too large to be sent all at once,'     00452\n         DC    C' as required',X'00'                                    00453\n         ORG   ETAB+(4*EPROTOTYPE)                                      00454\n         DC    A(MEPROTOTYPE)                                           00455\n         ORG                                                            00456\nMEPROTOTYPE DC    C'The socket type is incorrect',X'00'                 00457\n         ORG   ETAB+(4*ENOPROTOOPT)                                     00458\n         DC    A(MENOPROTOOPT)                                          00459\n         ORG                                                            00460\nMENOPROTOOPT DC    C'Protocol or socket option not available',X'00'     00461\n         ORG   ETAB+(4*EPROTONOSUPPORT)                                 00462\n         DC    A(MEPROTONOSUPPORT)                                      00463\n         ORG                                                            00464\nMEPROTONOSUPPORT DC    C'Protocol not supported',X'00'                  00465\n         ORG   ETAB+(4*ESOCKTNOSUPPORT)                                 00466\n         DC    A(MESOCKTNOSUPPORT)                                      00467\n         ORG                                                            00468\nMESOCKTNOSUPPORT DC    C'Socket type not supported',X'00'               00469\n         ORG   ETAB+(4*EOPNOTSUPP)                                      00470\n         DC    A(MEOPNOTSUPP)                                           00471\n         ORG                                                            00472\nMEOPNOTSUPP DC    C'The referenced socket is not a type that'           00473\n         DC    C' supports the requested function',X'00'                00474\n         ORG   ETAB+(4*EPFNOSUPPORT)                                    00475\n         DC    A(MEPFNOSUPPORT)                                         00476\n         ORG                                                            00477\nMEPFNOSUPPORT DC    C'Protocol family not supported',X'00'              00478\n         ORG   ETAB+(4*EAFNOSUPPORT)                                    00479\n         DC    A(MEAFNOSUPPORT)                                         00480\n         ORG                                                            00481\nMEAFNOSUPPORT DC    C'The address family is not supported',X'00'        00482\n         ORG   ETAB+(4*EADDRINUSE)                                      00483\n         DC    A(MEADDRINUSE)                                           00484\n         ORG                                                            00485\nMEADDRINUSE DC    C'The address is already in use',X'00'                00486\n         ORG   ETAB+(4*EADDRNOTAVAIL)                                   00487\n         DC    A(MEADDRNOTAVAIL)                                        00488\n         ORG                                                            00489\nMEADDRNOTAVAIL DC    C'Cannot assign requested address',X'00'           00490\n         ORG   ETAB+(4*ENETDOWN)                                        00491\n         DC    A(MENETDOWN)                                             00492\n         ORG                                                            00493\nMENETDOWN DC    C'Network is down',X'00'                                00494\n         ORG   ETAB+(4*ENETUNREACH)                                     00495\n         DC    A(MENETUNREACH)                                          00496\n         ORG                                                            00497\nMENETUNREACH DC    C'Network is unreachable',X'00'                      00498\n         ORG   ETAB+(4*ENETRESET)                                       00499\n         DC    A(MENETRESET)                                            00500\n         ORG                                                            00501\nMENETRESET DC    C'Network dropped connection on reset',X'00'           00502\n         ORG   ETAB+(4*ECONNABORTED)                                    00503\n         DC    A(MECONNABORTED)                                         00504\n         ORG                                                            00505\nMECONNABORTED DC    C'Software caused connection abort',X'00'           00506\n         ORG   ETAB+(4*ECONNRESET)                                      00507\n         DC    A(MECONNRESET)                                           00508\n         ORG                                                            00509\nMECONNRESET DC    C'Connection reset by peer',X'00'                     00510\n         ORG   ETAB+(4*ENOBUFS)                                         00511\n         DC    A(MENOBUFS)                                              00512\n         ORG                                                            00513\nMENOBUFS DC    C'Insufficient buffer space available',X'00'             00514\n         ORG   ETAB+(4*EISCONN)                                         00515\n         DC    A(MEISCONN)                                              00516\n         ORG                                                            00517\nMEISCONN DC    C'The socket is already connected',X'00'                 00518\n         ORG   ETAB+(4*ENOTCONN)                                        00519\n         DC    A(MENOTCONN)                                             00520\n         ORG                                                            00521\nMENOTCONN DC    C'The socket is not connected',X'00'                    00522\n         ORG   ETAB+(4*ESHUTDOWN)                                       00523\n         DC    A(MESHUTDOWN)                                            00524\n         ORG                                                            00525\nMESHUTDOWN DC    C'Cannot send after socket shutdown',X'00'             00526\n         ORG   ETAB+(4*ETOOMANYREFS)                                    00527\n         DC    A(METOOMANYREFS)                                         00528\n         ORG                                                            00529\nMETOOMANYREFS DC    C'Too many references: cannot splice',X'00'         00530\n         ORG   ETAB+(4*ETIMEDOUT)                                       00531\n         DC    A(METIMEDOUT)                                            00532\n         ORG                                                            00533\nMETIMEDOUT DC    C'Connection timed out',X'00'                          00534\n         ORG   ETAB+(4*ECONNREFUSED)                                    00535\n         DC    A(MECONNREFUSED)                                         00536\n         ORG                                                            00537\nMECONNREFUSED DC    C'The attempt to connect was rejected',X'00'        00538\n         ORG   ETAB+(4*EHOSTDOWN)                                       00539\n         DC    A(MEHOSTDOWN)                                            00540\n         ORG                                                            00541\nMEHOSTDOWN DC    C'Host is down',X'00'                                  00542\n         ORG   ETAB+(4*EHOSTUNREACH)                                    00543\n         DC    A(MEHOSTUNREACH)                                         00544\n         ORG                                                            00545\nMEHOSTUNREACH DC    C'No route to host',X'00'                           00546\n         ORG   ETAB+(4*EPROCLIM)                                        00547\n         DC    A(MEPROCLIM)                                             00548\n         ORG                                                            00549\nMEPROCLIM DC    C'Too many processes',X'00'                             00550\n         ORG   ETAB+(4*EUSERS)                                          00551\n         DC    A(MEUSERS)                                               00552\n         ORG                                                            00553\nMEUSERS  DC    C'Too many users',X'00'                                  00554\n         ORG   ETAB+(4*EDQUOT)                                          00555\n         DC    A(MEDQUOT)                                               00556\n         ORG                                                            00557\nMEDQUOT  DC    C'Disc quota exceeded',X'00'                             00558\n         ORG   ETAB+(4*ESTALE)                                          00559\n         DC    A(MESTALE)                                               00560\n         ORG                                                            00561\nMESTALE  DC    C'Stale NFS file handle',X'00'                           00562\n         ORG   ETAB+(4*EREMOTE)                                         00563\n         DC    A(MEREMOTE)                                              00564\n         ORG                                                            00565\nMEREMOTE DC    C'Too many levels of remote in path',X'00'               00566\n         ORG   ETAB+(4*ENOSTR)                                          00567\n         DC    A(MENOSTR)                                               00568\n         ORG                                                            00569\nMENOSTR  DC    C'Device is not a stream',X'00'                          00570\n         ORG   ETAB+(4*ETIME)                                           00571\n         DC    A(METIME)                                                00572\n         ORG                                                            00573\nMETIME   DC    C'Timer expired',X'00'                                   00574\n         ORG   ETAB+(4*ENOSR)                                           00575\n         DC    A(MENOSR)                                                00576\n         ORG                                                            00577\nMENOSR   DC    C'Out of streams resources',X'00'                        00578\n         ORG   ETAB+(4*ENOMSG)                                          00579\n         DC    A(MENOMSG)                                               00580\n         ORG                                                            00581\nMENOMSG  DC    C'No message of the desired type',X'00'                  00582\n         ORG   ETAB+(4*EBADMSG)                                         00583\n         DC    A(MEBADMSG)                                              00584\n         ORG                                                            00585\nMEBADMSG DC    C'Trying to read unreadable message',X'00'               00586\n         ORG   ETAB+(4*EIDRM)                                           00587\n         DC    A(MEIDRM)                                                00588\n         ORG                                                            00589\nMEIDRM   DC    C'Identifier removed',X'00'                              00590\n         ORG   ETAB+(4*ENONET)                                          00591\n         DC    A(MENONET)                                               00592\n         ORG                                                            00593\nMENONET  DC    C'Machine is not on the network',X'00'                   00594\n         ORG   ETAB+(4*ERREMOTE)                                        00595\n         DC    A(MERREMOTE)                                             00596\n         ORG                                                            00597\nMERREMOTE DC    C'Object is remote',X'00'                               00598\n         ORG   ETAB+(4*ENOLINK)                                         00599\n         DC    A(MENOLINK)                                              00600\n         ORG                                                            00601\nMENOLINK DC    C'The link has been severed',X'00'                       00602\n         ORG   ETAB+(4*EADV)                                            00603\n         DC    A(MEADV)                                                 00604\n         ORG                                                            00605\nMEADV    DC    C'Advertise error',X'00'                                 00606\n         ORG   ETAB+(4*ESRMNT)                                          00607\n         DC    A(MESRMNT)                                               00608\n         ORG                                                            00609\nMESRMNT  DC    C'srmount error',X'00'                                   00610\n         ORG   ETAB+(4*ECOMM)                                           00611\n         DC    A(MECOMM)                                                00612\n         ORG                                                            00613\nMECOMM   DC    C'Communication error on send',X'00'                     00614\n         ORG   ETAB+(4*EPROTO)                                          00615\n         DC    A(MEPROTO)                                               00616\n         ORG                                                            00617\nMEPROTO  DC    C'Protocol error',X'00'                                  00618\n         ORG   ETAB+(4*EMULTIHOP)                                       00619\n         DC    A(MEMULTIHOP)                                            00620\n         ORG                                                            00621\nMEMULTIHOP DC    C'Protocol error',X'00'                                00622\n         ORG   ETAB+(4*EDOTDOT)                                         00623\n         DC    A(MEDOTDOT)                                              00624\n         ORG                                                            00625\nMEDOTDOT DC    C'Cross mount point',X'00'                               00626\n         ORG   ETAB+(4*EREMCHG)                                         00627\n         DC    A(MEREMCHG)                                              00628\n         ORG                                                            00629\nMEREMCHG DC    C'Remote address change',X'00'                           00630\n         ORG   ETAB+(4*ECANCELED)                                       00631\n         DC    A(MECANCELED)                                            00632\n         ORG                                                            00633\nMECANCELED DC    C'The asynchronous I/O request has been canceled'      00634\n         DC    X'00'                                                    00635\n         ORG   ETAB+(4*ETCPOUTOFSTATE)                                  00636\n         DC    A(METCPOUTOFSTATE)                                       00637\n         ORG                                                            00638\nMETCPOUTOFSTATE DC    C'Socket send/receive gotten out of order'        00639\n         DC    X'00'                                                    00640\n         ORG   ETAB+(4*ETCPUNATTACH)                                    00641\n         DC    A(METCPUNATTACH)                                         00642\n         ORG                                                            00643\nMETCPUNATTACH DC    C'Unattached streams error',X'00'                   00644\n         ORG   ETAB+(4*ETCPBADOBJ)                                      00645\n         DC    A(METCPBADOBJ)                                           00646\n         ORG                                                            00647\nMETCPBADOBJ DC    C'Streams push object error',X'00'                    00648\n         ORG   ETAB+(4*ETCPCLOSED)                                      00649\n         DC    A(METCPCLOSED)                                           00650\n         ORG                                                            00651\nMETCPCLOSED DC    C'Streams closed error',X'00'                         00652\n         ORG   ETAB+(4*ETCPLINKED)                                      00653\n         DC    A(METCPLINKED)                                           00654\n         ORG                                                            00655\nMETCPLINKED DC    C'Streams link error',X'00'                           00656\n         ORG   ETAB+(4*ETCPERR)                                         00657\n         DC    A(METCPERR)                                              00658\n         ORG                                                            00659\nMETCPERR DC    C'Tcp error',X'00'                                       00660\n         ORG   ETAB+(4*EINTRNODATA)                                     00661\n         DC    A(MEINTRNODATA)                                          00662\n         ORG                                                            00663\nMEINTRNODATA DC    C'Accept_and_receive is interrupted after the'       00664\n         DC    C' connection arrived but before the first data'         00665\n         DC    C' arrived.',X'00'                                       00666\n         ORG   ETAB+(4*ENOREUSE)                                        00667\n         DC    A(MENOREUSE)                                             00668\n         ORG                                                            00669\nMENOREUSE DC    C'Socket descriptor reuse is not supported.',X'00'      00670\n         ORG   ETAB+(4*ENOMOVE)                                         00671\n         DC    A(MENOMOVE)                                              00672\n         ORG                                                            00673\nMENOMOVE DC    C'FileSystem can not be moved.',X'00'                    00674\n         EJECT                                                          00675\nWORKAREA DSECT                                                          00676\n         DS    26F                                                      00677\nWORKLEN  EQU   *-WORKAREA                                               00678\n         SPACE                                                          00679\nPARMS    DSECT                                                          00680\nPERRNO   DS    A        THE ERRNO TO UNRAVEL                            00681\nPLEN     DS    A        POINTS TO AN INT TO RECIEVE THE LENGTH          00682\nPMSG     DS    A        POINTS TO AN POINTER TO RECIEVE THE MSG ADDR    00683\n         SPACE                                                          00684\n         SYMBAR MODE=DEC                                                00685\n         BPXYERNO                                                       00686\n         END                                                            00687\n*          DATA SET FG50033705 AT LEVEL 016 AS OF 01/14/94\nBREAK    TITLE 'FIND FIRST OCCURANCE OF ANY CHAR IN A PLI STRING'       00001\n         PRINT OFF                                                      00002\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00006\n         EJECT                                                          00007\n*********************************************************************** 00012\n*                                                                     * 00012\n* SEGMENT NAME:                                                       * 00012\n*                                                                     * 00012\n*    BREAK -- FIND THE FIRST OCCURANCE ANY OF THE CHARACTERS IN THE   * 00012\n*       SEARCH STRING IN THE SCANNED STRING                           * 00012\n*                                                                     * 00032\n* INPUTS (*TO FUNCTIONS):                                             * 00032\n*                                                                     * 00014\n*    PARM1 -- SCANNED STRING: STRING (*1,3)                           * 00014\n*       THIS IS THE FIRST PARAMETER POINTED TO BY THE PARAMETER LIST. * 00015\n*       THIS IS THE STRING TO BE SCANNED.                             * 00015\n*       VALUES: 2 BYTE HEADER, THE LENGTH OF THE STRING FOLLOWED BY   * 00017\n*                     THE TEXT OF THE STRING.                         * 00017\n*                                                                     * 00019\n*    PARM2 -- SEARCH STRING: STRING (*1,2)                            * 00019\n*       THIS IS THE SECOND PARAMETER POINTED TO BY THE PARAMETER      * 00020\n*       LIST. THIS IS THE STRING WHICH CONTAINS THE LIST OF           * 00020\n*       CHARACTERS WHICH ARE BEING CHECKED FOR IN THE SEARCH STRING.  * 00020\n*       VALUES: 2 BYTE HEADER, THE LENGTH OF THE STRING FOLLOWED BY   * 00023\n*                     THE TEXT OF THE STRING.                         * 00023\n*                                                                     * 00031\n* FUNCTIONS:                                                          * 00031\n*                                                                     * 00031\n*    1. LOAD THE PARAMETER LENGTHS AND ADDRESSES INTO REGISTERS.      * 00031\n*                                                                     * 00034\n*    2. SET A TRT TABLE TO SCAN FOR ALL THE CHARACTERS IN THE SEARCH  * 00034\n*       STRING                                                        * 00034\n*                                                                     * 00037\n*    3. SCAN THE SCANNED STRING FOR THE FIRST CHARACTER OF IN THE     * 00037\n*       SCANNED STRING STRING.                                        * 00037\n*                                                                     * 00040\n*    4. IF FOUND, RETURN CHARACTER NUMBER IN THE STRING OF THE START  * 00040\n*       OF THE STRING.                                                * 00040\n*                                                                     * 00044\n*    5. IF NOT FOUND, RETURN ZERO.                                    * 00044\n*                                                                     * 00042\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00042\n*                                                                     * 00025\n*    POSITION -- POSITION IN THE SCANNED STRING (*4,5)                * 00025\n*       THIS INTEGER, RETURNED IN THE RETURN PARM, IS THE POSITION OF * 00026\n*       THE FIRST CHARACTER IS THE SCANNED STRING WHICH IS IN THE     * 00026\n*       SEARCH STRING OR ZERO IF NO CHARS IN THE SCANNED STRING ARE   * 00026\n*       IN THE SEARCH STRING.                                         * 00026\n*                                                                     * 00030\n*    RC -- RETURN CODE (*4,5)                                         * 00030\n*                                                                     * 00047\n* NOTES:                                                              * 00047\n*                                                                     * 00047\n*    1. SAMPLE DECLARE                                                * 00047\n*                                                                     * 00048\n*       DECLARE  BREAK(VARYING CHAR(*), VARYING CHAR(*))              * 00048\n*                       RETURNS(FIXED BINARY(15)) EXTERNAL;           * 00049\n*                                                                     * 00051\n*    2. ISSUE HISTORY:                                                * 00051\n*                                                                     * 00052\n*       REASON FOR ISSUE 02:                                          * 00052\n*       MAKE ROUTINE REENTRANT                                        * 00053\n*                                                                     * 00054\n*       REASON FOR ISSUE 03:                                          * 00054\n*       ADD ENTRY POINT STRNCAT.                                      * 00055\n*                                                                     * 00056\n*       REASON FOR ISSUE 04:                                          * 00056\n*       ADD PARM OVERFLOW TO STRNCAT.                                 * 00057\n*                                                                     * 00058\n*       REASON FOR ISSUE 05:                                          * 00058\n*       ADD ENTRY POINTS BCMP AND BCOPY                               * 00059\n*                                                                     * 00060\n*********************************************************************** 00060\n         SPACE 2                                                        00065\nBREAK1   AMODE ANY                                                      00085\nBREAK1   RMODE ANY                                                      00086\nBREAK    RENTR BASE=11,WORK=(WORKLEN,WORKAREA),PARM=10,ENV=BOTH         00066\n         SPACE 2                                                        00067\n*********************************************************************** 00068\n*                                                                     * 00068\n* LOAD THE PARM LIST INTO REGISTERS R3 AND R4, THUS FREEING R1.       * 00068\n*                                                                     * 00069\n*      REGISTER USAGE:                                                * 00069\n*              R1  -> PARM LIST                                       * 00070\n*              R3  -> PARM1                                           * 00071\n*              R4  -> PARM2                                           * 00072\n*                                                                     * 00073\n*********************************************************************** 00073\n         SPACE                                                          00074\n         LM    R3,R5,0(R10)        LOAD THE PARM LIST                   00075\n         L     R3,0(R3)            POINT TO STRING TO BE SCANNED        00076\n         L     R4,0(R4)            POINT TO CHARS TO LOOK FOR           00077\n         SPACE 2                                                        00078\n*********************************************************************** 00079\n*                                                                     * 00079\n* CLEAR THE 256 BYTE TRT TABLE                                        * 00079\n*                                                                     * 00080\n*********************************************************************** 00080\n         SPACE                                                          00081\n         XC    FINDFRST(255),FINDFRST  ZERO THE TRT TABLE               00082\n         SPACE 2                                                        00083\n*********************************************************************** 00084\n*                                                                     * 00084\n* LOAD THE PARM LENGTHS AND ADDRESSES INTO REGISTERS R3 THRU R7.      * 00084\n* CHECK THE SEARCH STRING LONGER THAN SCANNED STRING (NOT FOUND).     * 00084\n*                                                                     * 00088\n*      REGISTER USAGE:                                                * 00088\n*              R3  -  LENGTH OF SCANNED STRING                        * 00089\n*              R4  -> SCANNED STRING                                  * 00090\n*              R5  -> RETURNED PARM FIXED BINARY(15), HALFWORD        * 00091\n*              R6  -  LENGTH OF SEARCH STRING                         * 00092\n*              R7  -> SEARCH STRING                                   * 00093\n*              R9  -> START OF THE SCANNED STRING, SAVED TO CALCULATE * 00094\n*                     CHAR POS                                        * 00094\n*              R11 -  BASE FOR PROGRAM                                * 00095\n*              R13 -> DSA AND LOCAL VARIABLES                         * 00095\n*                                                                     * 00096\n*********************************************************************** 00096\n         SPACE                                                          00097\n         LA    R7,2(R4)            POINT TO CHARS TO LOOK FOR           00098\n         LH    R6,0(R4)            LOAD LENGTH OF CHARS TO LOOK FOR     00099\n         SPACE                                                          00100\n         LA    R4,2(R3)            LOAD ADDR OF SCANNED STRING          00101\n         LR    R9,R4               SAVE AWAY THE POINTER TO THE STRING  00102\n         LH    R3,0(R3)            LOAD LENGTH OF SCANNED STRING        00103\n         SPACE                                                          00104\n         LTR   R3,R3               CHECK ZERO LENGTH SCANNED STRING     00105\n         BNP   NOTFOUND            IF NULL, WE CANT FIND ANYTHING IN IT 00106\n         SPACE 2                                                        00107\n*********************************************************************** 00108\n*                                                                     * 00108\n* SET THE TRT TABLE TO SEARCH FOR THE FIRST CHARACTER NOT IN THE THE  * 00108\n* SEARCH STRING.                                                      * 00108\n*                                                                     * 00111\n*      REGISTER USAGE:                                                * 00111\n*              R3  -  LENGTH OF SCANNED STRING                        * 00112\n*              R4  -> SCANNED STRING                                  * 00113\n*              R5  -> RETURNED PARM FIXED BINARY(15), HALFWORD        * 00114\n*              R6  -  LENGTH OF SEARCH STRING                         * 00115\n*              R7  -> SEARCH STRING                                   * 00116\n*              R8  -  WORK REGISTER - OFFSET INTO THE TRT TABLE FOR   * 00117\n*                     THE SEARCH CHARACTER.                           * 00117\n*              R9  -> START OF THE SCANNED STRING, SAVED TO CALCULATE * 00119\n*                     CHAR POS                                        * 00119\n*              R11 -  BASE FOR PROGRAM                                * 00120\n*              R13 -> DSA AND LOCAL VARIABLES                         * 00120\n*                                                                     * 00121\n*********************************************************************** 00121\n         SPACE                                                          00122\n         LTR   R6,R6               CHECK THE LENGTH OF THE SEARCH       00123\n*                                  STRING                               00124\n         BZ    NOTFOUND            IF ZERO, WE WONT FIND ANYTHING       00125\n         SPACE                                                          00126\nSETTRT   DS    0H                                                       00127\n         SLR   R8,R8                                                    00128\n         IC    R8,0(R7)            INSERT A CHARACTER FROM THE          00129\n*                                  SEARCH STRING                        00130\n         SPACE                                                          00131\n         LA    R8,FINDFRST(R8)     USE THE CHARACTER'S HEX VALUE AS AN  00132\n*                                  OFFSET INTO THE TRT TABLE AND        00133\n         MVI   0(R8),X'FF'         MARK THE PROPER PLACE IN THE TRT     00134\n*                                  TABLE.                               00135\n         LA    R7,1(R7)            GO TO THE NEXT CHARACTER             00136\n         BCT   R6,SETTRT                                                00137\n         SPACE 2                                                        00138\n*********************************************************************** 00139\n*                                                                     * 00139\n* THE TRT TABLE IS NOW SET UP.  ISSUE THE TRT INSTRUCTION TO SCAN THE * 00139\n* SCANNED STRING.                                                     * 00139\n*                                                                     * 00142\n*      REGISTER USAGE:                                                * 00142\n*              R1  -> THE CHARACTER WHICH THE TRT INSTRUCTION FOUND   * 00143\n*              R3  -  LENGTH OF SCANNED STRING                        * 00144\n*              R4  -> SCANNED STRING                                  * 00145\n*              R5  -> RETURNED PARM FIXED BINARY(15), HALFWORD        * 00146\n*              R8  -  WORK REGISTER, TEMP STORAGE FOR R1 DURING       * 00147\n*                     CALCULATIONS                                    * 00147\n*              R9  -> START OF THE SCANNED STRING, SAVED TO CALCULATE * 00148\n*                     CHAR POS                                        * 00148\n*              R11 -  BASE FOR PROGRAM                                * 00149\n*              R13 -> DSA AND LOCAL VARIABLES                         * 00149\n*                                                                     * 00150\n*********************************************************************** 00150\n         SPACE                                                          00151\nSCAN     DS    0H                                                       00152\n**********************************************************              00153\n         SPACE                                                          00154\nLOOP     DS    0H                                                       00155\n         C     R3,=F'256'       IS THERE MORE THAN 256 CHARACTERS?      00156\n         BNH   LAST256          IF NOT, DO IT WITH AN EXECUTE           00157\n         SPACE                                                          00158\n         TRT   0(256,R4),FINDFRST SCAN 256 BYTES OF STRING              00159\n         BNZ   FOUND               GOT IT                               00160\n         SPACE                                                          00161\n         LA    R4,256(R4)       BUMP STRING POINTER                     00162\n         S     R3,=F'256'       SUBTRACT THE LENGTH OF THE STRING       00163\n         BZ    NOTFOUND         IF LENGTH IS NOW ZERO, WE ARE DONE      00164\n         B     LOOP                                                     00165\n         SPACE                                                          00166\nLAST256  DS    0H                                                       00167\n         BCTR  R3,0             SUB 1 FOR EXECUTE INSTRUCTIONS          00168\n         EX    R3,FIND          LOOK FOR CHARS IN SCANNED STRING        00169\n         BNZ   FOUND               GOT IT                               00170\n         SPACE                                                          00171\n         SPACE 2                                                        00172\n*********************************************************************** 00173\n*                                                                     * 00173\n* BRANCH TO, OR FALL INTO THIS CODE WHEN THE SEARCH FAILS.  SET R7 TO * 00173\n* ZERO.                                                               * 00173\n*                                                                     * 00176\n*      REGISTER USAGE:                                                * 00176\n*              R7  -  USED TO HOLD THE ZERO VALUE TO BE RETURNED TO   * 00177\n*                     THE CALLING PROGRAM.                            * 00177\n*                                                                     * 00179\n*********************************************************************** 00179\n         SPACE                                                          00180\nNOTFOUND DS    0H                                                       00181\n         SLR   R7,R7               ZERO THE ADDRESS                     00182\n         B     RETURN              GO CLOSE UP SHOP                     00183\n         SPACE 2                                                        00184\n*********************************************************************** 00185\n*                                                                     * 00185\n* BRANCH TO HERE IF A MATCH IS FOUND.  R1 CONTAINS THE ADDR OF THE    * 00185\n* FOUND CHARACTER                                                     * 00185\n*                                                                     * 00188\n*      REGISTER USAGE:                                                * 00188\n*              R1  -> POSITION IN THE SCANNED STRING WHICH WAS FOUND  * 00189\n*                     BY THE TRT INSTRUCTION.                         * 00189\n*              R7  -  USED TO HOLD CHARACTER POSITION TO BE RETURNED  * 00191\n*                     TO THE CALLING PROGRAM.                         * 00191\n*              R9  -> START OF THE SCANNED STRING, SAVED TO CALCULATE * 00193\n*                     CHAR POS                                        * 00193\n*                                                                     * 00194\n*********************************************************************** 00194\n         SPACE                                                          00195\nFOUND    DS    0H                                                       00196\n         SR    R1,R9               CALCULATE THE OFFSET INTO THE STRING 00197\n         LA    R1,1(R1)            CONVERT TO CHARACTER POSITITION      00198\n         LR    R7,R1                                                    00199\n         SPACE 2                                                        00200\n*********************************************************************** 00201\n*                                                                     * 00201\n* CLOSE UP SHOP AND RETURN                                            * 00201\n*                                                                     * 00203\n*      REGISTER USAGE:                                                * 00203\n*              R0  -> RETURNED CHARACTER POSITION                     * 00204\n*              R11 -  BASE FOR PROGRAM                                * 00205\n*              R13 -> DSA AND LOCAL VARIABLES                         * 00205\n*                                                                     * 00206\n*********************************************************************** 00206\n         SPACE                                                          00207\nRETURN   DS    0H                                                       00208\n         STH   R7,0(R5)            SAVE IN THE RETURNED PARM            00209\n         SPACE                                                          00210\n         REXIT ENV=BOTH                                                 00211\n         SPACE 2                                                        00212\n*********************************************************************** 00213\n*                                                                     * 00213\n* OBJECTS OF EXECUTE INSTRUCTIONS                                     * 00213\n*                                                                     * 00214\n*********************************************************************** 00214\n         SPACE                                                          00215\nFIND     TRT   0(*-*,R4),FINDFRST       SCAN FOR FIRST CHARACTER        00216\n         DROP  R11,R13                                                  00217\n         SPACE                                                          00218\nWORKAREA DSECT                                                          00219\n         DS    18D                 LOWER SAVE AREA                      00220\nFINDFRST DS    XL256                                                    00221\nWORKLEN  EQU   *-WORKAREA                                               00222\n         SYMBAR MODE=DEC                                                00223\n         END                                                            00224\nSTRNCAT  TITLE 'CONCATINATE ONE STRING ONTO ANOTHER QUICKLY'            00225\n         PRINT OFF                                                      00226\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00230\n*********************************************************************** 00231\n*                                                                     * 00231\n* SEGMENT NAME:                                                       * 00231\n*                                                                     * 00231\n*    STRNCAT -- CONCATINATE ONE STRING ONTO THE BACK OF ANOTHER       * 00231\n*       QUICKLY                                                       * 00231\n*                                                                     * 00232\n*       THIS FUNCTION PERFORMS THE EQUIVALENT OF THE PL/I STATEMENT   * 00232\n*       TARGET = TARGET || SOURCE;                                    * 00233\n*       FOR LONG STRINGS IT IS MUCH FASTER THAN THE PL/I GENERATED    * 00234\n*       CODE.                                                         * 00234\n*                                                                     * 00264\n* INPUTS (*TO FUNCTIONS):                                             * 00264\n*                                                                     * 00236\n*    TARGET -- TARGET STRING TO CONCATINATE TO. (*1,2)                * 00236\n*       THE FIRST PARM IS THE STRING TO BE ADDED TO.  THIS IS A PL/I  * 00237\n*       VARYING CHAR(*) STRING.  THE LOCATOR/DESCRIPTOR IS USED TO    * 00237\n*       EXTRACT THE MAXIMUM LENGTH THE STRING MAY CONTAIN.            * 00237\n*       VALUES: 2 BYTE HEADER, THE LENGTH OF THE STRING FOLLOWED BY   * 00240\n*                     THE TEXT OF THE STRING.                         * 00240\n*                                                                     * 00242\n*    SOURCE -- STRING TO BE ADDED ONTO THE TARGET (*1,2,3)            * 00242\n*       THE SECOND PARAMETER IS THE STRING TO BE ADDED TO THE TARGET. * 00243\n*       THIS IS A PL/I VARING CHAR STRING.                            * 00243\n*       VALUES: 2 BYTE HEADER, THE LENGTH OF THE STRING FOLLOWED BY   * 00245\n*                     THE TEXT OF THE STRING.                         * 00245\n*                                                                     * 00247\n*    MAXCHARS -- MAXIMUM NUMBER OF CHARS TO TRANSFER (*1,2)           * 00247\n*       THE THIRD PARM IS A FIXED BINARY(31) WHICH CONTAINS THE       * 00248\n*       MAXIMUM NUMBER OF CHARACTERS TO TRANSFER.  A MIN FUNCTION IS  * 00248\n*       CALCULATED USING THIS PARM, THE NUMBER OF CHARS IN THE SOUCE  * 00248\n*       STRING AND THE REMAINING SPACE IN THE TARGET STRING.  THE     * 00248\n*       MINIMUN OF THESE THREE VALUES IF THE NUMBER OF CHARACTERS     * 00248\n*       MOVED.                                                        * 00248\n*       VALUES: 0  -  IGNORE THIS PARM                                * 00253\n*               >0 -  MAXIMUM NUMBER OF CHARACTERS TO MOVE            * 00254\n*                                                                     * 00263\n* FUNCTIONS:                                                          * 00263\n*                                                                     * 00263\n*    1. LOAD THE PARMS INTO MEMORY                                    * 00263\n*                                                                     * 00267\n*    2. CALCULATE THE NUMBER OF CHARACTERS TO MOVE.  THIS IS THE      * 00267\n*       MINIMUM OF THE THIRD PARM, THE LENGTH OF THE SOURCE STRING,   * 00267\n*       AND THE SPACE REMAINING IN THE TARGET STRING.                 * 00267\n*                                                                     * 00273\n*    3. MOVE THE CHARACTERS AND UPDATE THE LENGTH OF THE TARGET       * 00273\n*       STRING                                                        * 00273\n*                                                                     * 00274\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00274\n*                                                                     * 00236\n*    TARGET -- TARGET STRING TO CONCATINATE TO. (*3)                  * 00236\n*       THE FIRST PARM IS THE STRING TO BE ADDED TO.  THIS IS A PL/I  * 00237\n*       VARYING CHAR(*) STRING.  THE LOCATOR/DESCRIPTOR IS USED TO    * 00237\n*       EXTRACT THE MAXIMUM LENGTH THE STRING MAY CONTAIN.            * 00237\n*       VALUES: 2 BYTE HEADER, THE LENGTH OF THE STRING FOLLOWED BY   * 00240\n*                     THE TEXT OF THE STRING.                         * 00240\n*                                                                     * 00277\n* NOTES:                                                              * 00277\n*                                                                     * 00277\n*    1. SAMPLE DECLARE                                                * 00277\n*                                                                     * 00278\n*       DECLARE  STRNCAT ENTRY(VARYING CHAR(*),                       * 00278\n*                         VARYING CHAR(*),                            * 00279\n*                         FIXED BINARY(31),                           * 00280\n*                         FIXED BINARY(31)) EXTERNAL;                 * 00281\n*                                                                     * 00282\n*       CALL STRNCAT(TARGET, SOURCE, MAX_CHARS, OVERFLOW_FLAG);       * 00283\n*                                                                     * 00284\n*********************************************************************** 00284\n         SPACE                                                          00285\nSTRNCAT1 AMODE ANY                                                      00085\nSTRNCAT1 RMODE ANY                                                      00086\nSTRNCAT  RENTR WORK=0,BASE=11,PARM=(R10,PLIPARM)                        00286\n         EJECT                                                          00287\n*********************************************************************** 00288\n*                                                                     * 00288\n* LOAD THE PARMS AND DETERMINE HOW MANY CHARACTERS TO MOVE.           * 00288\n*                                                                     * 00290\n*      REGISTER USAGE:                                                * 00290\n*              R2  -> TARGET POSITION TO MOVE THE SOURCE STRING TO    * 00291\n*              R3  -  SPACE REMAINING IN THE TARGET STRING            * 00292\n*              R4  -> SOURCE STRING                                   * 00293\n*              R5  -  MAXCHARS PARM, USED TO CALC THE MIN             * 00294\n*              R6  -> START OF TARGET STRING (LENGTH FIELD)           * 00295\n*              R7  -> MAXCHARS PARM AND THEN OVERFLOW PARM            * 00296\n*                                                                     * 00297\n*********************************************************************** 00297\n         SPACE                                                          00298\n         L     R6,TARGET               POINT TO TARGET L/D              00299\n         LH    R3,4(,R6)               LOAD MAX TARGET LENGTH           00300\n         L     R6,0(,R6)               POINT TO TARGET STRING           00301\n         LA    R2,2(0,R6)              POINT TO TEXT OF STRING          00302\n         AH    R2,0(,R6)               POINT TO FREE SPACE IN TARGET    00303\n         SH    R3,0(,R6)               GET THE SPACE LEFT IN THE STR    00304\n         BNP   OFCHECK                 NO SPACE, CHECK OVERFLOW         00305\n         SPACE                                                          00306\n         L     R4,SOURCE               POINT TO SOURCE L/D              00307\n         L     R4,0(,R4)               POINT TO SOURCE STRING LEN       00308\n         L     R7,MAXCHARS             POINT TO MAX CHARS TO TRANSFER   00309\n         L     R5,0(,R7)               LOAD  MAX CHARS TO TRANSFER      00310\n         L     R7,OVERFLOW             POINT TO OVERFLOW FLAG           00311\n         XC    0(4,R7),0(R7)           CLEAR IT INITIALLY               00312\n         SPACE                                                          00313\n         LTR   R5,R5                   IS THIRD PARM ZERO?              00314\n         BNZ   MAX1                                                     00315\n         SPACE                                                          00316\n         L     R5,=F'32767'            LOAD MAX STRING LEN              00317\n         SPACE                                                          00318\nMAX1     DS    0H                                                       00319\n         LH    R15,0(,R4)              LOAD LEN OF SOURCE STRING        00320\n         LA    R4,2(,R4)               POINT TO TEXT OF STRING          00321\n         CR    R15,R5                  COMPARE SOURCE LEN TO MAX        00322\n         BNL   MAX2                                                     00323\n         SPACE                                                          00324\n         LR    R5,R15                  NEW MAX VALUE                    00325\n         SPACE                                                          00326\nMAX2     DS    0H                                                       00327\n         CR    R5,R3                   WILL MAX FIT?                    00328\n         BNH   MAX3                                                     00329\n         SPACE                                                          00330\n         LR    R5,R3                   NEW MAX VALUE                    00331\n         MVC   0(4,R7),=F'1'           SET OVERFLOW FLAG                00332\n         SPACE                                                          00333\nMAX3     DS    0H                                                       00334\n         LR    R3,R5                   SET 2 VALUES EQUAL               00335\n         LH    R14,0(,R6)              LOAD SOURCE STRING LEN           00336\n         AR    R14,R5                  ADD NEW LEN                      00337\n         STH   R14,0(,R6)              PUT IT BACK                      00338\n         SPACE                                                          00339\n         MVCL  R2,R4                   DO THE MOVE                      00340\n         SPACE                                                          00341\nRETURN   DS    0H                                                       00342\n         REXIT LSA=NO                                                   00343\n         SPACE                                                          00344\nOFCHECK  DS    0H                                                       00345\n         L     R14,OVERFLOW            POINT TO OVERFLOW FLAG           00346\n         MVC   0(4,R14),=F'1'          ASSUME OVERFLOW                  00347\n         L     R15,TARGET              POINT TO TARGET L/D              00348\n         L     R15,0(,R15)             POINT TO TARGET HEADER           00349\n         LH    R15,0(,R15)             GET SOURCE STRING LEN            00350\n         LTR   R15,R15                 IS IT ZERO                       00351\n         BNZ   RETURN                  IF NOT, FLAG THE OVERFLOW        00352\n         SPACE                                                          00353\n         XC    0(4,R14),0(R14)         NO OVERFLOW, NULL SOURCE STRING  00354\n         B     RETURN                                                   00355\n         SPACE                                                          00356\n         DROP  R11                                                      00357\nPLIPARM  DSECT                                                          00358\nTARGET   DS    A                                                        00359\nSOURCE   DS    A                                                        00360\nMAXCHARS DS    A                                                        00361\nOVERFLOW DS    A                                                        00362\n         SYMBAR MODE=DEC                                                00363\n         END                                                            00364\nBCMP     TITLE 'BINARY COMPARE FOR PL/I LIKE FOR C'                     00365\n         PRINT OFF                                                      00366\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00370\n*********************************************************************** 00371\n*                                                                     * 00371\n* SEGMENT NAME:                                                       * 00371\n*                                                                     * 00371\n*    BCMP -- BINARY COMPARE FOR PL/I LIKE FOR C                       * 00371\n*                                                                     * 00372\n*       THIS FUNCTION DOES A QUICK BINARY COMPARE.                    * 00372\n*                                                                     * 00387\n* INPUTS (*TO FUNCTIONS):                                             * 00387\n*                                                                     * 00374\n*    D1 -- DATA AREA 1 - POINTER (*1,2)                               * 00374\n*       THE FIRST PARM IS THE FIRST DATA AREA TO LOOK AT .            * 00375\n*                                                                     * 00376\n*    D2 -- DATA AREA 2 - POINTER (*1,2)                               * 00376\n*       THE SECOND PARM IS THE SECOND DATA AREA TO LOOK AT .          * 00377\n*                                                                     * 00378\n*    LEN -- LENGTH OF THE AREAS - FIXED BINARY(31) (*1,2)             * 00378\n*       THE THIRD PARM IS THE LENGTH OF THE AREA TO COMPARE.          * 00379\n*                                                                     * 00386\n* FUNCTIONS:                                                          * 00386\n*                                                                     * 00386\n*    1. LOAD THE PARMS INTO MEMORY                                    * 00386\n*                                                                     * 00391\n*    2. COMPARE THE TWO STRINGS AND RETURN THE RESULT                 * 00391\n*                                                                     * 00390\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00390\n*                                                                     * 00380\n*    RC -- THE COMPARE RESULT  - FIXED BINARY(31) (*1,2)              * 00380\n*       THE RETURNED VALUE GIVES THE RESULT OF THE COMPARE.           * 00381\n*       VALUES: 0  -  AREAS ARE EQUAL                                 * 00382\n*               1  -  DATA AREA 1 > DATA AREA 2                       * 00383\n*               -1 -  DATA AREA 1 < DATA AREA 2                       * 00384\n*                                                                     * 00397\n* NOTES:                                                              * 00397\n*                                                                     * 00397\n*    1. SAMPLE DECLARE                                                * 00397\n*                                                                     * 00398\n*       DECLARE  BCMP ENTRY(POINTER,                                  * 00398\n*                         POINTER,                                    * 00399\n*                         FIXED BINARY(31))                           * 00400\n*                         RETURNS(FIXED BINARY(31)) EXTERNAL;         * 00401\n*                                                                     * 00402\n*       IF BCMD(ADDR(V1), ADDR(V2), LEN) \u00ac= 0                         * 00403\n*       THEN                                                          * 00404\n*          PUT SKIP LIST('VARS ARE NOT EQUAL');                       * 00405\n*                                                                     * 00406\n*********************************************************************** 00406\n         SPACE                                                          00407\nBCMP1    AMODE ANY                                                      00085\nBCMP1    RMODE ANY                                                      00086\nBCMP     RENTR WORK=0,BASE=11,PARM=(R10,PLIPARMS)                       00408\n         EJECT                                                          00409\n*********************************************************************** 00410\n*                                                                     * 00410\n* LOAD THE PARMS                                                      * 00410\n*                                                                     * 00412\n*      REGISTER USAGE:                                                * 00412\n*              R4  -> AREA 1                                          * 00413\n*              R5  -  LEN                                             * 00414\n*              R6  -> AREA 2                                          * 00415\n*              R7  -  LEN                                             * 00416\n*              R8  -> RETURNED RESULT                                 * 00417\n*                                                                     * 00418\n*********************************************************************** 00418\n         SPACE                                                          00419\n         L     R4,PLID1                                                 00420\n         L     R4,0(,R4)               LOAD ADDR DATA AREA 1            00421\n         L     R6,PLID2                                                 00422\n         L     R6,0(,R6)               LOAD ADDR DATA AREA 2            00423\n         L     R5,PLILEN               POINT TO LEN                     00424\n         L     R5,0(,R5)               LOAD LEN TO COMPARE              00425\n         LR    R7,R5                   TWO COPIES                       00426\n         L     R8,PLIRC                POINT TO OUTPUT AREA             00427\n         SLR   R9,R9                   CLEAR COMPARE RESULT             00428\n         SPACE                                                          00429\n         CLCL  R4,R6                                                    00430\n         BE    RETURN                  ON EQUAL RETURN 0                00431\n         BL    LOW                                                      00432\n         SPACE                                                          00433\n         LA    R9,1                    ON HIGH RETURN 1                 00434\n         B     RETURN                                                   00435\n         SPACE                                                          00436\nLOW      DS    0H                                                       00437\n         L     R9,=F'-1'               ON LOW RETURN -1                 00438\n         SPACE                                                          00439\nRETURN   DS    0H                                                       00440\n         ST    R9,0(,R8)                                                00441\n         REXIT LSA=NO                                                   00442\n         SPACE                                                          00443\n         DROP  R11,R10                                                  00444\nPLIPARMS DSECT                                                          00445\nPLID1    DS    A                                                        00446\nPLID2    DS    A                                                        00447\nPLILEN   DS    A                                                        00448\nPLIRC    DS    A                                                        00449\n         SYMBAR MODE=DEC                                                00450\n         END                                                            00451\nBCOPY    TITLE 'BINARY COPY FOR PL/I LIKE FOR C'                        00452\n         PRINT OFF                                                      00453\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00457\n*********************************************************************** 00458\n*                                                                     * 00458\n* SEGMENT NAME:                                                       * 00458\n*                                                                     * 00458\n*    BCOPY -- BINARY COPY FOR PL/I LIKE FOR C                         * 00458\n*                                                                     * 00459\n*       THIS FUNCTION DOES A QUICK BINARY COPY.                       * 00459\n*                                                                     * 00469\n* INPUTS (*TO FUNCTIONS):                                             * 00469\n*                                                                     * 00461\n*    SOURCE -- DATA AREA 1 - POINTER (*1,2)                           * 00461\n*       THE FIRST PARM IS THE ADDRESS OF THE SOURCE DATA.             * 00462\n*                                                                     * 00463\n*    TARGET -- DATA AREA 2 - POINTER (*1,2)                           * 00463\n*       THE SECOND PARM IS THE ADDRESS OF THE TARGET AREA.            * 00464\n*                                                                     * 00465\n*    LEN -- LENGTH OF THE AREAS - FIXED BINARY(31) (*1,2)             * 00465\n*       THE THIRD PARM IS THE LENGTH OF THE AREA TO COPY.             * 00466\n*                                                                     * 00468\n* FUNCTIONS:                                                          * 00468\n*                                                                     * 00468\n*    1. LOAD THE PARMS INTO MEMORY                                    * 00468\n*                                                                     * 00472\n*    2. COPY THE DATA                                                 * 00472\n*                                                                     * 00477\n* NOTES:                                                              * 00477\n*                                                                     * 00477\n*    1. SAMPLE DECLARE                                                * 00477\n*                                                                     * 00478\n*       DECLARE  BCOPY ENTRY(POINTER,                                 * 00478\n*                         POINTER,                                    * 00479\n*                         FIXED BINARY(31)) EXTERNAL;                 * 00480\n*                                                                     * 00481\n*       CALL BCOPY(ADDR(V1), ADDR(V2), LEN);                          * 00482\n*                                                                     * 00483\n*********************************************************************** 00483\n         SPACE                                                          00484\nBCOPY1   AMODE ANY                                                      00085\nBCOPY1   RMODE ANY                                                      00086\nBCOPY    RENTR WORK=0,BASE=11,PARM=(R10,PLIPARMS)                       00485\n         EJECT                                                          00486\n*********************************************************************** 00487\n*                                                                     * 00487\n* LOAD THE PARMS                                                      * 00487\n*                                                                     * 00489\n*      REGISTER USAGE:                                                * 00489\n*              R4  -> AREA 1                                          * 00490\n*              R5  -  LEN                                             * 00491\n*              R6  -> AREA 2                                          * 00492\n*              R7  -  LEN                                             * 00493\n*                                                                     * 00494\n*********************************************************************** 00494\n         SPACE                                                          00495\n         L     R4,PLID1                                                 00496\n         L     R4,0(,R4)               LOAD ADDR DATA AREA 1            00497\n         L     R6,PLID2                                                 00498\n         L     R6,0(,R6)               LOAD ADDR DATA AREA 2            00499\n         L     R5,PLILEN               POINT TO LEN                     00500\n         L     R5,0(,R5)               LOAD LEN TO COMPARE              00501\n         LR    R7,R5                   TWO COPIES                       00502\n         SPACE                                                          00503\n         MVCL  R6,R4                                                    00504\n         REXIT LSA=NO                                                   00505\n         SPACE                                                          00506\n         DROP  R11,R10                                                  00507\nPLIPARMS DSECT                                                          00508\nPLID1    DS    A                                                        00509\nPLID2    DS    A                                                        00510\nPLILEN   DS    A                                                        00511\n         SYMBAR MODE=DEC                                                00512\n         END                                                            00513\n*          DATA SET FG5002420A AT LEVEL 010 AS OF 02/13/04\n         PRINT OFF                                                      00001\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00005\nREVERSE  TITLE 'PLI FUNCTION TO REVERSE A CHARACTER STRING'             00006\n*********************************************************************** 00012\n*                                                                     * 00012\n* SEGMENT NAME:                                                       * 00012\n*                                                                     * 00012\n*    REVERSE -- PLI FUNCTION TO REVERSE A CHARACTER STRING            * 00012\n*                                                                     * 00024\n* INPUTS (*TO FUNCTIONS):                                             * 00024\n*                                                                     * 00013\n*    SOURCE -- THE STRING TO BE REVERSED (*1,2,3)                     * 00013\n*       THIS IS A PL/I VARYING LENGTH CHARACTER STRING WHOSE          * 00014\n*       CHARACTERS ARE TO BE REVERSED.                                * 00014\n*                                                                     * 00020\n* FUNCTIONS:                                                          * 00020\n*                                                                     * 00020\n*    1. IF THE SOURCE STRING IS LONGER THAT THE MAXIMUM (DECLARED)    * 00020\n*       LENGTH OF THE TARGET STRING, SET UP TO DO THE REVERSE ONLY ON * 00020\n*       THE FIRST 'N' CHARACTERS IN THE SOURCE STRING, WHERE 'N' IS   * 00020\n*       THE DECLARED LENGTH OF THE TARGET STRING.                     * 00020\n*                                                                     * 00025\n*    2. IF THE SOURCE STRING IS LONGER THAT 256 CHARACTERS, REVERSE   * 00025\n*       THE LAST 256 CHARACTERS OF THE SOURCE INTO THE FIRST 256      * 00025\n*       CHARACTERS OF THE TARGET.  REPEAT FOR THE NEXT 256 BYTES      * 00025\n*       UNTIL THERE ARE 256 CHARACTER OR LESS TO PROCESS.             * 00025\n*                                                                     * 00031\n*    3. IF THERE ARE LESS THAT 256 CHARACTERS TO PROCESS, REVERSE THE * 00031\n*       SOURCE TRING INTO THE TARGET STRING                           * 00031\n*                                                                     * 00030\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00030\n*                                                                     * 00016\n*    TARGET -- THE STRING TO BE RETURNED (*2,3)                       * 00016\n*       THIS IS A PL/I VARYING LENGTH CHARACTER STRING INTO WHICH IS  * 00017\n*       PUT THE TARGET STRING WITH THE FIRST LETTER LAST AND THE LAST * 00017\n*       LETTER FIRST.                                                 * 00017\n*                                                                     * 00035\n* NOTES:                                                              * 00035\n*                                                                     * 00035\n*    1. SAMPLE DECLARATION                                            * 00035\n*                                                                     * 00036\n*       DECLARE REVERSE ENTRY(VARYING CHARACTER(*)) RETURNS(VARYING   * 00036\n*       CHARACTER(256)) EXTERNAL;                                     * 00036\n*                                                                     * 00038\n*       IF CHARACTER STRINGS LONGER THAN 256 NEED TO BE REVERSED,     * 00038\n*       THEN THE RETURNS SPECIFICATION MAY BE INCREASED TO WHATEVER   * 00038\n*       IS REQUIRED.                                                  * 00038\n*                                                                     * 00041\n*       SAMPLE CALL:                                                  * 00041\n*       STRING_A = REVERSE(STRING_B);                                 * 00042\n*                                                                     * 00043\n*    2. THE REVERSE IS DONE USING AN ALGORITHM FROM GRIZWOLDS BOOK    * 00043\n*       \"ALGORITHMS IN SNOBOL 4\".  EACH 256 BYTES OR LESS OF THE      * 00043\n*       TARGET IS INITIALIZED WITH THE REQUIRED NUMBER OF CHARACTERS  * 00043\n*       FROM THE REVERSE EBCIDIC STRING.  THIS NUMBER IS EQUAL TO THE * 00043\n*       LENGTH OF THE SOURCE STRING AND IS TAKEN SO AS TO INCLUDE THE * 00043\n*       LAST CHARACTER IN THE STRING.  E.I.  IF TEN CHARACTERS ARE    * 00043\n*       REQUIRED, THE LAST TEN IN THE REVERSE EBCDIC STRING.  THE     * 00043\n*       EBCIDIC STRING IS STRING OF HEX CHARACTERS STARTING WITH      * 00043\n*       X'FF' AND GOING DOWN TO X'00'.  THE INITIALIZED TARGET IS     * 00043\n*       THEN USED AS THE FIRST OPERAND OF A TRANSLATE INSTRUCTION AND * 00043\n*       THE SOURCE STRING IS USED AS THE SECOND OPERAND.              * 00043\n*                                                                     * 00054\n*    3. ISSUE HISTORY:                                                * 00054\n*                                                                     * 00055\n         EJECT\n*       ISSUE 02:                                                     * 00055\n*       CHANGE THE INCLUDES TO INCLUDE PLRENTR AND PLREXIT.  THIS     * 00056\n*       ROUTINE IS ONLY CALLED FROM PL/I AND THE NEW FORM OF THESE    * 00056\n*       MACROS DOES NOT USE GETMAIN FREEMAIN.  PL/I'S STACK IS USED   * 00056\n*       INSTEAD.                                                      * 00056\n*                                                                     * 00059\n*       REASON FOR ISSUE 02:  02/13/2004                              * 00059\n*       ADD AMODE AND RMODE CARDS TO GET RID OF LINKER MESSAGES       * 00060\n*                                                                     * 00061\n*********************************************************************** 00061\n         SPACE                                                          00062\nREVERSE1 AMODE ANY                                                      00063\nREVERSE1 RMODE ANY                                                      00064\nREVERSE  RENTR  BASE=11,PARM=(10,PLIPARMS)                              00065\n         EJECT                                                          00066\n*********************************************************************** 00076\n*                                                                     * 00076\n* GET THE CURRENT LENGTH OF THE SOURCE STRING AND THE MAXIMUM LENGTH  * 00076\n* OF THE TARGET STRING.  USE THE MINIMUM AS THE LENGTH TO BE          * 00076\n* PROCESSED.  IF THE TARGET IS TO SHORT, ONLY THE FIRST CHARACTERS IN * 00076\n* THE SOURCE WILL BE USED.                                            * 00076\n*                                                                     * 00081\n*      REGISTER USAGE:                                                * 00081\n*              R7  -> NEXT SOURCE TEXT TO BE PROCESSED                * 00082\n*              R8  -> JUST PAST THE NEXT TARGET SOURCE TO BE          * 00082\n*                     PROCESSED                                       * 00082\n*              R9  -  LENGTH OF THE SOURCE STRING LEFT TO PROCESS     * 00082\n*              R10 -> PARM LIST FROM PL/I                             * 00082\n*              R11 -  BASE FOR PROGRAM                                * 00082\n*              R12 -> PLI TASK COMMUNICATIONS AREA  -  DO NOT MODIFY  * 00082\n*              R13 -> DYNAMIC SAVE AREA                               * 00082\n*              R15 -  WORK REGISTER                                   * 00083\n*                                                                     * 00084\n*********************************************************************** 00084\n         SPACE                                                          00085\n         L     R15,PLIFROM    POINT TO THE SOURCE PARM L/D              00086\n         L     R15,0(R15)     POINT TO THE SOURCE STRING                00087\n         LH    R9,0(R15)      GET SOURCE STIRNG CURRENT LENGTH          00088\n         LA    R7,2(R15)      SAVE THE ADDR OF THE BEGINNING OF THE     00089\n*                             SOURCE TEXT                               00090\n         SPACE                                                          00091\n         L     R15,PLITO      POINT TO THE TARGET PARM L/D              00092\n         CH    R9,4(R15)      COMPARE THE SOURCE LENGTH TO THE          00093\n*                             DECLARED LENGTH OF THE TARGET.            00094\n         BNH   SOURCEOK       IF THE TARGET IS LONG ENOUGH, THE         00095\n*                             SOURCE LENGTH IS THE ONE TO USE.          00096\n         SPACE                                                          00097\n         LH    R9,4(R15)      IF THE TARGET IS TO SHORT, ONLY USE       00098\n*                             THE FIRST TARGET_LENGTH CHARACTERS        00099\n         SPACE                                                          00100\nSOURCEOK DS    0H                                                       00101\n         L     R8,0(R15)      POINT TO THE TARGET STRING                00102\n         STH   R9,0(R8)       STORE THE LENGTH OF THE TARGET STRING     00103\n*                             IN THE STRING'S 2 BYTE HEADER.            00104\n         LA    R8,2(R9,R8)    POINT TO JUST PAST THE PORTION OF THE     00105\n*                             TARGET STRING TO BE USED.                 00106\n         EJECT                                                          00107\n*********************************************************************** 00108\n*                                                                     * 00108\n* CHECK IF THE AMOUNT OF SOURCE STRING LENF TO PROCESS IS LESS THAN   * 00108\n* OR EQUAL TO 256 CHARACTERS.  IF SO, GO PROCESS THE REMAINING AMOUNT * 00108\n* OF THE STRING.  IF THERE ARE MORE THAN 256 CHARACTERS TO BE         * 00108\n* PROCESSED, PROCESS 256 OF THEM AND SEE HOW MUCH IS LEFT.            * 00108\n*                                                                     * 00114\n*      REGISTER USAGE:                                                * 00114\n*              R7  -> NEXT SOURCE TEXT TO BE PROCESSED                * 00115\n*              R8  -> JUST PAST THE NEXT TARGET SOURCE TO BE          * 00115\n*                     PROCESSED                                       * 00115\n*              R9  -  LENGTH OF THE SOURCE STRING LEFT TO PROCESS     * 00115\n*              R10 -> PARM LIST FROM PL/I                             * 00115\n*              R11 -  BASE FOR PROGRAM                                * 00115\n*              R12 -> PLI TASK COMMUNICATIONS AREA  -  DO NOT MODIFY  * 00115\n*              R13 -> DYNAMIC SAVE AREA                               * 00115\n*                                                                     * 00116\n*********************************************************************** 00116\n         SPACE                                                          00117\nTESTLEN  DS    0H                                                       00118\n         CH    R9,=H'256'     IS THE STRING MORE THAN 256 CHARACTERS?   00119\n         BNH   LASTREV        IF NOT, GO DO THE WHOLE STRING.           00120\n         SPACE 5                                                        00121\nPROC256  DS    0H                                                       00122\n         SH    R8,=H'256'     MOVE BACK 256 CHARACTERS FROM THE END     00123\n*                             OF THE STRING                             00124\n         MVC   0(256,R8),REVERSES    MOVE IN THE REVERSING STRING       00125\n         TR    0(256,R8),0(R7)       AND REVERSE IN THE FIRST 256       00126\n*                                    BYTES OF THE SOURCE INTO THE LAST  00127\n*                                    256 BYTES OF THE TARGET.           00128\n         SPACE                                                          00129\n         LA    R7,256(R7)            MOVE THE SOURCE POINTER            00130\n         SH    R9,=H'256'            REDUCE THE LENGTH TO BE PROCESSED  00131\n         B     TESTLEN               AND GO BACK FOR MORE               00132\n         EJECT                                                          00133\n*********************************************************************** 00134\n*                                                                     * 00134\n* FOR STRINGS LESS THAN 256 CHRACTERS THE LAST 'N' BYTES OF THE       * 00134\n* REVERSING STRING ARE MOVED INTO THE TARGET.  'N' IS LENGTH OF THE   * 00134\n* SOURCE STRING.  THE TRANSLATE IS THEN EXECUTED FOR THE LENGTH OF    * 00134\n* THE SOURCE TO BE PROCESSED.                                         * 00134\n*                                                                     * 00139\n*      REGISTER USAGE:                                                * 00139\n*              R7  -> NEXT SOURCE TEXT TO BE PROCESSED                * 00140\n*              R8  -> JUST PAST THE NEXT TARGET SOURCE TO BE          * 00140\n*                     PROCESSED                                       * 00140\n*              R9  -  LENGTH OF THE SOURCE STRING LEFT TO PROCESS     * 00140\n*              R10 -> PARM LIST FROM PL/I                             * 00140\n*              R11 -  BASE FOR PROGRAM                                * 00140\n*              R12 -> PLI TASK COMMUNICATIONS AREA  -  DO NOT MODIFY  * 00140\n*              R13 -> DYNAMIC SAVE AREA                               * 00140\n*                                                                     * 00141\n*********************************************************************** 00141\n         SPACE                                                          00142\nLASTREV  DS    0H                                                       00143\n         SR    R8,R9          POINT TO FRONT OF TARGET STRING           00144\n         LA    R15,REVERSES+256    POINT JUST PAST REVERSES             00145\n         SR    R15,R9         BACK UP NEEDED NUMBER OF BYTES            00146\n         SPACE                                                          00147\n         BCTR  R9,0           SUBTRACT 1 FROM LENGTH FOR EXEC INSTR     00148\n         SPACE                                                          00149\n         EX    R9,MOVEREV     MOVE IN THE REVERSING STRING              00150\n         EX    R9,TRANREV     REVERSE THE STRING                        00151\n         SPACE 2                                                        00152\n*********************************************************************** 00153\n*                                                                     * 00153\n* GO BACK TO PL/I                                                     * 00153\n*                                                                     * 00155\n*********************************************************************** 00155\n         SPACE                                                          00156\n         REXIT                                                          00157\n         EJECT                                                          00158\n*********************************************************************** 00159\n*                                                                     * 00160\n*                            CONSTANT DATA                            * 00160\n*                                                                     * 00161\n*********************************************************************** 00161\n         SPACE                                                          00162\nMOVEREV  MVC   0(*-*,R8),0(R15)      MOVE REVERSING STRING              00163\nTRANREV  TR    0(*-*,R8),0(R7)       REVERSE STRING                     00164\n         SPACE 2                                                        00165\nREVERSES DC    XL16'FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0'                   00166\n         DC    XL16'EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0'                   00167\n         DC    XL16'DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0'                   00168\n         DC    XL16'CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0'                   00169\n         DC    XL16'BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0'                   00170\n         DC    XL16'AFAEADACABAAA9A8A7A6A5A4A3A2A1A0'                   00171\n         DC    XL16'9F9E9D9C9B9A99989796959493929190'                   00172\n         DC    XL16'8F8E8D8C8B8A89888786858483828180'                   00173\n         DC    XL16'7F7E7D7C7B7A79787776757473727170'                   00174\n         DC    XL16'6F6E6D6C6B6A69686766656463626160'                   00175\n         DC    XL16'5F5E5D5C5B5A59585756555453525150'                   00176\n         DC    XL16'4F4E4D4C4B4A49484746454443424140'                   00177\n         DC    XL16'3F3E3D3C3B3A39383736353433323130'                   00178\n         DC    XL16'2F2E2D2C2B2A29282726252423222120'                   00179\n         DC    XL16'1F1E1D1C1B1A19181716151413121110'                   00180\n         DC    XL16'0F0E0D0C0B0A09080706050403020100'                   00181\n         SPACE 5                                                        00182\n*********************************************************************** 00183\n*                                                                     * 00183\n* PLI DSECT                                                           * 00183\n*                                                                     * 00185\n*********************************************************************** 00185\nPLIPARMS DSECT                                                          00186\nPLIFROM  DS    A            POINTS TO SOURCE PARM LOCATOR DESCRIPTOR    00187\nPLITO    DS    A            POINTS TO TARGET PARM LOCATOR DESCRIPTOR    00188\n         SPACE 3                                                        00189\n         SYMBAR MODE=DEC                                                00190\n         END                                                            00191\n*          DATA SET FG50111102 AT LEVEL 005 AS OF 11/14/03\nSWAREQ   TITLE 'SWAREQ_RL_INVOCATION_ROUTINE'                           00001\n         PRINT OFF                                                      00002\n*          DATA SET PLRENTR    AT LEVEL 000 AS OF 05/18/04\n         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*          PASS 0 OR NULL TO OMIT A LOWER SAVE AREA\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*ACSECT  RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART\n.*\n.* CHANGE 05/18/2004. CHANGE CODE FOR OVERFLOW ROUTINE PER PL/I CODE\n.*\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO CEESTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN CEESTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(CEESTART)\n         L     15,*-4         LOAD CEESTART ADDR\n         LTR   15,15          IS CEESTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         L     14,72(0,13)\n         LR    15,0\n         STM   14,0,72(1)     STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LA    13,0(1,0)      POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n*          DATA SET PLREXIT    AT LEVEL 000 AS OF 10/09/03\n         MACRO ,                                                        00001\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI                      00002\n.*                                                                      00003\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM                00004\n.*    ENTERED WITH THE RENTR MACRO                                      00005\n.*                                                                      00006\n.*   PARMS:                                                             00007\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA    00008\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE                00009\n.*                                                                      00010\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE          00011\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE       00012\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15            00013\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX      00014\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.              00015\n.*                                                                      00016\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS           00017\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS          00018\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM             00019\n.*                                                                      00020\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)     00021\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING         00022\n.*          ROUTINE.                                                    00023\n.*                                                                      00024\n.*                                                                      00025\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR                         00026\n.*          VALUES:                                                     00027\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE      00028\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA        00029\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN   00030\n.*                 FOR THE DSA AND WORK AREA.                           00031\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I          00032\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.   00033\n.*                 IF NOT, USE A GETMAIN                                00034\n.*                                                                      00035\n.*                                                                      00036\n.* SAMPLE:                                                              00037\n.*RET     REXIT RC=(15)                                                 00038\n.*                                                                      00039\n.*                                                                      00040\n.* CHANGE 10/9/2003.  FOR ENV=BOTH, USE CEESTART INSTEAD OF PLISTART    00041\n.*                                                                      00042\n.*                                                                      00043\n         GBLC  &@LWRWKL                                                 00044\n         GBLA  &@RENTR1                                                 00045\n         LCLC  &LCLENV,&IDX                                             00046\n.*                                                                      00047\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV         00048\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD           00049\n.*                                                                      00050\n&IDX     SETC  '&SYSNDX'                                                00051\n&LCLENV  SETC  '&ENV'                                                   00052\n         AIF   ('&ENV' EQ 'IPCS').ENVOK                                 00053\n         AIF   ('&ENV' EQ 'BOTH').ENVOK                                 00054\n         AIF   ('&ENV' EQ 'OS').ENVOK                                   00055\n         AIF   ('&ENV' EQ 'PLI').ENVOK                                  00056\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'             00057\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'                 00058\n&LCLENV  SETC  'BOTH'                                                   00059\n.ENVOK   ANOP                                                           00060\n.*                                                                      00061\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE      00062\n.*       THE ENV PARM TO THIS VALUE.                                    00063\n.*                                                                      00064\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X00065\n               ('&SYSPARM' NE 'PLI') AND                               X00066\n               ('&SYSPARM' NE 'IPCS') AND                              X00067\n               ('&SYSPARM' NE 'OS')).LSACHK                             00068\n&LCLENV  SETC  '&SYSPARM'                                               00069\n.LSACHK  ANOP                                                           00070\n.*                                                                      00071\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE           00072\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK       00073\n.*       UP ONE SAVE AREA.                                              00074\n.*                                                                      00075\n         AIF   ('&LSA' EQ 'NO').NOLEN                                   00076\n.*                                                                      00077\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.        00078\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),        00079\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET       00080\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT         00081\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE             00082\n.*                                                                      00083\n         AIF   ('&LABL' EQ '').NOLABL                                   00084\n&LABL    DS    0H                                                       00085\n.NOLABL  ANOP                                                           00086\n         LA    1,0(0,13)           WORK AREA ADDRESS                    00087\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS                00088\n.*                                                                      00089\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN    00090\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00091\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00092\n.*                                                                      00093\n         AIF   ('&RETURN' EQ '').NORET                                  00094\n         AIF   ('&RETURN'(1,1) NE '(').NORET                            00095\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM               00096\n.NORET   ANOP                                                           00097\n.*                                                                      00098\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR       00099\n.*       DOING THE FREEMAIN                                             00100\n.*                                                                      00101\n         AIF   ('&LCLENV' EQ 'PLI').PLI1                                00102\n         L     14,16(0,13)         GET ORIG ENTRY POINT                 00103\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)     00104\n.*                                                                      00105\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN        00106\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT              00107\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.              00108\n.*                                                                      00109\n.PLI1    ANOP                                                           00110\n         AIF   ('&RC' EQ '').RCNREG                                     00111\n         AIF   ('&RC'(1,1) NE '(').RCNREG                               00112\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE                     00113\n.RCNREG  ANOP  ,                                                        00114\n.*                                                                      00115\n.*       DO FREEMAIN PROCESSING IF WE NEED TO                           00116\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH      00117\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO CEESTART IS    00118\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE      00119\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL        00120\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES. 00121\n.*                                                                      00122\n         AIF   ('&LCLENV' EQ 'PLI').CKRC                                00123\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH                             00124\n         AIF   (&@RENTR1 NE 0).NOWXTRN                                  00125\n         WXTRN CEESTART                                                 00126\n&@RENTR1 SETA  1                                                        00127\n.NOWXTRN ANOP                                                           00128\n         CNOP  0,4                                                      00129\n         B     *+8            SKIP ADDRESS CONSTANT                     00130\n         DC    V(CEESTART)                                              00131\n         L     15,*-4         LOAD CEESTART ADDR                        00132\n         LTR   15,15          IS CEESTART LINKED IN?                    00133\n         BNZ   PL1&IDX                                                  00134\n.NOBOTH  ANOP                                                           00135\n         FREEMAIN R,LV=(0),A=(1)                                        00136\n.CKRC    ANOP                                                           00137\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1                            00138\nPL1&IDX  DS    0H                                                       00139\n.NOBOTH1 ANOP                                                           00140\n.*                                                                      00141\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS             00142\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.  00143\n.*                                                                      00144\n         LM    14,12,12(13)        RESTORE REGISTERS                    00145\n         AIF   ('&RC' EQ '').NORC                                       00146\n         AIF   ('&RC'(1,1) EQ '(').NORC                                 00147\n         AIF   ('&RC' EQ '0').ZERORC                                    00148\n         LA    15,&RC              SET RETURN CODE                      00149\n         AGO   .NORC                                                    00150\n.ZERORC  SLR   15,15               ZERO RETURN CODE                     00151\n.NORC    AIF   ('&T' NE 'T').NOT                                        00152\n         MVI   12(13),X'FF'        SET RETURN INDICATION                00153\n.NOT     BR    14                  RETURN                               00154\n         MEXIT                                                          00155\n.*                                                                      00156\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.    00157\n.*                                                                      00158\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB                                    00159\n&LABL    DS    0H                                                       00160\n.NOLAB   ANOP  ,                                                        00161\n         AIF   ('&RC'(1,1) NE '(').CKRC                                 00162\n         AIF   ('&RC' EQ '(15)').RC15                                   00163\n         LR    15,&RC(1)           LOAD RETURN CODE                     00164\n.RC15    L     14,12(0,13)         RESTORE R14                          00165\n         LM    2,12,28(13)         RESTORE R2-R12                       00166\n         AGO   .NORC                                                    00167\n         MEND  , REXIT                                   RES 09/86      00168\n*          DATA SET SYMBAR     AT LEVEL 000 AS OF 02/13/90\n         MACRO                                                          00001\n         SYMBAR &MODE=DEC                                               00002\nR0       EQU   0  PARAMETER PASSING REG./UTILITY                        00003\nR1       EQU   1  PARAMETER PASSING REG./UTILITY                        00004\nR2       EQU   2  UTILITY                                               00005\nR3       EQU   3  UTILITY                                               00006\nR4       EQU   4  UTILITY                                               00007\nR5       EQU   5  UTILITY                                               00008\nR6       EQU   6  UTILITY                                               00009\nR7       EQU   7  UTILITY                                               00010\nR8       EQU   8 UTILITY                                                00011\nR9       EQU   9  UTILITY                                               00012\n         AIF   (K'&MODE NE 3).MHEX                                      00013\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX                              00014\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC                              00015\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''              00016\n.HEX     ANOP                                                           00017\nRA       EQU   10 UTILITY                                               00018\nRB       EQU   11 UTILITY                                               00019\nRC       EQU   12 UTILITY                                               00020\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00021\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00022\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00023\n         AGO   .END                                                     00024\n.DEC     ANOP                                                           00025\nR10      EQU   10 UTILITY                                               00026\nR11      EQU   11 UTILITY                                               00027\nR12      EQU   12 UTILITY                                               00028\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS                   00029\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS                      00030\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS                 00031\n.END     MEND                                                           00032\n         PRINT ON                                                       00006\n*********************************************************************** 00008\n*                                                                     * 00008\n* SEGMENT NAME:                                                       * 00008\n*                                                                     * 00008\n*    SWAREQ -- SWAREQ_RL_INVOCATION_ROUTINE                           * 00008\n*                                                                     * 00027\n* INPUTS (*TO FUNCTIONS):                                             * 00027\n*                                                                     * 00009\n*    SWATOK -- SWA (SCHEDULER WORK AREA) TOKEN (*1)                   * 00009\n*       THE PARM TO THIS ROUTINE IS THE ADDRESS OF THE 3 BYTE TOKEN   * 00010\n*       REPRESENTING THE SWA CONTROL BLOCK.  IN PRE-ESA DAYS, THIS    * 00010\n*       WAS THE THREE BYTE ADDRESS.  NOW, WITH THE SWA ABOVE THE 16   * 00010\n*       MEGABYTE LINE. THIS IS A THREE BYTE TOKEN.  ON ENTRY R1       * 00010\n*       POINTS TO THE 3 BYTE TOKEN.                                   * 00010\n*                                                                     * 00026\n* FUNCTIONS:                                                          * 00026\n*                                                                     * 00026\n*    1. BUILD THE SWAREQ PARM LIST AND EPA WORK AREA.                 * 00026\n*                                                                     * 00028\n*    2. CALL SWAREQ TO CONVERT THE TOKEN INTO AN ADDRESS              * 00028\n*                                                                     * 00029\n* OUTPUTS (*FROM FUNCTIONS):                                          * 00029\n*                                                                     * 00016\n*    ADDR -- CONTROL BLOCK ADDRESS (*2)                               * 00016\n*       THE CONTROL BLOCK ADDRESS IS RETURNED IN REGISTER R0.         * 00017\n*                                                                     * 00019\n*    RC -- RETURN CODE (*2)                                           * 00019\n*       THE RETURN CODE FROM SWAREQ IS RETURNED IN REGISTER R15.      * 00020\n*       VALUES: 00  -  CONVERSION WORKED                              * 00021\n*               08  -  INVALID SVA IN THE SWA PREFIX                  * 00022\n*               24  -  (HEX) ATTEMPT TO READ A BLOCK NOT YET WRITTEN  * 00023\n*               28  -  (HEX) INVALID POINTER TO THE EPA               * 00024\n*                                                                     * 00032\n* NOTES:                                                              * 00032\n*                                                                     * 00032\n*    1. THIS ROUTINE SUPPORTS BEING CALLED IN A PL/I ENVIRONMENT, BUT * 00032\n*       IS DESIGNED TO BE CALLED FROM ASSEMBLER.                      * 00032\n*                                                                     * 00035\n*    2. ISSUE HISTORY:                                                * 00035\n*                                                                     * 00036\n*       REASON FOR ISSUE 01:  3/30/92                                 * 00036\n*       INITIAL RELEASE                                               * 00037\n*                                                                     * 00038\n*       REASON FOR ISSUE 02:  11/14/2003                              * 00038\n*       ADD AMODE AND RMODE LINES TO GET RID OF LINKER MESSAGES       * 00039\n*                                                                     * 00040\n*********************************************************************** 00040\n         EJECT                                                          00041\nSWAREQ1  AMODE 31                                                       00042\nSWAREQ1  RMODE ANY                                                      00043\nSWAREQ   RENTR  BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA),ENV=BOTH        00044\n         MVC   SWALIST(SWALEN),CONSWA   INITIALIZE SWA PARM LIST        00045\n         XC    EPAAREA(EPALEN),EPAAREA  ZERO OUT THE EPA                00046\n         LA    R3,EPAAREA               POINT TO THE EPA                00047\n         ST    R3,EPAPTR                SAVE THE ADDRESS                00048\n         USING SWAEPA,R3                ADDRESS THE EPA SYMBOLICLY      00049\n         SPACE                                                          00050\n         MVC   SWVA(3),0(R10)           COPY THE SWA BLOCK TOKEN        00051\n         SPACE                                                          00052\n         SWAREQ FCODE=RL,EPA=EPAPTR,UNAUTH=YES,MF=(E,SWALIST)           00053\n         SPACE                                                          00054\n         L     R0,SWBLKPTR              GET THE 31 BIT ADDR OF THE JFCB 00055\nRETURN   DS    0H                                                       00056\n         REXIT ENV=BOTH,RETURN=(0),RC=(15)                              00057\n         DROP  R3,R11                                                   00058\n         SPACE                                                          00059\nCONSWA   SWAREQ FCODE=RL,MF=L                                           00060\nSWALEN   EQU   *-CONSWA                                                 00061\n         LTORG                                                          00062\nWORKAREA DSECT                                                          00063\n         DS    26F                                                      00064\n         DS    0F                                                       00065\nEPAPTR   DS    A                                                        00066\nSWALIST  DS    XL(SWALEN)                                               00067\nEPAAREA  DS    XL(EPALEN)                                               00068\n         DS    0D                                                       00069\nWORKLEN  EQU   *-WORKAREA                                               00070\nEPALEN   EQU   L'SWAEPAX                                                00071\n         SPACE 3                                                        00072\n         PRINT NOGEN                                                    00073\n         CVT   DSECT=YES                                                00074\n         SPACE                                                          00075\n         IEFZB505 LOCEPAX=YES                                           00076\n         SPACE                                                          00077\n         IEFJESCT                                                       00078\n         SPACE                                                          00079\n         SYMBAR MODE=DEC                                                00080\n         END                                                            00081\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COS001A": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x07\\x18\\x00\\x04\\x00\\x04\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T07:18:19", "lines": 4, "newlines": 4, "modlines": 0, "user": "QC22505"}, "text": "!rm -f /faketape/COS001.tape.000011\n+! cp /faketape/backup/mt/tape.000011 /faketape/COS001.tape.000011\nmount 0570 offline\nmount 0570 /faketape/COS001.tape.000011\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COS001B": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x07\\x18\\x00\\x04\\x00\\x04\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T07:18:33", "lines": 4, "newlines": 4, "modlines": 0, "user": "QC22505"}, "text": "mount 0570 offline\n!/bin/rm -f /faketape/COS001.tape.000011.gz\n!/bin/gzip /faketape/COS001.tape.000011\n!mv /faketape/COS001.tape.000011.gz /nfstape/COS001.tape.000011.gz\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSSDUMP": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x07\\x19\\x00\\x01\\x00\\x01\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T07:19:01", "lines": 1, "newlines": 1, "modlines": 0, "user": "QC22505"}, "text": "  DUMP FULL INDDNAME(DASD) OUTDDNAME(TAPE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LINKDATE": {"ttr": 6413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x06V\\x029\\x029\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T06:56:14", "lines": 569, "newlines": 569, "modlines": 0, "user": "QC22505"}, "text": "*          DATA SET FG16000302 AT LEVEL 017 AS OF 12/12/03\nLINKDATE TITLE 'LINK EDITOR INTERFACE - DATE/TIME STAMP LOAD MODULES'   00001\n         PRINT OFF                                                      00002\n*          DATA SET ENTER      AT LEVEL 000 AS OF 12/12/03\n         MACRO                                                          00001\n&NAME    ENTER &R,&FPR,&SAVE=,&BASE=,&SPIE=YES,&ID=YES,&BASE2=0         00002\n         LCLA  &SIZE,&SIZE1,&SIZE2                                      00003\n         LCLC  &BASE1,&BR(06),&HOLD,&SPIE1                              00004\n.*                                                                      00005\n.*       AUTHOR - GARY R. KOENIG                                        00006\n.*                                                                      00007\n.*       DATE - SEPTEMBER 25, 1969                                      00008\n.*                                                                      00009\n.*       FUNCTION - THE ENTER MACRO IS USED IN ASSEMBLER ROUTINES TO    00010\n.*         SAVE CODING THE REGISTER EQUATES, THE SAVING OF REGISTERS,   00011\n.*         ESTABLISHING A BASE REGISTER, ESTABLISHING A NEW SAVE AREA   00012\n.*         AND CROSS-LINKING WITH THE OLD SAVE AREA.  A STATIC OR A     00013\n.*         DYNAMIC SAVE AREA CAN BE GENERATED BY THE MACRO OR THE AD-   00014\n.*         DRESS OF A SAVE AREA OUTSIDE THE MACRO CAN BE USED.  THE     00015\n.*         ENTER MACRO ALSO INSERTS THE PROGRAM IDENTIFICATION FOR THE  00016\n.*         ABEND/DUMP ROUTINE.  THE SPIE MACRO IS ALSO ISSUED TO ALLOW  00017\n.*         ASSEMBLER SUBROUTINES TO BE LINKED WITH COMPILER LEVEL       00018\n.*         LANGUAGES.                                                   00019\n.*                                                                      00020\n.*       CODING - ENTER IS CODED INTO THE ASSEMBLER PROGRAM ACCORDING   00021\n.*         TO THE RULES OF MACRO INSERTION.  IT HAS TWO POSITIONAL      00022\n.*         PARAMETERS AND FOUR KEYWORD PARAMETERS AS FOLLOWS:           00023\n.*         1)  THE FIRST POSITIONAL PARAMETER (P/P) IS AN ALPHA-NUMERIC 00024\n.*           VARIABLE (1 TO 6 CHARACTERS LONG) USED FOR GENERAL-PURPOSE 00025\n.*           REGISTER EQUATES.  IF THIS PARAMETER IS OMITTED NO EQUATES 00026\n.*           ARE MADE.                                                  00027\n.*         2)  THE SECOND P/P IS THE SAME AS THE FIRST AND IS USED FOR  00028\n.*           FLOATING-POINT REGISTER EQUATES.                           00029\n.*         3)  THE &SAVE KEYWORD PARAMETER (K/P) CAN BE CODED &SAVE=XXX 00030\n.*           IN WHICH CASE THE ENTER MACRO WILL USE THE LOCATION AD-    00031\n.*           DRESSED BY XXX TO STORE THE REGISTERS.  IF &SAVE=RENT IS   00032\n.*           CODED, A DYNAMIC AREA WILL BE GENERATED USING A GETMAIN    00033\n.*           MACRO INSTRUCTION.  IF &SAVE IS OMITTED OR IS NULL, AN IN- 00034\n.*           TERNAL STATIC SAVE AREA WILL BE GENERATED WITH NO LABEL.   00035\n.*         4)  THE &BASE K/P IS USED TO DEFINE WHICH REGISTER IS TO BE  00036\n.*           USED FOR A BASE REGISTER.  IF &BASE IS NOT CODED AND A     00037\n.*           STATIC SAVE AREA WAS GENERATED BY THE PROGRAM, REGISTER 13 00038\n.*           WILL BE USED FOR BOTH THE ADDRESS OF THE SAVE AREA AND THE 00039\n.*           BASE REGISTER.  IF &BASE IS NOT CODED AND A STATIC SAVE    00040\n.*           AREA WAS NOT GENERATED BY THE MACRO, REGISTER 12 WILL BE   00041\n.*           USED AS THE BASE REGISTER.  IF &BASE=15 IS CODED, REGISTER 00042\n.*           15 WILL BE USED AS A BASE REGISTER, THE REGISTERS WILL BE  00043\n.*           STORED BUT NO NEW SAVE AREA WILL BE GENERATED NOR THE      00044\n.*           CROSS-LINKING OF THE SAVE AREAS UNLESS &SAVE=XXX IS EXPLI- 00045\n.*           CITLY CODED.  IF &BASE=14 IS CODED THIS WOULD CAUSE ERRORS 00046\n.*           SO REGISTER 12 OR 13 WILL BE USED ACCORDING TO THE &SAVE   00047\n.*           K/P.                                                       00048\n.*         5)  THE &SPIE K/P IS USED TO CONTROL GENERATION OF THE SPIE  00049\n.*           MACRO.  IF &SPIE=NO IS CODED, NO SPIE MACRO WILL BE GENER- 00050\n.*           ATED.  IF &SPIE=YES IS CODED OR &SPIE IS OMITTED, THE SPIE 00051\n.*           MACRO WILL BE GENERATED FOR SYSTEM ACTION ON ALL INTER-    00052\n.*           RUPTS.  IF AN INTERRUPTION EXIT ADDRESS IS DESIRED ALONG   00053\n.*           WITH DESIGNATED INTERRUPTION TYPES, THEY SHOULD BE CODED   00054\n.*           ACCORDING TO THE RULES OF THE SPIE MACRO BUT INSERTED IN   00055\n.*           AN EXTRA SET OF PARENTHESES.                               00056\n.*           EX:  &SPIE=(SPIEXIT,((7,9),15))                            00057\n.*         6)  THE &ID K/P IS USED TO CONTROL GENERATION OF THE PROGRAM 00058\n.*           IDENTIFICATION FOR ABEND/DUMP ROUTINE AT OFFSET +4 FROM    00059\n.*           THE BEGINNING OF THE CSECT.  IF &ID=NO IS CODED, THE IDEN- 00060\n.*           TIFICATION WILL NOT BE GENERATED.  IF &ID=YES IS CODED OR  00061\n.*           &ID IS OMITTED, THE IDENTIFICATION WILL BE GENERATED.      00062\n&BASE1   SETC  '&BASE'                                                  00063\n&HOLD    SETC  '&R'.'2'                                                 00064\n&SPIE1   SETC  '&SPIE'                                                  00065\n         AIF   ('&BASE' NE '15' AND '&BASE' NE '1').C0                  00066\n&SPIE1   SETC  'NO'                                                     00067\n         AGO   .C2                                                      00068\n.C0      AIF   ('&BASE1' NE '2').C1                                     00069\n&HOLD    SETC  '&R'.'3'                                                 00070\n         AGO   .C2                                                      00071\n.C1      AIF  ('&BASE' NE '14' AND '&BASE' NE '0' AND '&BASE' NE '').C3 00072\n&BASE1   SETC  '13'                                                     00073\n.C2      AIF   ('&BASE1' NE '13' OR '&SAVE' EQ '').C3                   00074\n&BASE1   SETC  '12'                                                     00075\n.C3      AIF   ('&R' EQ '').C4                                          00076\n         MNOTE *,'GENERAL PURPOSE REGISTER EQUATES'                     00077\n         MNOTE *,'     REGISTER &BASE1 IS THE BASE'                     00078\n         AIF   ('&BASE2' EQ '0').D3                                     00079\n         MNOTE *,'  REGISTER &BASE2 IS THE SECOND BASE'                 00080\n.D3      ANOP                                                           00081\n&R.0     EQU   0                                                        00082\n&R.1     EQU   1                                                        00083\n&R.2     EQU   2                                                        00084\n&R.3     EQU   3                                                        00085\n&R.4     EQU   4                                                        00086\n&R.5     EQU   5                                                        00087\n&R.6     EQU   6                                                        00088\n&R.7     EQU   7                                                        00089\n&R.8     EQU   8                                                        00090\n&R.9     EQU   9                                                        00091\n&R.10    EQU   10                                                       00092\n&R.11    EQU   11                                                       00093\n&R.12    EQU   12                                                       00094\n&R.13    EQU   13                                                       00095\n&R.14    EQU   14                                                       00096\n&R.15    EQU   15                                                       00097\n         SPACE 1                                                        00098\n.C4      AIF   ('&FPR' EQ '').C5                                        00099\n&FPR.0   EQU   0                  FLOATING POINT REGISTER EQUATES       00100\n&FPR.2   EQU   2                                                        00101\n&FPR.4   EQU   4                                                        00102\n&FPR.6   EQU   6                                                        00103\n         SPACE 1                                                        00104\n.C5      AIF   ('&BASE1' NE '15' AND '&BASE1' NE '13').C6               00105\n         USING *,&R.15                                                  00106\n.C6      AIF   ('&ID' EQ 'NO').C11                                      00107\n         AIF   ('&NAME' EQ '').C7                                       00108\n&BR(1)   SETC  '&NAME'                                                  00109\n&BR(2)   SETC  ''                                                       00110\n&SIZE    SETA  1                                                        00111\n         AGO   .C8                                                      00112\n.C7      AIF   ('&SYSECT' EQ '').C9                                     00113\n&BR(1)   SETC  '&SYSECT'                                                00114\n&BR(2)   SETC  ''                                                       00115\n&SIZE    SETA  1                                                        00116\n.C8      AIF   ('&BR(1)'(1,&SIZE) EQ '&BR(1)').C10                      00117\n&SIZE    SETA  &SIZE+1                                                  00118\n         AGO   .C8                                                      00119\n.C9      ANOP                                                           00120\n&BR(1)   SETC  'PRIVATE '                                               00121\n&BR(2)   SETC  'CODE'                                                   00122\n&SIZE    SETA  12                                                       00123\n.C10     ANOP                                                           00124\n&SIZE1   SETA  ((&SIZE+2)/2)*2+4                                        00125\n&NAME    B     &SIZE1.(0,&R.15)   BRANCH AROUND IDENTIFIER              00126\n         DC    AL1(&SIZE)         LENGTH OF IDENTIFIER                  00127\n         DC    CL&SIZE'&BR(1)&BR(2)' IDENTIFIER                         00128\n         STM   &R.14,&R.12,12(&R.13)                                    00129\n         AGO   .C12                                                     00130\n.C11     ANOP                                                           00131\n&NAME    STM   &R.14,&R.12,12(&R.13)                                    00132\n.C12     AIF   ('&BASE1' EQ '15' OR '&BASE1' EQ '13').C13               00133\n         BALR  &R&BASE1,0                                               00134\n         AIF   ('&BASE2' NE '0').D12                                    00135\n         USING *,&R&BASE1                                               00136\n         AGO   .E12                                                     00137\n.D12     USING *,&R&BASE1,&R&BASE2                                      00138\n.E12     AIF   ('&SAVE' NE 'RENT').C13                                  00139\n         LR    &HOLD,&R.1         SAVE PARAMETER ADDRESS REGISTER       00140\n         LA    &R.0,72            LOAD LENGTH                           00141\n         BAL   &R.1,*+4           INDICATE GETMAIN                      00142\n         SVC   10                 ISSUE GETMAIN SVC                     00143\n         ST    &R.13,4(&R.1)      CROSS-LINK                            00144\n         ST    &R.1,8(&R.13)      THE SAVE AREAS                        00145\n         LR    &R.13,&R.1         RELOCATE ADDRESS OF NEW SAVE AREA     00146\n         AIF   ('&SPIE1' EQ 'NO').C21                                   00147\n         AGO   .C18                                                     00148\n.C13     AIF   ('&SAVE' NE '').C14                                      00149\n         AIF   ('&BASE1' EQ '15').C22                                   00150\n         CNOP  2,4                                                      00151\n         LA    &R.14,*+18         LOAD ADDRESS OF NEW SAVE AREA         00152\n         AGO   .C15                                                     00153\n.C14     LA    &R.14,&SAVE        LOAD ADDRESS OF NEW SAVE AREA         00154\n.C15     ST    &R.13,4(&R.14)     CROSS-LINK                            00155\n         ST    &R.14,8(&R.13)     THE SAVE AREAS                        00156\n         LR    &R.13,&R.14        RELOCATE ADDRESS OF NEW SAVE AREA     00157\n         AIF   ('&SAVE' NE '').C17                                      00158\n         B     *+4+72             BRANCH AROUND SAVE AREA               00159\n         AIF   ('&BASE1' NE '13').C16                                   00160\n         AIF   ('&BASE2' NE '0').D15                                    00161\n         USING *,&R.13            USE SAVE AREA ADDRESS ALSO AS BASE    00162\n         AGO   .E15                                                     00163\n.D15     USING *,&R.13,&R&BASE2   USE SAVE AREA ADDRESS ALSO AS BASE    00164\n.E15     DROP  &R.15              DROP THE TEMPORARY BASE REGISTER      00165\n.C16     DC    18CL4'SAVE'        REGISTER SAVE AREA                    00166\n.C17     AIF   ('&SPIE1' EQ 'NO').C22                                   00167\n         LR    &HOLD,&R.1         SAVE PARAMETER ADDRESS REGISTER       00168\n.C18     ANOP                                                           00169\n         CNOP  2,4                                                      00170\n.C185    LA    &R.1,*+12          LOAD BRANCH ADDRESS                   00171\n         BALR  &R.1,&R.1          BRANCH AROUND PARAMETERS              00172\n         DC    A(0)               EXIT ROUTINE ADDRESS                  00173\n         DC    AL2(0)             INTERUPTION MASK                      00174\n         SVC   14                 ISSUE SPIE SVC                        00175\n.C20     ST    &R.1,0(&R.13)      SAVE PREVIOUS PICA                    00176\n.C21     LR    &R.1,&HOLD         RESTORE PARAMETER ADDRESS REGISTER    00177\n.C22     AIF   ('&BASE2' EQ '0').C23                                    00178\n         LA    &R&BASE2,2048(&R&BASE1) LOAD SECOND BASE REGISTER WITH   00179\n         LA    &R&BASE2,2048(&R&BASE2) VALUE 4096 BEYOND FIRST BASE REG 00180\n.C23     MEND                                                           00181\n*          DATA SET RETRN      AT LEVEL 000 AS OF 05/10/79\n         MACRO                                                          00001\n&NAME    RETRN &R,&FPR,&SAVE=,&BASE=,&SPIE=YES,&ID=YES,&RC=,&SAVEREG=   00002\n         LCLC  &BASE1,&HOLD,&SPIE1                                      00003\n.*                                                                      00004\n.*       AUTHOR - GARY R. KOENIG                                        00005\n.*                                                                      00006\n.*       DATE - NOVEMBER 1, 1969                                        00007\n.*                                                                      00008\n.*       FUNCTION - THE RETRN MACRO IS USED IN ASSEMBLER ROUTINES TO    00009\n.*         RETURN TO THE CALLING PROGRAM.  RETRN SHOULD BE USED ONLY    00010\n.*         AND ALWAYS IF THE ENTER MACRO IS USED.                       00011\n.*                                                                      00012\n.*       CODING - RETRN IS CODED INTO THE ASSEMBLER PROGRAM ACCORDING   00013\n.*         TO THE RULES OF MACRO INSERTION.  ALL PARAMETERS SHOULD BE   00014\n.*         CODED EXACTLY THE WAY THEY WERE FOR THE ENTER MACRO.  IN     00015\n.*         ADDITION TWO MORE KEYWORD PARAMETERS CAN BE CODED FOR THE    00016\n.*         RETRN MACRO.  THESE ARE AS FOLLOWS:                          00017\n.*         1)  &RC IS USED TO PASS A RETURN CODE THROUGH REGISTER 15.   00018\n.*           IF RC=20 IS CODED, 20 WILL BE THE RETURN CODE PASSED IN    00019\n.*           REGISTER 15.  IF REGISTER 15 ALREADY CONTAINS THE RETURN   00020\n.*           CODE, CODE RC=(15).                                        00021\n.*         2)  &SAVEREG IS USED TO INDICATE THE SUBPROGRAM IS A FUNC-   00022\n.*           TION AND A VALUE IS BEING RETURNED IN REGISTER 0.  TO      00023\n.*           INDICATE THIS, CODE &SAVEREG=0.                            00024\n&BASE1   SETC  '&BASE'                                                  00025\n&HOLD    SETC  '&R'.'2'                                                 00026\n&SPIE1   SETC  '&SPIE'                                                  00027\n         AIF   ('&BASE' NE '15' AND '&BASE' NE '1').C0                  00028\n&SPIE1   SETC  'NO'                                                     00029\n         AGO   .C2                                                      00030\n.C0      AIF   ('&BASE1' NE '2' AND '&SAVEREG' NE '2').C1               00031\n&HOLD    SETC  '&R'.'3'                                                 00032\n         AGO   .C2                                                      00033\n.C1      AIF  ('&BASE' NE '14' AND '&BASE' NE '0' AND '&BASE' NE '').C3 00034\n&BASE1   SETC  '13'                                                     00035\n.C2      AIF   ('&BASE1' NE '13' OR '&SAVE' EQ '').C3                   00036\n&BASE1   SETC  '12'                                                     00037\n.C3      AIF   ('&NAME' EQ '').C4                                       00038\n&NAME    DS    0H                                                       00039\n.C4      AIF   ('&BASE1' EQ '15').C7                                    00040\n         AIF   ('&SPIE1' EQ 'NO').C5                                    00041\n         L     &R.1,0(&R.13)      RELOAD THE PREVIOUS PICA ADDRESS      00042\n         SVC   14                 ISSUE SPIE SVC                        00043\n.C5      AIF   ('&ID' EQ 'NO' OR '&SAVE' EQ 'RENT').C6                  00044\n         MVI   0(&R.13),X'FF'     FLAG ROUTINE COMPLETE                 00045\n.C6      L     &R.13,4(&R.13)     LOAD ADDR OF PREVIOUS SAVE AREA       00046\n         AIF   ('&SAVE' EQ 'RENT').C8                                   00047\n.C7      AIF   ('&SAVEREG' EQ '0' OR '&SAVEREG' EQ '&R.0').C12          00048\n         AGO   .D8                                                      00049\n.C8      AIF   ('&SAVEREG' EQ '0' OR '&SAVEREG' EQ '&R.0').C11          00050\n         LA    &R.0,72            LOAD LENGTH                           00051\n         SVC   10                 ISSUE FREEMAIN SVC                    00052\n.D8      AIF   ('&RC' EQ '(15)' OR '&RC' EQ '(&R.15)').C10              00053\n         AIF   ('&RC' NE '').C9                                         00054\n         LM    &R.14,&R.12,12(&R.13)   RESTORE REGISTERS                00055\n         AGO   .END                                                     00056\n.C9      LA    &R.15,&RC          LOAD RETURN CODE                      00057\n.C10     L     &R.14,12(&R.13)    RESTORE                               00058\n         LM    &R.0,&R.12,20(&R.13) REGISTERS                           00059\n         AGO   .END                                                     00060\n.C11     LR    &HOLD,&R.0         SAVE REG 0                            00061\n         LA    &R.0,72            LOAD LENGTH                           00062\n         SVC   10                 ISSUE FREEMAIN SVC                    00063\n         LR    &R.0,&HOLD         RESTORE REG 0                         00064\n.C12     AIF   ('&RC' EQ '(15)' OR '&RC' EQ '(&R.15)').C14              00065\n         AIF   ('&RC' NE '').C13                                        00066\n         LM    &R.14,&R.15,12(&R.13)   RESTORE                          00067\n         LM    &R.1,&R.12,24(&R.13)      REGISTERS                      00068\n         AGO   .END                                                     00069\n.C13     LA    &R.15,&RC          LOAD RETURN CODE                      00070\n.C14     L     &R.14,12(&R.13)    RESTORE                               00071\n         LM    &R.1,&R.12,24(&R.13) REGISTERS                           00072\n.END     BR    &R.14              RETURN CONTROL                        00073\n         MEND                                                           00074\n         PRINT ON                                                       00005\n*********************************************************************** 00006\n*                                                                     * 00007\n*  NAME: LINKDATE                                                     * 00008\n*                                                                     * 00009\n*  PROGRAM WRITTEN BY: R.D.WIRTH   9/22/75                            * 00010\n*  LAST MAINTAINED BY: R.D.WIRTH   9/22/75                            * 00011\n*  LAST MAINTAINED BY: R.E.STYMA   5/10/85                            * 00012\n*  LAST MAINTAINED BY: R.E.STYMA  12/12/2003 MAKE OUTPUT RMODE ANY    * 00013\n*                                            AND AMODE ANY            * 00014\n*                                                                     * 00015\n*                                                                     * 00016\n*  PURPOSE: FETCH THE DATE AND TIME OF AN IBM LINKAGE EDITOR JOB STEP * 00017\n*           AND BUILD A \" SETSSI \" COMMAND WHICH CAN BE CONCATENATED  * 00018\n*           TO THE FRONT OF THE LINK EDITORS SYSLIN INPUT STREAM.  THE* 00019\n*           OPERAND OF THE SETSSI COMMAND WILL BE AN ENCODING OF THE  * 00020\n*           DATE AND TIME AS DEFINED BELOW.  THE LINK EDITOR INSERTS  * 00021\n*           THE OPERAND OF THE SETSSI COMMAND INTO THE USER DATA FIELD* 00022\n*           OF THE LOAD MODULE PDS DIRECTORY WHERE IT CAN SUBSEQUENTLY* 00023\n*           BE PRINTED ON A LOAD MODULE LIBRARY DIRECTORY ( SEE       * 00024\n*           LINKDIR ).                                                * 00025\n*           5/10/85 - ADD AN OPTION TO PUT THE DATE IN THE FORMAT     * 00026\n*           MM/DD/YY IN A VARYING LENGTH EXTERNAL STRING.             * 00027\n*           THE EXTERNAL CSECT NAME GENERATED IS LINKDTE AND THE      * 00028\n*           FORMAT IS A TWO BYTE LENGTH FIELD FOLLOWED BY             * 00029\n*           AN EIGHT BYTE STRING.                                     * 00030\n*           TO ACTIVATE THIS OPTION, PLACE THE TWO CHARACTERS \"L,\"    * 00031\n*           AS THE FIRST TWO CHARACTERS OF THE PARM STRING.           * 00032\n*                                                                     * 00033\n*                                                                     * 00034\n*                                                                     * 00035\n*  FUNCTIONS: 1) FETCH THE DATE & TIME USING THE OS MACRO.            * 00036\n*             2) BUILD A SINGLE 80 BYTE RECORD TO BE WRITTEN TO OUTPUT* 00037\n*                CARD IMAGE FILE (SETSSI).                            * 00038\n*                THE CARD FORMAT IS:                                  * 00039\n*                       '  SETSSI XXXXXYYY '                          * 00040\n*                   WHERE  XXXXX  IS THE JULIAN DATE IN YYDDD FORMAT  * 00041\n*                            YYY  IS THE TIME IN HOURS & TENS MINUTES * 00042\n*                IE; '         SETSSI 75237184 '                      * 00043\n*                    237 TH DAY OF 1975                               * 00044\n*                    AT 6:40 PM                                       * 00045\n*                NOTE THE THE CHARACTERS IN THE OPERAND OF            * 00046\n*                     SETSSI ARE LIMITED TO 0-9 & A-F.                * 00047\n*             3) PRINT A LINE (121 BYTES) ON AN OUTPUT FILE (PRINTDAT)* 00048\n*                CONTAINING:                                          * 00049\n*                  TITLE                                              * 00050\n*                  JULIAN DATE   YYDDD                                * 00051\n*                  CALENDAR DATE   MM/DD/YY                           * 00052\n*                  TIME  HH:MM:SS                                     * 00053\n*                  IMAGE OF SETSSI COMMAND                            * 00054\n*             4) READ THE PARM:                                       * 00055\n*                  FIRST PARAMETER IS THE NAME TO LOAD (TO 1ST COMMA) * 00056\n*                  REST IS PASSED TO PROGRAM CALLED.                  * 00057\n*             5) LINK TO THE LINK EDITOR LOAD MODULE, THE NAME        * 00058\n*                WAS PASSED AS THE FIRST PARAMETER IN THE PARM STRING.* 00059\n*             6) UPON RETURN FROM THE LINKED PROGRAM, RETURN WITH     * 00060\n*                THE LINKED PROGRAMS RETURN CODE                      * 00061\n*                                                                     * 00062\n*********************************************************************** 00063\n         EJECT                                                          00064\n*********************************************************************** 00065\n*                                                                     * 00066\n* OBTAIN THE CURRENT DATE AND TIME AND PROCEED TO FORMAT              * 00067\n* THE OUTPUT CARD IMAGE AND PRINT LINE                                * 00068\n*                                                                     * 00069\n*********************************************************************** 00070\n         SPACE                                                          00071\n*        PRINT NOGEN                                                    00072\nLINKDATE CSECT                                                          00073\n         ENTER R,SPIE=NO,ID=YES,BASE=13 * ESTABLISH SAVE AREA & ENTRY   00074\n         ST    R1,PARMSAVE    * SAVE THE POINTER TO THE PARM            00075\n         SPACE                                                          00076\n         TIME  DEC            * FETCH THE CURRENT DATE AND TIME         00077\n         ST    R1,DATESAVE    * SAVE THE PACKED DECIMAL DATE (00YYDDDF) 00078\n         ST    R0,TIMESAVE    * SAVE THE PACKED DECIMAL TIME (HHMMSSTH) 00079\n         SPACE                                                          00080\n         UNPK  DATEUNPK,DATESAVE  * UNPACK THE DATE FOR PRINTING  YYDDD 00081\n         MVC   SSICARD+10(5),DATEUNPK+3  * MOVE DATE CHARS INTO SETSSI  00082\n         LA    R3,DATESAVE    * SET UP JULIAN DATE (PACKED) FOR SUBR.   00083\n         BAL   R6,DATECONV    * GO CONVERT JULIAN DATE                  00084\n         ST    R3,SSICARD+52  *  TO MM/DD/YY FORMAT  (1ST 4 CHAR)       00085\n         ST    R4,SSICARD+56  *                      (LAST 4 CHAR)      00086\n         STCM  R3,15,OBJDATE     *  SAVE IN OBJ RECORD  (1ST 4 CHAR)    00087\n         STCM  R4,15,OBJDATE+4   *  IN CASE WE NEED IT  (LAST 4 CHAR)   00088\n         SPACE                                                          00089\n         OI    TIMESAVE+3,X'0F'  * SET THE SIGN TO PERMIT UNPACKING     00090\n         UNPK  TIMEUNPK,TIMESAVE  * UNPACK THE TIME FOR PRINTING        00091\n         MVC   SSICARD+15(3),TIMEUNPK+1  * MOVE HOURS & TENS OF MINUTES 00092\n         MVC   SSICARD+63(2),TIMEUNPK+1  * MOVE HOURS TO PRINT LINE     00093\n         MVC   SSICARD+66(2),TIMEUNPK+3  * MOVE MINUTES TO PRINT LINE   00094\n         MVC   SSICARD+69(2),TIMEUNPK+5  * MOVE SECONDS TO PRINT LINE   00095\n         MVC   OBJTIME+00(2),TIMEUNPK+1  * MOVE HOURS TO OBJECT CARD    00096\n         MVC   OBJTIME+03(2),TIMEUNPK+3  * MOVE MINUTES TO OBJECT CARD  00097\n         EJECT                                                          00098\n*********************************************************************** 00099\n*                                                                     * 00100\n* PERFORM ALL OUTPUT TO THE CARD AND PRINT FILES                      * 00101\n*   SETSSI    IS THE DDNAME OF THE CARD OUTPUT FILE                   * 00102\n*   PRINTDAT  IS THE DDNAME OF THE PRINT OUTPUT FILE                  * 00103\n*                                                                     * 00104\n*********************************************************************** 00105\n         SPACE                                                          00106\n         OPEN  (SSIDCB,OUTPUT,PRINTDCB,OUTPUT)  * OPEN BOTH OUTPUT FILE 00107\n         SPACE                                                          00108\n         TM    PRINTDCB+DCBOFLGS-IHADCB,X'10'  * TEST FOR OPEN DCB      00109\n         BZ    NOOPENPT       * BRANCH IF OPEN NOT SUCCESSFUL           00110\n         TM    SSIDCB+DCBOFLGS-IHADCB,X'10'  * TEST FOR OPEN DCB        00111\n         BZ    NOOPENCD       * BRANCH IF OPEN NOT SUCCESSFUL           00112\n         SPACE                                                          00113\n         PUT   SSIDCB,SSICARD              * WRITE CARD TO OUTPUT FILE  00114\n         PUT   PRINTDCB,SSICARD              * WRITE PRINT OUTPUT FILE  00115\n         SPACE                                                          00116\n         L     R15,PARMSAVE   * RETIREVE THE INPUT PARM POINTER         00117\n         L     R1,0(R15)      * POINT TO THE PARM STRING LENGTH         00118\n         LH    R2,0(R1)       * FETCH THE LENGTH OF THE PARM STRING     00119\n         LTR   R2,R2          * TEST LENGTH OF THE PARM STRING          00120\n         BZ    PARMERR        * BRANCH TO ERROR IF NO PARM WAS PASSED   00121\n         LA    R1,2(R1)       * BUMP PARM POINTER PAST LENGTH FIELD     00122\n         SPACE                                                          00123\n         CLC   0(2,R1),=CL2'L,' * IS THE FIRST PARM THE L PARM          00124\n         BNE   DOCLOSE        * IF NOT, SKIP OUTPUTING THE OBJ          00125\n         SPACE                                                          00126\n         BCTR  R2,0           * DECREMENT TWICE TO COMPENSATE FOR       00127\n         BCTR  R2,0           * THE L PARM AND COMMA                    00128\n         STH   R2,0(R1)       * STORE LENGTH OF NEW PARM                00129\n         ST    R1,0(R15)      * REPLACE STRING ADDR IN PARM LIST        00130\n         SPACE                                                          00131\n         PUT   SSIDCB,OBJ1    * OUTPUT ESD RECORD                       00132\n         PUT   SSIDCB,OBJ2    * OUTPUT TXT RECORD                       00133\n         PUT   SSIDCB,OBJ3    * OUTPUT END RECORD                       00134\n         SPACE                                                          00135\nDOCLOSE  EQU   *                                                        00136\n         CLOSE (SSIDCB,,PRINTDCB)  * CLOSE BOTH OUTPUT FILES            00137\n         EJECT                                                          00138\n*********************************************************************** 00139\n*                                                                     * 00140\n*  FETCH THE FIRST PARAMETER OF THE PARM STRING (WHICH SHOULD BE A    * 00141\n*  NAME OF A LINK EDITOR) AND USE IT TO LINK TO THE APPROPRIATE       * 00142\n*  LOAD MODULE.  THEN PASS THE REMAINDER OF THE PARM TO THE PROGRAM.  * 00143\n*  TERMINATE UPON RETURN.                                             * 00144\n*                                                                     * 00145\n*********************************************************************** 00146\n         SPACE                                                          00147\n         L     R1,PARMSAVE    * RETIREVE THE INPUT PARM POINTER         00148\n         L     R1,0(R1)       * POINT TO THE PARM STRING LENGTH         00149\n         LH    R2,0(R1)       * FETCH THE LENGTH OF THE PARM STRING     00150\n         LTR   R2,R2          * TEST LENGTH OF THE PARM STRING          00151\n         BZ    PARMERR        * BRANCH TO ERROR IF NO PARM WAS PASSED   00152\n         LA    R1,2(R1)       * BUMP PARM POINTER PAST LENGTH FIELD     00153\n         SPACE                                                          00154\n         LR    R3,R1          * CURRENT CHAR POINTER TO PARM STRING     00155\n         SR    R4,R4          * LENGTH OF FIRST PARAMETER OF PARM       00156\n         SPACE                                                          00157\nNEXTCHAR EQU   *                                                        00158\n         CH    R2,=H'0'       * RUN OUT OF PARM? MEANS ONLY NAME PASSED 00159\n         BNH   GOTNAME        * YES, GO SAVE NAME FOR LINK              00160\n         CLI   0(R3),C','     * COMMA? INDICATING END OF FIRST PARAM    00161\n         BE    GOTPARM        * YES, GO SAVE NAME & REMAINIGN PARM      00162\n         BCTR  R2,0           * DECREMENT PARM STRING LENGTH -REMAINDER 00163\n         LA    R3,1(R3)       * BUMP PARM POINTER TO NEXT CHAR          00164\n         LA    R4,1(R4)       * BUMP NAME PARAMETER LENGTH              00165\n         B     NEXTCHAR       * GO LOOK AT NEXT CHARACTER               00166\n         SPACE                                                          00167\nGOTPARM  EQU   *                                                        00168\n         BCTR  R2,0           * DECREMENT ONCE TO GET PASSED COMMA      00169\n         STH   R2,LPRMLST     * STORE LENGTH OF NEW PARM TO LINK EDITOR 00170\n         BCTR  R2,0           * DECREMENT AGAIN TO ADJUST FOR MVC       00171\n         EX    R2,PARMMVC     * GO EXECUTE MVC TO MOVE PARM FOR LINK    00172\n         SPACE                                                          00173\nGOTNAME  EQU   *                                                        00174\n         CH    R4,=H'8'       * IS THE NAME TOO LARGE? (>8 CHAR)        00175\n         BH    PARMERR        * YES, GO ABEND SIGNALLING PARM ERROR     00176\n         BCTR  R4,0           * DECREMENT TO ADJUST LENGTH FOR MVC      00177\n         EX    R4,NAMEMVC     * GO EXECUTE MVC TO MOVE NAME FOR LINK    00178\n         SPACE                                                          00179\n         LA    R1,APRMLST     * ADDRESS OF PARM PASSED TO LINK EDITOR   00180\n         LINK  EPLOC=EPNAME   * GO LINK TO THE REQUESTED LINK EDITOR    00181\n         SPACE                                                          00182\n         RETRN R,SPIE=NO,RC=(15)  * RETURN - PASS L/E RETURN CODE BACK  00183\n         SPACE                                                          00184\nNAMEMVC  MVC   EPNAME(*-*),0(R1)  * EXECUTED!  CAPTURE NAME FOR LINK    00185\nPARMMVC  MVC   PARM(*-*),1(R3)  * EXECUTED!  CAPTURE REMAINING PARM     00186\n         EJECT                                                          00187\n*********************************************************************** 00188\n*                                                                     * 00189\n*  SUBROUTINE TO CONVERT THE JULIAN DATE (AS OBTAINED FROM THE        * 00190\n*  OS TIME MACRO) INTO THE NORMAL CALENDAR DATE                       * 00191\n*                                                                     * 00192\n*  CALLING SEQUENCE:  (R3) = A(X'00YYDDDF')      YY = YEAR            * 00193\n*                     BAL  R6,DATECONV          DDD = DAY OF YEAR     * 00194\n*                                                                     * 00195\n*  RETURNS:           (R3) = C'MM/D'             MM = MONTH           * 00196\n*                     (R4) = C'D/YY'             DD = DAY             * 00197\n*                                                YY = YEAR            * 00198\n*                                                                     * 00199\n*********************************************************************** 00200\n         SPACE                                                          00201\nDATECONV EQU   *                                                        00202\n         ST    R6,DATERTRN    * SAVE THE RETURN LINKAGE                 00203\n         SPACE                                                          00204\n         MVC   DATEPACK(4),=X'0000000F'  * CONVERT YEAR OF DATE TO DEC  00205\n         MVO   DATEPACK(4),1(1,R3)  *                                   00206\n         UNPK  DATEUNPK(3),DATEPACK+2(2)  *                             00207\n         OI    DATEUNPK+2,X'F0'                                         00208\n         MVC   DATECHAR+6(2),DATEUNPK+1  * MOVE THE YEAR TO DATE CHARS  00209\n         SPACE                                                          00210\n         DP    DATEPACK(4),=PL2'4'  * DETERMINE IF LEAP YEAR (MULT 4)   00211\n         CP    DATEPACK+2(2),=PL2'0'  * REMAINDER OF ZERO IF IT IS      00212\n         MVC   DATEPACK(2),2(R3)  * CAPTURE DAY OF YEAR                 00213\n         BNE   DATELEAP       * BRANCH IF NOT LEAP YEAR                 00214\n         CP    DATEPACK(2),=P'60'  * SEE IF AFTER FEB 28                00215\n         BNH   DATELEAP       * BRANCH IF AFTER FEB 28                  00216\n         SP    DATEPACK(2),=P'1'  * DECREASE DATE TO COMPENSATE         00217\nDATELEAP EQU   *                                                        00218\n         LA    R4,DATETAB+22  * POINT TO LAST ENTRY IN THE TABLE        00219\nDATELOOP EQU   *                                                        00220\n         CP    DATEPACK(2),0(2,R4)  * SEE IF RIGHT RANGE OF MONTH       00221\n         BH    DATEGOT        * BRANCH IF RIGHT MONTH                   00222\n         SH    R4,=H'2'       * POINT TO THE NEXT ENTRY OF THE TABLE    00223\n         B     DATELOOP       * GO BACK TO TRY NEXT ENTRY               00224\nDATEGOT  EQU   *                                                        00225\n         SP    DATEPACK(2),0(2,R4)  * GET DAY OF MONTH                  00226\n         LA    R6,DATETAB-2   * CONVERT THE TABLE POINTER               00227\n         SR    R4,R6          *   INTO AN OFFSET                        00228\n         SRA   R4,1           *     AND THEN INTO MONTH NUMBER          00229\n         CVD   R4,DATEUNPK    * CONVERT THE MONTH # INTO DECIMAL        00230\n         UNPK  DATEUNPK(3),DATEUNPK+6(2)  * AND UNPACK MONTH # TO PRINT 00231\n         OI    DATEUNPK+2,X'F0'  * ADJUST SIGN FOR PROPER PRINTING      00232\n         MVC   DATECHAR(2),DATEUNPK+1  * PUT MONTH # INTO RTRN PARM     00233\n         SPACE                                                          00234\n         UNPK  DATEUNPK(3),DATEPACK(2)  * CONVERT DAY OF MONTH          00235\n         OI    DATEUNPK+2,X'F0'         *   INTO DECIMAL FOR PRINT      00236\n         MVC   DATECHAR+3(2),DATEUNPK+1 * PUT DAY INTO RETURN PARAM     00237\n         SPACE                                                          00238\n         L     R3,DATECHAR    * PICK UP 1ST HALF OF DATE CHARS          00239\n         L     R4,DATECHAR+4  * PICK UP LAST HALF OF DATE CHARS         00240\n         SPACE                                                          00241\n         L     R6,DATERTRN    * RESTORE THE RETURN LINKAGE              00242\n         BR    R6             * RETURN                                  00243\n         EJECT                                                          00244\n*********************************************************************** 00245\n*                                                                     * 00246\n* ERROR PROCESSING CONSISTS OF GENERATING A USER ABEND UNIQUE TO      * 00247\n* EACH TYPE OF ERROR DETECTED.                                        * 00248\n*                                                                     * 00249\n*********************************************************************** 00250\n         SPACE                                                          00251\nNOOPENPT EQU  *                                                         00252\n         ABEND 1000           * OUTPUT PRINT FILE DID NOT OPEN          00253\n         SPACE                                                          00254\nNOOPENCD EQU   *                                                        00255\n         ABEND 1004           * OUTPUT CARD FILE DID NOT OPEN           00256\n         SPACE                                                          00257\nPARMERR  EQU   *                                                        00258\n         ABEND 1008           * INVALID PARM INPUT STRING               00259\n*                             * EITHER: NO PARM?                        00260\n*                             *     OR  FIRST PARAMETER > 8 CHARACTERS? 00261\n         EJECT                                                          00262\n*********************************************************************** 00263\n*                                                                     * 00264\n*  DATA AREAS / DCB'S FOR OUTPUT / PARAMETER LISTS / DCB SYMBOLICS    * 00265\n*                                                                     * 00266\n*********************************************************************** 00267\n         SPACE                                                          00268\n         DS   0F                                                        00269\nSSICARD  DC    CL52'  SETSSI  XXXXXXXX  <SET LOADLIB SSI - YYDDDHHM>'   00270\n         DC    CL28'MM/DD/YY   HH:MM:SS'                                00271\n         DC    CL41'PROGRAM: LINKDATE  (LINK EDIT DATE/TIME)'           00272\n         SPACE                                                          00273\nTIMEUNPK DC    D'0'           * UNPACKED TIME                           00274\nTIMESAVE DC    F'0'           * SAVE AREA FOR THE PACKED TIME           00275\nDATERTRN DC    F'0'           * DATE CONVERSION SUBR RETURN LINK        00276\nDATESAVE DC    F'0'           * SAVE AREA FOR THE PACKED DATE           00277\nDATEPACK DC    F'0'                                                     00278\nDATEUNPK DC    D'0'           * UNPACKED DATE                           00279\nDATECHAR DC    CL8'XX/XX/XX'  * PARAMETER RETURNED FROM DATECONV        00280\nDATETAB  DC    PL2'0,31,59,90,120,151,181,212,243,273,304,334'          00281\n         SPACE                                                          00282\nEPNAME   DC    CL8' '         * CALLED LINK EDITOR ENTRY NAME           00283\n         SPACE                                                          00284\nPARMSAVE DC    F'0'           * SAVE ADDRESS OF PARM TO LINKDATE        00285\nAPRMLST  DC    AL1(X'80'),AL3(LPRMLST)  * ADDRESS OF PARM PASSED TO L/E 00286\nLPRMLST  DC    H'0'           * LENGTH OF PARM PASSED TO LINK EDITOR    00287\nPARM     DC    CL255' '       * ACTUAL PARM PASSED TO LINK EDITOR       00288\n         SPACE                                                          00289\nPRINTDCB DCB   DDNAME=SYSPRINT,BLKSIZE=121,DEVD=DA,DSORG=PS,           X00290\n               LRECL=121,MACRF=PM,RECFM=FA,BUFNO=1                      00291\n         SPACE                                                          00292\nSSIDCB   DCB   DDNAME=SETSSI,BLKSIZE=3200,BUFNO=1,DEVD=DA,DSORG=PS,    X00293\n               LRECL=80,MACRF=PM,RECFM=FB                               00294\n         SPACE                                                          00295\nOBJ1    DC    X'02'                                                     00296\n        DC    C'ESD      '                                              00297\n        DC    X'001040400001'                                           00298\n        DC    C'LINKDTE '                                               00299\n        DC    X'0000000047000028'                                       00300\n        DC    CL48' '                                                   00301\nOBJ2    DC    X'02'                                                     00302\n        DC    C'TXT '                                                   00303\n        DC    X'000000404000284040000141F0F02807FF0000000F'             00304\nOBJDATE DC    CL10'MM/DD/YY  '                                          00305\nOBJTIME DC    CL5'HH:MM'                                                00306\n        DC    CL41' '                                                   00307\nOBJ3    DC    X'02'                                                     00308\n        DC    CL79'END                            15741SC103 020185130' 00309\n         SPACE                                                          00310\n         PRINT NOGEN                                                    00311\n         DCBD  DSORG=PS,DEVD=DA  * GENERATE SYMBOLICS FOR DCB ADDRESSES 00312\n         END                                                            00313\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLISRC": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x009\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\x08\\t\\x07\\x86\\x07\\x86\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T08:09:39", "lines": 1926, "newlines": 1926, "modlines": 0, "user": "QC22505"}, "text": "        /* DATA SET FG50133001 AT LEVEL 018 AS OF 06/12/04    */\n /********************************************************************* 00001\n *                                                                      00002\n * PROGRAM:                                                             00003\n *   FLEXCLI -  FLEXESCLI_CMD_INTERFACE                                 00004\n *                                                                      00005\n *   THIS PROGRAM ALLOWS THE CALLER TO PASS COMMANDS TO THE             00006\n *   FLEXESCLI PROGRAM ON THE UNIX SIDE OF THE FLEXES SYSTEM.           00007\n *   THIS IS USEFUL FOR MOUNTING TAPES.  COMMANDS CAN BE                00008\n *   ENTERED VIA DDNAME SYSIN OR AS A SEMICOLON SEPARATED LIST          00009\n *   IN THE PARM STRING.                                                00010\n *                                                                      00011\n * MAINPARM OPTIONS:  (100 CHAR LIMIT IMPOSED BY MVS)                   00012\n *                                                                      00013\n *   IP=    - DOTTED NOTATION IP ADDRESS                                00014\n *            THE IP= ARGUMENT ON THE MAIN PARM STRING INDENTIFIES      00015\n *            THE ADDRESS OF THE SERVER.                                00016\n *            DEFAULT: 192.168.123.45                                   00017\n *                                                                      00018\n *   PORT=  - NUMERIC PORT NUMBER                                       00019\n *            THE PORT= ARGUMENT ON THE MAIN PARM STRING INDENTIFIES    00020\n *            THE PORT THE SERVER IS LISTENING ON.                      00021\n *            DEFAULT:  19999                                           00022\n *                                                                      00023\n *   CMD()  - LIST OF COMMANDS TO PASS TO FLEXESCLI.  THIS IS A         00024\n *            SEMICOLON SEPARATED LIST OF COMMANDS TO PASS TO FLEXESCLI.00025\n *            EACH COMMAND IS SUBMITTED TO FLEXCLI AS THOUGH IT WAS     00026\n *            INPUT IN A CARD IMAGE READ FROM SYSIN.  IF BOTH SYSIN     00027\n *            AND MAINPARM COMMANDS ARE INPUT, THE MAINPARM COMMANDS    00028\n *            ARE EXECUTED FIRST.                                       00029\n *                                                                      00030\n * FILES:                                                               00031\n *                                                                      00032\n *   SYSPRINT - PRINT FILE (LINESIZE 133 WITH CC)                       00033\n *            MESSAGES ARE WRITTEN TO SYSPRINT.  THIS INCLUDES MESSAGES 00034\n *            GERNERATED BY THIS PROGRAM AND ANYTHING FLEXESCLI SENDS   00035\n *            BACK.  THIS FILE IS REQUIRED.                             00036\n *                                                                      00037\n *   SYSIN    - CARD IMAGE INPUT FILE                                   00038\n *            COMMANDS, ONE PER CARD IMAGE ARE READ FROM SYSIN IF       00039\n *            IF EXISTS.                                                00040\n *                                                                      00041\n * COMMAND PROCESSING:                                                  00042\n *                                                                      00043\n *   COMMANDS ARE READ OR EXTRACTED FROM MAINPARM ONE AT AT TIME AND    00044\n *   PASSED TO THE FLEXCLI PROGRAM.  BY DEFAULT, IF THE COMMANDS ARE    00045\n *   ALL UPPER CASE, THEY ARE CONVERTED TO LOWER CASE.                  00046\n *   BY DEFAULT, IF AN ERROR IS DETECTED, THE REMAINING COMMANDS ARE    00047\n *   SKIPPED.  THIS BEHAVIOR IS                                         00048\n *   IMPLEMENTED AS FOLLOWS AND MAY BE OVERRIDDEN.                      00049\n *                                                                      00050\n *   FOR A NORMAL FLEXESCLI COMMAND, AFTER THE COMMAND IS SENT, A       00051\n *   LINE CONTAINING 'FLEXESCLI -- ERROR:' (LOWER CASE) IS WATCHED      00052\n *   FOR IN THE OUTPUT RETURNED.  IF FOUND THIS IS AN ERROR.            00053\n *                                                                      00054\n *   FOR A ! (ESCAPE TO SHELL) COMMAND.  THE COMMAND IS SUFFIXED WITH   00055\n *   ';ECHO \"CC=$?\"' WHICH CAUSES THE LAST COMPLETION CODE TO BE OUTPUT.00056\n *   THIS SEQUENCE IS WATCHED FOR IN THE RETURNED OUTPUT.  THIS LIMITS  00057\n *   THE LENGTH OF A COMMAND TO 67 CHARACTER SINCE 13 ARE USED IN       00058\n *   SUFFIX.                                                            00059\n *                                                                      00060\n *   IF COLUNM 1 OF A COMMAND CONTAINS A '+', THE COMMANDS IS EXECUTED  00061\n *   REGARDLESS OF THE ERROR STATE AND THE ERROR STATE IS RESET.        00062\n *                                                                      00063\n *   IF COLUMN 1 OF A COMMAND CONTAINS A '-' AND THE COMMAND IS A '!'   00064\n *   COMMAND, THE SUFFIX STRING IS NOT ADDED.  IN ADDITION NO LOWER     00065\n *   CASE CONVERSIONS ARE DONE.                                         00066\n *                                                                      00067\n * SAMPLE EXECUTION:                                                    00068\n *   //FLEX1    EXEC PGM=FLEXCLI                                        00069\n *   //STEPLIB  DD  DISP=SHR,DSN=EAXC.SUPPORT.LOADLIB.RELEASE           00070\n *   //SYSPRINT DD  SYSOUT=*                                            00071\n *   //SYSIN    DD  *                                                   00072\n *   ! CP /FAKETAPE/BACKUP/MT/TAPE.000012 /NFSTAPE/COS004.TAPE.000027   00073\n *   MOUNT 0570 /NFSTAPE/COS004.TAPE.000027                             00074\n *                                                                      00075\n *   NOTE:  IF CONSOLE OUTPUT IS TURNED ON IN FLEX, THERE MAY BE A      00076\n *          BUNCH OF MESSAGES OUTPUT BEFORE OUTPUT BEGINS.              00077\n *                                                                      00078\n **********************************************************************/00079\n                                                                        00080\n FLEXCLI:                                                               00081\n    PROCEDURE(MAINPARM) OPTIONS(MAIN) REORDER;                          00082\n DECLARE  MAINPARM          VARYING CHAR(100);                          00083\n                                                                        00084\n /***************************************************************       00085\n *                                                                      00086\n *  DEFAULT SERVER IP AND PORT, MAY BE OVERRIDDEN BY MAINPARM           00087\n *                                                                      00088\n ***************************************************************/       00089\n DECLARE  SERVER_IP         VARYING CHAR(20) INIT('192.168.123.45');    00090\n DECLARE  SERVER_PORT       FIXED BINARY(15) INIT(19999);               00091\n DECLARE  PARM_CMD_COUNT    FIXED BINARY(31) INIT(0);                   00092\n DECLARE  PARM_CMDS(20)     VARYING CHAR(100) AUTO INIT((20)(''));      00093\n DECLARE  CURRENT_CMD       FIXED BINARY(31) INIT(1);                   00094\n                                                                        00095\n /***************************************************************       00096\n *                                                                      00097\n *  VARIABLES USED IN SENDING DATA BACK AND FORTH TO FLESXESCLI         00098\n *                                                                      00099\n ***************************************************************/       00100\n DECLARE  READY_FOR_MORE      BIT(1) INIT('0'B);                        00101\n DECLARE  SYSPRINT            FILE PRINT;                               00102\n DECLARE  SYSIN               FILE RECORD INPUT;                        00103\n DECLARE  EOF_SYSIN           BIT(1) INIT('0'B);                        00104\n DECLARE  FIRST_CMD_SENT      BIT(1) INIT('0'B);                        00105\n DECLARE  SYSIN_OK            BIT(1);                                   00106\n DECLARE  ERROR_FOUND         BIT(1) INIT('0'B);                        00107\n DECLARE  EOF_PGM_SYSINOUTERR BIT(1) INIT('0'B);                        00108\n DECLARE  DONE                BIT(1) INIT('0'B);                        00109\n DECLARE  READFDS(8)          FIXED BINARY(31) INIT((8)0);              00110\n DECLARE  WRITEFDS(8)         FIXED BINARY(31) INIT((8)0);              00111\n DECLARE  EXCPFDS(8)          FIXED BINARY(31) INIT((8)0);              00112\n DECLARE  COUNT               FIXED BINARY(31) INIT(0);                 00113\n DECLARE  BUFF                CHAR(256) INIT(' ');                      00114\n DECLARE  BUFF80              CHAR(80) INIT(' ');                       00115\n DECLARE  SYSIN_DSN           CHAR(44);                                 00116\n                                                                        00117\n /***************************************************************       00118\n *                                                                      00119\n *  VARIABLES USED IN SETTING UP THE CONNECTION AND GENERAL ERROR       00120\n *  PROCESSING.                                                         00121\n *                                                                      00122\n ***************************************************************/       00123\n DECLARE  SOCKFD            FIXED BINARY(31) AUTO INIT(0);              00124\n DECLARE  SOCKET_PAIR(2)    FIXED BINARY(31) AUTO INIT(0);              00125\n DECLARE  01 SERVER_ADDR    LIKE SOCKADDR UNALIGNED AUTO;               00126\n DECLARE  01 TIMEOUT        LIKE BPXYSELT AUTO;                         00127\n DECLARE  RC                FIXED BINARY(31) AUTO;                      00128\n DECLARE  PIC_ZZZZ9         PIC'ZZZZ9' AUTO;                            00129\n DECLARE  SYSNULL           BUILTIN;                                    00130\n DECLARE  UNIX_RC           FIXED BINARY(31) AUTO INIT(0);              00131\n DECLARE  ERRNO             FIXED BINARY(31) AUTO INIT(0);              00132\n DECLARE  REASON            FIXED BINARY(31) AUTO INIT(0);              00133\n                                                                        00134\n OPEN FILE(SYSPRINT) LINESIZE(133);                                     00135\n PUT FILE(SYSPRINT) SKIP EDIT('FLEXCLI CONSOLE INTERFACE ',             00136\n                              'RELEASE 1.0 AS OF ',                     00137\n                              LINKDTE.LINK_DATE)(A,COL(40),A,A);        00138\n                                                                        00139\n /***************************************************************       00140\n *  PARSE THE MAIN PARM STRING FOR THE IP=, PORT= AND CMD() PARMS.      00141\n ***************************************************************/       00142\n RC = INITIALIZE(MAINPARM, SERVER_IP, SERVER_PORT,                      00143\n                 PARM_CMD_COUNT, PARM_CMDS);                            00144\n IF RC \u00ac= 0                                                             00145\n THEN                                                                   00146\n    DO;                                                                 00147\n       CALL PLIRETC(RC);                                                00148\n       RETURN;                                                          00149\n    END;                                                                00150\n                                                                        00151\n /***************************************************************       00152\n *  GET A TCP/IP SOCKET.                                                00153\n ***************************************************************/       00154\n CALL BPX1SOC(AF_INET,      /* INPUT:  DOMAIN,    AF_INET        */     00155\n          SOCK#_STREAM,     /* INPUT:  TYPE,      SOCK#_DGRAM    */     00156\n          IPPROTO_TCP,      /* INPUT:  PROTOCOL,  IPPROTO_UDP    */     00157\n          SOCK#DIM_SOCKET,  /* INPUT:  DIMENSION, DIM_SOCKET     */     00158\n          SOCKET_PAIR,      /* OUTPUT: SOCKET_VECTOR,            */     00159\n          UNIX_RC,          /* OUTPUT: UNIX RC - 0 OR -1         */     00160\n          ERRNO,            /* OUTPUT: ERRNO                     */     00161\n          REASON);          /* OUTPUT: REASON                    */     00162\n IF UNIX_RC \u00ac= 0                                                        00163\n THEN                                                                   00164\n    DO;                                                                 00165\n       CALL UNIXERR('COULD NOT CREATE SOCKET (BPX1SOC)',                00166\n                    ERRNO, REASON);                                     00167\n       CALL PLIRETC(12);                                                00168\n       RETURN;                                                          00169\n    END;                                                                00170\n                                                                        00171\n /***************************************************************       00172\n *  INITIALIZE THE SOCKET ADDRESS OF THE FLEXESCLI_INETD SERVER         00173\n ***************************************************************/       00174\n SOCKFD = SOCKET_PAIR(1);                                               00175\n SERVER_ADDR.SOCK_LEN      = SOCK_SIN#BIN;                              00176\n SERVER_ADDR.SOCK_FAMILY   = AF_INET_BITS;                              00177\n SERVER_ADDR.SOCK_SIN_PORT = SERVER_PORT;                               00178\n SERVER_ADDR.SOCK_SIN_ADDR = IP2BIN(SERVER_IP);                         00179\n SERVER_ADDR.RESERVED_1    = LOW(8);                                    00180\n                                                                        00181\n /***************************************************************       00182\n *  CONNECT TO HE SERVER.                                               00183\n ***************************************************************/       00184\n CALL     BPX1CON(                                                      00185\n          SOCKFD,           /* INPUT: SOCKET_DESCRIPTOR,           */   00186\n          SOCK_SIN#LEN,     /* INPUT: SERVER_ADDR_LENGTH,          */   00187\n          SERVER_ADDR,      /* INPUT: PTR TO SERVER_ADDR           */   00188\n          UNIX_RC,          /* OUTPUT: UNIX RC - 0 OR -1         */     00189\n          ERRNO,            /* OUTPUT: ERRNO                     */     00190\n          REASON);          /* OUTPUT: REASON                    */     00191\n IF UNIX_RC \u00ac= 0                                                        00192\n THEN                                                                   00193\n    DO;                                                                 00194\n       PIC_ZZZZ9 = SERVER_PORT;                                         00195\n       CALL UNIXERR('COULD NOT CONNECT TO SERVER ' || SERVER_IP ||      00196\n                    ' AT PORT ' || PIC_ZZZZ9,                           00197\n                    ERRNO, REASON);                                     00198\n       CALL PLIRETC(12);                                                00199\n       RETURN;                                                          00200\n    END;                                                                00201\n                                                                        00202\n /***************************************************************       00203\n *  SEE IF SYSIN IS SUPPLIED.                                           00204\n ***************************************************************/       00205\n SYSIN_DSN = GETDSN('SYSIN');                                           00206\n IF SYSIN_DSN  \u00ac= ' ' & SYSIN_DSN  \u00ac= 'NULLFILE'                        00207\n THEN                                                                   00208\n    DO;                                                                 00209\n       ON UNDEFINEDFILE(SYSIN) SYSIN_OK = '0'B;                         00210\n       SYSIN_OK = '1'B;                                                 00211\n       OPEN FILE(SYSIN) RECORD INPUT;                                   00212\n    END;                                                                00213\n ELSE                                                                   00214\n    SYSIN_OK = '0'B;                                                    00215\n                                                                        00216\n /***************************************************************       00217\n *                                                                      00218\n *  SOMETIMES FLEXESCLI HAS LOTS OF MESSAGES TO SEND WHEN IT FIRST      00219\n *  FIRES UP.  READ WHATEVER IS IN THE BUCKET AND COPY TO SYSRPRINT.    00220\n *  THEN START PASSING COMMANDS TO FLEXESCLI.                           00221\n *                                                                      00222\n ***************************************************************/       00223\n                                                                        00224\n DO WHILE(\u00acDONE);                                                       00225\n    CALL FDZERO(READFDS);                                               00226\n    CALL FDZERO(WRITEFDS);                                              00227\n                                                                        00228\n    /* IF WE ARE READY TO SEND MORE DATA, THIS BIT WILL BE TRUE */      00229\n    IF (READY_FOR_MORE)                                                 00230\n    THEN                                                                00231\n       CALL FDSET(WRITEFDS, SOCKFD); /* DATA TO FLEXESCLI */            00232\n    IF (EOF_PGM_SYSINOUTERR = '0'B)                                     00233\n    THEN                                                                00234\n       CALL FDSET( READFDS, SOCKFD); /* DATA FROM FLEXESCLI */          00235\n                                                                        00236\n    IF (EOF_PGM_SYSINOUTERR)                                            00237\n    THEN                                                                00238\n       DO;                                                              00239\n          CALL BPX1CLO(                                                 00240\n                     SOCKFD,    /* INPUT:  UNIX FD FROM BPX1OPN */      00241\n                     UNIX_RC,   /* OUTPUT: UNIX RC -1 ON ERROR  */      00242\n                     ERRNO,     /* OUTPUT: ERRNO                */      00243\n                     REASON);   /* OUTPUT: REASON               */      00244\n          IF (COUNT < 0)                                                00245\n          THEN                                                          00246\n             DO;                                                        00247\n                CALL UNIXERR('ERROR CLOSING SOCKET',                    00248\n                             ERRNO, REASON);                            00249\n              END;                                                      00250\n          DONE = '1'B;                                                  00251\n       END;                                                             00252\n                                                                        00253\n    IF (EOF_PGM_SYSINOUTERR)                                            00254\n    THEN                                                                00255\n       LEAVE;                                                           00256\n                                                                        00257\n    IF (EOF_SYSIN)                                                      00258\n    THEN                                                                00259\n       DO;                                                              00260\n          TIMEOUT.TV_SEC = 180;  /* LONG WAIT FOR THE GZIP */           00261\n          TIMEOUT.TV_USEC = 0;                                          00262\n       END;                                                             00263\n    ELSE                                                                00264\n       DO;                                                              00265\n          TIMEOUT.TV_SEC = 2;                                           00266\n          TIMEOUT.TV_USEC = 0;                                          00267\n       END;                                                             00268\n                                                                        00269\n    /****************************************************************** 00270\n    * IF WE ARE READY TO SEND MORE DATA, ISSUE A SELECT WITH NO TIMEOUT 00271\n    * AND BOTH READFDS AND WRITEFDS ACTIVE.  OTHERWISE WE ISSUE A       00272\n    * SELECT WITH A TIMEOUT AND ONLY WAIT FOR OUTPUT FROM FLEXESCLI.    00273\n    ******************************************************************/ 00274\n    IF (READY_FOR_MORE)                                                 00275\n    THEN                                                                00276\n       DO;                                                              00277\n          CALL BPX1SEL(SOCKFD+1,                                        00278\n                       32, /* FIXED SIZE STORAGE IN BYTES OF READFDS */ 00279\n                       READFDS,                                         00280\n                       32, /* FIXED SIZE STORAGE IN BYTES OF WRITEFDS*/ 00281\n                       WRITEFDS,                                        00282\n                       0,  /* NOT USING EXCPFDS */                      00283\n                       EXCPFDS,                                         00284\n                       SYSNULL(),                                       00285\n                       SYSNULL(),                                       00286\n                       (SEL#BITSFOREWARD), /* FORCE TEMP VAR*/          00287\n                       UNIX_RC, /* >0 # FD'S SET, 0 TIMEOUT, -1 ERROR */00288\n                       ERRNO,                                           00289\n                       REASON);                                         00290\n           IF UNIX_RC < 0                                               00291\n           THEN                                                         00292\n              DO;                                                       00293\n                 CALL UNIXERR('BPX1SEL FAILED (1)',                     00294\n                               ERRNO, REASON);                          00295\n                 RC = 12;                                               00296\n                 EOF_PGM_SYSINOUTERR = '1'B;                            00297\n              END;                                                      00298\n        END;                                                            00299\n    ELSE                                                                00300\n       DO;                                                              00301\n          CALL BPX1SEL(SOCKFD+1,                                        00302\n                       32, /* FIXED SIZE STORAGE IN BYTES OF READFDS */ 00303\n                       READFDS,                                         00304\n                       32, /* FIXED SIZE STORAGE IN BYTES OF WRITEFDS*/ 00305\n                       WRITEFDS,                                        00306\n                       0,  /* NOT USING EXCPFDS */                      00307\n                       EXCPFDS,                                         00308\n                       ADDR(TIMEOUT),                                   00309\n                       SYSNULL(),                                       00310\n                       (SEL#BITSFOREWARD), /* FORCE TEMP VAR*/          00311\n                       UNIX_RC, /* >0 # FD'S SET, 0 TIMEOUT, -1 ERROR */00312\n                       ERRNO,                                           00313\n                       REASON);                                         00314\n           IF UNIX_RC < 0                                               00315\n           THEN                                                         00316\n              DO;                                                       00317\n                 CALL UNIXERR('BPX1SEL FAILED (2)',                     00318\n                               ERRNO, REASON);                          00319\n                 EOF_PGM_SYSINOUTERR = '1'B;                            00320\n                 LEAVE;                                                 00321\n              END;                                                      00322\n       END;                                                             00323\n                                                                        00324\n    /****************************************************************** 00325\n    * IF A SELECT TIMED OUT, WAITING FOR DATA FROM FLEXEXCLI, THEN      00326\n    * WE ARE READY TO SEND ANOTHER COMMAND.                             00327\n    ******************************************************************/ 00328\n    IF UNIX_RC = 0                                                      00329\n    THEN                                                                00330\n       READY_FOR_MORE = '1'B;                                           00331\n    ELSE                                                                00332\n       READY_FOR_MORE = '0'B;                                           00333\n                                                                        00334\n    /****************************************************************** 00335\n    * SEE IF THERE IS OUTPUT FROM THE FLEXEXCLI.  IF SO, COPY IT TO     00336\n    * SYSPRINT.                                                         00337\n    ******************************************************************/ 00338\n    IF (FDISSET(READFDS, SOCKFD))                                       00339\n    THEN                                                                00340\n       DO;                                                              00341\n          CALL BPX1RCV(                                                 00342\n               SOCKFD,       /* INPUT: SOCKET_DESCRIPTOR,           */  00343\n               LENGTH(BUFF), /* INPUT: BUFFER_LENGTH,               */  00344\n               BUFF,         /* INPUT: BUFFER,                      */  00345\n               BPX1RCV_ALET, /* INPUT: BUFFER_ALET, BPX1RCV_ALET    */  00346\n               0,            /* INPUT: FLAGS, USUALLY 0             */  00347\n               COUNT,        /* OUTPUT: BYTE COUNT OR -1 ON ERROR   */  00348\n               ERRNO,        /* OUTPUT: ERRNO                       */  00349\n               REASON);      /* OUTPUT: REASON                      */  00350\n          IF (COUNT < 0)                                                00351\n          THEN                                                          00352\n             DO;                                                        00353\n                CALL UNIXERR('ERROR READING FROM FLEXESCLI STDOUT',     00354\n                             ERRNO, REASON);                            00355\n                 EOF_PGM_SYSINOUTERR = '1'B;                            00356\n              END;                                                      00357\n          ELSE                                                          00358\n             IF (COUNT = 0)                                             00359\n             THEN                                                       00360\n                EOF_PGM_SYSINOUTERR = '1'B;                             00361\n             ELSE                                                       00362\n                IF FIRST_CMD_SENT                                       00363\n                THEN                                                    00364\n                   DO;                                                  00365\n                      CALL FLEX_OUTPUT(BUFF, COUNT, ERROR_FOUND);       00366\n                      IF ERROR_FOUND                                    00367\n                      THEN                                              00368\n                         IF RC < 8                                      00369\n                         THEN                                           00370\n                            RC = 8;                                     00371\n                   END;                                                 00372\n       END;                                                             00373\n                                                                        00374\n    /****************************************************************** 00375\n    * IF WE CAN SEND A COMMAND TO FLEXSHELL, DO SO.                     00376\n    ******************************************************************/ 00377\n    IF (FDISSET(WRITEFDS, SOCKFD))                                      00378\n    THEN                                                                00379\n       DO;                                                              00380\n          IF (EOF_SYSIN)                                                00381\n          THEN                                                          00382\n             DO;                                                        00383\n                 IF \u00acFIRST_CMD_SENT                                     00384\n                 THEN                                                   00385\n                    DO;                                                 00386\n                       PUT FILE(SYSPRINT) SKIP EDIT(                    00387\n                           '*** NO INPUT COMMAND SUPPLIED ***')(A);     00388\n                       IF RC < 4                                        00389\n                       THEN                                             00390\n                          RC = 4;                                       00391\n                    END;                                                00392\n             END;                                                       00393\n          ELSE                                                          00394\n             DO;                                                        00395\n                EOF_SYSIN = GET_FLEX_CMD(BUFF80,                        00396\n                                         PARM_CMD_COUNT,                00397\n                                         PARM_CMDS,                     00398\n                                         CURRENT_CMD,                   00399\n                                         SYSIN_OK,                      00400\n                                         ERROR_FOUND);                  00401\n                IF EOF_SYSIN                                            00402\n                THEN                                                    00403\n                   BUFF80 = 'QUIT';                                     00404\n                ELSE                                                    00405\n                   FIRST_CMD_SENT = '1'B;                               00406\n                                                                        00407\n                CALL BPX1SND(                                           00408\n                      SOCKFD,      /* INPUT: SOCKET_DESCRIPTOR,       */00409\n                      80,          /* INPUT: BUFFER_LENGTH,           */00410\n                      BUFF80,      /* INPUT: BUFFER,                  */00411\n                      BPX1SND_ALET,/* INPUT: BUFFER_ALET, BPX1SND_ALET*/00412\n                      0,           /* INPUT: FLAGS, USUALLY 0         */00413\n                      COUNT,       /* OUTPUT: BYTE COUNT OR -1 ON ERR */00414\n                      ERRNO,       /* OUTPUT: ERRNO                   */00415\n                      REASON);     /* OUTPUT: REASON                  */00416\n                IF (COUNT < 0)                                          00417\n                THEN                                                    00418\n                   DO;                                                  00419\n                      CALL UNIXERR('ERROR WRITING TO FLEXESCLI SYSIN',  00420\n                                   ERRNO, REASON);                      00421\n                     EOF_SYSIN = '1'B;                                  00422\n                  END;                                                  00423\n             END;                                                       00424\n      END;                                                              00425\n END; /* END OF WHILE NOT DONE */                                       00426\n                                                                        00427\n CALL PLIRETC(RC);                                                      00428\n RETURN;                                                                00429\n                                                                        00430\n INITIALIZE:                                                            00431\n    PROCEDURE(MAINPARM, SERVER_IP, SERVER_PORT,                         00432\n    PARM_CMD_COUNT, PARM_CMDS) RETURNS(FIXED BINARY(31));               00433\n DECLARE  MAINPARM          VARYING CHAR(100);                          00434\n DECLARE  SERVER_IP         VARYING CHAR(20);                           00435\n DECLARE  SERVER_PORT       FIXED BINARY(15);                           00436\n DECLARE  PARM_CMD_COUNT    FIXED BINARY(31);                           00437\n DECLARE  PARM_CMDS(20)     VARYING CHAR(100) CONNECTED;                00438\n                                                                        00439\n DECLARE  RC                FIXED BINARY(31) AUTO INIT(0);              00440\n DECLARE  TEMP              VARYING CHAR(100) AUTO;                     00441\n DECLARE  DONE              BIT(1) AUTO;                                00442\n DECLARE  I                 FIXED BINARY(31) AUTO;                      00443\n                                                                        00444\n TEMP = GETPARM(MAINPARM, 'IP=');                                       00445\n IF TEMP \u00ac= ''                                                          00446\n THEN                                                                   00447\n    SERVER_IP = TEMP;                                                   00448\n                                                                        00449\n TEMP = GETPARM(MAINPARM, 'PORT=');                                     00450\n IF TEMP \u00ac= ''                                                          00451\n THEN                                                                   00452\n    DO;                                                                 00453\n       IF VERIFY(TEMP, '0123456789') = 0                                00454\n       THEN                                                             00455\n          GET STRING(TEMP) LIST(SERVER_PORT);                           00456\n       ELSE                                                             00457\n          DO;                                                           00458\n             PUT SKIP EDIT('INVALID PORT= PARAMETER, ', TEMP,           00459\n                           ' IS NOT ALL NUMERIC')(A);                   00460\n             RC = 8;                                                    00461\n          END;                                                          00462\n    END;                                                                00463\n                                                                        00464\n TEMP = GETPARM(MAINPARM, 'CMD(');                                      00465\n IF TEMP \u00ac= ''                                                          00466\n THEN                                                                   00467\n    DO;                                                                 00468\n       DONE = '0'B;                                                     00469\n       DO UNTIL(DONE);                                                  00470\n          I = INDEX(TEMP, ';');                                         00471\n          IF I = 0                                                      00472\n          THEN                                                          00473\n             DO;                                                        00474\n                PARM_CMD_COUNT = PARM_CMD_COUNT + 1;                    00475\n                PARM_CMDS(PARM_CMD_COUNT) = TEMP;                       00476\n                DONE = '1'B;                                            00477\n             END;                                                       00478\n          ELSE                                                          00479\n             DO;                                                        00480\n                PARM_CMD_COUNT = PARM_CMD_COUNT + 1;                    00481\n                PARM_CMDS(PARM_CMD_COUNT) = SUBSTR(TEMP, 1, I-1);       00482\n                TEMP = SUBSTR(TEMP, I+1);                               00483\n                IF TEMP = ''                                            00484\n                THEN                                                    00485\n                   DONE = '1'B;                                         00486\n             END;                                                       00487\n       END;                                                             00488\n    END;                                                                00489\n                                                                        00490\n RETURN(RC);                                                            00491\n        /* DATA SET GETPARM    AT LEVEL 000 AS OF 03/31/86    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET GETPARM                            *00002\n * DECLARTION FOR ROUNTINE GETPARM                                     *00003\n * THIS ROUTINE EXTERACTS A KEYWORD PARM FROM A PARAMETER STRING.      *00004\n *                                                                     *00005\n * EX:  VALUE = GETPARM(MAINPARM,'XXX=')                               *00005\n *                                                                     *00006\n * SOURCE IS IN FG500781                                               *00006\n *                                                                     *00007\n **********************************************************************/00007\n0 DECLARE GETPARM   ENTRY(VARYING CHAR(*),   /* PARM STRING */          00008\n                          VARYING CHAR(*))   /* PARM HEADER */          00009\n                    RETURNS( VARYING CHAR(2048))  EXTERNAL;             00010\n                                                                        00493\n END INITIALIZE;                                                        00494\n                                                                        00495\n                                                                        00496\n UNIXERR:                                                               00497\n    PROCEDURE(FIRST_LINE, ERRNO, REASON);                               00498\n DECLARE  FIRST_LINE        VARYING CHAR(*);                            00499\n DECLARE  ERRNO             FIXED BINARY(31);                           00500\n DECLARE  REASON            FIXED BINARY(31);                           00501\n                                                                        00502\n DECLARE  MSG_LEN           FIXED BINARY(31) INIT(0);                   00503\n DECLARE  MSGP              POINTER INIT(NULL());                       00504\n DECLARE  MSG               CHAR(256) BASED(MSGP);                      00505\n                                                                        00506\n PUT FILE(SYSPRINT) SKIP EDIT(FIRST_LINE)(A);                           00507\n CALL STRERR(ERRNO, MSG_LEN, MSGP);                                     00508\n PUT FILE(SYSPRINT) SKIP EDIT(SUBSTR(MSG,1,MSG_LEN))(A);                00509\n CALL STRREA(ERRNO, MSG_LEN, MSGP);                                     00510\n PUT FILE(SYSPRINT) SKIP EDIT(SUBSTR(MSG,1,MSG_LEN))(A);                00511\n                                                                        00512\n END UNIXERR;                                                           00513\n                                                                        00514\n TRIMX:                                                                 00515\n  PROCEDURE(INSTR)  RETURNS(VARYING CHAR(80));                          00516\n  DECLARE INSTR     CHAR(*);                                            00517\n  DECLARE I         FIXED BIN(15);                                      00518\n0/**********************************************************************00519\n *                                                                     *00519\n * TRIM LEADING AND TRAILING BLANKS                                    *00519\n *                                                                     *00521\n **********************************************************************/00521\n  I = VERIFY(INSTR,' ');                                                00522\n  IF  I = 0                                                             00523\n  THEN                                                                  00524\n     IF INDEX(INSTR,' ') = 0                                            00525\n     THEN                                                               00526\n        RETURN(INSTR);                                                  00527\n     ELSE                                                               00528\n        RETURN('');                                                     00529\n  RETURN(SUBSTR(INSTR,I,LENGTH(INSTR) - (I-1) -                         00530\n                (VERIFY(REVERSE((INSTR)),' ')-1)) );                    00531\n END TRIMX;                                                             00532\n                                                                        00533\n TRIM:                                                                  00534\n  PROCEDURE(INSTR)  RETURNS(VARYING CHAR(256));                         00535\n  DECLARE INSTR     VARYING CHAR(*);                                    00536\n  DECLARE I         FIXED BIN(15);                                      00537\n0/**********************************************************************00538\n *                                                                     *00538\n * TRIM LEADING AND TRAILING BLANKS                                    *00538\n *                                                                     *00540\n **********************************************************************/00540\n  I = VERIFY(INSTR,' ');                                                00541\n  IF  I = 0                                                             00542\n  THEN                                                                  00543\n     IF INDEX(INSTR,' ') = 0                                            00544\n     THEN                                                               00545\n        RETURN(INSTR);                                                  00546\n     ELSE                                                               00547\n        RETURN('');                                                     00548\n  RETURN(SUBSTR(INSTR,I,LENGTH(INSTR) - (I-1) -                         00549\n                (VERIFY(REVERSE((INSTR)),' ')-1)) );                    00550\n END TRIM;                                                              00551\n                                                                        00552\n GET_FLEX_CMD:                                                          00553\n    PROCEDURE(BUFF80,                                                   00554\n              PARM_CMD_COUNT, PARM_CMDS, CURRENT_CMD,                   00555\n              SYSIN_OK, ERROR_FOUND)                                    00556\n              RETURNS(BIT(1));                                          00557\n DECLARE  BUFF80            CHAR(80);                                   00558\n DECLARE  PARM_CMD_COUNT    FIXED BINARY(31);                           00559\n DECLARE  PARM_CMDS(20)     VARYING CHAR(100) CONNECTED;                00560\n DECLARE  CURRENT_CMD       FIXED BINARY(31);                           00561\n DECLARE  SYSIN_OK          BIT(1);                                     00562\n DECLARE  ERROR_FOUND       BIT(1);                                     00563\n DECLARE  WORK_80           VARYING CHAR(80) AUTO;                      00564\n                                                                        00565\n DECLARE  EOF               BIT(1) AUTO INIT('0'B);                     00566\n                                                                        00567\n BUFF80 = ' ';                                                          00568\n IF CURRENT_CMD > PARM_CMD_COUNT                                        00569\n THEN                                                                   00570\n    IF SYSIN_OK                                                         00571\n    THEN                                                                00572\n       DO;                                                              00573\n          ON ENDFILE(SYSIN) EOF = '1'B;                                 00574\n          READ FILE(SYSIN) INTO(BUFF80);                                00575\n       END;                                                             00576\n    ELSE                                                                00577\n       EOF = '1'B;                                                      00578\n ELSE                                                                   00579\n    DO;                                                                 00580\n       BUFF80 = PARM_CMDS(CURRENT_CMD);                                 00581\n       CURRENT_CMD = CURRENT_CMD + 1;                                   00582\n    END;                                                                00583\n                                                                        00584\n IF \u00acEOF                                                                00585\n THEN                                                                   00586\n    DO;                                                                 00587\n       IF SUBSTR(BUFF80,1,1) = '+'                                      00588\n       THEN                                                             00589\n          DO;                                                           00590\n             BUFF80 = SUBSTR(BUFF80,2);                                 00591\n             IF ERROR_FOUND                                             00592\n             then                                                       00593\n                PUT FILE(SYSPRINT) SKIP                                 00594\n                    EDIT('***** ERROR STATE CLEARED *****')(A);         00595\n             ERROR_FOUND = '0'B;                                        00596\n          END;                                                          00597\n       IF ERROR_FOUND                                                   00598\n       THEN                                                             00599\n          DO;                                                           00600\n             BUFF80 = '#' || SUBSTR(BUFF80, 1, 79);                     00601\n          END;                                                          00602\n       IF SUBSTR(BUFF80,1,1) = '-'                                      00603\n       THEN                                                             00604\n          BUFF80 = SUBSTR(BUFF80,2);                                    00605\n       ELSE                                                             00606\n          DO;                                                           00607\n             WORK_80 = TRIMX(BUFF80);                                   00608\n             IF BREAK(WORK_80, (LOWER_CASE_LETTERS)) = 0                00609\n             THEN                                                       00610\n                WORK_80 = TRANSLATE(WORK_80,                            00611\n                                    LOWER_CASE_LETTERS,                 00612\n                                    UPPER_CASE_LETTERS);                00613\n             IF SUBSTR(WORK_80, 1, 1) = '!'                             00614\n             THEN                                                       00615\n                WORK_80 = WORK_80 || ';echo \"CC=$?\"';                   00616\n             BUFF80 = WORK_80;                                          00617\n          END;                                                          00618\n    END;                                                                00619\n                                                                        00620\n RETURN(EOF);                                                           00621\n END GET_FLEX_CMD;                                                      00622\n                                                                        00623\n                                                                        00624\n FLEX_OUTPUT:                                                           00625\n    PROCEDURE(BUFF, COUNT, ERROR_FOUND);                                00626\n DECLARE  BUFF              CHAR(*);                                    00627\n DECLARE  COUNT             FIXED BINARY(31);                           00628\n DECLARE  ERROR_FOUND       BIT(1);                                     00629\n                                                                        00630\n DECLARE  LINE_SIZE         FIXED BINARY(31) STATIC INIT(132);          00631\n DECLARE  HOLD_BUFF         VARYING CHAR(256) STATIC INIT('');          00632\n DECLARE  LINE              VARYING CHAR(256) AUTO;                     00633\n DECLARE  CHARS_LEFT        FIXED BINARY(31);                           00634\n DECLARE  POS               FIXED BINARY(31) INIT(1);                   00635\n DECLARE  TEMP              FIXED BINARY(31);                           00636\n                                                                        00637\n IF COUNT = 0                                                           00638\n THEN                                                                   00639\n    DO;                                                                 00640\n       IF LENGTH(HOLD_BUFF) > 0                                         00641\n       THEN                                                             00642\n          PUT FILE(SYSPRINT) SKIP EDIT(HOLD_BUFF)(A);                   00643\n    END;                                                                00644\n                                                                        00645\n CHARS_LEFT = COUNT;                                                    00646\n                                                                        00647\n DO WHILE(LENGTH(HOLD_BUFF) + CHARS_LEFT >= LINE_SIZE);                 00648\n    IF LENGTH(HOLD_BUFF) > 0                                            00649\n    THEN                                                                00650\n       DO;                                                              00651\n          TEMP = LINE_SIZE - LENGTH(HOLD_BUFF);                         00652\n          LINE = HOLD_BUFF || SUBSTR(BUFF, POS, TEMP);                  00653\n          HOLD_BUFF = '';                                               00654\n          POS = POS + TEMP;                                             00655\n          CHARS_LEFT = CHARS_LEFT - TEMP;                               00656\n       END;                                                             00657\n    ELSE                                                                00658\n       DO;                                                              00659\n          LINE = SUBSTR(BUFF, POS, LINE_SIZE);                          00660\n          POS  = POS + LINE_SIZE;                                       00661\n          CHARS_LEFT = CHARS_LEFT - LINE_SIZE;                          00662\n       END;                                                             00663\n                                                                        00664\n    LINE = TRIM(LINE);                                                  00665\n    PUT FILE(SYSPRINT) SKIP EDIT(LINE)(A);                              00666\n                                                                        00667\n    IF SUBSTR(LINE, 1, 3) = 'CC=' & SUBSTR(LINE, 4, 1) \u00ac= '0'           00668\n    THEN                                                                00669\n       DO;                                                              00670\n          ERROR_FOUND = '1'B;                                           00671\n          PUT FILE(SYSPRINT) SKIP EDIT('***** ERROR DETECTED *****')(A);00672\n       END;                                                             00673\n    IF INDEX(LINE, 'flexescli -- error:') \u00ac= 0                          00674\n    THEN                                                                00675\n       DO;                                                              00676\n          ERROR_FOUND = '1'B;                                           00677\n          PUT FILE(SYSPRINT) SKIP EDIT('***** ERROR DETECTED *****')(A);00678\n       END;                                                             00679\n END;                                                                   00680\n                                                                        00681\n IF CHARS_LEFT > 0                                                      00682\n THEN                                                                   00683\n    HOLD_BUFF = SUBSTR(BUFF, POS, CHARS_LEFT);                          00684\n END FLEX_OUTPUT;                                                       00685\n                                                                        00686\n        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET DEFAULT                            *00002\n *                                                                     *00003\n * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003\n * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003\n * EASIER REENTRANCY.                                                  *00003\n *                                                                     *00006\n **********************************************************************/00006\n                                                                        00007\n DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008\n                  DESCRIPTORS ALIGNED;                                  00009\n        /* DATA SET BUILTIN    AT LEVEL 000 AS OF 10/05/89    */\n0/**********************************************************************00001\n *                                                                     *00001\n *                           SUBSET BUILTIN                            *00001\n *                                                                     *00002\n *                                                                     *00003\n *                       BUILTIN PL/I FUNCTIONS                        *00003\n *                                                                     *00003\n **********************************************************************/00003\n0DECLARE (ABS,                                                          00004\n          ADDR,                                                         00005\n          ALLOCATION,                                                   00006\n          CHAR,                                                         00007\n          COMPLETION,                                                   00008\n          DATE,                                                         00009\n          DECIMAL,                                                      00010\n          EMPTY,                                                        00011\n          HBOUND,                                                       00012\n          HIGH,                                                         00013\n          INDEX,                                                        00014\n          LBOUND,                                                       00015\n          LENGTH,                                                       00016\n          LINENO,                                                       00017\n          LOW,                                                          00018\n          MAX,                                                          00019\n          MIN,                                                          00020\n          MOD,                                                          00021\n          NULL,                                                         00022\n          ONCODE,                                                       00023\n          ONKEY,                                                        00024\n          PLIRETC,                                                      00025\n          PLIRETV,                                                      00026\n          PLISRTA,                                                      00027\n          REPEAT,                                                       00028\n          ROUND,                                                        00029\n          STORAGE,                                                      00030\n          STRING,                                                       00031\n          SUBSTR,                                                       00032\n          TIME,                                                         00033\n          TRANSLATE,                                                    00034\n          TRUNC,                                                        00035\n          UNSPEC,                                                       00036\n          VERIFY)            BUILTIN;                                   00037\n        /* DATA SET LINKDTE    AT LEVEL 000 AS OF 04/03/87    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET LINKDTE                            *00002\n *                                                                     *00003\n * DECLARATION FOR THE LINK DATE INFORMATION BUILD BY THE LINKDATE     *00003\n * PROGRAM AND LINKED WITH THIS PROGRAM.                               *00003\n *                                                                     *00005\n * LINKDTE IS A SPECIAL VARIABLE SET UP BY THE LINKDATE PROGRAM WHICH  *00005\n * IS PART OF THE RELEASE PROCEDURE AND THE MDLKED CATALOGUED          *00005\n * PROCEDURE.  THE LINKDATE PROGRAM GENERATES AN EXTERNAL VARIABLE     *00005\n * NAMED LINKDTE WHICH CONTAINS THE CURRENT DATE IN MM/DD/YY FORMAT.   *00005\n * NOTE: THAT WHEN USING LINKDTE YOU MUST ALWAYS INCLUDE THE ENTRY     *00005\n * PLISTART CARD AS LINKDTE IS THE FIRST CSECT AND WOULD BECOME THE    *00005\n * DEFAULT ENTRY POINT.                                                *00005\n *                                                                     *00012\n **********************************************************************/00012\n0   DECLARE  01  LINKDTE  STATIC EXTERNAL ALIGNED,                      00013\n                 02    HEADER_JUNK    CHAR(8) INIT(' '),                00014\n                 02    LINK_DATE      VARYING CHAR(30) INIT('UNKNOWN'); 00015\n                                                                        00690\n        /* DATA SET STRERR     AT LEVEL 000 AS OF 08/13/04    */\n0/**********************************************************************\n *                                                                     *\n *                       SUBSET FG501277.STRERR                        *\n * DECLARATION FOR ROUTINE STRERR FOR OMVS                             *\n *                                                                     *\n * SOURCE IS IN FG501291                                               *\n *                                                                     *\n * THIS ROUTINE CONVERTS THE ERRNO CODE FROM A BPX1*** ROUTINE TO A    *\n * TEXT STRING.                                                        *\n *                                                                     *\n * THE ERRNO IS PASSED TO THE ROUTINE.                                 *\n *                                                                     *\n * THE LENGTH OF THE MESSAGE IS RETURNED. IF NO MESSAGE IS FOUND FOR   *\n * THIS ERROR CODE, THE LENGTH IS SET TO ZERO.                         *\n *                                                                     *\n * A POINTER TO A NULL TERMINATED MESSAGE IS RETURNED.  THE LENGTH     *\n * RETURNED DOES NOT INCLUDE THE NUL BYTE.  THE PLI NULL() PONTER      *\n * (X'FF000000' IS RETURNED IF THERE IS NO MESSAGE)                    *\n *                                                                     *\n * SAMPLE CALL:                                                        *\n *                                                                     *\n * DECLARE  ERRNO FIXED BINARY(31) INIT(123)                           *\n * DECLARE  MSG_LEN FIXED BINARY(31) INIT(0)                           *\n * DECLARE  MSGP    POINTER INIT(NULL())                               *\n * DECLARE  MSG     CHAR(256) BASED(MSGP)                              *\n *                                                                     *\n * CALL STRERR(ERRNO, MSG_LEN, MSGP)                                   *\n * PUT SKIP EDIT(SUBSTR(MSG, 1, MSG_LEN))(A)                           *\n *                                                                     *\n **********************************************************************/\n\n DECLARE STRERR  ENTRY(\n                 FIXED BINARY(31),  /* IN  - ERRNO                */\n                 FIXED BINARY(31),  /* OUT - MESSAGE LEN          */\n                 POINTER)           /* OUT - MSG                  */\n                 OPTIONS(ASSEMBLER)  EXTERNAL;\n\n        /* DATA SET STRREA     AT LEVEL 000 AS OF 08/13/04    */\n0/**********************************************************************\n *                                                                     *\n *                       SUBSET FG501277.STRREA                        *\n * DECLARATION FOR ROUTINE STRREA                                      *\n *                                                                     *\n * SOURCE IS IN FG501292                                               *\n *                                                                     *\n * THIS ROUTINE CONVERTS THE REASON CODE FROM A BPX1*** ROUTINE (THE   *\n * ERRNO JR.) TO A TEXT STRING.                                        *\n *                                                                     *\n * THE REASON IS PASSED TO THE ROUTINE.                                *\n *                                                                     *\n * THE LENGTH OF THE MESSAGE IS RETURNED. IF NO MESSAGE IS FOUND FOR   *\n * THIS ERROR CODE, THE LENGTH IS SET TO ZERO.                         *\n *                                                                     *\n * A POINTER TO A NUL TERMINATED MESSAGE IS RETURNED.  THE LENGTH      *\n * RETURNED DOES NOT INCLUDE THE NUL BYTE.  THE PLI NULL() PONTER      *\n * (X'FF000000' IS RETURNED IF THERE IS NO MESSAGE)                    *\n *                                                                     *\n * SAMPLE CALL:                                                        *\n *                                                                     *\n * DECLARE  REASON  FIXED BINARY(31) INIT(123)                         *\n * DECLARE  MSG_LEN FIXED BINARY(31) INIT(0)                           *\n * DECLARE  MSGP    POINTER INIT(NULL())                               *\n * DECLARE  MSG     CHAR(256) BASED(MSGP)                              *\n *                                                                     *\n * CALL STRREA(REASON, MSG_LEN, MSGP)                                  *\n * PUT SKIP EDIT(SUBSTR(MSG, 1, MSG_LEN))(A)                           *\n *                                                                     *\n **********************************************************************/\n\n DECLARE STRREA  ENTRY(\n                 FIXED BINARY(31),  /* IN  - REASON (ERRNO JR.)   */\n                 FIXED BINARY(31),  /* OUT - MESSAGE LEN          */\n                 POINTER)           /* OUT - MSG                  */\n                 OPTIONS(ASSEMBLER)  EXTERNAL;\n\n        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.FDZERO                                              00003\n *                                                                      00004\n *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005\n *                                                                      00006\n *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007\n *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008\n *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009\n *  TO THE SELECT FUNCTION.                                             00010\n *                                                                      00011\n *  FDZERO      - ZERO AN FDSET                                         00012\n *                                                                      00013\n *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014\n *                                                                      00015\n *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016\n *                                                                      00017\n *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018\n *  DECLARE   SOCKET       FIXED BINARY(31)                             00019\n *  CALL FDZERO(READ_FDS)                                               00020\n *  CALL FDSET(READ_FDS, SOCKET)                                        00021\n *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022\n *  CALL FDISSET(READ_FDS, SOCKET)                                      00023\n *                                                                      00024\n *  SOURCE IS IN FG501326                                               00025\n *                                                                      00026\n ***************************************************************/       00027\n                                                                        00028\n DECLARE  FDZERO       ENTRY(                                           00029\n          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030\n          EXTERNAL;                                                     00031\n                                                                        00032\n DECLARE  FDSET        ENTRY(                                           00033\n          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035\n          EXTERNAL;                                                     00036\n                                                                        00037\n DECLARE  FDISSET      ENTRY(                                           00038\n          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040\n          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041\n                                                                        00042\n        /* DATA SET BPX1SEL    AT LEVEL 000 AS OF 02/05/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPX1SEL                                             00003\n *                                                                      00004\n *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1SEL          00005\n *                                                                      00006\n *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A SELECT OPERATION00007\n *  ON FILE DESCRIPTORS.                                                00008\n *                                                                      00009\n *  FIRST PARM  - SNFDS  (INPUT)                                        00010\n *                THE VALUE OF THE LARGEST FILE DESCRIPTOR PASSED       00011\n *                PLUS ONE.  IF YOU HAVE ONE SOCKET, THIS IS THE        00012\n *                VALUE RETURNED BY BPX1SOC + 1.                        00013\n *                                                                      00014\n *  SECOND PARM - READ_LIST_LENGTH (INPUT)                              00015\n *                THE LENGTH OF THE READ_FDS (THIRD PARM) IN BYTES.     00016\n *                PASS ZERO IF NOT SELECTING ON READ OTHERWISE PASS     00017\n *                THE VALUE 32.                                         00018\n *                                                                      00019\n *  THIRD PARM  - READ_FDS (INPUT/OUTPUT)                               00020\n *                AN ARRAY OF 8 FIXED BINARY(31) VALUES WHICH INDICATE  00021\n *                WHICH FILE DESCRIPTORS NEED TO BE LOOKED AT.  THIS    00022\n *                LIST IS TREATED AS A BIT ARRAY OF LENGTH 256 WITH     00023\n *                INDEXES FROM 0 TO 255 FOR THE FILE DESCRIPTORS.       00024\n *                ON RETURN, BIT POSITIONAS ARE SET TO SHOW WHICH       00025\n *                FILE DESCRIPTORS ARE READY FOR READING.               00026\n *                REINIT BEFORE EACH CALL.                              00027\n *                USE FDZERO  TO INITIALIZE (FG501326)                  00028\n *                    FDSET   TO SET BITS   (DCLS IN FG501277.FDZERO)   00029\n *                    FDISSET TO INSPECT BITS AFTER RETURN              00030\n *                                                                      00031\n *  FOURTH PARM - WRITE_LIST_LENGTH (INPUT)                             00032\n *                THE LENGTH OF THE WRITE_FDS (FIFTH PARM) IN BYTES.    00033\n *                PASS ZERO IF NOT SELECTING ON WRITE OTHERWISE PASS    00034\n *                THE VALUE 32.                                         00035\n *                                                                      00036\n *  FIFTH PARM  - WRITE_FDS (INPUT/OUTPUT)                              00037\n *                JUST LIKE 3RD PARM, BUT DETECTS WHEN FILE DESCRIPTORS 00038\n *                (SOCKETS) ARE READY FOR WRITE INSTEAD OF READ.        00039\n *                REINIT BEFORE EACH CALL.                              00040\n *                                                                      00041\n *  SIXTH PARM  - EXCEPTION_LIST_LENGTH (INPUT)                         00042\n *                THE LENGTH OF THE EXCPT_FDS (SEVETH PARM) IN BYTES.   00043\n *                PASS ZERO IF NOT SELECTING ON EXCEPTIONAL CONDITIONS  00044\n *                OTHERWISE PASS THE VALUE 32.                          00045\n *                                                                      00046\n *  SEVENTH PARM- EXCEPTION_FDS (INPUT/OUTPUT)                          00047\n *                JUST LIKE 3RD PARM, BUT DETECTS WHEN FILE DESCRIPTORS 00048\n *                (SOCKETS) HAVE AN EXCEPTION PENDING.                  00049\n *                REINIT BEFORE EACH CALL.                              00050\n *                                                                      00051\n *  FIFTH PARM  - FLAGS (INPUT)                                         00052\n *                ALWAYS PASS 0                                         00053\n *                                                                      00054\n *  SIXTH PARM  - SOCKADDR_LENGTH (INPUT)                               00055\n *                ALWAYS PASS VARABLE CONTAINING SOCK_SIN#LEN           00056\n *                SOCK_SIN#LEN IS DEFINED IN FG501277.BPXYSOCK          00057\n *                                                                      00058\n *  EIGHTH PARM - TIMEOUT (INPUT)                                       00059\n *                SYSNULL() (0) OR A POINTER TO A BPXYSELT STRUCT       00060\n *                (FG501277.BPXYSELT) WHICH CONTAINS A TIMEOUT VALUE.   00061\n *                BPXYSELT HAS TWO MEMBERS ONE FOR SECONDS AND ONE      00062\n *                FOR MICROSECONDS.  PASSING SYSNULL() MEANS INFINITE   00063\n *                WAIT - NO TIMEOUT.  PASSING A POINTER TO A STRUCT     00064\n *                WITH BOTH ELEMENTS ZERO MEANS POLL.                   00065\n *                                                                      00066\n *  NINTH PARM  - ECB PTR (INPUT/OUTPUT)                                00067\n *                PASS SYSNULL() OR A POINTER TO AN ECB OR LIST OF      00068\n *                EBC'S.                                                00069\n *                                                                      00070\n *  TENTH PARM  - USER_OP_FIELD (INPUT/OUTPUT)                          00071\n *                CAN BE PASSED SEL#BITSBACKWARD OR                     00072\n *                SEL#BITSFOREWARD.  IF USING FDZERO, FDSET, AND        00073\n *                FDISSET, ALWAYS PASS A VARIABLE CONTAINING            00074\n *                SEL#BITSFOREWARD.  REINIT BEFORE EACH CALL.           00075\n *                                                                      00076\n *  ELEVENTH    - RET_VALUE (OUTPUT)                                    00077\n *                >0  - THE NUMBER OF FILE DESCRIPTORS READY            00078\n *                =0  - TIMEOUT                                         00079\n *                -1  - ERROR, SEE ERRNO AND REA FOR WHAT HAPPENED.     00080\n *                                                                      00081\n ***************************************************************/       00082\n                                                                        00083\n DECLARE  BPX1SEL      ENTRY(                                           00084\n          FIXED BINARY(31), /* INPUT: NUMBER_MSGSFDS,MAXFD+1        */  00085\n          FIXED BINARY(31), /* INPUT: READ_LIST_LENGTH, 32 OR 0     */  00086\n       (8)FIXED BINARY(31), /* INPUT: READ_LIST,                    */  00087\n          FIXED BINARY(31), /* INPUT: WRITE_LIST_LENGTH, 32 OR 0    */  00088\n       (8)FIXED BINARY(31), /* INPUT: WRITE_LIST,                   */  00089\n          FIXED BINARY(31), /* INPUT: EXCEPTION_LIST_LENGTH, 32 OR 0*/  00090\n       (8)FIXED BINARY(31), /* INPUT: EXCEPTION_LIST,               */  00091\n          POINTER,          /* INPUT: TIMEOUT_POINTER, USE SYSNULL()*/  00092\n          POINTER,          /* INPUT: ECB_POINTER, USE SYSNULL()    */  00093\n          FIXED BINARY(31), /* INPUT: USER_OPTION_FIELD,            */  00094\n          FIXED BINARY(31), /* OUTPUT: # FD'S, 0 TIMEOUT, -1 ERR    */  00095\n          FIXED BINARY(31), /* OUTPUT: ERRNO                        */  00096\n          FIXED BINARY(31)) /* OUTPUT: REASON                       */  00097\n                       OPTIONS(ASM) EXTERNAL;                           00098\n                                                                        00099\n /* VALUES FOR USER_OPTION_FIELD */                                     00100\n DECLARE  SEL#BITSBACKWARD FIXED BINARY(31) STATIC INIT(0);             00101\n DECLARE  SEL#BITSFOREWARD FIXED BINARY(31) STATIC INIT(1);             00102\n        /* DATA SET BPX1SOC    AT LEVEL 000 AS OF 02/05/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPX1SOC                                             00003\n *                                                                      00004\n *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1SOC          00005\n *                                                                      00006\n *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO GET A SOCKET OR SOCKET    00007\n *  PAIR.  MUST HAVE THE IBM TCP STACK (NOT THE CA ONE).                00008\n *                                                                      00009\n ***************************************************************/       00010\n                                                                        00011\n DECLARE  BPX1SOC      ENTRY(                                           00012\n          FIXED BINARY(31), /* INPUT:  DOMAIN,    AF_INET        */     00013\n          FIXED BINARY(31), /* INPUT:  TYPE,      SOCK#_DGRAM    */     00014\n          FIXED BINARY(31), /* INPUT:  PROTOCOL,  IPPROTO_UDP    */     00015\n          FIXED BINARY(31), /* INPUT:  DIMENSION, DIM_SOCKET     */     00016\n      (2) FIXED BINARY(31), /* OUTPUT: SOCKET_VECTOR,            */     00017\n          FIXED BINARY(31), /* OUTPUT: UNIX RC - 0 OR -1         */     00018\n          FIXED BINARY(31), /* OUTPUT: ERRNO                     */     00019\n          FIXED BINARY(31)) /* OUTPUT: REASON                    */     00020\n                       OPTIONS(ASM) EXTERNAL;                           00021\n                                                                        00022\n /********************************************************************  00023\n *                                                                      00024\n * VALUES FOR DOMAIN PARAMETER                                          00025\n *                                                                      00026\n *  WE ALWAYS USE INTERNET ALTHOUGH VALUES EXIST FOR OTHER DOMAINS.     00027\n *                                                                      00028\n /*******************************************************************/  00029\n DECLARE  AF_INET             FIXED BINARY(31) STATIC INIT(2);          00030\n                                                                        00031\n /********************************************************************  00032\n *                                                                      00033\n * VALUES FOR TYPE PARAMETER - THIS AN THE PROTOCOL PARM MUST MATCH.    00034\n *                                                                      00035\n *  STREAM IS TCP/IP                                                    00036\n *  DGRAM  IS UDP/IP                                                    00037\n *  RAW    IS STRAIGHT IP, YOU MUST BE SUPERUSER FOR THIS ONE           00038\n *                                                                      00039\n /*******************************************************************/  00040\n DECLARE  SOCK#_STREAM        FIXED BINARY(31) STATIC INIT(1);          00041\n DECLARE  SOCK#_DGRAM         FIXED BINARY(31) STATIC INIT(2);          00042\n DECLARE  SOCK#_RAW           FIXED BINARY(31) STATIC INIT(3);          00043\n                                                                        00044\n /********************************************************************  00045\n *                                                                      00046\n * VALUES FOR PROTOCOL PARAMETER - THIS AN THE TYPE PARM MUST MATCH.    00047\n *                                                                      00048\n /*******************************************************************/  00049\n DECLARE  IPPROTO_IP          FIXED BINARY(31) STATIC INIT(0);          00050\n DECLARE  IPPROTO_TCP         FIXED BINARY(31) STATIC INIT(6);          00051\n DECLARE  IPPROTO_UDP         FIXED BINARY(31) STATIC INIT(17);         00052\n DECLARE  IPPROTO_IPV6        FIXED BINARY(31) STATIC INIT(41);         00053\n                                                                        00054\n /********************************************************************  00055\n *                                                                      00056\n * VALUES FOR DIMENSION PARAMETER                                       00057\n *                                                                      00058\n * SOCK#DIM_SOCKET     - RETURN ONE NORMAL SOCKET                       00059\n * SOCK#DIM_SOCKETPAIR - RETURN A SOCKET PAIR                           00060\n *                       PROBABLY NEED MORE CONSTANTS TO MAKE THIS      00061\n *                       WORK.                                          00062\n *                                                                      00063\n /*******************************************************************/  00064\n DECLARE  SOCK#DIM_SOCKET     FIXED BINARY(31) STATIC INIT(1);          00065\n DECLARE  SOCK#DIM_SOCKETPAIR FIXED BINARY(31) STATIC INIT(2);          00066\n                                                                        00067\n        /* DATA SET BPX1SND    AT LEVEL 000 AS OF 02/11/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPX1SND                                             00003\n *                                                                      00004\n *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1SND          00005\n *                                                                      00006\n *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A SEND ON A       00007\n *  SOCKET CREATED BY BPX1SOC.                                          00008\n *                                                                      00009\n *  FIRST PARM  - SOCKET (INPUT)                                        00010\n *                SOCKET RETURNED BY BPX1SOC                            00011\n *                                                                      00012\n *  SECOND PARM - BUFFER_LENGTH (INPUT)                                 00013\n *                LENGTH OF THE DATA TO SEND IN THE BUFFER IN THE       00014\n *                THIRD                                                 00015\n *                                                                      00016\n *  THIRD PARM  - BUFFER (OUTPUT)                                       00017\n *                THE DATA TO SEND                                      00018\n *                                                                      00019\n *  FORTH PARM  - BUFFER_ALET (INPUT)                                   00020\n *                ALWAYS PASS BPX1SND_ALET (0)                          00021\n *                                                                      00022\n *  FIFTH PARM  - FLAGS (INPUT)                                         00023\n *                ALWAYS PASS 0                                         00024\n *                                                                      00025\n *                                                                      00026\n *  SIXTH PARM  - COUNT (OUTPUT)                                        00027\n *                NUMBER OF BYTES SENT PLACED IN HERE OR -1 ON ERROR.   00028\n *                IF -1, ERRNO AND REA TELL YOU WHY                     00029\n *                      SEE FG501277.STRERR AND FG501277.STRREA         00030\n *                                                                      00031\n ***************************************************************/       00032\n                                                                        00033\n DECLARE  BPX1SND      ENTRY(                                           00034\n          FIXED BINARY(31), /* INPUT: SOCKET_DESCRIPTOR,           */   00035\n          FIXED BINARY(31), /* INPUT: BUFFER_LENGTH,               */   00036\n          CHAR(*),          /* INPUT: BUFFER,                      */   00037\n          FIXED BINARY(31), /* INPUT: BUFFER_ALET, BPX1SND_ALET    */   00038\n          FIXED BINARY(31), /* INPUT: FLAGS, USUALLY 0             */   00039\n          FIXED BINARY(31), /* OUTPUT: BYTE COUNT OR -1 ON ERROR   */   00040\n          FIXED BINARY(31), /* OUTPUT: ERRNO                       */   00041\n          FIXED BINARY(31)) /* OUTPUT: REASON                      */   00042\n                       OPTIONS(ASM) EXTERNAL;                           00043\n                                                                        00044\n DECLARE  BPX1SND_ALET FIXED BINARY(31) STATIC INIT(0);                 00045\n                                                                        00046\n        /* DATA SET BPX1RCV    AT LEVEL 000 AS OF 02/11/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPX1RCV                                             00003\n *                                                                      00004\n *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1RCV          00005\n *                                                                      00006\n *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A RECEIVE ON A    00007\n *  SOCKET CREATED BY BPX1SOC.                                          00008\n *                                                                      00009\n *  FIRST PARM  - SOCKET (INPUT)                                        00010\n *                SOCKET RETURNED BY BPX1SOC                            00011\n *                                                                      00012\n *  SECOND PARM - BUFFER_LENGTH (INPUT)                                 00013\n *                LENGTH OF THE DATA TO SEND IN THE BUFFER IN THE       00014\n *                THIRD                                                 00015\n *                                                                      00016\n *  THIRD PARM  - BUFFER (OUTPUT)                                       00017\n *                THE DATA TO SEND                                      00018\n *                                                                      00019\n *  FORTH PARM  - BUFFER_ALET (INPUT)                                   00020\n *                ALWAYS PASS BPX1SND_ALET (0)                          00021\n *                                                                      00022\n *  FIFTH PARM  - FLAGS (INPUT)                                         00023\n *                ALWAYS PASS 0                                         00024\n *                                                                      00025\n *  SIXTH PARM  - COUNT (OUTPUT)                                        00026\n *                NUMBER OF BYTES READ PLACED IN HERE OR -1 ON ERROR.   00027\n *                IF -1, ERRNO AND REA TELL YOU WHY                     00028\n *                      SEE FG501277.STRERR AND FG501277.STRREA         00029\n *                                                                      00030\n ***************************************************************/       00031\n                                                                        00032\n DECLARE  BPX1RCV      ENTRY(                                           00033\n          FIXED BINARY(31), /* INPUT: SOCKET_DESCRIPTOR,           */   00034\n          FIXED BINARY(31), /* INPUT: BUFFER_LENGTH,               */   00035\n          CHAR(*),          /* INPUT: BUFFER,                      */   00036\n          FIXED BINARY(31), /* INPUT: BUFFER_ALET, BPX1RCV_ALET    */   00037\n          FIXED BINARY(31), /* INPUT: FLAGS, USUALLY 0             */   00038\n          FIXED BINARY(31), /* OUTPUT: BYTE COUNT OR -1 ON ERROR   */   00039\n          FIXED BINARY(31), /* OUTPUT: ERRNO                       */   00040\n          FIXED BINARY(31)) /* OUTPUT: REASON                      */   00041\n                       OPTIONS(ASM) EXTERNAL;                           00042\n                                                                        00043\n DECLARE  BPX1RCV_ALET FIXED BINARY(31) STATIC INIT(0);                 00044\n                                                                        00045\n        /* DATA SET BPX1CLO    AT LEVEL 000 AS OF 10/28/03    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPX1CLO                                             00003\n *                                                                      00004\n *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1CLO          00005\n *                                                                      00006\n *  THIS ROUTINE CLOSES A FILE OPENED BY BPX1OPN                        00007\n *                                                                      00008\n ***************************************************************/       00009\n                                                                        00010\n DECLARE  BPX1CLO      ENTRY(                                           00011\n          FIXED BINARY(31), /* INPUT:  UNIX FD FROM BPX1OPN */          00012\n          FIXED BINARY(31), /* OUTPUT: UNIX RC -1 ON ERROR  */          00013\n          FIXED BINARY(31), /* OUTPUT: ERRNO                */          00014\n          FIXED BINARY(31)) /* OUTPUT: REASON               */          00015\n                       OPTIONS(ASM) EXTERNAL;                           00016\n                                                                        00017\n                                                                        00018\n        /* DATA SET BPX1CON    AT LEVEL 000 AS OF 04/12/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPX1CON                                             00003\n *                                                                      00004\n *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1CON          00005\n *                                                                      00006\n *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A CONNECT         00007\n *  TO A SERVER ON A SOCKET CREATED BY BPX1SOC.                         00008\n *                                                                      00009\n *  FIRST PARM  - SOCKET (INPUT)                                        00010\n *                SOCKET RETURNED BY BPX1SOC                            00011\n *                                                                      00012\n *  SECOND PARM - SOCKADDR_LENGTH (INPUT)                               00013\n *                LENGTH OF THE THIRD PARM.  USE SOCK_SIN#LEN FROM      00014\n *                FG501277.BPXYSOCK.                                    00015\n *                                                                      00016\n *  THIRD PARM  - SOCKADDR OF SERVER (INPUT)                            00017\n *                THE STRUCTURE FROM FG501277.BPXYSOCK IS INTIALIZED    00018\n *                WITH THE IP ADDRESS AND PORT FOR THE SERVER.          00019\n *                                                                      00020\n *  FORTH PARM  - UNIX RC (OUTPUT)                                      00021\n *                0 ON SUCCESS -1 ON ERROR.   ON SUCCESS, THE FIRST     00022\n *                PARM (SOCKET) IS CONNECTED TO THE SERVER.             00023\n *                                                                      00024\n *  FIFTH PARM  - ERRNO (OUTPUT)                                        00025\n *                REASON FOR ERROR, SEE FG501277.STRERR TO INTERPRET.   00026\n *                                                                      00027\n *  SIXTH PARM  - REASON(OUTPUT)                                        00028\n *                REASON FOR ERROR, SEE FG501277.STRREA TO INTERPRET.   00029\n *                                                                      00030\n ***************************************************************/       00031\n                                                                        00032\n DECLARE  BPX1CON      ENTRY(                                           00033\n          FIXED BINARY(31), /* INPUT: SOCKET_DESCRIPTOR,           */   00034\n          FIXED BINARY(31), /* INPUT: SOCKADDR_LENGTH,             */   00035\n          01 UNALIGNED,     /* INPUT: SOCKADDR OF SERVER           */   00036\n             02  BIT(8),           /*  SOCK_SIN#BIN                */   00037\n             02  BIT(8),           /*  AF_INET_BITS                */   00038\n             02  FIXED BINARY(15), /*  PORT NUMBER                 */   00039\n             02  FIXED BINARY(31), /*  BIN IP ADDR FG501277.IP2BIN */   00040\n             02  CHAR(8),          /*  USE LOW(8) BINARY ZERO      */   00041\n          FIXED BINARY(31), /* OUTPUT: UNIX RC 0  OR -1 ON ERROR   */   00042\n          FIXED BINARY(31), /* OUTPUT: ERRNO                       */   00043\n          FIXED BINARY(31)) /* OUTPUT: REASON                      */   00044\n                       OPTIONS(ASM) EXTERNAL;                           00045\n                                                                        00046\n        /* DATA SET IP2BIN     AT LEVEL 000 AS OF 04/12/04    */\n /********************************************************************* 00001\n *                                                                      00002\n *  SUBSET FG501277.IP2BIN                                              00003\n *                                                                      00004\n *  ROUTINE TO CONVERT A DOTTED IP ADDRESS INTO A BINARY IP ADDRESS     00005\n *  SUITABLE FOR USE WITH SOCKADDR.SOCK_SIN_ADDR IN FG501277.BPXYSOCK.  00006\n *                                                                      00007\n *  THIS ROUTINE IS SO SMALL, IT IS INCLUDED INLINE.                    00008\n *                                                                      00009\n *  FIRST PARM  - DOTTED_IP (INPUT)                                     00010\n *                THE 4 PART DOTTED IP ADDRESS TO CONVERT.              00011\n *                                                                      00012\n *  RETURNED    - BINARY IPFIXED BINARY(31)                             00013\n *                THIS IS THE PASSED PARM IN BINARY FORMAT.             00014\n *                                                                      00015\n *  SAMPLE CALL:                                                        00016\n *  SOCKADDR.SOCK_SIN_ADDR = IP2BIN('192.168.123.45')                   00017\n *                                                                      00018\n ***************************************************************/       00019\n                                                                        00020\n IP2BIN:                                                                00021\n    PROCEDURE(DOTTED_IP) RETURNS(FIXED BINARY(31));                     00022\n DECLARE  DOTTED_IP         VARYING CHAR(*);                            00023\n                                                                        00024\n DECLARE  WORK_IP           VARYING CHAR(20) AUTO;                      00025\n DECLARE  PARTS(4)          FIXED BINARY(31) AUTO INIT(0,0,0,0);        00026\n DECLARE  PART              VARYING CHAR(4) AUTO INIT('');              00027\n DECLARE  BIN_IP            FIXED BINARY(31) AUTO INIT(0);              00028\n DECLARE  BIN_IP_BITS(4)    BIT(8) BASED(ADDR(BIN_IP));                 00029\n DECLARE  PARTS_BITS(16)    BIT(8) BASED(ADDR(PARTS));                  00030\n DECLARE  TRANSLATE         BUILTIN;                                    00031\n DECLARE  ADDR              BUILTIN;                                    00032\n                                                                        00033\n WORK_IP = TRANSLATE(DOTTED_IP, ' ', '.');                              00034\n GET STRING(WORK_IP) LIST(PARTS(1), PARTS(2), PARTS(3), PARTS(4));      00035\n BIN_IP_BITS(1) = PARTS_BITS(4);                                        00036\n BIN_IP_BITS(2) = PARTS_BITS(8);                                        00037\n BIN_IP_BITS(3) = PARTS_BITS(12);                                       00038\n BIN_IP_BITS(4) = PARTS_BITS(16);                                       00039\n RETURN(BIN_IP);                                                        00040\n                                                                        00041\n END IP2BIN;                                                            00042\n        /* DATA SET BIN2IP     AT LEVEL 000 AS OF 04/12/04    */\n /********************************************************************* 00001\n *                                                                      00002\n *  SUBSET FG501277.BIN2IP                                              00003\n *                                                                      00004\n *  ROUTINE TO CONVERT A DOTTED IP ADDRESS INTO A BINARY IP ADDRESS     00005\n *  SUITABLE FOR USE WITH SOCKADDR.SOCK_SIN_ADDR IN FG501277.BPXYSOCK.  00006\n *                                                                      00007\n *  THIS ROUTINE IS SO SMALL, IT IS INCLUDED INLINE.                    00008\n *                                                                      00009\n *  FIRST PARM  - DOTTED_IP (INPUT)                                     00010\n *                THE 4 PART DOTTED IP ADDRESS TO CONVERT.              00011\n *                                                                      00012\n *  RETURNED    - BINARY IPFIXED BINARY(31)                             00013\n *                THIS IS THE PASSED PARM IN BINARY FORMAT.             00014\n *                                                                      00015\n *  SAMPLE CALL:                                                        00016\n *  PUT SKIP EDIT(BIN2IP(SOCKADDR.SOCK_SIN_ADDR))(A)                    00017\n *                                                                      00018\n ***************************************************************/       00019\n                                                                        00020\n BIN2IP:                                                                00021\n    PROCEDURE(INET) RETURNS(VARYING CHAR(20));                          00022\n DECLARE INET            FIXED BINARY(31);                              00023\n                                                                        00024\n DECLARE OV1             CHAR(4) BASED(ADDR(INET));                     00025\n DECLARE WORK2           FIXED BINARY(31);                              00026\n DECLARE OV2(4)          CHAR(1) BASED(ADDR(WORK2));                    00027\n DECLARE WORK3           PIC'ZZZZ9';                                    00028\n DECLARE OUTSTR          VARYING CHAR(20) INIT('');                     00029\n DECLARE I               FIXED BINARY(31);                              00030\n DECLARE NON_BLANK       FIXED BINARY(31);                              00031\n                                                                        00032\n DO I = 1 TO 4;                                                         00033\n    WORK2 = 0;                                                          00034\n    OV2(4) = SUBSTR(OV1,I,1);                                           00035\n    WORK3 = WORK2;                                                      00036\n    NON_BLANK = VERIFY(WORK3, ' ');                                     00037\n    IF NON_BLANK \u00ac= 0                                                   00038\n    THEN                                                                00039\n       OUTSTR = OUTSTR || SUBSTR(WORK3, NON_BLANK);                     00040\n    ELSE                                                                00041\n       OUTSTR = OUTSTR || '0'; /* SHOULD NEVER HAPPEN */                00042\n    IF I < 4                                                            00043\n    THEN                                                                00044\n       OUTSTR = OUTSTR || '.';                                          00045\n END;                                                                   00046\n                                                                        00047\n RETURN(OUTSTR);                                                        00048\n END BIN2IP;                                                            00049\n                                                                        00702\n        /* DATA SET BPXYSOCK   AT LEVEL 000 AS OF 04/12/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPXYSOCK                                            00003\n *                                                                      00004\n *  DECLARE FOR A SOCKADDR                                              00005\n *                                                                      00006\n *  IP ROUTINES SUCH AS BPX1RFM (RECVFROM) AND BPX1STO (SENDTO)         00007\n *  USE THIS STRUCTURE TO IDENTIFY THE MACHINE THE DATA IS              00008\n *  COMING FROM OR GOING TO.                                            00009\n *                                                                      00010\n *  AF_INET SOCKET ADDRESS STRUCTURE                                    00011\n *                                                                      00012\n *  SOCK_LEN      - USE SOCK_SIN#BIN                                    00013\n *                                                                      00014\n *  SOCK_FAMILY   - USE AF_INET_BITS                                    00015\n *                                                                      00016\n *  SOCK_SIN_PORT - PORT TO SEND TO OR DATA CAME FROM                   00017\n *                                                                      00018\n *  SOCK_SIN_ADDR - IP ADDRESS IN BINARY.  ONE BYTE PER NUMBER.         00019\n *                  THAT IS 130.131.36.72 IS X'82832448'                00020\n *                  NETWORK ORDER, WHICH IS BIG ENDIAN.                 00021\n *                                                                      00022\n *  RESERVED_1    - SET TO BINARY ZEROS - LOW(8)                        00023\n *                                                                      00024\n *  SAMPLE INITIALIZATION:                                              00025\n *                                                                      00026\n *  SOCKADDR.SOCK_LEN      = SOCK_SIN#BIN                               00027\n *  SOCKADDR.SOCK_FAMILY   = AF_INET_BITS                               00028\n *  SOCKADDR.SOCK_SIN_PORT = 19999                                      00029\n *  SOCKADDR.SOCK_SIN_ADDR = IP2BIN('192.168.123.45')                   00030\n *  SOCKADDR.RESERVED_1    = LOW(8)                                     00031\n *                                                                      00032\n *  FIND IP2BIN IN FG501277.IP2BIN                                      00033\n *                                                                      00034\n ***************************************************************/       00035\n                                                                        00036\n DECLARE  01 SOCKADDR  UNALIGNED BASED,                                 00037\n             02  SOCK_LEN         BIT(8),           /* SOCK_SIN#BIN */  00038\n             02  SOCK_FAMILY      BIT(8),           /* AF_INET_BITS */  00039\n             02  SOCK_SIN_PORT    FIXED BINARY(15), /* PORT NUMBER  */  00040\n             02  SOCK_SIN_ADDR    FIXED BINARY(31), /* BIN IP ADDR  */  00041\n             02  RESERVED_1       CHAR(8);                              00042\n                                                                        00043\n /***************************************************************       00044\n *  VALUE PUT IN SOCK_LEN                                               00045\n *  USE SOCK_SIN#LEN IN CALL TO BXP1BND                                 00046\n *  USE SOCK_SIN#BIN IN STRUCTURE MEMBER SOCK_LEN                       00047\n ***************************************************************/       00048\n DECLARE SOCK_SIN#LEN  FIXED BINARY(31) STATIC INIT(16);                00049\n DECLARE SOCK_SIN#BIN  BIT(8)           STATIC INIT('00010000'B);       00050\n                                                                        00051\n /***************************************************************       00052\n *  VALUE PUT IN SOCK_FAMILY                                            00053\n ***************************************************************/       00054\n DECLARE  AF_INET_BITS        BIT(8) STATIC INIT('00000010'B);          00055\n                                                                        00056\n        /* DATA SET BPXYSELT   AT LEVEL 000 AS OF 02/05/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.BPXYSELT                                            00003\n *                                                                      00004\n *  DECLARE FOR A SOCKADDR                                              00005\n *                                                                      00006\n *  STRUCTURE USED FOR TIMEOUT IN SELECT (BPX1SEL)                      00007\n *                                                                      00008\n ***************************************************************/       00009\n                                                                        00010\n DECLARE  01  BPXYSELT BASED,                                           00011\n              02  TV_SEC   FIXED BINARY(31), /* SECONDS       */        00012\n              02  TV_USEC  FIXED BINARY(31); /* MICRO SECONDS */        00013\n                                                                        00014\n        /* DATA SET BPXYERNOCM AT LEVEL 000 AS OF 03/15/04    */\n /****************************************************************      00001\n *                                                               *      00002\n *  SUBSET FG501277.BPXYERNOCM                                   *      00003\n *                                                               *      00004\n *  COMMON OPENMVS COMPONENT ERRNO VALUES.                       *      00005\n *                                                               *      00006\n *  THIS IS A SUBSET OF FG501277.BPXYERNO WITH THE COMMONLY USED *      00007\n *  VALUES.                                                      *      00008\n *                                                               *      00009\n ****************************************************************/      00010\n DECLARE  MVS_EACCES               FIXED BIN(15) STATIC INIT(111);      00011\n DECLARE  MVS_EEXIST               FIXED BIN(15) STATIC INIT(117);      00012\n DECLARE  MVS_ENOENT               FIXED BIN(15) STATIC INIT(129);      00013\n DECLARE  MVS_EWOULDBLOCK          FIXED BIN(15) STATIC INIT(1102);     00014\n DECLARE  MVS_EIO                  FIXED BIN(15) STATIC INIT(122);      00015\n                                                                        00706\n        /* DATA SET GETDSN     AT LEVEL 000 AS OF 01/19/87    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                            SUBSET GETDSN                            *00002\n *                                                                     *00003\n * DECLARATION FOR FUNCTIONS GETDSN, GETVOL, GETMEM, AND GETMODE.      *00003\n *                                                                     *00004\n * GETDSN RETURNS THE 44 CHARACTER DATASET NAME GIVEN THE DDNAME.      *00004\n * DSNAME = GETDSN(DDNAME)                                             *00006\n *                                                                     *00007\n * GETVOL RETURNS A 6 CHARACTER VOLUME SERIAL NUMBER OF THE VOLUME     *00007\n * CONTAINING THE DATASET GIVEN THE DDNAME.                            *00007\n * VOLSER = GETVOL(DDNAME)                                             *00009\n *                                                                     *00010\n * FOR EITHER FUNCTION, BLANKS ARE RETURNED IF THE DDNAME IS NOT       *00010\n * FOUND.                                                              *00010\n *                                                                     *00012\n * GETMEM RETURNS A 8 CHARACTER MEMBER NAME TAKEN FROM THE DD OR       *00012\n * ALLOCATE STATMENT FOR THE DATASET WITH THE PASSED DDNAME.           *00012\n * MEMBER = GETVOL(DDNAME)                                             *00014\n *                                                                     *00015\n * FOR THIS FUNCTION, BLANKS ARE RETURNED IF THE DDNAME IS NOT FOUND   *00015\n * OR THERE IS NO MEMBER.                                              *00015\n *                                                                     *00017\n * GETMODE RETURNS A FIXED BINARY(15) SPECIFYING THE CURRENT           *00017\n * ADDRESSING AND RESIDENCY MODES.                                     *00017\n * 0  -  RMODE=24, AMODE=24                                            *00019\n * 1  -  RMODE=24, AMODE=31                                            *00020\n * 2  -  RMODE=31, AMODE=31                                            *00021\n * MODE = GETMODE()                                                    *00022\n *                                                                     *00023\n * ON A NON-XA SYSTEM, ZERO IS ALWAYS RETURNED.                        *00023\n *                                                                     *00024\n **********************************************************************/00024\n0   DECLARE GETDSN  ENTRY(CHAR(8)) RETURNS(CHAR(44)) EXTERNAL;          00025\n0   DECLARE GETVOL  ENTRY(CHAR(8)) RETURNS(CHAR(6))  EXTERNAL;          00026\n0   DECLARE GETMEM  ENTRY(CHAR(8)) RETURNS(CHAR(8))  EXTERNAL;          00027\n0   DECLARE GETMODE ENTRY          RETURNS(FIXED BINARY(15)) EXTERNAL;  00028\n        /* DATA SET BREAK      AT LEVEL 000 AS OF 10/22/86    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                            SUBSET BREAK                             *00002\n * DECLARATION FOR FUNCTION BREAK (LIKE SPITBOL BREAK)                 *00003\n *                                                                     *00004\n **********************************************************************/00004\n0 DECLARE BREAK     ENTRY(VARYING CHAR(*),VARYING CHAR(*))              00005\n                          RETURNS(FIXED BINARY(15)) EXTERNAL;           00006\n        /* DATA SET REVERSE    AT LEVEL 000 AS OF 11/05/86    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET REVERSE                            *00002\n * DECLARATION FOR FUNCTION REVERSE                                    *00003\n * THIS ROUTINE WILL RETURN THE STRING PASSED IN REVERSE ORDER, E.I.   *00004\n * WITH THE FIRST CHARACTER LAST, ETC.                                 *00004\n *                                                                     *00006\n * BACKWARD_STRING = REVERSE(STRING)                                   *00006\n *                                                                     *00007\n * SOURCE IS IN FG500242                                               *00007\n *                                                                     *00008\n **********************************************************************/00008\n0   DECLARE REVERSE ENTRY(VARYING CHAR(*))                              00009\n                    RETURNS(VARYING CHAR(256)) EXTERNAL;                00010\n        /* DATA SET LOWERCASE  AT LEVEL 000 AS OF 09/29/87    */\n0/**********************************************************************00001\n *                                                                     *00001\n * THIS IS TWO CONSTANTS WHICH ARE USED TO CONVERT FROM LOWER CASE TO  *00001\n * UPPER CASE                                                          *00001\n *                                                                     *00004\n **********************************************************************/00004\n0   DECLARE UPPER_CASE_LETTERS CHAR(26) STATIC INIT(                    00005\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZ');                                      00006\n0   DECLARE LOWER_CASE_LETTERS CHAR(26) STATIC INIT(                    00007\n    'abcdefghijklmnopqrstuvwxyz');                                      00008\n                                                                        00711\n END FLEXCLI;                                                           00712\n*PROCESS;                                                               00001\n        /* DATA SET FG50132601 AT LEVEL 006 AS OF 02/05/04    */\n FDZERO:                                                                00002\n    PROCEDURE(FD_SET) REORDER OPTIONS(REENTRANT);                       00003\n DECLARE  FD_SET(*)      FIXED BINARY(31);                              00004\n                                                                        00005\n FD_SET = 0;                                                            00006\n                                                                        00007\n        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET DEFAULT                            *00002\n *                                                                     *00003\n * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003\n * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003\n * EASIER REENTRANCY.                                                  *00003\n *                                                                     *00006\n **********************************************************************/00006\n                                                                        00007\n DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008\n                  DESCRIPTORS ALIGNED;                                  00009\n        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.FDZERO                                              00003\n *                                                                      00004\n *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005\n *                                                                      00006\n *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007\n *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008\n *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009\n *  TO THE SELECT FUNCTION.                                             00010\n *                                                                      00011\n *  FDZERO      - ZERO AN FDSET                                         00012\n *                                                                      00013\n *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014\n *                                                                      00015\n *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016\n *                                                                      00017\n *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018\n *  DECLARE   SOCKET       FIXED BINARY(31)                             00019\n *  CALL FDZERO(READ_FDS)                                               00020\n *  CALL FDSET(READ_FDS, SOCKET)                                        00021\n *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022\n *  CALL FDISSET(READ_FDS, SOCKET)                                      00023\n *                                                                      00024\n *  SOURCE IS IN FG501326                                               00025\n *                                                                      00026\n ***************************************************************/       00027\n                                                                        00028\n DECLARE  FDZERO       ENTRY(                                           00029\n          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030\n          EXTERNAL;                                                     00031\n                                                                        00032\n DECLARE  FDSET        ENTRY(                                           00033\n          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035\n          EXTERNAL;                                                     00036\n                                                                        00037\n DECLARE  FDISSET      ENTRY(                                           00038\n          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040\n          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041\n                                                                        00042\n                                                                        00010\n END FDZERO;                                                            00011\n*PROCESS;                                                               00012\n /* THIS ROUTINE ASSUMES SEL#BITSFOREWARD IS PASSED TO SELECT */        00013\n /* THIS MEANS THAT BITS ARE IN FORWARD ORDER */                        00014\n FDSET:                                                                 00015\n    PROCEDURE(FD_SET, FD) REORDER OPTIONS(REENTRANT);                   00016\n DECLARE  FD_SET(8)      FIXED BINARY(31) CONNECTED;                    00017\n DECLARE  FD             FIXED BINARY(31);                              00018\n                                                                        00019\n DECLARE  FD_SET_OVLY(0:7) BIT(32) BASED(ADDR(FD_SET));                 00020\n DECLARE  INDX           FIXED BINARY(31);                              00021\n DECLARE  BITX           FIXED BINARY(31);                              00022\n                                                                        00023\n DECLARE  PATTERNS(0:31) BIT(32)          STATIC INIT(                  00024\n                                 '10000000000000000000000000000000'B,   00025\n                                 '01000000000000000000000000000000'B,   00026\n                                 '00100000000000000000000000000000'B,   00027\n                                 '00010000000000000000000000000000'B,   00028\n                                 '00001000000000000000000000000000'B,   00029\n                                 '00000100000000000000000000000000'B,   00030\n                                 '00000010000000000000000000000000'B,   00031\n                                 '00000001000000000000000000000000'B,   00032\n                                 '00000000100000000000000000000000'B,   00033\n                                 '00000000010000000000000000000000'B,   00034\n                                 '00000000001000000000000000000000'B,   00035\n                                 '00000000000100000000000000000000'B,   00036\n                                 '00000000000010000000000000000000'B,   00037\n                                 '00000000000001000000000000000000'B,   00038\n                                 '00000000000000100000000000000000'B,   00039\n                                 '00000000000000010000000000000000'B,   00040\n                                 '00000000000000001000000000000000'B,   00041\n                                 '00000000000000000100000000000000'B,   00042\n                                 '00000000000000000010000000000000'B,   00043\n                                 '00000000000000000001000000000000'B,   00044\n                                 '00000000000000000000100000000000'B,   00045\n                                 '00000000000000000000010000000000'B,   00046\n                                 '00000000000000000000001000000000'B,   00047\n                                 '00000000000000000000000100000000'B,   00048\n                                 '00000000000000000000000010000000'B,   00049\n                                 '00000000000000000000000001000000'B,   00050\n                                 '00000000000000000000000000100000'B,   00051\n                                 '00000000000000000000000000010000'B,   00052\n                                 '00000000000000000000000000001000'B,   00053\n                                 '00000000000000000000000000000100'B,   00054\n                                 '00000000000000000000000000000010'B,   00055\n                                 '00000000000000000000000000000001'B);  00056\n                                                                        00057\n INDX = FD / 32;                                                        00058\n BITX = MOD(FD,32);                                                     00059\n                                                                        00060\n FD_SET_OVLY(INDX) = FD_SET_OVLY(INDX) | PATTERNS(BITX);                00061\n                                                                        00062\n                                                                        00063\n        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET DEFAULT                            *00002\n *                                                                     *00003\n * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003\n * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003\n * EASIER REENTRANCY.                                                  *00003\n *                                                                     *00006\n **********************************************************************/00006\n                                                                        00007\n DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008\n                  DESCRIPTORS ALIGNED;                                  00009\n        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.FDZERO                                              00003\n *                                                                      00004\n *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005\n *                                                                      00006\n *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007\n *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008\n *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009\n *  TO THE SELECT FUNCTION.                                             00010\n *                                                                      00011\n *  FDZERO      - ZERO AN FDSET                                         00012\n *                                                                      00013\n *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014\n *                                                                      00015\n *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016\n *                                                                      00017\n *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018\n *  DECLARE   SOCKET       FIXED BINARY(31)                             00019\n *  CALL FDZERO(READ_FDS)                                               00020\n *  CALL FDSET(READ_FDS, SOCKET)                                        00021\n *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022\n *  CALL FDISSET(READ_FDS, SOCKET)                                      00023\n *                                                                      00024\n *  SOURCE IS IN FG501326                                               00025\n *                                                                      00026\n ***************************************************************/       00027\n                                                                        00028\n DECLARE  FDZERO       ENTRY(                                           00029\n          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030\n          EXTERNAL;                                                     00031\n                                                                        00032\n DECLARE  FDSET        ENTRY(                                           00033\n          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035\n          EXTERNAL;                                                     00036\n                                                                        00037\n DECLARE  FDISSET      ENTRY(                                           00038\n          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040\n          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041\n                                                                        00042\n                                                                        00066\n DECLARE  MOD             BUILTIN;                                      00067\n DECLARE  ADDR            BUILTIN;                                      00068\n                                                                        00069\n END FDSET;                                                             00070\n*PROCESS;                                                               00071\n /* THIS ROUTINE ASSUMES SEL#BITSFOREWARD IS PASSED TO SELECT */        00072\n /* THIS MEANS THAT BITS ARE IN FORWARD ORDER */                        00073\n FDISSET:                                                               00074\n    PROCEDURE(FD_SET, FD) RETURNS(BIT(1) ALIGNED)                       00075\n    REORDER OPTIONS(REENTRANT);                                         00076\n DECLARE  FD_SET(8)      FIXED BINARY(31) CONNECTED;                    00077\n DECLARE  FD             FIXED BINARY(31);                              00078\n                                                                        00079\n DECLARE  FD_SET_OVLY(0:7)  BIT(32) BASED(ADDR(FD_SET));                00080\n DECLARE  INDX           FIXED BINARY(31);                              00081\n DECLARE  BITX           FIXED BINARY(31);                              00082\n                                                                        00083\n DECLARE  PATTERNS(0:31) BIT(32)          STATIC INIT(                  00084\n                                 '10000000000000000000000000000000'B,   00085\n                                 '01000000000000000000000000000000'B,   00086\n                                 '00100000000000000000000000000000'B,   00087\n                                 '00010000000000000000000000000000'B,   00088\n                                 '00001000000000000000000000000000'B,   00089\n                                 '00000100000000000000000000000000'B,   00090\n                                 '00000010000000000000000000000000'B,   00091\n                                 '00000001000000000000000000000000'B,   00092\n                                 '00000000100000000000000000000000'B,   00093\n                                 '00000000010000000000000000000000'B,   00094\n                                 '00000000001000000000000000000000'B,   00095\n                                 '00000000000100000000000000000000'B,   00096\n                                 '00000000000010000000000000000000'B,   00097\n                                 '00000000000001000000000000000000'B,   00098\n                                 '00000000000000100000000000000000'B,   00099\n                                 '00000000000000010000000000000000'B,   00100\n                                 '00000000000000001000000000000000'B,   00101\n                                 '00000000000000000100000000000000'B,   00102\n                                 '00000000000000000010000000000000'B,   00103\n                                 '00000000000000000001000000000000'B,   00104\n                                 '00000000000000000000100000000000'B,   00105\n                                 '00000000000000000000010000000000'B,   00106\n                                 '00000000000000000000001000000000'B,   00107\n                                 '00000000000000000000000100000000'B,   00108\n                                 '00000000000000000000000010000000'B,   00109\n                                 '00000000000000000000000001000000'B,   00110\n                                 '00000000000000000000000000100000'B,   00111\n                                 '00000000000000000000000000010000'B,   00112\n                                 '00000000000000000000000000001000'B,   00113\n                                 '00000000000000000000000000000100'B,   00114\n                                 '00000000000000000000000000000010'B,   00115\n                                 '00000000000000000000000000000001'B);  00116\n                                                                        00117\n INDX = FD / 32;                                                        00118\n BITX = MOD(FD,32);                                                     00119\n                                                                        00120\n IF (FD_SET_OVLY(INDX) & PATTERNS(BITX))                                00121\n THEN                                                                   00122\n    RETURN('1'B);                                                       00123\n ELSE                                                                   00124\n    RETURN('0'B);                                                       00125\n                                                                        00126\n        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */\n0/**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET DEFAULT                            *00002\n *                                                                     *00003\n * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003\n * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003\n * EASIER REENTRANCY.                                                  *00003\n *                                                                     *00006\n **********************************************************************/00006\n                                                                        00007\n DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008\n                  DESCRIPTORS ALIGNED;                                  00009\n        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */\n /***************************************************************       00001\n *                                                                      00002\n *  SUBSET FG501277.FDZERO                                              00003\n *                                                                      00004\n *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005\n *                                                                      00006\n *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007\n *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008\n *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009\n *  TO THE SELECT FUNCTION.                                             00010\n *                                                                      00011\n *  FDZERO      - ZERO AN FDSET                                         00012\n *                                                                      00013\n *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014\n *                                                                      00015\n *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016\n *                                                                      00017\n *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018\n *  DECLARE   SOCKET       FIXED BINARY(31)                             00019\n *  CALL FDZERO(READ_FDS)                                               00020\n *  CALL FDSET(READ_FDS, SOCKET)                                        00021\n *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022\n *  CALL FDISSET(READ_FDS, SOCKET)                                      00023\n *                                                                      00024\n *  SOURCE IS IN FG501326                                               00025\n *                                                                      00026\n ***************************************************************/       00027\n                                                                        00028\n DECLARE  FDZERO       ENTRY(                                           00029\n          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030\n          EXTERNAL;                                                     00031\n                                                                        00032\n DECLARE  FDSET        ENTRY(                                           00033\n          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035\n          EXTERNAL;                                                     00036\n                                                                        00037\n DECLARE  FDISSET      ENTRY(                                           00038\n          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039\n          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040\n          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041\n                                                                        00042\n                                                                        00129\n DECLARE  MOD             BUILTIN;                                      00130\n DECLARE  ADDR            BUILTIN;                                      00131\n                                                                        00132\n END FDISSET;                                                           00133\n*PROCESS;                                                               00001\n        /* DATA SET FG50078104 AT LEVEL 015 AS OF 10/06/89    */\n0/**********************************************************************00002\n *                                                                     *00002\n * SEGMENT NAME:                                                       *00002\n *                                                                     *00002\n *    GETPARM -- EXTRACT A KEYWORD PARAMETER FROM A PARM STRING        *00002\n *                                                                     *00028\n * INPUTS (*TO FUNCTIONS):                                             *00028\n *                                                                     *00003\n *    PARM_STRING -- STRING CONTAINING ALL PARAMETERS (*1,2)           *00003\n *       THE FIRST PARMAMETER TO THIS ROUTINE IS A VARYING LENGTH      *00004\n *       STRING WHICH IS BELIEVED TO CONTAIN THE REQUESTED PARAMETER.  *00004\n *                                                                     *00006\n *    PARM_HEADER -- KEYWORD IDENTIFIER FOR THE STRING. (*1)           *00006\n *       PARAMETERS WITHIN THE PARM STRING ARE IDENTIFIED BY A KEYWORD *00007\n *       HEADER WHICH IS THE SECOND PARAMETER TO THIS ROUTINE.  THE    *00007\n *       HEADERS COME IN TWO VARIETIES.                                *00007\n *                                                                     *00010\n *       XXX=VALUE                                                     *00010\n *       THIS VARIETY IS USED FOR EXTRACTING SIMPLE PARMS.  THE        *00011\n *       PARM_STRING IS SCANNED FOR XXX= AND THE VALUE IS ASSUMED TO   *00011\n *       START AFTER THE EQUAL SIGN.  THE VALUE IS TERMINATED BY A     *00011\n *       COMMA OR END OF STRING.                                       *00011\n *                                                                     *00014\n *       XXX(VALUE)                                                    *00014\n *       THIS VARIETY IS USED FOR EXTRACTING MORE COMPLEX PARMS WHICH  *00015\n *       MAY CONTAIN A COMMA.  THE VALUE IS ASSUMED TO START AFTER THE *00015\n *       OPEN PAREN.  THE VALUE IS TERMINATED BY THE MATCHING CLOSE    *00015\n *       PAREN OR END OF STRING.  MATCHING SETS OF PARENS IN THE VALUE *00015\n *       ARE HANDLED PROPERLY.  MISMATCHED PARENS WILL CAUSE THE END   *00015\n *       OF THE VALUE SECTION TO BE NOT HANDLED PROPERLY.              *00015\n *       VALUES: XXX=VALUE                                             *00021\n *               XXX(VALUE)                                            *00022\n *                                                                     *00027\n * FUNCTIONS:                                                          *00027\n *                                                                     *00027\n *    1. SCAN THE PARM STRING FOR THE PARM HEADER                      *00027\n *                                                                     *00031\n *    2. FIND THE TRAILING DELIMITER FOR THE PARM AND EXTRACT THE PARM *00031\n *       VALUE.                                                        *00031\n *                                                                     *00030\n * OUTPUTS (*FROM FUNCTIONS):                                          *00030\n *                                                                     *00023\n *    VALUE -- RETURNED PARM VALUE (*1,2)                              *00023\n *       THE RETURNED VALUE FROM THIS ROUTINE IS THE VALUE EXTRACTED   *00024\n *       FROM THE PARAMETER.  THE LENGTH VALUE 2048 IS ARBITRARY.      *00024\n *                                                                     *00035\n * NOTES:                                                              *00035\n *                                                                     *00035\n *    1. ISSUE HISTORY                                                 *00035\n *                                                                     *00036\n *       REASON FOR ISSUE 03:                                          *00036\n *       MODIFY CODE TO MAKE SURE THAT THE CHARACTER BEFORE THE SCAN   *00037\n *       STRING IS A VALID DELIMITER.                                  *00037\n *                                                                     *00039\n *       REASON FOR ISSUE 04:                                          *00039\n *       MAKE REENTRANT WITH OPTIONS(REENTRANT).                       *00040\n *                                                                     *00041\n **********************************************************************/00041\n-GETPARM:                                                               00042\n    PROCEDURE(PARM_STRING,PARM_HEADER)                                  00043\n              RETURNS(VARYING CHAR(2048)) OPTIONS(REENTRANT) REORDER;   00044\n    DECLARE PARM_STRING     VARYING CHAR(*);                            00045\n    DECLARE PARM_HEADER     VARYING CHAR(*);                            00046\n                                                                        00047\n    DEFAULT RANGE(*) ALIGNED;                                           00048\n                                                                        00049\n    DECLARE I               FIXED BINARY(15)   AUTO;                    00050\n    DECLARE J               FIXED BINARY(15)   AUTO;                    00051\n    DECLARE TEMP_PARM       VARYING CHAR(2048) AUTO;                    00052\n    DECLARE C               CHAR(1)            AUTO;                    00053\n    DECLARE NEST_CHAR       CHAR(1)            AUTO INIT(' ');          00054\n    DECLARE NEST_LEVEL      FIXED BINARY(15)   AUTO INIT(0);            00055\n                                                                        00056\n    DECLARE (LENGTH, PLIRETC, INDEX, SUBSTR, VERIFY) BUILTIN;           00057\n                                                                        00058\n    I = INDEX(PARM_STRING,PARM_HEADER);                                 00059\n    IF I = 0                                                            00060\n    THEN                                                                00061\n       RETURN('');                                                      00062\n    ELSE                                                                00063\n       DO;                                                              00064\n          DO WHILE(VALID_DLM(I-1) = '0'B);                              00065\n             J = INDEX(SUBSTR(PARM_STRING,I+1),PARM_HEADER);            00066\n             IF J = 0                                                   00067\n             THEN                                                       00068\n                RETURN('');                                             00069\n             I = I + J;                                                 00070\n          END;                                                          00071\n          IF I = 0                                                      00072\n          THEN                                                          00073\n             RETURN('');                                                00074\n          C = SUBSTR(PARM_HEADER,LENGTH(PARM_HEADER),1);                00075\n          IF C = '('                                                    00076\n          THEN                                                          00077\n             DO;                                                        00078\n                C = ')';                                                00079\n                NEST_CHAR = '(';                                        00080\n             END;                                                       00081\n          ELSE                                                          00082\n             C = ',';                                                   00083\n          TEMP_PARM = SUBSTR(PARM_STRING,I+LENGTH(PARM_HEADER));        00084\n          DO I = 1 TO LENGTH(TEMP_PARM);                                00085\n             IF NEST_CHAR \u00ac= ' ' & SUBSTR(TEMP_PARM,I,1) = NEST_CHAR    00086\n             THEN                                                       00087\n                NEST_LEVEL = NEST_LEVEL + 1;                            00088\n             IF SUBSTR(TEMP_PARM,I,1) = C                               00089\n             THEN                                                       00090\n                DO;                                                     00091\n                   IF NEST_LEVEL = 0                                    00092\n                   THEN                                                 00093\n                      DO;                                               00094\n                         IF I = 1                                       00095\n                         THEN                                           00096\n                            RETURN('');                                 00097\n                         ELSE                                           00098\n                            RETURN(SUBSTR(TEMP_PARM,1,I-1));            00099\n                      END;                                              00100\n                   ELSE                                                 00101\n                      NEST_LEVEL = NEST_LEVEL - 1;                      00102\n                END;                                                    00103\n          END;                                                          00104\n          RETURN(TEMP_PARM);                                            00105\n       END;                                                             00106\n1                                                                       00107\n VALID_DLM:                                                             00108\n    PROCEDURE(IND);                                                     00109\n    DECLARE  IND  FIXED BINARY(15);                                     00110\n    DECLARE  C    CHAR(1) AUTO;                                         00111\n    IF IND <= 0                                                         00112\n    THEN                                                                00113\n       RETURN('1'B); /* START OF STRING IS OK */                        00114\n    C = SUBSTR(PARM_STRING,IND,1);                                      00115\n    IF VERIFY(C,', )/(`~*''') = 0                                       00116\n    THEN                                                                00117\n       RETURN('1'B); /* IS A VALID DELIMITER */                         00118\n    ELSE                                                                00119\n       RETURN('0'B); /* NOT A VALID LEADING DELIMITER */                00120\n0END VALID_DLM;                                                         00121\n0END GETPARM;                                                           00122\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAR": {"ttr": 7432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x08\\x0f\\x01\\x05\\x08\\x0f\\x06@\\x05\\xa7\\x05\\xa7\\x00\\x00\\xe3\\xc1\\xd9\\xc6\\xc9\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-21T00:00:00", "modifydate": "2005-03-21T06:40:00", "lines": 1447, "newlines": 1447, "modlines": 0, "user": "TARFILE"}, "mimetype": "application/x-tar", "datatype": "binary", "extension": ".tar"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT714/FILE714.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT714", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}