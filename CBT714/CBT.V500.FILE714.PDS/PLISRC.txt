        /* DATA SET FG50133001 AT LEVEL 018 AS OF 06/12/04    */
 /********************************************************************* 00001
 *                                                                      00002
 * PROGRAM:                                                             00003
 *   FLEXCLI -  FLEXESCLI_CMD_INTERFACE                                 00004
 *                                                                      00005
 *   THIS PROGRAM ALLOWS THE CALLER TO PASS COMMANDS TO THE             00006
 *   FLEXESCLI PROGRAM ON THE UNIX SIDE OF THE FLEXES SYSTEM.           00007
 *   THIS IS USEFUL FOR MOUNTING TAPES.  COMMANDS CAN BE                00008
 *   ENTERED VIA DDNAME SYSIN OR AS A SEMICOLON SEPARATED LIST          00009
 *   IN THE PARM STRING.                                                00010
 *                                                                      00011
 * MAINPARM OPTIONS:  (100 CHAR LIMIT IMPOSED BY MVS)                   00012
 *                                                                      00013
 *   IP=    - DOTTED NOTATION IP ADDRESS                                00014
 *            THE IP= ARGUMENT ON THE MAIN PARM STRING INDENTIFIES      00015
 *            THE ADDRESS OF THE SERVER.                                00016
 *            DEFAULT: 192.168.123.45                                   00017
 *                                                                      00018
 *   PORT=  - NUMERIC PORT NUMBER                                       00019
 *            THE PORT= ARGUMENT ON THE MAIN PARM STRING INDENTIFIES    00020
 *            THE PORT THE SERVER IS LISTENING ON.                      00021
 *            DEFAULT:  19999                                           00022
 *                                                                      00023
 *   CMD()  - LIST OF COMMANDS TO PASS TO FLEXESCLI.  THIS IS A         00024
 *            SEMICOLON SEPARATED LIST OF COMMANDS TO PASS TO FLEXESCLI.00025
 *            EACH COMMAND IS SUBMITTED TO FLEXCLI AS THOUGH IT WAS     00026
 *            INPUT IN A CARD IMAGE READ FROM SYSIN.  IF BOTH SYSIN     00027
 *            AND MAINPARM COMMANDS ARE INPUT, THE MAINPARM COMMANDS    00028
 *            ARE EXECUTED FIRST.                                       00029
 *                                                                      00030
 * FILES:                                                               00031
 *                                                                      00032
 *   SYSPRINT - PRINT FILE (LINESIZE 133 WITH CC)                       00033
 *            MESSAGES ARE WRITTEN TO SYSPRINT.  THIS INCLUDES MESSAGES 00034
 *            GERNERATED BY THIS PROGRAM AND ANYTHING FLEXESCLI SENDS   00035
 *            BACK.  THIS FILE IS REQUIRED.                             00036
 *                                                                      00037
 *   SYSIN    - CARD IMAGE INPUT FILE                                   00038
 *            COMMANDS, ONE PER CARD IMAGE ARE READ FROM SYSIN IF       00039
 *            IF EXISTS.                                                00040
 *                                                                      00041
 * COMMAND PROCESSING:                                                  00042
 *                                                                      00043
 *   COMMANDS ARE READ OR EXTRACTED FROM MAINPARM ONE AT AT TIME AND    00044
 *   PASSED TO THE FLEXCLI PROGRAM.  BY DEFAULT, IF THE COMMANDS ARE    00045
 *   ALL UPPER CASE, THEY ARE CONVERTED TO LOWER CASE.                  00046
 *   BY DEFAULT, IF AN ERROR IS DETECTED, THE REMAINING COMMANDS ARE    00047
 *   SKIPPED.  THIS BEHAVIOR IS                                         00048
 *   IMPLEMENTED AS FOLLOWS AND MAY BE OVERRIDDEN.                      00049
 *                                                                      00050
 *   FOR A NORMAL FLEXESCLI COMMAND, AFTER THE COMMAND IS SENT, A       00051
 *   LINE CONTAINING 'FLEXESCLI -- ERROR:' (LOWER CASE) IS WATCHED      00052
 *   FOR IN THE OUTPUT RETURNED.  IF FOUND THIS IS AN ERROR.            00053
 *                                                                      00054
 *   FOR A ! (ESCAPE TO SHELL) COMMAND.  THE COMMAND IS SUFFIXED WITH   00055
 *   ';ECHO "CC=$?"' WHICH CAUSES THE LAST COMPLETION CODE TO BE OUTPUT.00056
 *   THIS SEQUENCE IS WATCHED FOR IN THE RETURNED OUTPUT.  THIS LIMITS  00057
 *   THE LENGTH OF A COMMAND TO 67 CHARACTER SINCE 13 ARE USED IN       00058
 *   SUFFIX.                                                            00059
 *                                                                      00060
 *   IF COLUNM 1 OF A COMMAND CONTAINS A '+', THE COMMANDS IS EXECUTED  00061
 *   REGARDLESS OF THE ERROR STATE AND THE ERROR STATE IS RESET.        00062
 *                                                                      00063
 *   IF COLUMN 1 OF A COMMAND CONTAINS A '-' AND THE COMMAND IS A '!'   00064
 *   COMMAND, THE SUFFIX STRING IS NOT ADDED.  IN ADDITION NO LOWER     00065
 *   CASE CONVERSIONS ARE DONE.                                         00066
 *                                                                      00067
 * SAMPLE EXECUTION:                                                    00068
 *   //FLEX1    EXEC PGM=FLEXCLI                                        00069
 *   //STEPLIB  DD  DISP=SHR,DSN=EAXC.SUPPORT.LOADLIB.RELEASE           00070
 *   //SYSPRINT DD  SYSOUT=*                                            00071
 *   //SYSIN    DD  *                                                   00072
 *   ! CP /FAKETAPE/BACKUP/MT/TAPE.000012 /NFSTAPE/COS004.TAPE.000027   00073
 *   MOUNT 0570 /NFSTAPE/COS004.TAPE.000027                             00074
 *                                                                      00075
 *   NOTE:  IF CONSOLE OUTPUT IS TURNED ON IN FLEX, THERE MAY BE A      00076
 *          BUNCH OF MESSAGES OUTPUT BEFORE OUTPUT BEGINS.              00077
 *                                                                      00078
 **********************************************************************/00079
                                                                        00080
 FLEXCLI:                                                               00081
    PROCEDURE(MAINPARM) OPTIONS(MAIN) REORDER;                          00082
 DECLARE  MAINPARM          VARYING CHAR(100);                          00083
                                                                        00084
 /***************************************************************       00085
 *                                                                      00086
 *  DEFAULT SERVER IP AND PORT, MAY BE OVERRIDDEN BY MAINPARM           00087
 *                                                                      00088
 ***************************************************************/       00089
 DECLARE  SERVER_IP         VARYING CHAR(20) INIT('192.168.123.45');    00090
 DECLARE  SERVER_PORT       FIXED BINARY(15) INIT(19999);               00091
 DECLARE  PARM_CMD_COUNT    FIXED BINARY(31) INIT(0);                   00092
 DECLARE  PARM_CMDS(20)     VARYING CHAR(100) AUTO INIT((20)(''));      00093
 DECLARE  CURRENT_CMD       FIXED BINARY(31) INIT(1);                   00094
                                                                        00095
 /***************************************************************       00096
 *                                                                      00097
 *  VARIABLES USED IN SENDING DATA BACK AND FORTH TO FLESXESCLI         00098
 *                                                                      00099
 ***************************************************************/       00100
 DECLARE  READY_FOR_MORE      BIT(1) INIT('0'B);                        00101
 DECLARE  SYSPRINT            FILE PRINT;                               00102
 DECLARE  SYSIN               FILE RECORD INPUT;                        00103
 DECLARE  EOF_SYSIN           BIT(1) INIT('0'B);                        00104
 DECLARE  FIRST_CMD_SENT      BIT(1) INIT('0'B);                        00105
 DECLARE  SYSIN_OK            BIT(1);                                   00106
 DECLARE  ERROR_FOUND         BIT(1) INIT('0'B);                        00107
 DECLARE  EOF_PGM_SYSINOUTERR BIT(1) INIT('0'B);                        00108
 DECLARE  DONE                BIT(1) INIT('0'B);                        00109
 DECLARE  READFDS(8)          FIXED BINARY(31) INIT((8)0);              00110
 DECLARE  WRITEFDS(8)         FIXED BINARY(31) INIT((8)0);              00111
 DECLARE  EXCPFDS(8)          FIXED BINARY(31) INIT((8)0);              00112
 DECLARE  COUNT               FIXED BINARY(31) INIT(0);                 00113
 DECLARE  BUFF                CHAR(256) INIT(' ');                      00114
 DECLARE  BUFF80              CHAR(80) INIT(' ');                       00115
 DECLARE  SYSIN_DSN           CHAR(44);                                 00116
                                                                        00117
 /***************************************************************       00118
 *                                                                      00119
 *  VARIABLES USED IN SETTING UP THE CONNECTION AND GENERAL ERROR       00120
 *  PROCESSING.                                                         00121
 *                                                                      00122
 ***************************************************************/       00123
 DECLARE  SOCKFD            FIXED BINARY(31) AUTO INIT(0);              00124
 DECLARE  SOCKET_PAIR(2)    FIXED BINARY(31) AUTO INIT(0);              00125
 DECLARE  01 SERVER_ADDR    LIKE SOCKADDR UNALIGNED AUTO;               00126
 DECLARE  01 TIMEOUT        LIKE BPXYSELT AUTO;                         00127
 DECLARE  RC                FIXED BINARY(31) AUTO;                      00128
 DECLARE  PIC_ZZZZ9         PIC'ZZZZ9' AUTO;                            00129
 DECLARE  SYSNULL           BUILTIN;                                    00130
 DECLARE  UNIX_RC           FIXED BINARY(31) AUTO INIT(0);              00131
 DECLARE  ERRNO             FIXED BINARY(31) AUTO INIT(0);              00132
 DECLARE  REASON            FIXED BINARY(31) AUTO INIT(0);              00133
                                                                        00134
 OPEN FILE(SYSPRINT) LINESIZE(133);                                     00135
 PUT FILE(SYSPRINT) SKIP EDIT('FLEXCLI CONSOLE INTERFACE ',             00136
                              'RELEASE 1.0 AS OF ',                     00137
                              LINKDTE.LINK_DATE)(A,COL(40),A,A);        00138
                                                                        00139
 /***************************************************************       00140
 *  PARSE THE MAIN PARM STRING FOR THE IP=, PORT= AND CMD() PARMS.      00141
 ***************************************************************/       00142
 RC = INITIALIZE(MAINPARM, SERVER_IP, SERVER_PORT,                      00143
                 PARM_CMD_COUNT, PARM_CMDS);                            00144
 IF RC ¬= 0                                                             00145
 THEN                                                                   00146
    DO;                                                                 00147
       CALL PLIRETC(RC);                                                00148
       RETURN;                                                          00149
    END;                                                                00150
                                                                        00151
 /***************************************************************       00152
 *  GET A TCP/IP SOCKET.                                                00153
 ***************************************************************/       00154
 CALL BPX1SOC(AF_INET,      /* INPUT:  DOMAIN,    AF_INET        */     00155
          SOCK#_STREAM,     /* INPUT:  TYPE,      SOCK#_DGRAM    */     00156
          IPPROTO_TCP,      /* INPUT:  PROTOCOL,  IPPROTO_UDP    */     00157
          SOCK#DIM_SOCKET,  /* INPUT:  DIMENSION, DIM_SOCKET     */     00158
          SOCKET_PAIR,      /* OUTPUT: SOCKET_VECTOR,            */     00159
          UNIX_RC,          /* OUTPUT: UNIX RC - 0 OR -1         */     00160
          ERRNO,            /* OUTPUT: ERRNO                     */     00161
          REASON);          /* OUTPUT: REASON                    */     00162
 IF UNIX_RC ¬= 0                                                        00163
 THEN                                                                   00164
    DO;                                                                 00165
       CALL UNIXERR('COULD NOT CREATE SOCKET (BPX1SOC)',                00166
                    ERRNO, REASON);                                     00167
       CALL PLIRETC(12);                                                00168
       RETURN;                                                          00169
    END;                                                                00170
                                                                        00171
 /***************************************************************       00172
 *  INITIALIZE THE SOCKET ADDRESS OF THE FLEXESCLI_INETD SERVER         00173
 ***************************************************************/       00174
 SOCKFD = SOCKET_PAIR(1);                                               00175
 SERVER_ADDR.SOCK_LEN      = SOCK_SIN#BIN;                              00176
 SERVER_ADDR.SOCK_FAMILY   = AF_INET_BITS;                              00177
 SERVER_ADDR.SOCK_SIN_PORT = SERVER_PORT;                               00178
 SERVER_ADDR.SOCK_SIN_ADDR = IP2BIN(SERVER_IP);                         00179
 SERVER_ADDR.RESERVED_1    = LOW(8);                                    00180
                                                                        00181
 /***************************************************************       00182
 *  CONNECT TO HE SERVER.                                               00183
 ***************************************************************/       00184
 CALL     BPX1CON(                                                      00185
          SOCKFD,           /* INPUT: SOCKET_DESCRIPTOR,           */   00186
          SOCK_SIN#LEN,     /* INPUT: SERVER_ADDR_LENGTH,          */   00187
          SERVER_ADDR,      /* INPUT: PTR TO SERVER_ADDR           */   00188
          UNIX_RC,          /* OUTPUT: UNIX RC - 0 OR -1         */     00189
          ERRNO,            /* OUTPUT: ERRNO                     */     00190
          REASON);          /* OUTPUT: REASON                    */     00191
 IF UNIX_RC ¬= 0                                                        00192
 THEN                                                                   00193
    DO;                                                                 00194
       PIC_ZZZZ9 = SERVER_PORT;                                         00195
       CALL UNIXERR('COULD NOT CONNECT TO SERVER ' || SERVER_IP ||      00196
                    ' AT PORT ' || PIC_ZZZZ9,                           00197
                    ERRNO, REASON);                                     00198
       CALL PLIRETC(12);                                                00199
       RETURN;                                                          00200
    END;                                                                00201
                                                                        00202
 /***************************************************************       00203
 *  SEE IF SYSIN IS SUPPLIED.                                           00204
 ***************************************************************/       00205
 SYSIN_DSN = GETDSN('SYSIN');                                           00206
 IF SYSIN_DSN  ¬= ' ' & SYSIN_DSN  ¬= 'NULLFILE'                        00207
 THEN                                                                   00208
    DO;                                                                 00209
       ON UNDEFINEDFILE(SYSIN) SYSIN_OK = '0'B;                         00210
       SYSIN_OK = '1'B;                                                 00211
       OPEN FILE(SYSIN) RECORD INPUT;                                   00212
    END;                                                                00213
 ELSE                                                                   00214
    SYSIN_OK = '0'B;                                                    00215
                                                                        00216
 /***************************************************************       00217
 *                                                                      00218
 *  SOMETIMES FLEXESCLI HAS LOTS OF MESSAGES TO SEND WHEN IT FIRST      00219
 *  FIRES UP.  READ WHATEVER IS IN THE BUCKET AND COPY TO SYSRPRINT.    00220
 *  THEN START PASSING COMMANDS TO FLEXESCLI.                           00221
 *                                                                      00222
 ***************************************************************/       00223
                                                                        00224
 DO WHILE(¬DONE);                                                       00225
    CALL FDZERO(READFDS);                                               00226
    CALL FDZERO(WRITEFDS);                                              00227
                                                                        00228
    /* IF WE ARE READY TO SEND MORE DATA, THIS BIT WILL BE TRUE */      00229
    IF (READY_FOR_MORE)                                                 00230
    THEN                                                                00231
       CALL FDSET(WRITEFDS, SOCKFD); /* DATA TO FLEXESCLI */            00232
    IF (EOF_PGM_SYSINOUTERR = '0'B)                                     00233
    THEN                                                                00234
       CALL FDSET( READFDS, SOCKFD); /* DATA FROM FLEXESCLI */          00235
                                                                        00236
    IF (EOF_PGM_SYSINOUTERR)                                            00237
    THEN                                                                00238
       DO;                                                              00239
          CALL BPX1CLO(                                                 00240
                     SOCKFD,    /* INPUT:  UNIX FD FROM BPX1OPN */      00241
                     UNIX_RC,   /* OUTPUT: UNIX RC -1 ON ERROR  */      00242
                     ERRNO,     /* OUTPUT: ERRNO                */      00243
                     REASON);   /* OUTPUT: REASON               */      00244
          IF (COUNT < 0)                                                00245
          THEN                                                          00246
             DO;                                                        00247
                CALL UNIXERR('ERROR CLOSING SOCKET',                    00248
                             ERRNO, REASON);                            00249
              END;                                                      00250
          DONE = '1'B;                                                  00251
       END;                                                             00252
                                                                        00253
    IF (EOF_PGM_SYSINOUTERR)                                            00254
    THEN                                                                00255
       LEAVE;                                                           00256
                                                                        00257
    IF (EOF_SYSIN)                                                      00258
    THEN                                                                00259
       DO;                                                              00260
          TIMEOUT.TV_SEC = 180;  /* LONG WAIT FOR THE GZIP */           00261
          TIMEOUT.TV_USEC = 0;                                          00262
       END;                                                             00263
    ELSE                                                                00264
       DO;                                                              00265
          TIMEOUT.TV_SEC = 2;                                           00266
          TIMEOUT.TV_USEC = 0;                                          00267
       END;                                                             00268
                                                                        00269
    /****************************************************************** 00270
    * IF WE ARE READY TO SEND MORE DATA, ISSUE A SELECT WITH NO TIMEOUT 00271
    * AND BOTH READFDS AND WRITEFDS ACTIVE.  OTHERWISE WE ISSUE A       00272
    * SELECT WITH A TIMEOUT AND ONLY WAIT FOR OUTPUT FROM FLEXESCLI.    00273
    ******************************************************************/ 00274
    IF (READY_FOR_MORE)                                                 00275
    THEN                                                                00276
       DO;                                                              00277
          CALL BPX1SEL(SOCKFD+1,                                        00278
                       32, /* FIXED SIZE STORAGE IN BYTES OF READFDS */ 00279
                       READFDS,                                         00280
                       32, /* FIXED SIZE STORAGE IN BYTES OF WRITEFDS*/ 00281
                       WRITEFDS,                                        00282
                       0,  /* NOT USING EXCPFDS */                      00283
                       EXCPFDS,                                         00284
                       SYSNULL(),                                       00285
                       SYSNULL(),                                       00286
                       (SEL#BITSFOREWARD), /* FORCE TEMP VAR*/          00287
                       UNIX_RC, /* >0 # FD'S SET, 0 TIMEOUT, -1 ERROR */00288
                       ERRNO,                                           00289
                       REASON);                                         00290
           IF UNIX_RC < 0                                               00291
           THEN                                                         00292
              DO;                                                       00293
                 CALL UNIXERR('BPX1SEL FAILED (1)',                     00294
                               ERRNO, REASON);                          00295
                 RC = 12;                                               00296
                 EOF_PGM_SYSINOUTERR = '1'B;                            00297
              END;                                                      00298
        END;                                                            00299
    ELSE                                                                00300
       DO;                                                              00301
          CALL BPX1SEL(SOCKFD+1,                                        00302
                       32, /* FIXED SIZE STORAGE IN BYTES OF READFDS */ 00303
                       READFDS,                                         00304
                       32, /* FIXED SIZE STORAGE IN BYTES OF WRITEFDS*/ 00305
                       WRITEFDS,                                        00306
                       0,  /* NOT USING EXCPFDS */                      00307
                       EXCPFDS,                                         00308
                       ADDR(TIMEOUT),                                   00309
                       SYSNULL(),                                       00310
                       (SEL#BITSFOREWARD), /* FORCE TEMP VAR*/          00311
                       UNIX_RC, /* >0 # FD'S SET, 0 TIMEOUT, -1 ERROR */00312
                       ERRNO,                                           00313
                       REASON);                                         00314
           IF UNIX_RC < 0                                               00315
           THEN                                                         00316
              DO;                                                       00317
                 CALL UNIXERR('BPX1SEL FAILED (2)',                     00318
                               ERRNO, REASON);                          00319
                 EOF_PGM_SYSINOUTERR = '1'B;                            00320
                 LEAVE;                                                 00321
              END;                                                      00322
       END;                                                             00323
                                                                        00324
    /****************************************************************** 00325
    * IF A SELECT TIMED OUT, WAITING FOR DATA FROM FLEXEXCLI, THEN      00326
    * WE ARE READY TO SEND ANOTHER COMMAND.                             00327
    ******************************************************************/ 00328
    IF UNIX_RC = 0                                                      00329
    THEN                                                                00330
       READY_FOR_MORE = '1'B;                                           00331
    ELSE                                                                00332
       READY_FOR_MORE = '0'B;                                           00333
                                                                        00334
    /****************************************************************** 00335
    * SEE IF THERE IS OUTPUT FROM THE FLEXEXCLI.  IF SO, COPY IT TO     00336
    * SYSPRINT.                                                         00337
    ******************************************************************/ 00338
    IF (FDISSET(READFDS, SOCKFD))                                       00339
    THEN                                                                00340
       DO;                                                              00341
          CALL BPX1RCV(                                                 00342
               SOCKFD,       /* INPUT: SOCKET_DESCRIPTOR,           */  00343
               LENGTH(BUFF), /* INPUT: BUFFER_LENGTH,               */  00344
               BUFF,         /* INPUT: BUFFER,                      */  00345
               BPX1RCV_ALET, /* INPUT: BUFFER_ALET, BPX1RCV_ALET    */  00346
               0,            /* INPUT: FLAGS, USUALLY 0             */  00347
               COUNT,        /* OUTPUT: BYTE COUNT OR -1 ON ERROR   */  00348
               ERRNO,        /* OUTPUT: ERRNO                       */  00349
               REASON);      /* OUTPUT: REASON                      */  00350
          IF (COUNT < 0)                                                00351
          THEN                                                          00352
             DO;                                                        00353
                CALL UNIXERR('ERROR READING FROM FLEXESCLI STDOUT',     00354
                             ERRNO, REASON);                            00355
                 EOF_PGM_SYSINOUTERR = '1'B;                            00356
              END;                                                      00357
          ELSE                                                          00358
             IF (COUNT = 0)                                             00359
             THEN                                                       00360
                EOF_PGM_SYSINOUTERR = '1'B;                             00361
             ELSE                                                       00362
                IF FIRST_CMD_SENT                                       00363
                THEN                                                    00364
                   DO;                                                  00365
                      CALL FLEX_OUTPUT(BUFF, COUNT, ERROR_FOUND);       00366
                      IF ERROR_FOUND                                    00367
                      THEN                                              00368
                         IF RC < 8                                      00369
                         THEN                                           00370
                            RC = 8;                                     00371
                   END;                                                 00372
       END;                                                             00373
                                                                        00374
    /****************************************************************** 00375
    * IF WE CAN SEND A COMMAND TO FLEXSHELL, DO SO.                     00376
    ******************************************************************/ 00377
    IF (FDISSET(WRITEFDS, SOCKFD))                                      00378
    THEN                                                                00379
       DO;                                                              00380
          IF (EOF_SYSIN)                                                00381
          THEN                                                          00382
             DO;                                                        00383
                 IF ¬FIRST_CMD_SENT                                     00384
                 THEN                                                   00385
                    DO;                                                 00386
                       PUT FILE(SYSPRINT) SKIP EDIT(                    00387
                           '*** NO INPUT COMMAND SUPPLIED ***')(A);     00388
                       IF RC < 4                                        00389
                       THEN                                             00390
                          RC = 4;                                       00391
                    END;                                                00392
             END;                                                       00393
          ELSE                                                          00394
             DO;                                                        00395
                EOF_SYSIN = GET_FLEX_CMD(BUFF80,                        00396
                                         PARM_CMD_COUNT,                00397
                                         PARM_CMDS,                     00398
                                         CURRENT_CMD,                   00399
                                         SYSIN_OK,                      00400
                                         ERROR_FOUND);                  00401
                IF EOF_SYSIN                                            00402
                THEN                                                    00403
                   BUFF80 = 'QUIT';                                     00404
                ELSE                                                    00405
                   FIRST_CMD_SENT = '1'B;                               00406
                                                                        00407
                CALL BPX1SND(                                           00408
                      SOCKFD,      /* INPUT: SOCKET_DESCRIPTOR,       */00409
                      80,          /* INPUT: BUFFER_LENGTH,           */00410
                      BUFF80,      /* INPUT: BUFFER,                  */00411
                      BPX1SND_ALET,/* INPUT: BUFFER_ALET, BPX1SND_ALET*/00412
                      0,           /* INPUT: FLAGS, USUALLY 0         */00413
                      COUNT,       /* OUTPUT: BYTE COUNT OR -1 ON ERR */00414
                      ERRNO,       /* OUTPUT: ERRNO                   */00415
                      REASON);     /* OUTPUT: REASON                  */00416
                IF (COUNT < 0)                                          00417
                THEN                                                    00418
                   DO;                                                  00419
                      CALL UNIXERR('ERROR WRITING TO FLEXESCLI SYSIN',  00420
                                   ERRNO, REASON);                      00421
                     EOF_SYSIN = '1'B;                                  00422
                  END;                                                  00423
             END;                                                       00424
      END;                                                              00425
 END; /* END OF WHILE NOT DONE */                                       00426
                                                                        00427
 CALL PLIRETC(RC);                                                      00428
 RETURN;                                                                00429
                                                                        00430
 INITIALIZE:                                                            00431
    PROCEDURE(MAINPARM, SERVER_IP, SERVER_PORT,                         00432
    PARM_CMD_COUNT, PARM_CMDS) RETURNS(FIXED BINARY(31));               00433
 DECLARE  MAINPARM          VARYING CHAR(100);                          00434
 DECLARE  SERVER_IP         VARYING CHAR(20);                           00435
 DECLARE  SERVER_PORT       FIXED BINARY(15);                           00436
 DECLARE  PARM_CMD_COUNT    FIXED BINARY(31);                           00437
 DECLARE  PARM_CMDS(20)     VARYING CHAR(100) CONNECTED;                00438
                                                                        00439
 DECLARE  RC                FIXED BINARY(31) AUTO INIT(0);              00440
 DECLARE  TEMP              VARYING CHAR(100) AUTO;                     00441
 DECLARE  DONE              BIT(1) AUTO;                                00442
 DECLARE  I                 FIXED BINARY(31) AUTO;                      00443
                                                                        00444
 TEMP = GETPARM(MAINPARM, 'IP=');                                       00445
 IF TEMP ¬= ''                                                          00446
 THEN                                                                   00447
    SERVER_IP = TEMP;                                                   00448
                                                                        00449
 TEMP = GETPARM(MAINPARM, 'PORT=');                                     00450
 IF TEMP ¬= ''                                                          00451
 THEN                                                                   00452
    DO;                                                                 00453
       IF VERIFY(TEMP, '0123456789') = 0                                00454
       THEN                                                             00455
          GET STRING(TEMP) LIST(SERVER_PORT);                           00456
       ELSE                                                             00457
          DO;                                                           00458
             PUT SKIP EDIT('INVALID PORT= PARAMETER, ', TEMP,           00459
                           ' IS NOT ALL NUMERIC')(A);                   00460
             RC = 8;                                                    00461
          END;                                                          00462
    END;                                                                00463
                                                                        00464
 TEMP = GETPARM(MAINPARM, 'CMD(');                                      00465
 IF TEMP ¬= ''                                                          00466
 THEN                                                                   00467
    DO;                                                                 00468
       DONE = '0'B;                                                     00469
       DO UNTIL(DONE);                                                  00470
          I = INDEX(TEMP, ';');                                         00471
          IF I = 0                                                      00472
          THEN                                                          00473
             DO;                                                        00474
                PARM_CMD_COUNT = PARM_CMD_COUNT + 1;                    00475
                PARM_CMDS(PARM_CMD_COUNT) = TEMP;                       00476
                DONE = '1'B;                                            00477
             END;                                                       00478
          ELSE                                                          00479
             DO;                                                        00480
                PARM_CMD_COUNT = PARM_CMD_COUNT + 1;                    00481
                PARM_CMDS(PARM_CMD_COUNT) = SUBSTR(TEMP, 1, I-1);       00482
                TEMP = SUBSTR(TEMP, I+1);                               00483
                IF TEMP = ''                                            00484
                THEN                                                    00485
                   DONE = '1'B;                                         00486
             END;                                                       00487
       END;                                                             00488
    END;                                                                00489
                                                                        00490
 RETURN(RC);                                                            00491
        /* DATA SET GETPARM    AT LEVEL 000 AS OF 03/31/86    */
0/**********************************************************************00001
 *                                                                     *00002
 *                           SUBSET GETPARM                            *00002
 * DECLARTION FOR ROUNTINE GETPARM                                     *00003
 * THIS ROUTINE EXTERACTS A KEYWORD PARM FROM A PARAMETER STRING.      *00004
 *                                                                     *00005
 * EX:  VALUE = GETPARM(MAINPARM,'XXX=')                               *00005
 *                                                                     *00006
 * SOURCE IS IN FG500781                                               *00006
 *                                                                     *00007
 **********************************************************************/00007
0 DECLARE GETPARM   ENTRY(VARYING CHAR(*),   /* PARM STRING */          00008
                          VARYING CHAR(*))   /* PARM HEADER */          00009
                    RETURNS( VARYING CHAR(2048))  EXTERNAL;             00010
                                                                        00493
 END INITIALIZE;                                                        00494
                                                                        00495
                                                                        00496
 UNIXERR:                                                               00497
    PROCEDURE(FIRST_LINE, ERRNO, REASON);                               00498
 DECLARE  FIRST_LINE        VARYING CHAR(*);                            00499
 DECLARE  ERRNO             FIXED BINARY(31);                           00500
 DECLARE  REASON            FIXED BINARY(31);                           00501
                                                                        00502
 DECLARE  MSG_LEN           FIXED BINARY(31) INIT(0);                   00503
 DECLARE  MSGP              POINTER INIT(NULL());                       00504
 DECLARE  MSG               CHAR(256) BASED(MSGP);                      00505
                                                                        00506
 PUT FILE(SYSPRINT) SKIP EDIT(FIRST_LINE)(A);                           00507
 CALL STRERR(ERRNO, MSG_LEN, MSGP);                                     00508
 PUT FILE(SYSPRINT) SKIP EDIT(SUBSTR(MSG,1,MSG_LEN))(A);                00509
 CALL STRREA(ERRNO, MSG_LEN, MSGP);                                     00510
 PUT FILE(SYSPRINT) SKIP EDIT(SUBSTR(MSG,1,MSG_LEN))(A);                00511
                                                                        00512
 END UNIXERR;                                                           00513
                                                                        00514
 TRIMX:                                                                 00515
  PROCEDURE(INSTR)  RETURNS(VARYING CHAR(80));                          00516
  DECLARE INSTR     CHAR(*);                                            00517
  DECLARE I         FIXED BIN(15);                                      00518
0/**********************************************************************00519
 *                                                                     *00519
 * TRIM LEADING AND TRAILING BLANKS                                    *00519
 *                                                                     *00521
 **********************************************************************/00521
  I = VERIFY(INSTR,' ');                                                00522
  IF  I = 0                                                             00523
  THEN                                                                  00524
     IF INDEX(INSTR,' ') = 0                                            00525
     THEN                                                               00526
        RETURN(INSTR);                                                  00527
     ELSE                                                               00528
        RETURN('');                                                     00529
  RETURN(SUBSTR(INSTR,I,LENGTH(INSTR) - (I-1) -                         00530
                (VERIFY(REVERSE((INSTR)),' ')-1)) );                    00531
 END TRIMX;                                                             00532
                                                                        00533
 TRIM:                                                                  00534
  PROCEDURE(INSTR)  RETURNS(VARYING CHAR(256));                         00535
  DECLARE INSTR     VARYING CHAR(*);                                    00536
  DECLARE I         FIXED BIN(15);                                      00537
0/**********************************************************************00538
 *                                                                     *00538
 * TRIM LEADING AND TRAILING BLANKS                                    *00538
 *                                                                     *00540
 **********************************************************************/00540
  I = VERIFY(INSTR,' ');                                                00541
  IF  I = 0                                                             00542
  THEN                                                                  00543
     IF INDEX(INSTR,' ') = 0                                            00544
     THEN                                                               00545
        RETURN(INSTR);                                                  00546
     ELSE                                                               00547
        RETURN('');                                                     00548
  RETURN(SUBSTR(INSTR,I,LENGTH(INSTR) - (I-1) -                         00549
                (VERIFY(REVERSE((INSTR)),' ')-1)) );                    00550
 END TRIM;                                                              00551
                                                                        00552
 GET_FLEX_CMD:                                                          00553
    PROCEDURE(BUFF80,                                                   00554
              PARM_CMD_COUNT, PARM_CMDS, CURRENT_CMD,                   00555
              SYSIN_OK, ERROR_FOUND)                                    00556
              RETURNS(BIT(1));                                          00557
 DECLARE  BUFF80            CHAR(80);                                   00558
 DECLARE  PARM_CMD_COUNT    FIXED BINARY(31);                           00559
 DECLARE  PARM_CMDS(20)     VARYING CHAR(100) CONNECTED;                00560
 DECLARE  CURRENT_CMD       FIXED BINARY(31);                           00561
 DECLARE  SYSIN_OK          BIT(1);                                     00562
 DECLARE  ERROR_FOUND       BIT(1);                                     00563
 DECLARE  WORK_80           VARYING CHAR(80) AUTO;                      00564
                                                                        00565
 DECLARE  EOF               BIT(1) AUTO INIT('0'B);                     00566
                                                                        00567
 BUFF80 = ' ';                                                          00568
 IF CURRENT_CMD > PARM_CMD_COUNT                                        00569
 THEN                                                                   00570
    IF SYSIN_OK                                                         00571
    THEN                                                                00572
       DO;                                                              00573
          ON ENDFILE(SYSIN) EOF = '1'B;                                 00574
          READ FILE(SYSIN) INTO(BUFF80);                                00575
       END;                                                             00576
    ELSE                                                                00577
       EOF = '1'B;                                                      00578
 ELSE                                                                   00579
    DO;                                                                 00580
       BUFF80 = PARM_CMDS(CURRENT_CMD);                                 00581
       CURRENT_CMD = CURRENT_CMD + 1;                                   00582
    END;                                                                00583
                                                                        00584
 IF ¬EOF                                                                00585
 THEN                                                                   00586
    DO;                                                                 00587
       IF SUBSTR(BUFF80,1,1) = '+'                                      00588
       THEN                                                             00589
          DO;                                                           00590
             BUFF80 = SUBSTR(BUFF80,2);                                 00591
             IF ERROR_FOUND                                             00592
             then                                                       00593
                PUT FILE(SYSPRINT) SKIP                                 00594
                    EDIT('***** ERROR STATE CLEARED *****')(A);         00595
             ERROR_FOUND = '0'B;                                        00596
          END;                                                          00597
       IF ERROR_FOUND                                                   00598
       THEN                                                             00599
          DO;                                                           00600
             BUFF80 = '#' || SUBSTR(BUFF80, 1, 79);                     00601
          END;                                                          00602
       IF SUBSTR(BUFF80,1,1) = '-'                                      00603
       THEN                                                             00604
          BUFF80 = SUBSTR(BUFF80,2);                                    00605
       ELSE                                                             00606
          DO;                                                           00607
             WORK_80 = TRIMX(BUFF80);                                   00608
             IF BREAK(WORK_80, (LOWER_CASE_LETTERS)) = 0                00609
             THEN                                                       00610
                WORK_80 = TRANSLATE(WORK_80,                            00611
                                    LOWER_CASE_LETTERS,                 00612
                                    UPPER_CASE_LETTERS);                00613
             IF SUBSTR(WORK_80, 1, 1) = '!'                             00614
             THEN                                                       00615
                WORK_80 = WORK_80 || ';echo "CC=$?"';                   00616
             BUFF80 = WORK_80;                                          00617
          END;                                                          00618
    END;                                                                00619
                                                                        00620
 RETURN(EOF);                                                           00621
 END GET_FLEX_CMD;                                                      00622
                                                                        00623
                                                                        00624
 FLEX_OUTPUT:                                                           00625
    PROCEDURE(BUFF, COUNT, ERROR_FOUND);                                00626
 DECLARE  BUFF              CHAR(*);                                    00627
 DECLARE  COUNT             FIXED BINARY(31);                           00628
 DECLARE  ERROR_FOUND       BIT(1);                                     00629
                                                                        00630
 DECLARE  LINE_SIZE         FIXED BINARY(31) STATIC INIT(132);          00631
 DECLARE  HOLD_BUFF         VARYING CHAR(256) STATIC INIT('');          00632
 DECLARE  LINE              VARYING CHAR(256) AUTO;                     00633
 DECLARE  CHARS_LEFT        FIXED BINARY(31);                           00634
 DECLARE  POS               FIXED BINARY(31) INIT(1);                   00635
 DECLARE  TEMP              FIXED BINARY(31);                           00636
                                                                        00637
 IF COUNT = 0                                                           00638
 THEN                                                                   00639
    DO;                                                                 00640
       IF LENGTH(HOLD_BUFF) > 0                                         00641
       THEN                                                             00642
          PUT FILE(SYSPRINT) SKIP EDIT(HOLD_BUFF)(A);                   00643
    END;                                                                00644
                                                                        00645
 CHARS_LEFT = COUNT;                                                    00646
                                                                        00647
 DO WHILE(LENGTH(HOLD_BUFF) + CHARS_LEFT >= LINE_SIZE);                 00648
    IF LENGTH(HOLD_BUFF) > 0                                            00649
    THEN                                                                00650
       DO;                                                              00651
          TEMP = LINE_SIZE - LENGTH(HOLD_BUFF);                         00652
          LINE = HOLD_BUFF || SUBSTR(BUFF, POS, TEMP);                  00653
          HOLD_BUFF = '';                                               00654
          POS = POS + TEMP;                                             00655
          CHARS_LEFT = CHARS_LEFT - TEMP;                               00656
       END;                                                             00657
    ELSE                                                                00658
       DO;                                                              00659
          LINE = SUBSTR(BUFF, POS, LINE_SIZE);                          00660
          POS  = POS + LINE_SIZE;                                       00661
          CHARS_LEFT = CHARS_LEFT - LINE_SIZE;                          00662
       END;                                                             00663
                                                                        00664
    LINE = TRIM(LINE);                                                  00665
    PUT FILE(SYSPRINT) SKIP EDIT(LINE)(A);                              00666
                                                                        00667
    IF SUBSTR(LINE, 1, 3) = 'CC=' & SUBSTR(LINE, 4, 1) ¬= '0'           00668
    THEN                                                                00669
       DO;                                                              00670
          ERROR_FOUND = '1'B;                                           00671
          PUT FILE(SYSPRINT) SKIP EDIT('***** ERROR DETECTED *****')(A);00672
       END;                                                             00673
    IF INDEX(LINE, 'flexescli -- error:') ¬= 0                          00674
    THEN                                                                00675
       DO;                                                              00676
          ERROR_FOUND = '1'B;                                           00677
          PUT FILE(SYSPRINT) SKIP EDIT('***** ERROR DETECTED *****')(A);00678
       END;                                                             00679
 END;                                                                   00680
                                                                        00681
 IF CHARS_LEFT > 0                                                      00682
 THEN                                                                   00683
    HOLD_BUFF = SUBSTR(BUFF, POS, CHARS_LEFT);                          00684
 END FLEX_OUTPUT;                                                       00685
                                                                        00686
        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */
0/**********************************************************************00001
 *                                                                     *00002
 *                           SUBSET DEFAULT                            *00002
 *                                                                     *00003
 * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003
 * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003
 * EASIER REENTRANCY.                                                  *00003
 *                                                                     *00006
 **********************************************************************/00006
                                                                        00007
 DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008
                  DESCRIPTORS ALIGNED;                                  00009
        /* DATA SET BUILTIN    AT LEVEL 000 AS OF 10/05/89    */
0/**********************************************************************00001
 *                                                                     *00001
 *                           SUBSET BUILTIN                            *00001
 *                                                                     *00002
 *                                                                     *00003
 *                       BUILTIN PL/I FUNCTIONS                        *00003
 *                                                                     *00003
 **********************************************************************/00003
0DECLARE (ABS,                                                          00004
          ADDR,                                                         00005
          ALLOCATION,                                                   00006
          CHAR,                                                         00007
          COMPLETION,                                                   00008
          DATE,                                                         00009
          DECIMAL,                                                      00010
          EMPTY,                                                        00011
          HBOUND,                                                       00012
          HIGH,                                                         00013
          INDEX,                                                        00014
          LBOUND,                                                       00015
          LENGTH,                                                       00016
          LINENO,                                                       00017
          LOW,                                                          00018
          MAX,                                                          00019
          MIN,                                                          00020
          MOD,                                                          00021
          NULL,                                                         00022
          ONCODE,                                                       00023
          ONKEY,                                                        00024
          PLIRETC,                                                      00025
          PLIRETV,                                                      00026
          PLISRTA,                                                      00027
          REPEAT,                                                       00028
          ROUND,                                                        00029
          STORAGE,                                                      00030
          STRING,                                                       00031
          SUBSTR,                                                       00032
          TIME,                                                         00033
          TRANSLATE,                                                    00034
          TRUNC,                                                        00035
          UNSPEC,                                                       00036
          VERIFY)            BUILTIN;                                   00037
        /* DATA SET LINKDTE    AT LEVEL 000 AS OF 04/03/87    */
0/**********************************************************************00001
 *                                                                     *00002
 *                           SUBSET LINKDTE                            *00002
 *                                                                     *00003
 * DECLARATION FOR THE LINK DATE INFORMATION BUILD BY THE LINKDATE     *00003
 * PROGRAM AND LINKED WITH THIS PROGRAM.                               *00003
 *                                                                     *00005
 * LINKDTE IS A SPECIAL VARIABLE SET UP BY THE LINKDATE PROGRAM WHICH  *00005
 * IS PART OF THE RELEASE PROCEDURE AND THE MDLKED CATALOGUED          *00005
 * PROCEDURE.  THE LINKDATE PROGRAM GENERATES AN EXTERNAL VARIABLE     *00005
 * NAMED LINKDTE WHICH CONTAINS THE CURRENT DATE IN MM/DD/YY FORMAT.   *00005
 * NOTE: THAT WHEN USING LINKDTE YOU MUST ALWAYS INCLUDE THE ENTRY     *00005
 * PLISTART CARD AS LINKDTE IS THE FIRST CSECT AND WOULD BECOME THE    *00005
 * DEFAULT ENTRY POINT.                                                *00005
 *                                                                     *00012
 **********************************************************************/00012
0   DECLARE  01  LINKDTE  STATIC EXTERNAL ALIGNED,                      00013
                 02    HEADER_JUNK    CHAR(8) INIT(' '),                00014
                 02    LINK_DATE      VARYING CHAR(30) INIT('UNKNOWN'); 00015
                                                                        00690
        /* DATA SET STRERR     AT LEVEL 000 AS OF 08/13/04    */
0/**********************************************************************
 *                                                                     *
 *                       SUBSET FG501277.STRERR                        *
 * DECLARATION FOR ROUTINE STRERR FOR OMVS                             *
 *                                                                     *
 * SOURCE IS IN FG501291                                               *
 *                                                                     *
 * THIS ROUTINE CONVERTS THE ERRNO CODE FROM A BPX1*** ROUTINE TO A    *
 * TEXT STRING.                                                        *
 *                                                                     *
 * THE ERRNO IS PASSED TO THE ROUTINE.                                 *
 *                                                                     *
 * THE LENGTH OF THE MESSAGE IS RETURNED. IF NO MESSAGE IS FOUND FOR   *
 * THIS ERROR CODE, THE LENGTH IS SET TO ZERO.                         *
 *                                                                     *
 * A POINTER TO A NULL TERMINATED MESSAGE IS RETURNED.  THE LENGTH     *
 * RETURNED DOES NOT INCLUDE THE NUL BYTE.  THE PLI NULL() PONTER      *
 * (X'FF000000' IS RETURNED IF THERE IS NO MESSAGE)                    *
 *                                                                     *
 * SAMPLE CALL:                                                        *
 *                                                                     *
 * DECLARE  ERRNO FIXED BINARY(31) INIT(123)                           *
 * DECLARE  MSG_LEN FIXED BINARY(31) INIT(0)                           *
 * DECLARE  MSGP    POINTER INIT(NULL())                               *
 * DECLARE  MSG     CHAR(256) BASED(MSGP)                              *
 *                                                                     *
 * CALL STRERR(ERRNO, MSG_LEN, MSGP)                                   *
 * PUT SKIP EDIT(SUBSTR(MSG, 1, MSG_LEN))(A)                           *
 *                                                                     *
 **********************************************************************/

 DECLARE STRERR  ENTRY(
                 FIXED BINARY(31),  /* IN  - ERRNO                */
                 FIXED BINARY(31),  /* OUT - MESSAGE LEN          */
                 POINTER)           /* OUT - MSG                  */
                 OPTIONS(ASSEMBLER)  EXTERNAL;

        /* DATA SET STRREA     AT LEVEL 000 AS OF 08/13/04    */
0/**********************************************************************
 *                                                                     *
 *                       SUBSET FG501277.STRREA                        *
 * DECLARATION FOR ROUTINE STRREA                                      *
 *                                                                     *
 * SOURCE IS IN FG501292                                               *
 *                                                                     *
 * THIS ROUTINE CONVERTS THE REASON CODE FROM A BPX1*** ROUTINE (THE   *
 * ERRNO JR.) TO A TEXT STRING.                                        *
 *                                                                     *
 * THE REASON IS PASSED TO THE ROUTINE.                                *
 *                                                                     *
 * THE LENGTH OF THE MESSAGE IS RETURNED. IF NO MESSAGE IS FOUND FOR   *
 * THIS ERROR CODE, THE LENGTH IS SET TO ZERO.                         *
 *                                                                     *
 * A POINTER TO A NUL TERMINATED MESSAGE IS RETURNED.  THE LENGTH      *
 * RETURNED DOES NOT INCLUDE THE NUL BYTE.  THE PLI NULL() PONTER      *
 * (X'FF000000' IS RETURNED IF THERE IS NO MESSAGE)                    *
 *                                                                     *
 * SAMPLE CALL:                                                        *
 *                                                                     *
 * DECLARE  REASON  FIXED BINARY(31) INIT(123)                         *
 * DECLARE  MSG_LEN FIXED BINARY(31) INIT(0)                           *
 * DECLARE  MSGP    POINTER INIT(NULL())                               *
 * DECLARE  MSG     CHAR(256) BASED(MSGP)                              *
 *                                                                     *
 * CALL STRREA(REASON, MSG_LEN, MSGP)                                  *
 * PUT SKIP EDIT(SUBSTR(MSG, 1, MSG_LEN))(A)                           *
 *                                                                     *
 **********************************************************************/

 DECLARE STRREA  ENTRY(
                 FIXED BINARY(31),  /* IN  - REASON (ERRNO JR.)   */
                 FIXED BINARY(31),  /* OUT - MESSAGE LEN          */
                 POINTER)           /* OUT - MSG                  */
                 OPTIONS(ASSEMBLER)  EXTERNAL;

        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.FDZERO                                              00003
 *                                                                      00004
 *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005
 *                                                                      00006
 *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007
 *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008
 *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009
 *  TO THE SELECT FUNCTION.                                             00010
 *                                                                      00011
 *  FDZERO      - ZERO AN FDSET                                         00012
 *                                                                      00013
 *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014
 *                                                                      00015
 *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016
 *                                                                      00017
 *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018
 *  DECLARE   SOCKET       FIXED BINARY(31)                             00019
 *  CALL FDZERO(READ_FDS)                                               00020
 *  CALL FDSET(READ_FDS, SOCKET)                                        00021
 *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022
 *  CALL FDISSET(READ_FDS, SOCKET)                                      00023
 *                                                                      00024
 *  SOURCE IS IN FG501326                                               00025
 *                                                                      00026
 ***************************************************************/       00027
                                                                        00028
 DECLARE  FDZERO       ENTRY(                                           00029
          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030
          EXTERNAL;                                                     00031
                                                                        00032
 DECLARE  FDSET        ENTRY(                                           00033
          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035
          EXTERNAL;                                                     00036
                                                                        00037
 DECLARE  FDISSET      ENTRY(                                           00038
          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040
          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041
                                                                        00042
        /* DATA SET BPX1SEL    AT LEVEL 000 AS OF 02/05/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPX1SEL                                             00003
 *                                                                      00004
 *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1SEL          00005
 *                                                                      00006
 *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A SELECT OPERATION00007
 *  ON FILE DESCRIPTORS.                                                00008
 *                                                                      00009
 *  FIRST PARM  - SNFDS  (INPUT)                                        00010
 *                THE VALUE OF THE LARGEST FILE DESCRIPTOR PASSED       00011
 *                PLUS ONE.  IF YOU HAVE ONE SOCKET, THIS IS THE        00012
 *                VALUE RETURNED BY BPX1SOC + 1.                        00013
 *                                                                      00014
 *  SECOND PARM - READ_LIST_LENGTH (INPUT)                              00015
 *                THE LENGTH OF THE READ_FDS (THIRD PARM) IN BYTES.     00016
 *                PASS ZERO IF NOT SELECTING ON READ OTHERWISE PASS     00017
 *                THE VALUE 32.                                         00018
 *                                                                      00019
 *  THIRD PARM  - READ_FDS (INPUT/OUTPUT)                               00020
 *                AN ARRAY OF 8 FIXED BINARY(31) VALUES WHICH INDICATE  00021
 *                WHICH FILE DESCRIPTORS NEED TO BE LOOKED AT.  THIS    00022
 *                LIST IS TREATED AS A BIT ARRAY OF LENGTH 256 WITH     00023
 *                INDEXES FROM 0 TO 255 FOR THE FILE DESCRIPTORS.       00024
 *                ON RETURN, BIT POSITIONAS ARE SET TO SHOW WHICH       00025
 *                FILE DESCRIPTORS ARE READY FOR READING.               00026
 *                REINIT BEFORE EACH CALL.                              00027
 *                USE FDZERO  TO INITIALIZE (FG501326)                  00028
 *                    FDSET   TO SET BITS   (DCLS IN FG501277.FDZERO)   00029
 *                    FDISSET TO INSPECT BITS AFTER RETURN              00030
 *                                                                      00031
 *  FOURTH PARM - WRITE_LIST_LENGTH (INPUT)                             00032
 *                THE LENGTH OF THE WRITE_FDS (FIFTH PARM) IN BYTES.    00033
 *                PASS ZERO IF NOT SELECTING ON WRITE OTHERWISE PASS    00034
 *                THE VALUE 32.                                         00035
 *                                                                      00036
 *  FIFTH PARM  - WRITE_FDS (INPUT/OUTPUT)                              00037
 *                JUST LIKE 3RD PARM, BUT DETECTS WHEN FILE DESCRIPTORS 00038
 *                (SOCKETS) ARE READY FOR WRITE INSTEAD OF READ.        00039
 *                REINIT BEFORE EACH CALL.                              00040
 *                                                                      00041
 *  SIXTH PARM  - EXCEPTION_LIST_LENGTH (INPUT)                         00042
 *                THE LENGTH OF THE EXCPT_FDS (SEVETH PARM) IN BYTES.   00043
 *                PASS ZERO IF NOT SELECTING ON EXCEPTIONAL CONDITIONS  00044
 *                OTHERWISE PASS THE VALUE 32.                          00045
 *                                                                      00046
 *  SEVENTH PARM- EXCEPTION_FDS (INPUT/OUTPUT)                          00047
 *                JUST LIKE 3RD PARM, BUT DETECTS WHEN FILE DESCRIPTORS 00048
 *                (SOCKETS) HAVE AN EXCEPTION PENDING.                  00049
 *                REINIT BEFORE EACH CALL.                              00050
 *                                                                      00051
 *  FIFTH PARM  - FLAGS (INPUT)                                         00052
 *                ALWAYS PASS 0                                         00053
 *                                                                      00054
 *  SIXTH PARM  - SOCKADDR_LENGTH (INPUT)                               00055
 *                ALWAYS PASS VARABLE CONTAINING SOCK_SIN#LEN           00056
 *                SOCK_SIN#LEN IS DEFINED IN FG501277.BPXYSOCK          00057
 *                                                                      00058
 *  EIGHTH PARM - TIMEOUT (INPUT)                                       00059
 *                SYSNULL() (0) OR A POINTER TO A BPXYSELT STRUCT       00060
 *                (FG501277.BPXYSELT) WHICH CONTAINS A TIMEOUT VALUE.   00061
 *                BPXYSELT HAS TWO MEMBERS ONE FOR SECONDS AND ONE      00062
 *                FOR MICROSECONDS.  PASSING SYSNULL() MEANS INFINITE   00063
 *                WAIT - NO TIMEOUT.  PASSING A POINTER TO A STRUCT     00064
 *                WITH BOTH ELEMENTS ZERO MEANS POLL.                   00065
 *                                                                      00066
 *  NINTH PARM  - ECB PTR (INPUT/OUTPUT)                                00067
 *                PASS SYSNULL() OR A POINTER TO AN ECB OR LIST OF      00068
 *                EBC'S.                                                00069
 *                                                                      00070
 *  TENTH PARM  - USER_OP_FIELD (INPUT/OUTPUT)                          00071
 *                CAN BE PASSED SEL#BITSBACKWARD OR                     00072
 *                SEL#BITSFOREWARD.  IF USING FDZERO, FDSET, AND        00073
 *                FDISSET, ALWAYS PASS A VARIABLE CONTAINING            00074
 *                SEL#BITSFOREWARD.  REINIT BEFORE EACH CALL.           00075
 *                                                                      00076
 *  ELEVENTH    - RET_VALUE (OUTPUT)                                    00077
 *                >0  - THE NUMBER OF FILE DESCRIPTORS READY            00078
 *                =0  - TIMEOUT                                         00079
 *                -1  - ERROR, SEE ERRNO AND REA FOR WHAT HAPPENED.     00080
 *                                                                      00081
 ***************************************************************/       00082
                                                                        00083
 DECLARE  BPX1SEL      ENTRY(                                           00084
          FIXED BINARY(31), /* INPUT: NUMBER_MSGSFDS,MAXFD+1        */  00085
          FIXED BINARY(31), /* INPUT: READ_LIST_LENGTH, 32 OR 0     */  00086
       (8)FIXED BINARY(31), /* INPUT: READ_LIST,                    */  00087
          FIXED BINARY(31), /* INPUT: WRITE_LIST_LENGTH, 32 OR 0    */  00088
       (8)FIXED BINARY(31), /* INPUT: WRITE_LIST,                   */  00089
          FIXED BINARY(31), /* INPUT: EXCEPTION_LIST_LENGTH, 32 OR 0*/  00090
       (8)FIXED BINARY(31), /* INPUT: EXCEPTION_LIST,               */  00091
          POINTER,          /* INPUT: TIMEOUT_POINTER, USE SYSNULL()*/  00092
          POINTER,          /* INPUT: ECB_POINTER, USE SYSNULL()    */  00093
          FIXED BINARY(31), /* INPUT: USER_OPTION_FIELD,            */  00094
          FIXED BINARY(31), /* OUTPUT: # FD'S, 0 TIMEOUT, -1 ERR    */  00095
          FIXED BINARY(31), /* OUTPUT: ERRNO                        */  00096
          FIXED BINARY(31)) /* OUTPUT: REASON                       */  00097
                       OPTIONS(ASM) EXTERNAL;                           00098
                                                                        00099
 /* VALUES FOR USER_OPTION_FIELD */                                     00100
 DECLARE  SEL#BITSBACKWARD FIXED BINARY(31) STATIC INIT(0);             00101
 DECLARE  SEL#BITSFOREWARD FIXED BINARY(31) STATIC INIT(1);             00102
        /* DATA SET BPX1SOC    AT LEVEL 000 AS OF 02/05/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPX1SOC                                             00003
 *                                                                      00004
 *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1SOC          00005
 *                                                                      00006
 *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO GET A SOCKET OR SOCKET    00007
 *  PAIR.  MUST HAVE THE IBM TCP STACK (NOT THE CA ONE).                00008
 *                                                                      00009
 ***************************************************************/       00010
                                                                        00011
 DECLARE  BPX1SOC      ENTRY(                                           00012
          FIXED BINARY(31), /* INPUT:  DOMAIN,    AF_INET        */     00013
          FIXED BINARY(31), /* INPUT:  TYPE,      SOCK#_DGRAM    */     00014
          FIXED BINARY(31), /* INPUT:  PROTOCOL,  IPPROTO_UDP    */     00015
          FIXED BINARY(31), /* INPUT:  DIMENSION, DIM_SOCKET     */     00016
      (2) FIXED BINARY(31), /* OUTPUT: SOCKET_VECTOR,            */     00017
          FIXED BINARY(31), /* OUTPUT: UNIX RC - 0 OR -1         */     00018
          FIXED BINARY(31), /* OUTPUT: ERRNO                     */     00019
          FIXED BINARY(31)) /* OUTPUT: REASON                    */     00020
                       OPTIONS(ASM) EXTERNAL;                           00021
                                                                        00022
 /********************************************************************  00023
 *                                                                      00024
 * VALUES FOR DOMAIN PARAMETER                                          00025
 *                                                                      00026
 *  WE ALWAYS USE INTERNET ALTHOUGH VALUES EXIST FOR OTHER DOMAINS.     00027
 *                                                                      00028
 /*******************************************************************/  00029
 DECLARE  AF_INET             FIXED BINARY(31) STATIC INIT(2);          00030
                                                                        00031
 /********************************************************************  00032
 *                                                                      00033
 * VALUES FOR TYPE PARAMETER - THIS AN THE PROTOCOL PARM MUST MATCH.    00034
 *                                                                      00035
 *  STREAM IS TCP/IP                                                    00036
 *  DGRAM  IS UDP/IP                                                    00037
 *  RAW    IS STRAIGHT IP, YOU MUST BE SUPERUSER FOR THIS ONE           00038
 *                                                                      00039
 /*******************************************************************/  00040
 DECLARE  SOCK#_STREAM        FIXED BINARY(31) STATIC INIT(1);          00041
 DECLARE  SOCK#_DGRAM         FIXED BINARY(31) STATIC INIT(2);          00042
 DECLARE  SOCK#_RAW           FIXED BINARY(31) STATIC INIT(3);          00043
                                                                        00044
 /********************************************************************  00045
 *                                                                      00046
 * VALUES FOR PROTOCOL PARAMETER - THIS AN THE TYPE PARM MUST MATCH.    00047
 *                                                                      00048
 /*******************************************************************/  00049
 DECLARE  IPPROTO_IP          FIXED BINARY(31) STATIC INIT(0);          00050
 DECLARE  IPPROTO_TCP         FIXED BINARY(31) STATIC INIT(6);          00051
 DECLARE  IPPROTO_UDP         FIXED BINARY(31) STATIC INIT(17);         00052
 DECLARE  IPPROTO_IPV6        FIXED BINARY(31) STATIC INIT(41);         00053
                                                                        00054
 /********************************************************************  00055
 *                                                                      00056
 * VALUES FOR DIMENSION PARAMETER                                       00057
 *                                                                      00058
 * SOCK#DIM_SOCKET     - RETURN ONE NORMAL SOCKET                       00059
 * SOCK#DIM_SOCKETPAIR - RETURN A SOCKET PAIR                           00060
 *                       PROBABLY NEED MORE CONSTANTS TO MAKE THIS      00061
 *                       WORK.                                          00062
 *                                                                      00063
 /*******************************************************************/  00064
 DECLARE  SOCK#DIM_SOCKET     FIXED BINARY(31) STATIC INIT(1);          00065
 DECLARE  SOCK#DIM_SOCKETPAIR FIXED BINARY(31) STATIC INIT(2);          00066
                                                                        00067
        /* DATA SET BPX1SND    AT LEVEL 000 AS OF 02/11/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPX1SND                                             00003
 *                                                                      00004
 *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1SND          00005
 *                                                                      00006
 *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A SEND ON A       00007
 *  SOCKET CREATED BY BPX1SOC.                                          00008
 *                                                                      00009
 *  FIRST PARM  - SOCKET (INPUT)                                        00010
 *                SOCKET RETURNED BY BPX1SOC                            00011
 *                                                                      00012
 *  SECOND PARM - BUFFER_LENGTH (INPUT)                                 00013
 *                LENGTH OF THE DATA TO SEND IN THE BUFFER IN THE       00014
 *                THIRD                                                 00015
 *                                                                      00016
 *  THIRD PARM  - BUFFER (OUTPUT)                                       00017
 *                THE DATA TO SEND                                      00018
 *                                                                      00019
 *  FORTH PARM  - BUFFER_ALET (INPUT)                                   00020
 *                ALWAYS PASS BPX1SND_ALET (0)                          00021
 *                                                                      00022
 *  FIFTH PARM  - FLAGS (INPUT)                                         00023
 *                ALWAYS PASS 0                                         00024
 *                                                                      00025
 *                                                                      00026
 *  SIXTH PARM  - COUNT (OUTPUT)                                        00027
 *                NUMBER OF BYTES SENT PLACED IN HERE OR -1 ON ERROR.   00028
 *                IF -1, ERRNO AND REA TELL YOU WHY                     00029
 *                      SEE FG501277.STRERR AND FG501277.STRREA         00030
 *                                                                      00031
 ***************************************************************/       00032
                                                                        00033
 DECLARE  BPX1SND      ENTRY(                                           00034
          FIXED BINARY(31), /* INPUT: SOCKET_DESCRIPTOR,           */   00035
          FIXED BINARY(31), /* INPUT: BUFFER_LENGTH,               */   00036
          CHAR(*),          /* INPUT: BUFFER,                      */   00037
          FIXED BINARY(31), /* INPUT: BUFFER_ALET, BPX1SND_ALET    */   00038
          FIXED BINARY(31), /* INPUT: FLAGS, USUALLY 0             */   00039
          FIXED BINARY(31), /* OUTPUT: BYTE COUNT OR -1 ON ERROR   */   00040
          FIXED BINARY(31), /* OUTPUT: ERRNO                       */   00041
          FIXED BINARY(31)) /* OUTPUT: REASON                      */   00042
                       OPTIONS(ASM) EXTERNAL;                           00043
                                                                        00044
 DECLARE  BPX1SND_ALET FIXED BINARY(31) STATIC INIT(0);                 00045
                                                                        00046
        /* DATA SET BPX1RCV    AT LEVEL 000 AS OF 02/11/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPX1RCV                                             00003
 *                                                                      00004
 *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1RCV          00005
 *                                                                      00006
 *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A RECEIVE ON A    00007
 *  SOCKET CREATED BY BPX1SOC.                                          00008
 *                                                                      00009
 *  FIRST PARM  - SOCKET (INPUT)                                        00010
 *                SOCKET RETURNED BY BPX1SOC                            00011
 *                                                                      00012
 *  SECOND PARM - BUFFER_LENGTH (INPUT)                                 00013
 *                LENGTH OF THE DATA TO SEND IN THE BUFFER IN THE       00014
 *                THIRD                                                 00015
 *                                                                      00016
 *  THIRD PARM  - BUFFER (OUTPUT)                                       00017
 *                THE DATA TO SEND                                      00018
 *                                                                      00019
 *  FORTH PARM  - BUFFER_ALET (INPUT)                                   00020
 *                ALWAYS PASS BPX1SND_ALET (0)                          00021
 *                                                                      00022
 *  FIFTH PARM  - FLAGS (INPUT)                                         00023
 *                ALWAYS PASS 0                                         00024
 *                                                                      00025
 *  SIXTH PARM  - COUNT (OUTPUT)                                        00026
 *                NUMBER OF BYTES READ PLACED IN HERE OR -1 ON ERROR.   00027
 *                IF -1, ERRNO AND REA TELL YOU WHY                     00028
 *                      SEE FG501277.STRERR AND FG501277.STRREA         00029
 *                                                                      00030
 ***************************************************************/       00031
                                                                        00032
 DECLARE  BPX1RCV      ENTRY(                                           00033
          FIXED BINARY(31), /* INPUT: SOCKET_DESCRIPTOR,           */   00034
          FIXED BINARY(31), /* INPUT: BUFFER_LENGTH,               */   00035
          CHAR(*),          /* INPUT: BUFFER,                      */   00036
          FIXED BINARY(31), /* INPUT: BUFFER_ALET, BPX1RCV_ALET    */   00037
          FIXED BINARY(31), /* INPUT: FLAGS, USUALLY 0             */   00038
          FIXED BINARY(31), /* OUTPUT: BYTE COUNT OR -1 ON ERROR   */   00039
          FIXED BINARY(31), /* OUTPUT: ERRNO                       */   00040
          FIXED BINARY(31)) /* OUTPUT: REASON                      */   00041
                       OPTIONS(ASM) EXTERNAL;                           00042
                                                                        00043
 DECLARE  BPX1RCV_ALET FIXED BINARY(31) STATIC INIT(0);                 00044
                                                                        00045
        /* DATA SET BPX1CLO    AT LEVEL 000 AS OF 10/28/03    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPX1CLO                                             00003
 *                                                                      00004
 *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1CLO          00005
 *                                                                      00006
 *  THIS ROUTINE CLOSES A FILE OPENED BY BPX1OPN                        00007
 *                                                                      00008
 ***************************************************************/       00009
                                                                        00010
 DECLARE  BPX1CLO      ENTRY(                                           00011
          FIXED BINARY(31), /* INPUT:  UNIX FD FROM BPX1OPN */          00012
          FIXED BINARY(31), /* OUTPUT: UNIX RC -1 ON ERROR  */          00013
          FIXED BINARY(31), /* OUTPUT: ERRNO                */          00014
          FIXED BINARY(31)) /* OUTPUT: REASON               */          00015
                       OPTIONS(ASM) EXTERNAL;                           00016
                                                                        00017
                                                                        00018
        /* DATA SET BPX1CON    AT LEVEL 000 AS OF 04/12/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPX1CON                                             00003
 *                                                                      00004
 *  DECLARE FOR OPENEDITION ASSEMBLER CALLABLE SERVICE BPX1CON          00005
 *                                                                      00006
 *  THIS ROUTINE USES UNIX SYSTEM SERVICES TO PERFORM A CONNECT         00007
 *  TO A SERVER ON A SOCKET CREATED BY BPX1SOC.                         00008
 *                                                                      00009
 *  FIRST PARM  - SOCKET (INPUT)                                        00010
 *                SOCKET RETURNED BY BPX1SOC                            00011
 *                                                                      00012
 *  SECOND PARM - SOCKADDR_LENGTH (INPUT)                               00013
 *                LENGTH OF THE THIRD PARM.  USE SOCK_SIN#LEN FROM      00014
 *                FG501277.BPXYSOCK.                                    00015
 *                                                                      00016
 *  THIRD PARM  - SOCKADDR OF SERVER (INPUT)                            00017
 *                THE STRUCTURE FROM FG501277.BPXYSOCK IS INTIALIZED    00018
 *                WITH THE IP ADDRESS AND PORT FOR THE SERVER.          00019
 *                                                                      00020
 *  FORTH PARM  - UNIX RC (OUTPUT)                                      00021
 *                0 ON SUCCESS -1 ON ERROR.   ON SUCCESS, THE FIRST     00022
 *                PARM (SOCKET) IS CONNECTED TO THE SERVER.             00023
 *                                                                      00024
 *  FIFTH PARM  - ERRNO (OUTPUT)                                        00025
 *                REASON FOR ERROR, SEE FG501277.STRERR TO INTERPRET.   00026
 *                                                                      00027
 *  SIXTH PARM  - REASON(OUTPUT)                                        00028
 *                REASON FOR ERROR, SEE FG501277.STRREA TO INTERPRET.   00029
 *                                                                      00030
 ***************************************************************/       00031
                                                                        00032
 DECLARE  BPX1CON      ENTRY(                                           00033
          FIXED BINARY(31), /* INPUT: SOCKET_DESCRIPTOR,           */   00034
          FIXED BINARY(31), /* INPUT: SOCKADDR_LENGTH,             */   00035
          01 UNALIGNED,     /* INPUT: SOCKADDR OF SERVER           */   00036
             02  BIT(8),           /*  SOCK_SIN#BIN                */   00037
             02  BIT(8),           /*  AF_INET_BITS                */   00038
             02  FIXED BINARY(15), /*  PORT NUMBER                 */   00039
             02  FIXED BINARY(31), /*  BIN IP ADDR FG501277.IP2BIN */   00040
             02  CHAR(8),          /*  USE LOW(8) BINARY ZERO      */   00041
          FIXED BINARY(31), /* OUTPUT: UNIX RC 0  OR -1 ON ERROR   */   00042
          FIXED BINARY(31), /* OUTPUT: ERRNO                       */   00043
          FIXED BINARY(31)) /* OUTPUT: REASON                      */   00044
                       OPTIONS(ASM) EXTERNAL;                           00045
                                                                        00046
        /* DATA SET IP2BIN     AT LEVEL 000 AS OF 04/12/04    */
 /********************************************************************* 00001
 *                                                                      00002
 *  SUBSET FG501277.IP2BIN                                              00003
 *                                                                      00004
 *  ROUTINE TO CONVERT A DOTTED IP ADDRESS INTO A BINARY IP ADDRESS     00005
 *  SUITABLE FOR USE WITH SOCKADDR.SOCK_SIN_ADDR IN FG501277.BPXYSOCK.  00006
 *                                                                      00007
 *  THIS ROUTINE IS SO SMALL, IT IS INCLUDED INLINE.                    00008
 *                                                                      00009
 *  FIRST PARM  - DOTTED_IP (INPUT)                                     00010
 *                THE 4 PART DOTTED IP ADDRESS TO CONVERT.              00011
 *                                                                      00012
 *  RETURNED    - BINARY IPFIXED BINARY(31)                             00013
 *                THIS IS THE PASSED PARM IN BINARY FORMAT.             00014
 *                                                                      00015
 *  SAMPLE CALL:                                                        00016
 *  SOCKADDR.SOCK_SIN_ADDR = IP2BIN('192.168.123.45')                   00017
 *                                                                      00018
 ***************************************************************/       00019
                                                                        00020
 IP2BIN:                                                                00021
    PROCEDURE(DOTTED_IP) RETURNS(FIXED BINARY(31));                     00022
 DECLARE  DOTTED_IP         VARYING CHAR(*);                            00023
                                                                        00024
 DECLARE  WORK_IP           VARYING CHAR(20) AUTO;                      00025
 DECLARE  PARTS(4)          FIXED BINARY(31) AUTO INIT(0,0,0,0);        00026
 DECLARE  PART              VARYING CHAR(4) AUTO INIT('');              00027
 DECLARE  BIN_IP            FIXED BINARY(31) AUTO INIT(0);              00028
 DECLARE  BIN_IP_BITS(4)    BIT(8) BASED(ADDR(BIN_IP));                 00029
 DECLARE  PARTS_BITS(16)    BIT(8) BASED(ADDR(PARTS));                  00030
 DECLARE  TRANSLATE         BUILTIN;                                    00031
 DECLARE  ADDR              BUILTIN;                                    00032
                                                                        00033
 WORK_IP = TRANSLATE(DOTTED_IP, ' ', '.');                              00034
 GET STRING(WORK_IP) LIST(PARTS(1), PARTS(2), PARTS(3), PARTS(4));      00035
 BIN_IP_BITS(1) = PARTS_BITS(4);                                        00036
 BIN_IP_BITS(2) = PARTS_BITS(8);                                        00037
 BIN_IP_BITS(3) = PARTS_BITS(12);                                       00038
 BIN_IP_BITS(4) = PARTS_BITS(16);                                       00039
 RETURN(BIN_IP);                                                        00040
                                                                        00041
 END IP2BIN;                                                            00042
        /* DATA SET BIN2IP     AT LEVEL 000 AS OF 04/12/04    */
 /********************************************************************* 00001
 *                                                                      00002
 *  SUBSET FG501277.BIN2IP                                              00003
 *                                                                      00004
 *  ROUTINE TO CONVERT A DOTTED IP ADDRESS INTO A BINARY IP ADDRESS     00005
 *  SUITABLE FOR USE WITH SOCKADDR.SOCK_SIN_ADDR IN FG501277.BPXYSOCK.  00006
 *                                                                      00007
 *  THIS ROUTINE IS SO SMALL, IT IS INCLUDED INLINE.                    00008
 *                                                                      00009
 *  FIRST PARM  - DOTTED_IP (INPUT)                                     00010
 *                THE 4 PART DOTTED IP ADDRESS TO CONVERT.              00011
 *                                                                      00012
 *  RETURNED    - BINARY IPFIXED BINARY(31)                             00013
 *                THIS IS THE PASSED PARM IN BINARY FORMAT.             00014
 *                                                                      00015
 *  SAMPLE CALL:                                                        00016
 *  PUT SKIP EDIT(BIN2IP(SOCKADDR.SOCK_SIN_ADDR))(A)                    00017
 *                                                                      00018
 ***************************************************************/       00019
                                                                        00020
 BIN2IP:                                                                00021
    PROCEDURE(INET) RETURNS(VARYING CHAR(20));                          00022
 DECLARE INET            FIXED BINARY(31);                              00023
                                                                        00024
 DECLARE OV1             CHAR(4) BASED(ADDR(INET));                     00025
 DECLARE WORK2           FIXED BINARY(31);                              00026
 DECLARE OV2(4)          CHAR(1) BASED(ADDR(WORK2));                    00027
 DECLARE WORK3           PIC'ZZZZ9';                                    00028
 DECLARE OUTSTR          VARYING CHAR(20) INIT('');                     00029
 DECLARE I               FIXED BINARY(31);                              00030
 DECLARE NON_BLANK       FIXED BINARY(31);                              00031
                                                                        00032
 DO I = 1 TO 4;                                                         00033
    WORK2 = 0;                                                          00034
    OV2(4) = SUBSTR(OV1,I,1);                                           00035
    WORK3 = WORK2;                                                      00036
    NON_BLANK = VERIFY(WORK3, ' ');                                     00037
    IF NON_BLANK ¬= 0                                                   00038
    THEN                                                                00039
       OUTSTR = OUTSTR || SUBSTR(WORK3, NON_BLANK);                     00040
    ELSE                                                                00041
       OUTSTR = OUTSTR || '0'; /* SHOULD NEVER HAPPEN */                00042
    IF I < 4                                                            00043
    THEN                                                                00044
       OUTSTR = OUTSTR || '.';                                          00045
 END;                                                                   00046
                                                                        00047
 RETURN(OUTSTR);                                                        00048
 END BIN2IP;                                                            00049
                                                                        00702
        /* DATA SET BPXYSOCK   AT LEVEL 000 AS OF 04/12/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPXYSOCK                                            00003
 *                                                                      00004
 *  DECLARE FOR A SOCKADDR                                              00005
 *                                                                      00006
 *  IP ROUTINES SUCH AS BPX1RFM (RECVFROM) AND BPX1STO (SENDTO)         00007
 *  USE THIS STRUCTURE TO IDENTIFY THE MACHINE THE DATA IS              00008
 *  COMING FROM OR GOING TO.                                            00009
 *                                                                      00010
 *  AF_INET SOCKET ADDRESS STRUCTURE                                    00011
 *                                                                      00012
 *  SOCK_LEN      - USE SOCK_SIN#BIN                                    00013
 *                                                                      00014
 *  SOCK_FAMILY   - USE AF_INET_BITS                                    00015
 *                                                                      00016
 *  SOCK_SIN_PORT - PORT TO SEND TO OR DATA CAME FROM                   00017
 *                                                                      00018
 *  SOCK_SIN_ADDR - IP ADDRESS IN BINARY.  ONE BYTE PER NUMBER.         00019
 *                  THAT IS 130.131.36.72 IS X'82832448'                00020
 *                  NETWORK ORDER, WHICH IS BIG ENDIAN.                 00021
 *                                                                      00022
 *  RESERVED_1    - SET TO BINARY ZEROS - LOW(8)                        00023
 *                                                                      00024
 *  SAMPLE INITIALIZATION:                                              00025
 *                                                                      00026
 *  SOCKADDR.SOCK_LEN      = SOCK_SIN#BIN                               00027
 *  SOCKADDR.SOCK_FAMILY   = AF_INET_BITS                               00028
 *  SOCKADDR.SOCK_SIN_PORT = 19999                                      00029
 *  SOCKADDR.SOCK_SIN_ADDR = IP2BIN('192.168.123.45')                   00030
 *  SOCKADDR.RESERVED_1    = LOW(8)                                     00031
 *                                                                      00032
 *  FIND IP2BIN IN FG501277.IP2BIN                                      00033
 *                                                                      00034
 ***************************************************************/       00035
                                                                        00036
 DECLARE  01 SOCKADDR  UNALIGNED BASED,                                 00037
             02  SOCK_LEN         BIT(8),           /* SOCK_SIN#BIN */  00038
             02  SOCK_FAMILY      BIT(8),           /* AF_INET_BITS */  00039
             02  SOCK_SIN_PORT    FIXED BINARY(15), /* PORT NUMBER  */  00040
             02  SOCK_SIN_ADDR    FIXED BINARY(31), /* BIN IP ADDR  */  00041
             02  RESERVED_1       CHAR(8);                              00042
                                                                        00043
 /***************************************************************       00044
 *  VALUE PUT IN SOCK_LEN                                               00045
 *  USE SOCK_SIN#LEN IN CALL TO BXP1BND                                 00046
 *  USE SOCK_SIN#BIN IN STRUCTURE MEMBER SOCK_LEN                       00047
 ***************************************************************/       00048
 DECLARE SOCK_SIN#LEN  FIXED BINARY(31) STATIC INIT(16);                00049
 DECLARE SOCK_SIN#BIN  BIT(8)           STATIC INIT('00010000'B);       00050
                                                                        00051
 /***************************************************************       00052
 *  VALUE PUT IN SOCK_FAMILY                                            00053
 ***************************************************************/       00054
 DECLARE  AF_INET_BITS        BIT(8) STATIC INIT('00000010'B);          00055
                                                                        00056
        /* DATA SET BPXYSELT   AT LEVEL 000 AS OF 02/05/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.BPXYSELT                                            00003
 *                                                                      00004
 *  DECLARE FOR A SOCKADDR                                              00005
 *                                                                      00006
 *  STRUCTURE USED FOR TIMEOUT IN SELECT (BPX1SEL)                      00007
 *                                                                      00008
 ***************************************************************/       00009
                                                                        00010
 DECLARE  01  BPXYSELT BASED,                                           00011
              02  TV_SEC   FIXED BINARY(31), /* SECONDS       */        00012
              02  TV_USEC  FIXED BINARY(31); /* MICRO SECONDS */        00013
                                                                        00014
        /* DATA SET BPXYERNOCM AT LEVEL 000 AS OF 03/15/04    */
 /****************************************************************      00001
 *                                                               *      00002
 *  SUBSET FG501277.BPXYERNOCM                                   *      00003
 *                                                               *      00004
 *  COMMON OPENMVS COMPONENT ERRNO VALUES.                       *      00005
 *                                                               *      00006
 *  THIS IS A SUBSET OF FG501277.BPXYERNO WITH THE COMMONLY USED *      00007
 *  VALUES.                                                      *      00008
 *                                                               *      00009
 ****************************************************************/      00010
 DECLARE  MVS_EACCES               FIXED BIN(15) STATIC INIT(111);      00011
 DECLARE  MVS_EEXIST               FIXED BIN(15) STATIC INIT(117);      00012
 DECLARE  MVS_ENOENT               FIXED BIN(15) STATIC INIT(129);      00013
 DECLARE  MVS_EWOULDBLOCK          FIXED BIN(15) STATIC INIT(1102);     00014
 DECLARE  MVS_EIO                  FIXED BIN(15) STATIC INIT(122);      00015
                                                                        00706
        /* DATA SET GETDSN     AT LEVEL 000 AS OF 01/19/87    */
0/**********************************************************************00001
 *                                                                     *00002
 *                            SUBSET GETDSN                            *00002
 *                                                                     *00003
 * DECLARATION FOR FUNCTIONS GETDSN, GETVOL, GETMEM, AND GETMODE.      *00003
 *                                                                     *00004
 * GETDSN RETURNS THE 44 CHARACTER DATASET NAME GIVEN THE DDNAME.      *00004
 * DSNAME = GETDSN(DDNAME)                                             *00006
 *                                                                     *00007
 * GETVOL RETURNS A 6 CHARACTER VOLUME SERIAL NUMBER OF THE VOLUME     *00007
 * CONTAINING THE DATASET GIVEN THE DDNAME.                            *00007
 * VOLSER = GETVOL(DDNAME)                                             *00009
 *                                                                     *00010
 * FOR EITHER FUNCTION, BLANKS ARE RETURNED IF THE DDNAME IS NOT       *00010
 * FOUND.                                                              *00010
 *                                                                     *00012
 * GETMEM RETURNS A 8 CHARACTER MEMBER NAME TAKEN FROM THE DD OR       *00012
 * ALLOCATE STATMENT FOR THE DATASET WITH THE PASSED DDNAME.           *00012
 * MEMBER = GETVOL(DDNAME)                                             *00014
 *                                                                     *00015
 * FOR THIS FUNCTION, BLANKS ARE RETURNED IF THE DDNAME IS NOT FOUND   *00015
 * OR THERE IS NO MEMBER.                                              *00015
 *                                                                     *00017
 * GETMODE RETURNS A FIXED BINARY(15) SPECIFYING THE CURRENT           *00017
 * ADDRESSING AND RESIDENCY MODES.                                     *00017
 * 0  -  RMODE=24, AMODE=24                                            *00019
 * 1  -  RMODE=24, AMODE=31                                            *00020
 * 2  -  RMODE=31, AMODE=31                                            *00021
 * MODE = GETMODE()                                                    *00022
 *                                                                     *00023
 * ON A NON-XA SYSTEM, ZERO IS ALWAYS RETURNED.                        *00023
 *                                                                     *00024
 **********************************************************************/00024
0   DECLARE GETDSN  ENTRY(CHAR(8)) RETURNS(CHAR(44)) EXTERNAL;          00025
0   DECLARE GETVOL  ENTRY(CHAR(8)) RETURNS(CHAR(6))  EXTERNAL;          00026
0   DECLARE GETMEM  ENTRY(CHAR(8)) RETURNS(CHAR(8))  EXTERNAL;          00027
0   DECLARE GETMODE ENTRY          RETURNS(FIXED BINARY(15)) EXTERNAL;  00028
        /* DATA SET BREAK      AT LEVEL 000 AS OF 10/22/86    */
0/**********************************************************************00001
 *                                                                     *00002
 *                            SUBSET BREAK                             *00002
 * DECLARATION FOR FUNCTION BREAK (LIKE SPITBOL BREAK)                 *00003
 *                                                                     *00004
 **********************************************************************/00004
0 DECLARE BREAK     ENTRY(VARYING CHAR(*),VARYING CHAR(*))              00005
                          RETURNS(FIXED BINARY(15)) EXTERNAL;           00006
        /* DATA SET REVERSE    AT LEVEL 000 AS OF 11/05/86    */
0/**********************************************************************00001
 *                                                                     *00002
 *                           SUBSET REVERSE                            *00002
 * DECLARATION FOR FUNCTION REVERSE                                    *00003
 * THIS ROUTINE WILL RETURN THE STRING PASSED IN REVERSE ORDER, E.I.   *00004
 * WITH THE FIRST CHARACTER LAST, ETC.                                 *00004
 *                                                                     *00006
 * BACKWARD_STRING = REVERSE(STRING)                                   *00006
 *                                                                     *00007
 * SOURCE IS IN FG500242                                               *00007
 *                                                                     *00008
 **********************************************************************/00008
0   DECLARE REVERSE ENTRY(VARYING CHAR(*))                              00009
                    RETURNS(VARYING CHAR(256)) EXTERNAL;                00010
        /* DATA SET LOWERCASE  AT LEVEL 000 AS OF 09/29/87    */
0/**********************************************************************00001
 *                                                                     *00001
 * THIS IS TWO CONSTANTS WHICH ARE USED TO CONVERT FROM LOWER CASE TO  *00001
 * UPPER CASE                                                          *00001
 *                                                                     *00004
 **********************************************************************/00004
0   DECLARE UPPER_CASE_LETTERS CHAR(26) STATIC INIT(                    00005
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ');                                      00006
0   DECLARE LOWER_CASE_LETTERS CHAR(26) STATIC INIT(                    00007
    'abcdefghijklmnopqrstuvwxyz');                                      00008
                                                                        00711
 END FLEXCLI;                                                           00712
*PROCESS;                                                               00001
        /* DATA SET FG50132601 AT LEVEL 006 AS OF 02/05/04    */
 FDZERO:                                                                00002
    PROCEDURE(FD_SET) REORDER OPTIONS(REENTRANT);                       00003
 DECLARE  FD_SET(*)      FIXED BINARY(31);                              00004
                                                                        00005
 FD_SET = 0;                                                            00006
                                                                        00007
        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */
0/**********************************************************************00001
 *                                                                     *00002
 *                           SUBSET DEFAULT                            *00002
 *                                                                     *00003
 * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003
 * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003
 * EASIER REENTRANCY.                                                  *00003
 *                                                                     *00006
 **********************************************************************/00006
                                                                        00007
 DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008
                  DESCRIPTORS ALIGNED;                                  00009
        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.FDZERO                                              00003
 *                                                                      00004
 *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005
 *                                                                      00006
 *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007
 *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008
 *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009
 *  TO THE SELECT FUNCTION.                                             00010
 *                                                                      00011
 *  FDZERO      - ZERO AN FDSET                                         00012
 *                                                                      00013
 *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014
 *                                                                      00015
 *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016
 *                                                                      00017
 *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018
 *  DECLARE   SOCKET       FIXED BINARY(31)                             00019
 *  CALL FDZERO(READ_FDS)                                               00020
 *  CALL FDSET(READ_FDS, SOCKET)                                        00021
 *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022
 *  CALL FDISSET(READ_FDS, SOCKET)                                      00023
 *                                                                      00024
 *  SOURCE IS IN FG501326                                               00025
 *                                                                      00026
 ***************************************************************/       00027
                                                                        00028
 DECLARE  FDZERO       ENTRY(                                           00029
          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030
          EXTERNAL;                                                     00031
                                                                        00032
 DECLARE  FDSET        ENTRY(                                           00033
          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035
          EXTERNAL;                                                     00036
                                                                        00037
 DECLARE  FDISSET      ENTRY(                                           00038
          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040
          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041
                                                                        00042
                                                                        00010
 END FDZERO;                                                            00011
*PROCESS;                                                               00012
 /* THIS ROUTINE ASSUMES SEL#BITSFOREWARD IS PASSED TO SELECT */        00013
 /* THIS MEANS THAT BITS ARE IN FORWARD ORDER */                        00014
 FDSET:                                                                 00015
    PROCEDURE(FD_SET, FD) REORDER OPTIONS(REENTRANT);                   00016
 DECLARE  FD_SET(8)      FIXED BINARY(31) CONNECTED;                    00017
 DECLARE  FD             FIXED BINARY(31);                              00018
                                                                        00019
 DECLARE  FD_SET_OVLY(0:7) BIT(32) BASED(ADDR(FD_SET));                 00020
 DECLARE  INDX           FIXED BINARY(31);                              00021
 DECLARE  BITX           FIXED BINARY(31);                              00022
                                                                        00023
 DECLARE  PATTERNS(0:31) BIT(32)          STATIC INIT(                  00024
                                 '10000000000000000000000000000000'B,   00025
                                 '01000000000000000000000000000000'B,   00026
                                 '00100000000000000000000000000000'B,   00027
                                 '00010000000000000000000000000000'B,   00028
                                 '00001000000000000000000000000000'B,   00029
                                 '00000100000000000000000000000000'B,   00030
                                 '00000010000000000000000000000000'B,   00031
                                 '00000001000000000000000000000000'B,   00032
                                 '00000000100000000000000000000000'B,   00033
                                 '00000000010000000000000000000000'B,   00034
                                 '00000000001000000000000000000000'B,   00035
                                 '00000000000100000000000000000000'B,   00036
                                 '00000000000010000000000000000000'B,   00037
                                 '00000000000001000000000000000000'B,   00038
                                 '00000000000000100000000000000000'B,   00039
                                 '00000000000000010000000000000000'B,   00040
                                 '00000000000000001000000000000000'B,   00041
                                 '00000000000000000100000000000000'B,   00042
                                 '00000000000000000010000000000000'B,   00043
                                 '00000000000000000001000000000000'B,   00044
                                 '00000000000000000000100000000000'B,   00045
                                 '00000000000000000000010000000000'B,   00046
                                 '00000000000000000000001000000000'B,   00047
                                 '00000000000000000000000100000000'B,   00048
                                 '00000000000000000000000010000000'B,   00049
                                 '00000000000000000000000001000000'B,   00050
                                 '00000000000000000000000000100000'B,   00051
                                 '00000000000000000000000000010000'B,   00052
                                 '00000000000000000000000000001000'B,   00053
                                 '00000000000000000000000000000100'B,   00054
                                 '00000000000000000000000000000010'B,   00055
                                 '00000000000000000000000000000001'B);  00056
                                                                        00057
 INDX = FD / 32;                                                        00058
 BITX = MOD(FD,32);                                                     00059
                                                                        00060
 FD_SET_OVLY(INDX) = FD_SET_OVLY(INDX) | PATTERNS(BITX);                00061
                                                                        00062
                                                                        00063
        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */
0/**********************************************************************00001
 *                                                                     *00002
 *                           SUBSET DEFAULT                            *00002
 *                                                                     *00003
 * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003
 * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003
 * EASIER REENTRANCY.                                                  *00003
 *                                                                     *00006
 **********************************************************************/00006
                                                                        00007
 DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008
                  DESCRIPTORS ALIGNED;                                  00009
        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.FDZERO                                              00003
 *                                                                      00004
 *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005
 *                                                                      00006
 *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007
 *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008
 *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009
 *  TO THE SELECT FUNCTION.                                             00010
 *                                                                      00011
 *  FDZERO      - ZERO AN FDSET                                         00012
 *                                                                      00013
 *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014
 *                                                                      00015
 *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016
 *                                                                      00017
 *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018
 *  DECLARE   SOCKET       FIXED BINARY(31)                             00019
 *  CALL FDZERO(READ_FDS)                                               00020
 *  CALL FDSET(READ_FDS, SOCKET)                                        00021
 *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022
 *  CALL FDISSET(READ_FDS, SOCKET)                                      00023
 *                                                                      00024
 *  SOURCE IS IN FG501326                                               00025
 *                                                                      00026
 ***************************************************************/       00027
                                                                        00028
 DECLARE  FDZERO       ENTRY(                                           00029
          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030
          EXTERNAL;                                                     00031
                                                                        00032
 DECLARE  FDSET        ENTRY(                                           00033
          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035
          EXTERNAL;                                                     00036
                                                                        00037
 DECLARE  FDISSET      ENTRY(                                           00038
          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040
          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041
                                                                        00042
                                                                        00066
 DECLARE  MOD             BUILTIN;                                      00067
 DECLARE  ADDR            BUILTIN;                                      00068
                                                                        00069
 END FDSET;                                                             00070
*PROCESS;                                                               00071
 /* THIS ROUTINE ASSUMES SEL#BITSFOREWARD IS PASSED TO SELECT */        00072
 /* THIS MEANS THAT BITS ARE IN FORWARD ORDER */                        00073
 FDISSET:                                                               00074
    PROCEDURE(FD_SET, FD) RETURNS(BIT(1) ALIGNED)                       00075
    REORDER OPTIONS(REENTRANT);                                         00076
 DECLARE  FD_SET(8)      FIXED BINARY(31) CONNECTED;                    00077
 DECLARE  FD             FIXED BINARY(31);                              00078
                                                                        00079
 DECLARE  FD_SET_OVLY(0:7)  BIT(32) BASED(ADDR(FD_SET));                00080
 DECLARE  INDX           FIXED BINARY(31);                              00081
 DECLARE  BITX           FIXED BINARY(31);                              00082
                                                                        00083
 DECLARE  PATTERNS(0:31) BIT(32)          STATIC INIT(                  00084
                                 '10000000000000000000000000000000'B,   00085
                                 '01000000000000000000000000000000'B,   00086
                                 '00100000000000000000000000000000'B,   00087
                                 '00010000000000000000000000000000'B,   00088
                                 '00001000000000000000000000000000'B,   00089
                                 '00000100000000000000000000000000'B,   00090
                                 '00000010000000000000000000000000'B,   00091
                                 '00000001000000000000000000000000'B,   00092
                                 '00000000100000000000000000000000'B,   00093
                                 '00000000010000000000000000000000'B,   00094
                                 '00000000001000000000000000000000'B,   00095
                                 '00000000000100000000000000000000'B,   00096
                                 '00000000000010000000000000000000'B,   00097
                                 '00000000000001000000000000000000'B,   00098
                                 '00000000000000100000000000000000'B,   00099
                                 '00000000000000010000000000000000'B,   00100
                                 '00000000000000001000000000000000'B,   00101
                                 '00000000000000000100000000000000'B,   00102
                                 '00000000000000000010000000000000'B,   00103
                                 '00000000000000000001000000000000'B,   00104
                                 '00000000000000000000100000000000'B,   00105
                                 '00000000000000000000010000000000'B,   00106
                                 '00000000000000000000001000000000'B,   00107
                                 '00000000000000000000000100000000'B,   00108
                                 '00000000000000000000000010000000'B,   00109
                                 '00000000000000000000000001000000'B,   00110
                                 '00000000000000000000000000100000'B,   00111
                                 '00000000000000000000000000010000'B,   00112
                                 '00000000000000000000000000001000'B,   00113
                                 '00000000000000000000000000000100'B,   00114
                                 '00000000000000000000000000000010'B,   00115
                                 '00000000000000000000000000000001'B);  00116
                                                                        00117
 INDX = FD / 32;                                                        00118
 BITX = MOD(FD,32);                                                     00119
                                                                        00120
 IF (FD_SET_OVLY(INDX) & PATTERNS(BITX))                                00121
 THEN                                                                   00122
    RETURN('1'B);                                                       00123
 ELSE                                                                   00124
    RETURN('0'B);                                                       00125
                                                                        00126
        /* DATA SET DEFAULT    AT LEVEL 000 AS OF 10/05/89    */
0/**********************************************************************00001
 *                                                                     *00002
 *                           SUBSET DEFAULT                            *00002
 *                                                                     *00003
 * THIS DEFAULT STATEMENT IS BEING PHASED IN IN PLACE OF THE ONE IN    *00003
 * SUBSET ASETDCLS.  THIS DEFAULT USES AUTO INSTEAD OF STATIC TO ALLOW *00003
 * EASIER REENTRANCY.                                                  *00003
 *                                                                     *00006
 **********************************************************************/00006
                                                                        00007
 DEFAULT RANGE(*) ALIGNED FIXED BINARY,                                 00008
                  DESCRIPTORS ALIGNED;                                  00009
        /* DATA SET FDZERO     AT LEVEL 000 AS OF 04/08/04    */
 /***************************************************************       00001
 *                                                                      00002
 *  SUBSET FG501277.FDZERO                                              00003
 *                                                                      00004
 *  DECLARE FOR ROUTINES FDZERO, FDSET, AND FDISSET                     00005
 *                                                                      00006
 *  THESE ROUTINES PERFORM THE SAME PURPOSE AS THE FD_ZERO, FD_SET,     00007
 *  AND FD_ISSET ROUTINES IN UNIX.  THEY OPERATE ON AN 8 ELEMENT        00008
 *  ARRAY OF FIXED BINARY(31) VARIABLES WHICH ARE EVENTUALLY PASSED     00009
 *  TO THE SELECT FUNCTION.                                             00010
 *                                                                      00011
 *  FDZERO      - ZERO AN FDSET                                         00012
 *                                                                      00013
 *  FDSET       - SET THE BIT FOR THE PASSED FILE DESCRIPTOR.           00014
 *                                                                      00015
 *  FDISSET     - TEST THE BIT FOR THE PASSED FILE DESCRIPTOR.          00016
 *                                                                      00017
 *  DECLARE   READ_FDS(8)  FIXED BINARY(31)                             00018
 *  DECLARE   SOCKET       FIXED BINARY(31)                             00019
 *  CALL FDZERO(READ_FDS)                                               00020
 *  CALL FDSET(READ_FDS, SOCKET)                                        00021
 *  CALL BPX1SEL(..., READ_FDS, ...)                                    00022
 *  CALL FDISSET(READ_FDS, SOCKET)                                      00023
 *                                                                      00024
 *  SOURCE IS IN FG501326                                               00025
 *                                                                      00026
 ***************************************************************/       00027
                                                                        00028
 DECLARE  FDZERO       ENTRY(                                           00029
          (8) FIXED BINARY(31)) /* OUTPUT FD_SET TO BE INITIALIZED  */  00030
          EXTERNAL;                                                     00031
                                                                        00032
 DECLARE  FDSET        ENTRY(                                           00033
          (8) FIXED BINARY(31), /* IN/OUT FD_SET TO BE MODIFIED     */  00034
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO SET IN FD_SET */  00035
          EXTERNAL;                                                     00036
                                                                        00037
 DECLARE  FDISSET      ENTRY(                                           00038
          (8) FIXED BINARY(31), /* INPUT FD_SET TO BE INSPECTED     */  00039
          FIXED BINARY(31))     /* FILE DESCRIPTOR TO TEST IN FD_SET*/  00040
          RETURNS(BIT(1) ALIGNED) EXTERNAL;                             00041
                                                                        00042
                                                                        00129
 DECLARE  MOD             BUILTIN;                                      00130
 DECLARE  ADDR            BUILTIN;                                      00131
                                                                        00132
 END FDISSET;                                                           00133
*PROCESS;                                                               00001
        /* DATA SET FG50078104 AT LEVEL 015 AS OF 10/06/89    */
0/**********************************************************************00002
 *                                                                     *00002
 * SEGMENT NAME:                                                       *00002
 *                                                                     *00002
 *    GETPARM -- EXTRACT A KEYWORD PARAMETER FROM A PARM STRING        *00002
 *                                                                     *00028
 * INPUTS (*TO FUNCTIONS):                                             *00028
 *                                                                     *00003
 *    PARM_STRING -- STRING CONTAINING ALL PARAMETERS (*1,2)           *00003
 *       THE FIRST PARMAMETER TO THIS ROUTINE IS A VARYING LENGTH      *00004
 *       STRING WHICH IS BELIEVED TO CONTAIN THE REQUESTED PARAMETER.  *00004
 *                                                                     *00006
 *    PARM_HEADER -- KEYWORD IDENTIFIER FOR THE STRING. (*1)           *00006
 *       PARAMETERS WITHIN THE PARM STRING ARE IDENTIFIED BY A KEYWORD *00007
 *       HEADER WHICH IS THE SECOND PARAMETER TO THIS ROUTINE.  THE    *00007
 *       HEADERS COME IN TWO VARIETIES.                                *00007
 *                                                                     *00010
 *       XXX=VALUE                                                     *00010
 *       THIS VARIETY IS USED FOR EXTRACTING SIMPLE PARMS.  THE        *00011
 *       PARM_STRING IS SCANNED FOR XXX= AND THE VALUE IS ASSUMED TO   *00011
 *       START AFTER THE EQUAL SIGN.  THE VALUE IS TERMINATED BY A     *00011
 *       COMMA OR END OF STRING.                                       *00011
 *                                                                     *00014
 *       XXX(VALUE)                                                    *00014
 *       THIS VARIETY IS USED FOR EXTRACTING MORE COMPLEX PARMS WHICH  *00015
 *       MAY CONTAIN A COMMA.  THE VALUE IS ASSUMED TO START AFTER THE *00015
 *       OPEN PAREN.  THE VALUE IS TERMINATED BY THE MATCHING CLOSE    *00015
 *       PAREN OR END OF STRING.  MATCHING SETS OF PARENS IN THE VALUE *00015
 *       ARE HANDLED PROPERLY.  MISMATCHED PARENS WILL CAUSE THE END   *00015
 *       OF THE VALUE SECTION TO BE NOT HANDLED PROPERLY.              *00015
 *       VALUES: XXX=VALUE                                             *00021
 *               XXX(VALUE)                                            *00022
 *                                                                     *00027
 * FUNCTIONS:                                                          *00027
 *                                                                     *00027
 *    1. SCAN THE PARM STRING FOR THE PARM HEADER                      *00027
 *                                                                     *00031
 *    2. FIND THE TRAILING DELIMITER FOR THE PARM AND EXTRACT THE PARM *00031
 *       VALUE.                                                        *00031
 *                                                                     *00030
 * OUTPUTS (*FROM FUNCTIONS):                                          *00030
 *                                                                     *00023
 *    VALUE -- RETURNED PARM VALUE (*1,2)                              *00023
 *       THE RETURNED VALUE FROM THIS ROUTINE IS THE VALUE EXTRACTED   *00024
 *       FROM THE PARAMETER.  THE LENGTH VALUE 2048 IS ARBITRARY.      *00024
 *                                                                     *00035
 * NOTES:                                                              *00035
 *                                                                     *00035
 *    1. ISSUE HISTORY                                                 *00035
 *                                                                     *00036
 *       REASON FOR ISSUE 03:                                          *00036
 *       MODIFY CODE TO MAKE SURE THAT THE CHARACTER BEFORE THE SCAN   *00037
 *       STRING IS A VALID DELIMITER.                                  *00037
 *                                                                     *00039
 *       REASON FOR ISSUE 04:                                          *00039
 *       MAKE REENTRANT WITH OPTIONS(REENTRANT).                       *00040
 *                                                                     *00041
 **********************************************************************/00041
-GETPARM:                                                               00042
    PROCEDURE(PARM_STRING,PARM_HEADER)                                  00043
              RETURNS(VARYING CHAR(2048)) OPTIONS(REENTRANT) REORDER;   00044
    DECLARE PARM_STRING     VARYING CHAR(*);                            00045
    DECLARE PARM_HEADER     VARYING CHAR(*);                            00046
                                                                        00047
    DEFAULT RANGE(*) ALIGNED;                                           00048
                                                                        00049
    DECLARE I               FIXED BINARY(15)   AUTO;                    00050
    DECLARE J               FIXED BINARY(15)   AUTO;                    00051
    DECLARE TEMP_PARM       VARYING CHAR(2048) AUTO;                    00052
    DECLARE C               CHAR(1)            AUTO;                    00053
    DECLARE NEST_CHAR       CHAR(1)            AUTO INIT(' ');          00054
    DECLARE NEST_LEVEL      FIXED BINARY(15)   AUTO INIT(0);            00055
                                                                        00056
    DECLARE (LENGTH, PLIRETC, INDEX, SUBSTR, VERIFY) BUILTIN;           00057
                                                                        00058
    I = INDEX(PARM_STRING,PARM_HEADER);                                 00059
    IF I = 0                                                            00060
    THEN                                                                00061
       RETURN('');                                                      00062
    ELSE                                                                00063
       DO;                                                              00064
          DO WHILE(VALID_DLM(I-1) = '0'B);                              00065
             J = INDEX(SUBSTR(PARM_STRING,I+1),PARM_HEADER);            00066
             IF J = 0                                                   00067
             THEN                                                       00068
                RETURN('');                                             00069
             I = I + J;                                                 00070
          END;                                                          00071
          IF I = 0                                                      00072
          THEN                                                          00073
             RETURN('');                                                00074
          C = SUBSTR(PARM_HEADER,LENGTH(PARM_HEADER),1);                00075
          IF C = '('                                                    00076
          THEN                                                          00077
             DO;                                                        00078
                C = ')';                                                00079
                NEST_CHAR = '(';                                        00080
             END;                                                       00081
          ELSE                                                          00082
             C = ',';                                                   00083
          TEMP_PARM = SUBSTR(PARM_STRING,I+LENGTH(PARM_HEADER));        00084
          DO I = 1 TO LENGTH(TEMP_PARM);                                00085
             IF NEST_CHAR ¬= ' ' & SUBSTR(TEMP_PARM,I,1) = NEST_CHAR    00086
             THEN                                                       00087
                NEST_LEVEL = NEST_LEVEL + 1;                            00088
             IF SUBSTR(TEMP_PARM,I,1) = C                               00089
             THEN                                                       00090
                DO;                                                     00091
                   IF NEST_LEVEL = 0                                    00092
                   THEN                                                 00093
                      DO;                                               00094
                         IF I = 1                                       00095
                         THEN                                           00096
                            RETURN('');                                 00097
                         ELSE                                           00098
                            RETURN(SUBSTR(TEMP_PARM,1,I-1));            00099
                      END;                                              00100
                   ELSE                                                 00101
                      NEST_LEVEL = NEST_LEVEL - 1;                      00102
                END;                                                    00103
          END;                                                          00104
          RETURN(TEMP_PARM);                                            00105
       END;                                                             00106
1                                                                       00107
 VALID_DLM:                                                             00108
    PROCEDURE(IND);                                                     00109
    DECLARE  IND  FIXED BINARY(15);                                     00110
    DECLARE  C    CHAR(1) AUTO;                                         00111
    IF IND <= 0                                                         00112
    THEN                                                                00113
       RETURN('1'B); /* START OF STRING IS OK */                        00114
    C = SUBSTR(PARM_STRING,IND,1);                                      00115
    IF VERIFY(C,', )/(`~*''') = 0                                       00116
    THEN                                                                00117
       RETURN('1'B); /* IS A VALID DELIMITER */                         00118
    ELSE                                                                00119
       RETURN('0'B); /* NOT A VALID LEADING DELIMITER */                00120
0END VALID_DLM;                                                         00121
0END GETPARM;                                                           00122
