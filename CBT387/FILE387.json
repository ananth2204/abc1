{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011910000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3879876, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE387.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3879876, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3879876, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE387.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00<\\x0e'", "DS1TRBAL": "b'+\\x90'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xc4\\x00\\x01\\x02\\xc8\\x00\\x01\\x00='", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x045\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x17\\x12\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf3@@@'", "ispf": {"version": "04.53", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T17:12:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-453"}, "text": "REGULAR CBT TAPE - VERSION 453    FILE:  387\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT453.FILE387\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 29 MEMBERS COUNTED; CUMULATIVE SIZE IS 36,259 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/11/02    17:12:32    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x161\\x00H\\x00H\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:31:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "SPASCAL"}, "text": "Stonybrook Pascal Tape\n\nThe files on the Stonybrook Pascal tape were as follows:\n                                                    UTILITY   PKzipped\nFILE    DATASET NAME       RECFM   LRECL   BLKSIZE  USED      FILENAME\n====    ================   =====   =====   =======  ========  ========\n  1     COMMENTS           FR      80      7200     IEBGENER  FILE01\n  2     OMONITOR.ASM       FR      80      7200     IEBGENER  FILE02\n  3     RMONITOR.ASM       FR      80      7200     IEBGENER  FILE03\n  4     USER.PASCAL        FB      80      800      IEHMOVE   FILE04\n  5     PASS1.XPL          FR      80      7200     IEBGENER  FILE05\n  6     PASS1.OBJ          F       7200    7200     IEBGENER  FILE06\n  7     PASS2.XPL          FR      80      7200     IEBGENER  FILE07\n  8     PASS2.OBJ          F       7200    7200     IEBGENER  FILE08\n  9     PASS3.XPL          FR      80      7200     IEBGENER  FILE09\n 10     PASS3.OBJ          F       7200    7200     IEBGENER  FILE10\n 11     PMD.XPL            FB      80      7200     IEBGENER  FILE11\n 12     PMD.OBJ            F       7200    7200     IEBGENER  FILE12\n 13     BNCHMRKS           FR      80      7200     IEBGENER  FILE13\n 14     XPLSM.ASM          FR      80      7200     IEBGENER  FILE14\n 15     XCOM.OBJ           F       7200    7200     IEBGENER  FILE15\n 16     XCOM4.XPL          FR      80      7200     IEBGENER  FILE16\n 17     XPLIB.XPL          FR      80      7200     IEBGENER  FILE17\n 18     XPLXREF.XPL        FR      80      7200     IEBGENER  FILE18\n 19     EDITXPL.XPL        FR      80      7200     IEBGENER  FILE19\n 20     PASS1.UPDATE4      FR      80      7200     IEBGENER  FILE20\n 21     PASS2.UPDATE4      FR      80      7200     IEBGENER  FILE21\n 22     PASS3.UPDATE4      FR      80      7200     IEBGENER  FILE22\n 23     PMD.UPDATE4        FR      80      7200     IEBGENER  FILE23\n 24     OMONITOR.UPDATE4   FR      80      7200     IEBGENER  FILE24\n 25     RMONITOR.UPDATE4   FR      80      7200     IEBGENER  FILE25\n\n NOTE 1:     These files were downloaded to the PC with \"no conversion\",\n          so they contain the original binary or EBCDIC representation.\n          Also, there are no extra CR/LF characters to delimit records.\n\n NOTE 2:  I do not really remember a RECFM=FR, but that is what the\n    \"standard labels\" on the tape actually indicated, and I was\n    able to read the data just fine, by using RECFM=FB.\n\n NOTE 3:  I believe 7200 byte blocks was for \"full-track\" blocking\n    on a 2314 drive. This is not a great choice on most other\n    newer DASD devices, however.\n\n    You might want to use a more \"portable\" blocksize, such\n    as RECFM=FB,LRECL=80,BLKSIZE=3120 for source code files.\n    This should not present any problems, as IEBGENER will\n    re-block automatically (just keep the LRECL set to 80)\n    when you copy from these \"tape\" files.\n\n NOTE 4:  The XPL system uses its own peculiar program loader that\n    reads the \"object code\" from special OBJ files with a\n    RECFM=F, LRECL=7200 and BLKSIZE=7200. If you want to\n    change this, you will apparently have to change a constant\n    DECLARE in the XCOM compiler (XCOM4.XPL), and recompile\n    XCOM, and also change the constant in XPLSM.ASM, the\n    runtime loader routine, and reassemble it. (Good luck!)\n\n    By the way, an appropriate \"portable\" blocksize for this\n    file should be 6140, which waste some space on 2314s, but,\n    who really uses 2314s any more? (BLKSIZE=6140 fits 2 blocks\n    per track on 3330s, and 3 records per track on 3350s.)\n\nThere is also a file named XPLPAS.TXT in the ZIP file, that is a\nbrief overview of how to install the Stonybrook Pascal compiler\nunder OS/360.  (This is the same as FILE01, converted to ASCII).\n\nAnd, this file (README.TXT) is also included in the XPL.ZIP file.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$XPLPAS": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x17\\x01\\x02\\xef\\x02\\xef\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T17:01:00", "lines": 751, "newlines": 751, "modlines": 0, "user": "SPASCAL"}, "text": "TITLE -- DESCRIPTION OF THE TAPE FOR THE STONY BROOK PASCAL 360 SYSTEM\nAUTHOR -- WILLIAM BARABASH\nDATE -- 22 MAY 1977 (UPDATE 4)\nADDRESS -- DEPARTMENT OF COMPUTER SCIENCE\n           S.U.N.Y. AT STONY BROOK\n           STONY BROOK, NEW YORK 11794\nTELEPHONE NUMBER -- (516) 246-7146\n\n\n      THIS TAPE CONSISTS OF 25 FILES WRITTEN ON A NINE TRACK\nMAGNETIC TAPE.  YOU ARE NOW READING THE CONTENTS OF FILE 1, WHICH\nCONTAINS INSTRUCTIONS ON HOW TO RETRIEVE THE CONTENTS OF FILES 2\nTHROUGH 25 (AND ALSO ON HOW TO RE-RETRIEVE FILE 1 ITSELF).\n\n      HEREWITH ARE DESCRIPTIONS OF THE CONTENTS OF THE 25 FILES\nON THIS TAPE AND COMMENTS AS TO HOW THEY MAY BE USED.\n\n\n                           *****  FILE 1  *****\n                          *****  COMMENTS  *****\n\n      THIS FILE CONTAINS A SEQUENCE OF CARD IMAGES WHICH, WHEN\nPRINTED, WILL PROVIDE A DESCRIPTION OF THIS TAPE AND INSTRUCTIONS\nFOR ITS USE.  THE ATTRIBUTES OF THIS FILE (AND ALL SOURCE CODE\nFILES APPEARING ON IT) ARE:__\n\n               DCB=(RECFM=FBS,LRECL=80,BLKSIZE=7200) .\n\n      THE CONTENTS OF FILE 1 MAY BE RE-RETRIEVED BY A JOB SIMILAR\nTO THE FOLLOWING:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBPTPCH\n//SYSPRINT DD SYSOUT=A\n//SYSUT1   DD DSN=COMMENTS,DISP=OLD,UNIT=TAPE9,VOL=SER=PASCAL\n//SYSUT2   DD SYSOUT=A\n//SYSIN    DD *\n         PRINT TYPORG=PS,MAXFLDS=1\n         TITLE ITEM=('DESCRIPTION OF PASCAL TAPE',50)\n        RECORD FIELD=(80,,,20)\n//\n\n\n                           *****  FILE 2  *****\n                        *****  OMONITOR.ASM  *****\n\n      THIS FILE CONTAINS THE PASCAL OVERLAY MONITOR, A MUTATION\nOF XPLSM WHICH SUPPORTS THE MULTIPASS ARCHITECTURE OF THE STONY\nBROOK PASCAL 360 COMPILER.  THE MAJOR DIFFERENCES BETWEEN THIS\nPROGRAM AND XPLSM ARE THE NUMBER OF INPUT FILES (UP TO 6), THE\nNUMBER OF OUTPUT FILES (UP TO 7) AND THE DDNAMES THE FILES ARE\nMAPPED ONTO.  SPECIFICALLY,\n\n            //PROGRAM  DD  ...\n\nIS REPLACED BY\n\n            //PASS1  DD  ...\n            //PASS2  DD  ...\n            //PASS3  DD  ...\n                  AND\n            //PMD    DD  ...\n\nSTATEMENTS.  THE SEQUENTIALLY-ACCESSED FILE DD'S\n\n            //INPUT2  DD  ...\nAND         //OUTPUT3  DD  ...\n\nARE REPLACED BY\n\n            //SYSUT1  DD  ... .\n\n      LIKEWISE, WE REPLACE  //INPUT3  AND  //OUTPUT4  BY  //SYSUT2,\n//INPUT4  AND  //OUTPUT5  BY  //SYSUT3 , AND //INPUT5 AND //OUTPUT6 BY\n//SYSUT4.\n\n      INPUT(0) AND INPUT(1) REFER TO  //SYSIN  , OUTPUT(0) AND\nOUTPUT(1) REFER TO  //SYSPRINT  AND OUTPUT(2) REFERS TO\n//SYSPUNCH  AS UNDER XPLSM.\n\n      THE SYSUT FILES ARE USED AS FOLLOWS:  DURING PASS 1, FILE\nSYSUT1 IS GENERATED (VIA ASSIGNMENTS TO THE PSEUDOVARIABLE\nOUTPUT(3)) FOR TRANSMITTING THE PARSE TREES TO PASS 2.  SYSUT2 IS\nGENERATED (VIA ASSIGNMENTS TO THE PSEUDO-VARIABLE OUTPUT(4)) FOR\nTRANSMITTING SYMBOL TABLE INFORMATION TO PASS 2.  SYSUT3 IS\nGENERATED (VIA ASSIGNMENTS TO THE PSEUDOVARIABLE OUTPUT(5)) FOR\nTRANSMITTING CONTROL INFORMATION TO PASS 2.  PASS 2 WILL READ THE\nCONTENTS OF FILES SYSUT1, SYSUT2, AND SYSUT3 WITH CALLS TO\nINPUT(2), INPUT(3) AND INPUT(4) RESPECTIVELY.  IT MAY THEN\nREGENERATE THE FILES FOR TRANSMITTING INFORMATION TO PASS 3.\n\n      NOTE THAT NO SYSUT FILE IS EVER OPEN BOTH FOR INPUT AND\nOUTPUT AT THE SAME TIME.  WHEN THE PASCAL OVERLAY MONITOR DETECTS\nTHAT A SYSUT FILE WHICH IS OPEN FOR X IS TO BE USED FOR Y, WHERE\nX \u00bc= Y AND X, Y IN (. INPUT, OUTPUT .), IT WILL REWIND THE FILE,\nCLOSING IT FOR X, AND WILL THEN OPEN IT FOR Y.  BETWEEN PASSES,\nALL FILES (EXCEPT SYSIN, SYSPRINT AND SYSPUNCH) ARE CLOSED.\n\n      UNLIKE XPLSM, WHEN THE PASCAL OVERLAY MONITOR DETECTS AN\nENDFILE SITUATION ON ANY INPUT FILE (EXCEPT SYSIN), IT WILL NOT\nMARK THE FILE PERMANENTLY UNUSABLE;  IT WILL REWIND THE FILE.  IT\nIS THEREFORE VITALLY IMPORTANT THAT ONE ALWAYS TEST FOR THE\nENDFILE CONDITION ON ALL INPUT CALLS.\n\n      THE TRACE ROUTINE IS NOT AVAILABLE TO PROGRAMS RUNNING\nUNDER THE PASCAL OVERLAY MONITOR.  CALL TRACE AND CALL UNTRACE\nWOULD BE NO-OPS WITHIN THE PASCAL COMPILER.\n\n      FILE 2 CAN BE RETRIEVED BY THE FOLLOWING PROGRAM:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=OMONITOR.ASM,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(2,SL), X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 3  *****\n                        *****  RMONITOR.ASM  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR THE PASCAL RUN\nMONITOR, AN ASM360 PROGRAM WHICH LOADS PASCAL PROGRAMS AND\nPROVIDES THE RUN-TIME ENVIRONMENT NEEDED FOR THEIR EXECUTION.\n\n      FILE 3 CAN BE RETRIEVED BY THE FOLLOWING PROGRAM:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=RMONITOR.ASM,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(3,SL), X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 4  *****\n                         *****  USER.PASCAL  *****\n\n      THIS FILE CONTAINS THE UNLOADED PARTITIONED DATA SET\nUSER.PASCAL, WHICH CONTAINS AS ITS ONLY TWO MEMBERS THE LOAD\nMODULES PASCAL (THE PASCAL OVERLAY MONITOR) AND RMONITOR (THE\nPASCAL RUN MONITOR).  THE OVERLAY MONITOR TRANSFERS CONTROL TO\nRMONITOR WITH A 'LINK' MACRO SPECIFYING NO DCB.  THEREFORE,\nRMONITOR MUST EITHER RESIDE IN THE STEPLIB DATASET, THE JOBLIB\nDATASET OR THE SYSTEM LINKAGE LIBRARY (SYS1.LINKLIB).\n\n      THE OBJECT VERSION OF OMONITOR CORRESPONDS TO THE SOURCE\nCODE (FILE 2) AS MODIFIED BY THE OMONITOR UPDATE PATCHES (FILE\n24).  THE OBJECT VERSION OF RMONITOR CORRESPONDS TO THE SOURCE\nCODE (FILE 3) AS MODIFIED BY THE RMONITOR UPDATE PATCHES (FILE\n25).\n\n      THE ORIGINAL OF USER.PASCAL HAS BLKSIZE=7294 (FOR 2314 DISKS).\n\n      THE CONTENTS OF THIS FILE MAY BE PLACED INTO A DIRECT\nACCESS DATA SET IN A FORM READY FOR USE BY A JOB OF THE FOLLOWING\nTYPE:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEHMOVE\n//SYSPRINT DD SYSOUT=A\n//SYSUT1   DD UNIT=SYSDA,VOL=SER=USB001,DISP=OLD\n//TARGET   DD UNIT=2314,VOL=SER=USER03,DISP=(NEW,CATLG),               X\n//            SPACE=(TRK,(8,,10)),DCB=(DSORG=PO,RECFM=U,BLKSIZE=7294)\n//SOURCE   DD UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(4,SL),DISP=OLD\n//SYSIN    DD *\n         COPY  PDS=USER.PASCAL,FROM=2400=(PASCAL,4),TO=2314=USER03\n//\n\n\n                           *****  FILE 5  *****\n                          *****  PASS1.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR PASS 1 OF THE STONY\nBROOK PASCAL 360 COMPILER.  PASS 1 IS RESPONSIBLE FOR LEXICAL AND\nSYNTACTIC ANALYSIS OF PASCAL PROGRAMS AND PRODUCES PARSE TREES AS\nOUTPUT.  THE CURRENT VERSION INCLUDES THE HENNESSY - GOLDSTEIN -\nCHINSAW DGNS MODULE (AS MODIFIED BY MYSELF) WHICH PREPARES A\nPARAGRAPHED LISTING FOR USE IN AN EXECUTION FLOW SUMMARY, THE\nKIEBURTZ BLOCK-STRUCTURED HASHING LOOKUP FOR IDENTIFIERS, AND\nERROR RECOVERY ROUTINES BY AJIT PAI.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING PROGRAM:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS1.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(5,SL),    X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 6  *****\n                          *****  PASS1.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PASS1 (FILE 5) AS\nMODIFIED BY THE PASS1 UPDATE 4 PATCHES (FILE 20), READY FOR\nLOADING BY THE PASCAL OVERLAY MONITOR.  PASS1 CAN BE PUT UP BY\nTHE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS1.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(6,SL),    X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PASS1,DISP=(NEW,CATLG),UNIT=2314,        X\n//            SPACE=(TRK,14),VOL=SER=USER03,                           X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n\n                           *****  FILE 7  *****\n                          *****  PASS2.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR PASS 2 OF THE STONY\nBROOK PASCAL 360 COMPILER.  PASS 2 IS RESPONSIBLE FOR TYPE\nCHECKING, AND GENERATING SYMBOLIC TRIPLES SUITABLE FOR\nINTERPRETATION OR FURTHER PROCESSING BY A CODE GENERATOR.  THE\nCURRENT VERSION INCLUDES ROUTINES BY PROFESSOR KIEBURTZ FOR\nSYMBOL TABLE CONSTRUCTION AND STORAGE ALLOCATION.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS2.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(7,SL),    X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 8  *****\n                          *****  PASS2.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PASS 2 (FILE 7) AS\nMODIFIED BY THE PASS 2 UPDATE 4 PATCHES (FILE 21), READY FOR\nLOADING BY THE PASCAL OVERLAY MONITOR.  PASS2 CAN BE PUT UP BY\nTHE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS2.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(8,SL),    X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PASS2,DISP=(NEW,CATLG),UNIT=2314,        X\n//            SPACE=(TRK,20),VOL=SER=USER03,                           X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n\n                           *****  FILE 9  *****\n                          *****  PASS3.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR PASS 3 OF THE STONY\nBROOK PASCAL COMPILER.  WRITTEN BY CHARLES R. HILL, IT TAKES AS\nINPUT THE SYMBOLIC TRIPLES GENERATED BY PASS 2 AND GENERATES\nMACHINE CODE FOR THE IBM 360/370 SERIES COMPUTERS.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS3.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(9,SL),    X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 10  *****\n                          *****  PASS3.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PASS 3 (FILE 9) AS\nMODIFIED BY THE PASS 3 UPDATE 4 PATCHES (FILE 22), READY FOR\nLOADING BY THE PASCAL OVERLAY MONITOR.  PASS 3 CAN BE PUT UP BY\nTHE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS3.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(10,SL),   X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PASS3,DISP=(NEW,CATLG),UNIT=2314,        X\n//            SPACE=(TRK,16),VOL=SER=USER03,                           X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n                           *****  FILE 11  *****\n                           *****  PMD.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR THE POST-MORTEM\nANALYSIS ROUTINES (PMD).  IF A PASCAL PROGRAM TERMINATES WITH A\nPASCAL RUN ERROR AND DEBUG LEVEL > 0, THE POST MORTEM DUMP\nROUTINE PRINTS THE VALUES OF ALL LOCAL SCALAR, SUBRANGE, POINTER\nAND STRING VARIABLES FOR THE FIVE MOST RECENT ACTIVATIONS OF ALL\nACTIVE PROCEDURES.  (THE VALUE OF A POINTER IS PRINTED OUT AS\nEITHER 'NIL', 'DEFINED', OR 'UNDEFINED').  IF DEBUG LEVEL = 2 IS\nSPECIFIED (STRONGLY RECOMMENDED AS THE DEFAULT), AN EXECUTION\nFLOW SUMMARY WHICH INDICATES THE NUMBER OF TIMES EACH STATEMENT\nWAS EXECUTED IS PRINTED.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PMD.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(11,SL),     X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 12  *****\n                           *****  PMD.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PMD (FILE 11) AS\nMODIFIED BY THE PMD UPDATE PATCHES (FILE 23), READY FOR LOADING\nBY THE PASCAL OVERLAY MONITOR.  PMD CAN BE PUT UP BY THE\nFOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PMD.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(12,SL),     X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PMD,DISP=(NEW,CATLG),UNIT=2314,          X\n//            SPACE=(TRK,5),VOL=SER=USER03,                            X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n\n      HAVING PROCESSED FILES 4, 6, 8, 10 AND 12 ABOVE, YOU ARE\nNOW READY TO RUN YOUR PASCAL PROGRAMS.  THE FOLLOWING JCL\nPROCEDURE IS RECOMENDED:__\n\n//PASCAL PROC SECONDS=10,LINES=1000,DBGLVL=2\n//PASCAL EXEC PGM=PASCAL,REGION=148K,                                  X\n//            PARM='TIME=&SECONDS,LINES=&LINES,DEBUG=&DBGLVL'\n//STEPLIB  DD DSNAME=USER.PASCAL,DISP=SHR\n//PASS1    DD DSNAME=USER.PASCAL.PASS1,DISP=SHR\n//PASS2    DD DSNAME=USER.PASCAL.PASS2,DISP=SHR\n//PASS3    DD DSNAME=USER.PASCAL.PASS3,DISP=SHR\n//PMD      DD DSNAME=USER.PASCAL.PMD,DISP=SHR\n//FILE3    DD UNIT=SYSDA,SPACE=(CYL,3)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT2   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT3   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT4   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT5   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=A\n//       PEND\n\n      ONCE THE ABOVE JCL PROCEDURE IS CATALOGED, A PASCAL PROGRAM\nCAN BE RUN USING THE FOLLOWING DECK SETUP:\n\n//    (JOB CARD)\n//DOIT   EXEC PASCAL\n//SYSIN    DD *\n           :\n   PASCAL SOURCE CODE\n           :\n%EOF\n           :\n   INPUT TO THE PASCAL PROGRAM\n           :\n//\n\n\n      NOTE THAT THE CARD IMAGE WHICH SEPARATES THE PASCAL PROGRAM\nFROM THE INPUT DATA MUST CONTAIN THE CHARACTERS '%EOF' STARTING\nIN COLUMN ONE.  THIS IS MANDAT- ORY, AND CAUSES THE OVERLAY\nMONITOR TO RETURN AN END OF FILE TO THE PASS ONE SCANNER.\n\n      THE PASCAL COMPILER SHOULD RUN COMFORTABLY IN A 148K\nPARTITION UNDER OS/MVT OR A 152K PARTITION UNDER OS/MFT.\n\n      TO HELP YOU GET STARTED, A SAMPLE RUN STREAM (MINUS THE JOB\nCARD) IS INCLUDED.\n\n\n                           *****  FILE 13  *****\n                      *****  BNCHMARK.PROGRAMS  *****\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=BNCHMARK.PROGRAMS,UNIT=TAPE9,VOL=SER=PASCAL,         X\n//            LABEL=(13,SL),DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n      IN ORDER TO HELP YOU MAINTAIN A LOCAL COPY OF THE STONY\nBROOK PASCAL COMPILER, THE FOLLOWING PROGRAMS ARE INCLUDED ON THE\nTAPE:__\n\n\n                           *****  FILE 14  *****\n                          *****  XPLSM.ASM  *****\n\n      THIS FILE CONTAINS AN ASSEMBLY LANGUAGE VERSION OF THE XPL\nSUBMONITOR, XPLSM.  EXTERNAL REFERENCES TO THE TRACE ROUTINE HAVE\nBEEN ELIMINATED.  THIS FILE IS READY FOR ASSEMBLING AND\nLINKEDITING INTO A LOAD MODULE LIBRARY, IN CASE XPL IS NOT\nCURRENTLY AVAILABLE AT YOUR INSTALLATION.\n\n      THE FOLLOWING JCL WILL SUFFICE:__\n\n//    (JOB CARD)\n//DOIT   EXEC ASMFCL,PARM.ASM='LOAD,NODECK'\n//ASM.SYSIN DD UNIT=TAPE9,VOL=SER=PASCAL,DSN=XPLSM.ASM,LABEL=(14,SL),  X\n//            DISP=OLD\n//LKED.SYSLMOD DD DSN=USER.PASCAL(XPLSM),DISP=OLD\n//\n\n\n                           *****  FILE 15  *****\n                          *****  XCOM4.OBJ  *****\n\n      XCOM4 IS THE VERSION OF THE XPL COMPILER THAT HAS BEEN USED\nTO COMPILE THE PASCAL COMPILER.  IT DOES NOT SUPPORT ANY\nNON-STANDARD XPL FEATURE, BUT IT DOES CORRECT SOME WELL-KNOWN\nBUGS, AND WE DO NOT GUARANTEE THAT THE PASCAL COMPILER SOURCE\nWILL COMPILE CORRECTLY UNDER XCOM3.  XCOM4 IS ALSO FASTER IN\nEXECUTION THAN XCOM3.  THEREFORE, EVEN IF XPL IS ALREADY\nAVAILABLE AT YOUR INSTALLATION, WE STRONGLY URGE YOU TO PUT UP\nXCOM4.  TO PUT IT UP ON A 2314 DISK, WE SUGGEST THE FOLLOWING\nJCL:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=XCOM4.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(15,SL),   X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.XCOM4,UNIT=2314,VOL=SER=USER03,SPACE=(TRK,18),  X\n//            DISP=(NEW,CATLG)\n//\n\n\n\n      IF XPL IS NOT CURRENTLY AVAILABLE AT YOUR INSTALLATION, WE\nSUGGEST YOU CATALOG THE FOLLOWING PROCEDURE:__\n\n//XPLC   PROC\n//XPL    EXEC PGM=XPLSM,REGION=180K,PARM='ALTER'\n//STEPLIB  DD DSNAME=USER.PASCAL,DISP=SHR\n//FILE1    DD UNIT=SYSDA,SPACE=(CYL,3),                                X\n//            DSNAME=&&XPL,DISP=(NEW,PASS)\n//FILE2    DD UNIT=SYSDA,SPACE=(CYL,3)\n//FILE3    DD UNIT=SYSDA,SPACE=(CYL,3)\n//INPUT2   DD DSN=USER.XPLIB,DISP=SHR\n//PROGRAM  DD DSN=USER.XCOM4,DISP=SHR\n//SYSPRINT DD SYSOUT=A\n//SYSPUNCH DD SYSOUT=B\n//       PEND\n\n\n                           *****  FILE 16  *****\n                          *****  XCOM4.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE VERSION OF XCOM4.  TO PRODUCE\nXPL OBJECT MODULES FOR DISKS WHOSE TRACK SIZE IS SOMEWHAT\nDIFFERENT THAN THAT OF 2314 DISKS (1) REASSEMBLE XPLSM (FILE 14)\nCHANGING FILBYTS, AND (2) RECOMPILE XCOM4 CHANGING DISKBYTES TO A\nNEW VALUE WHICH (OPTIMALLY) IS THE LARGEST MULTIPLE OF 80 THAT IS\nLESS THAN OR EQUAL TO THE TRACK CAPACITY OF YOUR DISKS.  (CAUTION\nTO 3330 USERS: YOU MAY HAVE TO SPECIFY A LARGER REGION SIZE IN\nYOUR XPLC PROC IF YOU DO THIS.)\n\n    THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=XCOM4.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(16,SL),   X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 17  *****\n                          *****  XPLIB.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE VERSION OF COMPACTIFY, THE\nXPL PROCEDURE WHICH IS CONCATENATED ON TO THE FRONT OF EVERY XPL\nPROGRAM AUTOMATICALLY.  IF YOUR INSTALLATION DOES NOT CURRENTLY\nHAVE XPL, COMPACTIFY CAN BE PUT UP BY A JOB SUCH AS:__\n\n//    (JOB CARD)\n//DOIT EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=XPLIB.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(17,SL),   X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.XPLIB,DISP=(NEW,CATLG),UNIT=2314,               X\n//            SPACE=(TRK,(2,1)),VOL=SER=USER03,                        X\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=7200)\n//\n\n                           *****  FILE 18  *****\n                         *****  XPLXREF.XPL  *****\n\n      THIS FILE CONTAINS THE XPL SOURCE CODE OF A CROSS-REFERENCE\nLISTING PROGRAM FOR XPL SOURCE.  IT LISTS GLOBAL IDENTIFIERS, AND\nTHE LINE NUMBERS OF ALL REFERENCES TO THOSE IDENTIFIERS, BUT DOES\nNOT RECOGNIZE REDECLARATIONS OF IDENTIFIERS.  ITS TOGGLES ARE:\n\n      $K - PRODUCE A LINE-NUMBERED LISTING OF XPL SOURCE CODE\n           PRECEDING THE CROSS-REFERENCE TABLE - INITIALLY OFF.\n      $P - PRODUCE CROSS REFERENCE LISTINGS OF LOCAL VARIABLES OF\n           PROCEDURES INITIALLY OFF.\n\n      XPLXREF RUNS IN A 180K PARTITION.\n\n      TO COMPILE XPLXREF FROM THIS TAPE ONTO A 2314 DISK USING\nTHE JCL PROCEDURE XPLC, USE JCL SIMILAR TO THE FOLLOWING:__\n\n//    (JOB CARD)\n//XPL    EXEC XPLC\n//FILE1    DD DSN=USER.XPLXREF,UNIT=2314,VOL=SER=USER03,SPACE=(TRK,15),X\n//            DISP=(NEW,CATLG)\n//SYSIN    DD DSN=XPLXREF.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(18,SL), X\n//            DISP=OLD\n//\n\n\n      TO EXECUTE XPLXREF, USE JCL SIMILAR TO THE FOLLOWING:__\n\n//    (JOB CARD)\n//XREF   EXEC XPLC\n//PROGRAM  DD DSN=USER.XPLXREF,DISP=SHR\n//SYSIN    DD *\n           :\n    (XPL SOURCE TO BE CROSS-REFERENCED)\n           :\n//\n\n\n                           *****  FILE 19  *****\n                         *****  EDITXPL.XPL  *****\n\n      THIS FILE CONTAINS THE XPL SOURCE CODE OF A CARD-IMAGE\nEDITOR.  IT ACCEPTS THE FILE OF CARD IMAGES TO BE EDITED ON FILE\nINPUT(2), AND THE EDIT COMMANDS AND CARDIMAGES TO BE INSERTED ON\nTHE FILE SYSIN.  OUTPUT IS TO FILE SYSPUNCH.  IF A LINE-NUMBERED\nLISTING OF THE OUTPUT FILE IS DESIRED, IT WILL BE PRODUCED ON\nFILE OUTPUT(3).  THIS PROGRAM WILL BE USED TO EDIT UPDATE PATCHES\nINTO THE PASCAL COMPILER SOURCE FILES.\n\n      IN THE SYSIN FILE, AN EDIT COMMAND IS RECOGNIZED BY A\nCONTROL CHARACTER IN THE FIRST COLUMN.  THE CONTROL CHARACTER IS\nINITIALLY ASTERISK ('*'), BUT THAT CAN BE DYNAMICALLY CHANGED\n(SEE BELOW).  AN EDIT COMMAND MAY CONTAIN, IN FREE FORMAT ON THE\nREST OF THE CARD:\n\n      A SEQUENCE OF NUMBERS OR SUBRANGES OF NUMBERS, AS 2 5 9..12\n           THAT ARE INTERPRETED AS LINE NUMBERS IN THE SOURCE\n           FILE AND WHICH PROVIDE POINTS FOR INVOCATION OF EDIT\n           COMMANDS;\n\n      $I - THE INSERT COMMAND.  AT THE POINT IN THE SOURCE FILE\n           FOLLOWING THE LAST PRECEDING LINE NUMBER GIVEN ON AN\n           EDIT COMMAND CARD, THE SEQUENCE OF CARDS FOLLOWING THE\n           COMMAND CARD WILL BE INSERTED INTO THE SOURCE FILE.\n           THIS WILL TERMINATE WHEN THE NEXT EDIT COMMAND CARD IS\n           ENCOUNTERED (OR UPON END-OF-FILE);\n\n      $L - LISTING TOGGLE, INITIALLY OFF.  WHEN ON, THE SOURCE\n           FILE, AS MODIFIED BY EDITING, IS LISTED ON THE OUTPUT3\n           FILE.\n\n      $P - OUTPUT TOGGLE INITIALLY ON.  WHEN ON, THE MODIFIED\n           SOURCE FILE IS OUTPUT TO THE SYSPUNCH FILE.\n\n      $D - DELETION TOGGLE, INITIALLY OFF.  WHEN ON, EACH RECORD\n           OF THE SOURCE FILE THAT IS MENTIONED BY NUMBER OR\n           INCLUDED IN A SUBRANGE ON A COMMAND CARD IS DELETED\n           FROM THE MODIFIED SOURCE FILE.  TO REPLACE, YOU WOULD\n           USE DELETE AND INSERT.\n\n      $<OLD CONTROL CHAR><NEW CONTROL CHAR> - DYNAMICALLY CHANGES\n           THE CONTROL CHARACTER.  NOTE THAT <OLD CONTROL CHAR>\n           MUST APPEAR IN COLUMN 1.  FOR EXAMPLE\n\n*   $*@\n\n           CHANGES THE CONTROL CHARACTER FROM '*' TO '@' (FOR\n           EDITING ASM360 SOURCE CODE, FOR INSTANCE).\n\n      TO COMPILE EDITXPL FROM THIS TAPE ONTO A 2314 DISK USE THE\nFOLLOWING JCL:__\n\n//    (JOB CARD)\n//XPL    EXEC XPLC\n//FILE1    DD DSN=USER.EDITXPL,UNIT=2314,VOL=SER=USER03,SPACE=(TRK,2), X\n//            DISP=(NEW,CATLG)\n//SYSIN    DD DSN=EDITXPL.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(19,SL), X\n//            DISP=OLD\n//\n\n      TO EXECUTE EDITXPL AND PRODUCE AN UPDATED SOURCE FILE, USE\nJCL SIMILAR TO:\n\n//    (JOB CARD)\n//EDIT   EXEC XPLC,REGION=120K\n//INPUT2   DD DSN=INFILE,DISP=SHR\n//PROGRAM  DD DSN=USER.EDITXPL,DISP=SHR\n//SYSPUNCH DD DSN=&&CARDS,UNIT=SYSDA,SPACE=(CYL,(3,1)),DISP=(MOD,PASS)\n//OUTPUT3  DD SYSOUT=A,DCB=(RECFM=FB,LRECL=132,BLKSIZE=1320)\n//SYSIN    DD *\n           :\n    (EDITOR CONTROL FILE)\n           :\n//\n\n\n\n                           *****  FILE 20  *****\n                        *****  PASS1.UPDATE4  *****\n\n                           *****  FILE 21  *****\n                        *****  PASS2.UPDATE4  *****\n\n                           *****  FILE 22  *****\n                        *****  PASS3.UPDATE4  *****\n\n                           *****  FILE 23  *****\n                         *****  PMD.UPDATE4  *****\n                           *****  FILE 24  *****\n                       *****  OMONITOR.UPDATE4  *****\n\n                           *****  FILE 25  *****\n                       *****  RMONITOR.UPDATE4  *****\n\n      THESE SIX FILES CONTAIN THE UPDATE 4 PATCHES FOR THE PASS1,\nPASS2, PASS3, PMD, OMONITOR AND RMONITOR MODULES (FILES 5, 7, 9,\n11, 2 AND 3).  THE UPDATES ARE IN EDITXPL FORMAT.  YOU ARE URGED\nTO PUNCH OUT A COPY OF THESE UPDATE FILES ON CARDS, AS FUTURE\nUPDATE PATCHES MAY HAVE TO BE MERGED WITH THE UPDATE 4 PATCHES.\n\n      FOR EXAMPLE, PASS1 UPDATE 3 PATCHES CAN BE PUNCHED OUT BY\nJCL SUCH AS:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS1.UPDATE4,UNIT=TAPE9,VOL=SER=PASCAL,             X\n//            LABEL=(20,SL),DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n\n\n              THE EBCDIC REPRESENTATION OF STANDARD PASCAL SYMBOLS\n              *** ****** ************** ** ******** ****** *******\n\n      UP ARROW:              @\n      LEFT SQUARE BRACKET:   (.\n      RIGHT SQUARE BRACKET:  .)\n      LEFT CURLY BRACKET:    (*\n      RIGHT CURLY BRACKET:   *)\n      IN ADDITION, \u00bc= CAN BE USED FOR <>;  & FOR AND; | FOR OR;\n         AND \u00bc FOR NOT.\n\n\n  MAJOR DIFFERENCES BETWEEN STONY BROOK PASCAL AND STANDARD PASCAL\n  ***** *********** ******* ***** ***** ****** *** ******** ******\n\n      IDENTIFIERS CAN CONTAIN INTERNALLY THE UNDERSCORE CHARACTER('_').\n\n      THE WORD \"FORWARD\" IS RESERVED.\n\n      NONSTANDARD FILES (I.E., ALL FILES OTHER THAN INPUT AND\nOUTPUT) ARE NOT YET IMPLEMENTED.\n\n      A NEW PREDECLARED FUNCTION, 'CLOCK':\n           FUNCTION CLOCK:INTEGER;\nWHICH HAS NO PARAMETERS, AND RETURNS ELAPSED CPU TIME IN UNITS OF\n0.01 SECONDS.\n\n      OF ALL THE PREDECLARED PROCEDURES AND FUNCTIONS, ONLY THE\nARITHMETIC FUNC- TIONS SIN, COS, EXP, LN, SQRT AND ARCTAN MAY BE\nPASSED AS FORMAL PARAMETERS.  A NONSTANDARD SYNTAX IS USED WHICH\nREQUIRES PROGRAMMERS TO FULLY SPECIFY THE TYPES OF FORMAL\nPROCEDURE AND FUNCTION PARAMETERS.\n\n      THE ARGUMENTS TO THE STANDARD PROCEDURE \"WRITE\" MUST FOLLOW\nTHE ORDINARY SYNTAX FOR PARAMETER LISTS, OR A SYNTAX ERROR WILL\nRESULT.  PREDECLARED VARIABLES INTFIELDSIZE, REALFIELDSIZE AND\nBOOLFIELDSIZE SPECIFY THE \"MINIMUN FIELD WIDTH\" WHEN AN INTEGER,\nREAL OR BOOLEAN VALUE RESPECTIVELY IS WRITTEN.  THESE VARIABLES\nARE INITIALIZED TO:\n\n      INTFIELDSIZE : 12\n      REALFIELDSIZE: 14\n      BOOLFIELDSIZE:  6\n\n      AS IN PASCAL 6000-3.4, THE END OF EACH LINE OF OUTPUT MUST\nBE EXPLICITLY INDICATED BY A CALL TO WRITELN.  CARE MUST BE TAKEN\nTO INSURE THAT A LINE DOES NOT GROW LONGER THAN 132 CHARACTERS,\nOR ELSE THE TAIL END OF THE LINE WILL NOT BE PRINTED.\n\n\n                      COMPILER CONTROL TOGGLES\n                      ******** ******* *******\n\n      A $ WITHIN A COMMENT SPECIFIES THAT THE NEXT CHARACTER IS A\nCONTROL CHARACTER.  CORRESPONDING TO EVERY EBCDIC CHARACTER IS A\nCONTROL TOGGLE.  WHEN $ <CHARACTER> IS ENCOUNTERED IN A COMMENT,\nTHE VALUE OF THE CORRESPONDING TOGGLE IS COMPLEMENTED.  NOT ALL\nCONTROL TOGGLES ARE USED.  IN THE CURRENT VERSION, THE USEFUL\nTOGGLES ARE:\n\n      $B - TRACE THE EXECUTION OF THE LL1 PARSER (CAUTION - THIS\n           PRODUCES VOLUM- INOUS OUTPUT.)\n      $D - PRINT COMPILATION STATISTICS.\n      $E - PRINT CODE (ASSEMBLY FORMAT) EMITTED IN PASS 3.\n      $L - PRODUCE A FORMATTED LISTING OF THE PASCAL PROGRAM\n           (INITIALLY ON).\n      $M - PRODUCE AN UNFORMATTED LISTING OF THE SOURCE PROGRAM.\n      $P - DUMP THE PARSE TREES PRODUCED BY PASS 1.\n      $S - DUMP THE SYMBOL TABLE AND THE POST-MORTEM TABLES.\n      $T - PRINT THE TRIPLES EMITTED DURING PASS 2.\n      $Z - TRACE THE OPENING OF IDENTIFIER SCOPES DURING PASS 1,\n           AND DUMP THE SYMBOL TABLE AT THE END OF PASS 1.\n      $| - SET MARGIN.  THE PORTION OF SUCCEEDING CARDS STARTING\n           FROM THE COLUMN CONTAINING THE | WILL BE IGNORED.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE387": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00X\\x00\\x99\\x08?\\x01\\x02(O\\x17\\x06\\x00\\x04\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2002-10-11T17:06:58", "lines": 4, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 387 is the Stony Brook Pascal Compiler distribution,      *   FILE 387\n//*           which was written largely by William Barabash, and    *   FILE 387\n//*           which was resurrected by Mark S. Waterbury.           *   FILE 387\n//*                                                                 *   FILE 387\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILE01": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x02\\xc8\\x02\\xc8\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 712, "newlines": 712, "modlines": 0, "user": "SPASCAL"}, "text": "TITLE -- DESCRIPTION OF THE TAPE FOR THE STONY BROOK PASCAL 360 SYSTEM\nAUTHOR -- WILLIAM BARABASH\nDATE -- 22 MAY 1977 (UPDATE 4)\nADDRESS -- DEPARTMENT OF COMPUTER SCIENCE\n           S.U.N.Y. AT STONY BROOK\n           STONY BROOK, NEW YORK 11794\nTELEPHONE NUMBER -- (516) 246-7146\n\n\n      THIS TAPE CONSISTS OF 25 FILES WRITTEN ON A NINE TRACK MAGNETIC TAPE.\nYOU ARE NOW READING THE CONTENTS OF FILE 1, WHICH CONTAINS INSTRUCTIONS ON HOW\nTO RETRIEVE THE CONTENTS OF FILES 2 THROUGH 25 (AND ALSO ON HOW TO RE-RETRIEVE\nFILE 1 ITSELF).\n\n      HEREWITH ARE DESCRIPTIONS OF THE CONTENTS OF THE 25 FILES ON THIS TAPE\nAND COMMENTS AS TO HOW THEY MAY BE USED.\n\n\n                           *****  FILE 1  *****\n                          *****  COMMENTS  *****\n\n      THIS FILE CONTAINS A SEQUENCE OF CARD IMAGES WHICH, WHEN PRINTED, WILL\nPROVIDE A DESCRIPTION OF THIS TAPE AND INSTRUCTIONS FOR ITS USE.  THE ATTRIBUTES\nOF THIS FILE (AND ALL SOURCE CODE FILES APPEARING ON IT) ARE:__\n               DCB=(RECFM=FBS,LRECL=80,BLKSIZE=7200) .\n\n      THE CONTENTS OF FILE 1 MAY BE RE-RETRIEVED BY A JOB SIMILAR TO THE\nFOLLOWING:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBPTPCH\n//SYSPRINT DD SYSOUT=A\n//SYSUT1   DD DSN=COMMENTS,DISP=OLD,UNIT=TAPE9,VOL=SER=PASCAL\n//SYSUT2   DD SYSOUT=A\n//SYSIN    DD *\n         PRINT TYPORG=PS,MAXFLDS=1\n         TITLE ITEM=('DESCRIPTION OF PASCAL TAPE',50)\n        RECORD FIELD=(80,,,20)\n//\n\n\n                           *****  FILE 2  *****\n                        *****  OMONITOR.ASM  *****\n\n      THIS FILE CONTAINS THE PASCAL OVERLAY MONITOR, A MUTATION OF XPLSM WHICH\nSUPPORTS THE MULTIPASS ARCHITECTURE OF THE STONY BROOK PASCAL 360 COMPILER.  THE\nMAJOR DIFFERENCES BETWEEN THIS PROGRAM AND XPLSM ARE THE NUMBER OF INPUT FILES\n(UP TO 6), THE NUMBER OF OUTPUT FILES (UP TO 7) AND THE DDNAMES THE FILES ARE\nMAPPED ONTO.  SPECIFICALLY,\n\n            //PROGRAM  DD  ...\n\nIS REPLACED BY\n\n            //PASS1  DD  ...\n            //PASS2  DD  ...\n            //PASS3  DD  ...\n                  AND\n            //PMD    DD  ...\n\nSTATEMENTS.  THE SEQUENTIALLY-ACCESSED FILE DD'S\n\n            //INPUT2  DD  ...\nAND         //OUTPUT3  DD  ...\n\nARE REPLACED BY\n\n            //SYSUT1  DD  ... .\n\n      LIKEWISE, WE REPLACE  //INPUT3  AND  //OUTPUT4  BY  //SYSUT2,\n//INPUT4  AND  //OUTPUT5  BY  //SYSUT3 , AND //INPUT5 AND //OUTPUT6 BY\n//SYSUT4.\n\n      INPUT(0) AND INPUT(1) REFER TO  //SYSIN  , OUTPUT(0) AND OUTPUT(1) REFER\nTO  //SYSPRINT  AND OUTPUT(2) REFERS TO  //SYSPUNCH  AS UNDER XPLSM.\n\n      THE SYSUT FILES ARE USED AS FOLLOWS:  DURING PASS 1, FILE SYSUT1 IS\nGENERATED (VIA ASSIGNMENTS TO THE PSEUDOVARIABLE OUTPUT(3)) FOR TRANSMITTING THE\nPARSE TREES TO PASS 2.  SYSUT2 IS GENERATED (VIA ASSIGNMENTS TO THE PSEUDO-\nVARIABLE OUTPUT(4)) FOR TRANSMITTING SYMBOL TABLE INFORMATION TO PASS 2.  SYSUT3\nIS GENERATED (VIA ASSIGNMENTS TO THE PSEUDOVARIABLE OUTPUT(5)) FOR TRANSMITTING\nCONTROL INFORMATION TO PASS 2.  PASS 2 WILL READ THE CONTENTS OF FILES SYSUT1,\nSYSUT2, AND SYSUT3 WITH CALLS TO INPUT(2), INPUT(3) AND INPUT(4) RESPECTIVELY.\nIT MAY THEN REGENERATE THE FILES FOR TRANSMITTING INFORMATION TO PASS 3.\n\n      NOTE THAT NO SYSUT FILE IS EVER OPEN BOTH FOR INPUT AND OUTPUT AT THE SAME\nTIME.  WHEN THE PASCAL OVERLAY MONITOR DETECTS THAT A SYSUT FILE WHICH IS OPEN\nFOR X IS TO BE USED FOR Y, WHERE X \u00ac= Y AND X, Y IN (. INPUT, OUTPUT .), IT WILL\nREWIND THE FILE, CLOSING IT FOR X, AND WILL THEN OPEN IT FOR Y.  BETWEEN PASSES,\nALL FILES (EXCEPT SYSIN, SYSPRINT AND SYSPUNCH) ARE CLOSED.\n\n      UNLIKE XPLSM, WHEN THE PASCAL OVERLAY MONITOR DETECTS AN ENDFILE SITUATION\nON ANY INPUT FILE (EXCEPT SYSIN), IT WILL NOT MARK THE FILE PERMANENTLY\nUNUSABLE;  IT WILL REWIND THE FILE.  IT IS THEREFORE VITALLY IMPORTANT THAT ONE\nALWAYS TEST FOR THE ENDFILE CONDITION ON ALL INPUT CALLS.\n\n      THE TRACE ROUTINE IS NOT AVAILABLE TO PROGRAMS RUNNING UNDER THE PASCAL\nOVERLAY MONITOR.  CALL TRACE AND CALL UNTRACE WOULD BE NO-OPS WITHIN THE PASCAL\nCOMPILER.\n\n      FILE 2 CAN BE RETRIEVED BY THE FOLLOWING PROGRAM:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=OMONITOR.ASM,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(2,SL), X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 3  *****\n                        *****  RMONITOR.ASM  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR THE PASCAL RUN MONITOR, AN ASM360\nPROGRAM WHICH LOADS PASCAL PROGRAMS AND PROVIDES THE RUN-TIME ENVIRONMENT NEEDED\nFOR THEIR EXECUTION.\n\n      FILE 3 CAN BE RETRIEVED BY THE FOLLOWING PROGRAM:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=RMONITOR.ASM,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(3,SL), X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 4  *****\n                         *****  USER.PASCAL  *****\n\n      THIS FILE CONTAINS THE UNLOADED PARTITIONED DATA SET USER.PASCAL,\nWHICH CONTAINS AS ITS ONLY TWO MEMBERS THE LOAD MODULES PASCAL (THE PASCAL\nOVERLAY MONITOR) AND RMONITOR (THE PASCAL RUN MONITOR).  THE OVERLAY MONITOR\nTRANSFERS CONTROL TO RMONITOR WITH A 'LINK' MACRO SPECIFYING NO DCB.  THEREFORE,\nRMONITOR MUST EITHER RESIDE IN THE STEPLIB DATASET, THE JOBLIB DATASET OR THE\nSYSTEM LINKAGE LIBRARY (SYS1.LINKLIB).\n\n      THE OBJECT VERSION OF OMONITOR CORRESPONDS TO THE SOURCE CODE (FILE 2)\nAS MODIFIED BY THE OMONITOR UPDATE PATCHES (FILE 24).  THE OBJECT VERSION OF\nRMONITOR CORRESPONDS TO THE SOURCE CODE (FILE 3) AS MODIFIED BY THE RMONITOR\nUPDATE PATCHES (FILE 25).\n\n      THE ORIGINAL OF USER.PASCAL HAS BLKSIZE=7294 (FOR 2314 DISKS).\n\n      THE CONTENTS OF THIS FILE MAY BE PLACED INTO A DIRECT ACCESS DATA SET IN A\nFORM READY FOR USE BY A JOB OF THE FOLLOWING TYPE:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEHMOVE\n//SYSPRINT DD SYSOUT=A\n//SYSUT1   DD UNIT=SYSDA,VOL=SER=USB001,DISP=OLD\n//TARGET   DD UNIT=2314,VOL=SER=USER03,DISP=(NEW,CATLG),               X\n//            SPACE=(TRK,(8,,10)),DCB=(DSORG=PO,RECFM=U,BLKSIZE=7294)\n//SOURCE   DD UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(4,SL),DISP=OLD\n//SYSIN    DD *\n         COPY  PDS=USER.PASCAL,FROM=2400=(PASCAL,4),TO=2314=USER03\n//\n\n\n                           *****  FILE 5  *****\n                          *****  PASS1.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR PASS 1 OF THE STONY BROOK PASCAL\n360 COMPILER.  PASS 1 IS RESPONSIBLE FOR LEXICAL AND SYNTACTIC ANALYSIS OF\nPASCAL PROGRAMS AND PRODUCES PARSE TREES AS OUTPUT.  THE CURRENT VERSION\nINCLUDES THE HENNESSY - GOLDSTEIN - CHINSAW DGNS MODULE (AS MODIFIED BY MYSELF)\nWHICH PREPARES A PARAGRAPHED LISTING FOR USE IN AN EXECUTION FLOW SUMMARY,\nTHE KIEBURTZ BLOCK-STRUCTURED HASHING LOOKUP FOR IDENTIFIERS, AND ERROR RECOVERY\nROUTINES BY AJIT PAI.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING PROGRAM:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS1.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(5,SL),    X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 6  *****\n                          *****  PASS1.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PASS1 (FILE 5) AS MODIFIED BY THE\nPASS1 UPDATE 4 PATCHES (FILE 20), READY FOR LOADING BY THE PASCAL OVERLAY\nMONITOR.  PASS1 CAN BE PUT UP BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS1.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(6,SL),    X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PASS1,DISP=(NEW,CATLG),UNIT=2314,        X\n//            SPACE=(TRK,14),VOL=SER=USER03,                           X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n\n                           *****  FILE 7  *****\n                          *****  PASS2.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR PASS 2 OF THE STONY BROOK PASCAL\n360 COMPILER.  PASS 2 IS RESPONSIBLE FOR TYPE CHECKING, AND GENERATING SYMBOLIC\nTRIPLES SUITABLE FOR INTERPRETATION OR FURTHER PROCESSING BY A CODE GENERATOR.\nTHE CURRENT VERSION INCLUDES ROUTINES BY PROFESSOR KIEBURTZ FOR SYMBOL TABLE\nCONSTRUCTION AND STORAGE ALLOCATION.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS2.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(7,SL),    X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 8  *****\n                          *****  PASS2.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PASS 2 (FILE 7) AS MODIFIED BY THE\nPASS 2 UPDATE 4 PATCHES (FILE 21), READY FOR LOADING BY THE PASCAL OVERLAY\nMONITOR.  PASS2 CAN BE PUT UP BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS2.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(8,SL),    X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PASS2,DISP=(NEW,CATLG),UNIT=2314,        X\n//            SPACE=(TRK,20),VOL=SER=USER03,                           X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n\n                           *****  FILE 9  *****\n                          *****  PASS3.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR PASS 3 OF THE STONY BROOK PASCAL\nCOMPILER.  WRITTEN BY CHARLES R. HILL, IT TAKES AS INPUT THE SYMBOLIC TRIPLES\nGENERATED BY PASS 2 AND GENERATES MACHINE CODE FOR THE IBM 360/370 SERIES\nCOMPUTERS.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS3.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(9,SL),    X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 10  *****\n                          *****  PASS3.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PASS 3 (FILE 9) AS MODIFIED BY THE\nPASS 3 UPDATE 4 PATCHES (FILE 22), READY FOR LOADING BY THE PASCAL OVERLAY\nMONITOR.  PASS 3 CAN BE PUT UP BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS3.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(10,SL),   X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PASS3,DISP=(NEW,CATLG),UNIT=2314,        X\n//            SPACE=(TRK,16),VOL=SER=USER03,                           X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n                           *****  FILE 11  *****\n                           *****  PMD.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE CODE FOR THE POST-MORTEM ANALYSIS ROUTINES\n(PMD).  IF A PASCAL PROGRAM TERMINATES WITH A PASCAL RUN ERROR AND DEBUG LEVEL >\n0, THE POST MORTEM DUMP ROUTINE PRINTS THE VALUES OF ALL LOCAL SCALAR, SUBRANGE,\nPOINTER AND STRING VARIABLES FOR THE FIVE MOST RECENT ACTIVATIONS OF ALL ACTIVE\nPROCEDURES.  (THE VALUE OF A POINTER IS PRINTED OUT AS EITHER 'NIL', 'DEFINED',\nOR 'UNDEFINED').  IF DEBUG LEVEL = 2 IS SPECIFIED (STRONGLY RECOMMENDED AS THE\nDEFAULT), AN EXECUTION FLOW SUMMARY WHICH INDICATES THE NUMBER OF TIMES EACH\nSTATEMENT WAS EXECUTED IS PRINTED.\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PMD.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(11,SL),     X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 12  *****\n                           *****  PMD.OBJ  *****\n\n      THIS FILE CONTAINS THE COMPILED CODE OF PMD (FILE 11) AS MODIFIED BY THE\nPMD UPDATE PATCHES (FILE 23), READY FOR LOADING BY THE PASCAL OVERLAY MONITOR.\nPMD CAN BE PUT UP BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PMD.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(12,SL),     X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.PASCAL.PMD,DISP=(NEW,CATLG),UNIT=2314,          X\n//            SPACE=(TRK,5),VOL=SER=USER03,                            X\n//            DCB=(RECFM=F,LRECL=7200,BLKSIZE=7200)\n//\n\n\n      HAVING PROCESSED FILES 4, 6, 8, 10 AND 12 ABOVE, YOU ARE NOW READY TO RUN\nYOUR PASCAL PROGRAMS.  THE FOLLOWING JCL PROCEDURE IS RECOMENDED:__\n\n//PASCAL PROC SECONDS=10,LINES=1000,DBGLVL=2\n//PASCAL EXEC PGM=PASCAL,REGION=148K,                                  X\n//            PARM='TIME=&SECONDS,LINES=&LINES,DEBUG=&DBGLVL'\n//STEPLIB  DD DSNAME=USER.PASCAL,DISP=SHR\n//PASS1    DD DSNAME=USER.PASCAL.PASS1,DISP=SHR\n//PASS2    DD DSNAME=USER.PASCAL.PASS2,DISP=SHR\n//PASS3    DD DSNAME=USER.PASCAL.PASS3,DISP=SHR\n//PMD      DD DSNAME=USER.PASCAL.PMD,DISP=SHR\n//FILE3    DD UNIT=SYSDA,SPACE=(CYL,3)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT2   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT3   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT4   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSUT5   DD UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=A\n//       PEND\n\n      ONCE THE ABOVE JCL PROCEDURE IS CATALOGED, A PASCAL PROGRAM CAN BE RUN\nUSING THE FOLLOWING DECK SETUP:\n\n//    (JOB CARD)\n//DOIT   EXEC PASCAL\n//SYSIN    DD *\n           :\n   PASCAL SOURCE CODE\n           :\n%EOF\n           :\n   INPUT TO THE PASCAL PROGRAM\n           :\n//\n\n\n      NOTE THAT THE CARD IMAGE WHICH SEPARATES THE PASCAL PROGRAM FROM THE INPUT\nDATA MUST CONTAIN THE CHARACTERS '%EOF' STARTING IN COLUMN ONE.  THIS IS MANDAT-\nORY, AND CAUSES THE OVERLAY MONITOR TO RETURN AN END OF FILE TO THE PASS ONE\nSCANNER.\n\n      THE PASCAL COMPILER SHOULD RUN COMFORTABLY IN A 148K PARTITION UNDER\nOS/MVT OR A 152K PARTITION UNDER OS/MFT.\n\n      TO HELP YOU GET STARTED, A SAMPLE RUN STREAM (MINUS THE JOB CARD) IS\nINCLUDED.\n\n\n                           *****  FILE 13  *****\n                      *****  BNCHMARK.PROGRAMS  *****\n\n      THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=BNCHMARK.PROGRAMS,UNIT=TAPE9,VOL=SER=PASCAL,         X\n//            LABEL=(13,SL),DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n      IN ORDER TO HELP YOU MAINTAIN A LOCAL COPY OF THE STONY BROOK PASCAL\nCOMPILER, THE FOLLOWING PROGRAMS ARE INCLUDED ON THE TAPE:__\n\n\n                           *****  FILE 14  *****\n                          *****  XPLSM.ASM  *****\n\n      THIS FILE CONTAINS AN ASSEMBLY LANGUAGE VERSION OF THE XPL SUBMONITOR,\nXPLSM.  EXTERNAL REFERENCES TO THE TRACE ROUTINE HAVE BEEN ELIMINATED.  THIS\nFILE IS READY FOR ASSEMBLING AND LINKEDITING INTO A LOAD MODULE LIBRARY, IN CASE\nXPL IS NOT CURRENTLY AVAILABLE AT YOUR INSTALLATION.\n\n      THE FOLLOWING JCL WILL SUFFICE:__\n\n//    (JOB CARD)\n//DOIT   EXEC ASMFCL,PARM.ASM='LOAD,NODECK'\n//ASM.SYSIN DD UNIT=TAPE9,VOL=SER=PASCAL,DSN=XPLSM.ASM,LABEL=(14,SL),  X\n//            DISP=OLD\n//LKED.SYSLMOD DD DSN=USER.PASCAL(XPLSM),DISP=OLD\n//\n\n\n                           *****  FILE 15  *****\n                          *****  XCOM4.OBJ  *****\n\n      XCOM4 IS THE VERSION OF THE XPL COMPILER THAT HAS BEEN USED TO COMPILE THE\nPASCAL COMPILER.  IT DOES NOT SUPPORT ANY NON-STANDARD XPL FEATURE, BUT IT DOES\nCORRECT SOME WELL-KNOWN BUGS, AND WE DO NOT GUARANTEE THAT THE PASCAL COMPILER\nSOURCE WILL COMPILE CORRECTLY UNDER XCOM3.  XCOM4 IS ALSO FASTER IN EXECUTION\nTHAN XCOM3.  THEREFORE, EVEN IF XPL IS ALREADY AVAILABLE AT YOUR INSTALLATION,\nWE STRONGLY URGE YOU TO PUT UP XCOM4.  TO PUT IT UP ON A 2314 DISK, WE\nSUGGEST THE FOLLOWING JCL:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=XCOM4.OBJ,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(15,SL),   X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.XCOM4,UNIT=2314,VOL=SER=USER03,SPACE=(TRK,18),  X\n//            DISP=(NEW,CATLG)\n//\n\n\n\n      IF XPL IS NOT CURRENTLY AVAILABLE AT YOUR INSTALLATION, WE SUGGEST YOU\nCATALOG THE FOLLOWING PROCEDURE:__\n\n//XPLC   PROC\n//XPL    EXEC PGM=XPLSM,REGION=180K,PARM='ALTER'\n//STEPLIB  DD DSNAME=USER.PASCAL,DISP=SHR\n//FILE1    DD UNIT=SYSDA,SPACE=(CYL,3),                                X\n//            DSNAME=&&XPL,DISP=(NEW,PASS)\n//FILE2    DD UNIT=SYSDA,SPACE=(CYL,3)\n//FILE3    DD UNIT=SYSDA,SPACE=(CYL,3)\n//INPUT2   DD DSN=USER.XPLIB,DISP=SHR\n//PROGRAM  DD DSN=USER.XCOM4,DISP=SHR\n//SYSPRINT DD SYSOUT=A\n//SYSPUNCH DD SYSOUT=B\n//       PEND\n\n\n                           *****  FILE 16  *****\n                          *****  XCOM4.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE VERSION OF XCOM4.  TO PRODUCE XPL OBJECT\nMODULES FOR DISKS WHOSE TRACK SIZE IS SOMEWHAT DIFFERENT THAN THAT OF 2314 DISKS\n(1) REASSEMBLE XPLSM (FILE 14) CHANGING FILBYTS, AND (2) RECOMPILE XCOM4\nCHANGING DISKBYTES TO A NEW VALUE WHICH (OPTIMALLY) IS THE LARGEST MULTIPLE OF\n80 THAT IS LESS THAN OR EQUAL TO THE TRACK CAPACITY OF YOUR DISKS.  (CAUTION TO\n3330 USERS: YOU MAY HAVE TO SPECIFY A LARGER REGION SIZE IN YOUR XPLC PROC IF\nYOU DO THIS.)\n\n    THIS FILE CAN BE RETRIEVED BY THE FOLLOWING JOB:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=XCOM4.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(16,SL),   X\n//            DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n                           *****  FILE 17  *****\n                          *****  XPLIB.XPL  *****\n\n      THIS FILE CONTAINS THE SOURCE VERSION OF COMPACTIFY, THE XPL PROCEDURE\nWHICH IS CONCATENATED ON TO THE FRONT OF EVERY XPL PROGRAM AUTOMATICALLY.  IF\nYOUR INSTALLATION DOES NOT CURRENTLY HAVE XPL, COMPACTIFY CAN BE PUT UP BY A JOB\nSUCH AS:__\n\n//    (JOB CARD)\n//DOIT EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=XPLIB.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(17,SL),   X\n//            DISP=OLD\n//SYSUT2   DD DSN=USER.XPLIB,DISP=(NEW,CATLG),UNIT=2314,               X\n//            SPACE=(TRK,(2,1)),VOL=SER=USER03,                        X\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=7200)\n//\n\n                           *****  FILE 18  *****\n                         *****  XPLXREF.XPL  *****\n\n      THIS FILE CONTAINS THE XPL SOURCE CODE OF A CROSS-REFERENCE LISTING\nPROGRAM FOR XPL SOURCE.  IT LISTS GLOBAL IDENTIFIERS, AND THE LINE NUMBERS OF\nALL REFERENCES TO THOSE IDENTIFIERS, BUT DOES NOT RECOGNIZE REDECLARATIONS OF\nIDENTIFIERS.  ITS TOGGLES ARE:\n\n      $K - PRODUCE A LINE-NUMBERED LISTING OF XPL SOURCE CODE PRECEDING THE\n           CROSS-REFERENCE TABLE - INITIALLY OFF.\n      $P - PRODUCE CROSS REFERENCE LISTINGS OF LOCAL VARIABLES OF PROCEDURES\n           INITIALLY OFF.\n\n      XPLXREF RUNS IN A 180K PARTITION.\n\n      TO COMPILE XPLXREF FROM THIS TAPE ONTO A 2314 DISK USING THE JCL PROCEDURE\nXPLC, USE JCL SIMILAR TO THE FOLLOWING:__\n\n//    (JOB CARD)\n//XPL    EXEC XPLC\n//FILE1    DD DSN=USER.XPLXREF,UNIT=2314,VOL=SER=USER03,SPACE=(TRK,15),X\n//            DISP=(NEW,CATLG)\n//SYSIN    DD DSN=XPLXREF.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(18,SL), X\n//            DISP=OLD\n//\n\n\n      TO EXECUTE XPLXREF, USE JCL SIMILAR TO THE FOLLOWING:__\n\n//    (JOB CARD)\n//XREF   EXEC XPLC\n//PROGRAM  DD DSN=USER.XPLXREF,DISP=SHR\n//SYSIN    DD *\n           :\n    (XPL SOURCE TO BE CROSS-REFERENCED)\n           :\n//\n\n\n                           *****  FILE 19  *****\n                         *****  EDITXPL.XPL  *****\n\n      THIS FILE CONTAINS THE XPL SOURCE CODE OF A CARD-IMAGE EDITOR.  IT ACCEPTS\nTHE FILE OF CARD IMAGES TO BE EDITED ON FILE INPUT(2), AND THE EDIT COMMANDS AND\nCARDIMAGES TO BE INSERTED ON THE FILE SYSIN.  OUTPUT IS TO FILE SYSPUNCH.  IF A\nLINE-NUMBERED LISTING OF THE OUTPUT FILE IS DESIRED, IT WILL BE PRODUCED ON\nFILE OUTPUT(3).  THIS PROGRAM WILL BE USED TO EDIT UPDATE PATCHES INTO THE\nPASCAL COMPILER SOURCE FILES.\n\n      IN THE SYSIN FILE, AN EDIT COMMAND IS RECOGNIZED BY A CONTROL CHARACTER IN\nTHE FIRST COLUMN.  THE CONTROL CHARACTER IS INITIALLY ASTERISK ('*'), BUT THAT\nCAN BE DYNAMICALLY CHANGED (SEE BELOW).  AN EDIT COMMAND MAY CONTAIN, IN FREE\nFORMAT ON THE REST OF THE CARD:\n\n      A SEQUENCE OF NUMBERS OR SUBRANGES OF NUMBERS, AS 2 5 9..12 THAT ARE\n           INTERPRETED AS LINE NUMBERS IN THE SOURCE FILE AND WHICH PROVIDE\n           POINTS FOR INVOCATION OF EDIT COMMANDS;\n\n      $I - THE INSERT COMMAND.  AT THE POINT IN THE SOURCE FILE FOLLOWING THE\n           LAST PRECEDING LINE NUMBER GIVEN ON AN EDIT COMMAND CARD, THE\n           SEQUENCE OF CARDS FOLLOWING THE COMMAND CARD WILL BE INSERTED INTO\n           THE SOURCE FILE.  THIS WILL TERMINATE WHEN THE NEXT EDIT COMMAND\n           CARD IS ENCOUNTERED (OR UPON END-OF-FILE);\n\n      $L - LISTING TOGGLE, INITIALLY OFF.  WHEN ON, THE SOURCE FILE, AS MODIFIED\n           BY EDITING, IS LISTED ON THE OUTPUT3 FILE.\n\n      $P - OUTPUT TOGGLE INITIALLY ON.  WHEN ON, THE MODIFIED SOURCE FILE IS\n           OUTPUT TO THE SYSPUNCH FILE.\n\n      $D - DELETION TOGGLE, INITIALLY OFF.  WHEN ON, EACH RECORD OF THE SOURCE\n           FILE THAT IS MENTIONED BY NUMBER OR INCLUDED IN A SUBRANGE ON A\n           COMMAND CARD IS DELETED FROM THE MODIFIED SOURCE FILE.  TO REPLACE,\n           YOU WOULD USE DELETE AND INSERT.\n\n      $<OLD CONTROL CHAR><NEW CONTROL CHAR> - DYNAMICALLY CHANGES THE CONTROL\n           CHARACTER.  NOTE THAT <OLD CONTROL CHAR> MUST APPEAR IN COLUMN 1.\n           FOR EXAMPLE\n\n*   $*@\n\n           CHANGES THE CONTROL CHARACTER FROM '*' TO '@' (FOR EDITING ASM360\n           SOURCE CODE, FOR INSTANCE).\n\n      TO COMPILE EDITXPL FROM THIS TAPE ONTO A 2314 DISK USE THE FOLLOWING\nJCL:__\n\n//    (JOB CARD)\n//XPL    EXEC XPLC\n//FILE1    DD DSN=USER.EDITXPL,UNIT=2314,VOL=SER=USER03,SPACE=(TRK,2), X\n//            DISP=(NEW,CATLG)\n//SYSIN    DD DSN=EDITXPL.XPL,UNIT=TAPE9,VOL=SER=PASCAL,LABEL=(19,SL), X\n//            DISP=OLD\n//\n\n      TO EXECUTE EDITXPL AND PRODUCE AN UPDATED SOURCE FILE, USE JCL SIMILAR TO:\n\n//    (JOB CARD)\n//EDIT   EXEC XPLC,REGION=120K\n//INPUT2   DD DSN=INFILE,DISP=SHR\n//PROGRAM  DD DSN=USER.EDITXPL,DISP=SHR\n//SYSPUNCH DD DSN=&&CARDS,UNIT=SYSDA,SPACE=(CYL,(3,1)),DISP=(MOD,PASS)\n//OUTPUT3  DD SYSOUT=A,DCB=(RECFM=FB,LRECL=132,BLKSIZE=1320)\n//SYSIN    DD *\n           :\n    (EDITOR CONTROL FILE)\n           :\n//\n\n\n\n                           *****  FILE 20  *****\n                        *****  PASS1.UPDATE4  *****\n\n                           *****  FILE 21  *****\n                        *****  PASS2.UPDATE4  *****\n\n                           *****  FILE 22  *****\n                        *****  PASS3.UPDATE4  *****\n\n                           *****  FILE 23  *****\n                         *****  PMD.UPDATE4  *****\n                           *****  FILE 24  *****\n                       *****  OMONITOR.UPDATE4  *****\n\n                           *****  FILE 25  *****\n                       *****  RMONITOR.UPDATE4  *****\n\n      THESE SIX FILES CONTAIN THE UPDATE 4 PATCHES FOR THE PASS1, PASS2, PASS3,\nPMD, OMONITOR AND RMONITOR MODULES (FILES 5, 7, 9, 11, 2 AND 3).  THE UPDATES\nARE IN EDITXPL FORMAT.  YOU ARE URGED TO PUNCH OUT A COPY OF THESE UPDATE FILES\nON CARDS, AS FUTURE UPDATE PATCHES MAY HAVE TO BE MERGED WITH THE UPDATE 4\nPATCHES.\n\n      FOR EXAMPLE, PASS1 UPDATE 3 PATCHES CAN BE PUNCHED OUT BY JCL SUCH AS:__\n\n//    (JOB CARD)\n//DOIT   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=PASS1.UPDATE4,UNIT=TAPE9,VOL=SER=PASCAL,             X\n//            LABEL=(20,SL),DISP=OLD\n//SYSUT2   DD SYSOUT=B,DCB=BLKSIZE=80\n//\n\n\n\n\n              THE EBCDIC REPRESENTATION OF STANDARD PASCAL SYMBOLS\n              *** ****** ************** ** ******** ****** *******\n\n      UP ARROW:              @\n      LEFT SQUARE BRACKET:   (.\n      RIGHT SQUARE BRACKET:  .)\n      LEFT CURLY BRACKET:    (*\n      RIGHT CURLY BRACKET:   *)\n      IN ADDITION, \u00ac= CAN BE USED FOR <>;  & FOR AND; | FOR OR; AND \u00ac FOR NOT.\n\n\n        MAJOR DIFFERENCES BETWEEN STONY BROOK PASCAL AND STANDARD PASCAL\n        ***** *********** ******* ***** ***** ****** *** ******** ******\n\n      IDENTIFIERS CAN CONTAIN INTERNALLY THE UNDERSCORE CHARACTER('_').\n\n      THE WORD \"FORWARD\" IS RESERVED.\n\n      NONSTANDARD FILES (I.E., ALL FILES OTHER THAN INPUT AND OUTPUT) ARE NOT\nYET IMPLEMENTED.\n\n      A NEW PREDECLARED FUNCTION, 'CLOCK':\n           FUNCTION CLOCK:INTEGER;\nWHICH HAS NO PARAMETERS, AND RETURNS ELAPSED CPU TIME IN UNITS OF 0.01 SECONDS.\n\n      OF ALL THE PREDECLARED PROCEDURES AND FUNCTIONS, ONLY THE ARITHMETIC FUNC-\nTIONS SIN, COS, EXP, LN, SQRT AND ARCTAN MAY BE PASSED AS FORMAL PARAMETERS.  A\nNONSTANDARD SYNTAX IS USED WHICH REQUIRES PROGRAMMERS TO FULLY SPECIFY THE TYPES\nOF FORMAL PROCEDURE AND FUNCTION PARAMETERS.\n\n      THE ARGUMENTS TO THE STANDARD PROCEDURE \"WRITE\" MUST FOLLOW THE ORDINARY\nSYNTAX FOR PARAMETER LISTS, OR A SYNTAX ERROR WILL RESULT.  PREDECLARED\nVARIABLES INTFIELDSIZE, REALFIELDSIZE AND BOOLFIELDSIZE SPECIFY THE \"MINIMUN\nFIELD WIDTH\" WHEN AN INTEGER, REAL OR BOOLEAN VALUE RESPECTIVELY IS WRITTEN.\nTHESE VARIABLES ARE INITIALIZED TO:\n\n      INTFIELDSIZE : 12\n      REALFIELDSIZE: 14\n      BOOLFIELDSIZE:  6\n\n      AS IN PASCAL 6000-3.4, THE END OF EACH LINE OF OUTPUT MUST BE EXPLICITLY\nINDICATED BY A CALL TO WRITELN.  CARE MUST BE TAKEN TO INSURE THAT A LINE DOES\nNOT GROW LONGER THAN 132 CHARACTERS,  OR ELSE THE TAIL END OF THE LINE WILL NOT\nBE PRINTED.\n\n\n                            COMPILER CONTROL TOGGLES\n                            ******** ******* *******\n\n      A $ WITHIN A COMMENT SPECIFIES THAT THE NEXT CHARACTER IS A CONTROL\nCHARACTER.  CORRESPONDING TO EVERY EBCDIC CHARACTER IS A CONTROL TOGGLE.  WHEN\n$ <CHARACTER> IS ENCOUNTERED IN A COMMENT, THE VALUE OF THE CORRESPONDING TOGGLE\nIS COMPLEMENTED.  NOT ALL CONTROL TOGGLES ARE USED.  IN THE CURRENT VERSION, THE\nUSEFUL TOGGLES ARE:\n\n      $B - TRACE THE EXECUTION OF THE LL1 PARSER (CAUTION - THIS PRODUCES VOLUM-\n           INOUS OUTPUT.)\n      $D - PRINT COMPILATION STATISTICS.\n      $E - PRINT CODE (ASSEMBLY FORMAT) EMITTED IN PASS 3.\n      $L - PRODUCE A FORMATTED LISTING OF THE PASCAL PROGRAM (INITIALLY ON).\n      $M - PRODUCE AN UNFORMATTED LISTING OF THE SOURCE PROGRAM.\n      $P - DUMP THE PARSE TREES PRODUCED BY PASS 1.\n      $S - DUMP THE SYMBOL TABLE AND THE POST-MORTEM TABLES.\n      $T - PRINT THE TRIPLES EMITTED DURING PASS 2.\n      $Z - TRACE THE OPENING OF IDENTIFIER SCOPES DURING PASS 1, AND DUMP THE\n           SYMBOL TABLE AT THE END OF PASS 1.\n      $| - SET MARGIN.  THE PORTION OF SUCCEEDING CARDS STARTING FROM THE COLUMN\n           CONTAINING THE | WILL BE IGNORED.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE02": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x07\\xab\\x07\\xab\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 1963, "newlines": 1963, "modlines": 0, "user": "SPASCAL"}, "text": "PMON     TITLE 'THE PASCAL OVERLAY MONITOR'\n         SPACE 2                                                        XMN00010\n*********************************************************************** XMN00020\n*                                                                     * XMN00030\n*                                                                     * XMN00040\n*                                                                     * XMN00050\n*        T H E   P A S C A L   O V E R L A Y   M O N I T O R          *\n*                                                                     * XMN00070\n*                                                                     * XMN00080\n*                                  WILLIAM BARABASH                   *\n*                                  DEPARTMENT OF COMPUTER SCIENCE     *\n*                                  S.U.N.Y. AT STONY BROOK            *\n*                                  STONY BROOK, NEW YORK 11794        *\n*                                  DECEMBER 1975                      *\n*                                                                     * XMN00120\n*                                                                     * XMN00130\n*********************************************************************** XMN00140\n         EJECT                                                          XMN00150\n         SPACE 1                                                        XMN00160\n*********************************************************************** XMN00170\n*                                                                     * XMN00180\n*                                                                     * XMN00190\n*                                                                     * XMN00200\n*        DEFINE PARAMETRIC CONSTANTS FOR XPLSM                        * XMN00210\n*                                                                     * XMN00220\n*                                                                     * XMN00230\n*********************************************************************** XMN00240\n         SPACE 1                                                        XMN00250\n         GBLA  &INPUTS             NUMBER OF INPUT FILES                XMN00260\n         GBLA  &OUTPUTS            NUMBER OF OUTPUT FILES               XMN00270\n         GBLA  &FILES              NUMBER OF DIRECT ACCESS FILES        XMN00280\n         LCLA  &I,&J               VARIABLES FOR ITERATION LOOPS\n         SPACE 5                                                        XMN00300\nIOPACK   CSECT                                                          XMN00310\n         SPACE 2                                                        XMN00320\n&INPUTS  SETA  6                   INPUT(I), I IN 0..6\n         SPACE 1                                                        XMN00340\n&OUTPUTS SETA 7                    OUTPUT(I), I IN 0..7\n         SPACE 1                                                        XMN00360\n&FILES   SETA  3                   FILE(I,*),  I = 1,2,3                XMN00370\n         SPACE 1                                                        XMN00380\n*********************************************************************** XMN00390\n*                                                                     * XMN00400\n*                                                                     * XMN00410\n*        FILEBYTS DETERMINES THE BLOCKSIZE FOR DIRECT ACCESS FILE     * XMN00420\n*        I/O.  IT SHOULD BE EQUAL TO THE VALUE OF THE LITERAL         * XMN00430\n*        CONSTANT 'DISKBYTES' IN THE XCOM COMPILER FOR COMPILATION    * XMN00440\n*        TO WORK SUCCESSFULLY.  THE VALUE OF FILEBYTS WHICH IS        * XMN00450\n*        ASSEMBLED IN MAY BE OVERIDDEN BY THE 'FILE=NNNN' PARAMETER   * XMN00460\n*        ON THE OS/360 EXEC CARD.                                     * XMN00470\n*                                                                     * XMN00480\n*                                                                     * XMN00490\n*                                                                     * XMN00500\n*        DEVICE       ALLOWABLE RANGE         SUGGESTED VALUE         * XMN00510\n*                                                                     * XMN00520\n*        2311      80 <= FILEBYTS <= 3624        3600                 * XMN00530\n*                                                                     * XMN00540\n*        2314      80 <= FILEBYTS <= 7294        7200                 * XMN00550\n*                                                                     * XMN00560\n*        2321      80 <= FILEBYTS <= 2000        2000                 * XMN00570\n*                                                                     * XMN00580\n*                                                                     * XMN00590\n*        LARGER VALUES MAY BE USED FOR FILEBYTS IF THE SUBMONITOR     * XMN00600\n*        IS REASSEMBLED WITH  RECFM=FT  SPECIFIED IN THE DCBS FOR     * XMN00610\n*        THE DIRECT ACCESS FILES.                                     * XMN00620\n*                                                                     * XMN00630\n*                                                                     * XMN00640\n*********************************************************************** XMN00650\n         SPACE 2                                                        XMN00660\nFILEBYTS EQU   7200                2314  DISKS\n         SPACE 2                                                        XMN00680\n*********************************************************************** XMN00690\n*                                                                     * XMN00700\n*                                                                     * XMN00710\n*        BLKSIZE DEFAULT FOR SOME INPUT AND OUTPUT FILES.  SEE THE    * XMN00720\n*        EXIT LIST HANDLING ROUTINE GENXT.                            * XMN00730\n*                                                                     * XMN00750\n*********************************************************************** XMN00760\n         SPACE 2                                                        XMN00770\nIOFBYTS  EQU   2000\n         SPACE 2                                                        XMN00790\n*********************************************************************** XMN00800\n*                                                                     * XMN00810\n*                                                                     * XMN00820\n*        DEFINE THE REGISTERS USED TO PASS PARAMETERS TO THE          * XMN00830\n*        SUBMONITOR FROM THE XPL PROGRAM                              * XMN00840\n*                                                                     * XMN00850\n*                                                                     * XMN00860\n*********************************************************************** XMN00870\n         SPACE 2                                                        XMN00880\nSVCODE   EQU   1                   CODE INDICATING SERVICE REQUESTED    XMN00890\n         SPACE 1                                                        XMN00900\nPARM1    EQU   0                   FIRST PARAMETER                      XMN00910\n         SPACE 1                                                        XMN00920\nPARM2    EQU   2                   SECOND PARAMETER                     XMN00930\n         SPACE 2                                                        XMN00940\n*********************************************************************** XMN00950\n*                                                                     * XMN00960\n*                                                                     * XMN00970\n*        DEFINE THE SERVICE CODES USED BY THE XPL PROGRAM TO          * XMN00980\n*        INDICATE SERVICE REQUESTS TO THE SUBMONITOR                  * XMN00990\n*                                                                     * XMN01000\n*                                                                     * XMN01010\n*********************************************************************** XMN01020\n         SPACE 3                                                        XMN01030\nGETC     EQU   4                   SEQUENTIAL INPUT                     XMN01040\n         SPACE 1                                                        XMN01050\nPUTC     EQU   8                   SEQUENTIAL OUTPUT                    XMN01060\n         SPACE 1                                                        XMN01070\nTRC      EQU   12                  INITIATE TRACING  (NOP IN XPLSM)     XMN01080\n         SPACE 1                                                        XMN01090\nUNTR     EQU   16                  TERMINATE TRACING (NOP IN XPLSM)     XMN01100\n         SPACE 1                                                        XMN01110\nEXDMP    EQU   20                  FORCE A CORE DUMP                    XMN01120\n         SPACE 1                                                        XMN01130\nGTIME    EQU   24                  RETURN TIME AND DATE                 XMN01140\n         SPACE 1                                                        XMN01150\nRSVD1    EQU   28                  REWIND SEQUENTIAL FILES\n         SPACE 1                                                        XMN01170\nRSVD2    EQU   32                 CLOCK_TRAP\n         SPACE 1                                                        XMN01190\nRSVD3    EQU   36                 INTERRUPT_TRAP\n         SPACE 1                                                        XMN01210\nRSVD4    EQU   40                  MONITOR\n         SPACE 1                                                        XMN01230\nRSVD5    EQU   44                  (UNUSED)                             XMN01240\n         SPACE 1                                                        XMN01250\nRSVD6    EQU   48                  (UNUSED)                             XMN01260\n         SPACE 1                                                        XMN01270\n         SPACE 2                                                        XMN01280\n*********************************************************************** XMN01290\n*                                                                     * XMN01300\n*        GENERATE THE SERVICE CODES FOR DIRECT ACCESS FILE I/O        * XMN01310\n*        BASED ON THE NUMBER OF FILES AVAILABLE  (&FILES)             * XMN01320\n*                                                                     * XMN01330\n*********************************************************************** XMN01340\n         SPACE 2                                                        XMN01350\nFILEORG  EQU   RSVD6+4             ORIGIN FOR THE FILE SERVICE CODES    XMN01360\n         SPACE 1                                                        XMN01370\n&I       SETA  1                                                        XMN01380\n.SC1     AIF   (&I GT &FILES).SC2                                       XMN01390\nRD&I     EQU   FILEORG+8*(&I-1)    CODE FOR READING FILE&I              XMN01400\nWRT&I    EQU   FILEORG+8*(&I-1)+4  CODE FOR WRITING FILE&I              XMN01410\n&I       SETA  &I+1                                                     XMN01420\n         AGO   .SC1                                                     XMN01430\n.SC2     ANOP                                                           XMN01440\n         SPACE 2                                                        XMN01450\nENDSERV  EQU   FILEORG+8*(&I-1)    1ST UNUSED SERVICE CODE              XMN01460\n         SPACE 2                                                        XMN01470\n*********************************************************************** XMN01480\n*                                                                     * XMN01490\n*                                                                     * XMN01500\n*        DEFINE REGISTER USAGE                                        * XMN01510\n*                                                                     * XMN01520\n*********************************************************************** XMN01530\n         SPACE 2                                                        XMN01540\nRTN      EQU   3                   REGISTER CONTAINING COMPLETION       XMN01550\n*                                  CODE RETURNED BY THE PROGRAM         XMN01560\n         SPACE 1                                                        XMN01570\nEBR      EQU   10                  BASE REGISTER USED DURING            XMN01580\n*                                  INITIALIZATION                       XMN01590\n         SPACE 1                                                        XMN01600\nCBR      EQU   12                  LINKAGE REGISTER USED FOR CALLS      XMN01610\n*                                  TO THE SUBMONITOR                    XMN01620\n         SPACE 1                                                        XMN01630\nSELF     EQU   15                  REGISTER THAT ALWAYS CONTAINS        XMN01640\n*                                  THE ADDRESS OF THE SUBMONITOR        XMN01650\n*                                  ENTRY POINT                          XMN01660\n         SPACE 1                                                        XMN01670\n*********************************************************************** XMN01680\n*                                                                     * XMN01690\n*        BIT CONSTANTS NEEDED FOR CONVERSING WITH OS/360 DCBS         * XMN01700\n*                                                                     * XMN01710\n*********************************************************************** XMN01720\n         SPACE 2                                                        XMN01730\nOPENBIT  EQU   B'00010000'         DCBOFLGS BIT INDICATING OPEN         XMN01740\n*                                  SUCCESSFULLY COMPLETED               XMN01750\n         SPACE 1                                                        XMN01760\nTAPEBITS EQU   B'10000001'         BITS INDICATING A MAGNETIC TAPE      XMN01770\n         SPACE 1                                                        XMN01780\nKEYLBIT  EQU   B'00000001'         BIT IN RECFM THAT INDICATES          XMN01790\n*                                  KEYLEN WAS SET EXPLICITELY ZERO      XMN01800\n         SPACE 2                                                        XMN01810\n*********************************************************************** XMN01820\n*                                                                     * XMN01830\n*        FLAG BITS USED TO CONTROL SUBMONITOR OPERATION               * XMN01840\n*                                                                     * XMN01850\n*********************************************************************** XMN01860\n         SPACE 2                                                        XMN01870\nALLBITS  EQU   B'11111111'         MASK                                 XMN01880\n         SPACE 1                                                        XMN01920\nSFILLBIT EQU   B'01000000'         1 CHARACTER OF FILL NEEDED BY        XMN01930\n*                                  THE PUT ROUTINE                      XMN01940\n         SPACE 1                                                        XMN01950\nLFILLBIT EQU   B'00100000'         LONGER FILL NEEDED BY PUT ROUTINE    XMN01960\n         SPACE 1                                                        XMN01970\nDUMPBIT  EQU   B'00001000'         GIVE A CORE DUMP FOR I/O ERRORS      XMN01980\n         SPACE 2                                                        XMN01990\n*********************************************************************** XMN02000\n*                                                                     * XMN02010\n*                                                                     * XMN02020\n*              DEFINE ABEND CODES ISSUED BY THE SUBMONITOR            * XMN02030\n*                                                                     * XMN02040\n*********************************************************************** XMN02050\n         SPACE 2                                                        XMN02060\nOPENABE  EQU   100                 UNABLE TO OPEN ONE OF THE FILES:     XMN02070\n*                                  PROGRAM, SYSIN, OR SYSPRINT          XMN02080\n         SPACE 1                                                        XMN02090\nPGMEOD   EQU   200                 UNEXPECTED END OF FILE WHILE         XMN02100\n*                                  READING IN THE XPL PROGRAM           XMN02110\n         SPACE 1                                                        XMN02120\nPGMERR   EQU   300                 SYNAD ERROR WHILE READING IN         XMN02130\n*                                  THE XPL PROGRAM                      XMN02140\n         SPACE 1                                                        XMN02150\nCOREABE  EQU   400                 XPL PROGRAM WON'T FIT IN             XMN02160\n*                                  THE AMOUNT OF MEMORY AVAILABLE       XMN02170\n         SPACE 1                                                        XMN02180\nCODEABE  EQU   500                 INVALID SERVICE CODE FROM THE        XMN02190\n*                                  XPL PROGRAM                          XMN02200\n         SPACE 1                                                        XMN02210\nOUTSYND  EQU   800                 SYNAD ERROR ON OUTPUT FILE           XMN02220\n         SPACE 1                                                        XMN02230\nPFABE    EQU   900                 INVALID OUTPUT FILE SPECIFIED        XMN02240\n         SPACE 1                                                        XMN02250\nINSYND   EQU   1000                SYNAD ERROR ON INPUT FILE            XMN02260\n         SPACE 1                                                        XMN02270\nINEODAB  EQU   1200                END OF FILE ERROR ON INPUT FILE      XMN02280\n         SPACE 1                                                        XMN02290\nGFABE    EQU   1400                INVALID INPUT FILE SPECIFIED         XMN02300\n         SPACE 1                                                        XMN02310\nFLSYND   EQU   2000                SYNAD ERROR ON DIRECT ACCESS FILE    XMN02320\n         SPACE 1                                                        XMN02330\nFLEOD    EQU   2200                END OF FILE ERROR ON DIRECT          XMN02340\n*                                  ACCESS FILE                          XMN02350\n         SPACE 1                                                        XMN02360\nUSERABE  EQU   4000                XPL PROGRAM CALLED EXIT TO           XMN02370\n*                                  FORCE A CORE DUMP                    XMN02380\n         EJECT                                                          XMN02390\n         SPACE 5                                                        XMN02400\n*********************************************************************** XMN02410\n*                                                                     * XMN02420\n*                                                                     * XMN02430\n*                                                                     * XMN02440\n*        SUBMONITOR  INITIALIZATION                                   * XMN02450\n*                                                                     * XMN02460\n*                                                                     * XMN02470\n*********************************************************************** XMN02480\n         SPACE 3                                                        XMN02490\n         ENTRY PASCAL1             WHERE OS ENTERS THE OVERLAY MONITOR\n         ENTRY LINKSAVE            MONITOR_LINK SAVE AREA\n         ENTRY INPUT0,OUTPUT0      SYSIN, SYSPRINT DCB'S\n         SPACE 2                                                        XMN02510\n         DS    0F                                                       XMN02520\n         USING *,15                                                     XMN02530\n         SPACE 1                                                        XMN02540\nPASCAL1  SAVE  (14,12),T,*         SAVE ALL REGISTERS\n         ST    13,SAVE+4           SAVE RETURN POINTER                  XMN02560\n         LA    15,SAVE             ADDRESS OF SUBMONITOR'S OS SAVE AREA XMN02570\n         ST    15,8(0,13)                                               XMN02580\n         LR    13,15                                                    XMN02590\n         USING SAVE,13                                                  XMN02600\n         BALR  EBR,0               BASE ADDRESS FOR INITIALIZATION      XMN02610\n         USING *,EBR                                                    XMN02620\nBASE1    DS    0H                                                       XMN02630\n         DROP  15                                                       XMN02640\n         L     1,0(,1)             ADDRESS OF A POINTER TO THE PARM     XMN02650\n*                                  FIELD OF THE OS EXEC CARD            XMN02660\n         MVI   FLAGS,B'00000000'   RESET ALL FLAGS                      XMN02680\n         LH    4,0(,1)             LENGTH OF THE PARM FIELD             XMN02690\n         LA    1,2(,1)             ADDRESS OF THE PARM STRING           XMN02700\n         LA    4,0(1,4)            ADDRESS OF END OF PARAMETER LIST     XMN02710\n         LA    7,PARMSCAN                                               XMN02720\n         SPACE 2                                                        XMN02730\nPARMSCAN DS    0H                                                       XMN02740\n         CR    1,4                 ARE WE DONE ?                        XMN02750\n         BNL   NOPARMS             YES, SO QUIT LOOKING                 XMN02760\nPS2      CLC   ALTRM,0(1)          TEST FOR 'ALTER'                     XMN02820\n         BNE   PS3                 NOT FOUND                            XMN02830\n         MVC   FREEUP,ALTFREE      MAKE MORE ROOM FOR ALTER             XMN02840\n         LA    1,L'ALTRM+1(,1)     INCREMENT POINTER                    XMN02850\n         BR    7                   BRANCH BACK TO TEST                  XMN02860\nPS3      CLC   CMNM,0(1)           LOOK FOR 'MIN=NNNN'                  XMN02870\n         BNE   PS4                 NOT FOUND                            XMN02880\n         BAL   CBR,DIGET           GO GET THE NUMBER                    XMN02890\n         ST    3,COREMIN           SET NEW MINIMUM VALUE                XMN02900\n         BR    7                   BRANCH TO TEST                       XMN02910\nPS4      CLC   CMXM,0(1)           CHECK FOR 'MAX=MMMM'                 XMN02920\n         BNE   PS5                 NOT FOUND                            XMN02930\n         BAL   CBR,DIGET           GO GET THE VALUE                     XMN02940\n         ST    3,COREMAX           SET NEW MAXIMUM VALUE                XMN02950\n         BR    7                   BRANCH TO TEST                       XMN02960\nPS5      CLC   FREEM,0(1)          CHECK FOR 'FREE=NNNN'                XMN02970\n         BNE   PS6                 NOT FOUND                            XMN02980\n         BAL   CBR,DIGET           GO GET THE VALUE                     XMN02990\n         ST    3,FREEUP            SET NEW AMOUNT FREED                 XMN03000\n         BR    7                   BRANCH TO TEST                       XMN03010\nPS6      CLC   DMPM,0(1)           CHECK FOR 'DUMP'                     XMN03020\n         BNE   PS7                 NOT FOUND                            XMN03030\n         OI    FLAGS,DUMPBIT       SET DUMP ON ERROR FLAG               XMN03040\n         LA    1,L'DMPM+1(,1)      INCREMENT POINTER                    XMN03050\n         BR    7                   BRANCH TO TEST                       XMN03060\nPS7      CLC   FILEM,0(1)          CHECK FOR 'FILE=MMMM'                XMN03070\n         BNE   PS8                 NOT FOUND\n         BAL   CBR,DIGET           GET THE BLKSIZE VALUE                XMN03090\n         LA    2,&FILES*2          NUMBER OF DCB FOR FILES              XMN03100\n         LA    5,ARWDCBS           ADDRESS OF DCB LIST                  XMN03110\nFLOOP    L     6,0(,5)             ADDRESS OF A DCB                     XMN03120\n         USING IHADCB,6                                                 XMN03130\n         STH   3,DCBLRECL          SET NEW RECORD LENGTH                XMN03140\n         STH   3,DCBBLKSI          SET NEW BLOCKSIZE                    XMN03150\n         DROP  6                                                        XMN03160\n         LA    5,4(,5)             INCREMENT ADDRESS                    XMN03170\n         BCT   2,FLOOP             LOOP BACK                            XMN03180\n         SLL   3,2                 (NEW BLOCKSIZE)*4                    XMN03190\n         ST    3,ALTFREE           ALTER PARAMETER                      XMN03200\n         BR    7                   GO TO SCAN LOOP                      XMN03210\nPS8      CLC   TIMEM,0(1)          CHECK FOR 'TIME=SSS'\n         BNE   PS9                 NOT FOUND\n         BAL   CBR,DIGET           GET TIME ESTIMATE\n         ST    3,SECONDS           STORE IT IN MONITOR_LINK\n         BR    7                   BRANCH TO TEST\nPS9      CLC   LINESM,0(1)         CHECK FOR 'LINES=LLLL'\n         BNE   PS10                NOT FOUND\n         BAL   CBR,DIGET           GET LINES ESTIMATE\n         ST    3,LINES             STORE IN MONITOR_LINK\n         BR    7                   BRANCH TO TEST\nPS10     CLC   DEBUGM,0(1)         CHECK FOR 'DEBUG=D'\n         BNE   PSBUMP              NOT FOUND\n         BAL   CBR,DIGET           GET DEBUG LEVEL\n         ST    3,DBGLVL            STORE IN MONITOR_LINK\n         BR    7                   BRANCH TO TEST\nPSBUMP   LA    1,1(,1)             INCREMENT POINTER TO PARM STRING     XMN03220\n         BR    7                   BRANCH TO TEST                       XMN03230\nNOPARMS  DS    0H                                                       XMN03240\n         SPACE 2                                                        XMN03250\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        SCAN DD STATEMENTS, COUNT PASSES.                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         XR    5,5                 CONSTANT ZERO USED TO FIND END OF   *\n                                   TIOT.\n         XR    4,4                 REGISTER USED FOR COUNTING PASSES\n         LA    3,PROGRAM           ADDRESS OF PROGRAM DCB IN REG. 3\n         USING IHADCB,3\n         L     3,DCBDDNAM          THE STRING 'PASS' IN REG. 3\n         DROP  3\n         L     6,PMDCHARS          THE STRING 'PMD ' IN REG. 6\n         XR    2,2                 REGISTER 2 USED FOR DD ENTRY\n         EXTRACT ADDRTIOT,FIELDS=TIOT  EXTRACT TIOT ADDR. FROM TCB\n         L     1,ADDRTIOT          ADDRESS OF TASK I/O TABLE\n         LA    1,24(,1)            ADDRESS OF 1ST DD ENTRY\nNEXTDD   C     3,4(,1)             COMPARE DDNAMES\n         BNE   NOTPASS\n         LA    4,1(,4)             INCREMENT PASS COUNT\n         B     NOTPMD\nNOTPASS  C     6,4(,1)             DDNAME 'PMD' FOUND?\n         BNE   NOTPMD              NO, SO BRANCH\n         MVI   PMDPHASE,X'FF'      YES, INDICATE POST-MORTEM PHASE.\nNOTPMD   IC    2,0(,1)             LENGTH OF DD ENTRY.\n         LA    1,0(1,2)            ADDR OF NEXT DD ENTRY\n         C     5,0(,1)             CHECK FOR END OF TIOT\n         BNE   NEXTDD\n         STC   4,NPASSES\n         SPACE 2\n*********************************************************************** XMN03260\n*                                                                     * XMN03270\n*                                                                     * XMN03280\n*        OPEN THE FILES  PROGRAM, SYSIN, AND SYSPRINT                 * XMN03290\n*                                                                     * XMN03300\n*********************************************************************** XMN03310\n         SPACE 2                                                        XMN03320\n         OPEN  (INPUT0,(INPUT),OUTPUT0,(OUTPUT),PROGRAM,(INPUT))        XMN03330\n         SPACE 1                                                        XMN03340\n         L     3,GETDCBS           ADDRESS OF DCB FOR INPUT0            XMN03350\n         USING IHADCB,3                                                 XMN03360\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING         XMN03370\n         BZ    BADOPEN             INPUT0 NOT OPENED SUCCESSFULLY       XMN03380\n         L     3,PUTDCBS           ADDRESS OF DCB FOR OUTPUT0           XMN03390\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING         XMN03400\n         BZ    BADOPEN             OUTPUT0 NOT OPENED SUCCESSFULLY      XMN03410\n         L     3,PGMDCB            ADDRESS OF DCB FOR PROGRAM           XMN03420\n         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPENING          XMN03430\n         BNZ   OPENOK              PROGRAM SUCCESSFULLY OPENED          XMN03440\n         DROP  3                                                        XMN03450\n         SPACE 2                                                        XMN03460\nBADOPEN  LA    1,OPENABE           ABEND BECAUSE FILES DIDN'T OPEN      XMN03470\n*                                  PROPERLY                             XMN03480\n         B     ABEND               GO TO ABEND ROUTINE                  XMN03490\n         SPACE 2                                                        XMN03500\nOPENOK   DS    0H                                                       XMN03510\n         SPACE 2                                                        XMN03520\n*********************************************************************** XMN03530\n*                                                                     * XMN03540\n*                                                                     * XMN03550\n*        NOW OBTAIN SPACE IN MEMORY FOR THE XPL PROGRAM AND ITS       * XMN03560\n*        FREE STRING AREA.  A GETMAIN IS ISSUED TO OBTAIN AS MUCH     * XMN03570\n*        MEMORY AS POSSIBLE WITHIN THE PARTITION.  THEN A FREEMAIN    * XMN03580\n*        IS ISSUED TO RETURN THE AMOUNT OF MEMORY SPECIFIED BY        * XMN03590\n*        THE VARIABLE 'FREEUP' TO OS/360 FOR USE AS WORK SPACE.       * XMN03600\n*        OS/360 NEEDS SPACE FOR FOR DYNAMICALLY CREATING BUFFERS      * XMN03610\n*        FOR THE SEQUENTIAL INPUT AND OUTPUT FILES AND FOR            * XMN03620\n*        OVERLAYING I/O ROUTINES.                                     * XMN03630\n*                                                                     * XMN03640\n*           THE AMOUNT OF CORE REQUESTED FROM OS/360 CAN BE ALTERED   * XMN03650\n*        WITH THE 'MAX=NNNN' AND 'MIN=MMMM' PARAMETERS TO THE         * XMN03660\n*        SUBMONITOR.  THE AMOUNT OF CORE RETURNED TO OS/360 CAN BE    * XMN03670\n*        ALTERED WITH THE 'FREE=NNNN' OR THE 'ALTER' PARAMETER        * XMN03680\n*                                                                     * XMN03690\n*                                                                     * XMN03700\n*        MEMORY REQUEST IS DEFINED BY THE CONTROL BLOCK STARTING AT   * XMN03710\n*        'COREREQ'.  THE DESCRIPTION OF THE MEMORY SPACE OBTAINED     * XMN03720\n*        IS PUT INTO THE CONTROL BLOCK STARTING AT 'ACORE'.           * XMN03730\n*                                                                     * XMN03740\n*                                                                     * XMN03750\n*********************************************************************** XMN03760\n         SPACE 2                                                        XMN03770\n         GETMAIN VU,LA=COREREQ,A=ACORE                                  XMN03780\n         SPACE 1                                                        XMN03790\n         LM    1,2,ACORE           ADDRESS OF CORE OBTAINED TO R1       XMN03800\n*                                  LENGTH OF CORE AREA TO R2            XMN03810\n         AR    1,2                 ADDRESS OF TOP OF CORE AREA          XMN03820\n         S     1,FREEUP            LESS AMOUNT TO BE RETURNED           XMN03830\n         ST    1,CORETOP           ADDRESS OF TOP OF USABLE CORE        XMN03840\n*                                  (BECOMES 'FREELIMIT')                XMN03850\n         S     2,FREEUP            SUBTRACT AMOUNT RETURNED             XMN03860\n         ST    2,CORESIZE          SIZE OF AVAILABLE SPACE              XMN03870\n         L     0,FREEUP            AMOUNT TO GIVE BACK                  XMN03880\n         SPACE 1                                                        XMN03890\n         FREEMAIN R,LV=(0),A=(1)   GIVE 'FREEUP' BYTES OF CORE BACK     XMN03900\n         SPACE 2                                                        XMN03910\n*********************************************************************** XMN03920\n*                                                                     * XMN03930\n*                                                                     * XMN03940\n*        READ IN THE BINARY XPL PROGRAM AS SPECIFIED BY THE           * XMN03950\n*                                                                     * XMN03960\n*        //PASS1    DD  .....                                         * XMN03970\n*                                                                     * XMN03970\n*        AND                                                          * XMN03970\n*                                                                     * XMN03970\n*        //PASS2    DD  .....                                         * XMN03970\n*                                                                     * XMN03980\n*        CARDS. IT IS ASSUMED THAT THE BINARY PROGRAM IS IN STANDARD  * XMN03990\n*        XPL SYSTEM FORMAT.                                           * XMN04000\n*                                                                     * XMN04010\n*                                                                     * XMN04020\n*        THE 1ST RECORD OF THE BINARY PROGRAM FILE SHOULD BEGIN       * XMN04030\n*        WITH A BLOCK OF INFORMATION DESCRIBING THE CONTENTS OF       * XMN04040\n*        THE FILE.  THE FORMAT OF THIS BLOCK IS GIVEN IN THE DSECT    * XMN04050\n*        'FILECTRL' AT THE END OF THIS ASSEMBLY.                      * XMN04060\n*                                                                     * XMN04070\n*                                                                     * XMN04080\n*********************************************************************** XMN04090\n         SPACE 2                                                        XMN04100\n         MVI   PASS,X'1'           SIGNAL FOR LOADING OF PASS1\nREADPASS L     2,ACORE             ADDRESS OF START OF CORE AREA        XMN04110\n         LR    4,2                 SAVE STARTING ADDRESS                XMN04120\n         USING FILECTRL,4          ADDRESS OF CONTROL BLOCK             XMN04130\n         ST    2,CODEADR           SAVE STARTING ADDRESS FOR USE        XMN04140\n*                                  BY THE XPL PROGRAM                   XMN04150\n         BAL   CBR,READPGM         READ IN 1ST RECORD                   XMN04160\n         L     3,BYTSCODE          NUMBER OF BYTES OF CODE              XMN04170\n         S     3,BYTSBLK           LESS ONE RECORD                      XMN04180\n         A     3,BYTSFULL          PLUS AMOUNT IN LAST CODE RECORD      XMN04190\n         A     3,BYTSDATA          PLUS SIZE OF DATA AREA               XMN04200\n         C     3,CORESIZE          COMPARE WITH SPACE AVAILABLE         XMN04210\n         LA    1,COREABE           ABEND CODE FOR NO ROOM IN CORE       XMN04220\n         BH    ABEND               WON'T FIT, SO ABEND                  XMN04230\n         L     5,BLKSCODE          NUMBER OF RECORDS OF CODE            XMN04240\n         L     3,BYTSBLK           NUMBER OF BYTES PER RECORD           XMN04250\n         B     LOAD1               GO TEST FOR MORE CODE RECORDS        XMN04260\n         SPACE 1                                                        XMN04270\nRCODE    AR    2,3                 ADDRESS TO PUT NEXT RECORD           XMN04280\n         BAL   CBR,READPGM         READ IN THE BINARY XPL PROGRAM       XMN04290\nLOAD1    BCT   5,RCODE             LOOP BACK TO GET NEXT RECORD         XMN04300\n         SPACE 1                                                        XMN04310\n         A     2,BYTSFULL          NUMBER OF BYTES ACTUALLY             XMN04320\n*                                  USED IN LAST CODE RECORD             XMN04330\n         ST    2,DATADR            SAVE ADDRESS OF DATA AREA            XMN04340\n*                                  FOR USE BY THE XPL PROGRAM           XMN04350\n         L     5,BLKSDATA          NUMBER OF RECORDS OF DATA            XMN04360\n         SPACE 1                                                        XMN04370\nRDATA    BAL   CBR,READPGM         READ IN THE XPL PROGRAM'S DATA AREA  XMN04380\n         AR    2,3                 ADDRESS TO PUT NEXT RECORD           XMN04390\n         BCT   5,RDATA             LOOP BACK FOR NEXT RECORD            XMN04400\n         DROP  4                                                        XMN04410\n         SPACE 2                                                        XMN04420\n*********************************************************************** XMN04430\n*                                                                     * XMN04440\n*                                                                     * XMN04450\n*        CODE TO BRANCH TO THE XPL PROGRAM                            * XMN04460\n*                                                                     * XMN04470\n*                                                                     * XMN04480\n*********************************************************************** XMN04490\n         SPACE 2                                                        XMN04500\n         L     2,DATADR           FILL IN MONITOR_LINK\n         MVC   104(16,2),LINKSAVE\n         LA    SELF,ENTRY          ADDRESS OF ENTRY POINT TO XPLSM      XMN04510\n         LM    0,3,PGMPARMS        PARAMETERS FOR THE XPL PROGRAM       XMN04540\n         DROP  EBR,13                                                   XMN04550\n         USING ENTRY,SELF                                               XMN04560\n         SPACE 2                                                        XMN04570\n         USING FILECTRL,2          ADDRESS OF FIRST RECORD OF CODE      XMN04580\nGOC      BAL   CBR,CODEBEGN        BRANCH TO HEAD OF THE XPL PROGRAM    XMN04590\n         DROP  2                                                        XMN04600\n         SPACE 1                                                        XMN04610\n*********************************************************************** XMN04620\n*                                                                     * XMN04630\n*                                                                     * XMN04640\n*        THE XPL PROGRAM RETURNS HERE AT THE END OF EXECUTION         * XMN04650\n*                                                                     * XMN04660\n*                                                                     * XMN04670\n*********************************************************************** XMN04680\n         SPACE 2                                                        XMN04690\n         L     EBR,ABASE1          REGISTER FOR ADDRESSABILITY          XMN04700\n         USING BASE1,EBR                                                XMN04710\n         ST    RTN,RTNSV           SAVE COMPLETION CODE RETURNED BY     XMN04720\n*                                  THE XPL PROGRAM FOR PASSING TO OS    XMN04730\n         L     13,ASAVE            ADDRESS OF OS/360 SAVE AREA          XMN04760\n         USING SAVE,13                                                  XMN04770\n         DROP  SELF                                                     XMN04780\n         SPACE 2                                                        XMN04790\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*        SEE IF THERE ARE OTHER PASSES TO BE LOADED                   *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         CLC   PASS,NPASSES        LAST PASS?\n         BNL   SMRET               YES, SO TERMINATE.\n         L     2,DATADR            ADDRESS OF XPL DATA SEGMENT\n         MVC   LINKSAVE(16),104(2) SAVE MONITOR_LINK.\n         TM    LINKSAVE,X'80'      IS INHIBIT BIT ON?\n         BNZ   SMRET               YES, SO TERMINATE.\n         XR    2,2                 NO -- INCREMENT PASS COUNTER\n         IC    2,PASS\n         LA    2,1(2)\n         STC   2,PASS\n*   CLOSE FILES INPUT2, INPUT3, ... , &INPUTS\n         MVI   GETDCBS+4*&INPUTS,X'80'\n*                                  FLAG END OF PARAMETER LIST\n         CLOSE ,MF=(E,GETDCBS+8)\n         MVI   GETDCBS+4*&INPUTS,0 CLEAR FLAG\n*   CLOSE FILES OUTPUT3, OUTPUT4, ..., THE PROGRAM FILE, AND ALL\n*   DIRECT ACCESS FILES\n         CLOSE ,MF=(E,PUTDCBS+12)\n         LA    4,PROGRAM           CLOSE THE PROGRAM FILE\n         USING IHADCB,4\n         IC    2,DCBDDNAM+4        CHANGE DDNAME TO THAT OF NEXT PASS\n         LA    2,1(2)\n         STC   2,DCBDDNAM+4\n         OPEN  (PROGRAM,(INPUT))   OPEN THE FILE CONTAINING THE NEXT   -\n                                   PASS OF THE COMPILER\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING\n         BZ    BADOPEN             PROGRAM NOT OPENED SUCCESSFULLY\n         B     READPASS            PROGRAM OPENED SUCCESSFULLY\n         DROP  4\n         SPACE 2\n*********************************************************************** XMN04800\n*                                                                     * XMN04810\n*        RELEASE THE MEMORY OCCUPPIED BY THE XPL PROGRAM              * XMN04820\n*                                                                     * XMN04830\n*********************************************************************** XMN04840\n         SPACE 2                                                        XMN04850\nSMRET    L     1,ACORE             ADDRESS OF THE BLOCK TO BE FREED     XMN04860\n         L     0,CORESIZE          LENGTH OF THE BLOCK TO BE FREED      XMN04870\n         SPACE 1                                                        XMN04880\n         FREEMAIN R,LV=(0),A=(1)   FREEDOM NOW !                        XMN04890\n         SPACE 1                                                        XMN04900\n         TM    LINKSAVE,X'80'      IS INHIBIT BIT ON?\n         BNZ   RETURN              YES, DO NOT RUN THE PASCAL PROGRAM.\n         MVI   GETDCBS+4*&INPUTS,X'80' FLAG END OF LIST\n         CLOSE ,MF=(E,GETDCBS+8)   CLOSE SYSUT INPUT FILES\n         MVI   GETDCBS+4*&INPUTS,X'00' CLEAR FLAG\n         MVI   PUTDCBS+4*&OUTPUTS,X'80' FLAG END OF LIST\n         CLOSE ,MF=(E,PUTDCBS+12)  CLOSE SYSUT OUTPUT FILES\n         MVI   PUTDCBS+4*&OUTPUTS,X'00' CLEAR FLAG\n         CLOSE ,MF=(E,PGMDCB)      CLOSE THE PROGRAM FILE.\n         CALL  MONITORE            LINK TO RUN MONITOR\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*        THE PASCAL RUN MONITOR RETURNS THE ADDRESS OF A BLOCK OF     *\n*        STATUS INFORMATION IN MONITOR_LINK(3).  THE FORMAT OF THIS   *\n*        BLOCK IS DEFINED BY THE DSECT 'STATUS'.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         L     1,LINKSAVE+4*3      MONITOR_LINK(3) IN REG. 1\n         USING STATUS,1            REG. 1 POINTS TO STATUS BLOCK.\n         L     2,ARBASE            ADDRESS OF GLOBAL ACTIVATION RECORD.\n         ST    2,CORETOP           BECOMES 'FREELIMIT'\n         L     3,CODEPNT           ADDRESS OF PASCAL CODE SEGMENT.\n         ST    3,ACORE             WHERE POST-MORTEM ANALYSIS PHASE\n*                                  IS LOADED.\n         SR    2,3                 LENGTH OF PASCAL CODE SEGMENT.\n         ST    2,CORESIZE          BECOMES PMD REGION SIZE.\n         DROP  1\n         CLI   PMDPHASE,X'FF'      POST-MORTEM ANALYSIS?\n         BNE   RETURN              NO, FINISH UP.\n         TM    LINKSAVE,X'80'      INHIBIT BIT SET?\n         BNZ   RETURN              YES, FINISH UP.\n         LA    4,PROGRAM           ADDRESS OF PROGRAM DCB.\n         USING IHADCB,4\n         MVC   DCBDDNAM,PMDCHARS   DDNAME = 'PMD'.\n         OPEN  (PROGRAM,(INPUT))   OPEN THE PMD FILE.\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING.\n         BZ    BADOPEN             PROGRAM NOT OPENED SUCCESSFULLY.\n         OI    LINKSAVE,X'80'      SET THE INHIBIT BIT.\n         B     READPASS            LOAD THE POST-MORTEM ANALYSIS PHASE.\n         DROP  4\n         SPACE 1\nRETURN   DS    0H                  PREPARE TO RETURN TO OS/360\n         CLOSE (INPUT0,,OUTPUT0)                                        XMN04910\n         SPACE 1                                                        XMN04920\n*********************************************************************** XMN04930\n*                                                                     * XMN04940\n*        WARNING,  THE CLOSE OF INPUT0 AND OUTPUT0 MUST PRECEDE       * XMN04950\n*        THE CLOSE WHICH USES THE GETDCBS LIST.  THE CLOSE SVC WILL   * XMN04960\n*        LOOP INDEFINITELY IF THE SAME DCB ADDRESS APPEARS TWICE IN   * XMN04970\n*        A CLOSE LIST.                                                * XMN04980\n*                                                                     * XMN04990\n*********************************************************************** XMN05000\n         SPACE 1                                                        XMN05010\n         CLOSE ,MF=(E,GETDCBS)     CLOSE ALL FILE KNOWN TO XPLSM        XMN05020\n         SPACE 1                                                        XMN05030\n         L     15,RTNSV            LOAD RETURN CODE                     XMN05040\n         L     13,SAVE+4                                                XMN05050\n         DROP  13                                                       XMN05060\n         RETURN (14,12),RC=(15)    RETURN TO OS/360                     XMN05070\n         SPACE 1                                                        XMN05080\n         DROP  EBR                                                      XMN05090\n         USING SAVE,13                                                  XMN05100\n         EJECT                                                          XMN05110\n         SPACE 5                                                        XMN05120\n*********************************************************************** XMN05130\n*                                                                     * XMN05140\n*                                                                     * XMN05150\n*                                                                     * XMN05160\n*        CONSTANTS USED DURING INITIALIZATION                         * XMN05170\n*                                                                     * XMN05180\n*                                                                     * XMN05190\n*********************************************************************** XMN05200\n         SPACE 2                                                        XMN05210\nSAVE     DS    18F                 SAVE AREA FOR OS/360                 XMN05220\nACORE    DS    A                   ADDRESS OF CORE FOR THE PROGRAM      XMN05230\nCORESIZE DS    F                   SIZE OF CORE IN BYTES                XMN05240\nCOREREQ  DS    0F                  CORE REQUEST CONTROL BLOCK           XMN05270\nCOREMIN  DC    F'110000'           MINIMUM AMOUNT OF CORE REQUIRED      XMN05280\nCOREMAX  DC    F'5000000'          MAXIMUM AMOUNT OF CORE REQUESTED     XMN05290\nFREEUP   DC    A(2*FILEBYTS)       AMOUNT OF CORE TO RETURN TO OS       XMN05300\nALTFREE  DC    A(4*FILEBYTS)       AMOUNT OF CORE FREED FOR ALTER       XMN05310\nLINKSAVE DS    0F                  SAVE AREA FOR MONITOR_LINK\nSECONDS  DC    F'10'               DEFAULT IS 10 SECONDS\nLINES    DC    F'1000'             DEFAULT IS 1000 LINES\nDBGLVL   DC    F'2'                DEFAULT IS DEBUG LEVEL 2\nLINKRESV DC    F'0'                WORD 4 OF MONITOR_LINK IS RESERVED\nADDRTIOT DS    F                   ADDRESS OF TASK I/O TABLE\nPMDPHASE DC    X'00'               SET TO 'FF' IF A //PMD DD ...\n*                                  STATEMENT IS SUPPLIED.\nNPASSES  DS    X                   NUMBER OF PASSES, IN ALL\nPASS     DS    X                   WHICH PASS TO EXECUTE\n         SPACE 1                                                        XMN05320\n*********************************************************************** XMN05330\n*                                                                     * XMN05340\n*        BLOCK OF PARAMETERS PASSED TO THE XPL PROGRAM                * XMN05350\n*                                                                     * XMN05360\n*********************************************************************** XMN05370\n         SPACE 1                                                        XMN05380\nPGMPARMS DS    F                   R0  UNUSED                           XMN05390\nCORETOP  DC    A(0)                R1  ADDRESS OF TOP OF CORE           XMN05400\nCODEADR  DC    F'0'                R2  ADDRESS OF START OF 1ST RECORD   XMN05410\n*                                  OF THE XPL PROGRAM                   XMN05420\nDATADR   DC    F'0'                R3  ADDRESS OF THE START OF THE XPL  XMN05430\n*                                      PROGRAM'S DATA AREA              XMN05440\n         SPACE 1                                                        XMN05450\nPMDCHARS DC    CL8'PMD'            MUST BE FULLWORD-ALLIGNED\nALTRM    DC    CL5'ALTER'                                               XMN05470\nCMNM     DC    CL4'MIN='                                                XMN05480\nCMXM     DC    CL4'MAX='                                                XMN05490\nFREEM    DC    CL5'FREE='                                               XMN05500\nDMPM     DC    CL4'DUMP'                                                XMN05510\nFILEM    DC    CL5'FILE='                                               XMN05520\nTIMEM    DC    CL5'TIME='\nLINESM   DC    CL6'LINES='\nDEBUGM   DC    CL6'DEBUG='\n         EJECT                                                          XMN05530\n         SPACE 5                                                        XMN05540\n*********************************************************************** XMN05550\n*                                                                     * XMN05560\n*                                                                     * XMN05570\n*        ROUTINE TO SCAN PARAMETER STRINGS FOR DIGITS                 * XMN05580\n*                                                                     * XMN05590\n*                                                                     * XMN05600\n*********************************************************************** XMN05610\n         SPACE 2                                                        XMN05620\nDIGET    DS    0H                                                       XMN05630\n         SR    2,2                 CLEAR REGISTER                       XMN05640\n         SR    3,3                  \"                                   XMN05650\nDG1      CLI   0(1),C'='           CHECK FOR '='                        XMN05660\n         BE    DG2                                                      XMN05670\n         LA    1,1(,1)             INCREMENT POINTER                    XMN05680\n         CR    1,4                 AT END ?                             XMN05690\n         BCR   B'1011',CBR        YES, SO RETURN\n         B     DG1                 KEEP LOOKING FOR '='                 XMN05710\nDG2      LA    1,1(,1)             INCREMENT POINTER                    XMN05720\n         LA    5,C'0'              BINARY VALUE OF '0'                  XMN05730\nDGLP     IC    2,0(,1)             FETCH A CHARACTER                    XMN05740\n         SR    2,5                 NORMALIZE                            XMN05750\n         BM    DGDN                NOT A DIGIT SO DONE                  XMN05760\n         LR    0,3                                                      XMN05770\n         SLL   3,2                 NUMBER*4                             XMN05780\n         AR    3,0                 NUMBER*5                             XMN05790\n         SLL   3,1                 NUMBER*10                            XMN05800\n         AR    3,2                 ADD IN NEW DIGIT                     XMN05810\n         LA    1,1(,1)             INCREMENT POINTER                    XMN05820\n         CR    1,4                 AT END ?                             XMN05830\n         BL    DGLP                NO                                   XMN05840\nDGDN     LA    1,1(,1)             INCREMENT POINTER                    XMN05850\n         BR    CBR                 RETURN                               XMN05860\n*                                  VALUE OF NUMBER IS IN REG 3          XMN05870\n         EJECT                                                          XMN05880\n         SPACE 5                                                        XMN05890\n*********************************************************************** XMN05900\n*                                                                     * XMN05910\n*                                                                     * XMN05920\n*        ROUTINE TO READ IN THE BINARY IMAGE OF THE XPL PROGRAM       * XMN05930\n*                                                                     * XMN05940\n*                                                                     * XMN05950\n*********************************************************************** XMN05960\n         SPACE 2                                                        XMN05970\nREADPGM  DS    0H                                                       XMN05980\n*                                  SHARE DECB WITH FILE READ ROUTINE    XMN05990\n         SPACE 1                                                        XMN06000\n         READ  RDECB,SF,PROGRAM,(2),MF=E                                XMN06010\n         CHECK RDECB               WAIT FOR READ TO COMPLETE            XMN06020\n         SPACE 1                                                        XMN06030\n         BR    CBR                 RETURN TO CALLER                     XMN06040\n         EJECT                                                          XMN06050\n         SPACE 5                                                        XMN06060\n*********************************************************************** XMN06070\n*                                                                     * XMN06080\n*                                                                     * XMN06090\n*        ROUTINES TO PROVIDE DEFAULT DATASET INFORMATION IF NONE      * XMN06100\n*        IS PROVIDED BY JCL OR VOLUME LABELS.  IN PARTICULAR,         * XMN06110\n*        BLKSIZE, LRECL, BUFNO, AND RECFM INFORMATION.                * XMN06120\n*                                                                     * XMN06130\n*                                                                     * XMN06140\n*        EXIT LISTS FOR DCBS                                          * XMN06150\n*                                                                     * XMN06160\n*********************************************************************** XMN06170\n         SPACE 2                                                        XMN06180\n         DS    0F                                                       XMN06190\nINEXIT0  DC    X'85'               INPUT0                               XMN06200\n         DC    AL3(INXT0)                                               XMN06210\n         SPACE 1                                                        XMN06220\nOUTEXIT0 DC    X'85'               OUTPUT0                              XMN06230\n         DC    AL3(OUTXT0)                                              XMN06240\n         SPACE 1                                                        XMN06250\nINEXIT2  DC    X'85'               INPUT2                               XMN06260\n         DC    AL3(INXT2)                                               XMN06270\n         SPACE 1                                                        XMN06280\nOUTEXIT2 EQU   INEXIT0             OUTPUT2                              XMN06290\n         SPACE 2                                                        XMN06300\n&I       SETA  3                                                        XMN06310\n.IDF1    AIF   (&I GT &INPUTS).IDF2                                     XMN06320\nINEXIT&I EQU   INEXIT2             INPUT&I                              XMN06330\n&I       SETA  &I+1                                                     XMN06340\n         AGO   .IDF1                                                    XMN06350\n.IDF2    ANOP                                                           XMN06360\n         SPACE 1                                                        XMN06370\n&I       SETA  3                                                        XMN06380\n.ODF1    AIF   (&I GT &OUTPUTS).ODF2                                    XMN06390\nOUTEXIT&I EQU  INEXIT2                                                  XMN06400\n&I       SETA  &I+1                                                     XMN06410\n         AGO   .ODF1                                                    XMN06420\n.ODF2    ANOP                                                           XMN06430\n         SPACE 1                                                        XMN06440\n*********************************************************************** XMN06450\n*                                                                     * XMN06460\n*        DCB EXIT ROUTINE ENTRY POINTS                                * XMN06470\n*                                                                     * XMN06480\n*********************************************************************** XMN06490\n         SPACE 2                                                        XMN06500\nINXT0    MVC   DEFAULTS(6),INDFLT0                                      XMN06510\n         B     GENXT                                                    XMN06520\n         SPACE 1                                                        XMN06530\nINXT2    MVC   DEFAULTS(6),INDFLT2                                      XMN06540\n         B     GENXT                                                    XMN06550\n         SPACE 1                                                        XMN06560\nOUTXT0   MVC   DEFAULTS(6),OUTDFLT0                                     XMN06570\n         SPACE 1                                                        XMN06580\n*********************************************************************** XMN06590\n*                                                                     * XMN06600\n*                                                                     * XMN06610\n*        DCB EXIT LIST PROCESSING ROUTINE FOR OPEN EXITS              * XMN06620\n*                                                                     * XMN06630\n*********************************************************************** XMN06640\n         SPACE 2                                                        XMN06650\nGENXT    DS    0H                                                       XMN06660\n         USING IHADCB,1            REGISTER 1 POINTS AT THE DCB         XMN06670\n         NC    DCBBLKSI,DCBBLKSI   CHECK BLKSIZE                        XMN06680\n         BNZ   GXT1                ALREADY SET                          XMN06690\n         MVC   DCBBLKSI(2),DFLTBLKS                                     XMN06700\n*                                  PROVIDE DEFAULT BLOCKSIZE            XMN06710\n         SPACE 1                                                        XMN06720\nGXT1     NC    DCBLRECL,DCBLRECL   CHECK LRECL                          XMN06730\n         BNZ   GXT2                ALREADY SET                          XMN06740\n         MVC   DCBLRECL(2),DFLTLREC                                     XMN06750\n*                                  PROVIDE DEFAULT LRECL                XMN06760\n         SPACE 1                                                        XMN06770\nGXT2     CLI   DCBBUFNO,0          CHECK BUFNO                          XMN06780\n         BNE   GXT3                ALREADY SPECIFIED                    XMN06790\n         MVC   DCBBUFNO(1),DFLTBUFN                                     XMN06800\n*                                  PROVIDE DEFAULT BUFNO                XMN06810\n         SPACE 1                                                        XMN06820\nGXT3     TM    DCBRECFM,ALLBITS-KEYLBIT                                 XMN06830\n*                                  CHECK RECFM                          XMN06840\n         BCR   B'0111',14          ALREADY SET SO RETURN                XMN06850\n         OC    DCBRECFM(1),DFLTRECF                                     XMN06860\n*                                  PROVIDE DEFAULT RECFM                XMN06870\n         BR    14                  RETURN                               XMN06880\n         DROP  1                                                        XMN06890\n         SPACE 2                                                        XMN06900\n*********************************************************************** XMN06910\n*                                                                     * XMN06920\n*        ARRAY OF DEFAULT ATTRIBUTES USED BY GENXT                    * XMN06930\n*                                                                     * XMN06940\n*********************************************************************** XMN06950\n         SPACE 1                                                        XMN06960\nDEFAULTS DS    0H                                                       XMN06970\nDFLTBLKS DS    1H                  DEFAULT BLKSIZE                      XMN06980\nDFLTLREC DS    1H                  DEFAULT LRECL                        XMN06990\nDFLTBUFN DS    AL1                 DEFAULT BUFNO                        XMN07000\nDFLTRECF DS    1BL1                DEFAULT RECFM                        XMN07010\n         SPACE 1                                                        XMN07020\n*********************************************************************** XMN07030\n*                                                                     * XMN07040\n*        DEFINE ATTRIBUTES PROVIDED FOR THE VARIOUS FILES             * XMN07050\n*                                                                     * XMN07060\n*        INPUT(0), INPUT(1), OUTPUT(2)                                * XMN07070\n*                                                                     * XMN07080\n*********************************************************************** XMN07090\n         SPACE 1                                                        XMN07100\nINDFLT0  DS    0H                                                       XMN07110\n         DC    H'80'               BLKSIZE=80                           XMN07120\n         DC    H'80'               LRECL=80                             XMN07130\n         DC    AL1(2)              BUFNO=2                              XMN07140\n         DC    B'10000000'         RECFM=F                              XMN07150\n         SPACE 1                                                        XMN07160\n*********************************************************************** XMN07170\n*                                                                     * XMN07180\n*        OUTPUT(0), OUTPUT(1)                                         * XMN07190\n*                                                                     * XMN07200\n*********************************************************************** XMN07210\n         SPACE 1                                                        XMN07220\nOUTDFLT0 DS    0H                                                       XMN07230\n         DC    H'133'              BLKSIZE=133                          XMN07240\n         DC    H'133'              LRECL=133                            XMN07250\n         DC    AL1(2)              BUFNO=2                              XMN07260\n         DC    B'10000100'         RECFM=FA                             XMN07270\n         SPACE 1                                                        XMN07280\n*********************************************************************** XMN07290\n*                                                                     * XMN07300\n*        INPUT(2), INPUT(3), OUTPUT(3)                                * XMN07310\n*                                                                     * XMN07320\n*********************************************************************** XMN07330\n         SPACE 1                                                        XMN07340\nINDFLT2  DS    0H                                                       XMN07350\n         DC    AL2(IOFBYTS)        BLKSIZE=IOFBYTS                      XMN07360\n         DC    H'80'               LRECL=80                             XMN07370\n         DC    AL1(1)              BUFNO=1                              XMN07380\n         DC    B'10010000'         RECFM=FB                             XMN07390\n         EJECT                                                          XMN07400\n         SPACE 5                                                        XMN07410\n*********************************************************************** XMN07420\n*                                                                     * XMN07430\n*                                                                     * XMN07440\n*        INPUT - OUTPUT  ERROR ROUTINES                               * XMN07450\n*                                                                     * XMN07460\n*                                                                     * XMN07470\n*                                                                     * XMN07480\n*        SYNAD AND EOD ERROR ROUTINES FOR INITIAL LOADING OF THE      * XMN07490\n*        XPL PROGRAM                                                  * XMN07500\n*                                                                     * XMN07510\n*                                                                     * XMN07520\n*********************************************************************** XMN07530\n         SPACE 2                                                        XMN07540\nEODPGM   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN07550\n         LA    1,PGMEOD            UNEXPECTED EOD WHILE READING IN      XMN07560\n*                                  THE XPL PROGRAM                      XMN07570\n         B     ABEND               GO TO ABEND ROUTINE                  XMN07580\n         SPACE 2                                                        XMN07590\nERRPGM   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN07600\n         LA    1,PGMERR            SYNAD ERROR WHILE READING IN THE     XMN07610\n*                                  XPL PROGRAM                          XMN07620\n         B     ABEND               GO TO ABEND ROUTINE                  XMN07630\n         SPACE 2                                                        XMN07640\n*********************************************************************** XMN07650\n*                                                                     * XMN07660\n*                                                                     * XMN07670\n*        SYNAD AND EOD ROUTINES FOR INPUT(I),  I = 0,1, ...  ,&INPUTS * XMN07680\n*                                                                     * XMN07690\n*********************************************************************** XMN07700\n         SPACE 2                                                        XMN07710\nINEOD    L     2,SAVREG+PARM2*4    PICK UP SUBCODE SPECIFYING WHICH     XMN07720\n*                                  INPUT FILE                           XMN07730\n         SLL   2,2                 SUBCODE*4                            XMN07740\n         L     2,GETDCBS(2)        FETCH DCB ADDRESS                    XMN07750\n         USING IHADCB,2                                                 XMN07760\n         ST    2,OCDCB             STORE IT FOR THE CLOSE SVC           XMN07770\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST           XMN07780\n         CLOSE ,MF=(E,OCDCB)       CLOSE THE OFFENDING FILE             XMN07790\n         CLC   SAVREG+PARM2*4,F1   EOF ON SYSIN?\n         BH    RETNEOF             NO - FILE STILL USABLE\n         SPACE 1                                                        XMN07800\nPCLOSE   DS    0H                                                       XMN07810\n         XC    DCBDDNAM,DCBDDNAM   MARK THE FILE PERMANENTLY UNUSABLE   XMN07820\n         DROP  2                                                        XMN07830\n         B     RETNEOF             GO RETURN AN END OF FILE INDICATION  XMN07840\n         SPACE 2                                                        XMN07850\nINSYNAD  STM   0,2,ABEREGS         SAVE REGISTERS                       XMN07860\n         LA    1,INSYND            SYNAD ERROR ON AN INPUT FILE         XMN07870\n         B     INERR               BRANCH TO ERROR ROUTINE              XMN07880\n         SPACE 1                                                        XMN07890\nINERR    A     1,SAVREG+PARM2*4    SUBCODE INDICATING WHICH INPUT FILE  XMN07920\n         B     ABEND               BRANCH TO ABEND ROUTINE              XMN07930\n         SPACE 2                                                        XMN07940\n*********************************************************************** XMN07950\n*                                                                     * XMN07960\n*                                                                     * XMN07970\n*        SYNAD ERROR ROUTINES FOR OUTPUT FILES                        * XMN07980\n*                                                                     * XMN07990\n*                                                                     * XMN08000\n*********************************************************************** XMN08010\n         SPACE 2                                                        XMN08020\nOUTSYNAD STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08030\n         LA    1,OUTSYND           SYNAD ERROR ON OUTPUT FILE           XMN08040\n         B     INERR                                                    XMN08050\n         SPACE 2                                                        XMN08060\n*********************************************************************** XMN08070\n*                                                                     * XMN08080\n*        SYNAD AND EOD ROUTINES FOR DIRECT ACCESS FILE I/O            * XMN08090\n*                                                                     * XMN08100\n*********************************************************************** XMN08110\n         SPACE 2                                                        XMN08120\nFILESYND STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08130\n         LA    1,FLSYND            SYNAD ERROR ON DIRECT ACCESS FILE    XMN08140\n         B     FILERR              GO TO ERROR ROUTINE                  XMN08150\n         SPACE 1                                                        XMN08160\nFILEEOD  STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08170\n         LA    1,FLEOD             EOD ERROR ON DIRECT ACCESS FILE      XMN08180\n         SPACE 1                                                        XMN08190\nFILERR   L     2,SAVREG+SVCODE*4   SERVICE CODE                         XMN08200\n         LA    0,RD1-8             COMPUTE WHICH DIRECT ACCESS FILE     XMN08210\n         SR    2,0                 SERVICE_CODE - 1ST SERVICE CODE      XMN08220\n         SRL   2,3                 DIVIDE BY 8                          XMN08230\n         AR    1,2                                                      XMN08240\n*                                  FALL THROUGH TO ABEND ROUTINE        XMN08250\n         SPACE 2                                                        XMN08260\n*********************************************************************** XMN08270\n*                                                                     * XMN08280\n*                                                                     * XMN08290\n*        ABEND ROUTINE FOR ALL I/O ERRORS                             * XMN08300\n*                                                                     * XMN08310\n*                                                                     * XMN08320\n*********************************************************************** XMN08330\n         SPACE 2                                                        XMN08340\nABEND    DS    0H                                                       XMN08350\n         ST    1,ABESAVE           SAVE ABEND CODE                      XMN08360\n         SPACE 1                                                        XMN08370\n         CLOSE (INPUT0,,OUTPUT0)   THESE MUST BE CLOSED FIRST           XMN08380\n         CLOSE ,MF=(E,GETDCBS)     ATTEMPT TO CLOSE ALL FILES           XMN08390\n         SPACE 1                                                        XMN08400\n         L     1,ABESAVE                                                XMN08410\n         TM    FLAGS,DUMPBIT       IS A CORE DUMP DESIRED ?             XMN08420\n         BZ    NODUMP              NO, ABEND QUIETLY                    XMN08430\n         SPACE 1                                                        XMN08440\n         ABEND (1),DUMP            ABEND WITH A DUMP                    XMN08450\n         SPACE 1                                                        XMN08460\nNODUMP   DS    0H                                                       XMN08470\n         ABEND (1)                 ABEND WITHOUT A DUMP                 XMN08480\n         SPACE 2                                                        XMN08490\n*********************************************************************** XMN08500\n*                                                                     * XMN08510\n*                                                                     * XMN08520\n*        ROUTINE TO FORCE AN ABEND DUMP WHEN REQUESTED BY THE         * XMN08530\n*        XPL PROGRAM BY MEANS OF THE STATEMENT:                       * XMN08540\n*                                                                     * XMN08550\n*        CALL  EXIT  ;                                                * XMN08560\n*                                                                     * XMN08570\n*                                                                     * XMN08580\n*********************************************************************** XMN08590\n         SPACE 2                                                        XMN08600\nUSEREXIT DS    0H                                                       XMN08610\n         STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08620\n         OI    FLAGS,DUMPBIT       FORCE A DUMP                         XMN08630\n         LA    1,USERABE           USER ABEND CODE                      XMN08640\n         B     ABEND               BRANCH TO ABEND                      XMN08650\n         EJECT                                                          XMN08660\n         SPACE 5                                                        XMN08670\n*********************************************************************** XMN08680\n*                                                                     * XMN08690\n*                                                                     * XMN08700\n*        DISPATCHER FOR ALL SERVICE REQUESTS FROM THE XPL PROGRAM     * XMN08710\n*                                                                     * XMN08720\n*                                                                     * XMN08730\n*********************************************************************** XMN08740\n         SPACE 2                                                        XMN08750\n         DROP  13                                                       XMN08760\n         USING ENTRY,SELF                                               XMN08770\nENTRY    DS    0H                  XPL PROGRAMS ENTER HERE              XMN08780\n         STM   0,3,SAVREG          SAVE REGISTERS USED BY XPLSM         XMN08790\n         STM   13,15,SAVREG+13*4                                        XMN08800\n         L     13,ASAVE            ADDRESS OF OS SAVE AREA              XMN08810\n         DROP  SELF                                                     XMN08820\n         USING SAVE,13                                                  XMN08830\n         SPACE 1                                                        XMN08840\n         LTR   SVCODE,SVCODE       CHECK THE SERVICE CODE FOR VALIDITY  XMN08850\n         BNP   BADCODE             SERVICE CODE MUST BE > 0             XMN08860\n         C     SVCODE,MAXCODE      AND < ENDSERV                        XMN08870\n         BH    BADCODE             GO ABEND                             XMN08880\n         SPACE 1                                                        XMN08890\nTABLE    B     TABLE(SVCODE)       GO DO THE SERVICE                    XMN08900\n         SPACE 1                                                        XMN08910\n         ORG   TABLE+GETC                                               XMN08920\n         B     GET                 READ INPUT FILE                      XMN08930\n         SPACE 1                                                        XMN08940\n         ORG   TABLE+PUTC                                               XMN08950\n         B     PUT                 WRITE OUTPUT FILE                    XMN08960\n         SPACE 1                                                        XMN08970\n         ORG   TABLE+TRC                                                XMN08980\n         B     EXIT                INITIATE TRACING  (NOP)\n         SPACE 1                                                        XMN09000\n         ORG   TABLE+UNTR                                               XMN09010\n         B     EXIT                TERMINATE TRACING (NOP)\n         SPACE 1                                                        XMN09030\n         ORG   TABLE+EXDMP                                              XMN09040\n         B     USEREXIT            TERMINATE WITH A CORE DUMP           XMN09050\n         SPACE 1                                                        XMN09060\n         ORG   TABLE+GTIME                                              XMN09070\n         B     GETIME              RETURN TIME AND DATE                 XMN09080\n         SPACE 1                                                        XMN09090\n         ORG   TABLE+RSVD1                                              XMN09100\n         B     REWIND              REWIND SEQUENTIAL FILES\n         SPACE 1                                                        XMN09120\n         ORG   TABLE+RSVD2                                              XMN09130\n         B     CPUTIMER           CLOCK_TRAP\n         SPACE 1                                                        XMN09150\n         ORG   TABLE+RSVD3                                              XMN09160\n         B     EXIT                INTERRUPT_TRAP    (NOP)              XMN09170\n         SPACE 1                                                        XMN09180\n         ORG   TABLE+RSVD4                                              XMN09190\n         B     EXIT                MONITOR           (NOP)\n         SPACE 1                                                        XMN09210\n         ORG   TABLE+RSVD5                                              XMN09220\n         B     EXIT                (UNUSED)                             XMN09230\n         SPACE 1                                                        XMN09240\n         ORG   TABLE+RSVD6                                              XMN09250\n         B     EXIT                (UNUSED)                             XMN09260\n         SPACE 2                                                        XMN09270\n*********************************************************************** XMN09280\n*                                                                     * XMN09290\n*                                                                     * XMN09300\n*        DYNAMICALLY GENERATE THE DISPATCHING TABLE ENTRIES FOR       * XMN09310\n*        FILE I/O SERVICES.                                           * XMN09320\n*                                                                     * XMN09330\n*                                                                     * XMN09340\n*********************************************************************** XMN09350\n         SPACE 2                                                        XMN09360\n&I       SETA  1                   LOOP INDEX                           XMN09370\n.DBR1    AIF   (&I GT &FILES).DBR2                                      XMN09380\n*                                  FINISHED ?                           XMN09390\n         ORG   TABLE+RD&I                                               XMN09400\n         B     READ                BRANCH TO FILE READ ROUTINE          XMN09410\n         ORG   TABLE+WRT&I                                              XMN09420\n         B     WRITE               BRANCH TO FILE WRITE ROUTINE         XMN09430\n&I       SETA  &I+1                INCREMENT COUNTER                    XMN09440\n         AGO   .DBR1               LOOP BACK                            XMN09450\n.DBR2    ANOP                                                           XMN09460\n         SPACE 2                                                        XMN09470\n         ORG   TABLE+ENDSERV       RESET PROGRAM COUNTER                XMN09480\n         SPACE 2                                                        XMN09490\n*********************************************************************** XMN09500\n*                                                                     * XMN09510\n*                                                                     * XMN09520\n*        COMMON EXIT ROUTINE FOR RETURN TO THE XPL PROGRAM            * XMN09530\n*                                                                     * XMN09540\n*                                                                     * XMN09550\n*********************************************************************** XMN09560\n         SPACE 2                                                        XMN09570\nEXIT     DS    0H                                                       XMN09580\n         LM    0,3,SAVREG          RESTORE REGISTERS                    XMN09590\n         LM    13,15,SAVREG+13*4                                        XMN09600\n         DROP  13                                                       XMN09610\n         USING ENTRY,SELF                                               XMN09620\n         SPACE 1                                                        XMN09630\n         BR    CBR                 RETURN TO THE XPL PROGRAM            XMN09640\n         SPACE 1                                                        XMN09650\n         DROP  SELF                                                     XMN09660\n         USING SAVE,13                                                  XMN09670\n         SPACE 2                                                        XMN09680\n*********************************************************************** XMN09690\n*                                                                     * XMN09700\n*        ROUTINE TO ABEND IN CASE OF BAD SERVICE CODES                * XMN09710\n*                                                                     * XMN09720\n*********************************************************************** XMN09730\n         SPACE 2                                                        XMN09740\nBADCODE  STM   0,2,ABEREGS         SAVE REGISTERS                       XMN09750\n         LA    1,CODEABE           BAD SERVICE CODE ABEND               XMN09760\n         B     ABEND               GO ABEND                             XMN09770\n         EJECT                                                          XMN09780\n         SPACE 5                                                        XMN09790\n*********************************************************************** XMN09800\n*                                                                     * XMN09810\n*                                                                     * XMN09820\n*        INPUT ROUTINE FOR READING SEQUENTIAL INPUT FILES             * XMN09830\n*                                                                     * XMN09840\n*                                                                     * XMN09850\n*        INPUT TO THIS ROUTINE IS:                                    * XMN09860\n*                                                                     * XMN09870\n*      PARM1   ADDRESS OF THE NEXT AVAILABLE SPACE IN THE PROGRAMS    * XMN09880\n*              DYNAMIC STRING AREA  (FREEPOINT)                       * XMN09890\n*                                                                     * XMN09900\n*      SVCODE  THE SERVICE CODE FOR INPUT                             * XMN09910\n*                                                                     * XMN09920\n*      PARM2   A SUBCODE DENOTING WHICH INPUT FILE,                   * XMN09930\n*              INPUT(I),     I = 0,1, ... ,&INPUTS                    * XMN09940\n*                                                                     * XMN09950\n*        THE ROUTINE RETURNS:                                         * XMN09960\n*                                                                     * XMN09970\n*      PARM1   A STANDARD XPL STRING DESCRIPTOR POINTING AT THE INPUT * XMN09980\n*              RECORD WHICH IS NOW AT THE TOP OF THE STRING AREA      * XMN09990\n*                                                                     * XMN10000\n*      SVCODE  THE NEW VALUE FOR FREEPOINT, UPDATED BY THE LENGTH OF  * XMN10010\n*              THE RECORD JUST READ IN                                * XMN10020\n*                                                                     * XMN10030\n*                                                                     * XMN10040\n*        A STANDARD XPL STRING DESCRIPTOR HAS:                        * XMN10050\n*                                                                     * XMN10060\n*        BITS  0-7                 (LENGTH - 1) OF THE STRING         * XMN10070\n*        BITS  8-31                ABSOLUTE ADDRESS OF THE STRING     * XMN10080\n*                                                                     * XMN10090\n*                                                                     * XMN10100\n*                                                                     * XMN10110\n*********************************************************************** XMN10120\n         SPACE 2                                                        XMN10130\nGET      DS    0H                                                       XMN10140\n         LA    SVCODE,&INPUTS      CHECK THAT THE SUBCODE IS VALID      XMN10150\n         LTR   PARM2,PARM2         SUBCODE MUST BE >= 0                 XMN10160\n         BM    BADGET                                                   XMN10170\n         CR    PARM2,SVCODE        AND <= &INPUTS                       XMN10180\n         BH    BADGET              ILLEGAL SUBCODE                      XMN10190\n         SLL   PARM2,2             SUBCODE*4                            XMN10200\n         L     3,GETDCBS(PARM2)    ADDRESS OF DCB FOR THE FILE          XMN10210\n         USING IHADCB,3                                                 XMN10220\n         NC    DCBDDNAM,DCBDDNAM   HAS THE FILE BEEN PERMANENTLY        XMN10230\n*                                  CLOSED ?                             XMN10240\n         BZ    RETNEOF             YES, SO RETURN NULL STRING\n         SPACE 1                                                        XMN10260\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN10270\n         BO    GETOPEN             YES                                  XMN10280\n         LA    15,4*2              IF SUBCODE > 2 THEN CLOSE OUTPUT DCB\n         CR    PARM2,15\n         BL    GOPEN\n         L     15,PUTDCBS+4(PARM2) ADDRESS OF DCB FOR THE FILE\n         ST    15,OCDCB            STORE FOR CLOSE SVC\n         MVI   OCDCB,X'80'         FLAG END OF LIST\n         CLOSE ,MF=(E,OCDCB)\nGOPEN    ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC       XMN10290\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST           XMN10300\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN10310\n         LR    2,3                 COPY DCB ADDRESS                     XMN10320\n         TM    DCBOFLGS,OPENBIT    WAS THE FILE OPENED SUCCESSFULLY ?   XMN10330\n         BZ    PCLOSE              NO, MARK FILE PERMANENTLY CLOSED AND XMN10340\n*                                  RETURN EOD INDICATION TO THE PROGRAM XMN10350\n         SPACE 2                                                        XMN10360\nGETOPEN  DS    0H                                                       XMN10370\n         GET   (3)                 LOCATE MODE GET                      XMN10380\n         SPACE 1                                                        XMN10390\n*********************************************************************** XMN10400\n*                                                                     * XMN10410\n*        USING LOCATE MODE, THE ADDRESS OF THE NEXT INPUT BUFFER      * XMN10420\n*        IS RETURNED IN R1                                            * XMN10430\n*                                                                     * XMN10440\n*********************************************************************** XMN10450\n         SPACE 1                                                        XMN10460\n         L     2,SAVREG+PARM2*4    IS THE FILE SYSIN?\n         C     2,F1\n         BH    NOTSYSIN            NO, SO BRANCH\n         CLC   EOFCHARS,0(1)       YES, SO '%EOF' IN COLS. 1 - 4       *\n                                   SIMULATES END-OF-FILE.\n         BE    RETNEOF\nNOTSYSIN L     2,SAVREG+PARM1*4    FETCH THE STRING DESCRIPTOR\n         LA    2,0(,2)             ADDRESS PART ONLY                    XMN10480\n         LH    3,DCBLRECL          RECORD LENGTH                        XMN10490\n         DROP  3                                                        XMN10500\n         S     3,F1                LENGTH - 1                           XMN10510\n         EX    3,GETMOVE           MOVE THE CHARACTERS                  XMN10520\n         ST    2,SAVREG+PARM1*4    BUILD UP A STRING DESCRIPTOR         XMN10530\n         STC   3,SAVREG+PARM1*4    LENGTH FIELD                         XMN10540\n         LA    2,1(2,3)            NEW FREE POINTER                     XMN10550\n         ST    2,SAVREG+SVCODE*4                                        XMN10560\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN10570\n         SPACE 2                                                        XMN10580\n*********************************************************************** XMN10590\n*                                                                     * XMN10600\n*        RETURN A NULL STRING DESCRIPTOR AS AN END OF FILE            * XMN10610\n*        INDICATION THE FIRST TIME AN INPUT REQUEST FIND THE          * XMN10620\n*        END OF DATA CONDITION                                        * XMN10630\n*                                                                     * XMN10640\n*********************************************************************** XMN10650\n         SPACE 2                                                        XMN10660\nRETNEOF  DS    0H                                                       XMN10670\n         MVC   SAVREG+SVCODE*4(4),SAVREG+PARM1*4                        XMN10680\n*                                  RETURN FREEPOINT UNTOUCHED           XMN10690\n         XC    SAVREG+PARM1*4(4),SAVREG+PARM1*4                         XMN10700\n*                                  RETURN A NULL STRING DESCRIPTOR      XMN10710\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN10720\n         SPACE 2                                                        XMN10730\n*********************************************************************** XMN10740\n*                                                                     * XMN10750\n*        ROUTINE TO ABEND IN CASE OF AN INVALID SUBCODE               * XMN10760\n*                                                                     * XMN10770\n*********************************************************************** XMN10780\n         SPACE 2                                                        XMN10790\nBADGET   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN10800\n         LA    1,GFABE             INVALID GET SUBCODE                  XMN10810\n         B     INERR               GO ABEND                             XMN10820\n         EJECT                                                          XMN10830\n         SPACE 5                                                        XMN10840\n*********************************************************************** XMN10850\n*                                                                     * XMN10860\n*                                                                     * XMN10870\n*                                                                     * XMN10880\n*        ROUTINE FOR WRITING SEQUENTIAL OUTPUT FILES                  * XMN10890\n*                                                                     * XMN10900\n*                                                                     * XMN10910\n*        INPUT TO THIS ROUTINE:                                       * XMN10920\n*                                                                     * XMN10930\n*      PARM1   XPL STRING DESCRIPTOR OF THE STRING TO BE OUTPUT       * XMN10940\n*                                                                     * XMN10950\n*      PARM2   SUBCODE INDICATING  OUTPUT(I),  I = 0,1, ... ,&OUTPUTS * XMN10960\n*                                                                     * XMN10970\n*      SVCODE  THE SERVICE CODE FOR OUTPUT                            * XMN10980\n*                                                                     * XMN10990\n*                                                                     * XMN11000\n*        THE STRING NAMED BY THE DESCRIPTOR IS PLACED IN THE NEXT     * XMN11010\n*        OUTPUT BUFFER OF THE SELECTED FILE.  IF THE STRING IS        * XMN11020\n*        SHORTER THAN THE RECORD LENGTH OF THE FILE THEN THE          * XMN11030\n*        REMAINDER OF THE RECORD IS PADDED WITH BLANKS.  IF THE       * XMN11040\n*        STRING IS LONGER THAN THE RECORD LENGTH OF THE FILE          * XMN11050\n*        THEN IT IS TRUNCATED ON THE RIGHT TO FIT.  IF THE SUBCODE    * XMN11060\n*        SPECIFIES OUTPUT(0) THEN A SINGLE BLANK IS CONCATENATED      * XMN11070\n*        ON TO THE FRONT OF THE STRING TO SERVE AS CARRIAGE CONTROL.  * XMN11080\n*                                                                     * XMN11090\n*                                                                     * XMN11100\n*********************************************************************** XMN11110\n         SPACE 2                                                        XMN11120\nPUT      DS    0H                                                       XMN11130\n         LTR   PARM2,PARM2         CHECK SUBCODE FOR VALIDITY           XMN11140\n         BM    BADPUT              SUBCODE MUST BE >= 0                 XMN11150\n         LA    SVCODE,&OUTPUTS                                          XMN11160\n         CR    PARM2,SVCODE        AND <= &OUTPUTS                      XMN11170\n         BH    BADPUT                                                   XMN11180\n         ST    PARM1,MOVEADR       SAVE THE STRING DESCRIPTOR           XMN11190\n         SLL   PARM2,2             SUBCODE*4                            XMN11200\n         L     3,PUTDCBS(PARM2)    GET THE DCB ADDRESS                  XMN11210\n         USING IHADCB,3                                                 XMN11220\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN11230\n         BO    PUTOPEN             YES, GO DO THE OUTPUT                XMN11240\n         LA    15,4*3              IF SUBCODE > 3 THEN CLOSE INPUT DCB\n         CR    PARM2,15\n         BL    POPEN\n         L     15,GETDCBS-4(PARM2) ADDRESS OF DCB FOR THE FILE\n         ST    15,OCDCB            STORE FOR CLOSE SVC\n         MVI   OCDCB,X'80'         FLAG END OF LIST\n         CLOSE ,MF=(E,OCDCB)\nPOPEN    ST    3,OCDCB             STORE DCB ADDRESS FOR THE OPEN SVC   XMN11250\n         MVI   OCDCB,X'8F'         FLAG END OF PARAMETER LIST AND SET   XMN11260\n*                                  FLAG INDICATING OPENING FOR OUTPUT   XMN11270\n         SPACE 1                                                        XMN11280\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN11290\n         SPACE 1                                                        XMN11300\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFULL ?           XMN11310\n         BZ    OUTSYNAD            NO, OUTPUT SYNAD ERROR               XMN11320\n         SPACE 1                                                        XMN11330\nPUTOPEN  DS    0H                                                       XMN11340\n         PUT   (3)                 LOCATE MODE PUT                      XMN11350\n         SPACE 1                                                        XMN11360\n*********************************************************************** XMN11370\n*                                                                     * XMN11380\n*        USING LOCATE MODE, THE ADDRESS OF THE NEXT OUTPUT BUFFER     * XMN11390\n*        IS RETURNED IN  R1.                                          * XMN11400\n*                                                                     * XMN11410\n*********************************************************************** XMN11420\n         SPACE 1                                                        XMN11430\n         SR    15,15               CLEAR REGISTER 15                    XMN11440\n         C     15,MOVEADR          IS THE STRING NULL (DESCRIPTOR = 0)  XMN11450\n         BE    NULLPUT             YES, SO PUT OUT A BLANK RECORD       XMN11460\n         IC    15,MOVEADR          LENGTH-1 OF THE STRING               XMN11470\n         LA    14,1(15)            REAL LENGTH OF THE STRING            XMN11480\n         LH    0,DCBLRECL          RECORD LENGTH OF THE FILE            XMN11490\n         LTR   PARM2,PARM2         CHECK SUBCODE FOR OUTPUT(0)          XMN11500\n         BNZ   PUT1                NOT OUTPUT(0)                        XMN11510\n         LA    14,1(,14)           INCREASE REAL LENGTH BY ONE FOR      XMN11520\n*                                  CARRIAGE CONTROL                     XMN11530\nPUT1     SR    0,14                RECORD LENGTH - REAL LENGTH          XMN11540\n         BM    TOOLONG             RECORD LENGTH < REAL LENGTH          XMN11550\n         BZ    MATCH               RECORD LENGTH = REAL LENGTH          XMN11560\n*                                  RECORD LENGTH > REAL LENGTH          XMN11570\n         OI    FLAGS,SFILLBIT+LFILLBIT                                  XMN11580\n*                                  INDICATE PADDING REQUIRED            XMN11590\n         S     0,F1                RECORD LENGTH - REAL LENGTH - 1      XMN11600\n         BP    LONGMOVE            RECORD LENGTH - REAL LENGTH > 1      XMN11610\n         NI    FLAGS,ALLBITS-LFILLBIT                                   XMN11620\n*                                  RECORD LENGTH - REAL LENGTH = 1      XMN11630\n*                                  IS A SPECIAL CASE                    XMN11640\nLONGMOVE ST    0,FILLENG           SAVE LENGTH FOR PADDING OPERATION    XMN11650\n         B     MOVEIT              GO MOVE THE STRING                   XMN11660\n         SPACE 1                                                        XMN11670\nTOOLONG  LH    15,DCBLRECL         REPLACE THE STRING LENGTH            XMN11680\n*                                  WITH THE RECORD LENGTH               XMN11690\n         S     15,F1               RECORD LENGTH - 1 FOR THE MOVE       XMN11700\nMATCH    NI    FLAGS,ALLBITS-SFILLBIT-LFILLBIT                          XMN11710\n*                                  INDICATE NO PADDING REQUIRED         XMN11720\n         SPACE 1                                                        XMN11730\nMOVEIT   LTR   PARM2,PARM2         CHECK FOR OUTPUT(0)                  XMN11740\n         BNZ   MOVEIT2             OUTPUT(0) IS A SPECIAL CASE          XMN11750\n         MVI   0(1),C' '           PROVIDE BLANK CARRIAGE CONTROL       XMN11760\n         LA    1,1(,1)             INCREMENT BUFFER POINTER             XMN11770\nMOVEIT2  L     2,MOVEADR           STRING DESCRIPTOR                    XMN11780\n         LA    2,0(,2)             ADDRESS PART ONLY                    XMN11790\n         EX    15,MVCSTRNG         EXECUTE A MVC INSTRUCTION            XMN11800\n         TM    FLAGS,SFILLBIT      IS PADDING REQUIRED ?                XMN11810\n         BZ    EXIT                NO, RETURN TO THE XPL PROGRAM        XMN11820\n         SPACE 1                                                        XMN11830\n         AR    1,15                ADDRESS TO START PADDING - 1         XMN11840\n         MVI   1(1),C' '           START THE PAD                        XMN11850\n         TM    FLAGS,LFILLBIT      IS MORE PADDING REQUIRED ?           XMN11860\n         BZ    EXIT                NO, RETURN TO XPL PROGRAM            XMN11870\n         L     15,FILLENG          LENGTH OF PADDING NEEDED             XMN11880\n         S     15,F1               LESS ONE FOR THE MOVE                XMN11890\n         EX    15,MVCBLANK         EXECUTE MVC TO FILL IN BLANKS        XMN11900\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN11910\n         SPACE 1                                                        XMN11920\n*********************************************************************** XMN11930\n*                                                                     * XMN11940\n*        FOR A NULL STRING OUTPUT A BLANK RECORD                      * XMN11950\n*                                                                     * XMN11960\n*********************************************************************** XMN11970\n         SPACE 1                                                        XMN11980\nNULLPUT  LH    15,DCBLRECL         RECORD LENGTH                        XMN11990\n         S     15,F2               LESS TWO FOR THE MOVES               XMN12000\n         MVI   0(1),C' '           INITIAL BLANK                        XMN12010\n         EX    15,MVCNULL          EXECUTE MVC TO FILL IN THE BLANKS    XMN12020\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN12030\n         SPACE 1                                                        XMN12040\n         DROP  3                                                        XMN12050\n         SPACE 1                                                        XMN12060\n*********************************************************************** XMN12070\n*                                                                     * XMN12080\n*        ROUTINE TO ABEND IN CASE OF AN INVALID SERVICE CODE          * XMN12090\n*                                                                     * XMN12100\n*********************************************************************** XMN12110\n         SPACE 1                                                        XMN12120\nBADPUT   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN12130\n         LA    1,PFABE             INVALID PUT SUBCODE                  XMN12140\n         B     INERR               GO ABEND                             XMN12150\n         EJECT                                                          XMN12160\n         SPACE 5                                                        XMN12170\n*********************************************************************** XMN12180\n*                                                                     * XMN12190\n*                                                                     * XMN12200\n*                                                                     * XMN12210\n*        READ ROUTINE FOR DIRECT ACCESS FILE I/O                      * XMN12220\n*                                                                     * XMN12230\n*                                                                     * XMN12240\n*        INPUT TO THIS ROUTINE IS:                                    * XMN12250\n*                                                                     * XMN12260\n*      PARM1   CORE ADDRESS TO READ THE RECORD INTO                   * XMN12270\n*                                                                     * XMN12280\n*      SVCODE  SERVICE CODE INDICATING WHICH FILE TO USE              * XMN12290\n*                                                                     * XMN12300\n*      PARM2   RELATIVE RECORD NUMBER   0,1,2,3,...                   * XMN12310\n*                                                                     * XMN12320\n*                                                                     * XMN12330\n*                                                                     * XMN12340\n*********************************************************************** XMN12350\n         SPACE 2                                                        XMN12360\nREAD     DS    0H                                                       XMN12370\n         ST    PARM1,RDECB+12      STORE ADDRESS                        XMN12380\n         L     3,ARWDCBS-FILEORG(SVCODE)                                XMN12390\n*                                  ADDRESS OF THE DCB FOR THIS FILE     XMN12400\n         USING IHADCB,3                                                 XMN12410\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN12420\n         BO    READOPEN            YES, GO READ                         XMN12430\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC       XMN12440\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST           XMN12450\n*                                  AND INDICATE OPEN FOR INPUT          XMN12460\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN12470\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFUL ?            XMN12480\n         BZ    FILESYND            NO, SYNAD ERROR                      XMN12490\n         SPACE 1                                                        XMN12500\nREADOPEN DS    0H                                                       XMN12510\n         TM    DCBDEVT,TAPEBITS    IS THE FILE ON MAGNETIC TAPE         XMN12520\n         DROP  3                                                        XMN12530\n         BO    READTP              YES, GO FORM RECORD INDEX FOR TAPE   XMN12540\n         SLA   PARM2,16            FORM  TTRZ  ADDRESS                  XMN12550\n         BNZ   RDN0                BLOCK ZERO IS A SPECIAL CASE         XMN12560\n         LA    PARM2,1             FUNNY ADDRESS FOR BLOCK ZERO         XMN12570\n         B     READTP              GO DO THE READ                       XMN12580\nRDN0     O     PARM2,TTRSET        SPECIFY LOGICAL RECORD 1             XMN12590\nREADTP   ST    PARM2,TTR           SAVE RECORD POINTER                  XMN12600\n         SPACE 1                                                        XMN12610\n         POINT (3),TTR             POINT AT THE RECORD TO BE READ       XMN12620\n         READ  RDECB,SF,(3),0,'S'  READ THE RECORD INTO CORE            XMN12630\n         CHECK RDECB               WAIT FOR THE READ TO COMPLETE        XMN12640\n         SPACE 1                                                        XMN12650\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN12660\n         EJECT                                                          XMN12670\n         SPACE 5                                                        XMN12680\n*********************************************************************** XMN12690\n*                                                                     * XMN12700\n*                                                                     * XMN12710\n*                                                                     * XMN12720\n*        WRITE ROUTINE FOR DIRECT ACCESS FILE I/O                     * XMN12730\n*                                                                     * XMN12740\n*                                                                     * XMN12750\n*        INPUT TO THIS ROUTINE IS:                                    * XMN12760\n*                                                                     * XMN12770\n*      PARM1   CORE ADDRESS TO READ THE RECORD FROM                   * XMN12780\n*                                                                     * XMN12790\n*      SVCODE  SERVICE CODE INDICATING WHICH FILE TO USE              * XMN12800\n*                                                                     * XMN12810\n*      PARM2   RELATIVE RECORD NUMBER   0,1,2, ...                    * XMN12820\n*                                                                     * XMN12830\n*                                                                     * XMN12840\n*                                                                     * XMN12850\n*********************************************************************** XMN12860\n         SPACE 2                                                        XMN12870\nWRITE    DS    0H                                                       XMN12880\n         ST    PARM1,WDECB+12      SAVE CORE ADDRESS                    XMN12890\n         L     3,ARWDCBS-FILEORG(SVCODE)                                XMN12900\n*                                  GET THE DCB ADDRESS                  XMN12910\n         USING IHADCB,3                                                 XMN12920\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN12930\n         BO    WRTOPEN             YES, GO WRITE                        XMN12940\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC       XMN12950\n         MVI   OCDCB,X'8F'         FLAG END OF ARGUMENT LIST AND        XMN12960\n*                                  INDICATE OPENING FOR OUTPUT          XMN12970\n         SPACE 1                                                        XMN12980\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN12990\n         SPACE 1                                                        XMN13000\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFUL ?            XMN13010\n         BZ    FILESYND            NO,SYNAD ERROR                       XMN13020\n         SPACE 1                                                        XMN13030\nWRTOPEN  DS    0H                                                       XMN13040\n         TM    DCBDEVT,TAPEBITS    IS THE FILE ON MAGNETIC TAPE         XMN13050\n         DROP  3                                                        XMN13060\n         BO    WRITP               YES, GO FORM RECORD INDEX FOR TAPE   XMN13070\n         SLA   PARM2,16            FORM TTRZ ADDRESS FOR DIRECT ACCESS  XMN13080\n         BNZ   WRDN0               RECORD ZERO IS A SPECIAL CASE        XMN13090\n         LA    PARM2,1             FUNNY ADDRESS FOR RECORD ZERO        XMN13100\n         B     WRITP               GO DO THE WRITE                      XMN13110\nWRDN0    O     PARM2,TTRSET        OR IN RECORD NUMBER BIT              XMN13120\nWRITP    ST    PARM2,TTR           SAVE RECORD POINTER                  XMN13130\n         SPACE 1                                                        XMN13140\n         POINT (3),TTR             POINT AT THE DESIRED RECORD          XMN13150\n         WRITE WDECB,SF,(3),0,'S'  WRITE THE RECORD OUT                 XMN13160\n         CHECK WDECB               WAIT FOR THE WRITE TO FINISH         XMN13170\n         SPACE 1                                                        XMN13180\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN13190\n         EJECT                                                          XMN13200\n         SPACE 5                                                        XMN13210\n*********************************************************************** XMN13660\n*                                                                     * XMN13670\n*                                                                     * XMN13680\n*                                                                     * XMN13690\n*        TIME AND DATE FUNCTIONS                                      * XMN13700\n*                                                                     * XMN13710\n*                                                                     * XMN13720\n*        RETURNS TIME OF DAY IN HUNDREDTHS OF A SECOND IN REGISTER    * XMN13730\n*        PARM1  AND THE DATE IN THE FORM  YYDDD IN REGISTER SVCODE    * XMN13740\n*                                                                     * XMN13750\n*                                                                     * XMN13760\n*********************************************************************** XMN13770\n         SPACE 2                                                        XMN13780\nGETIME   TIME  BIN                 REQUEST THE TIME                     XMN13790\n         ST    0,SAVREG+PARM1*4    RETURN IN REGISTER PARM1             XMN13800\n         ST    1,DTSV+4            STORE THE DATE IN PACKED DECIMAL     XMN13810\n         CVB   1,DTSV              CONVERT IT TO BINARY                 XMN13820\n         ST    1,SAVREG+SVCODE*4   RETURN DATE IN REGISTER SVCODE       XMN13830\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN13840\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        REWIND SEQUENTIAL FILES                                      *\n*                                                                     *\n*                                                                     *\n*        INPUT TO THIS ROUTINE:                                       *\n*                                                                     *\n*      PARM1 = 0   => INPUT FILE                                      *\n*            = 1   => OUTPUT FILE                                     *\n*                                                                     *\n*      PARM2       SUBCODE DENOTING FILE NUMBER I OF                  *\n*                  INPUT(I) OR OUTPUT(I), I = 0,1,2,...               *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nREWIND   DS    0H                  REWIND A SEQUENTIAL FILE\n         SLL   PARM2,2             SUBCODE*4\n         LTR   PARM1,PARM1         INPUT FILE?\n         BZ    INFILE              YES - SO BRANCH\n         L     3,PUTDCBS(PARM2)    ADDRESS OF OUTPUT FILE DCB\n         B     CLOSE\nINFILE   L     3,GETDCBS(PARM2)    ADDRESS OF INPUT FILE DCB\n         USING IHADCB,3\nCLOSE    TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN?\n         BZ    BUFFREE             NO, GO FREE ITS BUFFER SPACE\n         ST    3,OCDCB             STORE DCB ADDRESS FOR CLOSE SVC\n         MVI   OCDCB,X'80'         FLAG END OF LIST\n         CLOSE ,MF=(E,OCDCB)       CLOSE THE SEQUENTIAL FILE\nBUFFREE  TM    DCBBUFCB+3,1        BUFFERS ALLOCATED?\n         BO    EXIT                NO, RETURN TO THE XPL PROGRAM\n      FREEPOOL (3)                 RELEASE BUFFERS\n         DROP  3\n         B     EXIT                RETURN TO THE XPL PROGRAM\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        CLOCK_TRAP                                                   *\n*                                                                     *\n*                                                                     *\n*        INPUT TO THIS ROUTINE:                                       *\n*                                                                     *\n*      PARM1 = 0        START THE CPU TIMER.                          *\n*            > 0        RETURN ELAPSED TIME IN 0.01 SECOND UNITS.     *\n*            < 0        CANCEL CPU TIMER AND RETURN ELAPSED TIME IN   *\n*                       0.01 SECOND UNITS.                            *\n*                                                                     *\n*      PARM2            USED ONLY IF PARM1 = 0;   THE ADDRESS OF AN   *\n*                       8-BYTE FULLWORD-ALLIGNED CORE AREA            *\n*                       CONTAINING:                                   *\n*                       BYTES 0 - 3    INITIAL TIMER VALUE IN .01 SEC *\n*                       BYTES 4 - 7    ADDRESS OF TIMER COMPLETION    *\n*                                      ROUTINE;  IF ZERO THEN NO      *\n*                                      ACTION IS TAKEN ON TIMER       *\n*                                      COMPLETION.                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCPUTIMER DS 0H\n         LTR   PARM1,PARM1        IS PARM1 ZERO?\n         BP    LAPSE              NO, GO RETURN ELAPSED TIME.\n         BM    STOPCLOC           NO, GO TO TIMER CANCEL ROUTINE.\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        MOVE INFORMATION POINTED TO BY PARM2 INTO THE SUBMONITOR.    *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         MVC   TIMEST(4),0(PARM2) INITIAL TIMER VALUE.\n         MVC   TIMETRAP(4),4(PARM2) ADDR. OF XPL TIMEOUT ROUTINE\n         NC    TIMETRAP,TIMETRAP  IS TIMETRAP ZERO?\n         BZ    NOTRAP             YES, SO NO TIMER COMPLETION ROUTINE.\n         STM   4,11,SAVREG+4*4    NO, SO PREPARE BY PLANTING XPL GPRS.\n*        SET THE ALARM AND START THE CLOCK TICKING:\n        STIMER TASK,TIMEOUT,BINTVL=TIMEST\n         L     1,16               CVT ADDR FROM ABSOLUTE LOCATION 16\n         L     1,0(,1)            TCB ADDRESS POINTER FROM CVT\n         L     1,4(,1)            ADDRESS OF CURRENT TCB\n         L     1,120(,1)          TQE ADDR FROM TCB\n         LA    1,28(,1)           ADDRESS OF RB LINK IN TQE\n         ST    1,INTLOC           PLANT FOR INTERRUPT\n         SPACE\n         B     EXIT               RETURN TO THE XPL PROGRAM.\n         SPACE\n*        START THE CLOCK TICKING, BUT DO NOT SET THE ALARM.\nNOTRAP  STIMER TASK,BINTVL=TIMEST\n         B     EXIT               RETURN TO THE XPL PROGRAM.\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        RETURN ELAPSED CPU TIME.  DO NOT STOP CPU TIMER.             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nLAPSE    TTIMER\n         B     ELAPSED            GO RETURN ELAPSED TIME.\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        CANCEL CPU TIMER AND RETURN ELAPSED INTERVAL.                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSTOPCLOC TTIMER CANCEL RETURNS # OF CLOCK TICKS (26.04166 USEC) IN GPR0\nELAPSED  SRDL  0,32               CONVERT TO UNITS OF 0.01 SECONDS.\n         LA    2,384              (CONVERSION FACTOR)\n         DR    0,2\n*        SUBTRACT WHAT'S LEFT FROM ORIGINAL TIMER ESTIMATE\n         L     2,TIMEST           ORIGINAL TIMER ESTIMATE\n         SR    2,1                ELAPSED TIME\n         ST    2,SAVREG+4*PARM1   RETURN ELAPSED TIME IN REGISTER PARM1\n         B     EXIT               RETURN TO THE XPL PROGRAM.\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        BRANCH TO THE XPL TIMER COMPLETION ROUTINE                   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nTIMEOUT  DS    0H                 SYSTEM ENTERS HERE.\n         DROP  13\n         USING TIMEOUT,SELF\n         SAVE  (14,12)            SAVE REGISTERS\n         ST    13,TIMESAVE        STORE ADDR OF SYSTEM SAVE AREA.\n         L     13,ASAVE\n         DROP  SELF\n         USING SAVE,13\n*        WE RETURN THE ADDRESS OF THE INTERRUPTED INSTRUCTION IN GPR3.\n         L     3,INTLOC           ADDRESS OF RB LINK\n         L     3,0(,3)            ADDRESS OF PRB\n         L     3,20(,3)           WORD2 OF OLD PSW AT INTERRUPT\n         LA    3,0(,3)            CLEAR THE HIGH ORDER BYTE.\n         MVC   SAVREG+CBR*4(4),TIMETRAP PLANT ADDRESS OF TIMEOUT RTN.\n         LM    4,15,SAVREG+4*4    RESTORE THE XPL REGISTERS.\n         DROP  13\n         USING ENTRY,SELF\n         BALR  CBR,CBR            CALL USER'S ROUTINE.\n         L     13,TIMESAVE        RESTORE REGISTERS & RETURN TO SYSTEM.\n        RETURN (14,12),T,RC=0\n         DROP  SELF\n         USING SAVE,13\n         EJECT                                                          XMN13850\n         SPACE 5                                                        XMN13860\n*********************************************************************** XMN14180\n*                                                                     * XMN14190\n*                                                                     * XMN14200\n*                                                                     * XMN14210\n*        DATA AREA FOR THE SUBMONITOR                                 * XMN14220\n*                                                                     * XMN14230\n*                                                                     * XMN14240\n*********************************************************************** XMN14250\n         SPACE 2                                                        XMN14260\n         DS    0F                                                       XMN14270\nASAVE    DC    A(SAVE)             ADDRESS OF OS SAVE AREA              XMN14280\nABASE1   DC    A(BASE1)            BASE ADDRESS FOR INITIALIZATION      XMN14290\nMAXCODE  DC    A(ENDSERV-4)        LARGEST VALID SERVICE CODE           XMN14300\nRTNSV    DC    F'0'                SAVE COMPLETION CODE RETURNED        XMN14320\n*                                  BY THE XPL PROGRAM                   XMN14330\nABESAVE  DS    F                   SAVE ABEND CODE DURING CLOSE         XMN14340\nABEREGS  DS    3F                  SAVE PROGRAMS REGS 0-2 BEFORE ABEND  XMN14350\nTTR      DC    F'0'                TTRZ ADDRESS FOR READ AND WRITE      XMN14360\nTTRSET   DC    X'00000100'         ADDRESS CONSTANT FOR TTRZ            XMN14370\nFLAGS    DC    X'00'               SUBMONITOR CONTROL FLAGS             XMN14380\nSAVREG   DC    16F'0'              SAVE AREA FOR THE SUBMONITOR         XMN14390\n         DS    0D                                                       XMN14400\nDTSV     DC    PL8'0'              WORK AREA FOR CONVERTING DATE        XMN14410\nTIMEST   DS    F                  HOLDS INTERVAL VALUE FOR CPU TIMER\nTIMETRAP DS    F                  ADDRESS OF XPL TIMEOUT ROUTINE.\nINTLOC   DS F                     ADDR OF WORD2 OF OPSW IF TIMER       *\n                                  INTERRUPT OCCURS.\nTIMESAVE DS F                     SAVES ADDR OF SYSTEM SAVE AREA FOR   *\n                                  ASYNCHRONOUS TIMER EXIT ROUTINE.\nEOFCHARS DC    CL4'%EOF'           SENTINEL SIMULATING ENDFILE IN SYSIN\n         SPACE 2                                                        XMN14490\n*********************************************************************** XMN14500\n*                                                                     * XMN14510\n*                                                                     * XMN14520\n*        DCB ADDRESS TABLE FOR ALL I/O ROUTINES                       * XMN14530\n*                                                                     * XMN14540\n*                                                                     * XMN14550\n*        THE FOUR SETS OF DCB ADDRESSES HEADED BY  'GETDCBS',         * XMN14560\n*        'PUTDCBS', 'ARWDCBS', AND 'PGMDCB' MUST BE CONTIGUOUS        * XMN14570\n*        AND END WITH 'PGMDCB'.  THESE LISTS ARE USED AT JOB END      * XMN14580\n*        TO CLOSE ALL FILES BEFORE RETURNING TO OS                    * XMN14590\n*                                                                     * XMN14600\n*                                                                     * XMN14610\n*        DCB ADDRESSES FOR INPUT FILES:                               * XMN14620\n*                                                                     * XMN14630\n*                                                                     * XMN14640\n*********************************************************************** XMN14650\n         SPACE 2                                                        XMN14660\n         PRINT NOGEN                                                    XMN14670\n         SPACE 1                                                        XMN14680\nGETDCBS  DS    0F                                                       XMN14690\n&I       SETA  0                                                        XMN14700\n.GD1     AIF   (&I GT &INPUTS).GD2                                      XMN14710\n         DC    A(INPUT&I)                                               XMN14720\n&I       SETA  &I+1                                                     XMN14730\n         AGO   .GD1                                                     XMN14740\n.GD2     ANOP                                                           XMN14750\n         SPACE 1                                                        XMN14760\n*********************************************************************** XMN14770\n*                                                                     * XMN14780\n*        DCB ADDRESSES FOR OUTPUT FILES                               * XMN14790\n*                                                                     * XMN14800\n*********************************************************************** XMN14810\n         SPACE 1                                                        XMN14820\nPUTDCBS  DS    0F                                                       XMN14830\n         SPACE 1                                                        XMN14840\n&I       SETA  0                                                        XMN14850\n.PD1     AIF   (&I GT &OUTPUTS).PD2                                     XMN14860\n         DC    A(OUTPUT&I)                                              XMN14870\n&I       SETA  &I+1                                                     XMN14880\n         AGO   .PD1                                                     XMN14890\n.PD2     ANOP                                                           XMN14900\n         SPACE 1                                                        XMN14910\n*********************************************************************** XMN14920\n*                                                                     * XMN14930\n*        DCB ADDRESS FOR DIRECT ACCESS FILES                          * XMN14940\n*                                                                     * XMN14950\n*********************************************************************** XMN14960\n         SPACE 1                                                        XMN14970\nARWDCBS  DS    0F                                                       XMN14980\n         SPACE 1                                                        XMN14990\n&I       SETA  1                                                        XMN15000\n.DA1     AIF   (&I GT &FILES).DA2                                       XMN15010\n         ORG   ARWDCBS+RD&I-FILEORG                                     XMN15020\n         DC    A(FILE&I.IN)                                             XMN15030\n         ORG   ARWDCBS+WRT&I-FILEORG                                    XMN15040\n         DC    A(FILE&I.OUT)                                            XMN15050\n&I       SETA  &I+1                                                     XMN15060\n         AGO   .DA1                                                     XMN15070\n.DA2     ANOP                                                           XMN15080\n         ORG   ARWDCBS+ENDSERV-FILEORG                                  XMN15090\n         DS    0F                                                       XMN15100\n         SPACE 2                                                        XMN15110\nPGMDCB   DC    X'80'               FLAG END OF PARAMETER LIST           XMN15120\n         DC    AL3(PROGRAM)        ADDRESS OF PROGRAM DCB               XMN15130\n         SPACE 2                                                        XMN15140\nOCDCB    DS    F                   DCB ADDRESSES FOR OPEN AND CLOSE     XMN15150\nMOVEADR  DS    1F                  DESCRIPTOR STORAGE FOR PUT ROUTINE   XMN15160\nFILLENG  DC    F'0'                LENGTH OF PADDING NEEDED IN OUTPUT   XMN15170\nF1       DC    F'1'                THE CONSTANT ONE                     XMN15180\nF2       DC    F'2'                THE CONSTANT TWO                     XMN15190\nGETMOVE  MVC   0(0,2),0(1)         MVC COMMAND FOR THE GET ROUTINE      XMN15200\nMVCNULL  MVC   1(0,1),0(1)         MVC COMMAND FOR THE PUT ROUTINE      XMN15210\nMVCBLANK MVC   2(0,1),1(1)             \"                                XMN15220\nMVCSTRNG MVC   0(0,1),0(2)             \"                                XMN15230\n         EJECT                                                          XMN15380\n         SPACE 5                                                        XMN15390\n*********************************************************************** XMN15400\n*                                                                     * XMN15410\n*                                                                     * XMN15420\n*                                                                     * XMN15430\n*        DEVICE  CONTROL  BLOCKS  FOR  THE  SUBMONITOR                * XMN15440\n*                                                                     * XMN15450\n*                                                                     * XMN15460\n*********************************************************************** XMN15470\n         SPACE 2                                                        XMN15480\nPROGRAM  DCB   DSORG=PS,                                               XXMN15490\n               MACRF=R,                                                XXMN15500\n               DDNAME=PASS1,                                           X\n               DEVD=DA,                                                XXMN15520\n               KEYLEN=0,                                               XXMN15530\n               EODAD=EODPGM,                                           XXMN15540\n               SYNAD=ERRPGM                                             XMN15550\n         SPACE 2                                                        XMN15560\nINPUT0   DCB   DSORG=PS,                                               XXMN15570\n               DDNAME=SYSIN,                                           XXMN15580\n               DEVD=DA,                                                XXMN15590\n               MACRF=GL,                                               XXMN15600\n               BUFNO=3,                                                XXMN15610\n               EODAD=INEOD,                                            XXMN15620\n               SYNAD=INSYNAD,                                          XXMN15630\n               EXLST=INEXIT0,                                          XXMN15640\n               EROPT=ACC                                                XMN15650\n         SPACE 1                                                        XMN15660\n*********************************************************************** XMN15670\n*                                                                     * XMN15680\nINPUT1   EQU   INPUT0              INPUT(0) & INPUT(1) ARE BOTH SYSIN * XMN15690\n*                                                                     * XMN15700\n*********************************************************************** XMN15710\n         SPACE 2                                                        XMN15720\n&I       SETA  2                                                        XMN15730\n&J       SETA  1\n.INP1    AIF   (&I GT &INPUTS).INP2                                     XMN15740\n         SPACE 1                                                        XMN15750\nINPUT&I  DCB   DSORG=PS,                                               XXMN15760\n               DDNAME=SYSUT&J,                                         X\n               DEVD=DA,                                                XXMN15780\n               MACRF=GL,                                               XXMN15790\n               EODAD=INEOD,                                            XXMN15800\n               SYNAD=INSYNAD,                                          XXMN15810\n               EXLST=INEXIT&I,                                         XXMN15820\n               EROPT=ACC                                                XMN15830\n         SPACE 1                                                        XMN15840\n&I       SETA  &I+1                                                     XMN15850\n&J       SETA  &J+1\n         AGO   .INP1                                                    XMN15860\n.INP2    ANOP                                                           XMN15870\n         SPACE 2                                                        XMN15880\nOUTPUT0  DCB   DSORG=PS,                                               XXMN15890\n               DDNAME=SYSPRINT,                                        XXMN15900\n               DEVD=DA,                                                XXMN15910\n               MACRF=PL,                                               XXMN15920\n               SYNAD=OUTSYNAD,                                         XXMN15930\n               EXLST=OUTEXIT0,                                         XXMN15940\n               EROPT=ACC                                                XMN15950\n         SPACE 1                                                        XMN15960\n*********************************************************************** XMN15970\n*                                                                     * XMN15980\nOUTPUT1  EQU   OUTPUT0             OUTPUT(0), OUTPUT(1) BOTH SYSPRINT * XMN15990\n*                                                                     * XMN16000\n*********************************************************************** XMN16010\n         SPACE 2                                                        XMN16020\nOUTPUT2  DCB   DSORG=PS,                                               XXMN16030\n               DDNAME=SYSPUNCH,                                        XXMN16040\n               DEVD=DA,                                                XXMN16050\n               MACRF=PL,                                               XXMN16060\n               SYNAD=OUTSYNAD,                                         XXMN16070\n               EXLST=OUTEXIT2,                                         XXMN16080\n               EROPT=ACC                                                XMN16090\n         SPACE 1                                                        XMN16100\n&I       SETA  3                                                        XMN16110\n&J       SETA  1\n.OP1     AIF   (&I GT &OUTPUTS).OP2                                     XMN16120\n         SPACE 1                                                        XMN16130\nOUTPUT&I DCB   DSORG=PS,                                               XXMN16140\n               DDNAME=SYSUT&J,                                         X\n               DEVD=DA,                                                XXMN16160\n               MACRF=PL,                                               XXMN16170\n               SYNAD=OUTSYNAD,                                         XXMN16180\n               EXLST=OUTEXIT&I,                                        XXMN16190\n               EROPT=ACC                                                XMN16200\n         SPACE 1                                                        XMN16210\n&I       SETA  &I+1                                                     XMN16220\n&J       SETA  &J+1\n         AGO   .OP1                                                     XMN16230\n.OP2     ANOP                                                           XMN16240\n         SPACE 1                                                        XMN16250\n*********************************************************************** XMN16260\n*                                                                     * XMN16270\n*                                                                     * XMN16280\n*        DCBS FOR THE DIRECT ACCESS FILES                             * XMN16290\n*                                                                     * XMN16300\n*                                                                     * XMN16310\n*        BECAUSE OF THE MANNER IN WHICH THE FILES ARE USED,  IT IS    * XMN16320\n*        NECESSARY TO HAVE TWO DCB'S FOR EACH FILE.  ONE DCB FOR      * XMN16330\n*        READING AND ONE FOR WRITING.                                 * XMN16340\n*                                                                     * XMN16350\n*                                                                     * XMN16360\n*********************************************************************** XMN16370\n         SPACE 2                                                        XMN16380\n&I       SETA  1                                                        XMN16390\n.DD1     AIF   (&I GT &FILES).DD2                                       XMN16400\n         SPACE 1                                                        XMN16410\nFILE&I.IN DCB  DSORG=PS,                                               XXMN16420\n               MACRF=RP,                                               XXMN16430\n               DDNAME=FILE&I,                                          XXMN16440\n               DEVD=DA,                                                XXMN16450\n               RECFM=F,                                                XXMN16460\n               LRECL=FILEBYTS,                                         XXMN16470\n               BLKSIZE=FILEBYTS,                                       XXMN16480\n               KEYLEN=0,                                               XXMN16490\n               EODAD=FILEEOD,                                          XXMN16500\n               SYNAD=FILESYND                                           XMN16510\n         SPACE 2                                                        XMN16520\nFILE&I.OUT DCB DSORG=PS,                                               XXMN16530\n               MACRF=WP,                                               XXMN16540\n               DDNAME=FILE&I,                                          XXMN16550\n               DEVD=DA,                                                XXMN16560\n               RECFM=F,                                                XXMN16570\n               KEYLEN=0,                                               XXMN16580\n               LRECL=FILEBYTS,                                         XXMN16590\n               BLKSIZE=FILEBYTS,                                       XXMN16600\n               SYNAD=FILESYND                                           XMN16610\n         SPACE 1                                                        XMN16620\n&I       SETA  &I+1                                                     XMN16630\n         AGO   .DD1                                                     XMN16640\n.DD2     ANOP                                                           XMN16650\n         SPACE 4                                                        XMN16660\nXPLSMEND DS    0H                  END  OF  THE  SUBMONITOR             XMN16670\n         EJECT                                                          XMN16680\n         SPACE 5                                                        XMN16690\n*********************************************************************** XMN16700\n*                                                                     * XMN16710\n*                                                                     * XMN16720\n*                                                                     * XMN16730\n*        DSECT WHICH DEFINES THE FORMAT OF BINARY PROGRAM CONTROL     * XMN16740\n*        INFORMATION AND THE STARTING POINT FOR PROGRAMS              * XMN16750\n*                                                                     * XMN16760\n*                                                                     * XMN16770\n*********************************************************************** XMN16780\n         SPACE 2                                                        XMN16790\nFILECTRL DSECT                                                          XMN16800\n         SPACE 1                                                        XMN16810\nBYTSCODE DS    1F                  NUMBER OF BYTES OF CODE              XMN16820\n         SPACE 1                                                        XMN16830\nBYTSDATA DS    1F                  NUMBER OF BYTES OF DATA AREA         XMN16840\n         SPACE 1                                                        XMN16850\nBLKSCODE DS    1F                  NUMBER OF RECORDS OF CODE            XMN16860\n         SPACE 1                                                        XMN16870\nBLKSDATA DS    1F                  NUMBER OF RECORDS OF DATA AREA       XMN16880\n         SPACE 1                                                        XMN16890\nBYTSBLK  DS    1F                  BLOCKSIZE OF THE XPL PROGRAM FILE    XMN16900\n         SPACE 1                                                        XMN16910\nBYTSFULL DS    1F                  NUMBER OF BYTES OF CODE ACTUALLY     XMN16920\n*                                  USED IN THE LAST RECORD OF CODE      XMN16930\n         SPACE 1                                                        XMN16940\nDATABYTS DS    1F                  NUMBER OF BYTES OF DATA ACTUALLY     XMN16950\n*                                  USED IN THE LAST RECORD OF DATA      XMN16960\n         SPACE 1                                                        XMN16970\n         ORG   FILECTRL+60         REMAINDER OF THE CONTROL BLOCK       XMN16980\n*                                  IS UNUSED                            XMN16990\n         SPACE 1                                                        XMN17000\nCODEBEGN DS    0H                  FIRST EXECUTABLE INSTRUCTION         XMN17010\n*                                  IN THE XPL PROGRAM                   XMN17020\n         EJECT\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*        DSECT WHICH DEFINES THE BLOCK OF STATUS INFORMATION RETURNED *\n*        BY THE PASCAL RUN MONITOR VIA MONITOR_LINK(3).               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSTATUS   DSECT\nARBASE   DS    F                   ADDRESS OF GLOBAL ACTIVATION RECORD.\nORGORGN  DS    F                   ADDRESS OF THE ORG SEGMENT.\nORGTV    DS    F                   ADDRESS OF TRANSFER VECTOR.\nCODEPNT  DS    F                   ADDRESS OF PASCAL CODE SEGMENT.\nEXECTIME DS    F                   EXECUTION TIME OF PASCAL PROGRAM.\nERRLINE  DS    F                   SOURCE LINE OF RUN ERROR, IF ANY.\nCOREEND  DS    F                   END OF PASCAL REGION.\n         EJECT                                                          XMN17030\n         SPACE 5                                                        XMN17040\n*********************************************************************** XMN17050\n*                                                                     * XMN17060\n*                                                                     * XMN17070\n*        DUMMY  DCB  FOR  DEFINING  DCB  FIELDS                       * XMN17080\n*                                                                     * XMN17090\n*                                                                     * XMN17100\n*********************************************************************** XMN17110\n         SPACE 2                                                        XMN17120\n         DCBD  DSORG=QS,DEVD=DA                                         XMN17130\n         EJECT                                                          XMN17140\n         SPACE 5                                                        XMN17150\n*********************************************************************** XMN17160\n*                                                                     * XMN17170\n*                                                                     * XMN17180\n*        THE  END                                                     * XMN17190\n*                                                                     * XMN17200\n*                                                                     * XMN17210\n*********************************************************************** XMN17220\n         SPACE 5                                                        XMN17230\n         END                                                            XMN17240\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE03": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x08\\xe2\\x08\\xe2\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 2274, "newlines": 2274, "modlines": 0, "user": "SPASCAL"}, "text": "***********************************************************************\n*                                                                     *\n*                  STONY BROOK PASCAL 360 COMPILER                    *\n*                LOADER AND RUN-TIME SERVICE MONITOR                  *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n*\n*        COPYRIGHT (C) 1976\n*        DEPARTMENT OF COMPUTER SCIENCE\n*        SUNY AT STONY BROOK\n*\n         SPACE 5\n         MACRO\n&NAME    POWERS\n         LCLA  &EXP\n&EXP     SETA  0-78\n&NAME    DS    0D\n.CONST1  ANOP\n         DC    DE-(&EXP)'1.0'\n         AGO   .NEXT\n.CONST2  ANOP\n         DC    DE(&EXP)'1.0'\n.NEXT    ANOP\n&EXP     SETA  &EXP+1\n         AIF   (&EXP LT 0).CONST1\n         AIF   (&EXP LE 75).CONST2\n         MEND\n         SPACE 5\n         MACRO\n&NAME    SRVRTNED\n&NAME    CLI   TIMELEFT,0\n         BE    TIMEOUT\n         L     R15,PR15\n         LM    R11,R8,ORGPSCLR(R15)\n         BR    R10\n         MEND\n         SPACE 5\n         MACRO\n&NAME    CHKFILE &KIND\n.*\n.*       CALLS ERROR IF AN ATTEMPT IS MADE TO USE A NONSTANDARD FILE.\n.*\n.*       &KIND SHOULD BE EITHER INPUT OR OUTPUT\n.*\n&NAME    L     R1,PR14\n         LA    R1,&KIND.@(0,R1)\n         CR    R9,R1\n         BH    FILEERR\n         MEND\n         SPACE 5\n         MACRO\n&LABEL   FPERROR &MESSAGE\n&LABEL STM     R11,R12,ORGPSCLR(R15)   SAVE R11,R12 IN SAVE AREA\n         LM    R11,R12,ORGREGMN(R15)   LOAD OTHER MON BASE REGS\n         BAL   LINKREG,ERROR\n         DC    AL1(L'E&SYSNDX)\nE&SYSNDX DC    C&MESSAGE\n         MEND\n         SPACE 5\n*        RETURN FROM STANDARD PROCEDURES SIN,COS,ARCTAN,LN,SQRT\n         MACRO\n&LABEL   FPRETURN\n&LABEL   CLI   TIMELEFT,0          CHECK IF TIMER RAN OUT DURING\n         BE    FPTIMOUT            MONITOR CALL. IF SO, GIVE ERROR.\n         LM    R13,R1,ORGPSCLR+8(R15)  OTHERWISE, RETURN TO USER.\n         BR    LINK                RETURN TO PASCAL CODE\n         MEND\n         EJECT\nMONITOR  CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nFPR      EQU   6\nLINKREG  EQU   7                   SUBROUTINE LINKAGE REGISTER.\nBASE1    EQU   13                  MONITOR BASE REGISTER.\nBASE2    EQU   12                  MONITOR BASE REGISTER.\nBASE3    EQU   11                  MONITOR BASE REGISTER.\nORGPSCLR EQU   208                 OFFSET OF PASCAL SAVE AREA IN ORG\nORGREGMN EQU   272                 OFFSET OF MONITOR SAVE AREA IN ORG\nFREEDARL EQU   14400               AREA SIZE FOR I/O BUFFERS.\n*        CODEMNL MUST BE A MULTIPLE OF 4\nCODEMNL  EQU   32768               MIN. REGION FOR POST-MORTEM PKG.\nDCBBUFCB EQU   X'14'               A FIELD IN DCB\n         SPACE 5\n         ENTRY MONITORE\n         DS    18F                 MONITOR SAVE AREA\n         USING MONITOR,BASE1,BASE2,BASE3\n         EJECT\n*\n*        SERVICE CALLS BRANCH TABLE\n*\n         SPACE 5\n         B     SIN\n         B     COS\n         B     ARCTAN\n         B     EXP\n         B     LN\n         B     SQRT\n         B     CASE6\n         B     CASE7\n         B     CASE8\n         B     CASE9\n         B     CASE10\n         B     CASE11\n         B     CASE12\n         B     EOLN\n         B     EOF\n         B     NEW\n         B     DISPOSE\n         B     GET\n         B     PUT\n         B     RESET\n         B     REWRITE\n         B     READINT\n         B     READREAL\n         B     READCHAR\n         B     WRITEINT\n         B     WRITREAL\n         B     WRITBOOL\n         B     WRITCHAR\n         B     WRITSTRG\n         B     READLN\n         B     WRITELN\n         B     PAGE\n         B     RANGEERR\n         B     MEMOVERF\n         B     RANGMASK\n         B     CLOCK\n         EJECT\n         DROP  BASE1,BASE2,BASE3\n         USING MONITORE,R15        R15 POINTS TO MONITORE\nMONITORE STM   R14,R12,12(R13)     SAVE REGISTERS\n         S     R15,=A(MONITORE-MONITOR) R15 POINTS TO MONITOR\n         ST    R13,4(0,R15)\n         ST    R15,8(0,R13)\n         LR    BASE1,R15           BASE1 POINTS TO MONITOR\n         LA    BASE2,4095(0,BASE1)\n         LA    BASE2,1(0,BASE2)    BASE2 POINTS TO MONITOR+4096\n         LA    BASE3,4095(0,BASE2)\n         LA    BASE3,1(0,BASE3)    BASE3 POINTS TO MONITOR+8192\n         DROP  R15\n         USING MONITOR,BASE1,BASE2,BASE3\n         B     MONITOR1\n         SPACE 3\n         LTORG\n         SPACE 5\nMONITOR1 DS    0H\n*\n*        ALLOCATE ALL FREE STORAGE IN REGION\n*\n         GETMAIN VC,LA=GETVAR,A=FREEAREA\n         SPACE 5\n*\n*        FREE AREA FOR ACCESS METHOD\n*\n         L     R1,FREEAREL         LENGTH OF ALLOCATED AREA\n         L     R0,=A(FREEDARL)     AMOUNT OF CORE TO BE GIVEN BACK\n*                                  FOR I/O BUFFERS.\n         SR    R1,R0               LENGTH OF PASCAL REGION\n         ST    R1,FREEAREL         SAVE FOR FREEMAIN.\n         A     R1,FREEAREA         ADDRESS OF AREA TO BE RETURNED.\n         ST    R1,CORETOP          SAVE FOR HEAP POINTER.\n         FREEMAIN R,LV=(0),A=(1)\n         EJECT\n*\n*        ORG SEGMENT LOADING\n*\n         OPEN  ORGDS                OPEN DATA SET\n         MVC   ORGORGN,FREEAREA    FIX ORG SEGMENT ORIGIN POINTER\n         SPACE 5\n*\n*        TREAT HEADER INFORMATION\n*\n         GET   ORGDS               READ HEADER RECORD\n         SPACE 5\n*        OBTAIN ORG LENGTH\n         LA    R2,5(0,R1)\n         BAL   LINKREG,CONVERT\n         ST    R2,ORGSIZE          KEEP ORG SEGMENT LENGTH\n         SPACE 5\n*        OBTAIN TRANSFER VECTOR BASE RELATIVE TO ORG ORIGIN\n         LA    R2,10(0,R1)\n         BAL   LINKREG,CONVERT\n         A     R2,ORGORGN          CALCULATE ABSOLUTE ADDRESS OF TV\n         ST    R2,ORGTV            KEEP TV ABSOLUTE ADDRESS\n         SPACE 5\n*        OBTAIN MAX NUMBER OF BYTES OF TEMPORARY STORAGE\n         LA    R2,15(0,R1)         R2 POINTS TO THE VALUE IN CHARACTERS\n         BAL   LINKREG,CONVERT     CONVERT TO BINARY\n         ST    R2,MAXTEMPS         KEEP MAX OF TEMPORARY STORAGE\n         SPACE 5\n*        OBTAIN LENGTH OF GLOBAL ACTIVATION RECORD AREA\n         LA    R2,35(0,R1)\n         BAL   LINKREG,CONVERT\n         ST    R2,GLBLSIZE         KEEP LENGTH OF GLBL AR\n         EJECT\n*\n*        LOAD ORG SEGMENT\n*\n         LA    R4,ORGDS            R4 POINTS TO ORGDS DCB\n         L     R2,ORGORGN          POINTER TO ORG SEGMENT\n         L     R3,ORGSIZE          R3<--- LENGTH OF ORG SEGMENT\n         BAL   LINKREG,LOAD        LOAD ORG SEGMENT CODE\n         CLOSE ORGDS               CLOSE DATA SET\n         LA    R3,ORGDS            R3 POINTS TO DCB\n         TM    DCBBUFCB+3(R3),1    TEST IF ANY BUFFERS NOT FREED\n         BO    ORG10               IF FREED , DO BRANCH\n         FREEPOOL (R3)             FREE BUFFERS\nORG10    DS    0H\n         B     CODE\nORGSIZE  DS    F                   ORG SEGMENT SIZE\nMAXTEMPS DS    F                   MAXIMUM LENGTH OF TEMPORARY STORAGE\n         EJECT\n*\n*        CODE SEGMENT LOADING\n*\nCODE     OPEN  CODEDS              OPEN DATA SET\n         LA    R4,CODEDS           R4 POINTS TO CODEDS DCB\n         LA    R2,7(0,R2)          GET ON A DOUBLEWORD BOUNDARY\n         SRL   R2,3\n         SLL   R2,3\n         ST    R2,CODEPNT          KEEP POINTER TO START OF CODE\nCODE2    GET   CODEDS              READ HEADER RECORD\n         ST    R2,CODE1            KEEP POINTER IN MEMORY\n         SPACE 5\n*\n*        OBTAIN THE LENGTH OF THIS PROCEDURE'S CODE.\n*\n         LA    R2,5(0,R1)\n         BAL   LINKREG,CONVERT\n         SPACE 5\n*\n*        LOAD THE CODE OF THIS PROCEDURE\n*\n         LR    R3,R2\n         L     R2,CODE1\n         BAL   LINKREG,LOAD\n         B     CODE2\n         EJECT\n*\n*        INITIALIZE HEAP_PTR AND MAX_TOP\n*\n         SPACE 5\nCODEEND  L     R3,CORETOP          LAST ADDR IN REGION + 1\n         BCTR  R3,0                LAST ADDR IN REGION\n         N     R3,=X'FFFFFFFC'     NEXT LOWER FULLWORD\n         L     R4,ORGORGN          ADDRESS OF ORG SEGMENT\n         ST    R3,HEAPPTR(R4)      STORE HEAP POINTER.\n         S     R3,MAXTEMPS         (HEAP_PTR - MAX_TEMP_DISPL)\n         N     R3,=X'FFFFFFFC'                 & \"FFFFFFFC\"\n         ST    R3,MAXTOP(R4)       --->MAX_STACKTOP\n         SPACE 5\n*\n*        SET TRANSFER VECTOR\n*\n         L     R4,ORGTV            R4<---TRANSFER VECTOR POINTER.\n         L     R5,CODEPNT          R5<---CODE SEGMENT POINTER.\nCODE3    LR    R3,R5               RELOCATION FACTOR\n         A     R3,0(0,R4)          RELOCATE TV ENTRY\n         ST    R3,0(0,R4)          STORE IN TV\n         LA    R4,4(0,R4)          MOVE TO NEXT TV ENTRY\n         CR    R4,R5               END OF TRANSFER VECTOR?\n         BL    CODE3               NO, RELOCATE NEXT ENTRY.\n         L     R4,ORGTV            R4 POINTS TO TRANSFER VECTOR\n         MVC   PR12,0(R4)          SET MAIN PROCEDURE POINTER\n         CLOSE CODEDS\n         LA    R3,CODEDS           R3 POINTS TO DCB\n         TM    DCBBUFCB+3(R3),1    TEST IF ANY BUFFERS NOT FREED\n         BO    CODE10              IF FREED , DO BRANCH\n         FREEPOOL (R3)             FREE BUFFERS\nCODE10   DS    0H\n         B     GLBL\nCODE1    DS    F\nHEAPPTR  EQU   0                   DISPLACEMENT OF HEAP_PTR IN ORG SEG.\nMAXTOP   EQU   4                   DISPLACEMENT OF MAX_TOP IN ORG SEG.\n         EJECT\n*\n*        GLOBAL ACTIV. RECORD LOADING\n*\nGLBL     OPEN  GLBLDS              OPEN DATA SET\n         AH    R2,=H'4'\n         SRA   R2,2\n         SLL   R2,2                R2 IS ON A        WORD BOUNDARY\n         LR    R3,R2               R2 POINTS TO END OF CODE\n         S     R3,CODEPNT          R3 CONTAINS LENGTH OF CODE\n         C     R3,=A(CODEMNL)      LENGTH OF CODE > MINIMUM?\n         BNL   GLBL1               IF YES , DO BRANCH\n         L     R2,CODEPNT\n         A     R2,=A(CODEMNL)      R3 POINTS TO AREA OF GLBL ACTIV. REC\nGLBL1    ST    R2,PR14             R2 POINTS TO GLBL ACTIV. REC.AREA\n         ST    R2,PR11             INITIAL CURRENT AR POINTER\n         LA    R4,GLBLDS            R4 POINTS TO GLBLDS DCB\n         L     R3,GLBLSIZE         R2 CONTAINS GLBL AR SIZE\n         BAL   LINKREG,LOAD\n         CLOSE GLBLDS\n         LA    R3,GLBLDS           R3 POINTS TO DCB\n         TM    DCBBUFCB+3(R3),1    TEST IF ANY BUFFERS NOT FREED\n         BO    GLBL10              IF FREED , DO BRANCH\n         FREEPOOL (R3)             FREE BUFFERS\nGLBL10   DS    0H\n         EJECT\n*        SET TIMER FOR PASCAL CODE EXECUTION\n         SPACE 5\nTIMER    L     R3,=V(LINKSAVE)\n         L     R3,0(0,R3)          R3 CONTAINS TIME LIMIT IN SECONDS\n         C     R3,MAXTIME          MUST BE <= 24 HOURS\n         BNH   SETTIMER\n         L     R3,MAXTIME\nSETTIMER MH    R3,=H'100'          R3 CONTAINS TIME LIMII IN\n*                                  HUNDREDTHS OF SECONDS\n         ST    R3,TIMELT           KEEP THE TIME LIMIT\n         TTIMER CANCEL\n         STIMER TASK,TIMETRAP,BINTVL=TIMELT\n         L     R1,16               CVT ADDR FROM ABSOLUTE LOCATION 16\n         L     R1,0(0,R1)          TCB ADDRESS POINTER FROM CVT\n         L     R1,4(0,R1)          ADDR OF CURRENT TCB\n         L     R1,120(0,R1)        TQE ADDR FROM TCB\n         LA    R1,28(0,R1)         ADDRESS OF RB LINK IN TQE\n         ST    R1,RBLINK           PLANT FOR TIMER INTERRUPT\n         MVI   TIMELEFT,X'FF'      INDICATE CPU CLOCK STILL TICKING\n         SPACE 5\n*        SET LINEST VALUE\n         L     R3,=V(LINKSAVE)\n         L     R3,4(0,R3)          R3 CONTAINS LINE NUMBER LIMIT\n         ST    R3,LINEST           KEEP LINE ESTIMATE AT LINEST\n         SPACE 5\n*        TRAP PROGRAM INTERRUPTS.\n         SPIE  PGMCHK,((1,9),11,12,15)\n         ST    1,PICAADDR          ADDRESS OF OLD PICA\n         SPACE 5\n*        ESTABLISH REGISTER STORAGE CONVENTION\n         L     R15,PR15            R15 POINTS TO ORG SEGMENT\n         L     R1,=V(INPUT0)       R1 POINTS TO INPUT0 DCB\n         NC    40(8,R1),40(R1)     WAS EODAD ENCOUNTERED?\n         BZ    S1                  YES, SO BRANCH.\n         LA    R2,=A(INPUTED)      ADDR OF OUR EODAD ROUTINE\n         MVC   33(3,R1),1(R2)      SET EODAD FIELD IN INPUT0 DCB.\n         BAL   LINKREG,NEXTCH      INITIALIZE INPUT\n         B     S2\nS1       MVI   ENDFILE,X'FF'       INDICATE EOF(INPUT)\nS2       STM   BASE3,BASE1,ORGREGMN(R15) KEEP MONITOR BASE REGS IN ORG.\n         SPACE 5\n*        LINK TO PASCAL CODE\n         SPACE 5\n         L     R10,PR11\n         STM   BASE3,BASE1,8(R10)  SAVE MONITOR BASE REGISTER BASE\n*                                  IN GLOBAL BLOCK MARK\n         LM    R11,R15,PR11        LOAD PREASSIGNED REGISTERS\n         BALR  R10,12              START EXECUTION OF PASCAL CODE\n         SPACE 5\n*        NORMAL RETURN FROM PASCAL CODE\n         CLI   TIMELEFT,0          TIMER ABORT?\n         BNE   ENDMNTR             NO, SO RETURN.\n         LA    LINKREG,TIMEERR     YES, CALL ERROR.\n         L     R10,ERRLINE\n         B     ERROR\nENDMNTR  LA    R1,PR14             ADDRESS OF STATUS BLOCK, WHICH\n*                                  BEGINS AT LOCATION PR14\n         L     R2,=V(LINKSAVE)     ADDRESS OF MONITOR_LINK\n         ST    R1,12(0,R2)         RETURN STATUS IN MONITOR_LINK(3)\n         L     R1,=V(INPUT0)\n         CLOSE (R1)\n         L     R1,PICAADDR         ADDRESS OF OLD PICA\n         SPIE  MF=(E,(1))          RESTORE OLD PICA\n*\n*        CANCEL THE CPU TIMER, CALCULATE EXECUTION TIME.\n*\n         TTIMER CANCEL\n*\n*        R0 CONTAINS TIME REMAINING (IN UNITS OF 26.04166 USEC).\n*\n         SRDL  R0,32               CONVERT TO UNITS OF 0.01 SECONDS.\n         LA    R2,384              (CONVERSION FACTOR)\n         DR    R0,R2\n         L     R2,TIMELT           ORIGINAL TIMER LIMIT\n         SR    R2,R1               ELAPSED CPU TIME.\n         ST    R2,EXECTIME\n         L     R13,4(0,R13)        R13 POINTS TO OV MONITOR SAVE AREA\n         LM    R14,12,12(R13)      RESTORE OV MONITOR REGISTERS\n         BR    R14                 BACK TO OV MONITOR\n         EJECT\n*\n*        TIMER COMPLETION ASYNCHRONOUS EXIT ROUTINE\n*\n         SPACE 5\nTIMETRAP DS    0H                  SYSTEM ENTERS HERE.\n         DROP  BASE1,BASE2,BASE3\n         USING TIMETRAP,R15\n         SAVE  (14,12)             SAVE REGISTERS.\n         L     R3,RBLINK           ADDR OF RB LINK\n         L     R3,0(0,R3)          ADDR OF PRB\n         L     R3,20(0,R3)         WORD2 OF OLD PSW\n         LA    R3,0(0,R3)          CLEAR THE HIGH ORDER BYTE.\n         MVI   TIMELEFT,0          INDICATE NO TIME LEFT.\n         C     R3,CODEPNT          WAS INTERRUPT IN PASCAL CODE?\n         BL    TIMER1              NO, FINISH MONITOR ROUTINE\n         C     R3,PR14                THEN GO TO TIMEOUT.\n         BH    TIMER1\n*\n*        INTERRUPT OCCURRED IN PASCAL CODE\n*\n         MVC   0(10,3),HALTBYTS    MOVE HALT INSTR. TO PASCAL CODE\n         ST    R3,ERRLINE\nTIMER1   RETURN (14,12),T,RC=0     RETURN TO O.S.\n         DROP  R15\n         USING MONITOR,BASE1,BASE2,BASE3\n         SPACE 5\nHALTBYTS STM   R11,R12,ORGPSCLR(R15)\n         LM    R10,R13,4(R14)\n         BR    R10\n         SPACE 3\nTIMELEFT DS    XL1\nRBLINK   DS    F\nMAXTIME  DC    F'86400'            SECONDS / DAY\nTIMELT   DS    F                   EXECUTION TIME LIMIT\n         SPACE 3\nTIMEOUT  BAL   LINKREG,ERROR\nTIMEERR  DC    AL1(L'TIMEERRM)\nTIMEERRM DC    C'ESTIMATED TIME EXCEEDED'\n         EJECT\n         PRINT NOGEN\n*\n*        ORG SEGMENT DATA SET DEFINITION\n*\nORGDS    DCB   DDNAME=SYSUT2,                                          X\n               DSORG=PS,                                               X\n               MACRF=GL\n         SPACE 5\n*\n*        CODE DATA SET DEFINITION\n*\nCODEDS   DCB   DDNAME=SYSUT1,                                          X\n               DSORG=PS,                                               X\n               MACRF=GL,                                               X\n               EODAD=CODEEND\n         SPACE 5\n*\n*        GLOBAL ACTIV. REC. DATA SET DEFINITION\n*\nGLBLDS   DCB   DDNAME=SYSUT3,                                          X\n               DSORG=PS,                                               X\n               MACRF=GL\n         SPACE 5\n         PRINT GEN\n*\n*        PROTOCOL POINTERS\n*\nPR11     DS    A                   POINTER TO CURRENT AR BASE\nPR12     DS    A                   POINTER TO CODE BASE\nPR13     DS    A                   POINTER TO STACK TOP\nPR14     DS    A                   POINTER TO GLBL AR AREA\nPR15     DS    A                   POINTER TO ORG\n         SPACE 5\n*\n*LOADER GLOBAL VARIABLES\n*\nORGORGN  EQU   PR15\nORGTV    DS    A                   ADDRESS OF TRANSFER VECTOR\nCODEPNT  DS    A                   ADDRESS OF CODE SEGMENT\nEXECTIME DS    F                   EXECUTION TIME OF PASCAL PROGRAM\nERRLINE  DC    F'0'                SOURCE LINE OF RUN ERROR\nCORETOP  DS    A                   INITIAL HEAP POINTER.\nFREEAREA DS    A                   POINTER TO UNUSED AREA IN REGION\nFREEAREL DS    F                   LENGTH OF THE FREE AREA IN REGION\nGLBLSIZE DS    F                   SIZE OF GLBL AR AREA\nGETVAR   DC    A(CODEMNL+FREEDARL+4096)\n         DC    A(1000000)\n         EJECT\n*\n*        CONVERT ROUTINE\n*\n*        PURPOSE: TO CONVERT HEADER INFORMATION INTO BINARY FORM\n*\n*        INPUT: R2 POINTS TO INFORMATION\n*\n*        OUTPUT: R2 CONTAINS THE VALUE\n*\nCONVERT  DS    0H\n         ST    R2,CONR2            KEEP POINTER\nCON2     CLI   0(R2),C' '          BLANK CHARACTER ?\n         BNE   CON1                IF NOT , DO BRANCH\n         MVI   0(R2),X'F0'         IF YES,FILL IN DECIMAL 0\n         LA    R2,1(0,R2)          INCREMENT POINTER\n         B     CON2                ITERATE\nCON1     L     R2,CONR2            RESTORE ORIGINAL POINTER\n         MVC   COND1,=8X'00'       CLEAR COND1 WITH ZEROES\n         PACK  COND1+5(3),0(5,R2)  PACK HEADER INFORMATION\n         CVB   R2,COND1            CONVERT HEADER INFORMATION INTO BIN.\n         BR    LINKREG             RETURN TO CALLER\nCOND1    DS     D                  AUXILIARY\nCONR2    DS    F                TO KEEP ORIGINAL POINTER TO INPUT DATA\n         EJECT\n*\n*        LOAD ROUTINE\n*\n*        PURPOSE: TO READ A MODULE OF CODE\n*\n*        INPUT: R2 POINTS TO BASE OF AREA TO BE LOADED\n*               R3 CONTAINS LENGTH OF CODE\n*               R4 POINTS TO DCB OF OBJECT CODE DATASET\n*\n*        OUTPUT: R2 POINTS TO BASE OF NEXT AREA TO BE LOADED\n*\nLOAD     DS    0H\nLOA2     GET   (R4)                OBTAIN CARD IMAGE\n         SH    R3,=H'80'           R3<---R3-80\n         BNH   LOA1                IF END OF CODE, BRANCH.\n         MVC   0(80,R2),0(R1)      MOVE CODE FROM BUFFER\n         LA    R2,80(0,R2)         INCREMENT POINTER\n         B     LOA2                ITERATE\nLOA1     LA    R3,79(0,R3)         LENGTH OF CODE - 1.\n         EX    R3,LOADMVC          MOVE RESIDUAL BYTES OF CODE.\n         LA    R2,1(R2,R3)         R2 POINTS TO END OF CODE.\n         BR    LINKREG             RETURN TO CALLER\n         SPACE 3\nLOADMVC  MVC   0(1,R2),0(R1)       MOVE RESIDUAL BYTES OF CODE.\n         EJECT\nOUTPUT@  EQU   31                  OFFSET +31 IN GLBL AR AREA\nINPUT@   EQU   29                  OFFSET +29 IN GLBL AR AREA\n         SPACE 5\n*\n*        ROUTINE NEXTCH\n*\n*        PURPOSE :  GET NEXT CHARACTER FROM INPUT STREAM AND\n*                   PUT IT INTO INPUT@\n         SPACE 5\nNEXTCH   STM   R14,R1,NEXTCHR0     KEEP REGISTERS\n         STM   R1,R2,NEXTCHR1      KEEP REGISTERS\n         ST    LINKREG,NEXTCHR2    KEEP REGISTER\n         CLI   ENDFILE,X'FF'       TEST END OF FILE CONDITION\n         BNE   NEXTCH1             IF NOT,DO BRANCH\n         BAL   LINKREG,ERROR       EOF ERROR MESSAGE\n         DC    AL1(L'NEXTCHM)      ERROR MESSAGE PREFIX\nNEXTCHM  DC    C'ATTEMPT TO READ PAST END OF FILE'\nNEXTCH2  BAL   LINKREG,NEXTGET     GET NEXT RECORD\n         CLI   ENDFILE,X'FF'       END OF FILE ENCOUNTERED ?\n         BE    NEXTCHFN            IF YES,DO BRANCH\n         MVC   INPTR,=H'0'         ZERO CURRENT CHARACTER POINTER\n         ST    R1,INLINE           KEEP POINTER TO INPUT RECORD\n         B     NEXTCH3             PROCEED\nNEXTCH4  LH    R2,=H'80'             INPTR<---80 (SIGNALS EOLN)\n         STH   R2,INPTR\n         L     R2,PR14             INPUT@<---BLANK\n         MVI   INPUT@(R2),C' '\n         B     NEXTCHFN\nNEXTCH1  CLC   INPTR,=H'79'        END OF LINE INDICATED?\n         BH    NEXTCH2             YES, GET NEXT RECORD.\n         BE    NEXTCH4             NO, SIGNAL EOLN.\n         LH    R1,INPTR            R1<---INPTR\n         LA    R1,1(0,R1)          R1<---R1+1\n         STH   R1,INPTR            INPTR<---R1\n         A     R1,INLINE           R1 POINTS TO CURRENT INPUT CHARACTER\nNEXTCH3  L     R2,PR14             R2 POINTS TO GLOBAL AR AREA\n         MVC   INPUT@(1,R2),0(R1)  SET INPUT@ VARIABLE\nNEXTCHFN LM    R14,R1,NEXTCHR0     RESTORE REGISTER\n         LM    R1,R2,NEXTCHR1      RESTORE REGISTER\n         L     LINKREG,NEXTCHR2    RESTORE REGISTER\n         BR    LINKREG             RETURN TO CALLER\n         EJECT\n*\n*        ROUTINE NEXTGET\n*\nNEXTGET  L     R1,=V(INPUT0)\n         GET   (R1)                READ A RECORD FROM FILE INPUT0\n         BR    LINKREG             RETURN TO CALLER\n         SPACE 5\n*        FOLLOWING LOCATION ENTERED AT EODAD OF INPUT FILE\nINPUTED  MVI   ENDFILE,X'FF'       SET EODAD FLAG TO ON\n         L     R2,PR14             R2 POINTS TO GLOBAL A. R. AREA\n         MVI   INPUT@(R2),C' '     SET INPUT@ VARIABLE\n         BR    LINKREG             RETURN TO CALLER OF NEXTGET\nINPTR    DS    H'80'               POINTER TO CURRENT INPUT CHARACTER\nINLINE   DS    A                   POINTER TO CURRENT INPUT RECORD\nENDFILE  DC    X'00'               END OF FILE FLAG.X'FF' INDICATES ON\nNEXTCHR0 DS    4F                  REGISTERS SAVE AREA\nNEXTCHR1 DS    2F                  REGISTERS SAVE AREA\nNEXTCHR2 DS    F                   REGISTERS SAVE AREA\n         EJECT\n*\n*        CONCATENATION ROUTINE\n*\n*        INPUT:  DESCRIPTOR FOR STRING S1, IN R1;\n*                DESCRIPTOR FOR STRING S2, IN R2.\n*\n*        OUTPUT: DESCRIPTOR FOR STRING S1 || S2, IN R1.\n*\n         SPACE 5\nCATENATE DS    0H\n         STM   R2,R6,CATSAVE       SAVE REGISTERS.\n         LA    R6,STRING#-1        SIZE OF LARGEST STRING - 1.\n         LR    R4,R1               R4<---DESCRIPTOR FOR S1\n         SRDL  R4,24               R4<---LENGTH(S1) - 1\n         SRL   R5,8                R5<---ADDR(1ST BYTE OF S1)\n         SR    R6,R4               R6<---MAX # CHARS TO BE MOVED\n         BNP   CATRETN             IF LENGTH(S1) >= STRING#, RETURN S1.\n         LA    R5,0(R4,R5)         ADDR(LAST BYTE OF S1).\n         SRDL  R2,24               R2<---LENGTH(S2) - 1.\n         SRL   R3,8                R3<---ADDR(1ST BYTE OF S2)\n         BCTR  R6,0                R6<---(MAX# CHARS TO BE MOVED) - 1\n         CR    R2,R6               S2 TOO LONG?\n         BNH   CAT1                NO, SO BRANCH.\n         LR    R2,R6               YES, SO ONLY MOVE SOME OF S2.\nCAT1     EX    R2,CATMOVE          PERFORM CONCATENATION.\n         LA    R2,1(R2,R4)         R2<---LENGTH(S1 || S2) - 1\n         SLL   R2,24               SHIFT TO HIGH ORDER BYTE.\n         LA    R1,0(0,R1)          CLEAR THE HIGH ORDER BYTE.\n         OR    R1,R2               R1<---DESCRIPTOR FOR S1 || S2.\nCATRETN  LM    R2,R6,CATSAVE       RESTORE REGISTERS\n         BR    LINKREG             RETURN\n         SPACE 3\nCATMOVE  MVC   1(0,R5),0(R3)       CONCATENATION MOVE\nCATSAVE  DS    5F                  REGISTER SAVE AREA.\nSTRING#  EQU   133                 SIZE OF LARGEST STRING.\n         EJECT\n*\n*        INTEGER - TO - STRING   CONVERSION\n*\n*        INPUT:  INTEGER NUMBER IN R1.\n*\n*        OUTPUT: XPL-TYPE STRING DESCRIPTOR IN R1.\n*\n         SPACE 5\nINT2STR  DS    0H                  INTEGER TO STRING\n         ST    R2,I2SSAVE          SAVE R2.\n         CVD   R1,I2SDEC           CONVERT INTEGER TO PACKED DECIMAL.\n         MVC   I2SEDIT,I2SPATRN    PREPARE WORK AREA FOR EDMK INSTR.\n*\n*        LARGEST INTEGER VALUE HAS 10 DECIMAL DIGITS.\n*\n         LA    R1,I2SEDIT+11       ADDR OF SIGNIFICANCE STARTER + 1\n         EDMK  I2SEDIT,I2SDEC+2    EDIT + MARK\n         BNM   I2S1                BRANCH IF NONNEGATIVE\n         BCTR  R1,0                SIGN POSITION\n         MVI   0(1),C'-'           INSERT A MINUS SIGN\n*\n*        FORM AN XPL-LIKE STRING DESCRIPTOR:\n*        BYTE 0: LENGTH(STRING) - 1\n*        BYTES 1..3: ADDRESS OF 1ST CHARACTER\n*\nI2S1     LA    R2,I2SEDIT+11       ADDR OF LAST CHARACTER\n         SR    R2,R1               MINUS ADDR OF 1ST CHARACTER\n         SLL   R2,24               SHIFT TO HIGH ORDER BYTE\n         LA    R1,0(0,R1)          CLEAR THE HIGH ORDER BYTE\n         OR    R1,R2               FORM DESCRIPTOR\n         L     R2,I2SSAVE          RESTORE R2\n         BR    LINKREG             RETURN TO CALLER.\n         SPACE 5\nI2SPATRN DC    X'40',9X'20',X'21',X'20' EDMK PATTERN\nI2SEDIT  DS    CL12                WORK AREA FOR EDMK\nI2SSAVE  DS    F                   SAVE AREA FOR R2\nI2SDEC   DS    D                   WORK AREA FOR CVD\n         EJECT\n*\n*        PROCEDURE I_FORMAT\n*\n*        PURPOSE: TO FORMAT A BINARY INTEGER FOR PRINTING\n*\n*        INPUT:  BINARY INTEGER TO BE PRINTED, IN R1;\n*                MINIMUM FIELD WIDTH IN R2.  IF FEWER CHARACTERS THAN\n*                THE MINIMUM ARE NEEDED, THE NUMBER IS RIGHT-JUSTIFIED\n*                (WITH LEADING BLANKS) IN A MINIMUM WIDTH FIELD.\n*\n*        OUTPUT: XPL-TYPE STRING DESCRIPTOR IN R1.\n*\n         SPACE 5\nIFORMAT  DS    0H\n         STM   R2,LINKREG,IFORSAVE SAVE REGISTERS.\n         BAL   LINKREG,INT2STR     CONVERT NUMBER TO STRING.\n         LR    R4,R1               R4<---STRING DESCRIPTOR\n         SRDL  R4,24               R4<---LENGTH(STRING) - 1\n         BCTR  R2,0                R2<--MINIMUM WIDTH - 1\n         CR    R2,R4               ARE LEADING BLANKS NEEDED?\n         BNH   IFORMAT1            NO, RETURN DESCRIPTOR\n         SR    R2,R4               YES, R2 = # LEADING BLANKS\n         LA    R1,ISTRING          ADDR OF OUTPUT STRING\n         SRL   R5,8                ADDR OF DIGITS.\n         EX    R2,IMOVE1           INSERT BLANKS\n         LA    R3,0(R1,R2)         ADDR OF 1ST NONBLANK\n         EX    R4,IMOVE2           INSERT DIGITS\n         AR    R2,R4               R2 = MINIMUM WIDTH - 1\n         SLL   R2,24               SHIFT TO HIGH ORDER BYTE\n         OR    R1,R2               FORM DESCRIPTOR\nIFORMAT1 LM    R2,LINKREG,IFORSAVE RESTORE REGISTERS\n         BR    LINKREG             RETURN TO CALLER\n         SPACE 3\nIMOVE1   MVC   0(0,1),SPACES       MOVE SPADES TO ISTRING\nIMOVE2   MVC   0(0,3),0(5)         MOVE DIGITS TO ISTRING\nISTRING  DS    CL133               STRING SPACE USED BY I_FORMAT.\nSPACES   DC    CL133' '\nIFORSAVE DS    6F\n         EJECT\n*\n*        PROCEDURE B_FORMAT\n*\n*        PURPOSE: TO FORMAT A BOOLEAN VALUE FOR OUTPUT\n*\n*        INPUT:  BOOLEAN VALUE TO BE PRINTED, IN R1;\n*                FIELD WIDTH IN R2.\n*\n*        OUTPUT: XPL-TYPE STRING DESCRIPTOR, IN R1.\n*\n         SPACE 5\nBFORMAT  DS    0H\n         STM   R2,LINKREG,BFORSAVE /* SAVE REGISTERS */\n         LTR   R1,R1               IF BOOL_VALUE THEN\n         BZ    BFOR1                  STRING = 'TRUE';\n         L     R1,TRUESTR\n         B     BFOR2               ELSE\nBFOR1    L     R1,FALSESTR            STRING = 'FALSE';\nBFOR2    LR    R3,R1               IF LENGTH(STRING) > WIDTH THEN\n         SRL   R3,24\n         LA    R3,1(0,R3)             /* R3<---LENGTH(STRING) */\n         CR    R2,R3                  /* R2<---WIDTH */\n         BNL   BFOR3\n         LA    R1,0(0,R1)             STRING = SUBSTR(STRING, 0, 1);\n         LA    R3,1\nBFOR3    CR    R2,R3               IF LENGTH(STRING) < WIDTH THEN\n         BNH   BFOR4\n         MVC   ISTRING,SPACES         STRING =\n         LA    R4,ISTRING                SUBSTR(SPACES, 0,\n         SR    R2,R3                           WIDTH-LENGTH(STRING))\n         BCTR  R2,0                      || STRING;\n         SLL   R2,24\n         OR    R4,R2\n         LR    R2,R1\n         LR    R1,R4\n         BAL   LINKREG,CATENATE\nBFOR4    LM    R2,LINKREG,BFORSAVE RETURN STRING;\n         BR    LINKREG\n         SPACE 1\nBFORSAVE DS    6F                  /* SAVE AREA FOR REGISTERS */\n         SPACE 3\n*\n*        TRUESTR IS AN XPL-TYPE DESCRIPTOR FOR THE STRING 'TRUE',\n*        FALSESTR IS A DESCRIPTOR FOR 'FALSE'\n*\nTRUESTR  DC    AL1(L'TRUECHRS-1),AL3(TRUECHRS)\nFALSESTR DC    AL1(L'FLSCHRS-1),AL3(FLSCHRS)\nTRUECHRS DC    C'TRUE'\nFLSCHRS  DC    C'FALSE'\n         EJECT\n*\n*        PROCEDURE PUTLN\n*\n*        PURPOSE: WRITE A LINE AND UPDATE LINEST\n*\n         SPACE 5\nPUTLN    DS    0H\n         STM   R14,R1,PUTLSAVE     SAVE REGISTERS\n         L     R1,LINEST           R1<---LINEST\n         LTR   R1,R1               LINE ESTIMATE EXCEEDED?\n         BH    PUTLN1              NO, SO BRANCH.\n         BAL   LINKREG,ERROR       YES, PRINT ERROR MESSAGE.\n         DC    AL1(L'PUTLNM)\nPUTLNM   DC    C'ESTIMATED LINES EXCEEDED'\nPUTLN1   BCTR  R1,0                LINEST = LINEST - 1\n         ST    R1,LINEST\n         L     R1,=V(OUTPUT0)      DCB ADDRESS\n*\n*        USING LOCATE MODE, THE ADDRESS OF THE NEXT OUTPUT BUFFER IS\n*        RETURNED IN R1.\n*\n         PUT   (R1)\n         MVC   0(133,R1),OUTLINE   MOVE LINE TO BUFFER\n         MVC   OUTLINE,SPACES      MOVE SPACES TO LINE\n         LA    R1,OUTLINE          RE-INITIALIZE OUTLINE DESCRIPTOR\n         ST    R1,OUTLINEP\n         LM    R14,R1,PUTLSAVE     RESTORE REGISTERS\n         BR    LINKREG             RETURN\n         SPACE 1\nPUTLSAVE DS    4F\n         TITLE 'STANDARD FUNCTIONS OF ANALYSIS'\n*        SIN, COS, ARCTAN, EXP, SQRT, LN ADAPTED FROM THE SUNY AT\n*        STONY BROOK BASIC COMPILER ( COURTESY OF GARRY MEYER )\n         SPACE 3\nGR0      EQU   0                   GENERAL REGISTERS USED FOR SCRATCH\nGR1      EQU   1\nGR2      EQU   14\nLINK     EQU   10                  LINK TO PASCAL CODE\nFR0      EQU   0                   FLOATING POINT REGISTERS\nFR2      EQU   2\nFR4      EQU   4\nFR6      EQU   6\nBUFF     DS    D                   BUFFER USED FOR TEMP STORAGE\n         SPACE\n*\n*        LINKAGE TO PASCAL CODE:\n*\n*          ALL SAVING OF REGISTERS IS DONE IN THE PASCAL CODE. GENERAL\n*          REGS 13..15,0,1 ARE THE ONLY GENERAL REGS SAVED, EXCEPT UPON\n*          ENTRY TO EXP, WHERE 2, 3 AND 4 ARE ALSO SAVED, SINCE EXP\n*          REQUIRES 7 SCRATCH REGS.\n*          REG 13 IS THE BASE REG FOR THE CODE & DATA, AND IS THE\n*          ONLY REG PRE-LOADED EXCEPT FOR FP6, THE ARGUMENT REG. R10 IS\n*          THE LINK TO THE PASCAL CODE, AND REGS 14,15,0,1 ARE USED FOR\n*          SCRATCH REGS. IF AN ERROR CONDITION OCCURS, THE REMAINING\n*          MONITOR BASE REGISTERS ARE LOADED BEFORE BRANCHING TO THE\n*          ERROR HANDLER.\n       SPACE 5\n*        HANDLE TIMER RUNOUT DURING SIN..SQRT ROUTINES\n*\nFPTIMOUT FPERROR 'ESTIMATED TIME EXCEEDED'\n       TITLE   'SINE-COSINE FUNCTIONS (SHORT)'\n*\n*      CASES --- 0,1 SIN,COS (SHORT)\n*              1. DIVIDE MAGNITUDE OF ARG BY PI/4 TO FIND OCTANT\n*                   AND FRACTION.\n*              2. IF COSINE, CRANK OCTANT NUMBER BY 2.\n*              3. IF SINE, CRANK OCTANT NUMBER BY 0(4) FOR +ARG(-ARG).\n*              4. COMPUTE SINE OR COSINE OF FRACTION*PI/4 DEPENDING\n*                   ON THE OCTANT.\n*              5. IF OCTANT NUMBER IS FOR LOWER PLANE, MAKE SIGN -.\n       SPACE\n       SPACE\nON       EQU   X'FF'\nOFF      EQU   X'00'\n       SPACE\nCOS    EQU     *\n       MVI     CRANK+3,X'02'     FOR COSINE, OCTANT CRANK IS 2\n       B       MERGE\n*                                  COS(X) = SIN(PI/2+X)\n*                                          OCTANT CRANK IS 4 IF -ARG\nSIN    MVI     CRANK+3,X'00'     FOR SINE, OCTANT CRANK IS 0 IF +ARG\n       LTER    FR6,FR6             ARG IN FP6. SIN(-X) = SIN(PI+X)\n       BNM     MERGE\n       MVI     CRANK+3,X'04'\n       SPACE\nMERGE  LD      FR4,ONE         LOAD FR4 DOUBLE WITH ONE\n       LD      FR2,CRANK       CLEAR L.O. FR2 AND LOAD WITH CRANK\n       LDR     FR0,FR2         CLEAR L.O. FR0\n     LER       FR0,FR6             GET ARG IN WORK REG\n       LPER    FR0,FR0         CONSIDER ARGUMENT TO BE POSITIVE\n       CE      FR0,MAXCOS\n       BC      10,ERSNCOS      ERROR IF /X/ GRT THAN OR = PI*2**18\n       MD      FR0,FOVPI       MULTIPLY BY 4/PI (LONG FORM)\n       CER     FR0,FR4\n       BC      4,SMALL         IF PRODUCT LESS THAN 1, JUMP\n       AWR     FR0,FR2         GIVE PROD CHAR OF 46, UNNORM, ADD CRANK\n       LER     FR2,FR0         INTEGER PART OF PROD TO FR2, UNNORM\n       SDR     FR0,FR2         FRACTION PART OF PROD TO FR0, NORM\n       SPACE\nSMALL  STE     FR2,OCTNT       SAVE OCTANT. LAST 3 BITS ARE MOD OCTANT\n       TM      OCTNT+3,X'01'   IF ODD OCTANT, TAKE COMPLEMENT OF\n       BC      8,EVEN            FRACTION TO OBTAIN THE MODIFIED\n       SDR     FR0,FR4             FRACTION R\n       LPER    FR0,FR0\n       SPACE\nEVEN   LA      GR1,4           GR1 = 4 FOR COSINE POLYNOMIAL\n       TM      OCTNT+3,X'03'     THIS IS FOR OCTANT 2, 3, 6, OR 7\n       BC      4,*+8           GR1 = 0 FOR SINE POLYNOMIAL\n       SR      GR1,GR1           THIS IS FOR OCTANT 1, 4, 5, OR 8\n       LER     FR4,FR0         LOAD FR4 WITH R FOR MULTIPLICATION\n       CE      FR0,UNFLO\n       BC      2,*+6           IF R**2 LST 16**-3, SET TO 0\n       SER     FR0,FR0           THIS AVOIDS IRRELEVANT UNDERFLOW\n       MER     FR0,FR0         COMPUTE SINE OR COSINE OF MODIFIED\n       LER     FR2,FR0           FRACTION USING PROPER CHEBYSHEV\n       ME      FR0,S3(GR1)         INTERPOLATION POLYNOMIAL\n       AE      FR0,SS2(GR1)\n       MER     FR0,FR2\n       AE      FR0,SS1(GR1)\n       MER     FR0,FR2\n       AE      FR0,S0(GR1)     SIN(R)/R OR COS(R) READY\n       MER     FR0,FR4         IF SINE POLYNOMIAL, MULTIPLY BY R\n       TM      OCTNT+3,X'04'\n       BC      8,*+6           IF MODIFIED OCTANT IS IN\n       LNER    FR0,FR0           LOWER PLANE, SIGN IS NEGATIVE\n       SPACE\n       FPRETURN\n       SPACE\nERSNCOS  FPERROR  'ARG TO SIN OR COS TOO LARGE (>PI*2**18)'\n     SPACE\n       DS      0D\nOCTNT  DS      F\nS3     DC      X'BD25B368'    -0.00003595   SIN C3\n       DC      X'BE14F17D'    -0.00031957   COS C3\nSS2    DC      X'3EA32F62'     0.00249001   SIN C2\nC2     DC      X'3F40ED0F'     0.01585108   COS C2\nSS1    DC      X'C014ABBC'    -0.08074543   SIN C1\nC1     DC      X'C04EF4EE'    -0.30842480   COS C1   +1F IN ABS\nS0     DC      X'40C90FDB'     0.78539816   SIN C0\nC0     DC      X'41100000'     1.00000000   COS C0\n       DC      X'00000000'\nONE    EQU     C0\n       DS      0D\nCRANK  DC      X'4600000000000000'\nFOVPI  DC      X'41145F306DC9C883'\nUNFLO  DC      X'3E100000'\nMAXCOS DC      X'45C90FDA'      PI*2**18\n         TITLE 'ARCTANGENT FUNCTION (SHORT) '\n*      CASE 2 --- ARCTAN\n*\n*              1. REDUCE THE CASE TO THE 1ST OCTANT BY USING\n*                   ATAN(-X)=-ATAN(X), ATAN(1/X)=PI/2-ATAN(X)\n*              2. REDUCE FURTHER TO THE CASE /X/ LESS THAN TAN(PI/12)\n*                   BY ATAN(X)=PI/6+ATAN((X*SQRT3-1)/(X+SQRT3)).\n*              3. FOR THE BASIC RANGE (X LESS THAN TAN(PI/12)), USE\n*                   A CONTINUED FRACTION APPROXIMATION\n       SPACE\n         SPACE\nARCTAN LER     FR0,FR6             GET ARG INTO WORK REG\n       STE     FR0,SIGN2         SAVE ITS SIGN\n       LPER    FR0,FR0         FORCE SIGN POSITIVE\n       LE      FR4,ONE2\n       SR      GR1,GR1         GR1 TO DENOTE THE SECTION TO WHICH\n       CER     FR0,FR4           ANSWER BELONGS. BREAK POINTS ARE\n       BC      12,REDUC            TAN(PI/12), TAN(PI/4), TAN(5PI/12)\n       LER     FR2,FR4         IF ARG GREATER THAN 1, TAKE INVERSE\n       DER     FR2,FR0           AND CRANK GR1 BY 8\n       LER     FR0,FR2\n       LA      GR1,8\n       SPACE\nREDUC  CE      FR0,SMALL2      IF ARG IS LESS THAN 16**-3, ANS=ARG.\n       BC      12,READY          THIS AVOIDS UNDERFLOW EXCEPTION\n       CE      FR0,TAN15       IF ARG GREATER THAN TAN(PI/12), REDUCE\n       BC      12,OK             THE ARG BY USING\n       LER     FR2,FR0             ATAN(X) = PI/6+ATAN(Y),\n       ME      FR0,RT3M1             WHERE Y = (X*SQRT3-1)/(X+SQRT3)\n       SER     FR0,FR4\n       AER     FR0,FR2\n       AE      FR2,RT3         COMPUTE X*SQRT3-1 AS X(SQRT3-1)-1+X\n       DER     FR0,FR2           TO PROTECT SIGNIFICANT DIGITS\n       LA      GR1,4(GR1)      CRANK GR1 BY 4\n       SPACE\nOK     LER     FR4,FR0         NOW MAGNITUDE OF REDUCED ARG IS\n       MER     FR0,FR0           LESS THAN TAN(PI/12)=0.26795\n       LER     FR2,FR0\n       ME      FR0,C           COMPUTE ANGLE BY\n       AE      FR2,A             ATAN(X)/X = D+C*XSQ+B/(XSQ+A)\n       LE      FR6,B\n       DER     FR6,FR2\n       AER     FR0,FR6\n       AE      FR0,D\n       MER     FR0,FR4\n       SPACE\nREADY  AE      FR0,ZERO(GR1)   DEPENDING ON THE SECTION TO WHICH\n       LPER    FR0,FR0           THE ANSWER BELONGS, ADD OR SUBTRACT\n*                                  REDUCED ANSWER FROM A BASE ANGLE\n       TM      SIGN2,X'80'      SIGN OF ANS SHOULD AGREE\n       BC      8,*+6             WITH SIGN OF ARG\n       LCER    FR0,FR0\n       FPRETURN\n       SPACE\n       SPACE\n         DS    0F\nA      DC      X'41168A5E'     1.4087812\nB      DC      X'408F239C'     0.55913709\nC      DC      X'BFD35F49'    -0.051604543\nD      DC      X'409A6524'     0.60310579\nLIM1   DC      X'06000000'\nLIM2   DC      X'FA000000'\nONE2   DC      X'41100000'\nPI     DC      X'413243F7'\nRT3    DC      X'411BB67B'     SQRT3\nRT3M1  DC      X'40BB67AF'     SQRT3-1\nSMALL2 DC      X'3E100000'\nTAN15  DC      X'40449851'     TAN 15 DEGREES\nZERO   DC      F'0'\n       DC      X'40860A92'     PI/6\nMPIOV2 DC      X'C11921FB'    -PI/2\n       DC      X'C110C152'    -PI/3\nSIGN2  DS      F\n       TITLE   'EXPONENTIAL FUNCTION (SHORT)'\n*\n*        CASE 3 --- EXP (SHORT)\n*              Y=X*LOG2(E)=4R-S-T, WHERE R AND S ARE INTEGERS, T\n*                FRACTION AND BOTH S AND T ARE NON-NEGATIVE.\n*              THEN E**X=2**Y=(16**R)(2**-S)(2**-T)\n       SPACE\n*      EXTRA SCRATCH REGS USED BY EXP\n       SPACE\nGR3    EQU     15\nGR4      EQU   2\nGR5      EQU   3\nGR6      EQU   4\n         SPACE 3\nEXP    SDR     FR0,FR0         CLEAR FR0 DOUBLE\n       LER     FR0,FR6         GET ARGUMENT INTO A WORK REG\n       CE      FR0,MAXEXP\n       BC      2,ERREXP        IF TOO BIG, ERROR\n       CE      FR0,MINEXP\n       BC      12,SMALL3       IF TOO SMALL, GIVE 0\n       SPACE\n       MD      FR0,LOG16E      EFFECT MPY BY LOG E BASE 16 AND SCALE\n       AW      FR0,CH46          TO B24 WITHOUT CAUSING PREMAT UNDFLO\n       STD     FR0,BUFF        /R/ IN H.O. FR0, /S+T/ IN L.O. FR0\n       LM      GR2,GR3,BUFF    /R/ IN GR2, /S+T/ IN GR3\n       BC      12,NEG3         IF X NON-POSITIVE, JUMP\n       X       GR2,ALLF        IF X POSITIVE, -R = -R(R'+1) IN GR2,\n       X       GR3,ALLF          S+T = 4-(S'+T') IN GR3\n       SPACE\nNEG3   LA      GR6,X'FC0'(GR2) SUBTRACT BASE CHARACTERISTIC FROM R\n       SLL     GR6,24\n       SR      GR2,GR2         CLEAR GR2 TO RECEIVE S\n       SLDL    GR2,2           S IN GR2 LOW, T IN GR3 HIGH\n       SRL     GR3,4           T                         (B3)\n       LR      GR1,GR3         SAVE T       IN GR3       (B3)\n       MR      GR0,GR1         T*T                       (B7)\n       LR      GR5,GR0\n       M       GR4,C3         C3*T*T        IN GR4       (B4)\n       A       GR0,A3\n       LR      GR5,GR0         A+T*T        IN GR5       (B7)\n       L       GR0,B3\n       DR      GR0,GR5         B/(A+T*T)    IN GR1       (B3)\n       SR      GR1,GR3\n       SRL     GR1,1           -T+B/(A+T*T) IN GR1       (B4)\n       A       GR1,D3\n       AR      GR1,GR4         C*T*T+D-T+B/(A+T*T)       (B4)\n       LR      GR4,GR3\n       SRL     GR4,2           2*T                       (B6)\n       DR      GR4,GR1         2*T/(C*T*T+D-T+B/(A+T*T)) (B1)\n       SRA     GR5,5\n       A       GR5,FXONE       2**(-T) READY             (B6)\n       SRL     GR5,0(GR2)      (2**-S)(2**-T) READY      (B6)\n       S       GR5,ALLF        ROUND AND\n       C       GR5,FXONE         FLOAT THIS NUMBER\n       SRL     GR5,1\n       BC      4,JOIN\n       L       GR5,ONE3\n       SPACE\nJOIN   SR      GR5,GR6         ADJUST CHARACTERISTIC WITH -R\n       ST      GR5,BUFF\n       LE      FR0,BUFF\n       SPACE\nEXIT3  L       R15,PR15\n         CLI   TIMELEFT,0          CHECK IF TIMER RAN OUT DURING\n         BE    FPTIMOUT            EXP MONITOR CALL. IF SO, GIVE ERROR.\n         LM    R13,R4,ORGPSCLR+8(R15)  OTHERWISE, RETURN TO USER.\n       BR      LINK\nSMALL3 SER     FR0,FR0\n       B       EXIT3\n       SPACE\nERREXP FPERROR 'ARGUMENT TO EXP TOO LARGE (>174.673)'\n      SPACE\n       DS      0D\nALLF   DC      X'FFFFFFFF'\nA3     DC      X'576AE119'     87.4174972   (B7)\nB3     DC      X'269F8E6B'     617.972269   (B11)\nC3     DC      X'B9059003'    -0.034657359  (B-4)\nD3     DC      X'B05CFCE3'    -9.95459578   (B4)\nFXONE  DC      X'02000000'     1            (B6)\nMAXEXP DC      X'42AEAC4F'     174.673\nMINEXP DC      X'C2B437E0'    -180.218\nONE3   DC      X'01100000'\n       DS      0D\nCH46   DC      X'4700000000000000'       X'46000...00' RAISED BY 1\nLOG16E DC      X'415C551D94AE0BF8'       (LOG E BASE 16)*16\n       TITLE   'LOGARITHMIC FUNCTION (SHORT)'\n*        CASE 4 --- LN\n*\n*              1. WRITE X = (M*2**-Q)*16**P, M MANTISSA BETWEEN 1/2\n*                   AND 1, Q INTEGER BETWEEN 0 AND 3. DEFINE A=1, B=0\n*                     IF M GREATER THAN SQRT2/2, OTHERWISE A=1/2, B=1.\n*              2. WRITE Z = (M-A)/(M+A), THEN\n*                   LOG(X) = (4P-Q-B)LOG(2)+LOG((1+Z)/(1-Z)).\n       SPACE\nLN     LTER    FR6,FR6         TEST SIGN OF ARGUMENT. IF ZERO OR\n       BNP     ERRORLN         NEGATIVE GIVE ERROR MESSAGE\n       STE     FR6,BUFF        GET ARG INTO GR0\n       L       GR0,BUFF\n       LR      GR2,GR0\n       SRDL    GR0,24          MANTISSA IN HIGH GR1\n       SLL     GR0,2\n       STH     GR0,IPART+2     FLOAT 4*CHAR AND SAVE IT\n       SRL     GR1,29          FIRST THREE BITS OF MANTISSA IN GR1\n       IC      GR1,TABLE(GR1)  NUMBER OF LEADING ZEROS (=Q) IN GR1\n       SLL     GR2,0(GR1)      SHIFT MANTISSA LEFT BY Q\n       ST      GR2,BUFF\n       MVI     BUFF,X'40'      M=MANTISSA*2**Q IN BUFF\n       SR      GR2,GR2\n       LE      FR0,BUFF        PICK UP M IN FR0\n       CE      FR0,LIMIT       IF M GREATER THAN SQRT(2)/2, GR2=0\n       BC      2,READY4\n       LA      GR2,4           IF M LESS THAN SQRT(2)/2, GR2=4\n       LA      GR1,1(GR1)        AND CRANK GR1 BY 1. Q+B IN GR1\n       SPACE\nREADY4 LD      FR2,ROUND       PRELOAD FR2 WITH ROUNDING FUDGE\n       HER     FR4,FR0         COMPUTE 2Z=(M-A)/(0.5M+0.5A)\n       SE      FR0,ONE4(GR2)      A=1 IF GR2=0, A=1/2 IF GR2=4\n       BC      7,*+6\n       SDR     FR2,FR2           AVOID POSSIBLE UNDERFLOW INTERRUPT\n       AE      FR4,HALF4(GR2)       WHEN ARG IS AN EXACT POWER OF 2\n       DER     FR0,FR4\n       LER     FR2,FR0         COMPUTE LOG((1+Z)/(1-Z)) USING A\n       MER     FR0,FR0           MINIMAX APPROXIMATION OF THE FORM\n       LE      FR4,B4              W+W(A*W**2/(B-W**2)), WHERE W=2Z\n       SER     FR4,FR0\n       ME      FR0,A4\n       DER     FR0,FR4\n       MER     FR0,FR2\n       ADR     FR2,FR0           EFFECTIVE ROUNDING HERE\n       SPACE\n       LE      FR0,IPART       4*(P+64)\n       LA      GR1,256(GR1)    4*64+Q+B\n       STH     GR1,IPART+2\n       SE      FR0,IPART       4*P-Q-B\n       ME      FR0,LOGE2\n       ADR     FR0,FR2         NATURAL LOG READY\n       SPACE\n       FPRETURN\n       SPACE\nERRORLN  FPERROR 'ARGUMENT TO LN 0.0 OR NEGATIVE'\n         SPACE\n       DS      0D\nA4     DC      X'408D8BC7'     0.55291406\nB4     DC      X'416A298C'     6.63515366\nIPART  DC      X'46000000F0000000'   INTEGER PART + ROUNDING FUDGE\nROUND  EQU     IPART\nLIMIT  DC      X'40B504F3'     SQRT(2)/2\nLOGE2  DC      X'40B17219'     LOG(2) BASE E + FUDGE 1\nLOGTE  DC      X'406F2DED'     LOG(E) BASE 10 + FUDGE 1\nONE4   DC      X'41100000'     1       THESE THREE\nHALF4  DC      X'40800000'     1/2       CONSTANTS MUST\n       DC      X'40400000'     1/4         BE CONSECUTIVE\nTABLE  DC      X'0302010100000000'\n       TITLE   'SQUARE ROOT FUNCTION (SHORT)'\n*        CASE 5 --- SQRT\n*\n*              1. WRITE X = M*16**(2P+Q), M MANTISSA, Q = 0 OR 1.\n*              2. THEN SQRT(X) = SQRT(M*16**-Q)*16**(P+Q).\n       SPACE\nSQRT   LER     FR0,FR6\n       LTER    FR2,FR0\n       BZ      EXIT5           IF ARG IS 0, ANSWER IS 0. RETURN.\n       BM      ERRSQRT         NEGATIVE ARG IS A NO-NO.\n       STE     FR2,BUFF        GET ARG INTO GR0\n       L       GR0,BUFF\n       SRDL    GR0,25\n       SLL     GR0,24          CHAR OF ANSWER MINUS Q+32\n       SRA     GR1,3           SIGN BIT OF GR3 = Q. SCALE Q+M TO B3\n       BC      11,*+8\n       A       GR0,BIAS        IF Q=1, ADD 1 TO CHAR AND 4 FOR INDEXING\n       LR      GR2,GR0\n       A       GR1,C5(GR2)      OBTAIN 1ST APPROX BY A HYPERBOLIC FIT\n       L       GR0,B5(GR2)        OF THE RESPECTIVE INTERVAL.\n       DR      GR0,GR1             IF Q=1, INTERPRET M AS M/16 (B-1)\n       A       GR1,A5(GR2)\n       ALR     GR1,GR2         ADD ON CHAR-32 TO COMPLETE 1ST APPROX\n       ST      GR1,BUFF\n       MVC     ROUND5(1),BUFF   GIVE ROUND CHARACTERISTIC OF ANSWER\n       SPACE\n       DE      FR0,BUFF        GIVE TWO PASSES OF NEWTON-RAPHSON\n       AU      FR0,BUFF          ITERATION\n       HER     FR0,FR0\n       DER     FR2,FR0         (X/Y1+Y1)/2 = (Y1-X/Y1)/2+X/Y1 TO GUARD\n       AU      FR0,ROUND5        LAST DIGIT-.  ADD ROUNDING FUDGE\n       SER     FR0,FR2\n       HER     FR0,FR0\n       AER     FR0,FR2\n       SPACE\nEXIT5  FPRETURN\n       SPACE\nERRSQRT  FPERROR  'NEGATIVE ARGUMENT TO SQRT'\n       SPACE\n       DS      0D\nBIAS   DC      X'01000004'\nA5     DC      X'21AE7D00'     1.6815948    A0 (B7) + 32 (B7)\n       DC      X'206B9F3C'     0.4203987    A1 (B7) + 32 (B7) - 4 (B31)\nB5     DC      X'FFEB605E'    -1.2889728    B0 (B11)\n       DC      X'FFFAD818'    -0.0201402    B1 (B7)\nC5     DC      X'0D73F185'     0.8408065    C0 (B3)\n       DC      X'1D73F185'     0.0525504    C1 (B-1) + 1 (B3)\nROUND5 DC      X'00000001'\n      TITLE   '     '\n*\n*        CASES 6..12 ARE RESERVED FOR FUTURE USE.\n*\n         SPACE 5\nCASE6    DS    0H\nCASE7    DS    0H\nCASE8    DS    0H\nCASE9    DS    0H\nCASE10   DS    0H\nCASE11   DS    0H\nCASE12   DS    0H\n         SRVRTNED  ,               RETURN;\n         EJECT\n*\n*        CASE 13 --- EOLN\n*\n         SPACE 5\nEOLN     DS    0H\n         CHKFILE INPUT\n         CLC   INPTR,=H'80'        END OF LINE REACHED?\n         BNE   EOLN1               IF NOT,DOBRANCH\n         LA    R9,1                INDICATE ON IN RETURN REGISTER\n         B     EOLN2               BRANCH\nEOLN1    LA    R9,0                INDICATE OFF\nEOLN2    SRVRTNED\n         SPACE 5\nFILEERR  BAL   LINKREG,ERROR\n         DC    AL1(L'FILEERRM)\nFILEERRM DC    C'NONSTANDARD FILES NOT YET IMPLEMENTED'\n         EJECT\n*\n*        CASE 14 --- EOF\n*\n         SPACE 5\nEOF      DS    0H\n         CHKFILE INPUT\n         CLI   ENDFILE,X'FF'       END OF FILE INDICATION ON?\n         BNE   EOF1                IF NOT,DO BRANCH\n         LA    R9,1                INDICATE ON IN RETURN REGISTER\n         B     EOF2                BRANCH\nEOF1     LA    R9,0                INDICATE OFF\nEOF2     SRVRTNED\n         EJECT\n*\n*        CASE 15 --- NEW\n*\n         SPACE 5\nNEW      DS    0H                  DO;\n         LA    R9,3(0,R9)             J = (ARG1 + 3) & \"FFFFFFFC\";\n         N     R9,=X'FFFFFFFC'\n         L     R1,ORGORGN             HEAP_PTR = HEAP_PTR - J;\n         L     R2,HEAPPTR(0,R1)\n         SR    R2,R9\n         ST    R2,HEAPPTR(0,R1)\n         L     R3,MAXTOP(0,R1)        MAX_TOP = MAX_TOP - J;\n         SR    R3,R9\n         ST    R3,MAXTOP(0,R1)\n         L     R4,STACKTOP(0,R1)      IF MAX_TOP < STACKTOP THEN\n         CR    R3,R4\n         BNL   NEW1\n         LA    LINKREG,MEMERR            CALL ERROR(MEMORY_ERROR);\n         B     ERROR\nNEW1     LR    R9,R2                  RETURNS = HEAP_PTR;\n         SRVRTNED  ,               END;\n         SPACE 3\nSTACKTOP EQU   ORGPSCLR+8          /* WHERE STACKTOP REGISTER IS STORED\n*                                     IN ORG SEGMENT. */\n         EJECT\n*\n*        CASE 16 --- DISPOSE\n*\n         SPACE 5\nDISPOSE  DS    0H                  DO;\n*                                     /***** NOT IMPLEMENTED YET *****/\n         SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 17 --- GET\n*\n         SPACE 5\nGET      DS    0H                  DO;\n         CHKFILE INPUT\n         BAL   LINKREG,NEXTCH         CALL NEXTCH;\n         SRVRTNED  ,               END;\n         EJECT\nOUTLINE  DC    CL133'1'            BUFFER FOR PRINTED OUTPUT.\nOUTLINEP DC    A(OUTLINE)          DESCRIPTOR FOR CURRENT OUTPUT LINE.\nLINEST   DS    F                   ESTIMATE OF PRINTED LINES\n         EJECT\n*\n*        CASE 18 --- PUT\n*\n         SPACE 5\nPUT      DS    0H                  DO;\n         CHKFILE OUTPUT\n         L     R1,OUTLINEP            OUT_LINE =\n         L     R2,PR14                   OUT_LINE || OUTPUT@;\n         LA    R2,OUTPUT@(0,R2)\n         BAL   LINKREG,CATENATE\n         ST    R1,OUTLINEP\n         SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 19 --- RESET\n*\n         SPACE 5\nRESET    DS    0H                  DO;\n*                                     /***** NOT YET IMPLEMENTED *****/\n         B     FILEERR\n*        SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 20 --- REWRITE\n*\n         SPACE 5\nREWRITE  DS    0H                  DO;\n*                                     /***** NOT YET IMPLEMENTED *****/\n         B     FILEERR\n*        SRVRTNED  ,               END;\n         EJECT\n*\n*        ROUTINE ERROR\n*\n*        PURPOSE : WRITE AN ERROR MESSAGE\n*\n         SPACE 5\nERROR    STM   R13,R3,ERRORR12\n         ST    LINKREG,ERRORAUX\n         LA    R1,4                LINEST<---4\n         ST    R1,LINEST\n         L     R1,OUTLINEP         IS LENGTH(OUT_LINE) > 1?\n         SRA   R1,24\n         BZ    ERROR1              NO, SO BRANCH\n         BAL   LINKREG,PUTLN       WRITE THE EXISTING LINE\nERROR1   LA    R10,0(0,R10)        CLEAR THE HIGH ORDER BYTE\n         ST    R10,ERRLINE         ERRLINE<---SOURCE LINE OF ERROR\n         BAL   LINKREG,SRCLINE\n         L     R1,=V(OUTPUT0)\n         PUT   (R1)                R1 POINTS TO BUFFER\n         MVC   0(133,R1),ERRORC    WRITE THE ERRORC LINE\n*\n*        PRINT THE ERROR MESSAGE\n*\n         MVI   OUTLINE,C' '\n         MVC   OUTLINE+1(ERRORC1L),ERRORC1\n         LA    R1,ERRORC1L         LENGTH(OUT_LINE) - 1\n         SLL   R1,24               SHIFT TO HIGH ORDER BYTE.\n         LA    R2,OUTLINE\n         OR    R1,R2               R1<---DESCRIPTOR FOR OUT_LINE\n         L     R3,ERRORAUX         R3<---POINTER TO ERROR MESSAGE.\n         SR    R2,R2\n         IC    R2,0(0,R3)          R2<---LENGTH(ERROR MESSAGE).\n         BCTR  R2,0                LENGTH(ERROR MESSAGE) - 1.\n         SLL   R2,24               SHIFT TO HIGH ORDER BYTE.\n         LA    R3,1(0,R3)          ADDR OF ERROR MESSAGE\n         OR    R2,R3               FORM DESCRIPTOR.\n         BAL   LINKREG,CATENATE    CONCATENATE MESSAGE ONTO LINE.\n         ST    R1,OUTLINEP\n         L     R1,ERRLINE          SOURCE LINE IN R1\n         LTR   R1,R1               SUCCESSFULLY COMPUTED?\n         BNP   ERROR2\n         BAL   LINKREG,INT2STR     CONVERT NUMBER TO STRING.\n         LR    R2,R1               STRING DESCRIPTOR IN R2\n         L     R1,NEARLINE         DESCRIPTOR FOR 'NEAR LINE' MESSAGE\n         BAL   LINKREG,CATENATE    CONCATENATE\n         LR    R2,R1               DESCRIPTOR IN R2.\n         L     R1,OUTLINEP         DESCRIPTOR OF  MESSAGE LINE\n         BAL   LINKREG,CATENATE    CONCATENATE LINE NUMBER INFO\n         ST    R1,OUTLINEP\nERROR2   L     R1,OUTLINEP         DESCRIPTOR IN R1\n         L     R2,ERROREOM         DESCRIPTOR FOR MESSAGE TRAILER CHARS\n         BAL   LINKREG,CATENATE    COMPLETES MESSAGE\n         ST    R1,OUTLINEP         SAVE DESCRIPTOR\n         BAL   LINKREG,PUTLN       WRITE THE MESSAGE.\n         MVI   ERRLINE,X'FF'       INDICATE A RUN ERROR DEVELOPED\n         LM    R13,R3,ERRORR12\n         B     ENDMNTR             BACK TO OV MONITOR\n         SPACE 3\n         DS    0F                  STRING DESCRIPTORS\nERROREOM DC    AL1(L'ERRORC2-1),AL3(ERRORC2)\nNEARLINE DC    AL1(L'NRLINE-1),AL3(NRLINE)\n         SPACE 1\nERRORC2  DC    C'. ***'            THE FIELD ERRORC2\nERRORC1  DC    C'*** RUN ERROR, '  THE FIELD ERRORC1\nERRORC1L EQU   L'ERRORC1\nNRLINE   DC    C' -- NEAR LINE '\nERRORC   DC    C'0',132C'-'        THE LINE ERRORC\nERRORR12 DS    7F\nERRORAUX DS    F\n         EJECT\n*\n*        PROGRAM INTERRUPT EXIT ROUTINE\n*\n         SPACE 5\nPGMCHK   DS    0H                  SYSTEM ENTERS HERE.\n         DROP  BASE1,BASE2,BASE3\n         USING PGMCHK,R15\n         STM   R11,R12,SPIESAVE    SAVE REGISTERS 11 AND 12.\n         LM    BASE3,BASE1,SPIEBASE LOAD BASE1, BASE2, AND BASE3.\n         DROP  R15\n         USING MONITOR,BASE1,BASE2,BASE3\n         SR    R2,R2               CLEAR REGISTER 2.\n         L     R3,8(0,R1)          WORD 2 OF OLD PSW IN R3.\n         SLDL  R2,3                2 * INSTRUCTION LENGTH CODE IN R2.\n         LNR   R2,R2\n         SRL   R3,3\n         LA    R3,0(R2,R3)         ADDRESS OF INTERRUPTED INSTRUCTION\n*                                     IN R3.\n         LH    R4,6(0,R1)          INTERRUPTION CODES IN R4.\n         MVC   9(3,R1),APGMCHK1+1  RESUME EXECUTION AT PGMCHK1.\n         BR    R14                 RETURN TO O.S.\nPGMCHK1  DS    0H                  RESUME EXECUTION HERE.\n         C     R3,CODEPNT          WAS INTERRUPT IN PASCAL CODE?\n         BL    PGMCHK2             NO, GO CALL ERROR.\n         C     R3,PR14\n         BNL   PGMCHK2\n*\n*        PROGRAM INTERRUPT IN PASCAL CODE.\n*\n         LR    R10,R3              SET ERROR LOCATION.\n         L     R2,PR15             ADDRESS OF ORG SEGMENT.\n         MVC   ORGPSCLR(8,R2),SPIESAVE PLANT PASCAL REGS. 11, 12.\nPGMCHK2  LA    R3,X'F'\n         NR    R4,R3               INTERRUPT_CODE & \"F\"\n         SLL   R4,2\n         L     LINKREG,SPIEERRM(R4) ADDRESS OF MESSAGE.\n         B     ERROR               CALL ERROR.\n         SPACE 5\nPICAADDR DS    A                   ADDRESS OF OLD PICA.\nSPIESAVE DS    2F                  SAVE AREA FOR R11, R12.\nSPIEBASE DC    A(MONITOR+8192),A(MONITOR+4096),A(MONITOR)\nAPGMCHK1 DC    A(PGMCHK1)\nSPIEERRM DS    0F                  TABLE OF ERROR MESSAGE POINTERS.\n         DC    A(SPIE0),A(SPIE1),A(SPIE2),A(SPIE3),A(SPIE4),A(SPIE5)\n         DC    A(SPIE6),A(SPIE7),A(SPIE8),A(SPIE9),A(SPIEA),A(SPIEB)\n         DC    A(SPIEC),A(SPIED),A(SPIEE),A(SPIEF)\n*\n*        SPIE ERROR MESSAGES.\n*\nSPIE0    DC    AL1(L'SPIE0M)\nSPIE0M   DC    C'IMPRECISE OR MULTIPLE-IMPRECISE PROGRAM INTERRUPTION'\nSPIE1    DC    AL1(L'SPIE1M)\nSPIE1M   DC    C'OPERATION EXCEPTION'\nSPIE2    DC    AL1(L'SPIE2M)\nSPIE2M   DC    C'PRIVILEGED-OPERATION EXCEPTION'\nSPIE3    DC    AL1(L'SPIE3M)\nSPIE3M   DC    C'EXECUTE EXCEPTION'\nSPIE4    DC    AL1(L'SPIE4M)\nSPIE4M   DC    C'PROTECTION EXCEPTION'\nSPIE5    DC    AL1(L'SPIE5M)\nSPIE5M   DC    C'ADDRESSING EXCEPTION'\nSPIE6    DC    AL1(L'SPIE6M)\nSPIE6M   DC    C'SPECIFICATION EXCEPTION'\nSPIE7    DC    AL1(L'SPIE7M)\nSPIE7M   DC    C'DATA EXCEPTION'\nSPIE8    DC    AL1(L'SPIE8M)\nSPIE8M   DC    C'INTEGER OVERFLOW'\nSPIE9    DC    AL1(L'SPIE9M)\nSPIE9M   DC    C'INTEGER DIVISION BY ZERO'\nSPIEA    DC    AL1(L'SPIEAM)\nSPIEAM   DC    C'DECIMAL OVERFLOW EXCEPTION'\nSPIEB    DC    AL1(L'SPIEBM)\nSPIEBM   DC    C'DECIMAL DIVISION EXCEPTION'\nSPIEC    DC    AL1(L'SPIECM)\nSPIECM   DC    C'REAL EXPONENT OVERFLOW'\nSPIED    DC    AL1(L'SPIEDM)\nSPIEDM   DC    C'REAL EXPONENT UNDERFLOW'\nSPIEE    DC    AL1(L'SPIEEM)\nSPIEEM   DC    C'REAL SIGNIFICANCE EXCEPTION'\nSPIEF    DC    AL1(L'SPIEFM)\nSPIEFM   DC    C'REAL DIVISION BY ZERO'\n         EJECT\n*\n*        PROCEDURE SOURCE_LINE\n*\n*        PURPOSE: COMPUTES THE SOURCE LINE WHICH CORRESPONDS TO AN\n*                 ADDRESS IN THE PASCAL CODE SEGMENT.\n*\n*        INPUT:  ABSOLUTE ADDRESS, IN LOCATION ERRLINE.\n*\n*        OUTPUT: LINE NUMBER, IN LOCATION ERRLINE.\n*\n        SPACE 5\nSRCLINE  DS    0H\n         STM   R14,R4,SRCLSAVE     /* SAVE REGISTERS */\n         SR    R3,R3               LINE# = 0;\n         CLC   ERRLINE,CODEPNT     IF (ERRLINE < CODE_POINTER)\n         BL    LINE#RTN\n         CLC   ERRLINE,PR14           | (ERRLINE >= GLOBAL_ARBASE) THEN\n         BNL   LINE#RTN            RETURN 0;\n         L     R2,ERRLINE          RELATIVE_ADDR =\n         S     R2,CODEPNT             ERRLINE - CODE_POINTER;\n*\n*        OPEN THE LINE NUMBER FILE, AND READ THE 1ST 80-BYTE RECORD.\n*\n         OPEN  LINE#DCB\n         LA    R1,LINE#DCB         BUFFER = INPUT(LINE#_FILE);\n         GET   (R1)\n*\n*        R1 NOW POINTS TO THE 1ST RECORD OF LINE NUMBER INFORMATION.\n*        THE LAST RECORD HAS THE CHARACTERS '%END' IN COLUMNS 1..4.\n*        ALL OTHER RECORDS ARE DIVIDED INTO 20 4-COLUMN BINARY FIXED\n*        FULLWORD NUMBERS.\n*\nSRCLINE1 CLI   0(1),C'%'           DO WHILE (BYTE(BUFFER) \u00ac= BYTE('%'))\n         BE    LINE#RTN                     & (LAST_#_IN_BUFFER <=\n         C     R2,76(0,R1)                             RELATIVE_ADDR);\n         BL    SRCLINE2\n         LA    R3,20(0,R3)            LINE# = LINE# + 20;\n         LA    R1,LINE#DCB            BUFFER = INPUT(LINE#_FILE);\n         GET   (R1)                END;\n         B     SRCLINE1\nSRCLINE2 DS    0H                  IF BYTE(BUFFER) = BYTE('%') THEN\n*                                     RETURN LINE#;\n         LA    R4,18               I = 18;\nSRCLINE3 LTR   R4,R4               DO WHILE (I > 0)\n         BM    LINE#RTN               & (ITH_#_IN_BUFFER >\n         SLL   R4,2                         RELATIVE_ADDR);\n         C     R2,0(R4,R1)\n         SRL   R4,2\n         BNL   SRCLINE4\n         BCTR  R4,0                   I = I - 1;\n         B     SRCLINE3            END;\nSRCLINE4 LA    R3,1(R3,R4)         RETURN LINE# + I + 1;\nLINE#RTN ST    R3,ERRLINE\n*\n*        CLOSE THE LINE NUMBER FILE\n*\n         CLOSE LINE#DCB\n         LA    R1,LINE#DCB\n         TM    DCBBUFCB+3(R1),1\n         BO    SRCLINE5\n         FREEPOOL (R1)\nSRCLINE5 LM    R14,R4,SRCLSAVE\n         BR    LINKREG\n         SPACE 3\nSRCLSAVE DS    7F\n         PRINT NOGEN\nLINE#DCB DCB   DDNAME=SYSUT4,DSORG=PS,MACRF=GL\n         PRINT GEN\n         EJECT\n*\n*        CASE 21 --- READ_INT\n*\n         SPACE 5\nREADINT  DS    0H\n         CHKFILE INPUT\n         MVI   READINTS,X'00'      INTEGER SIGN IS POSITIVE.ASSUMPTION\n         LA    R9,0                R9<---0.R9 CONTAINS THE VALUE OF THE\n*                                  READ INTO INTEGER\n         L     R2,PR14             R2 POINTS TO GLBL AR AREA\n         B     READINT9\nREADINT1 BAL   LINKREG,NEXTCH      READ NEXT CHARACTER\nREADINT9 CLI   INPUT@(R2),C' '     IS IT A BLANK?\n         BE    READINT1            IF YES,DO BRANCH\n         CLI   INPUT@(R2),C'-'     IS IT A '-' ?\n         BNE   READINT2            IF NOT,DO BRANCH\n         MVI   READINTS,X'FF'      INDICATE SIGN IS NEGATIVE\nREADINT4 BAL   LINKREG,NEXTCH      READ NEXT CHARACTER\n         B     READINT3            PROCEED\nREADINT2 CLI   INPUT@(R2),C'+'     IS IT A '+' ?\n         BE    READINT4            IF YES,DO BRANCH\nREADINT3 CLI   INPUT@(R2),C'0'     IS IT A DIGIT ?\n         BL    READINTE            IF NOT,ISSUE AN ERROR MESSAGE\n         CLI   INPUT@(R2),C'9'     IS IT A DIGIT ?\n         BH    READINTE            IF NOT,ISSUE AN ERROR MESSAGE\nREADINT6 LA    R4,0                R4<---0\n         IC    R4,INPUT@(R2)       R4 HOLDS THE DIGIT\n         S     R4,=A(X'F0')        R4 HOLDS ITS BINARY VALUE\n         C     R9,MAX10            R9<MAX10 ?\n         BNL   READINT5            IF NOT,DO BRANCH\nREADINT7 MH    R9,=H'10'           R9<----R9*10\n         AR    R9,R4               R9<---R9+R4\n         BAL   LINKREG,NEXTCH      READ NEXT CHARACTER\n         CLI   INPUT@(R2),C' '     IS IT A BLANK ?\n         BE    READINTF            IF YES,DO BRANCH\n         CLI   INPUT@(R2),C'0'     IS IT A DIGIT ?\n         BL    READINTF            IF NOT,DO BRANCH\n         CLI   INPUT@(R2),C'9'     IS IT A DIGIT ?\n         BH    READINTF            IF NOT,DO BRANCH\n         B     READINT6            PROCEED\nREADINT5 BH    READIE1             IF R9>MAX10 , ERROR MESSAGE\n         C     R4,RES10            R4>RES10\n         BNH   READINT7            IF NOT,DO BRANCH\n         CLI   READINTS,X'FF'      IS IT A NEGATIVE INTEGER ?\n         BNE   READIE1             IF NOT,ISSUE AN ERROR MESSAGE\n         BCTR  R4,0                R4<---R4-1\n         C     R4,RES10            R4>RES10\n         BNE   READIE1             IF YES,ISSUE AN ERROR MESSAGE\n         L     R9,READINTC         IF NOT , SET INTEGER VALUE\n         BAL   LINKREG,NEXTCH\n         CLI   INPUT@(R2),C' '\n         BE    READINT8\n         CLI   INPUT@(R2),C'0'\n         BL    READINT8\n         CLI   INPUT@(R2),C'9'\n         BH    READINT8\n         B     READIE1\nREADINTF CLI   READINTS,X'FF'      IS THE INTEGER NEGATIVE ?\n         BNE   READINT8            IF NOT,DO BRANCH\n         LCR   R9,R9               R9<--- -R9\nREADINT8 SRVRTNED\n         SPACE 3\nREADIE1  BAL   LINKREG,ERROR\n         DC    AL1(L'READIEM2)\nREADIEM2 DC    C'WHILE READING INTEGER CONSTANT -- VALUE OUT OF RANGE'\nREADINTE BAL   LINKREG,ERROR\n         DC    AL1(L'READIEM1)\nREADIEM1 DC    C'WHILE READING INTEGER CONSTANT - DIGIT EXPECTED'\nRES10    DC    A(7)                REMAINDER OF X'7FFFFFFF'/10\nMAX10    DC    F'214748364'        EQUAL TO X'7FFFFFFF'/10\nREADINTC DS    0F                  MOST NEGATIVE INTEGER VALUE\n         DC    X'80'\n         DC    AL3(0)\nREADINTS DS    X                   SIGN OF THE INTEGER\n         EJECT\nPOWERS   POWERS                    CALL MACRO POWERS (= EXPANDS POWERS)\n         EJECT\n*\n*        CASE 22 --- READ_REAL\n*\n         SPACE 5\nREADREAL DS    0H\n         CHKFILE INPUT\n         MVI   RSIGN,X'00'         ASSUME POSITIVE\n         MVI   REXPSIGN,X'00'      ASSUME POSITIVE\n         LA    R2,0                R2 IS NUMBER\n         LA    R3,0                R3 IS SCALE\n         LA    R4,0                R4 IS EXPONENT\n         L     R5,PR14             R5 POINTS TO GLBL AR AREA\nREADRE2  CLI   INPUT@(R5),C' '     CURRENT INPUT CHARACTER IS ABLANK ?\n         BNE   READRE1             IF NOT,DO BRANCH\n         BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         B     READRE2             LOOP\nREADRE1  CLI   INPUT@(R5),C'-'     IS IT A MINUS ?\n         BNE   READRE3             IF NOT,DO BRANCH\n         MVI   RSIGN,X'FF'         IF YES,SET RSIGN TO ON\n         BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         B     READRE4             PROCEED\nREADRE3  CLI   INPUT@(R5),C'+'     IS IT A '+' ?\n         BNE   READRE4             IF NOT,DO BRANCH\n         BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\nREADRE4  CLI   INPUT@(R5),C'0'     IS IT A DIGIT ?\n         BL    READREE1            IF NOT,ERROR MESSAGE\n         CLI   INPUT@(R5),C'9'     IS IT A DIGIT ?\n         BH    READREE1            IF NOT,ERROR MESSAGE\nREADRE7  C     R2,MAX10            NUMBER LOWER THAN MAX10 ?\n         BNL   READRE5             IF NOT,DO BRANCH\n         MH    R2,=H'10'           NUMBER<---NUMBER*10\n         LA    R6,0                R6<---0\n         IC    R6,INPUT@(0,R5)     R6<---INPUT@\n         SLL   R6,28               R6<---\n         SRL   R6,28                       INPUT@-C'0'\n         AR    R2,R6               NUMBER<---NUMBER+DIGIT\n         B     READRE6             PROCEED\nREADRE5 LA     R3,1(0,R3)          SCALE<---SCALE+1\nREADRE6  BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         CLI   INPUT@(R5),C'0'     IF NOT,DO BRANCH\n         BL    READRE8\n         CLI   INPUT@(R5),C'9'     IS IT A DIGIT ?\n         BH    READRE8             IF NOT,DO BRANCH\n         B     READRE7             LOOP\nREADRE8  CLI   INPUT@,C'.'         IS THE CURRENT CHARACTER A DECIMAL\n*                                  POINT\n         BNE   READR011            IF NOT,DO BRANCH\n*        READ FRACTION\n         BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         CLI   INPUT@(R5),C'0'     IS IT A DIGIT ?\n         BL    READREE1            IF NOT,ERROR MESSAGE\nREADRE9  CLI   INPUT@(R5),C'9'     IS IT A DIGIT ?\n         BH    READREE1            IF NOT,ERROR MESSAGE\nREADRE11 C     R2,MAX10            NUMBER LOWER THAN MAX10 ?\n         BNL   READRE10            IF NOT,DO BRANCH\n         MH    R2,=H'10'           NUMBER<---NUMBER*10\n         LA    R6,0                R6<---0\n         IC    R6,INPUT@(0,R5)     R6<----INPUT@\n         SLL   R6,28               R6<---\n         SRL   R6,28                       INPUT@-C'0'\n         AR    R2,R6               NUMBER<---NUMBER+DIGIT VALUE\n         SH    R3,=H'1'            SCALE<---SCALE-1\nREADRE10 BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         CLI   INPUT@(R5),C'0'     IS IT A DIGIT ?\n         BL    READR011            IF NOT,DO BRANCH\n         CLI   INPUT@(R5),C'9'     IS IT A DIGIT ?\n         BH    READR011            IF NOT,DO BRANCH\n         B     READRE11            IF YES,DO LOOP\nREADR011 CLI   INPUT@(R5),C'E'     IS CURRENT INPUT CHARACTER A 'E' ?\n         BNE   READRE12            IF NOT,DO BRANCH\n*        READ EXPONENT\n         BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         CLI   INPUT@(R5),C'-'     IS IT A '-' ?\n         BNE   READRE13            IF NOT,DO BRANCH\n         MVI   REXPSIGN,X'FF'      IF YES,SET REXPSIGN TO ON\n         BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         B     READR014            PROCEED\nREADRE13 CLI   INPUT@(R5),C'+'     IS IT A '+' ?\n         BNE   READR014            IF NOT,DO BRANCH\n         BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\nREADR014 CLI   INPUT@(R5),C'0'     IS IT A DIGIT ?\n         BL    READREE1            IF NOT,ERROR MESSAGE\n         CLI   INPUT@(R5),C'9'     IS IT A DIGIT ?\n         BH    READREE1            IF NOT,ERROR MESSAGE\nREADRE17 C     R4,MAX10            EXPONENT LOWER THAN MAX10 ?\n         BNL   READRE15            IF NOT,DO BRANCH\n         MH    R4,=H'10'           EXPONENT<---EXPONENT*10\n         LA    R6,0                R6<---0\n         IC    R6,INPUT@(R5)       R6<---INPUT@\n         SLL   R6,28               R6<---\n         SRL   R6,28                       INPUT - C'0'\n         AR    R4,R6               EXPONENT<---EXPONENT+DIGIT VALUE\nREADRE15 BAL   LINKREG,NEXTCH      READ NEXT INPUT CHARACTER\n         CLI   INPUT@(R5),C'0'     IS IT A DIGIT ?\n         BL    READRE16            IF NOT,DO BRANCH\n         CLI   INPUT@(R5),C'9'     IS IT A DIGIT ?\n         BH    READRE16            IF NOT,DO BRANCH\n         B     READRE17            IF YES,DO LOOP\nREADRE16 CLI   REXPSIGN,X'FF'      IS THE EXPONENT SIGN NEGATIVE ?\n         BNE   READRE12            IF NOT,DO BRANCH\n         LCR   R4,R4               EXPONENT<--- -EXPONENT\nREADRE12 ST    R2,FLOATI           PREPARE INPUT FOR FLOAT ROUTINE\n*                                  OF THE NUMBER)\n         SRL   R6,2\n         BAL   LINKREG,FLOAT       FLOAT NUMBER VALUE\n         ST    R2,TENINTOI         PREPARE INPUT FOR TENINTO ROUTINE\n         BAL   LINKREG,TENINTO     CALCULATE THE ORDER OF MAGNITUDE OF\n*                                  NUMBER\n         L     R6,TENINTOI         R6<---ORDER OF MAGNITUDE OF NUMBER\n         MH    R6,=H'2'            R6<---R6*2\n         ST    R6,RAUX             RAUX<---R6\n         LA    R6,156              R6<---156\n         S     R6,RAUX             R6<---156-2*(ORDER OF MAGNITUDE\n         SLL   R6,2\n         A     R6,=A(POWERS)       R6 POINTS TO APPROPRIATE ENTRY IN\n*                                  POWERS TABLE\n         MD    FPR,0(0,R6)         FPR<---FPR*(INPUT VALUE)\n         AR    R3,R4               SCALE<---SCALE+EXPONENT\n         A     R3,TENINTOI         SCALE<---SCALE+ORDER OF MAGNITUDE\n*                                  OF NUMBER\n         STE   FPR,RAUX            KEEP SHORT FPR AT RAUX\n         L     R2,RAUX             NUMBER<---SHORT FPR\n         C     R3,=A(0)            SCALE=0 ?\n         BE    READRE20            IF YES,DO BRANCH\n         C     R3,=F'-78'          SCALE<= -78 ?\n         BH    READRE14            IF NOT,DO BRANCH\n         BL    READRE24\n         C     R2,MINMANTS         R2<MINMANTS ?\n         BNL   READRE14            IF NOT,DO BRANCH\nREADRE24 SER   FPR,FPR             SUBTRACT NORMALIZED SHORT\n         B     READRE20            PROCEED\nREADRE14 C     R3,=F'75'           R3>=75 ?\n         BL    READRE19            IF NOT,DO BRANCH\n         BH    READRE23\n         C     R2,MAXMANTS         NUMBER> MAXMANTS ?\n         BNH   READRE19            IF NOT,DO BRANCH\nREADRE23 BAL   LINKREG,ERROR       IF SO, ISSUE AN ERROR MESSAGE\n         DC    AL1(L'READRE18)     ERROR MESSAGE PREFIX\nREADRE18 DC    C'WHILE READING REAL CONSTANT -- VALUE OUT OF RANGE'\n         B     READRE20            PROCEED\nREADRE19 MH    R3,=H'2'            SCALE<---SCALE*2\n         AH    R3,=H'156'          SCALE<---SCALE+156\n         SLL   R3,2\n         A     R3,=A(POWERS)       R3<---R3+A(POWERS)\n         MD    FPR,0(0,R3)\nREADRE20 CLI   RSIGN,X'FF'         IS THE NUMBER NEGATIVE ?\n         BNE   READRE21            IF NOT,DO BRANCH\n         LCER  FPR,FPR             FPR<--- -FPR\nREADRE21 SRVRTNED\n         SPACE 5\nRSIGN    DS    X                   MANTISSA SIGN.IF POSITIVE X'00'\nREXPSIGN DS    X                   EXPONENT SIGN.IF POSITIVE,X'00'\nRAUX     DS    F                   AUXILIARY\nMAXMANTS DC    X'40B9446F'\nMINMANTS DC    X'408A2DC0'\n         SPACE 5\nREADREE1 BAL   LINKREG,ERROR       BRANCH TO ERROR ROUTINE\n         DC    AL1(L'READRE22)     ERROR MESSAGE PREFIX\nREADRE22 DC    C'WHILE READING REAL CONSTANT -- DIGIT EXPECTED'\n         EJECT\n*\n*        ROUTINE FLOAT\n*\n*        PURPOSE : CONVERT TO FLOATING POINT A FIXED PINT VALUE\n*\n*        INPUT : FULLWORD AT LOCATION FLOATI CONTAINING FIXED POINT\n*        VALUE\n*        OUTPUT : FPR - FLOATING POINT REGISTER 6\n*\n         SPACE 5\nFLOAT    MVC   FWORK2,FLOATI       FWORK2<---FLOATI\n         LD    FPR,FWORK           FPR<---WORK.LONG (8 BYTES )\n*                                  OPERATION\n         AD    FPR,FZERO           ADD ZERO IN ORDER TO NORMALIZE\n         BR    LINKREG             RETURN TO CALLER\n         SPACE 3\nFLOATI   DS    F                   INPUT VALUE\nFZERO    DC      D'0'              FLOATING POINT ZERO\nFWORK    DS    0D\nFWORK1   DC    X'4E000000'\nFWORK2   DC    A(0)\n         EJECT\n*\n*        ROUTINE TENINTO\n*\n*        PURPOSE : FIND THE ORDER OF MAGNITUDE OF A GIVEN FIXED POINT\n*        VALUE\n*        INPUT : A FULLWORD AT LOCATION TENINTOI CONTAINING POSITIVE\n*        VALUE\n*        OUTPUT : SAME LOCATION AS INPUT\n*\n         SPACE 5\nTENINTO  STM   R2,R4,TENINTOR      KEEP REGISTERS\n         L     R3,TENINTOI         LOAD GIVEN VALUE INTO R3\n         LA    R4,0                LOOP COUNTER\nTENINTO2 C     R3,=A(0)            ZERO QUATIENT REACHED ?\n         BE    TENINTO1            IF YES,DO BRANCH\n         LA    R2,0                 R2<---0\n         D     R2,=A(10)           DIVIDE VALUE BY 10\n         LA    R4,1(0,R4)          R4<---R4+1\n         B     TENINTO2            LOOP\nTENINTO1 ST    R4,TENINTOI\n         LM    R2,R4,TENINTOR      RESTORE REGISTERS\n         BR    LINKREG             RETURN TO CALLER\n         SPACE 3\nTENINTOI DS    F                   INPUT/OUTPUT VALUE\nTENINTOR DS    3F                  REGISTERS' SAVE AREA\n         EJECT\n*\n*        CASE 23 --- READ_CHAR\n*\n         SPACE 5\nREADCHAR DS    0H                  DO;\n         CHKFILE INPUT\n         L     R2,PR14                RETURNS = INPUT@;\n         SR    R9,R9\n         IC    R9,INPUT@(0,R2)\n         BAL   LINKREG,NEXTCH         CALL NEXTCH;\n         SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 24 --- WRITE_INT\n*\n         SPACE 5\nWRITEINT DS    0H                  DO;\n         CHKFILE OUTPUT\n         LR    R1,R8                  /* R1<---NUMBER */\n         L     R2,PR14\n         L     R2,INTFLDSZ(0,R2)      /* R2<---INTFIELDSIZE */\n         BAL   LINKREG,IFORMAT        OUT_LINE =\n         LR    R2,R1                     OUT_LINE ||\n         L     R1,OUTLINEP                  I_FORMAT(NUMBER,\n         BAL   LINKREG,CATENATE                INTFIELDSIZE);\n         ST    R1,OUTLINEP\n         LR    R2,R1                  OUTPUT@ =\n         SRDL  R2,24                     BYTE(OUT_LINE,\n         SRL   R3,8                         LENGTH(OUT_LINE) - 1);\n         LA    R3,0(R2,R3)\n         L     R2,PR14\n         MVC   OUTPUT@(1,R2),0(R3)\n         SRVRTNED  ,               END;\n         SPACE 3\nINTFLDSZ EQU   32                  DISPLACEMENT IF INTFIELDSIZE IN\n*                                  GLOBAL ACTIVATION RECORD\n         EJECT\n*\n*        CASE 25 --- WRITE_REAL\n*\n         SPACE 5\nWRITREAL DS    0H\n         CHKFILE OUTPUT\n         STE   FPR,FPRSAVER        SAVE FPR.\n         L     R1,PR14\n         L     R1,RLFLDSZ(0,R1)    REALFIELDSIZE.\n         STC   R1,RWIDTH           PREPARE INPUT FOR EFORMAT.\n         STE   FPR,RNUMBER         PREPARE INPUT FOR EFORMAT.\n         BAL   LINKREG,EFORMAT     FORMAT THE REAL VALUE\n         LE    FPR,FPRSAVER        RESTORE FPR.\n         SR    R2,R2               CLEAR R2.\n         IC    R2,RWIDTH           REALFIELDSIZE.\n         BCTR  R2,0                REALFIELDSIZE - 1.\n         SLL   R2,24               SHIFT TO HIGH ORDER BYTE.\n         O     R2,=A(EFORS)        FORM DESCRIPTOR.\n         L     R1,OUTLINEP         DESCRIPTOR OF CURRENT LINE.\n         BAL   LINKREG,CATENATE    CONCATENATE REAL NUMBER ONTO LINE.\n         ST    R1,OUTLINEP         SAVE UPDATED DESCRIPTOR.\n         LR    R2,R1               OUTPUT@ =\n         SRDL  R2,24                  BYTE(OUT_LINE,\n         SRL   R3,8                      LENGTH(OUT_LINE) - 1);\n         LA    R3,0(R2,R3)\n         L     R2,PR14\n         MVC   OUTPUT@(1,R2),0(R3)\n         SRVRTNED\n         SPACE 3\nRLFLDSZ  EQU   40                  DISPLACEMENT OF REALFIELDSIZE IN\n*                                  GLOBAL ACTIVATION RECORD.\nFPRSAVER DS    F                   FPR SAVE AREA\nRNUMBER  DS    F                   REAL NUMBER\nRWIDTH   DS    X\n         EJECT\n*\n*        ROUTINE EFORMAT\n*\n*        PURPOSE : FORMATTING OF REAL NUMBER\n*\n*        INPUT : REAL NUMBER AT LOCATION RNUMBER\n*                LENGTH OF FORMAT AT LOCATION RWIDTH\n*\n*        OUTPUT : FORMAT AT LOCATION EFORS\n*                 END OF FORMAT POINTED BY EFORSP\n*\nEFORMAT  STM   R2,R4,EFORR         KEEP REGISTERS\n*        MINIMUM FIELD IS '+9.9E+99'\n         CLC   RWIDTH,=X'9'        RWIDTH<9 ?\n         BNL   EFOR1               IF NOT,DO BRANCH\n         LA    R2,9                R2<---9\n         STC   R2,RWIDTH           RWIDTH<---9\n         B     EFOR2               PROCEED\nEFOR1    CLC   RWIDTH,=FL1'14'     RWIDTH>14 ?\n         BNH   EFOR2               IF NOT,DO BRANCH\n         LA    R2,0                R2<---0\n         IC    R2,RWIDTH           R2<---RWIDTH\n         SH    R2,=H'13'           R2<---R2-13\n         LA    R3,EFORS            R3<---EFORS\n         AR    R3,R2               R3<---R3+R2\n         ST    R3,EFORSP           UPDATE EFORS POINTER\n         BCTR  R2,0                R2<---R2-1\n         EX    R2,EFORM            BLANK EFORS\n         MVI   RWIDTH,14           RWIDTH<---14\n         B     EFOR3               PROCEED\nEFOR2    LA    R2,EFORS            R2 POINTS TO EFORS\n         LA    R2,1(0,R2)          R2<---R2+1\n         ST    R2,EFORSP           UPDATE EFORS POINTER\n         MVI   EFORS,C' '          BLANK FIRST LOCATION OF EFORS\nEFOR3    TM    RNUMBER,X'80'       IS THE REAL NUMBER NEGATIVE ?\n         BNO   EFOR4               IF NOT,DO BRANCH\n         L     R2,EFORSP           R2 POINTS TO EFORS\n         MVI   0(R2),C'-'          MOVE '-' INTO FIRST VACANT LOCATION\n*                                  EFORS\n         LA    R2,1(0,R2)          R2<---R2+1\n         ST    R2,EFORSP           KEEP EFORS POINTER\n         L     R2,RNUMBER          R2 CONTAINS THE REAL NUMBER\n         N     R2,EFORAUX1         ZERO MOST SIGNIFICANT BIT IN R2\n         ST    R2,RNUMBER          RNUMBER CONTAINS ABSOLUTE VALUE OF\n*                                  REAL NUMBER\n         B     EFOR5               PROCEED\nEFOR4    L     R2,EFORSP           R2 POINTS TO THE FIRST VACANT\n*                                  LOCATION IN EFORS\n         MVI   0(R2),C' '          SET A BLANK INTO THIS LOCATION\n         LA    R2,1(0,R2)          R2<---R2+1\n         ST    R2,EFORSP           UPDATE EFORS POINTER\nEFOR5    L     R2,RNUMBER          R2 CONTAINS ABSOLUTE REAL NUMBER\n         LA    R4,0(0,R2)          R4<---R2 & \"00FFFFFF\"\n         LTR   R4,R4\n         BNE   EFOR6               IF NOT,DO BRANCH\n         L     R2,EFORSP           R2 POINTS TO FIRST VACANT LOC IN\n*                                  EFORS\n         LA    R3,0                R3<---0\n         IC    R3,RWIDTH           R3<---RWIDTH\n         SH    R3,=H'6'            R3<---R3-6\n         BCTR  R3,0                R3<---R3-1\n         EX    R3,EFORM1\n         LA    R3,1(0,R3)          RESTORE VALUE OF R3\n         AR    R2,R3\n         MVC   0(4,R2),=C'E+00'\n         LA    R2,4(0,R2)\n         ST    R2,EFORSP           UPDATE EFORSP POINTER\n         B     EFORF\nEFOR6    LA    R3,POWERS+14*4\n         C     R2,0(0,R3)          COMPARE REAL NUMBER VALUE WITH THE\n*                                  ENTRY IN POWERS TABLE\n         BNL   EFOR7               IF NOT EQUAL , DO BRANCH\n         LE    FPR,RNUMBER         FPR<---RNUMBER\n         LA    R3,POWERS+0*4       R3 POINTS TO FIRST ENTRY IN POWERS\n*                                  TABLE\n         DE    FPR,0(0,R3)         DIVIDE SHORT\n         STE   FPR,RNUMBER         RNUMBER<---FPR\n         MVC   EFOREXP,=FL2'-78'\n         B     EFOR8               PROCEED\nEFOR7    MVC   EFOREXP,=AL2(0)\nEFOR8    MVC   EFORI,=AL2(0)      EFORI<---0\n         MVC   EFORJ,=AL2(306)     EFORJ<---306\n         MVC   EFORX,=AL2(152)     EFORX<---152\nEFOR16   CLC   EFORI,EFORJ         EFORI>EFORJ ?\n         BH    EFOR9               IF YES,DO BRANCH\n         LH    R3,EFORX            R3<---EFORX\n         SLL   R3,2                R3<---R3*4\n         A     R3,=A(POWERS)       R3 POINTS TO APPROPRIATE ENTRY IN\n*                                  POWERS TABLE\n         CLC   0(4,R3),RNUMBER     POWERS ENTRY>RNUMBER ?\n         BH    EFOR10              IF YES,DO BRANCH\n         LH    R3,EFORX            R3<---EFORX\n         AH    R3,=H'2'            R3<---R3*2\n         STH   R3,EFORI            KEEP EFORI\n         B     EFOR11              PROCEED\nEFOR10   LH    R3,EFORX            R3<---EFORX\n         SH    R3,=H'2'            R3<---R3-2\n         STH   R3,EFORJ            EFORJ<---R3\nEFOR11   LH    R3,EFORI            R3<---EFORI\n         AH    R3,EFORJ            R3<---R3+RFORJ\n         SRL   R3,1                R3<---R3/2\n         N     R3,EFORCONS         ZERO LEFTMOST HALF OF R3\n         STH   R3,EFORX            EFORX<---R3\n         B     EFOR16              LOOP\nEFOR9    LE    FPR,RNUMBER         FPR<---RNUMBER\n         LH    R3,EFORX            R3<---EFORX\n         SH    R3,=H'14'           R3<---R3-14\n         SLL   R3,2                R3<---R3*4\n         A     R3,=A(POWERS)       R3 POINTS TO POWERS ENTRY\n         DE    FPR,0(0,R3)         DIVIDE SHORT\n         STE   FPR,DIVQUO          DIVQUO<---FPR\n         SDR   FPR,FPR             DOUBLE FPR<---0\n         LE    FPR,DIVQUO          FPR<---DIVQUO\n         AE    FPR,HALF            FPR<---FPR+HALF (ROUND)\n         AW    FPR,RZERO           DOUBLE FPR<---DOUBLE FPR+RZERO\n         STD   FPR,RWORK           RWORK<---DOUBLE FPR\n         MVC   EFORMANT,RWORK+4    EFORMANT<---RIGHT PART OF DOUBLE FPR\n         LH    R3,EFORX            R3<---EFORX\n         SRL   R3,1                R3<---R3/2\n         SH    R3,=H'78'           R3<---R3-78\n         AH    R3,EFOREXP          R3<---R3+EFOREXP\n         STH   R3,EFOREXP          EFOREXP<---R3\n         MVI   EFORS1,C' '         EFORS1<---' '\n         MVC   EFORS1+1(21),EFORS1 BLANK EFORS1\n         L     R3,EFORMANT         R3<---EFORMANT\n         C     R3,=F'9999999'      < 8 DIGITS?\n         BH    EFOR13              NO, SO BRANCH\n         LH    R3,EFOREXP          YES, SO SET EXP = EXP - 1\n         BCTR  R3,0\n         STH   R3,EFOREXP\n         B     EFOR13A\nEFOR13   C     R3,=F'99999999'     > 8 DIGITS?\n         BNH   EFOR13A             NO, SO BRANCH\n         LH    R3,EFOREXP          YES, SO SET EXP = EXP + 1\n         LA    R3,1(0,R3)\n         STH   R3,EFOREXP\nEFOR13A  L     R3,EFORMANT         R3<---MANTISSA\n         CVD   R3,EFORD            CONVERT R3 TO DECIMAL\n         MVC   EFORS1(10),EFORMPAT\n         LA    R1,EFORS1+2\n         EDMK  EFORS1(10),EFORD+3\n         MVC   EFORS+2(1),0(R1)\n         MVI   EFORS+3,C'.'\n         LA    R3,0                R3<---0\n         IC    R3,RWIDTH           R3<---RWIDTH\n         SH    R3,=H'8'            R3<---R3-8\n         L     R4,EFORSP           R4<---EFORSP\n         AR    R4,R3               R4<---R4+R3\n         LA    R4,2(0,R4)          R4<---R4+2\n         ST    R4,EFORSP           UPDATE EFORSP\n         BCTR  R3,0                R3<---R3-1\n         EX    R3,EFORMVC2\n         L     R3,EFORSP           R3<---EFORSP\n         MVI   0(R3),C'E'\n         LH    R4,EFOREXP          R4<---EFOREXP\n         TM    EFOREXP,X'80'       IS LEFTMOST BIT A ONE ?\n         BO    EFOR14              IF YES,DO BRANCH\n         MVI   1(R3),C'+'\n         B     EFOR15              PROCEED\nEFOR14   MVI   1(R3),C'-'\n         LCR   R4,R4               COMPLEMENT R4\nEFOR15   CVD   R4,EFORD            CONVERT R4 TO DECIMAL\n         MVC   EFORS1(4),EFORPAT1  PREPARE EDIT PATTERN\n         EDMK  EFORS1(4),EFORD+6   EDIT !\n         MVC   2(2,R3),EFORS1+2\n         LA    R3,4(0,R3)          R3<---R3+4\n         ST    R3,EFORSP           UPDATE EFORSP\nEFORF    LM    R2,R4,EFORR         RESTORE REGISTERS\n         BR    LINKREG             RETURN TO CALLER\n         SPACE 5\nEFOREXP  DS    H                   EXPONENT OF REAL NUMBER\nEFORZERO DC    C'0.0000000'\nEFORAUX1 DS    0F\n         DC    X'7FFFFFFF'         ALL ONE'S EXCEPT FOR THE LEFTMOST\nEFORX70  DC    CL70' '             BLANK CONSTANT\nEFORSP   DC    A(EFORS)            EFORS POINTER\nEFORS    DS    CL70                OUTPUT PARAMETER\nEFORR    DS    3F                  REGISTERS' SAVE AREA\nEFORI    DS    H                   AUXILIARY VARIABLE\nEFORJ    DS    H                   AUXILIARY VARIABL\nEFORX    DS    H                   AUXILIARY VARIABL\nEFORCONS DS    0F\n         DC    X'0000FFFE'\nEFORMANT DS    F                   MANTISSA OF THE REAL NUMBER\nEFORMPAT DC    X'40',9X'20'\nEFORS1   DS    CL22\nEFORD    DS    D\nEFORPAT1 DC    X'40',X'21',2X'20'\nRWORK    DS    D\nRZERO    DS    0D\n         DC    X'4E000000',A(0)\nHALF     DC    E'0.5'              FLOATING POINT HALF\nDIVQUO   DS    E\nEFORMVC2 MVC   EFORS+4(0),1(R1)\nEFORM    MVC   EFORS(0),EFORX70    BLANK EFORS\nEFORM1   MVC   0(0,R2),EFORZERO\n         EJECT\n*\n*        CASE 26 --- WRITE_BOOL\n*\n         SPACE 5\nWRITBOOL DS    0H                  DO;\n         CHKFILE OUTPUT\n         LR    R1,R8                  /* R1<---BOOL_VALUE */\n         L     R2,PR14\n         L     R2,BOOLFLDS(0,R2)      /* R2<---BOOLFIELDSIZE */\n         BAL   LINKREG,BFORMAT        OUT_LINE =\n         LR    R2,R1                     OUT_LINE ||\n         L     R1,OUTLINEP                  B_FORMAT(BOOL_VALUE,\n         BAL   LINKREG,CATENATE                BOOLFIELDSIZE);\n         ST    R1,OUTLINEP\n         LR    R2,R1                  OUTPUT@ =\n         SRDL  R2,24                     BYTE(OUT_LINE,\n         SRL   R3,8                         LENGTH(OUT_LINE) - 1);\n         LA    R3,0(R2,R3)\n         L     R2,PR14\n         MVC   OUTPUT@(1,R2),0(R3)\n         SRVRTNED  ,               END;\n         SPACE 3\nBOOLFLDS EQU   36                  /* DISPLACEMENT OF BOOLFIELDSIZE\n*                                     IN GLOBAL ACTIVATION RECORD */\n         EJECT\n*\n*        CASE 27 --- WRITE_CHAR\n*\n         SPACE 5\nWRITCHAR DS    0H                  DO;\n         CHKFILE OUTPUT\n         STC   R8,WRCHR\n         L     R2,WRCHRA\n         L     R1,OUTLINEP\n         BAL   LINKREG,CATENATE       OUT_LINE = OUT_LINE || CHAR;\n         ST    R1,OUTLINEP\n         L     R2,PR14\n         STC   R8,OUTPUT@(R2)         OUTPUT@ = BYTE(CHAR);\n         SRVRTNED  ,               END;\n         SPACE 3\nWRCHR    DS    CL1                 /* CHARACTER TO BE PRINTED */\nWRCHRA   DC    A(WRCHR)            /* DESCRIPTOR FOR WRCHR */\n         EJECT\n*\n*        CASE 28 --- WRITE_STRING\n*\n         SPACE 5\nWRITSTRG DS    0H                  DO;\n         CHKFILE OUTPUT\n         LR    R2,R8\n         L     R1,OUTLINEP            OUT_LINE =\n         BAL   LINKREG,CATENATE          OUT_LINE || STRING;\n         ST    R1,OUTLINEP\n         LR    R2,R1                  OUTPUT@ =\n         SRDL  R2,24                     BYTE(OUT_LINE,\n         SRL   R3,8                         LENGTH(OUT_LINE) - 1);\n         LA    R3,0(R2,R3)\n         L     R2,PR14\n         MVC   OUTPUT@(1,R2),0(R3)\n         SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 29 --- READLN\n*\n         SPACE 5\nREADLN   DS    0H                  DO;\n         CHKFILE INPUT\n         MVC   INPTR,=H'80'           IN_PTR = 80; /* SIGNALS EOLN */\n         BAL   LINKREG,NEXTCH         CALL NEXTCH;\n         SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 30 --- WRITELN\n*\n         SPACE 5\nWRITELN  DS    0H                  DO;\n         CHKFILE OUTPUT\n         BAL   LINKREG,PUTLN          OUTPUT(1) = OUT_LINE;\n         MVI   OUTLINE,C' '           OUT_LINE = ' ';\n         L     R1,PR14                OUTPUT@ = BYTE(' ');\n         MVI   OUTPUT@(R1),C' '\n         SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 31 --- PAGE\n*\n         SPACE 5\nPAGE     DS    0H                  DO;\n         CHKFILE OUTPUT\n         BAL   LINKREG,PUTLN          OUTPUT(1) = OUT_LINE;\n         MVI   OUTLINE,C'1'           OUT_LINE = '1';\n         L     R1,PR14                OUTPUT@ = BYTE('1');\n         MVI   OUTPUT@(R1),C'1'\n         SRVRTNED  ,               END;\n         EJECT\n*\n*        CASE 32 --- RANGE_ERROR\n*\n         SPACE 5\nRANGEERR DS    0H                  CALL ERROR(RANGE_ERROR);\n         BAL   LINKREG,ERROR\n         SPACE 3\n         DC    AL1(L'RANGERRM)\nRANGERRM DC    C'VALUE OUT OF RANGE'\n         EJECT\n*\n*        CASE 33 --- MEM_OVERFLOW\n*\n*\n         SPACE 5\nMEMOVERF DS    0H                  DO;\n         L     R1,ORGORGN             ERROR_LINE = CODE_BASE_REGISTER;\n         L     R10,CBR(0,R1)\n         BAL   LINKREG,ERROR          CALL ERROR(MEMORY_ERROR);\n*                                  END;\n         SPACE 3\nMEMERR   DC    AL1(L'MEMERRM)\nMEMERRM  DC    C'RUN-TIME STORAGE OVERFLOW'\nCBR      EQU   ORGPSCLR+4          /* WHERE CODE BASE REGISTER IS SAVED\n*                                     IN THE ORG SEGMENT */\n         EJECT\n*        CASE 34  FORM SUBRANGE MASK\n*\n*\n*        PURPOSE: FORMS A MASK (& RETURNS THE ADDRESS OF THAT MASK)\n*        WHICH, WHEN OD'D INTO A SET, INSERTS THE SUBRANGE INDICATED\n*        BY THE ARGUMENTS INTO THAT SET. THE MONITOR IS ONLY CALLED\n*        UPON TO DO THIS OPERATION WHEN THE STORAGE LENGTH OF THE SET\n*        IS GREATER THAN 64.\n*\n*        USES REGS 4-9\nMVCINS   MVC   0(0,R5),ONES\nBITORD2  EQU   9\nBITORD1  EQU   7\nBYTEORD2 EQU   8\nBYTEORD1 EQU   6\nMASK     DS    64F\nONES     DC    64F'-1'\nFIRSTBYT DC    X'FF7F3F1F0F070301'\n*\nRANGMASK XC    MASK(256),MASK      CLEAR THE MASK\n         CR    R9,R8               COMPARE THE ARGUMENTS.  IF THE 1ST\n*        OPERAND IS LARGER, RETURN THE MASK AS IS. WHEN OR'D INTO A\n*        SET, IT WOULD ADD THE EMPTY SET.\n*\n         BH    RETURNMK\n*\n*        FORM BIT & BYTE ORDINALITIES\n*\n         LR    BYTEORD1,R9\n         SRDL  BYTEORD2,3          FORM ARG2 DIV 8\n         SRL   BITORD2,29          FORM BITORD2 = ARG2 MOD 8\n         SRDL  BYTEORD1,3          FORM BYTEORD1 = ARG1 DIV 8\n         SRL   BITORD1,29          FORM BITORD1 = ARG1 MOD 8\n*\n*        WE WANT TO MOVE (BYTEORD2 - BYTEORD1 + 1) BYTES OF ONES INTO\n*        THE MASK. EX A MVC INSTRUCTION WITH LENGTH CODE IN R4\n*\n         LR    R4,BYTEORD2\n         SR    R4,BYTEORD1\n         LA    R5,MASK(BYTEORD1)\n         EX    R4,MVCINS           MOVE IN ONES STARTING AT\n*                                  MASK(BYTEORD1)\n*        NOW FILL IN FIRST & LAST BYTES\n         IC    R4,FIRSTBYT(BITORD1)\n         STC   R4,MASK(BYTEORD1)   MOVE IN FIRST BYTE\n         IC    R4,MASK(BYTEORD2)   SET LAST BYTE, LEAVING BITS\n         LCR   R5,BITORD2          ALREADY SET UNDISTURBED.\n         SLL   R4,7(R5)\n         STC   R4,MASK(BYTEORD2)\nRETURNMK L     R9,=A(MASK)         RETURN THE ADDRESS OF THE MASK\n         SRVRTNED\n         EJECT\n*\n*   CASE 35 --- CLOCK\n*\n*   RETURNS ELAPSED CPU TIME IN UNITS OF 0.01 SECONDS.\n*\n         SPACE 5\nCLOCK    TTIMER\n*\n*        THE TIME REMAINING (IN UNITS OF 26.04166 USEC) IS\n*        IN REGISTER R0.\n*\n         SRDL  R0,32               CONVERT TO UNITS OF 0.01 SEC.\n         LA    R9,384              CONVERSION FACTOR\n         DR    R0,R9\n*\n*        SUBTRACT THE REMAINING TIME FROM THE ORIGINAL TIMER LIMIT.\n*\n         L     R9,TIMELT           INITIAL TIMER LIMIT\n         SR    R9,R1               ELAPSED TIME\n         SRVRTNED\n         EJECT\n*\n*        L I T E R A L S\n*\n         SPACE 5\n         LTORG\n         SPACE 5\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE04": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x00\\xd8\\x00\\xd8\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 216, "newlines": 216, "modlines": 0, "user": "SPASCAL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FILE05": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x11J\\x11J\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 4426, "newlines": 4426, "modlines": 0, "user": "SPASCAL"}, "text": "   /********************************************************************\n   *                                                                   *\n   *                 STONY BROOK PASCAL 360 COMPILER                   *\n   *             PASS 1 -- LEXICAL AND SYNTACTIC ANALYSIS              *\n   *                                                                   *\n   ********************************************************************/\n\n   /*\n   COPYRIGHT (C) 1976 DEPARTMENT OF COMPUTER SCIENCE, SUNY AT STONY BROOK.\n                                                                      */\n\n   DECLARE ENTRIES(96) BIT(16) INITIAL ( \"0000\", \"0009\", \"000E\", \"0010\", \"0015\",\n      \"001A\", \"001E\", \"0021\", \"0023\", \"0025\", \"002A\", \"0034\", \"0035\", \"0037\",\n      \"0038\", \"0039\", \"003C\", \"003D\", \"003F\", \"0042\", \"004C\", \"0052\", \"0057\",\n      \"005B\", \"0065\", \"0068\", \"006A\", \"006D\", \"0071\", \"0076\", \"007F\", \"0080\",\n      \"0081\", \"0085\", \"008A\", \"008B\", \"008E\", \"0094\", \"0096\", \"0098\", \"009A\",\n      \"009E\", \"00A3\", \"00A6\", \"00A7\", \"00AA\", \"00AB\", \"00AC\", \"00AD\", \"00B2\",\n      \"00B7\", \"00BD\", \"00C2\", \"00C4\", \"00C9\", \"00D2\", \"00D8\", \"00DB\", \"00DD\",\n      \"00E7\", \"00E9\", \"00EA\", \"00EE\", \"00EF\", \"00F2\", \"00F7\", \"00F9\", \"00FD\",\n      \"00FE\", \"0101\", \"0102\", \"0103\", \"0104\", \"0106\", \"0107\", \"010C\", \"010D\",\n      \"010E\", \"0111\", \"0113\", \"0115\", \"011F\", \"0120\", \"0123\", \"0128\", \"012A\",\n      \"0130\", \"0139\", \"013A\", \"0140\", \"0149\", \"014A\", \"014B\", \"014C\", \"0150\",\n      \"0153\", \"0155\");\n   DECLARE INIT (340) BIT(8) INITIAL ( \"06\", \"09\", \"20\", \"2C\", \"32\", \"35\", \"3A\",\n      \"3C\", \"3E\", \"1E\", \"26\", \"2D\", \"38\", \"3B\", \"09\", \"3C\", \"07\", \"13\", \"24\",\n      \"3A\", \"3C\", \"1E\", \"26\", \"2D\", \"39\", \"3B\", \"02\", \"1D\", \"2B\", \"31\", \"04\",\n      \"0B\", \"17\", \"09\", \"1B\", \"0D\", \"21\", \"07\", \"13\", \"24\", \"3A\", \"3C\", \"02\",\n      \"08\", \"10\", \"14\", \"1D\", \"21\", \"27\", \"2B\", \"31\", \"34\", \"37\", \"02\", \"05\",\n      \"3C\", \"08\", \"09\", \"3A\", \"3C\", \"3C\", \"03\", \"11\", \"03\", \"08\", \"14\", \"01\",\n      \"06\", \"10\", \"13\", \"1D\", \"21\", \"27\", \"2B\", \"31\", \"34\", \"07\", \"09\", \"13\",\n      \"24\", \"3A\", \"3C\", \"1E\", \"26\", \"2D\", \"39\", \"3B\", \"1E\", \"2D\", \"39\", \"3B\",\n      \"02\", \"0F\", \"1D\", \"1F\", \"28\", \"2D\", \"30\", \"33\", \"3C\", \"3E\", \"02\", \"1D\",\n      \"31\", \"39\", \"3B\", \"02\", \"05\", \"07\", \"02\", \"1D\", \"2B\", \"31\", \"02\", \"09\",\n      \"1D\", \"3A\", \"3C\", \"01\", \"06\", \"10\", \"1D\", \"21\", \"27\", \"2B\", \"31\", \"34\",\n      \"3C\", \"02\", \"1E\", \"2D\", \"39\", \"3B\", \"1E\", \"26\", \"2D\", \"39\", \"3B\", \"02\",\n      \"02\", \"05\", \"07\", \"07\", \"09\", \"13\", \"24\", \"3A\", \"3C\", \"15\", \"34\", \"03\",\n      \"05\", \"3C\", \"3E\", \"20\", \"2C\", \"32\", \"36\", \"02\", \"08\", \"1D\", \"28\", \"3C\",\n      \"02\", \"08\", \"1D\", \"3C\", \"03\", \"14\", \"16\", \"07\", \"07\", \"02\", \"1E\", \"26\",\n      \"2D\", \"39\", \"3B\", \"1E\", \"26\", \"2D\", \"39\", \"3B\", \"1E\", \"26\", \"2D\", \"2F\",\n      \"39\", \"3B\", \"02\", \"08\", \"1E\", \"39\", \"3B\", \"02\", \"1D\", \"07\", \"09\", \"3A\",\n      \"3C\", \"3E\", \"06\", \"09\", \"20\", \"2C\", \"32\", \"35\", \"3A\", \"3C\", \"3E\", \"01\",\n      \"06\", \"12\", \"1D\", \"2B\", \"31\", \"1E\", \"39\", \"3B\", \"02\", \"08\", \"02\", \"08\",\n      \"0B\", \"10\", \"14\", \"1D\", \"27\", \"2B\", \"31\", \"34\", \"03\", \"14\", \"1D\", \"1E\",\n      \"2D\", \"39\", \"3B\", \"02\", \"2D\", \"39\", \"3B\", \"02\", \"08\", \"14\", \"16\", \"1D\",\n      \"3A\", \"3C\", \"09\", \"3A\", \"3C\", \"3E\", \"1D\", \"2D\", \"39\", \"3B\", \"2D\", \"02\",\n      \"02\", \"15\", \"34\", \"37\", \"1E\", \"26\", \"2D\", \"39\", \"3B\", \"02\", \"3C\", \"02\",\n      \"05\", \"07\", \"02\", \"08\", \"02\", \"08\", \"04\", \"06\", \"09\", \"20\", \"2C\", \"32\",\n      \"35\", \"3A\", \"3C\", \"3E\", \"04\", \"03\", \"08\", \"14\", \"02\", \"08\", \"1D\", \"3A\",\n      \"3C\", \"02\", \"08\", \"07\", \"09\", \"13\", \"24\", \"3A\", \"3C\", \"02\", \"0F\", \"1D\",\n      \"1F\", \"28\", \"2D\", \"30\", \"33\", \"3C\", \"07\", \"01\", \"06\", \"12\", \"1D\", \"2B\",\n      \"31\", \"02\", \"08\", \"10\", \"14\", \"1D\", \"27\", \"2B\", \"31\", \"34\", \"05\", \"04\",\n      \"07\", \"10\", \"15\", \"27\", \"34\", \"02\", \"08\", \"1D\", \"07\", \"13\");\n   DECLARE FIN (340) BIT(8) INITIAL ( \"07\", \"0A\", \"20\", \"2C\", \"32\", \"36\", \"3A\",\n      \"3C\", \"3E\", \"1E\", \"26\", \"2F\", \"39\", \"3B\", \"0A\", \"3E\", \"07\", \"13\", \"25\",\n      \"3A\", \"3E\", \"1E\", \"26\", \"2F\", \"39\", \"3B\", \"02\", \"1D\", \"2B\", \"31\", \"04\",\n      \"0C\", \"1A\", \"0A\", \"1B\", \"0E\", \"23\", \"07\", \"13\", \"25\", \"3A\", \"3E\", \"04\",\n      \"0E\", \"11\", \"1B\", \"1D\", \"23\", \"27\", \"2B\", \"31\", \"34\", \"37\", \"02\", \"05\",\n      \"3C\", \"08\", \"0A\", \"3A\", \"3E\", \"3C\", \"03\", \"11\", \"03\", \"08\", \"14\", \"04\",\n      \"0E\", \"11\", \"1B\", \"1D\", \"23\", \"27\", \"2B\", \"31\", \"34\", \"07\", \"0A\", \"14\",\n      \"25\", \"3A\", \"3E\", \"1E\", \"26\", \"2F\", \"39\", \"3B\", \"1E\", \"2D\", \"39\", \"3B\",\n      \"02\", \"0F\", \"1D\", \"1F\", \"2B\", \"2D\", \"31\", \"33\", \"3C\", \"3E\", \"02\", \"1D\",\n      \"31\", \"39\", \"3B\", \"03\", \"05\", \"08\", \"02\", \"1D\", \"2B\", \"31\", \"02\", \"0A\",\n      \"1D\", \"3A\", \"3E\", \"04\", \"0E\", \"1B\", \"1D\", \"23\", \"27\", \"2B\", \"31\", \"34\",\n      \"3C\", \"02\", \"1E\", \"2D\", \"39\", \"3B\", \"1E\", \"26\", \"2D\", \"39\", \"3B\", \"03\",\n      \"02\", \"05\", \"07\", \"07\", \"0A\", \"13\", \"25\", \"3A\", \"3E\", \"15\", \"34\", \"03\",\n      \"05\", \"3C\", \"3E\", \"20\", \"2C\", \"32\", \"36\", \"02\", \"08\", \"1D\", \"28\", \"3C\",\n      \"02\", \"08\", \"1D\", \"3E\", \"03\", \"14\", \"16\", \"07\", \"07\", \"02\", \"1E\", \"26\",\n      \"2F\", \"39\", \"3B\", \"1E\", \"26\", \"2F\", \"39\", \"3B\", \"1E\", \"26\", \"2D\", \"2F\",\n      \"39\", \"3B\", \"02\", \"08\", \"1E\", \"39\", \"3C\", \"02\", \"1D\", \"07\", \"0A\", \"3A\",\n      \"3C\", \"3E\", \"07\", \"0A\", \"20\", \"2C\", \"32\", \"36\", \"3A\", \"3C\", \"3E\", \"02\",\n      \"07\", \"13\", \"1D\", \"2B\", \"31\", \"1E\", \"39\", \"3C\", \"02\", \"08\", \"04\", \"08\",\n      \"0C\", \"11\", \"1A\", \"1D\", \"27\", \"2B\", \"31\", \"34\", \"03\", \"14\", \"1D\", \"1E\",\n      \"2D\", \"39\", \"3C\", \"02\", \"2D\", \"39\", \"3C\", \"03\", \"08\", \"14\", \"16\", \"1D\",\n      \"3A\", \"3C\", \"0A\", \"3A\", \"3C\", \"3E\", \"1D\", \"2D\", \"39\", \"3B\", \"2D\", \"02\",\n      \"02\", \"15\", \"34\", \"37\", \"1E\", \"26\", \"2D\", \"39\", \"3C\", \"02\", \"3C\", \"02\",\n      \"05\", \"08\", \"03\", \"08\", \"03\", \"08\", \"04\", \"07\", \"0A\", \"20\", \"2C\", \"32\",\n      \"36\", \"3A\", \"3C\", \"3E\", \"04\", \"03\", \"08\", \"14\", \"02\", \"0A\", \"1D\", \"3A\",\n      \"3E\", \"02\", \"08\", \"07\", \"0A\", \"13\", \"25\", \"3A\", \"3E\", \"02\", \"0F\", \"1D\",\n      \"1F\", \"2B\", \"2D\", \"31\", \"33\", \"3C\", \"07\", \"02\", \"07\", \"13\", \"1D\", \"2B\",\n      \"31\", \"04\", \"0C\", \"11\", \"1B\", \"1D\", \"27\", \"2B\", \"31\", \"34\", \"05\", \"04\",\n      \"07\", \"11\", \"15\", \"27\", \"34\", \"02\", \"08\", \"1D\", \"07\", \"13\");\n   DECLARE PTR (340) BIT(16) INITIAL ( \"0000\", \"0002\", \"0004\", \"0005\", \"0006\",\n      \"0007\", \"0009\", \"000A\", \"000B\", \"000C\", \"000D\", \"000E\", \"0011\", \"0013\",\n      \"0014\", \"0016\", \"0019\", \"001A\", \"001B\", \"001D\", \"001E\", \"0021\", \"0022\",\n      \"0023\", \"0026\", \"0027\", \"0028\", \"0029\", \"002A\", \"002B\", \"002C\", \"002D\",\n      \"002F\", \"0033\", \"0035\", \"0036\", \"0038\", \"003B\", \"003C\", \"003D\", \"003F\",\n      \"0040\", \"0043\", \"0046\", \"004D\", \"004F\", \"0057\", \"0058\", \"005B\", \"005C\",\n      \"005D\", \"005E\", \"005F\", \"0060\", \"0061\", \"0062\", \"0063\", \"0064\", \"0066\",\n      \"0067\", \"006A\", \"006B\", \"006C\", \"006D\", \"006E\", \"006F\", \"0070\", \"0074\",\n      \"007D\", \"007F\", \"0088\", \"0089\", \"008C\", \"008D\", \"008E\", \"008F\", \"0090\",\n      \"0091\", \"0093\", \"0095\", \"0097\", \"0098\", \"009B\", \"009C\", \"009D\", \"00A0\",\n      \"00A1\", \"00A2\", \"00A3\", \"00A4\", \"00A5\", \"00A6\", \"00A7\", \"00A8\", \"00A9\",\n      \"00AA\", \"00AE\", \"00AF\", \"00B1\", \"00B2\", \"00B3\", \"00B4\", \"00B5\", \"00B6\",\n      \"00B7\", \"00B8\", \"00B9\", \"00BB\", \"00BC\", \"00BE\", \"00BF\", \"00C0\", \"00C1\",\n      \"00C2\", \"00C3\", \"00C5\", \"00C6\", \"00C7\", \"00CA\", \"00CE\", \"00D7\", \"00E3\",\n      \"00E4\", \"00E7\", \"00E8\", \"00E9\", \"00EA\", \"00EB\", \"00EC\", \"00ED\", \"00EE\",\n      \"00EF\", \"00F0\", \"00F1\", \"00F2\", \"00F3\", \"00F4\", \"00F5\", \"00F6\", \"00F8\",\n      \"00F9\", \"00FA\", \"00FB\", \"00FC\", \"00FE\", \"00FF\", \"0101\", \"0102\", \"0105\",\n      \"0106\", \"0107\", \"0108\", \"0109\", \"010A\", \"010B\", \"010C\", \"010D\", \"010E\",\n      \"010F\", \"0110\", \"0111\", \"0112\", \"0113\", \"0114\", \"0115\", \"0116\", \"0117\",\n      \"011A\", \"011B\", \"011C\", \"011D\", \"011E\", \"011F\", \"0120\", \"0121\", \"0122\",\n      \"0125\", \"0126\", \"0127\", \"0128\", \"0129\", \"012C\", \"012D\", \"012E\", \"012F\",\n      \"0130\", \"0131\", \"0132\", \"0133\", \"0134\", \"0135\", \"0136\", \"0137\", \"0138\",\n      \"013A\", \"013B\", \"013C\", \"013D\", \"013F\", \"0140\", \"0141\", \"0142\", \"0144\",\n      \"0146\", \"0147\", \"0148\", \"0149\", \"014B\", \"014C\", \"014D\", \"014E\", \"0150\",\n      \"0152\", \"0154\", \"0155\", \"0156\", \"0157\", \"0158\", \"0159\", \"015B\", \"015C\",\n      \"015D\", \"0160\", \"0161\", \"0163\", \"0165\", \"016C\", \"016D\", \"016E\", \"016F\",\n      \"0170\", \"0171\", \"0172\", \"0173\", \"0174\", \"0175\", \"0176\", \"0177\", \"0179\",\n      \"017A\", \"017B\", \"017C\", \"017E\", \"0180\", \"0181\", \"0182\", \"0183\", \"0184\",\n      \"0185\", \"0186\", \"0188\", \"0189\", \"018A\", \"018B\", \"018C\", \"018D\", \"018E\",\n      \"018F\", \"0190\", \"0191\", \"0192\", \"0193\", \"0194\", \"0195\", \"0196\", \"0197\",\n      \"0198\", \"0199\", \"019B\", \"019C\", \"019D\", \"019E\", \"019F\", \"01A1\", \"01A3\",\n      \"01A4\", \"01A6\", \"01A7\", \"01A8\", \"01AA\", \"01AC\", \"01AD\", \"01AE\", \"01AF\",\n      \"01B1\", \"01B2\", \"01B3\", \"01B4\", \"01B5\", \"01B6\", \"01B7\", \"01B8\", \"01B9\",\n      \"01BC\", \"01BD\", \"01BE\", \"01C1\", \"01C2\", \"01C3\", \"01C4\", \"01C6\", \"01C7\",\n      \"01C9\", \"01CA\", \"01CD\", \"01CE\", \"01CF\", \"01D0\", \"01D1\", \"01D5\", \"01D6\",\n      \"01D8\", \"01D9\", \"01DA\", \"01DB\", \"01DD\", \"01DF\", \"01E1\", \"01E2\", \"01E3\",\n      \"01E4\", \"01E7\", \"01EC\", \"01EE\", \"01F6\", \"01F7\", \"01F8\", \"01F9\", \"01FA\",\n      \"01FB\", \"01FC\", \"01FD\", \"01FE\", \"0200\", \"0201\", \"0202\", \"0203\", \"0204\",\n      \"0205\", \"0206\", \"0207\");\n   DECLARE PROD_# (519) BIT(8) INITIAL ( \"62\", \"61\", \"61\", \"61\", \"63\", \"63\",\n      \"63\", \"64\", \"63\", \"61\", \"61\", \"61\", \"1C\", \"1C\", \"1C\", \"1C\", \"1C\", \"A6\",\n      \"1C\", \"1C\", \"79\", \"7A\", \"7B\", \"7B\", \"7B\", \"8E\", \"8E\", \"8E\", \"8E\", \"8E\",\n      \"8E\", \"8E\", \"8E\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"BE\", \"BE\",\n      \"BE\", \"BE\", \"7F\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"8B\", \"8C\", \"8D\",\n      \"91\", \"92\", \"93\", \"94\", \"95\", \"97\", \"99\", \"98\", \"9D\", \"9C\", \"96\", \"9B\",\n      \"9A\", \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"8F\", \"8F\", \"90\",\n      \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"90\", \"8F\", \"8F\",\n      \"8F\", \"90\", \"90\", \"90\", \"90\", \"01\", \"A5\", \"A4\", \"22\", \"A2\", \"75\", \"75\",\n      \"74\", \"75\", \"75\", \"75\", \"4E\", \"3D\", \"3E\", \"37\", \"38\", \"38\", \"9E\", \"9E\",\n      \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\",\n      \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\",\n      \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"9E\", \"A0\", \"A0\", \"A0\", \"A0\", \"A1\", \"A0\",\n      \"A0\", \"A0\", \"A0\", \"A0\", \"A0\", \"03\", \"03\", \"03\", \"03\", \"03\", \"03\", \"03\",\n      \"1D\", \"1E\", \"1E\", \"1E\", \"26\", \"26\", \"26\", \"26\", \"26\", \"26\", \"26\", \"26\",\n      \"26\", \"26\", \"26\", \"26\", \"26\", \"25\", \"06\", \"07\", \"07\", \"1B\", \"1A\", \"24\",\n      \"23\", \"24\", \"24\", \"24\", \"3A\", \"3A\", \"39\", \"3A\", \"A7\", \"49\", \"49\", \"A7\",\n      \"49\", \"49\", \"49\", \"49\", \"50\", \"52\", \"52\", \"52\", \"51\", \"9F\", \"52\", \"52\",\n      \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"4F\", \"52\", \"52\", \"52\",\n      \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\", \"52\",\n      \"52\", \"6F\", \"B6\", \"04\", \"04\", \"04\", \"04\", \"13\", \"12\", \"13\", \"13\", \"13\",\n      \"0B\", \"0A\", \"40\", \"40\", \"3F\", \"7C\", \"7C\", \"7C\", \"7C\", \"7C\", \"7C\", \"7C\",\n      \"7C\", \"7C\", \"7C\", \"3C\", \"3B\", \"4C\", \"4D\", \"5F\", \"60\", \"67\", \"66\", \"65\",\n      \"68\", \"A8\", \"A8\", \"A8\", \"6C\", \"6B\", \"6D\", \"6E\", \"6E\", \"76\", \"78\", \"77\",\n      \"AB\", \"AB\", \"AA\", \"B8\", \"BB\", \"C7\", \"C5\", \"C5\", \"C5\", \"C5\", \"C5\", \"C5\",\n      \"C5\", \"09\", \"09\", \"09\", \"08\", \"09\", \"09\", \"09\", \"0D\", \"0D\", \"0D\", \"0C\",\n      \"0D\", \"0D\", \"B2\", \"B2\", \"AF\", \"B0\", \"B1\", \"AE\", \"4A\", \"4B\", \"54\", \"55\",\n      \"56\", \"58\", \"53\", \"57\", \"C8\", \"C8\", \"C8\", \"C8\", \"C8\", \"C8\", \"C8\", \"C8\",\n      \"C8\", \"C8\", \"C8\", \"C8\", \"33\", \"36\", \"34\", \"35\", \"31\", \"32\", \"36\", \"36\",\n      \"36\", \"42\", \"43\", \"44\", \"41\", \"45\", \"46\", \"7E\", \"7E\", \"7D\", \"7E\", \"7D\",\n      \"7D\", \"7E\", \"7E\", \"7E\", \"7E\", \"7E\", \"7D\", \"7D\", \"7D\", \"7D\", \"7E\", \"7E\",\n      \"7E\", \"7E\", \"7E\", \"AC\", \"AD\", \"C3\", \"15\", \"15\", \"15\", \"15\", \"14\", \"21\",\n      \"20\", \"20\", \"20\", \"1F\", \"5A\", \"5A\", \"5A\", \"5A\", \"59\", \"5A\", \"5E\", \"5D\",\n      \"5B\", \"5B\", \"5C\", \"5B\", \"5B\", \"C0\", \"19\", \"18\", \"18\", \"05\", \"17\", \"B7\",\n      \"C1\", \"C1\", \"A3\", \"0F\", \"0F\", \"0F\", \"0F\", \"0F\", \"0E\", \"11\", \"BF\", \"48\",\n      \"48\", \"47\", \"48\", \"BA\", \"B9\", \"BA\", \"BD\", \"BC\", \"BD\", \"CE\", \"CF\", \"CF\",\n      \"CF\", \"CF\", \"CF\", \"CF\", \"CF\", \"CF\", \"CF\", \"CF\", \"CF\", \"CF\", \"10\", \"69\",\n      \"6A\", \"6A\", \"A9\", \"A9\", \"72\", \"72\", \"A9\", \"72\", \"72\", \"72\", \"72\", \"B4\",\n      \"B3\", \"88\", \"86\", \"87\", \"88\", \"88\", \"88\", \"88\", \"88\", \"88\", \"88\", \"30\",\n      \"29\", \"30\", \"2D\", \"2A\", \"2E\", \"2F\", \"30\", \"28\", \"2B\", \"30\", \"2C\", \"27\",\n      \"73\", \"D0\", \"D1\", \"D0\", \"D0\", \"D0\", \"D0\", \"D1\", \"D1\", \"D1\", \"8A\", \"8A\",\n      \"8A\", \"8A\", \"89\", \"89\", \"8A\", \"8A\", \"8A\", \"8A\", \"8A\", \"8A\", \"8A\", \"8A\",\n      \"8A\", \"8A\", \"8A\", \"89\", \"8A\", \"8A\", \"8A\", \"8A\", \"8A\", \"CD\", \"16\", \"B5\",\n      \"C9\", \"CA\", \"CB\", \"D4\", \"CB\", \"70\", \"71\", \"71\", \"D3\", \"D2\");\n   DECLARE NONEMPTY (212) BIT(8) INITIAL (0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1,\n      0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0,\n      1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,\n      1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1,\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1,\n      1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1,\n      1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1,\n      1);\n   DECLARE PRODUCES_EMPTY (95) BIT(1) INITIAL ( 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1,\n      0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,\n      0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1,\n      1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,\n      1, 0, 1, 1, 0, 0, 0, 1, 1, 0);\n   DECLARE TERMINAL_HEADS_INDEX (96) BIT(16) INITIAL ( 0, 12, 20, 22, 30, 37,\n      37, 44, 47, 52, 60, 65, 66, 67, 68, 69, 75, 76, 77, 78, 82, 92, 95, 96,\n      106, 107, 109, 110, 111, 118, 122, 123, 124, 128, 129, 130, 131, 141, 143,\n      144, 146, 150, 153, 154, 157, 158, 159, 160, 161, 168, 169, 170, 175, 176,\n      182, 194, 199, 203, 204, 211, 212, 213, 214, 215, 216, 217, 219, 224, 225,\n      227, 228, 229, 230, 232, 233, 234, 235, 236, 237, 238, 239, 252, 253, 254,\n      260, 261, 271, 280, 281, 286, 289, 290, 291, 292, 297, 298, 300);\n   DECLARE TERMINAL_HEADS (300) BIT(8) INITIAL ( \"06\", \"07\", \"09\", \"0A\", \"20\",\n      \"2C\", \"32\", \"35\", \"36\", \"3A\", \"3C\", \"3E\", \"1E\", \"26\", \"2D\", \"2E\", \"2F\",\n      \"38\", \"39\", \"3B\", \"09\", \"0A\", \"07\", \"13\", \"24\", \"25\", \"3A\", \"3C\", \"3D\",\n      \"3E\", \"1E\", \"26\", \"2D\", \"2E\", \"2F\", \"39\", \"3B\", \"04\", \"0B\", \"0C\", \"17\",\n      \"18\", \"19\", \"1A\", \"09\", \"0A\", \"1B\", \"0D\", \"0E\", \"21\", \"22\", \"23\", \"07\",\n      \"13\", \"24\", \"25\", \"3A\", \"3C\", \"3D\", \"3E\", \"0D\", \"0E\", \"21\", \"22\", \"23\",\n      \"37\", \"05\", \"3C\", \"08\", \"09\", \"0A\", \"3A\", \"3C\", \"3D\", \"3E\", \"3C\", \"03\",\n      \"03\", \"01\", \"06\", \"07\", \"13\", \"07\", \"09\", \"0A\", \"13\", \"24\", \"25\", \"3A\",\n      \"3C\", \"3D\", \"3E\", \"26\", \"2E\", \"2F\", \"1E\", \"0F\", \"1F\", \"28\", \"29\", \"2A\",\n      \"2D\", \"30\", \"33\", \"3C\", \"3E\", \"02\", \"39\", \"3B\", \"03\", \"2B\", \"02\", \"09\",\n      \"0A\", \"3A\", \"3C\", \"3D\", \"3E\", \"01\", \"06\", \"07\", \"13\", \"3C\", \"02\", \"1E\",\n      \"2D\", \"39\", \"3B\", \"26\", \"03\", \"07\", \"07\", \"09\", \"0A\", \"13\", \"24\", \"25\",\n      \"3A\", \"3C\", \"3D\", \"3E\", \"15\", \"34\", \"03\", \"3C\", \"3E\", \"20\", \"2C\", \"32\",\n      \"36\", \"02\", \"28\", \"3C\", \"02\", \"3C\", \"3D\", \"3E\", \"16\", \"07\", \"07\", \"02\",\n      \"1E\", \"26\", \"2D\", \"2E\", \"2F\", \"39\", \"3B\", \"2E\", \"2F\", \"02\", \"1E\", \"39\",\n      \"3B\", \"3C\", \"02\", \"07\", \"09\", \"0A\", \"3A\", \"3C\", \"3E\", \"06\", \"07\", \"09\",\n      \"0A\", \"20\", \"2C\", \"32\", \"35\", \"36\", \"3A\", \"3C\", \"3E\", \"01\", \"06\", \"07\",\n      \"12\", \"13\", \"1E\", \"39\", \"3B\", \"3C\", \"02\", \"04\", \"0B\", \"0C\", \"17\", \"18\",\n      \"19\", \"1A\", \"03\", \"1D\", \"3C\", \"02\", \"3C\", \"16\", \"3A\", \"3C\", \"09\", \"0A\",\n      \"3A\", \"3C\", \"3E\", \"1D\", \"39\", \"3B\", \"2D\", \"02\", \"02\", \"15\", \"34\", \"37\",\n      \"3C\", \"02\", \"3C\", \"07\", \"03\", \"03\", \"04\", \"06\", \"07\", \"09\", \"0A\", \"20\",\n      \"2C\", \"32\", \"35\", \"36\", \"3A\", \"3C\", \"3E\", \"04\", \"03\", \"09\", \"0A\", \"3A\",\n      \"3C\", \"3D\", \"3E\", \"02\", \"07\", \"09\", \"0A\", \"13\", \"24\", \"25\", \"3A\", \"3C\",\n      \"3D\", \"3E\", \"0F\", \"1F\", \"28\", \"29\", \"2A\", \"2D\", \"30\", \"33\", \"3C\", \"07\",\n      \"01\", \"06\", \"07\", \"12\", \"13\", \"09\", \"0A\", \"1B\", \"05\", \"04\", \"07\", \"10\",\n      \"11\", \"15\", \"27\", \"34\", \"02\", \"07\", \"13\", 0);\n   DECLARE NSY LITERALLY '158', NT LITERALLY '62', NPR LITERALLY '212';\n   DECLARE NNT LITERALLY '96';\n   DECLARE V(NSY) CHARACTER INITIAL('<ERROR: TOKEN = 0>', '.', ';', ',', '=',\n      ':', '@', '(', ')', '+', '-', '<', '>', '*', '/', 'IF', 'OF', 'DO', ':=',\n      '(.', '.)', 'TO', '..', '<>', '<=', '>=', 'IN', 'OR', '_|_', 'END', 'VAR',\n      'FOR', 'SET', 'DIV', 'MOD', 'AND', 'NOT', 'NIL', 'TYPE', 'THEN', 'CASE',\n      'WITH', 'GOTO', 'ELSE', 'FILE', 'BEGIN', 'LABEL', 'CONST', 'WHILE',\n      'UNTIL', 'ARRAY', 'REPEAT', 'DOWNTO', 'PACKED', 'RECORD', 'PROGRAM',\n      'FORWARD', 'FUNCTION', '<STRING>', 'PROCEDURE', '<IDENTIFIER>',\n      '<UNSIGNED REAL>', '<UNSIGNED INTEGER>', '<TYPE>', '<BODY>', '<SIGN>',\n      '<TERM>', '<BLOCK>', '<CLOSE>', '<RELOP>', '<ADDOP>', '<MULOP>',\n      '<FACTOR>', '<TERM 2>', '<PROGRAM>', '<RETURNS>', '<ID LIST>',\n      '<RPARENT>', '<CONSTANT>', '<VARIABLE>', '<VAR LIST>', '<EXP LIST>',\n      '<FACTOR 2>', '<ELEMENTS>', '<FIRSTPART>', '<VAR DECLS>', '<STATEMENT>',\n      '<STAT LIST>', '<PROC DECL>', '<ID LIST 2>', '<ELSE PART>', '<CASE LIST>',\n      '<QUALIFIER>', '<TAG IDENT>', '<SEMICOLON>', '<SECONDPART>',\n      '<TYPE DEFNS>', '<LABEL LIST>', '<PARAM LIST>', '<EXPRESSION>',\n      '<FOR STAT 2>', '<CONST LIST>', '<CONSTANT 1>', '<STRUC TYPE>',\n      '<FIELD LIST>', '<NEXT FIELD>', '<CONSTANT 2>', '<ELEMENTS 2>',\n      '<FUNC TYPES>', '<PROC TYPES>', '<SEMICOLON1>', '<DUMMYBLOCK>',\n      '<LABEL DECLS>', '<CONST DECLS>', '<PARAM TYPES>', '<CASE LIST 2>',\n      '<SIMPLE TYPE>', '<DUMMY FIELD>', '<ID STATEMENT>', '<PARAM LIST 1>',\n      '<PARAM LIST 2>', '<EXPRESSION 2>', '<ELEMENT LIST>', '<DUMMY ENDING>',\n      '<TYPE DEF LIST>', '<VAR DECL TAIL>', '<VAR DECL LIST>',\n      '<SIMPLE TYPE 1>', '<SIMPLE TYPE 3>', '<SIMPLE TYPE 2>',\n      '<RECORD ENDING>', '<PROC DECL LIST>', '<STATEMENT PART>',\n      '<TYPE DEFN TAIL>', '<PROC DECL TAIL>', '<DUMMY FOR STAT>',\n      '<PROGRAM HEADING>', '<CONST DECL LIST>', '<CONST DECL TAIL>',\n      '<TYPE IDENTIFIER>', '<PARAM TYPE LIST>', '<FUNC TYPES TAIL>',\n      '<PROC TYPES TAIL>', '<DUMMY TYPE BODY>', '<CONST VALUE PART>',\n      '<SIMPLE TYPE LIST>', '<VARIANT INSTANCE>', '<PARAM TYPES TAIL>',\n      '<SIMPLE EXPRESSION>', '<UNLABLED STATEMENT>', '<VARIANT INSTANCE 2>',\n      '<ASSIGNMENT     PART>', '<SIMPLE EXPRESSION 2>', '<DUMMY VAR DECL BODY>',\n      '<TYPE DESCRIPTOR PART>', '<PROGRAM HEADING TAIL>',\n      '<DUMMY STATEMENT TAIL>', '<VARIANT INSTANCE LIST>',\n      '<INDEX  AND  ELEMENTS  TYPE>');\n   DECLARE V_INDEX(18) BIT(8) INITIAL ( 1, 15, 28, 38, 45, 51, 55, 57, 59, 60,\n      60, 60, 61, 61, 61, 62, 62, 62, 63);\n   DECLARE GOAL LITERALLY '74';\n   DECLARE PR_LENGTH (212) BIT(8) INITIAL ( \"00\", \"03\", \"02\", \"03\", \"03\", \"03\",\n      \"02\", \"00\", \"03\", \"00\", \"02\", \"00\", \"02\", \"00\", \"01\", \"00\", \"02\", \"01\",\n      \"02\", \"00\", \"01\", \"00\", \"02\", \"01\", \"02\", \"00\", \"04\", \"05\", \"01\", \"04\",\n      \"00\", \"04\", \"00\", \"01\", \"01\", \"01\", \"00\", \"02\", \"01\", \"01\", \"03\", \"04\",\n      \"04\", \"03\", \"04\", \"04\", \"05\", \"01\", \"00\", \"01\", \"06\", \"04\", \"03\", \"04\",\n      \"00\", \"02\", \"00\", \"01\", \"00\", \"03\", \"03\", \"02\", \"00\", \"02\", \"00\", \"04\",\n      \"04\", \"05\", \"03\", \"01\", \"00\", \"02\", \"00\", \"05\", \"01\", \"00\", \"02\", \"00\",\n      \"01\", \"04\", \"02\", \"01\", \"00\", \"01\", \"02\", \"04\", \"04\", \"03\", \"02\", \"01\",\n      \"00\", \"02\", \"00\", \"00\", \"00\", \"00\", \"00\", \"01\", \"01\", \"01\", \"01\", \"01\",\n      \"02\", \"02\", \"02\", \"02\", \"00\", \"04\", \"06\", \"01\", \"00\", \"00\", \"02\", \"00\",\n      \"04\", \"02\", \"00\", \"02\", \"00\", \"00\", \"00\", \"00\", \"00\", \"00\", \"02\", \"02\",\n      \"00\", \"00\", \"00\", \"00\", \"00\", \"00\", \"00\", \"00\", \"02\", \"02\", \"02\", \"03\",\n      \"00\", \"00\", \"00\", \"00\", \"02\", \"03\", \"00\", \"00\", \"00\", \"00\", \"00\", \"00\",\n      \"01\", \"02\", \"01\", \"02\", \"00\", \"00\", \"00\", \"00\", \"01\", \"04\", \"03\", \"00\",\n      \"00\", \"02\", \"01\", \"00\", \"00\", \"01\", \"01\", \"00\", \"01\", \"00\", \"03\", \"00\",\n      \"02\", \"02\", \"02\", \"02\", \"01\", \"00\", \"01\", \"03\", \"00\", \"02\", \"05\", \"01\",\n      \"00\", \"03\", \"01\", \"00\", \"00\", \"00\", \"00\", \"01\", \"00\", \"00\", \"00\", \"01\",\n      \"00\", \"00\", \"02\", \"02\", \"01\", \"01\", \"00\", \"02\", \"01\", \"02\", \"03\", \"00\",\n      \"05\", \"05\", \"02\");\n   DECLARE PR_PTR (212) BIT(16) INITIAL ( \"0000\", \"0000\", \"0003\", \"0005\",\n      \"0008\", \"000B\", \"000E\", \"0010\", \"0010\", \"0013\", \"0013\", \"0015\", \"0015\",\n      \"0017\", \"0017\", \"0018\", \"0018\", \"001A\", \"001B\", \"001D\", \"001D\", \"001E\",\n      \"001E\", \"0020\", \"0021\", \"0023\", \"0023\", \"0027\", \"002C\", \"002D\", \"0031\",\n      \"0031\", \"0035\", \"0035\", \"0036\", \"0037\", \"0038\", \"0038\", \"003A\", \"003B\",\n      \"003C\", \"003F\", \"0043\", \"0047\", \"004A\", \"004E\", \"0052\", \"0057\", \"0058\",\n      \"0058\", \"0059\", \"005F\", \"0063\", \"0066\", \"006A\", \"006A\", \"006C\", \"006C\",\n      \"006D\", \"006D\", \"0070\", \"0073\", \"0075\", \"0075\", \"0077\", \"0077\", \"007B\",\n      \"007F\", \"0084\", \"0087\", \"0088\", \"0088\", \"008A\", \"008A\", \"008F\", \"0090\",\n      \"0090\", \"0092\", \"0092\", \"0093\", \"0097\", \"0099\", \"009A\", \"009A\", \"009B\",\n      \"009D\", \"00A1\", \"00A5\", \"00A8\", \"00AA\", \"00AB\", \"00AB\", \"00AD\", \"00AD\",\n      \"00AD\", \"00AD\", \"00AD\", \"00AD\", \"00AE\", \"00AF\", \"00B0\", \"00B1\", \"00B2\",\n      \"00B4\", \"00B6\", \"00B8\", \"00BA\", \"00BA\", \"00BE\", \"00C4\", \"00C5\", \"00C5\",\n      \"00C5\", \"00C7\", \"00C7\", \"00CB\", \"00CD\", \"00CD\", \"00CF\", \"00CF\", \"00CF\",\n      \"00CF\", \"00CF\", \"00CF\", \"00CF\", \"00D1\", \"00D3\", \"00D3\", \"00D3\", \"00D3\",\n      \"00D3\", \"00D3\", \"00D3\", \"00D3\", \"00D3\", \"00D5\", \"00D7\", \"00D9\", \"00DC\",\n      \"00DC\", \"00DC\", \"00DC\", \"00DC\", \"00DE\", \"00E1\", \"00E1\", \"00E1\", \"00E1\",\n      \"00E1\", \"00E1\", \"00E1\", \"00E2\", \"00E4\", \"00E5\", \"00E7\", \"00E7\", \"00E7\",\n      \"00E7\", \"00E7\", \"00E8\", \"00EC\", \"00EF\", \"00EF\", \"00EF\", \"00F1\", \"00F2\",\n      \"00F2\", \"00F2\", \"00F3\", \"00F4\", \"00F4\", \"00F5\", \"00F5\", \"00F8\", \"00F8\",\n      \"00FA\", \"00FC\", \"00FE\", \"0100\", \"0101\", \"0101\", \"0102\", \"0105\", \"0105\",\n      \"0107\", \"010C\", \"010D\", \"010D\", \"0110\", \"0111\", \"0111\", \"0111\", \"0111\",\n      \"0111\", \"0112\", \"0112\", \"0112\", \"0112\", \"0113\", \"0113\", \"0113\", \"0115\",\n      \"0117\", \"0118\", \"0119\", \"0119\", \"011B\", \"011C\", \"011E\", \"0121\", \"0121\",\n      \"0126\", \"012B\");\n   DECLARE RHS (300) BIT(8) INITIAL ( \"88\", \"43\", \"01\", \"54\", \"5F\", \"70\", \"71\",\n      \"60\", \"55\", \"83\", \"84\", \"56\", \"57\", \"1D\", \"56\", \"57\", \"3E\", \"61\", \"02\",\n      \"3E\", \"61\", \"3C\", \"90\", \"90\", \"4E\", \"8A\", \"89\", \"3C\", \"9A\", \"9A\", \"3F\",\n      \"85\", \"7C\", \"58\", \"86\", \"3C\", \"62\", \"02\", \"40\", \"3C\", \"62\", \"4B\", \"02\",\n      \"40\", \"43\", \"4C\", \"05\", \"3F\", \"7D\", \"4C\", \"05\", \"3F\", \"7D\", \"7E\", \"59\",\n      \"4C\", \"05\", \"95\", \"95\", \"76\", \"56\", \"57\", \"1D\", \"63\", \"27\", \"56\", \"5A\",\n      \"63\", \"10\", \"5B\", \"1D\", \"63\", \"11\", \"56\", \"56\", \"57\", \"31\", \"63\", \"3C\",\n      \"12\", \"63\", \"64\", \"4F\", \"50\", \"11\", \"56\", \"44\", \"3E\", \"63\", \"63\", \"51\",\n      \"14\", \"5C\", \"12\", \"63\", \"3C\", \"5C\", \"12\", \"63\", \"5C\", \"12\", \"63\", \"63\",\n      \"51\", \"08\", \"97\", \"63\", \"51\", \"56\", \"63\", \"11\", \"56\", \"63\", \"11\", \"56\",\n      \"4F\", \"50\", \"77\", \"08\", \"4C\", \"05\", \"8B\", \"78\", \"4C\", \"05\", \"8B\", \"78\",\n      \"4C\", \"8C\", \"05\", \"8B\", \"78\", \"4C\", \"8C\", \"78\", \"77\", \"72\", \"08\", \"4E\",\n      \"65\", \"05\", \"56\", \"73\", \"5B\", \"4E\", \"65\", \"5C\", \"63\", \"51\", \"14\", \"5C\",\n      \"3C\", \"5C\", \"5C\", \"7F\", \"4C\", \"08\", \"66\", \"16\", \"41\", \"66\", \"66\", \"16\",\n      \"41\", \"66\", \"16\", \"41\", \"66\", \"16\", \"80\", \"81\", \"41\", \"66\", \"74\", \"8B\",\n      \"67\", \"67\", \"9E\", \"10\", \"3F\", \"10\", \"74\", \"68\", \"82\", \"74\", \"91\", \"4C\",\n      \"05\", \"3F\", \"69\", \"5D\", \"05\", \"3C\", \"10\", \"92\", \"9D\", \"68\", \"92\", \"9D\",\n      \"4E\", \"65\", \"05\", \"96\", \"68\", \"08\", \"41\", \"6A\", \"94\", \"79\", \"45\", \"94\",\n      \"42\", \"98\", \"42\", \"98\", \"42\", \"98\", \"46\", \"42\", \"98\", \"48\", \"49\", \"47\",\n      \"48\", \"49\", \"52\", \"63\", \"4D\", \"48\", \"53\", \"14\", \"5C\", \"63\", \"51\", \"08\",\n      \"5C\", \"63\", \"6B\", \"7A\", \"3C\", \"9B\", \"8B\", \"73\", \"69\", \"63\", \"63\", \"6B\",\n      \"7A\", \"4C\", \"93\", \"4C\", \"93\", \"6C\", \"93\", \"6D\", \"93\", \"93\", \"72\", \"4C\",\n      \"08\", \"5E\", \"6E\", \"83\", \"72\", \"08\", \"05\", \"3C\", \"8D\", \"6C\", \"72\", \"08\",\n      \"8E\", \"6D\", \"64\", \"43\", \"3F\", \"69\", \"5B\", \"1D\", \"56\", \"64\", \"3F\", \"7D\",\n      \"9A\", \"3F\", \"85\", \"5C\", \"12\", \"63\", \"74\", \"91\", \"14\", \"10\", \"3F\", \"74\",\n      \"91\", \"08\", \"10\", \"3F\", \"56\", \"5A\");\n   DECLARE TERMINAL BIT(213) INITIAL (\"(1) 0 00001 10101 01010 11101 01100 11010\n      00111 01011 11111 11011 11101 01011 10100 11110 10010 10111 10111 11110\n      01111 10101 11111 00110 11001 10111 11000 01111 11111 00011 10001 11111\n      11111 11010 01110 10001 01001 11001 11011 01100 11001 00010 11001 00001\n      11\");\n    DECLARE CATCH_ACTION(62) BIT(16) INITIAL( \"0000\", \"0000\", \"0000\", \"00C2\",\n      \"0130\", \"014A\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\",\n      \"0000\", \"0000\", \"0032\", \"005F\", \"0088\", \"00B0\", \"0000\", \"0000\", \"0095\",\n      \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"00F9\", \"0015\",\n      \"0032\", \"00A2\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"000C\", \"00D9\",\n      \"0043\", \"0032\", \"0032\", \"00E9\", \"00A2\", \"0021\", \"0001\", \"0006\", \"0032\",\n      \"007B\", \"00A2\", \"0032\", \"0095\", \"00A2\", \"00A2\", \"0000\", \"0000\", \"0015\",\n      \"0000\", \"0015\", \"0113\", \"0000\", \"0000\");\n   DECLARE  SP_BIT  BIT(354) INITIAL(\"(1) 0 10000 11100 01110 00010 10110 01100\n      10111 01100 00001 10001 11101 00000 01100 00111 10001 10111 10000 00001\n      10000 10110 10100 00111 00110 10000 00111 10100 01000 01110 00000 01011\n      11100 00100 00011 10100 10100 00101 10000 01110 11010 01100 01110 10000\n      00011 01110 01110 00001 10111 01001 00100 10000 11001 01011 01110 10010\n      00001 01011 01001 01101 00100 00101 11000 11110 01100 11110 01100 00100\n      10100 01111 01110 00110 110 \");\n   DECLARE STOP_POP_SYMBOL(353) BIT(8) INITIAL (     \"00\",  \"4A\", \"43\", \"40\",\n      \"01\", \"00\", \"4A\", \"43\", \"40\", \"01\", \"5F\", \"00\", \"4A\", \"43\", \"40\", \"01\",\n      \"5F\", \"60\", \"55\", \"54\", \"00\", \"4A\", \"01\", \"43\", \"40\", \"5F\", \"55\", \"62\",\n      \"78\", \"77\", \"83\", \"8C\", \"00\", \"4A\", \"43\", \"40\", \"01\", \"5F\", \"84\", \"56\",\n      \"57\", \"44\", \"1D\", \"5A\", \"31\", \"64\", \"5B\", \"73\", \"95\", \"00\", \"4A\", \"43\",\n      \"40\", \"5F\", \"01\", \"84\", \"56\", \"57\", \"44\", \"1D\", \"5A\", \"31\", \"64\", \"5B\",\n      \"73\", \"95\", \"00\", \"7D\", \"7E\", \"96\", \"69\", \"60\", \"55\", \"68\", \"9D\", \"92\",\n      \"3F\", \"85\", \"4A\", \"43\", \"40\", \"5F\", \"01\", \"84\", \"56\", \"57\", \"44\", \"1D\",\n      \"5A\", \"31\", \"64\", \"5B\", \"73\", \"95\", \"00\", \"9D\", \"96\", \"10\", \"69\", \"68\",\n      \"3F\", \"60\", \"85\", \"9A\", \"83\", \"86\", \"84\", \"7D\", \"4A\", \"43\", \"40\", \"01\",\n      \"5F\", \"84\", \"56\", \"57\", \"1D\", \"44\", \"5A\", \"31\", \"64\", \"73\", \"00\", \"4A\",\n      \"43\", \"40\", \"01\", \"31\", \"56\", \"57\", \"5A\", \"1D\", \"5B\", \"73\", \"44\", \"00\",\n      \"11\", \"4A\", \"43\", \"40\", \"01\", \"56\", \"57\", \"5A\", \"1D\", \"44\", \"31\", \"64\",\n      \"00\", \"4A\", \"43\", \"40\", \"01\", \"56\", \"57\", \"5A\", \"1D\", \"44\", \"5B\", \"73\",\n      \"31\", \"00\", \"3F\", \"85\", \"4A\", \"43\", \"40\", \"01\", \"96\", \"9D\", \"5F\", \"60\",\n      \"69\", \"7E\", \"7D\", \"00\", \"12\", \"76\", \"97\", \"57\", \"56\", \"95\", \"5A\", \"31\",\n      \"1D\", \"44\", \"63\", \"4A\", \"43\", \"40\", \"01\", \"5F\", \"84\", \"00\", \"55\", \"7D\",\n      \"4C\", \"59\", \"76\", \"50\", \"65\", \"51\", \"53\", \"52\", \"4A\", \"61\", \"01\", \"57\",\n      \"31\", \"1D\", \"44\", \"11\", \"10\", \"7A\", \"8D\", \"8E\", \"00\", \"4A\", \"43\", \"40\",\n      \"6E\", \"01\", \"5F\", \"56\", \"95\", \"57\", \"73\", \"1D\", \"5A\", \"44\", \"64\", \"5B\",\n      \"00\", \"4A\", \"43\", \"40\", \"01\", \"5F\", \"5A\", \"56\", \"95\", \"57\", \"44\", \"64\",\n      \"31\", \"1D\", \"5B\", \"73\", \"00\", \"82\", \"1D\", \"3F\", \"60\", \"85\", \"55\", \"7D\",\n      \"83\", \"86\", \"84\", \"7E\", \"7D\", \"5F\", \"4A\", \"43\", \"40\", \"01\", \"84\", \"56\",\n      \"5A\", \"5B\", \"73\", \"57\", \"31\", \"44\", \"00\", \"71\", \"90\", \"54\", \"5F\", \"60\",\n      \"85\", \"9A\", \"55\", \"3F\", \"9D\", \"69\", \"7D\", \"62\", \"78\", \"5B\", \"73\", \"72\",\n      \"57\", \"93\", \"5A\", \"56\", \"31\", \"44\", \"84\", \"01\", \"43\", \"40\", \"4A\", \"00\",\n      \"04\", \"90\", \"8A\", \"89\", \"71\", \"54\", \"86\", \"55\", \"5F\", \"7C\", \"85\", \"3F\",\n      \"60\", \"9A\", \"43\", \"40\", \"01\", \"79\", \"63\", \"56\", \"57\", \"10\", \"11\", \"64\",\n      \"4A\", \"00\", \"83\", \"5F\", \"7D\", \"68\", \"9D\", \"05\", \"3F\", \"92\", \"4A\", \"3F\",\n      \"40\", \"01\", \"96\", \"69\", \"56\", \"57\", \"31\", \"5A\", \"A1\", \"5B\", \"73\", \"62\",\n      \"77\", \"00\");\n   DECLARE REST_PTR(353) BIT(16) INITIAL(\"0000\"  , \"0001\", \"0000\", \"0000\",\n      \"0004\", \"0000\", \"0006\", \"000B\", \"000B\", \"000B\", \"000F\", \"0000\", \"0012\",\n      \"0016\", \"0016\", \"0016\", \"0019\", \"0000\", \"0019\", \"0019\", \"0000\", \"001B\",\n      \"0020\", \"0020\", \"0020\", \"0000\", \"0000\", \"0024\", \"0027\", \"0000\", \"0029\",\n      \"002B\", \"0000\", \"002E\", \"0031\", \"0031\", \"0031\", \"0031\", \"0033\", \"0000\",\n      \"0037\", \"0037\", \"0039\", \"0039\", \"0039\", \"0037\", \"003C\", \"0037\", \"0000\",\n      \"0000\", \"003F\", \"0033\", \"0033\", \"0033\", \"0033\", \"0033\", \"0000\", \"0037\",\n      \"0037\", \"0039\", \"0039\", \"0039\", \"0037\", \"003C\", \"0037\", \"0000\", \"0000\",\n      \"0044\", \"0047\", \"004B\", \"004E\", \"0050\", \"0050\", \"0000\", \"004B\", \"004B\",\n      \"0044\", \"0044\", \"003F\", \"0033\", \"0033\", \"0033\", \"0033\", \"0000\", \"0000\",\n      \"0037\", \"0037\", \"0039\", \"0039\", \"0039\", \"0037\", \"003C\", \"0037\", \"0000\",\n      \"0000\", \"0054\", \"0057\", \"0000\", \"005C\", \"0060\", \"0064\", \"0066\", \"006A\",\n      \"0066\", \"006D\", \"006D\", \"0071\", \"0076\", \"0079\", \"007F\", \"007F\", \"007F\",\n      \"0066\", \"0084\", \"0089\", \"0089\", \"0089\", \"0089\", \"0089\", \"0084\", \"0089\",\n      \"0089\", \"0000\", \"008D\", \"008D\", \"008D\", \"008D\", \"0000\", \"0093\", \"0093\",\n      \"0093\", \"0093\", \"0096\", \"0093\", \"0093\", \"0000\", \"0000\", \"009A\", \"009A\",\n      \"009A\", \"00A0\", \"00A5\", \"00A7\", \"00A7\", \"00A7\", \"00A7\", \"00A7\", \"00A7\",\n      \"0000\", \"00AA\", \"00AA\", \"00AA\", \"00AA\", \"00AF\", \"00AF\", \"00AF\", \"00AF\",\n      \"00AF\", \"00B1\", \"00AF\", \"00B4\", \"0000\", \"0000\", \"00B7\", \"00B9\", \"00B9\",\n      \"00B9\", \"00BE\", \"00C2\", \"00C2\", \"00C6\", \"00C6\", \"00B7\", \"00C9\", \"00B7\",\n      \"0000\", \"0000\", \"0000\", \"00CC\", \"00CF\", \"00CF\", \"00CF\", \"00CF\", \"00CF\",\n      \"00CF\", \"00D3\", \"00D7\", \"00D9\", \"00E0\", \"00E0\", \"00E0\", \"00E0\", \"00E5\",\n      \"0000\", \"00E9\", \"00EF\", \"00F4\", \"00F6\", \"00F9\", \"00FE\", \"0101\", \"0104\",\n      \"0107\", \"00F9\", \"010C\", \"0113\", \"0116\", \"011C\", \"011C\", \"011C\", \"011C\",\n      \"011C\", \"011C\", \"0120\", \"0124\", \"0127\", \"0000\", \"012A\", \"0131\", \"0131\",\n      \"0131\", \"0131\", \"0131\", \"0137\", \"0137\", \"0137\", \"0137\", \"0137\", \"0137\",\n      \"0137\", \"0137\", \"013B\", \"0000\", \"0140\", \"0145\", \"0145\", \"0145\", \"0145\",\n      \"0000\", \"0149\", \"014B\", \"014B\", \"014B\", \"014B\", \"014E\", \"014E\", \"014B\",\n      \"014B\", \"0000\", \"0000\", \"0000\", \"0152\", \"0154\", \"0152\", \"0154\", \"0157\",\n      \"0157\", \"015B\", \"015B\", \"0157\", \"0160\", \"0154\", \"0164\", \"016B\", \"016B\",\n      \"016B\", \"0152\", \"0152\", \"0152\", \"0171\", \"0152\", \"0152\", \"0152\", \"0152\",\n      \"0000\", \"0174\", \"0177\", \"0179\", \"017E\", \"017E\", \"0181\", \"0177\", \"0183\",\n      \"0185\", \"0188\", \"004E\", \"018A\", \"0024\", \"0027\", \"0000\", \"018E\", \"0000\",\n      \"0037\", \"0190\", \"0037\", \"0000\", \"0037\", \"0037\", \"0033\", \"0033\", \"0192\",\n      \"0192\", \"0195\", \"0000\", \"0000\", \"0000\", \"0199\", \"0199\", \"0199\", \"019D\",\n      \"01A2\", \"01A7\", \"01A2\", \"01A7\", \"01AB\", \"01AE\", \"01A7\", \"01A7\", \"01A2\",\n      \"01A2\", \"01A2\", \"0000\", \"01B0\", \"01B2\", \"01B2\", \"01B0\", \"01B0\", \"01B0\",\n      \"01B5\", \"0000\", \"01BB\", \"01BF\", \"01C5\", \"01C8\", \"01CC\", \"0000\", \"01CF\",\n      \"01CC\", \"01D1\", \"0000\", \"01D8\", \"01BF\", \"01E3\", \"01E7\", \"01EA\", \"01EA\",\n      \"01EA\", \"01EA\", \"01ED\", \"01F1\", \"01F5\", \"01F8\", \"01FD\", \"0000\");\n   DECLARE  REST_SYMBOL(512)  BIT(8)   INITIAL(     \"00\", \"02\", \"01\", \"43\",\n      \"01\", \"43\", \"04\", \"01\", \"5F\", \"60\", \"71\", \"03\", \"5F\", \"60\", \"71\", \"02\",\n      \"60\", \"71\", \"03\", \"01\", \"5F\", \"60\", \"02\", \"5F\", \"60\", \"01\", \"60\", \"04\",\n      \"01\", \"84\", \"83\", \"55\", \"03\", \"84\", \"83\", \"55\", \"02\", \"08\", \"77\", \"01\",\n      \"77\", \"01\", \"55\", \"02\", \"08\", \"72\", \"02\", \"01\", \"84\", \"01\", \"84\", \"03\",\n      \"1D\", \"57\", \"56\", \"01\", \"56\", \"02\", \"57\", \"56\", \"02\", \"73\", \"56\", \"04\",\n      \"01\", \"1D\", \"57\", \"56\", \"02\", \"82\", \"68\", \"03\", \"7D\", \"82\", \"68\", \"02\",\n      \"08\", \"68\", \"01\", \"68\", \"03\", \"85\", \"82\", \"68\", \"02\", \"92\", \"10\", \"04\",\n      \"08\", \"9D\", \"92\", \"10\", \"03\", \"9D\", \"92\", \"10\", \"03\", \"69\", \"3F\", \"10\",\n      \"01\", \"10\", \"03\", \"85\", \"3F\", \"10\", \"02\", \"3F\", \"10\", \"03\", \"7D\", \"7F\",\n      \"10\", \"04\", \"83\", \"7D\", \"7F\", \"10\", \"02\", \"7F\", \"10\", \"05\", \"01\", \"5F\",\n      \"85\", \"3F\", \"10\", \"04\", \"5F\", \"85\", \"3F\", \"10\", \"04\", \"57\", \"1D\", \"5B\",\n      \"10\", \"03\", \"1D\", \"5B\", \"10\", \"05\", \"01\", \"57\", \"5A\", \"63\", \"31\", \"02\",\n      \"63\", \"31\", \"03\", \"73\", \"63\", \"31\", \"05\", \"01\", \"1D\", \"57\", \"56\", \"11\",\n      \"04\", \"1D\", \"57\", \"56\", \"11\", \"01\", \"11\", \"02\", \"56\", \"11\", \"04\", \"01\",\n      \"1D\", \"57\", \"64\", \"01\", \"64\", \"02\", \"73\", \"64\", \"02\", \"57\", \"64\", \"01\",\n      \"3F\", \"04\", \"01\", \"5F\", \"85\", \"3F\", \"03\", \"5F\", \"85\", \"3F\", \"03\", \"08\",\n      \"69\", \"3F\", \"02\", \"85\", \"3F\", \"02\", \"7D\", \"3F\", \"02\", \"63\", \"12\", \"03\",\n      \"87\", \"63\", \"12\", \"03\", \"87\", \"9F\", \"12\", \"01\", \"12\", \"06\", \"01\", \"6F\",\n      \"1D\", \"57\", \"63\", \"12\", \"04\", \"1D\", \"57\", \"63\", \"12\", \"03\", \"57\", \"63\",\n      \"12\", \"05\", \"7D\", \"3F\", \"05\", \"4C\", \"03\", \"04\", \"3F\", \"05\", \"4C\", \"03\",\n      \"01\", \"03\", \"02\", \"4C\", \"03\", \"04\", \"08\", \"51\", \"63\", \"03\", \"02\", \"4F\",\n      \"03\", \"02\", \"4E\", \"03\", \"02\", \"63\", \"03\", \"04\", \"7A\", \"6B\", \"63\", \"03\",\n      \"06\", \"01\", \"43\", \"5E\", \"08\", \"4C\", \"03\", \"02\", \"3E\", \"03\", \"05\", \"57\",\n      \"56\", \"51\", \"63\", \"03\", \"03\", \"51\", \"63\", \"03\", \"03\", \"6B\", \"63\", \"03\",\n      \"02\", \"6C\", \"03\", \"02\", \"6D\", \"03\", \"06\", \"01\", \"1D\", \"57\", \"5A\", \"56\",\n      \"27\", \"05\", \"1D\", \"57\", \"5A\", \"56\", \"27\", \"03\", \"5A\", \"56\", \"27\", \"04\",\n      \"73\", \"5A\", \"56\", \"27\", \"04\", \"01\", \"1D\", \"57\", \"5A\", \"03\", \"1D\", \"57\",\n      \"5A\", \"01\", \"2B\", \"02\", \"56\", \"2B\", \"03\", \"57\", \"56\", \"2B\", \"01\", \"1D\",\n      \"02\", \"85\", \"1D\", \"03\", \"55\", \"85\", \"1D\", \"04\", \"83\", \"55\", \"85\", \"1D\",\n      \"03\", \"7E\", \"85\", \"1D\", \"06\", \"01\", \"6F\", \"7B\", \"57\", \"56\", \"1D\", \"05\",\n      \"6F\", \"7B\", \"57\", \"56\", \"1D\", \"02\", \"73\", \"1D\", \"02\", \"90\", \"3C\", \"01\",\n      \"3C\", \"04\", \"5F\", \"60\", \"90\", \"3C\", \"02\", \"9A\", \"3C\", \"01\", \"7C\", \"01\",\n      \"7E\", \"02\", \"05\", \"4C\", \"01\", \"92\", \"03\", \"3F\", \"05\", \"4C\", \"01\", \"5B\",\n      \"01\", \"72\", \"02\", \"5F\", \"7C\", \"03\", \"01\", \"5F\", \"7C\", \"03\", \"8A\", \"4E\",\n      \"04\", \"04\", \"60\", \"8A\", \"4E\", \"04\", \"04\", \"5F\", \"85\", \"3F\", \"04\", \"03\",\n      \"85\", \"3F\", \"04\", \"02\", \"3F\", \"04\", \"01\", \"04\", \"01\", \"79\", \"02\", \"79\",\n      \"9C\", \"05\", \"01\", \"5F\", \"85\", \"3F\", \"04\", \"03\", \"7D\", \"3F\", \"05\", \"05\",\n      \"84\", \"83\", \"7D\", \"3F\", \"05\", \"02\", \"3F\", \"05\", \"03\", \"69\", \"3F\", \"05\",\n      \"02\", \"96\", \"05\", \"01\", \"05\", \"06\", \"01\", \"84\", \"83\", \"7D\", \"3F\", \"05\",\n      \"0A\", \"84\", \"83\", \"7D\", \"43\", \"A0\", \"84\", \"83\", \"7D\", \"3F\", \"05\", \"03\",\n      \"08\", \"75\", \"05\", \"02\", \"75\", \"05\", \"02\", \"95\", \"05\", \"03\", \"A2\", \"95\",\n      \"05\", \"03\", \"73\", \"56\", \"05\", \"02\", \"56\", \"05\", \"04\", \"08\", \"78\", \"8B\",\n      \"05\", \"03\", \"78\", \"8B\", \"05\");\n  DECLARE CATCH_SYMBOLS BIT(63) INITIAL(\"(1)0 00011 00000 00001\n11100 10000 00011 11000 00111 11111 10111 11110 01010 00\");\n  DECLARE BLOCK_HEADS BIT(63) INITIAL(\" (1)0 00000 00000 00000 00000\n  00000 00001 00000 00100 00001 11000 00000 01010  00\");\n   DECLARE  IS_PROC_TYPE BIT(32) INITIAL(\"(1)0000 0000 0000 0000 0100 0000 1010\n 0000\");\n\n\n   /* END OF DECLARATIONS PUNCHED BY LL(1) ANALYZER                   */\n  DECLARE  NOT_VAR_NOR_CONST BIT(63) INITIAL(\"(1)0 00000 00000\n  00000 00000 00000 00000 00000 00000 00000 00000 00000 00101 11\");\n\n  DECLARE NULL LITERALLY '\"FFFFFFFF\"';\n  DECLARE RESERVED_WORDS  BIT(63) INITIAL(\"(1)0 00000 00000 00001 11000 10000\n   11011 11111 11111 11111 11111 11111 11010 00\");\n\n  DECLARE EQUIVALENT(NT) FIXED INITIAL(0,3,5,1,18,2,0,19,20,0,0,0,0,0,0,0,0,0,\n4,7,8, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n,0,0,0,0,0);\n DECLARE   CRASH_SCAN_SYMBOLS BIT(63)  INITIAL (\"(1)0 01011 00000 00001 00000\n 00000 00101 11000 00101 11011 11101 10111 01010 00\");\n  DECLARE RECOVERY_SYMBOLS BIT(97) INITIAL(\"(1)0 00000 00000 00000 00000\n00000  00000 00000 00000 00000 00010  00000 00000 10000 00000 00100 00000 00000\n  00000 00010 0\");\n  DECLARE DOT BIT(16) INITIAL(\"01\");\n  DECLARE  STAT_LIST BIT(16) INITIAL(\"57\");\n  DECLARE STATEMENT BIT(16) INITIAL(\"56\");\n  DECLARE PROC_DECL_LIST BIT(16) INITIAL(\"83\");\n  DECLARE  ELSE_PART BIT(16) INITIAL(\"5A\");\n  DECLARE  ELSE_TOKEN BIT(16) INITIAL(\"2B\");\n  DECLARE DUMMY_VAR_DECL_BODY BIT(16) INITIAL(\"99\");\n  DECLARE  VAR_DECLS BIT(16) INITIAL(\"55\");\n  DECLARE  TYPE_DEFNS BIT(16) INITIAL(\"60\");\n  DECLARE DUMMY_TYPE_BODY  BIT(16) INITIAL(\"8F\");\n  DECLARE CONST_DECLS BIT(16) INITIAL(\"71\");\n  DECLARE  SEMI_COLON BIT(16) INITIAL(\"02\");\n  DECLARE RIGHT_PAREN BIT(16) INITIAL(\"08\");\n   /*  DECLARATIONS FOR THE SCANNER                                        */\n\n   /* TOKEN IS THE INDEX INTO THE VOCABULARY V() OF THE LAST SYMBOL SCANNED,\n      CP IS THE POINTER TO THE LAST CHARACTER SCANNED IN THE CARDIMAGE,\n      BCD IS THE LAST SYMBOL SCANNED (LITERAL CHARACTER STRING). */\n   DECLARE (TOKEN, CP) FIXED, BCD CHARACTER;\n\n   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */\n   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1) = PAGE',\n      PAGE CHARACTER INITIAL ('1'), DOUBLE CHARACTER INITIAL ('0'),\n      DOUBLE_SPACE LITERALLY 'OUTPUT(1) = DOUBLE',\n      X70 CHARACTER INITIAL ('\n                    ');\n\n   /* LENGTH OF LONGEST SYMBOL IN V */\n   DECLARE (RESERVED_LIMIT, MARGIN_CHOP) FIXED;\n\n   /* CHARTYPE() IS USED TO DISTINGUISH CLASSES OF SYMBOLS IN THE SCANNER.\n      TX() IS A TABLE USED FOR TRANSLATING FROM ONE CHARACTER SET TO ANOTHER.\n      CONTROL() HOLDS THE VALUE OF THE COMPILER CONTROL TOGGLES SET IN $ CARDS.\n      NOT_LETTER_OR_DIGIT() IS SIMILIAR TO CHARTYPE() BUT USED IN SCANNING\n      IDENTIFIERS ONLY.\n\n      ALL ARE USED BY THE SCANNER AND CONTROL() IS SET THERE.\n   */\n   DECLARE CHARSET_SIZE LITERALLY  '255';\n   DECLARE (CHARTYPE,TX) (CHARSET_SIZE) BIT(8),\n    (CONTROL, NOT_LETTER_OR_DIGIT) (CHARSET_SIZE) BIT(1);\n\n   /* MINUS_FLAG IS SET IN SYNTHESIZE PRODUCTIONS 86 AND 122 TO TELL GET_TOKEN\n      TO FOLD THE VALUE OF A NEGATIVE CONSTANT. */\n   DECLARE MINUS_FLAG BIT(1);\n\n   /* ALPHABET CONSISTS OF THE SYMBOLS CONSIDERED ALPHABETIC IN BUILDING\n      IDENTIFIERS     */\n   DECLARE ALPHABET CHARACTER INITIAL ('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n\n   /* BUFFER HOLDS THE LATEST CARDIMAGE,\n      TEXT HOLDS THE PRESENT STATE OF THE INPUT TEXT\n      (NOT INCLUDING THE PORTIONS DELETED BY THE SCANNER),\n      TEXT_LIMIT IS A CONVENIENT PLACE TO STORE THE POINTER TO THE END OF TEXT,\n      CARD_COUNT IS INCREMENTED BY ONE FOR EVERY SOURCE CARD READ,\n      ERROR_COUNT TABULATES THE ERRORS AS THEY ARE DETECTED,\n      SEVERE_ERRORS TABULATES THOSE ERRORS OF FATAL SIGNIFICANCE.\n   */\n   DECLARE (BUFFER, TEXT) CHARACTER,\n      (TEXT_LIMIT, CARD_COUNT, ERROR_COUNT, SEVERE_ERRORS, PREVIOUS_ERROR) FIXED\n      ;\n\n   /* NUMBER_VALUE CONTAINS THE NUMERIC VALUE OF THE LAST CONSTANT SCANNED,\n      WHEN THE CONSTANT IS REAL, IT SPILLS OVER INTO A SECOND WORD,\n      THEREFORE NUMBER_VALUE IS DECLARED AS A TWO-ELEMENT ARRAY       */\n   DECLARE NUMBER_VALUE (1) FIXED;\n\n   /* EACH OF THE FOLLOWING CONTAINS THE INDEX INTO V() OF THE CORRESPONDING\n      SYMBOL.   WE ASK:    IF TOKEN = IDENT    ETC.    */\n   DECLARE (IDENT, INTCONST, REALCONST, NEOP, DIVIDE, EOFILE, BLANK,\n            ANDSY, ORSY, NOTSY, LTOP, LEOP, STRING, LPARENT, LBRACKET, COLON,\n            RPARENT, EQUALSIGN) BIT(16);\n  DECLARE (COMPILING,BATCHING) BIT(1);\n   DECLARE NODE_NUMBER BIT(16),\n           ERROR_NODE BIT(16) INITIAL (81),\n          ERROR_PROD LITERALLY '212' ;\n DECLARE   NODE#TRANSLATE (NPR) BIT(8) INITIAL (0, 1,2,0,0,10, 0,0,4,0,0,\n   0,5,0,0,0, 0,0,6,0,0, 0,0,0,0,0, 8,9,0,11,0, 12,0,0,0,0, 0,13,0,14,16,\n   17,18,19,20,21, 23,24,70,51,53, 55,54,53,0,0, 0,0,0,0,0, 0,0,0,0,26,\n   25,27,27,0,0, 0,80,28,0,0, 0,0,51,53,55, 54,0,59,60,61, 61,61,61,0,0,\n   0,0,0,0,0, 0,0,62,0,73, 63,64,65,66,0, 0,67,68,0,0, 0,0,0,69,66,\n   0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,30, 0,0,0,0,0, 0,0,0,0,0,\n0,0,0,0,49, 0,31,0,50,50, 50,50,0,53,48, 50,0,0,0,0, 10,0,0,0,0, 0,75,0,77,78,\n   79,79,80,0,0, 0,0,0,0,79, 0,0,79,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,\n   0,0,0,0,0, 0,0);\n   DECLARE PR# (NNT) BIT(8) INITIAL (ERROR_PROD, 28, 0, 0, 2,\n      190, 0, 0, 0, 154,   144, 1, 0, 0, 162,   0, 78, 62, 56, 0,\n      161, 0, 0, 0, 7,   26, 36, 0, 73, 82,   111, 182, 0, 0, 0,\n      64, 0, 0, 0, 0, 103, 107, 110, 0, 0, 0, 0, 0, 0, 0, 0, 174,\n      75, 87, ERROR_PROD,0, ERROR_PROD, 70, 0, 173, 0, 21, 33, 32,\n      0, 0, 0, 192, 25, 5, 23, 183, 0, 0, 15, 17, 16, 0, 0, 0, 0, 0,\n      16, 106, 114, 179, 0, 41, 115, 0, 138, 0, 22, 181, 0, 113, 0);\n\n\n\n\n   /* TRANSLATION TABLES USED BY THE SCANNER */\n   DECLARE F8 LITERALLY '\"FFFFFFFF\"';\n   DECLARE ALPHATABLE(63) FIXED INITIAL(F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,\n      F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,\n      \"FF00FFFF\", F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,\n      F8, F8, F8, F8, F8, \"FF000000\", 0, \"0000FFFF\", F8, \"FF000000\", 0,\n      \"0000FFFF\", F8, \"FFFF0000\", 0, \"0000FFFF\", F8, 0, 0, \"0000FFFF\", F8);\n   DECLARE BLANKTABLE(63) FIXED INITIAL(F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,\n      F8, F8, F8, F8, F8, F8,\"00FFFFFF\", F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,\n      F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,\n      F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,\n      F8);\n   DECLARE COMMENTTABLE(63) FIXED INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, \"000000FF\", \"FF000000\", 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0);\n   DECLARE STRINGTABLE(63) FIXED INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \"00FF0000\", 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0);\n\n\n   DECLARE S CHARACTER;  /* A TEMPORARY USED VARIOUS PLACES */\n\n   /*THE PROPER SUBSTRING OF POINTER IS USED TO PLACE A $ UNDER THE POINT\n      OF DETECTION OF AN ERROR DURING CHECKING.  IT MARKS THE LAST CHARACTER\n      SCANNED.  */\n   DECLARE POINTER CHARACTER INITIAL ('\n                                           $');\n   DECLARE CALLCOUNT(20) FIXED   /* COUNT THE CALLS OF IMPORTANT PROCEDURES */\n      INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n   /* RECORD THE TIMES OF IMPORTANT POINTS DURING CHECKING */\n   DECLARE (CLOCK, CPU_CLOCK) (3) FIXED;\n   DECLARE ELAPSED_CPU_TIME LITERALLY 'CLOCK_TRAP(1)';\n\n\n   /* COMMONLY USED STRINGS */\n   DECLARE X1 CHARACTER INITIAL(' '), X4 CHARACTER INITIAL('    ');\n   DECLARE PERIOD CHARACTER INITIAL ('.');\n\n   /* TEMPORARIES USED THROUGHOUT THE COMPILER */\n   DECLARE (I, J) FIXED;\n\n   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';\n   DECLARE REAL LITERALLY 'BIT(32)';\n   DECLARE @REAL LITERALLY 'FIXED';\n   DECLARE MAXINT LITERALLY'2147483647';   /* 2**31 - 1 */\n   DECLARE NUL LITERALLY '\"FFFF\"';\n\n   /* THE DEBUG SET SWITCH */\n   DECLARE DEBUGGING LITERALLY '0';\n\n   DECLARE LAST_LITERAL_SCANNED FIXED,\n           CURRENT_LEVEL FIXED;\n   DECLARE LOOKUP_TYPE(NT) BIT(8);\n\n   /*  THE STACKS DECLARED BELOW ARE USED TO DRIVE THE SYNTACTIC\n      ANALYSIS ALGORITHM AND STORE INFORMATION RELEVANT TO THE INTERPRETATION\n      OF THE TEXT.  */\n\n   DECLARE STACKSIZE LITERALLY '100';  /* SIZE OF STACK */\n   DECLARE PARSE_STACK (STACKSIZE) BIT(8); /* TOKENS OF THE PARTIALLY PARSED\n                                              TEXT */\n\n   /* SP POINTS TO THE RIGHT END OF THE REDUCIBLE STRING IN THE PARSE STACK,\n      NT1 IS NT + 1  */\n   DECLARE (SP, NT1) FIXED;\n\n\n   /* THE SEMANTIC STACKS */\n   DECLARE NODE_STACK(STACKSIZE) BIT(16),\n           SUBTREE_INDEX(STACKSIZE) BIT(16),\n           SUBTREE_STACK(STACKSIZE) BIT(16),\n           (NODE_STACKSIZE, SUBTREE_STACKSIZE) BIT(16);\n   /* THE PARSE TREE */\n   DECLARE #_OF_TREES BIT(16);\n   DECLARE PARSE_TREE(7200) BIT(16), TREE_SIZE FIXED;\n   DECLARE MAX_TREE FIXED;   /* SIZE OF LARGEST PARSE_TREE */\n\n   /* THE SYMBOL TABLE */\n   DECLARE IDENTITY_LENGTH LITERALLY '500';\n   DECLARE TABLE_LENGTH LITERALLY '850';\n   DECLARE #_PREDECLARED FIXED INITIAL (46);\n   DECLARE BLOCK_DEPTH LITERALLY '25';\n   DECLARE NEW LITERALLY '1', OLD LITERALLY '0';\n   DECLARE BLOCK_CLOSURE_CODE BIT(1) INITIAL (NEW);\n   DECLARE NESTING_LEVEL FIXED;\n   DECLARE DUMMY_NAME# FIXED;\n   DECLARE #_MULTIPLE_DECLARATIONS BIT(16);\n   DECLARE DOLLAR CHARACTER INITIAL ('$');\n   DECLARE (IS_WITHBLOCK, IS_QUALIFIED_REFERENCE) (BLOCK_DEPTH) BIT(1),\n           (BLOCK_STACK, WITHCOUNT, PROCMARK, SYMB_BLOCK_OWNER) (BLOCK_DEPTH)\n                  BIT(16);\n   DECLARE  IS_PROC_CALL  BIT(1),\n            IS_FUNC_CALL(BLOCK_DEPTH) BIT(1);\n   DECLARE BUCKET (255) BIT(16);\n   DECLARE IDENTITY (IDENTITY_LENGTH) CHARACTER INITIAL (\n      'FALSE', 'TRUE', 'NIL', '(..)', 'INTEGER', 'BOOLEAN', 'REAL', 'CHAR',\n      'TEXT', 'INPUT', 'OUTPUT', 'ABS', 'SQR', 'ODD', 'SUCC', 'PRED', 'ORD',\n      'CHR', 'TRUNC', 'EOF', 'SIN', 'COS', 'EXP', 'LN', 'SQRT', 'ARCTAN',\n      'ROUND', 'EOLN', 'GET', 'PUT', 'RESET', 'REWRITE', 'NEW', 'READ', 'WRITE',\n      'PACK', 'UNPACK', 'MAXINT', 'DISPOSE', 'PAGE', 'READLN', 'WRITELN',\n      'CLOCK', 'INTFIELDSIZE', 'BOOLFIELDSIZE', 'REALFIELDSIZE',\n      'DECIMAL_PLACES');\n   DECLARE DATATYPE (TABLE_LENGTH) BIT(16) INITIAL (\n      5, 5, 2, 3, 37, 5, NUL, NUL, 7, 8,\n      8, NUL, NUL, 5, NUL, NUL, 4, 7, 4, 5,\n      6, 6, 6, 6, 6, 6, 4, 5, NUL, NUL,\n      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,\n      NUL, NUL, 4, 4, 4, 4, 4);\n   DECLARE VAR_TYPE (TABLE_LENGTH) BIT(16) INITIAL (\n      2, 2, 2, 2, 4, 4, 4, 4, 4, 1,\n      1, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n      5, 5, 5, 5, 5, 5, 5, 2, 5, 5,\n      5, 5, 5, 1, 1, 1, 1);\n   DECLARE INTCHAIN FIXED INITIAL (NULL), REALCHAIN FIXED INITIAL (NULL),\n              CHARCHAIN FIXED INITIAL (NULL);\n   DECLARE WHERE_DECL(IDENTITY_LENGTH) BIT(16);\n   DECLARE N_LOOKUPS(IDENTITY_LENGTH) BIT(16);\n   DECLARE VALUE(TABLE_LENGTH) BIT(32);\n   DECLARE SYMB_LINK(IDENTITY_LENGTH) BIT(16);\n   DECLARE N_DECL_SYMB FIXED;\n   DECLARE N_ANONYMOUS_SYMB FIXED;\n   DECLARE LABEL_DECL BIT(1);\n   DECLARE LABEL_LOOKUP BIT(1);\n   DECLARE OWN_MOD FIXED;\n   DECLARE CURRENT_BLOCK FIXED;\n   DECLARE FIRST_LITERAL FIXED;\n   DECLARE SYMB_OVFLO CHARACTER INITIAL(\n           'SYMBOL TABLE OVERFLOW, COMPILATION ABORTED');\n\n   /* POINTERS INTO THE SYMBOL TABLE TO THE PREDECLARED TYPES */\n   DECLARE INTPTR  BIT(16) INITIAL(4),\n           BOOLPTR BIT(16) INITIAL(5),\n           REALPTR BIT(16) INITIAL(6),\n           CHARPTR BIT(16) INITIAL(7);\n\n   /* STORAGE ALLOCATION COUNTERS */\n      DECLARE (CONST_POOL_SIZE, LITERAL_POOL_SIZE) FIXED;\n\n   /* TYPE_DECL_PART IS USED TO ALLOW FORWARD REFERENCES IN POINTER TYPE\n      DEFINITIONS.  FORWARD_REF_HEAD IS THE INDEX IN THE SYMBOL TABLE OF\n      THE MOST RECENT FORWARD REFERENCE POINTER TYPE.  THESE ARE CHAINED\n      TOGETHER BY THEIR S_LIST'S   */\n   DECLARE TYPE_DECL_PART BIT(1), FORWARD_REF_HEAD BIT(16);\n\n   /* PARAMETERS PASSED TO CLOCK_TRAP */\n   DECLARE TIMEST FIXED INITIAL (360000),\n           TIMETRAP FIXED INITIAL(0);\n\n\n   /* IS_DECLARATION IS A FLAG USED TO INDICATE WHEN A NEW IDENTIFIER IS TO BE\n      ENTERED IN THE CURRENT BLOCK, IF NOT ALREADY PRESENT THERE.\n      VARTYPECODE IS THE VALUE TO BE ENTERED IN THE VAR_TYPE COLUMN.  IT IS\n      SET, ALONG WITH IS_DECLARATION, IN PROCEDURE SYNTHESIZE.         */\n   DECLARE IS_DECLARATION BIT(1),  VARTYPECODE FIXED;\n      DECLARE IS_FORWARD_DECL BIT(1);\n\n   /* TYPE VAR_TYPES =\n        (TYPE_ID, VARIABLE, CONSTANT, LITERAL, TYPE, PROC, VAR_PARAM,\n         PROC_PARAM, UNDEFINED, LABLE, TAG, CASELABEL, VARIANT, FIELD_ID,\n         FORWARD, MULTDECL, VALUE_PARAM); */\n\n   DECLARE VARIABLE    BIT(16) INITIAL(01),\n           CONSTANT    BIT(16) INITIAL(02),\n           LITERAL     BIT(16) INITIAL(03),\n           TYPE        BIT(16) INITIAL(04),\n           PROC        BIT(16) INITIAL(05),\n           VAR_PARAM   BIT(16) INITIAL(06),\n           PROC_PARAM  BIT(16) INITIAL(07),\n           UNDEFINED   BIT(16) INITIAL(08),\n           LABLE       BIT(16) INITIAL(09),\n           VARIANT     BIT(16) INITIAL(12),\n           FIELD_ID    BIT(16) INITIAL(13),\n           FORWARD     BIT(16) INITIAL(14),\n           MULTDECL    BIT(16) INITIAL(15),\n           VALUE_PARAM BIT(16) INITIAL(16);\n   DECLARE RECORD BIT(16) INITIAL (17);\n\n   /*   FLOATING POINT POWERS OF TEN */\n   DECLARE POWERS(307) REAL INITIAL(\"001DA48C\", \"E468E7C7\", \"011286D8\",\n      \"0EC190DC\", \"01B94470\", \"938FA89C\", \"0273CAC6\", \"5C39C961\", \"03485EBB\",\n      \"F9A41DDD\", \"042D3B35\", \"7C0692AA\", \"051C4501\", \"6D841BAA\", \"0611AB20\",\n      \"E472914A\", \"06B0AF48\", \"EC79ACE8\", \"076E6D8D\", \"93CC0C11\", \"08450478\",\n      \"7C5F878B\", \"092B22CB\", \"4DBBB4B7\", \"0A1AF5BF\", \"109550F2\", \"0B10D997\",\n      \"6A5D5297\", \"0BA87FEA\", \"27A539EA\", \"0C694FF2\", \"58C74432\", \"0D41D1F7\",\n      \"777C8A9F\", \"0E29233A\", \"AAADD6A4\", \"0F19B604\", \"AAACA626\", \"101011C2\",\n      \"EAABE7D8\", \"10A0B19D\", \"2AB70E6F\", \"11646F02\", \"3AB26905\", \"123EC561\",\n      \"64AF81A3\", \"13273B5C\", \"DEEDB106\", \"1418851A\", \"0B548EA4\", \"14F53304\",\n      \"714D9266\", \"15993FE2\", \"C6D07B80\", \"165FC7ED\", \"BC424D30\", \"173BDCF4\",\n      \"95A9703E\", \"18256A18\", \"DD89E627\", \"1917624F\", \"8A762FD8\", \"19E9D71B\",\n      \"689DDE72\", \"1A922671\", \"2162AB07\", \"1B5B5806\", \"B4DDAAE4\", \"1C391704\",\n      \"310A8ACF\", \"1D23AE62\", \"9EA696C1\", \"1E164CFD\", \"A3281E39\", \"1EDF01E8\",\n      \"5F912E38\", \"1F8B6131\", \"3BBABCE3\", \"20571CBE\", \"C554B60E\", \"213671F7\",\n      \"3B54F1C9\", \"2222073A\", \"8515171D\", \"23154484\", \"932D2E72\", \"23D4AD2D\",\n      \"BFC3D078\", \"2484EC3C\", \"97DA624B\", \"255313A5\", \"DEE87D6F\", \"2633EC47\",\n      \"AB514E65\", \"272073AC\", \"CB12D0FF\", \"2814484B\", \"FEEBC2A0\", \"28CAD2F7\",\n      \"F5359A3B\", \"297EC3DA\", \"F9418065\", \"2A4F3A68\", \"DBC8F03F\", \"2B318481\",\n      \"895D9627\", \"2C1EF2D0\", \"F5DA7DD9\", \"2D1357C2\", \"99A88EA7\", \"2DC16D9A\",\n      \"0095928A\", \"2E78E480\", \"405D7B96\", \"2F4B8ED0\", \"283A6D3E\", \"302F3942\",\n      \"19248447\", \"311D83C9\", \"4FB6D2AC\", \"3212725D\", \"D1D243AC\", \"32B877AA\",\n      \"3236A4B4\", \"33734ACA\", \"5F6226F1\", \"34480EBE\", \"7B9D5856\", \"352D0937\",\n      \"0D425736\", \"361C25C2\", \"68497682\", \"37119799\", \"812DEA11\", \"37AFEBFF\",\n      \"0BCB24AB\", \"386DF37F\", \"675EF6EB\", \"3944B82F\", \"A09B5A53\", \"3A2AF31D\",\n      \"C4611874\", \"3B1AD7F2\", \"9ABCAF48\", \"3C10C6F7\", \"A0B5ED8D\", \"3CA7C5AC\",\n      \"471B4784\", \"3D68DB8B\", \"AC710CB3\", \"3E418937\", \"4BC6A7F0\", \"3F28F5C2\",\n      \"8F5C28F6\", \"40199999\", \"9999999A\", \"41100000\", \"00000000\", \"41A00000\",\n      \"00000000\", \"42640000\", \"00000000\", \"433E8000\", \"00000000\", \"44271000\",\n      \"00000000\", \"45186A00\", \"00000000\", \"45F42400\", \"00000000\", \"46989680\",\n      \"00000000\", \"475F5E10\", \"00000000\", \"483B9ACA\", \"00000000\", \"492540BE\",\n      \"40000000\", \"4A174876\", \"E8000000\", \"4AE8D4A5\", \"10000000\", \"4B9184E7\",\n      \"2A000000\", \"4C5AF310\", \"7A400000\", \"4D38D7EA\", \"4C680000\", \"4E2386F2\",\n      \"6FC10000\", \"4F163457\", \"85D8A000\", \"4FDE0B6B\", \"3A764000\", \"508AC723\",\n      \"0489E800\", \"5156BC75\", \"E2D63100\", \"523635C9\", \"ADC5DEA0\", \"5321E19E\",\n      \"0C9BAB24\", \"54152D02\", \"C7E14AF7\", \"54D3C21B\", \"CECCEDA1\", \"55845951\",\n      \"61401485\", \"5652B7D2\", \"DCC80CD3\", \"5733B2E3\", \"C9FD0804\", \"58204FCE\",\n      \"5E3E2502\", \"591431E0\", \"FAE6D721\", \"59C9F2C9\", \"CD04674F\", \"5A7E37BE\",\n      \"2022C091\", \"5B4EE2D6\", \"D415B85B\", \"5C314DC6\", \"448D9339\", \"5D1ED09B\",\n      \"EAD87C03\", \"5E134261\", \"72C74D82\", \"5EC097CE\", \"7BC90716\", \"5F785EE1\",\n      \"0D5DA46E\", \"604B3B4C\", \"A85A86C4\", \"612F050F\", \"E938943B\", \"621D6329\",\n      \"F1C35CA5\", \"63125DFA\", \"371A19E7\", \"63B7ABC6\", \"27050306\", \"6472CB5B\",\n      \"D86321E4\", \"6547BF19\", \"673DF52E\", \"662CD76F\", \"E086B93D\", \"671C06A5\",\n      \"EC5433C6\", \"68118427\", \"B3B4A05C\", \"68AF298D\", \"050E4396\", \"696D79F8\",\n      \"2328EA3E\", \"6A446C3B\", \"15F99267\", \"6B2AC3A4\", \"EDBBFB80\", \"6C1ABA47\",\n      \"14957D30\", \"6D10B46C\", \"6CDD6E3E\", \"6DA70C3C\", \"40A64E6C\", \"6E6867A5\",\n      \"A867F104\", \"6F4140C7\", \"8940F6A2\", \"7028C87C\", \"B5C89A25\", \"71197D4D\",\n      \"F19D6057\", \"71FEE50B\", \"7025C36A\", \"729F4F27\", \"26179A22\", \"73639178\",\n      \"77CEC055\", \"743E3AEB\", \"4AE13835\", \"7526E4D3\", \"0ECCC321\", \"76184F03\",\n      \"E93FF9F5\", \"76F31627\", \"1C7FC391\", \"7797EDD8\", \"71CFDA3A\", \"785EF4A7\",\n      \"4721E864\", \"793B58E8\", \"8C75313F\", \"7A251791\", \"57C93EC7\", \"7B172EBA\",\n      \"D6DDC73D\", \"7BE7D34C\", \"64A9C85D\", \"7C90E40F\", \"BEEA1D3A\", \"7D5A8E89\",\n      \"D7525244\", \"7E389916\", \"2693736B\", \"7F235FAD\", \"D81C2823\");\n\n   /* FLAGS TO SIGNAL EMPTY CASE INSTANCE OR EMPTY FIXED FIELD */\n   DECLARE IS_EMPTY_CASE_INSTANCE BIT(1) INITIAL(FALSE),\n           IS_EMPTY_FIELD_LIST BIT(1) INITIAL(FALSE);\n\n\n\n\n\n   /*               P R O C E D U R E S                                  */\n\n\n\nI_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;\n\n      STRING = NUMBER;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN SUBSTR('0000000000', 0, WIDTH-L) || STRING;\n   END I_FORMAT;\n\nERROR:\n   PROCEDURE(MSG, SEVERITY);\n      /* PRINTS AND ACCOUNTS FOR ALL ERROR MESSAGES */\n      /* IF SEVERITY IS NOT SUPPLIED, 0 IS ASSUMED */\n      DECLARE MSG CHARACTER, SEVERITY FIXED;\n      DECLARE TP FIXED;\n      /* IF LISTING IS SUPPRESSED, FORCE PRINTING OF THIS LINE */\n      IF \u00ac CONTROL(BYTE('L')) THEN\n         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|';\n      IF CP \u00ac= TP | CARD_COUNT \u00ac= PREVIOUS_ERROR THEN DO;\n      OUTPUT = SUBSTR(POINTER, TEXT_LIMIT-CP+MARGIN_CHOP);\n      OUTPUT = '*** ERROR, ' || MSG ||\n            '.  LAST PREVIOUS ERROR WAS DETECTED ON LINE ' ||\n            PREVIOUS_ERROR || '.  ***';\n      ERROR_COUNT = ERROR_COUNT + 1;\n      TP = CP;\n      PREVIOUS_ERROR = CARD_COUNT;\n      IF SEVERITY > 0 THEN\n         IF SEVERE_ERRORS > 25 THEN\n            DO;\n               OUTPUT = '*** TOO MANY SEVERE ERRORS, CHECKING ABORTED ***';\n               COMPILING = FALSE;\n            END;\n         ELSE SEVERE_ERRORS = SEVERE_ERRORS + 1;\n      END;\n      ELSE DO;\n         OUTPUT = '***        ' || MSG;\n         IF SEVERITY = 1 & SEVERE_ERRORS = 0 THEN SEVERE_ERRORS = 1;\n         END;\n      SEVERITY = 0; /* IN CASE SEVERITY IS NOT SPECIFIED NEXT TIME */\n   END ERROR;\n\nIS_TERMINAL:  PROCEDURE (I) BIT(1);\n   /* SIMULATES A BIT(1) ARRAY USING THE BIT STRING 'TERMINAL'.       */\n   DECLARE I FIXED;\n      RETURN(SHL(BYTE(TERMINAL, SHR(I, 3)), I & \"07\") &\"80\")\u00ac= 0;\n   END IS_TERMINAL;\n\n\n   IS_DECLARATION_NODE:\n      PROCEDURE (SP) BIT(1);\n         DECLARE (SP, NODE_NUMBER) BIT(16);\n         DECLARE DECLARATION_NODES BIT(96) INITIAL (\"(1) 0000 0010 0100 1000 000\n0 0000 0111 0000 0000 0000 0000 0000 0000 0000 0000 0010 0001 0000 0000 0000\n0000 0000 0000 0000\");\n         NODE_NUMBER = NODE_STACK(SP);\n         SP = BYTE (DECLARATION_NODES, SHR(NODE_NUMBER, 3));\n         RETURN SHR (SP, 7 - (NODE_NUMBER & 7)) & 1;\n      END IS_DECLARATION_NODE;\n\n   IS_ARRAY_OR_FILE_TYPE:\n      PROCEDURE (SP) BIT(1);\n         DECLARE (SP, NODE_NUMBER) BIT(16);\n         DECLARE ARRAY_OR_FILETYPE BIT(96) INITIAL (\"(1) 0000 0000 0000 0000 000\n0 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0011 1000 0001 1100 0000\n0000 0000 0000 0000\");\n         NODE_NUMBER = NODE_STACK(SP);\n         SP = BYTE (ARRAY_OR_FILETYPE, SHR(NODE_NUMBER, 3));\n         RETURN SHR (SP, 7 - (NODE_NUMBER & 7)) & 1;\n      END IS_ARRAY_OR_FILE_TYPE;\n\n   ASSOCIATE_TYPE_WITH_ID:\n      PROCEDURE;\n         DECLARE (ID_PTR, SP) BIT(16);\n         SP = NODE_STACKSIZE;\n         DO WHILE IS_ARRAY_OR_FILE_TYPE(SP);\n            SP = SP - 1;\n            END;\n         IF \u00acIS_DECLARATION_NODE(SP) THEN RETURN;\n         /* ELSE ALLOCATE TYPE WITH VARIABLE OR FIELD IDENTIFIERS */\n         IF (LAST_LITERAL_SCANNED > #_PREDECLARED) &\n                   (DATATYPE(LAST_LITERAL_SCANNED) = NULL) THEN\n               DATATYPE(LAST_LITERAL_SCANNED) = LAST_LITERAL_SCANNED;\n         IF TYPE_DECL_PART THEN DO;\n               /* CHOOSE THE FIRST LEAF NODE ON THE SUBTREE STACK */\n               SP = SUBTREE_STACKSIZE;\n               DO WHILE PARSE_TREE(SUBTREE_STACK(SP)) > 0;\n                  SP = SP - 1;\n                  END;\n               ID_PTR = PARSE_TREE(SUBTREE_STACK(SP) + 1);\n              IF ID_PTR > #_PREDECLARED THEN\n                  DATATYPE(ID_PTR) = LAST_LITERAL_SCANNED;\n               IF NODE_STACK(SP) = 6 THEN /* A TYPE RENAMING, PROPAGATE THE */\n                  VALUE(ID_PTR) = VALUE(LAST_LITERAL_SCANNED);  /* BLOCK NO. */\n               END;\n         ELSE DO SP = SUBTREE_INDEX(SP) TO SUBTREE_STACKSIZE;\n            IF PARSE_TREE(SUBTREE_STACK(SP)) = 0 THEN DO;\n               ID_PTR = PARSE_TREE(SUBTREE_STACK(SP) + 1);\n               IF ID_PTR > #_PREDECLARED THEN\n                  DATATYPE(ID_PTR) = LAST_LITERAL_SCANNED;\n               END;\n            END;\n      END ASSOCIATE_TYPE_WITH_ID;\n\n /******************************************************************************\n*                                                                              *\n*                                                                              *\n*        THE DGNS MODULE FOR PASCAL COMPILER                                   *\n*        DESIGNED BY                                                           *\n*             JOHN HENNESSY     GARY GOLDSTEIN     CHIA CHINSAW                *\n*                                                                              *\n*        MSC 522        DATE  10/29/74   VERSION 1                             *\n*               VERSION UPDATE 3  INCLUDES ERROR MESSAGES AND DEBUGGING CODE   *\n*                                                                              *\n*                  P U R P O S E                                               *\n*                       TO PREPARE THE PARGRAPHED VERSION OF THE SOURCE CODE   *\n*                       AND SET BASIC BLOCK POINTERS  (SEE SPECS. AND DOCUMENT.*\n*                                                                              *\n*                                                                              *\n*******************************************************************************/\n\n /******************************************************************************\n*                                                                              *\n*        THE FOLLOWING DECLARATION MUST APPEAR    THESE ARE GLOBAL INPUTS      *\n*                                                                              *\n*******************************************************************************/\n     DECLARE DGNS#_FILE_NO FIXED INITIAL(3);\n     DECLARE STRING_VALUE CHARACTER;\n\n /******************************************************************************\n*                                                                              *\n*                                                                              *\n*        THE FOLLOWING ARE GLOBAL VARIABLE DECLARATIONS OF OUTSIDE INTEREST    *\n*       THEY ARE EITHER DECLARATIONS OF OUTPUTED VARIABLES OR MACROS           *\n*                                                                              *\n*                                                                              *\n*******************************************************************************/\nDECLARE MAX_DEPTH LITERALLY '31',\n        BB_FLAG BIT(1),   /* SIGNALS START OF BASIC BLOCK */\n        (SUMMARY_BLOCKS, BASIC_BLOCKS) FIXED,\n        SUMMARY(7199) BIT(8);\n\n /******************************************************************************\n*                                                                              *\n*                                                                              *\n*        THE FOLLOWING DECLARATIONS ARE FOR GLOBAL VARIABLES WHICH ARE         *\n*        REQUIRED FOR THE DGNS MODULE.(SEE SPECS. AND DOCUMENTATION.)          *\n*        WHICH ARE NOT OF OUTSIDE INTEREST(I.E. THEY ARE OWN VARIABLES)        *\n*                                                                              *\n*                                                                              *\n*******************************************************************************/\nDECLARE DGNS#_STR CHARACTER,\n        (DGNS#_INCR, DGNS#_DECR, DGNS#_PTR, DGNS#_GOTO,\n        DGNS#_PROC, DGNS#_TOP2, IN_PROC_FLAG) BIT(1),\n        DGNS#_TOP1 BIT(8),\n        (DGNS#_LINE_NO, DGNS#_LAST_TOKEN, DGNS#_POS, DGNS#_INDEX,\n        DGNS#_DEPTH) FIXED,\n        DGNS#_IS_PROC_HEADING BIT(1), DGNS#_PAREN_COUNT FIXED,\n        DGNS#_STACK1(MAX_DEPTH) BIT(8),\n        DGNS#_STACK2(MAX_DEPTH) BIT(1);\n\nDGNS#_INITIALIZE:\n   PROCEDURE;\n      SUMMARY_BLOCKS, BASIC_BLOCKS = 0;\n      DGNS#_DEPTH = -1;\n      DGNS#_INCR, DGNS#_DECR, DGNS#_PTR, IN_PROC_FLAG = FALSE;\n      DGNS#_GOTO, DGNS#_PROC, DGNS#_TOP2 = FALSE;\n      DGNS#_TOP1, DGNS#_LINE_NO, DGNS#_INDEX = 0;\n      DGNS#_POS = 1;\n   END DGNS#_INITIALIZE;\n\nDGNS#_BLANK:\n   PROCEDURE CHARACTER;\n\n   IS_ALPHANUMERIC:\n      PROCEDURE(M) BIT(1);\n         DECLARE M FIXED;\n         DECLARE ALPHANUMERIC BIT(63) INITIAL(\"(1) 0 00000 00000 00001 11000\n            10000 11011 11111 11111 11111 11111 11111 11011 11\");\n         RETURN (SHL(BYTE(ALPHANUMERIC,SHR(M,3)),M & \"07\") & \"80\") \u00ac= 0;\n      END IS_ALPHANUMERIC;\n\n   IS_OPERATOR:\n      PROCEDURE(N) BIT(1);\n         DECLARE N FIXED;\n         DECLARE OPERATOR BIT(63) INITIAL(\"(1) 0 00011 00011 11001 11100 10111\n            11000 00000 00011 00100 00100 01000 00000 00\");\n         RETURN (SHL(BYTE(OPERATOR,SHR(N,3)),N & \"07\") & \"80\") \u00ac= 0;\n      END IS_OPERATOR;\n\n      IF IS_OPERATOR(DGNS#_LAST_TOKEN) | IS_OPERATOR(TOKEN) |\n         (DGNS#_LAST_TOKEN = 2) /* SEMICOLON */ THEN RETURN X1;\n      IF IS_ALPHANUMERIC(DGNS#_LAST_TOKEN) THEN IF IS_ALPHANUMERIC(TOKEN) THEN\n         RETURN X1;\n      RETURN '';\n   END DGNS#_BLANK;\n\n /******************************************************************************\n*                                                                              *\n*         PROCEDURE DGNS#_CONVERT                                              *\n*                  THIS PROCEDURE COMPLETES THE INTERFACE TO THE SCANNER TO    *\n*                  HANDLE THE CASE OF STRINGS WHERE QUOTES MUST BE REINSERTED  *\n*                                                                              *\n*******************************************************************************/\nDGNS#_CONVERT: PROCEDURE(STRING_VALUE) CHARACTER;\n     DECLARE STRING_VALUE CHARACTER;\n     DECLARE I FIXED,TEMP CHARACTER;\n     TEMP='''';\n     DO I=0 TO LENGTH(STRING_VALUE) - 1;\n          IF SUBSTR(STRING_VALUE,I,1)='''' THEN TEMP=TEMP||'''''';\n          ELSE TEMP=TEMP||SUBSTR(STRING_VALUE,I,1);\n     END;\n     RETURN(TEMP||'''');\nEND DGNS#_CONVERT;\n\n /******************************************************************************\n*                                                                              *\n*        PROCEDURE NEW_BLOCK                                                   *\n*                       THIS PROCEDURE DUMPS THE CURRENT SUMMARY BLOCK         *\n*                       TO THE FILE NUMBER DECLARED FILE_NO & RESETS DGNS#_POS *\n*                                                                              *\n*******************************************************************************/\nDGNS#_NEW_BLOCK: PROCEDURE;\n     /* SEE IF SUMMARY FULL IF NOT INSERT ZERO LENGTH FIELD    */\n     IF DGNS#_POS<7199 THEN SUMMARY(DGNS#_POS+1)=0;\n     FILE(DGNS#_FILE_NO, SUMMARY_BLOCKS) = SUMMARY;   /* OUTPUT THE BLOCK */\n     SUMMARY_BLOCKS=SUMMARY_BLOCKS+1; /* INCREMENT SUMMARY BLOCK COUNT   */\n     DGNS#_POS = 1;   /* RESET POSITION POINTER */\n     SUMMARY(0) = 0;   /* ASSUME LAST SUMMARY BLOCK */\nEND DGNS#_NEW_BLOCK;\n\n /******************************************************************************\n*                                                                              *\n*        PROCEDURE SYM                                                         *\n*                       PUT THE STRING DGNS#_STR INTO THE SUMMARY BLOCK AS     *\n*                       ONE SUMMARY LINE OF OUTPUT                             *\n*                                                                              *\n*******************************************************************************/\nDGNS#_SYM: PROCEDURE;\n     DECLARE I FIXED;\n     DECLARE STRING_LENGTH FIXED INITIAL (0);\n     STRING_LENGTH=LENGTH(DGNS#_STR);\n     IF STRING_LENGTH=0 THEN RETURN;\n     IF SUBSTR(DGNS#_STR,0,1)= X1 THEN DO;\n          DGNS#_STR=SUBSTR(DGNS#_STR,1);\n          STRING_LENGTH=STRING_LENGTH-1;\n     IF STRING_LENGTH=0 THEN RETURN;\n     END;\n     /* IF FULL THEN CALL NEW_BLOCK     */\n     IF (DGNS#_POS + STRING_LENGTH + 6) > 7199 THEN\n         DO;\n            SUMMARY(0) = 1;   /* NOT LAST SUMMARY BLOCK */\n            CALL DGNS#_NEW_BLOCK;\n         END;\n     SUMMARY(DGNS#_POS)=DGNS#_INDEX; /*   INSERT LINE INDENTING   */\n     SUMMARY(DGNS#_POS+1)=STRING_LENGTH; /* INSERT THE LINELENGTH     */\n     SUMMARY(DGNS#_POS+2) = SHR(DGNS#_LINE_NO,8);\n     SUMMARY(DGNS#_POS+3) = DGNS#_LINE_NO;\n     IF BB_FLAG THEN\n         DO;\n            SUMMARY(DGNS#_POS + 4) = SHR(BASIC_BLOCKS, 8);\n            SUMMARY(DGNS#_POS + 5) = BASIC_BLOCKS;\n            BASIC_BLOCKS = BASIC_BLOCKS + 1;\n            BB_FLAG = FALSE;\n         END;\n     ELSE SUMMARY(DGNS#_POS + 4), SUMMARY(DGNS#_POS + 5) = NULL;\n     DO I=0 TO STRING_LENGTH-1;\n          SUMMARY(DGNS#_POS+I+6)=BYTE(DGNS#_STR,I);  /*  INSERT THE CHARACTERS*/\n     END;\n     /*    UPDATE THE POSITION POINTER AND RESET DGNS#_STR TO EMPTY    */\n     DGNS#_POS=DGNS#_POS+STRING_LENGTH+6;\n     DGNS#_STR='';\n   END DGNS#_SYM;\n\n /******************************************************************************\n*                                                                              *\n*        PROCEDURE CHANGE                                                      *\n*                       THIS PROCEDURE IMPLEMENTS THE INDENTING & DEDENTING    *\n*                                                                              *\n*******************************************************************************/\nDGNS#_CHANGE:PROCEDURE(PARM);\n     /*  PARM DENOTED INDENT OR DEDENT      */\n     DECLARE PARM BIT(1);\n     DECLARE INDEX_INC FIXED INITIAL(3);\n     IF PARM THEN DO;\n          DGNS#_INCR=\"0\";\n          DGNS#_INDEX = DGNS#_INDEX + INDEX_INC;\n     END;\n     ELSE DO;\n          DGNS#_DECR=\"0\";\n          DGNS#_INDEX = DGNS#_INDEX - INDEX_INC;\n     END;\nEND DGNS#_CHANGE;\n\n /******************************************************************************\n*                                                                              *\n*        PROCEDURE NEW_LINE                                                    *\n*                       THIS PROCEDURE CHECKS WHEN THE PROGRAMMER STARTS A NEW *\n*                       LINE(CARD) AND DOES THE SAME IN SUMMARY                *\n*                                                                              *\n*******************************************************************************/\nDGNS#_NEW_LINE:PROCEDURE;\n     DECLARE TEMP FIXED;\n     DECLARE TEMP_STRING CHARACTER;\n     IF LENGTH(BUFFER) = LENGTH(TEXT) - CP THEN TEMP = CARD_COUNT - 1;\n          ELSE TEMP = CARD_COUNT;\n     TEMP_STRING = DGNS#_BLANK;\n     /* IF NOT A NEW LINE THEN CONCATENATE SYMBOL                          */\n     IF DGNS#_LINE_NO = TEMP THEN\n          DGNS#_STR = DGNS#_STR || TEMP_STRING || STRING_VALUE;\n     ELSE DO;\n          IF DGNS#_DECR THEN CALL DGNS#_CHANGE(\"0\");\n          /*   OTHERWISE START A NEW LINE      */\n          IF DGNS#_STR \u00ac= '' THEN CALL DGNS#_SYM;\n          DGNS#_LINE_NO=CARD_COUNT;\n          DGNS#_STR=STRING_VALUE;\n     END;\nEND DGNS#_NEW_LINE;\n\n /******************************************************************************\n*                                                                              *\n*        PROCEDURE STACK                                                       *\n*                       MANAGES A STACK OF 2 THINGS ONE BIT(8) THE OTHER       *\n*                       BIT(1) HANDLES POP,PUSH,OVERFLOW,UNDERFLOW             *\n*                                                                              *\n*******************************************************************************/\n DGNS#_STACK:PROCEDURE (ELEMENT);\n      DECLARE ELEMENT BIT(8) INITIAL(0);\n     /*  CHECK FOR OVERFLOW THEN UNDERFLOW      */\n     IF (DGNS#_DEPTH=MAX_DEPTH+1)&(ELEMENT\u00ac=0)THEN DO; /* STACK OVERFLOW   */\n          CALL ERROR('COMPILER ERROR - DGNS STACK OVERFLOW', 0);\n          RETURN;\n     END;\n     ELSE IF (DGNS#_DEPTH=-1)&(ELEMENT=0) THEN DO;\n          DGNS#_DEPTH=-2;\n          RETURN ;\n     END;\n               /*   PROCESS POP OPERATION      */\n             IF ELEMENT=0 THEN DO;\n             POP:DGNS#_DEPTH=DGNS#_DEPTH-1;\n                 DGNS#_TOP1=DGNS#_STACK1(DGNS#_DEPTH);\n                 DGNS#_TOP2 = DGNS#_TOP2 | DGNS#_STACK2(DGNS#_DEPTH);\n                 DGNS#_STACK2(DGNS#_DEPTH)=DGNS#_TOP2;\n                  END;\n        ELSE DO;\n               /*   PROCESS THE PUSH OPERATION      */\n             PUSH:DGNS#_DEPTH=DGNS#_DEPTH+1;\n             DGNS#_TOP1,DGNS#_STACK1(DGNS#_DEPTH)=ELEMENT;\n             DGNS#_TOP2,DGNS#_STACK2(DGNS#_DEPTH)=0;\n          DGNS#_GOTO = FALSE;\n       END;\n  END DGNS#_STACK;\n\n /******************************************************************************\n*                                                                              *\n*        PROCEDURE SET_PTR                                                     *\n*                       THIS PROCEDURE SETS THE BASIC BLOCK POINTERS           *\n*                       AND CALL SYM TO DUMP THE LINE FOR THE BASIC BLOCK      *\n*                                                                              *\n*******************************************************************************/\nDGNS#_SET_PTR:PROCEDURE;\n     DGNS#_PTR = FALSE;\n     CALL DGNS#_SYM;\n          /*  INCREMENT THE BASIC BLOCK COUNT AND SET THE BASIC BLOCK FLAG */\n     BB_FLAG = TRUE;\nEND DGNS#_SET_PTR;\n\n /******************************************************************************\n*                                                                              *\n*        PROCEDURE PARAGRAPH                                                   *\n*        MAIN PROCEDURE OF THE DGNS MODULE                                     *\n*                       THIS PROCEDURE EXAMINES TOKENS, LOOKING FOR BASIC      *\n*                       BLOCKS AND THEIR ENDINGS AND HANDLES THE INCR DECR     *\n*                       AND POINTER SETTING FLAGS                              *\n*                                                                              *\n*******************************************************************************/\nPARAGRAPH:PROCEDURE;\n     /* THE FOLLOWING ARE THE DECLARATIONS FOR THE TOKEN VALUES WHICH SHOULD\n        ADJUSTED TO ADHERE TO THOSE OF THE SCANNER BEING USED         */\nDECLARE UNTIL$               FIXED INITIAL(49),\n        REPEAT$              FIXED INITIAL(51),\n        ID$                  FIXED INITIAL(60),\n        BEGIN$               FIXED INITIAL(45),\n        ELSE$                FIXED INITIAL(43),\n        GOTO$                FIXED INITIAL(42),\n        THEN$                FIXED INITIAL(39),\n        END$                 FIXED INITIAL(29),\n        EOP$                 FIXED INITIAL(28),\n        COLON$               FIXED INITIAL(05),\n        ASSIGN$              FIXED INITIAL(18),\n        DO$                  FIXED INITIAL(17),\n        OF$                  FIXED INITIAL(16),\n        PROCEDURE$           FIXED INITIAL(59),\n        FUNCTION$            FIXED INITIAL(57),\n        SEMICOLON$           FIXED INITIAL(02);\n     /*   LOCAL VARIABLE DECLARATIONS     */\n     DECLARE INDEX_INC FIXED INITIAL(3);\n     DECLARE TEMP_INDEX FIXED;\n     DECLARE FLAG BIT(1);\n     DECLARE STR_LENGTH FIXED;\n     DECLARE TEMP CHARACTER;\n     DECLARE CH BIT(8);\n\n     POP$: PROCEDURE BIT(8);\n          IF (DGNS#_TOP1=THEN$) | (DGNS#_TOP1=ELSE$) | (DGNS#_TOP1=DO$) THEN\n               RETURN (DGNS#_TOP1);\n          ELSE RETURN(0);\n     END POP$;\n\n     /* CHECK FOR FATAL ERROR PREVIOUSLY  */\n     IF DGNS#_DEPTH<-1 THEN RETURN;\n     IF TOKEN = STRING THEN STRING_VALUE = DGNS#_CONVERT(BCD);\n     ELSE IF (TOKEN=IDENT) | (TOKEN=INTCONST) | (TOKEN = REALCONST) THEN\n          STRING_VALUE = BCD;\n     ELSE STRING_VALUE = V(TOKEN);\n     /* TEST FOR END OF PROGRAM   IF SO THEN OUTPUT SUMMARY */\n     IF TOKEN=EOP$ THEN DO;\n          DGNS#_INDEX = 0;\n          CALL DGNS#_SYM;\n          CALL DGNS#_NEW_BLOCK;\n          RETURN;\n     END;\n     IF (TOKEN=PROCEDURE$) | (TOKEN=FUNCTION$) THEN DO;\n         IF \u00acDGNS#_IS_PROC_HEADING THEN\n            DO;\n               IF DGNS#_DECR THEN CALL DGNS#_CHANGE(FALSE);\n               DGNS#_IS_PROC_HEADING = TRUE;\n               DGNS#_PAREN_COUNT = 0;\n               CALL DGNS#_SYM;\n               IN_PROC_FLAG = TRUE;\n               DGNS#_STR = '  ';\n               CALL DGNS#_SYM;\n            END;\n     END;\n     /* IF NOT IN STATEMENT BLOCK YET AND TOKEN IS NOT A BEGIN\n       THEN RETURN  AND WAIT FOR BEGIN */\n     IF (DGNS#_DEPTH=-1) & (TOKEN\u00ac=BEGIN$) THEN DO;\n          IF DGNS#_IS_PROC_HEADING THEN\n            DO;\n               IF TOKEN = LPARENT THEN\n                  DGNS#_PAREN_COUNT = DGNS#_PAREN_COUNT + 1;\n               ELSE IF TOKEN = RPARENT THEN\n                  DGNS#_PAREN_COUNT = DGNS#_PAREN_COUNT - 1;\n               ELSE IF TOKEN = SEMICOLON$ THEN\n                  DGNS#_IS_PROC_HEADING = (DGNS#_PAREN_COUNT > 0);\n            END;\n          CALL DGNS#_NEW_LINE;\n          RETURN;\n     END;\n     /*   IF FLAG FOR POINTER SETTING IS ON THEN CALL ROUTINE   */\n     IF DGNS#_PTR THEN CALL DGNS#_SET_PTR;\n     /* TEST IF WE SHOULD INCREMENT OR DECREMENT AND CALL ROUTINE */\n     IF DGNS#_DECR THEN CALL DGNS#_CHANGE(\"0\");\n     IF DGNS#_INCR THEN CALL DGNS#_CHANGE(\"1\");\n     IF DGNS#_LAST_TOKEN = ELSE$ THEN DGNS#_INDEX = DGNS#_INDEX + INDEX_INC;\n     /* TEST FOR TOKEN BEING A BEGIN OR REPEAT  OR CASE  */\n     IF (TOKEN=BEGIN$)|(TOKEN=REPEAT$)|(TOKEN=OF$) THEN DO;\n          IF (DGNS#_DEPTH=-1)&(\u00acIN_PROC_FLAG) THEN DO;\n               CALL DGNS#_SYM;\n               DGNS#_STR = '  ';\n               CALL DGNS#_SYM;\n          END;\n          DGNS#_INCR=\"1\";  /* SET INDEX FLAG */\n          /*  IF THE STATEMENT IS NOT A CASE THEN SET BASIC BLOCK FLAG  */\n          IF TOKEN\u00ac=OF$ THEN DGNS#_PTR=\"1\";\n          ELSE DO;\n               DGNS#_STR=DGNS#_STR||X1||V(TOKEN);\n               CALL DGNS#_SYM;\n               STRING_VALUE='';\n          END;\n          DGNS#_PROC=\"1\";     /*  POSSIBLE PROC CALL TO FOLLOW   */\n          CALL DGNS#_STACK(TOKEN); /* STACK THE TOKEN TO POP LATER */\n     END;\n     /* PROCESS THE END OF A BLOCK IF NESTING IS MULTIPLE DEPTHS THEN  CONTINUE\n       REMOVING LEVELS */\n     ELSE IF (TOKEN=END$)|(TOKEN=UNTIL$) THEN DO; /* PROCESS END OF BLOCK  */\n          TEMP_INDEX=DGNS#_INDEX;\n          DO WHILE ((DGNS#_TOP1\u00ac=BEGIN$)&(DGNS#_TOP1\u00ac=REPEAT$)&(DGNS#_TOP1\u00ac=OF$)\n            ); /*    POP THE STACK TILL WE FIND MATCHING  BEGINNING TOKEN */\n               IF DGNS#_DEPTH<-1 THEN RETURN;   /* CHECK FOR UNDERFLOW   */\n               CALL DGNS#_STACK(0);   /*    POP    */\n               TEMP_INDEX=TEMP_INDEX-INDEX_INC;\n          END;\n         IF DGNS#_TOP1 = OF$ THEN BB_FLAG = FALSE;\n          DGNS#_DECR=\"1\";       /* SET UN INDENT FLAG   */\n          /* IF A PROC CALL LOOKS LIKE A GOTO   */\n          IF DGNS#_PROC=2 THEN DGNS#_GOTO=\"1\";\n          IF DGNS#_GOTO THEN DO;\n               /*   A GOTO SET TOP OF STACK2, SET POINTER AND RESET FLAG  */\n               DGNS#_TOP2=\"1\";\n               DGNS#_STACK2(DGNS#_DEPTH)=\"1\";\n          END;\n          /*  NO PROC CALL   */\n          DGNS#_PROC=0;\n          CALL DGNS#_STACK(0);   /*   POP THE BEGINNING TOKEN   */\n          IF DGNS#_DEPTH=-1 THEN IN_PROC_FLAG=\"0\";\n          CALL DGNS#_SYM;\n          DGNS#_GOTO = DGNS#_TOP2 & (DGNS#_TOP1 \u00ac= OF$);\n          DGNS#_INDEX=TEMP_INDEX;\n     END;\n     ELSE IF (TOKEN=SEMICOLON$) THEN DO;\n          IF DGNS#_PROC=2 THEN DO;      /*   CHECK FOR PROC CALL    */\n               DGNS#_GOTO=\"1\";       /* SET GOTO FLAG    */\n          END;\n          IF DGNS#_GOTO THEN DO;       /* PROCESS AN INTERIOR GOTO   */\n                DGNS#_PTR=\"1\";       /* SET POINTER   */\n               DGNS#_TOP2=\"1\";     /* SET INTERIOR GOTO FOR SURROUNDING BLOCK */\n               DGNS#_STACK2(DGNS#_DEPTH)=\"1\";\n               DGNS#_GOTO=\"0\";        /* RESET FLAG   */\n               IF DGNS#_TOP2 THEN DGNS#_PTR=\"1\"; /* INTERIOR GOTO */\n          END;\n          DGNS#_PROC=1;        /* POSSIBLE PROC CALL TO FOLLOW     */\n          IF DGNS#_TOP1=POP$ THEN DO;      /*  CHECK IF POP */\n               DGNS#_STR=DGNS#_STR||V(TOKEN);  /* PUT SEMICOLON ON LINE */\n               CALL DGNS#_SYM;           /* DUMP LINE   */\n               STRING_VALUE='';\n               DGNS#_STR='';         /*   EMPTY STRING    */\n               IF DGNS#_TOP2 THEN DGNS#_PTR=\"1\"; /* INTERIOR GOTO */\n          END;\n          DO WHILE (DGNS#_TOP1=POP$);     /*  POP ALL NESTINGS WHICH END HERE */\n               IF DGNS#_DEPTH<-1 THEN RETURN;     /* STACK UNDERFLOW   */\n               CALL DGNS#_STACK(0);   /*    P O P       */\n               IF DGNS#_DECR THEN  DGNS#_INDEX=DGNS#_INDEX-3;      /* UNINDENT*/\n               ELSE DGNS#_DECR=\"1\";\n          END;\n     END;\n     /* THE TOKENS DO, THEN, ELSE START BASIC BLOCKS;  PROCESS THEM   */\n     ELSE IF(TOKEN=DO$)|(TOKEN=THEN$)|(TOKEN=ELSE$) THEN DO;\n          /*   INDENT FLAG,POINTER FLAG, PROC CALL START    */\n          IF TOKEN\u00ac=ELSE$ THEN DO;\n               DGNS#_INCR=\"1\";\n          /*   PUSH THE TOKEN TO POP SOON   */\n               CALL DGNS#_STACK(TOKEN);\n          END;\n          ELSE DO;\n               CALL DGNS#_SYM;\n               IF DGNS#_PROC = 2 THEN DGNS#_TOP2, DGNS#_STACK2(DGNS#_DEPTH) = 1;\n               DO WHILE DGNS#_TOP1 \u00ac= THEN$;\n                    IF DGNS#_DEPTH < -1 THEN RETURN;\n                    DGNS#_INDEX = DGNS#_INDEX - INDEX_INC;\n                    CALL DGNS#_STACK(0);\n               END;\n               DGNS#_INDEX = DGNS#_INDEX - INDEX_INC;\n          END;\n          DGNS#_PTR=\"1\";\n          DGNS#_PROC=1;\n     END;\n     /*   PROCESS THE COLON WHICH INDICATES A LABEL  */\n     ELSE IF TOKEN=COLON$ THEN DO;\n          DGNS#_PROC=1;\n          TEMP='';\n          IF LENGTH(DGNS#_STR)>=1 THEN DO;   /* POSSIBLE LABEL HERE    */\n          /* NOT IN A CASE STATEMENT  */\n          IF DGNS#_TOP1\u00ac=OF$ THEN DO;\n          /*  ONLY ONE LABEL. BACKUP TO BLANK OR START OF STRING TO GET IT   */\n               STR_LENGTH = LENGTH(DGNS#_STR) -1;\n               CH = BYTE(DGNS#_STR, STR_LENGTH);\n               DO WHILE ((CH < BYTE('0')) | (CH > BYTE('9'))) & (STR_LENGTH>0);\n                    STR_LENGTH = STR_LENGTH - 1;\n                    CH = BYTE(DGNS#_STR, STR_LENGTH);\n               END;\n               DO WHILE ((CH >= BYTE('0')) & (CH <= BYTE('9')))\n                        & (STR_LENGTH > 0);\n                    STR_LENGTH = STR_LENGTH - 1;\n                    CH = BYTE(DGNS#_STR, STR_LENGTH);\n               END;\n          END;\n          ELSE DO;  /* IN A CASE MUST BACKUP FOR PREVIOUS LABELS */\n               STR_LENGTH=LENGTH(DGNS#_STR)-1;\n               FLAG=\"1\";\n               /*   MULTIPLE LABELS MUST FIND TOKEN THAT CANNOT APPEAR OR END */\n               DO WHILE  (FLAG);\n                   /*   A SEMICOLON IS NOT IN LABEL STOP LOOKING  */\n                    DO WHILE (BYTE(DGNS#_STR, STR_LENGTH) = BYTE(''''))\n                             & (STR_LENGTH > 0);\n                         STR_LENGTH = STR_LENGTH - 1;\n                         DO WHILE (BYTE(DGNS#_STR,STR_LENGTH) \u00ac= BYTE(''''))\n                                  & (STR_LENGTH > 0);\n                              STR_LENGTH = STR_LENGTH - 1;\n                         END;\n                         IF STR_LENGTH > 0 THEN STR_LENGTH = STR_LENGTH - 1;\n                    END;\n                    IF SUBSTR(DGNS#_STR,STR_LENGTH,1)=';' THEN DO;\n                         FLAG=\"0\";\n                         STR_LENGTH=STR_LENGTH+1;\n                    END;\n                    /*  END OF STRING?..THEN STOP LOOKING   */\n                    ELSE IF STR_LENGTH=0 THEN FLAG=\"0\";\n                    /*   PERHAPS A OF FROM CASE INDICATES END OF LABELS */\n                    /*   IF MORE THEN KEEP BACKING UP   */\n                       ELSE STR_LENGTH=STR_LENGTH-1;\n               END;\n          END;\n          /* NOW SET TEMP TO THAT PART OF THE LINE STARTING WITH THE FIRST\n             LABEL, AND DGNS#_STR TO THE PART PRECEDING THAT.   */\n          IF STR_LENGTH = 0 THEN DO;\n               TEMP = DGNS#_STR;\n               DGNS#_STR = '';\n          END;\n          ELSE DO;\n               TEMP = SUBSTR(DGNS#_STR, STR_LENGTH);\n               DGNS#_STR = SUBSTR(DGNS#_STR, 0, STR_LENGTH);\n          END;\n\n\n          END;\n               /*   SET THE POINTER AND RETURN THE STRING FROM TEMP   */\n               CALL DGNS#_SET_PTR;\n               DGNS#_STR = TEMP;\n     END;\n     ELSE IF TOKEN=GOTO$ THEN DGNS#_GOTO=\"1\";\n     ELSE IF TOKEN=ASSIGN$ THEN DGNS#_PROC=0;    /* CAN NOT BE PROC CALL */\n     ELSE IF (TOKEN=ID$)&(DGNS#_PROC=1) THEN DGNS#_PROC=2;   /* MAY BE PROC CA*/\n     CALL DGNS#_NEW_LINE;\nEND PARAGRAPH;\n\n\n\n\n  /*                   CARD IMAGE HANDLING PROCEDURE                      */\n\n\nGET_CARD:\n   PROCEDURE;\n      /* DOES ALL CARD READING AND LISTING                                 */\n      DECLARE I FIXED, (TEMP, TEMP0, REST) CHARACTER, READING BIT(1);\n            BUFFER = INPUT;\n            IF LENGTH(BUFFER) = 0 THEN\n               DO; /* SIGNAL FOR EOF */\n                  TEXT = V(EOFILE) || X1 || V(EOFILE) || X1 || V(EOFILE) || X1\n                         || V(EOFILE) || X1 || V(EOFILE) || X1;\n                  BATCHING = FALSE;\n               END;\n      ELSE DO;   CARD_COUNT = CARD_COUNT + 1;  /* USED TO PRINT ON LISTING */\n      IF MARGIN_CHOP > 0 THEN\n         DO; /* THE MARGIN CONTROL FROM DOLLAR | */\n            I = LENGTH(BUFFER) - MARGIN_CHOP;\n            REST = SUBSTR(BUFFER, I);\n            BUFFER = SUBSTR(BUFFER, 0, I);\n         END;\n      ELSE REST = '';\n      TEXT = BUFFER;\n      IF CONTROL(BYTE('M')) THEN OUTPUT = BUFFER;\n      ELSE IF CONTROL(BYTE('L')) THEN\n         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|' || REST;\n      END;\n      TEXT_LIMIT = LENGTH(TEXT) - 1;\n      CP = 0;\n   END GET_CARD;\n\n\n   /*                THE SCANNER PROCEDURES              */\n\n\n   /*              A FINITE MACHINE MOANED \"OH, WHY\n                   CAN I ADD BUT NOT MULTIPLY?\"\n                   \"BECOME MORE COMPLEX,\n                   OR DISCOVER SEX\n                   AND DO IT,\" SAID THE RABBIT, \"LIKE I.\"\n\n                         -- PETER KUGEL             */\n\n\nCHAR:\n   PROCEDURE;\n      /* USED FOR STRINGS TO AVOID CARD BOUNDARY PROBLEMS */\n      CP = CP + 1;\n      IF CP <= TEXT_LIMIT THEN RETURN;\n      CALL GET_CARD;\n   END CHAR;\n\n\nTENINTO:\n   PROCEDURE(N) FIXED;\n      DECLARE(N,I) FIXED;\n      I = 0;\n      DO WHILE N > 0;\n         N = N / 10;\n         I = I + 1;\n      END;\n      RETURN(I);\n   END TENINTO;\n\nFLOAT:\n   PROCEDURE (N, RETURN_LOC);\n      DECLARE N FIXED, RETURN_LOC @REAL;\n      DECLARE ZERO(4) REAL INITIAL(0,0,0,0,0), OFFSET FIXED, WORK(4) REAL;\n      /* NOTE THAT IF ZERO IS DOUBLE-WORD ALLIGNED THEN SO IS WORK */\n      WORK(0), WORK(3) = \"4E000000\";\n      WORK(1), WORK(4) = N;\n      IF (ADDR(WORK) & \"FFFFFFF8\") = ADDR(WORK) THEN\n         OFFSET = 0;   /* DOUBLE-WORD ALLIGNED */\n      ELSE OFFSET = 12;   /* \u00acDOUBLE-WORD ALLIGNED */\n      CALL INLINE(\"58\",1,0,RETURN_LOC);          /* L    1,RETURN_LOC      */\n      CALL INLINE(\"58\",2,0,OFFSET);              /* L    2,OFFSET          */\n      CALL INLINE(\"41\",3,2,WORK);                /* LA   3,WORK(2)         */\n      CALL INLINE(\"68\",0,2,WORK);                /* LD   0,WORK(2)         */\n      CALL INLINE(\"6A\",0,2,ZERO);                /* AD   0,ZERO(2)         */\n      CALL INLINE(\"60\",0,2,WORK);                /* STD  0,WORK(2)         */\n      CALL INLINE(\"D2\",0,7,1,0,3,0);             /* MVC  0(8,1),0(3)       */\n   END FLOAT;\n\n\nREAL_ADD:\n   PROCEDURE (X, Y, RETURN_LOC);\n      DECLARE (X, Y, RETURN_LOC) @REAL, WORK(4) REAL, (OFFSET, I) FIXED;\n      IF (ADDR(WORK) & \"FFFFFFF8\") = ADDR(WORK) THEN\n         OFFSET = 0;   /* DOUBLE-WORD ALLIGNED */\n      ELSE OFFSET = 12;   /* \u00acDOUBLE-WORD ALLIGNED */\n      I = COREWORD(SHR(X, 2));\n      WORK(0), WORK(3) = I;\n      I = COREWORD(SHR(X, 2) + 1);\n      WORK(1), WORK(4) = I;\n      CALL INLINE(\"58\",2,0,OFFSET);              /* L    2,OFFSET          */\n      CALL INLINE(\"68\",0,2,WORK);                /* LD   0,WORK(2)         */\n      I = COREWORD(SHR(Y, 2));\n      WORK(0), WORK(3) = I;\n      I = COREWORD(SHR(Y, 2) + 1);\n      WORK(1), WORK(4) = I;\n      CALL INLINE(\"58\",1,0,RETURN_LOC);          /* L    1,RETURN_LOC      */\n      CALL INLINE(\"58\",2,0,OFFSET);              /* L    2,OFFSET          */\n      CALL INLINE(\"41\",3,2,WORK);                /* LA   3,WORK(2)         */\n      CALL INLINE(\"6A\",0,2,WORK);                /* AD   0,WORK(2)         */\n      CALL INLINE(\"60\",0,2,WORK);                /* STD  0,WORK(2)         */\n      CALL INLINE(\"D2\",0,7,1,0,3,0);             /* MVC  0(8,1),0(3)       */\n   END REAL_ADD;\n\n\nREAL_MULTIPLY:\n   PROCEDURE (X, Y, RETURN_LOC);\n      DECLARE (X, Y, RETURN_LOC) @REAL, WORK(4) REAL, (OFFSET, I) FIXED;\n      IF (ADDR(WORK) & \"FFFFFFF8\") = ADDR(WORK) THEN\n         OFFSET = 0;   /* DOUBLE-WORD ALLIGNED */\n      ELSE OFFSET = 12;   /* \u00acDOUBLE-WORD ALLIGNED */\n      I = COREWORD(SHR(X, 2));\n      WORK(0), WORK(3) = I;\n      I = COREWORD(SHR(X, 2) + 1);\n      WORK(1), WORK(4) = I;\n      CALL INLINE(\"58\",2,0,OFFSET);              /* L    2,OFFSET          */\n      CALL INLINE(\"68\",0,2,WORK);                /* LD   0,WORK(2)         */\n      I = COREWORD(SHR(Y, 2));\n      WORK(0), WORK(3) = I;\n      I = COREWORD(SHR(Y, 2) + 1);\n      WORK(1), WORK(4) = I;\n      CALL INLINE(\"58\",1,0,RETURN_LOC);          /* L    1,RETURN_LOC      */\n      CALL INLINE(\"58\",2,0,OFFSET);              /* L    2,OFFSET          */\n      CALL INLINE(\"41\",3,2,WORK);                /* LA   3,WORK(2)         */\n      CALL INLINE(\"6C\",0,2,WORK);                /* MD   0,WORK(2)         */\n      CALL INLINE(\"60\",0,2,WORK);                /* STD  0,WORK(2)         */\n      CALL INLINE(\"D2\",0,7,1,0,3,0);             /* MVC  0(8,1),0(3)       */\n   END REAL_MULTIPLY;\n\n\nSCAN:\n   PROCEDURE;\n      DECLARE (S1, S2) FIXED;\n      DECLARE MAX10 LITERALLY '214748364'; /* (2**31-1)/10 */\n      DECLARE (SCALE,EXPONENT) FIXED, X(1) REAL,\n         (ERROR_SW, SIGN) BIT(1),\n         MAX_MANTISSA REAL INITIAL(\"40B9446F\"),\n         MIN_MANTISSA REAL INITIAL(\"408A2DC0\");\n      DECLARE ST CHARACTER;\n      DECLARE LSTRNGM CHARACTER INITIAL('STRING TOO LONG');\n\n   SCAN_FINDS_END_OF:\n      PROCEDURE (TABLE) BIT(1);\n         DECLARE TABLE FIXED;\n         DECLARE TRT(2) BIT(16) INITIAL(\"DD00\", \"3000\", \"1000\");\n\n         /* THIS PROCEDURE ASSUMES CP = 0 WHEN IT IS CALLED */\n         CALL INLINE(\"58\",3,0,TEXT);             /* L    3,TEXT            */\n         CALL INLINE(\"17\",2,2);                  /* XR   2,2               */\n         CALL INLINE(\"19\",3,2);                  /* CR   3,2               */\n         CALL INLINE(\"07\",8,12);                 /* BER  12                */\n         CALL INLINE(\"8D\",2,0,0,8);              /* SLDL 2,8               */\n         CALL INLINE(\"88\",3,0,0,8);              /* SRL  3,8               */\n         CALL INLINE(\"58\",1,0,TABLE);            /* L    1,TABLE           */\n         CALL INLINE(\"44\",2,0,TRT);              /* EX   2,TRT             */\n         CALL INLINE(\"05\",12,0);                 /* BALR 12,0              */\n         CALL INLINE(\"47\",7,0,12,16);            /* BNZ  *+16              */\n         CALL INLINE(\"18\",1,2);                  /* LR   1,2               */\n         CALL INLINE(\"41\",1,0,1,1);              /* LA   1,1(,1)           */\n         CALL INLINE(\"17\",3,3);                  /* XR   3,3               */\n         CALL INLINE(\"47\",15,0,12,22);           /* B    *+10              */\n         CALL INLINE(\"1B\",1,3);                  /* SR   1,3               */\n         CALL INLINE(\"41\",3,0,0,1);              /* LA   3,1               */\n         CALL INLINE(\"50\",1,0,CP);               /* ST   1,CP              */\n      END SCAN_FINDS_END_OF;\n\n      SKIP_TO_END_OF_COMMENT: PROCEDURE(ENDC);\n         DECLARE ENDC BIT(8);\n            DO WHILE BYTE(TEXT, CP) \u00ac= ENDC;\n               TEXT = SUBSTR(TEXT, CP);\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               DO WHILE \u00acSCAN_FINDS_END_OF (ADDR(COMMENTTABLE));\n                  CALL GET_CARD;\n               END;\n               IF BYTE(TEXT, CP) = BYTE('$') THEN\n                  DO;  /* A CONTROL CHARACTER */\n                     CALL CHAR;\n                     S2 = BYTE(TEXT, CP);\n                     CONTROL(S2) = \u00ac CONTROL(S2);\n                     IF S2 = BYTE('|') THEN\n                        DO;\n                           IF CONTROL(S2) THEN\n                              MARGIN_CHOP = TEXT_LIMIT - CP + 1;\n                           ELSE\n                              MARGIN_CHOP = 0;\n                        END;\n                  END;\n               /* ELSE FOUND AN ASTERISK */\n               CALL CHAR;\n            END;\n      END SKIP_TO_END_OF_COMMENT;\n\n      CALLCOUNT(3) = CALLCOUNT(3) + 1;\n      BCD = '';\n      NUMBER_VALUE, SCALE = 0;\n      DGNS#_LAST_TOKEN = TOKEN;\n      DO FOREVER;\n         IF CP > TEXT_LIMIT THEN CALL GET_CARD;\n         ELSE\n            DO; /* DISCARD LAST SCANNED VALUE */\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               TEXT = SUBSTR(TEXT, CP);\n               CP = 0;\n            END;\n         /*  BRANCH ON NEXT CHARACTER IN TEXT                  */\n         DO CASE CHARTYPE(BYTE(TEXT));\n\n            /*  CASE 0  */\n\n            /* ILLEGAL CHARACTERS FALL HERE  */\n            CALL ERROR ('ILLEGAL CHARACTER: ' || SUBSTR(TEXT, 0, 1));\n\n            /*  CASE 1  */\n\n            /*  BLANK  */\n            DO;\n               CP = 1;\n               IF CP > TEXT_LIMIT THEN CALL GET_CARD;\n               IF BYTE(TEXT, CP) = BYTE(' ') THEN\n                  DO WHILE \u00ac SCAN_FINDS_END_OF(ADDR(BLANKTABLE));\n                     CALL GET_CARD;\n                  END;\n               CP = CP - 1;\n            END;\n\n\n            /*  CASE 2  */\n\n            /*  STRING QUOTE ('):   CHARACTER STRING  */\n            DO FOREVER;\n               CALL CHAR;\n               TOKEN = STRING;\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               TEXT = SUBSTR(TEXT, CP);\n               DO WHILE \u00ac SCAN_FINDS_END_OF (ADDR(STRINGTABLE));\n                  IF LENGTH(BCD) + LENGTH(TEXT) > 256 THEN\n                     DO;\n                        CALL ERROR(LSTRNGM, 1);\n                        RETURN;\n                     END;\n                  BCD = BCD || TEXT;\n                  CALL GET_CARD;\n               END;\n               IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);\n               CALL CHAR;\n               IF BYTE(TEXT, CP) \u00ac= BYTE('''') THEN\n                  DO;\n                     IF LENGTH(BCD) = 0 THEN\n                        DO;\n                           CALL ERROR(\n                              'BLANK SUBSTITUTED FOR STRING OF LENGTH ZERO', 0);\n                           BCD = X1;\n                        END;\n                     RETURN;\n                  END;\n               BCD = BCD || '''';\n               /* PREPARE TO RESUME SCANNING STRING */\n            END;\n\n            /*  CASE 3  */\n\n            DO;          /* A ( : MAY BE START OF \"SQUARE BRACKET\"\n                                       OR COMMENT   */\n               CALL CHAR;\n               IF BYTE(TEXT,CP) = BYTE('.') THEN\n                  DO;\n                     TOKEN = LBRACKET;\n                     CALL CHAR;\n                     RETURN;\n                  END;\n               ELSE IF BYTE(TEXT,CP) \u00ac= BYTE('*') THEN\n                  DO;\n                     TOKEN = LPARENT;\n                     RETURN;\n                  END;\n               /* WE HAVE A COMMENT */\n               CALL SKIP_TO_END_OF_COMMENT(BYTE(')'));\n            END;\n\n            /*  CASE 4  */\n\n            DO FOREVER;  /* A LETTER:  IDENTIFIERS AND RESERVED WORDS */\n               IF SCAN_FINDS_END_OF (ADDR(ALPHATABLE)) THEN\n                  DO;  /* END OF IDENTIFIER  */\n                     IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);\n                     S1 = LENGTH(BCD);\n                     IF S1 > 1 THEN IF S1 <= RESERVED_LIMIT THEN\n                        /* CHECK FOR RESERVED WORDS */\n                        DO I = V_INDEX(S1 - 1) TO V_INDEX(S1) - 1;\n                           IF BCD = V(I) THEN\n                              DO;\n                                 TOKEN = I;\n                                 RETURN;\n                              END;\n                        END;\n                     /*  RESERVED WORDS EXIT HIGHER: THEREFORE <IDENTIFIER> */\n                     TOKEN = IDENT;\n                     RETURN;\n                  END;\n               /*  END OF CARD  */\n               BCD = BCD || TEXT;\n               CALL GET_CARD;\n            END;\n\n            /*  CASE 5  */\n\n            DO;      /*  DIGIT:  A NUMBER  */\n               TOKEN = INTCONST;     /* ASSUME AN INTEGER */\n               ERROR_SW = FALSE;   /* ASSUME NO ERRORS */\n               ST = '';\n               DO WHILE BYTE(TEXT, CP) >= \"F0\";\n                  ST = ST || SUBSTR(TEXT,CP,1);\n                  IF NUMBER_VALUE < MAX10 THEN\n                     NUMBER_VALUE = 10 * NUMBER_VALUE + BYTE(TEXT,CP) - \"F0\";\n                  ELSE IF NUMBER_VALUE=MAX10 & BYTE(TEXT,CP)<=\"F7\" THEN\n                     NUMBER_VALUE = 10 * NUMBER_VALUE + BYTE(TEXT,CP) - \"F0\";\n                  ELSE ERROR_SW = TRUE;\n                  CALL CHAR;\n               END;\n               IF ERROR_SW THEN\n                  DO;\n                     CALL ERROR('INTEGER CONSTANT EXCEEDS RANGE',0);\n                     NUMBER_VALUE = 0;\n                  END;\n               EXPONENT = 154;\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               TEXT = SUBSTR(TEXT,CP);\n               CP = 0;\n               IF LENGTH(TEXT) < 2 THEN\n                  DO;\n                     BCD = TEXT;\n                     CALL GET_CARD;\n                     TEXT = BCD || TEXT;\n                  END;\n               IF BYTE(TEXT) = BYTE('.') THEN\n                  IF BYTE(TEXT,1) \u00ac= BYTE(')')\n                     & BYTE(TEXT,1) \u00ac= BYTE('.') THEN\n                     DO;     /* A REAL */\n                        TOKEN = REALCONST;\n                        ST = ST || '.';\n                        CP = 1;\n                        SCALE = TENINTO(NUMBER_VALUE);\n                        EXPONENT = EXPONENT - 2*SCALE;\n                        CALL FLOAT(NUMBER_VALUE, ADDR(NUMBER_VALUE));\n                        CALL REAL_MULTIPLY(ADDR(NUMBER_VALUE),\n                           ADDR(POWERS(2*(78-SCALE))),ADDR(NUMBER_VALUE));\n                        IF BYTE(TEXT,1) < \"F0\" THEN\n                           CALL ERROR('ERROR IN REAL CONSTANT: DIGIT EXPECTED');\n                        ELSE\n                           DO WHILE BYTE(TEXT,CP) >= \"F0\";\n                                    CALL FLOAT(BYTE(TEXT,CP)-\"F0\",ADDR(X));\n                              CALL REAL_MULTIPLY(ADDR(X),ADDR(POWERS(EXPONENT)),\n                                 ADDR(X));\n                              IF EXPONENT>0 THEN EXPONENT = EXPONENT - 2;\n                              CALL REAL_ADD(ADDR(NUMBER_VALUE),ADDR(X),\n                                 ADDR(NUMBER_VALUE));\n                              ST = ST || SUBSTR(TEXT,CP,1);\n                              CALL CHAR;\n                           END;\n                     END;\n               IF BYTE(TEXT,CP) = BYTE('E') THEN\n                  DO;\n                     IF EXPONENT = 154 THEN /* WE THOUGHT IT WAS AN INTEGER */\n                        DO;\n                           TOKEN = REALCONST;\n                           SCALE = TENINTO(NUMBER_VALUE);\n                           CALL FLOAT(NUMBER_VALUE,ADDR(NUMBER_VALUE));\n                           CALL REAL_MULTIPLY(ADDR(NUMBER_VALUE),\n                              ADDR(POWERS(2*(78-SCALE))), ADDR(NUMBER_VALUE));\n                        END;\n                     SIGN = FALSE;\n                     ST = ST || 'E';\n                     CALL CHAR;\n                     IF BYTE(TEXT,CP) < \"F0\" THEN ST = ST || SUBSTR(TEXT,CP,1);\n                     IF BYTE(TEXT,CP)=BYTE('+') THEN CALL CHAR;\n                     ELSE IF BYTE(TEXT,CP) = BYTE('-') THEN\n                        DO;\n                           SIGN = TRUE;\n                           CALL CHAR;\n                        END;\n                     EXPONENT = 0;\n                     IF BYTE(TEXT,CP) < \"F0\" THEN\n                        CALL ERROR('ERROR IN REAL CONSTANT: DIGIT EXPECTED',0);\n                     ELSE\n                        DO WHILE BYTE(TEXT,CP) >= \"F0\";\n                           ST = ST || SUBSTR(TEXT,CP,1);\n                           EXPONENT = 10*EXPONENT + BYTE(TEXT,CP) - \"F0\";\n                           CALL CHAR;\n                        END;\n                     IF SIGN THEN SCALE = SCALE - EXPONENT;\n                     ELSE SCALE = SCALE + EXPONENT;\n                  END;\n               IF SCALE \u00ac= 0 THEN\n                  DO;\n                     IF (SCALE < -78) | (SCALE > 75)\n                        | (SCALE = -78 & NUMBER_VALUE < MIN_MANTISSA)\n                        | (SCALE = 75 & NUMBER_VALUE > MAX_MANTISSA)\n                        THEN CALL ERROR(\n                           'ERROR IN REAL CONSTANT: VALUE OUT OF RANGE');\n                        ELSE CALL REAL_MULTIPLY(ADDR(NUMBER_VALUE),\n                           ADDR(POWERS(2*(78+SCALE))), ADDR(NUMBER_VALUE));\n                  END;\n               BCD = ST;\n               RETURN;\n            END;\n\n            /*  CASE 6  */\n\n            DO;      /*  A /:  MAY BE DIVIDE OR START OF COMMENT  */\n               CALL CHAR;\n               IF BYTE(TEXT, CP) \u00ac= BYTE('*') THEN\n                  DO;\n                     TOKEN = DIVIDE;\n                     RETURN;\n                  END;\n               /* WE HAVE A COMMENT  */\n               CALL SKIP_TO_END_OF_COMMENT(BYTE('/'));\n            END;\n\n            /*  CASE 7  */\n            DO;      /*  SPECIAL CHARACTERS  */\n               IF LENGTH(TEXT) < 2 THEN DO;\n                  BCD = TEXT;\n                  CALL GET_CARD;\n                  TEXT = BCD || TEXT;\n               END;\n               IF BYTE(TEXT, 1) \u00ac= BLANK & NOT_LETTER_OR_DIGIT(BYTE(TEXT,1))THEN\n                  DO I = V_INDEX(1) TO V_INDEX(2) - 1;\n                     IF SUBSTR(TEXT, 0, 2) = V(I) THEN DO;\n                        TOKEN = I;\n                        CP = 2;\n                        RETURN;\n                     END;\n                  END;\n               TOKEN = TX(BYTE(TEXT));\n               CP = 1;\n               RETURN;\n            END;\n\n            /*  CASE 8 - A '#' */\n\n            DO;\n               TOKEN = NEOP;\n               CALL CHAR;\n               RETURN;\n            END;\n\n            /* CASE 9 - THE 0-2-8 PUNCH */\n\n            DO;\n               TOKEN = EOFILE;\n               COMPILING = FALSE;\n               CALL CHAR;\n               RETURN;\n            END;\n\n            /* CASE 10 -- AMPERSAND (&) */\n\n            DO;\n               TOKEN = ANDSY;\n               CALL CHAR;\n               RETURN;\n            END;\n\n            /* CASE 11 -- VERTICAL BAR (|) */\n\n            DO;\n               TOKEN = ORSY;\n               CALL CHAR;\n               RETURN;\n            END;\n\n            /* CASE 12 -- NEGATION (\u00ac) */\n            DO;\n               IF LENGTH(TEXT) < 2 THEN DO;\n                  BCD = TEXT;\n                  CALL GET_CARD;\n                  TEXT = BCD || TEXT;\n               END;\n               IF BYTE(TEXT,1) \u00ac= BYTE('=') THEN DO;\n                  TOKEN = NOTSY;\n                  CP = 1;\n                  RETURN;\n               END;\n               TOKEN = NEOP;\n               CP = 2;\n               RETURN;\n            END;\n\n         END;     /* OF CASE ON CHARTYPE  */\n         CP = CP + 1;  /* ADVANCE SCANNER AND RESUME SEARCH FOR TOKEN  */\n      END;\n   END SCAN;\n\n\n\n\n  /*                       TIME AND DATE                                 */\n\n\nPRINT_TIME:\n   PROCEDURE (MESSAGE, T);\n      DECLARE MESSAGE CHARACTER, T FIXED;\n      MESSAGE = MESSAGE || T/360000 || ':' || T MOD 360000 / 6000 || ':'\n         || T MOD 6000 / 100 || '.';\n      T = T MOD 100;  /* DECIMAL FRACTION  */\n      IF T < 10 THEN MESSAGE = MESSAGE || '0';\n      OUTPUT = MESSAGE || T || '.';\n   END PRINT_TIME;\n\nPRINT_TIMES:\n   PROCEDURE (MESSAGE, T1, T2);\n      /* T1 ASSUMED TO BE REAL TIME, T2 CPU TIME */\n      DECLARE MESSAGE CHARACTER, (T1, T2) FIXED;\n      MESSAGE = MESSAGE || 'ELAPSED = ' || T1/360000 || ':' ||\n                T1 MOD 360000 / 6000 || ':' || T1 MOD 6000 / 100 || '.';\n      T1 = T1 MOD 100;   /* DECIMAL FRACTION */\n      IF T1 < 10 THEN MESSAGE = MESSAGE || '0';\n      CALL PRINT_TIME(MESSAGE || T1 || ', CPU = ', T2);\n   END PRINT_TIMES;\n\nPRINT_DATE_AND_TIME:\n   PROCEDURE (MESSAGE, D, T);\n      DECLARE MESSAGE CHARACTER, (D, T, YEAR, DAY, M) FIXED;\n      DECLARE MONTH(11) CHARACTER INITIAL ('JANUARY', 'FEBRUARY', 'MARCH',\n         'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER',\n         'NOVEMBER', 'DECEMBER'),\n      DAYS(12) FIXED INITIAL (0, 31, 60, 91, 121, 152, 182, 213, 244, 274,\n         305, 335, 366);\n      YEAR = D/1000 + 1900;\n      DAY = D MOD 1000;\n      IF (YEAR & \"3\") \u00ac= 0 THEN IF DAY > 59 THEN DAY = DAY + 1; /* \u00ac LEAP YEAR*/\n      M = 1;\n      DO WHILE DAY > DAYS(M);  M = M + 1;  END;\n      CALL PRINT_TIME(MESSAGE || MONTH(M-1) || X1 || DAY-DAYS(M-1) ||  ', '\n         || YEAR || '.  CLOCK TIME = ', T);\n   END PRINT_DATE_AND_TIME;\n\n  /*                       INITIALIZATION                                     */\n\n\n\nINITIALIZATION:\n   PROCEDURE;\n\n   LOCATE_INDEX:  PROCEDURE (S) FIXED;\n      DECLARE S CHARACTER;\n      DECLARE I BIT(16);\n      DO I = 1 TO NT;\n         IF S = V(I) THEN RETURN I;\n         END;\n      END LOCATE_INDEX;\n\n      ANDSY = LOCATE_INDEX ('AND');\n      COLON = LOCATE_INDEX (':');\n      DIVIDE = LOCATE_INDEX ('/');\n      EOFILE = LOCATE_INDEX ('_|_');\n      EQUALSIGN = LOCATE_INDEX ('=');\n      IDENT = LOCATE_INDEX('<IDENTIFIER>');\n      INTCONST = LOCATE_INDEX ('<UNSIGNED INTEGER>');\n      LBRACKET = LOCATE_INDEX ('(.');\n      LEOP = LOCATE_INDEX ('<=');\n      LPARENT = LOCATE_INDEX ('(');\n      RPARENT = LOCATE_INDEX(')');\n      LTOP = LOCATE_INDEX ('<');\n      NEOP = LOCATE_INDEX ('<>');\n      NOTSY = LOCATE_INDEX ('NOT');\n      ORSY = LOCATE_INDEX ('OR');\n      REALCONST = LOCATE_INDEX ('<UNSIGNED REAL>');\n      STRING = LOCATE_INDEX ('<STRING>');\n      RESERVED_LIMIT = 9;\n      V(EOFILE) = '\\';   /* THE 0-2-8 PUNCH */\n      CHARTYPE(BYTE(' ')) = 1;\n      BLANK = BYTE(X1);\n      DO I = 0 TO 255;\n         NOT_LETTER_OR_DIGIT(I) = TRUE;\n      END;\n      DO I = 0 TO LENGTH(ALPHABET) - 1;\n         J = BYTE(ALPHABET, I);\n         TX(J) = I;\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 4;\n      END;\n      DO I = 0 TO 9;\n         J = BYTE('0123456789', I);\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 5;\n      END;\n      NOT_LETTER_OR_DIGIT(BYTE('_')) = FALSE;\n      DO I = V_INDEX(0) TO V_INDEX(1) - 1;\n         J = BYTE(V(I));\n         IF NOT_LETTER_OR_DIGIT(J) THEN DO;\n            TX(J) = I;\n            CHARTYPE(J) = 7;\n         END;\n      END;\n      DO I = V_INDEX(1) TO V_INDEX(2) - 1;\n         J = BYTE(V(I));\n         IF NOT_LETTER_OR_DIGIT(J) THEN CHARTYPE(J) = 7;\n      END;\n      CHARTYPE(BYTE('''')) = 2;\n      CHARTYPE(BYTE('(')) = 3;\n      CHARTYPE(BYTE('/')) = 6;\n      CHARTYPE(BYTE('#')) = 8;\n      CHARTYPE(BYTE('\\')) = 9;    /* THE 0-2-8 PUNCH */\n      CHARTYPE(BYTE('&')) = 10;\n      CHARTYPE(BYTE('|')) = 11;\n      CHARTYPE(BYTE('\u00ac')) = 12;\n      NT1 = NT + 1;  /*  INDEX OF FIRST NONTERMINAL  */\n      LOOKUP_TYPE(IDENT) = 1;\n      LOOKUP_TYPE(STRING) = 2;\n      LOOKUP_TYPE(INTCONST), LOOKUP_TYPE(REALCONST) = 2;\n      BATCHING = TRUE;\n   END INITIALIZATION;\n\n INIT_SY_TABLE:PROCEDURE;\n DECLARE I FIXED;\n DO I = #_PREDECLARED + 1 TO TABLE_LENGTH;\n    VALUE(I) = 0 ;\n    DATATYPE(I) = NULL;\n    VAR_TYPE(I) = UNDEFINED;\n END;\n DO I = 0 TO IDENTITY_LENGTH;\n    WHERE_DECL(I) = 0;\n    N_LOOKUPS(I)=0;\n    SYMB_LINK(I) = NULL;\n END;\nDO I = 0 TO 255;\n   BUCKET(I) = NULL;\n   END;\nDO N_DECL_SYMB = 0 TO #_PREDECLARED;\n   /* ENTER PREDECLARED SYMBOLS ON THE HASH BUCKET CHAINS */\n   I = LENGTH(IDENTITY(N_DECL_SYMB)) - 1;\n   I =(BYTE(IDENTITY(N_DECL_SYMB)) + BYTE(IDENTITY(N_DECL_SYMB), I) + I) & \"FF\";\n   IF BUCKET(I) = NULL THEN\n         BUCKET(I) = N_DECL_SYMB;\n   ELSE DO;\n      I = BUCKET(I);\n      DO WHILE SYMB_LINK(I) \u00ac= NULL;\n         I = SYMB_LINK(I);\n         END;\n      SYMB_LINK(I) = N_DECL_SYMB;\n      END;\n   END;\n VALUE(37) = MAXINT;\n N_ANONYMOUS_SYMB = TABLE_LENGTH;\n N_DECL_SYMB = #_PREDECLARED + 1;\n OWN_MOD = #_PREDECLARED;\n SYMB_BLOCK_OWNER(0) = NULL;\n PROCMARK(1) = N_DECL_SYMB;\n BLOCK_STACK(1), CURRENT_BLOCK = 1;\n FIRST_LITERAL = NULL;\n END INIT_SY_TABLE;\n\nRE_INITIALIZE:  PROCEDURE;\n      /* FIRST SET UP GLOBAL VARIABLES CONTROLLING SCAN, THEN GET THE FIRST CARD\n                                                                      */\n      CONTROL(BYTE('L')) = TRUE;\n      CONTROL(BYTE('B')) = DEBUGGING;\n      IF BATCHING THEN DO;\n         CALL DGNS#_INITIALIZE;\n         CALL INIT_SY_TABLE;\n         /* INITIALIZE THE PARSE_STACK AND PARSE_TREE                 */\n         PARSE_STACK(0) = EOFILE;\n         SP = 1;  PARSE_STACK(SP) = GOAL;\n         TREE_SIZE = 1;\n         MAX_TREE, #_OF_TREES = 0;\n         CURRENT_LEVEL = 1;\n         TYPE_DECL_PART = FALSE;\n         FORWARD_REF_HEAD = NULL;\n         LITERAL_POOL_SIZE = 0;\n\n         /* INITIALIZE  COMPILATION   FLAG AND CONSTANTS              */\n          CARD_COUNT ,ERROR_COUNT,SEVERE_ERRORS,PREVIOUS_ERROR = 0 ;\n         COMPILING = TRUE;\n\n         /* INITIALIZE PROGRAM STATISTICS COUNTERS                    */\n         CALLCOUNT(1), CALLCOUNT(3) = 0;\n\n         /* PRINT PAGE HEADING                                        */\n         EJECT_PAGE;\n         CALL PRINT_DATE_AND_TIME(\n            'PASS ONE -- STONY BROOK PASCAL -- COMPILER VERSION OF ',\n               DATE_OF_GENERATION, TIME_OF_GENERATION);\n         CALL PRINT_DATE_AND_TIME ('TODAY IS ', DATE, TIME);\n         DOUBLE_SPACE;\n         CALL GET_CARD;\n      END;\nEND RE_INITIALIZE;\n\n\n\n\nDUMPIT:\n   PROCEDURE;    /* DUMP OUT THE STATISTICS COLLECTED DURING THIS RUN  */\n      DOUBLE_SPACE;\n      /*  PUT OUT THE ENTRY COUNT FOR IMPORTANT PROCEDURES */\n\n      OUTPUT = 'SYMBOL TABLE SIZE = ' || N_DECL_SYMB;\n      OUTPUT = 'NUMBER OF TREES   = ' || #_OF_TREES;\n      OUTPUT = 'LARGEST TREE SIZE = ' || MAX_TREE;\n   IF MONITOR_LINK(2) >= 2 THEN\n      OUTPUT = 'BASIC BLOCKS      = ' || BASIC_BLOCKS;\n      OUTPUT = 'SCAN              = ' || CALLCOUNT(3);\n      OUTPUT = 'NUMBER OF PRODUCTIONS RECOGNIZED = ' || CALLCOUNT(1);\n      OUTPUT = 'FREE STRING AREA  = ' || FREELIMIT - FREEBASE;\n   END DUMPIT;\n\n\nSTACK_DUMP:\n   PROCEDURE;\n      DECLARE LINE CHARACTER;\n      LINE = 'PARSE STACK AT THIS POINT PREDICTS: ';\n      DO I = 1 TO SP;\n         IF LENGTH(LINE) > 105 THEN\n            DO;\n               OUTPUT = LINE;\n               LINE = X4;\n            END;\n         IF PARSE_STACK(I) = EOFILE THEN LINE = LINE || 'END OF FILE';\n            ELSE LINE = LINE || X1 || V(PARSE_STACK(I));\n      END;\n      OUTPUT = LINE;\n   END STACK_DUMP;\n\nCOREIM_DESCRIPT:\n   PROCEDURE(ADDRESS,LENGTH) CHARACTER;\n      DECLARE (ADDRESS,LENGTH,DESCRIPTOR) FIXED;\n\n      IF LENGTH = 0 THEN DESCRIPTOR = 0;\n         ELSE DESCRIPTOR = SHL(LENGTH-1,24) + ADDRESS;\n   /* WE RETURN DESCRIPTOR IN REGISTER 3 */\n      CALL INLINE(\"58\",3,0,DESCRIPTOR);          /* L    3,DESCRIPTOR      */\n   END COREIM_DESCRIPT;\n\nPUNCH_PARSE_TREE:\n   PROCEDURE(TREE);\n      DECLARE (TREE,I) BIT(16);   /* TREE IS INDEX INTO PARSE TREE OF ROOT */\n      DECLARE STRING CHARACTER;\n\n      STRING = I_FORMAT(TREE,5);\n      STRING = '%TREE' || STRING;\n      /* TELL PASS 2 WHETHER OR NOT TO PRINT THE PARSE TREE */\n      IF CONTROL(BYTE('P')) THEN STRING = STRING || 'P';\n      ELSE STRING = STRING || X1;\n      IF CONTROL(BYTE('T')) THEN STRING = STRING || 'T';\n      ELSE STRING = STRING || X1;\n      IF CONTROL(BYTE('E')) THEN STRING = STRING || 'E';\n      OUTPUT(3) = STRING;\n      I = 0;\n      DO WHILE I < TREE_SIZE;\n         STRING = COREIM_DESCRIPT(ADDR(PARSE_TREE(I)),80);\n         OUTPUT(3) = STRING;\n         I = I + 40;   /* 2 BYTES PER ARRAY ELEMENT */\n      END;\n      STRING = '%END';\n      OUTPUT(3) = STRING;\n   END PUNCH_PARSE_TREE;\n\nCOMPACTIFY_SYMBOL_TABLE:\n   PROCEDURE;\n      DECLARE (GAP, I) BIT(16);\n\n   FIX_DATATYPE:\n      PROCEDURE (TP_PTR, LISTHEAD);\n      DECLARE LISTHEAD FIXED;\n      DECLARE (ID_PTR, NEXT, TP_PTR) FIXED;\n      ID_PTR = LISTHEAD;\n      DO WHILE ID_PTR \u00ac= NULL;\n         NEXT = DATATYPE(ID_PTR);\n         DATATYPE(ID_PTR) = TP_PTR;\n         ID_PTR = NEXT;\n         END;\n   END FIX_DATATYPE;\n\n      GAP = N_ANONYMOUS_SYMB - N_DECL_SYMB + 1;\n      IF GAP < 1 THEN\n         DO;\n            N_DECL_SYMB = TABLE_LENGTH;\n            RETURN;\n         END;\n      DO I = 0 TO N_DECL_SYMB;\n         IF DATATYPE(I) > N_ANONYMOUS_SYMB THEN\n            DATATYPE(I) = DATATYPE(I) - GAP;\n      END;\n      DO I = N_ANONYMOUS_SYMB + 1 TO TABLE_LENGTH;\n         IF DATATYPE(I) > N_ANONYMOUS_SYMB THEN\n            DATATYPE(N_DECL_SYMB) = DATATYPE(I) - GAP;\n         ELSE DATATYPE(N_DECL_SYMB) = DATATYPE(I);\n         VAR_TYPE(N_DECL_SYMB) = VAR_TYPE(I);\n         VALUE(N_DECL_SYMB) = VALUE(I);\n         N_DECL_SYMB = N_DECL_SYMB + 1;\n      END;\n      IF INTCHAIN > NULL THEN INTCHAIN = INTCHAIN - GAP;\n      IF REALCHAIN > NULL THEN REALCHAIN = REALCHAIN - GAP;\n      IF CHARCHAIN > NULL THEN CHARCHAIN = CHARCHAIN - GAP;\n      CALL FIX_DATATYPE(INTPTR, INTCHAIN);\n      CALL FIX_DATATYPE(REALPTR, REALCHAIN);\n      CALL FIX_DATATYPE(CHARPTR, CHARCHAIN);\n      N_ANONYMOUS_SYMB = N_ANONYMOUS_SYMB - GAP + 1; /* OLD N_DECL_SYMB */\n   END COMPACTIFY_SYMBOL_TABLE;\n\nSY_TABLE_STAT:\n   PROCEDURE (J);\n      DECLARE X2 CHARACTER INITIAL ('  ');\n      DECLARE J BIT(16);\n      DECLARE LINE CHARACTER;\n      DECLARE ID_FIELD FIXED INITIAL (12);\n      DECLARE VAR_TYPES(17) CHARACTER INITIAL ('        ','VARIABLE','CONSTANT',\n            'LITERAL ', 'TYPE    ', 'PROC    ', 'VAR PARM', 'PROCPARM',\n            'UNDEFINE', 'LABEL   ', '        ', 'CASELABL', 'VARIANT ',\n            'FIELD ID', 'FORWARD ', 'MULTDECL', 'VAL PARM', 'RECORD  ');\n\n   LJUSTIFY:\n      PROCEDURE (X, FIELDWIDTH);\n         DECLARE (X, XTEMP) CHARACTER;\n         DECLARE FIELDWIDTH FIXED;\n         XTEMP = X;\n         IF LENGTH(XTEMP) >= FIELDWIDTH THEN\n            XTEMP = SUBSTR (XTEMP, 0, FIELDWIDTH);\n         ELSE XTEMP = XTEMP || SUBSTR (X70, 0, FIELDWIDTH-LENGTH(XTEMP));\n         LINE = LINE || XTEMP || X4;\n      END LJUSTIFY;\n\n   RJUSTIFY:\n      PROCEDURE (X, FIELDWIDTH);\n         DECLARE (X, FIELDWIDTH) FIXED;\n         DECLARE XTEMP CHARACTER;\n         XTEMP = X;\n         IF LENGTH(XTEMP) > FIELDWIDTH THEN\n            LINE = SUBSTR (LINE, 0, LENGTH(LINE) - LENGTH(XTEMP) + FIELDWIDTH);\n         ELSE LINE = LINE || SUBSTR (X70, 0, FIELDWIDTH - LENGTH(XTEMP));\n         LINE = LINE || XTEMP || X4;\n      END RJUSTIFY;\n\n      LINE = I_FORMAT (J, 4);\n      LINE = LINE || X2;\n      IF J >= N_ANONYMOUS_SYMB THEN LINE = LINE || SUBSTR (X70, 0, ID_FIELD +4);\n      ELSE CALL LJUSTIFY (IDENTITY(J), ID_FIELD);\n      CALL RJUSTIFY (DATATYPE(J), 4);\n      CALL RJUSTIFY (SYMB_LINK(J), 8);\n      LINE = LINE || VAR_TYPES(VAR_TYPE(J)) || X4;\n      CALL RJUSTIFY (VALUE(J), 8);\n      CALL RJUSTIFY (WHERE_DECL(J), 8);\n      CALL RJUSTIFY (N_LOOKUPS(J), 8);\n      OUTPUT = LINE;\n   END SY_TABLE_STAT;\n\nSY_DUMP: PROCEDURE;\n      DECLARE I BIT(16);\n      EJECT_PAGE;\n      OUTPUT = '      IDENTITY      DATATYPE  SYMB LINK   VAR TYPE       VALUE'\n              || '     WHERE DECL   OCCURRENCES';\n      OUTPUT = '';\n      DO I = 0 TO N_DECL_SYMB - 1;\n         CALL SY_TABLE_STAT(I);\n      END;\n   END SY_DUMP;\n\nPUNCH_SYMBOLS:\n   PROCEDURE;\n      DECLARE (I,J) FIXED, (LINE,S1,S2) CHARACTER;\n      DECLARE ID CHARACTER;\n\n      LINE = '';\n      S1 = I_FORMAT(N_DECL_SYMB,5);\n      S2 = I_FORMAT(N_ANONYMOUS_SYMB,5);\n      S1 = '%SYMB' || S1 || S2;\n      S2 = I_FORMAT(FIRST_LITERAL,5);\n      IF CONTROL(BYTE('D')) THEN S2 = S2 || 'D';\n      ELSE S2 = S2 || X1;\n      IF CONTROL(BYTE('S')) THEN S2 = S2 || 'S';\n      OUTPUT(4) = S1 || S2;\n      I = #_PREDECLARED + 1;\n      DO WHILE I < N_ANONYMOUS_SYMB;\n         ID = '''' || IDENTITY(I) || ''' ';\n         DO J = 1 TO LENGTH(ID) - 3;\n            IF BYTE(ID,J) = BYTE('''') THEN\n               DO;\n                  S1 = SUBSTR(ID,0,J);\n                  S2 = SUBSTR(ID,J);\n                  ID = S1 || '''' || S2;\n                  J = J + 1;\n               END;\n         END;\n         IF LENGTH(LINE) + LENGTH(ID) <= 80 THEN\n               LINE = LINE || ID;\n            ELSE DO;\n               S1 = SUBSTR(ID,0,80 - LENGTH(LINE));\n               OUTPUT(4) = LINE || S1;\n               S2 = SUBSTR(ID,LENGTH(S1));\n               DO WHILE LENGTH(S2) > 80;\n                  OUTPUT(4) = SUBSTR(S2,0,80);\n                  S2 = SUBSTR(S2,80);\n               END;\n               LINE = S2;\n            END;\n         IF LENGTH(LINE) = 80 THEN\n            DO;\n               OUTPUT(4) = LINE;\n               LINE = '';\n            END;\n         I = I + 1;\n      END;\n      OUTPUT(4) = LINE;\n      I = #_PREDECLARED + 1;\n      DO WHILE I < N_ANONYMOUS_SYMB;\n         OUTPUT(4) = COREIM_DESCRIPT(ADDR(N_LOOKUPS(I)),80);\n         I = I + 40;\n      END;\n      I = #_PREDECLARED + 1;\n      DO WHILE I < N_ANONYMOUS_SYMB;\n         OUTPUT(4) = COREIM_DESCRIPT(ADDR(SYMB_LINK(I)), 80);\n         I = I + 40;\n      END;\n      I = #_PREDECLARED + 1;\n      DO WHILE I < N_DECL_SYMB;\n         OUTPUT(4) = COREIM_DESCRIPT(ADDR(VALUE(I)),80);\n         I = I + 20;\n      END;\n      I = #_PREDECLARED + 1;\n      DO WHILE I < N_DECL_SYMB;\n         OUTPUT(4) = COREIM_DESCRIPT(ADDR(VAR_TYPE(I)),80);\n         I = I + 40;\n      END;\n      I = #_PREDECLARED + 1;\n      DO WHILE I < N_DECL_SYMB;\n         OUTPUT(4) = COREIM_DESCRIPT(ADDR(DATATYPE(I)),80);\n         I = I + 40;\n      END;\n      I = #_PREDECLARED + 1;\n      DO WHILE I < N_ANONYMOUS_SYMB;\n         OUTPUT(4) = COREIM_DESCRIPT(ADDR(WHERE_DECL(I)),80);\n         I = I + 40;\n      END;\n      OUTPUT(4) = '%END';\n   END PUNCH_SYMBOLS;\n\n\n\n  /*                      THE SYMBOL TABLE PROCEDURES                      */\n\n\nOPEN_BLOCK:\n   PROCEDURE (IS_NEW_BLOCK);\n      DECLARE IS_NEW_BLOCK BIT(1),\n              (SP, ID_PTR) BIT(16);\n      CURRENT_LEVEL = CURRENT_LEVEL + 1;\n      /***** FIND THE TOPMOST LEAF NODE ON THE SUBTREE STACK *****/\n      SP = SUBTREE_STACKSIZE;\n      DO WHILE PARSE_TREE(SUBTREE_STACK(SP)) > 0;\n         SP = SP - 1;\n         END;\n      ID_PTR = PARSE_TREE(SUBTREE_STACK(SP) + 1);\n      IF IS_NEW_BLOCK THEN DO;\n         PROCMARK(CURRENT_LEVEL) = N_DECL_SYMB;\n         VALUE(ID_PTR), BLOCK_STACK(CURRENT_LEVEL), CURRENT_BLOCK\n            = CURRENT_BLOCK + 1;\n         END;\n       ELSE DO ;\n         PROCMARK(CURRENT_LEVEL) = 0 ;\n         IF VAR_TYPE(ID_PTR) = PROC THEN\n             BLOCK_STACK(CURRENT_LEVEL) = VALUE(ID_PTR);\n         ELSE BLOCK_STACK(CURRENT_LEVEL)=VALUE(DATATYPE(DATATYPE(ID_PTR)));\n       END;\n      SYMB_BLOCK_OWNER(CURRENT_LEVEL), OWN_MOD = ID_PTR;\n      DECLARE BLOCK_STRING CHARACTER;\n      IF CONTROL(BYTE('Z')) THEN DO;\n      BLOCK_STRING = '                                    *** BLOCK STACK DUMP';\n      DO SP = 0 TO CURRENT_LEVEL;\n         BLOCK_STRING = BLOCK_STRING || '  ' || BLOCK_STACK(SP);\n         END;\n      OUTPUT = BLOCK_STRING;\n      END;\n   END OPEN_BLOCK;\n\nNULLOUT:\n   PROCEDURE (MAXINDEX);\n      DECLARE (I, MAXINDEX) BIT(16);\n       IF MAXINDEX <= 0 THEN DO ;\n         CALL ERROR('***COMPILER ATTEMPTED TO NULL A DECLARATION' ||\n                     'BLOCK THAT IS NOT ASSOCIATED WITH A PROCEDURE',1);\n         RETURN;\n       END;\n      DO I = 0 TO 255;\n         IF BUCKET(I) > MAXINDEX THEN\n            BUCKET(I) = NULL;\n         END;\n      DO I = #_PREDECLARED TO N_DECL_SYMB;\n         IF SYMB_LINK(I) > MAXINDEX THEN\n            IF VAR_TYPE(I) \u00ac= LITERAL THEN\n               SYMB_LINK(I) = NULL;\n         END;\n   END NULLOUT;\n\nCLOSE_BLOCK:\n   PROCEDURE (IS_PROC_BLOCK);\n      DECLARE IS_PROC_BLOCK BIT(1);\n       IF IS_PROC_BLOCK THEN\n          IF BLOCK_STACK(CURRENT_LEVEL) > 1 THEN\n             CALL NULLOUT(PROCMARK(CURRENT_LEVEL));\n       IF CURRENT_LEVEL > 1 THEN CURRENT_LEVEL = CURRENT_LEVEL - 1 ;\n      OWN_MOD = SYMB_BLOCK_OWNER(CURRENT_LEVEL);\n   END CLOSE_BLOCK;\n\nENTER_SYMBOL:\n   PROCEDURE (ID, LEVEL) FIXED;\n      DECLARE ID CHARACTER,\n              (LEVEL, INDEX, I, CHAIN_PTR) BIT(16);\n         INDEX = N_DECL_SYMB;\n         N_DECL_SYMB = N_DECL_SYMB + 1;\n         IF (N_DECL_SYMB>IDENTITY_LENGTH) | (N_DECL_SYMB=N_ANONYMOUS_SYMB) THEN\n              DO;\n                   CALL ERROR(SYMB_OVFLO, 1);\n                   COMPILING = FALSE;\n              END;\n         VAR_TYPE(INDEX) = UNDEFINED;\n         IDENTITY(INDEX)= ID;\n         WHERE_DECL(INDEX) = CARD_COUNT;\n         I = LENGTH(ID) - 1;\n         I = (BYTE(ID) + BYTE(ID, I) + I + BLOCK_STACK(LEVEL)) & \"FF\";\n         IF BUCKET(I) = NULL THEN\n            BUCKET(I) = INDEX;\n         ELSE DO;\n            CHAIN_PTR = BUCKET(I);\n            DO WHILE SYMB_LINK(CHAIN_PTR) \u00ac= NULL;\n               CHAIN_PTR = SYMB_LINK(CHAIN_PTR);\n               END;\n            SYMB_LINK(CHAIN_PTR) = INDEX;\n            END;\n         RETURN (INDEX);\n   END ENTER_SYMBOL;\n\n   CONSTANT_INDEX: PROCEDURE(LISTHEAD) BIT(16);\n      /* LISTHEAD IS PASSED BY REFERENCE! */\n      DECLARE (LISTHEAD, INDEX) FIXED;\n      INDEX = COREWORD (SHR(LISTHEAD, 2));\n      DO WHILE INDEX > NULL;\n         IF VALUE(INDEX) = NUMBER_VALUE THEN RETURN INDEX;\n         INDEX = DATATYPE(INDEX);\n      END;\n      INDEX = N_ANONYMOUS_SYMB;\n      N_ANONYMOUS_SYMB = N_ANONYMOUS_SYMB - 1;\n      IF N_ANONYMOUS_SYMB = N_DECL_SYMB THEN\n         DO;\n            CALL ERROR(SYMB_OVFLO, 1);\n            COMPILING = FALSE;\n         END;\n      DATATYPE(INDEX) = COREWORD(SHR(LISTHEAD, 2));\n      COREWORD(SHR(LISTHEAD, 2)) = INDEX;\n      VAR_TYPE(INDEX) = CONSTANT;\n      VALUE(INDEX) = NUMBER_VALUE;\n      RETURN INDEX;\n   END CONSTANT_INDEX;\n\n   LITERAL_INDEX: PROCEDURE BIT(16);\n      DECLARE INDEX FIXED;\n      INDEX = FIRST_LITERAL;\n      DO WHILE INDEX \u00ac= NULL;\n         IF IDENTITY(INDEX) = BCD THEN RETURN INDEX;\n         INDEX = SYMB_LINK(INDEX);\n      END;\n      INDEX = N_DECL_SYMB;\n      N_DECL_SYMB = N_DECL_SYMB + 1;\n      IF (N_DECL_SYMB>IDENTITY_LENGTH) | (N_DECL_SYMB=N_ANONYMOUS_SYMB) THEN\n         DO;\n            CALL ERROR(SYMB_OVFLO, 1);\n            COMPILING = FALSE;\n         END;\n      SYMB_LINK(INDEX) = FIRST_LITERAL;\n      FIRST_LITERAL = INDEX;\n      DATATYPE(INDEX) = CHARPTR;\n      VAR_TYPE(INDEX) = LITERAL;\n      LITERAL_POOL_SIZE = LITERAL_POOL_SIZE + LENGTH(BCD);\n      IDENTITY(INDEX) = BCD;\n      RETURN INDEX;\n   END LITERAL_INDEX;\n\nLOOKUP:\n   PROCEDURE (ID, DEPTH) BIT(16);\n      DECLARE ID CHARACTER;\n      DECLARE (DEPTH, INDEX, L, I) BIT(16);\n      IF IS_DECLARATION THEN DEPTH = CURRENT_LEVEL;\n      L = LENGTH(ID) - 1;\n      I = BYTE(ID) + BYTE(ID, L) + L;\n      L = CURRENT_LEVEL;\n      DO WHILE L >= DEPTH;\n         INDEX = BUCKET((I + BLOCK_STACK(L)) & \"FF\");\n         DO WHILE INDEX \u00ac= NULL;\n            IF IDENTITY(INDEX) = ID THEN DO;\n               N_LOOKUPS(INDEX) = N_LOOKUPS + 1;\n               IF IS_DECLARATION THEN\n                  IF VAR_TYPE(INDEX) = UNDEFINED THEN\n                     VAR_TYPE(INDEX) = VARTYPECODE;\n                  ELSE IF (VARTYPECODE = PROC) & (VAR_TYPE(INDEX) = FORWARD)\n                     THEN BLOCK_CLOSURE_CODE = OLD;\n                  ELSE DO;\n                       CALL ERROR ('DUPLICATE DECLARATION FOR ' || ID, 0);\n                       #_MULTIPLE_DECLARATIONS = #_MULTIPLE_DECLARATIONS + 1;\n                       INDEX = ENTER_SYMBOL (DOLLAR || ID ||\n                                    #_MULTIPLE_DECLARATIONS, CURRENT_LEVEL);\n                     END;\n               RETURN INDEX;\n               END;\n            INDEX = SYMB_LINK(INDEX);\n            END;\n         L = L - 1;\n         END;\n      INDEX= ENTER_SYMBOL (ID, CURRENT_LEVEL);\n      IF IS_DECLARATION THEN VAR_TYPE(INDEX) = VARTYPECODE;\n      ELSE DO;\n         VAR_TYPE(INDEX) = UNDEFINED;\n         IF \u00acIS_FORWARD_DECL THEN\n            CALL ERROR (ID || ' IS AN UNDECLARED IDENTIFIER', 0);\n         END;\n      RETURN INDEX;\n   END LOOKUP;\n\n   LOOKUP_LITERAL: PROCEDURE (ID) FIXED;\n    DECLARE ID CHARACTER;\n    DECLARE INDEX FIXED;\n         IF LABEL_DECL THEN DO;\n            INDEX = LOOKUP(ID,CURRENT_LEVEL);\n            VAR_TYPE(INDEX)= LABLE;\n            RETURN INDEX;\n            END;\n         IF LABEL_LOOKUP THEN DO;\n            INDEX = LOOKUP(ID,1);\n            LABEL_LOOKUP = FALSE;\n            IF VAR_TYPE(INDEX) \u00ac= LABLE THEN\n               CALL ERROR('UNDECLARED LABEL ' || ID, 1);\n            RETURN(INDEX); END;\n         IF TOKEN = INTCONST THEN RETURN CONSTANT_INDEX(ADDR(INTCHAIN));\n         IF TOKEN = REALCONST THEN RETURN CONSTANT_INDEX(ADDR(REALCHAIN));\n         /* TOKEN = STRING */\n         IF LENGTH(BCD) > 1 THEN RETURN LITERAL_INDEX;\n         NUMBER_VALUE = BYTE(BCD);\n         RETURN CONSTANT_INDEX(ADDR(CHARCHAIN));\n   END LOOKUP_LITERAL;\n\n\n  /*               THE SYNTHESIS ALGORITHM FOR PASCAL 370                  */\n\n\nGET_NODE:\n   PROCEDURE(MULT) BIT(16);\n      DECLARE (MULT, POINTER) BIT(16);\n      IF (TREE_SIZE + MULT + 3) > 7200 THEN\n         DO;\n            CALL ERROR('PARSE TREE OVERFLOW',1);\n            TREE_SIZE = 1;\n            RETURN(1);\n         END;\n      POINTER = TREE_SIZE;\n      PARSE_TREE(TREE_SIZE) = MULT;\n      TREE_SIZE = TREE_SIZE + MULT + 3;\n      RETURN (POINTER);\n   END GET_NODE;\n\nSTACK_NODE:\n   PROCEDURE(NODE_NUMBER);\n      DECLARE NODE_NUMBER FIXED;\n      NODE_STACKSIZE = NODE_STACKSIZE + 1;\n      NODE_STACK(NODE_STACKSIZE) = NODE_NUMBER;\n      SUBTREE_INDEX(NODE_STACKSIZE) = SUBTREE_STACKSIZE + 1;\n   END STACK_NODE;\n\nUNSTACK:\nPROCEDURE;\n   DECLARE (I, J, K) FIXED;\n   IF NODE_STACKSIZE < 1 THEN RETURN;\n   I = SUBTREE_STACKSIZE - SUBTREE_INDEX(NODE_STACKSIZE) + 1;\n   J = GET_NODE(I);\n   PARSE_TREE(J+1) = NODE_STACK(NODE_STACKSIZE);\n   DO K = 1 TO I;\n      PARSE_TREE(J+K+1) = SUBTREE_STACK(SUBTREE_INDEX(NODE_STACKSIZE) + K - 1);\n   END;\n   SUBTREE_STACKSIZE = SUBTREE_INDEX(NODE_STACKSIZE);\n   SUBTREE_STACK(SUBTREE_STACKSIZE) = J;\n   IF I > 0 THEN\n      DO;\n         K = PARSE_TREE(J+2);\n         IF K \u00ac= NULL THEN PARSE_TREE(I+J+2) = PARSE_TREE(K+PARSE_TREE(K)+2);\n         ELSE PARSE_TREE(I+J+2) = CARD_COUNT;\n      END;\n   ELSE PARSE_TREE(I+J+2) = CARD_COUNT;\n   NODE_STACKSIZE = NODE_STACKSIZE - 1;\nEND UNSTACK;\n\nUNSTACK_QUALIFIER:\n   PROCEDURE;\n      DECLARE NODE_NUMBER BIT(16);\n      NODE_NUMBER = NODE_STACK(NODE_STACKSIZE);\n      IF NODE_NUMBER = 53 THEN CALL UNSTACK; /* SUBSCRIPT QUALIFIER */\n      ELSE IF NODE_NUMBER = 55 THEN DO;\n            IF VAR_TYPE(DATATYPE(DATATYPE(LAST_LITERAL_SCANNED))) = RECORD THEN\n               DO;\n               CURRENT_LEVEL = CURRENT_LEVEL - 1;\n               CALL OPEN_BLOCK (OLD);\n               END;\n            CALL UNSTACK;\n            END;\n   END UNSTACK_QUALIFIER;\n\nWRITEOUT:\n   PROCEDURE;\n   /* THIS PROCEDURE WILL SEND OUT TO DIRECT ACCESS STORAGE THE PARSE TREE\n         FOR A PARSED PASCAL BLOCK.                                    */\n      IF TREE_SIZE < 2 THEN\n         DO;\n            NODE_STACKSIZE, SUBTREE_STACKSIZE = 0;\n            RETURN;\n         END;\n      DO WHILE NODE_STACKSIZE > 0;\n         CALL UNSTACK;\n      END;\n      PARSE_TREE(0) = OWN_MOD;\n      CALL PUNCH_PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE));\n      IF TREE_SIZE > MAX_TREE THEN MAX_TREE = TREE_SIZE;\n      TREE_SIZE = 1;\n      #_OF_TREES = #_OF_TREES + 1;\n   END WRITEOUT;\n\nSTACK_OP:\n   PROCEDURE(OPERATOR);\n      DECLARE OPERATOR FIXED;\n      CALL STACK_NODE(OPERATOR);\n   /* WE'VE ALREADY \"UNSTACK\"-ED ONE OF THE INFIX OPERATOR'S OPERANDS, SO */\n      SUBTREE_INDEX(NODE_STACKSIZE) = SUBTREE_STACKSIZE;\n   END STACK_OP;\n\nSYNTHESIZE:\n   PROCEDURE(PRODUCTION_NUMBER);\n      DECLARE PRODUCTION_NUMBER FIXED;\n      DECLARE LPARENT FIXED INITIAL(240);\n      DECLARE I FIXED;\n\n      UNSTACK_DECLARATION:\n         PROCEDURE;\n            DO;\n               CALL UNSTACK; /* <TYPE> */\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (63<=I & I<=66) | (71<=I & I<=74);\n                  CALL UNSTACK;   /* ARRAY OF ARRAY OF ARRAY ...  (E.G.) */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n            END;\n      END UNSTACK_DECLARATION;\n\n   OPEN_BRACKET:\n      PROCEDURE;\n         NESTING_LEVEL = NESTING_LEVEL + 1;\n         WITHCOUNT(NESTING_LEVEL) = 0;\n      END OPEN_BRACKET;\n\n      CALLCOUNT(1) = CALLCOUNT(1) + 1;\n      IF CONTROL(BYTE('B')) THEN OUTPUT = 'PRODUCTION NUMBER ' ||\n         PRODUCTION_NUMBER || ' APPLIES';\n\n      DO CASE PRODUCTION_NUMBER;\n\n            ; /* CASE 0 IS A DUMMY BECAUSE WE NUMBER PRODUCTIONS FROM 1 */\n\n   /*   1   <PROGRAM>  ::=   <PROGRAM HEADING> <BLOCK> .   */\n            DO;\n               NODE_STACKSIZE, SUBTREE_STACKSIZE = 0;\n               CALL STACK_NODE(NODE_NUMBER);\n            END;\n\n   /*   2   <BLOCK>  ::=   <FIRSTPART> <SECONDPART>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*   3   <FIRSTPART>  ::=   <LABEL DECLS> <CONST DECLS> <TYPE DEFNS>   */\n            ;\n\n   /*   4   <SECONDPART>  ::=   <VAR DECLS> <PROC DECL LIST> <STATEMENT PART>\n        */\n            ;\n\n   /*   5   <STATEMENT PART>  ::=   BEGIN <STATEMENT> <STAT LIST> END   */\n            DO;\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL , TYPE_DECL_PART,IS_DECLARATION  = FALSE ;\n               CALL STACK_NODE(NODE_NUMBER);\n               CALL STACK_NODE(3);\n            END;\n\n   /*   6   <STAT LIST>  ::=   ; <STATEMENT> <STAT LIST>   */\n            DO;\n               CALL UNSTACK;\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (I=13) | (17<=I & I<=23);\n                  CALL UNSTACK;   /* NESTED IF, FOR, WHILE, WITH STATEMENTS */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n            END;\n\n   /*   7   <STAT LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               CALL UNSTACK;\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (I=13) | (17<=I & I<=23);\n                  CALL UNSTACK;   /* NESTED IF, FOR, WHILE, WITH STATEMENTS */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n               CALL UNSTACK;   /* <STAT LIST> */\n            END;\n\n   /*   8   <LABEL DECLS>  ::=   LABEL <UNSIGNED INTEGER> <LABEL LIST> ;   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               LABEL_DECL, IS_DECLARATION = TRUE;\n               VARTYPECODE = LABLE;\n            END;\n\n   /*   9   <LABEL DECLS>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /*  10   <LABEL LIST>  ::=   , <UNSIGNED INTEGER> <LABEL LIST>   */\n            ;\n\n   /*  11   <LABEL LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               LABEL_DECL, IS_DECLARATION = FALSE;\n               CALL UNSTACK;\n            END;\n\n   /*  12   <CONST DECLS>  ::=   CONST <IDENTIFIER> <CONST VALUE PART>   */\n            DO;\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL = FALSE ;\n               CALL STACK_NODE(NODE_NUMBER);\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = CONSTANT;\n            END;\n\n   /*  13   <CONST DECLS>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /*  14   <CONST DECL LIST>  ::=   <IDENTIFIER> <CONST VALUE PART>   */\n            ;\n\n   /*  15   <CONST DECL LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               IS_DECLARATION = FALSE;\n               CALL UNSTACK;\n            END;\n\n   /*  16   <CONST VALUE PART>  ::=   = <CONSTANT> <CONST DECL TAIL>   */\n            IS_DECLARATION = FALSE;\n\n   /*  17   <CONST DECL TAIL>  ::=   ; <CONST DECL LIST>   */\n            IS_DECLARATION = TRUE;\n\n   /*  18   <TYPE DEFNS>  ::=   TYPE <IDENTIFIER> <TYPE DESCRIPTOR PART>   */\n            DO;\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL = FALSE ;\n               CALL STACK_NODE(NODE_NUMBER);\n               TYPE_DECL_PART = TRUE;\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = TYPE;\n            END;\n\n   /*  19   <TYPE DEFNS>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /*  20   <TYPE DEF LIST>  ::=   <IDENTIFIER> <TYPE DESCRIPTOR PART>   */\n            TYPE_DECL_PART = TRUE;\n\n   /*  21   <TYPE DEF LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               IS_DECLARATION = FALSE;\n               TYPE_DECL_PART = FALSE;\n               CALL UNSTACK;\n            END;\n\n\n   /*  22   <TYPE DESCRIPTOR PART>  ::=   = <TYPE> <TYPE DEFN TAIL>   */\n            IS_DECLARATION = FALSE;\n\n   /*  23   <TYPE DEFN TAIL>  ::=   ; <TYPE DEF LIST>   */\n            DO;\n               CALL UNSTACK_DECLARATION;\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = TYPE;\n            END;\n\n   /*  24   <PROC DECL LIST>  ::=   <PROC DECL> <PROC DECL TAIL>   */\n            CALL WRITEOUT;\n\n   /*  25   <PROC DECL LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            CALL WRITEOUT;\n\n   /*  26   <PROC DECL>  ::=   PROCEDURE <IDENTIFIER> <PARAM LIST> ; <BODY>   */\n PROC_DECL : DO ;\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL , TYPE_DECL_PART = FALSE ;\n               CALL STACK_NODE(NODE_NUMBER);\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = PROC;\n            END;\n\n   /*  27   <PROC DECL>  ::=\n      FUNCTION <IDENTIFIER> <PARAM LIST> <RETURNS> ; <BODY>   */\n       GOTO PROC_DECL ;\n\n   /*  28   <BODY>  ::=   <BLOCK>   */\n            CALL WRITEOUT;\n\n   /*  29   <VAR DECLS>  ::=   VAR <ID LIST> : <TYPE> <VAR DECL TAIL>   */\n            DO;\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL , TYPE_DECL_PART = FALSE ;\n               CALL STACK_NODE(NODE_NUMBER);\n               CALL STACK_NODE(12);\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = VARIABLE;\n            END;\n\n   /*  30   <VAR DECLS>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /*  31   <VAR DECL LIST>  ::=   <ID LIST> : <TYPE> <VAR DECL TAIL>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  32   <VAR DECL LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               IS_DECLARATION = FALSE;\n               CALL UNSTACK;\n            END;\n\n   /*  33   <VAR DECL TAIL>  ::=   ; <VAR DECL LIST>   */\n            DO;\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL , TYPE_DECL_PART = FALSE ;\n               CALL UNSTACK_DECLARATION;\n               CALL UNSTACK;  /* <VAR DECL> */\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = VARIABLE;\n            END;\n   /*  34   <ID LIST>  ::=   <IDENTIFIER> <ID LIST 2>   */\n            ;\n\n   /*  35   <ID LIST 2>  ::=   , <ID LIST>   */\n            ;\n\n   /*  36   <ID LIST 2>  ::=   ... EMPTY PRODUCTION ...   */\n            IS_DECLARATION = FALSE;\n\n   /*  37   <STATEMENT>  ::=   <UNSIGNED INTEGER> : <UNLABLED STATEMENT>   */\n            DO;\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL , TYPE_DECL_PART,IS_DECLARATION  = FALSE ;\n               CALL STACK_NODE(NODE_NUMBER);\n               I = CURRENT_LEVEL;\n               J = VAR_TYPE(SYMB_BLOCK_OWNER(I));\n               DO WHILE J \u00ac= PROC;\n                  I = I - 1;\n                  J = VAR_TYPE(SYMB_BLOCK_OWNER(I));\n                  END;\n               LAST_LITERAL_SCANNED = LOOKUP (BCD, I);\n               IF VAR_TYPE(LAST_LITERAL_SCANNED) \u00ac= 9 /* LABEL */ THEN\n                  CALL ERROR('UNDECLARED LABEL ' || BCD, 0);\n            END;\n\n   /*  38   <STATEMENT>  ::=   <UNLABLED STATEMENT>   */\n /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */\n       LABEL_DECL , TYPE_DECL_PART,IS_DECLARATION  = FALSE ;\n\n   /*  39   <UNLABLED STATEMENT>  ::=   <IDENTIFIER> <ID STATEMENT>   */\n       DO; /* TEST IF IT IS A PROCEDURE CALL */\n         IS_PROC_CALL = SHR(IS_PROC_TYPE,VAR_TYPE(LAST_LITERAL_SCANNED)) & 1 ;\n         IF IS_PROC_CALL THEN  CALL STACK_NODE(15) ;\n         ELSE DO;\n           /* IT IS AN ASSIGNMENT STATEMENT */\n           CALL STACK_NODE(NODE_NUMBER);\n           CALL STACK_NODE(51) ; /* VARIABLE */\n         END;\n       END;\n\n   /*  40   <UNLABLED STATEMENT>  ::=   BEGIN <STATEMENT> <STAT LIST> END   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               CALL STACK_NODE(3);\n            END;\n\n   /*  41   <UNLABLED STATEMENT>  ::=\n      IF <EXPRESSION> THEN <STATEMENT> <ELSE PART>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  42   <UNLABLED STATEMENT>  ::=   CASE <EXPRESSION> OF <CASE LIST> END\n        */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  43   <UNLABLED STATEMENT>  ::=   WHILE <EXPRESSION> DO <STATEMENT>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  44   <UNLABLED STATEMENT>  ::=\n      REPEAT <STATEMENT> <STAT LIST> UNTIL <EXPRESSION>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               CALL STACK_NODE(3);\n            END;\n\n   /*  45   <UNLABLED STATEMENT>  ::=\n      FOR <IDENTIFIER> := <EXPRESSION> <FOR STAT 2>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  46   <UNLABLED STATEMENT>  ::=\n      WITH <VARIABLE> <VAR LIST> DO <STATEMENT> <CLOSE>   */\n            DO;\n               IS_WITHBLOCK(NESTING_LEVEL) = TRUE;\n               CALL STACK_NODE(NODE_NUMBER);\n               END;\n\n   /*  47   <UNLABLED STATEMENT>  ::=   GOTO <UNSIGNED INTEGER>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               LABEL_LOOKUP = TRUE;\n            END;\n\n   /*  48   <UNLABLED STATEMENT>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n            END;\n\n   /*  49   <ID STATEMENT>  ::=   := <EXPRESSION>   */\n            DO;\n               IF IS_PROC_CALL THEN DO;  /* ASSIGNMENT TO FUNCTION NAME */\n                  /* AN INSTANCE OF PREDICTIVE PARSING WITH HINDSIGHT */\n                  NODE_STACK(NODE_STACKSIZE) = 14;\n                  CALL STACK_NODE (NODE_NUMBER);\n                  SUBTREE_INDEX(NODE_STACKSIZE) = SUBTREE_STACKSIZE;\n                  IS_PROC_CALL = FALSE;\n                  END;\n               CALL UNSTACK;  /* FOUND A VARIABLE */\n               END;\n\n   /*  50   <ID STATEMENT>  ::=\n      (. <EXPRESSION> <EXP LIST> .) <QUALIFIER> := <EXPRESSION>   */\n ASSIGNMENT : DO ;\n               CALL OPEN_BRACKET;\n               CALL STACK_NODE(NODE_NUMBER);\n               END;\n\n   /*  51   <ID STATEMENT>  ::=   . <IDENTIFIER> <QUALIFIER> := <EXPRESSION>\n        */\n            DO;\n               IS_QUALIFIED_REFERENCE(NESTING_LEVEL) = TRUE;\n               CALL OPEN_BLOCK (OLD);\n               CALL STACK_NODE(NODE_NUMBER);\n               END;\n\n   /*  52   <ID STATEMENT>  ::=   @ <QUALIFIER> := <EXPRESSION>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n               CALL UNSTACK;\n            END;\n\n /* <ID STATEMENT> ::= ( <EXPRESSION> <EXP LIST> ) <ASSIGNMENT PART> */\n       DO;\n         /* TEST IF IT IS A PROCEDURE CALL WITH PARAMETERS */\n         IF IS_PROC_CALL THEN DO;\n           IS_PROC_CALL = FALSE;\n           CALL OPEN_BRACKET ;\n         END;\n         ELSE  /* ASSIGNMENT STATEMENT */\n           GOTO ASSIGNMENT;\n       END;\n\n   /*  54   <ID STATEMENT>  ::=   ... EMPTY PRODUCTION ...   */\n            /* A PARAMETERLESS PROPER PROCEDURE */\n            IS_PROC_CALL = FALSE;\n\n   /*  55   <EXP LIST>  ::=   , <EXPRESSION> <EXP LIST>   */\n            ;\n\n   /*  56   <EXP LIST>  ::=   ... EMPTY PRODUCTION ...   */\n       IF NESTING_LEVEL > 0 THEN\n            NESTING_LEVEL = NESTING_LEVEL - 1;\n\n   /*  57   <ELSE PART>  ::=   ELSE <STATEMENT>   */\n            DO;\n               CALL UNSTACK;   /* THEN STATEMENT */\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (I=13) | (19<=I & I<=23);\n                  CALL UNSTACK;   /* NESTED FOR, WHILE, WITH STATEMENTS */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n            END;\n\n   /*  58   <ELSE PART>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /*  59   <FOR STAT 2>  ::=   DOWNTO <EXPRESSION> DO <STATEMENT>   */\n            NODE_STACK(NODE_STACKSIZE) = 22;\n\n   /*  60   <FOR STAT 2>  ::=   TO <EXPRESSION> DO <STATEMENT>   */\n            ;\n\n   /*  61   <VAR LIST>  ::=   , <VARIABLE> <VAR LIST>   */\n            IF IS_WITHBLOCK(NESTING_LEVEL) THEN\n            WITHCOUNT(NESTING_LEVEL) = WITHCOUNT(NESTING_LEVEL) + 1;\n\n   /*  62   <VAR LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            IF IS_WITHBLOCK(NESTING_LEVEL) THEN DO;\n               WITHCOUNT(NESTING_LEVEL) = WITHCOUNT(NESTING_LEVEL) + 1;\n               CALL OPEN_BRACKET;\n               END;\n\n   /*  63   <PARAM LIST>  ::=   ( <PARAM LIST 1> )   */\n            DO;\n               VARTYPECODE = VARIABLE;\n               CALL OPEN_BRACKET;\n               CALL OPEN_BLOCK (NEW);\n            END;\n\n   /*  64   <PARAM LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               IS_DECLARATION = FALSE;\n               CALL OPEN_BLOCK(BLOCK_CLOSURE_CODE);\n               BLOCK_CLOSURE_CODE = NEW;\n            END;\n\n   /*  65   <PARAM LIST 1>  ::=   <ID LIST> : <IDENTIFIER> <PARAM LIST 2>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  66   <PARAM LIST 1>  ::=   VAR <ID LIST> : <IDENTIFIER> <PARAM LIST 2>\n        */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               VARTYPECODE =    VAR_PARAM;\n            END;\n\n   /*  67   <PARAM LIST 1>  ::=\n      FUNCTION <ID LIST> <PARAM TYPE LIST> : <IDENTIFIER> <PARAM LIST 2>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               VARTYPECODE = PROC_PARAM;\n            END;\n\n   /*  68   <PARAM LIST 1>  ::=\n      PROCEDURE <ID LIST> <PARAM TYPE LIST> <PARAM LIST 2>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               VARTYPECODE = PROC_PARAM;\n            END;\n\n   /*  69   <PARAM LIST 2>  ::=   ; <PARAM LIST 1>   */\n            DO;\n               CALL UNSTACK;\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = VARIABLE;\n            END;\n\n   /*  70   <PARAM LIST 2>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               CALL UNSTACK;\n               NESTING_LEVEL = NESTING_LEVEL - 1;\n               END;\n\n   /*  71   <PARAM TYPE LIST>  ::=   ( <PARAM TYPES> )   */\n            ;\n\n   /*  72   <PARAM TYPE LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n               CALL UNSTACK;\n            END;\n\n   /*  73   <CASE LIST>  ::=\n      <CONSTANT> <CONST LIST> : <STATEMENT> <CASE LIST 2>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  74   <CASE LIST 2>  ::=   ; <CASE LIST>   */\n            DO;\n               IF IS_EMPTY_CASE_INSTANCE THEN\n                  DO;\n                     IS_EMPTY_CASE_INSTANCE = FALSE;\n                     RETURN;\n                  END;\n               CALL UNSTACK; /* STATEMENT */\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (I=13) | (17<=I & I<=23);\n                  CALL UNSTACK;   /* NESTED IF, FOR, WHILE, WITH STATEMENTS */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n               CALL UNSTACK;   /* CASE LIST */\n            END;\n\n   /*  75   <CASE LIST 2>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               IF IS_EMPTY_CASE_INSTANCE THEN\n                  DO;\n                     IS_EMPTY_CASE_INSTANCE = FALSE;\n                     RETURN;\n                  END;\n               CALL UNSTACK; /* STATEMENT */\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (I=13) | (17<=I & I<=23);\n                  CALL UNSTACK;   /* NESTED IF, FOR, WHILE, WITH STATEMENTS */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n               CALL UNSTACK;   /* CASE LIST */\n            END;\n\n   /*  76   <CONST LIST>  ::=   , <CONSTANT> <CONST LIST>   */\n            ;\n\n   /*  77   <CONST LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /*  78   <VARIABLE>  ::=   <IDENTIFIER> <QUALIFIER>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  79   <QUALIFIER>  ::=   (. <EXPRESSION> <EXP LIST> .) <QUALIFIER>   */\n SUBSCRIPT : DO;\n               CALL UNSTACK_QUALIFIER;\n               CALL OPEN_BRACKET;\n               CALL STACK_NODE(NODE_NUMBER);\n            END;\n\n   /*  80   <QUALIFIER>  ::=   . <IDENTIFIER> <QUALIFIER>   */\n            DO;\n               CALL UNSTACK_QUALIFIER;\n               IF \u00acIS_QUALIFIED_REFERENCE(NESTING_LEVEL) THEN DO;\n                  CALL OPEN_BLOCK (OLD);\n                  IS_QUALIFIED_REFERENCE(NESTING_LEVEL) = TRUE;\n                  END;\n               CALL STACK_NODE(NODE_NUMBER);\n            END;\n\n   /*  81   <QUALIFIER>  ::=   @ <QUALIFIER>   */\n            DO;\n               CALL UNSTACK_QUALIFIER;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n               CALL UNSTACK;\n            END;\n\n   /*  82   <QUALIFIER>  ::=   ... EMPTY PRODUCTION ...   */\n            IF IS_FUNC_CALL(NESTING_LEVEL) THEN\n               IS_FUNC_CALL(NESTING_LEVEL) = FALSE;\n            ELSE\n            DO;\n               CALL UNSTACK_QUALIFIER;\n               IF IS_QUALIFIED_REFERENCE(NESTING_LEVEL) THEN DO;\n                  IF \u00acIS_WITHBLOCK(NESTING_LEVEL) THEN\n                     CALL CLOSE_BLOCK (OLD);\n                  IS_QUALIFIED_REFERENCE(NESTING_LEVEL) = FALSE;\n                  END;\n               ELSE IF IS_WITHBLOCK(NESTING_LEVEL) THEN\n                  CALL OPEN_BLOCK (OLD);\n               CALL UNSTACK;   /* FOUND A VARIABLE */\n            END;\n\n   /*  83   <SIMPLE TYPE>  ::=   <IDENTIFIER> <SIMPLE TYPE 1>   */\n            DO;\n               CALL ASSOCIATE_TYPE_WITH_ID;\n               CALL STACK_NODE(NODE_NUMBER);\n               END;\n\n   /*  84   <SIMPLE TYPE>  ::=   ( <ID LIST> )   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = CONSTANT;\n            END;\n\n   /*  85   <SIMPLE TYPE>  ::=   + <CONSTANT 1> .. <SIGN> <CONSTANT 1>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  86   <SIMPLE TYPE>  ::=   - <CONSTANT 1> .. <SIGN> <CONSTANT 1>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               MINUS_FLAG = TRUE;\n            END;\n\n   /*  87   <SIMPLE TYPE>  ::=   <UNSIGNED INTEGER> .. <SIGN> <CONSTANT 1>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  88   <SIMPLE TYPE>  ::=   <STRING> .. <SIMPLE TYPE 3>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /*  89   <SIMPLE TYPE 1>  ::=   .. <SIMPLE TYPE 2>   */\n            NODE_STACK(NODE_STACKSIZE) = 61;\n\n   /*  90   <SIMPLE TYPE 1>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /*  91   <SIMPLE TYPE 2>  ::=   <SIGN> <CONSTANT 1>   */\n            ;\n\n   /*  92   <SIMPLE TYPE 2>  ::=   <STRING>   */\n            ;\n\n   /*  93   <SIMPLE TYPE 3>  ::=   <IDENTIFIER>   */\n            ;\n\n   /*  94   <SIMPLE TYPE 3>  ::=   <STRING>   */\n            ;\n\n   /*  95   <CONSTANT 1>  ::=   <IDENTIFIER>   */\n            ;\n\n   /*  96   <CONSTANT 1>  ::=   <UNSIGNED INTEGER>   */\n            ;\n\n   /*  97   <TYPE>  ::=   <SIMPLE TYPE>   */\n            ;\n\n   /*  98   <TYPE>  ::=   @ <TYPE IDENTIFIER>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               IS_FORWARD_DECL = TRUE;\n               END;\n\n   /*  99   <TYPE>  ::=   <STRUC TYPE>   */\n            ;\n\n   /* 100   <TYPE>  ::=   PACKED <STRUC TYPE>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n /* 101 <STRUC TYPE> ::= ARRAY  <INDEX  AND  ELEMENTS  TYPE> */\n            IF NODE_STACK(NODE_STACKSIZE) = 73 THEN\n               NODE_STACK(NODE_STACKSIZE) = 71;\n            ELSE\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 102   <STRUC TYPE>  ::=   FILE OF <TYPE>   */\n            IF NODE_STACK(NODE_STACKSIZE) = 73 THEN\n               NODE_STACK(NODE_STACKSIZE) = 72;\n            ELSE\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 103   <STRUC TYPE>  ::=   SET OF <SIMPLE TYPE>   */\n            IF NODE_STACK(NODE_STACKSIZE)\u00ac= 73 THEN\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 104   <STRUC TYPE>  ::=   RECORD <FIELD LIST> <RECORD ENDINGS   */\n            DO;\n               IF \u00acTYPE_DECL_PART THEN DO;\n                  /* CREATE A DUMMY TYPE IDENTIFIER IN THE SYMBOL TABLE */\n                  DUMMY_NAME# = DUMMY_NAME# + 1;\n                  LAST_LITERAL_SCANNED =  ENTER_SYMBOL ('$RECORD' ||\n                                         DUMMY_NAME#, CURRENT_LEVEL);\n                  END;\n               VAR_TYPE(LAST_LITERAL_SCANNED) = RECORD;\n               VALUE(LAST_LITERAL_SCANNED) = CURRENT_BLOCK + 1;\n               CALL ASSOCIATE_TYPE_WITH_ID;\n               TYPE_DECL_PART = FALSE;\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = FIELD_ID;\n            IF NODE_STACK(NODE_STACKSIZE) = 73 THEN\n               NODE_STACK(NODE_STACKSIZE) = 74;\n               ELSE CALL STACK_NODE(NODE_NUMBER);\n               CALL OPEN_BLOCK (NEW);\n            END;\n\n   /* 105   <SIMPLE TYPE LIST>  ::=   , <SIMPLE TYPE> <SIMPLE TYPE LIST>   */\n            DO;\n               CALL UNSTACK;\n               CALL STACK_NODE(NODE_STACK(NODE_STACKSIZE));\n            END;\n\n   /* 106   <SIMPLE TYPE LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            CALL UNSTACK;\n\n   /* 107   <FIELD LIST>  ::=   <ID LIST> : <TYPE> <NEXT FIELD>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 108   <FIELD LIST>  ::=\n      CASE <IDENTIFIER> : <IDENTIFIER> OF <VARIANT INSTANCE> <VARIANT INSTANCE L\n        */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               VARTYPECODE = VARIANT;\n            END;\n\n   /* 109   <NEXT FIELD>  ::=   ; <FIELD LIST>   */\n            DO;\n               IF IS_EMPTY_FIELD_LIST THEN\n                     DO;\n                        IS_EMPTY_FIELD_LIST = FALSE;\n                        RETURN;\n                     END;\n               CALL UNSTACK;   /* <TYPE> */\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = FIELD_ID;\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (63<=I & I<=66) | (71<=I & I<=74);\n                  CALL UNSTACK;   /* ARRAY OF ARRAY OF ARRAY ...  (E.G.) */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n               CALL UNSTACK;   /* <FIXED FIELD> */\n            END;\n\n   /* 110   <NEXT FIELD>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               IF IS_EMPTY_FIELD_LIST THEN\n                     DO;\n                        IS_EMPTY_FIELD_LIST = FALSE;\n                        RETURN;\n                     END;\n               CALL UNSTACK;   /* <TYPE> */\n               I = NODE_STACK(NODE_STACKSIZE);\n               DO WHILE (63<=I & I<=66) | (71<=I & I<=74);\n                  CALL UNSTACK;   /* ARRAY OF ARRAY OF ARRAY ...  (E.G.) */\n                  I = NODE_STACK(NODE_STACKSIZE);\n               END;\n               CALL UNSTACK;   /* <FIXED FIELD> */\n            END;\n\n   /* 111   <TAG IDENT>  ::=   <IDENTIFIER>   */\n            IS_DECLARATION = FALSE;\n\n   /* 112   <VARIANT INSTANCE LIST>  ::=\n      ; <VARIANT INSTANCE> <VARIANT INSTANCE LIST>   */\n            DO;\n               IF IS_EMPTY_CASE_INSTANCE THEN\n                  IS_EMPTY_CASE_INSTANCE = FALSE;\n               ELSE\n                  DO;\n                     CALL UNSTACK;   /* 66 <TYPE> */\n                     CALL UNSTACK;   /* LAST <VARIANT INSTANCE> */\n                  END;\n            END;\n\n   /* 113   <VARIANT INSTANCE LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               IF IS_EMPTY_CASE_INSTANCE THEN\n                  IS_EMPTY_CASE_INSTANCE = FALSE;\n               ELSE\n                  DO;\n                     CALL UNSTACK;   /* 66 <TYPE> */\n                     CALL UNSTACK;   /* LAST <VARIANT INSTANCE> */\n                  END;\n               CALL UNSTACK;   /* <VARIANT FIELD> */\n            END;\n\n   /* 114   <VARIANT INSTANCE>  ::=\n      <CONSTANT> <CONST LIST> : <VARIANT INSTANCE 2>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 115   <VARIANT INSTANCE 2>  ::=   ( <FIELD LIST> )   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = FIELD_ID;\n            END;\n\n   /* 116   <CONSTANT>  ::=   <STRING>   */\n            ;\n\n   /* 117   <CONSTANT>  ::=   <SIGN> <CONSTANT 2>   */\n            ;\n\n   /* 118   <CONSTANT 2>  ::=   <IDENTIFIER>   */\n            ;\n\n   /* 119   <CONSTANT 2>  ::=   <UNSIGNED INTEGER>   */\n            ;\n\n   /* 120   <CONSTANT 2>  ::=   <UNSIGNED REAL>   */\n            ;\n\n   /* 121   <SIGN>  ::=   +   */\n            ;\n\n   /* 122   <SIGN>  ::=   -   */\n            MINUS_FLAG = TRUE;\n\n   /* 123   <SIGN>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /* 124   <EXPRESSION>  ::=   <SIMPLE EXPRESSION> <EXPRESSION 2>   */\n            ;\n\n   /* 125   <EXPRESSION 2>  ::=   <RELOP> <SIMPLE EXPRESSION>   */\n            ;\n\n   /* 126   <EXPRESSION 2>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /* 127   <RELOP>  ::=   =   */\n            CALL STACK_OP(32);\n\n   /* 128   <RELOP>  ::=   <   */\n            CALL STACK_OP(33);\n\n   /* 129   <RELOP>  ::=   >   */\n            CALL STACK_OP(34);\n\n   /* 130   <RELOP>  ::=   <>   */\n            CALL STACK_OP(35);\n\n   /* 131   <RELOP>  ::=   <=   */\n            CALL STACK_OP(36);\n\n   /* 132   <RELOP>  ::=   >=   */\n            CALL STACK_OP(37);\n\n   /* 133   <RELOP>  ::=   IN   */\n            CALL STACK_OP(38);\n\n   /* 134   <SIMPLE EXPRESSION>  ::=   + <TERM> <SIMPLE EXPRESSION 2>   */\n            ;\n\n   /* 135   <SIMPLE EXPRESSION>  ::=   - <TERM> <SIMPLE EXPRESSION 2>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 136   <SIMPLE EXPRESSION>  ::=   <TERM> <SIMPLE EXPRESSION 2>   */\n            ;\n\n   /* 137   <SIMPLE EXPRESSION 2>  ::=   <ADDOP> <TERM> <SIMPLE EXPRESSION 2>\n        */\n            DO WHILE (39 <= NODE_STACK(NODE_STACKSIZE)\n                      & NODE_STACK(NODE_STACKSIZE) <= 41)\n                  | NODE_STACK(NODE_STACKSIZE) = 30;\n                  CALL UNSTACK;\n            END;\n\n   /* 138   <SIMPLE EXPRESSION 2>  ::=   ... EMPTY PRODUCTION ...   */\n            DO WHILE (32 <= NODE_STACK(NODE_STACKSIZE)\n                      & NODE_STACK(NODE_STACKSIZE) <= 41)\n                  | NODE_STACK(NODE_STACKSIZE) = 30;\n                  CALL UNSTACK;\n            END;\n\n   /* 139   <ADDOP>  ::=   +   */\n            CALL STACK_OP(39);\n\n   /* 140   <ADDOP>  ::=   -   */\n            CALL STACK_OP(40);\n\n   /* 141   <ADDOP>  ::=   OR   */\n            CALL STACK_OP(41);\n\n   /* 142   <TERM>  ::=   <FACTOR> <TERM 2>   */\n            ;\n\n   /* 143   <TERM 2>  ::=   <MULOP> <FACTOR> <TERM 2>   */\n         TERM_2:\n            DO;\n               IF (47 <= NODE_STACK(NODE_STACKSIZE)\n                   & NODE_STACK(NODE_STACKSIZE) <= 50)\n                  THEN CALL UNSTACK;   /* FOUND A <FACTOR> */\n               DO WHILE NODE_STACK(NODE_STACKSIZE) = 31;\n                  CALL UNSTACK;   /* UNARY \u00ac'S */\n               END;\n               DO WHILE 42 <= NODE_STACK(NODE_STACKSIZE)\n                        & NODE_STACK(NODE_STACKSIZE) <= 46;\n                  CALL UNSTACK;   /* <TERM> */\n               END;\n            END;\n\n   /* 144   <TERM 2>  ::=   ... EMPTY PRODUCTION ...   */\n            GOTO TERM_2;\n\n   /* 145   <MULOP>  ::=   *   */\n            CALL STACK_OP(42);\n\n   /* 146   <MULOP>  ::=   /   */\n            CALL STACK_OP(43);\n\n   /* 147   <MULOP>  ::=   DIV   */\n            CALL STACK_OP(44);\n\n   /* 148   <MULOP>  ::=   MOD   */\n            CALL STACK_OP(45);\n\n   /* 149   <MULOP>  ::=   AND   */\n            CALL STACK_OP(46);\n\n   /* 150   <FACTOR>  ::=   <IDENTIFIER> <FACTOR 2>   */\n       DO ; /* CHECK IF IT IS A FUNCTION CALL  */\n               IS_FUNC_CALL(NESTING_LEVEL) =\n                  SHR (IS_PROC_TYPE, VAR_TYPE(LAST_LITERAL_SCANNED)) & 1;\n               IF IS_FUNC_CALL(NESTING_LEVEL) THEN CALL STACK_NODE(47);\n         ELSE  DO ; /* IT IS A VARIABLE */\n               CALL STACK_NODE(NODE_NUMBER);\n               CALL STACK_NODE(51);\n            END;\n       END ;\n\n   /* 151   <FACTOR>  ::=   ( <EXPRESSION> <RPARENT>   */\n            DO;\n               CALL STACK_NODE(LPARENT);\n               CALL OPEN_BRACKET;\n               END;\n\n   /* 152   <FACTOR>  ::=   NOT <FACTOR>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 153   <FACTOR>  ::=   (. <ELEMENTS> .)   */\n            CALL OPEN_BRACKET;\n\n   /* 154   <FACTOR>  ::=   <UNSIGNED INTEGER>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 155   <FACTOR>  ::=   <UNSIGNED REAL>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 156   <FACTOR>  ::=   <STRING>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 157   <FACTOR>  ::=   NIL   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = GET_NODE(0);\n               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE) + 1) = 2;\n               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE) + 2) = CARD_COUNT;\n            END;\n\n   /* 158   <FACTOR 2>  ::=   <QUALIFIER>   */\n            ;\n\n /* 159 <QUALIFIER>::= ( <EXPRESSION> <EXP LIST> ) <QUALIFIER> */\n       DO;\n         /* TEST IF IT IS A FUNCTION CALL */\n               IF IS_FUNC_CALL(NESTING_LEVEL) THEN\n           CALL OPEN_BRACKET ;\n         ELSE /* IT IS A SUBSCRIPTED VARIABLE  */\n           GOTO SUBSCRIPT ;\n       END;\n\n   /* 160   <ELEMENTS>  ::=   <EXPRESSION> <ELEMENTS 2> <ELEMENT LIST>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               CALL STACK_NODE(75);\n            END;\n\n   /* 161   <ELEMENTS>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = GET_NODE(0);\n               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE)+1) = 3;\n               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE)+2) = CARD_COUNT;\n               NESTING_LEVEL = NESTING_LEVEL - 1;\n            END;\n\n   /* 162   <RPARENT>  ::=   )   */\n            DO;\n               DO WHILE NODE_STACKSIZE > 0 &\n                        NODE_STACK(NODE_STACKSIZE) \u00ac= LPARENT;\n                  CALL UNSTACK;\n               END;\n               NODE_STACKSIZE = NODE_STACKSIZE - 1;\n               NESTING_LEVEL = NESTING_LEVEL - 1;\n            END;\n\n   /* 163   <PROGRAM HEADING>  ::=   PROGRAM <IDENTIFIER> <PROGRAM HEADING TAIL>\n        */\n            DO;\n               IS_DECLARATION = TRUE;\n               VARTYPECODE = PROC;\n            END;\n\n   /* 164   <RETURNS>  ::=   : <TYPE IDENTIFIER>   */\n            ;\n\n   /* 165   <RETURNS>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /* 166   <BODY>  ::=   FORWARD   */\n            DO;\n               CALL WRITEOUT;\n               VALUE(OWN_MOD) = CURRENT_BLOCK;\n               VAR_TYPE(OWN_MOD) = FORWARD;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n               CALL UNSTACK;\n               CALL WRITEOUT;\n               BLOCK_CLOSURE_CODE = OLD;\n            END;\n\n   /* 167   <CASE LIST>  ::=   <CASE LIST 2>   */\n            IS_EMPTY_CASE_INSTANCE = TRUE;\n\n   /* 168   <FIELD LIST>  ::=   <NEXT FIELD>   */\n            DO;\n               IS_DECLARATION = FALSE;\n               IS_EMPTY_FIELD_LIST = TRUE;\n            END;\n\n   /* 169   <VARIANT INSTANCE>  ::=   ... EMPTY PRODUCTION ...   */\n            IS_EMPTY_CASE_INSTANCE = TRUE;\n\n   /* 170   <ELEMENTS 2>  ::=   .. <EXPRESSION>   */\n            NODE_STACK(NODE_STACKSIZE) = 76;\n\n   /* 171   <ELEMENTS 2>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /* 172   <ELEMENT LIST>  ::=   , <EXPRESSION> <ELEMENTS 2> <ELEMENT LIST>\n        */\n            DO;\n               CALL UNSTACK;\n               CALL STACK_NODE(NODE_NUMBER);\n            END;\n\n   /* 173   <ELEMENT LIST>  ::=   ... EMPTY PRODUCTION ...   */\n            DO;\n               CALL UNSTACK;\n               NESTING_LEVEL = NESTING_LEVEL - 1;\n               END;\n\n   /* 174   <PARAM TYPES>  ::=   <ID LIST> <PARAM TYPES TAIL>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 175   <PARAM TYPES>  ::=   VAR <ID LIST> <PARAM TYPES TAIL>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 176   <PARAM TYPES>  ::=   FUNCTION <FUNC TYPES> <PARAM TYPES TAIL>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 177   <PARAM TYPES>  ::=   PROCEDURE <PROC TYPES> <PARAM TYPES TAIL>   */\n               CALL STACK_NODE(NODE_NUMBER);\n\n   /* 178   <PARAM TYPES>  ::=   <PARAM TYPES TAIL>   */\n            DO;\n               CALL STACK_NODE(NODE_NUMBER);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n            END;\n\n   /* 179   <PARAM TYPES TAIL>  ::=   ... EMPTY PRODUCTION ...   */\n            CALL UNSTACK;\n\n   /* 180   <PARAM TYPES TAIL>  ::=   ; <PARAM TYPES>   */\n            CALL UNSTACK;\n\n   /* 181   <PROGRAM HEADING TAIL>  ::=   ( <ID LIST> ) <SEMICOLON>   */\n            DO;\n               IS_DECLARATION = FALSE;\n               /*  MAKE THE PROGRAM NAME UN-REFERENCEABLE AND\n               **  RE-INITIALIZE THE BLOCK COUNT AND LEXICAL LEVEL */\n               IDENTITY(LAST_LITERAL_SCANNED) = DOLLAR ||\n                        IDENTITY(LAST_LITERAL_SCANNED);\n               CURRENT_BLOCK, CURRENT_LEVEL = 0;\n               CALL OPEN_BLOCK (NEW);\n               IS_FORWARD_DECL = TRUE;\n            END;\n\n   /* 182   <SEMICOLON>  ::=   ;   */\n            DO;\n               IS_FORWARD_DECL = FALSE;\n               CALL WRITEOUT;\n               END;\n\n   /* 183   <PROC DECL TAIL>  ::=   ; <PROC DECL LIST>   */\n            DO;\n               CALL CLOSE_BLOCK (BLOCK_CLOSURE_CODE);\n               BLOCK_CLOSURE_CODE = NEW;\n               END;\n\n   /* 184   <FUNC TYPES>  ::=\n      ( <PARAM TYPES> ) : <IDENTIFIER> <FUNC TYPES TAIL>   */\n            ;\n\n   /* 185   <FUNC TYPES TAIL>  ::=   , <FUNC TYPES>   */\n            DO;\n               CALL UNSTACK;\n               CALL STACK_NODE(NODE_NUMBER);\n            END;\n\n   /* 186   <FUNC TYPES TAIL>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n\n   /* 187   <PROC TYPES>  ::=   ( <PARAM TYPES> ) <PROC TYPES TAIL>   */\n            ;\n\n   /* 188   <PROC TYPES TAIL>  ::=   , <PROC TYPES>   */\n            DO;\n               CALL UNSTACK;\n               CALL STACK_NODE(NODE_NUMBER);\n            END;\n\n   /* 189   <PROC TYPES TAIL>  ::=   ... EMPTY PRODUCTION ...   */\n            ;\n   /* 190   <CLOSE>  ::=   ....EMPTY PRODUCTION ...   */\n            DO;\n               NESTING_LEVEL = NESTING_LEVEL - 1;\n               DO I = 1 TO WITHCOUNT(NESTING_LEVEL);\n                  CALL CLOSE_BLOCK (OLD);\n                  END;\n               IS_WITHBLOCK(NESTING_LEVEL) = FALSE;\n               WITHCOUNT(NESTING_LEVEL) = 0;\n               END;\n\n   /* 191   <TYPE IDENTIFIER>  ::=   <IDENTIFIER>   */\n            DO;\n               IS_FORWARD_DECL = FALSE;\n               CALL ASSOCIATE_TYPE_WITH_ID;\n               END;\n\n   /* 192   <RECORD ENDING>  ::=   END   */\n            CALL CLOSE_BLOCK(OLD);\n\n /* 193 .. 212 ARE PRODUCTIONS FOR ERROR RECOVERY */\n   /* 193   <DUMMY FOR STAT>  ::=   <FOR STAT 2>   */\n      ;\n   /* 194   <DUMMY FOR STAT>  ::=   ... EMPTY PRODUCTION ...   */\n      ;\n   /* 195   <DUMMY ENDING>  ::=   END   */\n      ;\n   /* 196   <DUMMY ENDING>  ::=   ... EMPTY PRODUCTION ...   */\n      ;\n   /* 197   <DUMMYBLOCK>  ::=   <BLOCK>   */\n      ;\n   /* 198   <DUMMYBLOCK>  ::=   ... EMPTY PRODUCTION ...   */\n      ;\n   /* 199   <SEMICOLON1>  ::=   ;   */\n      ;\n   /* 200   <DUMMY FIELD>  ::=   <TYPE> <NEXT FIELD>   */\n      CALL STACK_NODE(ERROR_NODE);\n   /* 201   <DUMMY STATEMENT TAIL>  ::=   OF <CASE LIST> END   */\n      CALL STACK_NODE(ERROR_NODE);\n   /* 202   <DUMMY STATEMENT TAIL>  ::=   DO <STATEMENT>   */\n      CALL STACK_NODE(ERROR_NODE);\n   /* 203   <DUMMY STATEMENT TAIL>  ::=   <FOR STAT 2>   */\n      CALL STACK_NODE(ERROR_NODE);\n   /* 204   <DUMMY STATEMENT TAIL>  ::=   ... EMPTY PRODUCTION ...   */\n      ;\n   /* 205   <DUMMY VAR DECL BODY>  ::=   : <TYPE> <VAR DECL TAIL>   */\n      CALL STACK_NODE(ERROR_NODE);\n   /* 206   <DUMMY TYPE BODY>  ::=   <TYPE DESCRIPTOR PART>   */\n      CALL STACK_NODE(ERROR_NODE);\n   /* 207   <DUMMY TYPE BODY>  ::=   <TYPE> <TYPE DEFN TAIL>   */\n      CALL STACK_NODE(ERROR_NODE);\n   /* 208   <ASSIGNMENT     PART>  ::=   <QUALIFIER> := <EXPRESSION>   */\n      ;\n   /* 209   <ASSIGNMENT     PART>  ::=   ... EMPTY PRODUCTION ...   */\n      ;\n   /* 210   <INDEX  AND  ELEMENTS  TYPE>  ::=\n      (. <SIMPLE TYPE> <SIMPLE TYPE LIST> .) OF <TYPE>   */\n      ;\n   /* 211   <INDEX  AND  ELEMENTS  TYPE>  ::=\n      ( <SIMPLE TYPE> <SIMPLE TYPE LIST> ) OF <TYPE>   */\n      ;\n   /* 212   <DUMMY STATEMENT TAIL>  ::=   THEN <STATEMENT> <ELSE PART>   */\n      CALL STACK_NODE(ERROR_NODE);\n /*  213  ERROR NODE  CASE  */\n            DO; /* FORCE AN ERROR SUBTREE ONTO THE SUBTREE STACK */\n               CALL STACK_NODE (ERROR_NODE);\n               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n               SUBTREE_STACK (SUBTREE_STACKSIZE) = NULL;\n               CALL UNSTACK;\n               END;\n\n      END;   /* OF DO CASE */\n\n   END SYNTHESIZE;\n\n\n\n\n /*         STRONG LL(1) ANALYSIS ALGORITHM                   */\n\n\n\n   /*              A PUSHDOWN STACK IN A PARSER\n                   IS A LIFO QUEUE IN O.R., SIR.\n                   YOU MAY CALL IT A 'TRAY STACK'\n                   OR EVEN A HAYSTACK\n                   BUT CALLING IT 'GEORGE' IS TOO FAR, SIR.\n\n                         -- PETER KUGEL             */\n\n\n\nCOMPILATION_LOOP:  PROCEDURE;\n   DECLARE (I, INDEX, STACKTOP, LGTH, RANGE) FIXED,\n            PRODUCTION_NUMBER FIXED,\n              TOKENS_OUT(NT) BIT(8),\n            FOUND_PROD BIT(1);\n  DECLARE  ( TOKEN_SUPPLIED,SUCCESSFUL_INSERTION) BIT(1),PREVIOUS_TOKEN FIXED;\n   DECLARE  FOUND_SPELLING_ERROR BIT(1), TOKEN_MISSPELT FIXED;\n  DECLARE BRACKET_COUNT BIT(1);\n   DECLARE (TOKEN_EXPECTED, #_EXPECTED_TOKENS ) FIXED;\n DECLARE (SEMI_COLON_OK,RIGHT_PAREN_OK) BIT(1);\n\n\n\n\n\n\n   GET_TOKEN:  PROCEDURE;  /* TO CALL THE LEXICAL ANALYZER  */\n      DECLARE I FIXED;\n      IF (TOKEN=IDENT) | (TOKEN=STRING) | (TOKEN=INTCONST) | (TOKEN=REALCONST)\n         THEN DO;\n            IF MINUS_FLAG THEN\n               DO;\n                    IF TOKEN=REALCONST THEN\n                      NUMBER_VALUE =NUMBER_VALUE | \"80000000\";\n                  ELSE IF TOKEN = INTCONST THEN NUMBER_VALUE = - NUMBER_VALUE;\n                  IF TOKEN \u00ac= IDENT THEN\n                     DO;\n                        MINUS_FLAG = FALSE;\n                        LAST_LITERAL_SCANNED = LOOKUP_LITERAL(BCD);\n                     END;\n                  ELSE CALL STACK_NODE(58);\n               END;\n            SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n            IF SUBTREE_STACKSIZE > STACKSIZE THEN\n               DO;\n                  CALL ERROR('SEMANTIC STACK OVERFLOW',1);\n                  COMPILING = FALSE;\n                  RETURN;\n               END;\n            I = GET_NODE(0);\n            SUBTREE_STACK(SUBTREE_STACKSIZE) = I;\n            PARSE_TREE(I+1) = LAST_LITERAL_SCANNED;\n            PARSE_TREE(I+2) = CARD_COUNT;\n            IF NODE_STACK(NODE_STACKSIZE) = 58 THEN CALL UNSTACK;\n            IF MINUS_FLAG THEN\n               DO;\n                  CALL UNSTACK;\n                  MINUS_FLAG = FALSE;\n               END;\n         END;\n      SUCCESSFUL_INSERTION=TRUE;\n      IF TOKEN_SUPPLIED THEN DO;\n        I=TOKEN;\n        TOKEN=PREVIOUS_TOKEN;\n        PREVIOUS_TOKEN=I;\n        TOKEN_SUPPLIED=FALSE;\n        SUCCESSFUL_INSERTION=FALSE;\n        RETURN;\n      END;\n       PREVIOUS_TOKEN=TOKEN;\n      CALL  SCAN;\n        IF MONITOR_LINK(2)  >= 2 THEN\n      CALL PARAGRAPH;\n      DO CASE LOOKUP_TYPE(TOKEN);\n         /*   CASE 0 -- NO LOOKUP  */\n            ;\n         /*   CASE 1 -- IDENTIFIER  */\n            LAST_LITERAL_SCANNED = LOOKUP(BCD, 0);\n         /*   CASE 2 -- STRING OR ARITHMETIC CONSTANT  */\n            LAST_LITERAL_SCANNED = LOOKUP_LITERAL (BCD);\n         END;  /* CASE ON LOOKUP_TYPE */\n   END GET_TOKEN;\n\n\n   /*                        ERROR RECOVERY PROCEDURES                */\n\n\n\n\n IS_RESERVED_WORD : PROCEDURE(I)  BIT(1);\n   DECLARE I FIXED;\n   RETURN (SHL(BYTE(RESERVED_WORDS,SHR(I,3)) ,I& \"07\" ) & \"80\" ) \u00ac = 0;\n END IS_RESERVED_WORD;\n\n\n CHECK_FOR_SPELLING_ERROR : PROCEDURE(I);\n  DECLARE I FIXED;\n   DECLARE (X,Y,Z,J) FIXED,MATCH BIT(1),(STRING1,STRING2) CHARACTER ;\n   IF \u00ac(IS_RESERVED_WORD(I) & (TOKEN=IDENT)) THEN RETURN;\n   IF LENGTH(V(TOKEN)) > 1 THEN DO;\n     STRING1 = V(I);\n     X=LENGTH(BCD); Y= LENGTH(STRING1);\n     IF ( (X-Y) >1 ) | ( (Y-X) > 1 )  THEN RETURN ;\n     Z=Y; IF   X<Z THEN Z=X;\n     J=0; MATCH=TRUE;\n     DO WHILE  (J< Z) & MATCH ;\n       IF SUBSTR(BCD,J,1) = SUBSTR(STRING1,J,1) THEN  J=J+1;\n       ELSE  MATCH = FALSE;\n       END;\n     IF MATCH  THEN DO;\n       FOUND_SPELLING_ERROR = TRUE;\n       TOKEN_MISSPELT = I;\n       RETURN;\n       END;\n     IF X=Y THEN DO;\n       STRING2 = SUBSTR(STRING1,J+1);\n       STRING1 = SUBSTR(BCD,J+1);\n       J=J+1;\n       END;\n     ELSE IF  X>Y THEN DO;\n              STRING2 = SUBSTR(STRING1,J);\n              STRING1 = SUBSTR(BCD,J+1);\n              END;\n          ELSE DO;\n              STRING2 = SUBSTR(STRING1,J+1);\n              STRING1 = SUBSTR(BCD,J);\n              END;\n     Z = Z-J; J=0; MATCH = TRUE;\n     DO WHILE (J< Z) & MATCH ;\n       IF SUBSTR(STRING1,J,1) = SUBSTR(STRING2,J,1) THEN J=J+1;\n       ELSE MATCH = FALSE;\n       END;\n     IF MATCH THEN DO;\n       FOUND_SPELLING_ERROR = TRUE;\n       TOKEN_MISSPELT = I;\n       END;\n     END;\n END CHECK_FOR_SPELLING_ERROR;\n\n\n DIAGNOSE_ERROR : PROCEDURE;\n      DECLARE L FIXED;\n      DECLARE (I, J, K, S, T) FIXED,\n              (CHECK_NEXT, INCLUDE_TOKEN) BIT(1),\n              LINE CHARACTER;\n      IF STACKTOP <= NT THEN DO;\n        #_EXPECTED_TOKENS = 1;\n         TOKEN_EXPECTED = STACKTOP;\n         RETURN;\n         END;\n\n      /*  STACKTOP IS A NONTERMINAL  */\n      #_EXPECTED_TOKENS = 0;  J = -1;\n      FOUND_SPELLING_ERROR, SEMI_COLON_OK, RIGHT_PAREN_OK = FALSE;\n      CHECK_NEXT = TRUE;\n      S = SP;\n      DO WHILE CHECK_NEXT;\n         T = PARSE_STACK(S);\n         IF T <= NT THEN DO;\n            J = J + 1;\n            TOKENS_OUT(J) = T;\n            IF \u00acFOUND_SPELLING_ERROR THEN CALL CHECK_FOR_SPELLING_ERROR (T);\n            CHECK_NEXT = FALSE;\n            END;\n         ELSE DO;\n            L = T - NT1 ;\n            CHECK_NEXT = PRODUCES_EMPTY(L);\n            DO I = TERMINAL_HEADS_INDEX(L) TO TERMINAL_HEADS_INDEX(L+1) - 1;\n               INCLUDE_TOKEN = TRUE;\n               T = TERMINAL_HEADS(I);\n               DO K = 0 TO J;\n                  IF T = TOKENS_OUT(K) THEN INCLUDE_TOKEN = FALSE;\n                  END;\n               IF INCLUDE_TOKEN THEN DO;\n                  J = J + 1;\n                  TOKENS_OUT(J) = T;\n                  IF \u00acFOUND_SPELLING_ERROR THEN CALL CHECK_FOR_SPELLING_ERROR(T)\n                     ;\n                  #_EXPECTED_TOKENS = #_EXPECTED_TOKENS + 1;\n                  IF T = SEMI_COLON THEN SEMI_COLON_OK = TRUE;\n                  ELSE IF T = RIGHT_PAREN THEN RIGHT_PAREN_OK = TRUE;\n                  END;\n               END;\n            END;\n         S = S - 1;\n         END;\n\n      LINE = SUBSTR (X70, 0, 30);\n      DO I = 0 TO J;\n         LINE = LINE || V(TOKENS_OUT(I)) ||X1;\n         END;\n   OUTPUT = LINE;\n END DIAGNOSE_ERROR;\n\n\n\n\n\n IS_BLOCK_HEAD : PROCEDURE(I) BIT(1);\n       DECLARE I FIXED;\n       RETURN  (SHL( BYTE( BLOCK_HEADS,SHR(I,3)), I & \"07\" ) & \"80\" )\u00ac=0;\n END  IS_BLOCK_HEAD;\n\n\n\n IS_RECOVER_SYMBOL : PROCEDURE(I) BIT(1);\n       DECLARE  I  FIXED;\n       IF  I<=NT THEN  RETURN FALSE;\n       I=I-NT;\n       RETURN (SHL(BYTE(RECOVERY_SYMBOLS,SHR(I,3)),I & \"07\") & \"80\") \u00ac= 0;\n END  IS_RECOVER_SYMBOL;\n\n\n\n\n\n IS_CRASH_SCAN_SYMBOL : PROCEDURE(I) BIT(1);\n       DECLARE I FIXED;\n       RETURN  ( SHL(BYTE( CRASH_SCAN_SYMBOLS,SHR(I,3)),I & \"07\") & \"80\")\u00ac=0;\n END IS_CRASH_SCAN_SYMBOL;\n\n\n\n\n\n\n\n IS_EXPECTED : PROCEDURE (I,J) BIT(1);\n      DECLARE (I,J,K) FIXED;\n      IF J<=NT  THEN  IF I=J THEN RETURN TRUE;\n                      ELSE  RETURN FALSE;\n      DO  K=0 TO #_EXPECTED_TOKENS - 1 ;\n          IF  I = TOKENS_OUT(K) THEN RETURN TRUE;\n          END;\n      RETURN FALSE;\n END  IS_EXPECTED;\n\n IS_CATCH_SYMBOL  :  PROCEDURE(I) BIT(1);\n       /*  PICKS OUT THE  I'TH BIT OF THE BIT STRING CATCH_SYMBOLS .  */\n       DECLARE I FIXED;\n       RETURN (SHL(BYTE(CATCH_SYMBOLS, SHR(I,3)), I & \"07\") & \"80\") \u00ac= 0;\n END  IS_CATCH_SYMBOL;\n\n\n IS_TO_BE_REPLACED : PROCEDURE(I) BIT(1);\n       /*  PICKS OUT THE I'TH BIT OF  SP_BIT  BIT STRING   */\n       DECLARE I FIXED;\n       RETURN ( SHL( BYTE(SP_BIT,SHR(I,3)), I&\"07\")& \"80\") \u00ac= 0;\n END IS_TO_BE_REPLACED;\n\n\n SCAN_AHEAD  :   PROCEDURE ;\n       /* SCANS AHEAD UNTIL THE TOKEN IS A HEAD SYMBOL FOR THE STACKTOP OR IS A\n       CATCH SYMBOL  */\n\n       DO WHILE \u00ac(IS_CATCH_SYMBOL(TOKEN) | IS_EXPECTED(TOKEN,STACKTOP));\n           CALL GET_TOKEN;\n       END;\n       DO  WHILE  TOKEN=SEMI_COLON  ;\n           CALL GET_TOKEN;\n       END;\n END SCAN_AHEAD;\n\n CRASH_RESTORE : PROCEDURE;\n       /* RESTORES THE STACK WHEN IT HAS CRASHED BECAUSE OF TOO MANY ERRORS. */\n       PARSE_STACK(1)=DOT;\n       PARSE_STACK(2)=STAT_LIST;\n       PARSE_STACK(3)=STATEMENT;\n       PARSE_STACK(4)=PROC_DECL_LIST;\n       PARSE_STACK(5)=DUMMY_VAR_DECL_BODY;\n       PARSE_STACK(6)=VAR_DECLS;\n       PARSE_STACK(7)=DUMMY_TYPE_BODY;\n       PARSE_STACK(8)=TYPE_DEFNS;\n       PARSE_STACK(9)=CONST_DECLS;\n       SP=9;\n       /* NOW SCAN FOR A SYNBOL TO BEGIN A NEW BLOCK.  */\n       DO  WHILE  \u00ac IS_CRASH_SCAN_SYMBOL(TOKEN);\n           CALL GET_TOKEN;\n       END;\n      CALL SYNTHESIZE (1);  /* TO RE-INITIALIZE THE SEMANTIC STACKS */\n END  CRASH_RESTORE;\n\n\n\n\n\n IS_NOT_VAR_NOR_CONST:PROCEDURE(I) BIT(1);\n       DECLARE I FIXED;\n      RETURN (SHL(BYTE(NOT_VAR_NOR_CONST,SHR(I,3)), I&\"07\") & \"80\") \u00ac= 0;\n END IS_NOT_VAR_NOR_CONST;\n\n\n\n\n\n HARD_RECOVER : PROCEDURE ;\n       /****************************************************************\n       *  POPS THE STACK  UNTIL ONE OF THE FOLLOWING CASES ARISES .    *\n       *   (1)  THE CURRENT STACKTOP IS   EQUAL TO THE CATCH TOKEN.    *\n       *   (2)  THE CURRENT STACKTOP HES THE CATCH TOKEN  AS  A        *\n       *              HEAD  SYMBOL.                                    *\n       *   (3)   THE CURRENT STACKTOP  IS A STOP POP SYMBOL FOR  THE   *\n       *        CATCH TOKEN.  IN THIS CASE  THE STACK IS RESTORED.     *\n       ****************************************************************/\n       DECLARE  ( RECOVERY_INDEX,J,K) FIXED, STOPIT BIT(1);\n       IF CONTROL(BYTE('B')) THEN\n       OUTPUT=' *** HARD RECOVERY  ATTEMPTED  ***';\n       RECOVERY_INDEX=CATCH_ACTION(TOKEN);\n       IF  RECOVERY_INDEX=0 THEN RETURN;\n       STOPIT=FALSE;\n       DO WHILE  \u00ac(SP=0 | STOPIT);\n           STACKTOP=PARSE_STACK(SP);\n           IF IS_EXPECTED(TOKEN,STACKTOP) THEN RETURN;\n           J=RECOVERY_INDEX;\n           DO  WHILE \u00ac(STOP_POP_SYMBOL(J)=0 | STOPIT);\n               IF  STOP_POP_SYMBOL(J)=STACKTOP THEN STOPIT=TRUE;\n               ELSE  J=J+1;\n           END;\n           IF \u00acSTOPIT THEN DO;\n               NODE_NUMBER = ERROR_NODE;\n               CALL SYNTHESIZE (PR#(PARSE_STACK(SP) -NT));\n               IF  CONTROL(BYTE('B')) THEN\n               OUTPUT = '*** PRODUCTION #  '||PR#(PARSE_STACK(SP)-NT) ||\n                        '  APPLIED  IN  HARD RECOVER. ***';\n               SP = SP - 1;\n               END;\n       END;\n       IF SP=0 THEN  CALL CRASH_RESTORE;\n       ELSE  DO;\n           IF IS_TO_BE_REPLACED(J) THEN DO;\n               CALL SYNTHESIZE (ERROR_PROD);\n               IF CONTROL(BYTE('B')) THEN\n               OUTPUT='**  ERROR  PRODUCTION APPLIED    ';\n               SP = SP - 1;\n               END;\n           K=REST_PTR(J);\n           IF  K\u00ac=0 THEN DO;\n             DO  J=K+1  TO  K+REST_SYMBOL(K);\n               SP=SP+1;\n               PARSE_STACK(SP)=REST_SYMBOL(J);\n             END;\n           END;\n       END;\n   IF CONTROL(BYTE('B')) THEN\n   CALL  STACK_DUMP;\n END  HARD_RECOVER;\n\n\n SUPPLY_TOKEN : PROCEDURE (I);\n       /* INSERTS  TOKEN  I  AND STORES THE PRESENT TOKEN IN PREVIOUS TOKEN */\n       DECLARE  I  FIXED;\n       PREVIOUS_TOKEN= TOKEN;\n       TOKEN = I;\n       TOKEN_SUPPLIED=TRUE;\n       OUTPUT=' *** TOKEN SUPPLIED   '||V(I)|| '   **';\n       SEMI_COLON_OK=FALSE;\n       RIGHT_PAREN_OK=FALSE;\n END  SUPPLY_TOKEN;\n\n\n\n\n\n SOFT_RECOVER : PROCEDURE;\n       DECLARE I FIXED;\n       /* FIRST  CHECK IF  EQUIVALENT TOKEN WILL DO */\n       IF  IS_EXPECTED(EQUIVALENT(TOKEN),STACKTOP) THEN DO;\n           TOKEN=EQUIVALENT(TOKEN);\n           OUTPUT='*** TOKEN ASSUMED TO BE ' || V(TOKEN) || '    ***';\n           IF  STACKTOP<=NT THEN  DO;\n               SP=SP-1;\n               CALL GET_TOKEN;\n           END;\n           RETURN;\n       END;\n\n          IF FOUND_SPELLING_ERROR THEN DO;\n             FOUND_SPELLING_ERROR=FALSE;\n             TOKEN=TOKEN_MISSPELT;\n             OUTPUT='*** TOKEN PROBABLY MIS_SPELT. ASSUMED TO BE   ' ||\n                       V(TOKEN) || '  ***';\n             IF  STACKTOP <= NT THEN DO;\n                 SP=SP-1;\n                 CALL GET_TOKEN;\n                 END;\n             RETURN;\n             END;\n\n       /*  TRY  MISSING TOKENS  */\n       /*  NOW CHECK  IF IT IS AN ERROR OF OMISSION  */\n       IF IS_EXPECTED(TOKEN,PARSE_STACK(SP-1)) THEN DO;\n           IF  STACKTOP<=NT THEN\n                OUTPUT=' ***  ' || V(STACKTOP)|| ' PROBABLY MISSING ***' ;\n         ELSE CALL SYNTHESIZE (PR#(PARSE_STACK(SP) - NT));\n           SP=SP-1;\n           RETURN;\n       END;\n       /*  CHECK FOR SPECIAL TYPES OF ERRORS  */\n       /*  TOKEN  IS  'ELSE'  TOKEN   */\n       IF TOKEN=ELSE_TOKEN  THEN DO;\n           IF  PREVIOUS_TOKEN=SEMI_COLON  THEN  DO;\n               OUTPUT=' SEMI COLON  PRECEDES  ''ELSE''  ***';\n               SEVERE_ERRORS=SEVERE_ERRORS-1;\n           END;\n           SP=SP+1;\n           PARSE_STACK(SP)=ELSE_PART;\n           RETURN;\n       END;\n       /* INSERTION OF TOKENS */\n       IF SUCCESSFUL_INSERTION THEN DO;\n         IF (#_EXPECTED_TOKENS=1)& IS_NOT_VAR_NOR_CONST(TOKEN_EXPECTED)\n            THEN DO;\n            CALL SUPPLY_TOKEN(TOKEN_EXPECTED);\n            RETURN;\n         END;\n         ELSE DO;\n            IF SEMI_COLON_OK THEN DO;\n              IF RIGHT_PAREN_OK  THEN\n                IF  \u00acBRACKET_COUNT THEN DO;\n                   BRACKET_COUNT=TRUE;\n                   CALL SUPPLY_TOKEN(SEMI_COLON);\n                   RETURN;\n                END;\n                ELSE DO;\n                   BRACKET_COUNT=FALSE;\n                   CALL SUPPLY_TOKEN(RIGHT_PAREN);\n                   RETURN;\n                END;\n              CALL SUPPLY_TOKEN(SEMI_COLON);\n              RETURN;\n            END;\n            IF RIGHT_PAREN_OK  THEN DO;\n              BRACKET_COUNT=TRUE;\n              CALL SUPPLY_TOKEN(RIGHT_PAREN);\n              RETURN;\n            END;\n         END;\n       END;\n       /*  IF  SOFT_RECOVER   FAILS THEN  CALL HARD RECOVER  */\n       CALL SCAN_AHEAD;\n       IF  IS_EXPECTED(TOKEN,STACKTOP)  THEN  RETURN;\n       ELSE  CALL  HARD_RECOVER;\n END  SOFT_RECOVER;\n\n\n\n\n   /*                         THE ANALYSIS ALGORITHM                  */\n\n\n   BRACKET_COUNT=FALSE;\n   TOKEN_SUPPLIED=FALSE;\n   CALL GET_TOKEN;\n   DO WHILE COMPILING;\n      IF SP = 0 THEN CALL CRASH_RESTORE;\n      FOUND_PROD = FALSE;\n      STACKTOP = PARSE_STACK(SP);\n      IF CONTROL(BYTE('B')) THEN DO;\n         IF TOKEN = IDENT THEN S = BCD;\n         ELSE IF TOKEN=INTCONST THEN S=BCD;\n         ELSE IF TOKEN=REALCONST THEN S=BCD;\n         ELSE IF TOKEN=STRING THEN S=BCD;\n         ELSE IF TOKEN=EOFILE THEN S='END OF FILE';\n         ELSE S = V(TOKEN);\n         OUTPUT = 'SCANNING ' || S;\n         CALL STACK_DUMP;\n      END;\n      IF STACKTOP <= NT THEN DO;\n         /*  MATCH TERMINAL SYMBOL SCANNED  */\n         IF  TOKEN=STACKTOP  THEN  DO;\n               SP=SP-1;  CALL GET_TOKEN;\n               END;\n         ELSE  DO;\n                CALL DIAGNOSE_ERROR;\n               CALL ERROR('SYNTAX ERROR -- '||V(STACKTOP)||' NOT FOUND',0);\n               CALL  SOFT_RECOVER;\n               END;\n      END; /* OF CASE TERMINAL */\n      ELSE DO; /* STACKTOP IS NONTERMINAL */\n         RANGE=ENTRIES(STACKTOP-NT1);\n         DO WHILE TOKEN >= INIT(RANGE) & RANGE <= ENTRIES(STACKTOP-NT) - 1\n                                                                & \u00acFOUND_PROD;\n            IF TOKEN <= FIN(RANGE) THEN DO;\n               INDEX = TOKEN - INIT(RANGE) + PTR(RANGE);\n               PRODUCTION_NUMBER = PROD_#(INDEX);\n               FOUND_PROD = TRUE;\n            END;\n            ELSE RANGE = RANGE + 1;\n         END;  /* OF SEARCH FOR AN APPLICABLE PRODUCTION */\n         IF  \u00acFOUND_PROD   THEN  DO;\n            IF IS_RECOVER_SYMBOL(STACKTOP-NT) THEN  SP=SP-1;\n            ELSE DO;\n                  IF TOKEN \u00ac= EOFILE THEN DO;\n                     CALL ERROR('ONE OF THE FOLLOWING SYMBOLS WAS EXPECTED:',1);\n                     CALL DIAGNOSE_ERROR;\n                  END;\n                  CALL   SOFT_RECOVER;\n            END;\n         END;\n\n\n         IF FOUND_PROD THEN DO;\n            NODE_NUMBER = NODE#TRANSLATE(PRODUCTION_NUMBER);\n            CALL SYNTHESIZE(PRODUCTION_NUMBER);\n            /* NOW UPDATE THE PARSE_STACK                             */\n            SP = SP - 1;\n            IF   NONEMPTY(PRODUCTION_NUMBER)\u00ac=0 THEN DO;\n                 LGTH = PR_LENGTH(PRODUCTION_NUMBER);\n                 IF LGTH > 0 THEN DO;\n                    INDEX = PR_PTR(PRODUCTION_NUMBER);\n                    DO I = 1 TO LGTH;\n                       SP = SP + 1;\n                       PARSE_STACK(SP) = RHS(INDEX + LGTH - I);\n                    END;\n                 END;\n                 /* IF THE APPLICABLE PRODUCTION BEGINS WITH A TERMINAL SYMBOL,\n                    THEN SCAN FOR NEXT TOKEN                               */\n                 IF  IS_TERMINAL(PRODUCTION_NUMBER) THEN\n                      CALL   GET_TOKEN;\n            END;\n         END;\n      END;\n   END;\n   CALL WRITEOUT;\n   CALL COMPACTIFY_SYMBOL_TABLE;\n   CALL PUNCH_SYMBOLS;\n      /* IF COMPILATION IS TERMINATED PREMATURELY, SCAN TO EOFILE     */\n   IF TOKEN \u00ac= EOFILE THEN DO;\n      SP = 0;\n      OUTPUT = '*****     NO FURTHER SYNTAX CHECKING WILL OCCUR     *****';\n      COMPILING = TRUE;\n      DO WHILE COMPILING;\n         CALL GET_CARD;\n         CALL SCAN;\n      END;\n   END;\n   IF SP > 0 THEN DO;\n      CALL ERROR(\n         'COMPILING HALTED BY PREMATURE END OF FILE, POSSIBLY MISSING \"END\"',1);\n      CALL STACK_DUMP;\n      IF #_OF_TREES = 0 THEN MONITOR_LINK(0) = NULL;\n  /* THE ABOVE INHIBITS FURTHER PROCESSING  */\n   END;\n   /* $P -- PRINT CROSS-REFERENCE LISTING FOR PROCEDURES  */\nEND COMPILATION_LOOP;\n\n   /* $P */\n\n\n\n\nPRINT_SUMMARY:\n   PROCEDURE;\n      DECLARE I FIXED;\n      CALL PRINT_DATE_AND_TIME ('END OF PASS ONE ', DATE, TIME);\n      OUTPUT = '';\n      OUTPUT = CARD_COUNT || ' CARDS WERE PARSED.';\n      IF ERROR_COUNT = 0 THEN OUTPUT = 'NO SYNTAX ERRORS WERE DETECTED.';\n      ELSE IF ERROR_COUNT > 1 THEN\n         OUTPUT = ERROR_COUNT || ' ERRORS (' || SEVERE_ERRORS\n            || ' SEVERE) WERE DETECTED.';\n      ELSE IF SEVERE_ERRORS = 1 THEN OUTPUT = 'ONE SEVERE ERROR WAS DETECTED.';\n         ELSE OUTPUT = 'ONE ERROR WAS DETECTED.';\n      IF PREVIOUS_ERROR > 0 THEN\n         OUTPUT = 'THE LAST DETECTED ERROR WAS ON LINE ' || PREVIOUS_ERROR\n            || PERIOD;\n      IF \u00acCONTROL(BYTE('D')) THEN RETURN;\n      CALL DUMPIT;\n      DOUBLE_SPACE;\n      CLOCK(3) = TIME;\n      CPU_CLOCK(3) = ELAPSED_CPU_TIME;\n      DO I = 1 TO 3;   /* WATCH OUT FOR MIDNIGHT */\n         IF CLOCK(I) < CLOCK(I-1) THEN CLOCK(I) = CLOCK(I) +  8640000;\n      END;\n      CALL PRINT_TIMES('TOTAL TIME IN PASS ONE:  ',\n         CLOCK(3) - CLOCK(0), CPU_CLOCK(3) - CPU_CLOCK(0));\n      CALL PRINT_TIMES('SET UP TIME:             ',\n         CLOCK(1) - CLOCK(0), CPU_CLOCK(1) - CPU_CLOCK(0));\n      CALL PRINT_TIMES('ACTUAL PARSING TIME:     ',\n         CLOCK(2) - CLOCK(1), CPU_CLOCK(2) - CPU_CLOCK(1));\n      CALL PRINT_TIMES('CLEANUP TIME AT END:     ',\n         CLOCK(3) - CLOCK(2), CPU_CLOCK(3) - CPU_CLOCK(2));\n      IF CLOCK(2) > CLOCK(1) THEN   /* WATCH OUT FOR CLOCK BEING OFF */\n      OUTPUT = 'PARSING RATE: ' || 6000*CARD_COUNT/(CLOCK(2)-CLOCK(1))\n         || ' CARDS PER MINUTE.';\n   END PRINT_SUMMARY;\n\nMAIN_PROCEDURE:\n      CLOCK(0) = TIME;  /* KEEP TRACK OF TIME IN EXECUTION */\n      CPU_CLOCK(0) = 0;\n      CALL CLOCK_TRAP(0,ADDR(TIMEST));\n      CALL INITIALIZATION;\n      CALL RE_INITIALIZE;\n\n      CLOCK(1) = TIME;\n      CPU_CLOCK(1) = ELAPSED_CPU_TIME;\n\n      CALL COMPILATION_LOOP;\n\n      CLOCK(2) = TIME;\n      CPU_CLOCK(2) = ELAPSED_CPU_TIME;\n\n      /* CLOCK(3) AND CPU_CLOCK(3) GET SET IN PRINT_SUMMARY */\n      IF CONTROL(BYTE('Z')) THEN CALL SY_DUMP;\n      CALL PRINT_SUMMARY;\n      MONITOR_LINK(3) = SEVERE_ERRORS;\n\nEOF EOF EOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE06": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x04\\xec\\x04\\xec\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 1260, "newlines": 1260, "modlines": 0, "user": "SPASCAL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FILE07": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x15\\xa9\\x15\\xa9\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 5545, "newlines": 5545, "modlines": 0, "user": "SPASCAL"}, "text": "   /********************************************************************\n   *                                                                   *\n   *                 STONY BROOK PASCAL 360 COMPILER                   *\n   *             PASS 2 -- GENERATION OF SYMBOLIC TRIPLES              *\n   *                                                                   *\n   ********************************************************************/\n\n   /*\n\n   COPYRIGHT (C) 1976 DEPARTMENT OF COMPUTER SCIENCE, SUNY AT STONY BROOK.\n\n   */\n\n\n\n   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */\n   DECLARE PAGE CHARACTER INITIAL('1');\n   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1)=PAGE';\n   DECLARE DOUBLE CHARACTER INITIAL('0');\n   DECLARE DOUBLE_SPACE LITERALLY 'OUTPUT(1)=DOUBLE';\n   DECLARE X1 CHARACTER INITIAL(' ');\n   DECLARE X2 CHARACTER INITIAL('  ');\n   DECLARE X4 CHARACTER INITIAL('    ');\n   DECLARE X70 CHARACTER INITIAL(\n      '                                                                      ');\n\n   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';\n   DECLARE NULL LITERALLY '-1';\n   DECLARE NUL LITERALLY '\"FFFF\"';\n   DECLARE MAXINT FIXED INITIAL (2147483647);\n\n   /* THE PARSE TREE */\n   DECLARE PARSE_TREE(7200) BIT(16);\n   DECLARE MULTIPLICITY LITERALLY 'PARSE_TREE';\n   DECLARE TREE_SIZE FIXED;\n\n   /* THE SYMBOL TABLE */\n   DECLARE IDENTITY_LENGTH LITERALLY '500';\n   DECLARE TABLE_LENGTH LITERALLY '850';\n   DECLARE IDENTITY (IDENTITY_LENGTH) CHARACTER INITIAL (\n      'FALSE', 'TRUE', 'NIL', '(..)', 'INTEGER', 'BOOLEAN', 'REAL', 'CHAR',\n      'TEXT', 'INPUT', 'OUTPUT', 'ABS', 'SQR', 'ODD', 'SUCC', 'PRED', 'ORD',\n      'CHR', 'TRUNC', 'EOF', 'SIN', 'COS', 'EXP', 'LN', 'SQRT', 'ARCTAN',\n      'ROUND', 'EOLN', 'GET', 'PUT', 'RESET', 'REWRITE', 'NEW', 'READ', 'WRITE',\n      'PACK', 'UNPACK', 'MAXINT', 'DISPOSE', 'PAGE', 'READLN', 'WRITELN',\n      'CLOCK', 'INTFIELDSIZE', 'BOOLFIELDSIZE', 'REALFIELDSIZE',\n      'DECIMAL_PLACES');\n   DECLARE STRUCTYPE (TABLE_LENGTH) BIT(16) INITIAL (\n      1, 1, 3, 11, 14, 1, 14, 1, 6, 6,\n      6, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n      14, 14, 14, 14, 14, 14, 10, 10, 10, 10,\n      10, 10, 10, 10, 10, 10, 10, 14, 10, 10,\n      10, 10, 10, 14, 14, 14, 14);\n   DECLARE DATATYPE (TABLE_LENGTH) BIT(16) INITIAL (\n      5, 5, 2, 3, 4, 5, 6, 7, 7, 8,\n      8, NUL, NUL, 5, NUL, NUL, 4, 7, 4, 5,\n      6, 6, 6, 6, 6, 6, 4, 5, NUL, NUL,\n      NUL, NUL, NUL, NUL, NUL, NUL, NUL, 4, NUL, NUL,\n      NUL, NUL, 4, 4, 4, 4, 4);\n   DECLARE VAR_TYPE (TABLE_LENGTH) BIT(16) INITIAL (\n      2, 2, 2, 2, 4, 4, 4, 4, 4, 1,\n      1, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n      5, 5, 5, 5, 5, 5, 5, 2, 5, 5,\n      5, 5, 5, 1, 1, 1, 1);\n   DECLARE OWNER(TABLE_LENGTH) BIT(16);\n   DECLARE VALUE(TABLE_LENGTH) BIT(32);\n   DECLARE WHERE_DECL(IDENTITY_LENGTH) BIT(16);\n   DECLARE N_LOOKUPS(IDENTITY_LENGTH) BIT(16);\n   DECLARE S_LIST(TABLE_LENGTH) BIT(16);\n   DECLARE STORAGE_LNGTH  (TABLE_LENGTH) FIXED;\n   DECLARE PSEUDO_REG (TABLE_LENGTH) BIT(16);\n   DECLARE DISPLACEMENT (TABLE_LENGTH) FIXED;\n   DECLARE SYMB_LINK(IDENTITY_LENGTH) BIT(16);\n   DECLARE N_DECL_SYMB BIT(16);\n   DECLARE N_ANONYMOUS_SYMB BIT(16);\n   DECLARE N_PREDECLARED_SYMB LITERALLY '46';\n   DECLARE FIRST_LITERAL BIT(16);\n\n   /* POINTERS TO THE PREDECLARED CONSTANTS */\n   DECLARE FALSEPTR    BIT(16) INITIAL(00),\n           TRUEPTR     BIT(16) INITIAL(01),\n           NILPTR      BIT(16) INITIAL(02),\n           EMPTYSETPTR BIT(16) INITIAL(03),\n           MAXINTPTR   BIT(16) INITIAL(37);\n\n   /* POINTERS INTO THE SYMBOL TABLE TO THE PREDECLARED TYPES */\n   DECLARE INTPTR  BIT(16) INITIAL(4),\n           BOOLPTR BIT(16) INITIAL(5),\n           REALPTR BIT(16) INITIAL(6),\n           CHARPTR BIT(16) INITIAL(7),\n           TEXTPTR BIT(16) INITIAL(8);\n\n   /* POINTERS TO THE PREDECLARED TEXTFILE VARIABLES */\n   DECLARE INPUTPTR  BIT(16) INITIAL(09),\n           OUTPUTPTR BIT(16) INITIAL(10);\n\n   /* POINTERS TO THE OUTPUT-FORMATTING VARIABLES */\n   DECLARE INTFIELDSIZEPTR   BIT(16) INITIAL (43),\n           BOOLFIELDSIZEPTR  BIT(16) INITIAL (44),\n           REALFIELDSIZEPTR  BIT(16) INITIAL (45),\n           DECIMAL_PLACESPTR BIT(16) INITIAL (46);\n\n   /* POINTERS TO SOME OF THE STANDARD PROCEDURES */\n   DECLARE ARCTANPTR  BIT(16) INITIAL(25),\n           CLOCKPTR   BIT(16) INITIAL(42),\n           GETPTR     LITERALLY '28',\n           PACKPTR    LITERALLY '35',\n           PAGEPTR    LITERALLY '39',\n           PUTPTR     LITERALLY '29',\n           READPTR    BIT(16) INITIAL(33),\n           READLNPTR  BIT(16) INITIAL(40),\n           SINPTR     BIT(16) INITIAL(20),\n           SUCCPTR    BIT(16) INITIAL(14),\n           TRUNCPTR   BIT(16) INITIAL(18),\n           WRITEPTR   BIT(16) INITIAL(34),\n           WRITELNPTR BIT(16) INITIAL(41);\n\n   /* CHARACTER BUFFER USED IN SYMBOL TABLE AND PARSE TREE RESTORE ROUTINES */\n   DECLARE SY_TEXT CHARACTER;\n\n   /* BUFFER WHICH ONE PAGE (80 BYTES) OF THE GLOBAL ACTIVATION RECORD */\n   DECLARE DATA_BYTES(79) BIT(8);\n\n   /* GAP IS SET IN RESTORE_SY_TABLE AND USED IN READ_TREE TO FIX UP PARSE\n      TREES, COMPENSATING FOR SYMBOL TABLE COMPACTIFICATION AT THE END OF\n      PASS 1.                                                              */\n   DECLARE GAP BIT(16);\n\n   /* KEEP COUNT OF ERRORS ENCOUNTERED IN PASS 2 */\n   DECLARE (ERROR_COUNT, SEVERE_ERRORS) FIXED;\n\n   /* DECLARATIONS FOR THE TREE-TRAVERSAL ALGORITHM */\n   DECLARE NODE#STACK#OFLO CHARACTER INITIAL(\n      'COMPILER ERROR, NODE#STACK OVERFLOW');\n   DECLARE NULREF CHARACTER INITIAL(\n      'ATTEMPT TO ACCESS PARSE TREE BY A NULL REFERENCE POINTER');\n   DECLARE NODE FIXED;\n   DECLARE NPMAX LITERALLY '75';\n   DECLARE NP FIXED;\n   DECLARE (NODE#STACK, #POS_STACK) (NPMAX) BIT(16);\n   DECLARE ROOT_OF_SUBTREE FIXED;\n\n   /* BUFFER FOR STORING GENERATED TRIPLES */\n   DECLARE TRIPLE_SIZE LITERALLY '7199';\n   DECLARE TRIPLES(TRIPLE_SIZE) BIT(16);\n\n   /* IC IS THE INSTRUCTION COUNT, THE INDEX INTO THE PROGRAM.\n      N_TRIPLES IS THE INDEX OF THE FIRST FREE ELEMENT OF THE ARRAY TRIPLES. */\n   DECLARE IC FIXED, N_TRIPLES BIT(16);\n\n   /* STACK OF OPERANDS FOR TRIPLES */\n   DECLARE #OPMAX LITERALLY '100';\n   DECLARE OPERAND#STK(#OPMAX) BIT(16);\n   DECLARE #OP FIXED;\n   DECLARE OP#STACK#ERR CHARACTER INITIAL('OPERAND STACK OVERFLOW');\n\n   /* OPERAND TYPE DEFINITION MASKS */\n   DECLARE MASK_SYMBOL BIT(16) INITIAL(\"0000\");\n   DECLARE MASK_IMMEDIATE BIT(16) INITIAL(\"4000\");\n   DECLARE MASK_TRIPLE BIT(16) INITIAL(\"8000\");\n   DECLARE MASK_TEMP BIT(16) INITIAL(\"C000\");\n\n   /* CURRENT_LINE AND LAST_LINE KEEP TRACK OF OUR POSITION RELATIVE TO\n      THE SOURCE TEXT. */\n   DECLARE (CURRENT_LINE, LAST_LINE) FIXED;\n\n   /* TOGGLES WHICH CONTROL THE AMOUNT OF PRINTOUT FROM PASS 2 */\n   DECLARE (PRINT_TREES, PRINT_TRIPLES, PRINT_SYMBOLS, PRINT_CODE) BIT(1);\n   DECLARE PRINT_STATISTICS BIT(1);\n\n   /* MEASURE THE SIZE OF THE PASCAL PROGRAM BEING COMPILED */\n   DECLARE (PROC_SEQUENCE_NUMBER, BASIC_BLOCKS) FIXED;\n\n   /* LEXICAL LEVEL OF PROCEDURE CURRENTLY BEING PROCESSED */\n   DECLARE CURRENT_LEVEL BIT(16);\n\n   /* PR_CASES IS A BRANCH TABLE USED TO DIRECT THE ACTION TAKEN WHEN A NON-LEAF\n         NODE OF THE PARSE_TREE IS VISITED THE FIRST TIME.             */\n   DECLARE #_PRODS LITERALLY '81';\n   DECLARE PR_CASES(#_PRODS) BIT(16) INITIAL(\n      0, 3,0,10,0,0, 0,0,3,3,4, 0,0,0,6,7, 0,7,7,1,1, 7,7,0,0,0, 0,0,0,0,0,\n      8,0,0,0,0, 0,0,0,0,0, 9,0,0,0,0, 9,7,11,0,0, 0,0,7,0,0, 0,0,0,0,0,\n      0,0,5,0,5, 2,0,0,0,0, 5,0,5,2,7, 7,0,0,12,0, 0);\n   DECLARE ALLOCATE_NEW_ROW BIT(1) INITIAL(TRUE);\n   DECLARE ALLOCATE_ARRAY_ENTRY BIT(1) INITIAL(TRUE);\n   DECLARE (OWNER_STACK, ARRAYS_ALLOCATED, STACK_LIMIT,\n         HALFWORD_DISP) (64) FIXED;\n\n   /*    THE ABOVE VARIABLES ARE ALL INDEXED BY CURRENT_LEVEL.\n         CURRENT_LEVEL IS INCREMENTED IN PRODS. 1, 8, 9, 66, AND 68.\n            OWNER_STACK(CURRENT_LEVEL) POINTS TO THE ENTRY IN THE SYMBOL TABLE\n                  FOR THE PROCEDURE OR RECORD TYPE THAT PROVIDES THE\n                  SURROUNDING CONTEXT OF A DECLARATION;\n            ARRAYS_ALLOCATED IS INITIALIZED TO NULL;\n            HALFWORD_DISP IS INITIALIZED TO 0;\n            STACK_LIMIT IS INITIALIZED IN PROD NO. 1 TO CONST_POOL_SIZE + 12,\n                  IN PRODS NO. 8 AND 9 TO THE SIZE OF THE DISPLAY ALLOCATION,\n                  AND IN PRODS NO. 66 AND 68 TO 0.\n        OWNER_STACK(CURRENT_LEVEL) IS REFERENCED IN NEARLY EVERY PRODUCTION, TO\n            SET THE VALUE OF THE OWNER FIELD IN THE SYMBOL TABLE.\n         STACK_LIMIT(CURRENT_LEVEL) GIVES THE VALUE, IN BYTES, OF THE NEXT FREE\n            STORAGE LOCATION IN EACH ACTIVITION RECORD OR RECORD TYPE SEGMENT.\n            SCALAR VARIABLES ARE ALLOCATED AS THEY ARE ENCOUNTERED, AND\n            STRUCTURED TYPES REQUIRING MORE THAN 4 BYTES OF STORAGE ARE HELD BY\n            A LIST BASED ON ARRAYS_ALLOCATED(CURRENT_LEVEL).\n         HALFWORD_DISP RECORDS 'HOLES' OF 2-BYTE SIZE THAT HAVE BEEN LEFT IN THE\n            ALLOCATED STORAGE.  THE VALUE OF STACK_LIMIT IS ALWAYS INCREMENTED\n            IN MULTIPLES OF 4 BYTES TO SECURE FULLWORD ALIGNMENT.  WHEN A 2-BYTE\n            VARIABLE IS ALLOCATED, HALFWORD_DISP IS SET TO POINT TO THE\n            REMAINING TWO BYTES, IF ANY.\n            BOTH STACK_LIMIT AND HALFWORD_DISP ARE REFERENCED AND SET BY\n            PROCEDURES ALLOCATE_STORAGE AND ALLOCATE_ARRAY_STORAGE, WHICH ARE\n            CALLED FROM PRODUCTIONS NO. 10, 12, 25, 66, 67 AND 68.\n            ALLOCATE_STORAGE IS ALSO CALLED FROM PRODUCTION NO. 25.\n         ARRAYS_ALLOCATED IS USED TO MAINTAIN THE HEAD OF A LIST OF STRUCTURED\n            VARIABLES THAT ARE TO BE ALLOCATED STORAGE IN A SEGMENT AFTER ALL\n            SCALAR VARIABLES IN THAT SEGMENT HAVE BEEN ALLOCATED STORAGE.\n            THE PROCEDURE ALLOCATE_STORAGE BUILDS THE LIST AND IT IS PROCESSED\n            BY THE PROCEDURE ALLOCATE_ARRAY_STORAGE.\n         CURRENT_LEVEL IS DECREMENTED IN PRODS NO. 10 AND 66.  PRIOR TO\n            DECREMENTING, A CALL IS MADE TO ALLOCATE_ARRAY_STORAGE.    */\n\n   /* WHEN THE HEADING OF A FORWARD PROCEDURE DECLARATION IS PROCESSED, WE\n      SAVE ITS ARRAYS_ALLOCATED, STACK_LIMIT, AND HALFWORD_DISP FOR WHEN THE\n      BODY APPEARS, IN CASE THE PROCEDURE HAS LOCAL VARIABLES OF ITS OWN.\n      HOWEVER, A STACK IS NOT ADEQUATE, SINCE WHEN SEVERAL FORWARD-DECLARED\n      PROCEDURE BODIES ARE PENDING, THE BODIES MAY IN FACT APPEAR IN AN\n      ARBITRARY ORDER.  WE THEREFORE USE THE HEAP FORWARD_SAVE(FORWARD_LENGTH).\n      FORWARD_AVAIL POINTS TO THE HEADER OF A LIST OF USED NODES, AND\n      FORWARD_LIMIT IS A POINTER TO THE AS YET UNUSED HEAP SPACE.             */\n   DECLARE FORWARD_LENGTH LITERALLY '29';\n   DECLARE FORWARD_SAVE(FORWARD_LENGTH) FIXED;\n   DECLARE (FORWARD_AVAIL, FORWARD_LIMIT) BIT(16);\n\n   /* VARIABLES USED IN DGNS ROUTINE FOR EMITTING ADD_DECIMAL INSTRUCTIONS */\n   DECLARE DGNS#_STACK(NPMAX) BIT(1);\n   DECLARE (DGNS#_TOP, DGNS#_GOTO) BIT(1);\n   DECLARE DGNS#_DEPTH BIT(16) INITIAL (NUL);\n\n   /* \"WITH\" STATEMENTS ARE IMPLEMENTED USING THE FOLLOWING DOUBLE_BARRELLED\n      STACK :__   */\n   DECLARE WITH_LENGTH LITERALLY '31';\n   DECLARE (WITH_DATATYPE, WITH_VARIABLE) (WITH_LENGTH) BIT(16);\n   DECLARE WITH_PTR BIT(16);\n\n   /* A FIXUP LIST CONSISTS OF A CHAIN, THROUGH THE BRANCH ADDRESS (FIRST\n         OPERAND) OF BRANCH TRIPLES, OF THOSE BRANCH TRIPLES WHOSE TARGET IS\n         UNDETERMINED AS YET.  THE HIGH-ORDER BIT OF EACH FIXUP POINTER\n         DETERMINES WHETHER THE BRANCH IS TO BE TAKEN TO A 'TRUE VALUE' TARGET\n         (BIT IS ON) OR A 'FALSE VALUE' TARGET (BIT IS OFF).  LISTHEAD HOLDS THE\n         HEAD OF ONE FIXUP LIST, AND FIX_LIST STACKS THE HEADS OF LEFT-OPERAND\n         FIXUP LISTS (OF BINARY BOOLEAN OPERATORS).  FX HOLDS THE CURRENT\n         LOGICAL VALUE ON WHICH TO BRANCH.  VALUES OF FX CORRESPONDING TO\n         UNFULFILLED OPERATORS ARE STACKED IN THE FIRST OPERAND POINTERS -\n         PARSE_TREE(NODE#STACK(NP) + 2).                                      */\n   DECLARE BOOLTYPE CHARACTER INITIAL ('BOOLEAN EXPRESSION EXPECTED');\n   DECLARE FIX_LIST(NPMAX) BIT(16);\n   DECLARE LISTHEAD BIT(16), FX BIT(1);\n\n   /* ENUMERATION TYPES --\n      THESE ARE IMPLEMENTED BY READ-ONLY VARIABLES */\n\n   /* TYPE STRUCTYPES =\n        (STATEMENT, SCALAR, SUBRANGE, POINTER, ARRAY, PACKED_ARRAY, FILE,\n         PACKED_FILE, RECORD, PACKED_RECORD, STANDARD, SET, PACKED_SET,\n         ARITHMETIC);   */\n\n   DECLARE STATEMENT     BIT(16) INITIAL(00),\n           SCALAR        BIT(16) INITIAL(01),\n           SUBRANGE      BIT(16) INITIAL(02),\n           POINTER       BIT(16) INITIAL(03),\n           ARRAY         BIT(16) INITIAL(04),\n           PACKED_ARRAY  BIT(16) INITIAL(05),\n           FILE          BIT(16) INITIAL(06),\n           PACKED_FILE   BIT(16) INITIAL(07),\n           RECORD        BIT(16) INITIAL(08),\n           PACKED_RECORD BIT(16) INITIAL(09),\n           STANDARD      BIT(16) INITIAL(10),\n           SET           BIT(16) INITIAL(11),\n           PACKED_SET    BIT(16) INITIAL(12),\n           TAG           BIT(16) INITIAL(13),\n           ARITHMETIC    BIT(16) INITIAL(14);\n\n   /* TYPE VAR_TYPES =\n        (TYPE_ID, VARIABLE, CONSTANT, LITERAL, TYPE, PROC, VAR_PARAM,\n         PROC_PARAM, UNDEFINED, LABLE, TAG, CASELABEL, VARIANT, FIELD_ID,\n         FORWARD, MULTDECL, VALUE_PARAM); */\n\n   DECLARE TYPE_ID     BIT(16) INITIAL(00),\n           VARIABLE    BIT(16) INITIAL(01),\n           CONSTANT    BIT(16) INITIAL(02),\n           LITERAL     BIT(16) INITIAL(03),\n           TYPE        BIT(16) INITIAL(04),\n           PROC        BIT(16) INITIAL(05),\n           VAR_PARAM   BIT(16) INITIAL(06),\n           PROC_PARAM  BIT(16) INITIAL(07),\n           UNDEFINED   BIT(16) INITIAL(08),\n           LABLE       BIT(16) INITIAL(09),\n           CASELABEL   BIT(16) INITIAL(11),\n           VARIANT     BIT(16) INITIAL(12),\n           FIELD_ID    BIT(16) INITIAL(13),\n           FORWARD     BIT(16) INITIAL(14),\n           MULTDECL    BIT(16) INITIAL(15),\n           VALUE_PARAM BIT(16) INITIAL(16);\n\n   /* TYPE OP_CODES =\n        (LOAD, MONITOR, TRUNCATE, FLOAT, BCH_TARGET, INDEX, TEMP, STORE, MOVE,\n         ADD, SUBTRACT, MULTIPLY, DIVIDE, COMPARE, ADD_DECIMAL, GREATER, LESS,\n         NOT, ADDFLT, SUBFLT, MPYFLT, DIVFLT, COMPAREFLT, GREATERFLT, LESSFLT,\n         LOAD_ADDR, AND, OR, XOR, RSHIFT, LSHIFT, BAL, BCH, BNZ, BZ, BCT,\n         PCALL, PRETURN, PARM, BLKMARK, PEND, TPOP, REM, ABS, ABSFLT, NEGATE,\n         NEGATEFLT, LLESS, LGREATER, LCOMPARE, PROCPARM, CASE, CASE_TARGET, ODD,\n         SQR, SQRFLT, ROUND, S_LENGTH, IN, INTO, LINE#, RANGE); */\n\n   DECLARE LOAD        BIT(16) INITIAL(00),\n           MONITOR     BIT(16) INITIAL(01),\n           TRUNCATE    BIT(16) INITIAL(02),\n           FLOAT       BIT(16) INITIAL(03),\n           BCH_TARGET  BIT(16) INITIAL(04),\n           INDEX       BIT(16) INITIAL(05),\n           TEMP        BIT(16) INITIAL(06),\n           STORE       BIT(16) INITIAL(07),\n           MOVE        BIT(16) INITIAL(08),\n           ADD         BIT(16) INITIAL(09),\n           SUBTRACT    BIT(16) INITIAL(10),\n           MULTIPLY    BIT(16) INITIAL(11),\n           DIVIDE      BIT(16) INITIAL(12),\n           COMPARE     BIT(16) INITIAL(13),\n           ADD_DECIMAL BIT(16) INITIAL(14),\n           GREATER     BIT(16) INITIAL(15),\n           LESS        BIT(16) INITIAL(16),\n           NOT         BIT(16) INITIAL(17),\n           ADDFLT      BIT(16) INITIAL(18),\n           SUBFLT      BIT(16) INITIAL(19),\n           MPYFLT      BIT(16) INITIAL(20),\n           DIVFLT      BIT(16) INITIAL(21),\n           COMPAREFLT  BIT(16) INITIAL(22),\n           GREATERFLT  BIT(16) INITIAL(23),\n           LESSFLT     BIT(16) INITIAL(24),\n           LOAD_ADDR   BIT(16) INITIAL(25),\n           AND         BIT(16) INITIAL(26),\n           OR          BIT(16) INITIAL(27),\n           XOR         BIT(16) INITIAL(28),\n           LSHIFT      BIT(16) INITIAL(29),\n           RSHIFT      BIT(16) INITIAL(30),\n           BAL         BIT(16) INITIAL(31),\n           BCH         BIT(16) INITIAL(32),\n           BNZ         BIT(16) INITIAL(33),\n           BZ          BIT(16) INITIAL(34),\n           BCT         BIT(16) INITIAL(35),\n           PCALL       BIT(16) INITIAL(36),\n           PRETURN     BIT(16) INITIAL(37),\n           PARM        BIT(16) INITIAL(38),\n           BLKMARK     BIT(16) INITIAL(39),\n           PEND        BIT(16) INITIAL(40),\n           TPOP        BIT(16) INITIAL(41),\n           REM         BIT(16) INITIAL(42),\n           ABS         BIT(16) INITIAL(43),\n           ABSFLT      BIT(16) INITIAL(44),\n           NEGATE      BIT(16) INITIAL(45),\n           NEGATEFLT   BIT(16) INITIAL(46),\n           LLESS       BIT(16) INITIAL(47),\n           LGREATER    BIT(16) INITIAL(48),\n           LCOMPARE    BIT(16) INITIAL(49),\n           PROCPARM    BIT(16) INITIAL(50),\n           CASE_JUMP   BIT(16) INITIAL(51),\n           CASE_TARGET BIT(16) INITIAL(52),\n           ODD         BIT(16) INITIAL(53),\n           SQR         BIT(16) INITIAL(54),\n           SQRFLT      BIT(16) INITIAL(55),\n           ROUND       BIT(16) INITIAL(56),\n           S_LENGTH    BIT(16) INITIAL(57),\n           IN          BIT(16) INITIAL(58),\n           INTO        BIT(16) INITIAL(59),\n           LINE#       BIT(16) INITIAL(60),\n           RANGE       BIT(16) INITIAL(61);\n\n   /* TYPE COMPARISONS =\n        (EQUAL_TO, GREATER_THAN, LESS_THAN, NOT_EQUAL_TO, LESS_EQ,\n         GREATER_EQ); */\n\n   DECLARE EQUAL_TO     BIT(16) INITIAL(0),\n           GREATER_THAN BIT(16) INITIAL(1),\n           LESS_THAN    BIT(16) INITIAL(2),\n           NOT_EQUAL_TO BIT(16) INITIAL(3),\n           LESS_EQ      BIT(16) INITIAL(4),\n           GREATER_EQ   BIT(16) INITIAL(5);\n\n   /*  VALUES USED IN THE ALLOCATION OF STORAGE ON THE RUNTIME STACK  */\n   DECLARE CONST_POOL_SIZE FIXED;\n   DECLARE DISPLAY_BYTES FIXED INITIAL(20);\n   /* SL IS THE VARIABLE SET BY PROCEDURE COMPUTE_STORAGE_LENGTH  */\n   DECLARE SL FIXED;\n\n   /* LEFT HAND SIDES IN INTERNAL FORM OF GRAMMAR */\n   DECLARE LEFT_PART(#_PRODS) CHARACTER INITIAL('', '<PROGRAM>', '<BLOCK>',\n      '<STATEMENT LIST>', '<LABEL DECL>', '<CONST DECL>', '<TYPE DEFN>',\n      '<PROC DECL LIST>', '<PROC DECL>', '<PROC DECL>', '<BODY>',\n      '<VAR DECL LIST>', '<VAR DECL>', '<STATEMENT>', '<STATEMENT>',\n      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',\n      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',\n      '<FORMAL PARAM>', '<FORMAL PARAM>', '<FORMAL PARAM>', '<CASE INSTANCE>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<VARIABLE>', '<VARIABLE>', '<QUALIFIER>',\n      '<QUALIFIER>', '<QUALIFIER>', '<QUALIFIER>', '<CONSTANT>', '<CONSTANT>',\n      '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>',\n      '<TYPE>', '<FIXED FIELD LIST>', '<VARIANT FIELD>', '<VARIANT INSTANCE>',\n      '<STATEMENT>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<ELEMENT>',\n      '<ELEMENT>', '<PARAM TYPES>', '<PARAM TYPES>', '<PARAM TYPES>',\n      '<PARAM TYPES>', '<ERROR>');\n\n  /*             P R O C E D U R E S                                  */\n\nPAD:\n   PROCEDURE (STRING, WIDTH) CHARACTER;\n      DECLARE STRING CHARACTER, (WIDTH, L) FIXED;\n\n      DO WHILE LENGTH(STRING) + 70 < WIDTH;\n         STRING = STRING || X70;\n      END;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN STRING || SUBSTR(X70, 0, WIDTH-L);\n   END PAD;\n\nI_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;\n\n      STRING = NUMBER;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN SUBSTR(X70, 0, WIDTH-L) || STRING;\n   END I_FORMAT;\n\nERROR:\n   PROCEDURE (MESSAGE, SEVERITY);\n      DECLARE MESSAGE CHARACTER, SEVERITY FIXED;\n\n      IF ERROR_COUNT = 0 THEN\n         DO;\n            EJECT_PAGE;\n            OUTPUT = '*** PASS TWO DIAGNOSTICS:';\n            DOUBLE_SPACE;\n         END;\n      ERROR_COUNT = ERROR_COUNT + 1;\n      OUTPUT = '*** ERROR, ' || MESSAGE || '. DETECTED NEAR LINE ' ||\n               CURRENT_LINE || '. ***';\n      IF SEVERITY > 0 THEN SEVERE_ERRORS = SEVERE_ERRORS + 1;\n   END ERROR;\n\n   /*                  DIAGNOSTIC  DUMP  ROUTINES                     */\n\nSY_TABLE_STAT:\n   PROCEDURE (J);\n      DECLARE J BIT(16);\n      DECLARE LINE CHARACTER;\n      DECLARE ID_FIELD FIXED INITIAL (12);\n      DECLARE STRUCTYPES(14) CHARACTER INITIAL('STATMENT', 'SCALAR  ',\n              'SUBRANGE', 'POINTER ', 'ARRAY   ', 'PKDARRAY', 'FILE    ',\n              'PKD FILE', 'RECORD  ', 'PKDRECRD', 'STANDARD', 'SET     ',\n              'PKD SET ', 'TAG     ', 'ARITHMET');\n      DECLARE VAR_TYPES(16) CHARACTER INITIAL('        ', 'VARIABLE','CONSTANT',\n              'LITERAL ', 'TYPE    ', 'PROC    ', 'VAR PARM', 'PROCPARM',\n              'UNDEFINE', 'LABEL   ', '        ', 'CASELABL', 'VARIANT ',\n              'FIELD ID', 'FORWARD ', 'MULTDECL', 'VAL PARM');\n\n   LJUSTIFY:\n      PROCEDURE (X, FIELDWIDTH);\n         DECLARE (X, XTEMP) CHARACTER;\n         DECLARE FIELDWIDTH FIXED;\n         XTEMP = X;\n         IF LENGTH(XTEMP) >= FIELDWIDTH THEN\n            XTEMP = SUBSTR(XTEMP,0,FIELDWIDTH);\n         ELSE XTEMP = XTEMP || SUBSTR(X70,0,FIELDWIDTH-LENGTH(XTEMP));\n         LINE = LINE || XTEMP || X4;\n      END LJUSTIFY;\n\n   RJUSTIFY:\n      PROCEDURE (X, FIELDWIDTH);\n         DECLARE X FIXED;\n         DECLARE FIELDWIDTH FIXED;\n         DECLARE XTEMP CHARACTER;\n         XTEMP = X;\n         IF LENGTH(XTEMP) > FIELDWIDTH THEN\n            LINE = SUBSTR(LINE,0,LENGTH(LINE)-LENGTH(XTEMP)+FIELDWIDTH);\n         ELSE LINE = LINE || SUBSTR(X70, 0, FIELDWIDTH-LENGTH(XTEMP));\n         LINE = LINE || XTEMP || X4;\n      END RJUSTIFY;\n\n      LINE = I_FORMAT(J,4);\n      LINE = LINE || X2;\n      IF J >= N_ANONYMOUS_SYMB THEN LINE = LINE || SUBSTR(X70,0,ID_FIELD+4);\n      ELSE CALL LJUSTIFY(IDENTITY(J), ID_FIELD);\n      CALL RJUSTIFY(DATATYPE(J), 4);\n      LINE = LINE || STRUCTYPES(STRUCTYPE(J)) || X4 ||\n          VAR_TYPES(VAR_TYPE(J)) || X4;\n      IF OWNER(J) = NULL THEN\n         LINE = LINE || SUBSTR(X70, 0, ID_FIELD + 4);\n      ELSE IF OWNER(J) < N_ANONYMOUS_SYMB THEN\n         CALL LJUSTIFY(IDENTITY(OWNER(J)), ID_FIELD);\n      ELSE\n         CALL LJUSTIFY('(' || OWNER(J) || ')', ID_FIELD);\n      CALL RJUSTIFY(STORAGE_LNGTH(J),4);\n      IF J < N_ANONYMOUS_SYMB THEN CALL RJUSTIFY(WHERE_DECL(J),4);\n      ELSE LINE = LINE || SUBSTR(X70,0,8);\n      CALL RJUSTIFY(S_LIST(J),4);\n      CALL RJUSTIFY(VALUE(J),8);\n      CALL RJUSTIFY(PSEUDO_REG(J),4);\n      CALL RJUSTIFY(DISPLACEMENT(J),8);\n      OUTPUT = LINE;\n   END SY_TABLE_STAT;\n\nSY_DUMP:\n   PROCEDURE;\n      DECLARE I BIT(16);\n      EJECT_PAGE;\n      OUTPUT = '      IDENTITY      DATATYPE  STRUCTYPE   VAR TYPE    OWNER\n  ST LENGTH    LINE   S_LIST      VALUE  PSEUDO REG    DISP';\n      OUTPUT = '';\n      DO I = 0 TO N_DECL_SYMB - 1;\n         CALL SY_TABLE_STAT(I);\n      END;\n   END SY_DUMP;\n\nPARSE_TREE_DUMP:\n   PROCEDURE (TREE);\n      DECLARE A(127) BIT(16);   /* AUXILIARY STACK; CF KNUTH V.1 P.317 */\n      DECLARE TREE BIT(16);   /* POINTER TO ROOT */\n      DECLARE (TOP_OF_A,M,C,P) BIT(16);\n      DECLARE LEAF LITERALLY 'PARSE_TREE(P+1)',\n              PRODUCTION_NUMB LITERALLY 'PARSE_TREE(P+1)',\n              LINE_NUMB LITERALLY 'PARSE_TREE(P+M+2)';\n      DECLARE MARGIN CHARACTER;\n      DECLARE INDENTATION BIT(16), (S1, S2) CHARACTER;\n      DECLARE OVERFLOW_MESSAGE CHARACTER INITIAL(\n         '*** AUXILIARY STACK OVERFLOW, PARSE TREE DUMP ABORTED');\n      MARGIN = X70 || X70 || '|';\n      INDENTATION = LENGTH(MARGIN) - 2;\n      TOP_OF_A = 0;\n      P = TREE;\n      OUTPUT = 'PARSE_TREE AT THIS POINT IS:';\n      DO FOREVER;\n         IF P = NULL THEN\n            DO;\n               M = 0;\n               S1 = '... EMPTY PRODUCTION ...';\n            END;\n         ELSE\n            DO;\n               M = MULTIPLICITY(P);\n               IF M = 0 THEN\n                  DO;\n                     IF LEAF < N_ANONYMOUS_SYMB THEN\n                        S1 = IDENTITY(LEAF);\n                     ELSE IF (DATATYPE(LEAF)=INTPTR) | (DATATYPE(LEAF)=REALPTR)\n                        THEN S1 = VALUE(LEAF);\n                     ELSE\n                        DO;\n                           S1 = ' ';\n                           BYTE(S1) = VALUE(LEAF) & \"FF\";\n                        END;\n                  END;\n               ELSE S1 = PRODUCTION_NUMB || X1 || LEFT_PART(PRODUCTION_NUMB);\n            END;\n         S2 = SUBSTR(MARGIN,INDENTATION) || X1 || S1;\n         S2 = PAD(S2,127);\n         S1 = I_FORMAT(LINE_NUMB,4);\n         IF P = NULL THEN S1 = '';\n         OUTPUT = S2 || '|' || S1;\n         IF M > 0 THEN\n            DO;\n               A(TOP_OF_A) = 0;\n               TOP_OF_A = TOP_OF_A + 1;\n               IF TOP_OF_A > 127 THEN\n                  DO;\n                     OUTPUT = OVERFLOW_MESSAGE;\n                     RETURN;\n                  END;\n            END;\n         DO C = - 1 TO M - 3;   /* STACK SUBTREES RIGHT TO LEFT */\n            A(TOP_OF_A) = PARSE_TREE(P + M - C);\n            TOP_OF_A = TOP_OF_A + 1;\n            IF TOP_OF_A > 127 THEN\n               DO;\n                  OUTPUT = OVERFLOW_MESSAGE;\n                  RETURN;\n               END;\n         END;\n         IF M = 0 THEN\n            DO;   /* UNSTACK SUBTREE */\n               IF TOP_OF_A = 0 THEN RETURN;\n               TOP_OF_A = TOP_OF_A - 1;\n               P = A(TOP_OF_A);\n               DO WHILE P = 0;\n                  IF TOP_OF_A = 0 THEN RETURN;\n                  INDENTATION = INDENTATION + 3;\n                  TOP_OF_A = TOP_OF_A - 1;\n                  P = A(TOP_OF_A);\n               END;\n            END;\n         ELSE\n            DO;    /* PREPARE TO DUMP LEFTMOST SUBTREE */\n               P = PARSE_TREE(P + 2);\n               INDENTATION = INDENTATION - 3;\n            END;\n      END;\n   END PARSE_TREE_DUMP;\n\nPRINT_COMPILE_TIME:\n   PROCEDURE;\n      DECLARE (COMPILE_TIME, L) FIXED, STRING CHARACTER;\n      COMPILE_TIME = CLOCK_TRAP(NULL);   /* CANCELS CPU TIMER */\n      STRING = COMPILE_TIME;   L = LENGTH(STRING);\n      IF L < 5 THEN STRING = SUBSTR('00000', 0, 5 - L) || STRING;\n      STRING = '0' || SUBSTR(STRING, 0, 3) || '.' || SUBSTR(STRING, 3, 2);\n      OUTPUT(1) = STRING || ' SECONDS IN COMPILATION, NO CODE GENERATED.';\n   END PRINT_COMPILE_TIME;\n\n   /*                TREE - TRAVERSAL  PROCEDURES                     */\n\nLEFTSON:\n   PROCEDURE;\n      IF NODE = NULL THEN CALL ERROR(NULREF, 1);\n      ELSE\n         DO;\n            IF MULTIPLICITY(NODE) = 0 THEN NODE = NULL;\n            ELSE\n               DO;\n                  IF NP >= NPMAX THEN\n                     DO;\n                        CALL ERROR(NODE#STACK#OFLO, 1);\n                        NP = 0;\n                     END;\n                  NP = NP + 1;\n                  NODE#STACK(NP) = NODE;\n                  #POS_STACK(NP) = 1;\n                  NODE = PARSE_TREE(NODE + 2);\n                  IF NODE \u00ac= NULL THEN\n                     CURRENT_LINE = PARSE_TREE(NODE + MULTIPLICITY(NODE) + 2);\n               END;\n         END;\n   END LEFTSON;\n\nRIGHT_BRO:\n   PROCEDURE;\n      IF MULTIPLICITY(NODE#STACK(NP)) > #POS_STACK(NP) THEN\n         DO;\n            NODE = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 2);\n            #POS_STACK(NP) = #POS_STACK(NP) + 1;\n            IF NODE \u00ac= NULL THEN\n               CURRENT_LINE = PARSE_TREE(NODE + MULTIPLICITY(NODE) + 2);\n         END;\n      ELSE NODE = NULL;\n   END RIGHT_BRO;\n\nFATHER:\n   PROCEDURE;\n      IF NP < 1 THEN CALL ERROR(NULREF, 1);\n      ELSE\n         DO;\n            NODE = NODE#STACK(NP);\n            NP = NP - 1;\n         END;\n   END FATHER;\n\nREPLACE:\n   PROCEDURE (NEWSON);\n      DECLARE NEWSON BIT(16);\n      IF NP < 1 THEN CALL ERROR(NULREF, 1);\n      ELSE PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 1) = NEWSON;\n   END REPLACE;\n\nREPLACE_LEFT_BRO:\n   PROCEDURE (NEWSON);\n      DECLARE NEWSON BIT(16);\n      IF (NP < 1) | (#POS_STACK(NP) < 2) THEN CALL ERROR(NULREF, 1);\n      ELSE PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP)) = NEWSON;\n   END REPLACE_LEFT_BRO;\n\n   /*             TYPE  COMPATIBILITY  CHECKING  PROCEDURE            */\n\nCOMPTYPES:\n   PROCEDURE (TYPE1, TYPE2) BIT(1);\n      DECLARE (TYPE1, TYPE2) BIT(16);\n      DECLARE COMP_STACKSIZE LITERALLY '50';\n      DECLARE STACK1(COMP_STACKSIZE) BIT(16);\n      DECLARE STACK2(COMP_STACKSIZE) BIT(16);\n      DECLARE SP BIT(16);\n      IF TYPE1 = TYPE2 THEN RETURN TRUE;\n      SP = 1;  /* FIRST FREE STACK ELEMENT;  0 NOT USED */\n      DO WHILE SP > 0;\n         IF STRUCTYPE(TYPE1) \u00ac= STRUCTYPE(TYPE2) THEN RETURN FALSE;\n         ELSE\n            DO CASE STRUCTYPE(TYPE1);\n               /* CASE 0 -- STATEMENT */\n               RETURN FALSE;\n               /* CASE 1 -- SCALAR */\n               IF DATATYPE(TYPE1) \u00ac= DATATYPE(TYPE2) THEN\n                  RETURN FALSE;\n               ELSE\n                  DO;\n                     SP = SP - 1;\n                     TYPE1 = STACK1(SP);\n                     TYPE2 = STACK2(SP);\n                  END;\n               /* CASE 2 -- SUBRANGE */\n               IF DATATYPE(TYPE1) \u00ac= DATATYPE(TYPE2) THEN\n                  RETURN FALSE; /* UNDERLYING BASE TYPES MUST MATCH */\n               ELSE IF VALUE(S_LIST(TYPE1)) \u00ac= VALUE(S_LIST(TYPE2)) THEN\n                  RETURN FALSE; /* LOWBOUNDS MUST MATCH */\n               ELSE IF STORAGE_LNGTH(TYPE1) \u00ac= STORAGE_LNGTH(TYPE2) THEN\n                  RETURN FALSE; /* HIGHBOUNDS MUST MATCH */\n               ELSE\n                  DO;\n                     SP = SP - 1;\n                     TYPE1 = STACK1(SP);\n                     TYPE2 = STACK2(SP);\n                  END;\n               /* CASE 3 -- POINTER */\n               DO;\n                  IF (TYPE1 \u00ac= NILPTR) & (TYPE2 \u00ac= NILPTR) THEN\n                     IF (DATATYPE(TYPE1) \u00ac= DATATYPE(TYPE2)) THEN\n                        RETURN FALSE;\n                     /* ALTERNATIVE - CHECK FOR COMPATIBILITY OF REFERENCED\n                                      TYPES.  MUST BEWARE OF CYCLES, HOWEVER */\n                  SP = SP - 1;\n                  TYPE1 = STACK1(SP);\n                  TYPE2 = STACK2(SP);\n               END;\n               /* CASE 4 -- ARRAY */\n               IF STORAGE_LNGTH(TYPE1) \u00ac= STORAGE_LNGTH(TYPE2) THEN\n                  RETURN FALSE;\n               ELSE\n                  DO;\n                     TYPE1 = DATATYPE(TYPE1);\n                     TYPE2 = DATATYPE(TYPE2);\n                  END;\n               /* CASE 5 -- PACKED ARRAY */\n               IF STORAGE_LNGTH(TYPE1) \u00ac= STORAGE_LNGTH(TYPE2) THEN\n                  RETURN FALSE;\n               ELSE\n                  DO;\n                     TYPE1 = DATATYPE(TYPE1);\n                     TYPE2 = DATATYPE(TYPE2);\n                  END;\n               /* CASE 6 -- FILE */\n               DO;\n                  TYPE1 = DATATYPE(TYPE1);\n                  TYPE2 = DATATYPE(TYPE2);\n               END;\n               /* CASE 7 -- PACKED FILE */\n               DO;\n                  TYPE1 = DATATYPE(TYPE1);\n                  TYPE2 = DATATYPE(TYPE2);\n               END;\n               /* CASE 8 -- RECORD */\n   CASE#8:     IF TYPE1 = TYPE2 THEN\n                  DO;\n                     SP = SP - 1;\n                     TYPE1 = STACK1(SP);\n                     TYPE2 = STACK2(SP);\n                  END;\n               ELSE IF STORAGE_LNGTH(TYPE1) \u00ac= STORAGE_LNGTH(TYPE2) THEN\n                  RETURN FALSE;\n               ELSE\n                  DO;\n                     TYPE1 = S_LIST(TYPE1);\n                     TYPE2 = S_LIST(TYPE2);\n                     DO WHILE (VAR_TYPE(TYPE1) = FIELD_ID)\n                             & (VAR_TYPE(TYPE2) = FIELD_ID);\n                        STACK1(SP) = DATATYPE(TYPE1);\n                        STACK2(SP) = DATATYPE(TYPE2);\n                        TYPE1 = S_LIST(TYPE1);\n                        TYPE2 = S_LIST(TYPE2);\n                        SP = SP + 1;\n                     END;\n                     IF (TYPE1 \u00ac= NULL) | (TYPE2 \u00ac= NULL) THEN\n                        RETURN FALSE;\n                     ELSE\n                        DO;\n                           SP = SP - 1;\n                           TYPE1 = STACK1(SP);\n                           TYPE2 = STACK2(SP);\n                        END;\n                  END;\n               /* CASE 9 -- PACKED RECORD */\n               GOTO CASE#8;\n               /* CASE 10 -- \"STANDARD\" */\n               RETURN FALSE;\n               /* CASE 11 -- SET */\n               IF (TYPE1 \u00ac= EMPTYSETPTR) & (TYPE2 \u00ac= EMPTYSETPTR) THEN\n                  DO;\n                     IF VALUE(TYPE1) \u00ac= VALUE(TYPE2) THEN RETURN FALSE;\n                     IF STORAGE_LNGTH(TYPE1) \u00ac= STORAGE_LNGTH(TYPE2) THEN\n                        RETURN FALSE;\n                     TYPE1 = DATATYPE(TYPE1);\n                     TYPE2 = DATATYPE(TYPE2);\n                  END;\n               ELSE\n                  DO;\n                     SP = SP - 1;\n                     TYPE1 = STACK1(SP);\n                     TYPE2 = STACK2(SP);\n                  END;\n               /* CASE 12 -- PACKED SET */\n               DO;\n                  IF VALUE(TYPE1) \u00ac= VALUE(TYPE2) THEN RETURN FALSE;\n                  IF STORAGE_LNGTH(TYPE1) \u00ac= STORAGE_LNGTH(TYPE2) THEN\n                     RETURN FALSE;\n                  TYPE1 = DATATYPE(TYPE1);\n                  TYPE2 = DATATYPE(TYPE2);\n               END;\n               /* CASE 13 -- TAG */\n               RETURN FALSE;\n               /* CASE 14 -- ARITHMETIC */\n               IF DATATYPE(TYPE1) \u00ac= DATATYPE(TYPE2) THEN RETURN FALSE;\n               ELSE\n                  DO;\n                     SP = SP - 1;\n                     TYPE1 = STACK1(SP);\n                     TYPE2 = STACK2(SP);\n                  END;\n            END; /* CASE */\n      END; /* WHILE */\n      RETURN TRUE;\n   END COMPTYPES;\n\nCOMPPROCS:\n   PROCEDURE (PROC1, PROC2) BIT(1);\n      DECLARE (PROC1, PROC2) BIT(16);\n      /* RETURNS TRUE IFF PROCEDURE PROC1 CAN BE USED AS ACTUAL PARAMETER\n         FOR FORMAL PROCEDURE PROC2.                                       */\n      DECLARE PROC_STACKSIZE LITERALLY '32';\n      DECLARE (STACK1, STACK2) (PROC_STACKSIZE) BIT(16), SP BIT(16);\n      SP = 1;   /* FIRST STACK ELEMENT; 0 NOT USED */\n      DO WHILE SP > 0;\n         /* RETURN TYPES MUST BE COMPATIBLE */\n         IF STRUCTYPE(PROC1) \u00ac= STRUCTYPE(PROC2) THEN RETURN FALSE;\n         IF \u00acCOMPTYPES(DATATYPE(PROC1), DATATYPE(PROC2)) THEN RETURN FALSE;\n         /* PARAMETER LISTS MUST BE COMPATIBLE */\n         IF VAR_TYPE(PROC1) = PROC_PARAM THEN PROC1 = VALUE(PROC1);\n         ELSE PROC1 = S_LIST(PROC1);\n         IF VAR_TYPE(PROC2) = PROC_PARAM THEN PROC2 = VALUE(PROC2);\n         ELSE PROC2 = S_LIST(PROC2);\n         DO WHILE (PROC1 \u00ac= NULL) & (PROC2 \u00ac= NULL);\n            IF VAR_TYPE(PROC1) \u00ac= VAR_TYPE(PROC2) THEN RETURN FALSE;\n            IF VAR_TYPE(PROC1) = PROC_PARAM THEN\n               DO;\n                  STACK1(SP) = PROC1;\n                  STACK2(SP) = PROC2;\n                  SP = SP + 1;\n               END;\n            ELSE IF \u00acCOMPTYPES(DATATYPE(PROC1), DATATYPE(PROC2)) THEN\n               RETURN FALSE;\n            PROC1 = S_LIST(PROC1);\n            PROC2 = S_LIST(PROC2);\n         END;\n         IF (PROC1 \u00ac= NULL) | (PROC2 \u00ac= NULL) THEN RETURN FALSE;\n         SP = SP - 1;\n         PROC1 = STACK1(SP);\n         PROC2 = STACK2(SP);\n      END;\n      RETURN TRUE;\n   END COMPPROCS;\n\n   /*                   THE CODE EMITTING PROCEDURE                   */\n\nEMIT_TRIPLE:\n   PROCEDURE (OP_CODE, OPND1, OPND2, STOR_LENGTH);\n      DECLARE (OP_CODE, OPND1, OPND2, STOR_LENGTH, NEW_LINE, LINE_MASK) BIT(16);\n      DECLARE NEW_LINE_TRIPLE BIT(1);\n      IF CURRENT_LINE <= LAST_LINE THEN\n         NEW_LINE, LINE_MASK, NEW_LINE_TRIPLE = 0;\n      ELSE IF (CURRENT_LINE - LAST_LINE) = 1 THEN\n         DO;\n            LAST_LINE, NEW_LINE = CURRENT_LINE;\n            LINE_MASK = \"0080\";\n            NEW_LINE_TRIPLE = FALSE;\n         END;\n      ELSE\n         DO;\n            LAST_LINE = CURRENT_LINE;\n            NEW_LINE, LINE_MASK = 0;\n            NEW_LINE_TRIPLE = TRUE;\n         END;\n      IF N_TRIPLES + 3*(NEW_LINE_TRIPLE + 1) > TRIPLE_SIZE THEN\n         DO;\n            CALL ERROR('STATEMENT PART OF BLOCK '\n                       || IDENTITY(OWNER_STACK(CURRENT_LEVEL))\n                       || ' IS TOO BIG',1);\n            N_TRIPLES = 0;\n         END;\n      IF NEW_LINE_TRIPLE THEN\n         DO;\n            TRIPLES(N_TRIPLES) = LINE#;\n            TRIPLES(N_TRIPLES + 1) = CURRENT_LINE;\n            TRIPLES(N_TRIPLES + 2) = NULL;\n            IC = IC + 1;\n            N_TRIPLES = N_TRIPLES + 3;\n         END;\n      TRIPLES(N_TRIPLES) = SHL(STOR_LENGTH, 8) | LINE_MASK | OP_CODE;\n      TRIPLES(N_TRIPLES + 1) = OPND1;\n      TRIPLES(N_TRIPLES + 2) = OPND2;\n      IC = IC + 1;\n      N_TRIPLES = N_TRIPLES + 3;\n   END EMIT_TRIPLE;\n\n      /*             GENERATE SEQUENTIAL OUTPUT FILES                   */\n\nREWIND:\n   PROCEDURE (IS_OUTPUT_FILE, FILE#);\n      DECLARE IS_OUTPUT_FILE BIT(1), FILE# FIXED;\n      CALL INLINE(\"1B\",0,0);                     /* SR   0,0               */\n      CALL INLINE(\"43\",0,0,IS_OUTPUT_FILE);      /* IC   0,IS_OUTPUT_FILE  */\n      CALL INLINE(\"41\",1,0,0,28);                /* LA  1,28               */\n      CALL INLINE(\"58\",2,0,FILE#);               /* L    2,FILE#           */\n      CALL INLINE(\"05\",12,15);                   /* BALR 12,15             */\n   END REWIND;\n\nCOREIM_DESCRIPT:\n   PROCEDURE (ADDRESS, LENGTH) CHARACTER;\n      DECLARE (ADDRESS, LENGTH, DESCRIPTOR) FIXED;\n      IF LENGTH = 0 THEN DESCRIPTOR = 0;\n      ELSE DESCRIPTOR = SHL(LENGTH - 1, 24) + ADDRESS;\n   /* WE RETURN DESCRIPTOR IN REGISTER 3 */\n      CALL INLINE(\"58\",3,0,DESCRIPTOR);          /* L    3,DESCRIPTOR      */\n   END COREIM_DESCRIPT;\n\nWRITE_TRIPLES:\n   PROCEDURE;\n      /* WRITE A CORE IMAGE OF THE TRIPLES BUFFER OUT TO A SEQUENTIALLY-\n         ACCESSED FILE */\n      DECLARE I BIT(16), TEXT CHARACTER;\n      TEXT = '%TRIPLE';\n      IF PRINT_CODE THEN TEXT = TEXT || 'E';\n      ELSE TEXT = TEXT || X1;\n      IF PRINT_TRIPLES THEN TEXT = TEXT || 'T';\n      ELSE TEXT = TEXT || X1;\n      TEXT = TEXT || IDENTITY(TRIPLES(0));\n      OUTPUT(4) = TEXT;\n      I = 0;\n      DO WHILE I < N_TRIPLES;\n         OUTPUT(4) = COREIM_DESCRIPT(ADDR(TRIPLES(I)), 80);\n         I = I + 40;   /* 2 BYTES PER ARRAY ELEMENT */\n      END;\n      OUTPUT(4) = '%END';\n   END WRITE_TRIPLES;\n\nWRITE_SYMBOLS:\n   PROCEDURE;\n      DECLARE (I,J) FIXED, (LINE,S1,S2) CHARACTER;\n      DECLARE ID CHARACTER;\n      CALL REWIND(FALSE, 2);   /* REWIND TREES FILE */\n      CALL REWIND(TRUE, 4);   /* REWIND TRIPLES FILE */\n      IF PRINT_STATISTICS THEN S1 = 'D';\n      ELSE S1 = X1;\n      OUTPUT(3) = '%SYMB' || I_FORMAT(N_DECL_SYMB, 5)\n                  || I_FORMAT(BASIC_BLOCKS, 5)\n                  || I_FORMAT(PROC_SEQUENCE_NUMBER, 5) || S1;\n      I = 0;\n      DO WHILE I < N_DECL_SYMB;\n         OUTPUT(3) = COREIM_DESCRIPT(ADDR(STORAGE_LNGTH(I)), 80);\n         I = I + 20;\n      END;\n      I = 0;\n      DO WHILE I < N_DECL_SYMB;\n         OUTPUT(3) = COREIM_DESCRIPT(ADDR(PSEUDO_REG(I)), 80);\n         I = I + 40;\n      END;\n      I = 0;\n      DO WHILE I < N_DECL_SYMB;\n         OUTPUT(3) = COREIM_DESCRIPT(ADDR(DISPLACEMENT(I)), 80);\n         I = I + 20;\n      END;\n      OUTPUT(3) = '%END';\n      CALL REWIND(TRUE, 3);   /* REWIND SYMBOL TABLE FILE */\n   END WRITE_SYMBOLS;\n\nEMIT_DATA_BYTES:\n   PROCEDURE (DATA_PTR);\n      DECLARE DATA_PTR BIT(16);\n      DECLARE (I, J, INDEX) BIT(16);\n      /* THIS PROCEDURE CREATES AN ENTRY INTO THE GLOBAL ACTIVATION RECORD\n         FOR THE SYMBOL TABLE ENTRY POINTED TO BY DATA_PTR.  ONE PAGE (80 BYTES)\n         OF THIS ACTIVATION RECORD IS KEPT IN CORE IN THE GLOBAL ARRAY\n         DATA_BYTES.  WHEN DATA_BYTES BECOMES FULL, IT IS OUTPUTTED TO\n         OUTPUT(5), AND HALFWORD_DISP(1) BECOMES ZERO.   */\n\n   WRITE_DATA:\n      PROCEDURE;\n         DECLARE J BIT(16);\n         OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);\n         HALFWORD_DISP(1) = 0;\n         CALL INLINE(\"D7\",\"4\",\"F\",DATA_BYTES, DATA_BYTES);\n                                       /* XC   DATA_BYTES(80), DATA_BYTES  */\n      END WRITE_DATA;\n\n      INDEX = DISPLACEMENT(DATA_PTR) MOD 80;\n      IF VAR_TYPE(DATA_PTR) = CONSTANT THEN\n         DO I = 1 TO STORAGE_LNGTH(DATA_PTR);\n            IF INDEX = 0 THEN CALL WRITE_DATA;\n            J = SHL(STORAGE_LNGTH(DATA_PTR) - I, 3);\n            DATA_BYTES(INDEX) = SHR(VALUE(DATA_PTR), J);\n            INDEX = (INDEX + 1) MOD 80;\n         END;\n      ELSE IF VAR_TYPE(DATA_PTR) = LITERAL THEN\n         DO I = 0 TO STORAGE_LNGTH(DATA_PTR) - 1;\n            IF INDEX = 0 THEN CALL WRITE_DATA;\n            DATA_BYTES(INDEX) = BYTE(IDENTITY(DATA_PTR), I);\n            INDEX = (INDEX + 1) MOD 80;\n         END;\n      ELSE /* VAR_TYPE(DATA_PTR) IN (.VARIABLE, VAR_PARAM, PROC_PARAM.) */\n         IF (INDEX = 0) | (INDEX + STORAGE_LNGTH(DATA_PTR) > 80) THEN\n            DO;\n               CALL WRITE_DATA;\n               DO I = 1 TO (STORAGE_LNGTH(DATA_PTR) - INDEX - 1) / 80;\n                  OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);\n               END;\n            END;\n   END EMIT_DATA_BYTES;\n\nPREPARE_POST_MORTEM_TABLES:\n   PROCEDURE;\n      DECLARE (I, OWNER_PTR, RELOCATION_INDEX, PROCSEQ#) FIXED,\n                     ID_BUFFER CHARACTER, PMD_FILE BIT(16) INITIAL (7),\n              SYT_CASE(16) BIT(8) INITIAL(0,2,4,0,3,1,0,0,0,0,0,0,0,0,0,0,0);\n      /* SET_OF_SIMPLE_TYPES INCLUDES SCALAR, SUBRANGE, POINTER AND ARITHMETIC.\n         BITS ARE ENUMERATED FROM THE RIGHT.   */\n      DECLARE SET_OF_SIMPLE_TYPES BIT(16) INITIAL (\"(1) 01000000 00001110\");\n      /* STORAGE OCCUPIED BY THE ARRAYS 'OWNER_STACK', 'ARRAYS_ALLOCATED',\n         'STACK_LIMIT' AND 'HALFWORD_DISP' IS OVERLAID TO SAVE SPACE.   */\n      DECLARE LIST_END LITERALLY 'OWNER_STACK',\n              PROCEDURE_HEADING LITERALLY 'STACK_LIMIT';\n\n   IS_STRING:\n      PROCEDURE (TYPE_PTR) BIT(1);\n         DECLARE TYPE_PTR BIT(16);   /* POINTER TO TYPE ENTRY IN SY_TABLE */\n         RETURN (STRUCTYPE(TYPE_PTR) = ARRAY)\n                & COMPTYPES(DATATYPE(TYPE_PTR), CHARPTR);\n      END IS_STRING;\n\n   WRITE_COLUMN:\n      PROCEDURE (ARRAY_ADDR, ITEMS_PER_IMAGE, LIMIT);\n         DECLARE (ARRAY_ADDR, ITEMS_PER_IMAGE, LIMIT, I, J) FIXED;\n         I, J = 0;\n         DO WHILE I <= LIMIT;\n            OUTPUT(PMD_FILE) = COREIM_DESCRIPT(ARRAY_ADDR + J, 80);\n            I = I + ITEMS_PER_IMAGE;\n            J = J + 80;\n         END;\n      END WRITE_COLUMN;\n\n      /* INITIALIZE LIST_END AND PROCEDURE_HEADING */\n      DO I = 0 TO PROC_SEQUENCE_NUMBER;\n         LIST_END(I), PROCEDURE_HEADING(I) = NULL;\n      END;\n      RELOCATION_INDEX = -1;\n      DO I = 0 TO N_ANONYMOUS_SYMB - 1;\n         DO CASE SYT_CASE(VAR_TYPE(I));\n            /* CASE 0 -- NOT OT BE COPIED */\n            WHERE_DECL(I) = NULL;\n            /* CASE 1 -- A PROCEDURE HEADING */\n            IF I > N_PREDECLARED_SYMB THEN\n               DO;   /* A USER-DEFINED PROCEDURE */\n                  IDENTITY(I) = PAD(IDENTITY(I), 12);\n                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);\n                  IF DATATYPE(I) \u00ac= NULL THEN\n                     DO;   /* A FUNCTION PROCEDURE */\n                        DATATYPE(I) = WHERE_DECL(DATATYPE(I));\n                        OWNER(I) = 4;   /* STORAGE_LNGTH */\n                     END;\n                  ELSE OWNER(I) = 0;\n                  S_LIST(I) = NULL;\n                  RELOCATION_INDEX, WHERE_DECL(I) = RELOCATION_INDEX + 1;\n                  PROCEDURE_HEADING(VALUE(I)) = RELOCATION_INDEX;\n               END;\n            ELSE WHERE_DECL(I) = NULL;\n            /* CASE 2 -- A VARIABLE */\n            IF (SHR(SET_OF_SIMPLE_TYPES, STRUCTYPE(I)) & 1)\n               | IS_STRING(DATATYPE(I)) THEN\n               DO;\n                  IDENTITY(I) = PAD(IDENTITY(I), 12);\n                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);\n                  /* RELOCATE THE DATATYPE POINTER */\n                  IF STRUCTYPE(I) = SUBRANGE THEN\n                     DO;\n                        VALUE(I) = VALUE(S_LIST(DATATYPE(I)));\n                        DATATYPE(I) = WHERE_DECL(DATATYPE(DATATYPE(I)));\n                     END;\n                  ELSE\n                     DO;\n                        VALUE(I) = 0;\n                        IF DATATYPE(I) >= N_ANONYMOUS_SYMB THEN\n                           DO;\n                              IF STRUCTYPE(I) = SCALAR THEN\n                                 DATATYPE(I) = S_LIST(DATATYPE(I)) +\n                                               RELOCATION_INDEX - I + 1;\n                              ELSE /* CHARACTER ARRAY */\n                                 DATATYPE(I) = WHERE_DECL(CHARPTR);\n                           END;\n                     ELSE DATATYPE(I) = WHERE_DECL(DATATYPE(I));\n                     END;\n                  OWNER_PTR = OWNER(I);\n                  PROCSEQ# = VALUE(OWNER_PTR);\n                  RELOCATION_INDEX, WHERE_DECL(I) = RELOCATION_INDEX + 1;\n                  /* USE THE OWNER FIELD FOR STORAGE_LNGTH */\n                  OWNER(I) = STORAGE_LNGTH(I);\n                  S_LIST(I) = NULL;\n                  /* ATTACH THIS SYT ENTRY TO THE LIST OF OWNER'S VARIABLES */\n                  IF LIST_END(PROCSEQ#) = NULL THEN\n                     S_LIST(OWNER_PTR) = RELOCATION_INDEX;\n                  ELSE S_LIST(LIST_END(PROCSEQ#)) = RELOCATION_INDEX;\n                  LIST_END(PROCSEQ#) = I;\n               END;\n            ELSE WHERE_DECL(I) = NULL;\n            /* CASE 3 -- A TYPE */\n            IF (STRUCTYPE(I) = SCALAR) | (STRUCTYPE(I) = ARITHMETIC) THEN\n               DO;\n                  IDENTITY(I) = PAD(IDENTITY(I), 12);\n                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);\n                  OWNER(I) = STORAGE_LNGTH(I);\n                  RELOCATION_INDEX, WHERE_DECL(I), DATATYPE(I) =\n                     RELOCATION_INDEX + 1;\n               END;\n            ELSE WHERE_DECL(I) = NULL;\n            /* CASE 4 -- A CONSTANT */\n            IF STRUCTYPE(I) = SCALAR THEN\n               DO;\n                  IDENTITY(I) = PAD(IDENTITY(I), 12);\n                  IDENTITY(I) = SUBSTR(IDENTITY(I),0,12);\n                  RELOCATION_INDEX, WHERE_DECL(I) = RELOCATION_INDEX + 1;\n                  IF VALUE(I) = 0 THEN\n                     DO;\n                        IF DATATYPE(I) >= N_ANONYMOUS_SYMB THEN\n                           DATATYPE(I) = I;\n                        S_LIST(DATATYPE(I)) = RELOCATION_INDEX;\n                        DATATYPE(I) = WHERE_DECL(DATATYPE(I));\n                     END;\n                  ELSE DATATYPE(I) = DATATYPE(I - 1);\n               END;\n            ELSE WHERE_DECL(I) = NULL;\n         END;   /* CASE */\n      END;   /* DO I */\n      DATATYPE(FALSEPTR), DATATYPE(TRUEPTR) = WHERE_DECL(BOOLPTR);\n      /* COMPRESS THE SYMBOL TABLE */\n      N_DECL_SYMB = 2;\n      DO I = 3 TO N_ANONYMOUS_SYMB - 1;\n         IF WHERE_DECL(I) \u00ac= NULL THEN\n            DO;\n               IDENTITY(N_DECL_SYMB) = IDENTITY(I);\n               DATATYPE(N_DECL_SYMB) = DATATYPE(I);\n               VAR_TYPE(N_DECL_SYMB) = VAR_TYPE(I);\n               STRUCTYPE(N_DECL_SYMB) = STRUCTYPE(I);\n               OWNER(N_DECL_SYMB) = OWNER(I);\n               S_LIST(N_DECL_SYMB) = S_LIST(I);\n               DISPLACEMENT(N_DECL_SYMB) = DISPLACEMENT(I);\n               VALUE(N_DECL_SYMB) = VALUE(I);\n               N_DECL_SYMB = N_DECL_SYMB + 1;\n            END;\n      END;\n      N_DECL_SYMB = N_DECL_SYMB - 1;\n      /* OUTPUT THE POST MORTEM INFO */\n      OUTPUT(PMD_FILE) = '%PMD ' || I_FORMAT(N_DECL_SYMB, 5)\n                         || I_FORMAT(PROC_SEQUENCE_NUMBER, 5);\n      /* WRITE OUT THE IDENTITY COLUMN */\n      ID_BUFFER = '';\n      DO I = 0 TO N_DECL_SYMB;\n         ID_BUFFER = ID_BUFFER || IDENTITY(I);\n         IF LENGTH(ID_BUFFER) > 80 THEN\n            DO;\n               OUTPUT(PMD_FILE) = SUBSTR(ID_BUFFER,0,80);\n               ID_BUFFER = SUBSTR(ID_BUFFER,80);\n            END;\n      END;\n      OUTPUT(PMD_FILE) = ID_BUFFER;\n      /* WRITE OUT THE OTHER SYMBOL TABLE COLUMNS OF INTEREST */\n      CALL WRITE_COLUMN(ADDR(DATATYPE), 40, N_DECL_SYMB);\n      CALL WRITE_COLUMN(ADDR(VAR_TYPE), 40, N_DECL_SYMB);\n      CALL WRITE_COLUMN(ADDR(STRUCTYPE), 40, N_DECL_SYMB);\n      CALL WRITE_COLUMN(ADDR(OWNER), 40, N_DECL_SYMB);\n      CALL WRITE_COLUMN(ADDR(S_LIST), 40, N_DECL_SYMB);\n      CALL WRITE_COLUMN(ADDR(DISPLACEMENT), 20, N_DECL_SYMB);\n      CALL WRITE_COLUMN(ADDR(VALUE), 20, N_DECL_SYMB);\n      /* WRITE THE PROCEDURE HEADING TABLE */\n      CALL WRITE_COLUMN(ADDR(PROCEDURE_HEADING), 20, PROC_SEQUENCE_NUMBER);\n      OUTPUT(PMD_FILE) = '%END';\n      CALL REWIND(TRUE, PMD_FILE);\n      IF \u00acPRINT_SYMBOLS THEN RETURN;\n      /* PRINT THE PROCEDURE HEADING TABLE */\n      EJECT_PAGE;\n      OUTPUT = 'PROCEDURE HEADING TABLE';\n      DOUBLE_SPACE;\n      DO I = 0 TO PROC_SEQUENCE_NUMBER;\n         OUTPUT = IDENTITY(PROCEDURE_HEADING(I)) || X4 || 'INDEX = ' ||\n                  I_FORMAT(PROCEDURE_HEADING(I), 4);\n      END;\n      N_DECL_SYMB = N_DECL_SYMB + 1;\n      CALL SY_DUMP;\n   END PREPARE_POST_MORTEM_TABLES;\n\n   /*       PROCEDURES FOR EMITTING BLOCK COUNTERS FOR FLOW SUMMARY       */\n\nDGNS#_PUSH:\n  PROCEDURE;\n      DGNS#_DEPTH = DGNS#_DEPTH + 1;\n      DGNS#_GOTO, DGNS#_TOP, DGNS#_STACK(DGNS#_DEPTH) = FALSE;\n   END DGNS#_PUSH;\n\nDGNS#_POP:\n   PROCEDURE;\n      DGNS#_GOTO = DGNS#_TOP & (DGNS#_DEPTH > 0);\n      DGNS#_DEPTH = DGNS#_DEPTH - 1;\n      IF DGNS#_DEPTH >= 0 THEN\n         DO;\n            DGNS#_TOP = DGNS#_TOP | DGNS#_STACK(DGNS#_DEPTH);\n            DGNS#_STACK(DGNS#_DEPTH) = DGNS#_TOP;\n         END;\n   END DGNS#_POP;\n\nEMIT_ADD_DECIMAL:\n   PROCEDURE;\n      IF MONITOR_LINK(2) < 2 THEN RETURN;\n      CALL EMIT_TRIPLE(ADD_DECIMAL, BASIC_BLOCKS, 1 | MASK_IMMEDIATE, 0);\n      BASIC_BLOCKS = BASIC_BLOCKS + 1;\n   END EMIT_ADD_DECIMAL;\n\nNEXT_FREE_ROW:\n   PROCEDURE FIXED;\n         /* THIS PROCEDURE ALLOCATES A NEW SYMBOL TABLE ENTRY.  IT REFERS TO,\n         AND UPDATES, THE GLOBAL VARIABLE N_DECL_SYMB.   */\n      IF N_DECL_SYMB < TABLE_LENGTH THEN N_DECL_SYMB = N_DECL_SYMB + 1;\n      ELSE CALL ERROR(\n         'SYMBOL TABLE OVERFLOW WHILE ALLOCATING TEMPORARIES OR CONSTANTS', 1);\n      RETURN N_DECL_SYMB - 1;\n   END NEXT_FREE_ROW;\n\n   /*           PROCEDURE FOR CREATING AN OPERAND OUT OF AN            */\n   /*                        INTEGER CONSTANT.                         */\n\nFINDCONST:\n   PROCEDURE (INTCONST) BIT(16);\n      /* WE CREATE AN INTEGER CONSTANT OPERAND FOR A TRIPLE.  IF IT IS\n         TOO LARGE TO BE AN IMMEDIATE OPERAND, WE SEARCH THE SYMBOL TABLE\n         FOR THE INTEGER CONSTANT INTCONST.  IF WE THEN DO NOT FIND IT,\n         WE ENTER IT, AND RETURN ITS INDEX.                                */\n      DECLARE INTCONST FIXED, INDEX BIT(16);\n      IF (0 <= INTCONST) & (INTCONST < 4096) THEN\n         /* RETURN AN IMMEDIATE OPERAND */\n         RETURN INTCONST | MASK_IMMEDIATE;\n      INDEX = S_LIST(INTPTR);\n      DO WHILE INDEX \u00ac= NULL;\n         IF VALUE(INDEX) = INTCONST THEN RETURN INDEX | MASK_SYMBOL;\n         INDEX = S_LIST(INDEX);\n      END;\n      INDEX = N_DECL_SYMB;\n      N_DECL_SYMB = N_DECL_SYMB + 1;\n      IF N_DECL_SYMB > TABLE_LENGTH THEN\n         DO;\n            CALL ERROR('SYMBOL TABLE OVERFLOW', 1);\n            RETURN;\n         END;\n      S_LIST(INDEX) = S_LIST(INTPTR);\n      S_LIST(INTPTR) = INDEX;\n      DATATYPE(INDEX) = INTPTR;\n      VAR_TYPE(INDEX) = CONSTANT;\n      STRUCTYPE(INDEX) = ARITHMETIC;\n      VALUE(INDEX) = INTCONST;\n      STORAGE_LNGTH(INDEX) = 4;\n      PSEUDO_REG(INDEX) = 0;\n      DISPLACEMENT(INDEX) = STACK_LIMIT(1);\n      STACK_LIMIT(1) = STACK_LIMIT(1) + 4;\n      CALL EMIT_DATA_BYTES(INDEX);\n      RETURN INDEX | MASK_SYMBOL;\n   END FINDCONST;\n\nFINDREAL:\n   PROCEDURE (REALCONST) BIT(16);\n      /* WE CREATE A REAL CONSTANT OPERAND FOR A TRIPLE.  FIRST WE SEARCH THE\n         SYMBOL TABLE FOR THE REAL CONSTANT \"REALCONST\".  IF WE THEN DO NOT\n         FIND IT WE ENTER IT AND RETURN ITS INDEX.                           */\n      DECLARE REALCONST FIXED, INDEX BIT(16);\n      INDEX = S_LIST(REALPTR);\n      DO WHILE INDEX \u00ac= NULL;\n         IF VALUE(INDEX) = REALCONST THEN RETURN INDEX | MASK_SYMBOL;\n         INDEX = S_LIST(INDEX);\n      END;\n      INDEX = N_DECL_SYMB;\n      N_DECL_SYMB = N_DECL_SYMB + 1;\n      IF N_DECL_SYMB > TABLE_LENGTH THEN\n         DO;\n            CALL ERROR('SYMBOL TABLE OVERFLOW', 1);\n            RETURN;\n         END;\n      S_LIST(INDEX) = S_LIST(REALPTR);\n      S_LIST(REALPTR) = INDEX;\n      DATATYPE(INDEX) = REALPTR;\n      VAR_TYPE(INDEX) = CONSTANT;\n      STRUCTYPE(INDEX) = ARITHMETIC;\n      VALUE(INDEX) = REALCONST;\n      STORAGE_LNGTH(INDEX) = 4;\n      PSEUDO_REG(INDEX) = 0;\n      DISPLACEMENT(INDEX) = STACK_LIMIT(1);\n      STACK_LIMIT(1) = STACK_LIMIT(1) + 4;\n      CALL EMIT_DATA_BYTES(INDEX);\n      RETURN INDEX | MASK_SYMBOL;\n   END FINDREAL;\n\n   /*                   THE TRIPLES - SYNTHESIZER                     */\n\nRANGE_CHECK:\n   PROCEDURE (TYPE, LOWBOUND, HIGHBOUND);\n      /* WHEN THIS PROCEDURE IS CALLED, THE TOP ELEMENT OF OPERAND#STK\n         HAS JUST BEEN COERCED TO A SUBRANGE TYPE, AND NODE HAS BEEN\n         REPLACED IN PARSE_TREE BY A POINTER TO THAT TYPE.  WE EMIT\n         TRIPLES TO CHECK WHETHER THE COERCION HAS INDEED RESULTED IN\n         A VALUE WITHIN THE TARGET RANGE.                             */\n      DECLARE (TYPE, OPND) BIT(16), (LOWBOUND, HIGHBOUND) BIT(1);\n      IF MONITOR_LINK(2) = 0 THEN /* DEBUG LEVEL = 0 */ RETURN;\n      IF \u00ac(LOWBOUND | HIGHBOUND) THEN RETURN;\n      OPND = OPERAND#STK(#OP);\n      /* IF OPND IS NOT IN A REGISTER, LOAD IT */\n      IF (OPND & \"C000\") \u00ac= (MASK_TRIPLE & \"C000\") THEN\n         DO;\n            CALL EMIT_TRIPLE(LOAD, OPND, NULL, 3);\n            OPND, OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n         END;\n      IF LOWBOUND THEN\n         DO; /* SEE IF OPERAND IS LESS THAN ZERO */\n            CALL EMIT_TRIPLE(LESS, OPND | MASK_TEMP, 0 | MASK_IMMEDIATE, 0);\n            IF HIGHBOUND THEN\n               CALL EMIT_TRIPLE(BNZ, (N_TRIPLES + 9) | MASK_TRIPLE,\n                                (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n            ELSE CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 6) | MASK_TRIPLE,\n                                  (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n         END;\n      IF HIGHBOUND THEN\n         DO; /* SEE IF OPERAND IS GREATER THAN HIGHBOUND */\n            CALL EMIT_TRIPLE(GREATER, OPND | MASK_TEMP,\n               FINDCONST(STORAGE_LNGTH(TYPE) - 1), 0);\n            CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 3*LOWBOUND + 6) | MASK_TRIPLE,\n                             (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n            IF LOWBOUND THEN CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);\n         END;\n      /* VALUE OUT OF RANGE -- CALL THE MONITOR */\n      CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);\n      CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);\n   END RANGE_CHECK;\n\nCOERCE_ASSIGNMENT:\n   PROCEDURE (TYPE1, TYPE2);\n      /* WE HAVE TWO OPERANDS, OPND1 AND OPND2, OF TYPES TYPE1 AND TYPE2\n         RESPECTIVELY.  OPND2 IS THE TOP ELEMENT OF OPERAND#STK.  WE WISH\n         TO ASSIGN THE VALUE OF OPND2 TO OPND1.  THIS PROCEDURE WILL PER-\n         FORM A LEGAL IMPLICIT TYPE COERCION FROM TYPE2 TO TYPE1 IF\n         NECESSARY.                                                         */\n      DECLARE (TYPE1, TYPE2, OPND2) BIT(16);\n      DECLARE (LOW1, LOW2) FIXED;\n      DECLARE RANGE_ERR CHARACTER INITIAL('VALUE OUT OF RANGE');\n      DECLARE INCOMPATIBLE_DATATYPES CHARACTER INITIAL (\n         'INCOMPATIBLE DATATYPES');\n      DECLARE ERROR_FLAG BIT(1);\n      DECLARE I FIXED, OFFSET FIXED;\n      IF COMPTYPES(TYPE1, TYPE2) THEN\n         /* NO COERCION IS NECESSARY */ RETURN;\n      OPND2 = OPERAND#STK(#OP);\n      IF STRUCTYPE(TYPE1) \u00ac= STRUCTYPE(TYPE2) THEN\n         DO;\n            IF ((STRUCTYPE(TYPE2) = SCALAR) | (STRUCTYPE(TYPE2) = ARITHMETIC)) &\n               (STRUCTYPE(TYPE1) = SUBRANGE) THEN\n               DO;\n                  LOW1 = VALUE(S_LIST(TYPE1));\n                  IF COMPTYPES(TYPE2, DATATYPE(TYPE1)) THEN\n                     DO; /* COERCE SCALAR TO SUBRANGE */\n                        IF (OPND2 & \"C000\") = MASK_IMMEDIATE THEN\n                           OPND2, OPERAND#STK(#OP) =\n                              FINDCONST((OPND2 & \"3FFF\") - LOW1);\n                        ELSE IF ((OPND2 & \"C000\") = MASK_SYMBOL) &\n                           (VAR_TYPE(OPND2) = CONSTANT) THEN\n                           OPND2, OPERAND#STK(#OP) =\n                              FINDCONST(VALUE(OPND2) - LOW1);\n                        ELSE IF VALUE(LOW1) = 1 THEN\n                           DO;\n                              CALL EMIT_TRIPLE(SUBTRACT, OPND2,\n                                 1 | MASK_IMMEDIATE, 3);\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                              OPND2 = OPERAND#STK(#OP);\n                           END;\n                        ELSE IF LOW1 \u00ac= 0 THEN\n                           DO;\n                              CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(-LOW1), 3);\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                              OPND2 = OPERAND#STK(#OP);\n                           END;\n                        IF (OPND2 & \"C000\") = MASK_IMMEDIATE THEN\n                           DO;\n                              IF (OPND2 & \"3FFF\") + LOW1 > VALUE(TYPE1) THEN\n                                 DO;\n                                    CALL ERROR(RANGE_ERR, 0);\n                                    CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);\n                                 END;\n                           END;\n                        ELSE IF ((OPND2 & \"C000\") = MASK_SYMBOL) &\n                                (VAR_TYPE(OPND2) = CONSTANT) THEN\n                           DO;\n                              IF (VALUE(OPND2) > STORAGE_LNGTH(TYPE1)) |\n                                 (VALUE(OPND2) < 0) THEN\n                                 DO;\n                                    CALL ERROR(RANGE_ERR, 0);\n                                    CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);\n                                 END;\n                           END;\n                        ELSE CALL RANGE_CHECK(TYPE1, TRUE, TRUE);\n                        CALL REPLACE(TYPE1);\n                        RETURN;\n                     END;\n                  ELSE\n                     DO;\n                        CALL ERROR(INCOMPATIBLE_DATATYPES, 1);\n                        RETURN;\n                     END;\n               END;\n            ELSE IF ((STRUCTYPE(TYPE1) = SCALAR) |\n                     (STRUCTYPE(TYPE1) = ARITHMETIC)) &\n                    (STRUCTYPE(TYPE2) = SUBRANGE) THEN\n               DO;  /* COERCE SUBRANGE TO SCALAR */\n                  LOW2 = VALUE(S_LIST(TYPE2));\n                  IF LOW2 \u00ac= 0 THEN\n                     DO;\n                        CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOW2), 3);\n                        OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                     END;\n                  TYPE2 = DATATYPE(TYPE2);\n                  CALL REPLACE(TYPE1);\n                  IF COMPTYPES(TYPE1, TYPE2) THEN RETURN;\n                  /* ELSE DO NOT RETURN;  MAY HAVE TO FLOAT OPND2 */\n                  OPND2 = OPERAND#STK(#OP);\n               END;\n            ELSE\n               DO;\n                  CALL ERROR(INCOMPATIBLE_DATATYPES, 1);\n                  RETURN;\n               END;\n         END;\n      /* NOW STRUCTYPE(TYPE1) = STRUCTYPE(TYPE2), AND \u00acCOMPTYPES(TYPE1,TYPE2) */\n      IF STRUCTYPE(TYPE1) = ARITHMETIC THEN\n         DO;\n            IF COMPTYPES(TYPE1, REALPTR) & COMPTYPES(TYPE2, INTPTR) THEN\n               DO;  /* FLOAT OPERAND 2 */\n                  CALL EMIT_TRIPLE(FLOAT, OPND2, NULL, 3);\n                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                  CALL REPLACE(REALPTR);\n               END;\n            ELSE CALL ERROR('ILLEGAL REAL EXPRESSION', 1);\n         END;\n      ELSE IF STRUCTYPE(TYPE1) = SUBRANGE THEN\n         DO;\n            IF \u00acCOMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2)) THEN\n               DO;\n                  CALL ERROR(INCOMPATIBLE_DATATYPES, 1);\n                  RETURN;\n               END;\n            /* COERCE TYPE2 TO TYPE1 */\n            LOW1 = VALUE(S_LIST(TYPE1));\n            LOW2 = VALUE(S_LIST(TYPE2));\n            IF LOW1 \u00ac= LOW2 THEN\n               DO;\n                  CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOW2 - LOW1), 3);\n                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n               END;\n            CALL RANGE_CHECK(TYPE1, (LOW1 > LOW2),\n               (VALUE(TYPE1) < VALUE(TYPE2)));\n            CALL REPLACE(TYPE1);\n         END;\n      ELSE IF STRUCTYPE(TYPE1) = SET THEN\n         DO;\n            ERROR_FLAG = \u00acCOMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2));\n            IF \u00acERROR_FLAG THEN\n               DO;\n                  LOW1 = VALUE(TYPE1);\n                  LOW2 = VALUE(TYPE2);\n                  OFFSET =\n                     LOW1 + STORAGE_LNGTH(TYPE1) - LOW2 - STORAGE_LNGTH(TYPE2);\n                  ERROR_FLAG = (LOW1 > LOW2) | (OFFSET < 0);\n               END;\n            IF ERROR_FLAG THEN\n               DO;\n                  CALL REPLACE(EMPTYSETPTR);\n                  CALL ERROR('INCOMPATIBLE SET TYPES', 1);\n                  RETURN;\n               END;\n            /* COERCE TYPE2 TO TYPE1 */\n            I = N_TRIPLES | MASK_TEMP;\n            CALL EMIT_TRIPLE(TEMP, NULL, 0, STORAGE_LNGTH(TYPE1) - 1);\n            CALL EMIT_TRIPLE(XOR, I, I, 0);\n            CALL EMIT_TRIPLE(INDEX, I, FINDCONST(LOW2 - LOW1),\n                             STORAGE_LNGTH(TYPE2) - 1);\n            CALL EMIT_TRIPLE(MOVE, (N_TRIPLES - 3) | MASK_TRIPLE, OPND2, 0);\n            OPERAND#STK(#OP) = I & \"BFFF\";\n            CALL REPLACE(TYPE1);\n         END;\n      ELSE CALL ERROR(INCOMPATIBLE_DATATYPES, 1);\n   END COERCE_ASSIGNMENT;\n\nCOERCE_PARAMETER:\n   PROCEDURE (ACTUAL, FORMAL, ACTUAL_TYPE);\n      DECLARE (ACTUAL, FORMAL, ACTUAL_TYPE) BIT(16);\n      DECLARE VAR_ERR CHARACTER INITIAL ('VAR PARAMETER MUST BE A VARIABLE');\n      IF VAR_TYPE(FORMAL) = VARIABLE THEN\n         DO;\n            IF (ACTUAL & \"C000\") = MASK_SYMBOL THEN\n               IF VAR_TYPE(ACTUAL) = VAR_PARAM THEN\n                  DO;\n                     CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE, ACTUAL,\n                                      STORAGE_LNGTH(FORMAL) - 1);\n                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                     IF STORAGE_LNGTH(FORMAL) > 255 THEN\n                        CALL EMIT_TRIPLE(S_LENGTH, SHR(STORAGE_LNGTH(FORMAL),\n                           16), STORAGE_LNGTH(FORMAL), 0);\n                  END;\n            CALL COERCE_ASSIGNMENT(DATATYPE(FORMAL), ACTUAL_TYPE);\n         END;\n      ELSE IF VAR_TYPE(FORMAL) = VAR_PARAM THEN\n         DO;\n            IF \u00ac COMPTYPES(DATATYPE(FORMAL), ACTUAL_TYPE) THEN\n               CALL ERROR('VAR PARAMETER NOT COMPATIBLE WITH TYPE '\n                          || IDENTITY(DATATYPE(FORMAL)), 1);\n            IF (ACTUAL & \"C000\") = MASK_SYMBOL THEN\n               DO;\n                  IF VAR_TYPE(ACTUAL) = VARIABLE THEN\n                     DO;\n                        CALL EMIT_TRIPLE(LOAD_ADDR, ACTUAL, NULL, 3);\n                        OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                     END;\n                  ELSE IF VAR_TYPE(ACTUAL) \u00ac= VAR_PARAM THEN\n                     CALL ERROR('VAR PARAMETER MUST BE A VARIABLE', 1);\n               END;\n            ELSE IF (ACTUAL & \"C000\") = MASK_IMMEDIATE THEN\n               CALL ERROR (VAR_ERR, 1);\n            ELSE\n               DO;   /* ACTUAL PARAMETER MUST BE AN INDEX TRIPLE */\n                  IF (TRIPLES(ACTUAL & \"3FFF\") & \"7F\") \u00ac= INDEX THEN\n                     CALL ERROR (VAR_ERR, 1);\n                  ELSE IF (STRUCTYPE(ACTUAL_TYPE) = SCALAR)\n                        | (STRUCTYPE(ACTUAL_TYPE) = SUBRANGE) THEN\n                        IF SHR(TRIPLES(ACTUAL & \"3FFF\"), 8) = 0 THEN\n                           CALL ERROR (\n             'VAR PARAMETER MUST NOT BE A SCALAR OR SUBRANGE ARRAY ELEMENT', 1);\n                  CALL EMIT_TRIPLE(LOAD_ADDR, ACTUAL, NULL, 3);\n                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n               END;\n         END;\n      ELSE   /* VAR_TYPE(FORMAL) = PROC_PARAM */\n         DO;\n            IF ((ACTUAL & \"C000\") \u00ac= MASK_SYMBOL)\n               | ((ACTUAL & \"3FFF\") >= N_ANONYMOUS_SYMB) THEN\n               CALL ERROR('IN PARAMETER LIST - PROCEDURE/FUNCTION NAME EXPECTED'\n                          , 1);\n            ELSE IF (SHL(1, VAR_TYPE(ACTUAL)) & \"(1)01000000010100000\") = 0 THEN\n               /* \u00ac(VAR_TYPE(ACTUAL) IN (.PROC, PROC_PARAM, MULTDECL.)) */\n               CALL ERROR(IDENTITY(ACTUAL) || ' IS NOT A PROCEDURE/FUNCTION',1);\n            ELSE IF STRUCTYPE(ACTUAL) = STANDARD THEN\n               CALL ERROR('ATTEMPT TO PASS STANDARD PROCEDURE/FUNCTION '\n                          || IDENTITY(ACTUAL), 1);\n            ELSE IF \u00acCOMPPROCS(ACTUAL, FORMAL) THEN\n               CALL ERROR(IDENTITY(ACTUAL) || ' IS NOT COMPATIBLE WITH '\n                          || IDENTITY(FORMAL), 1);\n            ELSE IF VAR_TYPE(ACTUAL) \u00ac= PROC_PARAM THEN\n               DO;\n                  CALL EMIT_TRIPLE(PROCPARM, ACTUAL, FINDCONST(VALUE(ACTUAL)),\n                                   0);\n                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n               END;\n         END;\n   END COERCE_PARAMETER;\n\nCOERCE_OP:\n   PROCEDURE;\n      /* WE ARE GIVEN TWO OPERANDS, OPND1 AND OPND2, OF TYPES TYPE1 AND TYPE2\n         RESPECTIVELY.  OPND1 AND OPND2 ARE THE TOP TWO ELEMENTS OF OPERAND#STK.\n         WE WISH TO COMBINE THEM USING SOME ARITHMETIC OR COMPARISON OPERATOR.\n         IN DOING SO, HOWEVER, WE MAY FIRST HAVE TO COERCE SUBRANGE TO SCALAR OR\n         INTEGER TO REAL, IN ACCORDANCE WITH THE AXIOMATIC DEFINITION OF PASCAL.\n      */\n      DECLARE (OPND1, OPND2, TYPE1, TYPE2) BIT(16);\n      DECLARE INCOMPATIBLE_DATATYPES CHARACTER INITIAL (\n         'INCOMPATIBLE DATATYPES');\n      DECLARE LOWBOUND FIXED;\n      DECLARE (I, ST_LNGTH, HIGHBOUND) FIXED, SET_TYPE_PTR BIT(16);\n      OPND1 = OPERAND#STK(#OP - 1);\n      OPND2 = OPERAND#STK(#OP);\n      TYPE1 = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP));\n      TYPE2 = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 1);\n      IF STRUCTYPE(TYPE1) = SUBRANGE THEN\n         DO;   /* COERCE OPERAND 1 FROM SUBRANGE TO SCALAR */\n            LOWBOUND = VALUE(S_LIST(TYPE1));\n            IF LOWBOUND \u00ac= 0 THEN\n               DO;\n                  CALL EMIT_TRIPLE(ADD, OPND1, FINDCONST(LOWBOUND), 3);\n                  OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                  OPND1 = OPERAND#STK(#OP - 1);\n               END;\n            TYPE1 = DATATYPE(TYPE1);\n            CALL REPLACE_LEFT_BRO(TYPE1);\n         END;\n      IF STRUCTYPE(TYPE2) = SUBRANGE THEN\n         DO;   /* COERCE OPERAND 2 FROM SUBRANGE TO SCALAR */\n            LOWBOUND = VALUE(S_LIST(TYPE2));\n            IF LOWBOUND \u00ac= 0 THEN\n               DO;\n                  CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOWBOUND), 3);\n                  OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                  OPND2 = OPERAND#STK(#OP);\n               END;\n            TYPE2 = DATATYPE(TYPE2);\n            CALL REPLACE(TYPE2);\n         END;\n      IF COMPTYPES(TYPE1, TYPE2) THEN RETURN;\n      IF (STRUCTYPE(TYPE1) = SET) & (STRUCTYPE(TYPE2) = SET) THEN\n         DO;\n            IF \u00acCOMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2)) THEN\n               DO;\n                  CALL ERROR('INCOMPATIBLE SET TYPES', 1);\n                  CALL REPLACE(EMPTYSETPTR);\n                  CALL REPLACE_LEFT_BRO(EMPTYSETPTR);\n                  RETURN;\n               END;\n            IF VALUE(TYPE1) < VALUE(TYPE2) THEN\n               LOWBOUND = VALUE(TYPE1);\n            ELSE LOWBOUND = VALUE(TYPE2);\n            IF (VALUE(TYPE1) + STORAGE_LNGTH(TYPE1))\n               > (VALUE(TYPE2) + STORAGE_LNGTH(TYPE2)) THEN\n               HIGHBOUND = VALUE(TYPE1) + STORAGE_LNGTH(TYPE1);\n            ELSE HIGHBOUND = VALUE(TYPE2) + STORAGE_LNGTH(TYPE2);\n            ST_LNGTH = HIGHBOUND - LOWBOUND;\n            IF ST_LNGTH > 256 THEN\n               DO;\n                  CALL ERROR('SET EXPRESSION REQUIRES MORE THAN 256 BYTES', 1);\n                  CALL REPLACE(EMPTYSETPTR);\n                  CALL REPLACE_LEFT_BRO(EMPTYSETPTR);\n                  RETURN;\n               END;\n            SET_TYPE_PTR = NEXT_FREE_ROW;\n            DATATYPE(SET_TYPE_PTR) = DATATYPE(TYPE1);\n            VALUE(SET_TYPE_PTR) = LOWBOUND;\n            STORAGE_LNGTH(SET_TYPE_PTR) = ST_LNGTH;\n            STRUCTYPE(SET_TYPE_PTR) = SET;\n            VAR_TYPE(SET_TYPE_PTR) = TYPE;\n            IF COMPTYPES(TYPE1, SET_TYPE_PTR) THEN\n               DO;\n                  N_DECL_SYMB = N_DECL_SYMB - 1;\n                  SET_TYPE_PTR = TYPE1;\n               END;\n            ELSE IF COMPTYPES(TYPE2, SET_TYPE_PTR) THEN\n               DO;\n                  N_DECL_SYMB = N_DECL_SYMB - 1;\n                  SET_TYPE_PTR = TYPE2;\n               END;\n            IF \u00acCOMPTYPES(TYPE1,SET_TYPE_PTR) THEN\n               DO;   /* COERCE OPND1 TO SET_TYPE_PTR */\n                  CALL EMIT_TRIPLE(TEMP, NULL, 0, ST_LNGTH - 1);\n                  I = (N_TRIPLES - 3) | MASK_TEMP;\n                  CALL EMIT_TRIPLE(XOR, I, I, 0);\n                  CALL EMIT_TRIPLE(INDEX, I, FINDCONST(VALUE(TYPE1) - LOWBOUND),\n                     STORAGE_LNGTH(TYPE1) - 1);\n                  CALL EMIT_TRIPLE(MOVE, (N_TRIPLES - 3) | MASK_TRIPLE, OPND1,\n                     0);\n                  OPERAND#STK(#OP - 1) = I & \"BFFF\";\n                  CALL REPLACE_LEFT_BRO(SET_TYPE_PTR);\n               END;\n            IF \u00acCOMPTYPES(TYPE2, SET_TYPE_PTR) THEN\n               CALL COERCE_ASSIGNMENT(SET_TYPE_PTR, TYPE2);\n            RETURN;\n         END;\n      ELSE IF (STRUCTYPE(TYPE1) \u00ac= ARITHMETIC)\n              | (STRUCTYPE(TYPE2) \u00ac= ARITHMETIC) THEN\n         DO;\n            CALL ERROR(INCOMPATIBLE_DATATYPES, 1);\n            RETURN;\n         END;\n      /* NOW OPERAND 1 AND OPERAND 2 ARE OF INCOMPATIBLE ARITHMETIC TYPES, I.E.,\n         ONE IS INTEGER, THE OTHER REAL.  FLOAT THE INTEGER OPERAND. */\n      IF DATATYPE(TYPE1) = INTPTR THEN\n         DO;   /* FLOAT OPERAND 1 */\n            CALL EMIT_TRIPLE(FLOAT, OPND1, NULL, 3);\n            OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;\n            CALL REPLACE_LEFT_BRO(REALPTR);\n         END;\n      ELSE\n         DO;   /* FLOAT OPERAND 2 */\n            CALL EMIT_TRIPLE(FLOAT, OPND2, NULL, 3);\n            OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n            CALL REPLACE(REALPTR);\n         END;\n   END COERCE_OP;\n\nCOERCE_SET_ELEMENT:\n   PROCEDURE (ELEMENT_TYPE, MIN);\n      DECLARE (ELEMENT_TYPE, MIN, ELT) BIT(16);\n      ELT = OPERAND#STK(#OP);\n      IF (ELT & \"C000\") = MASK_IMMEDIATE THEN\n         OPERAND#STK(#OP) = FINDCONST((ELT & \"3FFF\") - MIN);\n      ELSE IF ((ELT & \"C000\") = MASK_SYMBOL) & (VAR_TYPE(ELT) = CONSTANT) THEN\n         OPERAND#STK(#OP) = FINDCONST(VALUE(ELT) - MIN);\n      ELSE IF (STRUCTYPE(ELEMENT_TYPE) = SUBRANGE) &\n              (VALUE(S_LIST(ELEMENT_TYPE)) \u00ac= MIN) THEN\n         DO;\n            CALL EMIT_TRIPLE(ADD, ELT,\n               FINDCONST(VALUE(S_LIST(ELEMENT_TYPE)) - MIN), 3);\n            OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n         END;\n   END COERCE_SET_ELEMENT;\n\n   /*       S T O R A G E   A L L O C A T I O N   P R O C E D U R E S     */\n\nCOMPUTE_STORAGE_LENGTH:\n   PROCEDURE (TYPE_PTR);\n      DECLARE TYPE_PTR FIXED;\n      DECLARE STRUCTYPECASE (14) BIT(16) INITIAL(0,1,2,3,4,4,4,4,4,4,0,5,5,0,3);\n      DO CASE STRUCTYPECASE(STRUCTYPE(TYPE_PTR));\n         /*  0   STATEMENT, STANDARD   */\n            ;\n         /*  1   SCALAR   */\n            IF STORAGE_LNGTH(TYPE_PTR) <= 256 THEN SL = 1;\n            ELSE SL = 2;\n         /*  2   SUBRANGE   */\n            IF STORAGE_LNGTH(TYPE_PTR) = NULL THEN SL = 4;\n            ELSE IF STORAGE_LNGTH(TYPE_PTR) < 256 THEN SL = 1;\n            ELSE SL = 2;\n         /*  3   POINTER, ARITHMETIC   */\n            SL = 4;\n         /*  4   ARRAY, FILE, RECORD  */\n            SL = STORAGE_LNGTH(TYPE_PTR);\n         /*  5   SET   */\n            SL = STORAGE_LNGTH(TYPE_PTR);\n      END;\n   END COMPUTE_STORAGE_LENGTH;\n\nALLOCATE_STORAGE:\n   PROCEDURE (VAR_PTR);\n      DECLARE VAR_PTR FIXED;\n      /* THIS PROCEDURE REFERS TO THE GLOBAL VARIABLE SL, WHICH IS PRESUMED\n         TO HAVE BEEN SET BY A PRIOR CALL TO COMPUTE_STORAGE_LENGTH.  IT\n         SETS VALUES OF DISPLACEMENT(VAR_PTR), STACK_LIMIT(CURRENT_LEVEL),\n         HALFWORD_DISP(CURRENT_LEVEL) AND ARRAYS_ALLOCATED(CURRENT_LEVEL). */\n      IF SL <= 2 THEN\n         DO;\n            IF HALFWORD_DISP(CURRENT_LEVEL) \u00ac= 0 THEN\n               DO;\n                  DISPLACEMENT(VAR_PTR) = HALFWORD_DISP(CURRENT_LEVEL);\n                  HALFWORD_DISP(CURRENT_LEVEL) = 0;\n               END;\n            ELSE\n               DO;\n                  DISPLACEMENT(VAR_PTR) = STACK_LIMIT(CURRENT_LEVEL);\n                  HALFWORD_DISP(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 2;\n                  STACK_LIMIT(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 4;\n               END;\n            IF STRUCTYPE(VAR_PTR) = SET THEN\n               STORAGE_LNGTH(VAR_PTR) = SL;\n            ELSE STORAGE_LNGTH(VAR_PTR) = 2;\n            IF CURRENT_LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);\n         END;\n      ELSE IF SL <= 4 THEN\n         DO;\n            DISPLACEMENT(VAR_PTR) = STACK_LIMIT(CURRENT_LEVEL);\n            STACK_LIMIT(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 4;\n            STORAGE_LNGTH(VAR_PTR) = SL;\n            IF CURRENT_LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);\n         END;\n      ELSE\n         DO; /* CHAIN STRUCTURED VARIABLES THROUGH THE VALUE FIELD */\n            STORAGE_LNGTH(VAR_PTR) = SL;\n            VALUE(VAR_PTR) = ARRAYS_ALLOCATED(CURRENT_LEVEL);\n            ARRAYS_ALLOCATED(CURRENT_LEVEL) = VAR_PTR;\n         END;\n   END ALLOCATE_STORAGE;\n\nALLOCATE_ARRAY_STORAGE:\n   PROCEDURE (LEVEL);\n      DECLARE (VAR_PTR, LEVEL, I) BIT(16);\n   /* THIS PROCEDURE IS CALLED WHENEVER CURRENT_LEVEL IS ABOUT TO BE DECREMENTED\n         (AT THE CLOSE OF A BLOCK OR A RECORD DECLARATION) IN ORDER TO ALLOCATE\n         STORAGE FOR THE STRUCTURED VARIABLES, AFTER ALL STORAGE FOR SCALAR\n         VARIABLES HAS BEEN ALLOCATED.  THIS IS DONE TO SECURE EFFICIENCY IN\n         ADDRESS COMPUTATION AT RUNTIME.                               */\n      VAR_PTR = ARRAYS_ALLOCATED(LEVEL);\n      DO WHILE VAR_PTR > N_PREDECLARED_SYMB;\n         SL = STORAGE_LNGTH(VAR_PTR);\n         DISPLACEMENT(VAR_PTR) =   STACK_LIMIT(LEVEL);\n         SL = SHL(SHR(SL,2) + ((SL  &  3) > 0), 2);\n         STACK_LIMIT(LEVEL) = STACK_LIMIT(LEVEL) + SL;\n         IF LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);\n         I = VAR_PTR;\n         VAR_PTR = VALUE(VAR_PTR);\n         VALUE(I) = 0;\n      END;\n      ARRAYS_ALLOCATED(LEVEL) = NULL;\n   END ALLOCATE_ARRAY_STORAGE;\n\nSAVE_CURRENT_LEVEL:\n   PROCEDURE;\n      DECLARE I BIT(16), NODE_SIZE BIT(16) INITIAL(3);\n      /* FIRST, ALLOCATE A NODE FROM THE FORWARD_SAVE HEAP. */\n      IF FORWARD_AVAIL \u00ac= NULL THEN\n         DO;\n            I = FORWARD_AVAIL;\n            FORWARD_AVAIL = FORWARD_SAVE(I);\n         END;\n      ELSE IF FORWARD_LIMIT < FORWARD_LENGTH THEN\n         DO; /* CARVE OUT A NEW NODE */\n            I = FORWARD_LIMIT;\n            FORWARD_LIMIT = FORWARD_LIMIT + NODE_SIZE;\n         END;\n      ELSE\n         DO; /* HEAP OVERFLOW */\n            CALL ERROR(\n           'TOO MANY FORWARD-DECLARED PROCEDURES ARE PENDING AT THIS POINT', 1);\n            RETURN;\n         END;\n      PSEUDO_REG(OWNER_STACK(CURRENT_LEVEL)) = I;\n      FORWARD_SAVE(I) = ARRAYS_ALLOCATED(CURRENT_LEVEL);\n      FORWARD_SAVE(I + 1) = STACK_LIMIT(CURRENT_LEVEL);\n      FORWARD_SAVE(I + 2) = HALFWORD_DISP(CURRENT_LEVEL);\n   END SAVE_CURRENT_LEVEL;\n\nRESTORE_CURRENT_LEVEL:\n   PROCEDURE;\n      DECLARE I BIT(16);\n      I = PSEUDO_REG(OWNER_STACK(CURRENT_LEVEL));\n      PSEUDO_REG(OWNER_STACK(CURRENT_LEVEL)) = CURRENT_LEVEL - 1;\n      ARRAYS_ALLOCATED(CURRENT_LEVEL) = FORWARD_SAVE(I);\n      STACK_LIMIT(CURRENT_LEVEL) = FORWARD_SAVE(I + 1);\n      HALFWORD_DISP(CURRENT_LEVEL) = FORWARD_SAVE(I + 2);\n      FORWARD_SAVE(I) = FORWARD_AVAIL;\n      FORWARD_AVAIL = I;\n   END RESTORE_CURRENT_LEVEL;\n\n   /*      T R A V E R S E   P A R S E   T R E E S           */\n\nVISIT_NODES:\n   PROCEDURE;\n      DECLARE FIRST_VISIT BIT(1);\n      DECLARE IS_LEAF LITERALLY 'PARSE_TREE(NODE)=0';\n      DECLARE FATHERS_PROD_NO LITERALLY 'PARSE_TREE(NODE#STACK(NP)+1)';\n      DECLARE GREAT_GRANDFATHERS_PROD_NO LITERALLY\n              'PARSE_TREE(NODE#STACK(NP-2)+1)';\n      DECLARE(FATHERS_MULTIPLICITY, #MP, #TP) FIXED;\n      DECLARE IS_DECLARATION BIT(1);\n      DECLARE (LHS, PARAMLIST) BIT(1);\n      DECLARE FIRST_PARAM_TYPES BIT(1);\n      /* SYMBOL TABLE POINTERS USED IN PROCESSING DECLARATION TREES */\n      DECLARE (TABLE_PTR, ID_PTR, TP_ID_PTR) FIXED;\n      /*  GLOBAL TEMPORARIES USED IN TRAVERSING SYMBOL TABLE ENTRIES  */\n      DECLARE (I, LINK, NP1) FIXED;\n      DECLARE J FIXED;\n      DECLARE (MIN, MAX, CASE_LABEL_VALUE) FIXED;\n      DECLARE (CASE_INSTANCE_PTR, CASE_LABEL_PTR, CASE_PTR) BIT(16);\n      /*  STRINGS USED IN ERROR MESSAGES     */\n      DECLARE SUBRANGE_SIZE CHARACTER INITIAL\n         ('IMPLEMENTATION RESTRICTS LENGTH OF A SET TO 256 BYTES');\n      DECLARE TAG_TYPE CHARACTER INITIAL (\n         'TYPE OF CASE LABEL DOES NOT AGREE WITH TYPE OF TAG FIELD');\n      DECLARE (BOUND1_IS_CONST, BOUND2_IS_CONST) BIT(1);\n      DECLARE (BOUND1_VALUE, BOUND2_VALUE) FIXED;\n      DECLARE (MUST_CHECK_LOWBOUND, MUST_CHECK_HIGHBOUND) BIT(1);\n      DECLARE ERROR_FLAG BIT(1);\n\n   IS_VALID_ROOT_PRODUCTION:\n      PROCEDURE (PRODUCTION#) BIT(1);\n         DECLARE PRODUCTION# BIT(16);\n         IF (PRODUCTION# < 0) | (PRODUCTION# > 10) THEN RETURN FALSE;\n         RETURN (SHL(1, PRODUCTION#) & \"(1)11100 00011 0\") \u00ac= 0;\n         /* RETURN PRODUCTION# IN (.1,2,8,9,10.) */\n      END IS_VALID_ROOT_PRODUCTION;\n\n   SIZE:\n      PROCEDURE (OPND) FIXED;\n         DECLARE (OPND, OPCD) BIT(16);\n         IF (OPND & \"C000\") = MASK_SYMBOL THEN\n            RETURN STORAGE_LNGTH(OPND);\n         ELSE IF (OPND & \"C000\") = MASK_IMMEDIATE THEN\n            RETURN 4;   /* ASSUME LOADED IN A REGISTER */\n         /* ELSE OPERAND IS A TRIPLE */\n         OPND = OPND & \"3FFF\";\n         OPCD = TRIPLES(OPND) & \"7F\";\n         IF OPCD = INDEX THEN\n            IF TRIPLES(OPND + 3) = S_LENGTH THEN\n               RETURN SHL(TRIPLES(OPND + 4), 16) + TRIPLES(OPND + 5);\n         RETURN SHR(TRIPLES(OPND), 8) + 1;\n   END SIZE;\n\n   SUBSET:\n      PROCEDURE (OPND1, OPND2);\n         /* CHECK TO SEE IF OPND1 IS A SUBSET OF OPND2.  OPND1 AND OPND2\n            ARE THE TOP TWO ELEMENTS ON OPERAND#STK, BUT WE CANNOT TELL\n            WHICH ONE IS ON TOP. */\n         DECLARE (OPND1, OPND2, OPCD) BIT(16);\n         IF OPND1 = EMPTYSETPTR THEN\n            DO;\n               IF (OPND2 & MASK_TRIPLE) \u00ac= 0 THEN\n                  CALL EMIT_TRIPLE(TPOP, OPND2, NULL, 0);\n               OPERAND#STK(#OP - 1) = TRUE | MASK_IMMEDIATE;\n            END;\n         ELSE IF OPND2 = EMPTYSETPTR THEN\n            DO;\n               CALL EMIT_TRIPLE(AND, OPND1, OPND1, 0);\n               IF FX THEN OPCD = BZ; ELSE OPCD = BNZ;\n               CALL EMIT_TRIPLE(OPCD, LISTHEAD, NULL, 0);\n               LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);\n               OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;\n            END;\n         ELSE\n            DO;\n               CALL EMIT_TRIPLE(TEMP, OPND1, 0, SIZE(OPND1) - 1);\n               IF (OPND1 & MASK_TRIPLE) \u00ac= 0 THEN /* FLAG OPND1 AS REUSABLE */\n                  TRIPLES(N_TRIPLES - 2) = OPND1 | MASK_TEMP;\n               CALL EMIT_TRIPLE(AND, (N_TRIPLES - 3) | MASK_TEMP, OPND2, 0);\n               CALL EMIT_TRIPLE(LCOMPARE, (N_TRIPLES - 6) | MASK_TRIPLE,\n                  OPND1, 0);\n               IF FX THEN OPCD = BNZ;   ELSE OPCD = BZ;\n               CALL EMIT_TRIPLE(OPCD, LISTHEAD, (N_TRIPLES - 3)|MASK_TRIPLE, 0);\n               LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);\n               OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;\n            END;\n         #OP = #OP - 1;\n         #TP = BOOLPTR;\n      END SUBSET;\n\n   IS_CONDITION:\n      PROCEDURE (OP_PTR) BIT(1);\n         /* TESTS OPERAND TO SEE IF BZ OR BNZ TRIPLE */\n         DECLARE (OP_PTR, OPCD) BIT(16);\n         IF (OP_PTR & \"C000\") = (MASK_TRIPLE & \"C000\") THEN\n            DO;\n               OPCD = TRIPLES(OP_PTR & \"3FFF\") & \"7F\";\n               IF (OPCD = BZ) | (OPCD = BNZ) THEN RETURN TRUE;\n            END;\n         RETURN FALSE;\n      END IS_CONDITION;\n\n   IS_NEGATION:\n      PROCEDURE (OP_PTR) BIT(1);\n         /* DETERMINES IF OPERAND IS A \"NOT\" TRIPLE */\n         DECLARE (OP_PTR, OPCD) BIT(16);\n         IF (OP_PTR & \"C000\") = (MASK_TRIPLE & \"C000\") THEN\n            DO;\n               OPCD = TRIPLES(OP_PTR & \"3FFF\") & \"7F\";\n               IF OPCD = NOT THEN RETURN TRUE;\n            END;\n         RETURN FALSE;\n      END IS_NEGATION;\n\n   FIXUP:\n      PROCEDURE (HEAD_PTR, TARGET_TRIPLE);\n         /* ASSUMES TRIPLES ARE ALL IN TRIPLES BUFFER */\n         DECLARE (HEAD_PTR, TARGET_TRIPLE, NEXT) BIT(16);\n         DO WHILE HEAD_PTR \u00ac= NULL;\n            HEAD_PTR = HEAD_PTR & \"3FFF\";\n            NEXT = TRIPLES(HEAD_PTR + 1);\n            TRIPLES(HEAD_PTR + 1) = TARGET_TRIPLE | MASK_TRIPLE;\n            HEAD_PTR = NEXT;\n         END;\n      END FIXUP;\n\n   EMIT_CONDITIONAL_BRANCH:\n      PROCEDURE(FX);\n         DECLARE FX BIT(1), OPND BIT(16);\n         OPND = OPERAND#STK(#OP);\n         IF IS_NEGATION(OPND) THEN\n            DO;\n               N_TRIPLES = N_TRIPLES - 3;\n               IC = IC - 1;\n               OPND = TRIPLES(N_TRIPLES + 1);\n               FX = \u00acFX;\n            END;\n         IF FX THEN CALL EMIT_TRIPLE(BNZ, NULL, OPND, 0);\n         ELSE CALL EMIT_TRIPLE(BZ, NULL, OPND, 0);\n      END EMIT_CONDITIONAL_BRANCH;\n\n   COND_TO_REGISTER:\n      PROCEDURE;\n         /* ASSUMES OPERAND#STK(#OP) POINTS TO A CONDITIONAL BRANCH TRIPLE */\n         IF LISTHEAD = NULL THEN RETURN;\n         CALL EMIT_TRIPLE(TEMP, (1 - FX) | MASK_IMMEDIATE, NULL, 3);\n         OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n         CALL EMIT_TRIPLE(BCH, (N_TRIPLES + 9) | MASK_TRIPLE, NULL, 0);\n         CALL FIXUP(LISTHEAD, N_TRIPLES);\n         CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);\n         CALL EMIT_TRIPLE(STORE, (N_TRIPLES - 9) | MASK_TEMP,\n                          FX | MASK_IMMEDIATE, 0);\n         CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);\n         LISTHEAD = NULL;\n      END COND_TO_REGISTER;\n\n   EMIT_COMPARE:\n      PROCEDURE (OP);\n         DECLARE OP BIT(16);   /* OP IS OF TYPE COMPARISONS */\n         DECLARE COMPARE_ERROR CHARACTER INITIAL('ILLEGAL COMPARISON');\n         DECLARE CONTAINS_ERROR CHARACTER INITIAL(\n            'STRICT INCLUSION IS NOT ALLOWED');\n         IF #TP = BOOLPTR THEN\n            IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n               CALL COND_TO_REGISTER;\n         CALL REPLACE(#TP);\n         IF #MP = 1 THEN RETURN;\n         IF \u00acCOMPTYPES(#TP, PARSE_TREE(NODE#STACK(NP) + 2)) THEN\n            CALL COERCE_OP;\n         IF COMPTYPES(#TP, REALPTR) THEN\n            DO CASE OP MOD 3;\n               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */\n               CALL EMIT_TRIPLE(COMPAREFLT, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n               /* CASE 1 -- GREATER_THAN, LESS_EQ */\n               CALL EMIT_TRIPLE(GREATERFLT, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n               /* CASE 2 -- LESS_THAN, GREATER_EQ */\n               CALL EMIT_TRIPLE(LESSFLT, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n            END;\n         ELSE IF (STRUCTYPE(#TP) = SET) | (STRUCTYPE(#TP) = PACKED_SET) THEN\n            DO CASE OP MOD 3;\n               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */\n               IF OPERAND#STK(#OP) = EMPTYSETPTR THEN\n                  DO;\n                     CALL EMIT_TRIPLE(AND, OPERAND#STK(#OP - 1),\n                        OPERAND#STK(#OP - 1), 0);\n                     OPERAND#STK(#OP - 1) = NULL;\n                    IF OP = EQUAL_TO THEN OP = NOT_EQUAL_TO; ELSE OP = EQUAL_TO;\n                  END;\n               ELSE IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN\n                  DO;\n                     CALL EMIT_TRIPLE(AND, OPERAND#STK(#OP),\n                        OPERAND#STK(#OP), 0);\n                     OPERAND#STK(#OP - 1) = NULL;\n                    IF OP = EQUAL_TO THEN OP = NOT_EQUAL_TO; ELSE OP = EQUAL_TO;\n                  END;\n               ELSE\n                  DO;\n                     CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),\n                        OPERAND#STK(#OP), 0);\n                     OPERAND#STK(#OP - 1) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                  END;\n               /* CASE 1 -- GREATER_THAN, LESS_EQ */\n               IF OP = GREATER_THAN THEN\n                  CALL ERROR(CONTAINS_ERROR, 1);\n               ELSE\n                  DO;\n                     CALL SUBSET(OPERAND#STK(#OP - 1), OPERAND#STK(#OP));\n                     RETURN;\n                  END;\n               /* CASE 2 -- LESS_THAN, GREATER_EQ */\n               IF OP = LESS_THAN THEN\n                  CALL ERROR(CONTAINS_ERROR, 1);\n                ELSE\n                  DO;\n                     CALL SUBSET(OPERAND#STK(#OP), OPERAND#STK(#OP - 1));\n                     RETURN;\n                  END;\n            END;\n         ELSE IF ((STRUCTYPE(#TP) = ARRAY) | (STRUCTYPE(#TP) = PACKED_ARRAY)) &\n                 (DATATYPE(#TP) = CHARPTR) THEN\n            DO CASE OP MOD 3;\n               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */\n               CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n               /* CASE 1 -- GREATER_THAN, LESS_EQ */\n               CALL EMIT_TRIPLE(LGREATER, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n               /* CASE 2 -- LESS_THAN, GREATER_EQ */\n               CALL EMIT_TRIPLE(LLESS, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n            END;\n         ELSE IF (SHL(1, STRUCTYPE(#TP)) & \"(1)00000 11001 11000\") \u00ac= 0 THEN\n               /* STRUCTYPE(#TP) IN (.POINTER, ARRAY, PACKED_ARRAY,\n                                      RECORD, PACKED_RECORD.) */\n            DO;\n               IF (OP MOD 3) = 0 THEN\n                  CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),\n                     OPERAND#STK(#OP), 0);\n               ELSE CALL ERROR(COMPARE_ERROR, 1);\n            END;\n         ELSE IF (SHL(1, STRUCTYPE(#TP)) & \"(1)10000 00000 00110\") \u00ac= 0 THEN\n            /* STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, ARITHMETIC.) */\n            DO CASE OP MOD 3;\n               /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */\n               CALL EMIT_TRIPLE(COMPARE, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n               /* CASE 1 -- GREATER_THAN, LESS_EQ */\n               CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n               /* CASE 2 -- LESS_THAN, GREATER_EQ */\n               CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP - 1),\n                  OPERAND#STK(#OP), 0);\n            END;\n         ELSE CALL ERROR(COMPARE_ERROR, 1);\n         #OP = #OP - 1;\n         IF (FX & (OP < NOT_EQUAL_TO)) THEN\n            CALL EMIT_TRIPLE(BNZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n         ELSE IF (\u00acFX & (OP >= NOT_EQUAL_TO)) THEN\n            CALL EMIT_TRIPLE(BNZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n         ELSE CALL EMIT_TRIPLE(BZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n         IF (STRUCTYPE(#TP) = SET) | (STRUCTYPE(#TP) = PACKED_SET) THEN\n            TRIPLES(N_TRIPLES - 1) = OPERAND#STK(#OP);\n         OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n         LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);\n         #TP = BOOLPTR;\n      END EMIT_COMPARE;\n\n   EMIT_BOUND_CHECK:\n      PROCEDURE(OPND, VALUE, COMPARISON);\n         DECLARE (OPND, OPCD, COMPARISON) BIT(16), VALUE FIXED;\n         IF COMPARISON = LESS_EQ THEN OPCD = GREATER;\n         ELSE /* COMPARISON = GREATER_EQ */ OPCD = LESS;\n         CALL EMIT_TRIPLE(OPCD, OPND, FINDCONST(VALUE), 0);\n         CALL EMIT_TRIPLE(BNZ, LISTHEAD, (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n         LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);\n      END EMIT_BOUND_CHECK;\n\n   PROCFUNC:\n      PROCEDURE(IS_PROC);\n         DECLARE IS_PROC BIT(1);\n         DECLARE PARAM_ERROR CHARACTER INITIAL(\n            'ILLEGAL PARAMETER TYPE IN CALL TO STANDARD PROCEDURE/FUNCTION');\n         DECLARE #_PARAMS CHARACTER INITIAL(\n            'WRONG NUMBER OF PARAMETERS IN CALL TO STANDARD PROCEDURE');\n         DECLARE STD_FILE_ERR CHARACTER INITIAL(\n            'ILLEGAL USE OF STANDARD FILE');\n         DECLARE ERROR_FLAG BIT(1);\n         DECLARE MONITOR_CODE(N_PREDECLARED_SYMB) BIT(8) INITIAL(\n            \"FF\", \"FF\", \"FF\", \"FF\", \"FF\", \"FF\", \"FF\", \"FF\", \"FF\", \"FF\",\n            \"FF\", 10, 11, 12, \"FF\", \"FF\", \"FF\", \"FF\", 9, 14,\n            0, 1, 3, 4, 5, 2, 8, 13, 17, 18,\n            19, 20, 15, \"FF\", \"FF\", \"FF\", \"FF\", \"FF\", 16, 31,\n            29, 30, 35, \"FF\", \"FF\", \"FF\", \"FF\");\n         /* OTHER MONITOR CODES */\n         DECLARE READ_INT     BIT(16) INITIAL(21),\n                 READ_REAL    BIT(16) INITIAL(22),\n                 READ_CHAR    BIT(16) INITIAL(23),\n                 WRITE_INT    BIT(16) INITIAL(24),\n                 WRITE_REAL   BIT(16) INITIAL(25),\n                 WRITE_BOOL   BIT(16) INITIAL(26),\n                 WRITE_CHAR   BIT(16) INITIAL(27),\n                 WRITE_STRING BIT(16) INITIAL(28);\n         DECLARE (I, J) FIXED;\n         DECLARE FILE_PTR BIT(16);\n         DECLARE #TP1 BIT(16);\n         DECLARE TAG_PTR BIT(16);\n         DECLARE VARIANT_NOT_FOUND BIT(1);\n         DECLARE RECORD_LENGTH FIXED;\n         DECLARE (ARRAY1, ARRAY2) BIT(16);\n         DECLARE (ARRAY1_TYPE, ARRAY2_TYPE) BIT(16);\n         DECLARE FIRST_PROC BIT(16) INITIAL(11); /* INDEX OF 1ST STD. PROC */\n         DECLARE PROPER BIT(N_PREDECLARED_SYMB) INITIAL\n            (\"(1)0 00000 00000 00000 00000 00000 00111 11111 10111 10000 0\");\n         DECLARE PARAMETERLESS BIT(N_PREDECLARED_SYMB) INITIAL\n            (\"(1)0 00000 00000 00000 00010 00000 01000 00000 00011 11000 0\");\n\n      IS_PROPER:\n         PROCEDURE (STD_PROC) BIT(1);\n            DECLARE STD_PROC BIT(16); /* INDEX OF A STANDARD PROC */\n            /* RETURN TRUE IFF STD_PROC IS A PROPER STANDARD PROCEDURE */\n            RETURN (SHL(BYTE(PROPER, SHR(STD_PROC, 3)), STD_PROC & \"7\") & \"80\")\n                   \u00ac= 0;\n         END IS_PROPER;\n\n      IS_PARAMETERLESS:\n         PROCEDURE (STD_PROC) BIT(1);\n            DECLARE STD_PROC BIT(16); /* INDEX OF A STANDARD PROC */\n            /* RETURN TRUE IFF STD_PROC CAN BE CALLED WITH NO PARAMETERS */\n            RETURN (SHL(BYTE(PARAMETERLESS, SHR(STD_PROC, 3)), STD_PROC & \"7\")\n                    & \"80\") \u00ac= 0;\n         END IS_PARAMETERLESS;\n\n         IF #MP = 1 THEN\n            DO;\n               ERROR_FLAG = (SHL(1, VAR_TYPE(TABLE_PTR)) &\n                  \"(1)01 00000 00101 00000\") = 0;\n               /* ERROR_FLAG = \u00ac(VAR_TYPE(TABLE_PTR) IN (.PROC, PROC_PARAM,\n                     MULTDECL.)); */\n               IF TABLE_PTR > N_PREDECLARED_SYMB THEN\n                  DO;\n                     IF IS_PROC THEN\n                        ERROR_FLAG = ERROR_FLAG | (DATATYPE(TABLE_PTR) \u00ac= NULL);\n                     ELSE ERROR_FLAG = ERROR_FLAG | (DATATYPE(TABLE_PTR) =NULL);\n                  END;\n               ELSE\n                  ERROR_FLAG = ERROR_FLAG | (IS_PROC \u00ac= IS_PROPER(TABLE_PTR));\n               IF ERROR_FLAG THEN\n                  DO;\n                     CALL ERROR('ILLEGAL PROCEDURE/FUNCTION IDENTIFIER', 1);\n                     #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                     IF IS_PROC THEN #OP = #OP - 1;\n                     RETURN;\n                  END;\n               IF TABLE_PTR > N_PREDECLARED_SYMB THEN\n                  DO;\n                     IF VAR_TYPE(TABLE_PTR) = PROC_PARAM THEN\n                        DO;\n                           ID_PTR = VALUE(TABLE_PTR);\n                           J = NULL;\n                        END;\n                     ELSE\n                        DO;\n                           ID_PTR = S_LIST(TABLE_PTR);\n                           J = FINDCONST(VALUE(TABLE_PTR));\n                        END;\n                     CALL EMIT_TRIPLE(BLKMARK, TABLE_PTR, J, 0);\n                     I = 1;\n                     DO WHILE ID_PTR \u00ac= NULL;\n                        I = I + 1;\n                        ID_PTR = S_LIST(ID_PTR);\n                     END;\n                     IF I \u00ac= FATHERS_MULTIPLICITY THEN\n                        DO;\n                           CALL ERROR('WRONG NUMBER OF PARAMETERS', 1);\n                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                           IF IS_PROC THEN #OP = #OP - 1;\n                           RETURN;\n                        END;\n                     IF FATHERS_MULTIPLICITY = 1 THEN\n                        DO;   /* PARAMETERLESS CALL */\n                           CALL EMIT_TRIPLE(PCALL, TABLE_PTR, J, 3);\n                           IF IS_PROC THEN\n                              DO;\n                                 CALL EMIT_TRIPLE(TPOP, (N_TRIPLES - 3) |\n                                    MASK_TRIPLE, NULL, 0);\n                                 #OP = #OP - 1;\n                              END;\n                           ELSE OPERAND#STK(#OP) = (N_TRIPLES - 3) |MASK_TRIPLE;\n                        END;   /* FATHERS_MULTIPLICITY = 1 */\n                     ELSE IF VAR_TYPE(S_LIST(TABLE_PTR)) \u00ac= VARIABLE THEN\n                        PARAMLIST = TRUE;\n                  END;   /* USER-DEFINED PROC/FUNC */\n               ELSE IF FATHERS_MULTIPLICITY = 1 THEN\n                  DO;   /* PARAMETERLESS STANDARD PROC/FUNC CALL */\n                     IF TABLE_PTR = CLOCKPTR THEN\n                        DO;\n                           CALL EMIT_TRIPLE(MONITOR, NULL, NULL,\n                                            MONITOR_CODE(CLOCKPTR));\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           #TP = INTPTR;\n                           RETURN;\n                        END;\n                     IF (TABLE_PTR = PAGEPTR) | (TABLE_PTR = WRITELNPTR) THEN\n                        I = OUTPUTPTR;\n                     ELSE I = INPUTPTR;\n                     CALL EMIT_TRIPLE(LOAD_ADDR, I, NULL, 3);\n                     IF IS_PROC THEN #OP = #OP - 1;\n                     ELSE OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;\n                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,\n                        NULL, MONITOR_CODE(TABLE_PTR));\n                     IF \u00acIS_PARAMETERLESS(TABLE_PTR) THEN CALL ERROR(\n                 'MISSING PARAMETER IN CALL TO STANDARD PROCEDURE/FUNCTION', 1);\n                  END;\n               ELSE   /* THERE ARE PARAMETERS */\n                  DO;\n                     IF (TABLE_PTR = READPTR) | (TABLE_PTR = READLNPTR) THEN\n                        PARAMLIST = TRUE;   /* SIGNAL CALL BY REFERENCE */\n                     IF (\u00acIS_PROC) & (FATHERS_MULTIPLICITY > 2) THEN\n                        DO;\n                           CALL ERROR(\n                         'TOO MANY PARAMETERS IN CALL TO STANDARD FUNCTION', 1);\n                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                        END;\n                  END;\n            END;   /* #MP = 1 */\n         ELSE\n            DO;\n               ID_PTR = OPERAND#STK(#OP - 1);\n               IF #TP = BOOLPTR THEN\n                  IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                     CALL COND_TO_REGISTER;\n               TABLE_PTR = OPERAND#STK(#OP);\n               IF ID_PTR > N_PREDECLARED_SYMB THEN\n                  DO;\n                     IF VAR_TYPE(ID_PTR) = PROC_PARAM THEN\n                        DO;\n                           J = NULL;\n                           ID_PTR = VALUE(ID_PTR);\n                        END;\n                     ELSE\n                        DO;\n                           J = FINDCONST(VALUE(ID_PTR));\n                           ID_PTR = S_LIST(ID_PTR);\n                        END;\n                     DO I = 3 TO #MP;\n                        ID_PTR = S_LIST(ID_PTR);\n                     END;\n                     CALL COERCE_PARAMETER(TABLE_PTR, ID_PTR, #TP);\n                     CALL EMIT_TRIPLE(PARM, ID_PTR, OPERAND#STK(#OP), 0);\n                     #OP = #OP - 1;\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        DO;\n                           CALL EMIT_TRIPLE(PCALL, OPERAND#STK(#OP), J, 3);\n                           IF IS_PROC THEN\n                              DO;\n                                 CALL EMIT_TRIPLE(TPOP, (N_TRIPLES - 3) |\n                                    MASK_TRIPLE, NULL, 0);\n                                 #OP = #OP - 1;\n                              END;\n                           ELSE\n                              DO;\n                                 #TP = DATATYPE(OPERAND#STK(#OP));\n                                 OPERAND#STK(#OP) = (N_TRIPLES - 3)|MASK_TRIPLE;\n                              END;\n                        END;\n                     ELSE PARAMLIST = (VAR_TYPE(S_LIST(ID_PTR)) \u00ac= VARIABLE);\n                     RETURN;\n                  END;   /* USER-DEFINED PROC/FUNC */\n               DO CASE ID_PTR - FIRST_PROC;\n                  /* CASE 0 -- ABS() */\n                  DO;\n                     IF COMPTYPES(#TP, REALPTR) THEN\n                        CALL EMIT_TRIPLE(ABSFLT, TABLE_PTR, NULL, 3);\n                     ELSE\n                        DO;\n                           CALL COERCE_ASSIGNMENT(INTPTR, #TP);\n                           CALL EMIT_TRIPLE(ABS, OPERAND#STK(#OP), NULL, 3);\n                           #TP = INTPTR;\n                        END;\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                  END;\n                  /* CASE 1 -- SQR() */\n                  DO;\n                     IF COMPTYPES(#TP, REALPTR) THEN\n                        CALL EMIT_TRIPLE(SQRFLT, TABLE_PTR, NULL, 3);\n                     ELSE\n                        DO;\n                           CALL COERCE_ASSIGNMENT(INTPTR, #TP);\n                           CALL EMIT_TRIPLE(SQR, OPERAND#STK(#OP), NULL, 3);\n                           #TP = INTPTR;\n                        END;\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                  END;\n                  /* CASE 2 -- ODD() */\n                  DO;\n                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);\n                     CALL EMIT_TRIPLE(ODD, TABLE_PTR, NULL, 3);\n                     #TP = BOOLPTR;\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                  END;\n                  /* CASE 3 -- SUCC() */\n               PREDSUCC:\n                  DO;\n                     IF ID_PTR = SUCCPTR THEN I = ADD;\n                     ELSE /* PRED() */ I = SUBTRACT;\n                     CALL EMIT_TRIPLE(I, TABLE_PTR, 1 | MASK_IMMEDIATE, 3);\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                     IF (STRUCTYPE(#TP) = SCALAR) |\n                        (STRUCTYPE(#TP) = SUBRANGE) THEN\n                        CALL RANGE_CHECK(#TP, (ID_PTR \u00ac= SUCCPTR),\n                                         (ID_PTR = SUCCPTR));\n                     ELSE IF \u00acCOMPTYPES(#TP, INTPTR) THEN\n                        CALL ERROR(PARAM_ERROR, 1);\n                  END;\n                  /* CASE 4 -- PRED() */\n                  GOTO PREDSUCC;\n                  /* CASE 5 -- ORD() */\n                  DO;\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = TABLE_PTR;\n                     IF ((SHL(1, STRUCTYPE(#TP)) & \"(1)00000 00000 01110\") = 0)\n                        /* \u00ac(#TP IN (.POINTER, SUBRANGE, SCALAR.)) */\n                        & \u00acCOMPTYPES(#TP, INTPTR) THEN\n                        CALL ERROR(PARAM_ERROR, 1);\n                     #TP = INTPTR;\n                  END;\n                  /* CASE 6 -- CHR() */\n                  DO;\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = TABLE_PTR;\n                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);\n                     CALL RANGE_CHECK(CHARPTR, TRUE, TRUE);\n                     #TP = CHARPTR;\n                  END;\n                  /* CASE 7 -- TRUNC() */\n               TRUNCROUND:\n                  DO;\n                     CALL COERCE_ASSIGNMENT(REALPTR, #TP);\n                     IF ID_PTR = TRUNCPTR THEN I = TRUNCATE;\n                     ELSE /* ROUND() */ I = ROUND;\n                     CALL EMIT_TRIPLE(I, OPERAND#STK(#OP), NULL, 3);\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                     #TP = INTPTR;\n                  END;\n                  /* CASE 8 -- EOF() */\n                  DO;\n                     #OP = #OP - 1;\n                     CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);\n                     OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;\n                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,\n                        NULL, MONITOR_CODE(ID_PTR));\n                     IF (STRUCTYPE(#TP) \u00ac= FILE) &\n                        (STRUCTYPE(#TP) \u00ac= PACKED_FILE) THEN\n                        CALL ERROR(PARAM_ERROR, 1);\n                     #TP = BOOLPTR;\n                  END;\n                  /* CASE 9 -- SIN() */\n               SINCOSEXPLNSQRTARCTAN:\n                  DO;\n                     CALL COERCE_ASSIGNMENT(REALPTR, #TP);\n                     CALL EMIT_TRIPLE(MONITOR, OPERAND#STK(#OP), NULL,\n                        MONITOR_CODE(ID_PTR));\n                     #OP = #OP - 1;\n                     OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                     #TP = REALPTR;\n                  END;\n                  /* CASE 10 -- COS() */\n                  GOTO SINCOSEXPLNSQRTARCTAN;\n                  /* CASE 11 -- EXP() */\n                  GOTO SINCOSEXPLNSQRTARCTAN;\n                  /* CASE 12 -- LN() */\n                  GOTO SINCOSEXPLNSQRTARCTAN;\n                  /* CASE 13 -- SQRT() */\n                  GOTO SINCOSEXPLNSQRTARCTAN;\n                  /* CASE 14 -- ARCTAN() */\n                  GOTO SINCOSEXPLNSQRTARCTAN;\n                  /* CASE 15 -- ROUND() */\n                  GOTO TRUNCROUND;\n                  /* CASE 16 -- EOLN() */\n                  DO;\n                     #OP = #OP - 1;\n                     CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);\n                     OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;\n                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,\n                        NULL, MONITOR_CODE(ID_PTR));\n                     IF \u00acCOMPTYPES(TEXTPTR, #TP) THEN\n                        CALL ERROR(PARAM_ERROR, 1);\n                     #TP = BOOLPTR;\n                  END;\n                  /* CASE 17 -- GET() */\n               GETPUTRESETREWRITEPAGE:\n                  DO;\n                     #OP = #OP - 2;\n                     CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);\n                     CALL EMIT_TRIPLE(MONITOR, (N_TRIPLES - 3) | MASK_TRIPLE,\n                        NULL, MONITOR_CODE(ID_PTR));\n                     IF (STRUCTYPE(#TP) \u00ac= FILE) &\n                        (STRUCTYPE(#TP) \u00ac= PACKED_FILE) THEN\n                        CALL ERROR(PARAM_ERROR, 1);\n                     IF ((TABLE_PTR = INPUTPTR) & (ID_PTR \u00ac= GETPTR)) |\n                        ((TABLE_PTR = OUTPUTPTR) & (ID_PTR \u00ac= PUTPTR)\n                                    & (ID_PTR \u00ac= PAGEPTR)) THEN\n                        CALL ERROR(STD_FILE_ERR, 1);\n                     IF FATHERS_MULTIPLICITY > 2 THEN\n                        DO;\n                           CALL ERROR(#_PARAMS, 1);\n                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                        END;\n                  END;\n                  /* CASE 18 -- PUT() */\n                  GOTO GETPUTRESETREWRITEPAGE;\n                  /* CASE 19 -- RESET() */\n                  GOTO GETPUTRESETREWRITEPAGE;\n                  /* CASE 20 -- REWRITE() */\n                  GOTO GETPUTRESETREWRITEPAGE;\n                  /* CASE 21 -- NEW() */\n                  IF #MP = 2 THEN\n                     DO;\n                        IF STRUCTYPE(#TP) \u00ac= POINTER THEN\n                           CALL ERROR(PARAM_ERROR, 1);\n                        IF (STRUCTYPE(DATATYPE(#TP)) = SCALAR) |\n                           (STRUCTYPE(DATATYPE(#TP)) = SUBRANGE) THEN\n                           RECORD_LENGTH = 2;\n                        ELSE RECORD_LENGTH = STORAGE_LNGTH(DATATYPE(#TP));\n                        CALL EMIT_TRIPLE(MONITOR, FINDCONST(RECORD_LENGTH),\n                           NULL, MONITOR_CODE(ID_PTR));\n                        CALL EMIT_TRIPLE(STORE, TABLE_PTR, (N_TRIPLES - 3) |\n                           MASK_TRIPLE, 0);\n                        IF FATHERS_MULTIPLICITY = 2 THEN\n                           DO;\n                              #OP = #OP - 2;\n                              RETURN;\n                           END;\n                        /* FLAG THE 'MONITOR' TRIPLE AS REUSABLE */\n                        TRIPLES(N_TRIPLES - 1) = (N_TRIPLES - 6) | MASK_TEMP;\n                        ERROR_FLAG = FALSE;\n                        I = STRUCTYPE(DATATYPE(#TP));\n                        IF (I \u00ac= RECORD) & (I \u00ac= PACKED_RECORD) THEN\n                           ERROR_FLAG = TRUE;\n                        ELSE\n                           DO;\n                              TAG_PTR = S_LIST(DATATYPE(#TP));\n                              DO WHILE (STRUCTYPE(TAG_PTR) \u00ac= TAG) &\n                                 (TAG_PTR \u00ac= NULL);\n                                 TAG_PTR = S_LIST(TAG_PTR);\n                              END;\n                              ERROR_FLAG = (TAG_PTR = NULL);\n                           END;\n                        IF ERROR_FLAG THEN\n                           DO;\n                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                              #OP = #OP - 2;\n                              CALL ERROR(\n                               'MISSING CORRESPONDING TAGFIELD DECLARATION', 1);\n                              RETURN;\n                           END;\n                        /* SAVE POINTER TO THE \"MONITOR\" TRIPLE */\n                        FIX_LIST(NP) = (N_TRIPLES - 6) | MASK_TRIPLE;\n                        #OP = #OP - 1;\n                     END;   /* #MP = 2 */\n                  ELSE\n                     DO;\n                        I = FIX_LIST(NP);   /* POINTS TO \"MONITOR\" TRIPLE */\n                        IF #MP < FATHERS_MULTIPLICITY THEN\n                           I = I | MASK_TEMP;   /* FLAGS TRIPLE AS REUSABLE */\n                        CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE, I,\n                           RECORD_LENGTH - 1);\n                        CALL EMIT_TRIPLE(INDEX, (N_TRIPLES - 3) | MASK_TRIPLE,\n                           FINDCONST(DISPLACEMENT(TAG_PTR)), 1);\n                        IF (TABLE_PTR & \"C000\") = MASK_SYMBOL THEN\n                           ERROR_FLAG = (VAR_TYPE(TABLE_PTR) \u00ac= CONSTANT);\n                        ELSE ERROR_FLAG =\n                           ((TABLE_PTR & \"C000\") \u00ac= MASK_IMMEDIATE);\n                        IF ERROR_FLAG THEN\n                           DO;\n                              CALL ERROR(\n                             'CONSTANT REQUIRED IN TAGFIELD INITIALIZATION', 1);\n                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                              #OP = #OP - 2;\n                              RETURN;\n                           END;\n                        I = (N_TRIPLES - 3) | MASK_TRIPLE;\n                        CALL COERCE_ASSIGNMENT(DATATYPE(TAG_PTR), #TP);\n                        CALL EMIT_TRIPLE(STORE, I, OPERAND#STK(#OP), 0);\n                        IF #MP = FATHERS_MULTIPLICITY THEN\n                           DO;\n                              #OP = #OP - 2;\n                              RETURN;\n                           END;\n                        /* PREPARE FOR NEXT VISIT BY UPDATING TAG_PTR.\n                           FIRST, FIND THE <VARIANT INSTANCE> WHICH\n                           CORRESPONDS TO TABLE_PTR. */\n                        IF (TABLE_PTR & \"C000\") = MASK_IMMEDIATE THEN\n                           I = TABLE_PTR & \"3FFF\";\n                        ELSE I = VALUE(TABLE_PTR);\n                        TABLE_PTR = OWNER(TAG_PTR);\n                        VARIANT_NOT_FOUND = TRUE;\n                        TAG_PTR = S_LIST(TAG_PTR);\n                        DO WHILE VARIANT_NOT_FOUND & (TAG_PTR \u00ac= NULL);\n                           IF VALUE(TAG_PTR) = I THEN\n                              DO;\n                                 VARIANT_NOT_FOUND = FALSE;\n                                 DO WHILE (VAR_TYPE(TAG_PTR) = CASELABEL) &\n                                    (TAG_PTR \u00ac= NULL);\n                                    TAG_PTR = S_LIST(TAG_PTR);\n                                 END;\n                              END;\n                           ELSE\n                              DO;   /* LOCATE NEXT CASELABEL */\n                                 TAG_PTR = S_LIST(TAG_PTR);\n                                 DO WHILE (OWNER(TAG_PTR) \u00ac= TABLE_PTR) &\n                                    (TAG_PTR \u00ac= NULL);\n                                    TAG_PTR = S_LIST(TAG_PTR);\n                                 END;\n                              END;\n                        END;\n                        /* NOW FIND THE TAGFIELD */\n                        TABLE_PTR = TAG_PTR;\n                        IF TAG_PTR \u00ac= NULL THEN TAG_PTR = S_LIST(TAG_PTR);\n                        DO WHILE (TAG_PTR \u00ac= NULL) &(OWNER(TAG_PTR) = TABLE_PTR)\n                           & (STRUCTYPE(TAG_PTR) \u00ac= TAG);\n                           TAG_PTR = S_LIST(TAG_PTR);\n                        END;\n                        IF (TAG_PTR = NULL) | (OWNER(TAG_PTR) \u00ac= TABLE_PTR) THEN\n                           DO;\n                              CALL ERROR(\n                               'MISSING CORRESPONDING TAGFIELD DECLARATION', 1);\n                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                              #OP = #OP - 2;\n                           END;\n                        ELSE #OP = #OP - 1;\n                     END;   /* #MP > 2 */\n                  /* CASE 22 -- READ() */\n               READREADLN:\n                  DO;\n                     IF #MP = 2 THEN\n                        IF (STRUCTYPE(#TP) = FILE) |\n                           (STRUCTYPE(#TP) = PACKED_FILE) THEN\n                           DO;\n                              IF TABLE_PTR = OUTPUTPTR THEN\n                                 DO;\n                                    CALL ERROR(STD_FILE_ERR, 1);\n                                    #OP = #OP - 2;\n                                    #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                                    RETURN;\n                                 END;\n                              IF ID_PTR = READLNPTR THEN\n                                 IF \u00acCOMPTYPES(#TP, TEXTPTR) THEN\n                                       DO;\n                                          CALL ERROR(PARAM_ERROR, 1);\n                                          #OP = #OP - 2;\n                                          #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                                          RETURN;\n                                       END;\n                              FILE_PTR = TABLE_PTR;\n                              CALL EMIT_TRIPLE(LOAD_ADDR, FILE_PTR, NULL, 3);\n                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                              IF FATHERS_MULTIPLICITY = 2 THEN\n                                 DO;\n                                    #OP = #OP - 2;\n                                    IF ID_PTR = READPTR THEN\n                                       CALL ERROR(#_PARAMS, 1);\n                                    ELSE /* READLN() */\n                                       CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),\n                                          NULL, MONITOR_CODE(ID_PTR));\n                                 END;\n                              RETURN;\n                           END;\n                        ELSE /* DEFAULT FILE IS INPUT */\n                           DO;\n                              FILE_PTR = INPUTPTR;\n                              CALL EMIT_TRIPLE(LOAD_ADDR, INPUTPTR, NULL, 3);\n                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           END;\n                     I = FIX_LIST(NP); /* ADDR OF FILE */\n                     IF (#MP < FATHERS_MULTIPLICITY) | (ID_PTR = READLNPTR) THEN\n                        I = I | MASK_TEMP;\n                     IF \u00acCOMPTYPES(DATATYPE(FILE_PTR), TEXTPTR) THEN\n                        DO;\n                           CALL EMIT_TRIPLE(MONITOR, I, NULL,\n                                            MONITOR_CODE(GETPTR));\n                           OPERAND#STK(#OP) = FILE_PTR;\n                           CALL COERCE_ASSIGNMENT(DATATYPE(DATATYPE(FILE_PTR)),\n                              #TP);\n                           CALL EMIT_TRIPLE(STORE, TABLE_PTR, OPERAND#STK(#OP),\n                              0);\n                        END;\n                     ELSE\n                        DO;\n                           IF STRUCTYPE(#TP) = SUBRANGE THEN\n                              #TP1 = DATATYPE(#TP);\n                           ELSE #TP1 = #TP;\n                           IF COMPTYPES(#TP1, INTPTR) THEN\n                              J = READ_INT;\n                           ELSE IF COMPTYPES(#TP1, REALPTR) THEN\n                              J = READ_REAL;\n                           ELSE IF COMPTYPES(#TP1, CHARPTR) THEN\n                              J = READ_CHAR;\n                           ELSE CALL ERROR(PARAM_ERROR, 1);\n                           CALL EMIT_TRIPLE(MONITOR, I, NULL, J);\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           IF #TP \u00ac= #TP1 THEN CALL COERCE_ASSIGNMENT(#TP,#TP1);\n                           CALL EMIT_TRIPLE(STORE, TABLE_PTR,\n                              OPERAND#STK(#OP), 0);\n                        END;\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        DO;\n                           #OP = #OP - 2;\n                           IF ID_PTR = READLNPTR THEN\n                              CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP), NULL,\n                                 MONITOR_CODE(ID_PTR));\n                        END;\n                     ELSE #OP = #OP - 1;\n                  END;\n                  /* CASE 23 -- WRITE() */\n               WRITEWRITELN:\n                  DO;\n                     IF #MP = 2 THEN\n                        IF (STRUCTYPE(#TP) = FILE) |\n                           (STRUCTYPE(#TP) = PACKED_FILE) THEN\n                           DO;\n                              IF TABLE_PTR = INPUTPTR THEN\n                                 DO;\n                                    CALL ERROR(STD_FILE_ERR, 1);\n                                    #OP = #OP - 2;\n                                    #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                                    RETURN;\n                                 END;\n                              IF ID_PTR = WRITELNPTR THEN\n                                 IF \u00acCOMPTYPES(#TP, TEXTPTR) THEN\n                                    DO;\n                                       CALL ERROR(PARAM_ERROR, 1);\n                                       #OP = #OP - 2;\n                                       #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                                       RETURN;\n                                    END;\n                              FILE_PTR = TABLE_PTR;\n                              CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);\n                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                              IF FATHERS_MULTIPLICITY = 2 THEN\n                                 DO;\n                                    #OP = #OP - 2;\n                                    IF ID_PTR = WRITEPTR THEN\n                                       CALL ERROR(#_PARAMS, 1);\n                                    ELSE /* WRITELN() */\n                                       CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),\n                                          NULL, MONITOR_CODE(ID_PTR));\n                                 END;\n                              RETURN;\n                           END;\n                        ELSE   /* DEFAULT FILE IS OUTPUT */\n                           DO;\n                              FILE_PTR = OUTPUTPTR;\n                              CALL EMIT_TRIPLE(LOAD_ADDR, OUTPUTPTR, NULL, 3);\n                              FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           END;\n                     I = FIX_LIST(NP);   /* ADDR OF FILE */\n                     IF (#MP < FATHERS_MULTIPLICITY)\n                        | (ID_PTR = WRITELNPTR) THEN\n                        I = I | MASK_TEMP;\n                     IF \u00acCOMPTYPES(DATATYPE(FILE_PTR), TEXTPTR) THEN\n                        DO;\n                           CALL COERCE_ASSIGNMENT(DATATYPE(FILE_PTR), #TP);\n                           CALL EMIT_TRIPLE(STORE, FILE_PTR,OPERAND#STK(#OP),0);\n                           CALL EMIT_TRIPLE(MONITOR, I, NULL,\n                                            MONITOR_CODE(PUTPTR));\n                        END;\n                     ELSE\n                        DO;\n                           IF STRUCTYPE(#TP) = SUBRANGE THEN\n                              DO;\n                                 CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);\n                                 #TP = DATATYPE(#TP);\n                                 TABLE_PTR = OPERAND#STK(#OP);\n                              END;\n                           IF COMPTYPES(#TP, INTPTR) THEN\n                              J = WRITE_INT;\n                           ELSE IF COMPTYPES(#TP, REALPTR) THEN\n                              J = WRITE_REAL;\n                           ELSE IF COMPTYPES(#TP, BOOLPTR) THEN\n                              J = WRITE_BOOL;\n                           ELSE IF COMPTYPES(#TP, CHARPTR) THEN\n                              J = WRITE_CHAR;\n                           ELSE IF ((STRUCTYPE(#TP) = ARRAY) |\n                                    (STRUCTYPE(#TP) = PACKED_ARRAY)) &\n                              COMPTYPES(DATATYPE(#TP), CHARPTR) THEN\n                              DO;   /* FORM A STRING DESCRIPTOR */\n                                 CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL,3);\n                                 CALL EMIT_TRIPLE(ADD,(N_TRIPLES-3)|MASK_TRIPLE,\n                                    FINDCONST(SHL(STORAGE_LNGTH(#TP)-1,24)), 3);\n                                 TABLE_PTR = (N_TRIPLES - 3) | MASK_TRIPLE;\n                                 J = WRITE_STRING;\n                              END;\n                           ELSE CALL ERROR(PARAM_ERROR, 1);\n                           CALL EMIT_TRIPLE(MONITOR, I, TABLE_PTR, J);\n                        END;\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        DO;\n                           #OP = #OP - 2;\n                           IF ID_PTR = WRITELNPTR THEN\n                              CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),\n                                 NULL, MONITOR_CODE(ID_PTR));\n                        END;\n                     ELSE #OP = #OP - 1;\n                  END;\n                  /* CASE 24 -- PACK() */\n               PACKUNPACK:\n                  IF #MP = 2 THEN\n                     DO;\n                        IF FATHERS_MULTIPLICITY \u00ac= 4 THEN\n                           DO;\n                              #OP = #OP - 2;\n                              CALL ERROR(#_PARAMS, 1);\n                              #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                              RETURN;\n                           END;\n                        IF ID_PTR = PACKPTR THEN\n                           DO;\n                              ARRAY1 = TABLE_PTR;\n                              ARRAY1_TYPE = #TP;\n                           END;\n                        ELSE /* UNPACK() */\n                           DO;\n                              ARRAY2 = TABLE_PTR;\n                              ARRAY2_TYPE = #TP;\n                           END;\n                        #OP = #OP - 1;\n                     END;\n                  ELSE IF #MP = 3 THEN\n                     DO;\n                        IF ID_PTR = PACKPTR THEN\n                           DO;\n                              FIX_LIST(NP) = TABLE_PTR;\n                              #TP1 = #TP;\n                           END;\n                        ELSE /* UNPACK() */\n                           DO;\n                              ARRAY1 = TABLE_PTR;\n                              ARRAY1_TYPE = #TP;\n                           END;\n                        #OP = #OP - 1;\n                     END;\n                  ELSE /* #MP = 4 */\n                     DO;\n                        IF ID_PTR = PACKPTR THEN\n                           DO;\n                              ARRAY2 = TABLE_PTR;\n                              ARRAY2_TYPE = #TP;\n                           END;\n                        ELSE /* UNPACK() */\n                           DO;\n                              FIX_LIST(NP) = TABLE_PTR;\n                              #TP1 = #TP;\n                           END;\n                        ERROR_FLAG = (STRUCTYPE(ARRAY1_TYPE) \u00ac= ARRAY)\n                                     | (STRUCTYPE(ARRAY2_TYPE) \u00ac= ARRAY);\n                        IF \u00acERROR_FLAG THEN\n                           ERROR_FLAG =\n                              (STORAGE_LNGTH(ARRAY1_TYPE)\n                                 < STORAGE_LNGTH(ARRAY2_TYPE))\n                              | \u00acCOMPTYPES(DATATYPE(ARRAY1_TYPE),\n                                           DATATYPE(ARRAY2_TYPE));\n                        IF ERROR_FLAG | (VAR_TYPE(ARRAY1_TYPE) = LITERAL) THEN\n                           DO;\n                              CALL ERROR(PARAM_ERROR, 1);\n                              #OP = #OP - 2;\n                              RETURN;\n                           END;\n                        OPERAND#STK(#OP) = FIX_LIST(NP);\n                        CALL COERCE_ASSIGNMENT(S_LIST(ARRAY1_TYPE), #TP1);\n                        I = STORAGE_LNGTH(ARRAY2_TYPE);\n                        /* I EQUALS NUMBER OF BYTES TO BE MOVED */\n                        J = STORAGE_LNGTH(ARRAY1_TYPE)/STORAGE_LNGTH(\n                           S_LIST(ARRAY1_TYPE));\n                        /* J IS ARRAY ELEMENT SIZE */\n                        TABLE_PTR = OPERAND#STK(#OP);\n                        IF (TABLE_PTR & \"C000\") = (MASK_TRIPLE & \"C000\") THEN\n                           TABLE_PTR = TABLE_PTR | MASK_TEMP;\n                        /* FLAG TABLE_PTR AS REUSABLE */\n                        CALL EMIT_TRIPLE(GREATER, TABLE_PTR,\n                           FINDCONST((STORAGE_LNGTH(ARRAY1_TYPE) - I)/J), 0);\n                        CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 6) | MASK_TRIPLE,\n                           (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                        /* VALUE OUT OF RANGE */\n                        CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);\n                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);\n                        IF J \u00ac= 1 THEN\n                           DO;\n                              CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP),\n                                 FINDCONST(J), 3);\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           END;\n                        CALL EMIT_TRIPLE(INDEX, ARRAY1, OPERAND#STK(#OP), I-1);\n                        OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                        IF I > 256 THEN\n                           CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);\n                        IF ID_PTR = PACKPTR THEN\n                           CALL EMIT_TRIPLE(STORE, ARRAY2, OPERAND#STK(#OP), 0);\n                        ELSE /* UNPACK() */\n                           CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP), ARRAY2, 0);\n                        #OP = #OP - 2;\n                     END;\n                  /* CASE 25 -- UNPACK() */\n                  GOTO PACKUNPACK;\n                  /* CASE 26 -- (NOT USED) */\n                  ;\n                  /* CASE 27 -- DISPOSE() */\n                  DO;\n                     IF #MP = 2 THEN\n                        DO;\n                           IF STRUCTYPE(#TP) \u00ac= POINTER THEN\n                              CALL ERROR(PARAM_ERROR, 1);\n                           IF (STRUCTYPE(DATATYPE(#TP)) = SCALAR) |\n                              (STRUCTYPE(DATATYPE(#TP)) = SUBRANGE) THEN\n                              RECORD_LENGTH = 2;\n                           ELSE RECORD_LENGTH = STORAGE_LNGTH(DATATYPE(#TP));\n                           CALL EMIT_TRIPLE(MONITOR, TABLE_PTR,\n                              FINDCONST(RECORD_LENGTH), MONITOR_CODE(ID_PTR));\n                        END;\n                     IF #MP = FATHERS_MULTIPLICITY THEN #OP = #OP - 2;\n                     ELSE #OP = #OP - 1;\n                  END;\n                  /* CASE 28 -- PAGE() */\n                  GOTO GETPUTRESETREWRITEPAGE;\n                  /* CASE 29 -- READLN() */\n                  GOTO READREADLN;\n                  /* CASE 30 -- WRITELN() */\n                  GOTO WRITEWRITELN;\n                  /* CASE 31 -- CLOCK */\n                  DO;\n                     CALL ERROR('STANDARD FUNCTION CLOCK HAS NO PARAMETERS', 1);\n                     #OP = #OP - 1;\n                     #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                     #TP = INTPTR;\n                  END;\n               END;   /* CASE */\n            END;   /* #MP > 1 */\n      END PROCFUNC;\n\n     /*         $P ----- ENABLES XREF PROGRAM         */\n      FIRST_VISIT = TRUE;\n      NP, #OP = 0;\n      NODE = ROOT_OF_SUBTREE;\n      IF \u00acIS_VALID_ROOT_PRODUCTION(PARSE_TREE(NODE + 1)) THEN RETURN;\n      DO WHILE FIRST_VISIT | NP > 0;\n         IF FIRST_VISIT THEN\n            DO;\n               IF NODE = NULL THEN FIRST_VISIT = FALSE;\n               ELSE IF IS_LEAF THEN\n                  DO;\n                     TABLE_PTR = PARSE_TREE(NODE + 1);\n                     FIRST_VISIT = FALSE;\n                     IF IS_DECLARATION THEN CALL REPLACE(TABLE_PTR);\n                     ELSE\n                        DO; /* PUSH SYMBOL TABLE POINTER ONTO OPERAND STACK */\n                           IF #OP < #OPMAX THEN #OP = #OP + 1;\n                           ELSE\n                              DO;\n                                 CALL ERROR(OP#STACK#ERR, 1);\n                                 #OP = 10;\n                              END;\n                           OPERAND#STK(#OP) = TABLE_PTR;\n                           /* OPERAND#STK IS POPPED WHEN TRIPLES ARE FORMED */\n                           #TP = DATATYPE(TABLE_PTR);\n                           CALL REPLACE(#TP);\n                        END;\n                  END;\n               ELSE\n                  DO;\n                     /* CASE STATEMENT ON PRODUCTION NUMBER OF NODE */\n                     I = PARSE_TREE(NODE + 1);\n                     DO CASE PR_CASES(I);\n                        /*  CASE 0 -- NO ACTION  */\n                        ;\n                        /* CASE 1 -- WHILE OR UNTIL STATEMENT  */\n                        DO;\n                           CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                           IF NP < NPMAX THEN\n                              FIX_LIST(NP + 1) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           FX = FALSE;\n                           LISTHEAD = NULL;\n                        END;\n                        /* CASE 2 -- PROD. 66 RECORD TYPE.  CREATE SY_TABLE\n                                              ENTRY                    */\n                        DO;\n                           IF ALLOCATE_NEW_ROW THEN\n                              ID_PTR = NEXT_FREE_ROW;\n                           ELSE\n                              DO;\n                                 ID_PTR = TP_ID_PTR;\n                                 ALLOCATE_NEW_ROW = TRUE;\n                              END;\n                           DATATYPE(ID_PTR) = ID_PTR;\n                           VAR_TYPE(ID_PTR) = TYPE;\n                           STRUCTYPE(ID_PTR) = RECORD;\n                           OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                           CURRENT_LEVEL = CURRENT_LEVEL + 1;\n                           OWNER_STACK(CURRENT_LEVEL) = ID_PTR;\n                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;\n                           IF VAR_TYPE(OWNER_STACK(CURRENT_LEVEL-1)) = PROC THEN\n                              STACK_LIMIT(CURRENT_LEVEL),\n                                 HALFWORD_DISP(CURRENT_LEVEL) = 0;\n                           ELSE\n                              DO;\n                                 STACK_LIMIT(CURRENT_LEVEL) =\n                                    STACK_LIMIT(CURRENT_LEVEL - 1);\n                                 HALFWORD_DISP(CURRENT_LEVEL) =\n                                    HALFWORD_DISP(CURRENT_LEVEL - 1);\n                              END;\n                        END;\n                        /* CASE 3 -- BLOCK HEADER  */\n                        IS_DECLARATION = TRUE;\n                        /* CASE 4 -- BLOCK BODY */\n                        DO;\n                           IS_DECLARATION = FALSE;\n                           IF PARSE_TREE(NODE + 2) \u00ac= NULL THEN\n                              DO;\n                                 TRIPLES(0) = OWNER_STACK(CURRENT_LEVEL);\n                                 TRIPLES(1) = VALUE(TRIPLES(0));\n                                 TRIPLES(2), N_TRIPLES = 6;\n                                 IF CURRENT_LEVEL > 1 THEN\n                                    IF MONITOR_LINK(2) > 0 THEN\n                                    DO; /* DEBUG LEVEL > 0; INITIALIZE STORAGE*/\n                                       I = S_LIST(OWNER_STACK(CURRENT_LEVEL));\n                                       MAX = DISPLAY_BYTES+4*(CURRENT_LEVEL-1);\n                                       DO WHILE I \u00ac= NULL;\n                                          J = DISPLACEMENT(I)+STORAGE_LNGTH(I);\n                                          IF J > MAX THEN MAX = J;\n                                          I = S_LIST(I);\n                                       END;\n                                       I = STACK_LIMIT(CURRENT_LEVEL) - MAX;\n                                       IF I > 0 THEN\n                                          DO; /* THERE ARE LOCALS */\n                                             J = NEXT_FREE_ROW;\n                                             STORAGE_LNGTH(J) = I;\n                                             PSEUDO_REG(J) = CURRENT_LEVEL - 1;\n                                             DISPLACEMENT(J) = MAX;\n                                             CALL EMIT_TRIPLE(XOR, J, J, 0);\n                                          END;\n                                       /* INITIALIZE FUNCTION RETURN VALUE */\n                                       IF DATATYPE(OWNER_STACK(CURRENT_LEVEL))\n                                          \u00ac= NULL THEN\n                                          CALL EMIT_TRIPLE(STORE,\n                                             OWNER_STACK(CURRENT_LEVEL),\n                                             0 | MASK_IMMEDIATE, 0);\n                                    END;\n                              END;\n                        END;\n                        /* CASE 5 -- ARRAY TYPES  */\n                        DO;\n                           ALLOCATE_ARRAY_ENTRY = ALLOCATE_NEW_ROW;\n                           ALLOCATE_NEW_ROW = TRUE;\n                        END;\n                        /* CASE 6 -- ASSIGNMENT  */\n                        DO;\n                           LHS = TRUE;\n                           FX = FALSE;\n                           LISTHEAD = NULL;\n                        END;\n                        /* CASE 7 -- FOR STATEMENT, PROC/FUNC CALL,\n                           SUBSCRIPT LIST, SET ELEMENT */\n                        DO;\n                           CALL REPLACE(FX);\n                           FX = FALSE;\n                           LISTHEAD = NULL;\n                        END;\n                        /* CASE 8 -- UNARY NOT */\n                        FX = \u00acFX;\n                        /* CASE 9 -- AND, OR */\n                        DO;\n                           CALL REPLACE(FX);\n                           FX = (I = 41); /* TRUE IF OR, FALSE IF AND */\n                           LISTHEAD = NULL;\n                        END;\n                        /* CASE 10 -- STATEMENT LIST */\n                        DO;\n                           CALL DGNS#_PUSH;\n                           CALL EMIT_ADD_DECIMAL;\n                        END;\n                        /* CASE 11 -- SET ELEMENT LIST */\n                        DO;\n                           IF NP < NPMAX THEN\n                              FIX_LIST(NP + 1) = NEXT_FREE_ROW;\n                           VAR_TYPE(N_DECL_SYMB - 1) = TYPE;\n                           STRUCTYPE(N_DECL_SYMB - 1) = SET;\n                        END;\n                        /* CASE 12 -- DUMMY PROC_PARAM */\n                        DO;\n                           TABLE_PTR = NEXT_FREE_ROW;\n                           DATATYPE(TABLE_PTR), S_LIST(TABLE_PTR) = NULL;\n                           OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                           STORAGE_LNGTH(TABLE_PTR) = 12;\n                           VAR_TYPE(TABLE_PTR) = PROC_PARAM;\n                           STRUCTYPE(TABLE_PTR) = STATEMENT;\n                           PSEUDO_REG(TABLE_PTR) = NULL;\n                           DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);\n                           STACK_LIMIT(CURRENT_LEVEL) =\n                              STACK_LIMIT(CURRENT_LEVEL) + 12;\n                           CURRENT_LEVEL = CURRENT_LEVEL + 1;\n                           OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;\n                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;\n                           STACK_LIMIT(CURRENT_LEVEL) = 0;\n                           HALFWORD_DISP(CURRENT_LEVEL) = 0;\n                           CALL REPLACE(TABLE_PTR);\n                        END;\n                     END;  /* OF CASE ON PR_CASES  */\n                     CALL LEFTSON;\n                  END;\n            END;\n         ELSE  /*  LATER VISITS  */\n            DO;\n               #MP = #POS_STACK(NP);\n               FATHERS_MULTIPLICITY = PARSE_TREE(NODE#STACK(NP));\n               DO CASE FATHERS_PROD_NO;\n               /* FOR PRODUCTION NUMBERS WHOSE MULTIPLICITY CAN EXCEED ONE,\n                  THE CODE WILL INCLUDE A SEGMENT TO VISIT THE NEXT SUBTREE.\n                  IN ADDITION, FOR MANY OF THE PRODUCTION NUMBERS, IT WILL\n                  BE NECESSARY TO DETERMINE WHICH OF THE SIBLING NODES IS\n                  BEING VISITED.  FOR THIS PURPOSE, ONE CAN INTERROGATE #MP,\n                  WHOSE VALUE IS THE INDEX OF 'NODE' AMONG ITS FATHER'S SONS. */\n               /* CASE 0 IS A DUMMY BECAUSE WE NUMBER PRODUCTIONS FROM 1 */\n                  ;\n               /* 1  <PROGRAM> ::= <ID> (<ID>)+ <BLOCK> */\n                  IF #MP = 1 THEN\n                     DO;\n                        DATATYPE(TABLE_PTR) = NULL;\n                        VAR_TYPE(TABLE_PTR) = PROC;\n                        STRUCTYPE(TABLE_PTR) = STATEMENT;\n                        OWNER(TABLE_PTR) = NULL;\n                        VALUE(TABLE_PTR) = 0;\n                        PSEUDO_REG(TABLE_PTR) = 0;\n                        OWNER_STACK(1) = TABLE_PTR;\n                        STACK_LIMIT(1) = CONST_POOL_SIZE + DISPLAY_BYTES;\n                        ARRAYS_ALLOCATED(1) = NULL;\n                        CURRENT_LEVEL = 1;\n                        DISPLACEMENT(TABLE_PTR), PROC_SEQUENCE_NUMBER = 0;\n                        /* THE STORAGE_LNGTH FIELD IS TO BE FILLED IN LATER\n                           WITH THE LENGTH OF THE ACTIVATION RECORD FOR THE\n                           <PROGRAM> BLOCK.                                 */\n                     END;\n                  ELSE\n                     DO; /* <ID> IS A FILE NAME */\n                        IF VAR_TYPE(TABLE_PTR) = UNDEFINED THEN\n                           DO;\n                              VAR_TYPE(TABLE_PTR) = VARIABLE;\n                              STRUCTYPE(TABLE_PTR) = FILE;\n                              DATATYPE(TABLE_PTR) = NULL;\n                           END;\n                        S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;\n                        /* DATATYPE, STORAGE_LNGTH ARE TO BE FILLED IN WHEN\n                           THE FILE DECLARATION IS ENCOUNTERED              */\n                     END;\n               /* 2  <BLOCK> ::= (<LABEL DECL>) (<CONST DECL>) (<TYPE DEFN>)\n                  (<VAR DECL LIST>) (<PROC DECL LIST>) <STATEMENT LIST> */\n                  ;\n               /* 3  <STATEMENT LIST> ::= (<STATEMENT>)+ */\n                  IF #MP = FATHERS_MULTIPLICITY THEN CALL DGNS#_POP;\n                  ELSE IF DGNS#_GOTO THEN\n                     DO;\n                        DGNS#_GOTO = FALSE;\n                        CALL EMIT_ADD_DECIMAL;\n                     END;\n               /* 4  <LABEL DECL> ::= (<UNSIGNED INTEGER>)+ */\n                  DO;\n                     DATATYPE(TABLE_PTR) = NULL;\n                     VAR_TYPE(TABLE_PTR) = LABLE;\n                     STRUCTYPE(TABLE_PTR) = STATEMENT;\n                     STORAGE_LNGTH(TABLE_PTR), OWNER(TABLE_PTR) =\n                           OWNER_STACK(CURRENT_LEVEL);\n                  END;\n               /* 5  <CONST DECL> ::= (<ID> <CONSTANT>)+ */\n                  IF #MP & 1 THEN\n                     DO;   /* <ID> */\n                        VAR_TYPE(TABLE_PTR) = CONSTANT;\n                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                        PSEUDO_REG(TABLE_PTR) = 0;\n                     END;\n                  ELSE\n                     DO;   /* <CONSTANT> */\n                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);\n                        DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);\n                        IF VAR_TYPE(TABLE_PTR) = LITERAL THEN\n                           /* <CONSTANT> IS A STRING */\n                           STRUCTYPE(ID_PTR) = ARRAY;\n                        ELSE\n                           DO;\n                              IF VAR_TYPE(TABLE_PTR) \u00ac= CONSTANT THEN\n                                 CALL ERROR(\n                 'ILLEGAL IDENTIFIER ON RIGHT SIDE OF CONSTANT DECLARATION', 1);\n                              STRUCTYPE(ID_PTR) = STRUCTYPE(I);\n                              VALUE(ID_PTR) = VALUE(TABLE_PTR);\n                           END;\n                        DISPLACEMENT(ID_PTR) = DISPLACEMENT(TABLE_PTR);\n                        S_LIST(ID_PTR) = TABLE_PTR;\n                     END;\n               /* 6  <TYPE DEFN> ::= (<ID> <TYPE>)+ */\n                  IF #MP & 1 THEN\n                     DO;  /* <IDENTIFIER> */\n                        VAR_TYPE(TABLE_PTR) = TYPE;\n                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                        TP_ID_PTR = TABLE_PTR;\n                        ALLOCATE_NEW_ROW = FALSE;\n                     END;\n                  ELSE\n                     DO;  /* <TYPE> */\n                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);\n                        DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);\n                        STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);\n                        STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);\n                     END;\n               /* 7  <PROC DECL LIST> ::= <PROC DECL> (<PROC DECL LIST>) */\n                  ;\n               /* 8  <PROC DECL> ::= <ID> (<FORMAL PARAM>)* <BODY> */\n                                  /* PROPER PROCEDURE */\n               PROC_DECL:\n                  IF #MP = 1 THEN\n                     DO;\n                        IF VAR_TYPE(TABLE_PTR) = MULTDECL THEN\n                           DO;\n                              VAR_TYPE(TABLE_PTR) = PROC;\n                              CURRENT_LEVEL = CURRENT_LEVEL + 1;\n                              OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;\n                              CALL RESTORE_CURRENT_LEVEL;\n                           END;\n                        ELSE\n                           DO;\n                              IF VAR_TYPE(TABLE_PTR) = FORWARD THEN\n                                 VAR_TYPE(TABLE_PTR) = MULTDECL;\n                              ELSE VAR_TYPE(TABLE_PTR) = PROC;\n                              DATATYPE(TABLE_PTR) = NULL;\n                              STRUCTYPE(TABLE_PTR) = STATEMENT;\n                              OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                              PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL;\n                              DISPLACEMENT(TABLE_PTR) = 0;\n                              VALUE(TABLE_PTR), PROC_SEQUENCE_NUMBER =\n                                 PROC_SEQUENCE_NUMBER + 1;\n                              /* STORAGE_LNGTH IS TO BE FILLED IN WHEN\n                                 PRODUCTION NUMBER 10 IS PROCESSED, AFTER\n                                 ALL DECLARATIONS OF VARIABLES LOCAL TO\n                                 THE PROCEDURE HAVE HAD STORAGE ALLOCATED. */\n                              CURRENT_LEVEL = CURRENT_LEVEL + 1;\n                              OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;\n                              ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;\n                              STACK_LIMIT(CURRENT_LEVEL) =\n                                 (CURRENT_LEVEL - 1)*4 + DISPLAY_BYTES;\n                              HALFWORD_DISP(CURRENT_LEVEL) = 0;\n                              IF VAR_TYPE(TABLE_PTR) = MULTDECL THEN\n                                 IF FATHERS_MULTIPLICITY = 1 THEN\n                                    CALL SAVE_CURRENT_LEVEL;\n                           END;\n                     END;  /* #MP = 1 */\n                  ELSE\n                     DO;  /* LINK FORMAL PARAMETER LISTS TOGETHER. */\n                        LINK = PARSE_TREE(NODE#STACK(NP) + #MP);\n                        DO WHILE S_LIST(LINK) \u00ac= NULL;\n                           LINK = S_LIST(LINK);\n                        END;\n                        S_LIST(LINK) = TABLE_PTR;\n                        CALL REPLACE(TABLE_PTR);\n                        IF #MP = FATHERS_MULTIPLICITY THEN\n                           DO;  /* ASSUMES NO ENTRY FOR <BODY> EXISTS IN FATHER\n                                */\n                              CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);\n                              IF FATHERS_PROD_NO = 9 THEN\n                                 DO;\n                                    S_LIST(LINK) = NULL;\n                                    ID_PTR = OWNER_STACK(CURRENT_LEVEL);\n                                    DATATYPE(ID_PTR) = TABLE_PTR;\n                                    I, STRUCTYPE(ID_PTR) =\n                                       STRUCTYPE(TABLE_PTR);\n                                    IF (VAR_TYPE(TABLE_PTR) \u00ac= TYPE) |\n                                       /* \u00ac(I IN (.SCALAR, SUBRANGE, POINTER,\n                                                   ARITHMETIC.))             */\n                                       ((SHL(1, I) & \"(1)10000 00000 01110\")\n                                          = 0) THEN\n                                    CALL ERROR(\n                    'FUNCTION CANNOT BE DECLARED TO HAVE A STRUCTURED TYPE', 1);\n                                 END;\n                              IF VAR_TYPE(OWNER_STACK(CURRENT_LEVEL)) = MULTDECL\n                                 THEN CALL SAVE_CURRENT_LEVEL;\n                           END;\n                     END;  /* PROC_DECL */\n               /* 9  <PROC DECL> ::= <ID> (<FORMAL PARAM>)* <ID> <BODY> */\n                                  /* FUNCTION PROCEDURE */\n                  GOTO PROC_DECL;\n               /* 10  <BODY> ::= (<STATEMENT LIST>) */\n                  DO;\n                     CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);\n                     STORAGE_LNGTH(OWNER_STACK(CURRENT_LEVEL)) =\n                           STACK_LIMIT(CURRENT_LEVEL);\n                     CURRENT_LEVEL = CURRENT_LEVEL - 1;\n                     IF NODE \u00ac= NULL THEN\n                        DO;\n                           CALL EMIT_TRIPLE(PRETURN, NULL, NULL, 0);\n                           CALL EMIT_TRIPLE(PEND, NULL, NULL, 0);\n                           TRIPLES(3) = N_TRIPLES;\n                           CALL WRITE_TRIPLES;\n                        END;\n                  END;\n               /* 11  <VAR DECL LIST> ::= <VAR DECL> (<VAR DECL LIST>) */\n                  ;\n               /* 12  <VAR DECL> ::= (<ID>)+ <TYPE> */\n                  IF #MP < FATHERS_MULTIPLICITY THEN\n                     DO;\n                        VAR_TYPE(TABLE_PTR) = VARIABLE;\n                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                        PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;\n                     END;\n                  ELSE\n                     DO;\n                        CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);\n                        DO #TP = 2 TO FATHERS_MULTIPLICITY;\n                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + #TP);\n                           I, STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);\n                           DATATYPE(ID_PTR) = TABLE_PTR;\n                           CALL ALLOCATE_STORAGE(ID_PTR);\n                        END;\n                     END;\n               /* 13  <STATEMENT> ::= <UNSIGNED INTEGER> <STATEMENT> */\n                  /* WHEN #MP = 1, NODE POINTS TO LABEL. */\n                  IF #MP = 1 THEN\n                     DO;\n                        IF (TRIPLES(N_TRIPLES - 3) & \"7F\") = ADD_DECIMAL THEN\n                           DO;   /* BACK UP THE BLOCK-COUNTER EMITTER */\n                              IC = IC - 1;\n                              BASIC_BLOCKS = BASIC_BLOCKS - 1;\n                              N_TRIPLES = N_TRIPLES - 3;\n                           END;\n                        /* SEE IF LABEL HAS ALREADY BEEN DEFINED. */\n                        IF VALUE(TABLE_PTR) > 0 THEN\n                           CALL ERROR('THE SAME LABEL IS DEFINED TWICE', 1);\n                        /* NOW, DEFINE LABEL. */\n                        CALL EMIT_TRIPLE(BCH_TARGET, TABLE_PTR, NULL, 0);\n                        VALUE(TABLE_PTR) = IC;\n                        DISPLACEMENT(TABLE_PTR) = N_TRIPLES - 3;\n                        CALL EMIT_ADD_DECIMAL;\n                        /* POP THE LABEL FROM THE OPERAND STACK */\n                        #OP = #OP - 1;\n                     END;\n               /* 14  <STATEMENT> ::= <VARIABLE> <EXPRESSION> */\n                                  /* ASSIGNMENT */\n                  DO;\n                     CALL REPLACE(#TP);\n                     IF #MP = 1 THEN LHS = FALSE;\n                     ELSE\n                        DO;\n                           IF #TP = BOOLPTR THEN\n                              IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                                 CALL COND_TO_REGISTER;\n                           CALL COERCE_ASSIGNMENT(\n                              PARSE_TREE(NODE#STACK(NP) + #MP), #TP);\n                           I = STRUCTYPE(#TP);\n                           /* IF STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, POINTER,\n                              ARRAY, PACKED_ARRAY, RECORD, PACKED_RECORD,\n                              ARITHMETIC.) THEN   */\n                           IF (SHL(1, I) & \"(1)10000 11001 11110\") \u00ac= 0 THEN\n                              CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 0);\n                           ELSE IF (I = SET) | (I = PACKED_SET) THEN\n                              DO;\n                                 IF OPERAND#STK(#OP) = EMPTYSETPTR THEN\n                                    DO;\n                                       J = OPERAND#STK(#OP - 1);\n                                       CALL EMIT_TRIPLE(XOR, J, J, 0);\n                                    END;\n                                 ELSE CALL EMIT_TRIPLE(MOVE, OPERAND#STK(#OP-1),\n                                    OPERAND#STK(#OP), 0);\n                              END;\n                           ELSE CALL ERROR('ILLEGAL ASSIGNMENT', 1);\n                           #OP = #OP - 2;\n                        END;\n                  END;\n               /* 15  <STATEMENT> ::= <ID> (<EXPRESSION>)* */\n                                  /* PROCEDURE STATEMENT */\n                  DO;\n                     CALL PROCFUNC(TRUE);\n                     DGNS#_TOP, DGNS#_GOTO, DGNS#_STACK(DGNS#_DEPTH) = TRUE;\n                  END;\n               /* 16  <STATEMENT> ::= <STATEMENT LIST> */\n                                  /* COMPOUND GROUP */\n                  ;\n               /* 17  <STATEMENT> ::= <EXPRESSION> <STATEMENT> (<STATEMENT>) */\n                                  /* CONDITIONAL STATEMENT */\n                  IF #MP = 1 THEN\n                     DO;\n                        IF \u00acCOMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);\n                        IF \u00acIS_CONDITION(OPERAND#STK(#OP)) THEN\n                           DO;\n                              CALL EMIT_CONDITIONAL_BRANCH(FX);\n                              LISTHEAD = N_TRIPLES - 3;\n                           END;\n                        IF FX THEN\n                           DO; /* EMIT AN UNCONDITIONAL BRANCH AROUND\n                                  THE 'THEN' CLAUSE. */\n                              CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);\n                              OPERAND#STK(#OP) = N_TRIPLES - 3;\n                              CALL FIXUP(LISTHEAD, N_TRIPLES);\n                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                           END;\n                        ELSE OPERAND#STK(#OP) = LISTHEAD;\n                        LISTHEAD = NULL;\n                        CALL DGNS#_PUSH;\n                        CALL EMIT_ADD_DECIMAL;\n                     END;\n                  ELSE\n                     DO;\n                        LISTHEAD = OPERAND#STK(#OP);\n                        IF #MP < FATHERS_MULTIPLICITY THEN\n                           DO; /* BRANCH AROUND 'ELSE' CLAUSE */\n                              CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);\n                              OPERAND#STK(#OP) = N_TRIPLES - 3;\n                           END;\n                        ELSE #OP = #OP - 1;\n                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                        CALL FIXUP(LISTHEAD, N_TRIPLES - 3);\n                        LISTHEAD = NULL;\n                        IF #MP < FATHERS_MULTIPLICITY THEN\n                           CALL EMIT_ADD_DECIMAL;\n                        ELSE CALL DGNS#_POP;\n                     END;\n               /* 18  <STATEMENT> ::= <EXPRESSION> (<CASE INSTANCE>)+ */\n                                  /* CASE STATEMENT */\n                  IF #MP = 1 THEN\n                     DO;\n                        FIX_LIST(NP) = NULL;\n                        CALL DGNS#_PUSH;\n                        MIN = MAXINT;\n                        MAX = - MIN - 1;\n                        IF #TP = BOOLPTR THEN\n                           IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                              CALL COND_TO_REGISTER;\n                        CALL REPLACE(#TP);\n                        DO I = 3 TO FATHERS_MULTIPLICITY + 1;\n                           CASE_INSTANCE_PTR = PARSE_TREE(NODE#STACK(NP) + I);\n                           DO J = 2 TO MULTIPLICITY(CASE_INSTANCE_PTR);\n                              CASE_LABEL_PTR = PARSE_TREE(CASE_INSTANCE_PTR+J);\n                              IF MULTIPLICITY(CASE_LABEL_PTR) \u00ac= 0 THEN\n                                 /* UNARY MINUS */\n                                 CASE_LABEL_VALUE = - VALUE(PARSE_TREE(\n                                    PARSE_TREE(CASE_LABEL_PTR + 2) + 1));\n                              ELSE CASE_LABEL_VALUE =\n                                 VALUE(PARSE_TREE(CASE_LABEL_PTR + 1));\n                              IF CASE_LABEL_VALUE < MIN THEN\n                                 MIN = CASE_LABEL_VALUE;\n                              IF CASE_LABEL_VALUE > MAX THEN\n                                 MAX = CASE_LABEL_VALUE;\n                           END;\n                        END;\n                        IF (OPERAND#STK(#OP) & MASK_TRIPLE) = 0 THEN\n                           DO;   /* LOAD THE CASE SELECTOR */\n                              CALL EMIT_TRIPLE(LOAD, OPERAND#STK(#OP), NULL, 3);\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           END;\n                        IF STRUCTYPE(#TP) = SUBRANGE THEN\n                           DO;\n                              IF VALUE(S_LIST(#TP)) \u00ac= MIN THEN\n                                 DO;\n                                    CALL EMIT_TRIPLE(ADD, OPERAND#STK(#OP),\n                                       FINDCONST(VALUE(S_LIST(#TP)) - MIN), 3);\n                                    OPERAND#STK(#OP) =\n                                       (N_TRIPLES - 3) | MASK_TRIPLE;\n                                 END;\n                              IF VALUE(S_LIST(#TP)) < MIN THEN\n                                 DO;\n                                    CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP) |\n                                       MASK_TEMP, 0 | MASK_IMMEDIATE, 0);\n                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),\n                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                                    FIX_LIST(NP) = N_TRIPLES - 3;\n                                 END;\n                              IF VALUE(#TP) > MAX THEN\n                                 DO;\n                                    CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP) |\n                                       MASK_TEMP, FINDCONST(MAX - MIN), 0);\n                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),\n                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                                    FIX_LIST(NP) = N_TRIPLES - 3;\n                                 END;\n                           END;\n                        ELSE IF (STRUCTYPE(#TP) = SCALAR)\n                           | COMPTYPES(#TP, INTPTR) THEN\n                           DO;\n                              IF MIN \u00ac= 0 THEN\n                                 DO;\n                                    CALL EMIT_TRIPLE(ADD, OPERAND#STK(#OP),\n                                       FINDCONST(-MIN), 3);\n                                    OPERAND#STK(#OP) =\n                                       (N_TRIPLES - 3) | MASK_TRIPLE;\n                                    CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP) |\n                                       MASK_TEMP, 0 | MASK_IMMEDIATE, 0);\n                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),\n                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                                    FIX_LIST(NP) = N_TRIPLES - 3;\n                                 END;\n                              IF (STORAGE_LNGTH(#TP) - 1 > MAX)\n                                 | COMPTYPES(#TP, INTPTR) THEN\n                                 DO;\n                                    CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP)\n                                       | MASK_TEMP, FINDCONST(MAX - MIN), 0);\n                                    CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),\n                                       (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                                    FIX_LIST(NP) = N_TRIPLES - 3;\n                                 END;\n                           END;\n                        ELSE CALL ERROR('ILLEGAL TYPE OF CASE SELECTOR', 1);\n                        TABLE_PTR = NEXT_FREE_ROW;\n                        DATATYPE(TABLE_PTR) = DATATYPE(#TP);\n                        STRUCTYPE(TABLE_PTR) = SUBRANGE;\n                        VAR_TYPE(TABLE_PTR) = TYPE;\n                        VALUE(TABLE_PTR) = MAX;\n                        STORAGE_LNGTH(TABLE_PTR) = MAX - MIN + 1;\n                        CALL EMIT_TRIPLE(CASE_JUMP, OPERAND#STK(#OP),\n                           TABLE_PTR, 0);\n                        OPERAND#STK(#OP) = (N_TRIPLES - 3);\n                        DO I = MIN TO MAX;\n                           CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);\n                        END;\n                     END;   /* #MP = 1 */\n                  ELSE IF #MP < FATHERS_MULTIPLICITY THEN\n                     DO;\n                        CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);\n                        FIX_LIST(NP) = N_TRIPLES - 3;\n                     END;\n                  ELSE /* #MP = FATHERS_MULTIPLICITY */\n                     DO;\n                        LISTHEAD = NULL;\n                        I = OPERAND#STK(#OP);\n                        TABLE_PTR = TRIPLES(I + 2);\n                        TRIPLES(I + 2) = FINDCONST(STORAGE_LNGTH(TABLE_PTR));\n                        J = I + 3*STORAGE_LNGTH(TABLE_PTR);\n                        DO WHILE I < J;\n                           I = I + 3;\n                           IF TRIPLES(I + 1) = NULL THEN /* EMPTY CASE */\n                              DO;\n                                 TRIPLES(I + 1) = LISTHEAD;\n                                 LISTHEAD = I;\n                              END;\n                        END;\n                        IF LISTHEAD \u00ac= NULL THEN\n                           DO;\n                              CALL EMIT_TRIPLE(CASE_TARGET, NULL, NULL, 0);\n                              CALL FIXUP(LISTHEAD, N_TRIPLES - 3);\n                              LISTHEAD = NULL;\n                           END;\n                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                        CALL FIXUP(FIX_LIST(NP), N_TRIPLES - 3);\n                        IF TABLE_PTR + 1 = N_DECL_SYMB THEN\n                           /* RELEASE THE SYMBOL TABLE ENTRY */\n                           N_DECL_SYMB = N_DECL_SYMB - 1;\n                        #OP = #OP - 1;\n                        CALL DGNS#_POP;\n                     END;\n               /* 19  <STATEMENT> ::= <EXPRESSION> <STATEMENT> */\n                                  /* WHILE STATEMENT */\n                  IF #MP = 1 THEN\n                     DO;\n                        CALL DGNS#_PUSH;\n                        IF \u00acCOMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);\n                        IF \u00acIS_CONDITION(OPERAND#STK(#OP)) THEN\n                           DO;\n                              CALL EMIT_CONDITIONAL_BRANCH(FX);\n                              LISTHEAD = N_TRIPLES - 3;\n                           END;\n                        IF FX THEN\n                           DO; /* EMIT AN UNCONDITIONAL BRANCH\n                                  AROUND THE WHILE STATEMENT */\n                              CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);\n                              OPERAND#STK(#OP) = N_TRIPLES - 3;\n                              CALL FIXUP(LISTHEAD, N_TRIPLES);\n                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                           END;\n                        ELSE OPERAND#STK(#OP) = LISTHEAD;\n                        LISTHEAD = NULL;\n                        CALL EMIT_ADD_DECIMAL;\n                     END;\n                  ELSE\n                     DO;\n                        CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);\n                        CALL FIXUP(OPERAND#STK(#OP), N_TRIPLES);\n                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                        #OP = #OP - 1;\n                        CALL DGNS#_POP;\n                     END;\n               /* 20  <STATEMENT> ::= <STATEMENT LIST> <EXPRESSION> */\n                                  /* UNTIL STATEMENT */\n                  IF #MP = 1 THEN FX = FALSE;\n                  ELSE\n                     DO;\n                        IF \u00acCOMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);\n                        IF \u00acIS_CONDITION(OPERAND#STK(#OP)) THEN\n                           DO;\n                              CALL EMIT_CONDITIONAL_BRANCH(FX);\n                              LISTHEAD = N_TRIPLES - 3;\n                           END;\n                        IF FX THEN\n                           DO;\n                              CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);\n                              CALL FIXUP(LISTHEAD, N_TRIPLES);\n                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                           END;\n                        ELSE CALL FIXUP(LISTHEAD, FIX_LIST(NP));\n                        LISTHEAD = NULL;\n                        #OP = #OP - 1;\n                     END;\n               /* 21  <STATEMENT> ::= <ID> <EXPRESSION> <EXPRESSION> <STATEMENT>\n               */\n                                  /* FOR STATEMENT -- UPTO */\n               FORSTAT:\n                  IF #MP = 1 THEN\n                     DO;\n                        CALL REPLACE(#TP);\n                        IF VAR_TYPE(TABLE_PTR) = VAR_PARAM THEN\n                           CALL ERROR('CONTROL VARIABLE MUST NOT BE FORMAL', 1);\n                        ELSE IF VAR_TYPE(TABLE_PTR) \u00ac= VARIABLE THEN\n                   CALL ERROR('ILLEGAL OR UNDECLARED LOOP CONTROL VARIABLE', 1);\n                        I = STRUCTYPE(#TP);\n                        IF ((SHL(1, I) & \"(1)10000 00000 00110\") = 0)\n                           /* \u00ac(I IN (.SCALAR, SUBRANGE, ARITHMETIC.)) */\n                           | COMPTYPES(#TP, REALPTR) THEN\n                         CALL ERROR('ILLEGAL TYPE OF LOOP CONTROL VARIABLE', 1);\n                     END;\n                  ELSE IF #MP < 4 THEN\n                     DO;\n                        CALL REPLACE(#TP);\n                        IF COMPTYPES(#TP, BOOLPTR) THEN\n                           IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                              CALL COND_TO_REGISTER;\n                        CALL COERCE_ASSIGNMENT(PARSE_TREE(NODE#STACK(NP) + 2),\n                           #TP);\n                        TABLE_PTR = OPERAND#STK(#OP);\n                        IF (TABLE_PTR & \"C000\") = MASK_SYMBOL THEN\n                           DO;\n                              IF VAR_TYPE(TABLE_PTR) = CONSTANT THEN\n                                 DO;\n                                    IF #MP = 2 THEN\n                                       DO;\n                                          BOUND1_IS_CONST = TRUE;\n                                          BOUND1_VALUE = VALUE(TABLE_PTR);\n                                       END;\n                                    ELSE   /* #MP = 3 */\n                                       DO;\n                                          BOUND2_IS_CONST = TRUE;\n                                          BOUND2_VALUE = VALUE(TABLE_PTR);\n                                       END;\n                                 END;\n                              ELSE IF #MP = 2 THEN BOUND1_IS_CONST = FALSE;\n                              ELSE /* #MP = 3 */ BOUND2_IS_CONST = FALSE;\n                           END;\n                        ELSE IF (TABLE_PTR & \"C000\") = MASK_IMMEDIATE THEN\n                           DO;\n                              IF #MP = 2 THEN\n                                 DO;\n                                    BOUND1_IS_CONST = TRUE;\n                                    BOUND1_VALUE = TABLE_PTR & \"3FFF\";\n                                 END;\n                              ELSE   /* #MP = 3 */\n                                 DO;\n                                    BOUND2_IS_CONST = TRUE;\n                                    BOUND2_VALUE = TABLE_PTR & \"3FFF\";\n                                 END;\n                           END;\n                        ELSE IF #MP = 2 THEN BOUND1_IS_CONST = FALSE;\n                        ELSE /* #MP = 3 */ BOUND2_IS_CONST = FALSE;\n                        IF #MP = 3 THEN\n                           DO;\n                              CALL EMIT_TRIPLE(TEMP, OPERAND#STK(#OP), NULL, 3);\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TEMP;\n                              IF FATHERS_PROD_NO = 21 THEN /* UPTO */\n                                 DO;\n                                    IF BOUND1_IS_CONST THEN\n                                       DO;\n                                          IF BOUND2_IS_CONST THEN\n                                             CALL EMIT_TRIPLE(TEMP,\n                                                FINDCONST(BOUND2_VALUE + 1\n                                                   - BOUND1_VALUE), NULL, 3);\n                                          ELSE IF BOUND1_VALUE = 1 THEN\n                                             CALL EMIT_TRIPLE(TEMP,\n                                                OPERAND#STK(#OP), NULL, 3);\n                                          ELSE\n                                             DO;\n                                                CALL EMIT_TRIPLE(SUBTRACT,\n                                                   OPERAND#STK(#OP),\n                                                   FINDCONST(BOUND1_VALUE-1),3);\n                                                CALL EMIT_TRIPLE(TEMP,\n                                                   (N_TRIPLES-3) | MASK_TRIPLE,\n                                                   NULL, 3);\n                                             END;\n                                       END;\n                                    ELSE   /* \u00acBOUND1_IS_CONST */\n                                       DO;\n                                          IF BOUND2_IS_CONST THEN\n                                             CALL EMIT_TRIPLE(SUBTRACT,\n                                                FINDCONST(BOUND2_VALUE + 1),\n                                                OPERAND#STK(#OP - 1), 3);\n                                          ELSE\n                                             DO;   /* WORST CASE */\n                                                CALL EMIT_TRIPLE(SUBTRACT,\n                                                   OPERAND#STK(#OP),\n                                                   OPERAND#STK(#OP - 1), 3);\n                                                CALL EMIT_TRIPLE(ADD,\n                                                   (N_TRIPLES-3) | MASK_TRIPLE,\n                                                   1 | MASK_IMMEDIATE, 3);\n                                             END;\n                                          CALL EMIT_TRIPLE(TEMP,\n                                             (N_TRIPLES - 3) | MASK_TRIPLE,\n                                             NULL, 3);\n                                       END;\n                                 END;\n                              ELSE   /* DOWNTO */\n                                 DO;\n                                    IF BOUND1_IS_CONST THEN\n                                       DO;\n                                          IF BOUND2_IS_CONST THEN\n                                             CALL EMIT_TRIPLE(TEMP,\n                                                FINDCONST(BOUND1_VALUE + 1\n                                                   - BOUND2_VALUE), NULL, 3);\n                                          ELSE\n                                             DO;\n                                                CALL EMIT_TRIPLE(SUBTRACT,\n                                                   FINDCONST(BOUND1_VALUE + 1),\n                                                   OPERAND#STK(#OP), 3);\n                                                CALL EMIT_TRIPLE(TEMP,\n                                                   (N_TRIPLES-3) | MASK_TRIPLE,\n                                                   NULL, 3);\n                                             END;\n                                       END;\n                                    ELSE   /* \u00acBOUND1_IS_CONST */\n                                       DO;\n                                          IF \u00acBOUND2_IS_CONST THEN\n                                             DO;   /* WORST CASE */\n                                                CALL EMIT_TRIPLE(SUBTRACT,\n                                                   OPERAND#STK(#OP - 1),\n                                                   OPERAND#STK(#OP), 3);\n                                                CALL EMIT_TRIPLE(ADD,\n                                                   (N_TRIPLES-3) | MASK_TRIPLE,\n                                                   1 | MASK_IMMEDIATE, 3);\n                                                CALL EMIT_TRIPLE(TEMP,\n                                                   (N_TRIPLES-3) | MASK_TRIPLE,\n                                                   NULL, 3);\n                                             END;\n                                          ELSE IF BOUND2_VALUE = 1 THEN\n                                             CALL EMIT_TRIPLE(TEMP,\n                                                OPERAND#STK(#OP - 1), NULL, 3);\n                                          ELSE\n                                             DO;\n                                                CALL EMIT_TRIPLE(SUBTRACT,\n                                                   OPERAND#STK(#OP - 1),\n                                                   FINDCONST(BOUND2_VALUE-1),3);\n                                                CALL EMIT_TRIPLE(TEMP,\n                                                   (N_TRIPLES-3) | MASK_TRIPLE,\n                                                   NULL, 3);\n                                             END;\n                                       END;\n                                 END;\n                              OPERAND#STK(#OP - 1) = (N_TRIPLES-3) | MASK_TEMP;\n                              CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                              FIX_LIST(NP) = N_TRIPLES;\n                              CALL EMIT_TRIPLE(BCT, NULL, OPERAND#STK(#OP-1),0);\n                              IF FATHERS_PROD_NO = 21 THEN I = SUBTRACT;\n                              ELSE I = ADD;\n                              CALL EMIT_TRIPLE(I, OPERAND#STK(#OP),\n                                 OPERAND#STK(#OP - 1), 3);\n                              CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP - 2),\n                                 (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                              CALL DGNS#_PUSH;\n                              CALL EMIT_ADD_DECIMAL;\n                           END;\n                     END;\n                  ELSE /* #MP = 4 */\n                     DO;\n                        CALL EMIT_TRIPLE(BCH, (FIX_LIST(NP) - 3) | MASK_TRIPLE,\n                           NULL, 0);\n                        CALL FIXUP(FIX_LIST(NP), N_TRIPLES);\n                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n                        CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP - 1) & \"BFFF\",\n                           NULL, 0);\n                        CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP) & \"BFFF\",\n                           NULL, 0);\n                        #OP = #OP - 3;\n                        CALL DGNS#_POP;\n                     END;\n               /* 22  <STATEMENT> ::= <ID> <EXPRESSION> <EXPRESSION> <STATEMENT>\n               */\n                                  /* FOR STATEMENT - DOWNTO */\n                  GOTO FORSTAT;\n               /* 23  <STATEMENT> ::= (<VARIABLE>)+ <STATEMENT> */\n                                  /* WITH STATEMENT */\n                  IF #MP < FATHERS_MULTIPLICITY THEN\n                     DO;\n                        CALL REPLACE(#TP);\n                        WITH_PTR = WITH_PTR + 1;\n                        IF WITH_PTR > WITH_LENGTH THEN\n                           DO;\n                              CALL ERROR('WITH VARIABLES NESTED TOO DEEPLY', 1);\n                              WITH_PTR = WITH_PTR - 1;\n                              #OP = #OP - 1;\n                           END;\n                        ELSE\n                           DO;\n                              IF (OPERAND#STK(#OP) & \"C000\") = MASK_SYMBOL THEN\n                                 DO;\n                                    ID_PTR = OPERAND#STK(#OP);\n                                    IF VAR_TYPE(ID_PTR) \u00ac= VARIABLE THEN\n                                       CALL ERROR('ILLEGAL \"WITH\" VARIABLE: '\n                                          || IDENTITY(ID_PTR), 1);\n                                  END;\n                              CALL EMIT_TRIPLE(LOAD_ADDR, OPERAND#STK(#OP),\n                                 NULL, 3);\n                              WITH_VARIABLE(WITH_PTR) =\n                                 (N_TRIPLES - 3) | MASK_TEMP;\n                              WITH_DATATYPE(WITH_PTR) = #TP;\n                              #OP = #OP - 1;\n                           END;\n                        IF #MP = FATHERS_MULTIPLICITY - 1 THEN\n                           DO;\n                              CALL DGNS#_PUSH;\n                              CALL EMIT_ADD_DECIMAL;\n                           END;\n                     END;\n                  ELSE\n                     DO I = 1 TO FATHERS_MULTIPLICITY - 1;\n                        CALL EMIT_TRIPLE(TPOP, WITH_VARIABLE(WITH_PTR) & \"BFFF\",\n                                         NULL, 0);\n                        WITH_PTR = WITH_PTR - 1;\n                        IF I = FATHERS_MULTIPLICITY - 1 THEN\n                           CALL DGNS#_POP;\n                     END;\n               /* 24  <STATEMENT> ::= <UNSIGNED INTEGER> */\n                                  /* GOTO STATEMENT */\n                  DO;\n                     CALL EMIT_TRIPLE(BCH, TABLE_PTR,\n                        FINDCONST(VALUE(OWNER(TABLE_PTR))), 0);\n                     #OP = #OP - 1;\n                     DGNS#_TOP, DGNS#_GOTO, DGNS#_STACK(DGNS#_DEPTH) = TRUE;\n                  END;\n               /* 25  <FORMAL PARAM> ::= (<ID>)+ <ID> */\n                                  /* FORMAL VAR PARAMETER */\n            FORMAL:\n               IF #MP < FATHERS_MULTIPLICITY THEN DO;\n                  OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                  PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;\n                  IF #MP > 1 THEN\n                     S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;\n                  IF FATHERS_PROD_NO = 25 THEN\n                     DO;   /* VAR PARAMETER */\n                        VAR_TYPE(TABLE_PTR) = VAR_PARAM;\n                        STORAGE_LNGTH (TABLE_PTR) = 4;\n                        DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);\n                        STACK_LIMIT(CURRENT_LEVEL) =\n                              STACK_LIMIT(CURRENT_LEVEL) + 4;\n                        END;\n                  ELSE /* VALUE PARAM */ VAR_TYPE(TABLE_PTR) = VARIABLE;\n                  END;\n               ELSE DO;   /* TYPE IDENTIFIER  */\n                  IF VAR_TYPE(TABLE_PTR) \u00ac= TYPE THEN\n                     CALL ERROR(IDENTITY(TABLE_PTR) || ' IS NOT A TYPE', 1);\n                  I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                  DO WHILE ID_PTR \u00ac= NULL;\n                     DATATYPE(ID_PTR) = TABLE_PTR;\n                     STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);\n                     IF FATHERS_PROD_NO = 26 THEN DO;\n                        CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);\n                        CALL ALLOCATE_STORAGE(ID_PTR);\n                        END;\n                     ID_PTR = S_LIST(ID_PTR);\n                     END;\n                  TABLE_PTR = I;\n                  END;\n               /* 26  <FORMAL PARAM> ::= (<ID>)+ <ID> */\n                                  /* FORMAL VALUE PARAMETER */\n                  GOTO FORMAL;\n               /* 27  <FORMAL PARAM> ::= (<ID>)+ (<PARAM TYPES>)+ (<ID>) */\n                                  /* FORMAL PROCEDURE PARAMETER */\n                  IF IS_LEAF & (#MP < FATHERS_MULTIPLICITY) THEN\n                     DO;\n                        DATATYPE(TABLE_PTR), S_LIST(TABLE_PTR) = NULL;\n                        VAR_TYPE(TABLE_PTR) = PROC_PARAM;\n                        STRUCTYPE(TABLE_PTR) = STATEMENT;\n                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                        STORAGE_LNGTH(TABLE_PTR) = 12;\n                        PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;\n                        DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);\n                        STACK_LIMIT(CURRENT_LEVEL) =\n                           STACK_LIMIT(CURRENT_LEVEL) + 12;\n                        IF #MP > 1 THEN\n                           S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;\n                        CALL REPLACE(TABLE_PTR);\n                        FIRST_PARAM_TYPES =\n                           (MULTIPLICITY(PARSE_TREE(NODE#STACK(NP)+#MP+2)) > 0);\n                        IF FIRST_PARAM_TYPES THEN\n                           DO; /* INCREMENT CURRENT_LEVEL */\n                              CURRENT_LEVEL = CURRENT_LEVEL + 1;\n                              OWNER_STACK(CURRENT_LEVEL) =\n                                 PARSE_TREE(NODE#STACK(NP) + 2);\n                              ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;\n                              STACK_LIMIT(CURRENT_LEVEL) = 0;\n                              HALFWORD_DISP(CURRENT_LEVEL) = 0;\n                           END;\n                     END;\n                  ELSE\n                     DO;\n                        CALL REPLACE(TABLE_PTR);\n                        ID_PTR = OWNER_STACK(CURRENT_LEVEL);\n                        IF FIRST_PARAM_TYPES THEN\n                           DO;\n                              FIRST_PARAM_TYPES = FALSE;\n                              LINK = ID_PTR;\n                              DO WHILE LINK \u00ac= NULL;\n                                 VALUE(LINK) = TABLE_PTR;\n                                 LINK = S_LIST(LINK);\n                              END;\n                           END;\n                        ELSE\n                           DO;\n                              LINK = PARSE_TREE(NODE#STACK(NP) + #MP);\n                              IF LINK \u00ac= NULL THEN\n                                 DO;\n                                    DO WHILE S_LIST(LINK) \u00ac= NULL;\n                                       LINK = S_LIST(LINK);\n                                    END;\n                                    S_LIST(LINK) = TABLE_PTR;\n                                 END;\n                           END;\n                        IF #MP = FATHERS_MULTIPLICITY THEN\n                           DO;\n                              IF IS_LEAF THEN\n                                 DO; /* FUNCTION-TYPE PARAMETERS */\n                                    IF LINK \u00ac= NULL THEN S_LIST(LINK) = NULL;\n                                    LINK = ID_PTR;\n                                    DO WHILE LINK \u00ac= NULL;\n                                       DATATYPE(LINK) = TABLE_PTR;\n                                       STRUCTYPE(LINK) = STRUCTYPE(TABLE_PTR);\n                                       LINK = S_LIST(LINK);\n                                    END;\n                                    IF VAR_TYPE(TABLE_PTR) \u00ac= TYPE THEN\n                                       CALL ERROR(IDENTITY(TABLE_PTR)\n                                                  || ' IS NOT A TYPE', 1);\n                                 END;\n                              CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);\n                              CURRENT_LEVEL = CURRENT_LEVEL - 1;\n                              TABLE_PTR = ID_PTR;\n                           END;\n                     END;\n               /* 28  <CASE INSTANCE> ::= (<CONSTANT>)+ <STATEMENT> */\n                  IF #MP < FATHERS_MULTIPLICITY THEN\n                     DO;\n                        IF #MP = 1 THEN\n                           DO;\n                              CALL EMIT_TRIPLE(CASE_TARGET, NULL, NULL, 0);\n                              CASE_PTR = N_TRIPLES - 3;\n                              CALL EMIT_ADD_DECIMAL;\n                           END;\n                        #OP = #OP - 1;\n                        ID_PTR = TRIPLES(OPERAND#STK(#OP) + 2);\n                        IF \u00acCOMPTYPES(#TP, DATATYPE(ID_PTR)) THEN\n                           CALL ERROR(\n                             'LABEL TYPE INCOMPATIBLE WITH SELECTING EXPRESSION'\n                              , 1);\n                        IF (TABLE_PTR & \"C000\") = MASK_IMMEDIATE THEN\n                           CASE_LABEL_VALUE = TABLE_PTR & \"3FFF\";\n                        ELSE CASE_LABEL_VALUE = VALUE(TABLE_PTR);\n                        I = OPERAND#STK(#OP) + 3*(CASE_LABEL_VALUE +\n                           STORAGE_LNGTH(ID_PTR) - VALUE(ID_PTR));\n                        /* I POINTS TO THE \"BCH\" TRIPLE IN THE JUMP TABLE\n                           WHICH CORRESPONDS TO CASE_LABEL_VALUE   */\n                        IF TRIPLES(I + 1) = NULL THEN CALL FIXUP(I, CASE_PTR);\n                        ELSE CALL ERROR('MULTIDEFINED CASE LABEL', 1);\n                     END;\n               /* 29  <EXPRESSION> ::= <EXPRESSION> */\n                                  /* UNARY '+' OPERATOR */\n                  ;\n               /* 30  <EXPRESSION> ::= <EXPRESSION> */\n                                  /* UNARY '-' OPERATOR */\n                  DO;\n                     CALL REPLACE(#TP);\n                     IF STRUCTYPE(#TP) = SUBRANGE THEN\n                        DO;\n                           CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);\n                           #TP = DATATYPE(#TP);\n                        END;\n                     IF COMPTYPES(#TP, INTPTR) THEN\n                        DO;\n                           TABLE_PTR = OPERAND#STK(#OP);\n                           IF (TABLE_PTR & \"C000\") = MASK_IMMEDIATE THEN\n                              OPERAND#STK(#OP) = FINDCONST(-(TABLE_PTR&\"3FFF\"));\n                           ELSE IF ((TABLE_PTR & \"C000\") = MASK_SYMBOL)\n                                   & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN\n                              OPERAND#STK(#OP) = FINDCONST(-VALUE(TABLE_PTR));\n                           ELSE\n                              DO;\n                                 CALL EMIT_TRIPLE(NEGATE, TABLE_PTR, NULL, 3);\n                                 OPERAND#STK(#OP) =\n                                    (N_TRIPLES - 3) | MASK_TRIPLE;\n                              END;\n                        END;\n                     ELSE IF COMPTYPES(#TP, REALPTR) THEN\n                        DO;\n                           TABLE_PTR = OPERAND#STK(#OP);\n                           IF ((TABLE_PTR & \"C000\") = MASK_SYMBOL)\n                              & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN\n                              DO;\n                                 I = VALUE(TABLE_PTR);\n                                 IF I > 0 THEN\n                                    OPERAND#STK(#OP) = FINDREAL(I | \"80000000\");\n                                 ELSE OPERAND#STK(#OP) =\n                                    FINDREAL(I & \"7FFFFFFF\");\n                              END;\n                           ELSE\n                              DO;\n                                 CALL EMIT_TRIPLE(NEGATEFLT, OPERAND#STK(#OP),\n                                    NULL, 3);\n                                 OPERAND#STK(#OP) =\n                                    (N_TRIPLES - 3) | MASK_TRIPLE;\n                              END;\n                        END;\n                     ELSE CALL ERROR('ILLEGAL UNARY \"-\" OPERATOR', 1);\n                  END;\n               /* 31  <EXPRESSION> ::= <EXPRESSION> */\n                                  /* UNARY 'NOT' OPERATOR */\n                  DO;\n                     IF \u00acCOMPTYPES(#TP, BOOLPTR) THEN\n                        DO;\n                           CALL ERROR(BOOLTYPE, 1);\n                           #TP = BOOLPTR;\n                        END;\n                     IF IS_NEGATION(OPERAND#STK(#OP)) THEN\n                        DO;\n                           OPERAND#STK(#OP) = TRIPLES(N_TRIPLES - 2);\n                           N_TRIPLES = N_TRIPLES - 3;\n                           IC = IC - 1;\n                        END;\n                     ELSE IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                        DO;\n                           IF LISTHEAD \u00ac= NULL THEN\n                              DO; /* REVERSE THE PARITY OF LISTHEAD */\n                                 IF (LISTHEAD & \"8000\") \u00ac= 0 THEN\n                                    LISTHEAD = LISTHEAD & \"7FFF\";\n                                 ELSE LISTHEAD = LISTHEAD | \"8000\";\n                              END;\n                           ELSE\n                              DO;\n                                 CALL EMIT_CONDITIONAL_BRANCH(FX);\n                                 LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);\n                                 OPERAND#STK(#OP) =\n                                    (N_TRIPLES - 3) | MASK_TRIPLE;\n                              END;\n                        END;\n                     ELSE\n                        DO;\n                           CALL EMIT_TRIPLE(NOT, OPERAND#STK(#OP), NULL, 3);\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                        END;\n                     FX = \u00acFX;\n                  END;\n               /* 32  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '=' OPERATOR */\n                  CALL EMIT_COMPARE(EQUAL_TO);\n               /* 33  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '<' OPERATOR */\n                  CALL EMIT_COMPARE(LESS_THAN);\n               /* 34  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '>' OPERATOR */\n                  CALL EMIT_COMPARE(GREATER_THAN);\n               /* 35  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '<>' OPERATOR */\n                  CALL EMIT_COMPARE(NOT_EQUAL_TO);\n               /* 36  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '<=' OPERATOR */\n                  CALL EMIT_COMPARE(LESS_EQ);\n               /* 37  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '>=' OPERATOR */\n                  CALL EMIT_COMPARE(GREATER_EQ);\n               /* 38  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY 'IN' OPERATOR */\n                  IF #MP = 1 THEN\n                     DO;\n                        CALL REPLACE(#TP);\n                        IF STRUCTYPE(#TP) = SUBRANGE THEN\n                           CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);\n                        ELSE IF (STRUCTYPE(#TP) \u00ac= SCALAR)\n                                & \u00acCOMPTYPES(#TP, INTPTR) THEN\n                           DO;\n                              CALL ERROR(\n                'FIRST OPERAND OF \"IN\" MUST BE SCALAR, SUBRANGE OR INTEGER', 1);\n                              #TP = BOOLPTR;\n                              #POS_STACK(NP) = 2;\n                           END;\n                     END;\n                  ELSE /* #MP = 2 */ IF #TP = EMPTYSETPTR THEN\n                     DO;\n                        IF (OPERAND#STK(#OP - 1) & MASK_TRIPLE) \u00ac= 0 THEN\n                           CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP - 1), NULL,0);\n                        OPERAND#STK(#OP - 1) = FALSE | MASK_IMMEDIATE;\n                        #OP = #OP - 1;\n                        #TP = BOOLPTR;\n                     END;\n                  ELSE\n                     DO;\n                        ID_PTR = OPERAND#STK(#OP - 1);\n                        TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                        /* ID_PTR IS LEFT OPERAND, TABLE_PTR IS ITS DATATYPE */\n                        IF \u00acCOMPTYPES(TABLE_PTR, DATATYPE(#TP)) THEN\n                           CALL ERROR(\n                       'FIRST OPERAND OF \"IN\" NOT COMPATIBLE WITH SET TYPE', 1);\n                        MIN = SHL(VALUE(#TP), 3);\n                        MAX = SHL(VALUE(#TP) + STORAGE_LNGTH(#TP), 3) - 1;\n                        IF STRUCTYPE(TABLE_PTR) = SCALAR THEN\n                           DO;\n                              MUST_CHECK_LOWBOUND = (MIN > 0);\n                              MUST_CHECK_HIGHBOUND =\n                                 (MAX < STORAGE_LNGTH(TABLE_PTR) - 1);\n                           END;\n                        ELSE MUST_CHECK_LOWBOUND, MUST_CHECK_HIGHBOUND = TRUE;\n                        IF (ID_PTR & MASK_TRIPLE) \u00ac= 0 THEN\n                           J = ID_PTR | MASK_TEMP;\n                        ELSE J = ID_PTR;\n                        IF FX THEN\n                           DO;\n                              LINK = LISTHEAD;\n                              LISTHEAD = NULL;\n                           END;\n                        IF MUST_CHECK_LOWBOUND THEN\n                           CALL EMIT_BOUND_CHECK(J, MIN, GREATER_EQ);\n                        IF MUST_CHECK_HIGHBOUND THEN\n                           CALL EMIT_BOUND_CHECK(J, MAX, LESS_EQ);\n                        IF VALUE(#TP) \u00ac= 0 THEN\n                           DO;\n                              CALL EMIT_TRIPLE(SUBTRACT, ID_PTR,\n                                 FINDCONST(MIN), 3);\n                              ID_PTR = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           END;\n                        CALL EMIT_TRIPLE(IN, ID_PTR, OPERAND#STK(#OP), 0);\n                        #TP = BOOLPTR;\n                        #OP = #OP - 1;\n                        OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;\n                        IF FX THEN\n                           DO;\n                              CALL EMIT_TRIPLE(BNZ, LINK,\n                                 (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                              IF LISTHEAD \u00ac= NULL THEN\n                                 DO;\n                                    CALL FIXUP(LISTHEAD, N_TRIPLES);\n                                    CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);\n                                 END;\n                              LISTHEAD = OPERAND#STK(#OP);\n                           END;\n                        ELSE\n                           DO;\n                              CALL EMIT_TRIPLE(BZ, LISTHEAD,\n                                 (N_TRIPLES - 3) | MASK_TRIPLE, 0);\n                              LISTHEAD = N_TRIPLES - 3;\n                           END;\n                     END;\n               /* 39  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '+' OPERATOR */\n                  DO;\n                     CALL REPLACE(#TP);\n                     IF #MP = 2 THEN\n                        DO;\n                           CALL COERCE_OP;\n                           #TP = PARSE_TREE(NODE#STACK(NP) + 2);\n                           IF COMPTYPES(#TP, INTPTR) THEN\n                              CALL EMIT_TRIPLE(ADD,OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           ELSE IF COMPTYPES(#TP, REALPTR) THEN\n                              CALL EMIT_TRIPLE(ADDFLT, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           ELSE IF (STRUCTYPE(#TP) = SET) |\n                                   (STRUCTYPE(#TP) = PACKED_SET) THEN\n                              DO;\n                                 IF OPERAND#STK(#OP) = EMPTYSETPTR THEN\n                                    /* DO NOTHING */ ;\n                                 ELSE IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN\n                                    OPERAND#STK(#OP - 1) = OPERAND#STK(#OP);\n                                 ELSE\n                                    DO;\n                                       CALL EMIT_TRIPLE(TEMP,\n                                          OPERAND#STK(#OP - 1), 0,\n                                          STORAGE_LNGTH(#TP) - 1);\n                                       OPERAND#STK(#OP - 1) =\n                                          (N_TRIPLES - 3) | MASK_TRIPLE;\n                                       CALL EMIT_TRIPLE(OR,\n                                          (N_TRIPLES - 3) | MASK_TEMP,\n                                          OPERAND#STK(#OP), 0);\n                                    END;\n                              END;\n                           ELSE CALL ERROR('ILLEGAL \"+\" OPERATOR', 1);\n                           #OP = #OP - 1;\n                           IF (STRUCTYPE(#TP) \u00ac= SET)\n                              & (STRUCTYPE(#TP) \u00ac= PACKED_SET) THEN\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                        END;\n                  END;\n               /* 40  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '-' OPERATOR */\n                  DO;\n                     CALL REPLACE(#TP);\n                     IF #MP = 2 THEN\n                        DO;\n                           CALL COERCE_OP;\n                           #TP = PARSE_TREE(NODE#STACK(NP) + 2);\n                           IF COMPTYPES(#TP, INTPTR) THEN\n                              CALL EMIT_TRIPLE(SUBTRACT, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           ELSE IF COMPTYPES(#TP, REALPTR) THEN\n                              CALL EMIT_TRIPLE(SUBFLT, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           ELSE IF (STRUCTYPE(#TP) = SET) |\n                                   (STRUCTYPE(#TP) = PACKED_SET) THEN\n                              DO;\n                                 IF (OPERAND#STK(#OP) \u00ac= EMPTYSETPTR)\n                                    & (OPERAND#STK(#OP - 1) \u00ac= EMPTYSETPTR) THEN\n                                    DO;\n                                       J = OPERAND#STK(#OP - 1);\n                                       IF (J & MASK_TRIPLE) \u00ac= 0 THEN\n                                          J = J | MASK_TEMP;\n                                       CALL EMIT_TRIPLE(TEMP, J, 0,\n                                          STORAGE_LNGTH(#TP) - 1);\n                                       CALL EMIT_TRIPLE(XOR,\n                                          (N_TRIPLES - 3) | MASK_TEMP,\n                                          OPERAND#STK(#OP), 0);\n                                       CALL EMIT_TRIPLE(AND,\n                                          (N_TRIPLES - 6) | MASK_TEMP,\n                                          OPERAND#STK(#OP - 1), 0);\n                                       OPERAND#STK(#OP - 1) =\n                                          (N_TRIPLES - 9) | MASK_TRIPLE;\n                                    END;\n                              END;\n                           #OP = #OP - 1;\n                           IF (STRUCTYPE(#TP) \u00ac= SET)\n                              & (STRUCTYPE(#TP) \u00ac= PACKED_SET) THEN\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                        END;\n                  END;\n               /* 41  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY 'OR' OPERATOR */\n               ANDOR:\n                  IF #MP = 1 THEN\n                     DO;\n                        IF \u00acCOMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE,1);\n                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                           FIX_LIST(NP) = LISTHEAD;\n                        ELSE\n                           DO;\n                              CALL EMIT_CONDITIONAL_BRANCH(FATHERS_PROD_NO=41);\n                              FIX_LIST(NP) =\n                                 SHL(FATHERS_PROD_NO=41, 15) | (N_TRIPLES - 3);\n                           END;\n                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1)+1);\n                        LISTHEAD = NULL;\n                        #OP = #OP - 1;\n                     END;\n                  ELSE\n                     DO;\n                        IF \u00acCOMPTYPES(#TP, BOOLPTR) THEN\n                           DO;\n                              CALL ERROR(BOOLTYPE, 1);\n                              #TP = BOOLPTR;\n                           END;\n                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1)+1);\n                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                           DO; /* FIX UP RIGHT OPERAND LIST */\n                              IF LISTHEAD \u00ac= NULL THEN\n                                 IF (LISTHEAD & \"8000\") \u00ac= (SHL(FX,15) & \"8000\")\n                                 THEN\n                                    DO;\n                                       CALL EMIT_TRIPLE(BCH_TARGET, NULL,\n                                                        NULL, 1);\n                                       CALL FIXUP(LISTHEAD, N_TRIPLES - 3);\n                                       LISTHEAD = NULL;\n                                    END;\n                           END;\n                        ELSE\n                           DO;\n                              CALL EMIT_CONDITIONAL_BRANCH(FX);\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                              LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);\n                           END;\n                        /* CHECK LEFT OPERAND LIST FOR FIXUP */\n                        I = FIX_LIST(NP);\n                        IF I \u00ac= NULL THEN\n                           DO;\n                              IF (I & \"8000\") \u00ac= (SHL(FX,15) & \"8000\") THEN\n                                 DO;\n                                    CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);\n                                    CALL FIXUP(I, N_TRIPLES - 3);\n                                 END;\n                              ELSE IF LISTHEAD = NULL THEN LISTHEAD = I;\n                              ELSE\n                                 DO; /* LINK LEFT AND RIGHT FIXUP LISTS */\n                                    I = I & \"3FFF\";\n                                    DO WHILE TRIPLES(I + 1) \u00ac= NULL;\n                                       I = TRIPLES(I + 1) & \"3FFF\";\n                                    END;\n                                    TRIPLES(I + 1) = LISTHEAD;\n                                    LISTHEAD = FIX_LIST(NP);\n                                 END;\n                           END;\n                     END;\n               /* 42  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '*' OPERATOR */\n                  DO;\n                     CALL REPLACE(#TP);\n                     IF #MP = 2 THEN\n                        DO;\n                           CALL COERCE_OP;\n                              #TP = PARSE_TREE(NODE#STACK(NP) + 2);\n                           IF COMPTYPES(#TP, INTPTR) THEN\n                              CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           ELSE IF COMPTYPES(#TP, REALPTR) THEN\n                              CALL EMIT_TRIPLE(MPYFLT, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           ELSE IF (STRUCTYPE(#TP) = SET) |\n                                   (STRUCTYPE(#TP) = PACKED_SET) THEN\n                              DO;\n                                 IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN\n                                    /* DO NOTHING */ ;\n                                 ELSE IF OPERAND#STK(#OP) = EMPTYSETPTR THEN\n                                    DO;\n                                       IF (OPERAND#STK(#OP - 1) & MASK_TRIPLE)\n                                          \u00ac= 0 THEN\n                                          CALL EMIT_TRIPLE(TPOP,\n                                             OPERAND#STK(#OP - 1), NULL, 0);\n                                       OPERAND#STK(#OP - 1) = EMPTYSETPTR;\n                                    END;\n                                 ELSE\n                                    DO;\n                                       CALL EMIT_TRIPLE(TEMP,\n                                          OPERAND#STK(#OP - 1), 0,\n                                          STORAGE_LNGTH(#TP) - 1);\n                                       OPERAND#STK(#OP - 1) =\n                                          (N_TRIPLES - 3) | MASK_TRIPLE;\n                                       CALL EMIT_TRIPLE(AND,\n                                          (N_TRIPLES - 3) | MASK_TEMP,\n                                          OPERAND#STK(#OP), 0);\n                                    END;\n                              END;\n                           ELSE CALL ERROR('ILLEGAL \"*\" OPERATOR', 1);\n                           #OP = #OP - 1;\n                           IF (STRUCTYPE(#TP) \u00ac= SET)\n                              & (STRUCTYPE(#TP) \u00ac= PACKED_SET) THEN\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                        END;\n                  END;\n               /* 43  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY '/' OPERATOR */\n                  DO;\n                     CALL REPLACE(#TP);\n                     CALL COERCE_ASSIGNMENT(REALPTR, #TP);\n                     IF #MP = 2 THEN\n                        DO;\n                           CALL EMIT_TRIPLE(DIVFLT, OPERAND#STK(#OP - 1),\n                                            OPERAND#STK(#OP), 3);\n                           #OP = #OP - 1;\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           #TP = REALPTR;\n                        END;\n                  END;\n               /* 44  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY 'DIV' OPERATOR */\n                  DO;\n                     CALL REPLACE(#TP);\n                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);\n                     IF #MP = 2 THEN\n                        DO;\n                           CALL EMIT_TRIPLE(DIVIDE, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           #OP = #OP - 1;\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           #TP = INTPTR;\n                        END;\n                  END;\n               /* 45  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY 'MOD' OPERATOR */\n                  DO;\n                     CALL REPLACE(#TP);\n                     CALL COERCE_ASSIGNMENT(INTPTR, #TP);\n                     IF #MP = 2 THEN\n                        DO;\n                           CALL EMIT_TRIPLE(REM, OPERAND#STK(#OP - 1),\n                                               OPERAND#STK(#OP), 3);\n                           #OP = #OP - 1;\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           #TP = INTPTR;\n                        END;\n                  END;\n               /* 46  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* BINARY 'AND' OPERATOR */\n                  GOTO ANDOR;\n               /* 47  <EXPRESSION> ::= <IDENTIFIER> (<EXPRESSION>)* */\n                                  /* FUNCTION PROCEDURE */\n                  DO;\n                     IF \u00ac((FATHERS_MULTIPLICITY = 1) & PARAMLIST) THEN\n                        CALL PROCFUNC(FALSE);\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1) + 1);\n                  END;\n               /* 48  <EXPRESSION> ::= (<ELEMENT>)+ */\n                                  /* SET EXPRESSION */\n               SET_ELEMENT:\n                  DO;\n                     CALL REPLACE(#TP);\n                     IF #TP = BOOLPTR THEN\n                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                           CALL COND_TO_REGISTER;\n                     TABLE_PTR = OPERAND#STK(#OP);\n                     ID_PTR = FIX_LIST(NP);\n                     ERROR_FLAG = FALSE;\n                     I = PARSE_TREE(NODE + 1);\n                     J = FATHERS_PROD_NO;\n                     IF #MP = 1 THEN\n                        IF ((J = 76) & (#POS_STACK(NP-1) = 1)) | (I = 75) THEN\n                        DO;   /* FORM AN INITIAL TYPING OF THE SET */\n                           DATATYPE(ID_PTR) = DATATYPE(#TP);\n                           IF COMPTYPES(DATATYPE(#TP), REALPTR) THEN\n                              DO;\n                                 CALL ERROR('SET ELEMENT OF TYPE REAL', 1);\n                                 ERROR_FLAG = TRUE;\n                              END;\n                           IF (TABLE_PTR & \"C000\") = MASK_IMMEDIATE THEN\n                              DO;\n                                 STORAGE_LNGTH(ID_PTR) = 1;\n                                 VALUE(ID_PTR) = SHR(TABLE_PTR & \"3FFF\", 3);\n                              END;\n                           ELSE IF ((TABLE_PTR & \"C000\") = MASK_SYMBOL)\n                                 & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN\n                              DO;\n                                 STORAGE_LNGTH(ID_PTR) = 1;\n                                 I = VALUE(TABLE_PTR) / 8;\n                                 VALUE(ID_PTR) = I;\n                              END;\n                           ELSE IF STRUCTYPE(#TP) = SCALAR THEN\n                              DO;\n                                 STORAGE_LNGTH(ID_PTR) =\n                                    SHR(STORAGE_LNGTH(DATATYPE(#TP)), 3) + 1;\n                                 VALUE(ID_PTR) = 0;\n                              END;\n                           ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN\n                              DO;\n                                 STORAGE_LNGTH(ID_PTR) =\n                                    SHR(STORAGE_LNGTH(#TP), 3) + 1;\n                                 I = VALUE(S_LIST(#TP)) / 8;\n                                 VALUE(ID_PTR) = I;\n                              END;\n                           ELSE\n                              DO;\n                                 CALL ERROR(\n                           'UNABLE TO DETERMINE DATATYPE OF SET EXPRESSION', 1);\n                                 ERROR_FLAG = TRUE;\n                              END;\n                        END;\n                     IF (SHL(1, STRUCTYPE(#TP)) & \"(1)10000 00000 00110\") = 0\n                        /* \u00ac(STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, ARITHMETIC.))\n                        */ THEN\n                        DO;\n                           CALL ERROR('ILLEGAL SET ELEMENT', 1);\n                           ERROR_FLAG = TRUE;\n                        END;\n                     IF \u00acERROR_FLAG THEN\n                        IF \u00acCOMPTYPES(DATATYPE(ID_PTR), DATATYPE(#TP)) THEN\n                           DO;\n                              CALL ERROR('INCOMPATIBLE SET ELEMENTS', 1);\n                              ERROR_FLAG = TRUE;\n                           END;\n                     /* UPDATE SET TYPE ESTIMATE */\n                     MIN = SHL(VALUE(ID_PTR), 3);\n                     MAX = MIN + SHL(STORAGE_LNGTH(ID_PTR), 3) - 1;\n                     IF (TABLE_PTR & \"C000\") = MASK_IMMEDIATE THEN\n                        DO;\n                           J = TABLE_PTR & \"3FFF\";\n                           IF J < MIN THEN MIN = J & \"FFF8\";\n                           IF J > MAX THEN MAX = (J & \"FFF8\") + 7;\n                        END;\n                     ELSE IF ((TABLE_PTR & \"C000\") = MASK_SYMBOL) &\n                              (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN\n                        DO;\n                           J = VALUE(TABLE_PTR);\n                           IF J < MIN THEN MIN = J & \"FFFFFFF8\";\n                           IF J > MAX THEN MAX = (J & \"FFFFFFF8\") + 7;\n                        END;\n                     ELSE IF STRUCTYPE(#TP) = SCALAR THEN\n                        DO;\n                           MIN = 0;\n                           MAX = (STORAGE_LNGTH(DATATYPE(#TP))&\"FFFFFFF8\") + 7;\n                        END;\n                     ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN\n                        DO;\n                           J = VALUE(S_LIST(#TP));\n                           IF J < MIN THEN MIN = J & \"FFFFFFF8\";\n                           IF VALUE(#TP) > MAX THEN\n                              MAX = (VALUE(#TP) & \"FFFFFFF8\") + 7;\n                        END;\n                     ELSE IF \u00acERROR_FLAG THEN\n                        DO;\n                           CALL ERROR(\n                           'UNABLE TO DETERMINE DATATYPE OF SET EXPRESSION', 1);\n                           ERROR_FLAG = TRUE;\n                        END;\n                     I = MIN / 8;\n                     VALUE(ID_PTR) = I;\n                     STORAGE_LNGTH(ID_PTR) = SHR(MAX - MIN, 3) + 1;\n                     IF STORAGE_LNGTH(ID_PTR) > 256 THEN\n                        DO;\n                           CALL ERROR(SUBRANGE_SIZE, 1);\n                           ERROR_FLAG = TRUE;\n                        END;\n                     IF PARSE_TREE(NODE + 1) = 76 THEN\n                        DO;\n                           CALL REPLACE(NODE);\n                           IF #OP < #OPMAX THEN #OP = #OP + 1;\n                           ELSE\n                              DO;\n                                 CALL ERROR(OP#STACK#ERR, 1);\n                                 RETURN;\n                              END;\n                           OPERAND#STK(#OP) = NULL;\n                        END;\n                     IF ERROR_FLAG THEN\n                        DO;\n                           IF FATHERS_PROD_NO = 76 THEN\n                              DO;\n                                 CALL FATHER;\n                                 #MP = #POS_STACK(NP);\n                              END;\n                           DO I = 1 TO #MP;\n                              IF OPERAND#STK(#OP) = NULL THEN #OP = #OP - 3;\n                              ELSE #OP = #OP - 1;\n                           END;\n                           #OP = #OP + 1;\n                           #TP, OPERAND#STK(#OP) = EMPTYSETPTR;\n                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;\n                        END;\n                     ELSE IF #MP = FATHERS_MULTIPLICITY THEN\n                        DO;\n                           CALL EMIT_TRIPLE(TEMP, NULL, 0,\n                                            STORAGE_LNGTH(ID_PTR) - 1);\n                           FIX_LIST(NP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           J = FIX_LIST(NP) | MASK_TEMP;\n                           CALL EMIT_TRIPLE(XOR, J, J, 0);\n                           DO I = 1 TO #MP;\n                              IF OPERAND#STK(#OP) = NULL THEN\n                                 DO; /* A RANGE-TYPE SET ELEMENT */\n                                    #OP = #OP - 1;\n                                    J = PARSE_TREE(NODE#STACK(NP)+#MP-I+2);\n                                    /* J POINTS TO 76-NODE */\n                                    CALL COERCE_SET_ELEMENT(PARSE_TREE(J+3),\n                                       MIN);\n                                    #OP = #OP - 1;\n                                    CALL COERCE_SET_ELEMENT(PARSE_TREE(J+2),\n                                       MIN);\n                                    CALL EMIT_TRIPLE(RANGE, OPERAND#STK(#OP),\n                                       OPERAND#STK(#OP + 1),\n                                       STORAGE_LNGTH(ID_PTR) - 1);\n                                    OPERAND#STK(#OP) =\n                                       (N_TRIPLES - 3) | MASK_TRIPLE;\n                                 END;\n                              ELSE\n                                 CALL COERCE_SET_ELEMENT(\n                                    PARSE_TREE(NODE#STACK(NP)+#MP-I+2), MIN);\n                              J = FIX_LIST(NP) | MASK_TEMP;\n                              CALL EMIT_TRIPLE(INTO, OPERAND#STK(#OP), J, 0);\n                              IF I < #MP THEN #OP = #OP - 1;\n                              ELSE OPERAND#STK(#OP) = FIX_LIST(NP);\n                           END;\n                           #TP = ID_PTR;\n                        END;\n                  END;\n               /* 49  <EXPRESSION> ::= <VARIABLE> */\n                  CALL REPLACE(#TP);\n               /* 50  <EXPRESSION> ::= <UNSIGNED CONSTANT> */\n                  DO;\n                     PARAMLIST = FALSE;\n                     IF VAR_TYPE(TABLE_PTR) = LITERAL THEN\n                        DO;   /* A STRING CONSTANT */\n                           #TP = TABLE_PTR;\n                           CALL REPLACE(#TP);\n                        END;\n                     ELSE IF (#TP = INTPTR) | (#TP = CHARPTR) THEN\n                        OPERAND#STK(#OP) = FINDCONST(VALUE(TABLE_PTR));\n                  END;\n               /* 51  <VARIABLE> ::= <ID> (<QUALIFIER>)* */\n                  IF #MP = 1 THEN\n                     DO;\n                        I = VAR_TYPE(TABLE_PTR);\n                        IF I = VAR_PARAM THEN\n                           DO;\n                              IF \u00acPARAMLIST THEN\n                                 DO;\n                                    IF (STRUCTYPE(TABLE_PTR) = SCALAR) |\n                                       (STRUCTYPE(TABLE_PTR) = SUBRANGE) THEN\n                                       I = 1;\n                                    ELSE I = STORAGE_LNGTH(DATATYPE(TABLE_PTR))\n                                             - 1;\n                                    CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,\n                                                     OPERAND#STK(#OP), I);\n                                    OPERAND#STK(#OP) =\n                                       (N_TRIPLES - 3) | MASK_TRIPLE;\n                                    I = I + 1;\n                                    IF I > 256 THEN\n                                       IF FATHERS_MULTIPLICITY = 1 THEN\n                                          CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),\n                                             I, 0);\n                                 END;\n                           END;\n                        ELSE IF (I = FIELD_ID) | (I = VARIANT) THEN\n                           DO;\n                              ID_PTR = OWNER(TABLE_PTR);\n                              DO WHILE VAR_TYPE(S_LIST(ID_PTR)) = VARIANT;\n                                 ID_PTR = OWNER(ID_PTR);\n                              END;\n                              I = WITH_PTR;\n                              DO WHILE (I \u00ac= NULL)&(WITH_DATATYPE(I) \u00ac= ID_PTR);\n                                 I = I - 1;\n                              END;\n                              IF I \u00ac= NULL THEN\n                                 DO;\n                                    CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,\n                                       WITH_VARIABLE(I), 0);\n                                    I = STORAGE_LNGTH(TABLE_PTR);\n                                    OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;\n                                    CALL EMIT_TRIPLE(INDEX,\n                                       (N_TRIPLES - 3) | MASK_TRIPLE,\n                                       FINDCONST(DISPLACEMENT(TABLE_PTR)), I-1);\n                                    IF I > 256 THEN\n                                       IF FATHERS_MULTIPLICITY = 1 THEN\n                                          CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),\n                                             I, 0);\n                                 END;\n                              ELSE CALL ERROR('FIELD IDENTIFIER '\n                                 || IDENTITY(TABLE_PTR)\n                                 || ' MUST BE PRECEDED BY A RECORD NAME', 1);\n                           END;\n                        ELSE IF (I = PROC) | (I = MULTDECL) |\n                                (I = PROC_PARAM) THEN\n                           DO;\n                              IF LHS THEN\n                                 DO;\n                                    IF (DATATYPE(TABLE_PTR) = NULL) |\n                                       (TABLE_PTR \u00ac= OWNER_STACK(CURRENT_LEVEL))\n                                    THEN CALL ERROR (\n                                     'ILLEGAL ASSIGNMENT TO PROCEDURE/FUNCTION '\n                                       || IDENTITY(TABLE_PTR), 1);\n                                 END;\n                              ELSE IF \u00acPARAMLIST THEN\n                                 CALL PROCFUNC(FALSE);\n                           END;\n                        ELSE IF I = CONSTANT THEN\n                           DO;\n                              IF LHS THEN CALL ERROR('CONSTANT IDENTIFIER '\n                                 || IDENTITY(TABLE_PTR)\n                                 || ' MAY NOT BE ASSIGNED TO', 1);\n                              ELSE IF \u00acCOMPTYPES(#TP, REALPTR) THEN\n                                 OPERAND#STK(#OP) = FINDCONST(VALUE(TABLE_PTR));\n                           END;\n                        ELSE IF I \u00ac= VARIABLE THEN\n                           CALL ERROR('ILLEGAL VARIABLE: '\n                              || IDENTITY(TABLE_PTR), 1);\n                        LHS, PARAMLIST = FALSE;\n                     END;  /* #MP = 1 */\n                  ELSE\n                     CALL REPLACE(#TP);\n               /* 52  (NOT USED) */\n                  ;\n               /* 53  <QUALIFIER> ::= (<EXPRESSION>)+ */\n                                  /* SUBSCRIPT LIST */\n                  DO;\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        FX = PARSE_TREE(NODE#STACK(NP-1)+#POS_STACK(NP-1) + 1);\n                     IF #MP = 1 THEN ID_PTR =\n                        PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));\n                     ELSE ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);\n                     IF STRUCTYPE(ID_PTR) \u00ac= ARRAY THEN\n                        CALL ERROR('ILLEGAL SUBSCRIPT', 1);\n                     ELSE\n                        DO;\n                           IF #TP = BOOLPTR THEN\n                              IF IS_CONDITION(OPERAND#STK(#OP)) THEN\n                                 CALL COND_TO_REGISTER;\n                           CALL COERCE_ASSIGNMENT(S_LIST(ID_PTR), #TP);\n                           I = STORAGE_LNGTH(ID_PTR)\n                               / STORAGE_LNGTH(S_LIST(ID_PTR));\n                           /* I IS ARRAY ELEMENT SIZE */\n                           IF (OPERAND#STK(#OP) & \"C000\") = MASK_IMMEDIATE THEN\n                              OPERAND#STK(#OP) =\n                                 FINDCONST(I*(OPERAND#STK(#OP) & \"3FFF\"));\n                           ELSE IF ((OPERAND#STK(#OP) & \"C000\") = MASK_SYMBOL) &\n                                (VAR_TYPE(OPERAND#STK(#OP)) = CONSTANT) THEN\n                              OPERAND#STK(#OP) =\n                                 FINDCONST(VALUE(OPERAND#STK(#OP))*I);\n                           ELSE IF I \u00ac= 1 THEN\n                              DO;\n                                 CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP),\n                                    FINDCONST(I), 3);\n                                 OPERAND#STK(#OP) =\n                                    (N_TRIPLES - 3) | MASK_TRIPLE;\n                              END;\n                           CALL EMIT_TRIPLE(INDEX, OPERAND#STK(#OP - 1),\n                              OPERAND#STK(#OP), I - 1);\n                           #OP = #OP - 1;\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           IF I > 256 THEN\n                              IF (#MP = FATHERS_MULTIPLICITY) &\n                                 (#POS_STACK(NP - 1) =\n                                    MULTIPLICITY(NODE#STACK(NP - 1))) THEN\n                                 CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);\n                           #TP = DATATYPE(ID_PTR);\n                           CALL REPLACE(#TP);\n                        END;\n                  END;\n               /* 54  <QUALIFIER> ::= <EMPTY> */\n                                  /* ARROW (@) */\n                  DO;\n                     #TP = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));\n                     IF (STRUCTYPE(#TP) = FILE) | (STRUCTYPE(#TP) = PACKED_FILE)\n                        THEN #TP = DATATYPE(#TP);\n                     ELSE IF STRUCTYPE(#TP) = POINTER THEN\n                        DO;\n                           ID_PTR = DATATYPE(#TP);\n                           IF (STRUCTYPE(ID_PTR) = SCALAR) |\n                              (STRUCTYPE(ID_PTR) = SUBRANGE) THEN\n                                 I = 1;\n                           ELSE I = STORAGE_LNGTH(ID_PTR) - 1;\n                           CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,\n                              OPERAND#STK(#OP), I);\n                           OPERAND#STK(#OP) = (N_TRIPLES - 3) | MASK_TRIPLE;\n                           I = I + 1;\n                           IF I > 256 THEN\n                              IF #POS_STACK(NP - 1) =\n                                    MULTIPLICITY(NODE#STACK(NP - 1)) THEN\n                                CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);\n                           #TP = DATATYPE(#TP);\n                        END;\n                     ELSE CALL ERROR(\n                        'TYPE OF VARIABLE MUST BE FILE OR POINTER', 1);\n                  END;\n               /* 55  <QUALIFIER> ::= <ID> */\n                                  /* FIELD IDENTIFIER */\n                  IF (VAR_TYPE(TABLE_PTR) = FIELD_ID) |\n                     (VAR_TYPE(TABLE_PTR) = VARIANT) THEN\n                     DO;\n                        #TP =\n                           PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));\n                        #OP = #OP - 1;\n                        IF (STRUCTYPE(#TP) = RECORD) |\n                           (STRUCTYPE(#TP) = PACKED_RECORD) THEN\n                           DO;\n                              ID_PTR = OWNER(TABLE_PTR);\n                              DO WHILE VAR_TYPE(S_LIST(ID_PTR)) = VARIANT;\n                                 ID_PTR = OWNER(ID_PTR);\n                              END;\n                              IF ID_PTR \u00ac= #TP THEN\n                                 CALL ERROR(IDENTITY(TABLE_PTR)\n                                    || ' IS NOT A FIELD IN THIS RECORD', 1);\n                              ELSE\n                                 DO;\n                                    CALL EMIT_TRIPLE(INDEX, OPERAND#STK(#OP),\n                                       FINDCONST(DISPLACEMENT(TABLE_PTR)),\n                                       STORAGE_LNGTH(TABLE_PTR) - 1);\n                                    OPERAND#STK(#OP) =\n                                       (N_TRIPLES - 3) | MASK_TRIPLE;\n                                    I = STORAGE_LNGTH(TABLE_PTR);\n                                    IF I > 256 THEN\n                                       IF #POS_STACK(NP - 1) =\n                                             MULTIPLICITY(NODE#STACK(NP - 1))\n                                       THEN\n                                          CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),\n                                             I, 0);\n                                    #TP = DATATYPE(TABLE_PTR);\n                                    CALL REPLACE(#TP);\n                                 END;\n                           END;\n                        ELSE CALL ERROR('TYPE OF VARIABLE IS NOT RECORD', 1);\n                     END;\n                  ELSE\n                     DO;\n                        CALL ERROR(IDENTITY(TABLE_PTR)\n                                   || ' IS NOT A FIELD IDENTIFIER', 1);\n                        #OP = #OP - 1;\n                     END;\n               /* 56  (NOT USED) */\n                  ;\n               /* 57  <CONSTANT> ::= <UNSIGNED CONSTANT> */\n                                  /* + CONSTANT */\n                  ;\n               /* 58  <CONSTANT> ::= <UNSIGNED CONSTANT> */\n                                  /* - CONSTANT */\n                  IF (VAR_TYPE(TABLE_PTR) = CONSTANT) &\n                     (STRUCTYPE(TABLE_PTR) = ARITHMETIC) THEN\n                     DO;\n                        I = VALUE(TABLE_PTR);\n                        IF COMPTYPES(DATATYPE(TABLE_PTR), REALPTR) THEN\n                           DO;\n                              IF I < 0 THEN I = I & \"7FFFFFFF\";\n                              ELSE I = I | \"80000000\";\n                              TABLE_PTR = FINDREAL(I);\n                           END;\n                        ELSE TABLE_PTR = FINDCONST(-I);\n                        IF IS_DECLARATION THEN\n                           CALL REPLACE(TABLE_PTR);\n                        ELSE\n                           DO;\n                              OPERAND#STK(#OP) = TABLE_PTR;\n                              CALL REPLACE(#TP);\n                           END;\n                     END;\n                  ELSE CALL ERROR('ILLEGAL CONSTANT: -'\n                                  || IDENTITY(TABLE_PTR), 1);\n               /* 59  <TYPE> ::= <IDENTIFIER> */\n                                  /* SIMPLE TYPE IDENTIFIER */\n                  ALLOCATE_NEW_ROW = TRUE;\n               /* 60  <TYPE> ::= (<ID>)+ */\n                                  /* SCALAR TYPE */\n                  DO;\n                     IF #MP = 1 THEN\n                        DO;\n                           IF ALLOCATE_NEW_ROW THEN\n                              DO;\n                                 ID_PTR = NEXT_FREE_ROW;\n                                 VAR_TYPE(ID_PTR) = TYPE;\n                                 OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                              END;\n                           ELSE\n                              DO;\n                                 ID_PTR = TP_ID_PTR;\n                                 ALLOCATE_NEW_ROW = TRUE;\n                              END;\n                           STRUCTYPE(ID_PTR) = SCALAR;\n                           DATATYPE(ID_PTR) = ID_PTR;\n                           S_LIST(ID_PTR) = TABLE_PTR;\n                           STORAGE_LNGTH(ID_PTR) = FATHERS_MULTIPLICITY;\n                        END;\n                     ELSE S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;\n                     VAR_TYPE(TABLE_PTR) = CONSTANT;\n                     STRUCTYPE(TABLE_PTR) = SCALAR;\n                     OWNER(TABLE_PTR) = OWNER(ID_PTR);\n                     VALUE(TABLE_PTR) = #MP - 1;\n                     TABLE_PTR, DATATYPE(TABLE_PTR) = ID_PTR;\n                  END;\n               /* 61  <TYPE> ::= <CONSTANT> <CONSTANT> */\n                                  /* SUBRANGE TYPE */\n               IF #MP = 1 THEN DO;\n                  IF ALLOCATE_NEW_ROW THEN\n                     ID_PTR = NEXT_FREE_ROW;\n                  ELSE DO;\n                     ID_PTR = TP_ID_PTR;\n                     ALLOCATE_NEW_ROW = TRUE;\n                     END;\n                  CALL REPLACE (ID_PTR);\n                  I, DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);\n                  IF (I \u00ac= INTPTR) THEN\n                     IF STRUCTYPE(I) \u00ac= SCALAR THEN CALL ERROR\n                        ('A SUBRANGE MUST BE OF A SCALAR TYPE OR OF INTEGERS',1)\n                        ;\n                  VAR_TYPE(ID_PTR) = TYPE;\n                  STRUCTYPE(ID_PTR) = SUBRANGE;\n                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                  S_LIST(ID_PTR) = TABLE_PTR;\n                  END;\n               ELSE DO;\n                  ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                  I = VALUE(S_LIST(ID_PTR));  /* GET VALUE(<CONSTANT1>) */\n                  IF DATATYPE(ID_PTR) \u00ac= DATATYPE(TABLE_PTR) THEN\n                     CALL ERROR('TYPES OF SUBRANGE BOUNDS DISAGREE', 1);\n                  ELSE IF I > VALUE(TABLE_PTR) THEN\n                     CALL ERROR('LOWER BOUND OF SUBRANGE EXCEEDS UPPER BOUND',\n                        1);\n                  VALUE(ID_PTR) = VALUE(TABLE_PTR);\n                  IF I < 0 THEN DO;\n                     IF I + 32767 > VALUE(TABLE_PTR) THEN\n                        SL = VALUE(TABLE_PTR) - I + 1;\n                     ELSE SL = NULL;\n                     END;\n                  ELSE DO;\n                     SL = VALUE(TABLE_PTR) - I + 1;\n                     IF SL > 32767 THEN SL = NULL;\n                     END;\n                  STORAGE_LNGTH(ID_PTR) = SL;\n                  TABLE_PTR = ID_PTR;\n                  END;\n               /* 62  <TYPE> ::= <ID> */\n                                  /* POINTER TYPE */\n                  DO;\n                     IF ALLOCATE_NEW_ROW THEN ID_PTR = NEXT_FREE_ROW;\n                     ELSE\n                        DO;\n                           ID_PTR = TP_ID_PTR;\n                           ALLOCATE_NEW_ROW = TRUE;\n                        END;\n                     DATATYPE(ID_PTR) = TABLE_PTR;\n                     VAR_TYPE(ID_PTR) = TYPE;\n                     STORAGE_LNGTH(ID_PTR) = 4;\n                     STRUCTYPE(ID_PTR) = POINTER;\n                     OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                     TABLE_PTR = ID_PTR;\n                  END;\n               /* 63  <TYPE> ::= (<TYPE>)+ <TYPE> */\n                                  /* ARRAY TYPE */\n            ARRAYTYP:\n                  IF #MP < FATHERS_MULTIPLICITY THEN DO;\n                     IF ALLOCATE_ARRAY_ENTRY THEN\n                        ID_PTR = NEXT_FREE_ROW;\n                     ELSE DO;\n                        ID_PTR = TP_ID_PTR;\n                        ALLOCATE_ARRAY_ENTRY = TRUE;\n                        END;\n                     CALL REPLACE (ID_PTR);\n                     VAR_TYPE(ID_PTR) = TYPE;\n                     STRUCTYPE(ID_PTR) = ARRAY;\n                     OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                     S_LIST(ID_PTR) = TABLE_PTR;\n                     END;\n                  ELSE DO;\n                     CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);\n                     #TP = FATHERS_MULTIPLICITY;\n                     DO WHILE #TP >= 2;\n                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #TP);\n                        DATATYPE(ID_PTR) = TABLE_PTR;\n                        SL, STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(S_LIST(ID_PTR)\n                                                                        )*SL;\n                        TABLE_PTR = ID_PTR;\n                        #TP = #TP - 1;\n                        END;\n                     END;\n               /* 64  <TYPE> ::= <TYPE> */\n                                  /* FILE TYPE */\n            FILETYP:\n               DO;\n                  IF ALLOCATE_NEW_ROW THEN\n                     ID_PTR = NEXT_FREE_ROW;\n                  ELSE DO;\n                     ID_PTR = TP_ID_PTR;\n                     ALLOCATE_NEW_ROW = TRUE;\n                     END;\n                  DATATYPE(ID_PTR) = TABLE_PTR;\n                  VAR_TYPE(ID_PTR) = TYPE;\n                  STRUCTYPE(ID_PTR) = FILE;\n                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                  CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);\n                  STORAGE_LNGTH(ID_PTR) = SL;\n                  TABLE_PTR = ID_PTR;\n                  END;\n               /* 65  <TYPE> ::= <TYPE> */\n                                  /* SET TYPE */\n            SETTYP:\n               DO;\n                  IF ALLOCATE_ARRAY_ENTRY THEN\n                     ID_PTR = NEXT_FREE_ROW;\n                  ELSE DO;\n                     ID_PTR = TP_ID_PTR;\n                     ALLOCATE_ARRAY_ENTRY = TRUE;\n                     END;\n                  DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);\n                  S_LIST(ID_PTR) = TABLE_PTR;\n                  VAR_TYPE(ID_PTR) = TYPE;\n                  STRUCTYPE(ID_PTR) = SET;\n                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                  IF STRUCTYPE(TABLE_PTR) = SCALAR THEN\n                     DO;\n                        STORAGE_LNGTH(ID_PTR) =\n                           SHR(STORAGE_LNGTH(TABLE_PTR) + 7, 3);\n                        VALUE(ID_PTR) = 0;\n                     END;\n                  ELSE IF STRUCTYPE(TABLE_PTR) = SUBRANGE THEN\n                     DO;\n                        IF STORAGE_LNGTH(TABLE_PTR) = NULL THEN\n                           CALL ERROR(SUBRANGE_SIZE, 1);\n                        ELSE\n                           DO;\n                              I = VALUE(S_LIST(TABLE_PTR)) & \"FFFFFFF8\";\n                              I = I / 8;\n                              VALUE(ID_PTR) = I;\n                              SL = VALUE(TABLE_PTR) & \"FFFFFFF8\";\n                              SL = (SL/8) - VALUE(ID_PTR) + 1;\n                              STORAGE_LNGTH(ID_PTR) = SL;\n                           END;\n                     END;\n                  ELSE CALL ERROR(\n                     'A SET TYPE MUST BE BASED ON A SCALAR OR SUBRANGE TYPE',1);\n                  IF STORAGE_LNGTH(ID_PTR) > 256 THEN\n                     CALL ERROR(SUBRANGE_SIZE, 1);\n                  TABLE_PTR = ID_PTR;\n                  END;\n               /* 66  <TYPE> ::= (<FIXED FIELD LIST>)* (<VARIANT FIELD>) */\n                                  /* RECORD TYPE */\n               RECORDTYP:\n                  DO;\n                     IF #MP = 1 THEN\n                        DO;\n                           ID_PTR = OWNER_STACK(CURRENT_LEVEL);\n                           S_LIST(ID_PTR) = TABLE_PTR;\n                           CALL REPLACE(TABLE_PTR);\n                           STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);\n                        END;\n                     ELSE\n                        DO;\n                           I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);\n                           DO WHILE S_LIST(I) \u00ac= NULL;\n                              I = S_LIST(I);\n                           END;\n                           S_LIST(I) = TABLE_PTR;\n                           CALL REPLACE(TABLE_PTR);\n                           ID_PTR = OWNER_STACK(CURRENT_LEVEL);\n                        END;\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        DO;\n                           TABLE_PTR = OWNER_STACK(CURRENT_LEVEL);\n                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);\n                           /* COMPUTE STORAGE_LNGTH FROM ALLOCATED DISPLACEMENT\n                              INTO STACK.   */\n                           IF VAR_TYPE(OWNER(TABLE_PTR)) = PROC THEN\n                              STORAGE_LNGTH(TABLE_PTR) =\n                                 STACK_LIMIT(CURRENT_LEVEL);\n                           ELSE STORAGE_LNGTH(TABLE_PTR) =\n                              STACK_LIMIT(CURRENT_LEVEL)\n                                 - STACK_LIMIT(CURRENT_LEVEL - 1);\n                           CURRENT_LEVEL = CURRENT_LEVEL - 1;\n                        END;\n                  END;\n               /* 67  <FIXED FIELD LIST> ::= (<ID>)+ <TYPE> */\n                  IF #MP < FATHERS_MULTIPLICITY THEN\n                     DO;\n                        I, OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                        IF GREAT_GRANDFATHERS_PROD_NO = 69 THEN\n                           VAR_TYPE(TABLE_PTR) = VARIANT;\n                        ELSE VAR_TYPE(TABLE_PTR) = FIELD_ID;\n                        IF #MP > 1 THEN\n                           DO; /* LINK FIELD VARIABLES */\n                              ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);\n                              S_LIST(ID_PTR) = TABLE_PTR;\n                           END;\n                     END;\n                  ELSE\n                     DO;\n                        CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);\n                        I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                        DO WHILE ID_PTR \u00ac= NULL;\n                           DATATYPE(ID_PTR) = TABLE_PTR;\n                           STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);\n                           CALL ALLOCATE_STORAGE(ID_PTR);\n                           PSEUDO_REG(ID_PTR) = NULL;\n                           ID_PTR = S_LIST(ID_PTR);\n                        END;\n                        TABLE_PTR = I;\n                     END;\n               /* 68  <VARIANT FIELD> ::= <ID> <ID> (<VARIANT INSTANCE>)+ */\n                  DO;\n                     IF #MP = 1 THEN\n                        DO;\n                           I, OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                           IF GREAT_GRANDFATHERS_PROD_NO = 69 THEN\n                              VAR_TYPE(TABLE_PTR) = VARIANT;\n                           ELSE VAR_TYPE(TABLE_PTR) = FIELD_ID;\n                           STRUCTYPE(TABLE_PTR) = TAG;\n                           SL = 2;\n                           CALL ALLOCATE_STORAGE(TABLE_PTR);\n                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);\n                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;\n                        END;\n                     ELSE IF #MP = 2 THEN\n                        DO;\n                           IF (VAR_TYPE(TABLE_PTR) \u00ac= TYPE) |\n                              (STRUCTYPE(TABLE_PTR) < SCALAR) |\n                              (STRUCTYPE(TABLE_PTR) > SUBRANGE)  THEN\n                                 CALL ERROR('INVALID TAG TYPE IN VARIANT RECORD'\n                                    , 1);\n                           DATATYPE(PARSE_TREE(NODE#STACK(NP) + 2)) = TABLE_PTR;\n                        END;\n                     ELSE IF #MP = 3 THEN\n                        DO;\n                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                           S_LIST(ID_PTR) = TABLE_PTR;\n                           CALL REPLACE(TABLE_PTR);\n                           STORAGE_LNGTH(ID_PTR) = STACK_LIMIT(CURRENT_LEVEL+1)\n                                                  - STACK_LIMIT(CURRENT_LEVEL);\n                        END;\n                     ELSE\n                        DO;\n                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);\n                           DO WHILE S_LIST(ID_PTR) \u00ac= NULL;\n                              ID_PTR = S_LIST(ID_PTR);\n                           END;\n                           S_LIST(ID_PTR) = TABLE_PTR;\n                           CALL REPLACE(TABLE_PTR);\n                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                           SL = STACK_LIMIT(CURRENT_LEVEL + 1)\n                               - STACK_LIMIT(CURRENT_LEVEL);\n                           IF STORAGE_LNGTH(ID_PTR) < SL THEN\n                              STORAGE_LNGTH(ID_PTR) = SL;\n                        END;\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        DO;\n                           TABLE_PTR = ID_PTR; /* POINTS TO TAG */\n                           STACK_LIMIT(CURRENT_LEVEL) =\n                              STACK_LIMIT(CURRENT_LEVEL)\n                                 + STORAGE_LNGTH(ID_PTR);\n                           STORAGE_LNGTH(ID_PTR) = 2;\n                        END;\n                  END;\n               /* 69  <VARIANT INSTANCE> ::= (<CONSTANT>)+ <TYPE>\n                         IN WHICH <TYPE> IS ALWAYS A RECORD TYPE -- PROD. 66  */\n                  DO;\n                     IF FATHERS_MULTIPLICITY - #MP > 1 THEN\n                        DO;\n                           /* CREATE A SYMBOL TABLE ENTRY FOR A CASELABEL */\n                           ID_PTR = NEXT_FREE_ROW;\n                           DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);\n                           VAR_TYPE(ID_PTR) = CASELABEL;\n                           STRUCTYPE(ID_PTR) = SCALAR;\n                           OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);\n                           VALUE(ID_PTR) = VALUE(TABLE_PTR);\n                           TABLE_PTR = ID_PTR;\n                        END;\n                     IF #MP < FATHERS_MULTIPLICITY THEN\n                        DO;\n                           CALL REPLACE(TABLE_PTR);\n                           IF #MP > 1 THEN\n                              S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) =\n                                    TABLE_PTR;\n                           I = DATATYPE(PARSE_TREE(NODE#STACK(NP - 1) + 2));\n                              /* POINTER TO THE TAG TYPE */\n                           IF DATATYPE(TABLE_PTR) \u00ac= I THEN\n                              DO;\n                                 IF STRUCTYPE(I) = SUBRANGE THEN\n                                    DO;\n                                       IF DATATYPE(I) \u00ac= DATATYPE(TABLE_PTR)\n                                       THEN CALL ERROR(TAG_TYPE, 1);\n                                       ELSE\n                                          IF (VALUE(TABLE_PTR) > VALUE(I)) |\n                                          (VALUE(TABLE_PTR) < VALUE(S_LIST(I)))\n                                          THEN CALL ERROR(\n            'VALUE OF CASE LABEL IS OUTSIDE SUBRANGE SPECIFIED BY TAG TYPE', 1);\n                                    END;\n                                 ELSE CALL ERROR(TAG_TYPE, 1);\n                              END;\n                        END;\n                     ELSE\n                        DO;\n                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);\n                           VALUE(TABLE_PTR) = VALUE(ID_PTR);\n                           I = FATHERS_MULTIPLICITY - 1;\n                           IF I > 1 THEN\n                              DO;\n                                 S_LIST(PARSE_TREE(NODE#STACK(NP) + I)) =\n                                    TABLE_PTR;\n                                 TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                              END;\n                        END;\n                  END;\n               /* 70  <STATEMENT> ::= <EMPTY> */\n                  ;\n               /* 71  <TYPE> ::= (<TYPE>)+ <TYPE> */\n                                  /* PACKED ARRAY TYPE */\n                  GOTO ARRAYTYP;\n               /* 72  <TYPE> ::= <TYPE> */\n                                  /* PACKED FILE TYPE */\n                  GOTO FILETYP;\n               /* 73  <TYPE> ::= <TYPE> */\n                                  /* PACKED SET TYPE */\n                  GOTO SETTYP;\n               /* 74  <TYPE> ::= (<FIXED FIELD LIST>)* (<VARIANT FIELD>) */\n                                  /* PACKED RECORD TYPE */\n                  GOTO RECORDTYP;\n               /* 75  <ELEMENT> ::= <EXPRESSION> */\n                                  /* SIMPLE SET ELEMENT */\n                  FX = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1) + 1);\n               /* 76  <ELEMENT> ::= <EXPRESSION> <EXPRESSION> */\n                                  /* RANGE */\n                  IF #MP = 1 THEN\n                     DO;\n                        FIX_LIST(NP) = FIX_LIST(NP - 1);\n                        GOTO SET_ELEMENT;\n                     END;\n                  ELSE\n                     DO;\n                        CALL REPLACE(#TP);\n                        FX = PARSE_TREE(NODE#STACK(NP - 1)\n                                         + #POS_STACK(NP - 1) + 1);\n                     END;\n               /* 77  <PARAM TYPES> ::= (<TYPE ID>)+ */\n                                  /* LIST OF TYPES OF VALUE PARAMETERS */\n               TYPE_LIST:\n                  DO;\n                     I = NEXT_FREE_ROW;\n                     DATATYPE(I) = TABLE_PTR;\n                     IF VAR_TYPE(TABLE_PTR) \u00ac= TYPE THEN\n                        CALL ERROR(IDENTITY(TABLE_PTR) || ' IS NOT A TYPE', 1);\n                     STRUCTYPE(I) = STRUCTYPE(TABLE_PTR);\n                     OWNER(I) = OWNER_STACK(CURRENT_LEVEL);\n                     PSEUDO_REG(I), S_LIST(I) = NULL;\n                     IF FATHERS_PROD_NO = 77 THEN\n                        DO; /* FORMAL VALUE PARAMETERS */\n                           VAR_TYPE(I) = VARIABLE;\n                           CALL COMPUTE_STORAGE_LENGTH(I);\n                           CALL ALLOCATE_STORAGE(I);\n                        END;\n                     ELSE   /* FORMAL VAR PARAMETER */\n                        DO;\n                           VAR_TYPE(I) = VAR_PARAM;\n                           STORAGE_LNGTH(I) = 4;\n                           DISPLACEMENT(I) = STACK_LIMIT(CURRENT_LEVEL);\n                           STACK_LIMIT(CURRENT_LEVEL) =\n                              STACK_LIMIT(CURRENT_LEVEL) + 4;\n                        END;\n                     IF #MP > 1 THEN\n                        DO; /* LINK FORMAL PARAMETER TYPES TOGETHER */\n                           J = PARSE_TREE(NODE#STACK(NP) + #MP);\n                           S_LIST(J) = I;\n                        END;\n                     CALL REPLACE(I);\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n                  END;\n               /* 78  <PARAM TYPES> ::= (<TYPE ID>)+ */\n                                  /* LIST OF TYPES OF VAR PARAMETERS */\n                  GOTO TYPE_LIST;\n               /* 79  <PARAM TYPES> ::= (<PARAM TYPES>)+ (<TYPE ID>) */\n                                  /* PROCEDURE OR FUNCTION TYPES */\n                  DO;\n                     CALL REPLACE(TABLE_PTR);\n                     IF #MP > 1 THEN\n                        DO;   /* LINK FORMAL PARAM LISTS TOGETHER */\n                           LINK = PARSE_TREE(NODE#STACK(NP) + #MP);\n                           IF LINK \u00ac= NULL THEN\n                              DO;\n                                 DO WHILE S_LIST(LINK) \u00ac= NULL;\n                                    LINK = S_LIST(LINK);\n                                 END;\n                                 S_LIST(LINK) = TABLE_PTR;\n                              END;\n                        END;\n                     IF #MP = FATHERS_MULTIPLICITY THEN\n                        DO;\n                           ID_PTR = OWNER_STACK(CURRENT_LEVEL);\n                           IF IS_LEAF THEN\n                              DO; /* A FUNCTION-TYPE PARAMETER */\n                                 IF LINK \u00ac= NULL THEN S_LIST(LINK) = NULL;\n                                 DATATYPE(ID_PTR) = TABLE_PTR;\n                                 STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);\n                                 IF VAR_TYPE(TABLE_PTR) \u00ac= TYPE THEN\n                                    CALL ERROR(IDENTITY(TABLE_PTR)\n                                              || ' IS NOT A TYPE', 1);\n                              END;\n                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);\n                           VALUE(ID_PTR) = PARSE_TREE(NODE#STACK(NP) + 2);\n                           CURRENT_LEVEL = CURRENT_LEVEL - 1;\n                           TABLE_PTR = ID_PTR;\n                        END;\n                  END;\n               /* 80  <PARAM TYPES> ::= <EMPTY> */\n                  TABLE_PTR = NULL;\n               /* 81  <ERROR> ::= <EMPTY> */\n                  IF \u00acIS_DECLARATION THEN\n                     DO WHILE (FATHERS_PROD_NO \u00ac= 3) & (NP >= 0);\n                        CALL FATHER;\n                     END;\n               END;   /* CASE */\n               IF #POS_STACK(NP) = MULTIPLICITY(NODE#STACK(NP)) THEN\n                  CALL FATHER;\n               ELSE\n                  DO;\n                     CALL RIGHT_BRO;\n                     FIRST_VISIT = TRUE;\n                  END;\n            END;\n      END;\n   END VISIT_NODES;\n\n   /*             PROCEDURES FOR RESTORING SYMBOL TABLE               */\n\nNEXT_SYMBOL:\n   PROCEDURE CHARACTER;\n     /*         $P ----- DISABLES XREF PROGRAM         */\n      DECLARE (CP, S1, S2, TEXT_LIMIT) FIXED, (BCD, CHAR) CHARACTER;\n      IF LENGTH(SY_TEXT) < 3 THEN\n         DO;\n            CHAR = INPUT(3);\n            SY_TEXT = SY_TEXT || CHAR;\n         END;\n      BCD = '';\n      S1 = BYTE(X1);\n      S2 = BYTE(SY_TEXT, 1);\n      CP = 1;\n      TEXT_LIMIT = LENGTH(SY_TEXT) - 1;\n      DO WHILE \u00ac(S1 = BYTE('''') & S2 = BYTE(X1));\n         IF \u00ac(S1 = BYTE('''') & S2 = S1) THEN\n            DO;\n               CHAR = SUBSTR(SY_TEXT, CP, 1);\n               BCD = BCD || CHAR;\n            END;\n         ELSE S2 = BYTE(X1);\n         S1 = S2;\n         CP = CP + 1;\n         IF CP > TEXT_LIMIT THEN\n            DO;\n               SY_TEXT = INPUT(3);\n               TEXT_LIMIT = 79;\n               CP = 0;\n            END;\n         S2 = BYTE(SY_TEXT, CP);\n      END;\n      BCD = SUBSTR(BCD, 0, LENGTH(BCD) - 1);\n      IF CP = TEXT_LIMIT THEN\n         DO;\n            CHAR = INPUT(3);\n            SY_TEXT = SY_TEXT || CHAR;\n         END;\n      SY_TEXT = SUBSTR(SY_TEXT, CP + 1);\n      RETURN BCD;\n   END NEXT_SYMBOL;\n\nRESTORE_COLUMN:\n   PROCEDURE (ARRAY_ADDR, BYTES_PER_ITEM, LIMIT);\n      DECLARE ARRAY_ADDR FIXED,\n              (BYTES_PER_ITEM, LIMIT) BIT(16);\n      DECLARE (INCREMENT, I, J, K) FIXED;\n      DECLARE MVC(3) BIT(16) INITIAL(\"D200\", \"2000\", \"1000\");\n      INCREMENT = 80 / BYTES_PER_ITEM;\n      J = ARRAY_ADDR + (N_PREDECLARED_SYMB + 1)*BYTES_PER_ITEM;\n      I = N_PREDECLARED_SYMB + 1;\n      DO WHILE I + INCREMENT < LIMIT;\n         CALL INLINE(\"58\",1,0,SY_TEXT);          /* L    1,SY_TEXT         */\n         CALL INLINE(\"58\",2,0,J);                /* L    2,J               */\n         CALL INLINE(\"D2\",\"4\",\"F\",2,0,1,0);      /* MVC  0(80,2),0(1)      */\n         I = I + INCREMENT;\n         J = J + 80;\n         SY_TEXT = INPUT(3);\n      END;\n      K = (LIMIT - I) * BYTES_PER_ITEM - 1;\n      CALL INLINE(\"58\",1,0,SY_TEXT);             /* L    1,SY_TEXT         */\n      CALL INLINE(\"58\",2,0,J);                   /* L    2,J               */\n      CALL INLINE(\"58\",3,0,K);                   /* L    3,K               */\n      CALL INLINE(\"44\",3,0,MVC);                 /* EX   3,MVC             */\n      SY_TEXT = INPUT(3);\n   END RESTORE_COLUMN;\n\nRESTORE_SY_TABLE:\n   PROCEDURE;\n      DECLARE I FIXED;\n      DECLARE S CHARACTER;\n      N_DECL_SYMB, N_ANONYMOUS_SYMB = 0;\n      SY_TEXT = INPUT(3);\n      IF SUBSTR(SY_TEXT, 0, 5) \u00ac= '%SYMB' THEN\n         DO;\n            OUTPUT = '%SYMB CARD EXPECTED.';\n            CALL EXIT;\n         END;\n      DO I = 5 TO 9;\n         IF BYTE(SY_TEXT, I) \u00ac= BYTE(' ') THEN\n            N_DECL_SYMB = 10*N_DECL_SYMB + BYTE(SY_TEXT,I) - BYTE('0');\n      END;\n      DO I = 10 TO 14;\n         IF BYTE(SY_TEXT,I) \u00ac= BYTE(' ') THEN\n            N_ANONYMOUS_SYMB = 10*N_ANONYMOUS_SYMB + BYTE(SY_TEXT,I)\n                               - BYTE('0');\n      END;\n      FIRST_LITERAL = 0;\n      DO I = 15 TO 19;\n         IF BYTE(SY_TEXT, I) \u00ac= BYTE(' ') THEN\n            FIRST_LITERAL = 10*FIRST_LITERAL + BYTE(SY_TEXT, I) - BYTE('0');\n      END;\n      PRINT_STATISTICS = (BYTE(SY_TEXT, 20) = BYTE('D'));\n      PRINT_SYMBOLS = (BYTE(SY_TEXT, 21) = BYTE('S'));\n      IF FIRST_LITERAL < 0 THEN FIRST_LITERAL = NULL;\n      GAP = TABLE_LENGTH - N_DECL_SYMB + 1;\n      SY_TEXT = INPUT(3);\n      DO I = N_PREDECLARED_SYMB + 1 TO N_ANONYMOUS_SYMB - 1;\n         IDENTITY(I) = NEXT_SYMBOL;\n      END;\n      SY_TEXT = INPUT(3);\n      CALL RESTORE_COLUMN(ADDR(N_LOOKUPS),2,N_ANONYMOUS_SYMB);\n      CALL RESTORE_COLUMN(ADDR(SYMB_LINK),2,N_ANONYMOUS_SYMB);\n      CALL RESTORE_COLUMN(ADDR(VALUE),4,N_DECL_SYMB);\n      CALL RESTORE_COLUMN(ADDR(VAR_TYPE),2,N_DECL_SYMB);\n      CALL RESTORE_COLUMN(ADDR(DATATYPE),2,N_DECL_SYMB);\n      CALL RESTORE_COLUMN(ADDR(WHERE_DECL),2,N_ANONYMOUS_SYMB);\n      IDENTITY(N_PREDECLARED_SYMB + 1) =\n         SUBSTR(IDENTITY(N_PREDECLARED_SYMB + 1), 1);\n      CALL REWIND(FALSE, 3);   /* REWIND SYMBOL TABLE FILE */\n   END RESTORE_SY_TABLE;\n\nINITIALIZE_SY_TABLE:\n   PROCEDURE;\n      DECLARE I FIXED;\n      DO I = 0 TO TABLE_LENGTH;\n         VALUE(I) = 0;\n         OWNER(I) = NULL;\n         STORAGE_LNGTH(I), S_LIST(I) = NULL;\n         PSEUDO_REG(I) , DISPLACEMENT(I) = NULL;\n      END;\n      DO I = N_PREDECLARED_SYMB + 1 TO TABLE_LENGTH;\n         DATATYPE(I) = NULL;\n      END;\n      VALUE(FALSEPTR) = FALSE;\n      VALUE(TRUEPTR) = TRUE;\n      VALUE(NILPTR) = \"FBFBFBFB\";\n      VALUE(MAXINTPTR) = MAXINT;\n      S_LIST(INTPTR) = MAXINTPTR;\n      S_LIST(BOOLPTR) = FALSEPTR;\n      S_LIST(FALSEPTR) = TRUEPTR;\n      STORAGE_LNGTH(NILPTR) = 4;\n      STORAGE_LNGTH(INTPTR), STORAGE_LNGTH(REALPTR) = 4;\n      STORAGE_LNGTH(BOOLPTR) = 2;\n      STORAGE_LNGTH(CHARPTR) = 256;\n      STORAGE_LNGTH(MAXINTPTR) = 4;\n      STORAGE_LNGTH(INPUTPTR), STORAGE_LNGTH(OUTPUTPTR) = 2;\n      STORAGE_LNGTH(INTFIELDSIZEPTR), STORAGE_LNGTH(BOOLFIELDSIZEPTR) = 4;\n      STORAGE_LNGTH(REALFIELDSIZEPTR), STORAGE_LNGTH(DECIMAL_PLACESPTR) = 4;\n      PSEUDO_REG(MAXINTPTR) = 0;\n      DISPLACEMENT(MAXINTPTR) = DISPLAY_BYTES;\n      CALL EMIT_DATA_BYTES(MAXINTPTR);\n      PSEUDO_REG(NILPTR) = 0;\n      DISPLACEMENT(NILPTR) = DISPLAY_BYTES + 4;\n      CALL EMIT_DATA_BYTES(NILPTR);\n      PSEUDO_REG(INPUTPTR), PSEUDO_REG(OUTPUTPTR) = 0;\n      DISPLACEMENT(INPUTPTR) = DISPLAY_BYTES + 8;\n      DISPLACEMENT(OUTPUTPTR) = DISPLAY_BYTES + 10;\n      DATA_BYTES(DISPLACEMENT(INPUTPTR) + 1) = BYTE('?');\n      DATA_BYTES(DISPLACEMENT(OUTPUTPTR) + 1) = BYTE('?');\n      PSEUDO_REG(INTFIELDSIZEPTR), PSEUDO_REG(BOOLFIELDSIZEPTR) = 0;\n      PSEUDO_REG(REALFIELDSIZEPTR), PSEUDO_REG(DECIMAL_PLACESPTR) = 0;\n      DISPLACEMENT(INTFIELDSIZEPTR) = DISPLAY_BYTES + 12;\n      DISPLACEMENT(BOOLFIELDSIZEPTR) = DISPLAY_BYTES + 16;\n      DISPLACEMENT(REALFIELDSIZEPTR) = DISPLAY_BYTES + 20;\n      DISPLACEMENT(DECIMAL_PLACESPTR) = DISPLAY_BYTES + 24;\n      DATA_BYTES(DISPLACEMENT(INTFIELDSIZEPTR) + 3) = 12;\n      DATA_BYTES(DISPLACEMENT(BOOLFIELDSIZEPTR) + 3) = 6;\n      DATA_BYTES(DISPLACEMENT(REALFIELDSIZEPTR) + 3) = 14;\n      DATA_BYTES(DISPLACEMENT(DECIMAL_PLACESPTR) + 3) = 0;\n      DO I = DISPLACEMENT(DECIMAL_PLACESPTR) + 4 TO 79;\n         DATA_BYTES(I) = 0;\n      END;\n   END INITIALIZE_SY_TABLE;\n\nINITIALIZE_ARITHMETIC_FUNCTIONS:\n   PROCEDURE;\n      /* INITIALIZE SYMBOL TABLE ENTRIES FOR SIN, COS, EXP, LN, SQRT\n         AND ARCTAN. */\n      DECLARE (FUNCTION, PARAM_PTR) BIT(16),\n              MONITOR_CODE(5) BIT(8) INITIAL (0, 1, 3, 4, 5, 2);\n      /* ALLOCATE SYMBOL TABLE ENTRY FOR FORMAL PARAMETER OF STANDARD\n         ARITHMETIC FUNCTIONS */\n      PARAM_PTR = NEXT_FREE_ROW;\n      DATATYPE(PARAM_PTR) = REALPTR;\n      STRUCTYPE(PARAM_PTR) = ARITHMETIC;\n      VAR_TYPE(PARAM_PTR) = VARIABLE;\n      S_LIST(PARAM_PTR) = NULL;\n      DO FUNCTION = SINPTR TO ARCTANPTR;\n         S_LIST(FUNCTION) = PARAM_PTR;\n         VALUE(FUNCTION) = MONITOR_CODE(FUNCTION-SINPTR);\n      END;\n   END INITIALIZE_ARITHMETIC_FUNCTIONS;\n\n   /*                 PROCEDURE FOR READING IN A PARSE TREE           */\n\nREAD_TREE:\n   PROCEDURE FIXED;   /* RETURNS POINTER TO ROOT */\n      DECLARE (ROOT, I, J) FIXED;\n      ROOT, I = 0;\n      SY_TEXT = INPUT(2);\n      IF LENGTH(SY_TEXT) = 0 THEN RETURN NULL;\n      IF SUBSTR(SY_TEXT, 0, 5) \u00ac= '%TREE' THEN\n         DO;\n            OUTPUT = '%TREE CARD EXPECTED.';\n            RETURN NULL;\n         END;\n      DO J = 5 TO 9;\n         IF BYTE(SY_TEXT, J) \u00ac= BYTE(' ') THEN\n            ROOT = 10*ROOT + BYTE(SY_TEXT, J) - BYTE('0');\n      END;\n      PRINT_TREES = (BYTE(SY_TEXT, 10) = BYTE('P'));\n      PRINT_TRIPLES = (BYTE(SY_TEXT, 11) = BYTE('T'));\n      PRINT_CODE = (BYTE(SY_TEXT, 12) = BYTE('E'));\n      SY_TEXT = INPUT(2);\n      DO WHILE SUBSTR(SY_TEXT, 0, 4) \u00ac= '%END';\n         J = ADDR(PARSE_TREE(I));\n         CALL INLINE(\"58\",1,0,SY_TEXT);          /* L    1,SY_TEXT         */\n         CALL INLINE(\"58\",2,0,J);                /* L    2,J               */\n         CALL INLINE(\"D2\",\"4\",\"F\",2,0,1,0);      /* MVC  0(80,2),0(1)      */\n         I = I + 40;\n         SY_TEXT = INPUT(2);\n      END;\n      LAST_LINE = NULL;\n      CURRENT_LINE = PARSE_TREE(ROOT + MULTIPLICITY(ROOT) + 2);\n      TREE_SIZE = ROOT + MULTIPLICITY(ROOT) + 3;\n      IF GAP > 0 THEN\n         DO;\n            I = 1;\n            DO WHILE I <= ROOT;\n               IF MULTIPLICITY(I) = 0 THEN\n                  IF PARSE_TREE(I + 1) > N_ANONYMOUS_SYMB THEN\n                     PARSE_TREE(I + 1) = PARSE_TREE(I + 1) - GAP;\n               I = I + MULTIPLICITY(I) + 3;\n            END;\n         END;\n      IF PRINT_TREES THEN CALL PARSE_TREE_DUMP(ROOT);\n      RETURN ROOT;\n   END READ_TREE;\n\nEVALUATE_CONSTANTS:\n   PROCEDURE;\n      DECLARE I BIT(16);\n      HALFWORD_DISP(1) = 0;\n      I = N_DECL_SYMB - 1;\n      CONST_POOL_SIZE =\n         DISPLACEMENT(DECIMAL_PLACESPTR) + 4 - DISPLAY_BYTES;\n      DO WHILE I >= N_ANONYMOUS_SYMB;\n         IF DATATYPE(I) = INTPTR THEN\n            DO;\n               STORAGE_LNGTH(I) = 4;\n               STRUCTYPE(I) = ARITHMETIC;\n               S_LIST(I) = S_LIST(INTPTR);\n               S_LIST(INTPTR) = I;\n               PSEUDO_REG(I) = 0;\n               DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;\n               CONST_POOL_SIZE = CONST_POOL_SIZE + 4;\n            END;\n         ELSE IF DATATYPE(I) = CHARPTR THEN\n            DO;\n               STORAGE_LNGTH(I) = 2;\n               STRUCTYPE(I) = SCALAR;\n               S_LIST(I) = S_LIST(CHARPTR);\n               S_LIST(CHARPTR) = I;\n               PSEUDO_REG(I) = 0;\n               IF HALFWORD_DISP(1) > 0 THEN\n                  DO;\n                     DISPLACEMENT(I) = HALFWORD_DISP(1);\n                     HALFWORD_DISP(1) = 0;\n                  END;\n               ELSE\n                  DO;\n                     DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;\n                     HALFWORD_DISP(1) =\n                        CONST_POOL_SIZE + DISPLAY_BYTES + 2;\n                     CONST_POOL_SIZE = CONST_POOL_SIZE + 4;\n                  END;\n            END;\n         ELSE   /* DATATYPE(I) = REALPTR */\n            DO;\n               STORAGE_LNGTH(I) = 4;\n               STRUCTYPE(I) = ARITHMETIC;\n               S_LIST(I) = S_LIST(REALPTR);\n               S_LIST(REALPTR) = I;\n               PSEUDO_REG(I) = 0;\n               DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;\n               CONST_POOL_SIZE = CONST_POOL_SIZE + 4;\n            END;\n         CALL EMIT_DATA_BYTES(I);\n         I = I - 1;\n      END;\n      I = FIRST_LITERAL;\n      DO WHILE I \u00ac= NULL;\n         STORAGE_LNGTH(I) = LENGTH(IDENTITY(I));\n         STRUCTYPE(I) = ARRAY;\n         PSEUDO_REG(I) = 0;\n         DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;\n         CONST_POOL_SIZE = CONST_POOL_SIZE + STORAGE_LNGTH(I);\n         CALL EMIT_DATA_BYTES(I);\n         I = SYMB_LINK(I);\n      END;\n      CONST_POOL_SIZE = (CONST_POOL_SIZE + 3) & \"FFFFFC\";\n   END EVALUATE_CONSTANTS;\n\nMAIN_PROCEDURE:\n   PROCEDURE;\n      CALL INITIALIZE_SY_TABLE;\n      CALL RESTORE_SY_TABLE;\n      CALL EVALUATE_CONSTANTS;\n      CALL INITIALIZE_ARITHMETIC_FUNCTIONS;\n      ROOT_OF_SUBTREE = READ_TREE;\n      DO WHILE ROOT_OF_SUBTREE \u00ac= NULL;\n         CALL VISIT_NODES;\n         ROOT_OF_SUBTREE = READ_TREE;\n      END;\n      IF PRINT_SYMBOLS THEN CALL SY_DUMP;\n      CALL WRITE_SYMBOLS;\n      OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);\n      CALL REWIND(TRUE, 5);   /* REWIND DATA FILE */\n   END MAIN_PROCEDURE;\n\n   WITH_PTR = NULL;\n   FORWARD_AVAIL = NULL;\n   FORWARD_LIMIT = 0;\n   CALL MAIN_PROCEDURE;\n\n   IF SEVERE_ERRORS + MONITOR_LINK(3) > 0 THEN\n      DO;\n         MONITOR_LINK(0) = NULL;   /* ABORT COMPILATION */\n         CALL PRINT_COMPILE_TIME;\n      END;\n   ELSE IF MONITOR_LINK(2) > 0 THEN   /* DEBUG LEVEL > 0 */\n      CALL PREPARE_POST_MORTEM_TABLES;\nEOF EOF EOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE08": {"ttr": 7434, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x06\\xae\\x06\\xae\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 1710, "newlines": 1710, "modlines": 0, "user": "SPASCAL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FILE09": {"ttr": 8200, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x0f\\xf3\\x0f\\xf3\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 4083, "newlines": 4083, "modlines": 0, "user": "SPASCAL"}, "text": "\n   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    *                                                                     *\n    *                                                                     *\n    *                                                                     *\n    *                      P A S C A L   3 6 0 - 3 7 0                    *\n    *                                                                     *\n    *                         P A S S   T H R E E                         *\n    *                                                                     *\n    *                           CHARLES R. HILL                           *\n    *                    DEPARTMENT OF COMPUTER SCIENCE                   *\n    *                       S.U.N.Y. AT STONY BROOK                       *\n    *                                                                     *\n    *                                                                     *\n    *                                                                     *\n    *                                                                     *\n    *         THE FUNCTION OF PASS 3 IS TO GENERATE RELOCATABLE IBM 360-  *\n    *    370 MACHINE CODE FROM THE PSEUDO-MACHINE INSTRUCTIONS KNOWN      *\n    *    AS TRIPLES, WHICH ARE GENERATED IN PASS2.  AT THE END OF PASS2   *\n    *    THE ENTIRE SEMANTIC CONTENT OF THE ORIGINAL PASCAL PROGRAM IS    *\n    *    EMBEDDED IN THE TRIPLES, AND IN THREE COLUMNS OF THE SYMBOL      *\n    *    TABLE:    STORAGE_LENGTH, PSEUDO_REG,DISP.                       *\n    *                                                                     *\n    *         THE PASS 3 PROGRAM MODULES ARE AS FOLLOWS:\n    *    1) A MODULE FOR DEBUGGING & ROUTINE MAINTAINENCE                 *\n    *    2) A REGISTER ALLOCATION MODULE WHICH PROVIDES PRIMITIVES FOR    *\n    *       GETTING INDEX REGISTERS, ACCUMULATOR REGISTERS, FLOATING      *\n    *       POINT REGS, DOUBLE REGS, AND RUNTIME TEMPORARIES              *\n    *    3) CODE EMISSION PROCEDURES                                      *\n    *    4) ADDRESSABILITY PROCEDURES                                     *\n    *    5) INITIALIZATION AND INTERPASS COMMUNICATION ROUTINES           *\n    *    6) CODE GENERATION MODULE                                        *\n    *                                                                     *\n    *         SPECIFICALLY, PASS 3 DOES THE FOLLOWING:                    *\n    *    1)   BRING IN THE SYMBOL TABLE FROM AUXILARY STORAGE.            *\n    *    2)   FOR EACH PASCAL PROCEDURE, BRING IN ITS CORRESPONDING SET   *\n    *    OF TRIPLES, GENERATE CODE FOR THE PROCEDURE, AND SWAP THE RE-    *\n    *    SULTING CODE OUT TO AUX STORAGE. CODE GENERATION CONSISTS OF     *\n    *    A CASE ON THE TRIPLE OPERATION CODES.                            *\n    *    3)   EACH ENTRY POINT AND NON-LOCAL BRANCH TARGET OF A PRO-      *\n    *    CEDURE IS GIVEN AN ENTRY IN THE  TRANSFER VECTOR.\n    *    4)  A CORE IMAGE IS BUILT CONTAINING MULTIPLES OF 4096, THE      *\n    *       TRANSFER VECTOR, VARIOUS  INSTRUCTION SEQUENCES & CONSTANTS,  *\n    *       AND SWAPPED OUT. THIS SEGMENT IS KNOWN AS THE ORG SEGMENT.    *\n    *                                                                     *\n    *                                                                     *\n    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /\n\n   /*\n      PASS3, VERSION 1, RELEASE 0, MAY 1976\n     COPYRIGHT (C) 1976 DEPARTMENT OF COMPUTER SCIENCE, SUNY AT STONY BROOK\n                                                                             */\n\n\n\n   /*              G L O B A L    D E C L A R A T I O N S          */\n\n\n\n\n      /*       CONVENIENT ABBREVIATIONS USED FOR FORMATTING OF OUTPUT    */\n\n      DECLARE X1 CHARACTER INITIAL (' '),\n              X70 CHARACTER INITIAL (\n    '                                                                      ');\n\n      DECLARE SPACE LITERALLY 'SUBSTR(X70,0,';  /*  USED FOR SPACING  */\n      DECLARE X LITERALLY ')';\n      DECLARE LINE_FEED LITERALLY 'OUTPUT=X70';\n      DECLARE DOUBLE_SPACE LITERALLY 'OUTPUT(1)=0';\n\n\n\n\n      /*   THE FOLLOWING ARE USED TO COUNT CALLS TO IMPORTANT PROCEDURES\n           DURING COMPILATION (FOR PREPARING COMPILER STATISTICS)     */\n      DECLARE ( #FREE_TEMP,#GET_REG,#FLUSH_REG,#STORE_REG,#MAKE_OP_ADDR,\n                #FLUSH_ALL_TEMP_REGS,#STM_FLUSHES,#EMIT_RR,#EMIT_RX,#EMIT_SS)\n                BIT(16);\n      DECLARE INSTRUCTION (255) BIT(16);   /*   USED TO COUNT INSTRUCTIONS  */\n\n\n      /*  MISCELLANEOUS    */\n\n      DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0';\n      DECLARE FOREVER LITERALLY ' WHILE 1 ';\n      DECLARE ( I,J ) FIXED;\n      DECLARE TPTR BIT(16);\n      DECLARE STRING CHARACTER;\n      DECLARE POWER BIT(16);\n      DECLARE COMPILING BIT(1);\n      DECLARE TIME_ENTERED FIXED;      /*  TIME OF ENTRY INTO PASS 3     */\n      DECLARE LIST_INSTRUCTIONS BIT(1),\n              PROC_NAME CHARACTER,\n              STATISTICS BIT(1),\n              CPU_CLOCK FIXED;\n\n      /*    CODE ARRAY   */\n      DECLARE CODE_ARRAY_SIZE LITERALLY '14399';\n      DECLARE CODE_INDEX FIXED;  /* FORCES FULLWORD ALIGNMENT OF CODE ARRAY   */\n      DECLARE CODE (CODE_ARRAY_SIZE) BIT(8);\n\n\n      /*  USED FOR SYMBOLIC LISTINGS OF CODE      */\n\n\n\n /*        OPNAMES & OPNAMES2 ARE STRINGS CONTAINING MNEUMONIC OP CODES\n           USED IN PASS 3 FOR GENERATING SYMBOLIC LISTINGS OF CODE.\n           TO OBTAIN THE MNEUMONIC FOR A GIVEN INSTRUCTION, INDEX OPER\n           USING THE HEX-CODE, YIELDING THE REQUIRED INDEX INTO OPNAMES\n           OR OPNAMES2                                 */\n\n\n\n   DECLARE OPNAMES CHARACTER INITIAL ('    BALRBCTRBCR LPR LNR LTR LCR NR  CLR O\nR  XR  LR  CR  AR  SR  MR  DR  ALR SLR LA  STC IC  EX  BAL BCT BC  CVD CVB ST  N\n   CL  O   X   L   C   A   S   M   D   AL  SL  SRL SLL SRA SLA SRDLSLDLSRDASLDAS\nTM TM  MVI NI  CLI OI  XI  LM  MVC STH LH  STE CH  MH  ');\n\n      DECLARE OPNAMES2 CHARACTER INITIAL ('AH  SH  LCERLPERLER LE  CER CE  DER D\nE  SER SE  AER AE  MER ME  NC  CLC OC  XC  LD  AD  LCDRAW  SDR LTDRSTD AP  ');\n\n\n    DECLARE OPER(255) BIT(16) INITIAL (\n /*0**/   0,  0,  0,  0,  0,  4,  8, 12,  0,  0,  0,  0,  0,  0,  0,  0,\n /*1**/  16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76,\n /*2**/   0,  0,356,344,  0,  0,  0,  0,  0,  0,  0,352,  0,  0,  0,  0,\n /*3**/ 268,  0,  0,264,  0,  0,  0,  0,272,280,304,296,312,288,  0,  0,\n /*4**/ 236, 80, 84, 88, 92, 96,100,104,240,248,256,260,252,  0,108,112,\n /*5**/ 116,  0,  0,  0,120,124,128,132,136,140,144,148,152,156,160,164,\n /*6**/ 360,  0,  0,  0,  0,  0,  0,  0,336,  0,340,  0,  0,  0,348,  0,\n /*7**/ 244,  0,  0,  0,  0,  0,  0,  0,  276,284,308,300,316,292,0,  0,\n /*8**/   0,  0,  0,  0,  0,  0,  0,  0,168,172,176,180,184,188,192,196,\n /*9**/ 200,204,208,  0,212,216,220,224,228,  0,  0,  0,  0,  0,  0,  0,\n /*A**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*B**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*C**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*D**/   0,  0,232,  0,320,324,328,332,  0,  0,  0,  0,  0,  0,  0,  0,\n /*E**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*F**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,364,  0,  0,  0,  0,  0);\n /*      *0  *1  *2  *3  *4  *5  *6  *7  *8  *9  *A  *B  *C  *D  *E  *F  */\n\n   DECLARE OP_CODE CHARACTER;  /* FOR DEBUG PRINTOUT */\n\n\n      /*   360-370 OPERATION CODE MNEUMONICS   */\n\n      DECLARE BC FIXED INITIAL (\"47\"), BCR FIXED INITIAL (\"07\");\n      DECLARE BAL FIXED INITIAL (\"45\"), BALR FIXED INITIAL (\"05\");\n      DECLARE LOAD LITERALLY ' \"58\" ', ST LITERALLY '\"50\"';\n      DECLARE C FIXED INITIAL(\"59\"), CR FIXED INITIAL(\"19\");\n      DECLARE CH BIT(16) INITIAL (\"49\");\n      DECLARE LA LITERALLY '\"41\"';\n      DECLARE STM FIXED INITIAL (\"90\"),LM FIXED INITIAL (\"98\");\n      DECLARE MVC LITERALLY ' \"D2\" ';\n      DECLARE LR FIXED INITIAL (\"18\"), SR BIT(16) INITIAL (\"1B\");\n      DECLARE BCTR FIXED INITIAL (\"06\"),BCT BIT(16) INITIAL(\"46\");\n      DECLARE EX FIXED INITIAL (\"44\"),LH FIXED INITIAL (\"48\");\n      DECLARE IC FIXED INITIAL (\"43\");    /*  INSERT CHARACTER   */\n      DECLARE SLA BIT(16) INITIAL (\"8B\");   /*  ARITH SHIFT LEFT   */\n      DECLARE SLDL BIT(16) INITIAL (\"8D\"),SRDA BIT(16) INITIAL (\"8E\");\n      DECLARE LPR BIT(16) INITIAL (\"10\"),LCR BIT(16) INITIAL (\"13\");\n      DECLARE M BIT(16) INITIAL (\"5C\"),MR BIT(16) INITIAL (\"1C\");\n      DECLARE MH BIT(16) INITIAL (\"4C\"),AH BIT(16) INITIAL (\"4A\");\n      DECLARE A BIT(16) INITIAL (\"5A\"), AR BIT(16) INITIAL (\"1A\"),\n              D BIT(16) INITIAL (\"5D\"), DR BIT(16) INITIAL (\"1D\"),\n              S BIT(16) INITIAL (\"5B\"), SH BIT(16) INITIAL (\"4B\");\n      DECLARE LTR BIT(16) INITIAL (\"12\");\n      DECLARE ME   BIT(16) INITIAL(\"7C\"),MER  BIT(16) INITIAL(\"3C\"),\n              AE   BIT(16) INITIAL(\"7A\"),AER  BIT(16) INITIAL(\"3A\"),\n              SE   BIT(16) INITIAL(\"7B\"),SER  BIT(16) INITIAL(\"3B\"),\n              DE   BIT(16) INITIAL(\"7D\"),DER  BIT(16) INITIAL(\"3D\"),\n              CE   BIT(16) INITIAL(\"79\"),CER  BIT(16) INITIAL(\"39\"),\n              LE   BIT(16) INITIAL(\"78\"),LER  BIT(16) INITIAL(\"38\"),\n              LPER BIT(16) INITIAL(\"30\"),LCER BIT(16) INITIAL(\"33\");\n      DECLARE CLI BIT(16) INITIAL (\"95\");\n      DECLARE XOR BIT(16) INITIAL (\"57\"), N BIT(16) INITIAL (\"54\");\n      DECLARE SLL BIT(16) INITIAL (\"89\"),SRL BIT(16) INITIAL (\"88\");\n      DECLARE CLC BIT(16) INITIAL (\"D5\"), XC BIT(16) INITIAL (\"D7\"),\n              OC BIT(16) INITIAL (\"D6\"), NC BIT(16) INITIAL (\"D4\");\n      DECLARE LD   BIT(16) INITIAL(\"68\"),AD   BIT(16) INITIAL (\"6A\"),\n              LCDR BIT(16) INITIAL(\"23\"),AW   BIT(16) INITIAL (\"6E\"),\n              STD  BIT(16) INITIAL(\"60\"),STE  BIT(16) INITIAL (\"70\"),\n              STH  BIT(16) INITIAL(\"40\"),STC  BIT(16) INITIAL (\"42\"),\n              LTDR BIT(16) INITIAL(\"22\"),SDR  BIT(16) INITIAL (\"2B\");\n      DECLARE AP BIT(16) INITIAL(\"FA\"), MVI BIT(16) INITIAL (\"92\");\n      DECLARE SRDL BIT(16) INITIAL (\"8C\");\n      DECLARE TM BIT(16) INITIAL(\"91\"),OI BIT(16) INITIAL(\"96\");\n\n\n\n      /*   REGISTER ALLOCATION & TEMPORARY MANAGEMENT VARIABLES     */\n\n      DECLARE LAST_TEMP LITERALLY 'NEXT_TEMP-1';\n DECLARE FIX_BASE_REG_PRIORITIES LITERALLY\n      ' DO; IF X_REG \u00ac= 0 THEN PRIORITY(X_REG)=FIXED_PRIORITY;IF BASE_REG\u00ac=0\nTHEN PRIORITY(BASE_REG)=FIXED_PRIORITY;END;'  ;\n     DECLARE CONTENT(22) FIXED,\n             PRIORITY(22) BIT(16),\n             USE(22) FIXED,\n             FREE_PRIORITY BIT (8) INITIAL (0),\n             BASE_PRIORITY BIT(8) INITIAL (1),\n             TEMP_PRIORITY BIT(8) INITIAL (2),\n             FIXED_PRIORITY BIT(8) INITIAL (3),\n             #GP_REGS LITERALLY '16',\n             NONE LITERALLY '-1',     /*  FOR NOW   */\n             NULL LITERALLY '-1',\n             STACKTOP_PSEUDO_REG LITERALLY '100',\n             MARKED_FREE BIT(16) INITIAL (200),\n              NEXT_TEMP_DISPL FIXED,\n              NEXT_TEMP_DISPL_STACK (64) FIXED,   /*  USED FOR REMEMBERING\n                 NEXT_TEMP_DISPL DURING NESTED PROCEDURE CALLS       */\n              AR_OFFSET FIXED,\n              TEMP_DISPL_STACKTOP FIXED;\n\n\n\n      /*   GENERAL REGISTERS 11 - 15 ARE FIXED PRIORITY REGISTERS.\n            THEY ARE ASSIGNED AS FOLLOWS:                */\n      DECLARE\n         CURRENT_AR_BASE LITERALLY '11',    /* CURRENT ACTIVATION REC PTR  */\n         CODE_BASE LITERALLY '12',          /* BASE OF CURRENT CODE SEGMENT */\n         STACKTOP LITERALLY '13',           /*  TOP OF RUN-TIME STACK  */\n         GLOBAL_AR_BASE LITERALLY '14',     /*  BASE OF RUN-TIME STACK  */\n         ORG LITERALLY '15';           /*  ORIGIN OF RUN-TIME STORAGE AREA  */\n      DECLARE HI_REG LITERALLY '10';\n\n\n     /*  GLOBALS USED TO MAKE AN OPERAND ADDRESSABLE        */\n      DECLARE  (\n         OP_STORAGE_LENGTH,     /*  STORAGE LENGTH OF LAST ADDRESSED OPERAND */\n         BYTE_XREG,\n         DISPL,\n         ACC,\n         ACC1,\n         X_REG,\n         BASE_REG1,\n         X_REG1,\n         DISPL1,\n         BASE_REG2,\n         DISPL2,\n         BASE,\n         EVEN_REG,\n         ODD_REG,\n         FLT_REG,\n         FLT_ACC,\n         OP_MASK,\n         TEMP,\n         BASE_REG   ) FIXED,\n         LINK LITERALLY '10';\n      DECLARE IN_REG BIT(1),   /* INDICATES AN OP IS IN A REGISTER (ACC) */\n              IN_FREE_REG BIT(1),\n              FORMAL_PARAMETER BIT(1),\n              IMMEDIATE BIT(1);    /*  INDICATES OPERAND IS IMMEDIATE.    */\n\n\n\n      /*   THE FOLLOWING DEFINE THE RELATIVE DISPLACEMENTS FROM ORG OF\n           RUN-TIME DATA STRUCTURES LOCATED IN THE ORG SEGMENT         */\n\n      DECLARE MAX_TOP BIT(16) INITIAL(4);  /* WILL CONTAIN THE MAXIMUM\n              VALUE THE STACKTOP MAY ACHIEVE BEFORE COLLIDING WITH THE HEAP\n              POINTER. THIS VALUE IS UPDATED WHENEVER THE HEAP POINTER\n              IS CHANGED & IS ALWAYS EQUAL TO HEAP_POINTER - MAX_TEMP_DISPL. */\n      DECLARE MULT_OF_4096_BASE LITERALLY '8',\n              MVC_INSTR BIT(16) INITIAL (136),  /*  WILL CONTAIN A MVC TO BE EX'\n              MVC     20(0,10),20(9)                AT RUN TIME, TO BE USED FOR\n                                                   COPYING DISPLAYS        */\n              /*   WORKING STORAGE   */\n              DS1 BIT(16) INITIAL (144),\n\n         /*  USED FOR INLINE FLT PT/INTEGER ROUTINES   */\n              CONP5 BIT(16) INITIAL (152),   /*      DC    E'0.5'      */\n              DS4E BIT(16) INITIAL (160),   /*   DC   '4E',7X'00'    */\n              CONSTD0 BIT(16) INITIAL (168),   /*   DC    D'0'        */\n              CON4E BIT(16) INITIAL (176),    /*   DC    '4E',7X'00'   */\n\n              CONST1 BIT(16) INITIAL (184),         /*   BINARY 1      */\n              DEC1   BIT(16) INITIAL (188),     /* DECIMAL 1 USED FOR\n                                                   INCREMENTING BLOCK COUNTERS*/\n              CONSTM1 BIT(16) INITIAL(192),   /*   A DOUBLEWORD CONST -1  */\n              SET_MASKS BIT(16) INITIAL(200),   /* USED BY INTO TRIPLE   */\n              PASCAL_REGS BIT(16) INITIAL(208),   /*  SAVE AREA FOR GEN REGS */\n              MON_BASE_REGS BIT(16) INITIAL(272), /*  BASE ADDRESSES OF THE\n                 SERVICE MONITOR       */\n              MEM_OVERFLOW BIT(16) INITIAL(284),  /*  MEM OVERFLOW ERR ENTRY */\n              SUBRANGE_ERROR BIT(16) INITIAL (296), /*  ENTRY FOR RANGE ERROR */\n              BLOCK_COUNTER_BASE BIT(16) INITIAL(308),\n              TRANSFER_VECTOR_BASE FIXED;   /*  VALUE DEPENDS ON THE NUMBER\n              OF BLOCK COUNTERS, WHICH IS RECEIVED FROM PASS 2 .\n              TRANSFER_VECTOR_BASE IS INITIALED IN RESTORE_SY_TABLE    */\n\n\n      /*   SYMBOL TABLE DECLARATIONS             */\n      DECLARE MAX_TEMP LITERALLY '950',          /* WB */\n /* WB */     BASE_TEMP LITERALLY '851', /* DEFINE TEMP AREA OF SYMBOL TABLE  */\n              NEXT_TEMP FIXED;\n      DECLARE SYMBOL_TABLE_SIZE LITERALLY '1050';          /* WB */\n      DECLARE MULT_OF_4096_TABLE_BASE LITERALLY '951';     /* WB */\n\n      DECLARE DBR_TABLE_BASE LITERALLY '984';   /*  DENOTES INDEX INTO (* WB *)\n           SYMBOL TABLE OF FIRST DATA BASE PSEUDO REG              */\n\n      DECLARE PSEUDO_REG (MAX_TEMP) BIT(16),\n              DISP (MAX_TEMP) FIXED,             /* WB */\n              STORAGE_LENGTH (MAX_TEMP) FIXED,\n              REG (SYMBOL_TABLE_SIZE) BIT(16);\n\n\n\n\n      /*  THE TRANSFER VECTOR IS A VECTOR OF ADDRESSES USED TO TRANSFER\n          CONTROL FROM ONE CODE SEGMENT TO ANOTHER DURING EXECUTION.\n          A CORE IMAGE CONTAINING RELATIVE ADDRESSES IS BUILT DURING\n          PASS 3, AND SWAPPED OUT AT THE END OF THE PASS WITH THE ORG SEGMENT.\n          THE LOADER WILL ADD THE RELOCATION CONSTANT TO EACH ADDRESS AFTER\n          IT HAS SWAPPED IN THE ORG SEGMENT AT LOAD TIME        */\n\n\n      DECLARE TRANSFER_VECTOR_SIZE LITERALLY '300',\n              TRANSFER_VECTOR (TRANSFER_VECTOR_SIZE ) FIXED;\n\n\n\n     /*   THE TRIPLES ARRAY CONTAINS THE PSEUDO-MACHINE INSTRUCTIONS\n          KNOWN AS TRIPLES, WHICH ARE GENERATED IN PASS2.  THE FORMAT\n          OF A TRIPLE IS AS FOLLOWS:\n\n             BYTE 1  - LENGTH CODE (LENGTH - 1)\n             BYTE 2 - OPERATION CODE\n             2ND HALFWORD - OPERAND 1\n             3RD HALFWORD - OPERAND 2\n\n          THE FIRST TWO BITS OF EACH OPERAND FORM A MASK, WHICH HAS\n          THE FOLLOWING MEANINGS:\n\n             00 - SYMBOL TABLE POINTER\n             01 - IMMEDIATE OPERAND\n             10 - TRIPLE (TEMP)\n             11 - TRIPLE (TEMP NOT FREED)                         */\n\n      DECLARE TRIPLES(7199) BIT(16),   /*   TRIPLES ARRAY   */\n               OP1 LITERALLY 'TRIPLES(CURRENT_TRIPLE + 1) ',   /*  1ST OP  */\n               OP2 LITERALLY 'TRIPLES( CURRENT_TRIPLE + 2)',    /*  2ND OP */\n               CURRENT_TRIPLE BIT(16);\n\n\n      /*  MASKS USED FOR PROCESSING THE TRIPLES          */\n\n      DECLARE SY_TABLE_PTR BIT(16) INITIAL (0),\n              TRIPLE_PTR BIT(16) INITIAL (2),\n              TEMP_MASK BIT(16) INITIAL(3),\n              TRIPLE_OP_MASK BIT(16) INITIAL (\"7F\"),  /* OBTAINS TRIPLE OP  */\n              STRIPMASK LITERALLY ' \"3FFF\" ';  /*  USED TO STRIP OFF OP MASK  */\n\n\n\n      /*   TRIPLES REFERRED TO BY NAME         */\n\n      DECLARE INDEX BIT(16) INITIAL (5),\n              TEMP_TRIPLE BIT(16) INITIAL(6),\n              BNZ_TRIPLE BIT(16) INITIAL (33),\n              S_LENGTH BIT(16) INITIAL (57),\n              BCH_TARGET BIT(16) INITIAL(4),\n              PEND BIT(16) INITIAL (40);\n\n\n\n      /*   USED FOR PROCESSING PROCEDURE CALLS AND BRANCHES     */\n\n      DECLARE ENTRY_POINT FIXED;   /*  THE DISPLACEMENT OF THE FIRST INSTRUCTION\n              OF THE CURRENT PROCEDURE RELATIVE TO THE BASE OF THE ENTIRE\n              PROGRAM CODE SEGMENT.  WHEN CODE_GENERATION IS COMPLETE,\n              ENTRY_POINT WILL CONTAIN THE ENTRY INTO THE MAIN PROCEDURE    */\n      DECLARE CURRENT_LEVEL FIXED;  /*  LEX LEVEL OF CURRENT PROC  */\n      DECLARE STATIC_DISPLAY_SIZE BIT(16);\n      DECLARE (OPERAND1,OPERAND2 ) FIXED;\n      DECLARE OWNER LITERALLY 'STORAGE_LENGTH';\n      DECLARE CURRENT_PROCEDURE LITERALLY 'TRIPLES(0)';\n      DECLARE CURRENT_PROC_SEQ# FIXED;\n\n      /*   USED IN MONITOR CALLS     */\n      DECLARE SERVICE_CODE BIT(16);\n\n      /*   CONDITION CODE MASKS   */\n      DECLARE BH  BIT(16) INITIAL ( 2),\n              BL  BIT(16) INITIAL ( 4),\n              BNE BIT(16) INITIAL ( 7),\n              BE  BIT(16) INITIAL ( 8),\n              BNL BIT(16) INITIAL (11),\n              BNH BIT(16) INITIAL (13),\n              UNCOND BIT(16) INITIAL(15);\n\n\n      /*     GLOBAL VARIABLES PASSED TO PASS THREE         */\n\n      DECLARE LIST_CODE BIT(1);   /*  FLAGS WHETHER GENERATED CODE &ZTRIPLES\n              SHOULD BE LISTED       */\n      DECLARE N_DECL_SYMB FIXED;   /*  # OF DECLARED SYMBOLS IN USER PROG  */\n      DECLARE NEXT_SEQ# FIXED;\n      DECLARE #BASIC_BLOCKS FIXED;\n\n\n      /*   INTERPASS COMMUNICATION VARIABLES       */\n\n     /*   VARIABLES USED IN PASS 3 OUTPUT ROUTINES   */\n      DECLARE CODE_FILE BIT(16) INITIAL (3);\n      DECLARE ORG_FILE BIT(16) INITIAL(4);\n      DECLARE CODE_TEXT CHARACTER INITIAL ( '\n                                                                            ' );\n     /*   VARIABLES USED IN PASS 3  INPUT ROUTINES   */\n      DECLARE SY_TEXT CHARACTER;                           /* WB */\n      DECLARE SY_FILE BIT(16) INITIAL(2),\n              TRIPLES_FILE BIT(16) INITIAL(3);\n\n      /*   VARIABLES PASSED TO LOADER     */\n      DECLARE MAX_TEMP_DISPL FIXED;   /*   CONTAINS MAX VALUE OF\n              NEXT_TEMP_DISPL THRU-OUT ENTIRE PROGRAM. USED TO COMPUTE THE\n              MAXIMUM VALUE THE STACKTOP MAY ACHIEVE DURING EXECUTION   */\n              /*   TRANSFER_VECTOR_BASE IS ALSO PASSED     */\n\n\n      /*   VARIABLES USED FOR HANDLING LINE NUMBER INFORMATION    */\n      DECLARE CURRENT_LINE# FIXED,\n              LINE#MASK BIT(16) INITIAL(\"80\"),   /* PICKS OUT LINE# BIT   */\n              LINE#BUFF(20) FIXED,   /*  BUFFER FOR LINE# INFORMATION  */\n              LINE_BUFF_PTR BIT(16),   /*   PTR FOR ABOVE BUFFER   */\n              LINE#FILE BIT(16) INITIAL (6),   /*   FILE USED FOR LINE#S */\n              LINE_NUMS CHARACTER;   /*   \"DESCRIPTOR\" FOR LINE#BUFF   */\n      DECLARE END_COMPILATION LABEL;\n\n\n\n      /*    END OF GLOBAL  DECLARATIONS        */\n\n\n\n\n\n  /*     D E B U G G I N G  &   M A I N T A I N A N C E   R O U T I N E S    */\n\n\n PRINT_TIME: PROCEDURE (TIME,MESSAGE);\n      DECLARE (TIME,L) FIXED, (MESSAGE,STRING) CHARACTER;\n      STRING = TIME; L = LENGTH (STRING);\n      IF L < 5 THEN STRING = SUBSTR('00000',0,5 - L) || STRING;\n      STRING = '0' || SUBSTR(STRING,0,3) || '.' || SUBSTR(STRING,3,2);\n      OUTPUT(1) = STRING || MESSAGE;\n END PRINT_TIME;\n ERROR: PROCEDURE (MESSAGE);\n      DECLARE MESSAGE CHARACTER;\n      OUTPUT = '* * * COMPILER ERROR: ' || MESSAGE || ',';\n      OUTPUT = SPACE 7X || 'WHILE GENERATING CODE FOR PROCEDURE ' ||\n         PROC_NAME || ' NEAR LINE ' || CURRENT_LINE#;\n      MONITOR_LINK(0) = NULL;   /*   INHIBIT EXECUTION   */\n      GOTO END_COMPILATION;     /*  BREAK FROM COMPILATION LOOP   */\n END ERROR;\n\n\n PAD: PROCEDURE (STRING,WIDTH) CHARACTER;\n\n      DECLARE STRING CHARACTER, (WIDTH,L) FIXED;\n\n      DO WHILE LENGTH(STRING) + 70 < WIDTH;\n         STRING = STRING || X70;\n      END;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN (STRING);\n      ELSE RETURN STRING || SUBSTR(X70,0,WIDTH - L);\n\n END PAD;\n\n\n I_FORMAT: PROCEDURE (NUMBER,WIDTH) CHARACTER;\n\n      /*    PREPARES A FIELD OF THE GIVEN WIDTH ,INSERTING GIVEN\n            INTEGER RIGHT JUSTIFIED.                      */\n\n      DECLARE (NUMBER,WIDTH) FIXED,STRING CHARACTER;\n\n      STRING = NUMBER;\n      IF LENGTH(STRING) >= WIDTH THEN RETURN STRING;\n      RETURN (SPACE (WIDTH - LENGTH(STRING) ) X || STRING );\n END I_FORMAT;\n\n PRINT_PASS3_STATISTICS : PROCEDURE;\n    DECLARE DELTA FIXED;\n\n    IF STATISTICS THEN\n    DO;\n\n      OUTPUT(1) = 1;\n      OUTPUT= SPACE 40X || 'C O M P I L A T I O N   S T A T I S T I C S';\n      DOUBLE_SPACE;\n      OUTPUT = 'TRANSFER VECTOR SIZE = ' || NEXT_SEQ#;\n      IF #BASIC_BLOCKS \u00ac= 0 THEN OUTPUT = 'BLOCK COUNTER BASE = ' ||\n      BLOCK_COUNTER_BASE;\n       DOUBLE_SPACE;\n      OUTPUT = 'CALLS TO IMPORTANT PROCEDURES';\n      DOUBLE_SPACE;\n      OUTPUT = PAD('GET_REG',21) || #GET_REG;\n      OUTPUT = PAD('FREE_TEMP',21) || #FREE_TEMP;\n      OUTPUT = PAD('FLUSH_REG',21) || #FLUSH_REG;\n      OUTPUT = PAD('STORE_REG',21) || #STORE_REG;\n      OUTPUT = PAD('MAKE_OP_ADDR',21) || #MAKE_OP_ADDR;\n      OUTPUT = PAD('FLUSH_ALL_TEMP_REGS',21) || #FLUSH_ALL_TEMP_REGS;\n      OUTPUT = PAD('STM FLUSHES',21) || #STM_FLUSHES;\n      OUTPUT = PAD('EMIT_RR',21) || #EMIT_RR;\n      OUTPUT = PAD('EMIT_RX',21) || #EMIT_RX;\n      OUTPUT = PAD('EMIT_SS',21) || #EMIT_SS;\n      DOUBLE_SPACE;\n      OUTPUT = 'INSTRUCTION FREQUENCIES';\n      LINE_FEED;\n      DO I = 0 TO 255;\n         IF INSTRUCTION(I) \u00ac= 0 THEN DO;\n            IF OPER(I) < 256 THEN STRING = SUBSTR(OPNAMES,OPER(I),4);\n            ELSE STRING = SUBSTR(OPNAMES2,OPER(I) - 256, 4);\n            OUTPUT = STRING || SPACE 5 X || INSTRUCTION(I);\n         END;\n      END;\n      DELTA = TIME - TIME_ENTERED;\n      IF DELTA \u00ac= 0 THEN\n      DO;\n         IF DELTA < 0 THEN DELTA = DELTA = DELTA + 8640000;\n         DOUBLE_SPACE;\n         CALL PRINT_TIME(DELTA,' SECONDS (ELAPSED) IN PASS 3');\n         DELTA = CLOCK_TRAP(1) - CPU_CLOCK;\n         CALL PRINT_TIME(DELTA,' SECONDS (CPU) IN PASS 3');\n      END;\n    END;\n\n    DELTA = CLOCK_TRAP(NULL);   /*   CANCEL CPU TIMER   */\n      CALL PRINT_TIME (DELTA,' SECONDS (CPU) IN COMPILATION, ' ||\n         ENTRY_POINT + CODE_INDEX || ' BYTES OF CODE GENERATED.');\n    OUTPUT(1) = '0EXECUTION OPTIONS: ' || MONITOR_LINK(0) || ' SECONDS, '\n      || MONITOR_LINK(1) || ' LINES, DEBUG LEVEL = ' || MONITOR_LINK(2);\n END PRINT_PASS3_STATISTICS;\n\n PRINT_TRIPLE: PROCEDURE(INDEX);\n      DECLARE INDEX BIT(16),           /* INDEX INTO TRIPLES           */\n              IC FIXED,                /* INSTRUCTION COUNTER          */\n              STOR_LEN FIXED,\n              LINE# FIXED;             /* CORRESPONDING LINE OF SOURCE */\n      DECLARE OP_CODES(61) CHARACTER INITIAL('LOAD', 'MONITOR', 'TRUNCATE',\n         'FLOAT', 'BCH_TARGET', 'INDEX', 'TEMP', 'STORE', 'MOVE', 'ADD',\n         'SUBTRACT', 'MULTIPLY', 'DIVIDE', 'COMPARE', 'ADD_DECIMAL', 'GREATER',\n         'LESS', 'NOT', 'ADDFLT', 'SUBFLT', 'MPYFLT', 'DIVFLT', 'COMPAREFLT',\n         'GREATERFLT', 'LESSFLT', 'LOAD_ADDR', 'AND', 'OR', 'XOR', 'LSHIFT',\n         'RSHIFT', 'BAL', 'BCH', 'BNZ', 'BZ', 'BCT', 'PCALL', 'PRETURN',\n         'PARM', 'BLKMARK', 'PEND', 'TPOP', 'REM', 'ABS', 'ABSFLT', 'NEGATE',\n         'NEGATEFLT', 'LLESS', 'LGREATER', 'LCOMPARE', 'PROCPARM', 'CASE',\n         'CASE_TARGET', 'ODD', 'SQR', 'SQRFLT', 'ROUND', 'S_LENGTH', 'IN',\n         'INTO', 'LINE#', 'RANGE');\n      DECLARE LINE CHARACTER;\n      DECLARE (OPND, I) BIT(16);\n\n      LINE = PAD('$' || (INDEX - 6) / 3,9);\n      LINE = LINE || OP_CODES(TRIPLES(INDEX) & TRIPLE_OP_MASK);\n      LINE = PAD(LINE, 21);\n      DO I = 1 TO 2;   /* PRINT THE OPERANDS */\n         OPND = TRIPLES(INDEX + I);\n         IF (I = 2) & (OPND \u00ac= NULL) THEN LINE = LINE || ',';\n         DO CASE SHR(OPND,14) & \"0003\";\n\n            /* 00 -- OPERAND IS A POINTER TO THE SYMBOL TABLE          */\n            LINE = LINE || (OPND & \"3FFF\");\n\n            /* 01 -- OPERAND IS IMMEDIATE DATA, A 14-BIT CONSTANT      */\n            LINE = LINE || '=''' || (OPND & \"3FFF\") || '''';\n\n            /* 10 -- OPERAND IS A POINTER TO ANOTHER TRIPLE            */\n            LINE = LINE || '$' || ((OPND & \"3FFF\") - 6) / 3;\n\n            /* 11 -- OPERAND IS A TRIPLE WHOSE VALUE IS BEING TESTED   */\n            IF OPND \u00ac= NULL THEN\n            LINE = LINE || '$$'|| ((OPND & \"3FFF\") - 6) / 3;\n\n         END;\n      END;\n      /*  COMPUTE AND INCLUDE STORAGE LENGTH OF RESULT IN LINE    */\n      STOR_LEN = (SHR (TRIPLES(INDEX),8 ) & \"FF\" ) + 1;\n      LINE = PAD(LINE,45);\n      LINE = LINE || 'LENGTH ' || STOR_LEN;\n      OUTPUT = LINE;\n END PRINT_TRIPLE;\n\n LIST_TRIPLES: PROCEDURE;\n      DECLARE LINE# BIT(16), LINE#TRIPLE BIT(16) INITIAL(60);\n\n      /*   LIST ALL THE TRIPLES GENERATED FOR THE CURRENT PASCAL PROCEDURE */\n\n      OUTPUT(1) = 1;\n      OUTPUT = SPACE 40X || 'TRIPLES FOR PROCEDURE ' || PROC_NAME;\n      DOUBLE_SPACE;\n      OUTPUT = 'CURRENT_LEVEL = ' || CURRENT_LEVEL;\n      OUTPUT = 'CURRENT_PROCEDURE = ' || CURRENT_PROCEDURE;\n      OUTPUT = 'CURRENT SEQ# = ' || TRIPLES(1);\n      DOUBLE_SPACE;\n\n      LINE# = TRIPLES(7);\n      I = 6;\n      DO WHILE (TRIPLES(I) & TRIPLE_OP_MASK) \u00ac= PEND;\n         IF (TRIPLES(I) & LINE#MASK) \u00ac= 0 THEN DO;\n            LINE# = LINE# + 1;\n            OUTPUT = X70 || 'SOURCE LINE ' || LINE#;\n         END;\n         ELSE IF (TRIPLES(I) & TRIPLE_OP_MASK) = LINE#TRIPLE THEN DO;\n            LINE# = TRIPLES(I + 1);\n            OUTPUT = X70 || 'SOURCE LINE ' || LINE#;\n         END;\n         CALL PRINT_TRIPLE(I);\n         I = I + 3;\n      END;\n      CALL PRINT_TRIPLE(I);\n\n END LIST_TRIPLES;\n\n LIST_SYMBOLIC_CODE: PROCEDURE;\n     /*    PROCEDURE TO PRINT OUT SYMBOLIC INSTRUCTIONS FROM CODE ARRAY  */\n\n      DECLARE (IC,OP) FIXED;\n      DECLARE (R1,R2,R3,L) BIT (8), (DISP1,DISP2) FIXED;\n      DECLARE LINE# BIT(16);\n      DECLARE PREFIX CHARACTER;\n\n      /*   ACTION IS A DECISION TABLE FOR THE VARIOUS TRIPLES WHICH\n           ENCODES THE SEMANTICS FOR PRINTING OUT A SYMBOLIC CODE LISTING  */\n\n      DECLARE ACTION (62) BIT(8) INITIAL (\n      3,3,3,3,3,0,3,3,3,3,3,3,3,2,3,2,2,3,3,3,\n      3,3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n      4,0,3,3,3,3,3,2,2,2,2,3,3,3,3,3,3,0,2,3,1,2);\n\n LIST_CODE: PROCEDURE;\n      DO WHILE IC < OP1;\n         OP = CODE(IC);\n         IF OPER(OP) < 256 THEN\n         OP_CODE = SUBSTR(OPNAMES,OPER(OP),4);\n         ELSE OP_CODE = SUBSTR(OPNAMES2,OPER(OP) - 256,4);\n      IF OP = \"00\" THEN DO;    /*  A CONSTANT    */\n         I = SHL(CODE(IC+2),8) + CODE(IC + 3);\n         OUTPUT = I_FORMAT(IC,8) || ': ' || 'DC' || X1 || 'F''' || I || '''';\n         IC = IC + 4;\n      END;   ELSE\n         IF OP < \"40\" THEN   /*  AN RR INSTRUCTION    */\n         DO;\n             R1 = SHR(CODE(IC + 1),4);\n             R2 = CODE(IC + 1) & \"0F\";\n             OUTPUT = I_FORMAT(IC,8) ||\n                            ': ' || OP_CODE || X1 || R1 || ',' || R2;\n             IC = IC + 2;\n         END;\n\n         ELSE IF OP < \"C0\" THEN   /*   AN RX OR RS INSTRUCTION     */\n         DO;\n             R1 = SHR(CODE(IC + 1),4);\n             R2 = CODE(IC + 1) & \"0F\";\n             R3 = SHR(CODE(IC + 2),4);\n             DISP1 = SHL(CODE(IC + 2) & \"0F\",8) + CODE(IC + 3);\n             OUTPUT = I_FORMAT(IC,8) ||\n                            ': ' || OP_CODE || X1 || R1 || ',' || DISP1\n                 || '(' || R2 || ',' || R3 || ')';\n             IC = IC + 4;\n         END;\n\n         ELSE     /*   AN SS INSTRUCTION    */\n         DO;\n             L = CODE(IC + 1);\n             R1 = SHR(CODE(IC + 2),4);\n             R2 = SHR(CODE(IC + 4),4);\n             DISP1 = SHL(CODE(IC + 2) & \"0F\",8) + CODE(IC + 3);\n             DISP2 = SHL(CODE(IC + 4) & \"0F\",8) + CODE(IC + 5);\n             OUTPUT = I_FORMAT(IC,8) ||\n                            ': ' || OP_CODE || X1 || DISP1 || '('\n                 || L || ',' || R1 || ')' || ',' || DISP2 || '(' || R2 || ')';\n             IC = IC + 6;\n         END;\n      END;\n END LIST_CODE;\n\n      PREFIX = SPACE 40X || 'LINE# ';\n      OUTPUT(1) = 1;\n      OUTPUT = SPACE 20 X || 'LISTING OF GENERATED CODE FOR PROCEDURE ' ||\n         PROC_NAME;\n      DOUBLE_SPACE;\n      IC = 0;\n      LINE# = TRIPLES(7);  /*  OP1 OF 1ST TRIPLE IS 1ST LINE #  */\n      OUTPUT = PREFIX || LINE#;\n      CURRENT_TRIPLE = 9;\n\n      DO FOREVER;\n         DO CASE ACTION(TRIPLES(CURRENT_TRIPLE) & TRIPLE_OP_MASK);\n            /*   CASE 0 - NO CODE TO PRINT   */\n               IF (TRIPLES(CURRENT_TRIPLE) & LINE#MASK) \u00ac= 0 THEN\n               DO;\n                  LINE# = LINE# + 1;\n                  OUTPUT = PREFIX || LINE#;\n               END;\n            /*   CASE 1 - LINE#TRIPLE  */\n               DO;\n                  LINE# = OP1;\n                  OUTPUT = PREFIX || LINE#;\n               END;\n            /*   CASE 2 - TRIPLES WHICH ARE PAIRED   */\n               DO;\n                  IF (TRIPLES(CURRENT_TRIPLE) & LINE#MASK) \u00ac= 0 THEN DO;\n                     LINE# = LINE# + 1;\n                     OUTPUT = PREFIX || LINE#;\n                  END;\n                  CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n                  CALL LIST_CODE;\n               END;\n            /*   CASE 3   */\n               DO;\n                  IF (TRIPLES(CURRENT_TRIPLE) & LINE#MASK) \u00ac= 0 THEN DO;\n                     LINE# = LINE# + 1;\n                     OUTPUT = PREFIX || LINE#;\n                  END;\n                  CALL LIST_CODE;\n               END;\n            /*   CASE 4 - PEND   */\n               RETURN;\n         END;   /*   CASE   */\n         CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n      END;\n\n END LIST_SYMBOLIC_CODE;\n\n\n\n\n   /*       C O D E   E M I S S I O N   P R O C E D U R E S          */\n\n EMIT_RR: PROCEDURE (OP, R1, R2);\n\n      DECLARE (OP, R1, R2) FIXED;\n\n      /* EMIT A 16-BIT RR FORMAT INSTRUCTION  */\n\n      IF CODE_INDEX + 2 > CODE_ARRAY_SIZE THEN CALL ERROR('CODE ARRAY\n      OVERFLOW');\n      #EMIT_RR = #EMIT_RR + 1;\n      CODE(CODE_INDEX) = OP;       /*   EMIT OP CODE     */\n      CODE(CODE_INDEX + 1) = SHL(R1,4) + R2;      /*  EMIT REGISTER OPERANDS  */\n      IF LIST_CODE THEN DO;\n         IF OPER(OP) < 256 THEN\n         OP_CODE = SUBSTR(OPNAMES, OPER(OP), 4);\n         ELSE OP_CODE = SUBSTR(OPNAMES2,OPER(OP) - 256,4);\n         OUTPUT  = X70 || CODE_INDEX || ': CODE = ' || OP_CODE || X1 || R1\n            || ',' || R2;\n      END;\n      CODE_INDEX = CODE_INDEX + 2;\n      INSTRUCTION(OP) = INSTRUCTION(OP) + 1;\n END EMIT_RR;\n\n EMIT_RX: PROCEDURE (OP,R1,R2,R3,DISP);\n\n      DECLARE (OP, R1,R2,R3,DISP) FIXED;\n\n   /*   EMIT A 32-BIT RX FORMAT INSTRUCTION   */\n\n      IF CODE_INDEX + 4 > CODE_ARRAY_SIZE THEN CALL ERROR('CODE ARRAY\n         OVERFLOW');\n      #EMIT_RX = #EMIT_RX + 1;\n      CODE(CODE_INDEX) = OP;      /*  EMIT OPERATION    */\n      CODE(CODE_INDEX + 1) = SHL(R1,4) + R2;         /*  EMIT REG OPERANDS   */\n      CODE(CODE_INDEX + 2) = SHL(R3,4) + SHR(DISP,8);   /*  EMIT ADDRESS   */\n      CODE(CODE_INDEX + 3) = DISP & \"FF\";            /*  IN BASE - DISP FORM */\n      IF LIST_CODE THEN DO;\n         IF OPER(OP) < 256 THEN\n         OP_CODE = SUBSTR(OPNAMES, OPER(OP), 4);\n         ELSE OP_CODE = SUBSTR(OPNAMES2,OPER(OP) - 256,4);\n         OUTPUT = X70 || CODE_INDEX || ': CODE = ' || OP_CODE || X1 || R1\n            || ',' || DISP || '(' || R2 || ',' || R3 || ')';\n      END;\n      CODE_INDEX = CODE_INDEX + 4;\n      INSTRUCTION(OP) = INSTRUCTION(OP) + 1;\n END EMIT_RX;\n\n\n\n EMIT_SS: PROCEDURE (OP,L,B1,DISP1,B2,DISP2);\n      DECLARE (OP,L,B1,DISP1,B2,DISP2) FIXED;\n     /*    EMIT A 48 BIT SS FORMAT INSTRUCTION      */\n\n      IF CODE_INDEX + 6 > CODE_ARRAY_SIZE THEN CALL ERROR ('CODE ARRAY\n         OVERFLOW');\n      #EMIT_SS = #EMIT_SS + 1;\n      CODE(CODE_INDEX) = OP;\n      CODE(CODE_INDEX + 1) = L;             /*    EMIT LENGTH CODE     */\n      CODE(CODE_INDEX + 2) = SHL(B1,4) + SHR(DISP1,8);    /*  FIRST  ADDR   */\n      CODE(CODE_INDEX + 3) = DISP1 & \"FF\";\n      CODE(CODE_INDEX + 4) = SHL(B2,4) + SHR(DISP2,8);    /*   2ND  ADDR */\n      CODE(CODE_INDEX + 5) = DISP2 & \"FF\";\n      IF LIST_CODE THEN DO;\n         IF OPER(OP) < 256 THEN\n         OP_CODE = SUBSTR(OPNAMES, OPER(OP), 4);\n         ELSE OP_CODE = SUBSTR(OPNAMES2,OPER(OP) - 256,4);\n         OUTPUT = X70 || CODE_INDEX || ': CODE = ' || OP_CODE || X1 ||\n            DISP1 || '(' || L || ',' || B1 || ')' || ',' || DISP2\n            || '(' || B2 || ')';\n      END;\n      CODE_INDEX = CODE_INDEX + 6;\n      INSTRUCTION(OP) = INSTRUCTION(OP) + 1;\n END EMIT_SS;\n\n      /*   THE OTHER INSTRUCTION FORMATS ARE USED SO INFREQUENTLY THAT\n           THEY ARE FUDGED USING THE RX_FORMAT                     */\n\n\n INSERT_2BYTE_CONSTANT: PROCEDURE (CODE_PTR,CONSTANT);\n      DECLARE (CODE_PTR,CONSTANT) BIT(16);\n      CODE(CODE_PTR) = SHR(CONSTANT,8) & \"FF\";\n      CODE(CODE_PTR + 1) = CONSTANT & \"FF\";\n      IF LIST_CODE THEN\n      OUTPUT = X70 || SPACE 5X || CODE_PTR || ': CONST = ' || CONSTANT;\n END INSERT_2BYTE_CONSTANT;\n\n\n\n\n       /*   R E G I S T E R  A L L O C A T I O N   P R O C E D U R E S  */\n\n\nSTORE_REG: PROCEDURE(REG#);\n     DECLARE REG# FIXED;\n     /* STORES A TEMP_REG INTO ITS TEMP LOCATION */\n      IF DISP (CONTENT(REG#) ) > 4095 THEN\n        /*   MULT OF 4096 NEEDED BUT CAN'T BE LOADED    */\n         CALL ERROR('NO MEANS OF FLUSHING TEMPORARY');\n      IF REG# <  #GP_REGS THEN        /*   GENERAL REGISTER    */\n         CALL EMIT_RX    (ST,REG#,0,STACKTOP,DISP (CONTENT (REG#) ) );\n         ELSE   /*   FLOATING POINT REGISTER    */\n           CALL EMIT_RX (STE,REG#-16,0,STACKTOP,DISP( CONTENT(REG#) ) );\n      #STORE_REG = #STORE_REG + 1;\nEND STORE_REG;\n\n FREE_REG: PROCEDURE (REG#);\n\n      DECLARE REG# FIXED;\n\n      PRIORITY(REG#) = FREE_PRIORITY;\n      IF CONTENT (REG#) \u00ac= NULL THEN DO;\n         REG (CONTENT(REG#) ) = NULL;\n         CONTENT (REG#) = NULL;\n      END;\n END FREE_REG;\n\nFLUSH_REG: PROCEDURE(REG#);\n     DECLARE REG# FIXED;\n\n     DO CASE PRIORITY(REG#);\n          ;  /* FREE PRIORITY NOTHING TO DO */\n          CALL FREE_REG(REG#);  /* BASE PRIORITY  JUST MARK FREED  */\n          DO;  /*  TEMP PRIORITY  SAVE IT THEN MARK FREED  */\n               CALL STORE_REG(REG#);\n               CALL FREE_REG(REG#);\n          END;\n     CALL ERROR ('ATTEMPT TO FREE A FIXED PRIORITY REG: ' || REG#);\n     END;\n      #FLUSH_REG = #FLUSH_REG + 1;\nEND FLUSH_REG;\n\n LRU_REG_OF_PRIORITY: PROCEDURE(REG_PRIORITY,LOWER_REG,UPPER_REG) FIXED;\n\n      /*  RETURNS THE LEAST RECENTLY USED REG OF THE GIVEN PRIORITY IN THE GIVEN\n          RANGE         */\n\n      DECLARE (REG_PRIORITY,LOWER_REG,UPPER_REG,LRU_REG,LRU_USE,REG#) BIT(16);\n\n      LRU_USE = CODE_ARRAY_SIZE;\n      DO REG# = LOWER_REG TO UPPER_REG;\n         IF PRIORITY(REG#) = REG_PRIORITY & USE(REG#) < LRU_USE THEN\n         DO;\n            LRU_USE = USE(REG#);\n            LRU_REG = REG#;\n         END;\n      END;\n      CALL FLUSH_REG (LRU_REG);\n      RETURN(LRU_REG);\n\n END LRU_REG_OF_PRIORITY;\n\n\n GET_FLT_REG: PROCEDURE(REG_PRIORITY) FIXED;\n\n      DECLARE (REG#,REG_PRIORITY,LOWEST_PRIORITY) BIT(16);\n\n      LOWEST_PRIORITY = PRIORITY(16);\n      DO REG# = 16 TO 22 BY 2;\n         IF PRIORITY(REG#) = FREE_PRIORITY THEN\n         DO;\n            PRIORITY(REG#) = REG_PRIORITY;\n            RETURN (REG#);\n         END;\n         ELSE IF PRIORITY(REG#) < LOWEST_PRIORITY THEN\n            LOWEST_PRIORITY = PRIORITY(REG#);\n      END;\n      /*  RETURN HIGHER IF A FREE REG WAS AVAILABLE; OTHERWISE FLUSH OUT A REG*/\n      REG# = LRU_REG_OF_PRIORITY(LOWEST_PRIORITY,16,22);\n      PRIORITY(REG#) = REG_PRIORITY;\n      RETURN(REG#);\n\n END GET_FLT_REG;\n\n\n\n\n\n\n\n\nGET_REG: PROCEDURE(REG_PRIORITY) FIXED;\n      DECLARE (REG_PRIORITY,REG#,REG_CHOSEN,LOW_REG) BIT(16);\n\n\n      REG_CHOSEN,REG# = 1;\n      DO WHILE ( PRIORITY(REG#) \u00ac= FREE_PRIORITY ) & REG_CHOSEN <= HI_REG;\n         IF PRIORITY(REG_CHOSEN) < PRIORITY(REG#) THEN REG# = REG_CHOSEN;\n         REG_CHOSEN = REG_CHOSEN + 1;\n      END;\n      IF REG_PRIORITY \u00ac= BASE_PRIORITY THEN DO;\n         IF PRIORITY(0) < PRIORITY(REG#) THEN REG# = 0;\n         LOW_REG = 1;\n      END;\n      ELSE LOW_REG = 0;\n\n     /* NOW THE REG CHOSEN IS IN REG#  */\n      DO CASE PRIORITY(REG#);\n         ;   /*  FREE PRIORITYFOUND. DO NOTHING     */\n         REG# = LRU_REG_OF_PRIORITY(BASE_PRIORITY,LOW_REG,10);\n         REG# = LRU_REG_OF_PRIORITY(TEMP_PRIORITY,LOW_REG,10);\n         CALL ERROR (' CANNOT FIND A NON FIXED PRIORITY REG');\n      END;\n      PRIORITY(REG#) = REG_PRIORITY;\n      #GET_REG = #GET_REG + 1;\n      RETURN(REG#);\nEND GET_REG;\n\n\n ASSIGN_TEMP: PROCEDURE (REG#);\n\n      DECLARE REG# FIXED;\n\n      IF NEXT_TEMP > MAX_TEMP THEN CALL ERROR('TEMP STACK OVERFLOW');\n      DISP(NEXT_TEMP) = NEXT_TEMP_DISPL;\n      PSEUDO_REG (NEXT_TEMP) = STACKTOP_PSEUDO_REG;\n      STORAGE_LENGTH(NEXT_TEMP) = 4;\n      REG (NEXT_TEMP) = REG#;\n      CONTENT (REG#) = NEXT_TEMP;\n      USE(REG#) = CODE_INDEX;\n      NEXT_TEMP_DISPL = NEXT_TEMP_DISPL + 4;\n      IF NEXT_TEMP_DISPL > MAX_TEMP_DISPL THEN MAX_TEMP_DISPL = NEXT_TEMP_DISPL;\n      NEXT_TEMP = NEXT_TEMP + 1;\n END ASSIGN_TEMP;\n\n\n REASSIGN_TEMP: PROCEDURE(REG#,TEMP_PTR);\n      /*   USED FOR RE-ASSIGNING A REG TO A TEMPORARY AFTER THE TEMP\n          HAS BEEN FORCED INTO A REGISTER                   */\n      DECLARE (REG#,TEMP_PTR) BIT(16);\n      REG(TEMP_PTR) = REG#;\n      CONTENT(REG#) = TEMP_PTR;\n      USE(REG#) = CODE_INDEX;\n      PRIORITY(REG#) = TEMP_PRIORITY;\n END REASSIGN_TEMP;\n\n GET_TEMP_BYTES: PROCEDURE (#BYTES);\n      DECLARE #BYTES BIT(16);\n\n      IF NEXT_TEMP > MAX_TEMP THEN CALL ERROR('TEMP STACK OVERFLOW');\n      DISP(NEXT_TEMP) = NEXT_TEMP_DISPL;\n      STORAGE_LENGTH(NEXT_TEMP) = #BYTES;\n      PSEUDO_REG(NEXT_TEMP) = STACKTOP_PSEUDO_REG;\n      /*   ROUND #BYTES TO A MULT OF 4 TO MAINTAIN FULLWORD ALLIGNMENT   */\n      #BYTES = (#BYTES + 3 ) & \"FFFFFFFC\";\n      NEXT_TEMP_DISPL = NEXT_TEMP_DISPL + #BYTES;\n      IF NEXT_TEMP_DISPL > MAX_TEMP_DISPL THEN MAX_TEMP_DISPL = NEXT_TEMP_DISPL;\n      NEXT_TEMP = NEXT_TEMP + 1;\n END GET_TEMP_BYTES;\n\n FREE_TEMP: PROCEDURE (TEMP);\n\n      DECLARE TEMP FIXED;\n\n\n      #FREE_TEMP = #FREE_TEMP + 1;\n      IF REG(TEMP) \u00ac= NONE THEN CALL FREE_REG(REG(TEMP) );\n      IF TEMP = NEXT_TEMP - 1 THEN   /*  TOP TEMP; FREE ALL TEMPS BELOW      */\n      DO;                            /*  WHICH ARE MARKED FREE     */\n         NEXT_TEMP = NEXT_TEMP - 1;\n         NEXT_TEMP_DISPL = DISP(TEMP);\n         DO WHILE PSEUDO_REG(LAST_TEMP) = MARKED_FREE;\n            NEXT_TEMP_DISPL = DISP(LAST_TEMP);\n            NEXT_TEMP = LAST_TEMP;\n         END;\n      END;\n      ELSE     /*    JUST MARK FREE         */\n      PSEUDO_REG(TEMP) = MARKED_FREE;\n\n END FREE_TEMP;\n\n\n\n      /*   NEXT_TEMP_DISPL_STACK IS USED TO RETAIN THE VALUE OF\n           NEXT_TEMP_DISPL DURING A PROCEDURE CALL    */\n PUSH_NEXT_TEMP_DISPL: PROCEDURE;\n      NEXT_TEMP_DISPL_STACK(TEMP_DISPL_STACKTOP) = NEXT_TEMP_DISPL;\n      TEMP_DISPL_STACKTOP = TEMP_DISPL_STACKTOP + 1;\n END PUSH_NEXT_TEMP_DISPL;\n\n POP_NEXT_TEMP_DISPL: PROCEDURE;\n      TEMP_DISPL_STACKTOP = TEMP_DISPL_STACKTOP - 1;\n      NEXT_TEMP_DISPL = NEXT_TEMP_DISPL_STACK(TEMP_DISPL_STACKTOP);\n      IF TEMP_DISPL_STACKTOP \u00ac= 0 THEN AR_OFFSET = NEXT_TEMP_DISPL_STACK\n         (TEMP_DISPL_STACKTOP - 1); ELSE AR_OFFSET = NEXT_TEMP_DISPL;\n END POP_NEXT_TEMP_DISPL;\n\n   /*   MAPS A REG PRIORITY TO A CLASS# SUCH THAT THE CLASS OF A REG PAIR\n        (SUM OF THE CLASS#S) IS UNIQUE FOR THE PRIORITIES               */\n\n      DECLARE CLASSIFY_REG(3) BIT(16) INITIAL (0,1,3,7);\n\n\nGET_REG_PAIR: PROCEDURE FIXED;\n\n     /* RETURNS THE # OF AN EVEN REG OF AN ODD EVEN PAIR  AVAILABLE FOR USE */\n\n     DECLARE (TRY_REG,REG_CLASS,EVEN_REG,CLASS) FIXED;\n\n     REG_CLASS = CLASSIFY_REG(PRIORITY(8) ) + CLASSIFY_REG (PRIORITY(9) );\n     EVEN_REG,TRY_REG = 8;\n\n          /* LOOK FOR BEST PAIR TO GET   */\n\n      DO WHILE TRY_REG > 2 & REG_CLASS \u00ac= 0;\n          TRY_REG=TRY_REG - 2;\n         CLASS = CLASSIFY_REG(PRIORITY(TRY_REG) ) +\n                   CLASSIFY_REG (PRIORITY (TRY_REG + 1 ) );\n          IF CLASS<REG_CLASS THEN DO;\n               EVEN_REG=TRY_REG;\n               REG_CLASS=CLASS;\n          END;\n     END;\n\n    /****   OPTIMIZE LATER BY ATTEMPTING TO REASSIGNING TEMPS TO LOWER\n      PRIORITY REGS RATHER THAN GENERATE STORE INSTRUCTIONS      */\n     CALL FLUSH_REG(EVEN_REG);\n     CALL FLUSH_REG(EVEN_REG+1);\n     RETURN(EVEN_REG);\nEND GET_REG_PAIR;\n\n\n FLUSH_ALL_TEMP_REGS: PROCEDURE;\n      DECLARE (REG_PTR,TEMP_REG) BIT(16);\n\n      #FLUSH_ALL_TEMP_REGS = #FLUSH_ALL_TEMP_REGS + 1;\n\n           /*  FLUSH ALL FLOATING POINT REGS      */\n      DO I = 16 TO 22 BY 2;\n         IF PRIORITY(I) = TEMP_PRIORITY THEN CALL FLUSH_REG(I);\n      END;\n    /*  FLUSH ALL TEMP GENERAL REGS. OPTIMIZE BY SEEKING CONSECUTIVE TEMP\n      PRIORITY REGS ASSIGNED TO CONTIGUOUS TEMP STORAGE & EMITTING STM\n      RATHER THAN INDIVIDUAL STORES.                */\n      REG_PTR = 0;\n      DO FOREVER;\n         DO WHILE PRIORITY(REG_PTR) \u00ac= TEMP_PRIORITY & REG_PTR <= 10;\n             REG_PTR = REG_PTR + 1;\n         END;\n         IF REG_PTR <= HI_REG THEN\n         DO;\n             TEMP_REG = REG_PTR;\n             REG_PTR = REG_PTR + 1;\n             DO WHILE DISP(CONTENT(REG_PTR)) = DISP(CONTENT(REG_PTR-1)) + 4\n                & PRIORITY(REG_PTR) = TEMP_PRIORITY;\n                REG_PTR = REG_PTR + 1;\n             END;\n             IF TEMP_REG < REG_PTR - 1 THEN\n             DO;\n                CALL EMIT_RX(STM,TEMP_REG,REG_PTR-1,STACKTOP,\n                   DISP(CONTENT(TEMP_REG) ) );\n                #STM_FLUSHES = #STM_FLUSHES + 1;\n             END;\n                ELSE CALL EMIT_RX(ST   ,TEMP_REG,0,STACKTOP,\n                   DISP(CONTENT(TEMP_REG) ) );\n             DO TEMP_REG = TEMP_REG TO REG_PTR - 1;\n                CALL FREE_REG(TEMP_REG);\n             END;\n         END;\n         ELSE RETURN;\n      END;\n END FLUSH_ALL_TEMP_REGS;\n\n FLUSH_ALL_REGS: PROCEDURE;\n      CALL FLUSH_ALL_TEMP_REGS;\n      /*  FREE REMAINING FP REGS       */\n      DO I = 16 TO 22 BY 2;\n         CALL FREE_REG(I);\n      END;\n      DO I = 0 TO HI_REG;\n         CALL FREE_REG(I);\n      END;\n\n END FLUSH_ALL_REGS;\n\n\n\n\n\n      /*      A D D R E S S A B I L I T Y   P R O C E D U R E S         */\n\n MASK: PROCEDURE (OP);\n      DECLARE OP FIXED;\n      RETURN ( SHR(OP,14) & \"3\" );\n END MASK;\n\n\n\n IS_TRIPLE: PROCEDURE (OPERAND,INSTRUCTION) BIT(1);\n\n      /*  FUNCTION TO TEST WHETHER GIVEN OPERAND IS A TRIPLE OF THE\n          GIVEN TYPE.                     */\n\n      DECLARE (OPERAND,INSTRUCTION ) BIT(16);\n\n      IF OPERAND >= 0 THEN RETURN(FALSE);     /*  MASK NOT 10 OR 11   */\n      ELSE RETURN (TRIPLES(OPERAND & STRIPMASK) & TRIPLE_OP_MASK) = INSTRUCTION;\n\n END IS_TRIPLE;\n\n IMMED: PROCEDURE (OPERAND) BIT(1);\n      DECLARE OPERAND BIT(16);\n      RETURN ( (SHR(OPERAND,14) & \"3\" ) = 1 );\n END IMMED;\n\n\n CHECK_MULT_OF_4096: PROCEDURE;\n\n      /*  IF DISPL > 4095 THEN ASSIGNS X_REG TO A MULT OF 4096, GENERATES\n          THE LOAD, RESETS DISPL APPROPRIATELY                   */\n\n      DECLARE (MULT,MULT_PTR) FIXED;\n\n      IF DISPL < 4096 THEN X_REG = 0;\n      ELSE   /*  MULT OF 4096 REQUIRED   */\n      DO;\n         MULT = DISPL / 4096;\n         DISPL = DISPL MOD 4096;\n         MULT_PTR = MULT_OF_4096_TABLE_BASE + MULT;\n         IF REG(MULT_PTR) \u00ac= NULL THEN X_REG = REG(MULT_PTR);\n         ELSE DO;    /*  MUST LOAD A REG WITH THE MULT     */\n             X_REG = GET_REG(BASE_PRIORITY);\n             CALL EMIT_RX(LOAD,X_REG,0,ORG,MULT_OF_4096_BASE + MULT * 4 );\n             REG(MULT_PTR) = X_REG;\n             CONTENT(X_REG) = MULT_PTR;\n         END;\n         USE(X_REG) = CODE_INDEX;\n      END;\n\n END CHECK_MULT_OF_4096;\n\n RESET_ADDR_REG_PRIORITIES: PROCEDURE (BASE_REG,X_REG);\n\n      DECLARE (BASE_REG,X_REG) BIT(16);\n\n      IF  ( BASE_REG <= HI_REG ) & ( BASE_REG \u00ac= 0 ) THEN\n      DO;\n         IF CONTENT(BASE_REG) = NULL THEN\n             PRIORITY(BASE_REG) = FREE_PRIORITY;\n         ELSE DO;\n            IF CONTENT (BASE_REG)>= BASE_TEMP & CONTENT(BASE_REG) <= MAX_TEMP\n            THEN PRIORITY(BASE_REG) = TEMP_PRIORITY;\n            ELSE PRIORITY(BASE_REG) = BASE_PRIORITY;\n         END;\n      END;\n      IF ( X_REG <= HI_REG ) & ( X_REG \u00ac= 0 ) THEN\n      DO;\n         IF CONTENT(X_REG) = NULL THEN PRIORITY(X_REG) = FREE_PRIORITY;\n         ELSE DO;\n            IF CONTENT (   X_REG)>= BASE_TEMP & CONTENT(   X_REG) <= MAX_TEMP\n            THEN PRIORITY(X_REG) = TEMP_PRIORITY;\n            ELSE PRIORITY(X_REG) = BASE_PRIORITY;\n         END;\n      END;\n END RESET_ADDR_REG_PRIORITIES;\n\n      DECLARE RESET_BASE_REG_PRIORITIES LITERALLY\n         'RESET_ADDR_REG_PRIORITIES(BASE_REG,X_REG)';  /*  RESET GLOBAL\n         ADDRESSING  VALUES        */\n\n GET_OP_INTO_REG: PROCEDURE (REG_PRIORITY);\n\n      /*  GETS THE ADDRESSED OPERAND INTO A REG (DENOTED BY ACC ) OF\n          THE GIVEN PRIORITY.                                    */\n\n      /*  A CALL WITH REG_PRIORITY = FREE_PRIORITY IMPLIES THE REGISTER\n          CONTENT WILL NOT BE CHANGED BY THE CURRENT USAGE.  OTHERWISE\n      /*  IF ALREADY IN A REGISTER, MAKE SURE THAT REG HAS BEEN FREED\n          BY MAKE_ADDRESSABLE, OTHERWISE, LATER USES OF THE REG MAY BE INCORRECT\n          IF THE CONTENTS ARE CHANGED BY  THE CURRENT USAGE. IF ACC IS NOT FREE,\n          THEN GET ITS CONTENTS INTO ANOTHER REG & RETURN THAT REG IN ACC.  */\n\n\n      DECLARE REG_PRIORITY FIXED;\n\n      IF IN_REG THEN\n      DO;\n         IF REG_PRIORITY = FREE_PRIORITY THEN RETURN;\n         IF PRIORITY(ACC) \u00ac= FREE_PRIORITY THEN\n         DO;\n            ACC1 = GET_REG(REG_PRIORITY);\n            IF ACC \u00ac= ACC1 THEN CALL EMIT_RR(LR,ACC1,ACC);\n            ACC = ACC1;\n         END;\n         ELSE PRIORITY(ACC) = REG_PRIORITY;\n      END;\n\n\n\n      ELSE\n      IF OP_STORAGE_LENGTH = 1 THEN\n      /*  IN THIS CASE CARE MUST BE TAKEN NOT TO EMPLOY THE SAME\n          REGISTER AS ONE OF THE ADDRESS REGISTERS     */\n\n      DO;\n         FIX_BASE_REG_PRIORITIES;\n         ACC = GET_REG(REG_PRIORITY);\n         CALL EMIT_RR (SR,ACC,ACC);\n         CALL EMIT_RX(IC,ACC,X_REG,BASE_REG,DISPL);\n         CALL RESET_BASE_REG_PRIORITIES;\n      END;\n      ELSE DO;\n         ACC = GET_REG(REG_PRIORITY);\n         IF IMMEDIATE THEN DO;\n            IF DISPL = 0 THEN CALL EMIT_RR(SR,ACC,ACC);\n                   ELSE CALL EMIT_RX(LA,ACC,0,0,DISPL);\n         END;\n      ELSE IF OP_STORAGE_LENGTH = 2 THEN\n            CALL EMIT_RX(LH,ACC,X_REG,BASE_REG,DISPL);\n      ELSE   /*  FULLWORD   */   CALL EMIT_RX(LOAD,ACC,X_REG,BASE_REG,DISPL);\n      END;\n      IN_REG = TRUE;\n      IF REG_PRIORITY = FREE_PRIORITY & OP_MASK = TEMP_MASK THEN\n      /*  THE OPERAND IS A TEMPORARY WHICH WILL BE REFERENCED AGAIN.\n          ASSIGN ACC TO THE TEMPORARY, SO FOR SUBSEQUENT REFERENCES THE OPERAND\n          WILL ALREADY BE IN A REG          */\n         CALL REASSIGN_TEMP(ACC,TEMP);\n\n END GET_OP_INTO_REG;\n\n\n FORCE_INTO_BASE_REG: PROCEDURE;\n      /*  FORCES THE GIVEN OPERAND INTO A NON-ZERO REGISTER IF NOT ALREADY   */\n\n      IF IN_REG THEN    /*  IN ACC  */\n      DO;\n         IF ACC = 0 THEN\n         DO;\n            BASE_REG = GET_REG(BASE_PRIORITY);\n            CALL EMIT_RR(LR,BASE_REG,ACC);\n         END;\n         ELSE BASE_REG = ACC;\n      END;\n      ELSE\n      DO;   /*  MUST GET INTO A REGISTER   */\n         CALL GET_OP_INTO_REG(BASE_PRIORITY);\n         BASE_REG = ACC;\n      END;\n\n      X_REG = 0;\n      DISPL = 0;\n END FORCE_INTO_BASE_REG;\n\n\n LOAD_ADDRESS: PROCEDURE;\n\n      /*   LOADS THE ADDRESS OF THE ADDRESSED OPERAND INTO A SUITABLE REG */\n         IF ( BASE_REG > HI_REG ) | ( CONTENT(BASE_REG) \u00ac= NULL )\n            THEN   /*  DBR OR MULT OF 4096 OR TEMP   */\n         DO;\n            BASE = GET_REG(BASE_PRIORITY);\n            IF DISPL = 0 & X_REG = 0 THEN\n              CALL EMIT_RR(LR,BASE,BASE_REG);  ELSE\n            CALL EMIT_RX(LA,BASE,X_REG,BASE_REG,DISPL);\n            BASE_REG = BASE;\n            PRIORITY(BASE_REG) = FREE_PRIORITY;\n         END;\n         ELSE DO;\n            IF X_REG = 0 & DISPL = 0 THEN RETURN;\n            ELSE CALL EMIT_RX(LA,BASE_REG,X_REG,BASE_REG,DISPL);\n         END;\n         X_REG = 0;\n         DISPL = 0;\n END LOAD_ADDRESS;\n\n MAKE_OP_ADDRESSABLE: PROCEDURE(OPERAND);\n\n      DECLARE (OPERAND,DBR_PTR ) FIXED;\n\n      #MAKE_OP_ADDR = #MAKE_OP_ADDR + 1;    /*****/\n\n      OP_MASK = MASK(OPERAND);\n      DO CASE OP_MASK;\n\n         /*  SYMBOL TABLE POINTER  */\n      DO;\n         IMMEDIATE, IN_REG, IN_FREE_REG = FALSE;\n         OP_STORAGE_LENGTH = STORAGE_LENGTH(OPERAND);\n         IF PSEUDO_REG(OPERAND) = 0 THEN BASE_REG = GLOBAL_AR_BASE;\n         ELSE IF PSEUDO_REG(OPERAND) = CURRENT_LEVEL - 1 THEN\n            BASE_REG = CURRENT_AR_BASE;\n         ELSE\n         DO;\n            DBR_PTR = PSEUDO_REG (OPERAND ) + DBR_TABLE_BASE;\n            IF REG(DBR_PTR) = NONE THEN\n            DO;\n                BASE_REG = GET_REG(BASE_PRIORITY);\n                CONTENT(BASE_REG) = DBR_PTR;\n                REG(DBR_PTR) = BASE_REG;\n                CALL EMIT_RX(LOAD,BASE_REG,0,CURRENT_AR_BASE,16 +\n                  PSEUDO_REG(OPERAND) * 4 );   /*  LOAD FROM DISPLAY   */\n            END;\n            ELSE BASE_REG = REG(DBR_PTR);\n            DISPL = DISP(OPERAND);\n            PRIORITY(BASE_REG) = FIXED_PRIORITY;\n            CALL CHECK_MULT_OF_4096;\n            PRIORITY(BASE_REG) = BASE_PRIORITY;\n            USE(BASE_REG) = CODE_INDEX;\n            RETURN;\n         END;\n\n         DISPL = DISP(OPERAND);\n         CALL CHECK_MULT_OF_4096;\n      END;\n\n         /*  IMMEDIATE OPERAND   */\n      DO;\n         BASE_REG = 0;\n         X_REG = 0;\n         DISPL = OPERAND & STRIPMASK;\n         OP_STORAGE_LENGTH = 0;\n         IMMEDIATE = TRUE;\n         IN_REG,IN_FREE_REG = FALSE;\n      END;\n\n         /*   TRIPLE POINTER. TEMPORARY TO BE FREED        */\n      DO;\n         TEMP = TRIPLES ( (OPERAND & STRIPMASK) + 2 );\n         OP_STORAGE_LENGTH = STORAGE_LENGTH(TEMP);\n         IF REG(TEMP) = NONE THEN\n         DO;\n            BASE_REG = STACKTOP;\n            DISPL = DISP(TEMP);\n            CALL CHECK_MULT_OF_4096;\n            IN_REG,IN_FREE_REG = FALSE;\n         END;\n         ELSE\n         DO;\n            IN_REG = TRUE;\n            IN_FREE_REG = TRUE;\n            ACC = REG(TEMP);\n         END;\n         IMMEDIATE = FALSE;\n         CALL FREE_TEMP(TEMP);\n      END;\n\n         /*   TRIPLE POINTER. TEMP NOT TO BE FREED: MORE REFERENCES FOLLOW  */\n\n      DO;\n         TEMP = TRIPLES ( (OPERAND & STRIPMASK) + 2 );\n         OP_STORAGE_LENGTH = STORAGE_LENGTH(TEMP);\n         IF REG(TEMP) = NONE THEN\n         DO;\n            BASE_REG = STACKTOP;\n            DISPL = DISP(TEMP);\n            CALL CHECK_MULT_OF_4096;\n            IN_REG = FALSE;\n         END;\n         ELSE\n         DO;\n            IN_REG = TRUE;\n            ACC = REG(TEMP);\n            USE(ACC) = CODE_INDEX;   /*  UPDATE REG USE COLUMN   */\n         END;\n         IN_FREE_REG,IMMEDIATE = FALSE;\n      END;\n\n      END;   /*  CASE  */\n END MAKE_OP_ADDRESSABLE;\n\n MAKE_INDEX_OP_ADDRESSABLE: PROCEDURE (OPERAND);\n\n      DECLARE INDEX_STACK_SIZE LITERALLY '20',\n              OPERAND BIT(16),\n              (ACC1,DISPL1) BIT(16),\n              ADDR_TEMP BIT(16) INITIAL (62),\n              INDEX_STACK (INDEX_STACK_SIZE) BIT(16),\n              INDEX_OP_STACK (INDEX_STACK_SIZE) BIT(16),  /* INDICATES\n                   WHETHER AN INDEX TRIPLE IS A FIRST OR 2ND OPERAND    */\n              INDEX_STACKTOP BIT(16),\n              LAST_INDEX_TRIPLE BIT(16),  /*  INDICATES LAST TRIPLE UNSTACKED */\n              LAST_INDEX_OP BIT(16), /* INDICATES WHETHER LAST TRIPLE\n                   UNSTACKED WAS A FIRST OR 2ND OPERAND.           */\n              FIRST_OP BIT(16) INITIAL (1),\n              SECOND_OP BIT(16) INITIAL (2),\n              ( XOP1,XOP2 ) BIT(16);   /*  LOCAL POINTERS TO TRIPLE OPERANDS */\n\n PUSH_ONTO_INDEX_STACK: PROCEDURE (OPERAND,OP_POSITION);\n      DECLARE (OPERAND,OP_POSITION) BIT(16);\n\n      INDEX_STACKTOP = INDEX_STACKTOP + 1;\n      IF INDEX_STACKTOP > INDEX_STACK_SIZE THEN\n         CALL ERROR('INDEX STACK OVERFLOW');\n      INDEX_STACK(INDEX_STACKTOP) = OPERAND & STRIPMASK;\n      INDEX_OP_STACK(INDEX_STACKTOP) = OP_POSITION;\n      LAST_INDEX_OP = NULL;\n      OPERAND = OPERAND & STRIPMASK;\n\n END PUSH_ONTO_INDEX_STACK;\n\nPOP_INDEX_TRIPLE: PROCEDURE;\n      /*   UNSTACKS THE LAST INDEX TRIPLE, SETS THE VALUE OF LAST_INDEX_TRIPLE,\n      LAST_INDEX_OP, AND THE GLOBALS IN_REG, IMMEDIATE,OP_STORAGE_LENGTH  */\n\n      LAST_INDEX_TRIPLE = INDEX_STACK(INDEX_STACKTOP);\n         OP_STORAGE_LENGTH = SHR (TRIPLES(LAST_INDEX_TRIPLE),8 ) + 1;\n      IN_REG = FALSE;\n      IN_FREE_REG = FALSE;\n      IMMEDIATE = FALSE;\n      LAST_INDEX_OP = INDEX_OP_STACK(INDEX_STACKTOP);\n      INDEX_STACKTOP = INDEX_STACKTOP - 1;\n\n END POP_INDEX_TRIPLE;\n\n\n GENERATE_XREG_BASEREG: PROCEDURE;\n\n\n      /*   WHEN CALLED, LAST_INDEX_OP = SECOND_OP; THUS, BASE_REG, X_REG, (ACC),\n           DISPL WILL ADDRESS THE SECOND OPERAND OF THE TRIPLE ON TOP OF THE\n           INDEX STACK. GET THE CONTENTS INTO AN INDEX REG,CALL IT X_REG1.\n           FIX ITS PRIORITY.\n           THEN MAKE THE FIRST OPERAND ADDRESSABLE, REMOVING INDEXING\n           IF ANY.   ASSIGN X_REG = X_REG1;  THEN X_REG, BASE_REG,\n           DISPL WILL ADDRESS THE TOP TRIPLE                  */\n\n\n      CALL GET_OP_INTO_REG(BASE_PRIORITY);\n      X_REG1 = ACC;\n      PRIORITY(X_REG1) = FIXED_PRIORITY;\n      CALL MAKE_OP_ADDRESSABLE(XOP1);\n      IF IS_TRIPLE(XOP1,ADDR_TEMP) THEN /*   ADDRESS IS IN A TEMPORARY  */\n         CALL FORCE_INTO_BASE_REG;\n      ELSE IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n      IF IMMEDIATE THEN BASE_REG = X_REG1;   /*  IF IMMED THEN MUST BE 0  */\n      ELSE X_REG = X_REG1;\n      CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,X_REG1);\n\n END GENERATE_XREG_BASEREG;\n\n\n      /*  WHEN CALLED, LAST_INDEX_OP = FIRST_OP OR NULL. IF NU L, THEN\n          FIRST OPERAND MUST BE MADE ADDRESSABLE; OTHERWISE, IT ALREADY IS.\n          REMOVE INDEXING, GET THE SECOND OPERAND INTO A REGISTER CALLED X_REG.\n          NOW BASE_REG, X_REG, DISPL WILL ADDRESS THE TOP TRIPLE       */\n\n\n GENERATE_BASEREG_XREG: PROCEDURE;\n\n      IF LAST_INDEX_OP = NULL THEN /* BASE_REG,X_REG,DISPL MUST BE\n         SET BY MAKE_OP_ADDRESSABLE; OTHERWISE, THESE ALREADY ADDRESS\n         AN INDEX TRIPLE                      */\n      DO;\n         CALL MAKE_OP_ADDRESSABLE(XOP1);\n         IF IMMEDIATE THEN\n         DO;\n            IF DISPL \u00ac= 0 THEN CALL ERROR('ATTEMPT TO INDEX IMMED OP OTHER\n THAN 0');\n            CALL MAKE_OP_ADDRESSABLE(XOP2);\n            CALL FORCE_INTO_BASE_REG;\n            RETURN;\n         END;\n         ELSE IF IS_TRIPLE(XOP1,TEMP_TRIPLE) THEN /*  ADDR IN A TEMP   */\n            CALL FORCE_INTO_BASE_REG;\n      END;\n\n      IF IMMED (XOP2) THEN\n      DO;\n         IF DISPL + (XOP2  & STRIPMASK) > 4095 THEN CALL LOAD_ADDRESS;\n         DISPL = DISPL + (XOP2 & STRIPMASK);\n         CALL RESET_BASE_REG_PRIORITIES;\n         RETURN;\n      END;\n\n      IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n      BASE_REG1 = BASE_REG;           /*  SAVE BASE_REG & DISPL     */\n      DISPL1 = DISPL;\n      PRIORITY(BASE_REG) = FIXED_PRIORITY;\n      CALL MAKE_OP_ADDRESSABLE(XOP2);\n      CALL FORCE_INTO_BASE_REG;\n      X_REG = BASE_REG;\n      BASE_REG = BASE_REG1;\n      DISPL = DISPL1;\n      CALL RESET_BASE_REG_PRIORITIES;\n     /*  NOW BASE_REG,X_REG,DISPL ADDRESS THE INDEX TRIPLE         */\n END GENERATE_BASEREG_XREG;\n\n CONVERT_TO_TEMP: PROCEDURE;\n      /*   CONVERTS THE ADDRESSED INDEX TRIPLE TO A TEMPORARY SO THAT\n          IT CAN BE REFERENCED AGAIN.                        */\n\n      IF OP_STORAGE_LENGTH <= 4 THEN DO;\n         CALL GET_OP_INTO_REG(TEMP_PRIORITY);\n         CALL ASSIGN_TEMP(ACC);\n      END;\n      TRIPLES(LAST_INDEX_OP + 2) = LAST_TEMP;\n      /*  CONVERT THE TRIPLE CODE TO TEMP_TRIPLE, PRESERVING THE\n         LINE_NUM BIT         */\n      TRIPLES(LAST_INDEX_OP) = TEMP_TRIPLE + (TRIPLES(LAST_INDEX_OP) & \"80\");\n\n END CONVERT_TO_TEMP;\n\n\n\n      /*  KEEP STACKING FIRST OPERANDS OF AN INDEX TRIPLE WHICH ARE\n          THEMSELVES INDEX TRIPLES. AT SOME POINT, THE ADDRESS OF THE\n          FIRST OPERAND CAN BE GENERATED BY MAKE_OP_ADDRESSABLE. ANY\n          INDEXING IS THEN REMOVED BY LOADING THE ADDRESS INTO A BASE REG\n                        WE THEN PROCEED TO EVALUATE THE SECOND OPERAND:\n          IF THE SECOND OPERAND IS A CHAIN OF INDEX TRIPLES, THEY ARE\n          STACKED IN A SIMILAR MANNER AS ABOVE.\n          WHEN THE ADDRESS OF THE SECOND OPERAND IS FINALLY KNOWN, IT IS\n          DE-REFERENCED, ITS  C O N T E N T S  LOADED INTO AN INDEX REGISTER.\n          THE INDEX STACK IS THEN POPPED; BASE_REG,X_REG,DISPL WILL\n          ADDRESS THE TRIPLE JUST PROCESSED. WHEN ALL TRIPLES ARE UNSTACKED,\n          BASE_REG,X_REG,DISPL WILL ADDRESS THE WHOLE CHAIN, I.E. , THE\n          ORIGINAL OPERAND PASSED TO MAKE_ADDRESSABLE.             */\n\n\n      CALL PUSH_ONTO_INDEX_STACK(OPERAND);\n      DO WHILE INDEX_STACKTOP \u00ac= 0;\n         XOP1 = TRIPLES (INDEX_STACK(INDEX_STACKTOP) + 1 );\n         XOP2 = TRIPLES (INDEX_STACK(INDEX_STACKTOP) + 2 );\n         IF IS_TRIPLE (XOP1,INDEX) & (LAST_INDEX_OP = NULL) THEN\n            CALL PUSH_ONTO_INDEX_STACK(XOP1,FIRST_OP);\n         ELSE IF IS_TRIPLE(XOP2,INDEX) & (LAST_INDEX_OP \u00ac= SECOND_OP) THEN\n         DO;\n            IF LAST_INDEX_OP = FIRST_OP THEN   /*  GET THE ADDRESS\n                REPRESENTED BY THE FIRST OPERAND (CURRENTLY ADDRESSED BY\n                BASE_REG,X_REG,DISPL) INTO A REGISTER.            */\n            DO;\n                BASE = GET_REG(BASE_PRIORITY);\n                PRIORITY(BASE) = TEMP_PRIORITY;\n                CALL EMIT_RX(LA,BASE,BASE_REG,X_REG,DISPL);\n                CALL ASSIGN_TEMP(BASE);\n                /*   CONVERT THE INDEX TRIPLE TO AN OTHERWISE UNUSED TRIPLE,\n                     & ASSOCIATE A TEMPORARY WITH IT   */\n                TRIPLES(LAST_INDEX_TRIPLE) = ADDR_TEMP +\n                   (TRIPLES(LAST_INDEX_TRIPLE) & \"80\");\n                TRIPLES(LAST_INDEX_TRIPLE + 2) = LAST_TEMP;\n            END;\n            CALL PUSH_ONTO_INDEX_STACK(XOP2,SECOND_OP);\n         END;\n         ELSE\n         DO;\n            IF LAST_INDEX_OP = SECOND_OP THEN CALL GENERATE_XREG_BASEREG;\n            ELSE CALL GENERATE_BASEREG_XREG;\n            CALL POP_INDEX_TRIPLE;\n         END;\n      END;\n      IF MASK(OPERAND) = TEMP_MASK THEN DO;\n         CALL CONVERT_TO_TEMP;\n         OP_MASK = TEMP_MASK;\n      END;\n      ELSE OP_MASK = TRIPLE_PTR;\n\n      /*   FOR INDEXED  OPERANDS OF EXTRAORDINARY LENGTH, WE OBTAIN THE\n          STORAGE LENGTH FROM AN S_LENGTH TRIPLE IMMEDIATELY FOLLOWING\n          RATHER THE THE LENGTH FIELD OF THR INDEX TRIPLE. THE LENGTH IS\n          GIVEN BY OP1 || OP2 OF THE S_LENGTH TRIPLE           */\n      OPERAND = OPERAND & STRIPMASK;\n      IF TRIPLES(OPERAND + 3) = S_LENGTH THEN\n         OP_STORAGE_LENGTH = SHL(TRIPLES(OPERAND + 4),16) + TRIPLES(OPERAND+5);\n\n END MAKE_INDEX_OP_ADDRESSABLE;\n\n MAKE_ADDRESSABLE: PROCEDURE (OPERAND);\n\n      DECLARE OPERAND BIT(16);\n      IF IS_TRIPLE(OPERAND,INDEX) THEN\n         CALL MAKE_INDEX_OP_ADDRESSABLE(OPERAND);\n      ELSE CALL MAKE_OP_ADDRESSABLE (OPERAND);\n END MAKE_ADDRESSABLE;\n\n\n\n FIXUP: PROCEDURE (PTR);\n\n      DECLARE (TEMP_PTR,PTR,NEXT_PTR,DISPLACEMENT,BASE) FIXED;\n\n      DO FOREVER;\n\n         /*   RECOVER NEXT ELEMENT IN CHAIN     */\n         NEXT_PTR = SHL (CODE(PTR+2),8 ) + CODE(PTR + 3);\n\n         IF CODE_INDEX < 4096 THEN\n         DO;      /*  NO REGISTER NEEDED   */\n                IF (CODE(PTR + 1) & \"0F\") \u00ac= 0 THEN\n                DO;     /*  A REGISTER WAS ANTICIPATED     */\n                   CODE(PTR + 1) = 0;    /*  INSERT NO-OP    */\n                   PTR = PTR - 4;\n                  CODE(PTR + 1) = CODE(PTR + 1) & \"F0\";  /* SET INDEXING TO 0 */\n                END;\n             DISPLACEMENT = CODE_INDEX;\n             BASE = CODE_BASE;\n         END;\n\n         ELSE     /*  DISP > 4096. NEED A REG FOR ADDRESSING      */\n         IF ( CODE (PTR + 1) & \"0F\") = 0 THEN  /* NO INDEXING ANTICIPATED   */\n         CALL ERROR(' FIXUP FAILURE. NO AVAILABLE REG FOR DOUBLE INDEXING');\n\n         ELSE\n         IF CODE_INDEX - PTR < 4094 THEN  /*  MULT OF 4096 NOT NEEDED.   */\n            DO;     /*  PATCH IN A BALR, MOVE UP THE BC, INSERT HALFWORD NO-OP*/\n                BASE = 0;\n                DISPLACEMENT = CODE_INDEX - PTR + 2;\n                PTR = PTR - 2;\n                CODE(PTR - 2) = BALR;\n                CODE(PTR - 1) = SHL(CODE(PTR + 3),4);\n                CODE(PTR) = BC;\n                CODE(PTR + 1) = CODE(PTR + 3);\n                CODE(PTR + 4) = BCR;\n                CODE(PTR + 5) = 0;\n            END;\n         ELSE   /*  GENERATE LOAD AVAIL REG WITH THE NECC MULT OF 4096  */\n         DO;\n             TEMP_PTR = PTR - 4;\n             /*   DISPLACEMENT = 4 * (CODE_INDEX DIV 4096)+ MULT_OF_4096_BASE */\n             DISPLACEMENT = SHL(SHR(CODE_INDEX,12),2) + MULT_OF_4096_BASE;\n             CODE(TEMP_PTR) = LOAD;\n             CODE(TEMP_PTR + 1) = SHL(CODE(PTR + 1),4) + ORG;\n             CODE(TEMP_PTR + 2) = SHR(DISPLACEMENT,8);\n             CODE(TEMP_PTR + 3) = DISPLACEMENT & \"FF\";\n             /*   SET VALUES FOR BRANCH INSTRUCTION    */\n             DISPLACEMENT = CODE_INDEX MOD 4096;\n             BASE = CODE_BASE;\n         END;\n\n         /*  BREAK HIGHER IF ERROR.   FILL IN DISPLACEMENT & BASE REG    */\n\n         IF LIST_CODE THEN\n         OUTPUT = X70 || SPACE 5X ||      PTR || ': FIXUP = ' || DISPLACEMENT;\n         CODE(PTR + 2) = SHL(BASE,4) + SHR(DISPLACEMENT,8);\n         CODE(PTR + 3) = DISPLACEMENT & \"FF\";\n         IF NEXT_PTR = 0 THEN RETURN; ELSE PTR = NEXT_PTR;\n      END;\n END FIXUP;\n\n\n FORWARD_BRANCH: PROCEDURE(BRANCH_COND,TARGET#);\n\n      DECLARE (TARGET#,INDEX_REG,BRANCH_COND) FIXED;\n      /*  IF TARGET IS A NEW BASIC BLOCK THEN NO LENGTH FIELD     */\n      IF TARGET# > 1000 THEN\n\n      DO;    /*  MAY NEED A REG FOR DOUBLE INDEXING    */\n         INDEX_REG = GET_REG(BASE_PRIORITY);\n         CALL EMIT_RX (BC,BRANCH_COND,INDEX_REG,0,0);\n         PRIORITY(INDEX_REG) = FREE_PRIORITY;\n      END;\n      ELSE INDEX_REG = 0;\n      IF TRIPLES(TARGET# + 2)   /*  2ND OPERAND OF BR TARGET TRIPLE   */\n      = NULL THEN    /*  NO PREVIOUS ELEMENTS IN CHAIN  */\n      CALL EMIT_RX(BC,BRANCH_COND,INDEX_REG,0,0);\n      ELSE CALL EMIT_RX(BC,BRANCH_COND,INDEX_REG,SHR(TRIPLES(TARGET# + 2),12)\n        ,TRIPLES(TARGET# + 2) & \"FFF\"  );\n      /*  SET THE 2ND OPERAND OF BR TARGET TO ABOVE BR INSTR,I.E. TO\n          HEAD OF FIXUP CHAIN             */\n      TRIPLES(TARGET# + 2) = CODE_INDEX - 4;\n\n END FORWARD_BRANCH;\n\n LOCAL_BRANCH: PROCEDURE(BRANCH_COND,OPERAND);\n      DECLARE (BRANCH_COND,OPERAND) BIT(16);\n      IF MASK(OPERAND) = SY_TABLE_PTR THEN\n      DO;     /*  A LOCAL GOTO  */\n         IF DISP(OPERAND) > 0 THEN DO;\n            CALL FLUSH_ALL_REGS;\n            CALL FORWARD_BRANCH(BRANCH_COND,DISP(OPERAND) );\n         END;\n         ELSE DO;\n            DISPL = DISP(OPERAND) & \"7FFFFFFF\";\n            CALL CHECK_MULT_OF_4096;\n            CALL FLUSH_ALL_REGS;\n            CALL EMIT_RX(BC,BRANCH_COND,X_REG,CODE_BASE,DISPL);\n         END;\n      END;\n      ELSE\n      DO;\n         OPERAND = OPERAND & STRIPMASK;\n         IF OPERAND > CURRENT_TRIPLE THEN DO;\n            IF SHR(TRIPLES(OPERAND),8) = 0 THEN  /*  CHANGING BASIC BLOCKS */\n               CALL FLUSH_ALL_REGS;\n            CALL FORWARD_BRANCH(BRANCH_COND,OPERAND);\n         END;\n         ELSE DO;\n            DISPL = TRIPLES(OPERAND + 1);\n            CALL CHECK_MULT_OF_4096;\n            CALL FLUSH_ALL_REGS;\n            CALL EMIT_RX(BC,BRANCH_COND,X_REG,CODE_BASE,DISPL);\n         END;\n      END;\n END LOCAL_BRANCH;\n\n\n FORWARD_CODE_BRANCH: PROCEDURE(BR_COND,RELATIVE_DISPL);\n      /*   GENERATES A FORWARD BRANCH KNOWN ONLY TO THE CODE GENERATOR,\n          I.E. NOT EXPLICITLY INDICATED BY THE TRIPLES BUT NEVERTHELESS\n          REQUIRED BY THE EXPANSION OF A TRIPLE INTO CODE.\n            THE ARGUMENTS ARE THE BRANCH CONDITION & THE DISPL RELATIVE TO\n          THE CODE INDEX                                  */\n      DECLARE (BR_COND,RELATIVE_DISPL) BIT(16);\n      DISPL = CODE_INDEX + RELATIVE_DISPL;\n      CALL CHECK_MULT_OF_4096;\n      /*   NOTE CODE_INDEX MAY BE CHANGED BY CHECK_MULT_OF_4096 IF\n           A LOAD IS EMITTED         */\n      CALL EMIT_RX(BC,BR_COND,X_REG,CODE_BASE,CODE_INDEX + RELATIVE_DISPL);\n END FORWARD_CODE_BRANCH;\n\n\n    /*        C O D E   G E N E R A T I O N   P R O C E D U R E S         */\n\n\n\n  LOAD_OPERAND: PROCEDURE;\n      CALL MAKE_ADDRESSABLE(OP1);\n      CALL GET_OP_INTO_REG(TEMP_PRIORITY);\n      CALL ASSIGN_TEMP(ACC);\n         OP2 = LAST_TEMP;\n\n END LOAD_OPERAND;\n\n GET_OP_INTO_REG#: PROCEDURE(REG#);\n      DECLARE REG# BIT(16);\n      IF IN_REG THEN CALL EMIT_RR(LR,REG#,ACC);\n      ELSE\n      IF OP_STORAGE_LENGTH = 1 THEN DO;\n         CALL EMIT_RR(SR,REG#,REG#);\n         CALL EMIT_RX(IC,REG#,X_REG,BASE_REG,DISPL);\n      END;\n      ELSE IF IMMEDIATE THEN DO;\n         IF DISPL = 0 THEN CALL EMIT_RR(SR,REG#,REG#);\n         ELSE CALL EMIT_RX(LA,REG#,0,0,DISPL);\n      END;\n      ELSE IF OP_STORAGE_LENGTH = 2 THEN\n         CALL EMIT_RX(LH,REG#,X_REG,BASE_REG,DISPL);\n      ELSE CALL EMIT_RX(LOAD,REG#,X_REG,BASE_REG,DISPL);\n END GET_OP_INTO_REG#;\n\n RESET_PAIR_PRIORITIES: PROCEDURE(EVEN_REG_PRIORITY,ODD_REG_PRIORITY);\n      DECLARE (EVEN_REG_PRIORITY,ODD_REG_PRIORITY) BIT(16);\n      PRIORITY(EVEN_REG) = EVEN_REG_PRIORITY;\n      PRIORITY(ODD_REG) = ODD_REG_PRIORITY;\n END RESET_PAIR_PRIORITIES;\n\n GET_INTO_EVEN_REG: PROCEDURE;\n      IF OP_STORAGE_LENGTH = 1 THEN FIX_BASE_REG_PRIORITIES;\n      EVEN_REG = GET_REG_PAIR;\n      ODD_REG = EVEN_REG + 1;\n      IF OP_STORAGE_LENGTH = 1 THEN CALL RESET_BASE_REG_PRIORITIES;\n      IF IN_REG THEN DO;\n         IF ACC \u00ac= EVEN_REG THEN CALL EMIT_RR(LR,EVEN_REG,ACC);\n      END;\n      ELSE\n      CALL GET_OP_INTO_REG#(EVEN_REG);\n      CALL RESET_PAIR_PRIORITIES (FIXED_PRIORITY,FIXED_PRIORITY);\n      ACC = EVEN_REG;\n\n END GET_INTO_EVEN_REG;\n\n GET_INTO_ODD_REG: PROCEDURE;\n      /*  GETS THE ADDRESSED OPERAND INTO THE ODD REG OF AN EVEN-ODD PAIR */\n\n      IF OP_STORAGE_LENGTH = 1 THEN FIX_BASE_REG_PRIORITIES;\n      EVEN_REG = GET_REG_PAIR;\n      ODD_REG = EVEN_REG + 1;\n      IF OP_STORAGE_LENGTH = 1 THEN CALL RESET_BASE_REG_PRIORITIES;\n      IF IN_REG THEN\n      DO;\n         IF ACC \u00ac= ODD_REG THEN CALL EMIT_RR(LR,ODD_REG,ACC);\n      END;\n      ELSE CALL GET_OP_INTO_REG#(ODD_REG);\n      CALL RESET_PAIR_PRIORITIES(FIXED_PRIORITY,FIXED_PRIORITY);\n      ACC = ODD_REG;\n END GET_INTO_ODD_REG;\n\n\n\n CHECK_STATUS: PROCEDURE(OPERAND);\n      /*  THIS PROCEDURE LOOKS AHEAD AT AN OPERAND, WITH OUT MAKING IT\n          ADDRESSABLE; IT CHECKS ONLY THAT THE GIVEN OPERAND IS IN A TEMP\n          PRIORITY REGISTER THAT WILL NOT BE REFERENCED AGAIN. IN THAT CASE,\n          THE TEMPORARY IS FREED, ACC <- THE REG,IN_FREE_REG <- TRUE.\n          THIS PROCEDURE CAN THEN PRE-EMPT MAKE_ADDRESSABLE.       */\n      DECLARE OPERAND BIT(16);\n      IN_REG = FALSE;\n      IN_FREE_REG = FALSE;\n      OP_MASK = MASK(OPERAND);\n      DO CASE OP_MASK;\n      ;\n      ;\n\n      DO;\n         IF IS_TRIPLE(OPERAND,INDEX) THEN RETURN;\n         OPERAND = OPERAND & STRIPMASK;\n         ACC = REG(TRIPLES(OPERAND + 2) );\n         IF ACC \u00ac= NULL THEN DO;\n            IN_REG = TRUE;\n            IN_FREE_REG = TRUE;\n            CALL FREE_TEMP(TRIPLES(OPERAND + 2) );\n         END;\n      END;\n      DO;\n         IF IS_TRIPLE(OPERAND,INDEX) THEN RETURN;\n         TEMP = TRIPLES( (OPERAND & STRIPMASK) + 2 );\n         ACC = REG(TEMP);\n         IF ACC \u00ac= NULL THEN IN_REG = TRUE;\n      END;\n    END;\n END CHECK_STATUS;\n\n GET_STOR_LEN : PROCEDURE (OPERAND) FIXED;\n      /*   USED TO GET THE STORAGE LENGTH OF THE GIVEN OPERAND WITHOUT\n           MAKING IT ADDRESSABLE   */\n      DECLARE OPERAND BIT(16);\n      DO CASE MASK(OPERAND);\n         /*   SY TABLE PTR   */\n         RETURN STORAGE_LENGTH(OPERAND);\n         /*   IMMEDIATE   */\n         RETURN 0;\n         /*   TRIPLE   */\n         DO;\n            /*   IF OPERAND IS AN INDEX TRIPLE, THE STORAGE LENGTH MAY BE\n                 CONTAINED IN AN S_LENGTH TRIPLE IMMEDIATELY FOLLOWING  */\n           IF IS_TRIPLE(OPERAND,INDEX) THEN DO;\n               IF TRIPLES((OPERAND & STRIPMASK) + 3) = S_LENGTH THEN DO;\n                  OPERAND = (OPERAND & STRIPMASK) + 4;\n                  RETURN SHL(TRIPLES(OPERAND),16) + TRIPLES(OPERAND + 1);\n               END;\n            END;\n            /*   SET STORAGE LENGTH FROM LENGTH FIELD   */\n            RETURN (SHR(TRIPLES(OPERAND & STRIPMASK),8)& \"FF\") + 1;\n         END;\n         /*   TRIPLE   */\n         DO;\n            /*   IF OPERAND IS AN INDEX TRIPLE, THE STORAGE LENGTH MAY BE\n                 CONTAINED IN AN S_LENGTH TRIPLE IMMEDIATELY FOLLOWING  */\n            IF IS_TRIPLE(OPERAND,INDEX) THEN DO;\n               IF TRIPLES((OPERAND & STRIPMASK) + 3) = S_LENGTH THEN DO;\n                  OPERAND = (OPERAND & STRIPMASK) + 4;\n                  RETURN SHL(TRIPLES(OPERAND),16) + TRIPLES(OPERAND + 1);\n               END;\n            END;\n            /*   SET STORAGE LENGTH FROM LENGTH FIELD   */\n            RETURN (SHR(TRIPLES(OPERAND & STRIPMASK),8)& \"FF\") + 1;\n         END;\n      END;\n END GET_STOR_LEN;\n\n\n\n DOUBLE_REG_STATUS: PROCEDURE(OPERAND) BIT(1);\n      /*  CHECKS IF THE GIVEN OPERAND IS IN A FREE ODD REG, & THAT THE\n          CORRESPONDING EVEN REG IS FREE                 */\n      DECLARE OPERAND BIT(16);\n      DO CASE MASK(OPERAND);\n         RETURN FALSE;\n         RETURN FALSE;\n         DO;\n         IF IS_TRIPLE(OPERAND,INDEX) THEN RETURN FALSE;\n            OPERAND = OPERAND & STRIPMASK;\n            ACC = REG(TRIPLES(OPERAND + 2) );\n              IF ACC \u00ac= NONE & PRIORITY(ACC) = TEMP_PRIORITY & (ACC & \"1\") = 1\n            & PRIORITY(ACC - 1) = FREE_PRIORITY THEN DO;\n            CALL FREE_TEMP( TRIPLES(OPERAND + 2 ) );\n            ODD_REG = ACC;\n            EVEN_REG = ODD_REG - 1;\n            PRIORITY(ODD_REG),PRIORITY(EVEN_REG) = FIXED_PRIORITY;\n            RETURN TRUE;\n         END;\n         ELSE RETURN FALSE;\n         END;\n         RETURN FALSE;\n      END;\n END DOUBLE_REG_STATUS;\n\n GENERATE_OPERATION:\n PROCEDURE(FULLWORD_INSTR,RR_INSTR,HALFWORD_INSTR,REG#,OPERAND);\n      DECLARE (FULLWORD_INSTR,HALFWORD_INSTR,RR_INSTR,REG#,OPERAND) BIT(16);\n      DECLARE SAVED_PRIORITY BIT(16);\n      /*   THIS  ROCEDURE EXPECTS ONE OPERAND IN A REGISTER (ACC); IT MAKES\n          THE OTHER OPERAND ADDRESSABLE, AND GENERATES ONE OF THE GIVEN RX\n          OR RR INSTRUCTIONS DEPENDING ON THE STATUS OF THE LATTER OPERAND.\n          ACC IS UNCHANGED                 */\n\n      SAVED_PRIORITY = PRIORITY(ACC);\n      PRIORITY(ACC) = FIXED_PRIORITY;\n      ACC1 = ACC;\n      CALL MAKE_ADDRESSABLE(OPERAND);\n      IF IN_REG THEN CALL EMIT_RR(RR_INSTR,REG#,ACC);\n      ELSE IF OP_STORAGE_LENGTH = 4 THEN\n      CALL EMIT_RX(FULLWORD_INSTR,REG#,BASE_REG,X_REG,DISPL);\n      ELSE IF(OP_STORAGE_LENGTH = 1) | (HALFWORD_INSTR = NULL) | IMMEDIATE\n      THEN DO;\n         CALL GET_OP_INTO_REG(FREE_PRIORITY);\n         CALL EMIT_RR(RR_INSTR,REG#,ACC);\n      END;\n      ELSE\n         CALL EMIT_RX(HALFWORD_INSTR,REG#,BASE_REG,X_REG,DISPL);\n      ACC = ACC1;\n      PRIORITY(ACC) = SAVED_PRIORITY;\n END GENERATE_OPERATION;\n\n IMMED_POWER_OF_2: PROCEDURE (OPERAND) BIT(1);\n      DECLARE OPERAND BIT(16);\n      IF \u00ac IMMED(OPERAND) THEN RETURN FALSE;\n      ELSE DO;\n         OPERAND = OPERAND & STRIPMASK;\n         J = 1;\n         POWER = 0;\n         DO WHILE J < 4096;\n            IF OPERAND = J THEN RETURN TRUE;\n            J = SHL(J,1);\n            POWER = POWER + 1;\n         END;\n         RETURN FALSE;\n      END;\n END IMMED_POWER_OF_2;\n\n\n GEN_COND_BRANCH: PROCEDURE(BR_COND);\n      DECLARE BR_COND BIT(16);\n      /*  MOVE CURRENT_TRIPLE TO POINT TO THE FOLLOWING BZ OR BNZ TRIPLE  */\n      CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n      /****/  IF LIST_CODE THEN CALL PRINT_TRIPLE(CURRENT_TRIPLE);\n      IF (TRIPLES(CURRENT_TRIPLE) & TRIPLE_OP_MASK ) = BNZ_TRIPLE THEN\n         CALL LOCAL_BRANCH(BR_COND,OP1);\n      ELSE CALL LOCAL_BRANCH(15 - BR_COND,OP1);\n END GEN_COND_BRANCH;\n\n GEN_INTEGER_COMPARE: PROCEDURE(OP1_COND,OP2_COND);\n\n      DECLARE (OP1_COND,OP2_COND) BIT(16);\n\n      CALL CHECK_STATUS(OP2);\n      IF IN_REG THEN DO;\n         CALL GENERATE_OPERATION(C,CR,CH,ACC,OP1);\n         CALL GEN_COND_BRANCH(OP2_COND);\n      END;\n      ELSE\n      IF IMMED(OP2) THEN\n    DO;\n      IF (OP2 & STRIPMASK) = 0 THEN   /*   SPECIAL CASE.NO NEED TO LOAD OP  */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF \u00acIN_REG THEN CALL GET_OP_INTO_REG(FREE_PRIORITY);\n         CALL EMIT_RR(LTR,ACC,ACC);\n         CALL GEN_COND_BRANCH(OP1_COND);\n      END;\n      ELSE DO;\n         ACC = GET_REG(FREE_PRIORITY);\n         CALL EMIT_RX(LA,ACC,0,0,OP2 & STRIPMASK );\n         CALL GENERATE_OPERATION(C,CR,CH,ACC,OP1);\n         CALL GEN_COND_BRANCH(OP2_COND);\n      END;\n      END;\n      ELSE\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF \u00acIN_REG THEN CALL GET_OP_INTO_REG(FREE_PRIORITY);\n         CALL GENERATE_OPERATION(C,CR,CH,ACC,OP2);\n         CALL GEN_COND_BRANCH(OP1_COND);\n      END;\n\n END GEN_INTEGER_COMPARE;\n GET_OP_INTO_FLT_REG: PROCEDURE(REG_PRIORITY);\n      DECLARE REG_PRIORITY BIT(16);\n      IF IN_REG THEN\n      DO;\n          IF REG_PRIORITY = FREE_PRIORITY THEN RETURN;\n         IF PRIORITY(ACC) \u00ac= FREE_PRIORITY THEN\n         DO;\n            FLT_REG = GET_FLT_REG(REG_PRIORITY);\n            CALL EMIT_RR(LER,FLT_REG - #GP_REGS,ACC - #GP_REGS );\n         END;\n         ELSE DO;\n            FLT_REG = ACC;\n            PRIORITY(FLT_REG) = REG_PRIORITY;\n         END;\n      END;\n      ELSE DO;\n         FLT_REG = GET_FLT_REG(REG_PRIORITY);\n         CALL EMIT_RX(LE,FLT_REG - #GP_REGS,BASE_REG,X_REG,DISPL);\n         IN_REG = TRUE;\n      END;\n      IF ( REG_PRIORITY = FREE_PRIORITY) & (OP_MASK = TEMP_MASK) THEN\n      CALL REASSIGN_TEMP(FLT_REG,TEMP);\n\n END GET_OP_INTO_FLT_REG;\n\n GENERATE_FLT_OPERATION: PROCEDURE(RX_INSTR,RR_INSTR,OPERAND);\n      DECLARE (RX_INSTR,RR_INSTR,OPERAND) BIT(16);\n      /*  EXPECTS ONE OPERAND IN FLT_REG; THE GIVEN OPERAND IS MADE\n          ADDRESSABLE.  GENERATES RX OR RR INSTRUCTION ACCORDING TO THE\n          STATUS OF THE LATTER, AND ASSIGNS A TEMP TO FLT_REG , WHICH HOLDS\n          THE RESULT OF THE OPERATION .                        */\n\n      CALL MAKE_ADDRESSABLE(OPERAND);\n      IF IN_REG THEN CALL EMIT_RR(RR_INSTR,FLT_REG-#GP_REGS, ACC-#GP_REGS);\n      ELSE CALL EMIT_RX(RX_INSTR,FLT_REG-#GP_REGS,BASE_REG,X_REG,DISPL);\n      PRIORITY(FLT_REG) = TEMP_PRIORITY;\n      CALL ASSIGN_TEMP(FLT_REG);\n      OP2 = LAST_TEMP;\n END GENERATE_FLT_OPERATION;\n\n TEST_FOR_BOOLEAN_0: PROCEDURE (BR_COND);\n      DECLARE BR_COND BIT(16);\n      IF OP2 = NULL THEN DO;\n         CALL LOCAL_BRANCH(BR_COND,OP1);\n         RETURN;\n      END;\n         CALL MAKE_ADDRESSABLE(OP2);\n         IF \u00acIN_REG THEN DO;\n            IF (DISPL + OP_STORAGE_LENGTH     < 4097)  & X_REG  = 0 THEN\n               CALL EMIT_RX(CLI,0,0,BASE_REG,DISPL + OP_STORAGE_LENGTH - 1 );\n            ELSE DO;\n               CALL GET_OP_INTO_REG(FREE_PRIORITY);\n               CALL EMIT_RR(LTR,ACC,ACC);\n            END;\n         END;\n         ELSE CALL EMIT_RR(LTR,ACC,ACC);\n         CALL LOCAL_BRANCH(BR_COND,OP1);\n\n END TEST_FOR_BOOLEAN_0;\n GEN_FLT_COMPARE: PROCEDURE(OP1_COND,OP2_COND);\n      DECLARE (OP1_COND,OP2_COND) BIT(16);\n      CALL CHECK_STATUS(OP2);\n      IF IN_REG THEN DO;\n         FLT_REG = ACC;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF IN_REG THEN CALL EMIT_RR(CER,FLT_REG-#GP_REGS,ACC-#GP_REGS);\n         ELSE CALL EMIT_RX(CE,FLT_REG - #GP_REGS,BASE_REG,X_REG,DISPL);\n         CALL GEN_COND_BRANCH(OP2_COND);\n      END;\n      ELSE\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF \u00acIN_REG THEN CALL GET_OP_INTO_FLT_REG(FREE_PRIORITY);\n         ELSE FLT_REG = ACC;\n         CALL MAKE_ADDRESSABLE(OP2);\n         IF IN_REG THEN CALL EMIT_RR(CER,FLT_REG-#GP_REGS,ACC-#GP_REGS);\n         ELSE CALL EMIT_RX(CE,FLT_REG-#GP_REGS,BASE_REG,X_REG,DISPL);\n         CALL GEN_COND_BRANCH(OP1_COND);\n      END;\n END GEN_FLT_COMPARE;\n\n GENERATE_STRING_OPERATION : PROCEDURE (INSTR);\n      DECLARE INSTR BIT(16);\n      CALL MAKE_ADDRESSABLE(OP2);\n      IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n      IF OP1 = OP2 THEN CALL EMIT_SS(INSTR,OP_STORAGE_LENGTH-1,\n         BASE_REG,DISPL,BASE_REG,DISPL );\n    ELSE DO;\n      DISPL1 = DISPL;\n      BASE_REG1 = BASE_REG;\n      PRIORITY(BASE_REG) = FIXED_PRIORITY;\n      CALL MAKE_ADDRESSABLE(OP1);\n      /*   NOW BASE_REG,DISPL ADDRESS THE FIRST OPERAND (THE TARGET ),\n           BASE_REG1,DISPL1 ADDRESS THE SECOND.              */\n      IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n      CALL EMIT_SS(INSTR,OP_STORAGE_LENGTH-1,BASE_REG,DISPL,BASE_REG1,DISPL1);\n      CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,BASE_REG1);\n    END;\n END GENERATE_STRING_OPERATION;\n\n\n GET_TARGET_ADDRESS: PROCEDURE;\n      IF FORMAL_PARAMETER THEN DO;\n         BASE_REG = STACKTOP;\n         OP_STORAGE_LENGTH = STORAGE_LENGTH(OP1);\n         DISPL = DISP(OP1) + AR_OFFSET;\n         CALL CHECK_MULT_OF_4096;\n      END;\n      ELSE CALL MAKE_ADDRESSABLE(OP1);\n END GET_TARGET_ADDRESS;\n\n STORE_REGISTER: PROCEDURE(REG#);\n      DECLARE REG# BIT(16);\n      /*   STORES THE GIVEN REGISTER INTO THE CURRENTLY ADDRESSED OPERAND  */\n      IF REG# >= #GP_REGS THEN   /*  FLT REG   */\n         CALL EMIT_RX(STE,REG# - #GP_REGS,X_REG,BASE_REG,DISPL);\n      ELSE   /*   GENERAL REG   */\n      IF OP_STORAGE_LENGTH >= 4 THEN CALL EMIT_RX(ST,REG#,X_REG,BASE_REG,DISPL);\n      ELSE IF OP_STORAGE_LENGTH = 2 THEN\n         CALL EMIT_RX(STH,REG#,X_REG,BASE_REG,DISPL);\n      ELSE   /*  OP_STORAGE_LENGTH = 1   */\n         CALL EMIT_RX(STC,REG#,X_REG,BASE_REG,DISPL);\n END STORE_REGISTER;\n\n MAKE_TARGET_ADDR: PROCEDURE;\n      DISPL2 = DISPL;\n      BASE_REG2 = BASE_REG;\n      PRIORITY(BASE_REG) = FIXED_PRIORITY;\n      CALL GET_TARGET_ADDRESS;\n\n END MAKE_TARGET_ADDR;\n\n SETUP_SS_LOOP: PROCEDURE;\n      /*   SETS UP BASE_REGS FOR SS OPERATIONS WITH LONG OPERANDS.\n         THESE MAY REQUIRE A LOOP, & HENCE REQUIRE ONE OR TWO BASE REGS\n         WHICH CAN BE INCREMENTED WITH IMPUNITY                     */\n      DECLARE (BASE_REG1,X_REG1) BIT(16);\n      BASE_REG1 = BASE_REG;\n      X_REG1 = X_REG;\n      IF X_REG \u00ac= 0 THEN DO;\n         CALL LOAD_ADDRESS;\n         BASE_REG2 = BASE_REG;\n      END;\n      ELSE DO;\n         IF PRIORITY(BASE_REG) \u00ac= FREE_PRIORITY THEN DO;\n            BASE_REG2 = GET_REG(BASE_PRIORITY);\n            CALL EMIT_RR(LR,BASE_REG2,BASE_REG);\n         END;\n         ELSE BASE_REG2 = BASE_REG;\n      END;\n      PRIORITY(BASE_REG2) = FIXED_PRIORITY;\n      DISPL2 = DISPL;\n      CALL MAKE_ADDRESSABLE(OP1);\n      IF X_REG = X_REG1 & BASE_REG = BASE_REG1 THEN\n         /*   WE CAN OPTIMIZE BY USING ONLY ONE BASE REGISTER   */\n         BASE_REG = BASE_REG2;\n      ELSE DO;\n         IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n         ELSE IF PRIORITY(BASE_REG) \u00ac= FREE_PRIORITY THEN DO;\n            BASE_REG1 = GET_REG(BASE_PRIORITY);\n            CALL EMIT_RR(LR,BASE_REG1,BASE_REG);\n            BASE_REG = BASE_REG1;\n         END;\n         PRIORITY(BASE_REG) = FIXED_PRIORITY;\n      END;\n END SETUP_SS_LOOP;\n\n\n\n GEN_LONG_COMPARE: PROCEDURE (BR_COND);\n      /*   GENERATES COMPARISON OF BYTE STRINGS WHOSE LENGTHS EXCCEED 256.\n         THE STRINGS, INDICATED BY OP1 & OP2, ARE ASSUMED TO BE OF EQUAL LEN  */\n      DECLARE (BR_COND,LOOP_DISPL,B_REG,BR_FAIL,BR_SUCC,FIXUP_DISPL, LEN2,\n               COUNTER, TARGET) BIT(16), BR_ON_TRUE BIT(1);\n\n      CALL MAKE_ADDRESSABLE(OP2);\n      CALL SETUP_SS_LOOP;\n      COUNTER = GET_REG(FIXED_PRIORITY);\n      LEN2 = SHR(OP_STORAGE_LENGTH,8);\n      DISPL1 = DISPL;\n      CALL EMIT_RX(LA,COUNTER,0,0,LEN2);\n      LOOP_DISPL = CODE_INDEX;\n      CALL EMIT_SS(CLC,255,BASE_REG,DISPL1,BASE_REG2,DISPL2);\n      IF CODE_INDEX + 54 > 4095 THEN\n      DO;\n         /*   WORST CASE LENGTH OF LOOP + CURRENT CODE INDEX > 4095.\n              WILL REQUIRE ANOTHER REG FOR BRANCHING TO FAILURE ADDRESS,\n              (WHICH IS IMMEDIATELY AFTER THE LOOP BEING SETUP)     */\n         B_REG = GET_REG(BASE_PRIORITY);\n         PRIORITY(B_REG) = FREE_PRIORITY;\n         CALL EMIT_RR(BALR,B_REG,0);\n      END;\n      ELSE B_REG = CODE_BASE;\n      BR_ON_TRUE = ( (TRIPLES(CURRENT_TRIPLE + 3) & TRIPLE_OP_MASK)=BNZ_TRIPLE);\n      TARGET = TRIPLES(CURRENT_TRIPLE + 4);  /*   OP1 OF BNZ | BZ TRIPLE FOL */\n      FIXUP_DISPL = CODE_INDEX;  /* INSTRUCTION MAY FOLLOW WHICH REQUIRES\n              A FIXUP BY THIS PROCEDURE (THIS WOULD BE A BR TO FAILURE ADD   */\n      IF BR_COND = BE THEN DO;\n         IF BR_ON_TRUE THEN CALL EMIT_RX(BC,BNE,B_REG,0,0);\n         ELSE CALL LOCAL_BRANCH(BNE,TARGET);\n      END;\n      ELSE DO;\n         IF BR_ON_TRUE THEN DO;\n            BR_FAIL = (2 * BR_COND) MOD 6;\n            BR_SUCC = BR_COND;\n         END;\n         ELSE DO;\n            BR_FAIL = BR_COND;\n            BR_SUCC = (2 * BR_COND) MOD 6;\n         END;\n         CALL EMIT_RX(BC,BR_FAIL,B_REG,0,0);\n         CALL LOCAL_BRANCH(BR_SUCC,TARGET);\n      END;\n      /*   COMPLETE THE LOOP SETUP   */\n      CALL EMIT_RX(LA,BASE_REG,BASE_REG,0,256);\n      IF BASE_REG2 \u00ac= BASE_REG THEN CALL EMIT_RX(LA,BASE_REG2,BASE_REG2,0,256);\n       /*   GENERATE A BCT TO LOOP ON CLC INSTR   */\n      DISPL = LOOP_DISPL;\n      CALL CHECK_MULT_OF_4096;\n      CALL EMIT_RX(BCT,COUNTER,X_REG,CODE_BASE,DISPL);\n      LEN2 = OP_STORAGE_LENGTH - SHL(LEN2,8) - 1;\n      IF LEN2 >= 0 THEN DO;\n         CALL EMIT_SS(CLC,LEN2,BASE_REG,DISPL1,BASE_REG2,DISPL2);\n         CALL GEN_COND_BRANCH(BR_COND);\n      END;\n      ELSE CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n      /*   THE VALUE OF CODE_INDEX NOW REPRESENTS THE FAILURE DISPL   */\n      IF BR_COND \u00ac= BE | BR_ON_TRUE THEN DO;\n         IF B_REG = CODE_BASE THEN DO;\n            CODE(FIXUP_DISPL + 2) = SHR(CODE_INDEX,8);\n            CODE(FIXUP_DISPL + 3) = CODE_INDEX & \"FF\";\n         END;\n         ELSE DO;\n            CODE(FIXUP_DISPL + 2) = SHR(FIXUP_DISPL - CODE_INDEX,8);\n            CODE(FIXUP_DISPL + 3) = (FIXUP_DISPL - CODE_INDEX) & \"FF\";\n         END;\n      END;\n      /*   FREE THE REGISTERS USED IN THE LOOP   */\n      PRIORITY(BASE_REG), PRIORITY(BASE_REG2) = FREE_PRIORITY;\n      PRIORITY(COUNTER) = FREE_PRIORITY;\n END GEN_LONG_COMPARE;\n\n GEN_LONG_SS_OP: PROCEDURE(INSTR);\n      DECLARE (COUNTER,LEN2) BIT(16);\n      DECLARE INSTR BIT(16);\n\n      IF OP_STORAGE_LENGTH <= 1536 THEN  /*   EMIT A SERIES OF SS INSTRS  */\n      DO;\n         IF (X_REG \u00ac= 0) | (DISPL + OP_STORAGE_LENGTH > 3839)\n         /*   3839 = 4095 - 256   */\n            THEN CALL LOAD_ADDRESS;\n         CALL MAKE_TARGET_ADDR;\n         IF (X_REG \u00ac= 0) | (DISPL + OP_STORAGE_LENGTH > 3839 ) THEN\n            CALL LOAD_ADDRESS;\n         I = OP_STORAGE_LENGTH;\n         DO WHILE I > 256;\n            CALL EMIT_SS(INSTR,255,BASE_REG,DISPL,BASE_REG2,DISPL2);\n            I = I - 256;\n            DISPL = DISPL + 256;\n            DISPL2 = DISPL2 + 256;\n         END;\n         IF I > 0 THEN\n         CALL EMIT_SS(INSTR,I - 1,BASE_REG,DISPL,BASE_REG2,DISPL2);\n         CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,BASE_REG2);\n      END;\n      ELSE   /*     USE  A LOOP TO MAKE THE TRANSFER        */\n      DO;\n         CALL SETUP_SS_LOOP;\n         COUNTER = GET_REG(FREE_PRIORITY);\n         LEN2 = SHR(OP_STORAGE_LENGTH,8);\n         DISPL1 = DISPL;\n         CALL EMIT_RX(LA,COUNTER,0,0,LEN2);\n         CALL EMIT_SS(INSTR,255,BASE_REG,DISPL1,BASE_REG2,DISPL2);\n         CALL EMIT_RX(LA,BASE_REG,BASE_REG,0,256);\n         IF BASE_REG2 \u00ac= BASE_REG THEN\n         DO;\n            CALL EMIT_RX(LA,BASE_REG2,BASE_REG2,0,256);\n            DISPL = CODE_INDEX - 14;\n         END;\n         ELSE DISPL = CODE_INDEX - 10;\n\n         /*   GENERATE A BCT TO LOOP ON THE SS INSTRUCTION   */\n         CALL CHECK_MULT_OF_4096;\n         CALL EMIT_RX(BCT,COUNTER,X_REG,CODE_BASE,DISPL);\n\n         LEN2 = OP_STORAGE_LENGTH - SHL(LEN2,8) - 1;\n         IF LEN2 >= 0 THEN\n         CALL EMIT_SS(INSTR,LEN2,BASE_REG,DISPL1,BASE_REG2,DISPL2);\n         CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,BASE_REG2);\n      END;\n END GEN_LONG_SS_OP;\n\n\n MOVE_STRING: PROCEDURE;\n      DECLARE LEN2 BIT(16);\n      IF OP_STORAGE_LENGTH <= 256 THEN\n      DO;\n         IF FORMAL_PARAMETER THEN\n         DO;\n            IF BASE_REG = STACKTOP & X_REG = 0 & OP_STORAGE_LENGTH = 4 THEN\n            DO;\n               IF DISP(OP1) = DISPL & STORAGE_LENGTH(OP1) = 4 THEN\n                  /*  ARGUMENT IS THE RESULT OF A FUNCTION CALL AND IS\n                      ALREADY IN PLACE.                  */\n                  RETURN;\n            END;\n         END;\n         LEN2 = OP_STORAGE_LENGTH;\n         IF X_REG \u00ac= 0 | DISPL > 4092 THEN CALL LOAD_ADDRESS;\n         CALL MAKE_TARGET_ADDR;\n\n         /*   BE CAREFUL MOVING TEMPS INTO VARIABLES WITH SHORTER\n             STORAGE LENGTH   */\n         IF LEN2 > OP_STORAGE_LENGTH THEN\n            DISPL2 = DISPL2 + LEN2 - OP_STORAGE_LENGTH;\n         /*   DON'T COPY TOO MUCH.  NOTE  FUNCTION VARIABLES HAVE\n              STORAGE_LENGTH COLUMN = ACTIVATION RECORD SIZE        */\n         ELSE OP_STORAGE_LENGTH = LEN2;\n\n         IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n         CALL EMIT_SS(MVC,OP_STORAGE_LENGTH-1,BASE_REG,DISPL,BASE_REG2,DISPL2);\n         CALL RESET_ADDR_REG_PRIORITIES(BASE_REG2,BASE_REG);\n      END;\n      ELSE     /*   LENGTH > 256   */\n      CALL GEN_LONG_SS_OP(MVC);\n\n END MOVE_STRING;\n\n MOVE_OP: PROCEDURE;\n\n      DECLARE SAVED_PRIORITY BIT(16);\n\n\n\n      CALL MAKE_ADDRESSABLE(OP2);\n      IF IMMEDIATE THEN DO;\n         DISPL2 = DISPL;\n         CALL GET_TARGET_ADDRESS;\n         IF OP_STORAGE_LENGTH = 1  & X_REG  = 0 THEN   /*  FUDGE AN SI INSTR */\n            CALL EMIT_RX(MVI,SHR(DISPL2,8),DISPL2 & \"F\",BASE_REG,DISPL);\n         ELSE DO;\n            FIX_BASE_REG_PRIORITIES;\n            ACC1 = GET_REG(FREE_PRIORITY);\n            IF DISPL2 = 0 THEN CALL EMIT_RR(SR,ACC1,ACC1);  ELSE\n            CALL EMIT_RX(LA,ACC1,0,0,DISPL2);\n            CALL STORE_REGISTER(ACC1);\n            CALL RESET_BASE_REG_PRIORITIES;\n         END;\n      END;\n      ELSE\n      IF IN_REG THEN DO;\n         SAVED_PRIORITY = PRIORITY(ACC );\n         PRIORITY(ACC ) = FIXED_PRIORITY;\n         ACC1 = ACC;\n         CALL GET_TARGET_ADDRESS;\n         CALL STORE_REGISTER(ACC1);\n         PRIORITY(ACC1) = SAVED_PRIORITY;\n      END;\n      ELSE\n      IF OP_STORAGE_LENGTH < 3 THEN DO;\n         CALL GET_OP_INTO_REG(FREE_PRIORITY);\n         SAVED_PRIORITY = PRIORITY(ACC );\n         PRIORITY(ACC ) = FIXED_PRIORITY;\n         ACC1 = ACC;\n         CALL GET_TARGET_ADDRESS;\n         CALL STORE_REGISTER(ACC1);\n         PRIORITY(ACC1) = SAVED_PRIORITY;\n      END;\n      ELSE CALL MOVE_STRING;\n END MOVE_OP;\n\n\n MOVE_MONITOR_ARG: PROCEDURE(ARG);\n\n      /*   USED IN MONITOR CALL SEQUENCES     */\n      /*   MOVES CURRENTLY ADDRESSED OPERAND INTO THE ARG LOCATION SPECIFIED */\n\n      DECLARE ARG BIT(16);\n      IF \u00acIN_REG & (OP_STORAGE_LENGTH < 4 | IMMEDIATE ) THEN\n         CALL GET_OP_INTO_REG (FREE_PRIORITY);\n      IF IN_REG THEN DO;\n      IF ACC < #GP_REGS THEN CALL EMIT_RX(ST,ACC,0,ORG,ARG);\n      ELSE CALL EMIT_RX(STE,ACC,0,ORG,ARG);\n      END;\n      ELSE DO;\n         IF X_REG \u00ac= 0 THEN DO;\n            CALL LOAD_ADDRESS;\n            CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,0);\n         END;\n         CALL EMIT_SS(MVC,3,ORG,ARG,BASE_REG,DISPL);\n      END;\n END MOVE_MONITOR_ARG;\n\n\n LOGICAL_SHIFT: PROCEDURE (INSTR);\n      DECLARE INSTR BIT(16);\n      CALL LOAD_OPERAND;\n      ACC1 = ACC;\n      PRIORITY(ACC) = FIXED_PRIORITY;\n      CALL MAKE_ADDRESSABLE(OP2);\n      IF IMMEDIATE THEN DO;\n         IF DISPL \u00ac= 0 THEN DO;\n            IF DISPL = 1 THEN CALL EMIT_RR(AR,ACC1,ACC1);\n            ELSE CALL EMIT_RX(INSTR,ACC1,0,0,DISPL);\n         END;\n      END;\n      ELSE DO;\n         CALL FORCE_INTO_BASE_REG;   /*  GET INTO A NON-ZERO REG IF NOT   */\n         CALL EMIT_RX(INSTR,ACC1,0,BASE_REG,0);\n      END;\n      PRIORITY(ACC1) = TEMP_PRIORITY;\n      CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,0);\n\n END LOGICAL_SHIFT;\n\n\n SELECT: PROCEDURE;\n      /*   PROCEDURE CALLED BY IN & INTO CASES FOR SELECTING A BYTE\n           AND A BIT WITHIN THAT BYTE FROM THE GIVEN ORDINALITY (OP1).  THIS\n           IS ACCOMPLISHED BY DIVIDING BY 8 : THE REMAINDER SELECTS THE\n           BIT, THE QUOTIENT SELECTS THE BYTE   */\n      CALL MAKE_ADDRESSABLE(OP1);\n      IF GET_STOR_LEN(OP2) = 1 THEN DO;\n         /*   NOT NECESSARY TO COMPUTE THE BYTE-THERE IS ONLY ONE   */\n         BYTE_XREG = 0;\n         CALL GET_INTO_ODD_REG;\n      END;\n      ELSE DO;\n         CALL GET_INTO_EVEN_REG;\n         CALL EMIT_RX(SRDL,EVEN_REG,0,0,3);\n         CALL EMIT_RX(SRL,ODD_REG,0,0,29);\n         BYTE_XREG = EVEN_REG;\n      END;\n      /*   BYTE_XREG NOW SELECTS THE BYTE, ODD_REG THE BIT   */\n      CALL MAKE_ADDRESSABLE(OP2);\n      IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n      CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,0);\n END SELECT;\n\n\n FOLD_BIT_OP: PROCEDURE (INSTR);\n      /*   USED FOR GEN CODE FOR IN & INTO TRIPLES WHEN BIT ORDINALITY IS\n           KNOWN AT COMPILE TIME          */\n      DECLARE (BIT_ORD,BYTE_ORD,MASK,INSTR) BIT(16);\n      DISPL = OP1 & STRIPMASK;\n      BIT_ORD = DISPL MOD 8;\n      BYTE_ORD = DISPL / 8;\n      CALL MAKE_ADDRESSABLE(OP2);\n      IF DISPL + BYTE_ORD > 4095 & X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n      DISPL = DISPL + BYTE_ORD;\n      CALL CHECK_MULT_OF_4096;\n      IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n      MASK = SHR(\"80\",BIT_ORD);\n      /*   FUDGE AN SI INSTRUCTION   */\n      CALL EMIT_RX(INSTR,SHR(MASK,4),MASK & \"F\",BASE_REG,DISPL);\n END FOLD_BIT_OP;\n\n\n\n GEN_TRANSFER_TO_MONITOR: PROCEDURE;\n      /*   DETERMINE WHICH GENERAL REGISTERS NEED TO BE SAVED   */\n      I = 9;\n      DO WHILE PRIORITY(I) = FREE_PRIORITY & I \u00ac= -1;\n         I = I - 1;\n      END;\n      IF I = -1 THEN I = 15;\n      /*   SAVE PASCAL REGISTER USAGE, LOAD THE BASE REGS FOR THE MONITOR  */\n      CALL EMIT_RX(STM,11,I,ORG,PASCAL_REGS);\n      CALL FLUSH_REG(10);\n      CALL EMIT_RX(LM,11,13,ORG,MON_BASE_REGS);\n      /*   BRANCH INTO MONITOR JUMP TABLE   */\n      CALL EMIT_RX(BAL,10,0,13,SERVICE_CODE * 4 + 72);\n END GEN_TRANSFER_TO_MONITOR;\n\n REAL_ARG_REAL_VALUE: PROCEDURE;\n      /*   USED FOR GENERATING MONITOR CALLS WHICH HAVE REAL ARGUMENTS (1),\n           AND RETURN A REAL VALUE. WE ATTEMPT TO MAKE ENTRY TO THESE\n           MONITOR CALLS PARTICULARLY EFFICIENT BY LOADING ONLY 1\n           BASE REG, AND SAVING ONLY THOSE REGS ACTUALLY USED BY\n           THE ROUTINES (WHICH ARE NOT CURRENTLY BEING USED IN THE PASCAL CODE).\n           THESE CALLS USE ONLY REGS 14..1 FOR SCRATCH,\n           EXCEPT FOR EXP, WHICH USES 14..4.              */\n\n      DECLARE FLT_ARG_REG BIT(16) INITIAL (22);\n      CALL MAKE_ADDRESSABLE(OP1);\n      /*   FLUSH THE FLOATING POINT REGS   */\n      DO I = 16 TO 22 BY 2;\n         CALL FLUSH_REG(I);\n      END;\n      IF IN_REG THEN DO;\n         IF ACC = FLT_ARG_REG THEN  ;   /*   ARG IN PLACE ALREADY   */\n         ELSE CALL EMIT_RR(LER,FLT_ARG_REG - 16,ACC - 16);\n      END;\n      ELSE\n         CALL EMIT_RX(LE,FLT_ARG_REG - 16, X_REG,BASE_REG,DISPL);\n      PRIORITY(16) = TEMP_PRIORITY;\n      CALL ASSIGN_TEMP(16);   /*   VALUE IS RETURNED IN FLT REG 0   */\n      OP2 = LAST_TEMP;   /*   ASSIGN A TEMP TO THE VALUE WHICH IS RETURNED\n         IN FLT REG 0           */\n      /*   SAVE PASCAL GENERAL REG USAGE   */\n      IF SERVICE_CODE = 3 THEN    /*  CALL TO EXP-NEEDS MORE REGS   */\n      DO;\n         I = 4;\n         J = 15;\n      END;\n      ELSE DO;\n         I = 2;\n         J = 14;\n      END;\n      /*   DETERMINE WHICH REGS NEED TO BE FLUSHED   */\n      DO WHILE  I > -1 & PRIORITY(I) \u00ac= FREE_PRIORITY;\n         I = I - 1;\n      END;\n      IF I = -1 THEN I = J;\n      CALL EMIT_RX(STM,13,I,ORG,PASCAL_REGS + 8);\n      CALL FLUSH_REG(LINK);\n      /*   LOAD ONLY ONE BASE REG - REG 13   */\n      CALL EMIT_RX(LOAD,13,0,ORG,MON_BASE_REGS + 8);\n      CALL EMIT_RX(BAL,LINK,0,13,SERVICE_CODE * 4 + 72);\n END REAL_ARG_REAL_VALUE;\n\n ONE_INT_ARG_INT_VALUE: PROCEDURE;\n      CALL MAKE_ADDRESSABLE(OP1);\n      CALL FLUSH_REG(9);\n      IF IN_REG & ACC = 9 THEN ;\n      ELSE CALL GET_OP_INTO_REG#(9);\n      PRIORITY(9) = TEMP_PRIORITY;\n      CALL ASSIGN_TEMP(9);\n      OP2 = LAST_TEMP;\n      CALL GEN_TRANSFER_TO_MONITOR;\n END ONE_INT_ARG_INT_VALUE;\n\n INT_ARGS: PROCEDURE;\n      /*   GENERATES MONITOR CALLS WHICH HAVE ONE OR TWO INTEGER ARGUMENTS  */\n      IF OP2 \u00ac= NULL THEN DO;\n         CALL MAKE_ADDRESSABLE(OP2);\n         CALL FLUSH_REG(8);\n         IF IN_REG & ACC = 8 THEN   ;\n         ELSE CALL GET_OP_INTO_REG#(8);\n      END;\n      CALL MAKE_ADDRESSABLE(OP1);\n      CALL FLUSH_REG(9);\n      IF IN_REG & ACC = 9 THEN ;\n      ELSE CALL GET_OP_INTO_REG#(9);\n      CALL GEN_TRANSFER_TO_MONITOR;\n END INT_ARGS;\n\n\n INSERT_SUBRANGE: PROCEDURE;\n      DECLARE (A,S_REG) BIT(16);\n\n PREPARE_RANGE_OPERANDS: PROCEDURE;\n      CALL MAKE_ADDRESSABLE(OP1);\n      CALL GET_OP_INTO_REG(BASE_PRIORITY);\n      PRIORITY(ACC) = FIXED_PRIORITY;\n      A = ACC;\n      ACC = GET_REG(BASE_PRIORITY);\n      PRIORITY(ACC) = FIXED_PRIORITY;\n      CALL EMIT_RR(LR,ACC,A);\n      CALL GENERATE_OPERATION(S,SR,SH,ACC,OP2);\n END PREPARE_RANGE_OPERANDS;\n\n      OP_STORAGE_LENGTH = GET_STOR_LEN(TRIPLES(CURRENT_TRIPLE + 5) );\n      IF OP_STORAGE_LENGTH <= 4 THEN\n      DO;\n         CALL PREPARE_RANGE_OPERANDS;\n         S_REG = GET_REG(FREE_PRIORITY);\n         /*   FORM A MASK WITH THE SPECIFIED BITS SET. THIS IS ACCOMPLISHED\n              BY LOADING A REG WITH ALL ONES AND SHIFTING OUT ALL THOSE\n              WHOSE ORDINALITIES ARE OUTSIDE THE GIVEN SUBRANGE   */\n         CALL EMIT_RX(LOAD,S_REG,0,ORG,CONSTM1);\n         CALL EMIT_RX(SLL,S_REG,0,ACC,31);\n         CALL EMIT_RX(SRL,S_REG,0,A,0);\n         PRIORITY(A),PRIORITY(ACC) = FREE_PRIORITY;\n         CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n         IF LIST_CODE THEN CALL PRINT_TRIPLE(CURRENT_TRIPLE);\n         /*   STORE IN TEMP STORAGE AREA IN ORG SEGMENT   */\n         CALL EMIT_RX(ST,S_REG,0,ORG,DS1);\n         /*   OR THE MASK INTO THE SPECIFIED SET   */\n         CALL MAKE_ADDRESSABLE(OP2);   /*   SET GIVEN IN OP2 OF INTO TRIPLE */\n         IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n         CALL EMIT_SS(OC,OP_STORAGE_LENGTH - 1,BASE_REG,DISPL,ORG,DS1);\n      END;\n      ELSE IF OP_STORAGE_LENGTH <= 8 THEN\n      DO;\n         CALL PREPARE_RANGE_OPERANDS;\n         S_REG = GET_REG_PAIR;\n         CALL EMIT_RX(LM,S_REG,S_REG+1,ORG,CONSTM1);\n         CALL EMIT_RX(SLDL,S_REG,0,ACC,63);\n         CALL EMIT_RX(SRDL,S_REG,0,A,0);\n         PRIORITY(A),PRIORITY(ACC) = FREE_PRIORITY;\n         CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n         IF LIST_CODE THEN CALL PRINT_TRIPLE(CURRENT_TRIPLE);\n         /*   STORE IN TEMP STORAGE AREA IN ORG SEGMENT   */\n         CALL EMIT_RX(STM,S_REG,S_REG+1,ORG,DS1);\n         /*   OR THE MASK INTO THE SPECIFIED SET   */\n         CALL MAKE_ADDRESSABLE(OP2);   /*   SET GIVEN IN OP2 OF INTO TRIPLE */\n         IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n         CALL EMIT_SS(OC,OP_STORAGE_LENGTH - 1,BASE_REG,DISPL,ORG,DS1);\n      END;\n      ELSE DO;\n         /*   STORAGE LENGTH OF GIVEN SET > 8 BYTES. FORMING THE MASK\n              CANNOT BE DONE CONVENIENTLY IN REGISTERS. DO OFFLINE IN\n              CALL TO MONITOR          */\n\n         SERVICE_CODE = 34;\n         CALL INT_ARGS;\n         CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n         IF LIST_CODE THEN CALL PRINT_TRIPLE(CURRENT_TRIPLE);\n         /*  R9 RETURNS THE ADDRESS OF THE MASK TO BE OR'D IN  */\n         PRIORITY(9) = FIXED_PRIORITY;\n         CALL MAKE_ADDRESSABLE(OP2);\n         IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n         CALL EMIT_SS(OC,OP_STORAGE_LENGTH - 1, BASE_REG,DISPL,9,0);\n         PRIORITY(9) = FREE_PRIORITY;\n         ;\n      END;\n END INSERT_SUBRANGE;\n\n\n\n      /*   TO ASSOCIATE LINE NUMBERS IN THE PASCAL SOURCE WITH INSTRUCTIONS\n           IN THE GENERATED CODE, A LINE# ARRAY IS USED. WHENEVER THE LINE\n           NUMBER CHANGES (AS INDICATED BY A BIT IN THE TRIPLES FOR A\n           CHANGE OF 1 OR BY A LINE# TRIPLE IF THE CHANGE IS BY MORE THAN ONE)\n           AN ENTRY (OR ENTRIES) IS MADE IN THE LINE# ARRAY, (INDEXED BY THE\n           LINE NUMBER(S) ) CONTAINING THE CURRENT DISPLACEMENT RELATIVE TO\n           THE BEGINNING OF THE ENTIRE CODE SEGMENT. (IN PRACTICE, A SMALL\n           BUFFER IS USED, AND WHEN FULL, IS IMMEDIATELY SWAPPED OUT TO A\n           LINE# FILE.). IN THIS WAY, THE MONITOR CAN DETERMINE WHICH HIGH\n           LEVEL (PASCAL) STATEMENT WAS BEING EXECUTED WHEN A RUN ERROR OCCURS,\n           BY SEARCHING THE LINE# ARRAY FOR THE GREATEST LOWER BOUND TO\n           THE RELATIVE DISPLACEMENT OF THE LAST EXECUTED INSTRUCTION IN THE\n           PASCAL CODE, TAKING AS THE LINE NUMBER THE ASSOCIATED INDEX.     */\n\n\n NEXT_LINE: PROCEDURE(LINE#);\n\n      /*   USED FOR UPDATING THE LINE# ARRAY WHEN THE CURRENT LINE CHANGES.\n           WHEN THE LINE# BUFFER IS FULL, IT IS WRITTEN OUT TO THE LINE# FILE,\n           AND LINE_BUFF_PTR IS RESET.                               */\n\n      DECLARE LINE# BIT(16);\n      DO I = CURRENT_LINE# + 1 TO LINE#;\n         LINE#BUFF(LINE_BUFF_PTR) = CODE_INDEX + ENTRY_POINT;\n         LINE_BUFF_PTR = LINE_BUFF_PTR + 1;\n         IF LINE_BUFF_PTR > 20 THEN DO;\n         /*   OUTPUT THE FULL BUFFER. NOTE THE \"DESCRIPTOR\" FOR LINE#BUFF\n         (LINE_NUMS) HAS BEEN SET IN INITIALIZE   */\n            OUTPUT(LINE#FILE) = LINE_NUMS;\n            LINE_BUFF_PTR = 1;\n         END;\n      END;\n      CURRENT_LINE# = LINE#;\n      IF LIST_CODE THEN OUTPUT(1) = '+' || X70 || SPACE 40X || 'LINE# ' ||\n         CURRENT_LINE#;\n END NEXT_LINE;\n\n\n\n       /*           C O D E   G E N E R A T I O N                  */\n\n\n GENERATE_CODE: PROCEDURE;\n\n\n      /*     GENERATES CODE FOR THE CURRENT SET OF TRIPLES        */\n\n      CODE_INDEX = 0;\n      CURRENT_TRIPLE = 9;\n      CALL NEXT_LINE(TRIPLES(7));   /*FILL IN LINE# VECTOR ELEMENTS DENOTED\n                             /*   BY FIRST LINE# TRIPLE   */\n      CURRENT_LEVEL = PSEUDO_REG( CURRENT_PROCEDURE ) + 1;\n      CURRENT_PROC_SEQ# = TRIPLES(1);\n      /*   MAKE ENTRY INTO TRANSFER VECTOR FOR CURRENT PROCEDURE   */\n      TRANSFER_VECTOR(CURRENT_PROC_SEQ#) = ENTRY_POINT;\n      /*  STORE CURRENT_AR_BASE INTO DISPLAY          */\n      IF CURRENT_LEVEL \u00ac= 1 THEN\n         CALL EMIT_RX(ST,CURRENT_AR_BASE,0,CURRENT_AR_BASE,CURRENT_LEVEL*4+12);\n\n      /*  STORE RETURN ADDRESS INTO A.R.   */\n      CALL EMIT_RX(ST,LINK,0,CURRENT_AR_BASE,4);\n      /*   STORAGE LENGTH ENTRY FOR A PROCEDURE CONTAINS ITS ACTIVATION\n           RECORD SIZE.  COMPUTE THE STACKTOP FROM THE A.R. BASE ADDRESS\n           & THE A.R.  SIZE                             */\n      DISPL = STORAGE_LENGTH(CURRENT_PROCEDURE);\n      CALL CHECK_MULT_OF_4096;\n      CALL EMIT_RX(LA,STACKTOP,CURRENT_AR_BASE,X_REG,DISPL);\n      /*   CHECK FOR OVERFLOW OF RUN-TIME STORAGE    */\n      CALL EMIT_RX(C,STACKTOP,0,ORG,MAX_TOP);\n      CALL EMIT_RX(BC,BH,0,ORG,MEM_OVERFLOW);\n\n      DO FOREVER;\n\n      IF LIST_CODE THEN CALL PRINT_TRIPLE(CURRENT_TRIPLE);\n      IF (TRIPLES(CURRENT_TRIPLE) & LINE#MASK) \u00ac= 0 THEN\n         CALL NEXT_LINE(CURRENT_LINE# + 1);\n\n      DO CASE (TRIPLES(CURRENT_TRIPLE) & TRIPLE_OP_MASK);\n\n      /*   LOAD   */\n      CALL LOAD_OPERAND;\n\n\n      /*   MONITOR CALL   */\n\n\n\n      /*   THIS TRIPLE INDICATES A SERVICE CALL TO THE PASCAL RUN MONITOR\n           IS TO BE MADE. OP1 , OP2 INDICATE THE ARGUMENTS, IF ANY, AND\n           THE SERVICE CODE IS IN THE LENGTH FIELD.\n               TO PASS INTEGER ARGUMENTS, REGS 9 & 8 ARE USED FOR\n           OPERANDS 1, 2, RESPECTIVELY. REG 9, WHICH IS ASSIGNED A TEMPORARY,\n           IS USED TO RETURN INTEGER VALUES. (BY \"INTEGER\" IT IS MEANT\n           ANY NUMERICAL QUANTITY WHICH CAN BE PROCESSED IN A GENERAL REG-\n           ISTER SUCH AS BOOLEANS, INTEGER, OR ADDRESSES).\n           FLT REG 6 IS USED TO PASS REAL ARGUMENTS.                 */\n\n      DO;\n      SERVICE_CODE = SHR(TRIPLES(CURRENT_TRIPLE),8);\n      DO CASE SERVICE_CODE;\n         /*   CASE  0 - SIN  */\n         CALL REAL_ARG_REAL_VALUE;\n         /*   CASE  1 - COS  */\n         CALL REAL_ARG_REAL_VALUE;\n         /*   CASE  2 - ARCTAN  */\n         CALL REAL_ARG_REAL_VALUE;\n         /*   CASE  3 - EXP   */\n         CALL REAL_ARG_REAL_VALUE;\n         /*   CASE  4 - LN  */\n         CALL REAL_ARG_REAL_VALUE;\n         /*   CASE  5 - SQRT  */\n         CALL REAL_ARG_REAL_VALUE;\n         /*   CASE  6 - ABSFLT  */\n         /*   DONE INLINE   */   ;\n         /*   CASE  7 - SQRFLT  */\n         /*   DONE INLINE   */   ;\n         /*   CASE  8 - ROUND  */\n         /*   DONE INLINE   */   ;\n         /*   CASE  9 - TRUNC  */\n         /*   DONE INLINE   */   ;\n         /*   CASE 10 - ABS  */\n         /*   DONE INLINE   */   ;\n         /*   CASE 11 - SQR  */\n         /*   DONE INLINE   */   ;\n         /*   CASE 12 - ODD  */\n         /*   DONE INLINE   */   ;\n         /*   CASE 13 - EOLN  */\n         CALL ONE_INT_ARG_INT_VALUE;\n         /*   CASE 14 - EOF  */\n         CALL ONE_INT_ARG_INT_VALUE;\n         /*   CASE 15 - NEW  */\n         CALL ONE_INT_ARG_INT_VALUE;\n         /*   CASE 16 - DISPOSE  */\n         ;\n         /*   CASE 17 - GET  */\n         CALL INT_ARGS;\n         /*   CASE 18 - PUT  */\n         CALL INT_ARGS;\n         /*   CASE 19 - RESET  */\n         CALL INT_ARGS;\n         /*   CASE 20 - REWRITE  */\n         CALL INT_ARGS;\n         /*   CASE 21 - READ_INT  */\n         CALL ONE_INT_ARG_INT_VALUE;\n         /*   CASE 22 - READ_REAL  */\n         DO;\n            CALL FLUSH_REG(22);\n            PRIORITY(22) = TEMP_PRIORITY;\n            CALL ASSIGN_TEMP(22);\n            CALL INT_ARGS;\n            OP2 = LAST_TEMP;\n         END;\n         /*   CASE 23 - READ_CHAR  */\n         CALL ONE_INT_ARG_INT_VALUE;\n         /*   CASE 24 - WRITE_INT  */\n         CALL INT_ARGS;\n         /*   CASE 25 - WRITE_REAL  */\n         DO;\n            CALL MAKE_ADDRESSABLE(OP1);\n            CALL FLUSH_REG(9);\n            IF IN_REG & ACC = 9 THEN ;\n            ELSE CALL GET_OP_INTO_REG#(9);\n            CALL MAKE_ADDRESSABLE(OP2);\n            CALL FLUSH_REG(22);\n            IF IN_REG THEN DO;\n               IF ACC = 22 THEN ;\n               ELSE CALL EMIT_RR(LER,6,ACC - 16);\n            END;\n            ELSE CALL EMIT_RX(LE,6,X_REG,BASE_REG,DISPL);\n            CALL GEN_TRANSFER_TO_MONITOR;\n         END;\n         /*   CASE 26 - WRITE_BOOL  */\n         CALL INT_ARGS;\n         /*   CASE 27 - WRITE_CHAR  */\n         CALL INT_ARGS;\n         /*   CASE 28 - WRITE_STRING  */\n         CALL INT_ARGS;\n         /*   CASE 29 - READLN  */\n         CALL INT_ARGS;\n         /*   CASE 30 - WRITELN  */\n         CALL INT_ARGS;\n         /*   CASE 31 - PAGE  */\n         CALL INT_ARGS;\n         /*   CASE 32 - RANGE_ERR  */\n         /*   HERE MOST OF THE SETUP INSTRUCTIONS ARE DONE OFFLINE IN\n              THE ORG SEGMENT TO SAVE CODE , AS THIS CALL MAY OCCUR\n              QUITE FREQUENTLY.                        */\n         CALL EMIT_RX(BAL,LINK,0,ORG,SUBRANGE_ERROR);\n         /*   CASE 33 - MEM_OVFLO  */\n         /*   HANDLED ELSEWHERE   */   ;\n\n         /*   CASE 34 - INSERT SUBRANGE   */\n         /*   HANDLED ELSEWHERE   */\n      ;\n\n         /*   CASE 35 - CLOCK   */\n           /*   RETURNS THE VALUE OF THE CLOCK - NO ARGUMENTS   */\n         DO;\n            CALL FLUSH_REG(9);\n            PRIORITY(9) = TEMP_PRIORITY;\n            CALL ASSIGN_TEMP(9);\n            OP2 = LAST_TEMP;\n            CALL GEN_TRANSFER_TO_MONITOR;\n         END;\n      END;\n\n      END;   /*   MONITOR CALLS   */\n\n\n      /*   TRUNCATE   */\n      DO;\n         FLT_REG = GET_FLT_REG(FREE_PRIORITY);\n         FLT_ACC = FLT_REG - #GP_REGS;\n         CALL EMIT_RR(SDR,FLT_ACC,FLT_ACC);\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF IN_REG THEN CALL EMIT_RR(LER,FLT_ACC,ACC - #GP_REGS);\n         ELSE CALL EMIT_RX(LE,FLT_ACC,X_REG,BASE_REG,DISPL);\n         /*   ADD AN UNNORMALIZED FP 0 TO CAUSE LOSS OF FRACTION DURING\n            PRE-NORMALIZATION                      */\n         CALL EMIT_RX(AW,FLT_ACC,ORG,0,CON4E);\n         /*   STORE ENTIRE FP REG INTO WORK AREA     */\n         CALL EMIT_RX(STD,FLT_ACC,0,ORG,DS1);\n         ACC = GET_REG(TEMP_PRIORITY);   /*  ACC WILL CONTAIN TRUNC RESULT  */\n         CALL ASSIGN_TEMP(ACC);\n         /*   PUT LOWER ORDER HALF (WHICH IS THE DESIRED RESULT) INTO TEMP REG*/\n         CALL EMIT_RX(LOAD,ACC,0,ORG,DS1 + 4);\n         /*   TEST IF ORIGINAL ARG WAS NEGATIVE   */\n         CALL EMIT_RR(LTDR,FLT_ACC,FLT_ACC);\n         CALL FORWARD_CODE_BRANCH(BNL,6);\n         CALL EMIT_RR(LCR,ACC,ACC);\n         OP2 = LAST_TEMP;\n      END;\n\n      /*   FLOAT   */\n      DO;\n         ACC1 = GET_REG(FIXED_PRIORITY);\n         CALL MAKE_ADDRESSABLE(OP1);\n         CALL GET_OP_INTO_REG(FREE_PRIORITY);\n         CALL EMIT_RR(LPR,ACC1,ACC);   /*  LOAD ABS(OP1) INTO A GEN REG  */\n         CALL EMIT_RX(ST,ACC1,0,ORG,DS4E + 4);\n         /*  DS4E WOULD NOW CONTAIN FP ABS(OP1)       */\n         FLT_REG = GET_FLT_REG(TEMP_PRIORITY);\n         FLT_ACC = FLT_REG - #GP_REGS;\n         CALL EMIT_RX (LD,FLT_ACC,0,ORG,DS4E);\n         /*   GET INTO A FLT REG       */\n         CALL EMIT_RX(AD,FLT_ACC,0,ORG,CONSTD0);\n         /*   ADD FLT PT 0 TO FORCE NORMALIZATION     */\n         CALL EMIT_RR(LTR,ACC,ACC);  /*  TEST IF OPERAND WAS NEGATIVE  */\n         CALL FORWARD_CODE_BRANCH(BNL,6);\n         CALL EMIT_RR(LCDR,FLT_ACC,FLT_ACC);\n         PRIORITY(ACC1) = FREE_PRIORITY;\n         CALL ASSIGN_TEMP(FLT_REG);\n         OP2 = LAST_TEMP;\n      END;\n\n      /*     BCH_TARGET     */\n\n      DO;\n         IF SHR(TRIPLES(CURRENT_TRIPLE),8) = 0 THEN   /*  A NEW BASIC BLOCK\n            IS BEING ENTERED   */   CALL FLUSH_ALL_REGS;\n         OPERAND1 = OP1;\n         IF OPERAND1 \u00ac= NULL THEN\n         DO;      /*  BRANCH TARGET REPRESENTS A USER DEFINED LABEL. THE\n                 /*  FIRST OPERAND POINTS TO THE SY TABLE ENTRY FOR THAT LABEL*/\n\n             IF PSEUDO_REG(OPERAND1) \u00ac= NULL THEN  /* A SEG# HAS BEEN\n                ASSIGNED,INDICATING EXTERNAL REFS HAVE BEEN MADE.\n                FILL IN THE TRANSFER VECTOR ENTRY                 */\n             TRANSFER_VECTOR( PSEUDO_REG(OPERAND1) ) = CODE_INDEX +\n           TRANSFER_VECTOR ( CURRENT_PROC_SEQ# );\n             /* REPLACE TRIPLE# WITH DISPL,SET A MASK BIT.   */\n             DISP(OPERAND1) = \"80000000\" + CODE_INDEX;\n         END;\n         IF OP2 \u00ac= NULL THEN CALL FIXUP(OP2);\n         /*   NOW PUT DISPL IN FIRST OPERAND.   */\n         OP1 = CODE_INDEX;\n\n      END;\n      /*   INDEX   */\n         /*   GENERATES NO CODE UNTIL REFERENCED    */\n       ;\n      /*   TEMP   */\n      /*   CREATE A TEMPORARY WITH THE VALUE OF OP1   */\n      DO;\n         IF OP2 = NULL THEN  /*   INTEGER OR BOOLEAN TO BE CONTAINED IN A REG */\n         DO;\n            IF OP1 \u00ac= NULL THEN CALL LOAD_OPERAND;\n            ELSE DO;\n               ACC = GET_REG(TEMP_PRIORITY);\n               CALL ASSIGN_TEMP(ACC);\n               OP2 = LAST_TEMP;\n            END;\n         END;\n         ELSE\n         DO;\n            OP_STORAGE_LENGTH = SHR(TRIPLES(CURRENT_TRIPLE), 8) + 1;\n            IF OP1 \u00ac= NULL THEN DO;\n               CALL MAKE_ADDRESSABLE(OP1);\n               IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n               DISPL1 = DISPL;\n               DISPL = NEXT_TEMP_DISPL;\n               CALL CHECK_MULT_OF_4096;\n               CALL GET_TEMP_BYTES(OP_STORAGE_LENGTH);\n               CALL EMIT_SS(MVC,OP_STORAGE_LENGTH - 1,STACKTOP,DISPL,\n                  BASE_REG,DISPL1);\n            END;\n            ELSE  CALL GET_TEMP_BYTES(OP_STORAGE_LENGTH);\n            OP2 = LAST_TEMP;\n         END;\n\n      END;   /*   TEMP   */\n      /*   STORE   */\n      DO;\n         CALL CHECK_STATUS(OP1);\n         IF IN_REG THEN   /*  TARGET IS A TEMP WHICH IS ASSIGNED THE REG ACC */\n         DO;\n            PRIORITY(ACC) = FIXED_PRIORITY;\n            ACC1 = ACC;\n            CALL MAKE_ADDRESSABLE(OP2);\n            IF IN_REG THEN CALL EMIT_RR(LR,ACC1,ACC);\n            ELSE CALL GET_OP_INTO_REG#(ACC1);\n            PRIORITY(ACC1) = TEMP_PRIORITY;\n         END;\n         ELSE\n         CALL MOVE_OP;\n      END;\n\n      /*   MOVE   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP2);\n         CALL MOVE_STRING;\n      END;\n      /*   ADD   */\n      DO;\n         CALL CHECK_STATUS(OP2);\n         IF IN_FREE_REG THEN\n         DO;\n            PRIORITY(ACC) = TEMP_PRIORITY;\n            CALL GENERATE_OPERATION(A,AR,AH,ACC,OP1);\n         END;\n         ELSE IF IMMED(OP2) THEN DO;\n            ACC = GET_REG(TEMP_PRIORITY);\n            CALL EMIT_RX(LA,ACC,0,0,OP2 & STRIPMASK);\n            CALL GENERATE_OPERATION(A,AR,AH,ACC,OP1);\n         END;\n         ELSE DO;\n            CALL MAKE_ADDRESSABLE(OP1);\n            CALL GET_OP_INTO_REG(TEMP_PRIORITY);\n            CALL GENERATE_OPERATION(A,AR,AH,ACC,OP2);\n         END;\n         CALL ASSIGN_TEMP(ACC);\n         OP2 = LAST_TEMP;\n      END;\n      /*   SUBTRACT   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         CALL GET_OP_INTO_REG(TEMP_PRIORITY);\n         IF IMMED(OP2) & ((OP2 & STRIPMASK) = 1)  /*  IMMEDIATE \"1\"   */\n            THEN CALL EMIT_RR(BCTR,ACC,0);\n         ELSE\n            CALL GENERATE_OPERATION(S,SR,SH,ACC,OP2);\n         CALL ASSIGN_TEMP(ACC);\n         OP2 = LAST_TEMP;\n      END;\n      /*   MULTIPLY   */\n  DO;\n      IF IMMED_POWER_OF_2(OP2) THEN\n      DO;\n         CALL LOAD_OPERAND;\n         IF POWER > 1 THEN CALL EMIT_RX(SLA,ACC,0,0,POWER);\n         ELSE IF POWER = 1 THEN CALL EMIT_RR(AR,ACC,ACC);\n      END;\n      ELSE\n      DO;\n         IF DOUBLE_REG_STATUS(OP1) THEN\n            CALL GENERATE_OPERATION(M,MR,MH,EVEN_REG,OP2);\n         ELSE IF DOUBLE_REG_STATUS(OP2) THEN\n            CALL GENERATE_OPERATION(M,MR,MH,EVEN_REG,OP1);\n       ELSE DO;\n         CALL CHECK_STATUS(OP2);\n         IF IN_REG THEN\n         DO;\n            CALL GET_INTO_ODD_REG;\n            CALL GENERATE_OPERATION(M,MR,MH,EVEN_REG,OP1);\n         END;\n         ELSE\n         DO;\n            CALL MAKE_ADDRESSABLE(OP1);\n            CALL GET_INTO_ODD_REG;\n            CALL GENERATE_OPERATION(M,MR,MH,EVEN_REG,OP2);\n         END;\n       END;\n         CALL RESET_PAIR_PRIORITIES(FREE_PRIORITY,TEMP_PRIORITY);\n         CALL ASSIGN_TEMP(ODD_REG);\n         OP2 = LAST_TEMP;\n      END;\n  END;\n\n      /*   DIVIDE   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n      /*  OPTIMIZE LATER BY TESTING IF DIVIDEND IS A RESULT OF AN EARLIER\n          MULTIPLY, ELIMINATING THE NEED TO FORCE THE SIGN INTO THE EVEN REG */\n         IF OP_STORAGE_LENGTH = 1 THEN DO;\n            CALL GET_INTO_ODD_REG;\n            CALL EMIT_RR(SR,EVEN_REG,EVEN_REG);\n         END;\n         ELSE DO;\n            CALL GET_INTO_EVEN_REG;\n            CALL EMIT_RX(SRDA,EVEN_REG,0,0,32);\n         END;\n         CALL GENERATE_OPERATION(D,DR,NULL,EVEN_REG,OP2);\n         CALL RESET_PAIR_PRIORITIES(FREE_PRIORITY,TEMP_PRIORITY);\n         CALL ASSIGN_TEMP(ODD_REG);\n         OP2 = LAST_TEMP;\n      END;\n      /*   COMPARE   */\n      CALL GEN_INTEGER_COMPARE(BE,BE);\n      /*   ADD_DECIMAL   */\n      /*   GENERATE AN INCREMENT OF THE BASIC BLOCK COUNTER GIVEN IN OP1  */\n\n      DO;\n         DISPL = 4 * (OP1 & STRIPMASK) + BLOCK_COUNTER_BASE;\n         IF DISPL < 4096 THEN\n            CALL EMIT_SS(AP,\"33\",ORG,DISPL,ORG,DEC1);\n         ELSE   /*  BLOCK COUNTERS NO LONGER DIRECTLY ADDRESSABLE. WE\n                    ALLOW A POSSIBLY EXPENSIVE INDEXING OPERATION RATHER\n                    THAN GIVE UP.                                  */\n         DO;\n            BASE_REG = ORG;\n            CALL CHECK_MULT_OF_4096;\n            CALL LOAD_ADDRESS;\n            CALL EMIT_SS(AP,\"33\",BASE_REG,DISPL,ORG,DEC1);\n         END;\n      END;\n\n      /*   GREATER   */\n      CALL GEN_INTEGER_COMPARE(BH,BL);\n      /*   LESS   */\n      CALL GEN_INTEGER_COMPARE(BL,BH);\n      /*   NOT   */\n      DO;\n         CALL LOAD_OPERAND;\n         CALL EMIT_RX(XOR,ACC,0,ORG,CONST1);\n      END;\n      /*   ADDFLT   */\n      DO;\n         CALL CHECK_STATUS(OP2);\n         IF IN_FREE_REG THEN DO;\n            FLT_REG = ACC;\n            CALL GENERATE_FLT_OPERATION(AE,AER,OP1);\n         END;\n         ELSE DO;\n            CALL MAKE_ADDRESSABLE(OP1);\n            CALL GET_OP_INTO_FLT_REG(TEMP_PRIORITY);\n            CALL GENERATE_FLT_OPERATION(AE,AER,OP2);\n         END;\n      END;\n      /*   SUBTRACTFLT   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         CALL GET_OP_INTO_FLT_REG(TEMP_PRIORITY);\n         CALL GENERATE_FLT_OPERATION(SE,SER,OP2);\n      END;\n      /*   MPYFLT   */\n      DO;\n         CALL CHECK_STATUS(OP2);\n         IF IN_FREE_REG THEN DO;\n            FLT_REG = ACC;\n            CALL GENERATE_FLT_OPERATION(ME,MER,OP1);\n         END;\n         ELSE DO;\n            CALL MAKE_ADDRESSABLE(OP1);\n            CALL GET_OP_INTO_FLT_REG(TEMP_PRIORITY);\n            CALL GENERATE_FLT_OPERATION(ME,MER,OP2);\n         END;\n      END;\n      /*   DIVFLT   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         CALL GET_OP_INTO_FLT_REG(TEMP_PRIORITY);\n         CALL GENERATE_FLT_OPERATION(DE,DER,OP2);\n      END;\n      /*   COMPAREFLT   */\n      CALL GEN_FLT_COMPARE(BE,BE);\n      /*   GREATERFLT   */\n      CALL GEN_FLT_COMPARE(BH,BL);\n      /*   LESSFLT   */\n      CALL GEN_FLT_COMPARE(BL,BH);\n\n      /*  LOAD ADDR  */\n\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         CALL LOAD_ADDRESS;\n         PRIORITY(BASE_REG) = TEMP_PRIORITY;\n         CALL ASSIGN_TEMP(BASE_REG);\n         OP2 = NEXT_TEMP - 1;\n      END;\n\n      /*   AND   */\n      CALL GENERATE_STRING_OPERATION(NC);\n      /*   OR   */\n      CALL GENERATE_STRING_OPERATION(OC);\n      /*   XOR   */\n      DO;\n         IF GET_STOR_LEN(OP2) > 256 THEN CALL GEN_LONG_SS_OP(XC);\n         /*   ALLOW LONG XOR'S FOR ZEROING OUT ACTIVATION RECORDS   */\n         ELSE CALL GENERATE_STRING_OPERATION(XC);\n      END;\n      /*   LSHIFT   */\n      CALL LOGICAL_SHIFT(SLL);\n      /*   RSHIFT   */\n      CALL LOGICAL_SHIFT(SRL);\n      /*   CASE 31   */\n     ;\n\n      /*  BRANCH   */\n      DO;\n         OPERAND1 = OP1 & STRIPMASK;\n            IF OP2 = NULL | (OP2 & STRIPMASK) = CURRENT_PROC_SEQ# THEN\n            CALL LOCAL_BRANCH(UNCOND,OP1);\n             ELSE    /*  A PROCEDURE EXIT VIA GOTO     */\n             DO;\n                /*  GENERATE RELOAD OF CODE_BASE OF OWNER FROM XFER VECTOR  */\n                DISPL = TRANSFER_VECTOR_BASE + 4 * ( OP2 & STRIPMASK );\n                CALL CHECK_MULT_OF_4096;\n                CALL EMIT_RX(LOAD,CODE_BASE,X_REG,ORG,DISPL);\n                /*  RELOAD CURRENT_AR_BASE FROM STATIC DISPLAY, USING\n                   PSEUDO_REG AS INDEX. RECALL PSEUDO_REG ENTRY FOR A PROC\n                   IS THE LEX LEVEL OF ITS B O D Y  - 1;         */\n\n                IF PSEUDO_REG (OWNER(OPERAND1) ) = 0 THEN\n                /* EXITING TO GLOBAL ENVIRONMENT        */\n                CALL EMIT_RR(LR,CURRENT_AR_BASE,GLOBAL_AR_BASE);\n                ELSE\n                CALL EMIT_RX(LOAD,CURRENT_AR_BASE,0,CURRENT_AR_BASE,16 +\n                   PSEUDO_REG (OWNER (OPERAND1 ) ) * 4 );\n\n                /*   RELOAD STACKTOP    */\n                DISPL = STORAGE_LENGTH( OWNER(OPERAND1) );\n                CALL CHECK_MULT_OF_4096;\n                CALL EMIT_RX(LA,STACKTOP,X_REG,CURRENT_AR_BASE,DISPL);\n                /*  GET THE TARGET ADDRESS FROM THE XFER VEC & EMIT BR  */\n                IF PSEUDO_REG(OPERAND1) = NULL THEN\n                DO;   /*  SEQ# NOT YET ASSIGNED. ASSIGN ONE FROM NEXT_SEQ#   */\n                   IF NEXT_SEQ# > TRANSFER_VECTOR_SIZE THEN CALL ERROR\n                   ('TRANSFER VECTOR EXCEEDS MAX ALLOWED SIZE');\n                   PSEUDO_REG(OPERAND1) = NEXT_SEQ#;\n                   IF DISP(OPERAND1) & \"80000000\" \u00ac= 0 THEN  /*  DISPLACEMENT\n                   IS KNOWN - ENTER IT IN THE TRANSFER VECTOR.    */\n                   TRANSFER_VECTOR(NEXT_SEQ#) = (\"7FFFFFFF\" & DISP(OPERAND1) )\n                   + TRANSFER_VECTOR(OP2 & STRIPMASK);\n                   DISPL = NEXT_SEQ# * 4 + TRANSFER_VECTOR_BASE;\n                   NEXT_SEQ# = NEXT_SEQ# + 1;\n                END;\n                ELSE DISPL = TRANSFER_VECTOR_BASE + PSEUDO_REG(OPERAND1) * 4;\n                CALL CHECK_MULT_OF_4096;\n                /*  GENERATE A LOAD OF ADDR FROM XFER VECTOR         */\n                CALL EMIT_RX(LOAD,LINK,X_REG,ORG,DISPL);\n                CALL EMIT_RR(BCR,UNCOND,LINK);   /*  GENERATE BRANCH     */\n             END;   /* \"EXTERNAL GOTO   */  ;\n      END;\n\n      /*   BNZ   */\n      CALL TEST_FOR_BOOLEAN_0(BNE);\n      /*   BZ   */\n      CALL TEST_FOR_BOOLEAN_0(BE);\n\n      /*   BCT   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP2);\n         CALL GET_OP_INTO_REG(FREE_PRIORITY);\n         CALL EMIT_RR(LTR,ACC,ACC);\n         CALL FORWARD_BRANCH(BNH,OP1 & STRIPMASK);\n         CALL EMIT_RR(BCTR,ACC,0);\n      END;\n\n\n\n\n      /*    PCALL    */\n\n\n   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    *                                                                     *\n    *                                                                     *\n    *    A PROCEDURE OR FUNCTION CALL SEQUENCE IS ALWAYS INITIATED BY     *\n    *    A BLKMARK TRIPLE, WHOSE OPERANDS ARE IDENTICAL TO THOSE OF THE   *\n    *    PCALL TRIPLE:  OP1 INDICATES THE PROCEDURE TO BE CALLED, OP2     *\n    *    INDICATES THE SEQUENCE # OF THAT PROCEDURE. THE LATTER IS NULL   *\n    *    FOR A FORMAL PROCEDURE CALL.                                     *\n    *    THE BLKMARK TRIPLE GENERATES CODE TO COPY THE DISPLAY & FILL IN  *\n    *    THE DYNAMIC LINK, STACKTOP, CODE BASE INTO THE NEW ACTIVATION    *\n    *    RECORD.                                                          *\n    *    PARM TRIPLES GENERATE CODE TO MOVE ARGUMENTS INTO THE A.R.       *\n    *    PCALL GENERATES A LOAD FROM THE TRANSFER VECTOR, A RELOAD OF     *\n    *    CURRENT_AR_BASE, & BRANCH & LINK.  THE CALLED PROCEDURE UPDATES  *\n    *    THE STACKTOP & ENTERS THE RETURN ADDRESS INTO THE A.R.           *\n    *    FOR FORMAL PROCEDURE CALLS, THE TRANSFER VECTOR INDEX, DISPLAY-  *\n    *    SIZE, AND ENVIRONMENT BASE MUST BE FOUND AT RUNTIME FROM THE     *\n    *    DESCRIPTOR ENTRY CORRESPONDING TO THE CALLED PROCEDURE.          *\n    *                                                                     *\n    *                                                                     *\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n         DO;\n             CALL FLUSH_ALL_REGS;\n             IF OP2 \u00ac= NULL THEN        /*  USUAL PROCEDURE CALL        */\n             DO;\n                IF (OP2 & STRIPMASK) \u00ac= CURRENT_PROC_SEQ# THEN\n                  DO;    /*  CALL TO A DIFFERENT PROCEDURE THAN THE CURRENT */\n                 /*  LOAD CODE BASE FROM TRANSFER VECTOR         */\n\n                DISPL = TRANSFER_VECTOR_BASE + (OP2 & STRIPMASK) * 4;\n                CALL CHECK_MULT_OF_4096;\n                CALL EMIT_RX (LOAD,CODE_BASE,X_REG,ORG,DISPL);\n                  END;\n\n               IF AR_OFFSET = 0 THEN\n                CALL EMIT_RR (LR,CURRENT_AR_BASE,STACKTOP);\n               ELSE DO;\n                  DISPL = AR_OFFSET;\n                  CALL CHECK_MULT_OF_4096;\n                  CALL EMIT_RX(LA,CURRENT_AR_BASE,X_REG,STACKTOP,DISPL);\n               END;\n                CALL EMIT_RR (BALR,LINK,CODE_BASE);\n\n             END;\n\n             ELSE       /*   FORMAL PROCEDURE CALL       */\n            DO;\n               CALL MAKE_ADDRESSABLE(OP1);\n               /*   GET BASE ADDRESS FROM DESCRIPTOR   */\n               CALL EMIT_RX(LOAD,CODE_BASE,X_REG,BASE_REG,DISPL );\n                  CALL FLUSH_ALL_REGS;\n               /*   COMPUTE CURRENT_AR_BSSE FROM STACKTOP & DISPLAY SIZE   */\n               CALL EMIT_RX(S,STACKTOP,X_REG,BASE_REG,DISPL + 4);\n               CALL EMIT_RR(LR,CURRENT_AR_BASE,STACKTOP);\n               CALL EMIT_RR(BALR,LINK,CODE_BASE);\n             END;\n            /*   HERE IT IS ASSUMED THAT ALL TEMPORARIES CREATED DURING\n                 ARGUMENT PASSING HAVE VANISHED (WHICH IMPLIES THAT ANY\n                 COMMON SUB_EXPRESSIONS THAT ARE TO BE REFERENCED\n                 SUBSEQUENT TO THE PARM PASSING COMPUTATIONS SHOULD BE\n                 CREATED BEFORE THE BLKMARK TRIPLE).                  */\n            CALL POP_NEXT_TEMP_DISPL;\n            CALL GET_TEMP_BYTES(4);\n            OP2 = LAST_TEMP;\n         END;\n\n\n      /*   PRETURN     */\n      DO;\n         CALL FLUSH_ALL_REGS;\n         CALL EMIT_RX(LM,LINK,STACKTOP,CURRENT_AR_BASE,4);\n         CALL EMIT_RR(BCR,UNCOND,LINK);\n      END;\n\n      /*   PARM   */\n         /*   USED TO MOVE ARGUMENTS INTO THE NEW ACTIVATION RECORD.\n              USING STACKTOP AS A BASE.  THE 2ND ARG GIVES THE ACTUAL PARAMETER,\n              THE FIRST ARG GIVES THE FORMAL PARAM.\n                  NEXT_TEMP_DISPL (DISPL OF THE NEXT TEMPORARY) NEEDS TO\n              BE ADJUSTED  IF THE ARGUMENT OVERLAPS ITS PREVIOUS VALUE .   */\n      DO;\n         FORMAL_PARAMETER = TRUE;\n         CALL MOVE_OP;\n         FORMAL_PARAMETER = FALSE;\n         /*   MAINTAIN ALIGNMENT   */\n         OP_STORAGE_LENGTH = (OP_STORAGE_LENGTH + 3) & \"FFFFFFFC\";\n         IF AR_OFFSET + DISP(OP1) + OP_STORAGE_LENGTH > NEXT_TEMP_DISPL THEN\n         NEXT_TEMP_DISPL = AR_OFFSET + DISP(OP1) + OP_STORAGE_LENGTH;\n      IF NEXT_TEMP_DISPL > MAX_TEMP_DISPL THEN MAX_TEMP_DISPL = NEXT_TEMP_DISPL;\n      END;\n\n      /*    BLKMARK   */\n\n      DO;\n         IF OP2 \u00ac= NULL THEN\n         DO;     /*   USUAL PROCEDURE CALL   */\n            CALL PUSH_NEXT_TEMP_DISPL;\n            STATIC_DISPLAY_SIZE = PSEUDO_REG(OP1) * 4;\n            IF STATIC_DISPLAY_SIZE > 4 THEN\n            DO;   /*   COPY DISPLAY  INTO NEW ACTIVATION RECORD   */\n                BASE_REG = STACKTOP;\n                DISPL = NEXT_TEMP_DISPL + 20;\n                CALL CHECK_MULT_OF_4096;\n                IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n                CALL EMIT_SS(MVC,STATIC_DISPLAY_SIZE-5,BASE_REG,DISPL,\n                   CURRENT_AR_BASE,20);\n            END;\n\n            /*   SAVE CURRENT_AR_BASE (BECOMES DYNAMIC LINK), CODE_BASE,\n                 STACKTOP. THE RETURN ADDRESS IS SAVED BY THE CALLED PROC   */\n            BASE_REG = STACKTOP;\n            DISPL = NEXT_TEMP_DISPL + 8;\n            CALL CHECK_MULT_OF_4096;\n            IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n            CALL EMIT_RX(STM,CURRENT_AR_BASE,STACKTOP,BASE_REG,DISPL);\n            AR_OFFSET = NEXT_TEMP_DISPL;\n            NEXT_TEMP_DISPL = NEXT_TEMP_DISPL + STATIC_DISPLAY_SIZE + 20;\n            IF NEXT_TEMP_DISPL > MAX_TEMP_DISPL THEN MAX_TEMP_DISPL =\n               NEXT_TEMP_DISPL;\n         END;   /*   USUAL PROC   */\n         ELSE        /*   FORMAL PROCEDURE     */\n         /*   SINCE THE PROCEDURE BEING CALLED IS NOT KNOWN UNTIL RUN-TIME,\n              THE CODE BASE ADDRESS FOR THE PROCEDURE, THE DISPLAY SIZE,\n              AND THE STATIC ENVIRONMENT CANNOT BE OBTAINED UNTIL RUN-TIME.\n              THESE QUANTITIES ARE STORED IN A 3 WORD DESCRIPTOR, WHICH IS\n              INITIALIZED WHEN THE ACTUAL PROCEDURE IS PASSED AS A PARAMETER.\n              CODE FOR FILLING IN THE DESCRIPTOR IS GENERATED BY THE PROCPARM\n              TRIPLE. THE DISPLAY WHICH MUST BE COPIED IS THE CURRENT DISPLAY\n              AT THE TIME OF THE CALL. THUS THE CURRENT AR_BASE IS STORED IN\n              WORD 3 OF THE DESCRIPTOR (THE ENVIRONMENT POINTER).\n              WORD 2 GETS THE DISPLAY SIZE.\n              WORD 1 GETS THE CODE BASE ADDRESS.\n              TO COPY A  VARIABLE  SIZE STATIC DISPLAY, AN MVC INSTR IS\n              EX'D WITH THE LENGTH (OBTAINED FROM THE DESCRIPTOR) IN REG 8.  */\n\n         DO;\n            CALL FLUSH_ALL_TEMP_REGS;\n            CALL FLUSH_REG(8);  CALL FLUSH_REG(9); CALL FLUSH_REG(10);\n            PRIORITY(8), PRIORITY(9) = FIXED_PRIORITY;\n            PRIORITY(10) = FIXED_PRIORITY;\n            CALL MAKE_ADDRESSABLE(OP1);\n            FIX_BASE_REG_PRIORITIES;\n            /*   LOAD DISPLAY LENGTH & ENVIRONMENT BASE, RESPECTIVELY   */\n            IF X_REG \u00ac= 0 THEN DO;\n                CALL EMIT_RX(LOAD,8,X_REG,BASE_REG,DISPL + 4);\n                CALL EMIT_RX(LOAD,9,X_REG,BASE_REG,DISPL + 8);\n            END;\n            ELSE CALL EMIT_RX(LM,8,9,BASE_REG,DISPL + 4);\n            X_REG1 = X_REG;\n            DISPL1 = DISPL;\n            DISPL = NEXT_TEMP_DISPL;\n            CALL CHECK_MULT_OF_4096;\n            IF X_REG = 0 & DISPL = 0 THEN CALL EMIT_RR(LR,10,STACKTOP);\n            ELSE\n            CALL EMIT_RX(LA,10,X_REG,STACKTOP,DISPL);\n            /*   COPY DISPLAY. DON'T BOTHER TO DECREMENT LEN BY 1 FOR LEN CODE-\n                 IRRELEVENT THAT AN EXTRA BYTE IS COPIED       */\n            CALL EMIT_RX(EX,8,0,ORG,MVC_INSTR);\n\n            CALL EMIT_RX(STM,CURRENT_AR_BASE,STACKTOP,10,8);\n            IF (TRIPLES(CURRENT_TRIPLE + 3) & TRIPLE_OP_MASK) = 36 THEN\n            DO;   /*   PCALL TRIPLE FOLLOWS -> NO PARMS.SKIP OVER THE\n              PCALL, & BALR IMMEDIATELY    */\n               CALL EMIT_RX(LOAD,CODE_BASE,X_REG,BASE_REG,DISPL1);\n               CALL FLUSH_ALL_REGS;\n               CALL EMIT_RR(LR,CURRENT_AR_BASE,10);\n               CALL EMIT_RR(BALR,LINK,CODE_BASE);\n               /*   BUMP OVER PCALL   */\n               CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n               IF LIST_CODE THEN CALL PRINT_TRIPLE(CURRENT_TRIPLE);\n               CALL GET_TEMP_BYTES(4);\n               OP2 = LAST_TEMP;   /*  ASSIGN A TEMP TO THE PROC   */\n            END;\n            ELSE DO;\n            /*   ARGS WILL BE ADDRESSED OFF THE STACKTOP. ADJUST IT\n               ACCORDINGLY, & ADJUST VALUE OF NEXT_TEMP_DISPL   */\n               /*  NOTE THAT BY THUS INCREMENTING THE STACKTOP, TEMPS\n                   OUTSTANDING AT THE TIME OF THE CALL ARE NO LONGER\n                   ADDRESSABLE FROM THE STACKTOP. THIS EXCLUDES ARG COM-\n                   PUTATIONS OF FORMAL PROC CALLS FROM REFERENCING PRE-\n                   VIOUSLY COMPUTED COMMON SUB-EXPRESSIONS.         */\n\n               CALL EMIT_RX(LA,STACKTOP,10,8,0);\n               CALL PUSH_NEXT_TEMP_DISPL;\n               AR_OFFSET,NEXT_TEMP_DISPL = 20;\n            END;\n            CALL RESET_ADDR_REG_PRIORITIES(BASE_REG,X_REG);\n            IF X_REG1 \u00ac= X_REG THEN CALL RESET_ADDR_REG_PRIORITIES(X_REG1,0);\n            PRIORITY(8),PRIORITY(9) = FREE_PRIORITY;\n            PRIORITY(10) = FREE_PRIORITY;\n         END;   /*  FORMAL PROC   */\n      END;\n\n\n      /*    PEND      */\n      DO;\n         IF CURRENT_PROC_SEQ# = 0   /*   MAIN PROCEDURE   */\n            THEN COMPILING = FALSE;\n         ELSE ENTRY_POINT = ENTRY_POINT + CODE_INDEX;\n         RETURN;   /*   CODE GENERATION COMPLETED FOR CURRENT PROCEDURE   */\n      END;\n\n      /*   TPOP   */\n      /*   FREE THE TEMPORARY ASSOCIATED WITH THE TRIPLE GIVEN BY OP1   */\n      DO;\n         TPTR = OP1 & STRIPMASK;\n         CALL FREE_TEMP(TRIPLES(TPTR+2) );\n      END;\n      /*   REM   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF OP_STORAGE_LENGTH = 1 THEN DO;\n            CALL GET_INTO_ODD_REG;\n            CALL EMIT_RR(SR,EVEN_REG,EVEN_REG);\n         END;\n         ELSE DO;\n            CALL GET_INTO_EVEN_REG;\n            CALL EMIT_RX(SRDA,EVEN_REG,0,0,32);\n         END;\n         CALL GENERATE_OPERATION(D,DR,NULL,EVEN_REG,OP2);\n         CALL RESET_PAIR_PRIORITIES(TEMP_PRIORITY,FREE_PRIORITY);\n         CALL ASSIGN_TEMP(EVEN_REG);\n         OP2 = LAST_TEMP;\n      END;\n\n      /*   ABS   */\n      DO;\n         CALL LOAD_OPERAND;\n         CALL EMIT_RR(LPR,ACC,ACC);\n      END;\n\n      /*   ABSFLT   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF IN_REG & \u00acIN_FREE_REG THEN DO;\n            FLT_REG = GET_FLT_REG(TEMP_PRIORITY);\n            CALL EMIT_RR(LPER,FLT_REG-#GP_REGS,ACC-#GP_REGS);\n         END;\n         ELSE DO;\n            CALL GET_OP_INTO_FLT_REG(TEMP_PRIORITY);\n            CALL EMIT_RR(LPER,FLT_REG-#GP_REGS,FLT_REG-#GP_REGS);\n         END;\n         CALL ASSIGN_TEMP(FLT_REG);\n         OP2 = LAST_TEMP;\n      END;\n\n      /*   NEGATE   */\n      DO;\n         CALL LOAD_OPERAND;\n         CALL EMIT_RR(LCR,ACC,ACC);\n      END;\n      /*   NEGFLT   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF IN_REG & \u00acIN_FREE_REG THEN DO;\n            FLT_REG = GET_FLT_REG(TEMP_PRIORITY);\n            CALL EMIT_RR(LCER,FLT_REG-#GP_REGS,ACC-#GP_REGS);\n         END;\n         ELSE DO;\n            CALL GET_OP_INTO_FLT_REG(TEMP_PRIORITY);\n            CALL EMIT_RR(LCER,FLT_REG-#GP_REGS,FLT_REG-#GP_REGS);\n         END;\n         CALL ASSIGN_TEMP(FLT_REG);\n         OP2 = LAST_TEMP;\n      END;\n\n      /*   LLESS   */\n         IF GET_STOR_LEN(OP1) > 256 THEN CALL GEN_LONG_COMPARE(BL);\n         ELSE\n      DO;\n         CALL GENERATE_STRING_OPERATION(CLC);\n         CALL GEN_COND_BRANCH(BL);\n      END;\n      /*   LGREATER   */\n         IF GET_STOR_LEN(OP1) > 256 THEN CALL GEN_LONG_COMPARE(BH);\n         ELSE\n      DO;\n         CALL GENERATE_STRING_OPERATION(CLC);\n         CALL GEN_COND_BRANCH(BH);\n      END;\n      /*   LCOMPARE   */\n         IF GET_STOR_LEN(OP1) > 256 THEN CALL GEN_LONG_COMPARE(BE);\n         ELSE\n      DO;\n         CALL GENERATE_STRING_OPERATION(CLC);\n         CALL GEN_COND_BRANCH(BE);\n      END;\n\n      /*   PROCPARM   */\n         /*   USED TO PASS A PROCEDURE AS AN ACTUAL PARAMETER. THE OPRRANDS\n              GIVE THE PROCEDURE & ITS SEQ#. THIS TRIPLE IS ALWAYS FOLLOWED BY\n              A PARM TRIPLE WHICH GIVES THE FORMAL PARAMETER IN ITS FIRST OP  */\n      DO;\n         DECLARE SEQ# BIT(16);\n         SEQ# = OP2 & STRIPMASK;\n         IF OP1 <= 25 THEN\n            /*   ONE OF THE STANDARD PROCEDURES SIN, COS, EXP, LN, SQRT,\n            ARCTAN ARE BEING PASSED. THESE ARE THE ONLY STANDARD PROCEDURES\n            ALLOWED TO BE PASSED IN THE CURRENT VERSION.            */\n            STATIC_DISPLAY_SIZE = 0;\n         ELSE STATIC_DISPLAY_SIZE = PSEUDO_REG(OP1) * 4;\n         CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n         IF LIST_CODE THEN CALL PRINT_TRIPLE(CURRENT_TRIPLE);\n         /*   NOW AT PARM TRIPLE. FILL IN DESCRIPTOR WITH THE DISPLAY SIZE,\n              CODE BASE ADDRESS, & CURRENT_AR_BASE, RESPECTIVELY      */\n         CALL FLUSH_REG(9); CALL FLUSH_REG(10);\n         PRIORITY(9),PRIORITY(10) = FIXED_PRIORITY;\n         FORMAL_PARAMETER = TRUE;\n         CALL GET_TARGET_ADDRESS;\n         FORMAL_PARAMETER = FALSE;\n         IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n         DISPL1 = DISPL;\n         IF STATIC_DISPLAY_SIZE = 0 THEN\n         DO;   /*  STANDARD PROC. SEQ# WILL BE THE MONITOR SERVICE CODE  */\n            /*   PREPARE A THUNK, BAL AROUND IT IN THE PARM PASSING\n         SEQUENCE, PUTTING ITS ADDRESS IN THE REG WHICH IS STORED AS THE\n         CODE BASE ADDRESS IN THE DESCRIPTOR. THE THUNK WILL THEN BE\n         ENTERED WHEN THE  FORMAL PROC CALL HAS BEEN MADE, PERMITTING\n         ENTRY INTO THE MONITOR ACCORDING TO THE SPECIFIED PROTOCALL FOR\n         MONITOR ENTRIES & RETURNS.                      */\n            DISPL = CODE_INDEX + 34;\n            CALL CHECK_MULT_OF_4096;\n            CALL EMIT_RX(BAL,9,X_REG,CODE_BASE,CODE_INDEX + 34);\n            /*   GENERATE THE THUNK. NOTE THAT WHEN THE THUNK IS ENTERED,\n                 THE STACKTOP WILL POINT TO THE BASE OF THE A.R. CREATED\n                 BY THE CALLING MECHANISM. LOAD THE ARGUMENT TO CONFORM TO\n                 THE STANDARD PROCEDURE PROTOCALL, SAVE THE LINK ADDRESS,\n                 GENERATE THE MONITOR CALL, & STORE THE VALUE RETURNED\n                 IN FLT REG #0 TO THE TEMPORARY ASSOCIATED WITH THE PCALL\n                 TRIPLE.                                      */\n            CALL EMIT_RX(LE,6,0,STACKTOP,20);  /* GET ARG FROM A.R.  */\n            CALL EMIT_RX(ST,LINK,0,CURRENT_AR_BASE,4);   /*  SAVE LINK  */\n            CALL EMIT_RX(STM,13,15,ORG,PASCAL_REGS + 8);\n            CALL EMIT_RX(LOAD,13,0,ORG,MON_BASE_REGS + 8);\n            CALL EMIT_RX(BAL,LINK,0,13,4 * SEQ# + 72);\n            CALL EMIT_RX(STE,0,0,  CURRENT_AR_BASE,0);  /* PUT VALUE IN PLACE*/\n            CALL EMIT_RX(LM,LINK,STACKTOP,CURRENT_AR_BASE,4);  /* RESTORE  */\n            CALL EMIT_RR(BCR,UNCOND,10);\n            /*   END OF THUNK   */\n            CALL EMIT_RR(SR,10,10);  /*  DISPLAY SIZE WILL BE SET TO 0  */\n         END;\n         ELSE\n         DO;   /*   USER DEFINED PROCEDURE   */\n            DISPL = 4 * SEQ# + TRANSFER_VECTOR_BASE;\n            CALL CHECK_MULT_OF_4096;\n            CALL EMIT_RX(LOAD,9,X_REG,ORG,DISPL);\n            CALL EMIT_RX(LA,10,0,0,STATIC_DISPLAY_SIZE);\n         END;\n\n         CALL EMIT_RX(STM,9,CURRENT_AR_BASE,BASE_REG,DISPL1);\n         PRIORITY(9),PRIORITY(10) = FREE_PRIORITY;\n         IF DISPL1 + 8 > NEXT_TEMP_DISPL THEN NEXT_TEMP_DISPL = DISPL1 + 8;\n         IF NEXT_TEMP_DISPL > MAX_TEMP_DISPL THEN MAX_TEMP_DISPL =\n            NEXT_TEMP_DISPL;\n      END;\n\n      /*   CASE   */\n\n   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    *                                                                     *\n    *         THE CASE SEQUENCE IS INITIATED BY A CASE_TRIPLE, FOLLOWED   *\n    *       BY A SEQUENCE OF BRANCH TRIPLES, ONE FOR EACH POSSIBLE VALUE  *\n    *       OF THE CASE SELECTOR IN THE UNDERLYING INTEGER SUBRANGE. THE  *\n    *       TARGETS OF THESE BRANCH TRIPLES ARE CASE_TARGET TRIPLES,      *\n    *    FOR NON-EMPTY CASES (THESE PRECEDE THE TRIPLES FOR THAT CASE)    *\n    *      OR A BRANCH TARGET AT THE END OF THE ENTIRE CASE SEQUENCE FOR  *\n    *      EMPTY CASES.                                                   *\n    *         EACH CASE_TARGET IS REFERENCED BY ONE OR MORE BRANCHES. IN  *\n    *       GENERATING CODE, A RELATIVE ADDRESS TABLE IS SET UP, TO CON-  *\n    *       TAIN THE LOCATION OF THE FIRST BYTE OF CODE FOR THE CASE      *\n    *       CORRESPONDING TO EACH OF THE BRANCH TRIPLES.                  *\n    *         THE CASE TRIPLE CAUSES EMISSION OF MACHINE INSTRUCTIONS TO  *\n    *       DO THE FOLLOWING:                                             *\n    *    1) GET THE CASE SELECTOR IN A NON-ZERO REGISTER (BASE_REG)       *\n    *    2) SHIFT THE SELECTOR TO OBTAIN AN INDEX INTO THE RELATIVE AD-   *\n    *    DRESS TABLE                                                      *\n    *    3) RE-LOAD BASE_REG WITH THE CONTENTS OF THE INDEXED TABLE ENTRY *\n    *    4) USE BASE_REG TO INDEX A FORWARD UNCOND BRANCH TO THE CASE     *\n    *                                                                     *\n    *    OP2 OF THE CASE_TARGET TRIPLE IS USED TO HEAD A FIXUP LIST OF    *\n    *    REFERENCES TO THAT CASE. AS EACH CASE_TARGET IS ENCOUNTERED,     *\n    *    THE LOC OF THE FIRST INSTRUCTION IN THAT CASE IS KNOWN & IS THEN *\n    *    ENTERED IN THE RELATIVE ADDRESS TABLE.                           *\n    *                                                                     *\n    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/\n\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         CALL FLUSH_ALL_REGS;\n         CALL FORCE_INTO_BASE_REG;\n         CALL EMIT_RX(SLA,BASE_REG,0,0,2);\n         IF CODE_INDEX < 4086 THEN /* CODE_BASE CAN BE USED TO ADDRESS\n              THE ADDRESS TABLE     */\n            CALL EMIT_RX( LH ,BASE_REG,BASE_REG,CODE_BASE,CODE_INDEX + 10);\n         ELSE DO;\n            CALL EMIT_RR(BALR,BASE_REG,0);\n            CALL EMIT_RX( LH ,BASE_REG,BASE_REG,0,10);\n         END;\n         CALL EMIT_RX(BC,UNCOND,CODE_BASE,BASE_REG,0);\n         CALL RESET_BASE_REG_PRIORITIES;\n\n         OPERAND2 = OP2 & STRIPMASK;\n         DO I = 1 TO OPERAND2;\n            CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n            IF MASK(OP1) = SY_TABLE_PTR THEN TPTR = DISP(OP1);\n               /*  A PSEUDO LABEL. GET TARGET FROM SYMBOL TABLE    */\n            ELSE TPTR = (OP1 & STRIPMASK);\n            CALL INSERT_2BYTE_CONSTANT(CODE_INDEX,0);\n            CALL INSERT_2BYTE_CONSTANT(CODE_INDEX+ 2,TRIPLES(TPTR + 2) );\n            TRIPLES(TPTR + 2) = CODE_INDEX;\n            CODE_INDEX = CODE_INDEX + 4;\n         END;\n      END;\n\n\n      /*   CASE_TARGET     */\n\n      DO;\n         CALL FLUSH_ALL_REGS;\n         TPTR = OP2;\n         DO WHILE TPTR \u00ac= NULL;   /*  FIXUP REFERENCES TO THE CASE TARGET  */\n            I = TPTR + 2;\n            /*  GET NEXT ELEMENT IN CHAIN   */\n            TPTR = SHL(CODE(I),8) + CODE(I + 1);\n            CALL INSERT_2BYTE_CONSTANT(I,CODE_INDEX);\n         END;\n      END;\n      /*   ODD   */\n      DO;\n         CALL LOAD_OPERAND;\n         CALL EMIT_RX(N,ACC,0,ORG,CONST1);\n      END;\n      /*   SQR   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF \u00ac DOUBLE_REG_STATUS THEN CALL GET_INTO_ODD_REG;\n         CALL EMIT_RR (MR,EVEN_REG,ODD_REG);\n         CALL RESET_PAIR_PRIORITIES(FREE_PRIORITY,TEMP_PRIORITY);\n         CALL ASSIGN_TEMP(ODD_REG);\n         OP2 = LAST_TEMP;\n      END;\n      /*   SQRFLT   */\n      DO;\n         CALL MAKE_ADDRESSABLE(OP1);\n         CALL GET_OP_INTO_FLT_REG(TEMP_PRIORITY);\n         CALL EMIT_RR(MER,FLT_REG,FLT_REG);\n         CALL ASSIGN_TEMP(FLT_REG);\n         OP2 = LAST_TEMP;\n      END;\n\n      /*   ROUND   */\n         /*   ROUNDING IS PERFORMED BY ADDING OR SUBTRACTING 0.5 (DEPEND-\n              ING ON THE SIGN )  AND TRUNCATING THE RESULT   */\n      DO;\n         FLT_REG = GET_FLT_REG(FREE_PRIORITY);\n         FLT_ACC = FLT_REG - #GP_REGS;\n         CALL EMIT_RR(SDR,FLT_ACC,FLT_ACC);\n         CALL MAKE_ADDRESSABLE(OP1);\n         IF IN_REG THEN CALL EMIT_RR(LER,FLT_ACC,ACC - #GP_REGS);\n         ELSE CALL EMIT_RX(LE,FLT_ACC,X_REG,BASE_REG,DISPL);\n         CALL EMIT_RR(LTDR,FLT_ACC,FLT_ACC);\n         ACC = GET_REG(TEMP_PRIORITY);\n         CALL ASSIGN_TEMP(ACC);\n         CALL FORWARD_CODE_BRANCH(BNL,26);\n         /*   IF NEGATIVE  FIRST SUBTRACT  0.5   */\n         CALL EMIT_RX(SE,FLT_ACC,0,ORG,CONP5);\n         CALL EMIT_RX(AW,FLT_ACC,0,ORG,CON4E);\n         CALL EMIT_RX(STD,FLT_ACC,0,ORG,DS1);\n         CALL EMIT_RX(LOAD,ACC,0,ORG,DS1 + 4);\n         CALL EMIT_RR(LCR,ACC,ACC);\n         CALL FORWARD_CODE_BRANCH(UNCOND,20);\n         /*   IF POSITIVE ADD  0.5     BEFORE TRUNCATING    */\n         CALL EMIT_RX(AE,FLT_ACC,0,ORG,CONP5);\n         CALL EMIT_RX(AW,FLT_ACC,0,ORG,CON4E );\n         CALL EMIT_RX(STD,FLT_ACC,0,ORG,DS1);\n         CALL EMIT_RX(LOAD,ACC,0,ORG,DS1 + 4);\n         OP2 = LAST_TEMP;\n      END;\n\n      /*   S_LENGTH   */\n         /*   GENERATES NO CODE BUT USED TO INDICATE THE STORAGE LENGTH\n              FOR INDEX TRIPLES OF LENGTH > 256   */\n      ;\n      /*   IN   */\n         /*   CHECK IF THE BIT WHOSE ORDINALITY IS GIVEN IN THE FIRST OPERAND\n              IS SET IN THE SECOND OPERAND     */\n      DO;\n        IF IMMED(OP1) THEN   /*  ORDINALITY KNOWN AT COMPILE TIME - NO\n         NEED TO GEN CODE TO COMPUTE BIT & BYTE ORDINALITIES   */\n        DO;\n            CALL FOLD_BIT_OP(TM);\n            CALL GEN_COND_BRANCH(1);     /*   BNZ => BR IF ONES   */\n        END;\n        ELSE DO;\n         CALL SELECT;\n      /*   BYTE_XREG CONTAINS ORDINALITY OF SELECTED BYTE (UNLESS IT = 0,\n           IN WHICH CASE THE ORDINALITY IS 0 ). INSERT THAT BYTE INTO EVEN_REG*/\n         CALL EMIT_RX(IC,EVEN_REG,BYTE_XREG,BASE_REG,DISPL);\n         /*   SHIFT THE SELECTED BIT TO SIGN POSITION   */\n         CALL EMIT_RX(SLL,EVEN_REG,0,ODD_REG,24);\n         CALL EMIT_RR(LTR,EVEN_REG,EVEN_REG);   /*   TEST THE BIT    */\n         /*   MINUS IS THE TRUE CONDITION   */\n         CALL GEN_COND_BRANCH(BL);\n         CALL RESET_PAIR_PRIORITIES(FREE_PRIORITY,FREE_PRIORITY);\n      END;\n        END;\n\n      /*   INTO   */\n      DO;\n        IF IMMED(OP1) THEN CALL FOLD_BIT_OP(OI);\n        ELSE DO;\n         /*   SET THE BIT WHOSE ORDINALITY IS GIVEN BY OP1   */\n\n         CALL SELECT;\n         /*   PUT ADDRESS OF CORRECT MASK IN ODD_REG    */\n         CALL EMIT_RX(LA,ODD_REG,ODD_REG,ORG,SET_MASKS);\n      IF BYTE_XREG \u00ac= 0 THEN DO;\n         /*   PUT ADDRESS OF SELECTED BYTE IN EVEN_REG   */\n         CALL EMIT_RX(LA,EVEN_REG,BYTE_XREG,BASE_REG,DISPL);\n         CALL EMIT_SS(OC,0,EVEN_REG,0,ODD_REG,0);\n      END;\n      ELSE CALL EMIT_SS(OC,0,BASE_REG,DISPL,ODD_REG,0);\n         CALL RESET_PAIR_PRIORITIES(FREE_PRIORITY,FREE_PRIORITY);\n        END;\n      END;\n\n      /*   LINE#   */\n      CALL NEXT_LINE(OP1);\n\n      /*   RANGE   */\n\n      /*   THIS TRIPLE SPECIFIES THE INSERTION OF A SUBRANGE INTO A SET.\n           OP1 & OP2 INDICATE THE RANGE (COERCED TO ORDINALITIES WITHIN\n           THE SET);  AN INTO TRIPLE IMMEDIATELY FOLLOWS WHICH GIVES THE\n           ADDRESS OF THE BYTES REPRESENTING THE SET IN ITS 2ND OPERAND  */\n\n      CALL INSERT_SUBRANGE;\n\n\n      END;\n\n      IF LIST_INSTRUCTIONS THEN DO;\n         /*   A LISTING OF GEN CODE IS DESIRED. PRESERVE THE CURRENT VALUE\n              OF CODE_INDEX SO LINE#S MAY BE ASSOCIATED WITH DISPLACEMENTS */\n         I = TRIPLES(CURRENT_TRIPLE) & TRIPLE_OP_MASK;\n         IF I \u00ac= INDEX & I \u00ac= S_LENGTH & I \u00ac= 60  /* LINE#TRIPLE */ THEN\n         OP1 = CODE_INDEX;\n      END;\n\n      CURRENT_TRIPLE = CURRENT_TRIPLE + 3;\n      END;\n END GENERATE_CODE;\n\n\n\n /*     I N T E R P A S S   C O M M U N I C A T I O N   P R O C E D U R E S   */\n\n\n\n\n REWIND: PROCEDURE (IS_OUTPUT_FILE,FILE#);\n      /*   USED FOR REWINDING FILES IN ORDER TO FREE BUFFER SPACE   */\n      DECLARE IS_OUTPUT_FILE BIT(1), FILE# FIXED;\n      CALL INLINE(\"1B\",0,0);                     /* SR   0,0              */\n      CALL INLINE(\"43\",0,0,IS_OUTPUT_FILE);      /* IC   0,IS_OUTPUT_FILE */\n      CALL INLINE(\"41\",1,0,0,28);                /* LA   1,28             */\n      CALL INLINE(\"58\",2,0,FILE#);               /* L    2,FILE#          */\n      CALL INLINE(\"05\",12,15);                   /* BALR 12,15            */\n END REWIND;\n\n\n      /*   INPUT PROCEDURES TO READ IN SYMBOL TABLE AND TRIPLE BLOCKS   */\n\nRESTORE_COLUMN:\n   PROCEDURE (ARRAY_ADDR, BYTES_PER_ITEM, LIMIT);\n      DECLARE ARRAY_ADDR FIXED,\n              (BYTES_PER_ITEM, LIMIT) BIT(16);\n      DECLARE (INCREMENT, I, J, K) FIXED;\n      DECLARE MOV(3) BIT(16) INITIAL(\"D200\", \"2000\", \"1000\");\n      INCREMENT = 80 / BYTES_PER_ITEM;\n      I = 0;\n      J = ARRAY_ADDR;\n      DO WHILE I + INCREMENT < LIMIT;\n         CALL INLINE(\"58\",1,0,SY_TEXT);          /* L    1,SY_TEXT         */\n         CALL INLINE(\"58\",2,0,J);                /* L    2,J               */\n         CALL INLINE(\"D2\",\"4\",\"F\",2,0,1,0);      /* MVC  0(80,2),0(1)      */\n         I = I + INCREMENT;\n         J = J + 80;\n         SY_TEXT = INPUT(SY_FILE);\n      END;\n      K = (LIMIT - I) * BYTES_PER_ITEM - 1;\n      CALL INLINE(\"58\",1,0,SY_TEXT);             /* L    1,SY_TEXT         */\n      CALL INLINE(\"58\",2,0,J);                   /* L    2,J               */\n      CALL INLINE(\"58\",3,0,K);                   /* L    3,K               */\n      CALL INLINE(\"44\",3,0,MOV);                 /* EX   3,MVC             */\n      SY_TEXT = INPUT(SY_FILE);\n   END RESTORE_COLUMN;\n\n\nRESTORE_SY_TABLE:\n   PROCEDURE;\n      /* RESTORE THE STORAGE_LENGTH, PSEUDO_REG AND DISP COLUMNS OF THE\n         SYMBOL TABLE TO THEIR STATUS AT THE END OF PASS 2.            */\n      DECLARE I BIT(16);\n      N_DECL_SYMB = 0;\n      #BASIC_BLOCKS = 0;\n      NEXT_SEQ# = 0;\n      SY_TEXT = INPUT(SY_FILE);\n      IF SUBSTR(SY_TEXT, 0, 5) \u00ac= '%SYMB' THEN\n         DO;\n            OUTPUT = '%SYMB CARD EXPECTED.';\n            RETURN;\n         END;\n      /*   READ IN GLOBALS PASSED FROM PASS 2     */\n      DO I = 5 TO 9;\n         IF BYTE(SY_TEXT, I) \u00ac= BYTE(' ') THEN\n            N_DECL_SYMB = 10*N_DECL_SYMB + BYTE(SY_TEXT, I) - BYTE('0');\n      END;\n      DO I = 10 TO 14;\n         IF BYTE(SY_TEXT, I) \u00ac= BYTE(' ') THEN\n         #BASIC_BLOCKS = 10 * #BASIC_BLOCKS + BYTE(SY_TEXT,I) - BYTE('0');\n      END;\n      DO I = 15 TO 19;\n         IF BYTE(SY_TEXT, I) \u00ac= BYTE(' ') THEN\n         NEXT_SEQ# = 10 * NEXT_SEQ# + BYTE(SY_TEXT,I) - BYTE('0');\n      END;\n      IF BYTE(SY_TEXT,20) = BYTE('D') THEN STATISTICS = TRUE;\n        ELSE STATISTICS = FALSE;\n      NEXT_SEQ# = NEXT_SEQ# + 1;\n\n\n      /*   SET PASS 2 DEPENDENT PASS 3 GLOBALS   */\n      TRANSFER_VECTOR_BASE = BLOCK_COUNTER_BASE + 4 * #BASIC_BLOCKS;\n\n      SY_TEXT = INPUT(SY_FILE);\n      CALL RESTORE_COLUMN(ADDR(STORAGE_LENGTH), 4, N_DECL_SYMB);\n      CALL RESTORE_COLUMN(ADDR(PSEUDO_REG), 2, N_DECL_SYMB);\n      CALL RESTORE_COLUMN(ADDR(DISP), 4, N_DECL_SYMB);\n      IF SUBSTR(SY_TEXT, 0, 4) \u00ac= '%END' THEN OUTPUT = '%END CARD EXPECTED';\n      CALL REWIND(0,SY_FILE);\n   END RESTORE_SY_TABLE;\n\n\n\n      /*               READ IN A BLOCK OF TRIPLES               */\n\n\n\nREAD_TRIPLES:\n   PROCEDURE;   /* READS IN TRIPLES FOR A PASCAL BLOCK */\n      DECLARE (I, J) FIXED;\n      DECLARE TRIPLE_LISTING BIT(1);\n      SY_TEXT = INPUT(TRIPLES_FILE);\n      IF LENGTH(SY_TEXT) = 0 THEN RETURN; /**** ENDFILE ****/\n      IF SUBSTR(SY_TEXT, 0, 7) \u00ac= '%TRIPLE' THEN\n         DO;\n            OUTPUT = '%TRIPLE CARD EXPECTED.';\n            RETURN;\n         END;\n\n      /*   SET REQUESTED OPTION FLAGS   */\n      PROC_NAME = SUBSTR(SY_TEXT,9);\n      IF BYTE(SY_TEXT,7) \u00ac= BYTE('E') THEN DO;\n         LIST_CODE, LIST_INSTRUCTIONS = FALSE;\n         IF BYTE(SY_TEXT,8) = BYTE('T') THEN TRIPLE_LISTING = TRUE;\n         ELSE TRIPLE_LISTING = FALSE;\n      END;\n      ELSE DO;\n         IF BYTE(SY_TEXT,8) = BYTE('T') THEN\n         DO;   /*   BOTH E & T TOGGLES--GIVE TRIPLES & CODE INTERLEAVED   */\n            LIST_INSTRUCTIONS = FALSE;\n            LIST_CODE = TRUE;\n            OUTPUT(1) = '1' || SPACE 40X || 'TRIPLES AND CODE FOR PROCEDURE '\n               || PROC_NAME;\n         END;\n         ELSE LIST_INSTRUCTIONS = TRUE;\n      END;\n\n      I = 0;\n      SY_TEXT = INPUT(TRIPLES_FILE);\n      DO WHILE SUBSTR(SY_TEXT, 0, 4) \u00ac= '%END';\n         J = ADDR(TRIPLES(I));\n         CALL INLINE(\"58\",1,0,SY_TEXT);          /* L    1,SY_TEXT         */\n         CALL INLINE(\"58\",2,0,J);                /* L    2,J               */\n         CALL INLINE(\"D2\",\"4\",\"F\",2,0,1,0);      /* MVC  0(80,2),0(1)      */\n         I = I + 40;\n         SY_TEXT = INPUT(TRIPLES_FILE);\n      END;\n      IF TRIPLE_LISTING THEN CALL LIST_TRIPLES;\n   END READ_TRIPLES;\n\n      /*   OUTPUT PROCEDURE FOR SWAPPING OUT CODE AND ORG SEGMENTS   */\n\n SWAP_OUT_SEGMENT: PROCEDURE(FILE#,HEADER);\n      DECLARE FILE# BIT(16),HEADER CHARACTER;\n      OUTPUT(FILE#) = HEADER;\n      I = 0;\n      DO WHILE I < CODE_INDEX;\n         J = ADDR(CODE(I) );\n         CALL INLINE(LOAD,1,0,CODE_TEXT);     /*   L 1,A(CODE_TEXT)   */\n         CALL INLINE(LOAD,2,0,J);        /*  L 2,J    */\n         CALL INLINE(MVC,\"4\",\"F\",1,0,2,0);   /*  MVC 0(80,1),0(2)   */\n         OUTPUT(FILE#) = CODE_TEXT;\n         I = I + 80;\n      END;\n END SWAP_OUT_SEGMENT;\n\n\n\n   /*        G E N E R A T I O N   O F    O R G   S E G M E N T               */\n\n GENERATE_ORG_SEGMENT: PROCEDURE;\n\n\n EMIT_4BYTE_CONST: PROCEDURE(CONST);\n      DECLARE CONST FIXED;\n      COREWORD(SHR(ADDR(CODE(CODE_INDEX    )),2)) = CONST;\n      CODE_INDEX = CODE_INDEX + 4;\n END EMIT_4BYTE_CONST;\n\n EMIT_8BYTE_CONST: PROCEDURE(CONST1,CONST2);\n      DECLARE (CONST1,CONST2) FIXED;\n      COREWORD(SHR(ADDR(CODE(CODE_INDEX    )),2)) = CONST1;\n      COREWORD(SHR(ADDR(CODE(CODE_INDEX + 4)),2)) = CONST2;\n      CODE_INDEX = CODE_INDEX + 8;\n END EMIT_8BYTE_CONST;\n\n      /*    USES THE CODE_ARRAY AS A BUFFER     */\n      CODE_INDEX = 0;\n      /*   HEAP POINTER & MAX_TOP ARE FILLED IN BY LOADER     */\n      CALL EMIT_4BYTE_CONST(0);\n      CALL EMIT_4BYTE_CONST(\"FFFFFF\");     /*   MAX_TOP    */\n      /*   EMIT MULTIPLES OF 4096   */\n      DO I = 0 TO 31;\n         CALL EMIT_4BYTE_CONST(I * 4096);\n      END;\n\n       /*   MVC INSTRUCTION FOR COPYING DISPLAYS   */\n      CALL EMIT_SS(MVC,0,10,20,9,20);\n      CODE_INDEX = CODE_INDEX + 2;   /*   RE-ALIGN   */\n      /*   WORKING STORAGE   */\n      CALL EMIT_8BYTE_CONST(0,0);\n\n      /*   FLOATING POINT CONSTANTS    */\n      CALL EMIT_8BYTE_CONST(\"40800000\",0);    /*   CONP5   */\n      CALL EMIT_8BYTE_CONST(\"4E000000\",0);   /*   DS4E   */\n      CALL EMIT_8BYTE_CONST(0,0);       /*   CONSTD0     */\n      CALL EMIT_8BYTE_CONST(\"4E000000\",0);      /*   CON4E    */\n\n      CALL EMIT_4BYTE_CONST(1);       /*   CONST1    */\n      CALL EMIT_4BYTE_CONST(\"1C\");     /*   DEC1    */\n\n      CALL EMIT_8BYTE_CONST(-1,-1);   /*   DOUBLEWORD -1   */\n      /*   INITIALIZE 8 ONE BYTE MASKS   */\n      CALL EMIT_8BYTE_CONST(\"80402010\",\"08040201\");   /*   SET_MASKS   */\n      /*   SPACE FOR SAVE AREA, MONITOR BASE ADDRESSES. THE LATTER ARE TO BE\n           FILLED IN BY THE LOADER, BEFORE TRANSFERING CONTROL TO THE PASCAL\n           PROGRAM             */\n      DO I = 1 TO 19;\n         CALL EMIT_4BYTE_CONST(0);\n      END;\n      /*   EMIT MEMORY OVERFLOW MONITOR ENTRY   */\n      CALL EMIT_RX(STM,11,15,ORG,PASCAL_REGS);   /*  SAVE IMP'T REGS   */\n      CALL EMIT_RX(LM,11,13,ORG,MON_BASE_REGS);\n      CALL EMIT_RX(BC,UNCOND,0,13,204);\n      /*   EMIT RANGE ERROR MONITOR ENTRY   */\n      CALL EMIT_RX(STM,11,15,ORG,PASCAL_REGS);   /*  SAVE IMP'T REGS   */\n      CALL EMIT_RX(LM,11,13,ORG,MON_BASE_REGS);\n      CALL EMIT_RX(BC,UNCOND,0,13,200);\n\n      /*   INITIALIZE BLOCK COUNTERS   */\n      IF #BASIC_BLOCKS > 0 THEN\n      DO I = 0 TO #BASIC_BLOCKS - 1;\n         CALL EMIT_4BYTE_CONST(\"0C\");   /*   DECIMAL 0   */\n      END;\n\n      /*   TRANSFER VECTOR     */\n      DO I = 0 TO NEXT_SEQ# - 1;\n         CALL EMIT_4BYTE_CONST(TRANSFER_VECTOR(I) );\n      END;\n      CALL SWAP_OUT_SEGMENT(ORG_FILE,\n            '%ORG ' || I_FORMAT(  CODE_INDEX,5)\n                    || I_FORMAT(  TRANSFER_VECTOR_BASE,5)\n                ||   I_FORMAT(  MAX_TEMP_DISPL,5)\n                  || I_FORMAT(   STORAGE_LENGTH(CURRENT_PROCEDURE),20) );\n      CALL REWIND(1,ORG_FILE);\n\n END GENERATE_ORG_SEGMENT;\n\n FILL_LAST_LINE#_RECORD: PROCEDURE;\n      /*   FILL OUT REMAINING ENTRIES  IN LINE#BUFF (IF ANY) & SWAP IT OUT */\n      DO WHILE LINE_BUFF_PTR <= 20;\n         LINE#BUFF(LINE_BUFF_PTR) = CODE_INDEX + ENTRY_POINT;\n         LINE_BUFF_PTR = LINE_BUFF_PTR + 1;\n      END;\n      OUTPUT(LINE#FILE) = LINE_NUMS;\n      OUTPUT(LINE#FILE) = '%END';\n      CALL REWIND(1,LINE#FILE);\n END FILL_LAST_LINE#_RECORD;\n\n\n\n\n\n      /*      P A S S   T H R E E   I N I T I A L I Z A T I O N        */\n\n\n INITIALIZE: PROCEDURE;\n\n\n      /*     INITIALIZE GLOBAL VARIABLES       */\n\n      COMPILING = TRUE;\n      ENTRY_POINT = 0;\n      NEXT_TEMP = BASE_TEMP;\n      NEXT_TEMP_DISPL = 0;\n      TEMP_DISPL_STACKTOP = 0;\n      FORMAL_PARAMETER = FALSE;\n\n\n      /*  INITIALIZE COUNTERS      */\n\n      #FREE_TEMP = 0;\n      #GET_REG = 0;\n      #FLUSH_REG = 0;\n      #STORE_REG = 0;\n      #MAKE_OP_ADDR = 0;\n      #FLUSH_ALL_TEMP_REGS = 0;\n      #STM_FLUSHES = 0;\n      #EMIT_RR = 0;\n      #EMIT_RX = 0;\n      #EMIT_SS = 0;\n\n\n      /*  INITIALIZE REG COLUMN OF SYMBOL TABLE     */\n\n      DO I = 0 TO SYMBOL_TABLE_SIZE;\n         REG(I) = NULL;\n      END;\n      /*    INITIALIZE REGISTER TABLES. REGS 11-15 ARE FIXED PRIORITY   */\n\n      DO I = 0 TO 22;\n         CONTENT(I) = NULL;\n         PRIORITY(I) = FREE_PRIORITY;\n      END;\n      DO I = 11 TO 15;\n         PRIORITY(I) = FIXED_PRIORITY;\n      END;\n\n\n      /*   LINE NUMBER VARIABLES   */\n      CURRENT_LINE# = 0;\n      LINE_BUFF_PTR = 1;\n      /*   FUDGE A DESCRIPTOR FOR LINE#BUFF    */\n      I = SHL(79,24) + ADDR(LINE#BUFF) + 4;\n      CALL INLINE(LOAD,1,0,I);\n      CALL INLINE(\"50\",1,0,LINE_NUMS);\n\n\n END INITIALIZE;\n\n\n\n\n\n       /*              M A I N    P R O C E D U R E              */\n\n\n\n\n      CPU_CLOCK = CLOCK_TRAP(1);   /*  READ CPU TIMER   */\n      TIME_ENTERED = TIME;\n\n      CALL INITIALIZE;\n      CALL RESTORE_SY_TABLE;\n      DO WHILE COMPILING;\n         CALL READ_TRIPLES;\n         CALL GENERATE_CODE;\n         IF LIST_INSTRUCTIONS THEN CALL LIST_SYMBOLIC_CODE;\n         CALL SWAP_OUT_SEGMENT(CODE_FILE,'%CODE' || I_FORMAT (CODE_INDEX,5) );\n      END;\n      CALL REWIND(0,TRIPLES_FILE);\n      CALL REWIND(1,CODE_FILE);\n      CALL FILL_LAST_LINE#_RECORD;\n      CALL GENERATE_ORG_SEGMENT;\n END_COMPILATION:\n      CALL PRINT_PASS3_STATISTICS;\n\nEOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE10": {"ttr": 9988, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x05\\xa0\\x05\\xa0\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 1440, "newlines": 1440, "modlines": 0, "user": "SPASCAL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FILE11": {"ttr": 10503, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x02\\xad\\x02\\xad\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 685, "newlines": 685, "modlines": 0, "user": "SPASCAL"}, "text": "   /********************************************************************\n   *                                                                   *\n   *                  STONY BROOK PASCAL 360 COMPILER                  *\n   *                   POST MORTEM ANALYSIS ROUTINES                   *\n   *                                                                   *\n   ********************************************************************/\n\n   /*\n\n   COPYRIGHT (C) 1976 DEPARTMENT OF COMPUTER SCIENCE, SUNY AT STONY BROOK.\n\n   */\n\n\n\n   /* THE FOLLOWING VARIABLES ARE INITIALIZED FROM THE STATUS BLOCK, WHOSE\n         ADDRESS IS INSERTED BY THE RUN MONITOR INTO MONITOR_LINK(3):\n      AR_BASE_ADDR IS THE ADDRESS OF THE GLOBAL ACTIVATION RECORD.\n      ORIGIN_ADDR IS THE ADDRESS OF THE ORG SEGMENT.\n      TRANSFER_VECTOR_BASE_ADDR IS THE ADDRESS OF THE ORG SEGMENT TRANSFER\n         VECTOR, WHICH CONTAINS THE ADDRESS OF EACH PASCAL BLOCK ENTRY POINT.\n      CODE_SEG_BASE_ADDR IS THE ADDRESS OF THE PASCAL CODE SEGMENT, OVER WHICH\n         THIS CODE IS OVERLAYED.\n      EXECUTION_TIME IS THE CPU TIME, IN UNITS OF 0.01 SECONDS, USED BY THE\n         PASCAL PROGRAM.\n      ERROR_LINE IS THE SOURCE LINE NUMBER CORRESPONDING TO A RUN ERROR;\n         ZERO IF THE PASCAL PROGRAM TERMINATED NORMALLY.\n      CORETOP IS THE LAST ADDRESS IN THE REGION.  THE VALUE OF CORETOP\n         BECOMES 'FREELIMIT' AT FLOW_SUMMARY TIME, THUS CLOBBERING THE\n         ACTIVATION RECORD STACK AS WELL AS THE HEAP.\n   */\n   DECLARE (AR_BASE_ADDR, ORIGIN_ADDR, TRANSFER_VECTOR_BASE_ADDR,\n            CODE_SEG_BASE_ADDR, EXECUTION_TIME, ERROR_LINE, CORETOP) FIXED;\n\n   /* PASCAL_REGS IS THE ADDRESS OF A LOCATION IN THE ORG SEGMENT WHERE THE\n         PASCAL REGISTERS ARE SAVED IN THE ORDER 11..15, 0..10.\n      BLOCK_COUNTER_BASE_ADDR IS THE ADDRESS OF ANOTHER LOCATION IN THE ORG\n         SEGMENT, WHERE THE BASIC BLOCK EXECUTION COUNTERS USED IN THE FLOW\n         SUMMARY ARE FOUND.\n   */\n   DECLARE (PASCAL_REGS, BLOCK_COUNTER_BASE_ADDR) FIXED;\n\n   /* THE VALUES OF THE ABOVE VARIABLES ARE SET IN INITIALIZE, AND REMAIN\n      CONSTANT THEREAFTER.\n   */\n\n   /* SOME COMMONLY USED EUPHAMISMS */\n   DECLARE FALSE LITERALLY '0', TRUE LITERALLY '1', FOREVER LITERALLY 'WHILE 1',\n           REAL LITERALLY 'FIXED', FPR LITERALLY '6', NULL LITERALLY '-1',\n           DEBUG_LEVEL LITERALLY 'MONITOR_LINK(2)';\n\n   /* SOME COMMONLY USED CONSTANT STRINGS */\n   DECLARE X1 CHARACTER INITIAL (' '), X70 CHARACTER INITIAL (\n      '                                                                      ');\n\n   /* THE FLOATING-POINT POWERS OF TEN(LONG).  TWO ADJACENT ENTRIES IN 'POWERS'\n      (EVEN-ODD) FORM ONE DOUBLE-PRECISION REAL.\n   */\n   DECLARE POWERS(307) REAL INITIAL(\"001DA48C\", \"E468E7C7\", \"011286D8\",\n      \"0EC190DC\", \"01B94470\", \"938FA89C\", \"0273CAC6\", \"5C39C961\", \"03485EBB\",\n      \"F9A41DDD\", \"042D3B35\", \"7C0692AA\", \"051C4501\", \"6D841BAA\", \"0611AB20\",\n      \"E472914A\", \"06B0AF48\", \"EC79ACE8\", \"076E6D8D\", \"93CC0C11\", \"08450478\",\n      \"7C5F878B\", \"092B22CB\", \"4DBBB4B7\", \"0A1AF5BF\", \"109550F2\", \"0B10D997\",\n      \"6A5D5297\", \"0BA87FEA\", \"27A539EA\", \"0C694FF2\", \"58C74432\", \"0D41D1F7\",\n      \"777C8A9F\", \"0E29233A\", \"AAADD6A4\", \"0F19B604\", \"AAACA626\", \"101011C2\",\n      \"EAABE7D8\", \"10A0B19D\", \"2AB70E6F\", \"11646F02\", \"3AB26905\", \"123EC561\",\n      \"64AF81A3\", \"13273B5C\", \"DEEDB106\", \"1418851A\", \"0B548EA4\", \"14F53304\",\n      \"714D9266\", \"15993FE2\", \"C6D07B80\", \"165FC7ED\", \"BC424D30\", \"173BDCF4\",\n      \"95A9703E\", \"18256A18\", \"DD89E627\", \"1917624F\", \"8A762FD8\", \"19E9D71B\",\n      \"689DDE72\", \"1A922671\", \"2162AB07\", \"1B5B5806\", \"B4DDAAE4\", \"1C391704\",\n      \"310A8ACF\", \"1D23AE62\", \"9EA696C1\", \"1E164CFD\", \"A3281E39\", \"1EDF01E8\",\n      \"5F912E38\", \"1F8B6131\", \"3BBABCE3\", \"20571CBE\", \"C554B60E\", \"213671F7\",\n      \"3B54F1C9\", \"2222073A\", \"8515171D\", \"23154484\", \"932D2E72\", \"23D4AD2D\",\n      \"BFC3D078\", \"2484EC3C\", \"97DA624B\", \"255313A5\", \"DEE87D6F\", \"2633EC47\",\n      \"AB514E65\", \"272073AC\", \"CB12D0FF\", \"2814484B\", \"FEEBC2A0\", \"28CAD2F7\",\n      \"F5359A3B\", \"297EC3DA\", \"F9418065\", \"2A4F3A68\", \"DBC8F03F\", \"2B318481\",\n      \"895D9627\", \"2C1EF2D0\", \"F5DA7DD9\", \"2D1357C2\", \"99A88EA7\", \"2DC16D9A\",\n      \"0095928A\", \"2E78E480\", \"405D7B96\", \"2F4B8ED0\", \"283A6D3E\", \"302F3942\",\n      \"19248447\", \"311D83C9\", \"4FB6D2AC\", \"3212725D\", \"D1D243AC\", \"32B877AA\",\n      \"3236A4B4\", \"33734ACA\", \"5F6226F1\", \"34480EBE\", \"7B9D5856\", \"352D0937\",\n      \"0D425736\", \"361C25C2\", \"68497682\", \"37119799\", \"812DEA11\", \"37AFEBFF\",\n      \"0BCB24AB\", \"386DF37F\", \"675EF6EB\", \"3944B82F\", \"A09B5A53\", \"3A2AF31D\",\n      \"C4611874\", \"3B1AD7F2\", \"9ABCAF48\", \"3C10C6F7\", \"A0B5ED8D\", \"3CA7C5AC\",\n      \"471B4784\", \"3D68DB8B\", \"AC710CB3\", \"3E418937\", \"4BC6A7F0\", \"3F28F5C2\",\n      \"8F5C28F6\", \"40199999\", \"9999999A\", \"41100000\", \"00000000\", \"41A00000\",\n      \"00000000\", \"42640000\", \"00000000\", \"433E8000\", \"00000000\", \"44271000\",\n      \"00000000\", \"45186A00\", \"00000000\", \"45F42400\", \"00000000\", \"46989680\",\n      \"00000000\", \"475F5E10\", \"00000000\", \"483B9ACA\", \"00000000\", \"492540BE\",\n      \"40000000\", \"4A174876\", \"E8000000\", \"4AE8D4A5\", \"10000000\", \"4B9184E7\",\n      \"2A000000\", \"4C5AF310\", \"7A400000\", \"4D38D7EA\", \"4C680000\", \"4E2386F2\",\n      \"6FC10000\", \"4F163457\", \"85D8A000\", \"4FDE0B6B\", \"3A764000\", \"508AC723\",\n      \"0489E800\", \"5156BC75\", \"E2D63100\", \"523635C9\", \"ADC5DEA0\", \"5321E19E\",\n      \"0C9BAB24\", \"54152D02\", \"C7E14AF7\", \"54D3C21B\", \"CECCEDA1\", \"55845951\",\n      \"61401485\", \"5652B7D2\", \"DCC80CD3\", \"5733B2E3\", \"C9FD0804\", \"58204FCE\",\n      \"5E3E2502\", \"591431E0\", \"FAE6D721\", \"59C9F2C9\", \"CD04674F\", \"5A7E37BE\",\n      \"2022C091\", \"5B4EE2D6\", \"D415B85B\", \"5C314DC6\", \"448D9339\", \"5D1ED09B\",\n      \"EAD87C03\", \"5E134261\", \"72C74D82\", \"5EC097CE\", \"7BC90716\", \"5F785EE1\",\n      \"0D5DA46E\", \"604B3B4C\", \"A85A86C4\", \"612F050F\", \"E938943B\", \"621D6329\",\n      \"F1C35CA5\", \"63125DFA\", \"371A19E7\", \"63B7ABC6\", \"27050306\", \"6472CB5B\",\n      \"D86321E4\", \"6547BF19\", \"673DF52E\", \"662CD76F\", \"E086B93D\", \"671C0615\",\n      \"EC5433C6\", \"68118427\", \"B3B4A05C\", \"68AF298D\", \"050E4396\", \"696D79F8\",\n      \"2328EA3E\", \"6A446C3B\", \"15F99267\", \"6B2AC3A4\", \"EDBBFB80\", \"6C1ABA47\",\n      \"14957D30\", \"6D10B46C\", \"6CDD6E3E\", \"6DA70C3C\", \"40A64E6C\", \"6E6867A5\",\n      \"A867F104\", \"6F4140C7\", \"8940F6A2\", \"7028C87C\", \"B5C89A25\", \"71197D4D\",\n      \"F19D6057\", \"71FEE50B\", \"7025C36A\", \"729F4F27\", \"26179A22\", \"73639178\",\n      \"77CEC055\", \"743E3AEB\", \"4AE13835\", \"7526E4D3\", \"0ECCC321\", \"76184F03\",\n      \"E93FF9F5\", \"76F31627\", \"1C7FC391\", \"7797EDD8\", \"71CFDA3A\", \"785EF4A7\",\n      \"4721E864\", \"793B58E8\", \"8C75313F\", \"7A251791\", \"57C93EC7\", \"7B172EBA\",\n      \"D6DDC73D\", \"7BE7D34C\", \"64A9C85D\", \"7C90E40F\", \"BEEA1D3A\", \"7D5A8E89\",\n      \"D7525244\", \"7E389916\", \"2693736B\", \"7F235FAD\", \"D81C2823\");\n\n\n\n         /*   P R O C E D U R E S   */\n\n\n\nDIVFLT:\n   PROCEDURE (DIVIDEND, DIVISOR) REAL;\n      DECLARE (DIVIDEND, DIVISOR, QUOTIENT) REAL;\n      CALL INLINE(\"78\",FPR,0,DIVIDEND);          /* LE   FPR,DIVIDEND      */\n      CALL INLINE(\"7D\",FPR,0,DIVISOR);           /* DE   FPR,DIVISOR       */\n      CALL INLINE(\"70\",FPR,0,QUOTIENT);          /* STE  FPR,QUOTIENT      */\n      RETURN QUOTIENT;\n   END DIVFLT;\n\nROUND:\n   PROCEDURE(X) FIXED;\n      DECLARE X REAL, WORK(4) REAL, HALF REAL INITIAL(\"40800000\"),\n              ZERO(4) REAL INITIAL(\"4E000000\", 0, 0, \"4E000000\", 0);\n      /* NOTE THAT IF WORK IS DOUBLE-WORD ALLIGNED, THEN SO IS ZERO. */\n      DECLARE IS_ALLIGNED BIT(1), OFFSET FIXED;\n      IS_ALLIGNED = ((ADDR(WORK) & \"FFFFFFF8\") = ADDR(WORK));\n      IF IS_ALLIGNED THEN OFFSET = 0;   ELSE OFFSET = 12;\n      CALL INLINE(\"58\",2,0,OFFSET);              /* L    2,OFFSET          */\n      CALL INLINE(\"2B\",FPR,FPR);                 /* SDR  FPR,FPR           */\n      CALL INLINE(\"78\",FPR,0,X);                 /* LE   FPR,X             */\n      CALL INLINE(\"7A\",FPR,0,HALF);              /* AE   FPR,HALF          */\n      CALL INLINE(\"6E\",FPR,2,ZERO);              /* AW   FPR,ZERO(2)       */\n      CALL INLINE(\"60\",FPR,2,WORK);              /* STD  FPR,WORK(2)       */\n      IF IS_ALLIGNED THEN RETURN WORK(1);   ELSE RETURN WORK(4);\n   END ROUND;\n\nI_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;\n      STRING = NUMBER;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN SUBSTR(X70, 0, WIDTH - L) || STRING;\n   END I_FORMAT;\n\nE_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, MANTISSA) FIXED;\n      DECLARE (WIDTH, EXPONENT, I, J, X) BIT(16);\n      DECLARE (S, S1) CHARACTER;\n      /* MINIMUM FIELD IS B+9.9E+99 */\n      IF WIDTH < 9 THEN WIDTH = 9;\n      /* MAXIMUM 7 SIGNIFICANT DIGITS */\n      IF WIDTH > 14 THEN\n         DO;\n            S = SUBSTR(X70, 0, WIDTH - 13);\n            WIDTH = 14;\n         END;\n      ELSE S = X1; /* MUST HAVE LEADING BLANK */\n      IF NUMBER < 0 THEN\n         DO;\n            S = S || '-';\n            NUMBER = NUMBER & \"7FFFFFFF\";\n         END;\n      ELSE S = S || X1;\n      IF (NUMBER & \"00FFFFFF\") = 0 THEN\n         RETURN S || SUBSTR('0.0000000', 0, WIDTH - 6) || 'E+00';\n      IF NUMBER < POWERS(14) /* 10**-71 */ THEN\n         DO;\n            NUMBER = DIVFLT(NUMBER, POWERS(0));\n            /* NUMBER = NUMBER / 10**-78 */\n            EXPONENT = - 78;\n         END;\n      ELSE EXPONENT = 0;\n      /* NOW BINARY-SEARCH THE ARRAY POWERS TO FIND X SUCH THAT\n            10**X  <=  NUMBER  <  10**(X+1)  .   */\n      I = 0;   J = 306;   X = 152;\n      DO WHILE I <= J;\n         IF POWERS(X) <= NUMBER THEN I = X + 2;\n         ELSE J = X - 2;\n         X = SHR(I + J, 1) & \"FFFE\";\n      END;\n      MANTISSA = ROUND(DIVFLT(NUMBER, POWERS(X - 14)));\n      EXPONENT = EXPONENT + SHR(X, 1) - 78;\n      S1 = MANTISSA;\n      IF LENGTH(S1) > 8 THEN EXPONENT = EXPONENT + 1;\n      ELSE IF LENGTH(S1) < 8 THEN EXPONENT = EXPONENT - 1;\n      S = S || SUBSTR(S1, 0, 1) || '.' || SUBSTR(S1, 1, WIDTH - 8) || 'E';\n      IF EXPONENT >= 0 THEN S = S || '+';\n      ELSE\n         DO;\n            S = S || '-';\n            EXPONENT = - EXPONENT;\n         END;\n      IF EXPONENT < 10 THEN RETURN S || '0' || EXPONENT;\n      ELSE RETURN S || EXPONENT;\n   END E_FORMAT;\n\nREWIND:\n   PROCEDURE (IS_OUTPUT_FILE, FILE#);\n      DECLARE IS_OUTPUT_FILE BIT(1), FILE# FIXED;\n      CALL INLINE(\"1B\",0,0);                     /* SR   0,0              */\n      CALL INLINE(\"43\",0,0,IS_OUTPUT_FILE);      /* IC   0,IS_OUTPUT_FILE */\n      CALL INLINE(\"41\",1,0,0,28);                /* LA   1,28             */\n      CALL INLINE(\"58\",2,0,FILE#);               /* L    2,FILE#          */\n      CALL INLINE(\"05\",12,15);                   /* BALR 12,15            */\n   END REWIND;\n\nPRINT_TIME:\n   PROCEDURE(TIME, MESSAGE);\n      DECLARE (TIME, L) FIXED, (MESSAGE, STRING) CHARACTER;\n      STRING = TIME;   L = LENGTH(STRING);\n      IF L < 5 THEN STRING = SUBSTR('00000', 0, 5 - L) || STRING;\n      STRING = '0' || SUBSTR(STRING, 0, 3) || '.' || SUBSTR(STRING, 3, 2);\n      OUTPUT(1) = STRING || MESSAGE;\n   END PRINT_TIME;\n\nSOURCE_LINE:\n   PROCEDURE (ABSOLUTE_ADDRESS) FIXED;\n      DECLARE (ABSOLUTE_ADDRESS, RELATIVE_ADDRESS, LINE#, I) FIXED,\n              LINES(19) FIXED, BUFFER CHARACTER;\n      DECLARE LINE#_FILE FIXED INITIAL (5);\n      LINE# = 0;\n      IF (ABSOLUTE_ADDRESS < CODE_SEG_BASE_ADDR)\n         | (ABSOLUTE_ADDRESS >= AR_BASE_ADDR) THEN\n         RETURN 0;\n      RELATIVE_ADDRESS = ABSOLUTE_ADDRESS - CODE_SEG_BASE_ADDR;\n      BUFFER = INPUT(LINE#_FILE);\n      CALL INLINE(\"58\",1,0,BUFFER);              /* L    1,BUFFER         */\n      CALL INLINE(\"41\",2,0,LINES);               /* LA   2,LINES          */\n      CALL INLINE(\"D2\",\"4\",\"F\",2,0,1,0);         /* MVC  0(80,2),0(1)     */\n      DO WHILE (BYTE(BUFFER) \u00ac= BYTE('%')) & (LINES(19) <= RELATIVE_ADDRESS);\n         LINE# = LINE# + 20;\n         BUFFER = INPUT(LINE#_FILE);\n         CALL INLINE(\"58\",1,0,BUFFER);           /* L    1,BUFFER         */\n         CALL INLINE(\"41\",2,0,LINES);            /* LA   2,LINES          */\n         CALL INLINE(\"D2\",\"4\",\"F\",2,0,1,0);      /* MVC  0(80,2),0(1)     */\n      END;\n      CALL REWIND(FALSE, LINE#_FILE);\n      IF BYTE(BUFFER) = BYTE('%') THEN\n         RETURN LINE#;\n      I = 18;\n      DO WHILE (I >= 0) & (LINES(I) > RELATIVE_ADDRESS);\n         I = I - 1;\n      END;\n      RETURN LINE# + I + 1;\n   END SOURCE_LINE;\n\nINITIALIZE:\n   PROCEDURE;\n      DECLARE I FIXED;\n      I = SHR(MONITOR_LINK(3), 2);\n      AR_BASE_ADDR = COREWORD(I);\n      ORIGIN_ADDR = COREWORD(I + 1);\n      TRANSFER_VECTOR_BASE_ADDR = COREWORD(I + 2);\n      CODE_SEG_BASE_ADDR = COREWORD(I + 3);\n      EXECUTION_TIME = COREWORD(I + 4);\n      ERROR_LINE = COREWORD(I + 5);\n      CORETOP = COREWORD(I + 6);\n      PASCAL_REGS = ORIGIN_ADDR + 208;\n      BLOCK_COUNTER_BASE_ADDR = ORIGIN_ADDR + 308;\n   END INITIALIZE;\n\nPOST_MORTEM_DUMP:\n   PROCEDURE;\n\n      /* THE PMD TABLES */\n      DECLARE SYTSIZE LITERALLY '255';\n      DECLARE IDENTITY(SYTSIZE) CHARACTER,\n              DATATYPE(SYTSIZE) BIT(16),\n              VAR_TYPE(SYTSIZE) BIT(16),\n              STRUCTYPE(SYTSIZE) BIT(16),\n              STORAGE_LNGTH(SYTSIZE) BIT(16),\n              S_LIST(SYTSIZE) BIT(16),\n              DISPLACEMENT(SYTSIZE) FIXED,\n              VALUE(SYTSIZE) FIXED;\n      DECLARE PROCMAX LITERALLY '127';\n      DECLARE PROC_HEAD(PROCMAX) FIXED;\n\n      /* VAR_TYPE CODES ENCOUNTERED IN PMD TABLES */\n      DECLARE VARIABLE BIT(16) INITIAL (1),\n              CONSTANT BIT(16) INITIAL (2),\n              TYPE     BIT(16) INITIAL (4),\n              PROC     BIT(16) INITIAL (5);\n\n      /* STRUCTYPE CODES ENCOUNTERED IN PMD TABLES */\n      DECLARE STATEMENT  BIT(16) INITIAL (0),\n              SCALAR     BIT(16) INITIAL (1),\n              SUBRANGE   BIT(16) INITIAL (2),\n              POINTER    BIT(16) INITIAL (3),\n              ARRAY      BIT(16) INITIAL (4),\n              ARITHMETIC BIT(16) INITIAL (14);\n\n      /* POINTERS INTO THE PMD TABLES TO THE PREDECLARED TYPES */\n      DECLARE INTPTR  BIT(16) INITIAL (2),\n              BOOLPTR BIT(16) INITIAL (3),\n              REALPTR BIT(16) INITIAL (4),\n              CHARPTR BIT(16) INITIAL (5);\n\n      DECLARE FATAL_ERROR BIT(1),\n              (THIS_PROC, N_DECL_SYMB, PROC_SEQUENCE_NUMBER) BIT(16),\n              (CBR, ARBASE, GLOBAL_ARBASE, CALLED_FROM_ADDR) FIXED;\n\n   INITIALIZE_PMD_TABLES:\n      PROCEDURE;\n         DECLARE PMD_FILE BIT(16) INITIAL (6),\n                 BUFFER CHARACTER,\n                 I FIXED;\n\n      NEXT_SYMBOL:\n         PROCEDURE CHARACTER;\n            DECLARE S CHARACTER;\n            IF LENGTH(BUFFER) < 12 THEN\n               BUFFER = BUFFER || INPUT(PMD_FILE);\n            S = SUBSTR(BUFFER, 0, 12);\n            BUFFER = SUBSTR(BUFFER, 12);\n            RETURN S;\n         END NEXT_SYMBOL;\n\n      READ_COLUMN:\n         PROCEDURE (ARRAY_ADDR, BYTES_PER_ITEM, LIMIT);\n            DECLARE (BYTES_PER_ITEM, LIMIT) BIT(16),\n                    (ARRAY_ADDR, INCREMENT, I, J, K) FIXED,\n                    MOVE (2) BIT(16) INITIAL (\"D200\", \"2000\", \"1000\");\n            INCREMENT = 80/BYTES_PER_ITEM;\n            J = ARRAY_ADDR;\n            I = 0;\n            DO WHILE I + INCREMENT <= LIMIT;\n               CALL INLINE(\"58\",1,0,BUFFER);     /* L    1,BUFFER          */\n               CALL INLINE(\"58\",2,0,J);          /* L    2,J               */\n               CALL INLINE(\"D2\",\"4\",\"F\",2,0,1,0);/* MVC  0(80,2),0(1)      */\n               I = I + INCREMENT;\n               J = J + 80;\n               BUFFER = INPUT(PMD_FILE);\n            END;\n            K = (LIMIT - I + 1)*BYTES_PER_ITEM - 1;\n            CALL INLINE(\"58\",1,0,BUFFER);        /* L    1,BUFFER          */\n            CALL INLINE(\"58\",2,0,J);             /* L    2,J               */\n            CALL INLINE(\"58\",3,0,K);             /* L    3,K               */\n            CALL INLINE(\"44\",3,0,MOVE);          /* EX   3,MOVE            */\n            BUFFER = INPUT(PMD_FILE);\n         END READ_COLUMN;\n\n         N_DECL_SYMB, PROC_SEQUENCE_NUMBER = 0;\n         BUFFER = INPUT(PMD_FILE);\n         IF SUBSTR(BUFFER, 0, 5) \u00ac= '%PMD ' THEN\n            DO;\n               OUTPUT = '%PMD CARD EXPECTED';\n               FATAL_ERROR = TRUE;\n               RETURN;\n            END;\n         DO I = 5 TO 9;\n            IF BYTE(BUFFER, I) \u00ac= BYTE(' ') THEN\n               N_DECL_SYMB = 10*N_DECL_SYMB + BYTE(BUFFER, I) - BYTE('0');\n         END;\n         DO I = 10 TO 14;\n            IF BYTE(BUFFER, I) \u00ac= BYTE(' ') THEN\n               PROC_SEQUENCE_NUMBER =\n                  10*PROC_SEQUENCE_NUMBER + BYTE(BUFFER, I) - BYTE('0');\n         END;\n         IF (N_DECL_SYMB > SYTSIZE) | (PROC_SEQUENCE_NUMBER > PROCMAX) THEN\n            DO;\n               OUTPUT = 'PMD TABLE OVERFLOW';\n               FATAL_ERROR = TRUE;\n               RETURN;\n            END;\n         BUFFER = INPUT(PMD_FILE);\n         DO I = 0 TO N_DECL_SYMB;\n            IDENTITY(I) = NEXT_SYMBOL;\n         END;\n         BUFFER = INPUT(PMD_FILE);\n         CALL READ_COLUMN(ADDR(DATATYPE), 2, N_DECL_SYMB);\n         CALL READ_COLUMN(ADDR(VAR_TYPE), 2, N_DECL_SYMB);\n         CALL READ_COLUMN(ADDR(STRUCTYPE), 2, N_DECL_SYMB);\n         CALL READ_COLUMN(ADDR(STORAGE_LNGTH), 2, N_DECL_SYMB);\n         CALL READ_COLUMN(ADDR(S_LIST), 2, N_DECL_SYMB);\n         CALL READ_COLUMN(ADDR(DISPLACEMENT), 4, N_DECL_SYMB);\n         CALL READ_COLUMN(ADDR(VALUE), 4, N_DECL_SYMB);\n         CALL READ_COLUMN(ADDR(PROC_HEAD), 4, PROC_SEQUENCE_NUMBER);\n         IF SUBSTR(BUFFER, 0, 4) \u00ac= '%END' THEN\n            DO;\n               OUTPUT = '%END CARD EXPECTED';\n               FATAL_ERROR = TRUE;\n            END;\n      END INITIALIZE_PMD_TABLES;\n\n   INITIALIZE_PMD_POINTERS:\n      PROCEDURE;\n         GLOBAL_ARBASE = AR_BASE_ADDR;\n         ARBASE = COREWORD(SHR(PASCAL_REGS, 2)) & \"00FFFFFF\";\n         CBR = COREWORD(SHR(PASCAL_REGS, 2) + 1) & \"00FFFFFF\";\n         FATAL_ERROR = (CBR < CODE_SEG_BASE_ADDR) | (CBR > GLOBAL_ARBASE)\n                       | (ARBASE < GLOBAL_ARBASE)\n                       | (ARBASE >= CORETOP);\n      END INITIALIZE_PMD_POINTERS;\n\n   FINDPROC:\n      PROCEDURE (CBR) BIT(16);\n         /* RETURNS SEQUENCE # OF CODE BLOCK WHOSE ENTRY POINT ADDRESS\n            IS IN CBR. */\n         DECLARE CBR FIXED, SEQ# BIT(16);\n         DO SEQ# = 0 TO PROC_SEQUENCE_NUMBER;\n            /* SEARCH THE TRANSFER VECTOR. */\n            IF CBR = COREWORD(SHR(TRANSFER_VECTOR_BASE_ADDR, 2) + SEQ#) THEN\n               RETURN SEQ#;\n         END;\n         /* CBR IS NOT A VALID ENTRY POINT. */\n         RETURN NULL;\n      END FINDPROC;\n\n   DUMP_LOCAL_VARIABLES:\n      PROCEDURE (SEQ#);\n         DECLARE (SEQ#, #ACTIVATIONS, VAR_PTR, PROC_PTR, L) BIT(16),\n                 (VAR_VALUE, VAR_ADDR, I, B) FIXED,\n                 (LINE, S) CHARACTER,\n                 MAX_DUMPS LITERALLY '5';\n\n      TAB:\n         PROCEDURE;\n            /* AFTER EXECUTION OF THIS PROCEDURE,\n               LENGTH(LINE) IN (.1, 33, 65, 97.) */\n            DECLARE (L1, L2) BIT(16);\n            L1 = LENGTH(LINE);\n            L2 = (L1 - 1) MOD 32;\n            IF (L1 < 97) & (L2 \u00ac= 0) THEN\n               LINE = LINE || SUBSTR(X70, 0, 32 - L2);\n            ELSE IF L1 > 97 THEN\n               DO;\n                  OUTPUT = LINE;\n                  LINE = X1;\n               END;\n         END TAB;\n\n         #ACTIVATIONS = SHR(PROC_HEAD(SEQ#), 16);\n         IF #ACTIVATIONS = MAX_DUMPS THEN\n            DO;   /* WRITE ELLIPSES */\n               OUTPUT = '. . .';\n               OUTPUT  = '';   /* WRITES A BLANK LINE */\n            END;\n         #ACTIVATIONS = #ACTIVATIONS + 1;\n         PROC_HEAD(SEQ#) = (PROC_HEAD(SEQ#) & \"FFFF\") | SHL(#ACTIVATIONS, 16);\n         IF #ACTIVATIONS > MAX_DUMPS THEN RETURN;\n         PROC_PTR = PROC_HEAD(SEQ#) & \"FFFF\";\n         IF SEQ# = 0 THEN\n            LINE = '=> PROGRAM BLOCK ';\n         ELSE IF STRUCTYPE(PROC_PTR) = STATEMENT THEN\n            LINE = '=> PROCEDURE BLOCK ';\n         ELSE LINE = '=> FUNCTION BLOCK ';\n         OUTPUT = LINE || IDENTITY(PROC_PTR);\n         VAR_PTR = S_LIST(PROC_PTR);\n         IF VAR_PTR = NULL THEN\n            OUTPUT(1) =\n               '0  NO LOCAL SCALAR, SUBRANGE, POINTER OR STRING VARIABLES';\n         ELSE OUTPUT(1) = '0  VALUE OF LOCAL VARIABLES:';\n         LINE = X1;\n         DO WHILE VAR_PTR \u00ac= NULL;\n            VAR_ADDR = ARBASE + DISPLACEMENT(VAR_PTR);\n            S = X1 || IDENTITY(VAR_PTR);\n            L = LENGTH(S) - 1;\n            DO WHILE BYTE(S, L) = BYTE(' ');\n               L = L - 1;\n            END;\n            S = SUBSTR(S, 0, L + 1) || ' = ';\n            IF STRUCTYPE(VAR_PTR) \u00ac= ARRAY THEN\n               DO; /* FETCH VALUE FROM ACTIVATION RECORD */\n                  VAR_VALUE = 0;\n                  DO I = 0 TO STORAGE_LNGTH(VAR_PTR) - 1;\n                     VAR_VALUE = SHL(VAR_VALUE, 8) + COREBYTE(VAR_ADDR + I);\n                  END;\n                  VAR_VALUE = VAR_VALUE + VALUE(VAR_PTR);\n                  IF DATATYPE(VAR_PTR) = CHARPTR THEN\n                     DO;\n                        S = S || '''X''';\n                        BYTE(S, LENGTH(S) - 2) = VAR_VALUE;\n                     END;\n                  ELSE IF STRUCTYPE(DATATYPE(VAR_PTR)) = SCALAR THEN\n                     DO;\n                        I = S_LIST(DATATYPE(VAR_PTR)) + VAR_VALUE;\n                        IF (DATATYPE(I) = DATATYPE(VAR_PTR))\n                           & (VAR_TYPE(I) = CONSTANT) THEN\n                           S = S || IDENTITY(I);\n                        ELSE S = S || '?';\n                     END;\n                  ELSE IF STRUCTYPE(VAR_PTR) = POINTER THEN\n                     DO;\n                        IF VAR_VALUE = 0 THEN S = S || 'UNDEFINED';\n                        ELSE IF VAR_VALUE = \"FBFBFBFB\" THEN S = S || 'NIL';\n                        ELSE S = S || '(DEFINED)';\n                     END;\n                  ELSE IF DATATYPE(VAR_PTR) = REALPTR THEN\n                     S = S || E_FORMAT(VAR_VALUE, 14);\n                  ELSE S = S || VAR_VALUE;\n                  IF (STRUCTYPE(VAR_PTR) \u00ac= POINTER) &\n                     (VAR_VALUE = VALUE(VAR_PTR)) THEN\n                     DO;   /* POSSIBLY UNDEFINED VARIABLE */\n                        L = LENGTH(S) - 1;\n                        DO WHILE BYTE(S, L) = BYTE(' ');\n                           L = L - 1;\n                        END;\n                        S = SUBSTR(S, 0, L + 1) || ' (OR UNDEFINED)';\n                     END;\n                  LINE = LINE || S;\n                  CALL TAB;\n               END;\n            ELSE   /* CHARACTER ARRAY */\n               DO;\n                  IF LENGTH(LINE) + LENGTH(S) + STORAGE_LNGTH(VAR_PTR) + 2 > 132\n                  THEN\n                     DO;\n                        IF LENGTH(LINE) > 1 THEN OUTPUT = LINE;\n                        LINE = X1;\n                     END;\n                  L = STORAGE_LNGTH(VAR_PTR);\n                  IF LENGTH(S) + L > 130 THEN L = 130 - LENGTH(S);\n                  LINE = LINE || S;\n                  S = 'X';\n                  DO WHILE LENGTH(S) + 70 < L;\n                     S = S || X70;\n                  END;\n                  IF LENGTH(S) < L THEN S = S || SUBSTR(X70, 0, L - LENGTH(S));\n                  DO I = 0 TO L - 1;\n                     B = COREBYTE(VAR_ADDR + I);\n                     BYTE(S, I) = B;\n                  END;\n                  LINE = LINE || '''' || S || '''';\n                  CALL TAB;\n               END;\n         /* S_LIST(VAR_PTR) = NULL OR VAR_PTR < S_LIST(VAR_PTR) <= N_DECL_SYMB\n            AND VAR_TYPE(S_LIST(VAR_PTR)) = VARIABLE */\n            VAR_PTR = S_LIST(VAR_PTR);\n         END; /* WHILE */\n         IF LENGTH(LINE) > 1 THEN OUTPUT = LINE;\n         OUTPUT = '';   /* WRITES A BLANK LINE */\n         IF SEQ# = 0 THEN RETURN;\n         LINE = '  ' || IDENTITY(PROC_PTR);\n         L = LENGTH(LINE) - 1;\n         DO WHILE BYTE(LINE, L) = BYTE(' ');\n            L = L - 1;\n         END;\n         OUTPUT = SUBSTR(LINE, 0, L + 1) || ' WAS CALLED NEAR LINE '\n                  || SOURCE_LINE(CALLED_FROM_ADDR);\n         OUTPUT = '';\n      END DUMP_LOCAL_VARIABLES;\n\n      /****   POST MORTEM DUMP STARTS HERE   ****/\n      FATAL_ERROR = FALSE;\n      CALL INITIALIZE_PMD_POINTERS;\n      IF FATAL_ERROR THEN RETURN;\n      CALL INITIALIZE_PMD_TABLES;\n      IF FATAL_ERROR THEN RETURN;\n      OUTPUT(1) = '1=> TRACE OF ACTIVE BLOCKS';\n      OUTPUT = '';\n      DO FOREVER;\n         THIS_PROC = FINDPROC(CBR);   /* RETURNS SEQ# */\n         IF THIS_PROC = NULL THEN RETURN;\n         CALLED_FROM_ADDR = (COREWORD(SHR(ARBASE, 2) + 1) & \"00FFFFFF\") - 2;\n         CALL DUMP_LOCAL_VARIABLES(THIS_PROC);\n         CBR = COREWORD(SHR(ARBASE, 2) + 3);\n         IF ARBASE \u00ac= GLOBAL_ARBASE THEN\n            ARBASE = COREWORD(SHR(ARBASE, 2) + 2);\n         ELSE RETURN;\n      END;\n   END POST_MORTEM_DUMP;\n\nBLOCK_COUNT:\n   PROCEDURE (BLOCK#) FIXED;\n      DECLARE (I, BLOCK#) FIXED;\n      DECLARE WORK(4) FIXED, OFFSET FIXED;\n      IF (ADDR(WORK) & \"FFFFFFF8\") \u00ac= ADDR(WORK) THEN OFFSET = 12;\n      ELSE OFFSET = 0;   /* OFFSET IS INDEX INTO WORK OF DOUBLEWORD BOUNDARY */\n      I = BLOCK_COUNTER_BASE_ADDR + SHL(BLOCK#, 2);\n      WORK(0), WORK(3) = 0;\n      WORK(1) = COREWORD(SHR(I, 2));\n      WORK(4) = WORK(1);\n      CALL INLINE(\"58\",2,0,OFFSET);              /* L    2,OFFSET          */\n      CALL INLINE(\"4F\",3,2,WORK);   /*   CVB INTO XPL FUNC RETURN REG   */\n   END BLOCK_COUNT;\n\nFLOW_SUMMARY:\n   PROCEDURE (ERROR_LINE);\n      DECLARE ERROR_LINE FIXED;\n      DECLARE DGNS#_FILE_NO FIXED INITIAL (3);\n      DECLARE READING BIT(1), BLOCK# BIT(16);\n      DECLARE STRING CHARACTER, I FIXED;\n\n   DGNS#_DUMP:\n      PROCEDURE (BLOCK_NUMBER);\n      /* DUMP ONE SUMMARY BLOCK */\n         DECLARE (POS, I, LAST_LINE, LINE_NUMBER, BLOCK_NUMBER,\n                  INDENTATION) FIXED,\n                 SUMMARY_1(7200) BIT(8), /* MUST BE FULLWORD-ALLIGNED */\n                 (TEMP_STRING, EXTRA_STR) CHARACTER,\n                 COUNTER# BIT(16);\n\n      DECODE:\n         PROCEDURE (POS) CHARACTER;\n            /* DECODE ONE LINE OF PARAGRAPHED TEXT */\n            DECLARE (POS, I) FIXED, (EXTRA_STR, CHAR_STR) CHARACTER;\n            CHAR_STR = 'X';\n            EXTRA_STR = X1;\n            DO I = 1 TO SUMMARY_1(POS + 1);\n               BYTE(CHAR_STR) = SUMMARY_1(POS + I + 5);\n               EXTRA_STR = EXTRA_STR || CHAR_STR;\n            END;\n            RETURN EXTRA_STR;\n         END DECODE;\n\n         SUMMARY_1 = FILE(DGNS#_FILE_NO, BLOCK_NUMBER);\n         READING = SUMMARY_1(0);\n         POS = 1;\n         DO WHILE POS < 7200;\n            /* MAKE SURE THE BLOCK DOES NOT END PREMATURELY */\n            IF SUMMARY_1(POS + 1) = 0 THEN\n               POS = 7200;\n            ELSE\n               DO;\n                  LAST_LINE = LINE_NUMBER;\n                  LINE_NUMBER = SHL(SUMMARY_1(POS + 2), 8) + SUMMARY_1(POS + 3);\n                  IF ERROR_LINE > 0 THEN\n                     IF ((LAST_LINE < ERROR_LINE) & (LINE_NUMBER >= ERROR_LINE))\n                       | ((LAST_LINE = ERROR_LINE) & (LINE_NUMBER > ERROR_LINE))\n                  THEN\n                OUTPUT = '---- ERROR -------------------------------------------\n------------------------------------------------------------------------------';\n                  COUNTER# = SHL(SUMMARY_1(POS + 4), 8) + SUMMARY_1(POS + 5);\n                  TEMP_STRING = LINE_NUMBER;\n                  I = LENGTH(TEMP_STRING);\n                  IF I < 4 THEN\n                     TEMP_STRING = SUBSTR('0000', 0, 4 - I) || TEMP_STRING;\n                  EXTRA_STR = DECODE(POS);\n                  INDENTATION = SUMMARY_1(POS);\n                  TEMP_STRING = TEMP_STRING || SUBSTR(X70, 0, INDENTATION);\n                  IF EXTRA_STR = '  ' THEN TEMP_STRING = '';\n                  ELSE IF COUNTER# \u00ac= NULL THEN\n                     EXTRA_STR = I_FORMAT(BLOCK_COUNT(COUNTER#), 8)\n                                     || '.--|     ' || EXTRA_STR;\n                  ELSE EXTRA_STR = '           |     ' || EXTRA_STR;\n                  OUTPUT = TEMP_STRING || EXTRA_STR;\n               END;\n            POS = POS + SUMMARY_1(POS + 1) + 6;\n         END;\n      END DGNS#_DUMP;\n\n      /* FIRST EXECUTABLE STATEMENT OF FLOW_SUMMARY */\n      READING = TRUE;\n      BLOCK# = 0;\n      OUTPUT(1) = '1=> EXECUTION FLOW SUMMARY';\n      OUTPUT = '';   /* PRINTS A BLANK LINE */\n      DO WHILE READING;\n         CALL DGNS#_DUMP(BLOCK#);\n         BLOCK# = BLOCK# + 1;\n      END;\n   END FLOW_SUMMARY;\n\n\n\nMAIN_PROCEDURE:\n   PROCEDURE;\n\n      CALL INITIALIZE;\n\n      IF (DEBUG_LEVEL > 0) & (ERROR_LINE \u00ac= 0) THEN\n         CALL POST_MORTEM_DUMP;\n\n      IF DEBUG_LEVEL > 1 THEN\n         DO;\n            FREELIMIT = CORETOP;\n            CALL FLOW_SUMMARY(ERROR_LINE & \"00FFFFFF\");\n         END;\n\n      CALL PRINT_TIME(EXECUTION_TIME, ' SECONDS IN EXECUTION.');\n\n   END MAIN_PROCEDURE;\n\n\n   CALL MAIN_PROCEDURE;\n\nEOF EOF EOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE12": {"ttr": 10760, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x01\\xc2\\x01\\xc2\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 450, "newlines": 450, "modlines": 0, "user": "SPASCAL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FILE13": {"ttr": 11014, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x03\\x04\\x03\\x04\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 772, "newlines": 772, "modlines": 0, "user": "SPASCAL"}, "text": "//       (JOB CARD)\n// EXEC PASCAL,DBGLVL=0\n//SYSIN    DD  *\nPROGRAM     ANCESTOR(OUTPUT);\n (* R.W.FLOYD: 'ANCESTOR' , COMM.ACM 6-62 AND 3-63  ,ALG.96 *)\n   CONST N = 100;\n  VAR I,J,K: INTEGER;\n      R: ARRAY (.1..N,1..N.) OF BOOLEAN ;\nBEGIN (* R(I,J)=\"I IS A PARENT OF J\" *)\n     FOR I:=1 TO N DO\n        FOR J:=1 TO N DO R(I,J):=FALSE ;\n     FOR I:=1 TO N DO\n      IF I MOD 10 <>0 THEN R(I,I+1):=TRUE;\n      WRITELN (CLOCK);\n    FOR I:=1 TO N DO\n       FOR J:=1 TO N DO\n          IF R(J,I) THEN\n             FOR K:=1 TO N DO\n                IF R(I,K) THEN R(J,K):=TRUE;\n      WRITELN (CLOCK);\n       FOR I:=1 TO N DO\n        BEGIN WRITE(' ') ;\n          FOR J:=1 TO N DO WRITE(CHR(ORD(R(I,J))+ORD('0')));\n    WRITELN\n   END;\n    WRITELN (CLOCK)\nEND.\n// EXEC PASCAL,DBGLVL=0\n//SYSIN    DD  *\nPROGRAM     ANCESTOR(OUTPUT);\n (* R.W.FLOYD: 'ANCESTOR' , COMM.ACM 6-62 AND 3-63  ,ALG.96 *)\n   (*  IN THIS VERSION, USE VARIABLES OF SUBRANGE TZPES FOR INDEXING ARRAYS *)\n   CONST N = 100;\n  VAR I,J,K : 1..N;\n      R: ARRAY (.1..N,1..N.) OF BOOLEAN ;\nBEGIN (* R(I,J)=\"I IS A PARENT OF J\" *)\n     FOR I:=1 TO N DO\n        FOR J:=1 TO N DO R(I,J):=FALSE ;\n     FOR I:=1 TO N DO\n      IF I MOD 10 <>0 THEN R(I,I+1):=TRUE;\n      WRITELN (CLOCK);\n    FOR I:=1 TO N DO\n       FOR J:=1 TO N DO\n          IF R(J,I) THEN\n             FOR K:=1 TO N DO\n                IF R(I,K) THEN R(J,K):=TRUE;\n      WRITELN (CLOCK);\n       FOR I:=1 TO N DO\n        BEGIN WRITE(' ') ;\n          FOR J:=1 TO N DO WRITE(CHR(ORD(R(I,J))+ORD('0')));\n    WRITELN\n   END;\n    WRITELN (CLOCK)\nEND.\n// EXEC PASCAL\n//SYSIN    DD  *\nPROGRAM   PRIMES(OUTPUT);\nCONST N=1000; N1=33;    (* N1=SQRT(N) *)\nVAR   I,K,X,INC,LIM,SQUARE,L: INTEGER ;\n       PRIM: BOOLEAN;\n      P,V: ARRAY(.1..N1.) OF INTEGER ;\nBEGIN WRITELN (CLOCK);\n   INTFIELDSIZE := 6;\n   WRITE (2, 3);  L := 2;\n   X:=1; INC:=4; LIM:=1; SQUARE:=9;\n   FOR I:=3 TO N DO\n  BEGIN (* FIND NEXT PRIME *)\n      REPEAT X:=X+INC ; INC:=6-INC ;\n         IF SQUARE <= X THEN\n            BEGIN LIM:=LIM+1 ;\n              V(LIM):=SQUARE ; SQUARE:=SQR(P(LIM+1))\n            END ;\n         K:=2 ; PRIM:=TRUE ;\n         WHILE PRIM AND (K<LIM) DO\n         BEGIN K:=K+1 ;\n            IF V(K)<X THEN V(K):=V(K)+2*P(K) ;\n            PRIM:=X<> V(K)\n         END\n     UNTIL PRIM ;\n     IF I<=N1 THEN P(I):=X ;\n   WRITE (X);  L := L + 1;\n     IF L=20 THEN\n        BEGIN WRITELN ; L:=0\n        END\n   END;\nWRITELN;  WRITELN (CLOCK)\nEND.\n// EXEC PASCAL\n//SYSIN    DD  *\nPROGRAM  POWERSOFTWO(OUTPUT);\nCONST M=30; N=90;   (* M>= N*LOG(2)   *)\nVAR EXP,I,J,L: INTEGER ;\n     C,R,T:INTEGER ;\n    D:ARRAY(.0..M.) OF INTEGER ; (*POSITIVE POWERS*)\n    F: ARRAY (.1..N.) OF INTEGER ;    (*NEGATIVE POWERS*)\nBEGIN L:=0 ; R:=1; D(0):=1;\n    WRITELN (CLOCK);\n    INTFIELDSIZE := 1;\n    FOR EXP:=1 TO N DO\n    BEGIN  (*COMPUTE AND PRINT 2**EXP  *)   C:=0;\n         FOR I:=0 TO L DO\n         BEGIN T:=2*D(I)+C ;\n              IF T>=10 THEN\n                   BEGIN D(I):=T-10; C:=1\n                   END\n              ELSE\n                   BEGIN D(I):=T; C:=0\n                   END\n         END;\n         IF C>0 THEN\n              BEGIN L:=L+1 ; D(L):=1\n              END;\n         FOR I:=M DOWNTO L DO WRITE(' ') ;\n         FOR I:=L DOWNTO 0 DO WRITE(D(I));\n         INTFIELDSIZE := 5;\n         WRITE (EXP, '  .');\n         INTFIELDSIZE:= 1;\n         (* COMPUTE AND PRINT 2**(-EXP)    *)\n         FOR J:=1 TO EXP-1 DO\n         BEGIN R:=10*R+F(J) ;\n              F(J):=R DIV 2; R:=R-2*F(J) ;  WRITE(F(J))\n         END ;\n         F(EXP):=5 ; WRITELN('5'); R:=0\n    END ;\n    WRITELN (CLOCK)\nEND .\n// EXEC PASCAL\n//SYSIN    DD  *\nPROGRAM EIGHTQUEENS(OUTPUT) ;\nVAR I : INTEGER ;\n    A : ARRAY(.1..8.) OF BOOLEAN ;\n    B : ARRAY(.2..16.) OF BOOLEAN ;\n    C : ARRAY(.-7..7.) OF BOOLEAN ;\n    X : ARRAY(.1..8.) OF INTEGER ;\n    SAFE : BOOLEAN ;\n    PROCEDURE PRINT ;\n    VAR K : INTEGER ;\n    BEGIN WRITE(' ') ;\n        FOR K:=1 TO 8 DO WRITE(X(K));\n         WRITELN\n    END ;\nPROCEDURE TRYCOL(J : INTEGER ) ;\n         VAR I : INTEGER ;\n         PROCEDURE SETQUEEN ;\n         BEGIN A(I):=FALSE ; B(I+J):=FALSE ; C(I-J):=FALSE\n         END ;\n         PROCEDURE REMOVEQUEEN ;\n         BEGIN A(I):=TRUE ; B(I+J):=TRUE ; C(I-J):=TRUE\n         END ;\n              BEGIN\n                    I:=0      ;\n                   REPEAT I:=I+1 ; SAFE:=A(I) AND B(I+J) AND C(I-J) ;\n                        IF SAFE THEN\n                        BEGIN SETQUEEN ; X(J):=I ;\n                             IF J<8 THEN TRYCOL(J+1) ELSE PRINT ;\n                             REMOVEQUEEN\n                        END\n                   UNTIL I=8\n              END ;\n              BEGIN FOR I:=1 TO 8 DO A(I):=TRUE ;\n                    FOR I:=2 TO 16 DO B(I):=TRUE ;\n                    FOR I:=-7  TO 7 DO C(I):=TRUE ;\n   WRITELN (CLOCK);\n   INTFIELDSIZE := 2;\n   TRYCOL (1);\n   INTFIELDSIZE := 12;\n   WRITELN (CLOCK)\nEND.\n// EXEC PASCAL\n//SYSIN    DD  *\nPROGRAM PALINDROMES(OUTPUT) ;\n    VAR I,J,L,N,R,S: INTEGER ;\n         P: BOOLEAN ;\n         D: ARRAY (.1..10.) OF INTEGER ;\nBEGIN N:=0 ;   WRITELN (CLOCK);\n    REPEAT N:=N+1 ; S:=N*N ; L:=0 ;\n         REPEAT L:=L+1 ; R:=S DIV 10 ;\n              D(.L.) := S - 10*R;  S := R\n         UNTIL S=0 ;\n         I:=1 ; J:=L ;\n         REPEAT\n            P := D(.I.) = D(.J.);\n            I := I + 1;  J := J - 1\n         UNTIL (I>=J) OR NOT P ;\n         IF P THEN\n            BEGIN\n               INTFIELDSIZE := 10;  WRITE (N);\n               INTFIELDSIZE := 50;  WRITELN (N*N)\n               END\n    UNTIL N= 10000 ;\n    INTFIELDSIZE := 12;\n    WRITELN (CLOCK)\nEND .\n// EXEC PASCAL\n//SYSIN  DD *\nPROGRAM COUNTCHARACTERS(INPUT,OUTPUT) ;\n    VAR CH: CHAR ;\n        C0,C1,C2,C3,C4: INTEGER ;   (* COUNTERS *)\nBEGIN\n    WRITELN (CLOCK);\n    C0:=0 ;C1:=0 ;C2:=0 ;C3:=0 ;C4:=0 ;\n    WHILE NOT EOF(INPUT) DO\n    BEGIN WRITE(' ') ; C0:=C0+1 ;\n        WHILE NOT EOLN(INPUT) DO\n        BEGIN READ(CH) ; WRITE(CH) ;\n              IF CH=' ' THEN C1:=C1+1 ELSE\n              IF CH IN (.'A'..'Z'.) THEN C2:=C2+1  ELSE\n              IF CH IN (.'0'..'9'.) THEN C3:=C3+1 ELSE C4:=C4+1\n        END ;\n        READLN ; WRITELN ;\n    END ;\n    WRITELN (CLOCK);\n    WRITELN(C0,' LINES') ;\n    WRITELN(C1,' BLANKS') ;\n    WRITELN(C2,' LETTERS') ;\n    WRITELN(C3,' DIGITS') ;\n    WRITELN(C4,' SPECIAL CHARACTERS') ;\nEND.\n%EOF\nPROGRAM     ANCESTOR(OUTPUT);\n (* R.W.FLOYD: 'ANCESTOR' , COMM.ACM 6-62 AND 3-63  ,ALG.96 *)\n  CONST N=50;\n  VAR I,J,K: INTEGER;\n      R: ARRAY (.1..N,1..N.) OF BOOLEAN ;\n     FOR I:=1 TO N DO\n        FOR J:=1 TO N DO R(I,J):=FALSE ;\n     FOR I:=1 TO N DO\n      IF I MOD 10 <>0 THEN R(I,I+1):=TRUE;\n    FOR I:=1 TO N DO\n       FOR J:=1 TO N DO\n          IF R(J,I) THEN\n             FOR K:=1 TO N DO\n                IF R(I,K) THEN R(J,K):=TRUE;\n       FOR I:=1 TO N DO\n        BEGIN WRITE(' ') ;\n          FOR J:=1 TO N DO WRITE(CHR(ORD(R(I,J))+ORD('0')));\n    WRITELN\n   END;\nEND.\n// EXEC PASCAL\n//SYSIN    DD *\nPROGRAM QUICKSORT   (OUTPUT);\n   CONST N = 1000;\n    VAR   I,Z: INTEGER ;\n         A: ARRAY(.1..N.) OF INTEGER ;\n\n    PROCEDURE  SORT(L,R: INTEGER) ;\n         VAR I,J,X,W: INTEGER ;\n         BEGIN (* QUICKSORT WITH RECURSION ON BOTH PARTITIONS *)\n            I := L ; J := R;  X := A(.(I+J) DIV 2.);\n\n            REPEAT\n               WHILE A(.I.) < X DO I := I + 1;\n               WHILE X < A(.J.) DO J := J - 1;\n               IF I <= J THEN\n                  BEGIN\n                     W := A(.I.);  A(.I.) := A(.J.);  A(.J.) := W;\n                     I := I + 1;  J := J - 1;\n                  END\n            UNTIL I > J;\n            IF L < J THEN SORT (L, J);\n            IF I < R THEN SORT (I, R)\n         END (* SORT *);\n\nBEGIN   Z:=1729 ;  (* GENERATE RANDOM SEQUENCE *)\n    FOR I:=1 TO N DO\n         BEGIN Z:=(131071*Z) MOD 2147483647 ; A(.I.) := Z\n         END ;\n    WRITELN (CLOCK);\n    SORT(1,N);\n    WRITELN (CLOCK)\nEND .\n// EXEC PASCAL\n//SYSIN    DD *\nPROGRAM KNUTH (INPUT, OUTPUT);\n\nTYPE\n  PTR = @TERM;\n  TERM = RECORD\n           COEF, ABC: INTEGER;\n           LINK: PTR\n         END;\n  POLY = @TERM;\nVAR\n  PP, QQ: PTR;\n  I: INTEGER;\n   T_VEC: ARRAY (.1..8.) OF INTEGER;\nPROCEDURE ADVANCE (VAR P: PTR);\nBEGIN\n  P := P@.LINK\nEND;\n\nPROCEDURE FREE_POLY (VAR P: PTR);\n\nVAR P1: PTR;\n\nBEGIN\n  ADVANCE (P);\n  WHILE P@.ABC >= 0 DO\n  BEGIN\n    P1 := P;\n    ADVANCE (P);\n    DISPOSE (P1)\n  END;\n  DISPOSE (P)\nEND;\nPROCEDURE ADDPOLY (VAR P, Q: PTR);\n\nVAR\n  Q1, Q2: PTR;\n\nBEGIN\n  (* STEP A1 *)\n  Q1 := Q;\n  ADVANCE (P);\n  ADVANCE (Q);\n  (* STEP A2 *)\n  REPEAT\n    IF P@.ABC < Q@.ABC THEN\n    BEGIN\n      Q1 := Q;\n      ADVANCE (Q)\n    END\n    ELSE IF P@.ABC = Q@.ABC THEN\n    BEGIN\n      (* STEP A3 *)\n      IF P@.ABC >= 0 THEN\n      BEGIN\n        Q@.COEF := Q@.COEF + P@.COEF;\n        IF Q@.COEF = 0 THEN\n        BEGIN\n          (* STEP A4 *)\n          Q2 := Q;\n          ADVANCE (Q);\n          Q1@.LINK := Q\n        END\n        ELSE\n        BEGIN\n          Q1 := Q;\n          ADVANCE (Q)\n        END;\n        ADVANCE (P)\n      END\n    END\n    ELSE BEGIN\n      NEW (Q2);\n      Q2@.COEF := P@.COEF;\n      Q2@.ABC := P@.ABC;\n      Q2@.LINK := Q;\n      Q1@.LINK := Q2;\n      Q1 := Q2;\n      ADVANCE (P)\n    END;\n  UNTIL (P@.ABC < 0) AND (Q@.ABC < 0)\nEND;\n\nPROCEDURE PRINTPOLY (VAR P: PTR);\n\nTYPE TEXTLINE = ARRAY (.1..132.) OF CHAR;\n\nVAR SUPERSCRIPTS, LINE: TEXTLINE;\n    INDEX, XS, YS, ZS: INTEGER;\n    COEFSIGNED, PRINT_ONE: BOOLEAN;\n\n  PROCEDURE NUM (NN: INTEGER; VAR DUMMY, ACTUAL: TEXTLINE;\n                 SIGNED, PRNT1: BOOLEAN);\n\n  VAR N, D, I, J: INTEGER;\n      VAL: ARRAY (.0..20.) OF CHAR;\n      MINUS: BOOLEAN;\n\n  BEGIN\n    N := NN;\n    I := -1;\n    IF N < 0 THEN\n    BEGIN\n      MINUS := TRUE;\n      N := -N\n    END\n    ELSE MINUS := FALSE;\n    IF PRNT1 OR (ABS (N) <> 1) THEN\n    REPEAT\n      I := I + 1;\n      D := N MOD 10;\n      N := N DIV 10;\n      VAL (.I.) := CHR (ORD ('0') + D)\n    UNTIL N = 0;\n    IF MINUS THEN\n    BEGIN\n      I := I + 1;\n      VAL (.I.) := '-'\n    END\n    ELSE IF SIGNED THEN\n    BEGIN\n      I := I + 1;\n      VAL (.I.) := '+'\n    END;\n    FOR J := 0 TO I DO\n    BEGIN\n      DUMMY (.INDEX + J.) := ' ';\n      ACTUAL (.INDEX + J.) := VAL (.I - J.)\n    END;\n    INDEX := INDEX + I + 1\n  END;\n\n  PROCEDURE DOIT (N: INTEGER; C: CHAR);\n  BEGIN\n    IF N > 0 THEN\n    BEGIN\n      LINE (.INDEX.) := C;\n      SUPERSCRIPTS (.INDEX.) := ' ';\n      INDEX := INDEX + 1;\n      NUM (N, LINE, SUPERSCRIPTS, FALSE, FALSE)\n    END\n  END;\n\nBEGIN\n  COEFSIGNED := FALSE;\n  FOR INDEX := 1 TO 132 DO\n  BEGIN\n    SUPERSCRIPTS (.INDEX.) := ' ';\n    LINE (.INDEX.) := ' '\n  END;\n  ADVANCE (P);\n  INDEX := 1;\n  WHILE P@.ABC >= 0 DO\n  BEGIN\n    WITH P@ DO\n    BEGIN\n      XS := ABC DIV 10000;\n      YS := (ABC DIV 100) MOD 100;\n      ZS := ABC MOD 100;\n      PRINT_ONE := (ABC = 0);\n      NUM (COEF, SUPERSCRIPTS, LINE, COEFSIGNED, PRINT_ONE);\n      COEFSIGNED := TRUE;\n      DOIT (XS, 'X');\n      DOIT (YS, 'Y');\n      DOIT (ZS, 'Z');\n    END;\n    ADVANCE (P)\n  END;\n  WRITELN;\n  WRITELN (SUPERSCRIPTS);\n  WRITELN (LINE)\nEND;\n\nFUNCTION READPOLY: PTR;\n\nVAR P, P1, START: PTR;\n    FIRST: BOOLEAN;\n\nBEGIN\n  FIRST := TRUE;\n  BEGIN\n    REPEAT\n      NEW (P);\n      READ (P@.COEF, P@.ABC);\n      IF FIRST THEN\n      BEGIN\n        FIRST := FALSE;\n        START := P\n      END\n      ELSE P1@.LINK := P;\n      P1 := P\n    UNTIL P@.ABC < 0;\n    P@.LINK := START;\n    READPOLY := P\n  END;\n  READLN\nEND;\n\n(* FINALLY - THE PROGRAM  *)\n\nBEGIN\n  WHILE NOT EOF(INPUT) DO\n  BEGIN\n    PP := READPOLY;\n    QQ := READPOLY;\n    PRINTPOLY (PP);\n    PRINTPOLY (QQ);\n    ADDPOLY (PP, QQ);\n    PRINTPOLY (QQ);\n    WRITELN\n  END\nEND.\n%EOF\n-1 30001 -5 302 2 301 1 100 1 2 1 1 0 -1\n3 30001 2 20101 1 20100 1 303 5 302 -1 301 5 1 3 0 0 -1\n1 101 1 100 1 1 0 -1\n1 100 2 1 0 -1\n1 10000 1 100 0 -1\n1 10000 -1 100 0 -1\n1 100 1 1 1 0 0 -1\n1 200 1 201 1 2 1 1 3 0 0 -1\n3 10203 2 10202 5 203 6 201 4 3 5 2 1 0 0 -1\n1 50002 3 40103 12 501 2 101 0 -1\n//       EXEC  PASCAL\n//SYSIN DD *\nPROGRAM PASSPROC (OUTPUT);\n\n   PROCEDURE P1 (PROCEDURE P2, P3);\n         BEGIN P2; P3 END;\n\n   FUNCTION SIMPSON (A, B: REAL; FUNCTION F (REAL): REAL): REAL;\n      VAR I, N: INTEGER; S, SS, S1, S2, S4, H: REAL;\n      (* F(X) IS A REAL-VALUED FUNCTION WITH A SINGLE REAL-VALUED\n         PARAMETER.  THE FUNCTION MUST BE WELL-DEFINED IN THE INTERVAL\n         A <= X <= B                                                   *)\n      BEGIN N := 2; H := (B-A)*0.5; S1 := H*(F(A) + F(B)); S2 := 0.0;\n         S4 := 4.0*H*F(A+H); S := S1 + S2 + S4;\n         REPEAT SS := S; N := 2*N; H := H/2.0;\n            S1 := 0.5*S1; S2 := 0.5*S2 + 0.25*S4; S4 := 0; I := 1;\n            REPEAT S4 := S4 + F(A+I*H); I := I + 2\n            UNTIL I > N;\n            S4 := 4*H*S4; S := S1 + S2 + S4\n         UNTIL ABS(S-SS) < 1.0E-5;\n         SIMPSON := S/3.0\n      END (* SIMPSON *) ;\n\n   PROCEDURE P2;\n      BEGIN WRITELN(SIMPSON(0,1,SIN)) END;\n\n   PROCEDURE P3;\n      BEGIN WRITELN(SIMPSON(0,1,COS)) END;\n\n PROCEDURE P5(PROCEDURE P2,P3);\n   BEGIN P1(P2, P3);   WRITELN(1.0);  END;\n   BEGIN P5(P2, P3) END.\n// EXEC PASCAL,SECONDS=30\n//SYSIN    DD *\nPROGRAM SOMA(OUTPUT);\n\n\n   (*************************************************************************\n   *                                                                        *\n   *               SOLUTIONS TO THE SOMA CUBE PROBLEM                       *\n   *                                                                        *\n   *                     A PASCAL PROGRAM                                   *\n   *                     BY RANCE DELONG                                    *\n   *                     MORAVIAN COLLEGE                                   *\n   *                                                                        *\n   *                     PUBLISHED IN ACM SIGPLAN NOTICES                   *\n   *                     VOL. 9 NO. 10 (OCTOBER 1974)                       *\n   *                                                                        *\n   *************************************************************************)\n\n\n\nTYPE\n   CUBE_SET = SET OF 1..27;\n   WHERE = (TOP, BOTTOM, RIGHT, LEFT, FRONT, BACK, NOWHERE);\n   PIECE_DESCRIPTION = ARRAY (.1..3.) OF WHERE;\n   AXES = (TBAXIS, RLAXIS, FBAXIS);\n   HASH_VALUE = 0..58;\n   PLIST_PTR = @ POSN_LIST_ELEMENT;\n   WHERE_SET = SET OF WHERE;\n   PIECE_RANGE = 1..7;\n   POSN_LIST_ELEMENT = RECORD\n                          PC_POSITION : CUBE_SET;\n                          NEXT_POSN : PLIST_PTR\n                       END;\n\nVAR\n   THE_CUBE : CUBE_SET;\n   PIECE : ARRAY (.1..7.) OF PIECE_DESCRIPTION;\n   MAJOR_ROTATIONS : ARRAY (.0..1.) OF AXES;\n   ROTATED : ARRAY (.AXES,WHERE.) OF WHERE;\n   SHIFT : ARRAY (.WHERE.) OF INTEGER;\n   HASH : ARRAY (.WHERE,1..2.) OF INTEGER;\n   POSN_LISTHEAD, SOLUTION_PTR : ARRAY (.1..7.) OF PLIST_PTR;\n   THOSE_CONSIDERED : SET OF HASH_VALUE;\n   P, I, SOLUTIONS : INTEGER;\n   NUMBER_USED : INTEGER;\n\n\n\nFUNCTION ORD1(S:WHERE_SET) : INTEGER;\n   VAR I,J : INTEGER;   W : WHERE;\n   BEGIN\n      I := 0; J := 1;\n      FOR W := TOP TO NOWHERE DO\n         BEGIN\n            IF W IN S THEN I := I + J;\n            J := 2*J\n         END;\n      ORD1 := I\n   END (**** ORD1 ****) ;\n\n\nPROCEDURE INITIALIZE;\n   BEGIN\n      PIECE(.1,1.) := RIGHT; PIECE(.1,2.) := FRONT; PIECE(.1,3.) := NOWHERE;\n      PIECE(.2,1.) := RIGHT; PIECE(.2,2.) := FRONT; PIECE(.2,3.) := FRONT;\n      PIECE(.3,1.) := RIGHT; PIECE(.3,2.) := FRONT; PIECE(.3,3.) := RIGHT;\n      PIECE(.4,1.) := RIGHT; PIECE(.4,2.) := FRONT; PIECE(.4,3.) := RIGHT;\n      PIECE(.5,1.) := RIGHT; PIECE(.5,2.) := TOP;   PIECE(.5,3.) := FRONT;\n      PIECE(.6,1.) := RIGHT; PIECE(.6,2.) := FRONT; PIECE(.6,3.) := TOP;\n      PIECE(.7,1.) := RIGHT; PIECE(.7,2.) := TOP;   PIECE(.7,3.) := FRONT;\n      MAJOR_ROTATIONS(.0.) := FBAXIS; MAJOR_ROTATIONS(.1.) := RLAXIS;\n      ROTATED(.TBAXIS,TOP.) := TOP; ROTATED(.TBAXIS,BOTTOM.) := BOTTOM;\n      ROTATED(.TBAXIS,RIGHT.) := BACK; ROTATED(.TBAXIS,LEFT.) := FRONT;\n      ROTATED(.TBAXIS,FRONT.) := RIGHT; ROTATED(.TBAXIS,BACK.) := LEFT;\n      ROTATED(.TBAXIS,NOWHERE.) := NOWHERE;\n      ROTATED(.RLAXIS,TOP.) := FRONT; ROTATED(.RLAXIS,BOTTOM.) := BACK;\n      ROTATED(.RLAXIS,RIGHT.) := RIGHT; ROTATED(.RLAXIS,LEFT.) := LEFT;\n      ROTATED(.RLAXIS,FRONT.) := BOTTOM; ROTATED(.RLAXIS,BACK.) := TOP;\n      ROTATED(.RLAXIS,NOWHERE.) := NOWHERE;\n      ROTATED(.FBAXIS,TOP.) := LEFT; ROTATED(.FBAXIS,BOTTOM.) := RIGHT;\n      ROTATED(.FBAXIS,RIGHT.) := TOP; ROTATED(.FBAXIS,LEFT.) := BOTTOM;\n      ROTATED(.FBAXIS,FRONT.) := FRONT; ROTATED(.FBAXIS,BACK.) := BACK;\n      ROTATED(.FBAXIS,NOWHERE.) := NOWHERE;\n      SHIFT(.TOP.) := 9; SHIFT(.BOTTOM.) := -9; SHIFT(.RIGHT.) := 1;\n      SHIFT(.LEFT.) := -1; SHIFT(.FRONT.) := 3; SHIFT(.BACK.) := -3;\n      SHIFT(.NOWHERE.) := 0;\n      HASH(.TOP,1.) := 1; HASH(.TOP,2.) := 6; HASH(.BOTTOM,1.) := -1;\n      HASH(.BOTTOM,2.) := -6; HASH(.RIGHT,1.) := 2; HASH(.RIGHT,2.) := 19;\n      HASH(.LEFT,1.) := -2; HASH(.LEFT,2.) := -19; HASH(.FRONT,1.) := 3;\n      HASH(.FRONT,2.) := 32; HASH(.BACK,1.) := -3; HASH(.BACK,2.) := -32;\n      HASH(.NOWHERE,1.) := 0; HASH(.NOWHERE,2.) := 0;\n      THE_CUBE := (..);\n      INTFIELDSIZE := 3;\n      NUMBER_USED := 0;\n      SOLUTIONS := 0\n   END (**** INITIALIZE ****) ;\n\n\nPROCEDURE RECORD_SOLUTION;\n   BEGIN\n      SOLUTIONS := SOLUTIONS + 1;\n      WRITELN(' SOLUTION ', SOLUTIONS);\n      IF (SOLUTIONS MOD 25) = 0 THEN\n         WRITELN('* * * * ELAPSED CPU TIME =', 10*CLOCK, ' MILLISECONDS.');\n      FOR (* PIECES *) P := 1 TO 7 DO\n         BEGIN\n            WRITE(P, '   ');\n            WITH SOLUTION_PTR(.P.)@ DO\n               FOR I := 1 TO 27 DO IF I IN PC_POSITION THEN WRITE(I);\n            WRITELN\n         END;\n      WRITELN\n   END (**** RECORD_SOLUTION ****) ;\n\n\nFUNCTION ORIENTATION(PIECE:PIECE_DESCRIPTION) : HASH_VALUE;\n   VAR PC : SET OF WHERE;\n   BEGIN   (* SYMMETRIC ORIENTATIONS RECEIVE SAME VALUE *)\n      IF P IN (.1,2,7.) THEN\n         IF ODD(ORD(PIECE(.1.))) THEN\n               PC := (.PRED(PIECE(.1.)),PIECE(.2.).)\n            ELSE PC := (.SUCC(PIECE(.1.)),PIECE(.2.).);\n      CASE P OF\n         1,2   : ORIENTATION := ORD1(PC) DIV 2\n                          + 32*ORD(ORD(PIECE(.1.)) > ORD(PIECE(.3.)));\n         3     : ORIENTATION := ABS(ABS(HASH(.PIECE(.1.),1.)\n                          + HASH(.PIECE(.3.),1.)) + HASH(.PIECE(.2.),2.));\n         4,5,6 : ORIENTATION := ABS(HASH(.PIECE(.1.),1.)\n                          + HASH(.PIECE(.2.),2.) + HASH(.PIECE(.3.),1.));\n         7     : ORIENTATION := ORD1(PC + (.PIECE(.3.).))\n      END\n   END (**** ORIENTATION ****) ;\n\n\nPROCEDURE ROTATE(VAR PIECE : PIECE_DESCRIPTION; AXIS : AXES);\n   BEGIN\n      FOR I := 1 TO 3 DO\n         PIECE(.I.) := ROTATED(.AXIS,PIECE(.I.).)\n   END (**** ROTATE ****) ;\n\n\nPROCEDURE GENERATE_TRANSLATIONS(PIECE : PIECE_DESCRIPTION;\n                                ORIENTATION : HASH_VALUE);\n   VAR RLDISP, FBDISP, DISP, J : INTEGER;\n       SIZE, PART : ARRAY (.0..3.) OF INTEGER;\n       CUBICLE : 1..27;\n   BEGIN RLDISP := 1; FBDISP := 3; PART(.0.) := 1;\n      FOR I := 0 TO 3 DO SIZE(.I.) := 3;\n      THOSE_CONSIDERED := THOSE_CONSIDERED + (.ORIENTATION.);\n      FOR I := 1 TO 3 DO\n         BEGIN\n            PART(.0.) := PART(.0.) + ORD(PIECE(.I.)) MOD 2\n                        * (-SHIFT(.PIECE(.I.).));\n            SIZE(.ORD(PIECE(.I.)) DIV 2.) := SIZE(.ORD(PIECE(.I.)) DIV 2.) - 1;\n         END;\n      IF (* PIECE *) P IN (.3,7.) THEN\n         FOR I := 1 TO 3 DO\n            PART(.I.) := PART(.I DIV 2.) + SHIFT(.PIECE(.I.).)\n      ELSE\n         FOR I := 1 TO 3 DO\n            PART(.I.) := PART(.I-1.) + SHIFT(.PIECE(.I.).);\n      FOR I := 1 TO SIZE(.0.)*SIZE(.1.)*SIZE(.2.) DO\n         BEGIN\n            WITH SOLUTION_PTR(.P.)@ DO (* ADD POSITION TO LIST *)\n               BEGIN\n                  PC_POSITION := (..);\n                  FOR J := 0 TO 3 DO\n                     BEGIN\n                        CUBICLE := PART(.J.);\n                        PC_POSITION := PC_POSITION + (.CUBICLE.)\n                     END;\n                  NEW(NEXT_POSN);\n                  SOLUTION_PTR(.P.) := NEXT_POSN;\n                  NEXT_POSN@.NEXT_POSN := NIL\n               END;\n            IF I MOD SIZE(.1.) = 0 THEN (* SHIFT TO NEW POSITION *)\n               BEGIN (* FORWARD, BACKWARD OR UPWARD MOVEMENT *)\n                  RLDISP := -RLDISP;\n                  IF I MOD (SIZE(.1.)*SIZE(.2.)) = 0 THEN\n                     BEGIN\n                        FBDISP := -FBDISP;\n                        DISP := 9;\n                     END\n                  ELSE DISP := FBDISP\n               END\n            ELSE DISP := RLDISP  (* RIGHT OR LEFT *) ;\n           FOR J := 0 TO 3 DO PART(.J.) := PART(.J.) + DISP\n         END\n   END (**** GENERATE_TRANSLATIONS ****) ;\n\n\nPROCEDURE GENERATE_PIECE_POSITIONS;\n   VAR M, MINOR_ROTATIONS : INTEGER; THIS_ORIENTATION : HASH_VALUE;\n   BEGIN\n      FOR (* PIECES *) P := 1 TO 7 DO\n         BEGIN\n            THOSE_CONSIDERED := (..);\n            NEW(POSN_LISTHEAD(.P.)); SOLUTION_PTR(.P.) := POSN_LISTHEAD(.P.);\n            FOR (* MAJOR_ROTATIONS *) M := 1 TO 6 DO\n               BEGIN\n                  FOR MINOR_ROTATIONS := 1 TO 4 DO\n                     BEGIN\n                        THIS_ORIENTATION := ORIENTATION(PIECE(.P.));\n                        IF NOT(THIS_ORIENTATION IN THOSE_CONSIDERED) THEN\n                           GENERATE_TRANSLATIONS(PIECE(.P.),THIS_ORIENTATION)\n                        ELSE\n                           REPEAT\n                              ROTATE(PIECE(.P.),TBAXIS);\n                              MINOR_ROTATIONS := MINOR_ROTATIONS + 1\n                           UNTIL MINOR_ROTATIONS > 3;\n                        ROTATE(PIECE(.P.),TBAXIS);\n                     END;\n                  ROTATE(PIECE(.P.),MAJOR_ROTATIONS(.M MOD 3 DIV 2.))\n               END\n         END;\n      POSN_LISTHEAD(.2.)@.NEXT_POSN@.NEXT_POSN@.NEXT_POSN := NIL\n   END (**** GENERATE_PIECE_POSITIONS ****) ;\n\n\nPROCEDURE GENERATE_SOLUTIONS(PC_NUM : PIECE_RANGE);\n   BEGIN\n      NUMBER_USED := NUMBER_USED + 1;\n      SOLUTION_PTR(.PC_NUM.) := POSN_LISTHEAD(.PC_NUM.);\n      WHILE SOLUTION_PTR(.PC_NUM.)@.NEXT_POSN <> NIL DO\n         WITH SOLUTION_PTR(.PC_NUM.)@ DO\n         BEGIN\n            IF THE_CUBE * PC_POSITION = (..) THEN\n               BEGIN\n                  THE_CUBE := THE_CUBE + PC_POSITION;\n                  IF NUMBER_USED = 7 THEN RECORD_SOLUTION\n                     ELSE GENERATE_SOLUTIONS(PC_NUM MOD 7 + 1);\n                  THE_CUBE := THE_CUBE - PC_POSITION\n               END;\n            SOLUTION_PTR(.PC_NUM.) := NEXT_POSN\n         END;\n      NUMBER_USED := NUMBER_USED - 1\n   END (**** GENERATE_SOLUTIONS ****) ;\n\n\nBEGIN\n   INITIALIZE;\n   GENERATE_PIECE_POSITIONS;\n   GENERATE_SOLUTIONS(2)\nEND (**** SOMA ****) .\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE14": {"ttr": 11273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x06\\\\\\x06\\\\\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 1628, "newlines": 1628, "modlines": 0, "user": "SPASCAL"}, "text": "XMON     TITLE 'XPLSM SUBMONITOR FOR THE XPL COMPILER SYSTEM'           XMN00000\n         SPACE 2                                                        XMN00010\n*********************************************************************** XMN00020\n*                                                                     * XMN00030\n*                                                                     * XMN00040\n*                                                                     * XMN00050\n*        XPLSM    SUBMONITOR FOR THE XPL COMPILER GENERATOR SYSTEM    * XMN00060\n*                                                                     * XMN00070\n*                                                                     * XMN00080\n*                                  DAVID B. WORTMAN                   * XMN00090\n*                                  STANFORD UNIVERSITY                * XMN00100\n*                                  MARCH  1969                        * XMN00110\n*                                                                     * XMN00120\n*                                                                     * XMN00130\n*********************************************************************** XMN00140\n         EJECT                                                          XMN00150\n         SPACE 1                                                        XMN00160\n*********************************************************************** XMN00170\n*                                                                     * XMN00180\n*                                                                     * XMN00190\n*                                                                     * XMN00200\n*        DEFINE PARAMETRIC CONSTANTS FOR XPLSM                        * XMN00210\n*                                                                     * XMN00220\n*                                                                     * XMN00230\n*********************************************************************** XMN00240\n         SPACE 1                                                        XMN00250\n         GBLA  &INPUTS             NUMBER OF INPUT FILES                XMN00260\n         GBLA  &OUTPUTS            NUMBER OF OUTPUT FILES               XMN00270\n         GBLA  &FILES              NUMBER OF DIRECT ACCESS FILES        XMN00280\n         LCLA  &I                  VARIABLE FOR ITERATION LOOPS         XMN00290\n         SPACE 5                                                        XMN00300\nIOPACK   CSECT                                                          XMN00310\n         SPACE 2                                                        XMN00320\n&INPUTS  SETA  3                   INPUT(I),   I = 0,1,2,3              XMN00330\n         SPACE 1                                                        XMN00340\n&OUTPUTS SETA  3                   OUTPUT(I),  I = 0,1,2,3              XMN00350\n         SPACE 1                                                        XMN00360\n&FILES   SETA  3                   FILE(I,*),  I = 1,2,3                XMN00370\n         SPACE 1                                                        XMN00380\n*********************************************************************** XMN00390\n*                                                                     * XMN00400\n*                                                                     * XMN00410\n*        FILEBYTS DETERMINES THE BLOCKSIZE FOR DIRECT ACCESS FILE     * XMN00420\n*        I/O.  IT SHOULD BE EQUAL TO THE VALUE OF THE LITERAL         * XMN00430\n*        CONSTANT 'DISKBYTES' IN THE XCOM COMPILER FOR COMPILATION    * XMN00440\n*        TO WORK SUCCESSFULLY.  THE VALUE OF FILEBYTS WHICH IS        * XMN00450\n*        ASSEMBLED IN MAY BE OVERIDDEN BY THE 'FILE=NNNN' PARAMETER   * XMN00460\n*        ON THE OS/360 EXEC CARD.                                     * XMN00470\n*                                                                     * XMN00480\n*                                                                     * XMN00490\n*                                                                     * XMN00500\n*        DEVICE       ALLOWABLE RANGE         SUGGESTED VALUE         * XMN00510\n*                                                                     * XMN00520\n*        2311      80 <= FILEBYTS <= 3624        3600                 * XMN00530\n*                                                                     * XMN00540\n*        2314      80 <= FILEBYTS <= 7294        7200                 * XMN00550\n*                                                                     * XMN00560\n*        2321      80 <= FILEBYTS <= 2000        2000                 * XMN00570\n*                                                                     * XMN00580\n*                                                                     * XMN00590\n*        LARGER VALUES MAY BE USED FOR FILEBYTS IF THE SUBMONITOR     * XMN00600\n*        IS REASSEMBLED WITH  RECFM=FT  SPECIFIED IN THE DCBS FOR     * XMN00610\n*        THE DIRECT ACCESS FILES.                                     * XMN00620\n*                                                                     * XMN00630\n*                                                                     * XMN00640\n*********************************************************************** XMN00650\n         SPACE 2                                                        XMN00660\nFILEBYTS EQU   7200                2314  DISKS                          BARABASH\n         SPACE 2                                                        XMN00680\n*********************************************************************** XMN00690\n*                                                                     * XMN00700\n*                                                                     * XMN00710\n*        BLKSIZE DEFAULT FOR SOME INPUT AND OUTPUT FILES.  SEE THE    * XMN00720\n*        EXIT LIST HANDLING ROUTINE GENXT.  SHOULD BE THE LARGEST     * XMN00730\n*        MULTIPLE OF 80 THAT IS LESS THAN OR EQUAL TO FILEBYTS        * XMN00740\n*                                                                     * XMN00750\n*********************************************************************** XMN00760\n         SPACE 2                                                        XMN00770\nIOFBYTS  EQU   80*(FILEBYTS/80)                                         XMN00780\n         SPACE 2                                                        XMN00790\n*********************************************************************** XMN00800\n*                                                                     * XMN00810\n*                                                                     * XMN00820\n*        DEFINE THE REGISTERS USED TO PASS PARAMETERS TO THE          * XMN00830\n*        SUBMONITOR FROM THE XPL PROGRAM                              * XMN00840\n*                                                                     * XMN00850\n*                                                                     * XMN00860\n*********************************************************************** XMN00870\n         SPACE 2                                                        XMN00880\nSVCODE   EQU   1                   CODE INDICATING SERVICE REQUESTED    XMN00890\n         SPACE 1                                                        XMN00900\nPARM1    EQU   0                   FIRST PARAMETER                      XMN00910\n         SPACE 1                                                        XMN00920\nPARM2    EQU   2                   SECOND PARAMETER                     XMN00930\n         SPACE 2                                                        XMN00940\n*********************************************************************** XMN00950\n*                                                                     * XMN00960\n*                                                                     * XMN00970\n*        DEFINE THE SERVICE CODES USED BY THE XPL PROGRAM TO          * XMN00980\n*        INDICATE SERVICE REQUESTS TO THE SUBMONITOR                  * XMN00990\n*                                                                     * XMN01000\n*                                                                     * XMN01010\n*********************************************************************** XMN01020\n         SPACE 3                                                        XMN01030\nGETC     EQU   4                   SEQUENTIAL INPUT                     XMN01040\n         SPACE 1                                                        XMN01050\nPUTC     EQU   8                   SEQUENTIAL OUTPUT                    XMN01060\n         SPACE 1                                                        XMN01070\nTRC      EQU   12                  INITIATE TRACING  (NOP IN XPLSM)     XMN01080\n         SPACE 1                                                        XMN01090\nUNTR     EQU   16                  TERMINATE TRACING (NOP IN XPLSM)     XMN01100\n         SPACE 1                                                        XMN01110\nEXDMP    EQU   20                  FORCE A CORE DUMP                    XMN01120\n         SPACE 1                                                        XMN01130\nGTIME    EQU   24                  RETURN TIME AND DATE                 XMN01140\n         SPACE 1                                                        XMN01150\nRSVD1    EQU   28                  (UNUSED)                             XMN01160\n         SPACE 1                                                        XMN01170\nRSVD2    EQU   32                  CLOCK_TRAP        (NOP IN XPLSM)     XMN01180\n         SPACE 1                                                        XMN01190\nRSVD3    EQU   36                  INTERRUPT_TRAP    (NOP IN XPLSM)     XMN01200\n         SPACE 1                                                        XMN01210\nRSVD4    EQU   40                  MONITOR           (NOP IN XPLSM)     XMN01220\n         SPACE 1                                                        XMN01230\nRSVD5    EQU   44                  (UNUSED)                             XMN01240\n         SPACE 1                                                        XMN01250\nRSVD6    EQU   48                  (UNUSED)                             XMN01260\n         SPACE 1                                                        XMN01270\n         SPACE 2                                                        XMN01280\n*********************************************************************** XMN01290\n*                                                                     * XMN01300\n*        GENERATE THE SERVICE CODES FOR DIRECT ACCESS FILE I/O        * XMN01310\n*        BASED ON THE NUMBER OF FILES AVAILABLE  (&FILES)             * XMN01320\n*                                                                     * XMN01330\n*********************************************************************** XMN01340\n         SPACE 2                                                        XMN01350\nFILEORG  EQU   RSVD6+4             ORIGIN FOR THE FILE SERVICE CODES    XMN01360\n         SPACE 1                                                        XMN01370\n&I       SETA  1                                                        XMN01380\n.SC1     AIF   (&I GT &FILES).SC2                                       XMN01390\nRD&I     EQU   FILEORG+8*(&I-1)    CODE FOR READING FILE&I              XMN01400\nWRT&I    EQU   FILEORG+8*(&I-1)+4  CODE FOR WRITING FILE&I              XMN01410\n&I       SETA  &I+1                                                     XMN01420\n         AGO   .SC1                                                     XMN01430\n.SC2     ANOP                                                           XMN01440\n         SPACE 2                                                        XMN01450\nENDSERV  EQU   FILEORG+8*(&I-1)    1ST UNUSED SERVICE CODE              XMN01460\n         SPACE 2                                                        XMN01470\n*********************************************************************** XMN01480\n*                                                                     * XMN01490\n*                                                                     * XMN01500\n*        DEFINE REGISTER USAGE                                        * XMN01510\n*                                                                     * XMN01520\n*********************************************************************** XMN01530\n         SPACE 2                                                        XMN01540\nRTN      EQU   3                   REGISTER CONTAINING COMPLETION       XMN01550\n*                                  CODE RETURNED BY THE PROGRAM         XMN01560\n         SPACE 1                                                        XMN01570\nEBR      EQU   10                  BASE REGISTER USED DURING            XMN01580\n*                                  INITIALIZATION                       XMN01590\n         SPACE 1                                                        XMN01600\nCBR      EQU   12                  LINKAGE REGISTER USED FOR CALLS      XMN01610\n*                                  TO THE SUBMONITOR                    XMN01620\n         SPACE 1                                                        XMN01630\nSELF     EQU   15                  REGISTER THAT ALWAYS CONTAINS        XMN01640\n*                                  THE ADDRESS OF THE SUBMONITOR        XMN01650\n*                                  ENTRY POINT                          XMN01660\n         SPACE 1                                                        XMN01670\n*********************************************************************** XMN01680\n*                                                                     * XMN01690\n*        BIT CONSTANTS NEEDED FOR CONVERSING WITH OS/360 DCBS         * XMN01700\n*                                                                     * XMN01710\n*********************************************************************** XMN01720\n         SPACE 2                                                        XMN01730\nOPENBIT  EQU   B'00010000'         DCBOFLGS BIT INDICATING OPEN         XMN01740\n*                                  SUCCESSFULLY COMPLETED               XMN01750\n         SPACE 1                                                        XMN01760\nTAPEBITS EQU   B'10000001'         BITS INDICATING A MAGNETIC TAPE      XMN01770\n         SPACE 1                                                        XMN01780\nKEYLBIT  EQU   B'00000001'         BIT IN RECFM THAT INDICATES          XMN01790\n*                                  KEYLEN WAS SET EXPLICITELY ZERO      XMN01800\n         SPACE 2                                                        XMN01810\n*********************************************************************** XMN01820\n*                                                                     * XMN01830\n*        FLAG BITS USED TO CONTROL SUBMONITOR OPERATION               * XMN01840\n*                                                                     * XMN01850\n*********************************************************************** XMN01860\n         SPACE 2                                                        XMN01870\nALLBITS  EQU   B'11111111'         MASK                                 XMN01880\n         SPACE 1                                                        XMN01890\nTRACEBIT EQU   B'10000000'         BEGIN EXECUTION OF THE PROGRAM       XMN01900\n*                                  IN TRACE MODE                        XMN01910\n         SPACE 1                                                        XMN01920\nSFILLBIT EQU   B'01000000'         1 CHARACTER OF FILL NEEDED BY        XMN01930\n*                                  THE PUT ROUTINE                      XMN01940\n         SPACE 1                                                        XMN01950\nLFILLBIT EQU   B'00100000'         LONGER FILL NEEDED BY PUT ROUTINE    XMN01960\n         SPACE 1                                                        XMN01970\nDUMPBIT  EQU   B'00001000'         GIVE A CORE DUMP FOR I/O ERRORS      XMN01980\n         SPACE 2                                                        XMN01990\n*********************************************************************** XMN02000\n*                                                                     * XMN02010\n*                                                                     * XMN02020\n*              DEFINE ABEND CODES ISSUED BY THE SUBMONITOR            * XMN02030\n*                                                                     * XMN02040\n*********************************************************************** XMN02050\n         SPACE 2                                                        XMN02060\nOPENABE  EQU   100                 UNABLE TO OPEN ONE OF THE FILES:     XMN02070\n*                                  PROGRAM, SYSIN, OR SYSPRINT          XMN02080\n         SPACE 1                                                        XMN02090\nPGMEOD   EQU   200                 UNEXPECTED END OF FILE WHILE         XMN02100\n*                                  READING IN THE XPL PROGRAM           XMN02110\n         SPACE 1                                                        XMN02120\nPGMERR   EQU   300                 SYNAD ERROR WHILE READING IN         XMN02130\n*                                  THE XPL PROGRAM                      XMN02140\n         SPACE 1                                                        XMN02150\nCOREABE  EQU   400                 XPL PROGRAM WON'T FIT IN             XMN02160\n*                                  THE AMOUNT OF MEMORY AVAILABLE       XMN02170\n         SPACE 1                                                        XMN02180\nCODEABE  EQU   500                 INVALID SERVICE CODE FROM THE        XMN02190\n*                                  XPL PROGRAM                          XMN02200\n         SPACE 1                                                        XMN02210\nOUTSYND  EQU   800                 SYNAD ERROR ON OUTPUT FILE           XMN02220\n         SPACE 1                                                        XMN02230\nPFABE    EQU   900                 INVALID OUTPUT FILE SPECIFIED        XMN02240\n         SPACE 1                                                        XMN02250\nINSYND   EQU   1000                SYNAD ERROR ON INPUT FILE            XMN02260\n         SPACE 1                                                        XMN02270\nINEODAB  EQU   1200                END OF FILE ERROR ON INPUT FILE      XMN02280\n         SPACE 1                                                        XMN02290\nGFABE    EQU   1400                INVALID INPUT FILE SPECIFIED         XMN02300\n         SPACE 1                                                        XMN02310\nFLSYND   EQU   2000                SYNAD ERROR ON DIRECT ACCESS FILE    XMN02320\n         SPACE 1                                                        XMN02330\nFLEOD    EQU   2200                END OF FILE ERROR ON DIRECT          XMN02340\n*                                  ACCESS FILE                          XMN02350\n         SPACE 1                                                        XMN02360\nUSERABE  EQU   4000                XPL PROGRAM CALLED EXIT TO           XMN02370\n*                                  FORCE A CORE DUMP                    XMN02380\n         EJECT                                                          XMN02390\n         SPACE 5                                                        XMN02400\n*********************************************************************** XMN02410\n*                                                                     * XMN02420\n*                                                                     * XMN02430\n*                                                                     * XMN02440\n*        SUBMONITOR  INITIALIZATION                                   * XMN02450\n*                                                                     * XMN02460\n*                                                                     * XMN02470\n*********************************************************************** XMN02480\n         SPACE 3                                                        XMN02490\n         ENTRY XPLSM               WHERE OS ENTERS THE SUBMONITOR       XMN02500\n         SPACE 2                                                        XMN02510\n         DS    0F                                                       XMN02520\n         USING *,15                                                     XMN02530\n         SPACE 1                                                        XMN02540\nXPLSM    SAVE  (14,12),T,*         SAVE ALL REGISTERS                   XMN02550\n         ST    13,SAVE+4           SAVE RETURN POINTER                  XMN02560\n         LA    15,SAVE             ADDRESS OF SUBMONITOR'S OS SAVE AREA XMN02570\n         ST    15,8(0,13)                                               XMN02580\n         LR    13,15                                                    XMN02590\n         USING SAVE,13                                                  XMN02600\n         BALR  EBR,0               BASE ADDRESS FOR INITIALIZATION      XMN02610\n         USING *,EBR                                                    XMN02620\nBASE1    DS    0H                                                       XMN02630\n         DROP  15                                                       XMN02640\n         L     1,0(,1)             ADDRESS OF A POINTER TO THE PARM     XMN02650\n*                                  FIELD OF THE OS EXEC CARD            XMN02660\n         MVI   FLAGS,B'00000000'   RESET ALL FLAGS                      XMN02680\n         LH    4,0(,1)             LENGTH OF THE PARM FIELD             XMN02690\n         LA    1,2(,1)             ADDRESS OF THE PARM STRING           XMN02700\n         LA    4,0(1,4)            ADDRESS OF END OF PARAMETER LIST     XMN02710\n         LA    7,PARMSCAN                                               XMN02720\n         SPACE 2                                                        XMN02730\nPARMSCAN DS    0H                                                       XMN02740\n         CR    1,4                 ARE WE DONE ?                        XMN02750\n         BNL   NOPARMS             YES, SO QUIT LOOKING                 XMN02760\n         CLC   TRCM,0(1)           LOOK FOR 'TRACE'                     XMN02770\n         BNE   PS2                 NOT FOUND                            XMN02780\n         OI    FLAGS,TRACEBIT      SET FLAG TO BEGIN IN TRACE MODE      XMN02790\n         LA    1,L'TRCM+1(,1)      INCREMENT POINTER                    XMN02800\n         BR    7                   BRANCH BACK TO TEST                  XMN02810\nPS2      CLC   ALTRM,0(1)          TEST FOR 'ALTER'                     XMN02820\n         BNE   PS3                 NOT FOUND                            XMN02830\n         MVC   FREEUP,ALTFREE      MAKE MORE ROOM FOR ALTER             XMN02840\n         LA    1,L'ALTRM+1(,1)     INCREMENT POINTER                    XMN02850\n         BR    7                   BRANCH BACK TO TEST                  XMN02860\nPS3      CLC   CMNM,0(1)           LOOK FOR 'MIN=NNNN'                  XMN02870\n         BNE   PS4                 NOT FOUND                            XMN02880\n         BAL   CBR,DIGET           GO GET THE NUMBER                    XMN02890\n         ST    3,COREMIN           SET NEW MINIMUM VALUE                XMN02900\n         BR    7                   BRANCH TO TEST                       XMN02910\nPS4      CLC   CMXM,0(1)           CHECK FOR 'MAX=MMMM'                 XMN02920\n         BNE   PS5                 NOT FOUND                            XMN02930\n         BAL   CBR,DIGET           GO GET THE VALUE                     XMN02940\n         ST    3,COREMAX           SET NEW MAXIMUM VALUE                XMN02950\n         BR    7                   BRANCH TO TEST                       XMN02960\nPS5      CLC   FREEM,0(1)          CHECK FOR 'FREE=NNNN'                XMN02970\n         BNE   PS6                 NOT FOUND                            XMN02980\n         BAL   CBR,DIGET           GO GET THE VALUE                     XMN02990\n         ST    3,FREEUP            SET NEW AMOUNT FREED                 XMN03000\n         BR    7                   BRANCH TO TEST                       XMN03010\nPS6      CLC   DMPM,0(1)           CHECK FOR 'DUMP'                     XMN03020\n         BNE   PS7                 NOT FOUND                            XMN03030\n         OI    FLAGS,DUMPBIT       SET DUMP ON ERROR FLAG               XMN03040\n         LA    1,L'DMPM+1(,1)      INCREMENT POINTER                    XMN03050\n         BR    7                   BRANCH TO TEST                       XMN03060\nPS7      CLC   FILEM,0(1)          CHECK FOR 'FILE=MMMM'                XMN03070\n         BNE   PSBUMP              NOT FOUND                            XMN03080\n         BAL   CBR,DIGET           GET THE BLKSIZE VALUE                XMN03090\n         LA    2,&FILES*2          NUMBER OF DCB FOR FILES              XMN03100\n         LA    5,ARWDCBS           ADDRESS OF DCB LIST                  XMN03110\nFLOOP    L     6,0(,5)             ADDRESS OF A DCB                     XMN03120\n         USING IHADCB,6                                                 XMN03130\n         STH   3,DCBLRECL          SET NEW RECORD LENGTH                XMN03140\n         STH   3,DCBBLKSI          SET NEW BLOCKSIZE                    XMN03150\n         DROP  6                                                        XMN03160\n         LA    5,4(,5)             INCREMENT ADDRESS                    XMN03170\n         BCT   2,FLOOP             LOOP BACK                            XMN03180\n         SLL   3,2                 (NEW BLOCKSIZE)*4                    XMN03190\n         ST    3,ALTFREE           ALTER PARAMETER                      XMN03200\n         BR    7                   GO TO SCAN LOOP                      XMN03210\nPSBUMP   LA    1,1(,1)             INCREMENT POINTER TO PARM STRING     XMN03220\n         BR    7                   BRANCH TO TEST                       XMN03230\nNOPARMS  DS    0H                                                       XMN03240\n         SPACE 2                                                        XMN03250\n*********************************************************************** XMN03260\n*                                                                     * XMN03270\n*                                                                     * XMN03280\n*        OPEN THE FILES  PROGRAM, SYSIN, AND SYSPRINT                 * XMN03290\n*                                                                     * XMN03300\n*********************************************************************** XMN03310\n         SPACE 2                                                        XMN03320\n         OPEN  (INPUT0,(INPUT),OUTPUT0,(OUTPUT),PROGRAM,(INPUT))        XMN03330\n         SPACE 1                                                        XMN03340\n         L     3,GETDCBS           ADDRESS OF DCB FOR INPUT0            XMN03350\n         USING IHADCB,3                                                 XMN03360\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING         XMN03370\n         BZ    BADOPEN             INPUT0 NOT OPENED SUCCESSFULLY       XMN03380\n         L     3,PUTDCBS           ADDRESS OF DCB FOR OUTPUT0           XMN03390\n         TM    DCBOFLGS,OPENBIT    CHECK FOR SUCCESSFUL OPENING         XMN03400\n         BZ    BADOPEN             OUTPUT0 NOT OPENED SUCCESSFULLY      XMN03410\n         L     3,PGMDCB            ADDRESS OF DCB FOR PROGRAM           XMN03420\n         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPENING          XMN03430\n         BNZ   OPENOK              PROGRAM SUCCESSFULLY OPENED          XMN03440\n         DROP  3                                                        XMN03450\n         SPACE 2                                                        XMN03460\nBADOPEN  LA    1,OPENABE           ABEND BECAUSE FILES DIDN'T OPEN      XMN03470\n*                                  PROPERLY                             XMN03480\n         B     ABEND               GO TO ABEND ROUTINE                  XMN03490\n         SPACE 2                                                        XMN03500\nOPENOK   DS    0H                                                       XMN03510\n         SPACE 2                                                        XMN03520\n*********************************************************************** XMN03530\n*                                                                     * XMN03540\n*                                                                     * XMN03550\n*        NOW OBTAIN SPACE IN MEMORY FOR THE XPL PROGRAM AND ITS       * XMN03560\n*        FREE STRING AREA.  A GETMAIN IS ISSUED TO OBTAIN AS MUCH     * XMN03570\n*        MEMORY AS POSSIBLE WITHIN THE PARTITION.  THEN A FREEMAIN    * XMN03580\n*        IS ISSUED TO RETURN THE AMOUNT OF MEMORY SPECIFIED BY        * XMN03590\n*        THE VARIABLE 'FREEUP' TO OS/360 FOR USE AS WORK SPACE.       * XMN03600\n*        OS/360 NEEDS SPACE FOR FOR DYNAMICALLY CREATING BUFFERS      * XMN03610\n*        FOR THE SEQUENTIAL INPUT AND OUTPUT FILES AND FOR            * XMN03620\n*        OVERLAYING I/O ROUTINES.                                     * XMN03630\n*                                                                     * XMN03640\n*           THE AMOUNT OF CORE REQUESTED FROM OS/360 CAN BE ALTERED   * XMN03650\n*        WITH THE 'MAX=NNNN' AND 'MIN=MMMM' PARAMETERS TO THE         * XMN03660\n*        SUBMONITOR.  THE AMOUNT OF CORE RETURNED TO OS/360 CAN BE    * XMN03670\n*        ALTERED WITH THE 'FREE=NNNN' OR THE 'ALTER' PARAMETER        * XMN03680\n*                                                                     * XMN03690\n*                                                                     * XMN03700\n*        MEMORY REQUEST IS DEFINED BY THE CONTROL BLOCK STARTING AT   * XMN03710\n*        'COREREQ'.  THE DESCRIPTION OF THE MEMORY SPACE OBTAINED     * XMN03720\n*        IS PUT INTO THE CONTROL BLOCK STARTING AT 'ACORE'.           * XMN03730\n*                                                                     * XMN03740\n*                                                                     * XMN03750\n*********************************************************************** XMN03760\n         SPACE 2                                                        XMN03770\n         GETMAIN VU,LA=COREREQ,A=ACORE                                  XMN03780\n         SPACE 1                                                        XMN03790\n         LM    1,2,ACORE           ADDRESS OF CORE OBTAINED TO R1       XMN03800\n*                                  LENGTH OF CORE AREA TO R2            XMN03810\n         AR    1,2                 ADDRESS OF TOP OF CORE AREA          XMN03820\n         S     1,FREEUP            LESS AMOUNT TO BE RETURNED           XMN03830\n         ST    1,CORETOP           ADDRESS OF TOP OF USABLE CORE        XMN03840\n*                                  (BECOMES 'FREELIMIT')                XMN03850\n         S     2,FREEUP            SUBTRACT AMOUNT RETURNED             XMN03860\n         ST    2,CORESIZE          SIZE OF AVAILABLE SPACE              XMN03870\n         L     0,FREEUP            AMOUNT TO GIVE BACK                  XMN03880\n         SPACE 1                                                        XMN03890\n         FREEMAIN R,LV=(0),A=(1)   GIVE 'FREEUP' BYTES OF CORE BACK     XMN03900\n         SPACE 2                                                        XMN03910\n*********************************************************************** XMN03920\n*                                                                     * XMN03930\n*                                                                     * XMN03940\n*        READ IN THE BINARY XPL PROGRAM AS SPECIFIED BY THE           * XMN03950\n*                                                                     * XMN03960\n*        //PROGRAM  DD  .....                                         * XMN03970\n*                                                                     * XMN03980\n*        CARD.  IT IS ASSUMED THAT THE BINARY PROGRAM IS IN STANDARD  * XMN03990\n*        XPL SYSTEM FORMAT.                                           * XMN04000\n*                                                                     * XMN04010\n*                                                                     * XMN04020\n*        THE 1ST RECORD OF THE BINARY PROGRAM FILE SHOULD BEGIN       * XMN04030\n*        WITH A BLOCK OF INFORMATION DESCRIBING THE CONTENTS OF       * XMN04040\n*        THE FILE.  THE FORMAT OF THIS BLOCK IS GIVEN IN THE DSECT    * XMN04050\n*        'FILECTRL' AT THE END OF THIS ASSEMBLY.                      * XMN04060\n*                                                                     * XMN04070\n*                                                                     * XMN04080\n*********************************************************************** XMN04090\n         SPACE 2                                                        XMN04100\n         L     2,ACORE             ADDRESS OF START OF CORE AREA        XMN04110\n         LR    4,2                 SAVE STARTING ADDRESS                XMN04120\n         USING FILECTRL,4          ADDRESS OF CONTROL BLOCK             XMN04130\n         ST    2,CODEADR           SAVE STARTING ADDRESS FOR USE        XMN04140\n*                                  BY THE XPL PROGRAM                   XMN04150\n         BAL   CBR,READPGM         READ IN 1ST RECORD                   XMN04160\n         L     3,BYTSCODE          NUMBER OF BYTES OF CODE              XMN04170\n         S     3,BYTSBLK           LESS ONE RECORD                      XMN04180\n         A     3,BYTSFULL          PLUS AMOUNT IN LAST CODE RECORD      XMN04190\n         A     3,BYTSDATA          PLUS SIZE OF DATA AREA               XMN04200\n         C     3,CORESIZE          COMPARE WITH SPACE AVAILABLE         XMN04210\n         LA    1,COREABE           ABEND CODE FOR NO ROOM IN CORE       XMN04220\n         BH    ABEND               WON'T FIT, SO ABEND                  XMN04230\n         L     5,BLKSCODE          NUMBER OF RECORDS OF CODE            XMN04240\n         L     3,BYTSBLK           NUMBER OF BYTES PER RECORD           XMN04250\n         B     LOAD1               GO TEST FOR MORE CODE RECORDS        XMN04260\n         SPACE 1                                                        XMN04270\nRCODE    AR    2,3                 ADDRESS TO PUT NEXT RECORD           XMN04280\n         BAL   CBR,READPGM         READ IN THE BINARY XPL PROGRAM       XMN04290\nLOAD1    BCT   5,RCODE             LOOP BACK TO GET NEXT RECORD         XMN04300\n         SPACE 1                                                        XMN04310\n         A     2,BYTSFULL          NUMBER OF BYTES ACTUALLY             XMN04320\n*                                  USED IN LAST CODE RECORD             XMN04330\n         ST    2,DATADR            SAVE ADDRESS OF DATA AREA            XMN04340\n*                                  FOR USE BY THE XPL PROGRAM           XMN04350\n         L     5,BLKSDATA          NUMBER OF RECORDS OF DATA            XMN04360\n         SPACE 1                                                        XMN04370\nRDATA    BAL   CBR,READPGM         READ IN THE XPL PROGRAM'S DATA AREA  XMN04380\n         AR    2,3                 ADDRESS TO PUT NEXT RECORD           XMN04390\n         BCT   5,RDATA             LOOP BACK FOR NEXT RECORD            XMN04400\n         DROP  4                                                        XMN04410\n         SPACE 2                                                        XMN04420\n*********************************************************************** XMN04430\n*                                                                     * XMN04440\n*                                                                     * XMN04450\n*        CODE TO BRANCH TO THE XPL PROGRAM                            * XMN04460\n*                                                                     * XMN04470\n*                                                                     * XMN04480\n*********************************************************************** XMN04490\n         SPACE 2                                                        XMN04500\n         LA    SELF,ENTRY          ADDRESS OF ENTRY POINT TO XPLSM      XMN04510\n         LM    0,3,PGMPARMS        PARAMETERS FOR THE XPL PROGRAM       XMN04540\n         DROP  EBR,13                                                   XMN04550\n         USING ENTRY,SELF                                               XMN04560\n         SPACE 2                                                        XMN04570\n         USING FILECTRL,2          ADDRESS OF FIRST RECORD OF CODE      XMN04580\nGOC      BAL   CBR,CODEBEGN        BRANCH TO HEAD OF THE XPL PROGRAM    XMN04590\n         DROP  2                                                        XMN04600\n         SPACE 1                                                        XMN04610\n*********************************************************************** XMN04620\n*                                                                     * XMN04630\n*                                                                     * XMN04640\n*        THE XPL PROGRAM RETURNS HERE AT THE END OF EXECUTION         * XMN04650\n*                                                                     * XMN04660\n*                                                                     * XMN04670\n*********************************************************************** XMN04680\n         SPACE 2                                                        XMN04690\n         L     EBR,ABASE1          REGISTER FOR ADDRESSABILITY          XMN04700\n         USING BASE1,EBR                                                XMN04710\n         ST    RTN,RTNSV           SAVE COMPLETION CODE RETURNED BY     XMN04720\n*                                  THE XPL PROGRAM FOR PASSING TO OS    XMN04730\n         L     13,ASAVE            ADDRESS OF OS/360 SAVE AREA          XMN04760\n         USING SAVE,13                                                  XMN04770\n         DROP  SELF                                                     XMN04780\n         SPACE 2                                                        XMN04790\n*********************************************************************** XMN04800\n*                                                                     * XMN04810\n*        RELEASE THE MEMORY OCCUPPIED BY THE XPL PROGRAM              * XMN04820\n*                                                                     * XMN04830\n*********************************************************************** XMN04840\n         SPACE 2                                                        XMN04850\nSMRET    L     1,ACORE             ADDRESS OF THE BLOCK TO BE FREED     XMN04860\n         L     0,CORESIZE          LENGTH OF THE BLOCK TO BE FREED      XMN04870\n         SPACE 1                                                        XMN04880\n         FREEMAIN R,LV=(0),A=(1)   FREEDOM NOW !                        XMN04890\n         SPACE 1                                                        XMN04900\n         CLOSE (INPUT0,,OUTPUT0)                                        XMN04910\n         SPACE 1                                                        XMN04920\n*********************************************************************** XMN04930\n*                                                                     * XMN04940\n*        WARNING,  THE CLOSE OF INPUT0 AND OUTPUT0 MUST PRECEDE       * XMN04950\n*        THE CLOSE WHICH USES THE GETDCBS LIST.  THE CLOSE SVC WILL   * XMN04960\n*        LOOP INDEFINITELY IF THE SAME DCB ADDRESS APPEARS TWICE IN   * XMN04970\n*        A CLOSE LIST.                                                * XMN04980\n*                                                                     * XMN04990\n*********************************************************************** XMN05000\n         SPACE 1                                                        XMN05010\n         CLOSE ,MF=(E,GETDCBS)     CLOSE ALL FILE KNOWN TO XPLSM        XMN05020\n         SPACE 1                                                        XMN05030\n         L     15,RTNSV            LOAD RETURN CODE                     XMN05040\n         L     13,SAVE+4                                                XMN05050\n         DROP  13                                                       XMN05060\n         RETURN (14,12),RC=(15)    RETURN TO OS/360                     XMN05070\n         SPACE 1                                                        XMN05080\n         DROP  EBR                                                      XMN05090\n         USING SAVE,13                                                  XMN05100\n         EJECT                                                          XMN05110\n         SPACE 5                                                        XMN05120\n*********************************************************************** XMN05130\n*                                                                     * XMN05140\n*                                                                     * XMN05150\n*                                                                     * XMN05160\n*        CONSTANTS USED DURING INITIALIZATION                         * XMN05170\n*                                                                     * XMN05180\n*                                                                     * XMN05190\n*********************************************************************** XMN05200\n         SPACE 2                                                        XMN05210\nSAVE     DS    18F                 SAVE AREA FOR OS/360                 XMN05220\nACORE    DS    A                   ADDRESS OF CORE FOR THE PROGRAM      XMN05230\nCORESIZE DS    F                   SIZE OF CORE IN BYTES                XMN05240\nCONTROL  DS    A                   ADDRESS OF PARAMETER STRING PASSED   XMN05250\n*                                  TO THE SUBMONITOR BY OS/360          XMN05260\nCOREREQ  DS    0F                  CORE REQUEST CONTROL BLOCK           XMN05270\nCOREMIN  DC    F'110000'           MINIMUM AMOUNT OF CORE REQUIRED      XMN05280\nCOREMAX  DC    F'5000000'          MAXIMUM AMOUNT OF CORE REQUESTED     XMN05290\nFREEUP   DC    A(2*FILEBYTS)       AMOUNT OF CORE TO RETURN TO OS       XMN05300\nALTFREE  DC    A(4*FILEBYTS)       AMOUNT OF CORE FREED FOR ALTER       XMN05310\n         SPACE 1                                                        XMN05320\n*********************************************************************** XMN05330\n*                                                                     * XMN05340\n*        BLOCK OF PARAMETERS PASSED TO THE XPL PROGRAM                * XMN05350\n*                                                                     * XMN05360\n*********************************************************************** XMN05370\n         SPACE 1                                                        XMN05380\nPGMPARMS DS    F                   R0  UNUSED                           XMN05390\nCORETOP  DC    A(0)                R1  ADDRESS OF TOP OF CORE           XMN05400\nCODEADR  DC    F'0'                R2  ADDRESS OF START OF 1ST RECORD   XMN05410\n*                                  OF THE XPL PROGRAM                   XMN05420\nDATADR   DC    F'0'                R3  ADDRESS OF THE START OF THE XPL  XMN05430\n*                                      PROGRAM'S DATA AREA              XMN05440\n         SPACE 1                                                        XMN05450\nTRCM     DC    CL5'TRACE'                                               XMN05460\nALTRM    DC    CL5'ALTER'                                               XMN05470\nCMNM     DC    CL4'MIN='                                                XMN05480\nCMXM     DC    CL4'MAX='                                                XMN05490\nFREEM    DC    CL5'FREE='                                               XMN05500\nDMPM     DC    CL4'DUMP'                                                XMN05510\nFILEM    DC    CL5'FILE='                                               XMN05520\n         EJECT                                                          XMN05530\n         SPACE 5                                                        XMN05540\n*********************************************************************** XMN05550\n*                                                                     * XMN05560\n*                                                                     * XMN05570\n*        ROUTINE TO SCAN PARAMETER STRINGS FOR DIGITS                 * XMN05580\n*                                                                     * XMN05590\n*                                                                     * XMN05600\n*********************************************************************** XMN05610\n         SPACE 2                                                        XMN05620\nDIGET    DS    0H                                                       XMN05630\n         SR    2,2                 CLEAR REGISTER                       XMN05640\n         SR    3,3                  \"                                   XMN05650\nDG1      CLI   0(1),C'='           CHECK FOR '='                        XMN05660\n         BE    DG2                                                      XMN05670\n         LA    1,1(,1)             INCREMENT POINTER                    XMN05680\n         CR    1,4                 AT END ?                             XMN05690\n         BCR   B'1011',CBR         YES, SO RETURN                       XMN05700\n         B     DG1                 KEEP LOOKING FOR '='                 XMN05710\nDG2      LA    1,1(,1)             INCREMENT POINTER                    XMN05720\n         LA    5,C'0'              BINARY VALUE OF '0'                  XMN05730\nDGLP     IC    2,0(,1)             FETCH A CHARACTER                    XMN05740\n         SR    2,5                 NORMALIZE                            XMN05750\n         BM    DGDN                NOT A DIGIT SO DONE                  XMN05760\n         LR    0,3                                                      XMN05770\n         SLL   3,2                 NUMBER*4                             XMN05780\n         AR    3,0                 NUMBER*5                             XMN05790\n         SLL   3,1                 NUMBER*10                            XMN05800\n         AR    3,2                 ADD IN NEW DIGIT                     XMN05810\n         LA    1,1(,1)             INCREMENT POINTER                    XMN05820\n         CR    1,4                 AT END ?                             XMN05830\n         BL    DGLP                NO                                   XMN05840\nDGDN     LA    1,1(,1)             INCREMENT POINTER                    XMN05850\n         BR    CBR                 RETURN                               XMN05860\n*                                  VALUE OF NUMBER IS IN REG 3          XMN05870\n         EJECT                                                          XMN05880\n         SPACE 5                                                        XMN05890\n*********************************************************************** XMN05900\n*                                                                     * XMN05910\n*                                                                     * XMN05920\n*        ROUTINE TO READ IN THE BINARY IMAGE OF THE XPL PROGRAM       * XMN05930\n*                                                                     * XMN05940\n*                                                                     * XMN05950\n*********************************************************************** XMN05960\n         SPACE 2                                                        XMN05970\nREADPGM  DS    0H                                                       XMN05980\n*                                  SHARE DECB WITH FILE READ ROUTINE    XMN05990\n         SPACE 1                                                        XMN06000\n         READ  RDECB,SF,PROGRAM,(2),MF=E                                XMN06010\n         CHECK RDECB               WAIT FOR READ TO COMPLETE            XMN06020\n         SPACE 1                                                        XMN06030\n         BR    CBR                 RETURN TO CALLER                     XMN06040\n         EJECT                                                          XMN06050\n         SPACE 5                                                        XMN06060\n*********************************************************************** XMN06070\n*                                                                     * XMN06080\n*                                                                     * XMN06090\n         USING BASE1,EBR                                                XMN04710\n         ST    RTN,RTNSV           SAVE COMPLETION CODE RETURNED BY     XMN04720\n*                                  THE XPL PROGRAM FOR PASSING TO OS    XMN04730\n         LA    1,UNTR              TURN OFF POSSIBLE TRACE              XMN04740\n*        ROUTINES TO PROVIDE DEFAULT DATASET INFORMATION IF NONE      * XMN06100\n*        IS PROVIDED BY JCL OR VOLUME LABELS.  IN PARTICULAR,         * XMN06110\n*        BLKSIZE, LRECL, BUFNO, AND RECFM INFORMATION.                * XMN06120\n*                                                                     * XMN06130\n*                                                                     * XMN06140\n*        EXIT LISTS FOR DCBS                                          * XMN06150\n*                                                                     * XMN06160\n*********************************************************************** XMN06170\n         SPACE 2                                                        XMN06180\n         DS    0F                                                       XMN06190\nINEXIT0  DC    X'85'               INPUT0                               XMN06200\n         DC    AL3(INXT0)                                               XMN06210\n         SPACE 1                                                        XMN06220\nOUTEXIT0 DC    X'85'               OUTPUT0                              XMN06230\n         DC    AL3(OUTXT0)                                              XMN06240\n         SPACE 1                                                        XMN06250\nINEXIT2  DC    X'85'               INPUT2                               XMN06260\n         DC    AL3(INXT2)                                               XMN06270\n         SPACE 1                                                        XMN06280\nOUTEXIT2 EQU   INEXIT0             OUTPUT2                              XMN06290\n         SPACE 2                                                        XMN06300\n&I       SETA  3                                                        XMN06310\n.IDF1    AIF   (&I GT &INPUTS).IDF2                                     XMN06320\nINEXIT&I EQU   INEXIT2             INPUT&I                              XMN06330\n&I       SETA  &I+1                                                     XMN06340\n         AGO   .IDF1                                                    XMN06350\n.IDF2    ANOP                                                           XMN06360\n         SPACE 1                                                        XMN06370\n&I       SETA  3                                                        XMN06380\n.ODF1    AIF   (&I GT &OUTPUTS).ODF2                                    XMN06390\nOUTEXIT&I EQU  INEXIT2                                                  XMN06400\n&I       SETA  &I+1                                                     XMN06410\n         AGO   .ODF1                                                    XMN06420\n.ODF2    ANOP                                                           XMN06430\n         SPACE 1                                                        XMN06440\n*********************************************************************** XMN06450\n*                                                                     * XMN06460\n*        DCB EXIT ROUTINE ENTRY POINTS                                * XMN06470\n*                                                                     * XMN06480\n*********************************************************************** XMN06490\n         SPACE 2                                                        XMN06500\nINXT0    MVC   DEFAULTS(6),INDFLT0                                      XMN06510\n         B     GENXT                                                    XMN06520\n         SPACE 1                                                        XMN06530\nINXT2    MVC   DEFAULTS(6),INDFLT2                                      XMN06540\n         B     GENXT                                                    XMN06550\n         SPACE 1                                                        XMN06560\nOUTXT0   MVC   DEFAULTS(6),OUTDFLT0                                     XMN06570\n         SPACE 1                                                        XMN06580\n*********************************************************************** XMN06590\n*                                                                     * XMN06600\n*                                                                     * XMN06610\n*        DCB EXIT LIST PROCESSING ROUTINE FOR OPEN EXITS              * XMN06620\n*                                                                     * XMN06630\n*********************************************************************** XMN06640\n         SPACE 2                                                        XMN06650\nGENXT    DS    0H                                                       XMN06660\n         USING IHADCB,1            REGISTER 1 POINTS AT THE DCB         XMN06670\n         NC    DCBBLKSI,DCBBLKSI   CHECK BLKSIZE                        XMN06680\n         BNZ   GXT1                ALREADY SET                          XMN06690\n         MVC   DCBBLKSI(2),DFLTBLKS                                     XMN06700\n*                                  PROVIDE DEFAULT BLOCKSIZE            XMN06710\n         SPACE 1                                                        XMN06720\nGXT1     NC    DCBLRECL,DCBLRECL   CHECK LRECL                          XMN06730\n         BNZ   GXT2                ALREADY SET                          XMN06740\n         MVC   DCBLRECL(2),DFLTLREC                                     XMN06750\n*                                  PROVIDE DEFAULT LRECL                XMN06760\n         SPACE 1                                                        XMN06770\nGXT2     CLI   DCBBUFNO,0          CHECK BUFNO                          XMN06780\n         BNE   GXT3                ALREADY SPECIFIED                    XMN06790\n         MVC   DCBBUFNO(1),DFLTBUFN                                     XMN06800\n*                                  PROVIDE DEFAULT BUFNO                XMN06810\n         SPACE 1                                                        XMN06820\nGXT3     TM    DCBRECFM,ALLBITS-KEYLBIT                                 XMN06830\n*                                  CHECK RECFM                          XMN06840\n         BCR   B'0111',14          ALREADY SET SO RETURN                XMN06850\n         OC    DCBRECFM(1),DFLTRECF                                     XMN06860\n*                                  PROVIDE DEFAULT RECFM                XMN06870\n         BR    14                  RETURN                               XMN06880\n         DROP  1                                                        XMN06890\n         SPACE 2                                                        XMN06900\n*********************************************************************** XMN06910\n*                                                                     * XMN06920\n*        ARRAY OF DEFAULT ATTRIBUTES USED BY GENXT                    * XMN06930\n*                                                                     * XMN06940\n*********************************************************************** XMN06950\n         SPACE 1                                                        XMN06960\nDEFAULTS DS    0H                                                       XMN06970\nDFLTBLKS DS    1H                  DEFAULT BLKSIZE                      XMN06980\nDFLTLREC DS    1H                  DEFAULT LRECL                        XMN06990\nDFLTBUFN DS    AL1                 DEFAULT BUFNO                        XMN07000\nDFLTRECF DS    1BL1                DEFAULT RECFM                        XMN07010\n         SPACE 1                                                        XMN07020\n*********************************************************************** XMN07030\n*                                                                     * XMN07040\n*        DEFINE ATTRIBUTES PROVIDED FOR THE VARIOUS FILES             * XMN07050\n*                                                                     * XMN07060\n*        INPUT(0), INPUT(1), OUTPUT(2)                                * XMN07070\n*                                                                     * XMN07080\n*********************************************************************** XMN07090\n         SPACE 1                                                        XMN07100\nINDFLT0  DS    0H                                                       XMN07110\n         DC    H'80'               BLKSIZE=80                           XMN07120\n         DC    H'80'               LRECL=80                             XMN07130\n         DC    AL1(2)              BUFNO=2                              XMN07140\n         DC    B'10000000'         RECFM=F                              XMN07150\n         SPACE 1                                                        XMN07160\n*********************************************************************** XMN07170\n*                                                                     * XMN07180\n*        OUTPUT(0), OUTPUT(1)                                         * XMN07190\n*                                                                     * XMN07200\n*********************************************************************** XMN07210\n         SPACE 1                                                        XMN07220\nOUTDFLT0 DS    0H                                                       XMN07230\n         DC    H'133'              BLKSIZE=133                          XMN07240\n         DC    H'133'              LRECL=133                            XMN07250\n         DC    AL1(2)              BUFNO=2                              XMN07260\n         DC    B'10000100'         RECFM=FA                             XMN07270\n         SPACE 1                                                        XMN07280\n*********************************************************************** XMN07290\n*                                                                     * XMN07300\n*        INPUT(2), INPUT(3), OUTPUT(3)                                * XMN07310\n*                                                                     * XMN07320\n*********************************************************************** XMN07330\n         SPACE 1                                                        XMN07340\nINDFLT2  DS    0H                                                       XMN07350\n         DC    AL2(IOFBYTS)        BLKSIZE=IOFBYTS                      XMN07360\n         DC    H'80'               LRECL=80                             XMN07370\n         DC    AL1(1)              BUFNO=1                              XMN07380\n         DC    B'10010000'         RECFM=FB                             XMN07390\n         EJECT                                                          XMN07400\n         SPACE 5                                                        XMN07410\n*********************************************************************** XMN07420\n*                                                                     * XMN07430\n*                                                                     * XMN07440\n*        INPUT - OUTPUT  ERROR ROUTINES                               * XMN07450\n*                                                                     * XMN07460\n*                                                                     * XMN07470\n*                                                                     * XMN07480\n*        SYNAD AND EOD ERROR ROUTINES FOR INITIAL LOADING OF THE      * XMN07490\n*        XPL PROGRAM                                                  * XMN07500\n*                                                                     * XMN07510\n*                                                                     * XMN07520\n*********************************************************************** XMN07530\n         SPACE 2                                                        XMN07540\nEODPGM   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN07550\n         LA    1,PGMEOD            UNEXPECTED EOD WHILE READING IN      XMN07560\n*                                  THE XPL PROGRAM                      XMN07570\n         B     ABEND               GO TO ABEND ROUTINE                  XMN07580\n         SPACE 2                                                        XMN07590\nERRPGM   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN07600\n         LA    1,PGMERR            SYNAD ERROR WHILE READING IN THE     XMN07610\n*                                  XPL PROGRAM                          XMN07620\n         B     ABEND               GO TO ABEND ROUTINE                  XMN07630\n         SPACE 2                                                        XMN07640\n*********************************************************************** XMN07650\n*                                                                     * XMN07660\n*                                                                     * XMN07670\n*        SYNAD AND EOD ROUTINES FOR INPUT(I),  I = 0,1, ...  ,&INPUTS * XMN07680\n*                                                                     * XMN07690\n*********************************************************************** XMN07700\n         SPACE 2                                                        XMN07710\nINEOD    L     2,SAVREG+PARM2*4    PICK UP SUBCODE SPECIFYING WHICH     XMN07720\n*                                  INPUT FILE                           XMN07730\n         SLL   2,2                 SUBCODE*4                            XMN07740\n         L     2,GETDCBS(2)        FETCH DCB ADDRESS                    XMN07750\n         USING IHADCB,2                                                 XMN07760\n         ST    2,OCDCB             STORE IT FOR THE CLOSE SVC           XMN07770\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST           XMN07780\n         CLOSE ,MF=(E,OCDCB)       CLOSE THE OFFENDING FILE             XMN07790\n         SPACE 1                                                        XMN07800\nPCLOSE   DS    0H                                                       XMN07810\n         XC    DCBDDNAM,DCBDDNAM   MARK THE FILE PERMANENTLY UNUSABLE   XMN07820\n         DROP  2                                                        XMN07830\n         B     RETNEOF             GO RETURN AN END OF FILE INDICATION  XMN07840\n         SPACE 2                                                        XMN07850\nINSYNAD  STM   0,2,ABEREGS         SAVE REGISTERS                       XMN07860\n         LA    1,INSYND            SYNAD ERROR ON AN INPUT FILE         XMN07870\n         B     INERR               BRANCH TO ERROR ROUTINE              XMN07880\n         SPACE 1                                                        XMN07890\nINEOD2   LA    1,INEODAB           EOD ON AN INPUT FILE                 XMN07900\n*                                  ATTEMPT TO READ AFTER AN EOD SIGNAL  XMN07910\nINERR    A     1,SAVREG+PARM2*4    SUBCODE INDICATING WHICH INPUT FILE  XMN07920\n         B     ABEND               BRANCH TO ABEND ROUTINE              XMN07930\n         SPACE 2                                                        XMN07940\n*********************************************************************** XMN07950\n*                                                                     * XMN07960\n*                                                                     * XMN07970\n*        SYNAD ERROR ROUTINES FOR OUTPUT FILES                        * XMN07980\n*                                                                     * XMN07990\n*                                                                     * XMN08000\n*********************************************************************** XMN08010\n         SPACE 2                                                        XMN08020\nOUTSYNAD STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08030\n         LA    1,OUTSYND           SYNAD ERROR ON OUTPUT FILE           XMN08040\n         B     INERR                                                    XMN08050\n         SPACE 2                                                        XMN08060\n*********************************************************************** XMN08070\n*                                                                     * XMN08080\n*        SYNAD AND EOD ROUTINES FOR DIRECT ACCESS FILE I/O            * XMN08090\n*                                                                     * XMN08100\n*********************************************************************** XMN08110\n         SPACE 2                                                        XMN08120\nFILESYND STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08130\n         LA    1,FLSYND            SYNAD ERROR ON DIRECT ACCESS FILE    XMN08140\n         B     FILERR              GO TO ERROR ROUTINE                  XMN08150\n         SPACE 1                                                        XMN08160\nFILEEOD  STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08170\n         LA    1,FLEOD             EOD ERROR ON DIRECT ACCESS FILE      XMN08180\n         SPACE 1                                                        XMN08190\nFILERR   L     2,SAVREG+SVCODE*4   SERVICE CODE                         XMN08200\n         LA    0,RD1-8             COMPUTE WHICH DIRECT ACCESS FILE     XMN08210\n         SR    2,0                 SERVICE_CODE - 1ST SERVICE CODE      XMN08220\n         SRL   2,3                 DIVIDE BY 8                          XMN08230\n         AR    1,2                                                      XMN08240\n*                                  FALL THROUGH TO ABEND ROUTINE        XMN08250\n         SPACE 2                                                        XMN08260\n*********************************************************************** XMN08270\n*                                                                     * XMN08280\n*                                                                     * XMN08290\n*        ABEND ROUTINE FOR ALL I/O ERRORS                             * XMN08300\n*                                                                     * XMN08310\n*                                                                     * XMN08320\n*********************************************************************** XMN08330\n         SPACE 2                                                        XMN08340\nABEND    DS    0H                                                       XMN08350\n         ST    1,ABESAVE           SAVE ABEND CODE                      XMN08360\n         SPACE 1                                                        XMN08370\n         CLOSE (INPUT0,,OUTPUT0)   THESE MUST BE CLOSED FIRST           XMN08380\n         CLOSE ,MF=(E,GETDCBS)     ATTEMPT TO CLOSE ALL FILES           XMN08390\n         SPACE 1                                                        XMN08400\n         L     1,ABESAVE                                                XMN08410\n         TM    FLAGS,DUMPBIT       IS A CORE DUMP DESIRED ?             XMN08420\n         BZ    NODUMP              NO, ABEND QUIETLY                    XMN08430\n         SPACE 1                                                        XMN08440\n         ABEND (1),DUMP            ABEND WITH A DUMP                    XMN08450\n         SPACE 1                                                        XMN08460\nNODUMP   DS    0H                                                       XMN08470\n         ABEND (1)                 ABEND WITHOUT A DUMP                 XMN08480\n         SPACE 2                                                        XMN08490\n*********************************************************************** XMN08500\n*                                                                     * XMN08510\n*                                                                     * XMN08520\n*        ROUTINE TO FORCE AN ABEND DUMP WHEN REQUESTED BY THE         * XMN08530\n*        XPL PROGRAM BY MEANS OF THE STATEMENT:                       * XMN08540\n*                                                                     * XMN08550\n*        CALL  EXIT  ;                                                * XMN08560\n*                                                                     * XMN08570\n*                                                                     * XMN08580\n*********************************************************************** XMN08590\n         SPACE 2                                                        XMN08600\nUSEREXIT DS    0H                                                       XMN08610\n         STM   0,2,ABEREGS         SAVE REGISTERS                       XMN08620\n         OI    FLAGS,DUMPBIT       FORCE A DUMP                         XMN08630\n         LA    1,USERABE           USER ABEND CODE                      XMN08640\n         B     ABEND               BRANCH TO ABEND                      XMN08650\n         EJECT                                                          XMN08660\n         SPACE 5                                                        XMN08670\n*********************************************************************** XMN08680\n*                                                                     * XMN08690\n*                                                                     * XMN08700\n*        DISPATCHER FOR ALL SERVICE REQUESTS FROM THE XPL PROGRAM     * XMN08710\n*                                                                     * XMN08720\n*                                                                     * XMN08730\n*********************************************************************** XMN08740\n         SPACE 2                                                        XMN08750\n         DROP  13                                                       XMN08760\n         USING ENTRY,SELF                                               XMN08770\nENTRY    DS    0H                  XPL PROGRAMS ENTER HERE              XMN08780\n         STM   0,3,SAVREG          SAVE REGISTERS USED BY XPLSM         XMN08790\n         STM   13,15,SAVREG+13*4                                        XMN08800\n         L     13,ASAVE            ADDRESS OF OS SAVE AREA              XMN08810\n         DROP  SELF                                                     XMN08820\n         USING SAVE,13                                                  XMN08830\n         SPACE 1                                                        XMN08840\n         LTR   SVCODE,SVCODE       CHECK THE SERVICE CODE FOR VALIDITY  XMN08850\n         BNP   BADCODE             SERVICE CODE MUST BE > 0             XMN08860\n         C     SVCODE,MAXCODE      AND < ENDSERV                        XMN08870\n         BH    BADCODE             GO ABEND                             XMN08880\n         SPACE 1                                                        XMN08890\nTABLE    B     TABLE(SVCODE)       GO DO THE SERVICE                    XMN08900\n         SPACE 1                                                        XMN08910\n         ORG   TABLE+GETC                                               XMN08920\n         B     GET                 READ INPUT FILE                      XMN08930\n         SPACE 1                                                        XMN08940\n         ORG   TABLE+PUTC                                               XMN08950\n         B     PUT                 WRITE OUTPUT FILE                    XMN08960\n         SPACE 1                                                        XMN08970\n         ORG   TABLE+TRC                                                XMN08980\n         B     EXIT                INITIATE TRACING OF THE PROGRAM      XMN08990\n         SPACE 1                                                        XMN09000\n         ORG   TABLE+UNTR                                               XMN09010\n         B     EXIT                TERMINATE TRACING                    XMN09020\n         SPACE 1                                                        XMN09030\n         ORG   TABLE+EXDMP                                              XMN09040\n         B     USEREXIT            TERMINATE WITH A CORE DUMP           XMN09050\n         SPACE 1                                                        XMN09060\n         ORG   TABLE+GTIME                                              XMN09070\n         B     GETIME              RETURN TIME AND DATE                 XMN09080\n         SPACE 1                                                        XMN09090\n         ORG   TABLE+RSVD1                                              XMN09100\n         B     EXIT                (UNUSED)                             XMN09110\n         SPACE 1                                                        XMN09120\n         ORG   TABLE+RSVD2                                              XMN09130\n         B     EXIT                CLOCK_TRAP        (NOP)              XMN09140\n         SPACE 1                                                        XMN09150\n         ORG   TABLE+RSVD3                                              XMN09160\n         B     EXIT                INTERRUPT_TRAP    (NOP)              XMN09170\n         SPACE 1                                                        XMN09180\n         ORG   TABLE+RSVD4                                              XMN09190\n         B     EXIT                MONITOR           (NOP)              XMN09200\n         SPACE 1                                                        XMN09210\n         ORG   TABLE+RSVD5                                              XMN09220\n         B     EXIT                (UNUSED)                             XMN09230\n         SPACE 1                                                        XMN09240\n         ORG   TABLE+RSVD6                                              XMN09250\n         B     EXIT                (UNUSED)                             XMN09260\n         SPACE 2                                                        XMN09270\n*********************************************************************** XMN09280\n*                                                                     * XMN09290\n*                                                                     * XMN09300\n*        DYNAMICALLY GENERATE THE DISPATCHING TABLE ENTRIES FOR       * XMN09310\n*        FILE I/O SERVICES.                                           * XMN09320\n*                                                                     * XMN09330\n*                                                                     * XMN09340\n*********************************************************************** XMN09350\n         SPACE 2                                                        XMN09360\n&I       SETA  1                   LOOP INDEX                           XMN09370\n.DBR1    AIF   (&I GT &FILES).DBR2                                      XMN09380\n*                                  FINISHED ?                           XMN09390\n         ORG   TABLE+RD&I                                               XMN09400\n         B     READ                BRANCH TO FILE READ ROUTINE          XMN09410\n         ORG   TABLE+WRT&I                                              XMN09420\n         B     WRITE               BRANCH TO FILE WRITE ROUTINE         XMN09430\n&I       SETA  &I+1                INCREMENT COUNTER                    XMN09440\n         AGO   .DBR1               LOOP BACK                            XMN09450\n.DBR2    ANOP                                                           XMN09460\n         SPACE 2                                                        XMN09470\n         ORG   TABLE+ENDSERV       RESET PROGRAM COUNTER                XMN09480\n         SPACE 2                                                        XMN09490\n*********************************************************************** XMN09500\n*                                                                     * XMN09510\n*                                                                     * XMN09520\n*        COMMON EXIT ROUTINE FOR RETURN TO THE XPL PROGRAM            * XMN09530\n*                                                                     * XMN09540\n*                                                                     * XMN09550\n*********************************************************************** XMN09560\n         SPACE 2                                                        XMN09570\nEXIT     DS    0H                                                       XMN09580\n         LM    0,3,SAVREG          RESTORE REGISTERS                    XMN09590\n         LM    13,15,SAVREG+13*4                                        XMN09600\n         DROP  13                                                       XMN09610\n         USING ENTRY,SELF                                               XMN09620\n         SPACE 1                                                        XMN09630\n         BR    CBR                 RETURN TO THE XPL PROGRAM            XMN09640\n         SPACE 1                                                        XMN09650\n         DROP  SELF                                                     XMN09660\n         USING SAVE,13                                                  XMN09670\n         SPACE 2                                                        XMN09680\n*********************************************************************** XMN09690\n*                                                                     * XMN09700\n*        ROUTINE TO ABEND IN CASE OF BAD SERVICE CODES                * XMN09710\n*                                                                     * XMN09720\n*********************************************************************** XMN09730\n         SPACE 2                                                        XMN09740\nBADCODE  STM   0,2,ABEREGS         SAVE REGISTERS                       XMN09750\n         LA    1,CODEABE           BAD SERVICE CODE ABEND               XMN09760\n         B     ABEND               GO ABEND                             XMN09770\n         EJECT                                                          XMN09780\n         SPACE 5                                                        XMN09790\n*********************************************************************** XMN09800\n*                                                                     * XMN09810\n*                                                                     * XMN09820\n*        INPUT ROUTINE FOR READING SEQUENTIAL INPUT FILES             * XMN09830\n*                                                                     * XMN09840\n*                                                                     * XMN09850\n*        INPUT TO THIS ROUTINE IS:                                    * XMN09860\n*                                                                     * XMN09870\n*      PARM1   ADDRESS OF THE NEXT AVAILABLE SPACE IN THE PROGRAMS    * XMN09880\n*              DYNAMIC STRING AREA  (FREEPOINT)                       * XMN09890\n*                                                                     * XMN09900\n*      SVCODE  THE SERVICE CODE FOR INPUT                             * XMN09910\n*                                                                     * XMN09920\n*      PARM2   A SUBCODE DENOTING WHICH INPUT FILE,                   * XMN09930\n*              INPUT(I),     I = 0,1, ... ,&INPUTS                    * XMN09940\n*                                                                     * XMN09950\n*        THE ROUTINE RETURNS:                                         * XMN09960\n*                                                                     * XMN09970\n*      PARM1   A STANDARD XPL STRING DESCRIPTOR POINTING AT THE INPUT * XMN09980\n*              RECORD WHICH IS NOW AT THE TOP OF THE STRING AREA      * XMN09990\n*                                                                     * XMN10000\n*      SVCODE  THE NEW VALUE FOR FREEPOINT, UPDATED BY THE LENGTH OF  * XMN10010\n*              THE RECORD JUST READ IN                                * XMN10020\n*                                                                     * XMN10030\n*                                                                     * XMN10040\n*        A STANDARD XPL STRING DESCRIPTOR HAS:                        * XMN10050\n*                                                                     * XMN10060\n*        BITS  0-7                 (LENGTH - 1) OF THE STRING         * XMN10070\n*        BITS  8-31                ABSOLUTE ADDRESS OF THE STRING     * XMN10080\n*                                                                     * XMN10090\n*                                                                     * XMN10100\n*                                                                     * XMN10110\n*********************************************************************** XMN10120\n         SPACE 2                                                        XMN10130\nGET      DS    0H                                                       XMN10140\n         LA    SVCODE,&INPUTS      CHECK THAT THE SUBCODE IS VALID      XMN10150\n         LTR   PARM2,PARM2         SUBCODE MUST BE >= 0                 XMN10160\n         BM    BADGET                                                   XMN10170\n         CR    PARM2,SVCODE        AND <= &INPUTS                       XMN10180\n         BH    BADGET              ILLEGAL SUBCODE                      XMN10190\n         SLL   PARM2,2             SUBCODE*4                            XMN10200\n         L     3,GETDCBS(PARM2)    ADDRESS OF DCB FOR THE FILE          XMN10210\n         USING IHADCB,3                                                 XMN10220\n         NC    DCBDDNAM,DCBDDNAM   HAS THE FILE BEEN PERMANENTLY        XMN10230\n*                                  CLOSED ?                             XMN10240\n         BZ    INEOD2              YES, SO TERMINATE THE JOB            XMN10250\n         SPACE 1                                                        XMN10260\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN10270\n         BO    GETOPEN             YES                                  XMN10280\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC       XMN10290\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST           XMN10300\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN10310\n         LR    2,3                 COPY DCB ADDRESS                     XMN10320\n         TM    DCBOFLGS,OPENBIT    WAS THE FILE OPENED SUCCESSFULLY ?   XMN10330\n         BZ    PCLOSE              NO, MARK FILE PERMANENTLY CLOSED AND XMN10340\n*                                  RETURN EOD INDICATION TO THE PROGRAM XMN10350\n         SPACE 2                                                        XMN10360\nGETOPEN  DS    0H                                                       XMN10370\n         GET   (3)                 LOCATE MODE GET                      XMN10380\n         SPACE 1                                                        XMN10390\n*********************************************************************** XMN10400\n*                                                                     * XMN10410\n*        USING LOCATE MODE, THE ADDRESS OF THE NEXT INPUT BUFFER      * XMN10420\n*        IS RETURNED IN R1                                            * XMN10430\n*                                                                     * XMN10440\n*********************************************************************** XMN10450\n         SPACE 1                                                        XMN10460\n         L     2,SAVREG+PARM1*4    FETCH THE STRING DESCRIPTOR          XMN10470\n         LA    2,0(,2)             ADDRESS PART ONLY                    XMN10480\n         LH    3,DCBLRECL          RECORD LENGTH                        XMN10490\n         DROP  3                                                        XMN10500\n         S     3,F1                LENGTH - 1                           XMN10510\n         EX    3,GETMOVE           MOVE THE CHARACTERS                  XMN10520\n         ST    2,SAVREG+PARM1*4    BUILD UP A STRING DESCRIPTOR         XMN10530\n         STC   3,SAVREG+PARM1*4    LENGTH FIELD                         XMN10540\n         LA    2,1(2,3)            NEW FREE POINTER                     XMN10550\n         ST    2,SAVREG+SVCODE*4                                        XMN10560\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN10570\n         SPACE 2                                                        XMN10580\n*********************************************************************** XMN10590\n*                                                                     * XMN10600\n*        RETURN A NULL STRING DESCRIPTOR AS AN END OF FILE            * XMN10610\n*        INDICATION THE FIRST TIME AN INPUT REQUEST FIND THE          * XMN10620\n*        END OF DATA CONDITION                                        * XMN10630\n*                                                                     * XMN10640\n*********************************************************************** XMN10650\n         SPACE 2                                                        XMN10660\nRETNEOF  DS    0H                                                       XMN10670\n         MVC   SAVREG+SVCODE*4(4),SAVREG+PARM1*4                        XMN10680\n*                                  RETURN FREEPOINT UNTOUCHED           XMN10690\n         XC    SAVREG+PARM1*4(4),SAVREG+PARM1*4                         XMN10700\n*                                  RETURN A NULL STRING DESCRIPTOR      XMN10710\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN10720\n         SPACE 2                                                        XMN10730\n*********************************************************************** XMN10740\n*                                                                     * XMN10750\n*        ROUTINE TO ABEND IN CASE OF AN INVALID SUBCODE               * XMN10760\n*                                                                     * XMN10770\n*********************************************************************** XMN10780\n         SPACE 2                                                        XMN10790\nBADGET   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN10800\n         LA    1,GFABE             INVALID GET SUBCODE                  XMN10810\n         B     INERR               GO ABEND                             XMN10820\n         EJECT                                                          XMN10830\n         SPACE 5                                                        XMN10840\n*********************************************************************** XMN10850\n*                                                                     * XMN10860\n*                                                                     * XMN10870\n*                                                                     * XMN10880\n*        ROUTINE FOR WRITING SEQUENTIAL OUTPUT FILES                  * XMN10890\n*                                                                     * XMN10900\n*                                                                     * XMN10910\n*        INPUT TO THIS ROUTINE:                                       * XMN10920\n*                                                                     * XMN10930\n*      PARM1   XPL STRING DESCRIPTOR OF THE STRING TO BE OUTPUT       * XMN10940\n*                                                                     * XMN10950\n*      PARM2   SUBCODE INDICATING  OUTPUT(I),  I = 0,1, ... ,&OUTPUTS * XMN10960\n*                                                                     * XMN10970\n*      SVCODE  THE SERVICE CODE FOR OUTPUT                            * XMN10980\n*                                                                     * XMN10990\n*                                                                     * XMN11000\n*        THE STRING NAMED BY THE DESCRIPTOR IS PLACED IN THE NEXT     * XMN11010\n*        OUTPUT BUFFER OF THE SELECTED FILE.  IF THE STRING IS        * XMN11020\n*        SHORTER THAN THE RECORD LENGTH OF THE FILE THEN THE          * XMN11030\n*        REMAINDER OF THE RECORD IS PADDED WITH BLANKS.  IF THE       * XMN11040\n*        STRING IS LONGER THAN THE RECORD LENGTH OF THE FILE          * XMN11050\n*        THEN IT IS TRUNCATED ON THE RIGHT TO FIT.  IF THE SUBCODE    * XMN11060\n*        SPECIFIES OUTPUT(0) THEN A SINGLE BLANK IS CONCATENATED      * XMN11070\n*        ON TO THE FRONT OF THE STRING TO SERVE AS CARRIAGE CONTROL.  * XMN11080\n*                                                                     * XMN11090\n*                                                                     * XMN11100\n*********************************************************************** XMN11110\n         SPACE 2                                                        XMN11120\nPUT      DS    0H                                                       XMN11130\n         LTR   PARM2,PARM2         CHECK SUBCODE FOR VALIDITY           XMN11140\n         BM    BADPUT              SUBCODE MUST BE >= 0                 XMN11150\n         LA    SVCODE,&OUTPUTS                                          XMN11160\n         CR    PARM2,SVCODE        AND <= &OUTPUTS                      XMN11170\n         BH    BADPUT                                                   XMN11180\n         ST    PARM1,MOVEADR       SAVE THE STRING DESCRIPTOR           XMN11190\n         SLL   PARM2,2             SUBCODE*4                            XMN11200\n         L     3,PUTDCBS(PARM2)    GET THE DCB ADDRESS                  XMN11210\n         USING IHADCB,3                                                 XMN11220\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN11230\n         BO    PUTOPEN             YES, GO DO THE OUTPUT                XMN11240\n         ST    3,OCDCB             STORE DCB ADDRESS FOR THE OPEN SVC   XMN11250\n         MVI   OCDCB,X'8F'         FLAG END OF PARAMETER LIST AND SET   XMN11260\n*                                  FLAG INDICATING OPENING FOR OUTPUT   XMN11270\n         SPACE 1                                                        XMN11280\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN11290\n         SPACE 1                                                        XMN11300\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFULL ?           XMN11310\n         BZ    OUTSYNAD            NO, OUTPUT SYNAD ERROR               XMN11320\n         SPACE 1                                                        XMN11330\nPUTOPEN  DS    0H                                                       XMN11340\n         PUT   (3)                 LOCATE MODE PUT                      XMN11350\n         SPACE 1                                                        XMN11360\n*********************************************************************** XMN11370\n*                                                                     * XMN11380\n*        USING LOCATE MODE, THE ADDRESS OF THE NEXT OUTPUT BUFFER     * XMN11390\n*        IS RETURNED IN  R1.                                          * XMN11400\n*                                                                     * XMN11410\n*********************************************************************** XMN11420\n         SPACE 1                                                        XMN11430\n         SR    15,15               CLEAR REGISTER 15                    XMN11440\n         C     15,MOVEADR          IS THE STRING NULL (DESCRIPTOR = 0)  XMN11450\n         BE    NULLPUT             YES, SO PUT OUT A BLANK RECORD       XMN11460\n         IC    15,MOVEADR          LENGTH-1 OF THE STRING               XMN11470\n         LA    14,1(15)            REAL LENGTH OF THE STRING            XMN11480\n         LH    0,DCBLRECL          RECORD LENGTH OF THE FILE            XMN11490\n         LTR   PARM2,PARM2         CHECK SUBCODE FOR OUTPUT(0)          XMN11500\n         BNZ   PUT1                NOT OUTPUT(0)                        XMN11510\n         LA    14,1(,14)           INCREASE REAL LENGTH BY ONE FOR      XMN11520\n*                                  CARRIAGE CONTROL                     XMN11530\nPUT1     SR    0,14                RECORD LENGTH - REAL LENGTH          XMN11540\n         BM    TOOLONG             RECORD LENGTH < REAL LENGTH          XMN11550\n         BZ    MATCH               RECORD LENGTH = REAL LENGTH          XMN11560\n*                                  RECORD LENGTH > REAL LENGTH          XMN11570\n         OI    FLAGS,SFILLBIT+LFILLBIT                                  XMN11580\n*                                  INDICATE PADDING REQUIRED            XMN11590\n         S     0,F1                RECORD LENGTH - REAL LENGTH - 1      XMN11600\n         BP    LONGMOVE            RECORD LENGTH - REAL LENGTH > 1      XMN11610\n         NI    FLAGS,ALLBITS-LFILLBIT                                   XMN11620\n*                                  RECORD LENGTH - REAL LENGTH = 1      XMN11630\n*                                  IS A SPECIAL CASE                    XMN11640\nLONGMOVE ST    0,FILLENG           SAVE LENGTH FOR PADDING OPERATION    XMN11650\n         B     MOVEIT              GO MOVE THE STRING                   XMN11660\n         SPACE 1                                                        XMN11670\nTOOLONG  LH    15,DCBLRECL         REPLACE THE STRING LENGTH            XMN11680\n*                                  WITH THE RECORD LENGTH               XMN11690\n         S     15,F1               RECORD LENGTH - 1 FOR THE MOVE       XMN11700\nMATCH    NI    FLAGS,ALLBITS-SFILLBIT-LFILLBIT                          XMN11710\n*                                  INDICATE NO PADDING REQUIRED         XMN11720\n         SPACE 1                                                        XMN11730\nMOVEIT   LTR   PARM2,PARM2         CHECK FOR OUTPUT(0)                  XMN11740\n         BNZ   MOVEIT2             OUTPUT(0) IS A SPECIAL CASE          XMN11750\n         MVI   0(1),C' '           PROVIDE BLANK CARRIAGE CONTROL       XMN11760\n         LA    1,1(,1)             INCREMENT BUFFER POINTER             XMN11770\nMOVEIT2  L     2,MOVEADR           STRING DESCRIPTOR                    XMN11780\n         LA    2,0(,2)             ADDRESS PART ONLY                    XMN11790\n         EX    15,MVCSTRNG         EXECUTE A MVC INSTRUCTION            XMN11800\n         TM    FLAGS,SFILLBIT      IS PADDING REQUIRED ?                XMN11810\n         BZ    EXIT                NO, RETURN TO THE XPL PROGRAM        XMN11820\n         SPACE 1                                                        XMN11830\n         AR    1,15                ADDRESS TO START PADDING - 1         XMN11840\n         MVI   1(1),C' '           START THE PAD                        XMN11850\n         TM    FLAGS,LFILLBIT      IS MORE PADDING REQUIRED ?           XMN11860\n         BZ    EXIT                NO, RETURN TO XPL PROGRAM            XMN11870\n         L     15,FILLENG          LENGTH OF PADDING NEEDED             XMN11880\n         S     15,F1               LESS ONE FOR THE MOVE                XMN11890\n         EX    15,MVCBLANK         EXECUTE MVC TO FILL IN BLANKS        XMN11900\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN11910\n         SPACE 1                                                        XMN11920\n*********************************************************************** XMN11930\n*                                                                     * XMN11940\n*        FOR A NULL STRING OUTPUT A BLANK RECORD                      * XMN11950\n*                                                                     * XMN11960\n*********************************************************************** XMN11970\n         SPACE 1                                                        XMN11980\nNULLPUT  LH    15,DCBLRECL         RECORD LENGTH                        XMN11990\n         S     15,F2               LESS TWO FOR THE MOVES               XMN12000\n         MVI   0(1),C' '           INITIAL BLANK                        XMN12010\n         EX    15,MVCNULL          EXECUTE MVC TO FILL IN THE BLANKS    XMN12020\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN12030\n         SPACE 1                                                        XMN12040\n         DROP  3                                                        XMN12050\n         SPACE 1                                                        XMN12060\n*********************************************************************** XMN12070\n*                                                                     * XMN12080\n*        ROUTINE TO ABEND IN CASE OF AN INVALID SERVICE CODE          * XMN12090\n*                                                                     * XMN12100\n*********************************************************************** XMN12110\n         SPACE 1                                                        XMN12120\nBADPUT   STM   0,2,ABEREGS         SAVE REGISTERS                       XMN12130\n         LA    1,PFABE             INVALID PUT SUBCODE                  XMN12140\n         B     INERR               GO ABEND                             XMN12150\n         EJECT                                                          XMN12160\n         SPACE 5                                                        XMN12170\n*********************************************************************** XMN12180\n*                                                                     * XMN12190\n*                                                                     * XMN12200\n*                                                                     * XMN12210\n*        READ ROUTINE FOR DIRECT ACCESS FILE I/O                      * XMN12220\n*                                                                     * XMN12230\n*                                                                     * XMN12240\n*        INPUT TO THIS ROUTINE IS:                                    * XMN12250\n*                                                                     * XMN12260\n*      PARM1   CORE ADDRESS TO READ THE RECORD INTO                   * XMN12270\n*                                                                     * XMN12280\n*      SVCODE  SERVICE CODE INDICATING WHICH FILE TO USE              * XMN12290\n*                                                                     * XMN12300\n*      PARM2   RELATIVE RECORD NUMBER   0,1,2,3,...                   * XMN12310\n*                                                                     * XMN12320\n*                                                                     * XMN12330\n*                                                                     * XMN12340\n*********************************************************************** XMN12350\n         SPACE 2                                                        XMN12360\nREAD     DS    0H                                                       XMN12370\n         ST    PARM1,RDECB+12      STORE ADDRESS                        XMN12380\n         L     3,ARWDCBS-FILEORG(SVCODE)                                XMN12390\n*                                  ADDRESS OF THE DCB FOR THIS FILE     XMN12400\n         USING IHADCB,3                                                 XMN12410\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN12420\n         BO    READOPEN            YES, GO READ                         XMN12430\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC       XMN12440\n         MVI   OCDCB,X'80'         FLAG END OF PARAMETER LIST           XMN12450\n*                                  AND INDICATE OPEN FOR INPUT          XMN12460\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN12470\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFUL ?            XMN12480\n         BZ    FILESYND            NO, SYNAD ERROR                      XMN12490\n         SPACE 1                                                        XMN12500\nREADOPEN DS    0H                                                       XMN12510\n         TM    DCBDEVT,TAPEBITS    IS THE FILE ON MAGNETIC TAPE         XMN12520\n         DROP  3                                                        XMN12530\n         BO    READTP              YES, GO FORM RECORD INDEX FOR TAPE   XMN12540\n         SLA   PARM2,16            FORM  TTRZ  ADDRESS                  XMN12550\n         BNZ   RDN0                BLOCK ZERO IS A SPECIAL CASE         XMN12560\n         LA    PARM2,1             FUNNY ADDRESS FOR BLOCK ZERO         XMN12570\n         B     READTP              GO DO THE READ                       XMN12580\nRDN0     O     PARM2,TTRSET        SPECIFY LOGICAL RECORD 1             XMN12590\nREADTP   ST    PARM2,TTR           SAVE RECORD POINTER                  XMN12600\n         SPACE 1                                                        XMN12610\n         POINT (3),TTR             POINT AT THE RECORD TO BE READ       XMN12620\n         READ  RDECB,SF,(3),0,'S'  READ THE RECORD INTO CORE            XMN12630\n         CHECK RDECB               WAIT FOR THE READ TO COMPLETE        XMN12640\n         SPACE 1                                                        XMN12650\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN12660\n         EJECT                                                          XMN12670\n         SPACE 5                                                        XMN12680\n*********************************************************************** XMN12690\n*                                                                     * XMN12700\n*                                                                     * XMN12710\n*                                                                     * XMN12720\n*        WRITE ROUTINE FOR DIRECT ACCESS FILE I/O                     * XMN12730\n*                                                                     * XMN12740\n*                                                                     * XMN12750\n*        INPUT TO THIS ROUTINE IS:                                    * XMN12760\n*                                                                     * XMN12770\n*      PARM1   CORE ADDRESS TO READ THE RECORD FROM                   * XMN12780\n*                                                                     * XMN12790\n*      SVCODE  SERVICE CODE INDICATING WHICH FILE TO USE              * XMN12800\n*                                                                     * XMN12810\n*      PARM2   RELATIVE RECORD NUMBER   0,1,2, ...                    * XMN12820\n*                                                                     * XMN12830\n*                                                                     * XMN12840\n*                                                                     * XMN12850\n*********************************************************************** XMN12860\n         SPACE 2                                                        XMN12870\nWRITE    DS    0H                                                       XMN12880\n         ST    PARM1,WDECB+12      SAVE CORE ADDRESS                    XMN12890\n         L     3,ARWDCBS-FILEORG(SVCODE)                                XMN12900\n*                                  GET THE DCB ADDRESS                  XMN12910\n         USING IHADCB,3                                                 XMN12920\n         TM    DCBOFLGS,OPENBIT    IS THE FILE OPEN ?                   XMN12930\n         BO    WRTOPEN             YES, GO WRITE                        XMN12940\n         ST    3,OCDCB             STORE DCB ADDRESS FOR OPEN SVC       XMN12950\n         MVI   OCDCB,X'8F'         FLAG END OF ARGUMENT LIST AND        XMN12960\n*                                  INDICATE OPENING FOR OUTPUT          XMN12970\n         SPACE 1                                                        XMN12980\n         OPEN  ,MF=(E,OCDCB)       OPEN THE FILE                        XMN12990\n         SPACE 1                                                        XMN13000\n         TM    DCBOFLGS,OPENBIT    WAS THE OPEN SUCCESSFUL ?            XMN13010\n         BZ    FILESYND            NO,SYNAD ERROR                       XMN13020\n         SPACE 1                                                        XMN13030\nWRTOPEN  DS    0H                                                       XMN13040\n         TM    DCBDEVT,TAPEBITS    IS THE FILE ON MAGNETIC TAPE         XMN13050\n         DROP  3                                                        XMN13060\n         BO    WRITP               YES, GO FORM RECORD INDEX FOR TAPE   XMN13070\n         SLA   PARM2,16            FORM TTRZ ADDRESS FOR DIRECT ACCESS  XMN13080\n         BNZ   WRDN0               RECORD ZERO IS A SPECIAL CASE        XMN13090\n         LA    PARM2,1             FUNNY ADDRESS FOR RECORD ZERO        XMN13100\n         B     WRITP               GO DO THE WRITE                      XMN13110\nWRDN0    O     PARM2,TTRSET        OR IN RECORD NUMBER BIT              XMN13120\nWRITP    ST    PARM2,TTR           SAVE RECORD POINTER                  XMN13130\n         SPACE 1                                                        XMN13140\n         POINT (3),TTR             POINT AT THE DESIRED RECORD          XMN13150\n         WRITE WDECB,SF,(3),0,'S'  WRITE THE RECORD OUT                 XMN13160\n         CHECK WDECB               WAIT FOR THE WRITE TO FINISH         XMN13170\n         SPACE 1                                                        XMN13180\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN13190\n         EJECT                                                          XMN13640\n         SPACE 5                                                        XMN13650\n*********************************************************************** XMN13660\n*                                                                     * XMN13670\n*                                                                     * XMN13680\n*                                                                     * XMN13690\n*        TIME AND DATE FUNCTIONS                                      * XMN13700\n*                                                                     * XMN13710\n*                                                                     * XMN13720\n*        RETURNS TIME OF DAY IN HUNDREDTHS OF A SECOND IN REGISTER    * XMN13730\n*        PARM1  AND THE DATE IN THE FORM  YYDDD IN REGISTER SVCODE    * XMN13740\n*                                                                     * XMN13750\n*                                                                     * XMN13760\n*********************************************************************** XMN13770\n         SPACE 2                                                        XMN13780\nGETIME   TIME  BIN                 REQUEST THE TIME                     XMN13790\n         ST    0,SAVREG+PARM1*4    RETURN IN REGISTER PARM1             XMN13800\n         ST    1,DTSV+4            STORE THE DATE IN PACKED DECIMAL     XMN13810\n         CVB   1,DTSV              CONVERT IT TO BINARY                 XMN13820\n         ST    1,SAVREG+SVCODE*4   RETURN DATE IN REGISTER SVCODE       XMN13830\n         B     EXIT                RETURN TO THE XPL PROGRAM            XMN13840\n         EJECT                                                          XMN14160\n         SPACE 5                                                        XMN14170\n*********************************************************************** XMN14180\n*                                                                     * XMN14190\n*                                                                     * XMN14200\n*                                                                     * XMN14210\n*        DATA AREA FOR THE SUBMONITOR                                 * XMN14220\n*                                                                     * XMN14230\n*                                                                     * XMN14240\n*********************************************************************** XMN14250\n         SPACE 2                                                        XMN14260\n         DS    0F                                                       XMN14270\nASAVE    DC    A(SAVE)             ADDRESS OF OS SAVE AREA              XMN14280\nABASE1   DC    A(BASE1)            BASE ADDRESS FOR INITIALIZATION      XMN14290\nMAXCODE  DC    A(ENDSERV-4)        LARGEST VALID SERVICE CODE           XMN14300\nASMR     DC    A(SMRET)            ADDRESS OF SUBMONITOR RETURN TO OS   XMN14310\nRTNSV    DC    F'0'                SAVE COMPLETION CODE RETURNED        XMN14320\n*                                  BY THE XPL PROGRAM                   XMN14330\nABESAVE  DS    F                   SAVE ABEND CODE DURING CLOSE         XMN14340\nABEREGS  DS    3F                  SAVE PROGRAMS REGS 0-2 BEFORE ABEND  XMN14350\nTTR      DC    F'0'                TTRZ ADDRESS FOR READ AND WRITE      XMN14360\nTTRSET   DC    X'00000100'         ADDRESS CONSTANT FOR TTRZ            XMN14370\nFLAGS    DC    X'00'               SUBMONITOR CONTROL FLAGS             XMN14380\nSAVREG   DC    16F'0'              SAVE AREA FOR THE SUBMONITOR         XMN14390\n         DS    0D                                                       XMN14400\nDTSV     DC    PL8'0'              WORK AREA FOR CONVERTING DATE        XMN14410\n         SPACE 2                                                        XMN14490\n*********************************************************************** XMN14500\n*                                                                     * XMN14510\n*                                                                     * XMN14520\n*        DCB ADDRESS TABLE FOR ALL I/O ROUTINES                       * XMN14530\n*                                                                     * XMN14540\n*                                                                     * XMN14550\n*        THE FOUR SETS OF DCB ADDRESSES HEADED BY  'GETDCBS',         * XMN14560\n*        'PUTDCBS', 'ARWDCBS', AND 'PGMDCB' MUST BE CONTIGUOUS        * XMN14570\n*        AND END WITH 'PGMDCB'.  THESE LISTS ARE USED AT JOB END      * XMN14580\n*        TO CLOSE ALL FILES BEFORE RETURNING TO OS                    * XMN14590\n*                                                                     * XMN14600\n*                                                                     * XMN14610\n*        DCB ADDRESSES FOR INPUT FILES:                               * XMN14620\n*                                                                     * XMN14630\n*                                                                     * XMN14640\n*********************************************************************** XMN14650\n         SPACE 2                                                        XMN14660\n         PRINT NOGEN                                                    XMN14670\n         SPACE 1                                                        XMN14680\nGETDCBS  DS    0F                                                       XMN14690\n&I       SETA  0                                                        XMN14700\n.GD1     AIF   (&I GT &INPUTS).GD2                                      XMN14710\n         DC    A(INPUT&I)                                               XMN14720\n&I       SETA  &I+1                                                     XMN14730\n         AGO   .GD1                                                     XMN14740\n.GD2     ANOP                                                           XMN14750\n         SPACE 1                                                        XMN14760\n*********************************************************************** XMN14770\n*                                                                     * XMN14780\n*        DCB ADDRESSES FOR OUTPUT FILES                               * XMN14790\n*                                                                     * XMN14800\n*********************************************************************** XMN14810\n         SPACE 1                                                        XMN14820\nPUTDCBS  DS    0F                                                       XMN14830\n         SPACE 1                                                        XMN14840\n&I       SETA  0                                                        XMN14850\n.PD1     AIF   (&I GT &OUTPUTS).PD2                                     XMN14860\n         DC    A(OUTPUT&I)                                              XMN14870\n&I       SETA  &I+1                                                     XMN14880\n         AGO   .PD1                                                     XMN14890\n.PD2     ANOP                                                           XMN14900\n         SPACE 1                                                        XMN14910\n*********************************************************************** XMN14920\n*                                                                     * XMN14930\n*        DCB ADDRESS FOR DIRECT ACCESS FILES                          * XMN14940\n*                                                                     * XMN14950\n*********************************************************************** XMN14960\n         SPACE 1                                                        XMN14970\nARWDCBS  DS    0F                                                       XMN14980\n         SPACE 1                                                        XMN14990\n&I       SETA  1                                                        XMN15000\n.DA1     AIF   (&I GT &FILES).DA2                                       XMN15010\n         ORG   ARWDCBS+RD&I-FILEORG                                     XMN15020\n         DC    A(FILE&I.IN)                                             XMN15030\n         ORG   ARWDCBS+WRT&I-FILEORG                                    XMN15040\n         DC    A(FILE&I.OUT)                                            XMN15050\n&I       SETA  &I+1                                                     XMN15060\n         AGO   .DA1                                                     XMN15070\n.DA2     ANOP                                                           XMN15080\n         ORG   ARWDCBS+ENDSERV-FILEORG                                  XMN15090\n         DS    0F                                                       XMN15100\n         SPACE 2                                                        XMN15110\nPGMDCB   DC    X'80'               FLAG END OF PARAMETER LIST           XMN15120\n         DC    AL3(PROGRAM)        ADDRESS OF PROGRAM DCB               XMN15130\n         SPACE 2                                                        XMN15140\nOCDCB    DS    F                   DCB ADDRESSES FOR OPEN AND CLOSE     XMN15150\nMOVEADR  DS    1F                  DESCRIPTOR STORAGE FOR PUT ROUTINE   XMN15160\nFILLENG  DC    F'0'                LENGTH OF PADDING NEEDED IN OUTPUT   XMN15170\nF1       DC    F'1'                THE CONSTANT ONE                     XMN15180\nF2       DC    F'2'                THE CONSTANT TWO                     XMN15190\nGETMOVE  MVC   0(0,2),0(1)         MVC COMMAND FOR THE GET ROUTINE      XMN15200\nMVCNULL  MVC   1(0,1),0(1)         MVC COMMAND FOR THE PUT ROUTINE      XMN15210\nMVCBLANK MVC   2(0,1),1(1)             \"                                XMN15220\nMVCSTRNG MVC   0(0,1),0(2)             \"                                XMN15230\n         EJECT                                                          XMN15380\n         SPACE 5                                                        XMN15390\n*********************************************************************** XMN15400\n*                                                                     * XMN15410\n*                                                                     * XMN15420\n*                                                                     * XMN15430\n*        DEVICE  CONTROL  BLOCKS  FOR  THE  SUBMONITOR                * XMN15440\n*                                                                     * XMN15450\n*                                                                     * XMN15460\n*********************************************************************** XMN15470\n         SPACE 2                                                        XMN15480\nPROGRAM  DCB   DSORG=PS,                                               XXMN15490\n               MACRF=R,                                                XXMN15500\n               DDNAME=PROGRAM,                                         XXMN15510\n               DEVD=DA,                                                XXMN15520\n               KEYLEN=0,                                               XXMN15530\n               EODAD=EODPGM,                                           XXMN15540\n               SYNAD=ERRPGM                                             XMN15550\n         SPACE 2                                                        XMN15560\nINPUT0   DCB   DSORG=PS,                                               XXMN15570\n               DDNAME=SYSIN,                                           XXMN15580\n               DEVD=DA,                                                XXMN15590\n               MACRF=GL,                                               XXMN15600\n               BUFNO=3,                                                XXMN15610\n               EODAD=INEOD,                                            XXMN15620\n               SYNAD=INSYNAD,                                          XXMN15630\n               EXLST=INEXIT0,                                          XXMN15640\n               EROPT=ACC                                                XMN15650\n         SPACE 1                                                        XMN15660\n*********************************************************************** XMN15670\n*                                                                     * XMN15680\nINPUT1   EQU   INPUT0              INPUT(0) & INPUT(1) ARE BOTH SYSIN * XMN15690\n*                                                                     * XMN15700\n*********************************************************************** XMN15710\n         SPACE 2                                                        XMN15720\n&I       SETA  2                                                        XMN15730\n.INP1    AIF   (&I GT &INPUTS).INP2                                     XMN15740\n         SPACE 1                                                        XMN15750\nINPUT&I  DCB   DSORG=PS,                                               XXMN15760\n               DDNAME=INPUT&I,                                         XXMN15770\n               DEVD=DA,                                                XXMN15780\n               MACRF=GL,                                               XXMN15790\n               EODAD=INEOD,                                            XXMN15800\n               SYNAD=INSYNAD,                                          XXMN15810\n               EXLST=INEXIT&I,                                         XXMN15820\n               EROPT=ACC                                                XMN15830\n         SPACE 1                                                        XMN15840\n&I       SETA  &I+1                                                     XMN15850\n         AGO   .INP1                                                    XMN15860\n.INP2    ANOP                                                           XMN15870\n         SPACE 2                                                        XMN15880\nOUTPUT0  DCB   DSORG=PS,                                               XXMN15890\n               DDNAME=SYSPRINT,                                        XXMN15900\n               DEVD=DA,                                                XXMN15910\n               MACRF=PL,                                               XXMN15920\n               SYNAD=OUTSYNAD,                                         XXMN15930\n               EXLST=OUTEXIT0,                                         XXMN15940\n               EROPT=ACC                                                XMN15950\n         SPACE 1                                                        XMN15960\n*********************************************************************** XMN15970\n*                                                                     * XMN15980\nOUTPUT1  EQU   OUTPUT0             OUTPUT(0), OUTPUT(1) BOTH SYSPRINT * XMN15990\n*                                                                     * XMN16000\n*********************************************************************** XMN16010\n         SPACE 2                                                        XMN16020\nOUTPUT2  DCB   DSORG=PS,                                               XXMN16030\n               DDNAME=SYSPUNCH,                                        XXMN16040\n               DEVD=DA,                                                XXMN16050\n               MACRF=PL,                                               XXMN16060\n               SYNAD=OUTSYNAD,                                         XXMN16070\n               EXLST=OUTEXIT2,                                         XXMN16080\n               EROPT=ACC                                                XMN16090\n         SPACE 1                                                        XMN16100\n&I       SETA  3                                                        XMN16110\n.OP1     AIF   (&I GT &OUTPUTS).OP2                                     XMN16120\n         SPACE 1                                                        XMN16130\nOUTPUT&I DCB   DSORG=PS,                                               XXMN16140\n               DDNAME=OUTPUT&I,                                        XXMN16150\n               DEVD=DA,                                                XXMN16160\n               MACRF=PL,                                               XXMN16170\n               SYNAD=OUTSYNAD,                                         XXMN16180\n               EXLST=OUTEXIT&I,                                        XXMN16190\n               EROPT=ACC                                                XMN16200\n         SPACE 1                                                        XMN16210\n&I       SETA  &I+1                                                     XMN16220\n         AGO   .OP1                                                     XMN16230\n.OP2     ANOP                                                           XMN16240\n         SPACE 1                                                        XMN16250\n*********************************************************************** XMN16260\n*                                                                     * XMN16270\n*                                                                     * XMN16280\n*        DCBS FOR THE DIRECT ACCESS FILES                             * XMN16290\n*                                                                     * XMN16300\n*                                                                     * XMN16310\n*        BECAUSE OF THE MANNER IN WHICH THE FILES ARE USED,  IT IS    * XMN16320\n*        NECESSARY TO HAVE TWO DCB'S FOR EACH FILE.  ONE DCB FOR      * XMN16330\n*        READING AND ONE FOR WRITING.                                 * XMN16340\n*                                                                     * XMN16350\n*                                                                     * XMN16360\n*********************************************************************** XMN16370\n         SPACE 2                                                        XMN16380\n&I       SETA  1                                                        XMN16390\n.DD1     AIF   (&I GT &FILES).DD2                                       XMN16400\n         SPACE 1                                                        XMN16410\nFILE&I.IN DCB  DSORG=PS,                                               XXMN16420\n               MACRF=RP,                                               XXMN16430\n               DDNAME=FILE&I,                                          XXMN16440\n               DEVD=DA,                                                XXMN16450\n               RECFM=F,                                                XXMN16460\n               LRECL=FILEBYTS,                                         XXMN16470\n               BLKSIZE=FILEBYTS,                                       XXMN16480\n               KEYLEN=0,                                               XXMN16490\n               EODAD=FILEEOD,                                          XXMN16500\n               SYNAD=FILESYND                                           XMN16510\n         SPACE 2                                                        XMN16520\nFILE&I.OUT DCB DSORG=PS,                                               XXMN16530\n               MACRF=WP,                                               XXMN16540\n               DDNAME=FILE&I,                                          XXMN16550\n               DEVD=DA,                                                XXMN16560\n               RECFM=F,                                                XXMN16570\n               KEYLEN=0,                                               XXMN16580\n               LRECL=FILEBYTS,                                         XXMN16590\n               BLKSIZE=FILEBYTS,                                       XXMN16600\n               SYNAD=FILESYND                                           XMN16610\n         SPACE 1                                                        XMN16620\n&I       SETA  &I+1                                                     XMN16630\n         AGO   .DD1                                                     XMN16640\n.DD2     ANOP                                                           XMN16650\n         SPACE 4                                                        XMN16660\nXPLSMEND DS    0H                  END  OF  THE  SUBMONITOR             XMN16670\n         EJECT                                                          XMN16680\n         SPACE 5                                                        XMN16690\n*********************************************************************** XMN16700\n*                                                                     * XMN16710\n*                                                                     * XMN16720\n*                                                                     * XMN16730\n*        DSECT WHICH DEFINES THE FORMAT OF BINARY PROGRAM CONTROL     * XMN16740\n*        INFORMATION AND THE STARTING POINT FOR PROGRAMS              * XMN16750\n*                                                                     * XMN16760\n*                                                                     * XMN16770\n*********************************************************************** XMN16780\n         SPACE 2                                                        XMN16790\nFILECTRL DSECT                                                          XMN16800\n         SPACE 1                                                        XMN16810\nBYTSCODE DS    1F                  NUMBER OF BYTES OF CODE              XMN16820\n         SPACE 1                                                        XMN16830\nBYTSDATA DS    1F                  NUMBER OF BYTES OF DATA AREA         XMN16840\n         SPACE 1                                                        XMN16850\nBLKSCODE DS    1F                  NUMBER OF RECORDS OF CODE            XMN16860\n         SPACE 1                                                        XMN16870\nBLKSDATA DS    1F                  NUMBER OF RECORDS OF DATA AREA       XMN16880\n         SPACE 1                                                        XMN16890\nBYTSBLK  DS    1F                  BLOCKSIZE OF THE XPL PROGRAM FILE    XMN16900\n         SPACE 1                                                        XMN16910\nBYTSFULL DS    1F                  NUMBER OF BYTES OF CODE ACTUALLY     XMN16920\n*                                  USED IN THE LAST RECORD OF CODE      XMN16930\n         SPACE 1                                                        XMN16940\nDATABYTS DS    1F                  NUMBER OF BYTES OF DATA ACTUALLY     XMN16950\n*                                  USED IN THE LAST RECORD OF DATA      XMN16960\n         SPACE 1                                                        XMN16970\n         ORG   FILECTRL+60         REMAINDER OF THE CONTROL BLOCK       XMN16980\n*                                  IS UNUSED                            XMN16990\n         SPACE 1                                                        XMN17000\nCODEBEGN DS    0H                  FIRST EXECUTABLE INSTRUCTION         XMN17010\n*                                  IN THE XPL PROGRAM                   XMN17020\n         EJECT                                                          XMN17030\n         SPACE 5                                                        XMN17040\n*********************************************************************** XMN17050\n*                                                                     * XMN17060\n*                                                                     * XMN17070\n*        DUMMY  DCB  FOR  DEFINING  DCB  FIELDS                       * XMN17080\n*                                                                     * XMN17090\n*                                                                     * XMN17100\n*********************************************************************** XMN17110\n         SPACE 2                                                        XMN17120\n         DCBD  DSORG=QS,DEVD=DA                                         XMN17130\n         EJECT                                                          XMN17140\n         SPACE 5                                                        XMN17150\n*********************************************************************** XMN17160\n*                                                                     * XMN17170\n*                                                                     * XMN17180\n*        THE  END                                                     * XMN17190\n*                                                                     * XMN17200\n*                                                                     * XMN17210\n*********************************************************************** XMN17220\n         SPACE 5                                                        XMN17230\n         END                                                            XMN17240\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE15": {"ttr": 12038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x05\\xfa\\x05\\xfa\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 1530, "newlines": 1530, "modlines": 0, "user": "SPASCAL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FILE16": {"ttr": 12554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x11/\\x11/\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 4399, "newlines": 4399, "modlines": 0, "user": "SPASCAL"}, "text": "   /*  FIRST WE INITIALIZE THE GLOBAL CONSTANTS THAT DEPEND UPON THE INPUT\n      GRAMMAR.  THE FOLLOWING CARDS ARE PUNCHED BY THE SYNTAX PRE-PROCESSOR  */\n\n   /*  XPL PARSING TABLES  */\n\n   DECLARE MAXTL LITERALLY '12' ;\n   DECLARE MAXNTL LITERALLY '26' ;\n   DECLARE STARTSTATE LITERALLY '112' ;\n   DECLARE NT LITERALLY '42' ;\n   DECLARE NSY LITERALLY '92' ;\n   DECLARE NSTATES LITERALLY '228' ;\n   DECLARE V(92) CHARACTER INITIAL ( '< DUMMY >', '<', '(', '+', '|',\n      '&', '*', ')', ';', '\u00ac', '-', '/', ',', '>', ':', '=', '||',\n      'BY', 'DO', 'GO', 'IF', 'TO', 'BIT', 'END', 'EOF', 'MOD', 'CALL',\n      'CASE', 'ELSE', 'GOTO', 'THEN', 'FIXED', 'LABEL', 'WHILE',\n      'RETURN', 'DECLARE', 'INITIAL', '<NUMBER>', '<STRING>',\n      'CHARACTER', 'LITERALLY', 'PROCEDURE', '<IDENTIFIER>', '<TERM>',\n      '<TYPE>', '<GO TO>', '<GROUP>', '<ENDING>', '< START >',\n      '<PRIMARY>', '<PROGRAM>', '<REPLACE>', '<BIT HEAD>',\n      '<CONSTANT>', '<RELATION>', '<VARIABLE>', '<IF CLAUSE>',\n      '<LEFT PART>', '<STATEMENT>', '<TRUE PART>', '<ASSIGNMENT>',\n      '<BOUND HEAD>', '<EXPRESSION>', '<GROUP HEAD>', '<IF STATEMENT>',\n      '<INITIAL HEAD>', '<INITIAL LIST>', '<WHILE CLAUSE>',\n      '<CASE SELECTOR>', '<CALL STATEMENT>', '<LOGICAL FACTOR>',\n      '<PARAMETER HEAD>', '<PARAMETER LIST>', '<PROCEDURE HEAD>',\n      '<PROCEDURE NAME>', '<STATEMENT LIST>', '<SUBSCRIPT HEAD>',\n      '<BASIC STATEMENT>', '<GO TO STATEMENT>', '<IDENTIFIER LIST>',\n      '<LOGICAL PRIMARY>', '<STEP DEFINITION>', '<LABEL DEFINITION>',\n      '<RETURN STATEMENT>', '<TYPE DECLARATION>',\n      '<ITERATION CONTROL>', '<LOGICAL SECONDARY>',\n      '<STRING EXPRESSION>', '<DECLARATION ELEMENT>',\n      '<PROCEDURE DEFINITION>', '<ARITHMETIC EXPRESSION>',\n      '<DECLARATION STATEMENT>', '<IDENTIFIER SPECIFICATION>') ;\n   DECLARE VT_INDEX(13) BIT(8) INITIAL (0,  1, 16, 22, 26, 31, 34, 35,\n      37, 39, 42, 42, 42, 43) ;\n   DECLARE STATESTART(228) BIT(16) INITIAL (0,   1,   1,   2,   1,   1,\n        2,   2,   2,   2,   2,   2,   2,   1,   2,   2,   3,   2,   3,\n        2,   2,   2,   3,   3,   3,   2,   4,   2,   4,   2,   2,   3,\n        2,   3,   3,   4,   2,   3,   1,   3,   1,   2,   2,   2,   1,\n        2,   2,   2,   2,   1,   2,   3,   1,   3,   2,   4,   2,   1,\n        1,   1,   3,   2,   2,   1,   3,   1,   3,   3,   2,   3,   3,\n        2,   1,   2,   1,   3,   1,   3,   1,   2,   1,   3,   1,   1,\n        1,   2,   2,   2,   2,   2,   1,   3,   1,   3,   3,   2,   2,\n        1,   3,   3,   3,   1,   1,   3,   1,   3,   2,   3,   1,   1,\n        3,   1,   2,  32, 351, 352, 372,   1, 394,   2, 435, 436, 437,\n      438, 460, 489, 522, 523, 554, 555, 584,   3,  98, 636, 678, 667,\n      668, 669,  41, 267,   4, 286, 348, 349, 350,  59,  77, 116, 130,\n        5,   6,   7,   8,   9, 264,  10,  90, 142, 150, 226,  11,  12,\n      168,  13, 172, 210,  14, 186, 198,  15,  16,  17, 229,  18, 247,\n       19, 288, 306, 309,  20, 329,  21, 370,  22,  23, 403, 414,  24,\n      426, 402, 404, 405, 411, 412, 413, 415, 420, 421, 424, 441,  25,\n      494,  26,  27, 637, 606, 594, 595, 598, 596, 605, 671, 375, 433,\n      707,  86, 158, 266, 263, 161, 224, 167, 171, 223, 327, 401, 417,\n      706, 553) ;\n   DECLARE STATEMIDDLE(228) BIT(16) INITIAL (0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   2,  11,  36, 352, 359, 373,   0, 396,   0, 436, 437,\n      438, 440, 469, 490, 523, 533, 555, 564, 590,   0, 105, 637, 688,\n      668, 669, 671,  48, 274,   0, 287, 349, 350, 351,  66,  81, 122,\n      134,   0,   0,   0,   0,   0, 266,   0,  94, 146, 154, 229,   0,\n        0, 171,   0, 178, 216,   0, 190, 202,   0,   0,   0, 236,   0,\n      254,   0, 295, 308, 316,   0, 336,   0, 372,   0,   0, 404, 415,\n        0, 431, 403, 405, 409, 412, 413, 414, 417, 421, 423, 426, 448,\n        0, 503,   0,   0, 648, 616, 595, 596, 603, 598, 606, 673, 382,\n      435, 716,  87, 161, 267, 264, 166, 226, 168, 172, 224, 329, 402,\n      418, 707, 554) ;\n   DECLARE STATEEND(228) BIT(16) INITIAL (0,  50,  75,  75,  58,  58,\n       77,  77,  77,  77,  77,  77,  77,  77,  77,  64,  64,  64,  56,\n       59,  46,  63,  63,  63,  63,  63,  81,  85,  85,  67,  68,  89,\n       73,  73,  73,  73,  74,  72,  71,  71,  47,  47,  47,  82,  83,\n       83,  69,  78,  45,  45,  91,  91,  88,  88,  84,  84,  84,  44,\n       44,  44,  44,  52,  61,  92,  92,  79,  79,  66,  65,  65,  60,\n       60,  51,  57,  62,  62,  70,  70,  86,  86,  80,  80,  54,  54,\n       54,  54,  54,  54,  54,  54,  87,  87,  90,  90,  90,  90,  90,\n       43,  43,  43,  43,  49,  49,  49,  55,  55,  76,  76,  53,  53,\n       48,   1,  31,  40, 351, 369, 374, 212, 400, 213, 435, 436, 437,\n      440, 488, 493, 522, 552, 554, 583, 593, 214, 115, 636, 705, 667,\n      668, 670,  58, 284, 215, 287, 348, 349, 350,  76,  85, 129, 138,\n      216, 217, 218, 219, 220, 265, 216,  97, 149, 157, 228, 216, 221,\n      170, 222, 183, 222, 220, 194, 206, 216, 216, 223, 245, 218, 262,\n      217, 305, 308, 326, 224, 346, 217, 371, 217, 225, 403, 414, 226,\n      432, 402, 404, 410, 411, 412, 413, 416, 420, 423, 425, 458, 217,\n      521, 227, 228, 666, 635, 594, 595, 604, 597, 605, 677, 392, 434,\n      734,  86, 160, 266, 263, 166, 225, 167, 171, 223, 328, 401, 419,\n      706, 553) ;\n   DECLARE STATETOKEN(228) BIT(8) INITIAL (0, 75, 58, 58, 77, 64,  8,\n       8,  8,  8,  8,  8,  8,  8, 77, 58, 58, 64, 30, 28, 47,  8,  8,\n       8,  8, 58, 85, 62, 62, 62, 62, 47,  8,  8,  8,  8, 41,  7,  2,\n      12, 23, 42, 47, 14, 34, 62, 55, 42, 21, 29, 88, 88, 84, 38, 44,\n      44, 66, 31, 39, 32,  7,  2,  2, 42,  7,  2, 12,  7,  2, 12, 62,\n      60, 15, 12, 70, 70, 86, 86, 80, 80, 87, 87, 15,  1, 13, 15,  1,\n      13, 15, 15, 90, 90, 43, 43, 43, 43, 43, 49, 49, 49, 49, 53, 55,\n       7, 42,  7,  2, 12, 38, 37, 24,  0, 24, 18, 19, 20, 26, 34, 35,\n      42, 45, 46, 50, 55, 56, 57, 60, 63, 69, 73, 74, 75, 76, 78, 82,\n      83, 89, 91, 27, 33, 42, 55, 67, 68, 81,  2,  3,  9, 10, 43, 62,\n      70, 87, 90, 62, 43,  6, 11, 25, 62, 43,  1,  9, 13, 16, 54, 90,\n       3, 10, 43, 43, 87,  4, 70,  5, 62, 51, 62, 21, 62, 17, 62, 62,\n      62, 42, 61, 79, 84, 92, 40, 37,  7, 22, 52, 37, 42, 36, 65, 53,\n      51, 62, 59, 77, 23, 82, 75, 44, 71, 72, 42, 44, 12, 34, 42, 75,\n      42, 43, 62, 70, 87, 90,  1, 13, 87, 62, 42, 84, 77, 23) ;\n   DECLARE STATETYPE(57) BIT(8) INITIAL (\"(2)0111\", \"(2)1111\",\n      \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\",\n      \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\",\n      \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\",\n      \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\",\n      \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\", \"(2)1111\",\n      \"(2)1102\", \"(2)2222\", \"(2)2323\", \"(2)2222\", \"(2)2222\",\n      \"(2)2223\", \"(2)2222\", \"(2)2222\", \"(2)3222\", \"(2)2222\",\n      \"(2)2333\", \"(2)3323\", \"(2)2222\", \"(2)3323\", \"(2)2232\",\n      \"(2)2333\", \"(2)2323\", \"(2)2223\", \"(2)2323\", \"(2)3223\",\n      \"(2)2222\", \"(2)2222\", \"(2)2222\", \"(2)3233\", \"(2)2222\",\n      \"(2)2222\", \"(2)2222\", \"(2)2222\", \"(2)2222\", \"(2)2222\",\n      \"(2)2000\") ;\n   DECLARE SCANTOKENS(734) BIT(8) INITIAL (0, 24,  8, 18, 19, 20, 26,\n      29, 34, 35, 42, 45, 46, 50, 55, 56, 57, 58, 60, 63, 64, 69, 73,\n      74, 75, 76, 77, 78, 82, 83, 89, 91,  8, 27, 33, 42, 55, 67, 68,\n      76, 81,  2,  3,  9, 10, 37, 38, 42, 43, 49, 53, 55, 62, 70, 76,\n      80, 86, 87, 90,  2,  3,  9, 10, 37, 38, 42, 43, 49, 53, 55, 62,\n      70, 76, 80, 86, 87, 90,  2, 37, 38, 42, 43, 49, 53, 55, 76,  2,\n       6, 11, 25,  2, 37, 38, 42, 49, 53, 55, 76,  2,  3,  9, 10, 37,\n      38, 42, 43, 49, 53, 55, 62, 70, 76, 80, 86, 87, 90,  2,  3, 10,\n      37, 38, 42, 43, 49, 53, 55, 76, 80, 87, 90,  2, 37, 38, 42, 43,\n      49, 53, 55, 76,  6, 11, 25,  2, 37, 38, 42, 49, 53, 55, 76,  2,\n      37, 38, 42, 49, 53, 55, 76,  6, 11, 25,  1,  9, 13, 15, 16, 54,\n      15,  1, 13, 15, 15,  2,  3, 10, 37, 38, 42, 43, 49, 53, 55, 76,\n      90,  3, 10,  2, 37, 38, 42, 43, 49, 53, 55, 76,  6, 11, 25,  2,\n      37, 38, 42, 43, 49, 53, 55, 76,  6, 11, 25,  2,  3, 10, 37, 38,\n      42, 43, 49, 53, 55, 76, 87, 90, 16,  3, 10,  4,  7, 12,  2,  3,\n       9, 10, 37, 38, 42, 43, 49, 53, 55, 70, 76, 80, 86, 87, 90,  5,\n       2,  3,  9, 10, 37, 38, 42, 43, 49, 53, 55, 76, 80, 86, 87, 90,\n       5,  4,  7,  4,  2,  3,  9, 10, 37, 38, 42, 43, 49, 53, 55, 62,\n      70, 76, 80, 86, 87, 90,  4, 15, 51,  2,  3,  9, 10, 37, 38, 42,\n      43, 49, 53, 55, 62, 70, 76, 80, 86, 87, 90,  4, 21, 85,  2,  3,\n       9, 10, 37, 38, 42, 43, 49, 53, 55, 62, 70, 76, 80, 86, 87, 90,\n       4, 17,  2,  3,  9, 10, 37, 38, 42, 43, 49, 53, 55, 62, 70, 76,\n      80, 86, 87, 90,  4,  8,  8,  8, 21,  2,  3,  9, 10, 37, 38, 42,\n      43, 49, 53, 55, 62, 70, 76, 80, 86, 87, 90,  4, 30, 42, 55, 76,\n       2,  3,  9, 10, 37, 38, 42, 43, 49, 53, 55, 62, 70, 76, 80, 86,\n      87, 90,  4,  2, 42, 61, 79, 84, 88, 92, 40, 38, 37,  7, 22, 31,\n      32, 39, 44, 52,  2, 37,  7, 42,  7, 12, 36, 65, 66,  2, 37, 38,\n      53,  7, 12,  2, 22, 31, 32, 39, 44, 52,  2, 14, 42,  8, 24, 12,\n      15, 51,  2,  3,  9, 10, 37, 38, 42, 43, 49, 53, 55, 62, 70, 76,\n      80, 86, 87, 90,  4,  8, 18, 19, 20, 26, 29, 34, 35, 42, 45, 46,\n      55, 56, 57, 58, 59, 60, 63, 64, 69, 73, 74, 76, 77, 78, 82, 83,\n      89, 91, 42, 55, 57, 60, 76,  8, 18, 19, 20, 26, 29, 34, 35, 42,\n      45, 46, 55, 56, 57, 58, 60, 63, 64, 69, 73, 74, 76, 77, 78, 82,\n      83, 89, 91,  8,  8, 18, 19, 20, 23, 26, 29, 34, 35, 42, 45, 46,\n      47, 55, 56, 57, 58, 60, 63, 64, 69, 73, 74, 76, 77, 78, 82, 83,\n      89, 91, 42,  8,  8, 18, 19, 20, 26, 29, 34, 35, 42, 45, 46, 55,\n      56, 57, 58, 60, 63, 64, 69, 73, 74, 75, 76, 77, 78, 82, 83, 89,\n      91,  2,  8, 22, 31, 32, 39, 44, 52, 71, 72,  8, 42,  7, 12,  8,\n      22, 31, 32, 39, 44, 52,  8,  8, 18, 19, 20, 23, 26, 29, 34, 35,\n      42, 45, 46, 47, 55, 56, 57, 58, 60, 63, 64, 69, 73, 74, 76, 77,\n      78, 82, 83, 89, 91,  8,  8, 18, 19, 20, 23, 26, 29, 34, 35, 41,\n      42, 45, 46, 47, 55, 56, 57, 60, 63, 64, 69, 73, 74, 76, 77, 78,\n      82, 83, 89, 91,  8,  8,  8, 12,  2, 42, 61, 79, 84, 88, 92,  8,\n      18, 19, 20, 26, 29, 34, 35, 41, 42, 45, 46, 55, 56, 57, 60, 63,\n      64, 69, 73, 74, 76, 77, 78, 82, 83, 89, 91, 28,  8, 18, 19, 20,\n      26, 29, 34, 35, 42, 45, 46, 55, 56, 57, 58, 60, 63, 64, 69, 73,\n      74, 76, 77, 78, 82, 83, 89, 91) ;\n   DECLARE SCANGOTOS(734) BIT(8) INITIAL (0, 112,  13, 113, 114, 115,\n      116,  49, 117, 118, 119, 120, 121, 122, 123, 124, 125,   2, 126,\n      127,   5, 128, 129, 130, 131, 132,   4, 133, 134, 135, 136, 137,\n       21, 138, 139, 140, 141, 142, 143, 132, 144, 145, 146, 147, 148,\n      109, 108, 140, 149,  97, 101, 102, 150, 151, 132,  78,  76, 152,\n      153, 145, 146, 147, 148, 109, 108, 140, 149,  97, 101, 102, 154,\n      151, 132,  78,  76, 152, 153, 145, 109, 108, 140, 155,  97, 101,\n      102, 132, 106, 156, 157, 158, 145, 109, 108, 140,  98, 101, 102,\n      132, 145, 146, 147, 148, 109, 108, 140, 149,  97, 101, 102, 159,\n      151, 132,  78,  76, 152, 153, 145, 146, 148, 109, 108, 140, 149,\n       97, 101, 102, 132,  79, 152, 153, 145, 109, 108, 140, 160,  97,\n      101, 102, 132, 156, 157, 158, 145, 109, 108, 140,  99, 101, 102,\n      132, 145, 109, 108, 140, 100, 101, 102, 132, 156, 157, 158, 161,\n      162, 163,  82, 164, 165,  88,  86,  87,  85,  89, 145, 146, 148,\n      109, 108, 140, 149,  97, 101, 102, 132, 166, 167, 168, 145, 109,\n      108, 140, 169,  97, 101, 102, 132, 156, 157, 158, 145, 109, 108,\n      140, 170,  97, 101, 102, 132, 156, 157, 158, 145, 146, 148, 109,\n      108, 140, 149,  97, 101, 102, 132, 171, 153, 164, 167, 168, 172,\n      105, 107, 145, 146, 147, 148, 109, 108, 140, 149,  97, 101, 102,\n      173, 132,  78,  76, 152, 153, 174, 145, 146, 147, 148, 109, 108,\n      140, 149,  97, 101, 102, 132,  78,  77, 152, 153, 174, 172, 103,\n      172, 145, 146, 147, 148, 109, 108, 140, 149,  97, 101, 102, 175,\n      151, 132,  78,  76, 152, 153, 172,  72, 176, 145, 146, 147, 148,\n      109, 108, 140, 149,  97, 101, 102, 177, 151, 132,  78,  76, 152,\n      153, 172, 178,  26, 145, 146, 147, 148, 109, 108, 140, 149,  97,\n      101, 102, 179, 151, 132,  78,  76, 152, 153, 172, 180, 145, 146,\n      147, 148, 109, 108, 140, 149,  97, 101, 102, 181, 151, 132,  78,\n       76, 152, 153, 172,  23,  24,  22,  48, 145, 146, 147, 148, 109,\n      108, 140, 149,  97, 101, 102, 182, 151, 132,  78,  76, 152, 153,\n      172,  18, 140,  46, 132, 145, 146, 147, 148, 109, 108, 140, 149,\n       97, 101, 102, 183, 151, 132,  78,  76, 152, 153, 172,  65, 184,\n      185, 186, 187,  50, 188, 189,  53, 190, 191, 192,  57,  59,  58,\n       55, 193,  61, 194,  60, 195,  64,  66, 196, 197,  56,  68, 109,\n      108, 198,  67,  69,  62, 192,  57,  59,  58,  54, 193, 106,  43,\n       47,   7, 110,  73,  72, 199, 145, 146, 147, 148, 109, 108, 140,\n      149,  97, 101, 102, 200, 151, 132,  78,  76, 152, 153, 172,  13,\n      113, 114, 115, 116,  49, 117, 118, 119, 120, 121, 123, 124, 125,\n       15, 201, 126, 127,   5, 128, 129, 130, 132, 202, 133, 134, 135,\n      136, 137, 140, 123, 125,  71, 132,  13, 113, 114, 115, 116,  49,\n      117, 118, 119, 120, 121, 123, 124, 125,  16, 126, 127,   5, 128,\n      129, 130, 132,   4, 133, 134, 135, 136, 137,   6,  13, 113, 114,\n      115, 203, 116,  49, 117, 118, 119, 120, 121,  20, 123, 124, 125,\n       25, 126, 127,   5, 128, 129, 130, 132,   4, 133, 204, 135, 136,\n      137,  41,  10,  13, 113, 114, 115, 116,  49, 117, 118, 119, 120,\n      121, 123, 124, 125,   2, 126, 127,   5, 128, 129, 130, 205, 132,\n        4, 133, 134, 135, 136, 137,  38,  32, 192,  57,  59,  58, 206,\n      193, 207, 208,  33, 209,  37,  39,  34, 192,  57,  59,  58, 210,\n      193,  35,  13, 113, 114, 115, 203, 116,  49, 117, 118, 119, 120,\n      121,  31, 123, 124, 125,   3, 126, 127,   5, 128, 129, 130, 132,\n        4, 133, 204, 135, 136, 137,  11,  13, 113, 114, 115, 203, 116,\n       49, 117, 118,  36, 119, 120, 121,  42, 123, 124, 125, 126, 127,\n       17, 128, 129, 130, 132,  14, 133, 204, 135, 136, 137,   9,   8,\n       12, 211,  65, 184, 185, 186, 187,  51, 188,  13, 113, 114, 115,\n      116,  49, 117, 118,  36, 119, 120, 121, 123, 124, 125, 126, 127,\n       17, 128, 129, 130, 132,  14, 133, 134, 135, 136, 137,  19,  13,\n      113, 114, 115, 116,  49, 117, 118, 119, 120, 121, 123, 124, 125,\n        3, 126, 127,   5, 128, 129, 130, 132,   4, 133, 134, 135, 136,\n      137) ;\n   DECLARE LASTART(28) BIT(16) INITIAL (0,   1,   9,  29,  39,  58,\n       76,  78,  86,  99, 114, 132, 150, 157, 164, 179, 197, 215, 224,\n      232, 234, 237, 239, 241, 247, 250, 252, 264, 266) ;\n   DECLARE LATOKENS(265) BIT(8) INITIAL (0,  2,  3,  8,  9, 10, 37, 38\n      , 42,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15\n      , 16, 17, 21, 25, 30,  8, 18, 19, 20, 24, 26, 29, 34, 35, 42,  1\n      ,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 15, 16, 17, 21\n      , 25, 30,  1,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 15, 16\n      , 17, 21, 25, 30,  4,  8,  4,  5,  7,  8, 12, 17, 21, 30,  1,  4\n      ,  5,  7,  8,  9, 12, 13, 15, 16, 17, 21, 30,  1,  3,  4,  5,  7\n      ,  8,  9, 10, 12, 13, 15, 16, 17, 21, 30,  1,  3,  4,  5,  6,  7\n      ,  8,  9, 10, 11, 12, 13, 15, 16, 17, 21, 25, 30,  1,  3,  4,  5\n      ,  6,  7,  8,  9, 10, 11, 12, 13, 15, 16, 17, 21, 25, 30,  2,  3\n      , 10, 15, 37, 38, 42,  2,  3, 10, 15, 37, 38, 42,  1,  3,  4,  5\n      ,  7,  8,  9, 10, 12, 13, 15, 16, 17, 21, 30,  1,  3,  4,  5,  6\n      ,  7,  8,  9, 10, 11, 12, 13, 15, 16, 17, 21, 25, 30,  1,  3,  4\n      ,  5,  6,  7,  8,  9, 10, 11, 12, 13, 15, 16, 17, 21, 25, 30,  4\n      ,  5,  7,  8, 12, 16, 17, 21, 30,  4,  5,  7,  8, 12, 17, 21, 30\n      ,  4,  8,  4,  8, 17,  4,  8,  4,  8,  2, 22, 31, 32, 39, 40,  8\n      , 12, 36,  4,  8,  8, 18, 19, 20, 23, 24, 26, 28, 29, 34, 35, 42\n      ,  8, 42) ;\n   DECLARE LAGOTOS(265) BIT(8) INITIAL (0, 212, 212,  44, 212, 212\n      , 212, 212, 212, 104, 213, 104, 104, 104, 104, 104, 104, 104\n      , 104, 104, 104, 104, 213, 104, 104, 104, 104, 104, 104, 214\n      , 214, 214, 214,   1, 214, 214, 214, 214, 214, 104, 215, 104\n      , 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104\n      , 104, 104, 104, 104,  92,  92,  92,  92, 216,  92,  92,  92\n      ,  92, 216,  92,  92,  92,  92,  92,  92, 216,  92, 217,  30\n      ,  74, 218,  74,  74,  74,  74,  74,  74, 219,  80,  80,  80\n      ,  80, 219,  80, 219, 219, 219,  80,  80,  80,  90, 220,  90\n      ,  90,  90,  90,  90, 220,  90,  90,  90,  90,  90,  90,  90\n      ,  95,  95,  95,  95, 216,  95,  95,  95,  95, 216,  95,  95\n      ,  95,  95,  95,  95, 216,  95,  96,  96,  96,  96, 216,  96\n      ,  96,  96,  96, 216,  96,  96,  96,  96,  96,  96, 216,  96\n      ,  83,  83,  83, 221,  83,  83,  83,  84,  84,  84, 222,  84\n      ,  84,  84,  91, 220,  91,  91,  91,  91,  91, 220,  91,  91\n      ,  91,  91,  91,  91,  91,  93,  93,  93,  93, 216,  93,  93\n      ,  93,  93, 216,  93,  93,  93,  93,  93,  93, 216,  93,  94\n      ,  94,  94,  94, 216,  94,  94,  94,  94, 216,  94,  94,  94\n      ,  94,  94,  94, 216,  94,  81,  81,  81,  81,  81, 223,  81\n      ,  81,  81,  75, 218,  75,  75,  75,  75,  75,  75, 217,  29\n      , 224,  27, 224, 217,  28, 217,  45,  63,  63,  63,  63,  63\n      , 225,  52,  52, 226, 217,  70,   4,   4,   4,   4,   4,   4\n      ,   4, 227,   4,   4,   4,   4,  40, 228) ;\n\n\n    DECLARE (GROUPHEAD,PROCHEAD) FIXED;\n   /*  DECLARATIONS FOR THE SCANNER                                        */\n\n   /* TOKEN IS THE INDEX INTO THE VOCABULARY V() OF THE LAST SYMBOL SCANNED,\n      CH IS THE LAST CHARACTER SCANNED (HEX CODE),\n      CP IS THE POINTER TO THE LAST CHARACTER SCANNED IN THE CARDIMAGE,\n      BCD IS THE LAST SYMBOL SCANNED (LITERAL CHARACTER STRING). */\n   DECLARE (TOKEN, CH, CP) FIXED, BCD CHARACTER;\n\n   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */\n   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1) = PAGE',\n      PAGE CHARACTER INITIAL ('1'), DOUBLE CHARACTER INITIAL ('0'),\n      DOUBLE_SPACE LITERALLY 'OUTPUT(1) = DOUBLE',\n      X70 CHARACTER INITIAL ('\n                    ');\n\n   /* LENGTH OF LONGEST SYMBOL IN V */\n   DECLARE (RESERVED_LIMIT, MARGIN_CHOP) FIXED;\n\n   /* CHARTYPE() IS USED TO DISTINGUISH CLASSES OF SYMBOLS IN THE SCANNER.\n      TX() IS A TABLE USED FOR TRANSLATING FROM ONE CHARACTER SET TO ANOTHER.\n      CONTROL() HOLDS THE VALUE OF THE COMPILER CONTROL TOGGLES SET IN $ CARDS.\n\n      ALL ARE USED BY THE SCANNER AND CONTROL() IS SET THERE.\n   */\n   DECLARE (CHARTYPE, TX) (255) BIT(8),\n           CONTROL (255) BIT(1);\n\n   /* ALPHABET CONSISTS OF THE SYMBOLS CONSIDERED ALPHABETIC IN BUILDING\n      IDENTIFIERS     */\n   DECLARE ALPHABET CHARACTER INITIAL ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_$@#');\n\n   /* TRANSLATION TABLES NEEDED BY THE SCANNER */\n   DECLARE (ALPHATABLE, BLANKTABLE, COMMENTABLE, STRINGTABLE) (63) FIXED;\n\n   /* BUFFER HOLDS THE LATEST CARDIMAGE,\n      TEXT HOLDS THE PRESENT STATE OF THE INPUT TEXT (INCLUDING MACRO\n      EXPANSIONS AND NOT INCLUDING THE PORTIONS DELETED BY THE SCANNER),\n      TEXT_LIMIT IS A CONVENIENT PLACE TO STORE THE POINTER TO THE END OF TEXT,\n      CARD_COUNT IS INCREMENTED BY ONE FOR EVERY XPL SOURCE CARD READ,\n      ERROR_COUNT TABULATES THE ERRORS AS THEY ARE DETECTED DURING COMPILE,\n      SEVERE_ERRORS TABULATES THOSE ERRORS OF FATAL SIGNIFICANCE.\n   */\n   DECLARE (BUFFER, TEXT, CURRENT_PROCEDURE, INFORMATION) CHARACTER,\n      (TEXT_LIMIT, CARD_COUNT, ERROR_COUNT, SEVERE_ERRORS, PREVIOUS_ERROR) FIXED\n      ;\n\n   /* NUMBER_VALUE CONTAINS THE NUMERIC VALUE OF THE LAST CONSTANT SCANNED,\n      JBASE CONTAINS THE FIELD WIDTH IN BIT STRINGS (DEFAULT VALUE = 4),\n      BASE IS  2**JBASE   (I.E., SHL(1,JBASE) ).\n   */\n   DECLARE (NUMBER_VALUE, JBASE, BASE) FIXED;\n\n   /* EACH OF THE FOLLOWING CONTAINS THE INDEX INTO V() OF THE CORRESPONDING\n      SYMBOL.   WE ASK:    IF TOKEN = IDENT    ETC.    */\n   DECLARE (IDENT, STRING, NUMBER, DIVIDE, EOFILE, ORSYMBOL,\n      CONCATENATE) FIXED;\n\n   /* USED TO SAVE BRANCH ADDRESSES IN DO-LOOP CODE */\n   DECLARE STEPK FIXED;\n\n   /* THE FOLLOWING ARE USED IN THE MACRO EXPANDER.  CONSIDERABLE LOGIC\n      IS DEVOTED TO AVOIDING CREATING STRINGS OF LENGTH > 256, THE STRING LIMIT.\n   */\n   DECLARE BALANCE CHARACTER, LB FIXED;\n   DECLARE MACRO_LIMIT FIXED INITIAL (40), MACRO_NAME(40) CHARACTER,\n      MACRO_TEXT(40) CHARACTER, MACRO_INDEX(256) BIT (8),\n      TOP_MACRO FIXED INITIAL (\"FFFFFFFF\");\n   DECLARE EXPANSION_COUNT FIXED, EXPANSION_LIMIT LITERALLY '300';\n\n   /* STOPIT() IS A TABLE OF SYMBOLS WHICH ARE ALLOWED TO TERMINATE THE ERROR\n      FLUSH PROCESS.  IN GENERAL THEY ARE SYMBOLS OF SUFFICIENT SYNTACTIC\n      HIERARCHY THAT WE EXPECT TO AVOID ATTEMPTING TO START COMPILING AGAIN\n      RIGHT INTO ANOTHER ERROR PRODUCING SITUATION.  THE TOKEN STACK IS ALSO\n      FLUSHED DOWN TO SOMETHING ACCEPTABLE TO A STOPIT() SYMBOL.\n      FAILSOFT IS A BIT WHICH ALLOWS THE COMPILER ONE ATTEMPT AT A GENTLE\n      RECOVERY.   THEN IT TAKES A STRONG HAND.   WHEN THERE IS REAL TROUBLE\n      COMPILING IS SET TO FALSE, THEREBY TERMINATING THE COMPILATION.\n      MAINLOC IS THE SYMBOL TABLE LOCATION OF COMPACTIFY FOR USE IN ERROR().\n   */\n   DECLARE STOPIT(NT) BIT(1), COMPILING BIT(1), MAINLOC FIXED;\n\n   DECLARE S CHARACTER;  /* A TEMPORARY USED VARIOUS PLACES */\n\n   /* SUBSTR(HEXCODES, I, 1) IS THE HEXADECIMAL CODE LETTER FOR I  */\n   DECLARE HEXCODES CHARACTER INITIAL ('0123456789ABCDEF');\n\n   /*THE PROPER SUBSTRING OF POINTER IS USED TO PLACE AN  |  UNDER THE POINT\n      OF DETECTION OF AN ERROR DURING COMPILATION.  IT MARKS THE LAST CHARACTER\n      SCANNED.  */\n   DECLARE POINTER CHARACTER INITIAL ('\n                                           |');\n   DECLARE (COUNT#STACK, COUNT#SCAN, COUNT#RR, COUNT#RX, COUNT#FORCE,\n      COUNT#ARITH, COUNT#STORE, COUNT#FIXBFW, COUNT#FIXD, COUNT#FIXCHW,\n      COUNT#GETD, COUNT#GETC, COUNT#FIND) FIXED;\n\n   /* RECORD THE TIMES OF IMPORTANT POINTS DURING COMPILATION */\n   DECLARE CLOCK(5) FIXED;\n\n   /* COUNT THE NUMBER OF COMPARISONS OF IDENTIFIERS IN SYMBOL TABLE LOOK-UPS\n      THIS CAN, IN GENERAL, BE EXPECTED TO BE A SUBSTANTIAL PART OF RUN TIME.\n   */\n   DECLARE IDCOMPARES FIXED, STATEMENT_COUNT FIXED;\n   DECLARE TRUELOC FIXED;  /* ADDRESS OF INTEGER 1 IN DATA AREA */\n   DECLARE COMPLOC FIXED; /*  THE ADDRESS OF ALL ONES MASK FOR COMPLEMENT */\n   DECLARE CATCONST FIXED;   /* ADDRESS OF 2**24  */\n   DECLARE BASEDATA FIXED;   /*  BASE REGISTER INITIALIZATION ADDRESS */\n\n   /*  THE EMITTER  ARRAYS  */\n\n\n /******************************************************************************\n\n      WARNING:  THE EMITTER ARRAYS \"CODE\", \"DATA\", AND \"STRINGS\" ARE\n   DEPENDENT ON THE HARDWARE DEVICES AVAILABLE FOR SCRATCH STORAGE.  THE\n   LITERAL CONSTANT \"DISKBYTES\" SHOULD BE EQUAL TO THE BLOCKSIZE OF THESE FILES\n   AS ESTABLISHED IN DCB'S IN THE SUBMONITOR.\n\n   SUGGESTED VALUES:\n            FOR LARGE CORE:             FOR SMALL CORE DISKBYTES = 400.\n\n      2311     DISKBYTES = 3600\n      2314     DISKBYTES = 7200\n      2321     DISKBYTES = 2000\n\n      THIS VERSION OF XCOM NEEDS THREE SCRATCH FILES:\n      1        COMPILED CODE TEMPORARY\n      2        COMPILED DATA TEMPORARY\n      3        CHARACTER STRING TEMPORARY\n      1        BINARY PROGRAM OUTPUT\n\n ******************************************************************************/\n\n   DECLARE DISKBYTES LITERALLY '7200';   /*2314 DISKS */\n      /* SIZE OF SCRATCH FILE BLOCKS IN BYTES */\n   DECLARE CODEMAX FIXED;        /* FORCES CODE TO WORD BOUNDARY */\n   DECLARE CODE (DISKBYTES) BIT(8);\n   DECLARE DATAMAX FIXED;     /* FORCES DATA TO WORD BOUNDARY */\n   DECLARE DATA (DISKBYTES) BIT(8);\n   DECLARE STRNGMX FIXED;            /*  AND FORCE STRINGS TO BE ALIGNED  */\n   DECLARE STRINGS (DISKBYTES) BIT(8); /* BUFFER FOR COMPILED STRINGS  */\n\n\n   /*  CODEMAX  IS THE # OF RECORDS OF CODE GENERATED\n       DATAMAX IS THE NUMBER OF RECORDS OF DATA GENERATED\n   */\n\n   DECLARE CODEFILE FIXED INITIAL(1);    /* FILE FOR BINARY CODE, AND */\n   DECLARE BINARYFILE FIXED INITIAL(1);  /* COLLECTION OF ALL COMPILED OUTPUT */\n   DECLARE DATAFILE FIXED INITIAL (2);    /* SCRATCH FILE FOR DATA */\n   DECLARE STRINGFILE FIXED INITIAL (3);\n      /* SCRATCH FILE FOR CHARACTER STRINGS */\n\n   DECLARE (PPORG, PPLIM, DPORG, DPLIM, CURCBLK, CURDBLK, CURSBLK, CHPORG,\n      CHPLIM, STRINGMAX, SHORTDFIX, SHORTCFIX, LONGDFIX, LONGCFIX, FCP) FIXED;\n\n      /* ARRAYS TO HOLD FIXUPS DURING COMPILATION */\n\n   /* FCLIM IS THE NUMBER OF FIXUPS THAT CAN BE RECORDED BEFORE THEY ARE MADE */\n   DECLARE FCLIM LITERALLY '100';\n   DECLARE FIXCADR (FCLIM) FIXED;      /* ADDRESS OF CODE FIXUP  */\n   DECLARE FIXCB1 (FCLIM) BIT(8);      /* 1ST BYTE OF CODE FIXUP  */\n   DECLARE FIXCB2 (FCLIM) BIT(8);      /* 2ND BYTE OF CODE FIXUP  */\n\n   DECLARE LIMITWORD FIXED;\n   DECLARE STRING_RECOVER FIXED;\n\n   DECLARE CATENTRY FIXED;   /*  ENTRY TO CATENATE ROUTINE */\n   DECLARE STRL FIXED;  /* ADDRESS OF LAST STRING COMPUTED FOR OPTIMIZING || */\n   DECLARE STRN FIXED;  /* ADDRESS OF TEMP IN STRING TO NUMBER ROUTINE */\n   DECLARE DESCL FIXED;\n   DECLARE IO_SAVE FIXED;\n   DECLARE NMBRNTRY  FIXED;     /*  ENTRY TO BINARY TO CHAR. CONVERSION */\n   DECLARE TSA FIXED;  /* INTEGER ADDRESS OF TOP-OF-STRINGS  */\n   DECLARE MOVER FIXED;   /*  ADDRESS OF MOVE TEMPLATE  */\n   DECLARE BASES (15) FIXED;    /*  THE VALUE OF THE BASE REGISTERS */\n   DECLARE AVAIL FIXED INITIAL (2);\n   DECLARE INSTRUCT (255) BIT(16);  /*  INSTRUCTION USE COUNTERS */\n   DECLARE DESC(1024) FIXED;  /* STRING DESCRIPTORS, REG 13 RELATIVE */\n\n   /*  360 REGISTER ASSIGNMENTS:\n            0     SCRATCH\n            1-3   ACCUMULATORS\n            4-11  DATA ADDRESSING\n            12    BRANCH REGISTER\n            13    STRING DESCRIPTOR AREA BASE\n            14    PROGRAM BASE\n            15    POINTS TO ENTRY OF I/O PACKAGE\n   */\n\n   DECLARE IOREG LITERALLY '\"F\"';  /* REGISTER FOR IO ROUTINES OF SUBMONITOR */\n   DECLARE PBR LITERALLY '\"E\"';  /* PROGRAM BASE REGISTER POINTS TO CODE  */\n   DECLARE SBR LITERALLY '\"D\"';  /* STRING BASE REGISTER TO ADDRESS DESCRIPT. */\n   DECLARE BRCHREG LITERALLY '\"C\"';  /* REGISTER FOR BRANCHING  */\n   DECLARE DBR LITERALLY '\"B\"';  /* FIRST DATA BASE REGISTER  */\n   DECLARE PROGRAMSIZE LITERALLY '25';  /* NUMBER OF 4096 BYTE PAGES ALLOWED */\n   DECLARE LASTBASE FIXED;   /*  KEEP TRACK OF ALLOCATION OF REG 11 - 4 */\n   DECLARE TARGET_REGISTER FIXED;\n   DECLARE MASKF000 BIT(32);\n   DECLARE ADREG FIXED, ADRDISP FIXED;    /* GLOBALS FOR FINDADDRESS */\n   DECLARE RTNADR FIXED;  /*  WHERE THE PRESENT RETURN ADDRESS IS STORED */\n   DECLARE RETURNED_TYPE BIT (8);\n   DECLARE TEMP(3) FIXED ;         /*  STORAGE FOR SAVE_REGISTERS  */\n   DECLARE (DP, PP, CHP, DSP, NEWDP, NEWDSP) FIXED; /* EMITTER POINTERS */\n   DECLARE ITYPE FIXED;   /*  INITIALIZATION TYPE  */\n   DECLARE STILLCOND FIXED;  /*  REMEMBER CONDITION CODE TEST FOR PEEPHOLE */\n\n   /*  COMMON  IBM  360  OP-CODES  */\n   DECLARE OPNAMES CHARACTER INITIAL ('    BALRBCTRBCR LPR LNR LTR LCR NR  CLR O\nR  XR  LR  CR  AR  SR  MR  DR  ALR SLR LA  STC IC  EX  BAL BCT BC  CVD CVB ST  N\n   CL  O   X   L   C   A   S   M   D   AL  SL  SRL SLL SRA SLA SRDLSLDLSRDASLDAS\nTM TM  MVI NI  CLI OI  XI  LM  MVC STH LH  ');\n   DECLARE OPER(255) BIT(8) INITIAL(\n /*0**/   0,  0,  0,  0,  0,  4,  8, 12,  0,  0,  0,  0,  0,  0,  0,  0,\n /*1**/  16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76,\n /*2**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*3**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*4**/ 236, 80, 84, 88, 92, 96,100,104,240,  0,  0,  0,  0,  0,108,112,\n /*5**/ 116,  0,  0,  0,120,124,128,132,136,140,144,148,152,156,160,164,\n /*6**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*7**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*8**/   0,  0,  0,  0,  0,  0,  0,  0,168,172,176,180,184,188,192,196,\n /*9**/ 200,204,208,  0,212,216,220,224,228,  0,  0,  0,  0,  0,  0,  0,\n /*A**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*B**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*C**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*D**/   0,  0,232,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*E**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n /*F**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0);\n /*      *0  *1  *2  *3  *4  *5  *6  *7  *8  *9  *A  *B  *C  *D  *E  *F  */\n   DECLARE OP_CODE CHARACTER;  /* FOR DEBUG PRINTOUT */\n   DECLARE COMMUTATIVE(63) BIT(1);  /* RECORD WHICH OPERATORS ARE COMMUTATIVE */\n\n   /* COMMONLY USED /360 OPERATION CODES */\n   DECLARE BC FIXED INITIAL (\"47\"), BCR FIXED INITIAL (\"07\");\n   DECLARE BAL FIXED INITIAL (\"45\"), BALR FIXED INITIAL (\"05\");\n   DECLARE LOAD FIXED INITIAL (\"58\"), STORE FIXED INITIAL (\"50\");\n   DECLARE CMPR FIXED INITIAL (\"59\"), CMPRR FIXED INITIAL (\"19\");\n   DECLARE LA FIXED INITIAL (\"41\");\n\n   /* THE FOLLOWING ARE USED TO HOLD ADDRESS PAIRS IN THE EMITTER FOR || */\n   DECLARE (A1, A2, B1, B2, T1, T2) FIXED;\n\n   /* COMMONLY USED STRINGS */\n   DECLARE X1 CHARACTER INITIAL(' '), X4 CHARACTER INITIAL('    ');\n   DECLARE EQUALS CHARACTER INITIAL (' = '), PERIOD CHARACTER INITIAL ('.');\n   DECLARE QUOTE CHARACTER INITIAL ('''');\n\n   /* TEMPORARIES USED THROUGHOUT THE COMPILER */\n   DECLARE (I, J, K, L) FIXED;\n\n   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';\n\n   /*  SYMBOL  TABLE  VARIABLES  */\n\n   DECLARE HALFWORD     LITERALLY  '1',\n           LABELTYPE    LITERALLY  '2',\n           ACCUMULATOR  LITERALLY  '3',\n           VARIABLE     LITERALLY  '4',\n           CONSTANT     LITERALLY  '5',\n           CONDITION    LITERALLY  '6',\n           CHRTYPE      LITERALLY  '7',\n           FIXEDTYPE    LITERALLY  '8',\n           BYTETYPE     LITERALLY  '9',\n           FORWARDTYPE  LITERALLY '10',\n           DESCRIPT     LITERALLY '11',\n           SPECIAL      LITERALLY '12',\n           FORWARDCALL  LITERALLY '13' ,\n           CHAR_PROC_TYPE LITERALLY '14'\n           ;\n   DECLARE TYPENAME(14) CHARACTER INITIAL ('', 'BIT(16)  ', 'LABEL    ', '', '',\n      '', '', 'CHARACTER', 'FIXED    ', 'BIT(8)   ', '', '', '', '',\n      'CHARACTER PROCEDURE');\n   DECLARE PROCMARK FIXED;  /* START OF LOCAL VARIABLES IN SYMBOL TABLE */\n   DECLARE PARCT FIXED;  /* NUMBER OF PARAMETERS TO CURRENT PROCEDURE */\n   DECLARE NDECSY FIXED;     /* CURRENT NUMBER OF DECLARED SYMBOLS */\n   /* MAXNDECSY IS THE MAXIMUM OF NDECSY OVER A COMPILATION.  IF MAXNDECSY\n      BEGINS TO APPROACH SYTSIZE THEN SYTSIZE SHOULD BE INCREASED */\n   DECLARE MAXNDECSY FIXED;\n\n    DECLARE SYTSIZE LITERALLY '415';   /*   SYMBOL TABLE SIZE   */\n\n   /*  THE SYMBOL TABLE IS INITIALIZED WITH THE NAMES OF ALL\n       BUILTIN FUNCTIONS AND PSEUDO VARIABLES.  THE PROCEDURE\n       INITIALIZE DEPENDS ON THE ORDER AND PLACEMENT OF THESE\n       NAMES.  DUE CAUTION SHOULD BE OBSERVED WHILE MAKING CHANGES .\n   */\n\n   DECLARE SYT (SYTSIZE) CHARACTER          /*  VARIABLE NAME */\n      INITIAL ('','','MONITOR_LINK','TIME_OF_GENERATION',\n         'DATE_OF_GENERATION','COREWORD','COREBYTE','FREEPOINT',\n         'DESCRIPTOR','NDESCRIPT', 'LENGTH','SUBSTR','BYTE','SHL',\n         'SHR','INPUT','OUTPUT','FILE','INLINE','TRACE','UNTRACE',\n         'EXIT','TIME','DATE','CLOCK_TRAP','INTERRUPT_TRAP',\n         'MONITOR','ADDR','COMPACTIFY', '','');\n   DECLARE SYTYPE (SYTSIZE) BIT (8)   /* TYPE OF THE VARIABLE */\n      INITIAL (0,0,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,\n         BYTETYPE,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,SPECIAL,SPECIAL,\n         SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,\n         SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,\n         SPECIAL,SPECIAL,FORWARDCALL,0,0);\n   DECLARE SYBASE (SYTSIZE) BIT (4) INITIAL(0,0,DBR,DBR,DBR,0,0,\n      DBR,SBR,DBR,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,DBR,0,0);\n   DECLARE SYDISP (SYTSIZE) BIT (12)  /* DISPLACEMENT FOR VARIABLE */\n      INITIAL (0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,  10,11,12,13,14,\n         15,16,17,18,19,0,0);\n   DECLARE SYTCO(SYTSIZE) BIT (16);     /* COUNT OF REFERENCES TO SYMBOLS */\n   DECLARE DECLARED_ON_LINE(SYTSIZE) BIT(16);\n\n   DECLARE MAXNEST LITERALLY '32',\n           NULL LITERALLY '-1';\n   DECLARE N_PREDECLARED_SYMB FIXED INITIAL (28);\n   DECLARE (PROCEDURE_NUMBER, LEX_LEVEL) FIXED,\n            BUCKET(255) BIT(16),\n            SY_LINK(SYTSIZE) BIT(16);\n   DECLARE PROC_STACK(MAXNEST) BIT(16);\n\n   /*  THE COMPILER STACKS DECLARED BELOW ARE USED TO DRIVE THE SYNTACTIC\n      ANALYSIS ALGORITHM AND STORE INFORMATION RELEVANT TO THE INTERPRETATION\n      OF THE TEXT.  THE STACKS ARE ALL POINTED TO BY THE STACK POINTER SP.  */\n\n   DECLARE STACKSIZE LITERALLY '75';  /* SIZE OF STACK  */\n   DECLARE TYPE (STACKSIZE) BIT(8);  /* OPERAND TYPE FOR EXPRESSIONS */\n   DECLARE REG (STACKSIZE) BIT(8);   /* ASSOCIATED GENERAL REGISTER */\n   DECLARE INX (STACKSIZE) BIT(8);   /* ASSOCIATED INDEX REGISTER */\n   DECLARE CNT (STACKSIZE) BIT(8);   /* ANNY COUNT, PARAMETERS, SUBSCRIPTS ...*/\n   DECLARE VAR (STACKSIZE) CHARACTER;/* EBCDIC NAME OF ITEM */\n   DECLARE FIXL (STACKSIZE) FIXED;   /* FIXUP LOCATION */\n   DECLARE FIXV (STACKSIZE) FIXED;   /* FIXUP VALUE */\n   DECLARE PPSAVE (STACKSIZE) FIXED; /* ASSOCIATED PROGRAM POINTER */\n\n   /* SP POINTS TO THE RIGHT END OF THE REDUCIBLE STRING IN THE PARSE STACK,\n      MP POINTS TO THE LEFT END, AND\n      MPP1 = MP+1.\n   */\n   DECLARE (SP, MP, MPP1) FIXED;\n\n   /* DECLARE STATEMENTS AND CASE STATEMENTS REQUIRE AN AUXILIARY STACK */\n   DECLARE CASELIMIT LITERALLY '255', CASESTACK(CASELIMIT) FIXED;\n   DECLARE CASEP FIXED;   /* POINTS TO THE CURRENT POSITION IN CASESTACK */\n   DECLARE DCLRM CHARACTER INITIAL ('IDENTIFIER LIST TOO LONG');\n    DECLARE STATE_STACK (STACKSIZE) BIT(16);\n    DECLARE RECOV BIT(1) ;\n    DECLARE (STATE#,NEXT) FIXED;\n DECLARE NEWSTATE FIXED;\n  DECLARE MCHAR CHARACTER INITIAL ('I');\n\n\n\n\n   /*               P R O C E D U R E S                                  */\n\n\n\nPAD:\n   PROCEDURE (STRING, WIDTH) CHARACTER;\n      DECLARE STRING CHARACTER, (WIDTH, L) FIXED;\n\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN STRING || SUBSTR(X70, 0, WIDTH-L);\n   END PAD;\n\nI_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;\n\n      STRING = NUMBER;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN SUBSTR(X70, 0, WIDTH-L) || STRING;\n   END I_FORMAT;\n\nERROR:\n   PROCEDURE(MSG, SEVERITY);\n      /* PRINTS AND ACCOUNTS FOR ALL ERROR MESSAGES */\n      /* IF SEVERITY IS NOT SUPPLIED, 0 IS ASSUMED */\n      DECLARE (MSG, ST) CHARACTER, SEVERITY FIXED;\n      ERROR_COUNT = ERROR_COUNT + 1;\n      /* IF LISTING IS SUPPRESSED, FORCE PRINTING OF THIS LINE */\n      IF \u00ac CONTROL(BYTE('L')) THEN\n         OUTPUT= I_FORMAT (CARD_COUNT,4) || X1 || MCHAR || BUFFER || MCHAR ;\n      OUTPUT = SUBSTR(POINTER, TEXT_LIMIT+LB-CP+MARGIN_CHOP);\n      /* SEVERITY(-1) IS A PORNOGRAPHIC WAY OF OBTAINING THE RETURN ADDRESS */\n      ST = '***ERROR, ' || MSG || '.';\n      IF LENGTH(ST) > 100 THEN DO;\n         OUTPUT = ST;\n         ST = X4;\n      END;\n      ST = ST || '  LAST ERROR IN LINE ' || PREVIOUS_ERROR;\n      OUTPUT = ST;\n      PREVIOUS_ERROR = CARD_COUNT;\n      IF SEVERITY > 0 THEN\n         IF SEVERE_ERRORS > 25 & \u00acCONTROL(BYTE('X')) THEN\n            DO;\n               OUTPUT='***TOO MANY SEVERE ERRORS.  COMPILATION ABORTED.';\n               COMPILING = FALSE;\n            END;\n         ELSE SEVERE_ERRORS = SEVERE_ERRORS + 1;\n   END ERROR;\n\n\n   /*                      FILE HANDLING PROCEDURES                          */\n\n\n\nGETDATA:\n   PROCEDURE;\n      /* HANDLE SCRATCH STORAGE ALLOCATION FOR THE DATA ARRAY  */\n      DECLARE I FIXED;\n      COUNT#GETD = COUNT#GETD + 1;\n      FILE(DATAFILE,CURDBLK) = DATA;     /*  WRITE OUT CURRENT BLOCK */\n      CURDBLK = DP / DISKBYTES;          /* CALCULATE NEW BLOCK NUMBER */\n      DPORG = CURDBLK * DISKBYTES;\n      DPLIM = DPORG + DISKBYTES;\n      IF CURDBLK <= DATAMAX THEN\n            DATA = FILE(DATAFILE,CURDBLK);\n      ELSE\n         DO;\n            /*  ZERO OUT THE NEW DATA BLOCK  */\n            DO I = 1 TO SHR(DISKBYTES,2);\n               DATAMAX(I) = 0;\n            END;\n            DO DATAMAX = DATAMAX + 1 TO CURDBLK - 1;\n               FILE(DATAFILE,DATAMAX)= DATA;\n            END;\n         END;\n   END  GETDATA;\n\nGETCODE:\n   PROCEDURE;\n      /*  HANDLE SCRATCH STORAGE ALLOCATION FOR THE CODE ARRAY */\n      DECLARE I FIXED;\n      FILE(CODEFILE,CURCBLK) = CODE;\n      COUNT#GETC = COUNT#GETC + 1;\n      CURCBLK = PP / DISKBYTES;       /* CALCULATE NEW BLOCK NUMBER */\n      PPORG = CURCBLK * DISKBYTES;\n      PPLIM = PPORG + DISKBYTES;\n      IF CURCBLK <= CODEMAX THEN\n               CODE = FILE(CODEFILE,CURCBLK);\n      ELSE\n         DO;\n         /*  ZERO OUT THE NEW CODE BLOCK */\n            DO I = 1 TO SHR(DISKBYTES,2);\n               CODEMAX(I) = 0;\n            END;\n            DO CODEMAX = CODEMAX + 1 TO CURCBLK - 1;\n               FILE(CODEFILE,CODEMAX) = CODE;\n            END;\n         END;\n   END  GETCODE;\n\nGETSTRINGS:\n   PROCEDURE;\n      /* HANDLE SCRATCH STORAGE ALLOCATION FOR STRING ARRAY */\n      FILE(STRINGFILE, CURSBLK) = STRINGS;    /* WRITE INTO THE FILE */\n      CURSBLK = CHP / DISKBYTES;              /* COMPUTE NEW BLOCK NUMBER */\n      CHPORG = CURSBLK*DISKBYTES;             /* NEW BLOCK ORIGIN */\n      CHPLIM = CHPORG + DISKBYTES;            /* NEW UPPER BOUND */\n      IF CURSBLK <= STRINGMAX THEN\n         STRINGS = FILE(STRINGFILE,CURSBLK);  /* READ BACK FROM FILE */\n      ELSE\n         DO STRINGMAX = STRINGMAX+1 TO CURSBLK - 1;\n            FILE(STRINGFILE,STRINGMAX) = STRINGS;\n            /* FILL OUT FILE SO NO GAPS EXIST */\n         END;\n   END GETSTRINGS;\n\n\n\n  /*                   CARD IMAGE HANDLING PROCEDURE                      */\n\n\nGET_CARD:\n   PROCEDURE;\n      /* DOES ALL CARD READING AND LISTING                                 */\n      DECLARE I FIXED, (TEMP, TEMP0, REST) CHARACTER, READING BIT(1);\n      IF LB > 0 THEN\n         DO;\n            TEXT = BALANCE;\n            TEXT_LIMIT = LB - 1;\n            CP = 0;\n            RETURN;\n         END;\n      EXPANSION_COUNT = 0;   /* CHECKED IN SCANNER MACRO EXPANSION */\n      IF READING THEN\n         DO; /* 'READING' IS FALSE DURING COMPILE OF LIBRARY FROM INPUT(2) */\n            BUFFER = INPUT;\n            IF LENGTH(BUFFER) = 0 THEN\n               DO; /* SIGNAL FOR EOF */\n                  CALL ERROR ('EOF MISSING OR COMMENT STARTING IN COLUMN 1.',1);\n                  BUFFER = PAD (' /*''/* */ EOF;END;EOF', 80);\n               END;\n            ELSE CARD_COUNT = CARD_COUNT + 1;  /* USED TO PRINT ON LISTING */\n         END;\n      ELSE\n         DO; /* WHILE READING LIBRARY FILE ONLY */\n            BUFFER = INPUT(2);\n            IF LENGTH(BUFFER) = 0 THEN\n               DO;  /* SIGNAL TO SWITCH TO SYSIN */\n CONTROL(BYTE('Q'))= FALSE ; /******************* OUT *****************/\n                  CONTROL(BYTE('L')), READING = TRUE;  /* TURN ON LISTING */\n                  CONTROL(BYTE('D')) = TRUE;    /* TURN ON SYMBOL DUMP  */\n                  CLOCK(1) = TIME;  /* KEEP TRACK OF TIME FOR COMPILE RATE */\n                  TEXT = X1;  /* INITIALIZE TEXT FOR SCAN */\n                  /* STATEMENTS ARE COUNTED FOR STATISTICS */\n                  STATEMENT_COUNT = -1;\n                  TEXT_LIMIT = 0;\n                  PROCMARK = NDECSY + 1;\n                  PROC_STACK(1) = 1;  /* SEPARATE THE GLOBAL SYMBOL TABLE\n                                         BLOCK FROM THE PREDECLARED BLOCK */\n                  RETURN;\n               END;\n         END;\n      IF MARGIN_CHOP > 0 THEN\n         DO; /* THE MARGIN CONTROL FROM DOLLAR | */\n            I = LENGTH(BUFFER) - MARGIN_CHOP;\n            REST = SUBSTR(BUFFER, I);\n            BUFFER = SUBSTR(BUFFER, 0, I);\n         END;\n      ELSE REST = '';\n      TEXT = BUFFER;\n      TEXT_LIMIT = LENGTH(TEXT) - 1;\n      IF CONTROL(BYTE('M')) THEN OUTPUT = BUFFER;\n      ELSE IF CONTROL(BYTE('L')) THEN\n         DO;\n            REST = I_FORMAT (PP, 6) || REST;\n           OUTPUT=I_FORMAT(CARD_COUNT,4) || X1 || MCHAR || BUFFER || MCHAR ||\n               REST || CURRENT_PROCEDURE || INFORMATION;\n         END;\n      INFORMATION = '';\n      CP = 0;\n   END GET_CARD;\n\n\n   /*                THE SCANNER PROCEDURES              */\n\n\nCHAR:\n   PROCEDURE;\n      /* USED FOR STRINGS TO AVOID CARD BOUNDARY PROBLEMS */\n      CP = CP + 1;\n      IF CP <= TEXT_LIMIT THEN RETURN;\n      CALL GET_CARD;\n   END CHAR;\n\nDEBLANK:\n   PROCEDURE;\n      /* USED BY BCHAR */\n      CALL CHAR;\n      DO WHILE BYTE(TEXT, CP) = BYTE(' ');\n         CALL CHAR;\n      END;\n   END DEBLANK;\n\nBCHAR:\n   PROCEDURE;\n      /* USED FOR BIT STRINGS */\n      DO FOREVER;\n         CALL DEBLANK;\n         CH = BYTE(TEXT, CP);\n         IF CH \u00ac= BYTE('(') THEN RETURN;\n         /*  (BASE WIDTH)  */\n         CALL DEBLANK;\n         JBASE = BYTE(TEXT, CP) - \"F0\";  /* WIDTH */\n         IF JBASE < 1 | JBASE > 4 THEN\n            DO;\n               CALL ERROR ('ILLEGAL BIT STRING WIDTH: ' || SUBSTR(TEXT, CP, 1));\n               JBASE = 4;  /* DEFAULT WIDTH FOR ERROR */\n            END;\n         BASE = SHL(1, JBASE);\n         CALL DEBLANK;\n         IF BYTE(TEXT, CP) \u00ac= BYTE(')') THEN\n            CALL ERROR ('MISSING ) IN BIT STRING', 0 );\n      END;\n   END BCHAR;\n\nBUILD_BCD:\n   PROCEDURE (C);\n      DECLARE C BIT(8);\n      IF LENGTH(BCD) > 0 THEN\n         BCD = BCD || X1;\n      ELSE\n         BCD = SUBSTR(X1 || X1, 1);\n      /* FORCE BCD TO THE TOP OF FREE STRING AREA AND INCREASE LENGTH\n          BY ONE  */\n      /* THIS LINE DEPENDS UPON THE IMPLEMENTATION OF XPL STRINGS */\n      COREBYTE(FREEPOINT-1) = C;\n   END BUILD_BCD;\n\nSCAN:\n   PROCEDURE;\n\nSCAN_FINDS_END_OF:\n   PROCEDURE (TABLE) BIT(1);\n      DECLARE TABLE FIXED;\n      DECLARE TRT (1) FIXED INITIAL (\"DD003000\", \"10000000\");\n\n   /* THIS PROCEDURE ASSUMES CP = 0 WHEN IT IS CALLED */\n      CALL INLINE (\"58\", 3, 0,TEXT); /*LOAD STRING DESCRIPTOR */\n      CALL INLINE (\"1B\", 2, 2);      /* CLEAR REG. 2 */\n      CALL INLINE (\"19\", 3, 2);      /* CHECK FOR TEXT = NULL STRING */\n      CALL INLINE (\"07\", 8, 12);     /* RETURN FALSE IF TEXT IS NULL */\n      CALL INLINE (\"8D\", 2, 0,0,8);  /*  SHIFT LENGTH FIELD TO REG. 2 */\n      CALL INLINE (\"88\", 3, 0,0,8);  /* RESTORE STRING ADDRESS  */\n      CALL INLINE (\"58\", 1, 0,TABLE);/* LOAD BASE ADDRESS OF TRANS_TABLE */\n      CALL INLINE (\"41\", 12, 0,TRT); /* LOAD ADDRESS OF TRT INSTRUCTION */\n      CALL INLINE (\"44\", 2, 0,12,0); /* EXECUTE TRT INSTRUCTION */\n      CALL INLINE (\"05\",  12, 0);    /* LOAD BRANCH REGISTER  */\n      CALL INLINE (\"47\", 7, 0,12,18);/*  BRANCH ON CC\u00ac=0  */\n      CALL INLINE (\"18\", 1, 2);      /* LOAD REG. 1 WITH LENGTH(\\) - 1 */\n      CALL INLINE (\"41\", 0, 0,0,1);  /* LOAD REG. 0 WITH 1  */\n      CALL INLINE (\"1A\", 1, 0);      /* ADD TO OBTAIN IDENTIFIER LNGTH*/\n      CALL INLINE (\"1B\", 3, 3);      /* PUT 0 INTO RETURN REGISTER */\n      CALL INLINE (\"47\", 15, 0,12,24); /* BRANCH AROUND NEXT TWO INSTR*/\n      CALL INLINE (\"1B\", 1, 3);      /* SUBTRACT TO OBTAIN IDENTIFIER LENGTH */\n      CALL INLINE (\"41\", 3, 0,0,1);  /* LOAD 1 INTO RETURN REGISTER */\n      CALL INLINE (\"50\", 1, 0,CP);   /* STORE IDENTIFIER LENGTH */\n   END;\n\n      DECLARE (S1, S2) FIXED;\n      DECLARE LSTRNGM CHARACTER INITIAL('STRING TOO LONG');\n      COUNT#SCAN = COUNT#SCAN + 1;\n      BCD = '';  NUMBER_VALUE = 0;\n      DO FOREVER;\n         IF CP > TEXT_LIMIT THEN CALL GET_CARD;\n   SCAN1:\n         /* DISCARD LAST SCANNED VALUE */\n         TEXT = SUBSTR (TEXT, CP);\n         TEXT_LIMIT = TEXT_LIMIT - CP;\n         CP = 0;\n         /*  BRANCH ON NEXT CHARACTER IN TEXT                  */\n         DO CASE CHARTYPE(BYTE(TEXT));\n\n            /*  CASE 0  */\n\n            /* ILLEGAL CHARACTERS FALL HERE  */\n            CALL ERROR ('ILLEGAL CHARACTER: ' || SUBSTR(TEXT, 0, 1));\n\n            /*  CASE 1  */\n\n            /*  BLANK  */\n            DO;\n               CP = 1;\n               IF CP > TEXT_LIMIT THEN CALL GET_CARD;\n               IF BYTE (TEXT) = BYTE (' ') THEN\n                  DO WHILE \u00ac SCAN_FINDS_END_OF(ADDR(BLANKTABLE));\n                     CALL GET_CARD;\n                  END;\n               GOTO SCAN1;\n            END;\n\n            /*  CASE 2  */\n\n            /*  STRING QUOTE ('):  CHARACTER STRING  */\n            DO FOREVER;\n                  CALL CHAR;\n                  TOKEN = STRING;\n                  TEXT_LIMIT = TEXT_LIMIT - CP;\n                  TEXT = SUBSTR(TEXT, CP);\n                  DO WHILE \u00acSCAN_FINDS_END_OF (ADDR(STRINGTABLE));\n                     IF LENGTH(BCD) + LENGTH(TEXT) > 256 THEN DO;\n                              CALL ERROR(LSTRNGM  ,0);\n                        RETURN;\n                        END;\n                     BCD = BCD || TEXT;\n                     CALL GET_CARD;\n                     END;\n                  IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);\n                  CALL CHAR;\n                  IF BYTE (TEXT, CP) \u00ac= BYTE(QUOTE) THEN RETURN;\n                  BCD = BCD || QUOTE;\n            END;\n\n            /*  CASE 3  */\n\n            DO;      /*  BIT QUOTE(\"):  BIT STRING  */\n               JBASE = 4;  BASE = SHL(1, JBASE);  /* DEFAULT WIDTH  */\n               TOKEN = NUMBER;  /* ASSUME SHORT BIT STRING */\n               S1 = 0;\n               CALL BCHAR;\n               DO WHILE CH \u00ac= BYTE('\"');\n                  S1 = S1 + JBASE;\n                  IF CH >= \"F0\" THEN S2 = CH - \"F0\";  /* DIGITS */\n                  ELSE S2 = CH - \"B7\";                /* LETTERS */\n                  IF S2 >= BASE | S2 < 0 THEN\n                     CALL ERROR ('ILLEGAL CHARACTER IN BIT STRING: '\n                     || SUBSTR(TEXT, CP, 1));\n                  IF S1 > 32 THEN TOKEN = STRING;     /* LONG BIT STRING */\n                  IF TOKEN = STRING THEN\n                     DO WHILE S1 - JBASE >= 8;\n                        IF LENGTH(BCD) > \"FF\" THEN\n                           DO;\n                              CALL ERROR (LSTRNGM, 0);\n                              RETURN;\n                           END;\n                        S1 = S1 - 8;\n                        CALL BUILD_BCD (SHR(NUMBER_VALUE, S1-JBASE));\n                     END;\n                  NUMBER_VALUE = SHL(NUMBER_VALUE, JBASE) + S2;\n                  CALL BCHAR;\n               END;     /* OF DO WHILE CH...  */\n               CP = CP + 1;\n               IF TOKEN = STRING THEN\n                  IF LENGTH(BCD) > \"FF\" THEN CALL ERROR (LSTRNGM, 0);\n                  ELSE CALL BUILD_BCD (SHL(NUMBER_VALUE, 8 - S1));\n               RETURN;\n            END;\n\n            /*  CASE 4  */\n\n            DO FOREVER;  /* A LETTER:  IDENTIFIERS AND RESERVED WORDS */\n               IF SCAN_FINDS_END_OF (ADDR(ALPHATABLE)) THEN\n                     DO;  /* END OF IDENTIFIER  */\n                        IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);\n                        S1 = LENGTH(BCD);\n                        IF S1 > 1 THEN IF S1 <= RESERVED_LIMIT THEN\n                           /* CHECK FOR RESERVED WORDS */\n                           DO I =VT_INDEX(S1) TO VT_INDEX(S1+1) -1;\n                              IF BCD = V(I) THEN\n                                 DO;\n                                    TOKEN = I;\n                                    RETURN;\n                                 END;\n                           END;\n                        DO I = MACRO_INDEX(S1-1) TO MACRO_INDEX(S1) - 1;\n                           IF BCD = MACRO_NAME(I) THEN\n                              DO;\n                                 BCD = MACRO_TEXT(I);\n                                 IF EXPANSION_COUNT < EXPANSION_LIMIT THEN\n                                    EXPANSION_COUNT = EXPANSION_COUNT + 1;\n                                 ELSE OUTPUT =\n                                    '*** WARNING, TOO MANY EXPANSIONS FOR ' ||\n                                    MACRO_NAME(I) || ' LITERALLY: ' || BCD;\n                                 TEXT = SUBSTR(TEXT, CP);\n                                 TEXT_LIMIT = TEXT_LIMIT - CP;\n                                 IF LENGTH(BCD) + TEXT_LIMIT > 255 THEN\n                                    DO;\n                                       IF LB + TEXT_LIMIT > 255 THEN\n                                         CALL ERROR('MACRO EXPANSION TOO LONG');\n                                       ELSE\n                                          DO;\n                                             BALANCE = TEXT || BALANCE;\n                                             LB = LENGTH(BALANCE);\n                                             TEXT = BCD;\n                                          END;\n                                    END;\n                                 ELSE TEXT = BCD || TEXT;\n                                 BCD = '';\n                                 TEXT_LIMIT = LENGTH(TEXT) - 1;\n                                 CP = 0;\n                                 GO TO SCAN1;\n                              END;\n                        END;\n                        /*  RESERVED WORDS EXIT HIGHER: THEREFORE <IDENTIFIER>*/\n                        TOKEN = IDENT;\n                        RETURN;\n                     END;\n               /*  END OF CARD  */\n               BCD = BCD || TEXT;\n               CALL GET_CARD;\n            END;\n\n            /*  CASE 5  */\n\n            DO;      /*  DIGIT:  A NUMBER  */\n               TOKEN = NUMBER;\n               DO FOREVER;\n                  DO CP = CP TO TEXT_LIMIT;\n                     S1 = BYTE(TEXT, CP);\n                     IF S1 < \"F0\" THEN RETURN;\n                     NUMBER_VALUE = 10*NUMBER_VALUE + S1 - \"F0\";\n                  END;\n                  CALL GET_CARD;\n               END;\n            END;\n\n            /*  CASE 6  */\n\n            DO;      /*  A /:  MAY BE DIVIDE OR START OF COMMENT  */\n               CALL CHAR;\n               IF BYTE(TEXT, CP) \u00ac= BYTE('*') THEN\n                  DO;\n                     TOKEN = DIVIDE;\n                     RETURN;\n                  END;\n               /* WE HAVE A COMMENT  */\n               SCANCOMMENT:\n                  TEXT = SUBSTR(TEXT, CP);\n                  TEXT_LIMIT = TEXT_LIMIT - CP;\n                  DO WHILE \u00acSCAN_FINDS_END_OF (ADDR(COMMENTABLE));\n                     CALL GET_CARD;\n                  END;\n                  IF BYTE(TEXT, CP) = BYTE('$') THEN DO;\n                     /* A CONTROL CHARACTER */\n                     CALL CHAR;\n                     S2 = BYTE(TEXT, CP);\n                        CONTROL(S2) = \u00ac CONTROL(S2);\n                        IF S2 = BYTE('T') THEN CALL TRACE;\n                        ELSE IF S2=BYTE('Y') THEN MCHAR='|' ;\n                        ELSE IF S2 = BYTE('U') THEN CALL UNTRACE;\n                        ELSE IF S2 = BYTE('|') THEN\n                           IF CONTROL(S2) THEN\n                              MARGIN_CHOP = TEXT_LIMIT - CP + 1;\n                           ELSE\n                              MARGIN_CHOP = 0;\n                        GOTO SCANCOMMENT;\n                     END;\n                  /* ELSE FOUND AN ASTERISK */\n                  CALL CHAR;\n                  IF BYTE(TEXT, CP) \u00ac= BYTE('/') THEN\n                     GOTO SCANCOMMENT;\n            END;\n\n            /*  CASE 7  */\n            DO;      /*  SPECIAL CHARACTERS  */\n               TOKEN = TX(BYTE(TEXT));\n               CP = 1;\n               RETURN;\n            END;\n\n            /*  CASE 8  */\n            DO;  /* A |:  MAY BE \"OR\" OR \"CAT\"  */\n               CALL CHAR;\n               IF BYTE(TEXT, CP) = BYTE('|') THEN\n                  DO;\n                     CALL CHAR;\n                     TOKEN = CONCATENATE;\n                  END;\n               ELSE TOKEN = ORSYMBOL;\n               RETURN;\n            END;\n\n         END;     /* OF CASE ON CHARTYPE  */\n         CP = CP + 1;  /* ADVANCE SCANNER AND RESUME SEARCH FOR TOKEN  */\n      END;\n   END SCAN;\n\n\n  /*             ADDRESS AND REGISTER COMPUTATIONS                       */\n\n\nCHECKBASES:\n   PROCEDURE;\n      IF \u00ac COMPILING THEN RETURN;\n      IF DP >= BASES(LASTBASE) + 4096 THEN\n         DO;\n            LASTBASE = LASTBASE - 1;  /* USE REG 11 DOWN TO REG 4 */\n            BASES(LASTBASE) = DP & \"FFFFFC\";\n            INFORMATION = INFORMATION || ' R' || LASTBASE || EQUALS ||\n               BASES(LASTBASE) || PERIOD;\n            IF LASTBASE = 3 THEN CALL ERROR('EXCEEDED DATA AREA',1);\n         END;\n   END  CHECKBASES;\n\nCLEARREGS:\n   PROCEDURE;\n      /* FREE ALL THE ARITHMETIC REGISTERS  */\n      DO I = 0 TO 3;  BASES(I) = AVAIL;  END;\n      TARGET_REGISTER = -1;\n   END  CLEARREGS;\n\nFINDAC:\n   PROCEDURE FIXED;\n      /*  FIND AN ACCUMULATOR FOR 32 BIT QUANTITY  */\n      DECLARE I FIXED;\n      IF TARGET_REGISTER > -1 THEN IF BASES(TARGET_REGISTER) = AVAIL THEN\n         DO;\n            BASES(TARGET_REGISTER) = ACCUMULATOR;\n            RETURN TARGET_REGISTER;\n         END;\n      DO I = 1 TO 3;\n         IF BASES(I) = AVAIL THEN\n            DO;\n               BASES(I) = ACCUMULATOR;\n               RETURN I;\n            END;\n      END;\n      CALL ERROR('USED ALL ACCUMULATORS',0);\n      RETURN 0;\n   END  FINDAC;\n\n\nFINDADDRESS:\n   PROCEDURE (ADR);\n      /* FIND THE APPROPRIATE BASE AND DISPLACEMENT FOR THE ADDRESS  */\n      DECLARE (ADR, I) FIXED;\n      COUNT#FIND = COUNT#FIND + 1;\n      IF ADR < 0 THEN\n         DO;\n            ADRDISP = - ADR;\n            ADREG = SBR;\n            RETURN;\n         END;\n      IF ADR = 0 THEN\n         DO;\n            ADREG,ADRDISP = 0;\n            RETURN;\n         END;\n      DO I = LASTBASE TO DBR;\n         IF BASES(I) <= ADR & BASES(I)+4096 > ADR THEN\n            DO;\n               ADRDISP = ADR - BASES(I);\n               ADREG = I;\n               RETURN;\n            END;\n      END;\n      CALL ERROR('FIND ADDRESS FAILED',1);\n      ADREG,ADRDISP = 0;\n   END  FINDADDRESS;\n\n\n\n\n  /*                    CODE EMISSION PROCEDURES                       */\n\n\nEMITCHAR:\n   PROCEDURE (C);\n      DECLARE C BIT (8);\n      /*  SEND ONE 8-BIT CHARACTER TO THE STRING AREA  */\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || CHP || ': CHARACTER = ' ||\n            SUBSTR(HEXCODES, SHR(C,4), 1) || SUBSTR(HEXCODES, C & \"F\", 1);\n      IF CHP < CHPORG | CHP >= CHPLIM THEN CALL GETSTRINGS;\n      STRINGS(CHP-CHPORG) = C;\n      CHP = CHP + 1;\n   END  EMITCHAR;\n\nEMITBYTE:\n   PROCEDURE (B);\n      DECLARE B FIXED;\n      /*  EMIT ONE BYTE OF DATA  */\n      IF DP < DPORG | DP >= DPLIM THEN CALL GETDATA;\n      DATA(DP-DPORG) = B;\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || DP || ': DATA = ' ||\n            SUBSTR(HEXCODES, SHR(B,4), 1) || SUBSTR(HEXCODES, B & \"F\", 1);\n      DP = DP + 1;\n      CALL CHECKBASES;\n   END EMITBYTE;\n\nEMITCODEBYTES:\n   PROCEDURE (B1,B2);\n      DECLARE (B1, B2) BIT(8), I FIXED;\n      /*  EMIT TWO BYTES OF CODE  */\n      STILLCOND = 0;\n      IF PP < PPORG | PP >= PPLIM THEN CALL GETCODE;\n      I = PP - PPORG;\n      CODE(I) = B1;             /*  FIRST  BYTE  */\n      CODE(I+1) = B2;           /*  SECOND  BYTE  */\n      IF CONTROL(BYTE('B')) THEN\n         OUTPUT = X70 || PP || ': CODE = ' ||\n            SUBSTR(HEXCODES, SHR(B1,4), 1) || SUBSTR(HEXCODES, B1 & \"F\", 1)\n            || SUBSTR(HEXCODES, SHR(B2,4), 1) || SUBSTR(HEXCODES, B2 & \"F\",1);\n      PP =  PP + 2;\n   END  EMITCODEBYTES ;\n\nEMITDATAWORD:\n   PROCEDURE(W);\n      DECLARE (W, I) FIXED;\n      /*  SEND A 32-BIT WORD TO THE DATA ARRAY  */\n      DP = (DP + 3) & \"FFFFFC\";\n      IF DP < DPORG | DP >= DPLIM THEN CALL GETDATA;\n      CALL CHECKBASES;\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || DP || ': DATA = ' || W;\n      I = DP - DPORG;\n      DATA(I) = SHR(W,24);\n      DATA(I+1) = SHR(W,16);\n      DATA(I+2) = SHR(W,8);\n      DATA(I+3) = W;\n      DP = DP + 4;\n      CALL CHECKBASES;\n   END EMITDATAWORD;\n\nEMITDESC:\n   PROCEDURE (D);\n      DECLARE D FIXED;\n      /*  SEND 32-BIT DESCRIPTOR TO STRING DESCRIPTOR AREA  */\n      IF DSP >= 4096 THEN\n         DO;\n            CALL ERROR ('TOO MANY STRINGS', 1);\n            DSP = 0;\n         END;\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || DSP || ': DESC = ' || SHR(D,24) || ', ' ||\n            (D & \"FFFFFF\");\n      DESC(SHR(DSP,2)) = D;\n      DSP = DSP + 4;\n   END EMITDESC;\n\nEMITCONSTANT:\n   PROCEDURE(C);\n      /* SEE IF C HAS ALREADY BEEN EMITED, AND IF NOT EMIT.  SET UP ADDRESS */\n      DECLARE CTAB(100) FIXED, CADD (100) BIT(16), (C, NC, I) FIXED;\n      DO I = 1 TO NC;\n         IF CTAB(I) = C THEN\n            DO;\n               ADREG = SHR(CADD(I),12);\n               ADRDISP = CADD(I) & \"FFF\";\n               RETURN;\n            END;\n      END;\n      CALL EMITDATAWORD (C);\n      CTAB(I) = C;\n      CALL FINDADDRESS(DP-4);\n      CADD(I) = SHL(ADREG,12) + ADRDISP;\n      IF I < 100 THEN NC = I;\n      INFORMATION = INFORMATION || ' C' || I || EQUALS || C || PERIOD;\n   END EMITCONSTANT;\nEMITRR:\n   PROCEDURE (OP, R1, R2);\n      DECLARE (OP, R1, R2) FIXED;\n      /* EMIT A 16-BIT RR FORMAT INSTRUCTION  */\n      COUNT#RR = COUNT#RR + 1;\n      IF CONTROL(BYTE('E')) THEN\n         DO;\n            OP_CODE = SUBSTR(OPNAMES, OPER(OP), 4);\n            OUTPUT = X70 || PP || ': CODE = ' || OP_CODE || X1 || R1\n               || ',' || R2;\n         END;\n      CALL EMITCODEBYTES(OP, SHL(R1,4)+R2);\n      INSTRUCT(OP) = INSTRUCT(OP) + 1;\n   END EMITRR;\n\nEMITRX:\n   PROCEDURE (OP, R1, R2, R3, DISP);\n      DECLARE (OP, R1, R2, R3, DISP) FIXED;\n      /*  EMIT A 32-BIT RX FORMAT INSTRUCTION */\n      COUNT#RX = COUNT#RX + 1;\n      IF CONTROL(BYTE('E')) THEN\n         DO;\n            OP_CODE = SUBSTR(OPNAMES, OPER(OP), 4);\n            OUTPUT = X70 || PP || ': CODE = ' || OP_CODE || X1 || R1\n               || ',' || DISP || '(' || R2 || ',' || R3 || ')';\n         END;\n      CALL EMITCODEBYTES(OP, SHL(R1,4)+R2);\n      CALL EMITCODEBYTES(SHL(R3,4)+SHR(DISP,8), DISP & \"FF\");\n      INSTRUCT(OP) = INSTRUCT(OP) + 1;\n   END EMITRX;\n\n\n  /*                       FIXUP PROCEDURES                                  */\n\n\nINSERT_CODE_FIXUPS:\n   PROCEDURE;\n\n      DECLARE (I, J, L, FXLIM, T1, K) FIXED;\n      DECLARE T2 BIT(8), EXCHANGES BIT(1);\n\n      /* THE FIRST STEP IS TO SORT THE CODE FIXUP TABLE */\n      K,FXLIM = FCP - 1;     EXCHANGES = TRUE;\n      DO WHILE EXCHANGES;  /* QUIT BUBBLE SORT AFTER TABLE QUIETS DOWN */\n         EXCHANGES = FALSE;  /* RESET ON EACH EXCHANGE BELOW */\n         DO J = 0 TO K-1;\n            I = FXLIM-J;\n            L = I-1;\n            IF FIXCADR(L) > FIXCADR(I) THEN\n               DO;  /* SWAP */\n                  T1 = FIXCADR(L);  FIXCADR(L) = FIXCADR(I);  FIXCADR(I) = T1;\n                  T2 = FIXCB1(L);  FIXCB1(L) = FIXCB1(I);  FIXCB1(I) = T2;\n                  T2 = FIXCB2(L);  FIXCB2(L) = FIXCB2(I);  FIXCB2(I) = T2;\n                  EXCHANGES = TRUE;  K = J;\n               END;\n         END;\n      END;\n\n      /* NOW WRITE OUT THE CURRENT BLOCK */\n      FILE(CODEFILE,CURCBLK) = CODE;\n\n      /* WRITE BINARY PROGRAM PATCHES INTO PROGRAM FILE */\n\n      K,PPORG=0;  PPLIM = DISKBYTES;\n      DO J = 0 TO CODEMAX;\n\n         I = K;  /* KEEP TRACK OF K SO THAT WE WILL KNOW WHEN TO READ IN */\n\n         DO WHILE (K <= FXLIM)  &  (FIXCADR(K) < PPLIM);\n            /* IF THE FILE HAS NOT YET BEEN READ IN, DO SO */\n            IF K = I THEN CODE = FILE(CODEFILE,J); /* ONLY IF A FIX IS NEEDED */\n            L = FIXCADR(K) - PPORG;  /* RELATIVE ADDRESS WITHIN THIS BLOCK */\n            CODE(L) = FIXCB1(K);  CODE(L+1) = FIXCB2(K);\n            K = K + 1;\n         END;\n\n         IF K > I THEN    /* A FIXUP WAS DONE */\n            FILE(CODEFILE,J) = CODE;  /* SO WRITE OUT THE CONTENTS */\n\n         PPORG=PPORG+DISKBYTES;\n         PPLIM = PPLIM + DISKBYTES;\n      END;\n\n      FCP = 0;  /* RESET TABLE TO EMPTY */\n      CODE = FILE(CODEFILE,CURCBLK);  /* RESTORE FILE TO PREVIOUS STATE */\n      PPORG = CURCBLK*DISKBYTES;  PPLIM = PPORG + DISKBYTES;\n   END INSERT_CODE_FIXUPS;\n\nFIXCHW:\n   PROCEDURE (ADR, B1, B2);\n      DECLARE ADR FIXED, (B1, B2) BIT(8);\n      /*  FIX UP ONE HALF WORD OF CODE  */\n      COUNT#FIXCHW = COUNT#FIXCHW + 1;\n      IF FCP >= FCLIM THEN\n         CALL INSERT_CODE_FIXUPS;\n      IF PPORG <= ADR & ADR < PPLIM THEN\n         DO;\n            SHORTCFIX = SHORTCFIX + 1;\n            ADR = ADR - PPORG;\n            CODE(ADR) = B1;\n            CODE(ADR+1) = B2;\n         END;\n      ELSE\n         DO;\n            LONGCFIX = LONGCFIX + 1;\n            FIXCADR(FCP) = ADR;\n            FIXCB1(FCP) = B1;\n            FIXCB2(FCP) = B2;\n            FCP = FCP + 1;\n         END;\n   END  FIXCHW;\n\n\nFIXBFW:\n   PROCEDURE (WHERE, VAL);\n      DECLARE (WHERE, VAL, I, J, P) FIXED;\n      IF WHERE = 0 THEN RETURN;\n      /* FIX UP A BRANCH WHOSE ADDRESS WE NOW KNOW */\n      COUNT#FIXBFW = COUNT#FIXBFW + 1;\n      IF CONTROL(BYTE('E')) THEN OUTPUT = X70 || '     ' || WHERE || ': FIXUP ='\n            || VAL;\n      P = WHERE + 2;       /* THE ACTUAL ADDRESS FIELD  */\n      IF WHERE >=  \"1000\" THEN\n         DO;\n            CALL FIXCHW (P, SHL(DBR,4), SHR(VAL,10) & \"FC\");\n            VAL = VAL & \"FFF\";\n            P = P + 4;\n         END;\n      ELSE IF VAL >= \"1000\" THEN\n         DO;\n            I = VAL & \"FFF\";\n            J = SHR(VAL, 12);\n            INSTRUCT(LOAD) = INSTRUCT(LOAD) + 1;\n            INSTRUCT(BC) = INSTRUCT(BC) + 1;\n            CALL EMITDATAWORD (SHL(LOAD, 24) + SHL(BRCHREG, 20) + SHL(DBR, 12)\n                  + SHL(J, 2));\n            CALL EMITDATAWORD(\"47F00000\" +  SHL(BRCHREG,16) + SHL(PBR, 12) + I);\n            CALL FINDADDRESS (DP-8);\n            CALL FIXCHW(P, SHL(ADREG,4)+SHR(ADRDISP,8), ADRDISP & \"FF\");\n            RETURN;\n         END;\n      CALL FIXCHW(P, SHL(PBR,4)+SHR(VAL,8), VAL & \"FF\");\n   END FIXBFW;\n\n\nFIXWHOLEDATAWORD:\n   PROCEDURE (ADR, WORD);\n      DECLARE (ADR, WORD) FIXED;\n      DECLARE (BLK, TEMP) FIXED, REREAD BIT(1);\n      IF CONTROL(BYTE('E')) THEN\n         OUTPUT = X70 || ADR || ':  FIXUP = ' || WORD;\n      COUNT#FIXD = COUNT#FIXD + 1;\n      BLK = ADR/DISKBYTES;\n      REREAD = (CURDBLK \u00ac= BLK);\n      IF REREAD THEN\n         DO;  /* MUST GET THE RIGHT BLOCK  */\n            LONGDFIX = LONGDFIX + 1;\n            TEMP = DP;\n            DP = ADR;\n            CALL GETDATA;\n         END;\n      ELSE SHORTDFIX = SHORTDFIX + 1;\n      ADR = ADR MOD DISKBYTES;\n      DATA(ADR) = SHR(WORD, 24);\n      DATA(ADR+1) = SHR(WORD, 16);\n      DATA(ADR+2) = SHR(WORD, 8);\n      DATA(ADR+3) = WORD;\n      IF REREAD THEN DP = TEMP;\n   END  FIXWHOLEDATAWORD;\n\n\n   /*  S Y M B O L   T A B L E   E N T R Y   A N D   L O O K U P   */\n\n   NULLOUT:\n      PROCEDURE (MAXINDEX);\n         DECLARE (I, MAXINDEX) FIXED;\n         DO I = 0 TO 255;\n            IF BUCKET(I) >= MAXINDEX THEN\n               BUCKET(I) = NULL;\n            END;\n         DO I = 1 TO MAXINDEX - 1;\n            IF SY_LINK(I) >= MAXINDEX THEN\n               SY_LINK(I) = NULL;\n            END;\n      END NULLOUT;\n\n\nENTER:\n   PROCEDURE (SYMB, T, L, LINE);\n      /*  ENTER A SYMBOL IN THE SYMBOL TABLE  */\n      DECLARE (SY_PTR, I, J, K, L, T, LINE) FIXED,\n               SYMB CHARACTER;\n\n      I = LENGTH(SYMB) -1;\n      I = (BYTE(SYMB) + BYTE(SYMB, I) + I + PROC_STACK(LEX_LEVEL)) & \"FF\";\n      SY_PTR = BUCKET(I);\n      IF SY_PTR \u00ac= NULL THEN DO;\nSEARCH_SOMEMORE:  /* DO UNTIL SY_LINK(SY_PTR) = NULL  */\n         IF SYT(SY_PTR) = SYMB THEN DO;\n               IDCOMPARES = IDCOMPARES + 1;\n               K = SYTYPE(SY_PTR);\n               IF T = LABELTYPE & (K = FORWARDTYPE | K = FORWARDCALL) THEN\n                  DO;\n                     IF CONTROL(BYTE('E')) THEN\n                        OUTPUT = X70 || 'FIX REFERENCES TO: ' || SYMB;\n                     J = BASES(SYBASE(SY_PTR)) + SYDISP(SY_PTR);\n                     IF K = FORWARDCALL THEN\n                        IF L > \"FFF\" THEN\n                           L = L+8;\n                        ELSE\n                           L = L+4;\n                     SYBASE(SY_PTR) = SHR(L, 12);\n                     SYDISP(SY_PTR) = L & \"FFF\";\n                     CALL FIXWHOLEDATAWORD(J,L);\n                     SYTYPE(SY_PTR) = T;\n                     DECLARED_ON_LINE(SY_PTR) = LINE;\n                  END;\n               ELSE IF PROCMARK + PARCT < SY_PTR THEN\n                  CALL ERROR('DUPLICATE DECLARATION FOR:  ' || SYMB, 0);\n               ELSE DECLARED_ON_LINE(SY_PTR) = LINE;\n               RETURN SY_PTR;\n            END;\n         IDCOMPARES = IDCOMPARES + 1;\n         IF SY_LINK(SY_PTR) \u00ac= NULL THEN DO;\n            SY_PTR = SY_LINK(SY_PTR);\n            GOTO SEARCH_SOMEMORE;\n            END;\n         NDECSY,         SY_LINK(SY_PTR) = NDECSY + 1;\n         END;\n      ELSE\n         NDECSY,         BUCKET(I) = NDECSY + 1;\n      IF NDECSY > MAXNDECSY THEN\n         IF NDECSY > SYTSIZE THEN\n            DO;\n               CALL ERROR ('SYMBOL TABLE OVERFLOW', 1);\n               NDECSY = NDECSY - 1;\n            END;\n         ELSE MAXNDECSY = NDECSY;\n      SYT(NDECSY) = SYMB;\n      SYTYPE(NDECSY) = T;\n      DECLARED_ON_LINE(NDECSY) = LINE;\n      SYTCO(NDECSY) = 0;\n      IF T = LABELTYPE THEN\n         DO;\n            SYBASE(NDECSY) = SHR(L, 12);  /* PAGE  */\n            SYDISP(NDECSY) = L & \"FFF\";\n         END;\n      ELSE\n         DO;\n            CALL FINDADDRESS(L);\n            SYBASE(NDECSY) = ADREG;\n            SYDISP(NDECSY) = ADRDISP;\n         END;\n      RETURN NDECSY;\n   END  ENTER;\n\nID_LOOKUP:\n   PROCEDURE (P);\n       /* LOOKS UP THE IDENTIFIER AT P IN THE ANALYSIS STACK IN THE\n          SYMBOL TABLE AND INITIALIZES FIXL,CNT,TYPE,REG,INX\n          APPROPRIATELY.  IF THE IDENTIFIER IS NOT FOUND, FIXL IS\n          SET TO -1\n       */\n      DECLARE (P, I, L, SY_PTR) FIXED,\n              CHAR_TEMP CHARACTER;\n       CHAR_TEMP = VAR(P);\n      L = LEX_LEVEL;\n      I = LENGTH(CHAR_TEMP) -1;\n      I = BYTE(CHAR_TEMP) + BYTE(CHAR_TEMP, I) + I;\n      DO WHILE L >= 0;\n          SY_PTR = BUCKET((I + PROC_STACK(L)) & \"FF\");\n         DO WHILE SY_PTR \u00ac= NULL;\n            IF SYT(SY_PTR) = CHAR_TEMP THEN DO;\n               IDCOMPARES = IDCOMPARES + 1;\n               FIXL(P) = SY_PTR;\n               CNT(P) = 0;   /* INITIALIZE SUBSCRIPT COUNT  */\n               TYPE(P) = VARIABLE;\n               IF SYTYPE(SY_PTR) = SPECIAL THEN\n                  FIXV(P) = SYDISP(SY_PTR);     /* BUILTIN FUNCTION */\n               ELSE\n                  FIXV(P) = 0;               /* \u00ac BUILTIN FUNCTION */\n               REG(P),INX(P) = 0;   /* INITIALIZE REGISTER POINTERS */\n               SYTCO(SY_PTR) = SYTCO(SY_PTR) + 1;  /* COUNT REFERENCES */\n               RETURN;\n               END;\n            SY_PTR = SY_LINK(SY_PTR);\n            IDCOMPARES = IDCOMPARES + 1;\n            END;\n         L = L - 1;\n         END;\n      FIXL(P) = -1;      /*  IDENTIFIER NOT  FOUND */\n   END   ID_LOOKUP;\n\n\nUNDECLARED_ID:\n   PROCEDURE (P);\n      /* ISSUES AN ERROR MESSAGE FOR UNDECLARED IDENTIFIERS AND\n         ENTERS THEM WITH DEFAULT TYPE IN THE SYMBOL TABLE\n      */\n      DECLARE P FIXED;\n      CALL ERROR('UNDECLARED IDENTIFIER:  ' || VAR(P) ,0);\n      CALL EMITDATAWORD(0);\n      CALL ENTER (VAR(P), FIXEDTYPE, DP-4, CARD_COUNT);\n      CNT(P) = 0;\n      FIXV(P) = 0;\n      REG(P) = 0;\n      INX(P) = 0;\n      FIXL(P) = NDECSY;\n      SYTCO(NDECSY) = 1;                /* COUNT FIRST REFERENCE */\n      TYPE(P) = VARIABLE;\n   END  UNDECLARED_ID;\n\nSETINIT:\n   PROCEDURE;\n      /*  PLACES INITIAL VALUES INTO DATA AREA */\n\n      DECLARE (I, J) FIXED;\n      IF ITYPE = CHRTYPE THEN\n         DO;\n            IF TYPE(MPP1) \u00ac= CHRTYPE THEN VAR(MPP1) = FIXV(MPP1);\n            S = VAR(MPP1);    /* THE STRING */\n            I = LENGTH(S) - 1;\n\n            IF I < 0 THEN\n               CALL EMITDESC(0);\n            ELSE\n               CALL EMITDESC(SHL(I,24) + CHP);\n\n            DO J = 0 TO I;\n               CALL EMITCHAR(BYTE(S,J));\n            END;\n         END;\n      ELSE IF TYPE(MPP1) \u00ac= CONSTANT THEN\n         CALL ERROR ('ILLEGAL CONSTANT IN INITIAL LIST');\n      ELSE IF ITYPE = FIXEDTYPE THEN\n         CALL EMITDATAWORD(FIXV(MPP1));\n      ELSE IF ITYPE = HALFWORD THEN\n         DO;\n            /*  FIRST FORCE ALIGNMENT  */\n            DP = (DP + 1) & \"FFFFFE\";\n            CALL EMITBYTE (SHR(FIXV(MPP1), 8));\n            CALL EMITBYTE(FIXV(MPP1) & \"FF\");\n         END;\n      ELSE IF ITYPE = BYTETYPE THEN\n         CALL EMITBYTE(FIXV(MPP1));\n   END  SETINIT;\n\nALLOCATE :\n   PROCEDURE(P,DIM);\n      /* ALLOCATES STORAGE FOR THE IDENTIFIER AT P IN THE ANALYSIS\n         STACK WITH DIMENSION DIM\n      */\n\n      DECLARE (P, DIM, J) FIXED;\n\n\n   CHECK_NEWDP:\n      PROCEDURE;\n         DECLARE T FIXED;\n         T = DP;\n         DP = NEWDP;\n         CALL CHECKBASES;\n         DP = T;\n      END  CHECK_NEWDP;\n\n\n\n      DIM = DIM + 1;         /* ACTUAL NUMBER OF ITEMS  */\n      DO CASE TYPE(P);\n\n         ;     /*  CASE  0    DUMMY        */\n\n         DO;      /*   CASE 1    HALFWORD  */\n            NEWDP = (NEWDP + 1) & \"FFFFFE\";   /* ALIGN HALFWORD  */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + SHL(DIM, 1);\n         END;\n\n\n         ;     /*  CASE  2    LABEL TYPE         */\n\n\n          ;    /*  CASE  3    ACCUMULATOR        */\n\n          ;    /*  CASE  4    VARIABLE           */\n\n          ;    /*  CASE  5    CONSTANT           */\n\n          ;    /*  CASE  6    CONDITION          */\n\n          DO;  /*  CASE  7    CHARACTER TYPE     */\n            J = -NEWDSP;\n            NEWDSP = NEWDSP + SHL(DIM,2);\n          END;\n\n          DO;  /*  CASE  8    FIXED TYPE         */\n            NEWDP = (NEWDP + 3) & \"FFFFFC\";    /* ALIGN TO WORD */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + SHL(DIM,2);\n          END;\n\n          DO;  /*  CASE  9    BYTE TYPE          */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + DIM;\n          END;\n\n         DO;  /*  CASE 10    FORWARD TYPE  (LABEL)  */\n            NEWDP = (NEWDP+3) & \"FFFFFC\";  /* WORD ALIGN */\n            CALL CHECK_NEWDP;\n            J = NEWDP;\n            NEWDP = NEWDP + SHL(DIM,2);        /* SPACE FOR FIXUPS  */\n         END;\n\n          ;    /*  CASE 11    DESCRIPT           */\n\n          ;    /*  CASE 12    SPECIAL            */\n\n          ;    /*  CASE 13    FORWARD CALL       */\n\n          ;    /*  CASE 14    CHAR_PROC_TYPE             */\n\n          ;    /*  CASE 15    UNUSED             */\n\n      END; /*  OF DO CASE TYPE(P)  */\n\n      SYTYPE(FIXL(P)) = TYPE(P);\n      CALL FINDADDRESS(J);\n      SYBASE(FIXL(P)) = ADREG;\n      SYDISP(FIXL(P)) = ADRDISP;\n\n   END  ALLOCATE;\n\n\nTDECLARE:\n   PROCEDURE (DIM);\n      /*  ALLOCATES STORAGE FOR IDENTIFIERS IN DECLARATIONS  */\n      DECLARE DIM FIXED;\n      NEWDP = DP;\n      NEWDSP = DSP;\n      TYPE(MP) = TYPE(SP);\n      CASEP = FIXL(MP);\n      DO I = 1 TO INX(MP);\n         FIXL(MP) = CASESTACK(CASEP+I);      /* SYMBOL TABLE POINTER */\n         CALL ALLOCATE(MP, DIM);\n      END;\n   END  TDECLARE;\n\n\n\n\nMOVESTACKS:\n   PROCEDURE (F,T);\n      DECLARE F FIXED, T FIXED;\n      /*  MOVE ALL THE COMPILER STACKS DOWN FROM F TO T  */\n      TYPE(T) = TYPE(F);  VAR(T) = VAR(F);\n      FIXL(T) = FIXL(F);  FIXV(T) = FIXV(F);\n      INX(T) = INX(F);    REG(T) = REG(F);\n      PPSAVE(T) = PPSAVE(F);  CNT(T) = CNT(F);\n   END  MOVESTACKS;\n\n\n\n\n  /*                        BRANCH PROCEDURES                                */\n\n\n\nBRANCH_BD:\n   PROCEDURE(COND, B, D);\n      DECLARE (COND, B, D) FIXED;\n      /*  BRANCHES ARE A SPECIAL CASE.  IF THEY ARE INTO THE 1ST  4096\n         BYTES OF PROGRAM A SINGLE BRANCH WILL SUFFICE.  OTHERWISE WE\n         MUST INDEX WITH A CONSTANT IN BRCHREG TO GET ANYWHERE.\n      */\n      IF B = 0 THEN\n         CALL EMITRX(BC, COND, 0, PBR, D);\n      ELSE\n    DO;\n            CALL EMITRX(LOAD,BRCHREG,0,DBR,SHL(B,2));\n            CALL EMITRX(BC, COND, BRCHREG, PBR, D);\n         END;\n   END  BRANCH_BD;\n\n\nBRANCH:\n   PROCEDURE (COND, LOCATION);\n      DECLARE (COND, LOCATION) FIXED;\n      IF LOCATION = 0 THEN LOCATION = PP;\n      /* ASSUME FIXUP WILL BE NEAR  */\n      CALL BRANCH_BD(COND, SHR(LOCATION,12), LOCATION & \"FFF\");\n   END BRANCH;\n\n\n\n\n  /*                     EXPRESSIONS                                         */\n\n\nCONDTOREG:\n   PROCEDURE (MP, CC);\n      DECLARE (MP, CC, J) FIXED;\n      J = FINDAC;\n      CALL EMITRX(LA, J, 0, 0, 0);\n      IF PP < 4084 THEN\n         CALL BRANCH(CC, PP+8);\n      ELSE\n         CALL BRANCH(CC, PP+12);\n      CALL EMITRX(LA, J, 0, 0, 1);\n      TYPE(MP) = ACCUMULATOR;\n      REG(MP) = J;\n      STILLCOND = CC;\n   END CONDTOREG;\n\nBRLINK_BD:\n   PROCEDURE (BASE,DISP);\n      DECLARE (BASE, DISP) FIXED;\n      IF BASE = 0 THEN\n         CALL EMITRX(BAL, BRCHREG, 0, PBR, DISP);\n      ELSE\n         DO;\n            CALL EMITRX(LOAD, BRCHREG, 0, DBR, SHL(BASE,2));\n            CALL EMITRX(BAL, BRCHREG, BRCHREG, PBR, DISP);\n         END;\n    END BRLINK_BD;\n\n\n   /*                  CODE FOR PROCEDURES                                   */\n\n\nSAVE_REGISTERS:\n   PROCEDURE;\n      /* GENERATES CODE TO SAVE REGISTERS BEFORE A PROCEDURE OR\n         FUNCTION CALL\n      */\n      DECLARE I FIXED;\n      DO I = 1 TO 3;\n         IF BASES(I) \u00ac= AVAIL THEN\n            DO;\n               CALL EMITDATAWORD(0);\n               CALL FINDADDRESS(DP-4);\n               TEMP(I) = SHL(ADREG,12)+ ADRDISP;\n               CALL EMITRX(STORE,I,0,ADREG,ADRDISP);\n            END;\n         ELSE\n            TEMP(I) = 0;\n      END;\n   END  SAVE_REGISTERS;\n\n\nUNSAVE_REGISTERS:\n   PROCEDURE (R,P);\n      /*  GENERATES CODE TO RESTORE REGISTERS AFTER A FUNCTION\n          OR PROCEDURE CALL AND ALSO DOES SOME HOUSEKEEPING\n      */\n      DECLARE (R, P, I, J) FIXED;\n      IF BASES(R) \u00ac= AVAIL THEN\n         DO;\n            J = FINDAC;\n            CALL EMITRR(\"18\", J, R);\n         END;\n      ELSE\n         J = R;\n      DO I = 1 TO 3;\n         IF TEMP(I) \u00ac= 0 THEN\n            CALL EMITRX(LOAD,I,0,SHR(TEMP(I),12), TEMP(I)&\"FFF\");\n      END;\n      TYPE(P) = ACCUMULATOR;\n      REG(P) = J;\n      BASES(J) = ACCUMULATOR;\n   END  UNSAVE_REGISTERS;\n\n\n\n\nCALLSUB:\n   PROCEDURE (SB,SD, R, P);\n      DECLARE (SB, SD, R, P) FIXED;\n      CALL SAVE_REGISTERS;\n      CALL BRLINK_BD(SB,SD);\n      CALL UNSAVE_REGISTERS(R, P);\n   END  CALLSUB;\n\n\nCALLSUB_FORWARD:\n   PROCEDURE (SB,SD,R,P);\n      DECLARE (SB, SD, R, P) FIXED;\n      CALL SAVE_REGISTERS;\n      CALL EMITRX(LOAD, BRCHREG, 0, SB,SD);\n      CALL EMITRX(BAL, BRCHREG, BRCHREG, PBR, 0);\n      CALL UNSAVE_REGISTERS(R, P);\n   END  CALLSUB_FORWARD;\n\n\n\nFORCE_ADDRESS:\n   PROCEDURE (SP,R);\n      /* GENERATES THE ADDRESS OF THE <VARIABLE> IN THE ANALYSIS\n         STACK AT SP IN REGISTER R.\n      */\n      DECLARE (SP, R, K, INXSP) FIXED;\n      IF SYTYPE(FIXL(SP)) = LABELTYPE THEN\n         DO;\n            K = FIXL(SP);\n            IF SYBASE(K) = 0 THEN\n               CALL EMITRX(LA,R,0,PBR,SYDISP(K));\n            ELSE\n               DO;\n                  CALL EMITRX(LOAD,R,0,DBR,SHL(SYBASE(K),2));\n                  CALL EMITRX(LA,R,R,PBR,SYDISP(K));\n               END;\n         END;\n      ELSE\n         DO;\n            K = SYTYPE(FIXL(SP));\n            INXSP = INX(SP);\n            IF INXSP \u00ac= 0 THEN\n               DO;\n                  IF K \u00ac= BYTETYPE THEN\n                     IF K = HALFWORD THEN\n                        CALL EMITRR (\"1A\", INXSP, INXSP);\n                     ELSE\n                        CALL EMITRX(\"89\",INXSP,0,0,2);\n               END;\n                  BASES(INXSP) = AVAIL;\n            IF K = FORWARDTYPE | K = FORWARDCALL THEN\n               DO;\n                  K = FIXL(SP);\n                  CALL EMITRX(LOAD,R,0,SYBASE(K),SYDISP(K));\n                  CALL EMITRR(\"1A\",R,PBR);\n               END;\n            ELSE\n               CALL EMITRX(LA,R,INXSP,SYBASE(FIXL(SP)),SYDISP(FIXL(SP)));\n         END;\n   END  FORCE_ADDRESS;\n\n\nFILE_PSEUDO_ARRAY:\n   PROCEDURE (VARP,FILEP, DIRECTION);\n      /* PROCEDURE TO GENERATE CODE FOR THE FILE PSEUDO ARRAY.\n         TWO FORMS ARE HANDLED:\n\n               <VARIABLE>  =  FILE(I,J);\n\n               FILE(I,J)  =  <VARIABLE>;\n\n         VARP IS A POINTER TO THE <VARIABLE> IN THE ANALYSIS STACKS.\n         FILEP IS A POINTER TO THE ANALYSIS STACK WHERE FILE(I,J)\n         HAS BEEN ASSIMILATED UNDER THE GUISE OF A SUBSCRIPTED\n         VARIABLE.  DIRECTION = 0 FOR THE FIRST CASE (READ) AND\n         DIRECTION = 4 FOR THE SECOND CASE (WRITE).  I IS THE FILE\n         INDEX (I = 1,2,3) AND J IS THE RELATIVE RECORD WITHIN THE\n         FILE.  THE GENERATED CODE SHOULD HAVE THE SAME EFFECT AS;\n\n               LA   0,<VARIABLE>\n               L    1,I\n               SLL  1,3                 I*8\n               LA   1,DIRECTION+44(,1)\n               L    2,J\n               BALR BRCHREG,IOREG\n\n         REGISTERS 0-3 ARE NOT PRESERVED ACROSS THE MONITOR CALL,\n         HENCE ALL REGISTERS ARE FREED,\n\n      */\n      DECLARE (VARP, DIRECTION, FILEP, R) FIXED;\n      IF TYPE(VARP) = VARIABLE THEN\n         DO;\n            CALL FORCE_ADDRESS(VARP,0);\n            CALL EMITRX(\"89\",REG(FILEP),0,0,3);   /*  I*8  */\n            R = FINDAC;\n            IF INX(FILEP) = 1 THEN\n               DO;                      /*  JUGGLE REGISTERS  */\n                  CALL EMITRR(\"18\",R,1);\n                  INX(FILEP) = R;\n               END;\n            CALL EMITRX(LA,1,0,REG(FILEP),44+DIRECTION);\n            IF INX(FILEP) \u00ac= 2 THEN\n               CALL EMITRR(\"18\",2,INX(FILEP));    /*  J    */\n            CALL EMITRR(BALR,BRCHREG,IOREG);\n            TYPE(FILEP) = SPECIAL;      /*  NO MORE ASSIGNMENTS  */\n            CALL CLEARREGS;            /*  FREE ALL REGISTERS  */\n         END;\n      ELSE\n         CALL ERROR('ILLEGAL USE OF FILE PSEUDO ARRAY',1);\n   END  FILE_PSEUDO_ARRAY;\n\n\nEMIT_INLINE:\n   PROCEDURE;\n\n      /* GENERATES CODE FOR THE PSEUDO FUNCTION INLINE                */\n\n      DECLARE BINLM CHARACTER INITIAL ('BAD ARGUMENT TO INLINE');\n\n      IF CNT(MP) < 4 THEN\n         DO;\n            IF TYPE(MPP1) = CONSTANT THEN\n               DO CASE CNT(MP);\n\n                  ;                              /* NO CASE 0 */\n\n                  FIXL(MP) = FIXV(MPP1);         /* SAVE OP CODE */\n\n                  DO;                            /* SAVE R1  */\n                     TYPE(MP) = ACCUMULATOR;\n                     REG(MP) = FIXV(MPP1);\n                  END;\n\n                  CALL EMITCODEBYTES(FIXL(MP), SHL(REG(MP), 4) +\n                     FIXV(MPP1));\n                                                 /* EMIT  OP R1 X  */\n               END;\n            ELSE\n               CALL ERROR(BINLM,1);\n         END;\n      ELSE IF TYPE(MPP1) = CONSTANT THEN\n         DO;\n            IF CNT(MP) & 1 THEN\n               CALL EMITCODEBYTES(INX(MP)+SHR(FIXV(MPP1), 8),\n                  FIXV(MPP1));\n                                       /* EMIT  B DDD  */\n            ELSE\n               INX(MP) = SHL(FIXV(MPP1), 4);      /* SAVE BASE REG  */\n         END;\n      ELSE IF TYPE(MPP1) = VARIABLE THEN\n         DO;\n            CNT(MP) = CNT(MP) + 1;\n            IF CNT(MP) & 1 THEN\n               CALL EMITCODEBYTES(SHL(SYBASE(FIXL(MPP1)), 4) +\n                                  SHR(SYDISP(FIXL(MPP1)), 8) ,\n                                  SYDISP(FIXL(MPP1)));\n            ELSE\n               CALL ERROR(BINLM, 1);\n         END;\n      ELSE\n         CALL ERROR(BINLM, 1);\n\n   END  EMIT_INLINE;\n\n\n\n\nPROC_START:\n   PROCEDURE;\n      /*  GENERATES CODE FOR THE HEAD OF A PROCEDURE */\n\n      DECLARE I FIXED;\n      I = FIXL(MP);\n      FIXL(MP) = PP;\n      CALL BRANCH(\"F\",0);    /*  BRANCH AROUND  */\n      CALL EMITDATAWORD(0);  /*  PLACE TO STORE RETURN ADDRESS */\n      PPSAVE(MP) = RTNADR;\n      RTNADR = DP - 4;\n      CALL FINDADDRESS(RTNADR);\n      SYBASE(I) = SHR(PP,12);          /* ADDRESS OF THE PROCEDURE  */\n      SYDISP(I) = PP & \"FFF\";\n      CALL EMITRX(STORE, BRCHREG,0,ADREG,ADRDISP);\n   END  PROC_START;\n\nSTUFF_PARAMETER:\n   PROCEDURE;\n      /* GENERATES CODE TO SEND AN ACTUAL PARAMETER TO A PROCEDURE */\n      I = FIXL(MP) + CNT(MP);\n      IF LENGTH(SYT(I)) = 0 THEN\n         DO;\n            IF SYTYPE(I) = BYTETYPE THEN\n               J = \"42\";           /*  STC  */\n            ELSE IF SYTYPE(I) = HALFWORD THEN\n               J = \"40\";\n            ELSE\n               J = STORE;         /*  ST  */\n            CALL EMITRX(J, REG(MPP1), 0, SYBASE(I), SYDISP(I));\n            BASES(REG(MPP1)) = AVAIL;\n         END;\n      ELSE\n         CALL ERROR('TOO MANY ACTUAL PARAMETERS', 1);\n   END  STUFF_PARAMETER;\n\n\nCHECK_STRING_OVERFLOW:\n   PROCEDURE;\n      DECLARE (I, BR_SAVE) FIXED;\n      CALL EMITRX (LOAD, 0, 0, DBR, TSA);\n      CALL EMITRX (CMPR, 0, 0, DBR, LIMITWORD);\n      I = PP;\n      CALL BRANCH (4, 0);\n      CALL EMITDATAWORD(0);  BR_SAVE = DP - 4;\n      CALL FINDADDRESS(BR_SAVE);\n      CALL EMITRX(STORE, BRCHREG, 0, ADREG, ADRDISP);\n      IF SYTYPE (STRING_RECOVER) = LABELTYPE THEN\n         CALL CALLSUB(SYBASE(STRING_RECOVER),SYDISP(STRING_RECOVER), 0,\n            STACKSIZE);\n      ELSE\n         CALL CALLSUB_FORWARD(SYBASE(STRING_RECOVER),\n            SYDISP(STRING_RECOVER), 0, STACKSIZE);\n      BASES(REG(STACKSIZE)) = AVAIL;\n      CALL FINDADDRESS (BR_SAVE);\n      CALL EMITRX(LOAD,BRCHREG,0,ADREG,ADRDISP);\n      SYTCO(STRING_RECOVER) = SYTCO(STRING_RECOVER) + 1;\n      CALL EMITRR (\"1B\", 0, 0);\n      CALL FINDADDRESS (STRL);\n      CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);\n      CALL FIXBFW (I, PP);\n   END CHECK_STRING_OVERFLOW;\n\n\nFORCEACCUMULATOR:\n   PROCEDURE (P);\n      DECLARE P FIXED;\n      /* FORCE THE OPERAND AT P INTO AN ACCUMULATOR */\n      DECLARE (R, SB, SD, TP, SFP) FIXED, T1 CHARACTER;\n      COUNT#FORCE = COUNT#FORCE + 1;\n      TP = TYPE(P);\n      IF TP = CONDITION THEN CALL CONDTOREG (P, REG(P));\n      ELSE IF TP = VARIABLE THEN\n         DO;\n            SB = SYBASE(FIXL(P));\n            SD = SYDISP(FIXL(P));\n            SFP = SYTYPE(FIXL(P));\n            IF SFP = LABELTYPE | SFP = CHAR_PROC_TYPE THEN\n               DO;\n                  CALL CALLSUB(SB,SD,3,P);\n                  IF LENGTH(SYT(FIXL(P)+CNT(P)+1)) = 0 THEN\n                     IF CONTROL(BYTE('N')) THEN\n                        OUTPUT = '** WARNING--NOT ALL PARAMETERS SUPPLIED';\n                  IF SFP = CHAR_PROC_TYPE THEN\n                     TYPE(P) = DESCRIPT;\n               END;\n            ELSE IF SFP = FORWARDTYPE | SFP = FORWARDCALL THEN\n               DO;\n                  CALL CALLSUB_FORWARD(SB,SD,3,P);\n                  SYTYPE(FIXL(P)) = FORWARDCALL;\n               END;\n            ELSE  IF SFP = SPECIAL THEN\n               DO;\n                  CALL EMITRX(\"90\", 1, 3, DBR, IO_SAVE);\n                  IF SD = 6 THEN\n                     DO;  /*  INPUT */\n                        CALL CHECK_STRING_OVERFLOW;\n                        IF REG(P) = 0 THEN CALL EMITRR (\"1B\", 2, 2);\n                        ELSE IF REG(P)\u00ac=2 THEN CALL EMITRR(\"18\", 2, REG(P));\n                        BASES(REG(P)) = AVAIL;\n                        CALL FINDADDRESS (TSA);\n                        CALL EMITRX (LOAD, 0, 0, ADREG, ADRDISP);\n                        /* THIS IS A POINTER TO THE FIRST FREE STRING AREA*/\n                        CALL EMITRX (LA, 1, 0, 0, 4); /* 4 IS READ CARD  */\n                        CALL EMITRR (BALR, BRCHREG, IOREG); /* MONITOR CALL*/\n                        /* MOVE FREE STRING AREA POINTER */\n                        CALL EMITRX (STORE, 1, 0, ADREG, ADRDISP);\n                        CALL FINDADDRESS (STRL);/* LAST COMPUTED STRING */\n                        CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);\n                        REG(P) = 0;\n                        TYPE(P) = DESCRIPT;\n                     END;\n                  ELSE IF SD = 8 THEN\n                     CALL FILE_PSEUDO_ARRAY(P-2,P,0);\n                  ELSE IF SD >= 11 & SD <= 18 THEN\n                     DO;\n                        /* TRACE, UNTRACE, EXIT, TIME, DATE, ETC.         */\n                        IF SD = 15 THEN R = 1; ELSE R = 0;\n                        IF SD > 15 THEN\n                           DO;\n                              IF REG(P) \u00ac= 0 THEN\n                                 CALL EMITRR (\"18\", 0, REG(P));\n                              BASES(REG(P)) = AVAIL;\n                              IF INX(P) \u00ac= 2 THEN\n                                 CALL EMITRR (\"18\", 2, INX(P));\n                              BASES(INX(P)) = AVAIL;\n                           END;\n                        /* SET UP MONITOR REQUEST CODE */\n                        CALL EMITRX(LA,1,0,0,SHL(SD-R,2)-32);\n                        /* MONITOR CALL */\n                        CALL EMITRR (BALR, BRCHREG, IOREG);\n                        TYPE(P) = ACCUMULATOR;\n                        IF R \u00ac= 0 THEN\n                           CALL EMITRR (\"18\", 0, R);\n                        REG(P) = 0;\n                     END;\n                  ELSE CALL ERROR (' ILLEGAL USE OF ' || SYT(FIXL(P)));\n                  CALL EMITRX (\"98\", 1, 3, DBR, IO_SAVE);\n               END;\n            ELSE\n               DO;  /* FETCH THE VARIABLE (ALL ELSE HAS FAILED) */\n                  IF SFP \u00ac= BYTETYPE THEN\n                     DO;\n                        IF INX(P) \u00ac= 0 THEN\n                          DO;\n                           IF SFP = HALFWORD THEN\n                              CALL EMITRR (\"1A\", INX(P), INX(P));\n                           ELSE\n                              CALL EMITRX (\"89\", INX(P), 0, 0, 2);\n                           /* SHIFT INDEX FOR WORD-TYPE ARRAY */\n                          R = INX(P);\n                          END;\n                        ELSE R = FINDAC;\n                        IF SFP = HALFWORD THEN TP = \"48\";\n                        ELSE TP = LOAD;\n                           CALL EMITRX(TP,R,INX(P),SYBASE(FIXL(P)),\n                        SYDISP(FIXL(P)));\n                     END;\n                  ELSE\n                     DO;\n                        R = FINDAC;\n                        CALL EMITRR (\"1B\", R, R); /* CLEAR R */\n                           CALL EMITRX(\"43\",R,INX(P),SYBASE(FIXL(P)),\n                        SYDISP(FIXL(P)));\n                        /* INSERT CHARACTER */\n                        BASES(INX(P)) = AVAIL;\n                     END;\n                  IF SFP = CHRTYPE THEN TYPE(P) = DESCRIPT;\n                     ELSE TYPE(P) = ACCUMULATOR;\n                  REG(P) = R;\n               END;\n         END;\n            ELSE IF TP = CONSTANT THEN\n               DO;\n                  R = FINDAC;\n                  /* FETCH A CONSTANT INTO AN ACCUMULATOR */\n                  IF FIXV(P) = 0 THEN CALL EMITRR(\"1B\", R, R);\n                  ELSE IF FIXV(P) < \"1000\" & FIXV(P) >= 1 THEN\n                     CALL EMITRX(LA, R, 0, 0, FIXV(P));\n                     ELSE\n                        DO;\n                           CALL EMITCONSTANT (FIXV(P));\n                           CALL EMITRX (LOAD, R, 0, ADREG, ADRDISP);\n                        END;\n                  TYPE(P) = ACCUMULATOR;\n                  REG(P) = R;\n               END;\n            ELSE IF TP = CHRTYPE THEN\n               DO;\n                  R = FINDAC;\n                  TYPE(P) = DESCRIPT;\n                  REG(P) = R;\n                  T1 = VAR(P);\n                  SD = LENGTH(T1) - 1;\n                  IF SD < 0 THEN\n                     CALL EMITRR(\"1B\",R,R); /* CLEAR  REG R, NULL STRING */\n                  ELSE\n                     DO;\n                        CALL FINDADDRESS (-DSP);\n                        /* MAKE UP A DESCRIPTOR */\n                        CALL EMITDESC(SHL(SD,24)+CHP);\n                        DO I = 0 TO SD;\n                           CALL EMITCHAR(BYTE(T1, I));\n                        END;\n                        CALL EMITRX (LOAD, R, 0, ADREG, ADRDISP);\n                     END;\n               END;\n            ELSE IF TP \u00ac= ACCUMULATOR THEN IF TP \u00ac= DESCRIPT THEN\n               CALL ERROR ('FORCEACCUMULATOR FAILED ***', 1);\n   END FORCEACCUMULATOR;\n\nFORCEDESCRIPT:\n   PROCEDURE (P);\n      /* GET A DESCRIPTOR FOR THE OPERAND P */\n      DECLARE P FIXED;\n      CALL FORCEACCUMULATOR (P);\n      IF TYPE(P) \u00ac= DESCRIPT THEN\n         DO;\n            CALL EMITRX (STORE, REG(P), 0, DBR, STRN);\n            /* STORE IN PARAMETER LOCATION FOR NUMBER-TO -DECIMAL-STRING */\n            BASES(REG(P)) = AVAIL;\n            CALL CALLSUB(0,NMBRNTRY,3,P);\n            /* ASSUMES NUMBER-TO-STRING IS IN THE 1ST PAGE */\n            TYPE(P) = DESCRIPT;\n         END;\n   END FORCEDESCRIPT;\n\nGENSTORE:\n   PROCEDURE (MP, SP);\n      DECLARE (MP, SP, SFP, SB, SD) FIXED;\n      COUNT#STORE = COUNT#STORE + 1;\n      IF TYPE(SP) = SPECIAL THEN RETURN;\n      /* GENERATE TYPE CONVERSION (IF NECESSARY) & STORAGE CODE --\n            ALSO HANDLES OUTPUT AND FILE ON LEFT OF REPLACE OPERATOR */\n      SB = SYBASE(FIXL(MP));\n      SD = SYDISP(FIXL(MP));\n      SFP = SYTYPE(FIXL(MP));\n      IF SFP = SPECIAL THEN\n         DO;\n            IF SD = 3 THEN      /*  FUNCTION BYTE ON THE LEFT */\n               DO;\n                  CALL FORCEACCUMULATOR(SP);\n                  CALL EMITRX(\"42\",REG(SP),INX(MP),REG(MP),0);\n               END;\n            ELSE IF SD = 7 THEN\n               DO;      /* OUTPUT   */\n                  CALL EMITRX(\"90\",1,3,DBR,IO_SAVE);\n                  TARGET_REGISTER = 0;\n                  CALL FORCEDESCRIPT (SP);\n                  TARGET_REGISTER = -1;\n                  IF REG(SP) \u00ac= 0 THEN CALL EMITRR (\"18\", 0, REG(SP));\n                  IF REG(MP) = 0 THEN CALL EMITRR (\"1B\", 2, 2);\n                  ELSE IF REG(MP) \u00ac= 2 THEN CALL EMITRR (\"18\", 2, REG(MP));\n                  BASES(REG(MP)) = AVAIL;\n                  CALL EMITRX (LA, 1, 0, 0, 8);  /* 8 = PRINT CODE */\n                  CALL EMITRR (BALR, BRCHREG, IOREG); /* MONITOR CALL */\n                  CALL EMITRX(\"98\",1,3,DBR,IO_SAVE);\n               END;\n            ELSE IF SD = 8 THEN\n               CALL FILE_PSEUDO_ARRAY(SP,MP,4);\n            ELSE CALL ERROR ('ILLEGAL USE OF ' || SYT(FIXL(MP)));\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (SP);\n            IF TYPE(SP) \u00ac= SPECIAL THEN\n               DO;\n                  IF SFP=FIXEDTYPE & TYPE(SP)=ACCUMULATOR | SFP=CHRTYPE THEN\n                     DO;\n                        IF SFP = CHRTYPE THEN CALL FORCEDESCRIPT (SP);\n                        /* SHIFT INDEX FOR WORD ARRAY */\n                        IF INX(MP) \u00ac= 0 THEN CALL EMITRX (\"89\", INX(MP),0,0,2);\n                        CALL EMITRX(STORE,REG(SP),INX(MP),SB,SD);\n                     END;\n                  ELSE IF SFP = HALFWORD & TYPE(SP) = ACCUMULATOR THEN\n                     DO;\n                        IF INX(MP) \u00ac= 0 THEN CALL EMITRR (\"1A\",INX(MP),INX(MP));\n                        CALL EMITRX (\"40\", REG(SP), INX(MP), SB, SD);\n                     END;\n                  ELSE IF SFP = BYTETYPE & TYPE(SP) = ACCUMULATOR THEN\n                     CALL EMITRX(\"42\",REG(SP),INX(MP),SB,SD); /* STC */\n                  ELSE CALL ERROR('ASSIGNMENT NEEDS ILLEGAL TYPE CONVERSION');\n               END;\n         END;\n      BASES(INX(MP)) = AVAIL;\n      BASES(REG(SP)) = AVAIL;\n      CALL MOVESTACKS (SP, MP);\n   END GENSTORE;\n\nSTRINGCOMPARE:\n   PROCEDURE;\n      /* GENERATES THE CODE TO COMPARE THE STRINGS AT SP & MP */\n      DECLARE (I, J, K) FIXED;\n      CALL FORCEDESCRIPT (SP);  /* GET THE DESCRIPTOR FOR THE SECOND OPERAND */\n      I = 6 - REG(MP) - REG(SP);  /* FIND THE THIRD REGISTER */\n      CALL EMITRR (\"18\", 0, REG(MP));  /* WE CAN USE 0 FOR SCRATCH */\n      CALL EMITRR (\"17\", 0, REG(SP));     /* EXCL. | TO COMPARE  */\n      CALL EMITRX (\"8A\", 0, 0, 0, 24);  /* CHECK HIGH ORDER 8 BITS FOR ZERO */\n      IF REG(MPP1) = 6 | REG(MPP1) = 8 THEN\n         DO;          /* IF WE ONLY NEED TO TEST EQUALITY, CODE IS SIMPLER  */\n            K = PP;\n            CALL BRANCH (6, 0);\n         END;\n      ELSE\n         DO;\n            J = PP;\n            CALL BRANCH (8, 0);     /*  SKIP IF EQUAL LENGTH */\n            CALL EMITRR (\"15\", REG(MP), REG(SP));     /* SET CONDITION CODE  */\n            K = PP;  /* SAVE FOR FIXUP */\n            CALL BRANCH (\"F\", 0);  /* BRANCH AROUND STRING COMPARE CODE  */\n            CALL FIXBFW (J, PP);\n         END;\n      IF BASES(I) \u00ac= AVAIL THEN CALL EMITRR (\"18\", 0, I);  /* SAVE REG I */\n      CALL EMITRR (\"18\", I, REG(MP));\n      CALL EMITRX (\"88\", I, 0, 0, 24);  /* SCALE LENGTH FOR EXECUTE COMMAND  */\n      CALL EMITDATAWORD (\"D5000000\" + SHL(REG(MP), 12));\n      CALL EMITBYTE (SHL(REG(SP), 4));\n      CALL EMITBYTE (0);\n      CALL FINDADDRESS (DP-6);\n      CALL EMITRX (\"44\", I, 0, ADREG, ADRDISP);\n      IF BASES(I) \u00ac= AVAIL THEN CALL EMITRR (\"18\", I, 0);/* RESTORE REG I*/\n      BASES(REG(SP)) = AVAIL;\n      CALL FIXBFW (K, PP);  /* BRING OTHER BRANCH IN HERE */\n   END STRINGCOMPARE;\n\nSHOULDCOMMUTE:\n   PROCEDURE BIT(1);\n      IF TYPE(SP) = VARIABLE THEN\n         IF SYTYPE(FIXL(SP)) = FIXEDTYPE THEN RETURN FALSE;\n      IF TYPE(MP) = CONSTANT THEN RETURN TRUE;\n      IF TYPE(MP) = VARIABLE THEN\n         IF SYTYPE(FIXL(MP)) = FIXEDTYPE THEN RETURN TRUE;\n      RETURN FALSE;\n   END;\n\nARITHEMIT:\n   PROCEDURE (OP);\n      /* EMIT AN INSTRUCTION FOR AN INFIX OPERATOR -- CONNECTS MP & SP */\n\n      DECLARE (OP, TP, T1) FIXED;\n      COUNT#ARITH = COUNT#ARITH + 1;\n      TP = 0;  /* REMEMBER IF COMMUTED */\n      IF COMMUTATIVE(OP) THEN\n            IF SHOULDCOMMUTE THEN\n               DO;\n                  TP = MP; MP = SP; SP = TP;\n               END;\n      CALL FORCEACCUMULATOR (MP);  /* GET THE LEFT ONE INTO AN ACCUMULATOR */\n      /* FIXL(SP) IS GARBAGE IF TYPE \u00ac= VARIABLE, WE GET 0C5 IF WE TEST IT */\n      T1 = \"0\";\n      IF TYPE(SP) = VARIABLE THEN IF SYTYPE(FIXL(SP)) = FIXEDTYPE THEN T1 = \"1\";\n      IF TYPE(MP) = DESCRIPT THEN\n         DO;\n            IF OP = CMPRR THEN CALL STRINGCOMPARE;\n            ELSE CALL ERROR ('ARITHMETIC WITH A STRING DESCRIPTOR');\n         END;\n      ELSE IF T1 THEN\n            DO;  /* OPERATE DIRECTLY FROM STORAGE  */\n               IF INX(SP) \u00ac= 0 THEN CALL EMITRX (\"89\", INX(SP), 0, 0, 2);\n               /* SHIFT TO  WORD INDEXING */\n               CALL EMITRX(OP+64,REG(MP),INX(SP),SYBASE(FIXL(SP)),\n                  SYDISP(FIXL(SP)));\n               /* REG OPCODE + 64 = RX OPCODE */\n               BASES(INX(SP)) = AVAIL;\n            END;\n      ELSE IF TYPE(SP) = CONSTANT THEN\n            DO;\n               CALL EMITCONSTANT (FIXV(SP));\n               CALL EMITRX (OP+64, REG(MP), 0, ADREG, ADRDISP);\n            END;\n      ELSE\n            DO;\n               CALL FORCEACCUMULATOR (SP);\n               IF TYPE(SP) \u00ac= ACCUMULATOR THEN\n                  CALL ERROR ('ARITHMETIC BETWEEN STRING DESCRIPTORS', 1);\n               CALL EMITRR (OP, REG(MP), REG(SP));\n               BASES(REG(SP)) = AVAIL;\n            END;\n      IF TP \u00ac= 0 THEN\n         DO;  /* COMMUTED */\n            SP = MP;  MP = TP;\n            CALL MOVESTACKS (SP, MP);\n         END;\n         /* BY THE ALGORITHM, TYPE(MP) IS ALREADY ACCUMULATOR */\n   END ARITHEMIT;\n\nBOOLBRANCH:\n   PROCEDURE (SP, MP);\n      DECLARE (SP, MP, T1) FIXED;\n      T1 = \"0\";\n      IF TYPE(SP) = VARIABLE THEN IF SYTYPE(FIXL(SP)) = BYTETYPE THEN T1 = \"1\";\n      /* GENERATE A CONDITIONAL BRANCH FOR A DO WHILE OR AN IF STATEMENT */\n      IF STILLCOND \u00ac= 0 THEN\n         DO;\n            BASES(REG(SP)) = AVAIL;\n               IF PP < \"1008\" THEN PP = PP - 12; ELSE PP = PP - 16;\n            IF CONTROL(BYTE('E')) THEN\n                  OUTPUT = X70 || '               BACK UP CODE EMITTER';\n            INSTRUCT(BC) = INSTRUCT(BC) - 1;  /* KEEP STATISTICS ACCURATE */\n            INSTRUCT(LA) = INSTRUCT(LA) - 2;\n            REG(SP) = STILLCOND;\n         END;\n      ELSE IF T1 THEN\n         DO;\n            IF INX(SP) \u00ac= 0 THEN\n               DO;\n                  CALL EMITRR(\"1A\",INX(SP),SYBASE(FIXL(SP)));\n                  CALL EMITRX(\"91\",0,1,INX(SP),SYDISP(FIXL(SP)));\n                  /*  TEST UNDER MASK  */\n                  BASES(INX(SP)) = AVAIL;\n               END;\n            ELSE CALL EMITRX(\"91\",0,1,SYBASE(FIXL(SP)),SYDISP(FIXL(SP)));\n                  /*  TEST UNDER MASK  */\n            REG(SP) = 8;\n         END;\n      ELSE IF TYPE(SP) = CONSTANT THEN\n         DO;\n            IF FIXV(SP) THEN\n               DO;  FIXL(MP) = 0;  RETURN; END;\n            ELSE REG(SP) = 15;\n         END;\n      ELSE IF TYPE(SP) \u00ac= CONDITION THEN\n         DO;\n            CALL FORCEACCUMULATOR (SP);\n            CALL EMITRX (\"54\", REG(SP), 0, DBR, TRUELOC);/* TEST LS BIT */\n            BASES(REG(SP)) = AVAIL;\n            REG(SP) = 8;\n         END;\n      FIXL(MP) = PP;  /* SAVE ADDRESS FOR FUTURE FIXUP */\n      CALL BRANCH (REG(SP), 0);  /* REG(SP) HAS THE CC TO BE TESTED FOR */\n   END BOOLBRANCH;\n\n\nSET_LIMIT:\n   PROCEDURE;\n      /*  SETS DO LOOP LIMIT FOR <ITERATION CONTROL>   */\n      IF TYPE(MPP1) = CONSTANT THEN\n         CALL EMITCONSTANT(FIXV(MPP1));\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(MPP1);\n            CALL EMITDATAWORD(0);\n            CALL FINDADDRESS(DP-4);\n            CALL EMITRX(STORE,REG(MPP1),0,ADREG,ADRDISP);\n            BASES(REG(MPP1)) = AVAIL;\n         END;\n      INX(MP) = ADREG;\n      FIXV(MP) = ADRDISP;\n   END  SET_LIMIT;\n\n\nDIVIDE_CODE:\n   PROCEDURE;\n      /*  GENERATES THE CODE FOR DIVISION  */\n\n      TARGET_REGISTER = 0;\n      CALL FORCEACCUMULATOR(MP);\n      TARGET_REGISTER = -1;\n      IF REG(MP) \u00ac= 0 THEN\n         DO;\n            CALL EMITRR(\"18\",0,REG(MP));         /*  LR    0,REG(MP)  */\n            BASES(REG(MP)) = AVAIL;\n            REG(MP) = 0;\n         END;\n      IF BASES(1) = AVAIL THEN\n         DO;\n            /*  MUST \"SMEAR\"  THE SIGN  */\n            CALL EMITRX(\"8E\",0,0,0,32);          /*  SRDA  0,32       */\n            BASES(1) = ACCUMULATOR;\n            CALL ARITHEMIT(\"1D\");                /*  DIVIDE  */\n            REG(MP) = 1;                         /*  RESULT  */\n         END;\n      ELSE\n         CALL ERROR('DIVISION OR MOD REQUIRES BUSY REGISTER',1);\n\n   END  DIVIDE_CODE;\n\n\nSHIFT_CODE:\n   PROCEDURE (OP);\n      /*  GENERATES CODE FOR THE BUILT IN FUNCTIONS  SHL  AND  SHR  */\n      DECLARE OP BIT (8);\n      IF CNT(MP) \u00ac= 2 THEN\n         CALL ERROR('SHIFT REQUIRES TWO ARGUMENTS',0);\n      ELSE IF TYPE(MPP1) = CONSTANT THEN\n         DO;\n            IF OP = \"89\" & FIXV(MPP1) = 1 THEN\n               CALL EMITRR (\"1A\", REG(MP), REG(MP));\n            ELSE CALL EMITRX (OP, REG(MP), 0, 0, FIXV(MPP1));\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(MPP1);\n            CALL EMITRX(OP, REG(MP), 0, REG(MPP1), 0);\n            BASES(REG(MPP1)) = AVAIL;\n         END;\n      TYPE(MP) = ACCUMULATOR;\n   END  SHIFT_CODE;\n\n\n\n  /*                    BUILT-IN FUNCTIONS                              */\n\n\nREGISTER_SETUP_CODE:\n   PROCEDURE;\n      CALL EMITRR(\"18\",PBR,2);  /* SET BASE */\n      CALL EMITRR(\"18\",DBR,3);\n      CALL EMITRX(STORE,BRCHREG,0,DBR,RTNADR);\n      CALL EMITCONSTANT (256);\n      CALL EMITRX (\"5B\", 1, 0, ADREG, ADRDISP);\n      LIMITWORD = DP;\n      CALL EMITRX (STORE, 1, 0, DBR, DP);\n      CALL ENTER ('FREELIMIT', FIXEDTYPE, DP, 0);\n      CALL EMITDATAWORD (0);\n      BASEDATA = DP;\n      DP = DP+16;\n      CALL EMITRX (\"98\", 4, DBR-1, DBR, DP);  /* LOAD MULTIPLE  */\n      DO I = 4 TO DBR-1;\n         CALL EMITRR(\"1A\",I,DBR);\n      END;\n      DP = DP + SHL(DBR-4, 2);\n   END REGISTER_SETUP_CODE;\n\nRELOCATE_DESCRIPTORS_CODE:\n   PROCEDURE;\n      /* EMIT CODE TO RELOCATE DESCRIPTORS TO ABSOLUTE ADDRESSES */\n\n      CALL EMITRX(LOAD,0,0,DBR,BASEDATA+8);\n      CALL EMITRR(\"1A\",0,DBR);\n      CALL EMITRX(STORE,0,0,DBR,TSA);\n      CALL EMITRX (STORE, 0, 0, DBR, DP);\n      CALL ENTER ('FREEBASE', FIXEDTYPE, DP, 0);\n      CALL EMITDATAWORD (0);\n      CALL EMITRX(\"91\",0,1,DBR,BASEDATA+12);\n      K = PP;\n      CALL BRANCH (1, 0);\n      CALL EMITRX(\"96\",0,1,DBR,BASEDATA+12);\n      CALL EMITRX(LOAD,1,0,DBR,BASEDATA);\n      CALL EMITRX (LA,SBR,1,DBR,0);\n      CALL EMITRX(LOAD,2,0,DBR,BASEDATA+4);\n      CALL EMITRR (\"1A\",2,DBR);\n      J = PP;                             /* SAVE DESTINATION FOR LOOP */\n      CALL EMITRX (LOAD,3,1,DBR,0);\n      CALL EMITRR (\"12\",3,3);\n      CALL BRANCH (8,PP+10);              /* ESCAPE */\n      CALL EMITRR (\"1A\",3,2);\n      CALL EMITRX (STORE,3,1,DBR,0);\n      CALL EMITRX (LA,1,0,1,4);\n      CALL EMITRX(CMPR,1,0,DBR,BASEDATA+4);\n      CALL BRANCH (4,J);                  /* LOOP */\n      CALL FIXBFW (K,PP);\n      CALL BRANCH (15,0);      /*  JUMP TO FIRST COMPILED CODE */\n   END RELOCATE_DESCRIPTORS_CODE;\n\nCATENATE_CODE:\n   PROCEDURE;\n      /* BUILD A CATENATE SUBROUTINE  */\n\n      CATENTRY = PP;\n      CALL CHECK_STRING_OVERFLOW;\n      CALL EMITRX (LOAD,1,0,A1,A2);  /*  LOAD FIRST DESCRIPTOR */\n      CALL EMITRR (\"18\", 3, 1);  /* COPY INTO REG(3)  */\n      CALL EMITRX (\"5E\", 3, 0, B1, B2);  /* COMBINE DESCRIPTORS  */\n      CALL EMITRR (\"12\", 1, 1);  /* TEST FOR NULL FIRST OPERAND  */\n      CALL EMITRR (BCR, 8, BRCHREG);  /* RETURN WITH RESULT IN REG(3)  */\n      CALL EMITRR (CMPRR, 3, 1);  /* IS SECOND OPERAND NULL?  */\n      CALL EMITRR (BCR, 8, BRCHREG);  /* RETURN WITH RESULT IN REG(3)  */\n      CALL FINDADDRESS (MASKF000);\n      CALL EMITRX (\"54\", 3, 0, ADREG, ADRDISP);  /* MASK OUT ADDRESS  */\n      CALL EMITRX (\"5E\", 3, 0, DBR, CATCONST);  /* CORRECT LENGTH OF RESULT  */\n      CALL FINDADDRESS (MOVER);  /* FIND MOVE INSTRUCTION */\n      T1 = ADREG;  T2 = ADRDISP;\n      CALL EMITRR (\"18\", 0, 3);  /* SAVE LENGTH IN REG(0)  */\n      CALL FINDADDRESS (TSA);  /* FIND CURRENT TOP OF STR AREA  */\n      CALL EMITRX (LOAD,2,0,ADREG,ADRDISP);\n      CALL FINDADDRESS (STRL);  /* LAST STRING MADE IN STRING AREA */\n      CALL EMITRX (CMPR, 1, 0, ADREG, ADRDISP); /* SKIP MOVE IF AT TOP */\n      J = PP;\n      CALL BRANCH (6, 0);       /* FAKE MOVE */\n      CALL EMITRX (LA, 1, 0, 1, 0);\n      CALL EMITRR (\"16\", 0, 1);\n      K = PP;\n      CALL BRANCH (\"F\", 0);\n      CALL FIXBFW (J, PP);\n      CALL EMITRR (\"16\",0,2);  /* OR IN CORRECT ADDRESS */\n      CALL EMITRX (\"43\",3,0,A1,A2);  /* INSERT LENGTH FIELD */\n      CALL EMITRX (\"44\",3,0,T1,T2);   /* EXECUTE THE MOVE */\n      CALL EMITRX (\"41\",2,3,2,1);  /* UPDATE TSA */\n      CALL FIXBFW (K, PP);\n      CALL EMITRX (LOAD,1,0,B1,B2);  /* LOAD SECOND DESCRIPTOR */\n      CALL EMITRX (\"43\", 3,0,B1,B2);  /* INSERT LENGTH FIELD  */\n      CALL EMITRX (\"44\",3,0,T1,T2);  /* EXECUTE THE MOVE */\n      CALL EMITRX (\"41\",2,3,2,1);   /*  UPDATE TSA  */\n      CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);  /* STORE INTO STRL */\n      CALL FINDADDRESS (TSA);\n      CALL EMITRX (STORE,2,0,ADREG,ADRDISP);   /* SAVE TOP OF STR. A.  */\n      CALL EMITRR (\"18\", 3, 0);  /* RESULT TO REG(3)  */\n      CALL EMITRR (BCR, 15, BRCHREG);  /* RETURN  */\n   END CATENATE_CODE;\n\nCONVERT_CODE:\n   PROCEDURE;\n      /*  THE NUMBER-TO-STRING CONVERSION SUBROUTINE */\n\n      NMBRNTRY = PP;\n      CALL CHECK_STRING_OVERFLOW;         /* CALL COMPACTIFY */\n      CALL EMITRX (LOAD, 3,0, DBR, STRN);\n      CALL EMITRR (\"10\",3,3);             /* SET POSITIVE FOR CONVERT */\n      CALL EMITRX (LOAD, 1,0,DBR,TSA);    /* FREE SOME STRING AREA */\n      CALL EMITRX  (LA,1,0,1,11);         /* 11 IS THE MAXIMUM NUMBER OF DIGITS\n                                             IN A CONVERTED 32 BIT INTEGER */\n      CALL EMITRX (STORE,1,0,DBR,TSA);\n      CALL EMITRX (LA,0,0,0,10);          /* BASE 10 FOR DIVISION */\n      I = PP;\n      CALL EMITRR (\"06\",1,0);             /* COUNT THE DIGIT */\n      CALL EMITRR (\"1B\",2,2);             /* CLEAR REGISTER 2 */\n      CALL EMITRR (\"1D\",2,0);             /* DIVIDE BY 10 */\n      CALL EMITRX (LA,2,0,2,\"F0\");        /* ADD IN THE EBCDIC CODE */\n      CALL EMITRX (\"42\",2,0,1,0);\n      CALL EMITRR (\"12\",3,3);             /* TEST FOR ZERO */\n      CALL BRANCH (6,I);                  /* GET NEXT DIGIT */\n      CALL EMITRX (LOAD,3,0,DBR,STRN);\n      CALL EMITRR (\"12\",3,3);             /* TEST FOR NEGATIVE */\n      I = PP;\n      CALL BRANCH (10,0);\n      CALL EMITRX (LA,2,0,0,\"60\");        /* \"60\" = '-' */\n      CALL EMITRR (\"06\",1,0);\n      CALL EMITRX (\"42\",2,0,1,0);\n      CALL FIXBFW (I,PP);\n      CALL EMITRX (LOAD,3,0,DBR,TSA);     /* MAKE UP RESULT DESCRIPTOR */\n      CALL EMITRR (\"1B\",3,1);\n      CALL EMITRR (\"06\",3,0);\n      CALL EMITRX (\"89\",3,0,0,24);        /* SHIFT LENGTH FIELD LEFT */\n      CALL EMITRR (\"1A\",3,1);             /* ADD IN ADDRESS */\n      CALL FINDADDRESS (STRL);            /* UPDATE POINTER TO NEWEST STRING */\n      CALL EMITRX (STORE, 3, 0, ADREG, ADRDISP);\n      CALL EMITRR (BCR,15,BRCHREG);       /* RETURN */\n      CALL FIXBFW (CATENTRY-4, PP);\n   END CONVERT_CODE;\n\n\n  /*                       TIME AND DATE                                 */\n\n\nPRINT_TIME:\n   PROCEDURE (MESSAGE, T);\n      DECLARE MESSAGE CHARACTER, T FIXED;\n      MESSAGE = MESSAGE || T/360000 || ':' || T MOD 360000 / 6000 || ':'\n         || T MOD 6000 / 100 || '.';\n      T = T MOD 100;  /* DECIMAL FRACTION  */\n      IF T<10 THEN MESSAGE= MESSAGE || '0';\n      OUTPUT = MESSAGE || T || '.';\n   END PRINT_TIME;\n\nPRINT_DATE_AND_TIME:\n   PROCEDURE (MESSAGE, D, T);\n      DECLARE MESSAGE CHARACTER, (D, T, YEAR, DAY, M) FIXED;\n      DECLARE MONTH(11) CHARACTER INITIAL ('JANUARY', 'FEBRUARY', 'MARCH',\n         'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER',\n         'NOVEMBER', 'DECEMBER'),\n      DAYS(12) FIXED INITIAL (0, 31, 60, 91, 121, 152, 182, 213, 244, 274,\n         305, 335, 366);\n      YEAR = D/1000 + 1900;\n      DAY = D MOD 1000;\n      IF (YEAR & \"3\") \u00ac= 0 THEN IF DAY > 59 THEN DAY = DAY + 1; /* \u00ac LEAP YEAR*/\n      M = 1;\n      DO WHILE DAY > DAYS(M);  M = M + 1;  END;\n      CALL PRINT_TIME(MESSAGE || MONTH(M-1) || X1 || DAY-DAYS(M-1) ||  ', '\n         || YEAR || '.  CLOCK TIME = ', T);\n   END PRINT_DATE_AND_TIME;\n\n  /*                       INITIALIZATION                                     */\n\n\n\nINITIALIZATION:\n   PROCEDURE;\n\nSET_ALPHANUMERIC:\n   PROCEDURE (J);\n      DECLARE (J, TEMP, M) FIXED;\n      TEMP = ALPHATABLE(J/4);\n      M = SHL (J&3, 3);   /*  8*(J MOD 4)  */\n      TEMP = (SHR (\"00FFFFFF\", M) | SHL (\"FFFFFF00\", 24-M)) & TEMP;\n      ALPHATABLE(J/4) = TEMP;\n   END;\n\n      EJECT_PAGE;\n  CALL PRINT_DATE_AND_TIME (' XPL COMPILATION---SUNY STONYBROOK---XCOM4.5 VERSIO\nN OF  ',DATE_OF_GENERATION, TIME_OF_GENERATION);\n      DOUBLE_SPACE;\n      CALL PRINT_DATE_AND_TIME ('TODAY IS ', DATE, TIME);\n      DOUBLE_SPACE;\n\n      /* INITIALIZE THE CHARACTER TRANSLATION TABLES */\n      DO I = 0 TO 63;\n         ALPHATABLE(I) = \"FFFFFFFF\";\n         END;\n      DO I = 0 TO 63;\n         BLANKTABLE(I) = \"FFFFFFFF\";\n         END;\n      BLANKTABLE(16) = \"00FFFFFF\";\n      DO I = 0 TO 63;\n         COMMENTABLE(I) = 0;\n         END;\n      DO I = 0 TO 1;\n         J = BYTE('*$', I);\n         COMMENTABLE (SHR(J, 2)) = SHR(\"FF000000\", SHL(J&3, 3)) |\n                                   COMMENTABLE (SHR(J, 2));\n         END;\n      DO I = 0 TO 63;\n         STRINGTABLE(I) = 0;\n         END;\n      J = BYTE(QUOTE);\n      STRINGTABLE (SHR(J, 2)) = SHR (\"FF000000\", SHL(J&3, 3));\n\n      DO I = 1 TO NT;\n         S = V(I);\n         IF S = '<NUMBER>' THEN NUMBER = I;  ELSE\n         IF S = '<IDENTIFIER>' THEN IDENT = I;  ELSE\n         IF S = '<STRING>' THEN STRING = I;  ELSE\n         IF S = '/' THEN DIVIDE = I;  ELSE\n         IF S = 'EOF' THEN EOFILE = I;  ELSE\n         IF S = 'DECLARE' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = 'PROCEDURE' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = 'END' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = 'DO' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = ';' THEN STOPIT(I) = TRUE;  ELSE\n         IF S = '|' THEN ORSYMBOL = I; ELSE\n         IF S = '||' THEN CONCATENATE = I; ELSE\n         ;\n      END;\n       DO  I= NT+1 TO NSY;\n          S=V(I);\n          IF S='<PROCEDURE HEAD>' THEN PROCHEAD=I; ELSE\n      IF S='<GROUP HEAD>' THEN GROUPHEAD=I;\n       END;\n      IF IDENT = NT THEN RESERVED_LIMIT = LENGTH(V(NT-1));\n      ELSE RESERVED_LIMIT = LENGTH(V(NT));\n      STOPIT(EOFILE) = TRUE;\n      CHARTYPE(BYTE(' ')) = 1;\n      CHARTYPE(BYTE('''')) = 2;\n      CHARTYPE(BYTE('\"')) = 3;\n      DO I = 0 TO LENGTH(ALPHABET) - 1;\n         J = BYTE(ALPHABET, I);\n         TX(J) = I;\n         CHARTYPE(J) = 4;\n         CALL SET_ALPHANUMERIC (J);\n      END;\n      DO I = 0 TO 9;\n         J = BYTE('0123456789', I);\n         CHARTYPE(J) = 5;\n         CALL SET_ALPHANUMERIC (J);\n      END;\n      DO I = VT_INDEX(1) TO VT_INDEX(2) - 1;\n         J = BYTE(V(I));\n         TX(J) = I;\n         CHARTYPE(J) = 7;\n      END;\n      CHARTYPE(BYTE('|')) = 8;\n      CHARTYPE(BYTE('/')) = 6;\n      COMMUTATIVE(\"14\") = TRUE;\n      COMMUTATIVE(\"16\") = TRUE;\n      COMMUTATIVE(\"1A\") = TRUE;\n      RETURNED_TYPE = FIXEDTYPE;          /* DEFAULT RETURN TYPE */\n\n      LASTBASE = DBR;  BASES(LASTBASE) = 0;\n      /*              INITIALIZE SYMBOL TABLE VARIABLES */\n      PP = 60;   /*  OFFSET  CODE  FOR  CONTROL  RECORD (SEE LOADER) */\n      DP = 0;    /*  DATA ORIGIN  */\n      DSP = 4;\n      CHP = 1;\n      PPLIM, DPLIM, CHPLIM = DISKBYTES;\n         /* UPPER BOUND FOR EMITTER ARRAYS */\n      PPORG, DPORG, CHPORG = 0;\n         /* LOWER BOUND FOR EMITTER ARRAYS */\n      CURCBLK, CURDBLK, CURSBLK = 0;\n         /* CURRENT BLOCK OCCUPYING EMITTER ARRAYS */\n      SHORTCFIX, SHORTDFIX, LONGCFIX, LONGDFIX = 0;\n         /* STATISTICAL COUNTERS FOR FIXUPS */\n      FCP = 0;  /* POINTER INTO FIXUP ARRAY */\n      NDECSY ,PROCMARK = 1;   PARCT = 0;\n      /* INTEGERS FOR BRANCH ADDRESSING */\n      DO I = 0 TO PROGRAMSIZE;  CALL EMITDATAWORD(SHL(I,12)); END;\n\n      /*  WARNING, THE FOLLOWING SECTION OF INITIALIZE DEPENDS ON\n          THE INITIALIZATION OF THE BUILTIN FUNCTION AND PSEUDO\n          VARIABLE NAMES AND ATTRIBUTES IN THE SYMBOL TABLE ARRAYS.\n      */\n\n      SYDISP(2) = DP;                     /*  MONITOR_LINK               */\n      DP = DP + 16;  /* RESERVE 4 WORDS FOR COMMUNICATION WITH MONITOR  */\n      MASKF000 = DP;  CALL EMITDATAWORD(\"FF000000\");\n      IO_SAVE = DP;  DP = DP + 12;  /* REGISTER SAVE FOR INPUT/OUTPUT  */\n\n      /*  SET UP THE MOVE TEMPLATE IN DATA AREA */\n\n      MOVER = DP;\n      CALL EMITBYTE(\"D2\");  /* MVC */\n      CALL EMITBYTE(0);\n      CALL EMITBYTE(\"20\");\n      CALL EMITBYTE(0);\n      CALL EMITBYTE(\"10\");\n      CALL EMITBYTE(0);\n      CALL EMITDATAWORD(0);  TSA = DP-4;\n      SYDISP(3) = DP;                     /*  TIME_OF_GENERATION         */\n      CALL EMITDATAWORD(TIME);\n      SYDISP(4) =  DP;                    /*  DATE_OF_GENERATION         */\n      CALL EMITDATAWORD(DATE);\n      SYDISP(5) = 0;                      /*  COREWORD                   */\n      SYDISP(6) = 0;                      /*  COREBYTE                   */\n      SYDISP(7) = TSA;                    /*  FREEPOINT                  */\n      SYDISP(8) = DSP;                    /*  DESCRIPTOR                 */\n      SYDISP(9) = DP;                     /*  NDESCRIPT                  */\n      DESCL = DP;\n      CALL EMITDATAWORD (0);\n      A1, B1 = SBR;  /* A1,A2 IS THE FIRST PARAMETER TO ||, */\n      A2 = DSP;       /* B1,B2 IS THE SECOND */\n      CALL EMITDESC (0);\n      B2 = DSP;\n      CALL EMITDESC (0);\n      STRL = -DSP;  CALL EMITDESC(0);\n      STRN = DP; CALL EMITDATAWORD(0);\n      TRUELOC = DP; CALL EMITDATAWORD(TRUE);\n      COMPLOC = DP; CALL EMITDATAWORD(\"FFFFFFFF\");\n      CATCONST = DP; CALL EMITDATAWORD (\"1000000\");\n      RTNADR = DP; CALL EMITDATAWORD (0);\n\n      DO I = 0 TO 255;\n         BUCKET(I) = NULL;\n         END;\n      DO I = 0 TO SYTSIZE;\n         SY_LINK(I) = NULL;\n         END;\n      LEX_LEVEL, PROCEDURE_NUMBER = 1;\n      IDCOMPARES = 0;\n      DO NDECSY = 2 TO N_PREDECLARED_SYMB;\n         S = SYT(NDECSY);\n         I = LENGTH(S) -1;\n         I =(BYTE(S) + BYTE(S, I) + I) & \"FF\";\n         IF BUCKET(I) = NULL THEN BUCKET(I) = NDECSY;\n         ELSE DO;\n            I = BUCKET(I);\n            DO WHILE SY_LINK(I) \u00ac= NULL;\n               I = SY_LINK(I);\n               END;\n            SY_LINK(I) = NDECSY;\n            END;\n         END;\n      NDECSY = N_PREDECLARED_SYMB;\n\n      CALL EMITDATAWORD (0);\n      SYDISP(NDECSY) = DP-4;            /*  COMPACTIFY                 */\n      STRING_RECOVER = NDECSY;\n      CALL CLEARREGS;\n\n\n      /*         EMIT CODE FOR BUILT_IN FUNCTIONS                        */\n\n      CALL REGISTER_SETUP_CODE;\n\n      CALL RELOCATE_DESCRIPTORS_CODE;\n\n      CALL CATENATE_CODE;\n\n      CALL CONVERT_CODE;\n\n      MAINLOC = PP;\n      CALL CLEARREGS;\n      /* FIRST SET UP GLOBAL VARIABLES CONTROLLING SCAN, THEN CALL IT */\n      CP = 0;  TEXT_LIMIT = -1;\n      TEXT, CURRENT_PROCEDURE = '';\n STATE#,STATE_STACK(0)=STARTSTATE ; /*INITIALIZE STATE STACK WITH START STATE*/\n    RECOV = FALSE ;   NEXT = 0;\n SP=0;  /* INITIALIZE TOP OF STATE STACK POINTER */\n      CALL SCAN;\n COMPILING=TRUE;   /* YOU CAN ABORT COMPILATION BY SETTING FALSE */\n   END INITIALIZATION;\n\n\n\n  /*               SYMBOL AND STATISTICS PRINTOUT                         */\n\n\nSYMBOLDUMP:\n   PROCEDURE;\n      /* LISTS THE SYMBOLS IN THE PROCEDURE THAT HAS JUST BEEN\n         COMPILED IF $S OR $D IS ENABLED\n         MAINTAIN PARITY ON $D AND $S\n      */\n      DECLARE (LPM, I, J, K, L, M) FIXED;\n      DECLARE (BUFFER, BLANKS) CHARACTER;\n      DECLARE EXCHANGES BIT(1), SYTSORT(SYTSIZE) BIT(16);\n\n      OUTLINE:\n         PROCEDURE (NAME, P) CHARACTER;\n            DECLARE NAME CHARACTER, (P, B, D) FIXED;\n            IF SYTYPE(P) = LABELTYPE | SYTYPE(P) = CHAR_PROC_TYPE THEN\n               DO;\n                  B = PBR;\n                  D = SHL(SYBASE(P), 12) + SYDISP(P);\n               END;\n            ELSE\n               DO;\n                  B = SYBASE(P);\n                  D = SYDISP(P);\n               END;\n\n            BUFFER = PAD (D || '(' || B || '),', 11);\n            RETURN NAME || ': ' || TYPENAME(SYTYPE(P)) || ' AT ' || BUFFER ||\n               ' DECLARED ON LINE ' || DECLARED_ON_LINE(P) ||\n               ' AND REFERENCED ' || SYTCO(P) || ' TIMES.';\n         END  OUTLINE;\n\n   BUCKET_CHAIN_STATISTICS:\n      PROCEDURE;\n         DECLARE (NUMBER_FULL, MAXCHAIN, CHAIN_LENGTH, SY_PTR, I) FIXED;\n         NUMBER_FULL, MAXCHAIN = 0;\n         DO I = 0 TO 255;\n            IF BUCKET(I) \u00ac= NULL THEN DO;\n               CHAIN_LENGTH = 1;  SY_PTR = BUCKET(I);\n               NUMBER_FULL = NUMBER_FULL + 1;\n               DO WHILE SY_LINK(SY_PTR) \u00ac= NULL;\n                  CHAIN_LENGTH = CHAIN_LENGTH + 1;\n                  SY_PTR = SY_LINK(SY_PTR);\n                  END;\n               IF CHAIN_LENGTH > MAXCHAIN THEN\n                  MAXCHAIN = CHAIN_LENGTH;\n               END;\n            END;\n         DOUBLE_SPACE;\n         OUTPUT = 'THE SYMBOL TABLE PRESENTLY CONTAINS ' ||NDECSY|| ' SYMBOLS';\n         OUTPUT = NUMBER_FULL || ' OF THE 255 HASH BUCKETS ARE OCCUPIED';\n         OUTPUT = 'THE MAXIMUM BUCKET CHAIN LENGTH IS ' || MAXCHAIN;\n      END BUCKET_CHAIN_STATISTICS;\n\n\n      IF PROCMARK <= NDECSY THEN\n         DO;\n            DOUBLE_SPACE;\n            OUTPUT = 'SYMBOL  TABLE  DUMP';\n            DOUBLE_SPACE;\n            LPM = LENGTH(SYT(PROCMARK));\n            L = 15;\n            DO I = PROCMARK TO NDECSY;\n               IF LENGTH(SYT(I)) > L THEN\n                  L = LENGTH(SYT(I));\n            END;\n            IF L > 70 THEN L = 70;\n            BLANKS = SUBSTR(X70, 0, L);\n            DO I = PROCMARK TO NDECSY;\n               SYTSORT(I) = I;\n               K = LENGTH(SYT(I));\n               IF K > 0 THEN\n                  IF K < L THEN\n                     DO;\n                        BUFFER = SUBSTR(BLANKS,K);\n                        SYT(I) = SYT(I) || BUFFER;\n                     END;\n                  ELSE\n                     DO;\n                        BUFFER = SUBSTR (SYT(I), 0, L);\n                        SYT(I) = BUFFER;\n                     END;\n            END;\n\n            EXCHANGES = TRUE;\n            K = NDECSY - PROCMARK;\n\n            DO WHILE EXCHANGES;\n               EXCHANGES = FALSE;\n               DO J = 0 TO K - 1;\n                  I = NDECSY - J;\n                  L = I - 1;\n                  IF SYT(SYTSORT(L)) > SYT(SYTSORT(I)) THEN\n                     DO;\n                        M = SYTSORT(I);\n                        SYTSORT(I) = SYTSORT(L);\n                        SYTSORT(L) = M;\n                        EXCHANGES = TRUE;\n                        K = J;         /* RECORD LAST SWAP */\n                     END;\n               END;\n            END;\n\n            I = PROCMARK;\n            DO WHILE LENGTH(SYT(SYTSORT(I))) = 0;\n               I = I + 1;              /* IGNORE NULL NAMES */\n            END;\n\n            DO I = I TO NDECSY;\n               K = SYTSORT(I);\n               OUTPUT = OUTLINE(SYT(K), K);\n\n               K = K + 1;\n               DO WHILE (LENGTH(SYT(K)) = 0) & (K <= NDECSY);\n                  J = K - SYTSORT(I);\n                  OUTPUT =\n                     OUTLINE('  PARAMETER  ' || J || SUBSTR(BLANKS, 14), K);\n                  K = K + 1;\n               END;\n\n            END;\n\n            CALL BUCKET_CHAIN_STATISTICS;\n\n            BUFFER = SUBSTR(SYT(PROCMARK), 0 , LPM);\n            SYT(PROCMARK) = BUFFER;\n            EJECT_PAGE;\n         END;\n\n   END  SYMBOLDUMP;\n\n\n\nDUMPIT:\n   PROCEDURE;    /* DUMP OUT THE COMPILED CODE & DATA AREAS  */\n      CALL SYMBOLDUMP;\n      OUTPUT = 'MACRO DEFINITIONS:';\n      DOUBLE_SPACE;\n      DO I = 0 TO TOP_MACRO;\n         OUTPUT = PAD(MACRO_NAME(I), 20) || ' LITERALLY: ' || MACRO_TEXT(I);\n      END;\n      DOUBLE_SPACE;\n      /*  PUT OUT THE ENTRY COUNT FOR IMPORTANT PROCEDURES */\n\n      OUTPUT = 'IDCOMPARES        = ' || IDCOMPARES;\n      OUTPUT = 'SYMBOL TABLE SIZE = ' || MAXNDECSY;\n      OUTPUT = 'MACRO DEFINITIONS = ' || TOP_MACRO + 1;\n      OUTPUT = 'PRODUCTIONS APPLIED ' || COUNT#STACK;\n      OUTPUT = 'SCAN              = ' || COUNT#SCAN;\n      OUTPUT = 'EMITRR            = ' || COUNT#RR;\n      OUTPUT = 'EMITRX            = ' || COUNT#RX;\n      OUTPUT = 'FORCEACCUMULATOR  = ' || COUNT#FORCE;\n      OUTPUT = 'ARITHEMIT         = ' || COUNT#ARITH;\n      OUTPUT = 'GENSTORE          = ' || COUNT#STORE;\n      OUTPUT = 'FIXBFW            = ' || COUNT#FIXBFW;\n      OUTPUT = 'FIXDATAWORD       = ' || COUNT#FIXD;\n      OUTPUT = 'FIXCHW            = ' || COUNT#FIXCHW;\n      OUTPUT = 'GETDATA           = ' || COUNT#GETD;\n      OUTPUT = 'GETCODE           = ' || COUNT#GETC;\n      OUTPUT = 'FINDADDRESS       = ' || COUNT#FIND;\n      OUTPUT = 'SHORTCFIX         = ' || SHORTCFIX;\n      OUTPUT = 'LONGCFIX          = ' || LONGCFIX;\n      OUTPUT = 'SHORTDFIX         = ' || SHORTDFIX;\n      OUTPUT = 'LONGDFIX          = ' || LONGDFIX;\n      OUTPUT = 'FREE STRING AREA  = ' || FREELIMIT - FREEBASE;\n      DOUBLE_SPACE;\n      OUTPUT = 'REGISTER VALUES (RELATIVE TO R11):';\n      DO I = 4 TO 13;\n         OUTPUT = 'R' || I || ' = ' || BASES(I);\n      END;\n\n      OUTPUT = ''; OUTPUT = ' INSTRUCTION FREQUENCIES:';\n      OUTPUT = '';\n      DO I = 0 TO 255;\n         IF INSTRUCT(I) \u00ac = 0 THEN\n             OUTPUT = SUBSTR(OPNAMES,OPER(I),4) || X4 || INSTRUCT(I);\n      END;\n   END DUMPIT;\n\n\nDUMP:\n   PROCEDURE;\n      DECLARE LINE CHARACTER, J FIXED;\n      LINE = 'PARTIAL PARSE TO THIS POINT IS: ';\n      IF SP > 0 THEN DO J = 1 TO SP;\n         IF LENGTH(LINE) > 110 THEN DO;\n            OUTPUT = LINE;  LINE = X4;\n         END;\n         LINE = LINE || X1 || V(STATETOKEN(STATE_STACK(J)));\n      END;\n      OUTPUT = LINE;\n   END DUMP;\n\n\nTRANS: PROCEDURE(I,J,K) BIT(1) ;\n  /*  SET NEWSTATE TO TRANSITION (IF ANY) FROM STATE I UNDER TOKEN J\n       IF NO TRANSITION , RETURN FALSE;     */\nDECLARE (I,J,K,A) BIT(16);\n DO A= I TO J BY 2 ;\n      IF SCANTOKENS(A) >= K THEN IF SCANTOKENS(A) = K THEN DO ;\n           NEWSTATE= SCANGOTOS(A);\n           RETURN TRUE;\n      END;\n      ELSE IF SCANTOKENS(A-1) = K THEN DO ;\n           NEWSTATE = SCANGOTOS(A-1) ;\n           RETURN TRUE ;\n           END ;\n      ELSE RETURN FALSE ;\n END;\n IF SCANTOKENS(J) = K THEN DO ;\n      NEWSTATE = SCANGOTOS(J) ;\n      RETURN TRUE ;\n      END ;\n RETURN FALSE;\nEND TRANS;\n\nFIXIT: PROCEDURE BIT(1);\n DECLARE T CHARACTER;\n CALL ID_LOOKUP(SP);\n IF FIXL(SP)= -1 THEN RETURN FALSE;\n T=VAR(SP);     /* THE END NAME  */\n SEVERE_ERRORS=SEVERE_ERRORS +1;\n S= SUBSTR( CURRENT_PROCEDURE,1);\n DO I= 0 TO MP-1;\n    J=MP-I;\n    IF STATETOKEN(STATE_STACK(J))= PROCHEAD THEN DO;\n       IF T=S THEN DO;\n          MP=J+2;\n          STATE_STACK(MP)=31;  /* SET UP A PROCEDURE DEF PRODUCTION */\n          CURRENT_PROCEDURE= X1 || S;\n          VAR(MP)=T;\n          OUTPUT= '***ASSUMED END OF PROCEDURE ' || T;\n          RETURN TRUE;\n       END;\n       ELSE S=SUBSTR(VAR(J),1);\n    END;   /* OF DO PROCEDURE MATCH */\n    ELSE IF J>1 & STATETOKEN(STATE_STACK(J)) = GROUPHEAD THEN\n    IF T= VAR(J-1) & STATETOKEN(STATE_STACK(J-1)) \u00ac= PROCHEAD THEN DO ;\n       MP=J+1;\n       STATE_STACK(MP)=20;\n       VAR(MP)=T;\n       OUTPUT='***ASSUMED END OF GROUP ' || T;\n       RETURN TRUE;\n    END;   /* OF GROUP MATCH  */\n END;  /* OF STACK SEARCH */\n SP=SP-1;   /* EXTRA END CAUSED PREMATURE POP OF HEAD */\n OUTPUT='***EXTRA \"END\" DETECTED ';\n RETURN TRUE;\nEND FIXIT;\n\n\n  /*                  THE SYNTHESIS ALGORITHM FOR XPL                      */\n\nSYNTHESIZE:\nPROCEDURE(PRODUCTION_NUMBER);\n   DECLARE PRODUCTION_NUMBER FIXED;\n\n   /*  ONE STATEMENT FOR EACH PRODUCTION OF THE GRAMMAR*/\n\n\nDO CASE PRODUCTION_NUMBER;\n   ;      /*  CASE 0 IS A DUMMY, BECAUSE WE NUMBER PRODUCTIONS FROM 1  */\n\n /*  <PROGRAM>  ::=  <STATEMENT LIST>    */\n   DO;   /* FINAL CODE FOR XPLSM INTERFACE & SETUP  */\n      IF MP \u00ac= 1 THEN  /* WE DIDN'T GET HERE LEGITEMATELY */\n         DO;\n            CALL ERROR ('EOF AT INVALID POINT', 1);\n            CALL DUMP;\n         END;\n      DO I = 1 TO NDECSY;\n         IF SYTYPE(I) = FORWARDTYPE | SYTYPE(I) = FORWARDCALL THEN\n          IF SYTCO(I) > 0 THEN\n            CALL ERROR ('UNDEFINED LABEL OR PROCEDURE: ' || SYT(I), 1);\n      END;\n      CALL EMITRR (\"1B\", 3, 3);  /* RETURN CODE OF ZERO  */\n      CALL EMITRX(LOAD, BRCHREG, 0, DBR, RTNADR);\n      CALL EMITRR(BCR, \"F\", BRCHREG);  /* SET UP BASE REGISTERS */\n      BASES(SBR) = (DP + 3) & \"FFFFFC\";\n      DO I = 4 TO DBR-1;\n         CALL FIXWHOLEDATAWORD(BASEDATA+SHL(I,2), BASES(I));\n      END;\n      CALL FIXWHOLEDATAWORD(DESCL, SHR(DSP,2)-1);\n      COMPILING = FALSE;\n   END;\n\n /*  <STATEMENT LIST> ::= <STATEMENT>    */\n   ;\n /*  <STATEMENT LIST> ::= <STATEMENT LIST> <STATEMENT>    */\n   ;\n /*  <STATEMENT> ::= <BASIC STATEMENT>    */\n   DO;\n      CALL CLEARREGS;\n      STATEMENT_COUNT = STATEMENT_COUNT + 1;\n   END;\n\n /*  <STATEMENT> ::= <IF STATEMENT>    */\n   CALL CLEARREGS;\n\n /*  <BASIC STATEMENT> ::= <ASSIGNMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <GROUP> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <PROCEDURE DEFINITION> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <RETURN STATEMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <CALL STATEMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <GO TO STATEMENT> ;    */\n   ;\n /*  <BASIC STATEMENT> ::= <DECLARATION STATEMENT> ;    */\n   ;\n\n /*  <BASIC STATEMENT> ::= ;    */\n      ;\n /*  <BASIC STATEMENT> ::= <LABEL DEFINITION> <BASIC STATEMENT>    */\n      ;\n /*  <IF STATEMENT> ::= <IF CLAUSE> <STATEMENT>    */\n   CALL FIXBFW(FIXL(MP), PP); /* FIX THE ESCAPE BRANCH NOW THAT STMT IS DONE */\n\n /*  <IF STATEMENT> ::= <IF CLAUSE> <TRUE PART> <STATEMENT>    */\n   DO;  /* THERE ARE TWO BRANCHES TO BE FILLED IN WITH ADDRESSES HERE */\n      CALL FIXBFW(FIXL(MPP1), PP); /* ESCAPE FROM TRUE PART */\n      CALL FIXBFW(FIXL(MP), FIXV(MPP1)); /* HOP AROUND TRUE PART */\n   END;\n\n /*  <IF STATEMENT> ::= <LABEL DEFINITION> <IF STATEMENT>    */\n   ;\n\n /*  <IF CLAUSE> ::= IF <EXPRESSION> THEN    */\n   CALL BOOLBRANCH(MPP1, MP); /* BRANCH ON FALSE OVER TRUE PART */\n\n  /*  <TRUE PART> ::= <BASIC STATEMENT> ELSE   */\n   DO;  /* SAVE THE PROGRAM POINTER & EMIT THE CONDITIONAL BRANCH */\n      FIXL(MP) = PP;\n      CALL BRANCH(\"F\", 0); /* \"F\" MEANS UNCONDITIONAL BRANCH */\n      FIXV(MP) = PP;\n   END;\n\n /*  <GROUP> ::= <GROUP HEAD> <ENDING>    */\n   DO;  /* BRANCH BACK TO LOOP & FIX ESCAPE JUMP */\n       IF LENGTH(VAR(SP))>0 & VAR(MP-1)\u00ac=VAR(SP) THEN DO;\n          S='END ' || VAR(SP) || ' DOESN''T MATCH GROUP LABEL ';\n          IF V(STATETOKEN(STATE_STACK(MP-1))) = '<LABEL DEFINITION>'\n               THEN S=S || VAR(MP-1) ;\n          CALL ERROR(S,0);\n          CALL DUMP;\n       IF FIXIT THEN RETURN;\n       END;\n      IF INX(MP) = 1 | INX(MP) = 2 THEN\n         DO; /* STEP OR WHILE LOOP FIX UP */\n            CALL BRANCH(\"F\", PPSAVE(MP));\n            CALL FIXBFW(FIXL(MP), PP);\n         END;\n      ELSE IF  INX(MP) = 3 THEN\n         DO;  /* COMMENT  CASE GROUP */\n            /* JUSTIFY TO WORD BOUNDARY */\n            DP = (DP + 3) & \"FFFFFC\";\n            CALL FINDADDRESS(DP);\n            CALL FIXCHW(FIXL(MP)+2, SHL(ADREG,4)+SHR(ADRDISP,8), ADRDISP);\n            DO I = PPSAVE(MP) TO CASEP-1; CALL EMITDATAWORD(CASESTACK(I)); END;\n            CASEP = PPSAVE(MP) - 1;\n            CALL FIXBFW(FIXV(MP), PP);\n         END;\n   END;\n\n /*  <GROUP HEAD> ::= DO ;    */\n   INX(MP) = 0;\n\n /*  <GROUP HEAD> ::= DO <STEP DEFINITION> ;    */\n   DO;\n      CALL MOVESTACKS(MPP1, MP);\n      INX(MP) = 1;  /* 1 DENOTES STEP */\n   END;\n\n /*  <GROUP HEAD> ::= DO <WHILE CLAUSE> ;    */\n   DO;\n      PPSAVE(MP) = PPSAVE(MPP1);\n      FIXL(MP) = FIXL(MPP1);\n      INX(MP) = 2;  /* 2 DENOTES WHILE */\n   END;\n\n /*  <GROUP HEAD> ::= DO <CASE SELECTOR> ;    */\n   DO;\n      CALL MOVESTACKS(MPP1, MP);\n      INX(MP) = 3;  /* 3 DENOTES CASE  */\n      INFORMATION = INFORMATION || ' CASE 0.';\n   END;\n\n /*  <GROUP HEAD> ::= <GROUP HEAD> <STATEMENT>    */\n   IF  INX(MP) = 3 THEN\n      DO;  /* CASE GROUP, MUST RECORD STATEMENT ADDRESSES */\n         CALL BRANCH (\"F\", FIXV(MP));\n      IF CASEP >= CASELIMIT THEN CALL ERROR ('TOO MANY CASES', 1);\n         ELSE CASEP = CASEP + 1;  CASESTACK(CASEP) = PP;\n      IF BCD \u00ac= 'END' THEN\n            INFORMATION = INFORMATION || ' CASE ' || CASEP-PPSAVE(MP) || PERIOD;\n      END;\n\n /*  <STEP DEFINITION> ::= <VARIABLE> <REPLACE> <EXPRESSION> <ITERATION CONTROL>\n         */\n   DO; /* EMIT CODE FOR STEPPING DO LOOPS */\n      CALL FORCEACCUMULATOR(MP+2);\n      IF INX(MP) \u00ac = 0 THEN\n         CALL ERROR ('SUBSCRIPTED DO VARIABLE', 0);\n      STEPK = PP;\n      CALL BRANCH(\"F\", 0);\n      PPSAVE(MP) = PP;\n      L = FIXL(MP);\n      ADREG = SYBASE(L);\n      ADRDISP = SYDISP(L);\n      IF SYTYPE(L) = BYTETYPE THEN\n         DO;\n            CALL EMITRR(\"1B\", REG(MP+2), REG(MP+2));\n            CALL EMITRX (\"43\", REG(MP+2), 0, ADREG, ADRDISP);\n         END;\n      ELSE IF SYTYPE(L) = HALFWORD THEN\n         CALL EMITRX (\"48\", REG(MP+2), 0, ADREG, ADRDISP);\n      ELSE\n         CALL EMITRX (LOAD, REG(MP+2), 0, ADREG, ADRDISP);\n      CALL EMITRX (\"5A\", REG(MP+2), 0, REG(MP+3), FIXL(MP+3));\n      CALL FIXBFW(STEPK, PP);\n      IF SYTYPE(L) = BYTETYPE THEN I = \"42\";\n      ELSE IF SYTYPE(L) = HALFWORD THEN I = \"40\";\n      ELSE I = STORE;\n      CALL EMITRX (I, REG(MP+2), 0, ADREG, ADRDISP);\n      CALL EMITRX (CMPR, REG(MP+2), 0, INX(MP+3), FIXV(MP+3));\n      FIXL(MP) = PP;\n      CALL BRANCH(\"2\", 0);\n        BASES(INX(MP)) = AVAIL;\n      BASES(REG(MP+2)) = AVAIL;\n   END;\n\n /*  <ITERATION CONTROL> ::= TO <EXPRESSION>    */\n   DO;\n      REG(MP) = DBR;\n      FIXL(MP) = TRUELOC;  /* POINT AT THE CONSTANT ONE FOR STEP  */\n      CALL SET_LIMIT;\n   END;\n\n /*  <ITERATION CONTROL> ::= TO <EXPRESSION> BY <EXPRESSION>    */\n   DO;\n      IF TYPE(SP) = CONSTANT THEN CALL EMITCONSTANT (FIXV(SP));\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (SP);\n            CALL EMITDATAWORD (0);\n            CALL FINDADDRESS (DP-4);\n            CALL EMITRX (STORE, REG(SP), 0, ADREG, ADRDISP);\n            BASES(REG(SP)) = AVAIL;\n         END;\n      REG(MP) = ADREG;\n      FIXL(MP) = ADRDISP;\n      CALL SET_LIMIT;\n   END;\n\n /*  <WHILE CLAUSE> ::= WHILE <EXPRESSION>    */\n   CALL BOOLBRANCH(SP, MP);\n\n /*  <CASE SELECTOR> ::= CASE <EXPRESSION>    */\n   DO;\n      CALL FORCEACCUMULATOR(SP);\n      CALL EMITRX(\"89\", REG(SP), 0, 0, 2);\n      FIXL(MP) = PP;\n      CALL EMITRX(LOAD, REG(SP), REG(SP), 0, 0);\n      CALL EMITRX(BC, \"F\", REG(SP), PBR, 0);\n      BASES(REG(SP)) = AVAIL;\n      FIXV(MP) = PP;\n      CALL BRANCH(\"F\", 0);\n      IF CASEP >= CASELIMIT THEN CALL ERROR ('TOO MANY CASES', 1);\n      ELSE CASEP = CASEP + 1;\n      CASESTACK(CASEP) = PP;\n      PPSAVE(MP) = CASEP;\n   END;\n\n /*  <PROCEDURE DEFINITION> ::= <PROCEDURE HEAD> <STATEMENT LIST> <ENDING>    */\n   DO; /* PROCEDURE IS DEFINED, RESTORE SYMBOL TABLE */\n       LEX_LEVEL = LEX_LEVEL - 1;\n       CALL NULLOUT(PROCMARK);\n       IF LENGTH(VAR(SP)) >0 & VAR(SP)\u00ac= SUBSTR(CURRENT_PROCEDURE,1) THEN DO;\n            CALL ERROR ('PROCEDURE' || CURRENT_PROCEDURE || ' CLOSED BY END ' ||\n               VAR(SP), 0);\n          CALL DUMP;\n          IF FIXIT THEN RETURN;\n       END;\n      IF CONTROL(BYTE('S')) THEN CALL SYMBOLDUMP;\n      DO I = PROCMARK TO NDECSY;\n         IF SYTYPE(I) = FORWARDTYPE | SYTYPE(I) = FORWARDCALL THEN\n          IF SYTCO(I) > 0 THEN\n            CALL ERROR ('UNDEFINED LABEL OR PROCEDURE: ' || SYT(I), 1);\n      END;\n      DO I = PROCMARK + PARCT  TO  NDECSY + 1;\n         SYT(I) = X1;   SY_LINK(I) = NULL;\n      END;\n      NDECSY = PROCMARK + PARCT - 1;\n      /* PARAMETER ADDRESS MUST BE SAVED BUT NAMES DISCARDED */\n      DO I = PROCMARK TO NDECSY;\n         IF SYTYPE(I) = 0 THEN\n            DO;\n               CALL ERROR('UNDECLARED PARAMETER:' || SYT(I));\n               SYTYPE(I) = FIXEDTYPE;\n               CALL EMITDATAWORD(0);\n               CALL FINDADDRESS(DP-4);\n               SYBASE(I) = ADREG;\n               SYDISP(I) = ADRDISP;\n            END;\n         SYT(I) = '';\n      END;\n      CURRENT_PROCEDURE = VAR(MP);\n      PROCMARK = FIXV(MP);  PARCT = CNT(MP);\n      RETURNED_TYPE = TYPE(MP) ;\n      /* EMIT A GRATUITOUS RETURN */\n      CALL FINDADDRESS(RTNADR);\n      CALL EMITRX(LOAD, BRCHREG, 0, ADREG, ADRDISP);\n      CALL EMITRR(BCR, \"F\", BRCHREG);\n      RTNADR = PPSAVE(MP);\n      CALL FIXBFW(FIXL(MP), PP); /* COMPLETE JUMP AROUND PROCEDURE DEFINITION */\n   END;\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> ;    */\n   DO;  /* MUST POINT AT FIRST PARAMETER EVEN IF NONEXISTENT  */\n      /* SAVE OLD PARAMETER COUNT */\n      CNT(MP) = PARCT; PARCT = 0;\n      /* SAVE OLD PROCEDURE MARK IN SYMBOL TABLE */\n      FIXV(MP) = PROCMARK;  PROCMARK = NDECSY + 1;\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = 0;\n      LEX_LEVEL = LEX_LEVEL + 1;\n      PROCEDURE_NUMBER, PROC_STACK(LEX_LEVEL) = PROCEDURE_NUMBER + 1;\n      CALL PROC_START;\n   END;\n\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <TYPE> ;    */\n   DO;\n      CNT(MP) = PARCT;\n      PARCT = 0;\n      FIXV(MP) = PROCMARK;\n      PROCMARK = NDECSY + 1;\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = TYPE(SP-1);\n      IF RETURNED_TYPE = CHRTYPE THEN\n         SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE ;\n      LEX_LEVEL = LEX_LEVEL + 1;\n      PROCEDURE_NUMBER, PROC_STACK(LEX_LEVEL) = PROCEDURE_NUMBER + 1;\n      CALL PROC_START;\n   END;\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> ;    */\n   DO;\n      CNT(MP) = CNT(MPP1);  /* SAVE PARAMETER COUNT */\n      FIXV(MP) = FIXV(MPP1);\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = 0;\n      CALL PROC_START;\n   END;\n\n\n /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> <TYPE> ;       */\n   DO;\n      CNT(MP) = CNT(MPP1);\n      FIXV(MP) = FIXV(MPP1);\n      TYPE(MP) = RETURNED_TYPE;\n      RETURNED_TYPE = TYPE(SP-1);\n      IF RETURNED_TYPE = CHRTYPE THEN\n         SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE ;\n      CALL PROC_START;\n   END;\n\n /*  <PROCEDURE NAME> ::= <LABEL DEFINITION> PROCEDURE    */\n   DO;\n      S = CURRENT_PROCEDURE;\n      CURRENT_PROCEDURE = X1 || VAR(MP);\n      VAR(MP) = S;\n   END;\n\n /*  <PARAMETER LIST> ::= <PARAMETER HEAD> <IDENTIFIER> )    */\n   DO;\n      PARCT = PARCT + 1;\n      CALL ENTER (VAR(MPP1), 0, 0, 0);\n   END;\n\n /*  <PARAMETER HEAD> ::= (   */\n   DO;  /* POINT AT THE FIRST PARAMETER FOR SYMBOL TABLE */\n      FIXV(MP) = PROCMARK;  PROCMARK = NDECSY + 1;\n      CNT(MP) = PARCT;\n      PARCT = 0;\n      LEX_LEVEL = LEX_LEVEL + 1;\n      PROCEDURE_NUMBER, PROC_STACK(LEX_LEVEL) = PROCEDURE_NUMBER + 1;\n   END;\n\n /*  <PARAMETER HEAD> ::= <PARAMETER HEAD> <IDENTIFIER> ,    */\n   DO;\n      PARCT = PARCT + 1;\n      CALL ENTER (VAR(MPP1), 0, 0, 0);\n   END;\n\n /*  <ENDING> ::= END    */\n   VAR(MP) = '';\n\n /*  <ENDING> ::= END <IDENTIFIER>    */\n   VAR(MP) = VAR(SP);\n\n /*  <ENDING> ::= <LABEL DEFINITION> <ENDING>    */\n   VAR(MP) = VAR(SP);\n\n /*  <LABEL DEFINITION> ::= <IDENTIFIER> :    */\n   FIXL(MP) = ENTER (VAR(MP), LABELTYPE, PP, FIXL(MP));\n\n\n /*  <RETURN STATEMENT> ::= RETURN    */\n   DO;  /* EMIT A RETURN BRANCH */\n      CALL FINDADDRESS(RTNADR);\n      CALL EMITRX(LOAD, BRCHREG,0,ADREG,ADRDISP);\n      CALL EMITRR(BCR,\"F\",BRCHREG);\n   END;\n\n /*  <RETURN STATEMENT> ::= RETURN <EXPRESSION>    */\n   DO;  /* EMIT A RETURN BRANCH & PASS VALUE IN REGISTER 3 */\n      /* NOW FORCE IT INTO REGISTER 3 */\n      TARGET_REGISTER = 3;\n      IF RETURNED_TYPE = CHRTYPE THEN\n         CALL FORCEDESCRIPT(MPP1);\n      ELSE\n         CALL FORCEACCUMULATOR(MPP1);\n      TARGET_REGISTER = -1;\n      IF REG(MPP1) \u00ac = 3 THEN CALL EMITRR(\"18\",3,REG(MPP1));\n      CALL FINDADDRESS(RTNADR);\n      CALL EMITRX(LOAD, BRCHREG, 0, ADREG, ADRDISP);\n      CALL EMITRR(BCR, \"F\", BRCHREG);\n      CALL CLEARREGS;\n   END;\n\n /*  <CALL STATEMENT> ::= CALL <VARIABLE>    */\n   DO;\n      CALL FORCEACCUMULATOR(SP);\n      CALL CLEARREGS;\n   END;\n\n /*  <GO TO STATEMENT> ::= <GO TO> <IDENTIFIER>    */\n   DO;\n      CALL ID_LOOKUP(SP);\n      J = FIXL(SP);\n      IF J < 0 THEN          /*  1ST OCURRANCE OF THE LABEL */\n         DO;\n            CALL EMITDATAWORD(0);      /* SPACE FOR FIXUP */\n            J = ENTER (VAR(SP), FORWARDTYPE, DP-4, FIXL(SP));\n            SYTCO(J) = 1;\n         END;\n      IF SYTYPE(J) = LABELTYPE THEN\n         CALL BRANCH_BD(\"F\",SYBASE(J),SYDISP(J));\n      ELSE IF SYTYPE(J) = FORWARDTYPE THEN\n         DO;\n            CALL EMITRX(LOAD,BRCHREG,0,SYBASE(J),SYDISP(J));\n            CALL EMITRX(BC,\"F\",BRCHREG,PBR,0);\n         END;\n      ELSE\n         DO;\n            CALL ERROR('TARGET OF GO TO IS NOT A LABEL',0);\n            CALL EMITRX(BC,\"F\",0,SYBASE(J),SYDISP(J));\n         END;\n   END;\n\n /*  <GO TO> ::= GO TO    */\n      ;\n /*  <GO TO> ::= GOTO    */\n      ;\n /*  <DECLARATION STATEMENT> ::= DECLARE <DECLARATION ELEMENT>    */\n      ;\n\n /*  <DECLARATION STATEMENT> ::= <DECLARATION STATEMENT> , <DECLARATION ELEMENT>\n          */\n      ;\n\n /*  <DECLARATION ELEMENT> ::= <TYPE DECLARATION>    */\n   DO;\n      IF TYPE(MP) = CHRTYPE THEN\n         DSP = NEWDSP ;\n      ELSE\n         DO;\n            DP = NEWDP ;\n            CALL CHECKBASES ;\n         END;\n   END;\n\n /*  <DECLARATION ELEMENT> ::= <IDENTIFIER> LITERALLY <STRING>    */\n      IF TOP_MACRO >= MACRO_LIMIT THEN\n         CALL ERROR('MACRO TABLE OVERFLOW',1);\n      ELSE\n         DO;\n            TOP_MACRO = TOP_MACRO + 1;\n            I = LENGTH(VAR(MP));\n            J = MACRO_INDEX(I);\n            DO L = 1 TO TOP_MACRO - J;\n               K = TOP_MACRO - L;\n               MACRO_NAME(K+1) = MACRO_NAME(K);\n               MACRO_TEXT(K+1) = MACRO_TEXT(K);\n            END;\n            MACRO_NAME(J) = VAR(MP);\n            MACRO_TEXT(J) = VAR(SP);\n            DO J = I TO 255;\n               MACRO_INDEX(J) = MACRO_INDEX(J)+1;\n            END;\n         END;\n\n /*  <TYPE DECLARATION> ::= <IDENTIFIER SPECIFICATION> <TYPE>    */\n   CALL TDECLARE(0);\n\n /*  <TYPE DECLARATION> ::= <BOUND HEAD> <NUMBER> ) <TYPE>    */\n   CALL TDECLARE(FIXV(MPP1));\n\n /*  <TYPE DECLARATION> ::= <TYPE DECLARATION> <INITIAL LIST>    */\n      ;\n\n /*  <TYPE> ::= FIXED    */\n   TYPE(MP) = FIXEDTYPE ;\n\n /*  <TYPE> ::= CHARACTER    */\n   TYPE(MP) = CHRTYPE ;\n\n /*  <TYPE> ::= LABEL    */\n   TYPE(MP) = FORWARDTYPE ;\n\n /*  <TYPE> ::= <BIT HEAD> <NUMBER> )    */\n      IF FIXV(MPP1) <= 8 THEN TYPE(MP) = BYTETYPE;\n      ELSE IF FIXV(MPP1) <= 16 THEN TYPE(MP) = HALFWORD;\n      ELSE IF FIXV(MPP1) <= 32 THEN TYPE(MP) = FIXEDTYPE;\n      ELSE TYPE(MP) = CHRTYPE;\n\n /*  <BIT HEAD> ::= BIT (   */\n      ;\n\n /*  <BOUND HEAD> ::= <IDENTIFIER SPECIFICATION> (   */\n      ;\n\n /*  <IDENTIFIER SPECIFICATION> ::= <IDENTIFIER>    */\n   DO;\n      INX(MP) = 1;\n      I = FIXL(MP);\n      FIXL(MP) = CASEP;\n      IF CASEP >= CASELIMIT THEN\n         CALL ERROR(DCLRM,1);\n      ELSE\n         CASEP = CASEP + 1;\n      CASESTACK(CASEP) = ENTER (VAR(MP), 0, 0, I);\n   END;\n\n /*  <IDENTIFIER SPECIFICATION> ::= <IDENTIFIER LIST> <IDENTIFIER> )    */\n   DO;\n      INX(MP) = INX(MP) + 1;\n      IF CASEP >= CASELIMIT THEN\n         CALL ERROR(DCLRM, 1);\n      ELSE\n         CASEP = CASEP + 1;\n      CASESTACK(CASEP) = ENTER (VAR(MPP1), 0, 0, FIXL(MPP1));\n   END;\n\n /*  <IDENTIFIER LIST> ::= (   */\n   DO;\n      INX(MP) = 0;\n      FIXL(MP) = CASEP;\n   END;\n\n /*  <IDENTIFIER LIST> ::= <IDENTIFIER LIST> <IDENTIFIER> ,    */\n   DO;\n      INX(MP) = INX(MP) + 1;\n       IF CASEP >= CASELIMIT THEN CALL ERROR(DCLRM,1);\n       ELSE\n         CASEP = CASEP + 1;\n      CASESTACK(CASEP) = ENTER (VAR(MPP1), 0, 0, FIXL(MPP1));\n   END;\n\n /*  <INITIAL LIST> ::= <INITIAL HEAD> <CONSTANT> )    */\n   CALL SETINIT ;\n\n /*  <INITIAL HEAD> ::= INITIAL (   */\n   IF INX(MP-1) = 1 THEN\n      ITYPE = TYPE(MP-1);    /*  INFORMATION FROM  <TYPE DECLARATION>  */\n   ELSE\n      DO;\n         CALL ERROR('INITIAL MAY NOT BE USED WITH IDENTIFIER LIST',0);\n         ITYPE = 0;\n      END;\n\n\n /*  <INITIAL HEAD> ::= <INITIAL HEAD> <CONSTANT> ,    */\n   CALL SETINIT;\n\n /*  <ASSIGNMENT> ::= <VARIABLE> <REPLACE> <EXPRESSION>    */\n   CALL GENSTORE(MP,SP);\n\n /*  <ASSIGNMENT> ::= <LEFT PART> <ASSIGNMENT>    */\n   CALL GENSTORE(MP,SP);\n\n /*  <REPLACE> ::= =    */\n   ;\n\n /*  <LEFT PART> ::= <VARIABLE> ,    */\n   ;\n\n /*  <EXPRESSION> ::= <LOGICAL FACTOR>    */\n      ;\n /*  <EXPRESSION> ::= <EXPRESSION> | <LOGICAL FACTOR>    */\n   /* \"16\" = OR, \"56\" = O */\n   CALL ARITHEMIT(\"16\");\n\n /*  <LOGICAL FACTOR> ::= <LOGICAL SECONDARY>    */\n      ;\n\n /*  <LOGICAL FACTOR> ::= <LOGICAL FACTOR> & <LOGICAL SECONDARY>    */\n   /* \"14\" = NR, \"54\" = N */\n   CALL ARITHEMIT(\"14\");\n\n /*  <LOGICAL SECONDARY> ::= <LOGICAL PRIMARY>    */\n   IF TYPE(MP) = CONDITION THEN CALL CONDTOREG(MP, REG(MP));\n\n /*  <LOGICAL SECONDARY> ::= \u00ac <LOGICAL PRIMARY>    */\n   DO;\n      CALL MOVESTACKS (SP, MP);\n      IF TYPE(MP) = CONDITION THEN\n         CALL CONDTOREG (MP, \"E\" - REG(MP));\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (MP);\n              /* \"57\" = X */\n            CALL EMITRX (\"57\", REG(MP), 0, DBR, COMPLOC);\n         END;\n   END;\n\n /*  <LOGICAL PRIMARY> ::= <STRING EXPRESSION>    */\n      ;\n\n   /*              CONDITION CODES     MASK\n                   0  OPERANDS EQUAL   BIT 8\n                   1  FIRST OPERAND LO BIT 9\n                   2  FIRST OPERAND HI BIT 10                                 */\n\n /*  <LOGICAL PRIMARY> ::= <STRING EXPRESSION> <RELATION> <STRING EXPRESSION>\n         */\n   DO;\n      CALL ARITHEMIT(CMPRR);\n      BASES(REG(MP)) = AVAIL;\n      REG(MP) = REG(MPP1);\n      TYPE(MP) = CONDITION;\n   END;\n\n /*  <RELATION> ::= =    */\n   REG(MP) = 6;\n\n /*  <RELATION> ::= <    */\n   REG(MP) = 10;\n\n /*  <RELATION> ::= >    */\n   REG(MP) = 12;\n\n /*  <RELATION> ::= \u00ac =    */\n   REG(MP) = 8;\n\n /*  <RELATION> ::= \u00ac <    */\n   REG(MP) = 4;\n\n /*  <RELATION> ::= \u00ac >    */\n   REG(MP) = 2;\n\n /*  <RELATION> ::= < =    */\n   REG(MP) = 2;\n\n /*  <RELATION> ::= > =    */\n   REG(MP) = 4;\n\n /*  <STRING EXPRESSION> ::= <ARITHMETIC EXPRESSION>    */\n      IF TYPE(SP) = VARIABLE THEN\n         IF SYTYPE(FIXL(SP)) = CHAR_PROC_TYPE THEN\n            CALL FORCEDESCRIPT(SP);\n\n /*  <STRING EXPRESSION> ::= <STRING EXPRESSION> || <ARITHMETIC EXPRESSION>\n         */\n   DO; /* CATENATE TWO STRINGS */\n      CALL FORCEDESCRIPT(SP);\n      CALL EMITRX(STORE,REG(SP),0,B1,B2);\n      BASES(REG(SP)) = AVAIL;\n      CALL FORCEDESCRIPT(MP);\n      CALL EMITRX(STORE,REG(MP),0,A1,A2);\n      BASES(REG(MP)) = AVAIL;\n      CALL CALLSUB(0,CATENTRY,3,MP);\n      /* ASSUME CATENATE IS IN THE 1ST PAGE */\n\n      TYPE(MP) = DESCRIPT;\n   END;\n\n /*  <ARITHMETIC EXPRESSION> ::= <TERM>    */\n      ;\n /*  <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> + <TERM>    */\n   /* \"1A\" = AR, \"5A\" = A  */\n   CALL ARITHEMIT(\"1A\");\n\n /*  <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> - <TERM>    */\n   /* \"1B\" = SR, \"5B\" = S */\n   CALL ARITHEMIT(\"1B\");\n\n /*  <ARITHMETIC EXPRESSION> ::= + <TERM>    */\n   CALL MOVESTACKS(MPP1,MP);\n\n /*  <ARITHMETIC EXPRESSION> ::= - <TERM>    */\n   DO;\n      CALL MOVESTACKS(MPP1, MP);\n      IF TYPE(MP) = CONSTANT THEN FIXV(MP) = - FIXV(MP);\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(MP);\n            CALL EMITRR(\"13\", REG(MP), REG(MP));  /* LCR = COMPLEMENT */\n         END;\n   END;\n\n /*  <TERM> ::= <PRIMARY>    */\n      ;\n\n /*  <TERM> ::= <TERM> * <PRIMARY>    */\n   /* \"1C\" = MR, \"5C\" = M */\n   DO;\n      CALL FORCEACCUMULATOR(MP);\n      IF REG(MP) = 1 THEN\n         DO;  /* MULTIPLY IS FUNNY ON A 360--SORRY */\n            REG(MP) = 0;\n            CALL ARITHEMIT(\"1C\");\n            REG(MP) = 1;\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR(SP);\n             IF REG(SP) = 1 THEN\n               DO;\n                  CALL EMITRR(\"1C\",0,REG(MP));\n                  BASES(REG(MP)) = AVAIL;\n                  REG(MP) = 1;\n               END;\n               ELSE IF REG(MP) + REG(SP) = 5 THEN\n                  DO;   /*  OPERANDS ARE IN 2 & 3  */\n                      CALL EMITRR(\"1C\",2,2);\n                      BASES(2) = AVAIL;\n                      REG(MP) = 3;\n                  END;\n            ELSE CALL ERROR ('MULTIPLY FAILED ***', 1);\n         END;\n   END;\n\n /*  <TERM> ::= <TERM> / <PRIMARY>    */\n   CALL DIVIDE_CODE;\n   /*  DIVIDE IS EVEN FUNNIER THAN MULTIPLY  */\n\n /*  <TERM> ::= <TERM> MOD <PRIMARY>    */\n   DO;\n      CALL DIVIDE_CODE;\n      CALL EMITRR(\"18\",1,0);                     /*  LR    1,0        */\n   END;\n\n /*  <PRIMARY> ::= <CONSTANT>    */\n      ;\n /*  <PRIMARY> ::= <VARIABLE>    */\n      IF FIXV(MP) = 3 THEN   /*  FINISH OFF THE FUNCTION  BYTE        */\n         IF CNT(MP) = 1 THEN\n            DO;\n               IF TYPE(MP) = CHRTYPE THEN\n                  DO;\n                     TYPE(MP) = CONSTANT;\n                     FIXV(MP) = BYTE(VAR(MP));\n                  END;\n               ELSE\n                  DO;\n                     I = FINDAC;\n                     CALL EMITRR(\"1B\",I,I);      /*  SR    I,I        */\n                     CALL EMITRX(\"43\",I,0,REG(MP),0);\n                                                 /*  IC               */\n                     BASES(REG(MP)) = AVAIL;\n                     REG(MP) = I;\n                     TYPE(MP) = ACCUMULATOR;\n                  END;\n            END;\n         ELSE IF CNT(MP) = 2 THEN\n            DO;\n               I = INX(MP);\n                     CALL EMITRX(\"43\",I,I,REG(MP),0);\n                     BASES(REG(MP)) = AVAIL;\n                     REG(MP) = I;\n               TYPE(MP) = ACCUMULATOR;\n            END;\n\n /*  <PRIMARY> ::= ( <EXPRESSION> )    */\n   CALL MOVESTACKS(MPP1, MP);\n\n /*  <VARIABLE> ::= <IDENTIFIER>    */\n   DO;      /* FIND THE IDENTIFIER IN THE SYMBOL TABLE */\n      CALL ID_LOOKUP(MP);\n      IF FIXL(MP) = -1 THEN\n         CALL UNDECLARED_ID(MP);\n   END;\n\n /*  <VARIABLE> ::= <SUBSCRIPT HEAD> <EXPRESSION> )    */\n   DO;  /* EITHER A PROCEDURE CALL OR ARRAY OR BUILT IN FUNCTION */\n      CNT(MP) = CNT(MP) + 1;\n      I = FIXV(MP);\n\n      IF I < 6 THEN\n      DO CASE I;\n\n         /* CASE  0  */\n\n         DO;      /* SUBS | CALL */\n            CALL FORCEACCUMULATOR (MPP1);\n            IF SYTYPE(FIXL(MP)) = LABELTYPE |\n               SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE  THEN DO;\n               CALL STUFF_PARAMETER;\n               CALL FORCEACCUMULATOR (MP);\n               END;\n            ELSE\n               DO;      /* SUBSCRIPTED VARIABLE */\n                  IF CNT(MP) > 1 THEN\n                     CALL ERROR ('MULTIPLE SUBSCRIPTS NOT ALLOWED', 0);\n                  INX(MP) = REG(MPP1);\n               END;\n         END;\n\n         /* CASE  1  */\n\n         DO;  /* BUILT IN FUNCTION: LENGTH */\n            CALL FORCEDESCRIPT (MPP1);\n            CALL EMITRR (\"12\", REG(MPP1), REG(MPP1));  /* LTR TO CHECK FOR NUL*/\n            CALL EMITRX (\"88\", REG(MPP1), 0, 0, 24);  /* SHIFT TO CHARACTER */\n            I = PP;\n            CALL BRANCH (8, 0);   /* DON'T INCREMENT LENGTH ON NULL STRING */\n            CALL EMITRX (LA, REG(MPP1), 0, REG(MPP1), 1); /*ADD 1, TRUE LENGTH*/\n            CALL FIXBFW (I, PP);  /* DESTINATION OF NULL STRING JUMP */\n            REG(MP) = REG(MPP1);  /* RECORD CONTAINING ACCUMULATOR */\n            TYPE(MP) = ACCUMULATOR;\n         END;\n\n         /* CASE  2  */\n\n         /* BUILT-IN FUNCTION SUBSTR */\n         DO;\n            IF CNT(MP) = 2 THEN\n               DO;\n                  IF TYPE(MPP1) = CONSTANT THEN\n                     DO;\n                        CALL EMITCONSTANT (SHL(FIXV(MPP1), 24) - FIXV(MPP1));\n                        CALL EMITRX (\"5F\", REG(MP), 0, ADREG, ADRDISP);\n                     END;\n                  ELSE\n                     DO;\n                        CALL FORCEACCUMULATOR (MPP1);\n                        CALL EMITRR (\"1E\", REG(MP), REG(MPP1)); /* ALR BASE */\n                        CALL EMITRX (\"89\", REG(MPP1), 0, 0, 24);\n                        CALL EMITRR (\"1F\", REG(MP), REG(MPP1));\n                        BASES(REG(MPP1)) = AVAIL;\n                     END;\n                  I = PP;\n                  CALL BRANCH (1, 0);     /* WE MAY NOW HAVE NEGATIVE LENGTH */\n                  CALL EMITRR (\"1B\", REG(MP), REG(MP));  /* NULL DESCRIPTOR */\n                  CALL FIXBFW (I, PP);\n               END;\n            ELSE\n               DO;         /* THREE ARGUMENTS */\n                  CALL EMITRX (LA, REG(MP), INX(MP), REG(MP), PPSAVE(MP));\n                  BASES(INX(MP)) = AVAIL;\n                  IF TYPE(MPP1) \u00ac= CONSTANT THEN\n                     DO;\n                        CALL FORCEACCUMULATOR (MPP1);\n                        CALL EMITRX (LA, REG(MPP1), 0, REG(MPP1), \"FF\");\n                                /* DECREMENT LENGTH BY 1  */\n                        CALL EMITRX (\"89\", REG(MPP1), 0, 0, 24);\n                        CALL EMITRR (\"16\", REG(MP), REG(MPP1));  /* | INTO D */\n                        BASES(REG(MPP1)) = AVAIL;\n                     END;\n                  ELSE\n                     DO;\n                        CALL EMITCONSTANT (SHL(FIXV(MPP1)-1, 24));\n                        CALL EMITRX (\"56\", REG(MP), 0, ADREG, ADRDISP);\n                     END;\n               END;\n            TYPE(MP) = DESCRIPT;\n         END;\n\n         /* CASE  3  */\n\n         DO;      /* BUILT IN FUNCTION BYTE */\n            IF CNT(MP) = 1 THEN\n               DO;\n                  IF TYPE(MPP1) = CHRTYPE THEN\n                     DO;\n                        TYPE(MP) = CHRTYPE;\n                        VAR(MP) = VAR(MPP1);\n                     END;\n                  ELSE\n                     DO;\n                        CALL FORCEDESCRIPT(MPP1);\n                        IF REG(MPP1) = 0 THEN\n                           DO;\n                              REG(MP) = FINDAC;\n                              CALL EMITRR(\"18\",REG(MP),0);\n                                                 /*  LR    REG(MP),0  */\n                           END;\n                        ELSE\n                           REG(MP) = REG(MPP1);\n                        TYPE(MP) = DESCRIPT;\n                        INX(MP) = 0;\n                    END;\n               END;\n            ELSE IF CNT(MP) = 2 THEN\n               DO;\n                  CALL FORCEACCUMULATOR(MPP1);\n                  INX(MP) = REG(MPP1);\n               END;\n            ELSE\n               CALL ERROR('BYTE CALLED WITH MORE THAN TWO ARGUMENTS',0);\n         END;\n\n         /* CASE  4  */\n\n         CALL SHIFT_CODE(\"89\");        /*  SLL  */\n\n         /* CASE  5  */\n\n         CALL SHIFT_CODE(\"88\");        /*  SRL  */\n      END;     /* OF CASE STATEMENT */\n\n      ELSE IF I = 10 THEN\n         CALL EMIT_INLINE;\n      ELSE IF I = 19 THEN    /*  BUILTIN  FUNCTION  ADDR   */\n         DO;\n            REG(MP) = FINDAC;\n            CALL FORCE_ADDRESS(MPP1,REG(MP));\n            TYPE(MP) = ACCUMULATOR;\n         END;\n      ELSE\n         DO;\n            CALL FORCEACCUMULATOR (MPP1);\n            IF CNT(MP) = 1 THEN REG(MP) = REG(MPP1);\n            ELSE INX(MP) = REG(MPP1);\n         END;\n\n   END;     /* OF PRODUCTION */\n\n /*  <SUBSCRIPT HEAD> ::= <IDENTIFIER> (   */\n   DO;\n      CALL ID_LOOKUP(MP);\n      IF FIXL(MP) < 0 THEN\n         CALL UNDECLARED_ID(MP);\n   END;\n\n /*  <SUBSCRIPT HEAD> ::= <SUBSCRIPT HEAD> <EXPRESSION> ,    */\n   DO;      /* BUILT IN FUNCTION OR PROCEDURE CALL */\n      CNT(MP) = CNT(MP) + 1;\n      IF FIXV(MP) = 0 THEN\n         DO;      /* \u00ac BUILT IN FUNCTION */\n            CALL FORCEACCUMULATOR (MPP1);\n            IF SYTYPE(FIXL(MP)) = LABELTYPE |\n               SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE  THEN\n               CALL STUFF_PARAMETER;\n         END;\n      ELSE IF FIXV(MP) = 2 | FIXV(MP) = 3 THEN\n         DO;      /* SUBSTR OR BYTE */\n            IF CNT(MP) = 1 THEN\n               DO;\n                  CALL FORCEDESCRIPT (MPP1);\n                  IF REG(MPP1) = 0 THEN\n                     DO;\n                        REG(MP) = FINDAC;\n                        CALL EMITRR (\"18\", REG(MP), 0);\n                     END;\n                  ELSE REG(MP) = REG(MPP1);\n               END;\n            ELSE IF CNT(MP) = 2 THEN\n               DO;\n                  IF TYPE(MPP1) = CONSTANT THEN PPSAVE(MP) = FIXV(MPP1);\n                  ELSE\n                     DO;\n                        CALL FORCEACCUMULATOR (MPP1);\n                        INX(MP) = REG(MPP1);\n                        PPSAVE(MP) = 0;\n                     END;\n               END;\n            ELSE CALL ERROR ('TOO MANY ARGUMENTS TO SUBSTR | BYTE');\n         END;\n      ELSE IF FIXV(MP) = 4 | FIXV(MP) = 5 THEN\n         DO;  /*  SHR  |  SHL  */\n            CALL FORCEACCUMULATOR(MPP1);\n            REG(MP) = REG(MPP1);\n         END;\n      ELSE IF FIXV(MP) = 10 THEN\n         CALL EMIT_INLINE;\n      ELSE IF FIXV(MP) >= 8 THEN\n         DO;      /* SOME SORT OF MONITOR CALL */\n            CALL FORCEACCUMULATOR (MPP1);\n            IF CNT(MP) = 1 THEN REG(MP) = REG(MPP1);\n            ELSE CALL ERROR ('TOO MANY ARGUMENTS FOR ' || SYT(FIXL(MP)));\n         END;\n      ELSE;      /* RESERVED FOR OTHER BUILT IN FUNCTIONS */\n   END;\n\n /*  <CONSTANT> ::= <STRING>    */\n   TYPE(MP) = CHRTYPE;\n\n /*  <CONSTANT> ::= <NUMBER>    */\n   TYPE(MP) = CONSTANT;\n\n   END;  /* OF CASE SELECTION ON PRODUCTION NUMBER */\nEND SYNTHESIZE;\n\nRECOVER: PROCEDURE;\n IF \u00ac RECOV THEN DO;\n      RECOV=TRUE;\n      IF NEXT > 0 THEN DO;\n         TOKEN = NEXT;\n         NEXT = 0;\n         END;\n      DO WHILE \u00acSTOPIT(TOKEN);\n           CALL SCAN;\n      END;\n END;\n ELSE IF SP>1 THEN DO;  /* RESTORE LOOK AHEAD STATE IF POSSIBLE */\n      SP=SP-1;\n      I = STATE_STACK(SP-1) ;\n      IF TRANS(STATESTART(I),STATEEND(I),STATETOKEN(STATE_STACK(SP)))\n           THEN STATE_STACK(SP)= NEWSTATE ;\n      ELSE CALL ERROR(' FAILURE IN STATE RECOVERY',1);\n END;\n ELSE IF NEXT > 0 THEN DO;\n         TOKEN = NEXT;\n         NEXT = 0;\n         END;\n ELSE CALL SCAN;\n OUTPUT= 'RESUME:' || SUBSTR(POINTER, TEXT_LIMIT+LB-CP+MARGIN_CHOP+7);\n STATE#= STATE_STACK(SP) ;\nEND RECOVER;\n\n\n\n COMPILATION_LOOP: PROCEDURE;\n   DECLARE SYNTAX_ERROR CHARACTER INITIAL\n      (' IS NOT ACCEPTED AS A SCAN TOKEN: SYNTAX ERROR');\n\n DO WHILE COMPILING;\n    DO CASE SHR( STATETYPE( SHR(STATE#,2)),SHL(3-STATE# &3,1)) &3;\n      COMPILING=FALSE; /* CASE 0 IS ACCEPT STATE. QUIT */\n      DO;   /* CASE 1 IS REDUCE STATE.APPLY PRODUCTION STATE# */\n           COUNT#STACK = COUNT#STACK + 1;\n           MP= SP - STATESTART(STATE#) + 1 ; /* POINT TO LEFT END OF\n                                                 REDUCE STRING*/\n           MPP1=MP+1;\n           CALL SYNTHESIZE(STATE#);\n           SP=MP;\n           I= STATE_STACK(SP-1) ;\n           IF TRANS(STATEMIDDLE(I),STATEEND(I),STATEEND(STATE#)) THEN\n                   STATE_STACK(SP),STATE#= NEWSTATE;\n              ELSE DO;\n                   IF \u00acRECOV THEN DO;\n                   CALL ERROR(' SCANNED TOKEN ' || V(STATEEND(STATE#))\n                     || ' IS ILLEGAL IN STATE #' || STATE_STACK(SP-1),1);\n                   CALL DUMP ;\n                   END;\n                   CALL RECOVER;\n                   END;\n      END;   /* OF CASE 1 */\n      DO;   /* CASE 2. SCAN SCANSTOKEN TILL MATCH TOKEN */\n           IF SP=STACKSIZE THEN DO;\n                CALL ERROR('*** STACK OVERFLOW. COMPILATION ABORTED',1);\n                RETURN;\n           END;\n           IF TRANS(STATESTART(STATE#),STATEMIDDLE(STATE#)-1,TOKEN) THEN DO ;\n                     SP=SP+1;\n                     VAR(SP)=BCD;\n                     FIXV(SP)= NUMBER_VALUE;\n                     FIXL(SP)=CARD_COUNT;\n                     PPSAVE(SP)=PP;\n                     RECOV=FALSE;\n                     IF NEXT = 0 THEN CALL SCAN;\n                     ELSE DO;\n                          TOKEN = NEXT;\n                          NEXT= 0;\n                          END ;\n                     STATE_STACK(SP),STATE#= NEWSTATE;\n           END;\n           ELSE DO;\n                IF \u00ac RECOV THEN DO;\n                  CALL ERROR (V(TOKEN) || SYNTAX_ERROR, 1);\n                  CALL DUMP;\n                  END;\n                CALL RECOVER;\n           END;\n      END;   /* OF DO CASE 2.   */\n      DO;  /* CASE 3   LOOK-AHEAD STATE  */\n           J= STATESTART(STATE#);\n           /*  I IS LOOK-AHEAD TABLE POINTER  */\n           DO I= LASTART(J) TO LASTART(J+1)-1;\n              IF TOKEN= LATOKENS(I) THEN DO ; /* MATCH FOUND */\n                STATE#= LAGOTOS(I) ;\n                IF STATESTART(STATE#)= 0 THEN DO ;\n                     COUNT#STACK = COUNT#STACK + 1;\n                     MP = SP + 1 ;\n                     MPP1= MP + 1;\n                     CALL SYNTHESIZE(STATE#);\n                     NEXT= TOKEN ;\n                     TOKEN= STATEEND(STATE#);\n                     STATE#= STATE_STACK(SP) ;\n                     END ;\n                ELSE STATE_STACK(SP)= STATE# ;\n                RECOV=FALSE;\n                GO TO OUTLOOK;\n           END;\n           END;\n           IF \u00acRECOV THEN DO;\n                  CALL ERROR (V(TOKEN) || SYNTAX_ERROR, 1);\n              CALL DUMP;\n           END;\n           CALL RECOVER;\nOUTLOOK: END;/* OF CASE 3 */\n    END;   /* OF DO CASE STATEMIX(STATE#)  */\n END;   /* OF DO WHILE COMPILING */\n END COMPILATION_LOOP;\n\n\n\n\n\nLOADER:\n   PROCEDURE;\n\n      /*  WRITE OUT A LOAD FILE OF COMPILED CODE & DATA\n         ASSUMES CODE ON  FILE(CODEFILE, J)    J = 0 TO CODEMAX\n         ASSUMES DATA ON  FILE(DATAFILE, J)   J = 0 TO DATAMAX\n         ASSUMES STRINGS ON FILE(STRINGFILE,J)\n         OUTPUT  ON FILE(BINARYFILE, J)  J = 0 TO CODEMAX+DATAMAX+1\n         ASSUMES THAT BINARYFILE = CODEFILE    */\n\n\n      /*  PUT SOME CONTROL INFORMATION IN THE FIRST 60 BYTES OF THE\n         FIRST BLOCK OF CODE.  CONSECUTIVE WORDS OF THIS CONTROL\n         INFORMATION CONTAIN:\n\n            1  # OF BYTES OF PROGRAM\n            2  # OF BYTES OF DATA\n            3  # OF BLOCKS OF PROGRAM\n            4  # OF BLOCKS OF DATA\n            5  # OF BYTES PER BLOCK\n            6  # OF BYTES ACTUALLY FILLED IN THE LAST CODE BLOCK\n            7  # OF BYTES ACTUALLY FILLED IN THE LAST DATA BLOCK\n\n         THE FILE IS FORMATTED:\n\n            1  CODEMAX+1 BLOCKS OF PROGRAM\n               (AND CONTROL INFORMATION AT HEAD OF FIRST BLOCK)\n            2  DATAMAX+1 BLOCKS OF DATA AND STRINGS\n      */\n\n      DECLARE (I, J) FIXED;\n      DECLARE BLOCKCNT FIXED;  /* CUMMULATIVE BLOCK COUNTER DURING LOAD */\n\n      CONTROL(BYTE('E')) = FALSE;\n      EJECT_PAGE;\n      DP = BASES(SBR);\n      CALL FIXWHOLEDATAWORD (BASEDATA, DP);\n      DO I = 0 TO SHR(DSP,2);\n         CALL EMITDATAWORD (DESC(I));\n      END;\n      CALL FIXWHOLEDATAWORD(BASEDATA+4, DP);\n\n      /* COPY COMPILED CHARACTER STRINGS TO THE PROGRAM DATA AREA */\n      CHPORG = 0;\n      CHPLIM = DISKBYTES;\n      FILE(STRINGFILE,CURSBLK) = STRINGS;    /* WRITE OUT CURRENT BLOCK */\n      CURSBLK = 0;\n      STRINGS = FILE(STRINGFILE,CURSBLK);    /* READ IN FIRST BLOCK */\n\n      DO I = 0 TO CHP;\n         IF I >= CHPLIM THEN\n            DO;\n               CURSBLK = CURSBLK + 1;\n               STRINGS = FILE(STRINGFILE,CURSBLK);   /* READ IN NEXT BLOCK */\n               CHPORG = CHPORG + DISKBYTES;\n               CHPLIM = CHPLIM + DISKBYTES;\n            END;\n         CALL EMITBYTE(STRINGS(I-CHPORG));\n      END;\n\n      CALL FIXWHOLEDATAWORD(BASEDATA+8, DP);\n\n      CALL INSERT_CODE_FIXUPS;\n\n      CODE = FILE(CODEFILE,0);        /*  READ IN FIRST CODE RECORD  */\n\n      CODEMAX(1) = DISKBYTES*(CODEMAX+1);\n      CODEMAX(2) = DISKBYTES*(DATAMAX+1);\n      CODEMAX(3) = CODEMAX + 1;\n      CODEMAX(4) = DATAMAX + 1;\n      CODEMAX(5) = DISKBYTES;\n      IF SEVERE_ERRORS > 0 THEN IF \u00ac CONTROL(BYTE('Z')) THEN\n         DO;\n            CODE(60) = \"07\";\n            CODE(61) = \"FC\";\n            OUTPUT = '########  EXECUTION OF THIS PROGRAM WILL BE INHIBITED.';\n         END;\n      J = PP - CODEMAX(1) + DISKBYTES;    /*  PORTION ACTUALLY  USED  */\n      /* FORCES REMAINDER TO WORD BOUNDARY  */\n      J = (J + 3) & \"FFFFFC\";\n      CODEMAX(6) = J;\n        /* PORTION OF THE LAST DATA RECORD WHICH WAS ACTUALLY USED  */\n      CODEMAX(7) = (DP - CODEMAX(2) + DISKBYTES + 3) & \"FFFFFC\" ;\n\n\n      OUTPUT = '*  FILE CONTROL BLOCK  ' || CODEMAX(1) || X4 ||\n         CODEMAX(2) || X4 || CODEMAX(3) || X4 || CODEMAX(4) || X4 ||\n         CODEMAX(5) || X4 || CODEMAX(6) || X4 || CODEMAX(7);\n\n      FILE(BINARYFILE,0) = CODE;   /* WRITE FIRST RECORD TO BINARY FILE */\n\n      BLOCKCNT = CODEMAX + 1;\n\n      FILE(DATAFILE,CURDBLK) = DATA;  /* WRITE OUT CURRENT DATA ARRAY */\n\n\n      /*  WRITE OUT THE COMPILE DATA ARRAY  */\n\n      DO J = 0 TO DATAMAX;\n         DATA = FILE(DATAFILE,J);\n         FILE(BINARYFILE, BLOCKCNT)  =  DATA ;\n         BLOCKCNT = BLOCKCNT + 1;\n      END;\n\n      OUTPUT = '*  LOAD FILE WRITTEN.';\n\n   END LOADER;\n\n\nPRINT_SUMMARY:\n   PROCEDURE;\n      DECLARE I FIXED;\n      CALL PRINT_DATE_AND_TIME ('END OF COMPILATION ', DATE, TIME);\n      OUTPUT = '';\n      OUTPUT = CARD_COUNT || ' CARDS CONTAINING ' || STATEMENT_COUNT\n         || ' STATEMENTS WERE COMPILED.';\n      IF ERROR_COUNT = 0 THEN OUTPUT = 'NO ERRORS WERE DETECTED.';\n      ELSE IF ERROR_COUNT > 1 THEN\n         OUTPUT = ERROR_COUNT || ' ERRORS (' || SEVERE_ERRORS\n            || ' SEVERE) WERE DETECTED.';\n      ELSE IF SEVERE_ERRORS = 1 THEN OUTPUT = 'ONE SEVERE ERROR WAS DETECTED.';\n         ELSE OUTPUT = 'ONE ERROR WAS DETECTED.';\n      IF PREVIOUS_ERROR > 0 THEN\n         OUTPUT = 'THE LAST DETECTED ERROR WAS ON LINE ' || PREVIOUS_ERROR\n            || PERIOD;\n      OUTPUT = PP || ' BYTES OF PROGRAM, ' || DP-DSP-CHP || ' OF DATA, ' || DSP\n         || ' OF DESCRIPTORS, ' || CHP || ' OF STRINGS.  TOTAL CORE REQUIREMENT'\n         || X1 || PP + DP || ' BYTES.';\n      IF CONTROL(BYTE('D')) THEN CALL DUMPIT;\n      DOUBLE_SPACE;\n      CLOCK(3) = TIME;\n      DO I = 1 TO 3;   /* WATCH OUT FOR MIDNIGHT */\n         IF CLOCK(I) < CLOCK(I-1) THEN CLOCK(I) = CLOCK(I) +  8640000;\n      END;\n      CALL PRINT_TIME ('TOTAL TIME IN COMPILER   ', CLOCK(3) - CLOCK(0));\n      CALL PRINT_TIME ('SET UP TIME              ', CLOCK(1) - CLOCK(0));\n      CALL PRINT_TIME ('ACTUAL COMPILATION TIME  ', CLOCK(2) - CLOCK(1));\n      CALL PRINT_TIME ('POST-COMPILATION TIME    ', CLOCK(3) - CLOCK(2));\n      IF CLOCK(2) > CLOCK(1) THEN   /* WATCH OUT FOR CLOCK BEING OFF */\n      OUTPUT = 'COMPILATION RATE: ' || 6000*CARD_COUNT/(CLOCK(2)-CLOCK(1))\n         || ' CARDS PER MINUTE.';\n   END PRINT_SUMMARY;\n\nMAIN_PROCEDURE:\n   PROCEDURE;\n      CLOCK(0) = TIME;  /* KEEP TRACK OF TIME IN EXECUTION */\n      CALL INITIALIZATION;\n\n      /* CLOCK(1) GETS SET IN GETCARD */\n      CALL COMPILATION_LOOP;\n\n      CLOCK(2) = TIME;\n      CALL LOADER;\n\n      /* CLOCK(3) GETS SET IN PRINT_SUMMARY */\n      CALL PRINT_SUMMARY;\n\n   END MAIN_PROCEDURE;\n\n\nCALL MAIN_PROCEDURE;\nRETURN SEVERE_ERRORS;\n\nEOF EOF EOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE17": {"ttr": 14346, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x00M\\x00M\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "SPASCAL"}, "text": "COMPACTIFY:\n   PROCEDURE;\n   DECLARE (I, J, K, L, ND, TC, BC, DELTA) FIXED;\n   DECLARE DX_SIZE LITERALLY '500', DX(DX_SIZE) BIT(16);\n   DECLARE MASK FIXED INITIAL (\"FFFFFF\"), LOWER_BOUND FIXED, TRIED BIT(1);\n   /* FIRST WE MUST SET THE LOWER BOUND OF THE COLLECTABLE AREA */\n   IF LOWER_BOUND = 0 THEN LOWER_BOUND = FREEBASE;\n DO TRIED = 0 TO 1;\n   ND = -1;\n   /* FIND THE COLLECTABLE DESCRIPTORS  */\n   DO I = 0 TO NDESCRIPT;\n      IF (DESCRIPTOR(I) & MASK) >= LOWER_BOUND THEN\n         DO;\n            ND = ND + 1;\n            IF ND > DX_SIZE THEN\n               DO;  /* WE HAVE TOO MANY POTENTIALLY COLLECTABLE STRINGS  */\n                  OUTPUT = '* * * NOTICE FROM COMPACTIFY:  DISASTROUS STRING OVE\nRFLOW.   JOB ABANDONED. * * *';\n                  CALL EXIT;\n               END;\n            DX(ND) = I;\n         END;\n   END;\n   /* SORT IN ASCENDING ORDER  */\n   K, L = ND;\n   DO WHILE K <= L;\n      L = -2;\n      DO I = 1 TO K;\n         L = I - 1;\n         IF (DESCRIPTOR(DX(L)) & MASK) > (DESCRIPTOR (DX(I)) & MASK) THEN\n            DO;\n               J = DX(L); DX(L) = DX(I); DX(I) = J;\n               K = L;\n            END;\n      END;\n   END;\n   /* MOVE THE ACTIVE STRINGS DOWN  */\n   FREEPOINT = LOWER_BOUND;\n   TC, DELTA = 0;\n   BC = 1;   /* SETUP INITIAL CONDITION  */\n   DO I = 0 TO ND;\n      J = DESCRIPTOR(DX(I));\n      IF (J & MASK) - 1 > TC THEN\n         DO;\n           IF DELTA > 0 THEN\n            DO K = BC TO TC;\n               COREBYTE(K-DELTA) = COREBYTE(K);\n            END;\n            FREEPOINT = FREEPOINT + TC - BC + 1;\n            BC = J & MASK;\n            DELTA = BC - FREEPOINT;\n         END;\n      DESCRIPTOR (DX(I)) = J - DELTA;\n      L = (J & MASK) + SHR(J, 24);\n      IF TC < L THEN TC = L;\n   END;\n   DO K = BC TO TC;\n      COREBYTE(K-DELTA) = COREBYTE(K);\n   END;\n   FREEPOINT = FREEPOINT + TC - BC + 1;\n   IF SHL(FREELIMIT-FREEPOINT, 4) < FREELIMIT-FREEBASE THEN\n      LOWER_BOUND = FREEBASE;\n   ELSE\n      DO;\n         LOWER_BOUND = FREEPOINT;\n         RETURN ;\n      END;\n   /* THE HOPE IS THAT WE WON'T HAVE TO COLLECT ALL THE STRINGS EVERY TIME */\n   END ;  /* OF THE DO TRIED LOOP       */\n   IF FREELIMIT-FREEPOINT < 256 THEN\n            DO;\n               OUTPUT = '* * * NOTICE FROM COMPACTIFY:  INSUFFICIENT STRING SPAC\nE  JOB ABANDONED. * * *';\n               CALL EXIT;    /* FORCE ABEND  */\n            END;\n\nEND COMPACTIFY;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE18": {"ttr": 14595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x02\\xcd\\x02\\xcd\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 717, "newlines": 717, "modlines": 0, "user": "SPASCAL"}, "text": "      'RETURN', 'DECLARE', 'INITIAL', '<NUMBER>', '<STRING>',\n      'CHARACTER', 'LITERALLY', 'PROCEDURE', '<IDENTIFIER>', '<TERM>',\n      '<TYPE>', '<GO TO>', '<GROUP>', '<ENDING>', '< START >',\n      '<PRIMARY>', '<PROGRAM>', '<REPLACE>', '<BIT HEAD>',\n      '<CONSTANT>', '<RELATION>', '<VARIABLE>', '<IF CLAUSE>',\n      '<LEFT PART>', '<STATEMENT>', '<TRUE PART>', '<ASSIGNMENT>',\n      '<BOUND HEAD>', '<EXPRESSION>', '<GROUP HEAD>', '<IF STATEMENT>',\n      '<INITIAL HEAD>', '<INITIAL LIST>', '<WHILE CLAUSE>',\n      '<CASE SELECTOR>', '<CALL STATEMENT>', '<LOGICAL FACTOR>',\n      '<PARAMETER HEAD>', '<PARAMETER LIST>', '<PROCEDURE HEAD>',\n      '<PROCEDURE NAME>', '<STATEMENT LIST>', '<SUBSCRIPT HEAD>',\n      '<BASIC STATEMENT>', '<GO TO STATEMENT>', '<IDENTIFIER LIST>',\n      '<LOGICAL PRIMARY>', '<STEP DEFINITION>', '<LABEL DEFINITION>',\n      '<RETURN STATEMENT>', '<TYPE DECLARATION>',\n      '<ITERATION CONTROL>', '<LOGICAL SECONDARY>',\n      '<STRING EXPRESSION>', '<DECLARATION ELEMENT>',\n      '<PROCEDURE DEFINITION>', '<ARITHMETIC EXPRESSION>',\n      '<DECLARATION STATEMENT>', '<IDENTIFIER SPECIFICATION>') ;\n   DECLARE VT_INDEX(13) BIT(8) INITIAL (0,  1, 16, 22, 26, 31, 34, 35,\n      37, 39, 42, 42, 42, 43) ;\n\n\n   /*  DECLARATIONS FOR THE SCANNER                                        */\n\n   /* TOKEN IS THE INDEX INTO THE VOCABULARY V() OF THE LAST SYMBOL SCANNED,\n      CP IS THE POINTER TO THE LAST CHARACTER SCANNED IN THE CARDIMAGE,\n      BCD IS THE LAST SYMBOL SCANNED (LITERAL CHARACTER STRING). */\n   DECLARE (TOKEN, CP) FIXED, BCD CHARACTER;\n\n   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */\n   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1) = PAGE',\n      PAGE CHARACTER INITIAL ('1'), DOUBLE CHARACTER INITIAL ('0'),\n      DOUBLE_SPACE LITERALLY 'OUTPUT(1) = DOUBLE',\n      X70 CHARACTER INITIAL ('\n                    ');\n\n   /* LENGTH OF LONGEST SYMBOL IN V */\n   DECLARE (RESERVED_LIMIT, MARGIN_CHOP) FIXED;\n\n   /* CHARTYPE() IS USED TO DISTINGUISH CLASSES OF SYMBOLS IN THE SCANNER.\n      TX() IS A TABLE USED FOR TRANSLATING FROM ONE CHARACTER SET TO ANOTHER.\n      CONTROL() HOLDS THE VALUE OF THE COMPILER CONTROL TOGGLES SET IN $ CARDS.\n      NOT_LETTER_OR_DIGIT() IS SIMILIAR TO CHARTYPE() BUT USED IN SCANNING\n      IDENTIFIERS ONLY.\n\n      ALL ARE USED BY THE SCANNER AND CONTROL() IS SET THERE.\n   */\n   DECLARE (CHARTYPE, TX) (255) BIT(8),\n           (CONTROL, NOT_LETTER_OR_DIGIT)(255) BIT(1);\n\n   /* ALPHABET CONSISTS OF THE SYMBOLS CONSIDERED ALPHABETIC IN BUILDING\n      IDENTIFIERS     */\n   DECLARE ALPHABET CHARACTER INITIAL ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_$@#');\n\n   /* BUFFER HOLDS THE LATEST CARDIMAGE,\n      TEXT HOLDS THE PRESENT STATE OF THE INPUT TEXT\n      (NOT INCLUDING THE PORTIONS DELETED BY THE SCANNER),\n      TEXT_LIMIT IS A CONVENIENT PLACE TO STORE THE POINTER TO THE END OF TEXT,\n      CARD_COUNT IS INCREMENTED BY ONE FOR EVERY SOURCE CARD READ,\n      ERROR_COUNT TABULATES THE ERRORS AS THEY ARE DETECTED,\n      SEVERE_ERRORS TABULATES THOSE ERRORS OF FATAL SIGNIFICANCE.\n   */\n   DECLARE (BUFFER, TEXT) CHARACTER,\n      (TEXT_LIMIT, CARD_COUNT, ERROR_COUNT, SEVERE_ERRORS, PREVIOUS_ERROR) FIXED\n      ;\n   DECLARE TOKENTYPE (NT) BIT(16);\n\n   /* NUMBER_VALUE CONTAINS THE NUMERIC VALUE OF THE LAST CONSTANT SCANNED,\n   */\n   DECLARE NUMBER_VALUE FIXED;\n\n   /* EACH OF THE FOLLOWING CONTAINS THE INDEX INTO V() OF THE CORRESPONDING\n      SYMBOL.   WE ASK:    IF TOKEN = IDENT    ETC.    */\n   DECLARE (IDENT, NUMBER, DIVIDE, EOFILE, STRING, ORSYMBOL, CATENATE) FIXED;\n\n   DECLARE S CHARACTER;  /* A TEMPORARY USED VARIOUS PLACES */\n\n\n   /*THE PROPER SUBSTRING OF POINTER IS USED TO PLACE AN  |  UNDER THE POINT\n      OF DETECTION OF AN ERROR DURING CHECKING.  IT MARKS THE LAST CHARACTER\n      SCANNED.  */\n   DECLARE POINTER CHARACTER INITIAL ('\n                                           |');\n\n   DECLARE END_MESSAGE CHARACTER INITIAL ('   ');\n\n\n   /* COMMONLY USED STRINGS */\n   DECLARE X1 CHARACTER INITIAL(' '), X4 CHARACTER INITIAL('    ');\n   DECLARE PERIOD CHARACTER INITIAL ('.');\n   DECLARE NT LITERALLY '42' ;\n   DECLARE V(92) CHARACTER INITIAL ( '< DUMMY >', '<', '(', '+', '|',\n      '&', '*', ')', ';', '\u00ac', '-', '/', ',', '>', ':', '=', '||',\n      'BY', 'DO', 'GO', 'IF', 'TO', 'BIT', 'END', 'EOF', 'MOD', 'CALL',\n      'CASE', 'ELSE', 'GOTO', 'THEN', 'FIXED', 'LABEL', 'WHILE',\n      DECLARE QUOTE CHARACTER INITIAL ('''');\n      DECLARE BITQUOTE CHARACTER INITIAL ('\"');\n      DECLARE STROKE   CHARACTER INITIAL ('|');\n\n   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';\n\n   DECLARE NULL LITERALLY '-1';\n   DECLARE MAXNEST LITERALLY '32';\n   DECLARE SYTSIZE LITERALLY '415';\n   DECLARE SY_LINK(SYTSIZE) BIT(16);\n   DECLARE N_PREDECLARED_SYMB FIXED INITIAL (28);\n   DECLARE SYT(SYTSIZE) CHARACTER INITIAL (\n      '', '', 'MONITOR_LINK', 'TIME_OF_GENERATION', 'DATE_OF_GENERATION',\n      'COREWORD','COREBYTE', 'FREEPOINT', 'DESCRIPTOR', 'NDESCRIPT', 'LENGTH',\n      'SUBSTR', 'BYTE', 'SHL', 'SHR', 'INPUT', 'OUTPUT', 'FILE', 'INLINE',\n      'TRACE', 'UNTRACE', 'EXIT', 'TIME', 'DATE', 'CLOCK_TRAP', 'INTERRUPT_TRAP'\n      , 'MONITOR', 'ADDR', 'COMPACTIFY', '', '');\n   DECLARE (PROCEDURE_NUMBER, LEX_LEVEL) FIXED;\n   DECLARE PROC_STACK (MAXNEST) BIT(16);\n   DECLARE (NDECSY, PROCMARK) FIXED;\n   DECLARE BUCKET (255) BIT(16);\n   DECLARE (STACKMARK, ENDCOUNT) (MAXNEST) BIT(16);\n   DECLARE LIST_SIZE LITERALLY '20000';\n   DECLARE (REF_LINK, LINE_#) (LIST_SIZE) BIT(16);\n   DECLARE NEXTREF FIXED INITIAL (0),\n            (MACRODEF, MACROEND, NOT_FOUND) BIT(1),\n            (REF_PTR, LAST_REF, OWNER) (SYTSIZE) BIT(16);\n   DECLARE COMPILING BIT(1);\n\n\n\n\n   /*               P R O C E D U R E S                                  */\n\n\n\nPAD:\n   PROCEDURE (STRING, WIDTH) CHARACTER;\n      DECLARE STRING CHARACTER, (WIDTH, L) FIXED;\n\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN STRING || SUBSTR(X70, 0, WIDTH-L);\n   END PAD;\n\nI_FORMAT:\n   PROCEDURE (NUMBER, WIDTH) CHARACTER;\n      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;\n\n      STRING = NUMBER;\n      L = LENGTH(STRING);\n      IF L >= WIDTH THEN RETURN STRING;\n      ELSE RETURN SUBSTR(X70, 0, WIDTH-L) || STRING;\n   END I_FORMAT;\n\nERROR:\n   PROCEDURE(MSG, SEVERITY);\n      /* PRINTS AND ACCOUNTS FOR ALL ERROR MESSAGES */\n      /* IF SEVERITY IS NOT SUPPLIED, 0 IS ASSUMED */\n      DECLARE MSG CHARACTER, SEVERITY FIXED;\n      ERROR_COUNT = ERROR_COUNT + 1;\n      /* IF LISTING IS SUPPRESSED, FORCE PRINTING OF THIS LINE */\n      IF \u00ac CONTROL(BYTE('L')) THEN\n         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|';\n      OUTPUT = SUBSTR(POINTER, TEXT_LIMIT-CP+MARGIN_CHOP);\n      OUTPUT = '*** ERROR, ' || MSG ||\n            '.  LAST PREVIOUS ERROR WAS DETECTED ON LINE ' ||\n            PREVIOUS_ERROR || '.  ***';\n      PREVIOUS_ERROR = CARD_COUNT;\n      IF SEVERITY > 0 THEN\n         IF SEVERE_ERRORS > 25 & \u00acCONTROL(BYTE('X')) THEN\n            DO;\n               OUTPUT = '*** TOO MANY SEVERE ERRORS, CHECKING ABORTED ***';\n               COMPILING = FALSE;\n            END;\n         ELSE SEVERE_ERRORS = SEVERE_ERRORS + 1;\n   END ERROR;\n\n\n\n\n\n  /*                   CARD IMAGE HANDLING PROCEDURE                      */\n\n\nGET_CARD:\n   PROCEDURE;\n      /* DOES ALL CARD READING AND LISTING                                 */\n      DECLARE I FIXED, (TEMP, TEMP0, REST) CHARACTER, READING BIT(1);\n BUFFER=INPUT;\n IF LENGTH(BUFFER)=0 THEN DO;\n      /* IN XCOM, CALL ERROR HERE */\n      COMPILING = FALSE;\n      S='';\n      DO I= 0 TO 1;\n           S=S || ' EOF';\n      END;\n      BUFFER=PAD(S,80);\n END;\n ELSE CARD_COUNT=CARD_COUNT +1;\n      IF MARGIN_CHOP > 0 THEN\n         DO; /* THE MARGIN CONTROL FROM DOLLAR | */\n            I = LENGTH(BUFFER) - MARGIN_CHOP;\n            REST = SUBSTR(BUFFER, I);\n            BUFFER = SUBSTR(BUFFER, 0, I);\n         END;\n      ELSE REST = '';\n      TEXT = BUFFER;\n      TEXT_LIMIT = LENGTH(TEXT) - 1;\n      IF CONTROL(BYTE('K')) THEN\n         OUTPUT = I_FORMAT (CARD_COUNT, 6) || ' |' || BUFFER || '|' || REST;\n      CP = 0;\n   END GET_CARD;\n\n\n   /*                THE SCANNER PROCEDURES              */\n\n\nCHAR:\n   PROCEDURE;\n      /* USED FOR STRINGS TO AVOID CARD BOUNDARY PROBLEMS */\n      CP = CP + 1;\n      IF CP <= TEXT_LIMIT THEN RETURN;\n      CALL GET_CARD;\n   END CHAR;\n\n\nSCAN:\n   PROCEDURE;\n      DECLARE I FIXED;\n      DECLARE (S1, S2) FIXED;\n      BCD = '';  NUMBER_VALUE = 0;\n   SCAN1:\n      DO FOREVER;\n         IF CP > TEXT_LIMIT THEN CALL GET_CARD;\n         ELSE\n            DO; /* DISCARD LAST SCANNED VALUE */\n               TEXT_LIMIT = TEXT_LIMIT - CP;\n               TEXT = SUBSTR(TEXT, CP);\n               CP = 0;\n            END;\n         /*  BRANCH ON NEXT CHARACTER IN TEXT                  */\n         DO CASE CHARTYPE(BYTE(TEXT));\n\n            /*  CASE 0  */\n\n            /* ILLEGAL CHARACTERS FALL HERE  */\n            CALL ERROR ('ILLEGAL CHARACTER: ' || SUBSTR(TEXT, 0, 1));\n\n            /*  CASE 1  */\n\n            /*  BLANK  */\n            DO;\n               CP = 1;\n               DO WHILE BYTE(TEXT, CP) = BYTE(' ') & CP <= TEXT_LIMIT;\n                  CP = CP + 1;\n               END;\n               CP = CP - 1;\n            END;\n\n            /*  CASE 2  */\n            /*  A '|' MAY BE ORSYMBOL OR CATENATE  */\n\n            DO;\n               CALL CHAR;\n               IF BYTE(TEXT,CP) = BYTE(STROKE) THEN DO;\n                  CALL CHAR;\n                  TOKEN = CATENATE;\n                  END;\n               ELSE TOKEN = ORSYMBOL;\n               RETURN;\n               END;\n\n            /*  CASE 3  */\n            /*  BIT STRING CONSTANT  */\n\n            DO;\n               TOKEN = STRING;\n               DO FOREVER;\n                  CALL CHAR;  /* TO SKIP PAST INITIAL BITQUOTE */\n                  DO WHILE BYTE(TEXT,CP) \u00ac= BYTE(BITQUOTE);\n                     CALL CHAR;\n                     END;\n                  CALL CHAR;  /* TO SKIP PAST THE TERMINAL BITQUOTE  */\n                  RETURN;\n                  END;\n               END;\n\n            /*  CASE 4  */\n\n            DO FOREVER;  /* A LETTER:  IDENTIFIERS AND RESERVED WORDS */\n               DO CP = CP + 1 TO TEXT_LIMIT;\n                  IF NOT_LETTER_OR_DIGIT(BYTE(TEXT, CP)) THEN\n                     DO;  /* END OF IDENTIFIER  */\n                        IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);\n                        S1 = LENGTH(BCD);\n                        IF S1 > 1 THEN IF S1 <= RESERVED_LIMIT THEN\n                           /* CHECK FOR RESERVED WORDS */\n                           DO I= VT_INDEX(S1) TO VT_INDEX(S1+1) -1;\n                              IF BCD = V(I) THEN\n                                 DO;\n                                    TOKEN = I;\n                                    RETURN;\n                                 END;\n                           END;\n                        /*  RESERVED WORDS EXIT HIGHER: THEREFORE <IDENTIFIER>*/\n                        TOKEN = IDENT;\n                        RETURN;\n                     END;\n               END;\n               /*  END OF CARD  */\n               BCD = BCD || TEXT;\n               CALL GET_CARD;\n               CP = -1;\n            END;\n\n            /*  CASE 5  */\n\n            DO;      /*  DIGIT:  A NUMBER  */\n               TOKEN = NUMBER;\n               DO FOREVER;\n                  DO CP = CP TO TEXT_LIMIT;\n                     S1 = BYTE(TEXT, CP);\n                     IF S1 < \"F0\" THEN RETURN;\n                  END;\n                  CALL GET_CARD;\n               END;\n            END;\n\n            /*  CASE 6  */\n\n            DO;      /*  A /:  MAY BE DIVIDE OR START OF COMMENT  */\n               CALL CHAR;\n               IF BYTE(TEXT, CP) \u00ac= BYTE('*') THEN\n                  DO;\n                     TOKEN = DIVIDE;\n                     RETURN;\n                  END;\n               /* WE HAVE A COMMENT  */\n               S1, S2 = BYTE(' ');\n               DO WHILE S1 \u00ac= BYTE('*') | S2 \u00ac= BYTE('/');\n                  IF S1 = BYTE('$') THEN\n                     DO;  /* A CONTROL CHARACTER  */\n                        CONTROL(S2) = \u00acCONTROL(S2);\n                        IF S2 = BYTE('|') THEN\n                           IF CONTROL(S2) THEN\n                              MARGIN_CHOP = TEXT_LIMIT - CP + 1;\n                           ELSE\n                              MARGIN_CHOP = 0;\n                     END;\n                  S1 = S2;\n                  CALL CHAR;\n                  S2 = BYTE(TEXT, CP);\n               END;\n            END;\n\n            /*  CASE 7  */\n            DO;      /*  SPECIAL CHARACTERS  */\n               TOKEN = TX(BYTE(TEXT));\n               CP = 1;\n               RETURN;\n            END;\n\n            /*  CASE 8 --  A STRING QUOTE  */\n\n            DO FOREVER;\n               CALL CHAR;  /* SKIP OVER THE INITIAL QUOTE */\n               IF MACRODEF THEN DO;\n                  MACRODEF = FALSE;\n                  MACROEND = TRUE;\n                  TOKEN = 0;\n                  RETURN;\n                  END;\n               ELSE IF MACROEND THEN\n                  IF BYTE(TEXT,CP) \u00ac= BYTE(QUOTE) THEN DO;\n                     MACROEND = FALSE;\n                     CALL CHAR;\n                     TOKEN = STRING;\n                     RETURN;\n                     END;\n               DO WHILE BYTE (TEXT, CP) \u00ac= BYTE (QUOTE);\n                  BCD = BCD || SUBSTR (TEXT, CP, 1);\n                  CALL CHAR;\n               END;\n               CALL CHAR;  /* SKIP OVER THE TERMINAL QUOTE */\n               TOKEN = STRING;\n               IF BYTE (TEXT, CP) \u00ac= BYTE (QUOTE) THEN RETURN;\n            END;\n\n         END;     /* OF CASE ON CHARTYPE  */\n         CP = CP + 1;  /* ADVANCE SCANNER AND RESUME SEARCH FOR TOKEN  */\n      END;\n   END SCAN;\n\n\n\n\n   /*  H A S H   A D D R E S S E D   S Y M B O L   T A B L E   L O O K U P  */\n\n\n   NULLOUT:\n      PROCEDURE (MAXINDEX);\n         DECLARE(I, MAXINDEX) FIXED;\n         DO I = 0 TO 255;\n            IF BUCKET(I) >= MAXINDEX THEN\n               BUCKET(I) = NULL;\n            END;\n         DO I = 1 TO MAXINDEX - 1;\n            IF SY_LINK(I) >= MAXINDEX THEN\n               SY_LINK(I) = NULL;\n            END;\n      END NULLOUT;\n\n   ID_LOOKUP:\n      PROCEDURE;\n         DECLARE    (I, L, SY_PTR) FIXED;\n         NOT_FOUND = FALSE;\n         L = LEX_LEVEL;\n         I = LENGTH(BCD) - 1;\n         I = BYTE(BCD, I) + BYTE(BCD) + I;\n         DO WHILE L >= 0;\n            SY_PTR = BUCKET((I + PROC_STACK(L)) & \"FF\");\n            DO WHILE SY_PTR \u00ac= NULL;\n               IF SYT(SY_PTR) = BCD THEN DO;\n                  /*  FOUND IDENTIFIER */\n                  REF_LINK(LAST_REF(SY_PTR)) = NEXTREF;\n                  LINE_#(NEXTREF) = CARD_COUNT;\n                  LAST_REF(SY_PTR) = NEXTREF;\n                  NEXTREF = NEXTREF + 1;\n                  RETURN;\n                  END;\n               SY_PTR = SY_LINK(SY_PTR);\n               END;\n            L = L - 1;\n            END;\n         NOT_FOUND = TRUE;\n      END ID_LOOKUP;\n\n   ENTER:\n      PROCEDURE (SYMB, LINE);\n         DECLARE    (J, K,       LINE) FIXED,\n                    I BIT(16);\n         DECLARE SYMB CHARACTER, SY_PTR FIXED;\n         I = LENGTH(SYMB) - 1;\n         I = (BYTE(SYMB, I) + BYTE(SYMB) + I + PROC_STACK(LEX_LEVEL)) & \"FF\";\n         SY_PTR = BUCKET(I);\n         IF SY_PTR \u00ac= NULL THEN DO;\nSEARCH_SOMEMORE:  /* DO UNTIL SY_LINK(SY_PTR) = NULL */\n            IF SY_LINK(SY_PTR) \u00ac= NULL THEN DO;\n               SY_PTR = SY_LINK(SY_PTR);\n               GOTO SEARCH_SOMEMORE;\n               END;\n            NDECSY, SY_PTR, SY_LINK(SY_PTR) = NDECSY + 1;\n            END;\n         ELSE\n            NDECSY, SY_PTR, BUCKET(I) = NDECSY + 1;\n         SYT(SY_PTR) = SYMB;\n            LAST_REF(SY_PTR), REF_PTR(SY_PTR) = NEXTREF;\n            LINE_#(NEXTREF) = LINE;\n            NEXTREF = NEXTREF + 1;\n            OWNER(SY_PTR) = PROC_STACK(LEX_LEVEL);\n         RETURN SY_PTR;\n      END ENTER;\n  /*  $P  */\n\nSY_DUMP:\n   PROCEDURE;\n   DECLARE(I, P, SY_LISTHEAD) FIXED,\n          (REF_MESSAGE, DECL_MESSAGE) CHARACTER;\n\n\n   DUMP_LIST:  PROCEDURE (LIST_PTR);\n      DECLARE LIST_PTR BIT(16);\n      DECLARE (LINE, NUMERAL) CHARACTER;\n\n      LINE = SUBSTR(X70, 0, 40);\n      DO WHILE LIST_PTR \u00ac= NULL;\n         NUMERAL = LINE_#(LIST_PTR);\n         IF LENGTH(LINE) + LENGTH(NUMERAL) > 120 THEN DO;\n            OUTPUT = LINE;\n            LINE = SUBSTR(X70, 0, 40);\n            END;\n         LINE = LINE || NUMERAL || X1;\n         LIST_PTR = REF_LINK(LIST_PTR);\n         END;\n      IF LENGTH(LINE) > 40 THEN OUTPUT = LINE;\n   END DUMP_LIST;\n\n\n   SORT_SYMBOLS:\n      PROCEDURE;\n         DECLARE I BIT(16);\n\n         INSERT: PROCEDURE;\n            DECLARE PTR BIT(16);\n            IF SYT(I) < SYT(SY_LISTHEAD) THEN DO;\n               SY_LINK(I) = SY_LISTHEAD;\n               SY_LISTHEAD = I;\n               RETURN;\n               END;\n\n            PTR = SY_LISTHEAD;\n            DO WHILE SY_LINK(PTR) \u00ac= NULL;\n               IF SYT(I) < SYT(SY_LINK(PTR)) THEN DO;\n                  SY_LINK(I) = SY_LINK(PTR);\n                  SY_LINK(PTR) = I;\n                  RETURN;\n                  END;\n               PTR = SY_LINK(PTR);\n               END;\n\n            SY_LINK(PTR) = I;\n         END INSERT;\n\n         SY_LISTHEAD = NULL;\n         DO I = PROCMARK TO NDECSY;\n            IF LENGTH(SYT(I)) > 0 THEN DO;\n               SYT(I) = PAD(SYT(I), 32);\n               SY_LINK(I) = NULL;\n               IF SY_LISTHEAD = NULL THEN\n                  SY_LISTHEAD = I;\n               ELSE CALL INSERT;\n               END;\n            END;\n      END SORT_SYMBOLS;\n\n\n   EJECT_PAGE;\n   IF LEX_LEVEL > 1 THEN\n      OUTPUT = SUBSTR(X70, 0, 32) ||\n               'X P L   CROSS-REFERENCE TABLE FOR LOCAL IDENTIFIERS OF PROCEDURE\n ' || SYT(PROCMARK - 1);\n   ELSE DO;\n      PROCMARK = 2;\n      OUTPUT = SUBSTR(X70, 0, 32) ||\n               'X P L   CROSS-REFERENCE TABLE OF GLOBAL IDENTIFIERS';\n      IF \u00acCONTROL(BYTE('K')) THEN\n         OUTPUT = SUBSTR(X70, 0, 40) ||\n                   'FOR A PROGRAM LISTING, INCLUDE A /* $K */ COMMENT WITH THE\nSOURCE DECK';\n      IF \u00acCONTROL(BYTE('P')) THEN OUTPUT = SUBSTR(X70, 0, 40) ||\n         'TO OBTAIN CROSS-REFERENCE TABLES OF LOCAL VARIABLES OF PROCEDURES,' ||\n         ' INCLUDE /* $P */';\n      OUTPUT = END_MESSAGE;\n      END;\n         DOUBLE_SPACE;\n         OUTPUT =        '     SYMBOL TABLE CONTENTS'; DOUBLE_SPACE;\n   DOUBLE_SPACE;\n   CALL SORT_SYMBOLS;\n   DO WHILE SY_LISTHEAD \u00ac= NULL;\n      IF LINE_#(REF_PTR(SY_LISTHEAD)) > 0 THEN\n         DECL_MESSAGE = ' DECLARED ON LINE ' || LINE_#(REF_PTR(SY_LISTHEAD));\n      ELSE DECL_MESSAGE = ' PREDECLARED';\n      P = REF_LINK(REF_PTR(SY_LISTHEAD));\n      IF P = NULL THEN REF_MESSAGE = ' AND NEVER REFERENCED';\n      ELSE REF_MESSAGE = ' AND REFERENCED ON LINES';\n      OUTPUT = SYT(SY_LISTHEAD) || DECL_MESSAGE || REF_MESSAGE;\n      CALL DUMP_LIST(P);\n      SY_LISTHEAD = SY_LINK(SY_LISTHEAD);\n      END;\n   DOUBLE_SPACE;  DOUBLE_SPACE;\n   END SY_DUMP;\n   /*  $P  */\n\n\n\n  /*                       INITIALIZATION                                     */\n\n\n\n\nINITIALIZATION:\n   PROCEDURE;\n         DECLARE (I, J) FIXED, T CHARACTER;\n      DO I = 0 TO NT;         /* ONLY NEED 1 TO NT, EXCEPT IN THIS EXAMPLE*/\n         S = V(I);\n         IF S = '<NUMBER>' THEN NUMBER = I;  ELSE\n         IF S = '<IDENTIFIER>' THEN DO;\n            IDENT = I;\n            TOKENTYPE(I) = 1;\n            END;\n         IF S = '/' THEN DIVIDE = I;  ELSE\n         IF S = 'EOF' THEN EOFILE = I;  ELSE\n         IF S = '<STRING>' THEN STRING = I; ELSE\n         IF S = '|' THEN ORSYMBOL = I; ELSE\n         IF S = '||' THEN CATENATE = I; ELSE\n         IF S = 'PROCEDURE' THEN TOKENTYPE(I) = 2; ELSE\n         IF S = 'DO' THEN TOKENTYPE(I) = 3; ELSE\n         IF S = 'END' THEN TOKENTYPE(I) = 4; ELSE\n         IF S = 'LITERALLY' THEN TOKENTYPE(I) = 5; ELSE\n         ;\n      END;\n      IF IDENT = NT THEN RESERVED_LIMIT = LENGTH(V(NT-1));\n      ELSE RESERVED_LIMIT = LENGTH(V(NT));\n      CHARTYPE(BYTE(' ')) = 1;\n      CHARTYPE(BYTE(QUOTE)) = 8;\n      CHARTYPE(BYTE(BITQUOTE)) = 3;\n      DO I = 0 TO 255;\n         NOT_LETTER_OR_DIGIT(I) = TRUE;\n      END;\n      DO I = 0 TO LENGTH(ALPHABET) - 1;\n         J = BYTE(ALPHABET, I);\n         TX(J) = I;\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 4;\n      END;\n      DO I = 0 TO 9;\n         J = BYTE('0123456789', I);\n         NOT_LETTER_OR_DIGIT(J) = FALSE;\n         CHARTYPE(J) = 5;\n      END;\n      DO I = VT_INDEX(1) TO VT_INDEX(2) -1;\n         J = BYTE(V(I));\n         TX(J) = I;\n         CHARTYPE(J) = 7;\n      END;\n      CHARTYPE(BYTE('/')) = 6;\n      CHARTYPE(BYTE(STROKE)) = 2;\n\n         DO I = 0 TO 255;\n            BUCKET(I) = NULL;\n            END;\n         DO I = 0 TO SYTSIZE;\n            SY_LINK(I) = NULL;\n            REF_PTR(I), LAST_REF(I) = NULL;\n            END;\n         DO I = 0 TO 20000;\n            REF_LINK(I) = NULL;\n            END;\n      LEX_LEVEL, PROCEDURE_NUMBER = 1;\n         DO NDECSY = 2 TO N_PREDECLARED_SYMB;\n            REF_PTR(NDECSY), LAST_REF(NDECSY) = NEXTREF;\n            NEXTREF = NEXTREF + 1;\n            T = SYT(NDECSY);\n            I = LENGTH(T) -1;\n            I = (BYTE(T, I) + BYTE(T) + I) & \"FF\";\n            IF BUCKET(I) = NULL THEN BUCKET(I) = NDECSY;\n            ELSE DO;\n               I = BUCKET(I);\n               DO WHILE SY_LINK(I) \u00ac= NULL;\n                  I = SY_LINK(I);\n                  END;\n               SY_LINK(I) = NDECSY;\n               END;\n         END;\n         NDECSY = N_PREDECLARED_SYMB;\n         PROCMARK = NDECSY + 1;\n\n      /* FIRST SET UP GLOBAL VARIABLES CONTROLLING SCAN, THEN CALL IT */\n      CP=0;  TEXT_LIMIT= -1;\n      TEXT='';\n      CALL SCAN;\n      COMPILING = TRUE;  /* YOU CAN ABORT COMPILATION BY SETTING FALSE */\n   END INITIALIZATION;\n\n\n\n\n   BUILD_CROSS_REF_TABLE: PROCEDURE;\n      DECLARE I FIXED;\n      DO WHILE COMPILING;\n         DO CASE TOKENTYPE(TOKEN);\n\n            /*  CASE 0 -- NOT AN IDENTIFIER  */\n               ;\n\n            /*  CASE 1 -- IDENTIFIER  */\n            DO;\n               CALL ID_LOOKUP;\n               IF NOT_FOUND THEN\n                  CALL ENTER (BCD, CARD_COUNT);\n               END;\n\n            /*  CASE 2 -- 'PROCEDURE'  */\n            DO;\n               STACKMARK(LEX_LEVEL) = PROCMARK;\n               LEX_LEVEL = LEX_LEVEL + 1;\n               PROCEDURE_NUMBER, PROC_STACK(LEX_LEVEL) = PROCEDURE_NUMBER + 1;\n               ENDCOUNT(LEX_LEVEL) = 0;\n               PROCMARK = NDECSY + 1;\n               END;\n\n            /*  CASE 3 -- 'DO'  */\n            ENDCOUNT(LEX_LEVEL) = ENDCOUNT(LEX_LEVEL) + 1;\n\n            /*  CASE 4 -- 'END'  */\n            IF ENDCOUNT(LEX_LEVEL) = 0 THEN DO;\n               IF CONTROL(BYTE('P')) THEN\n                  CALL SY_DUMP;\n               IF LEX_LEVEL > 0 THEN\n                  LEX_LEVEL = LEX_LEVEL - 1;\n               CALL NULLOUT(PROCMARK);\n               DO I = PROCMARK TO NDECSY;\n                  OWNER(I) = 0;\n                  SYT(I) = X1;  SY_LINK(I) = NULL;\n                  REF_PTR(I), LAST_REF(I) = NULL;\n                  END;\n               NDECSY = PROCMARK - 1;\n               PROCMARK = STACKMARK(LEX_LEVEL);\n               END;\n            ELSE\n               ENDCOUNT(LEX_LEVEL) = ENDCOUNT(LEX_LEVEL) - 1;\n\n            /*  CASE 5 -- 'LITERALLY'  */\n            MACRODEF = TRUE;\n\n            END;\n         CALL SCAN;\n         END;\n   END BUILD_CROSS_REF_TABLE;\n\n\nCONTROL_PROGRAM:\n   CALL INITIALIZATION;  /* WHICH MAKES AN INITIAL CALL TO SCAN */\n   CALL BUILD_CROSS_REF_TABLE;\n   IF LEX_LEVEL > 1 THEN DO;\n      END_MESSAGE = END_MESSAGE || 'TABLE MAY INCLUDE SOME EXTRANEOUS LOCAL IDEN\nTIFIERS BECAUSE OF ONE OR MORE MISSING ''END'' SYMBOLS';\n      LEX_LEVEL = 1;\n      END;\n   CALL SY_DUMP;\nEOF EOF EOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE19": {"ttr": 14853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x00\\xa3\\x00\\xa3\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "SPASCAL"}, "text": "EDIT:\nDECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';\n   DECLARE INFINITY LITERALLY '99999';\n   DECLARE CC CHARACTER INITIAL ('*');\n   DECLARE LEFT_MARGIN CHARACTER INITIAL ('    |'),\n           RIGHT_MARGIN CHARACTER INITIAL ('|');\n   DECLARE EDITING BIT(1) INITIAL (1),\n           (DELETING, INSERTING) BIT(1),\n           PUNCHING BIT(1) INITIAL(1),\n           LISTING BIT(1);\n   DECLARE NEXT_DELETE FIXED INITIAL (INFINITY),\n           (CONTROL_CARD, BUFFER) CHARACTER;\n   DECLARE (I, LINE_COUNT, LAST_DELETE) FIXED,\n           RECORD_COUNT FIXED INITIAL (1),\n           CP FIXED INITIAL (80),\n           CARD_END FIXED INITIAL (79);\n   DECLARE CHARTYPE (255) BIT(8);\n   CHARTYPE(BYTE('$')) = 1;\n   DECLARE IS_NUMERAL (255) BIT(1);\n   DO I = 240 TO 249;\n      IS_NUMERAL(I) = TRUE;\n      CHARTYPE(I) = 2;\n      END;\n\nI_FORMAT:\n   PROCEDURE (NUMBER_VALUE, WIDTH) CHARACTER;\n      DECLARE (NUMBER_VALUE, WIDTH) FIXED;\n      DECLARE S CHARACTER;\n      S = NUMBER_VALUE;\n      IF LENGTH(S) < WIDTH THEN\n         S = SUBSTR('                                    ', 0,\n               WIDTH - LENGTH(S)) || S;\n      ELSE IF LENGTH(S) > WIDTH THEN\n         S = SUBSTR('************************************', 0, WIDTH);\n      RETURN S;\n   END I_FORMAT;\n\nCARD_IMAGE_OUTPUT:\n   PROCEDURE (CARDIMAGE);\n      DECLARE CARDIMAGE CHARACTER;\n      LINE_COUNT = LINE_COUNT + 1;\n      IF PUNCHING THEN OUTPUT(2) = CARDIMAGE;\n      IF LISTING THEN OUTPUT(3)=I_FORMAT(LINE_COUNT, 6) || LEFT_MARGIN\n            || CARDIMAGE || RIGHT_MARGIN;\n   END CARD_IMAGE_OUTPUT;\n\nGET_CONTROL_CARD:\n   PROCEDURE;\n      CONTROL_CARD = INPUT;\n      IF LENGTH(CONTROL_CARD) = 0 THEN DO;\n         EDITING = FALSE;\n         RETURN;\n         END;\n      OUTPUT = CONTROL_CARD;\n      DO WHILE EDITING & (BYTE(CONTROL_CARD) \u00ac= BYTE(CC));\n         IF INSERTING THEN\n            CALL CARD_IMAGE_OUTPUT (CONTROL_CARD);\n         CONTROL_CARD = INPUT;\n         IF LENGTH(CONTROL_CARD) = 0 THEN DO;\n            EDITING = FALSE;\n            NEXT_DELETE = INFINITY;\n            END;\n         ELSE OUTPUT = CONTROL_CARD;\n         END;\n      INSERTING = FALSE;\n      CP = 0;  CARD_END = 79;\n   END GET_CONTROL_CARD;\n\nCONVERT_NUMERAL:\n   PROCEDURE FIXED;\n      DECLARE N FIXED;\n      N = BYTE(CONTROL_CARD, CP) - 240;  CP = CP + 1;\n      DO WHILE CP <= CARD_END & IS_NUMERAL(BYTE(CONTROL_CARD, CP));\n         N = N*10 +(BYTE(CONTROL_CARD, CP) - 240);\n         CP = CP + 1;\n         END;\n      RETURN N;\n   END CONVERT_NUMERAL;\n\nSCAN_CONTROL_CARD:\n   PROCEDURE;\n      DO FOREVER;\n         NEXT_DELETE = 0;\n         IF CP > CARD_END THEN CALL GET_CONTROL_CARD;\n         IF \u00ac EDITING THEN DO;\n            NEXT_DELETE = INFINITY;\n            RETURN;\n            END;\n         DO WHILE CP <= CARD_END & BYTE(CONTROL_CARD, CP) = BYTE(' ');\n            CP = CP + 1;\n            END;\n         IF CP < CARD_END THEN\n            DO CASE CHARTYPE (BYTE(CONTROL_CARD,  CP));\n\n               /*  CASE 0 -- NO ACT&ON  */\n               CP = CP + 1;\n\n               /*  CASE 1 -- A TOGGLE */\n               DO;\n                  CP = CP + 1;\n                  IF BYTE(CONTROL_CARD, CP) = BYTE('I') THEN DO;\n                     INSERTING = TRUE;\n                     CALL GET_CONTROL_CARD;\n                     END;\n                  ELSE IF BYTE(CONTROL_CARD, CP) = BYTE(CC) THEN DO;\n                     CP = CP + 1;\n                     IF BYTE(CONTROL_CARD, CP) \u00ac= BYTE(' ') THEN\n                        CC = SUBSTR(CONTROL_CARD, CP, 1);\n                     END;\n                  ELSE IF BYTE(CONTROL_CARD, CP) = BYTE('L') THEN\n                     LISTING = \u00acLISTING;\n                  ELSE IF BYTE(CONTROL_CARD, CP) = BYTE('P') THEN\n                     PUNCHING = \u00acPUNCHING;\n                  ELSE IF BYTE(CONTROL_CARD, CP) = BYTE('D') THEN\n                     DELETING = \u00acDELETING;\n                  END;\n\n               /*  CASE 2 -- A NUMERAL */\n               DO;\n                  NEXT_DELETE = CONVERT_NUMERAL;\n                  IF CP < CARD_END THEN DO;\n                     IF BYTE(CONTROL_CARD, CP) = BYTE('.') THEN DO;\n                        CP = CP + 1;\n                        IF BYTE(CONTROL_CARD, CP) = BYTE('.') THEN CP = CP + 1;\n                        LAST_DELETE = CONVERT_NUMERAL;\n                        END;\n                     END;\n                  IF LAST_DELETE < NEXT_DELETE THEN LAST_DELETE = NEXT_DELETE;\n                  RETURN;\n                  END;\n               END;  /* OF CASE ON CHARTYPE */\n            END; /* OF DO FOREVER LOOP */\n      END SCAN_CONTROL_CARD;\n\nEDIT_FILE:  PROCEDURE;\n   OUTPUT(1) = '1';  /* PAGE THROW */\n   OUTPUT = '*****   E D I T O R   C O N T R O L   F I L E   *****';\n   OUTPUT(1) = '0';  /* SPACE  */\n   DO FOREVER;\n      CALL SCAN_CONTROL_CARD;\n      DO WHILE RECORD_COUNT < NEXT_DELETE;\n         BUFFER = INPUT(2);\n         IF LENGTH(BUFFER) > 0 THEN DO;\n            RECORD_COUNT = RECORD_COUNT + 1;\n            CALL CARD_IMAGE_OUTPUT(BUFFER);\n            END;\n         ELSE RETURN;\n         END;\n      DO WHILE RECORD_COUNT <= LAST_DELETE;\n         BUFFER = INPUT(2);\n         IF LENGTH(BUFFER) > 0 THEN  DO;\n            RECORD_COUNT = RECORD_COUNT + 1;\n            IF \u00acDELETING THEN CALL CARD_IMAGE_OUTPUT(BUFFER);\n            END;\n         ELSE RETURN;\n         END;\n      NEXT_DELETE = INFINITY;\n      END;  /* OF DO FOREVER LOOP */\n   END EDIT_FILE;\n\nCALL EDIT_FILE;\n\nEOF EOF EOF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILE20": {"ttr": 14857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x01\\xe5\\x01\\xe5\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 485, "newlines": 485, "modlines": 0, "user": "SPASCAL"}, "text": "*  $D  449..450  $D  $I\n      \"85\", \"3F\", \"04\", \"02\", \"3F\", \"04\", \"01\", \"04\", \"01\", \"79\", \"02\", \"9C\",\n      \"79\", \"05\", \"01\", \"5F\", \"85\", \"3F\", \"04\", \"03\", \"7D\", \"3F\", \"05\", \"05\",\n*  $D 473  $D  $I\n   DECLARE EQUIVALENT(NT) FIXED INITIAL(0,0,5,0,18,2,0,19,20,0,0,0,0,0,0,0,0,0,\n*   $D   485   $D   $I\n  DECLARE CASE_LIST BIT(16) INITIAL(91);\n  DECLARE CASE_LIST_2 BIT(16) INITIAL(115);\n*   $D   552   $D   $I\n            RPARENT, EQUALSIGN, RBRACKET) BIT(16);\n*   $D   556   $D   $I\n           ERROR_PROD LITERALLY '213';\n*     $D  571  $D $I\n      0, 0, 0, 192, 25, 5, 23, 183, 0, 0, 15, 17, 16, 0, 0, 0, 0,\n*     $D  631  $D $I\n           (CURRENT_LEVEL, PROC_LEVEL) FIXED;\n*     $D  638  $D $I\n   DECLARE STACKSIZE LITERALLY '75',\n           FORESTSIZE LITERALLY '200';\n*     $D  650  $D $I\n           SUBTREE_STACK(FORESTSIZE) BIT(16),\n*   $D   659   $D   $I\n   DECLARE TABLE_LENGTH LITERALLY '725';\n*     $D  735  $D $I\n   DECLARE (IS_FORWARD_DECL, IS_SCALAR_TYPE_DEFN) BIT(1);\n*     750  $I\n           DEFN_LABEL  BIT(16) INITIAL (11),\n*   815   $I\n   /* #_PRODS IS THE NUMBER OF PRODUCTIONS IN THE INTERNAL GRAMMAR */\n   DECLARE #_PRODS LITERALLY '81';\n\n   /* LEFT HAND SIDES IN INTERNAL FORM OF GRAMMAR */\n   DECLARE LEFT_PART(#_PRODS) CHARACTER INITIAL('', '<PROGRAM>', '<BLOCK>',\n      '<STATEMENT LIST>', '<LABEL DECL>', '<CONST DECL>', '<TYPE DEFN>',\n      '<PROC DECL LIST>', '<PROC DECL>', '<PROC DECL>', '<BODY>',\n      '<VAR DECL LIST>', '<VAR DECL>', '<STATEMENT>', '<STATEMENT>',\n      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',\n      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',\n      '<FORMAL PARAM>', '<FORMAL PARAM>', '<FORMAL PARAM>', '<CASE INSTANCE>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',\n      '<EXPRESSION>', '<EXPRESSION>', '<VARIABLE>', '<VARIABLE>', '<QUALIFIER>',\n      '<QUALIFIER>', '<QUALIFIER>', '<QUALIFIER>', '<CONSTANT>', '<CONSTANT>',\n      '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>',\n      '<TYPE>', '<FIXED FIELD LIST>', '<VARIANT FIELD>', '<VARIANT INSTANCE>',\n      '<STATEMENT>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<ELEMENT>',\n      '<ELEMENT>', '<PARAM TYPES>', '<PARAM TYPES>', '<PARAM TYPES>',\n      '<PARAM TYPES>', '<ERROR>');\n\n*     $D 839 $D $I\n      DECLARE TP FIXED INITIAL (0);\n*     $D 843 $D $I\n      IF TEXT_LIMIT \u00ac= TP | CARD_COUNT \u00ac= PREVIOUS_ERROR THEN DO;\n*     $D 849 $D $I\n      TP = TEXT_LIMIT;\n*   $D   857   $D   $I\n         ELSE\n            DO;\n               SEVERE_ERRORS = SEVERE_ERRORS + 1;\n               MONITOR_LINK(2) = 0;   /* DEBUG LEVEL <--- 0 */\n            END;\n*   894   $I\nUNDERLYING_TYPE:\n   PROCEDURE (TP) BIT(16);\n      DECLARE TP BIT(16);\n      DO WHILE TP > #_PREDECLARED & DATATYPE(TP) \u00ac= TP;\n         TP = DATATYPE(TP);\n         END;\n      RETURN TP;\n   END UNDERLYING_TYPE;\n\n*   $D   898..900   $D   $I\n      DECLARE NSP BIT(16);\n      IS_NO_CYCLE:\n         /* CHECKS FOR POSSIBLE CYCLIC DATATYPE CHAINS */\n         PROCEDURE (T1, T2) BIT(1);\n            DECLARE (T1, T2) BIT(16);\n            DO WHILE T2 > #_PREDECLARED & DATATYPE(T2) \u00ac= T2;\n               T2 = DATATYPE(T2);\n               IF T1 = T2 THEN RETURN FALSE;\n               END;\n            RETURN TRUE;\n         END IS_NO_CYCLE;\n\n         NSP = NODE_STACKSIZE;\n         DO WHILE IS_ARRAY_OR_FILE_TYPE(NSP);\n            NSP = NSP - 1;\n*   $D   902   $D   $I\n         IF \u00acIS_DECLARATION_NODE(NSP) THEN RETURN;\n*   914   $I\n                  IF IS_NO_CYCLE (ID_PTR, LAST_LITERAL_SCANNED) THEN\n*   915   $I\n                  ELSE CALL ERROR ('CYCLIC TYPE DECLARATION', 1);\n*   $D   919   $D   $I\n         ELSE DO SP = SUBTREE_INDEX(NSP) TO SUBTREE_STACKSIZE;\n*   $D   1307   $D\n*   $D   1321   $D   $I\n          DGNS#_GOTO = DGNS#_STACK2(DGNS#_DEPTH+1) & (DGNS#_TOP1 \u00ac= OF$);\n*   1348   $I\n          IF DGNS#_TOP1 = OF$ THEN DGNS#_PTR = FALSE; /* SET BY NEXT CASELABEL*/\n*   $D   1453..1454   $D   $I\n                  TEXT = V(EOFILE) || '(*''(**)/**/' || V(EOFILE);\n*   1689   $I\n               IF LENGTH(BCD) + CP > 256 THEN\n                  DO;\n                     CALL ERROR(LSTRNGM, 1);\n                     RETURN;\n                  END;\n*   1871   $I\n                  TEXT_LIMIT = LENGTH(TEXT) - 1;\n*   1924   $I\n                  TEXT_LIMIT = LENGTH(TEXT) - 1;\n*   1935   $I\n            /* CASE 13 -- LEFT BRACKET */\n            DO;\n               TOKEN = LBRACKET;\n               CP = CP + 1;\n               RETURN;\n            END;\n\n            /* CASE 14 -- RIGHT BRACKET */\n            DO;\n               TOKEN = RBRACKET;\n               CP = CP + 1;\n               RETURN;\n            END;\n\n*   2007   $I\n      RBRACKET = LOCATE_INDEX('.)');\n*   2054   $I\n      CHARTYPE(\"AD\") = 13;   /* LBRACKET */\n      CHARTYPE(\"BD\") = 14;   /* RBRACKET */\n*     2130  $I\n         OUTPUT = SUBSTR(X70, 0, 34) || 'RELEASE 1, UPDATE 4';\n*     2221  $I\n      /* CHECK FOR UNDEFINED LABELS  */\n      DO I = #_PREDECLARED + 1 TO N_DECL_SYMB;\n         IF (VAR_TYPE(I) = LABLE) & (N_LOOKUPS(I) > 0) THEN\n            CALL ERROR (IDENTITY(I) || ' DECLARED ON LINE ' ||\n                        WHERE_DECL(I) || ' IS AN UNDEFINED LABEL', 1);\n         END;\n\n*   2245   $I\n      I = FIRST_LITERAL;\n      DO WHILE I \u00ac= NULL;\n         I, VALUE(I) = SYMB_LINK(I);\n      END;\n*     $D  2257  $D $I\n            'UNDEFINE', 'UNDF LAB', '        ', 'LABEL   ', 'VARIANT ',\n*   2305   $I\nPARSE_TREE_DUMP:\n   PROCEDURE (TREE);\n      DECLARE A(127) BIT(16);   /* AUXILIARY STACK; CF KNUTH V.1 P.317 */\n      DECLARE TREE BIT(16);   /* POINTER TO ROOT */\n      DECLARE (TOP_OF_A,M,C,P) BIT(16);\n      DECLARE LEAF LITERALLY 'PARSE_TREE(P+1)',\n              MULTIPLICITY LITERALLY 'PARSE_TREE',\n              PRODUCTION_NUMB LITERALLY 'PARSE_TREE(P+1)',\n              LINE_NUMB LITERALLY 'PARSE_TREE(P+M+2)';\n      DECLARE MARGIN CHARACTER;\n      DECLARE INDENTATION BIT(16), (S1, S2) CHARACTER;\n      DECLARE OVERFLOW_MESSAGE CHARACTER INITIAL(\n         '*** AUXILIARY STACK OVERFLOW, PARSE TREE DUMP ABORTED');\n      MARGIN = X70 || X70 || '|';\n      INDENTATION = LENGTH(MARGIN) - 2;\n      TOP_OF_A = 0;\n      P = TREE;\n      OUTPUT = 'PARSE_TREE AT THIS POINT IS:';\n      DO FOREVER;\n         IF P = NULL THEN\n            DO;\n               M = 0;\n               S1 = '... EMPTY PRODUCTION ...';\n            END;\n         ELSE\n            DO;\n               M = MULTIPLICITY(P);\n               IF M = 0 THEN\n                  DO;\n                     IF LEAF < N_ANONYMOUS_SYMB THEN\n                        S1 = IDENTITY(LEAF);\n                     ELSE IF (DATATYPE(LEAF)=INTPTR) | (DATATYPE(LEAF)=REALPTR)\n                        THEN S1 = VALUE(LEAF);\n                     ELSE\n                        DO;\n                           S1 = ' ';\n                           BYTE(S1) = VALUE(LEAF) & \"FF\";\n                        END;\n                  END;\n               ELSE S1 = PRODUCTION_NUMB || X1 || LEFT_PART(PRODUCTION_NUMB);\n            END;\n         S2 = SUBSTR(MARGIN,INDENTATION) || X1 || S1;\n         IF LENGTH(S2) < 57 THEN S2 = S2 || X70;\n         IF LENGTH(S2) < 127 THEN S2 = S2 || SUBSTR(X70,0,127 - LENGTH(S2));\n         S1 = I_FORMAT(LINE_NUMB,4);\n         IF P = NULL THEN S1 = '';\n         OUTPUT = S2 || '|' || S1;\n         IF M > 0 THEN\n            DO;\n               A(TOP_OF_A) = 0;\n               TOP_OF_A = TOP_OF_A + 1;\n               IF TOP_OF_A > 127 THEN\n                  DO;\n                     OUTPUT = OVERFLOW_MESSAGE;\n                     RETURN;\n                  END;\n            END;\n         DO C = - 1 TO M - 3;   /* STACK SUBTREES RIGHT TO LEFT */\n            A(TOP_OF_A) = PARSE_TREE(P + M - C);\n            TOP_OF_A = TOP_OF_A + 1;\n            IF TOP_OF_A > 127 THEN\n               DO;\n                  OUTPUT = OVERFLOW_MESSAGE;\n                  RETURN;\n               END;\n         END;\n         IF M = 0 THEN\n            DO;   /* UNSTACK SUBTREE */\n               IF TOP_OF_A = 0 THEN RETURN;\n               TOP_OF_A = TOP_OF_A - 1;\n               P = A(TOP_OF_A);\n               DO WHILE P = 0;\n                  IF TOP_OF_A = 0 THEN RETURN;\n                  INDENTATION = INDENTATION + 3;\n                  TOP_OF_A = TOP_OF_A - 1;\n                  P = A(TOP_OF_A);\n               END;\n            END;\n         ELSE\n            DO;    /* PREPARE TO DUMP LEFTMOST SUBTREE */\n               P = PARSE_TREE(P + 2);\n               INDENTATION = INDENTATION - 3;\n            END;\n      END;\n   END PARSE_TREE_DUMP;\n\n*   $D   2352..2361   $D\n*   $D   2377..2382   $D\n*     $D  2408  $D $I\n         IF VAR_TYPE(ID_PTR) = FORWARD THEN  DO;\n*     2409 $I\n            PROCMARK(CURRENT_LEVEL) = N_DECL_SYMB;\n            END;\n*   $D   2410   $D   $I\n         ELSE BLOCK_STACK(CURRENT_LEVEL) = VALUE(UNDERLYING_TYPE(ID_PTR));\n*   2426   $I\n        IF CONTROL(BYTE('Z')) THEN\n*     $D  2529  $D $I\n      DECLARE ENTER_LEVEL BIT(16);\n      ENTER_LEVEL = CURRENT_LEVEL;\n      IF IS_DECLARATION THEN\n         IF IS_SCALAR_TYPE_DEFN THEN\n            DEPTH, ENTER_LEVEL = PROC_LEVEL;\n         ELSE DEPTH = CURRENT_LEVEL;\n*     $D  2532  $D $I\n      IF IS_SCALAR_TYPE_DEFN THEN L = ENTER_LEVEL; ELSE L = CURRENT_LEVEL;\n*     $D  2537  $D $I\n               N_LOOKUPS(INDEX) = N_LOOKUPS(INDEX) + 1;\n*     $D  2555  $D $I\n      INDEX = ENTER_SYMBOL (ID, ENTER_LEVEL);\n*     $D  2576 2577  $D $I\n            IF VAR_TYPE(INDEX) \u00ac= LABLE & VAR_TYPE(INDEX) \u00ac= DEFN_LABEL THEN DO;\n               CALL ERROR ('UNDECLARED LABEL ' || ID, 0);\n               VAR_TYPE(INDEX)= LABLE;\n              END;\n*   $D   2619..2620   $D   $I\n   IF I = 0 THEN J = NULL;\n   ELSE\n      DO;\n         J = GET_NODE(I);\n         PARSE_TREE(J + 1) = NODE_STACK(NODE_STACKSIZE);\n      END;\n*   $D   2632   $D\n*   2635   $I\nBUILD_ERROR_TREE:\n   PROCEDURE;\n      /* FORCE AN ERROR SUBTREE ONTO THE SUBTREE STACK */\n      CALL STACK_NODE(ERROR_NODE);\n      SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n      SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n      CALL UNSTACK;\n   END BUILD_ERROR_TREE;\n\n*   $D   2642   $D   $I\n            IF VAR_TYPE(UNDERLYING_TYPE(LAST_LITERAL_SCANNED)) = RECORD THEN\n*   2667   $I\n      IF CONTROL(BYTE('P')) THEN\n         CALL PARSE_TREE_DUMP(SUBTREE_STACK(SUBTREE_STACKSIZE));\n*   2681   $I\n      DECLARE FI FIXED INITIAL (241), IFF FIXED INITIAL (17);\n*   2682   $I\n      DECLARE TYPE_ID_MARKER BIT(16);\n*   2808   $I\n               TYPE_ID_MARKER = N_DECL_SYMB;\n*   2821   $I\n               DO I = TYPE_ID_MARKER TO N_DECL_SYMB - 1;\n                  IF VAR_TYPE(I) = UNDEFINED THEN\n                     DO;\n                        CALL ERROR(IDENTITY(I) || ' IS AN UNDECLARED TYPE', 0);\n                        VAR_TYPE(I) = TYPE;\n                     END;\n               END;\n*     $D  2895  $D $I\n            IS_DECLARATION, IS_SCALAR_TYPE_DEFN = FALSE;\n*     2907  $I\n               VARTYPECODE = UNDEFINED;\n*     $D  2909 2910 $D $I\n               IF VAR_TYPE(LAST_LITERAL_SCANNED) \u00ac= LABLE THEN\n                  IF VAR_TYPE(LAST_LITERAL_SCANNED) = UNDEFINED THEN\n                     CALL ERROR ('UNDECLARED LABEL ' || BCD, 0);\n                  ELSE CALL ERROR ('DUPLICATE DEFINITION OF ' || BCD, 1);\n               VAR_TYPE(LAST_LITERAL_SCANNED) = DEFN_LABEL;\n*   $D   2936   $D   $I\n            CALL STACK_NODE(FI);\n*   $D   3024   $D   $I\n            IF IS_PROC_CALL THEN\n               IS_PROC_CALL = FALSE;\n            ELSE\n               DO;   /* WE PREDICTED AN ASSIGNMENT */\n                  NODE_STACKSIZE = NODE_STACKSIZE - 1;\n                  NODE_STACK(NODE_STACKSIZE) = 15;   /* PROC CALL */\n               END;\n*   $D   3034..3041   $D   $I\n ELSE_PART: DO;\n               DO WHILE (NODE_STACK(NODE_STACKSIZE) \u00ac= FI)\n                        & (NODE_STACKSIZE > 0);\n                     CALL UNSTACK;\n                  END;\n               NODE_STACK(NODE_STACKSIZE) = IFF;\n            END;\n*   $D   3044   $D   $I\n            GOTO ELSE_PART;\n*     3063  $I\n               IF VAR_TYPE(LAST_LITERAL_SCANNED) = FORWARD THEN\n                  CALL ERROR(IDENTITY(LAST_LITERAL_SCANNED) ||\n' IS FORWARD DECLARED. REPETITION OF ITS PARAMETER LIST IS NOT ALLOWED', 1);\n*   $D   3135..3139   $D   $I\n               DO WHILE (NODE_STACK(NODE_STACKSIZE) \u00ac= 28)\n                        & (NODE_STACKSIZE > 0);\n                  CALL UNSTACK;\n*   $D   3151..3155   $D   $I\n               DO WHILE (NODE_STACK(NODE_STACKSIZE) \u00ac= 28)\n                        & (NODE_STACKSIZE > 0);\n                  CALL UNSTACK;\n*     3221  $I\n               PROC_LEVEL = CURRENT_LEVEL;\n      RPT:     I = VAR_TYPE(SYMB_BLOCK_OWNER(PROC_LEVEL));\n               IF (I \u00ac= PROC) & (I \u00ac= FORWARD) THEN DO;\n                  IF PROC_LEVEL > 1 THEN PROC_LEVEL = PROC_LEVEL - 1;\n                  IS_SCALAR_TYPE_DEFN = TRUE;\n                  GOTO RPT;\n                  END;\n*   $D   3499..3501   $D   $I\n               IF NODE_STACK(NODE_STACKSIZE) \u00ac= LPARENT THEN\n                  CALL UNSTACK;\n               ELSE\n                  NODE_STACKSIZE = NODE_STACKSIZE - 1;\n*   $D   3604   $D\n*   $D   3773   $D   $I\n      CALL BUILD_ERROR_TREE;\n*   $D   3775   $D   $I\n      CALL BUILD_ERROR_TREE;\n*   $D   3777   $D   $I\n      CALL BUILD_ERROR_TREE;\n*   $D   3779   $D   $I\n      CALL BUILD_ERROR_TREE;\n*   $D   3783   $D   $I\n      CALL BUILD_ERROR_TREE;\n*   $D   3785   $D   $I\n      CALL BUILD_ERROR_TREE;\n*   $D   3787   $D   $I\n      CALL BUILD_ERROR_TREE;\n*   $D   3799   $D   $I\n      DO;\n         CALL STACK_NODE(FI);\n         CALL BUILD_ERROR_TREE;\n      END;\n*   $D   3801..3806   $D   $I\n      CALL BUILD_ERROR_TREE;\n*     $D  3862  $D $I\n            IF SUBTREE_STACKSIZE >= FORESTSIZE THEN\n*     $D  3964..3971  $D $I\n\n      J = -1;\n*     3979  $I\n            IF T = RIGHT_PAREN THEN RIGHT_PAREN_OK = TRUE;\n*     $D  3997  $D  4005  $I\n      #_EXPECTED_TOKENS = J + 1;\n      IF #_EXPECTED_TOKENS = 1 THEN TOKEN_EXPECTED = TOKENS_OUT;\n*     $D 4046..4053  $D $I\n IS_EXPECTED:  PROCEDURE (T, S) BIT(1);\n      DECLARE (T, S, I, STACK_TOKEN) BIT(16);\n      DO FOREVER;\n         STACK_TOKEN = PARSE_STACK(S);\n         IF STACK_TOKEN <= NT THEN RETURN (STACK_TOKEN = T);\n         /* ELSE INSPECT THE TERMINAL HEADS OF STACK_TOKEN */\n         DO I = TERMINAL_HEADS_INDEX(STACK_TOKEN - NT1)\n                TO TERMINAL_HEADS_INDEX(STACK_TOKEN - NT1+ 1) - 1;\n            IF TERMINAL_HEADS(I) = T THEN RETURN TRUE;\n            END;\n         IF PRODUCES_EMPTY(STACK_TOKEN - NT1) THEN S = S - 1;\n         ELSE RETURN FALSE;\n         END;\n*     $D  4074  $D $I\n       DO WHILE COMPILING &\n                \u00ac(IS_CATCH_SYMBOL(TOKEN) | IS_EXPECTED(TOKEN, SP));\n*     4076  $I\n       IF \u00acIS_EXPECTED(SEMI_COLON, SP) THEN\n*     $D 4131 $D $I\n           IF IS_EXPECTED (TOKEN, SP) THEN RETURN;\n*     $D  4139  $D $I\n               CALL SYNTHESIZE (PR#(PARSE_STACK(SP) - NT1));\n*     $D  4141  $D $I\n               OUTPUT = '*** PRODUCTION #  ' || PR#(PARSE_STACK(SP)- NT1) ||\n*     $D  4173  $D $I\n       OUTPUT = '***        TOKEN SUPPLIED IS   ' || V(I) || '   ***';\n*     $D 4185 $D $I\n       IF IS_EXPECTED (EQUIVALENT(TOKEN), SP) THEN DO;\n*     $D   4198 4199   $D   $I\n             OUTPUT = '***        PROBABLE MISSPELLING OF A KEYWORD.  TOKEN ASSU\nMED TO BE ' || V(TOKEN) || '   ***';\n*     $D 4209 $D $I\n       IF IS_EXPECTED (TOKEN, SP-1) THEN DO;\n*     $D  4212  $D $I\n           ELSE CALL SYNTHESIZE (PR#(PARSE_STACK(SP) - NT1));\n*     $D  4220 4221  $D $I\n               OUTPUT = '***        A SEMICOLON CANNOT PRECEDE ''ELSE''   ***';\n*   $D   4223..4224   $D   $I\n           IF STACKTOP = CASE_LIST THEN DO;\n               CALL STACK_NODE(28);   /* CASE INSTANCE */\n               CALL BUILD_ERROR_TREE;   /* FOR CASE LABEL */\n               PARSE_STACK(SP) = CASE_LIST_2;\n               SP = SP + 1;\n               PARSE_STACK(SP) = STATEMENT;\n           END;\n           CALL GET_TOKEN;\n*     $D  4257  $D $I\n       /* IF SOFT_RECOVER FAILS ... */\n       CALL STACK_NODE (ERROR_NODE);\n       SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;\n       SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;\n*     $D  4259  $D $I\n       CALL UNSTACK;\n       IF IS_EXPECTED (TOKEN, SP) THEN RETURN;\n*     $D  4292  4293  $D $I\n               CALL ERROR ('ONE OF THE FOLLOWING SYMBOLS WAS EXPECTED:', 0);\n               CALL DIAGNOSE_ERROR;\n*   4297   $I\n   /*\n*   4307   $I\n      CALL INLINE(\"58\",2,0,STACKTOP);            /* L    2,STACKTOP        */\n      CALL INLINE(\"5B\",2,0,NT1);                 /* S    2,NT1             */\n      CALL INLINE(\"41\",3,0,2,1);                 /* LA   3,1(0,2)          */\n      CALL INLINE(\"8D\",2,0,0,1);                 /* SLDL 2,1               */\n      CALL INLINE(\"48\",1,2,ENTRIES);             /* LH   1,ENTRIES(2)      */\n      CALL INLINE(\"48\",2,3,ENTRIES);             /* LH   2,ENTRIES(3)      */\n      CALL INLINE(\"06\",2,0);                     /* BCTR 2,0               */\n      CALL INLINE(\"58\",0,0,TOKEN);               /* L    0,TOKEN           */\n      CALL INLINE(\"1B\",3,3);                     /* SR   3,3               */\n      CALL INLINE(\"05\",12,0);                    /* BALR 12,0              */\n      CALL INLINE(\"19\",1,2);                     /* CR   1,2               */\n      CALL INLINE(\"47\",2,0,12,66);               /* BH   66(0,12)          */\n      CALL INLINE(\"43\",3,1,INIT);                /* IC   3,INIT(1)         */\n      CALL INLINE(\"19\",0,3);                     /* CR   0,3               */\n      CALL INLINE(\"47\",4,0,12,66);               /* BL   66(0,12)          */\n      CALL INLINE(\"43\",3,1,FIN);                 /* IC   3,FIN(1)          */\n      CALL INLINE(\"19\",0,3);                     /* CR   0,3               */\n      CALL INLINE(\"47\",2,0,12,60);               /* BH   60(0,12)          */\n      CALL INLINE(\"18\",2,0);                     /* LR   2,0               */\n      CALL INLINE(\"43\",3,1,INIT);                /* IC   3,INIT(1)         */\n      CALL INLINE(\"1B\",2,3);                     /* SR   2,3               */\n      CALL INLINE(\"1A\",1,1);                     /* AR   1,1               */\n      CALL INLINE(\"4A\",2,1,PTR);                 /* AH   2,PTR(1)          */\n      CALL INLINE(\"43\",3,2,PROD_#);              /* IC   3,PROD_#(2)       */\n      CALL INLINE(\"50\",3,0,PRODUCTION_NUMBER);   /* ST   3,PRODUCTION_NUMBER */\n      CALL INLINE(\"41\",3,0,0,1);                 /* LA   3,1               */\n      CALL INLINE(\"42\",3,0,FOUND_PROD);          /* STC  3,FOUND_PROD      */\n      CALL INLINE(\"47\",15,0,12,66);              /* B    66(0,12)          */\n      CALL INLINE(\"41\",1,0,1,1);                 /* LA   1,1(0,1)          */\n      CALL INLINE(\"07\",15,12);                   /* BR   12                */\n*\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE21": {"ttr": 15109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x02\\x1c\\x02\\x1c\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 540, "newlines": 540, "modlines": 0, "user": "SPASCAL"}, "text": "*   $D   32..36   $D\n*   $D   39   $D   $I\n   DECLARE TABLE_LENGTH LITERALLY '725';\n*   $D   68..69   $D\n*   $D   74   $D\n*   $D   145..146   $D   $I\n   DECLARE TRIPLES(3599) BIT(16);                 /* SMALL-CORE VERSION */\n\n   /* THE PARSE TREE */\n   DECLARE PARSE_TREE(7200) BIT(16);\n   DECLARE MULTIPLICITY LITERALLY 'PARSE_TREE';\n   DECLARE TREE_SIZE FIXED;\n*   163   $I\n   /* LAST_TRIPLE IS SET EQUAL TO (N_TRIPLES - 3) | MASK_TRIPLE THROUGHOUT\n      COMPILATION. */\n   DECLARE LAST_TRIPLE BIT(16);\n\n*   $D   182   $D   $I\n      0, 3,3,10,3,3, 3,0,3,3,4, 3,3,0,6,7, 0,7,7,1,1, 7,7,0,0,0, 0,0,0,0,0,\n*   $D   184   $D   $I\n      0,0,5,0,5, 2,0,0,0,0, 5,0,5,2,7, 7,0,0,12,0, 13);\n*   $D   224..235   $D\n*   $D   245   $D   $I\n   DECLARE WITH_PTR BIT(16) INITIAL (NUL);\n*   $D   269..279   $D   $I\n   DECLARE STATEMENT      LITERALLY '0',\n           SCALAR         LITERALLY '1',\n           SUBRANGE       LITERALLY '2',\n           POINTER        LITERALLY '3',\n           ARRAY          LITERALLY '4',\n           PACKED_ARRAY   LITERALLY '5',\n           FILE           LITERALLY '6',\n           PACKED_FILE    LITERALLY '7',\n           RECORD         LITERALLY '8',\n           PACKED_RECORD  LITERALLY '9',\n           STANDARD       LITERALLY '10',\n*   $D   492   $D   $I\n         ELSE IF FIELDWIDTH > LENGTH(XTEMP) THEN\n            LINE = LINE || SUBSTR(X70, 0, FIELDWIDTH - LENGTH(XTEMP));\n*   $D   510..511   $D\n*   $D   524   $D   $I\n  ST LENGTH   S_LIST      VALUE  PSEUDO_REG    DISP';\n*   $D   531..614   $D\n*   $D   892   $D   $I\n      /* IN SMALL-CORE VERSION, TRIPLES OVERLAPS WITH PARSE_TREE */\n      IF N_TRIPLES + 3*(NEW_LINE_TRIPLE + 1) > 3600 + NODE THEN\n*   910   $I\n      LAST_TRIPLE = N_TRIPLES | MASK_TRIPLE;\n*   1003   $I\n      IF SEVERE_ERRORS + MONITOR_LINK(3) > 0 THEN RETURN;\n*   $D   1022   $D   $I\n               DO I = 1 TO (STORAGE_LNGTH(DATA_PTR) + INDEX - 1)/80;\n*   1062   $I\n      DO I = INTFIELDSIZEPTR TO DECIMAL_PLACESPTR;\n         /* THESE VARIABLES DO NOT APPEAR IN DUMP */\n         VAR_TYPE(I) = LITERAL;\n      END;\n*   $D   1067   $D   $I\n            PSEUDO_REG(I) = NULL;\n*   $D   1075   $D   $I\n                        DATATYPE(I) = PSEUDO_REG(DATATYPE(I));\n*   $D   1080   $D   $I\n                  RELOCATION_INDEX, PSEUDO_REG(I) = RELOCATION_INDEX + 1;\n*   $D   1083   $D   $I\n            ELSE PSEUDO_REG(I) = NULL;\n*   $D   1094   $D   $I\n                        DATATYPE(I) = PSEUDO_REG(DATATYPE(DATATYPE(I)));\n*   $D   1105   $D   $I\n                                 DATATYPE(I) = PSEUDO_REG(CHARPTR);\n*   $D   1107   $D   $I\n                        ELSE DATATYPE(I) = PSEUDO_REG(DATATYPE(I));\n*   $D   1111   $D   $I\n                  RELOCATION_INDEX, PSEUDO_REG(I) = RELOCATION_INDEX + 1;\n*   $D   1121   $D   $I\n            ELSE PSEUDO_REG(I) = NULL;\n*   $D   1128   $D   $I\n                  RELOCATION_INDEX, PSEUDO_REG(I), DATATYPE(I) =\n*   $D   1131   $D   $I\n            ELSE PSEUDO_REG(I) = NULL;\n*   $D   1137   $D   $I\n                  RELOCATION_INDEX, PSEUDO_REG(I) = RELOCATION_INDEX + 1;\n*   $D   1143   $D   $I\n                        DATATYPE(I) = PSEUDO_REG(DATATYPE(I));\n*   $D   1147   $D   $I\n            ELSE PSEUDO_REG(I) = NULL;\n*   $D   1150   $D   $I\n      DATATYPE(FALSEPTR), DATATYPE(TRUEPTR) = PSEUDO_REG(BOOLPTR);\n*   $D   1154   $D   $I\n         IF PSEUDO_REG(I) \u00ac= NULL THEN\n*   $D   1194..1204   $D\n*   $D   1238..1239   $D   $I\n      ELSE CALL ERROR('SYMBOL TABLE OVERFLOW', 1);\n*   1324   $I\n      HIGHBOUND = HIGHBOUND & (STORAGE_LNGTH(TYPE) \u00ac= MAXINT);\n*   $D   1331   $D   $I\n            OPND, OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1338   $D   $I\n                                LAST_TRIPLE, 0);\n*   $D   1340   $D   $I\n                                   LAST_TRIPLE, 0);\n*   $D   1347   $D   $I\n                             LAST_TRIPLE, 0);\n*   $D   1387   $D   $I\n                        ELSE IF LOW1 \u00ac= 0 THEN\n*   $D   1390..1392   $D   $I\n                                 FINDCONST(LOW1), 3);\n                              OPND2, OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1394..1399   $D\n*   $D   1436   $D   $I\n                        OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1456   $D   $I\n                  OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1474   $D   $I\n                  OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1503   $D   $I\n            CALL EMIT_TRIPLE(MOVE, LAST_TRIPLE, OPND2, 0);\n*   $D   1521   $D   $I\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   1525   $I\n            ELSE IF ACTUAL = EMPTYSETPTR THEN\n               DO;\n                  CALL EMIT_TRIPLE(TEMP, NULL, 0, STORAGE_LNGTH(FORMAL) - 1);\n                  ACTUAL, OPERAND#STK(#OP) = LAST_TRIPLE;\n                  CALL EMIT_TRIPLE(XOR, ACTUAL | MASK_TEMP, ACTUAL | MASK_TEMP,\n                                   0);\n               END;\n*   $D   1538   $D   $I\n                        OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1555   $D   $I\n                  OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1577   $D   $I\n                  OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1605..1606   $D   $I\n                  OPND1, OPERAND#STK(#OP - 1) = LAST_TRIPLE;\n*   $D   1617..1618   $D   $I\n                  OPND2, OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1667   $D   $I\n                  I = LAST_TRIPLE | MASK_TEMP;\n*   $D   1671..1672   $D   $I\n                  CALL EMIT_TRIPLE(MOVE, LAST_TRIPLE, OPND1, 0);\n*   $D   1691   $D   $I\n            OPERAND#STK(#OP - 1) = LAST_TRIPLE;\n*   $D   1697   $D   $I\n            OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1715   $D   $I\n            OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   1732..1733   $D   $I\n            IF STORAGE_LNGTH(TYPE_PTR) > 32768 THEN SL = 4;\n            ELSE IF STORAGE_LNGTH(TYPE_PTR) <= 256 THEN SL = 1;\n*   1803   $I\n      HALFWORD_DISP(LEVEL) = 0;\n*   $D   1806..1843   $D\n*   1872   $I\n      DECLARE ERROR_EXIT LABEL;\n*   $D   1916   $D   $I\n               OPERAND#STK(#OP - 1) = LAST_TRIPLE;\n*   $D   1923   $D   $I\n               CALL EMIT_TRIPLE(AND, LAST_TRIPLE | MASK_TEMP, OPND2, 0);\n*   $D   1927   $D   $I\n               CALL EMIT_TRIPLE(OPCD, LISTHEAD, LAST_TRIPLE, 0);\n*   $D   1929   $D   $I\n               OPERAND#STK(#OP - 1) = LAST_TRIPLE;\n*   1962   $I\n         IF MONITOR_LINK(3) + SEVERE_ERRORS > 0 THEN RETURN;\n*   $D   1991   $D   $I\n         OPERAND#STK(#OP) = LAST_TRIPLE;\n*   2013   $I\n         #TP = PARSE_TREE(NODE#STACK(NP) + 2);\n*   $D   2047   $D   $I\n                     OPERAND#STK(#OP - 1) = LAST_TRIPLE;\n*   $D   2104   $D   $I\n            CALL EMIT_TRIPLE(BNZ, LISTHEAD, LAST_TRIPLE, 0);\n*   $D   2106..2107   $D   $I\n            CALL EMIT_TRIPLE(BNZ, LISTHEAD, LAST_TRIPLE, 0);\n         ELSE CALL EMIT_TRIPLE(BZ, LISTHEAD, LAST_TRIPLE, 0);\n*   $D   2110   $D   $I\n         OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2121   $D   $I\n         CALL EMIT_TRIPLE(BNZ, LISTHEAD, LAST_TRIPLE, 0);\n*   $D   2231..2232   $D   $I\n                                 CALL EMIT_TRIPLE(TPOP, LAST_TRIPLE, NULL, 0);\n*   $D   2235   $D   $I\n                           ELSE OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2246   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2255..2256   $D   $I\n                     ELSE OPERAND#STK(#OP) = LAST_TRIPLE;\n                     CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE,\n*   $D   2263..2264   $D\n*   $D   2303..2304   $D   $I\n                                 CALL EMIT_TRIPLE(TPOP, LAST_TRIPLE, NULL, 0);\n*   $D   2310   $D   $I\n                                 OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2328   $D   $I\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2341   $D   $I\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2346   $D   $I\n                     CALL EMIT_TRIPLE(ODD, OPERAND#STK(#OP), NULL, 3);\n*   $D   2349   $D   $I\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2358   $D   $I\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2394   $D   $I\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2401..2403   $D   $I\n                     CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE, NULL,\n                                      MONITOR_CODE(ID_PTR));\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2416   $D   $I\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2435..2437   $D   $I\n                     CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE, NULL,\n                                      MONITOR_CODE(ID_PTR));\n                     OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2447   $D   $I\n                     CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE,\n*   $D   2479..2480   $D   $I\n                        CALL EMIT_TRIPLE(STORE, TABLE_PTR, LAST_TRIPLE, 0);\n*   $D   2520   $D   $I\n                        CALL EMIT_TRIPLE(INDEX, LAST_TRIPLE,\n*   $D   2534   $D   $I\n                        I = LAST_TRIPLE;\n*   $D   2609   $D   $I\n                              FIX_LIST(NP) = LAST_TRIPLE;\n*   2618   $I\n                              ELSE #OP = #OP - 1;\n*   $D   2625   $D   $I\n                              FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   2653   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2691   $D   $I\n                              FIX_LIST(NP) = LAST_TRIPLE;\n*   2700   $I\n                              ELSE #OP = #OP - 1;\n*   $D   2707   $D   $I\n                              FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   2741   $D   $I\n                                 CALL EMIT_TRIPLE(ADD, LAST_TRIPLE,\n*   $D   2743   $D   $I\n                                 TABLE_PTR = LAST_TRIPLE;\n*   $D   2835   $D   $I\n                           LAST_TRIPLE, 0);\n*   $D   2843   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   2846   $D   $I\n                        OPERAND#STK(#OP) = LAST_TRIPLE;\n*   2891   $I\n   IS_RECOVERY_PRODUCTION:\n      PROCEDURE (PROD#) BIT(1);\n         DECLARE PROD# BIT(16);\n         IF (PROD# < 0) | (PROD# > 11) THEN RETURN FALSE;\n         RETURN (SHL(1,PROD#) & \"(1)1 11100 01111 0\") \u00ac= 0;\n      END IS_RECOVERY_PRODUCTION;\n\n*   $D   2900   $D   $I\n               IF NODE = NULL THEN\n                  DO;\n                     FIRST_VISIT = FALSE;\n                     TABLE_PTR = NULL;\n                  END;\n*   $D   2931   $D   $I\n                              FIX_LIST(NP + 1) = LAST_TRIPLE;\n*   3028   $I\n                           IS_DECLARATION = FALSE;\n*   3057   $I\n                        /* CASE 13 -- ERROR PRODUCTION */\n                        DO;\n                           DO WHILE \u00acIS_RECOVERY_PRODUCTION(FATHERS_PROD_NO);\n                              CALL FATHER;\n                           END;\n                           CALL RIGHT_BRO;\n                           GOTO ERROR_EXIT;\n                        END;\n*   $D   3060   $D   $I\n      ERROR_EXIT: END;\n*   $D   3135..3136   $D   $I\n                           DO;   /* <CONSTANT> IS A STRING */\n                              STRUCTYPE(ID_PTR) = ARRAY;\n                              STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);\n                           END;\n*   $D   3175   $D   $I\n                              STACK_LIMIT(CURRENT_LEVEL) =\n                                 STORAGE_LNGTH(TABLE_PTR);\n                              ARRAYS_ALLOCATED(CURRENT_LEVEL),\n                                 HALFWORD_DISP(CURRENT_LEVEL) = 0;\n*   $D   3199..3201   $D   $I\n                              STORAGE_LNGTH(TABLE_PTR) =\n                                 STACK_LIMIT(CURRENT_LEVEL);\n*   $D   3231..3232   $D   $I\n                              STORAGE_LNGTH(OWNER_STACK(CURRENT_LEVEL)) =\n                                 STACK_LIMIT(CURRENT_LEVEL);\n*   3239   $I\n                     IF CURRENT_LEVEL < 1 THEN RETURN;\n*   $D   3249   $D   $I\n                           IF SEVERE_ERRORS + MONITOR_LINK(3) = 0 THEN\n                              CALL WRITE_TRIPLES;\n*   $D   3342   $D   $I\n                              LISTHEAD = LAST_TRIPLE;\n*   $D   3348   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   3363   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   3367   $D   $I\n                        CALL FIXUP(LISTHEAD, LAST_TRIPLE);\n*   $D   3404   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   3406   $D   $I\n                        IF FATHERS_MULTIPLICITY = 1 THEN\n                           DO;   /* EMPTY CASE LIST */\n                              CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP), NULL, 0);\n                              #OP = #OP - 1;\n                           END;\n                        ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN\n*   $D   3412..3413   $D   $I\n                                    OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   3420..3421   $D   $I\n                                       LAST_TRIPLE, 0);\n                                    FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   3428..3429   $D   $I\n                                       LAST_TRIPLE, 0);\n                                    FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   3439..3440   $D   $I\n                                    OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   3444..3445   $D   $I\n                                       LAST_TRIPLE, 0);\n                                    FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   3453..3454   $D   $I\n                                       LAST_TRIPLE, 0);\n                                    FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   3458..3469   $D   $I\n                        IF FATHERS_MULTIPLICITY > 1 THEN\n                           DO;\n                              TABLE_PTR = NEXT_FREE_ROW;\n                              DATATYPE(TABLE_PTR) = DATATYPE(#TP);\n                              STRUCTYPE(TABLE_PTR) = SUBRANGE;\n                              VAR_TYPE(TABLE_PTR) = TYPE;\n                              VALUE(TABLE_PTR) = MAX;\n                              STORAGE_LNGTH(TABLE_PTR) = MAX - MIN + 1;\n                              CALL EMIT_TRIPLE(CASE_JUMP, OPERAND#STK(#OP),\n                                               TABLE_PTR, 0);\n                              OPERAND#STK(#OP) = (N_TRIPLES - 3);\n                              DO I = MIN TO MAX;\n                                 CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);\n                              END;\n                           END;\n*   $D   3474   $D   $I\n                        FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   3494   $D   $I\n                              CALL FIXUP(LISTHEAD, LAST_TRIPLE);\n*   $D   3498   $D   $I\n                        CALL FIXUP(FIX_LIST(NP), LAST_TRIPLE);\n*   $D   3514   $D   $I\n                              LISTHEAD = LAST_TRIPLE;\n*   $D   3520   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   3545   $D   $I\n                              LISTHEAD = LAST_TRIPLE;\n*   $D   3619   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE | MASK_TEMP;\n*   $D   3637..3638   $D   $I\n                                                   LAST_TRIPLE, NULL, 3);\n*   $D   3653   $D   $I\n                                                   LAST_TRIPLE,\n*   $D   3657..3658   $D   $I\n                                                LAST_TRIPLE, NULL, 3);\n*   $D   3675..3676   $D   $I\n                                                   LAST_TRIPLE, NULL, 3);\n*   $D   3687   $D   $I\n                                                   LAST_TRIPLE,\n*   $D   3690..3691   $D   $I\n                                                   LAST_TRIPLE, NULL, 3);\n*   $D   3702..3703   $D   $I\n                                                   LAST_TRIPLE, NULL, 3);\n*   $D   3707   $D   $I\n                              OPERAND#STK(#OP - 1) = LAST_TRIPLE | MASK_TEMP;\n*   $D   3716   $D   $I\n                                 LAST_TRIPLE, 0);\n*   $D   3762   $D   $I\n                                 LAST_TRIPLE | MASK_TEMP;\n*   $D   3902   $D   $I\n                              CASE_PTR = LAST_TRIPLE;\n*   $D   3944..3945   $D   $I\n                                 OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   3964..3965   $D   $I\n                                 OPERAND#STK(#OP) = LAST_TRIPLE;\n*   3981   $I\n                           LAST_TRIPLE = (N_TRIPLES - 3) | MASK_TRIPLE;\n*   $D   3996..3997   $D   $I\n                                 OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4003   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4082   $D   $I\n                              ID_PTR = LAST_TRIPLE;\n*   $D   4090..4091   $D   $I\n                              CALL EMIT_TRIPLE(BNZ, LINK, LAST_TRIPLE, 0);\n*   $D   4101..4102   $D   $I\n                              CALL EMIT_TRIPLE(BZ, LISTHEAD, LAST_TRIPLE, 0);\n*   $D   4132..4133   $D   $I\n                                       OPERAND#STK(#OP - 1) = LAST_TRIPLE;\n*   $D   4135   $D   $I\n                                          LAST_TRIPLE | MASK_TEMP,\n*   $D   4143   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4172   $D   $I\n                                          LAST_TRIPLE | MASK_TEMP,\n*   4180   $I\n                           ELSE CALL ERROR('ILLEGAL \"-\" OPERATOR', 1);\n*   $D   4184   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4220   $D   $I\n                                                        NULL, 0);\n*   $D   4221   $D   $I\n                                       CALL FIXUP(LISTHEAD, LAST_TRIPLE);\n*   $D   4228   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4237   $D   $I\n                                    CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);\n*   $D   4238   $D   $I\n                                    CALL FIXUP(I, LAST_TRIPLE);\n*   $D   4284..4285   $D   $I\n                                       OPERAND#STK(#OP - 1) = LAST_TRIPLE;\n*   $D   4287   $D   $I\n                                          LAST_TRIPLE | MASK_TEMP,\n*   $D   4295   $D   $I\n                              OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4308   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4322   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4336   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4393..4394   $D\n*   4396   $I\n                                 SL = VALUE(#TP) & \"FFFFFFF8\";\n                                 SL = (SL/8) - I + 1;\n                                 STORAGE_LNGTH(ID_PTR) = SL;\n*   $D   4490   $D   $I\n                           FIX_LIST(NP) = LAST_TRIPLE;\n*   $D   4507..4508   $D   $I\n                                    OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4540   $D   $I\n                              IF \u00acPARAMLIST | (FATHERS_MULTIPLICITY > 1) THEN\n*   $D   4549..4550   $D   $I\n                                    OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4574..4575   $D   $I\n                                    CALL EMIT_TRIPLE(INDEX, LAST_TRIPLE,\n*   4604   $I\n                              ELSE IF STRUCTYPE(TABLE_PTR) = ARRAY THEN\n                                 DO;   /* A STRING CONSTANT */\n                                    #TP = TABLE_PTR;\n                                    CALL REPLACE(#TP);\n                                 END;\n*   $D   4647..4648   $D   $I\n                                 OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4653   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4678   $D   $I\n                           OPERAND#STK(#OP) = LAST_TRIPLE;\n*   $D   4712..4713   $D   $I\n                                    OPERAND#STK(#OP) = LAST_TRIPLE;\n*   4801   $I\n                  IF VAR_TYPE(TABLE_PTR) \u00ac= CONSTANT THEN\n                     CALL ERROR('LOWBOUND OF SUBRANGE TYPE MUST BE A CONSTANT',\n                                1);\n*   4812   $I\n                  IF VAR_TYPE(TABLE_PTR) \u00ac= CONSTANT THEN\n                     CALL ERROR('HIGHBOUND OF SUBRANGE TYPE MUST BE A CONSTANT',\n                                1);\n*   $D   4821..4822   $D   $I\n                  IF I <= 0 THEN DO;\n                     IF I + MAXINT > VALUE(TABLE_PTR) THEN\n*   $D   4824   $D   $I\n                     ELSE\n                        DO;\n                           CALL ERROR('CARDINALITY OF SUBRANGE > MAXINT', 0);\n                           SL = MAXINT;\n                        END;\n*   $D   4826..4829   $D   $I\n                  ELSE SL = VALUE(TABLE_PTR) - I + 1;\n*   $D   4918..4921   $D\n*   $D   4928   $D\n*   5018   $I\n                           IF (STRUCTYPE(TABLE_PTR) = SUBRANGE)\n                              & (STORAGE_LNGTH(TABLE_PTR) > 32768) THEN\n                              CALL ERROR('CARDINALITY OF TAGFIELD TYPE > 32768',\n                                 1);\n*   5025   $I\n                        IF TABLE_PTR \u00ac= NULL THEN\n*   $D   5029   $D   $I\n                     ELSE IF TABLE_PTR \u00ac= NULL THEN\n*   $D   5031   $D   $I\n                           I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);\n*   $D   5037   $D   $I\n                           ID_PTR = I; /* POINTS TO TAGFIELD */\n*   $D   5089   $D   $I\n                     ELSE IF TABLE_PTR \u00ac= NULL THEN\n*   $D   5205..5208   $D   $I\n                  ;\n*   5226   $I\n      DECLARE FP FIXED;\n*   $D   5235   $D   $I\n      CP, FP = 1;   /* CP POINTS TO CURRENT CHARACTER,\n                       FP POINTS TO FIRST CHARACTER */\n*   $D   5238..5243   $D   $I\n         IF (S1 = BYTE('''')) & (S2 = S1) THEN\n            DO;\n               BCD = BCD || SUBSTR(SY_TEXT, FP, CP - FP);\n               S2 = BYTE(' ');\n               FP = CP + 1;\n            END;\n*   5247   $I\n               IF CP > FP THEN BCD = BCD || SUBSTR(SY_TEXT, FP);\n*   $D   5249..5250   $D   $I\n               TEXT_LIMIT = LENGTH(SY_TEXT) - 1;\n               CP, FP = 0;\n*   5253   $I\n      IF CP > FP THEN BCD = BCD || SUBSTR(SY_TEXT, FP, CP - FP);\n*   $D   5323..5324   $D\n*   $D   5328   $D\n*   $D   5448   $D\n*   $D   5511   $D   $I\n         I = VALUE(I);\n*   $D   5517   $D\n*   $D   5528..5544   $D   $I\n      IF SEVERE_ERRORS + MONITOR_LINK(3) = 0 THEN\n         DO;   /* NO SEVERE ERRORS WERE ENCOUNTERED */\n            CALL WRITE_SYMBOLS;\n            OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);\n            CALL REWIND(TRUE, 5);\n            IF MONITOR_LINK(2) > 0 THEN   /* DEBUG LEVEL > 0 */\n               CALL PREPARE_POST_MORTEM_TABLES;\n         END;\n      ELSE   /* THERE WERE SEVERE ERRORS */\n         DO;\n            MONITOR_LINK(0) = NULL;   /* ABORT COMPILATION */\n            CALL PRINT_COMPILE_TIME;\n         END;\n*\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE22": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x00\\xaa\\x00\\xaa\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 170, "newlines": 170, "modlines": 0, "user": "SPASCAL"}, "text": "*   $D  249  $D\n*  365  $I\n              ADDR_TEMP LITERALLY '62',\n*    $D  535  $D  $I\n         ENTRY_POINT || ' BYTES OF CODE GENERATED.');\n*   $D  1245..1249  $D\n*  1297  $I\n GET_STOR_LEN: PROCEDURE (OPERAND) FIXED;\n      DECLARE OPERAND BIT(16);\n      DO CASE MASK(OPERAND);\n         /*   SY TABLE PTR   */\n         RETURN STORAGE_LENGTH(OPERAND);\n         /*   IMMEDIATE   */\n         RETURN 0;\n         /*   TRIPLE   */\n         DO;\n            /*   IF OPERAND IS AN INDEX TRIPLE, THE STORAGE LENGTH MAY BE\n                 CONTAINED IN AN S_LENGTH TRIPLE IMMEDIATELY FOLLOWING  */\n            IF IS_TRIPLE(OPERAND,INDEX) | IS_TRIPLE(OPERAND,ADDR_TEMP) THEN\n            DO;\n               IF TRIPLES((OPERAND & STRIPMASK) + 3) = S_LENGTH THEN DO;\n                  OPERAND = (OPERAND & STRIPMASK) + 4;\n                  RETURN SHL(TRIPLES(OPERAND),16) + TRIPLES(OPERAND + 1);\n               END;\n            END;\n            /*   SET STORAGE LENGTH FROM LENGTH FIELD   */\n            RETURN (SHR(TRIPLES(OPERAND & STRIPMASK),8)& \"FF\") + 1;\n         END;\n         /*   TRIPLE   */\n         DO;\n            /*   IF OPERAND IS AN INDEX TRIPLE, THE STORAGE LENGTH MAY BE\n                 CONTAINED IN AN S_LENGTH TRIPLE IMMEDIATELY FOLLOWING  */\n            IF IS_TRIPLE(OPERAND,INDEX)  | IS_TRIPLE(OPERAND,ADDR_TEMP) THEN\n            DO;\n               IF TRIPLES((OPERAND & STRIPMASK) + 3) = S_LENGTH THEN DO;\n                  OPERAND = (OPERAND & STRIPMASK) + 4;\n                  RETURN SHL(TRIPLES(OPERAND),16) + TRIPLES(OPERAND + 1);\n               END;\n            END;\n            /*   SET STORAGE LENGTH FROM LENGTH FIELD   */\n            RETURN (SHR(TRIPLES(OPERAND & STRIPMASK),8)& \"FF\") + 1;\n         END;\n      END;\n END GET_STOR_LEN;\n\n\n*   1300  $I\n      DECLARE TEMP BIT(16);\n*  1366  $I\n         IF IS_TRIPLE(OPERAND,ADDR_TEMP) THEN DO;\n            /*   TEMP MUST BE DE-REFERENCED   */\n            CALL FORCE_INTO_BASE_REG;\n            IN_REG, IN_FREE_REG = FALSE;\n            OP_STORAGE_LENGTH = GET_STOR_LEN(OPERAND);\n         END;\n*   1386  $I\n         IF IS_TRIPLE(OPERAND,ADDR_TEMP) THEN DO;\n            /*   TEMP MUST BE DE-REFERENCED   */\n            CALL FORCE_INTO_BASE_REG;\n            /*   REMEMBER THE BASE_REG FOR FUTURE REFERENCE   */\n            IN_REG = FALSE;\n            CALL REASSIGN_TEMP(BASE_REG,TRIPLES((OPERAND & STRIPMASK) + 2));\n            OP_STORAGE_LENGTH = GET_STOR_LEN(OPERAND);\n         END;\n*  1397  $I\n              (BASE_REG1,X_REG1) BIT(16),\n*  $D  1398  $D\n*   $D  1428  $D  $I\n      OP_STORAGE_LENGTH =\n         (SHR (TRIPLES(LAST_INDEX_TRIPLE),8) & \"FF\" ) + 1;\n*   $D  1454..1456  $D  $I\n      IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n*   $D  1485..1486  $D\n*  $D  1512  $D  $I\n           IT CAN BE DE-REFERENCED AGAIN.                     */\n*   $D  1514..1517  $D  $I\n      IF (BASE_REG = CURRENT_AR_BASE | BASE_REG = GLOBAL_AR_BASE) & X_REG = 0\n         THEN RETURN;   /*   NO NEED TO SAVE ADDRESS- CAN BE SIMPLY RECOMPUTED*/\n      CALL LOAD_ADDRESS;\n      PRIORITY(BASE_REG) = TEMP_PRIORITY;\n      CALL ASSIGN_TEMP(BASE_REG);\n*   $D  1518  $D  $I\n      TRIPLES(LAST_INDEX_TRIPLE + 2) = LAST_TEMP;\n*  $D  1520..1521  $D  $I\n          LINE NUMBER BIT AND LENGTH FIELD     */\n      TRIPLES(LAST_INDEX_TRIPLE) = ADDR_TEMP +\n         (TRIPLES(LAST_INDEX_TRIPLE) & \"FF80\");\n*  $D  1561  $D  $I\n                  (TRIPLES(LAST_INDEX_TRIPLE) & \"FF80\");\n*    $D  1729  $D  $I\n      CALL EMIT_RX(BC,BR_COND,X_REG,CODE_BASE,\n         (CODE_INDEX + RELATIVE_DISPL) MOD 4096 );\n*   1807   $I\n      DECLARE TEMP BIT(16);\n*  $D  1816  $D  $I\n         IF IS_TRIPLE(OPERAND,INDEX) | IS_TRIPLE(OPERAND,ADDR_TEMP)\n            THEN RETURN;\n*   $D  1826  $D  $I\n         IF IS_TRIPLE(OPERAND,INDEX) | IS_TRIPLE(OPERAND,ADDR_TEMP)\n            THEN RETURN;\n*  $D  1834..1871  $D\n*   1872  $I\n ACCUMULATE: PROCEDURE(OPERAND);\n      DECLARE OPERAND BIT(16);\n      /*   LOADS THE CURRENTLY ADDRESSED OPERAND INTO AN ACCUMULATOR. IF THE OP\n           IS A VALUE TEMP (AS OPPOSED TO AN ADDR_TEMP WHICH MUST BE\n           DE-REFERENCED) THE REGISTER PRIORITY IS INCREASED TO TEMP_PRIORITY\n           AND ASSOCIATED WITH THE TEMPORARY   */\n         CALL GET_OP_INTO_REG(FREE_PRIORITY);\n         IF \u00acIS_TRIPLE(OPERAND,ADDR_TEMP) & \u00acIS_TRIPLE(OPERAND,INDEX)\n            & MASK(OPERAND) = TEMP_MASK THEN\n            CALL REASSIGN_TEMP(ACC,TRIPLES((OPERAND & STRIPMASK) + 2));\n END ACCUMULATE;\n\n*   $D  1882  $D  $I\n         IF IS_TRIPLE(OPERAND,INDEX) | IS_TRIPLE(OPERAND,ADDR_TEMP)\n            THEN RETURN FALSE;\n*   $D  1917  $D  $I\n         CALL ACCUMULATE(OPERAND);\n*   $D  1921  $D  $I\n         CALL EMIT_RX(HALFWORD_INSTR,ACC1,BASE_REG,X_REG,DISPL);\n*   $D   1968  $D  $I\n         CALL ACCUMULATE(OP1);\n*   $D  1982  $D  $I\n         CALL ACCUMULATE(OP1);\n*   $D  2008..2009  $D\n*  2035  $I\n            IF IMMEDIATE THEN\n            DO;   /*   FOLD FOR IMMEDIATE OPERANDS-NO NEED FOR COND BRANCH  */\n               IF (BR_COND = BE & DISPL = 0) | (BR_COND = BNE & DISPL \u00ac= 0 )\n                  THEN CALL LOCAL_BRANCH(UNCOND,OP1);\n               RETURN;\n            END;\n\n*   $D  2039  $D  $I\n               CALL ACCUMULATE(OP2);\n*   $D  2060  $D  $I\n         IF \u00acIN_REG THEN DO;\n            CALL GET_OP_INTO_FLT_REG(FREE_PRIORITY);\n            IF MASK(OP1) = TEMP_MASK THEN\n               CALL REASSIGN_TEMP(FLT_REG,TRIPLES((OP1 & STRIPMASK) + 2));\n         END;\n*   $D  2127..2130  $D  $I\n      IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n*  2134  $I\n         BASE_REG = BASE_REG2;\n*  $D  2136  $D\n*  $D  2138..2140  $D  $I\n      CALL MAKE_TARGET_ADDR;\n*  $D  2327  $D  $I\n            CALL EMIT_RX(MVI,SHR(DISPL2,4),DISPL2 & \"F\",BASE_REG,DISPL);\n*   $D 2904  $D  $I\n            OP_STORAGE_LENGTH = (SHR(TRIPLES(CURRENT_TRIPLE),8) & \"FF\" ) + 1;\n*   2908  $I\n               BASE_REG1 = BASE_REG;\n               BASE_REG = STACKTOP;\n*  2910  $I\n               IF X_REG \u00ac= 0 THEN CALL LOAD_ADDRESS;\n*  $D  2912..2913  $D  $I\n               CALL EMIT_SS(MVC,OP_STORAGE_LENGTH - 1,BASE_REG,DISPL,\n                  BASE_REG1,DISPL1);\n*   $D  3181  $D  $I\n         CALL ACCUMULATE(OP2);\n*  $D  3640  $D  $I\n         CALL EMIT_RR(MER,FLT_REG-#GP_REGS,FLT_REG-#GP_REGS);\n*  3922  $I\n      ENTRY_POINT = ENTRY_POINT + CODE_INDEX;   /* SAVE # CODE BYTES GENERATED*/\n*\n*\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE23": {"ttr": 15368, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SPASCAL"}, "text": "*   51   $I\n   /* MAX_STRING_LENGTH IS THE MAXIMUM LENGTH OF AN XPL CHARACTER STRING.\n   */\n   DECLARE MAX_STRING_LENGTH LITERALLY '256';\n\n*   $D   478   $D   $I\n                  IF (DATATYPE(VAR_PTR) = CHARPTR)\n                     & (STRUCTYPE(VAR_PTR) \u00ac= POINTER) THEN\n*   $D   674   $D   $I\n            FREELIMIT = CORETOP - MAX_STRING_LENGTH;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILE24": {"ttr": 15370, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SPASCAL"}, "text": "*   $*@\n@   $D   80   $D   $I\nIOFBYTS  EQU   800\n@   $D   250..251   $D\n@   $D   277..296   $D\n@   $D   298   $D   $I\n         BNE   PS8                 NOT FOUND\n@   $D   302..316   $D\n@   $D   335..367   $D\n@   $D   534..535   $D\n@   $D   539   $D   $I\n         BNZ   RETURN              YES, SO TERMINATE.\n         CLI   PASS,NPASSES        LAST PASS?\n         BE    SMRET               YES, ENTER EXECUTION PHASE.\n@   $D   584   $D   $I\n         LA    1,STATBLK           ADDRESS OF STATUS BLOCK\n         ST    1,LINKSAVE+4*3      STORE IN MONITOR_LINK(3).\n*        LINK TO RUN MONITOR\n         LINK  EP=RMONITOR,PARAM=(LINKSAVE,INPUT0,OUTPUT0)\n@   $D   604..605   $D\n@   $D   656..657   $D   $I\nFREEUP   DC    A(10000)            AMOUNT OF CORE TO RETURN TO OS\n@   $D   664..666   $D   $I\nSTATBLK  DS    7F                  RUN MONITOR COPIES STATUS BLOCK HERE\nNPASSES  EQU   3                   NUMBER OF COMPILER PASSES.\n@   $D   1963   $D   $I\n         END PASCAL1\n@\n@\n@\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILE25": {"ttr": 15372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(O\\x01\\x02(O\\x16\\x04\\x00\\x87\\x00\\x87\\x00\\x00\\xe2\\xd7\\xc1\\xe2\\xc3\\xc1\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-11T00:00:00", "modifydate": "2002-10-11T16:04:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "SPASCAL"}, "text": "*   $*@\n@   $D   94   $D   $I\nFREEDARL EQU   10000               AREA SIZE FOR I/O BUFFERS.\n@   $D   97   $D\n@   $D   99   $D   $I\n         ENTRY RMONITOR\n@   $D   145..147   $D   $I\n         USING RMONITOR,R15        R15 POINTS TO RMONITOR\nRMONITOR STM   R14,R12,12(R13)     SAVE REGISTERS\n         S     R15,=A(RMONITOR-MONITOR) R15 POINTS TO MONITOR\n@   156   $I\n         ST    R1,PARMPTR          SAVE ADDRESS OF PARAMETER LIST.\n@   $D   182   $D   $I\n         OPEN  (ORGDS)             OPEN DATA SET\n@   $D   218   $D   $I\n         CLOSE (ORGDS)             CLOSE DATA SET\n@   $D   220   $D   $I\n         USING IHADCB,R3\n         TM    DCBBUFCB+3,1        TEST IF BUFFERS FREED.\n@   222   $I\n         DROP R3\n@   $D   231   $D   $I\nCODE     OPEN  (CODEDS)            OPEN DATA SET\n@   $D   280   $D   $I\n         CLOSE (CODEDS)            CLOSE DATA SET\n@   $D   282   $D   $I\n         USING IHADCB,R3\n         TM    DCBBUFCB+3,1        TEST IF BUFFERS FREED.\n@   284   $I\n         DROP R3\n@   $D   294   $D   $I\nGLBL     OPEN  (GLBLDS)            OPEN DATA SET\n@   $D   309   $D   $I\n         CLOSE (GLBLDS)            CLOSE DATA SET\n@   $D   311   $D   $I\n         USING IHADCB,R3\n         TM    DCBBUFCB+3,1        TEST IF BUFFERS FREED.\n@   313   $I\n         DROP  R3\n@   $D   318   $D   $I\nTIMER    L     R4,PARMPTR          ADDRESS OF PARAMETER LIST.\n         USING PARMS,R4\n         L     R3,LINKSAVE         ADDRESS OF MONITOR_LINK.\n@   $D   337   $D   $I\n         L     R3,LINKSAVE         ADDRESS OF MONITOR_LINK.\n@   $D   347..348   $D   $I\n         L     R1,INPUT0           ADDRESS OF DCB FOR THE INPUT FILE.\n         USING IHADCB,R1\n         NC    DCBDDNAM,DCBDDNAM   WAS EOF(INPUT) ENCOUNTERED?\n@   $D   351   $D   $I\n         MVC   DCBEODAD+1(3),1(R2) SET EODAD FIELD IN INPUT DCB.\n         DROP  R1,R4\n@   $D   371..377   $D   $I\nENDMNTR  L     R1,PICAADDR         ADDRESS OF OLD PICA.\n@   391   $I\n         CLI   OUTLINEP,X'00'      IS LENGTH(OUTLINE) > 0?\n         BE    *+8                 NO, SO BRANCH.\n         BAL   LINKREG,PUTLN       YES, SO WRITE LAST LINE OF OUTPUT.\n         SPACE 1\n         LA    R1,PR14             ADDRESS OF STATUS BLOCK, WHICH\n*                                  BEGINS AT LOCATION PR14.\n         L     R2,PARMPTR          ADDRESS OF PARAMETER LIST\n         USING PARMS,R2\n         L     R2,LINKSAVE         ADDRESS OF MONITOR_LINK.\n         DROP  R2\n         L     R2,4*3(0,R2)        SAVE STATUS BLOCK IN AREA WHOSE\n*                                  ADDRESS IS IN MONITOR_LINK(3).\n         MVC   0(4*7,R2),0(R1)\n         SPACE 1\n@   481   $I\nPARMPTR  DS    A                   ADDRESS OF PARAMETER LIST PASSED BY\n*                                  OVERLAY MONITOR, WHOSE FORMAT IS\n*                                  DEFINED BY THE DSECT \"PARMS\".\n@   $D   577..578   $D   $I\nNEXTGET  L     R1,PARMPTR          ADDRESS OF PARAMETER LIST.\n         USING PARMS,R1\n         L     R1,INPUT0           ADDRESS OFDCB FOR THE INPUT FILE.\n         DROP  R1\n         GET   (1)                 READ A RECORD\n@   $D   586   $D   $I\nINPTR    DC    H'80'               POINTER TO CURRENT INPUT CHARACTER\n@   $D   772   $D   $I\n         L     R1,PARMPTR          ADDRESS OF PARAMETER LIST.\n         USING PARMS,R1\n         L     R1,OUTPUT0          ADDRESS OF DCB FOR THE OUTPUT FILE.\n         DROP  R1\n@   $D   777   $D   $I\n         PUT   (1)\n@   $D   1307   $D   $I\n         LA    R1,MAXINT           LINEST <--- MAXINT.\n@   $D   1316..1318   $D   $I\n         MVC   OUTLINE(133),ERRORC\n         MVI   OUTLINEP,132\n         BAL   LINKREG,PUTLN       WRITE A LINE OF DASHES.\n@   $D   1509   $D   $I\n         USING IHADCB,R1\n         TM    DCBBUFCB+3,1\n@   $D   1511   $D   $I\n         FREEPOOL (1)\n         DROP  R1\n@   $D   1641   $D   $I\nREADRE8  CLI   INPUT@(R5),C'.'     IS THE CURRENT CHARACTER A DECIMAL\n@   2048   $I\nMAXINT   DS    0F\n@   $D   2273..2274   $D   $I\n         EJECT\n*\n*        DSECT WHICH DEFINES THE LIST OF PARAMETERS PASSED BY THE\n*        OVERLAY MONITOR TO THE RUN MONITOR.\n*\n         SPACE 5\nPARMS    DSECT\n         SPACE 1\nLINKSAVE DS    A                   ADDRESS OF MONITOR_LINK.\n         SPACE 1\nINPUT0   DS    A                   ADDRESS OFDCB FOR THE INPUT FILE.\n         SPACE 1\nOUTPUT0  DS    A                   ADDRESS OF DCB FOR THE OUTPUT FILE.\n         EJECT\n*\n*        DUMMY  DCB  FOR  DEFINING  DCB  FIELDS\n*\n         SPACE 5\n         PRINT NOGEN\n         DCBD  DSORG=QS,DEVD=DA\n         EJECT\n*\n*        T H E   E N D\n*\n         SPACE 5\n         END RMONITOR\n@\n@\n@\n@\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT387/FILE387.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT387", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}