{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012508000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE629.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE629.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x06'", "DS1TRBAL": "b'\\x99\\xee'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x8f\\x00\\x0b\\x04\\x90\\x00\\x05\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04@\\x00\\x00\\x01\\x034\\x1f\\x01\\x034\\x1f\\x01\\x12\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf4@@@'", "ispf": {"version": "04.64", "flags": 0, "createdate": "2003-12-07T00:00:00", "modifydate": "2003-12-07T01:12:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-464"}, "text": "REGULAR CBT TAPE - VERSION 464    FILE:  629\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT464.FILE629\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 18 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,265 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/07/03    01:12:25    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00#\\x01\\x03\\x13o\\x01\\x033\\x9f\\x16(\\x00\\xc0\\x00\\xab\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2003-05-16T00:00:00", "modifydate": "2003-12-05T16:28:23", "lines": 192, "newlines": 171, "modlines": 0, "user": "FAJA"}, "text": "NAME     - SNTPD\n\nTITLE    - SIMPLE NETWORK TIME DAEMON (SNTPD)\n\nVERSION  - 1.2\n\nFUNCTION - This is a Simple Network Time Protocol (SNTPv3)\n           server as defined by RFC2030 (which defines SNTPv4,\n           but this server does not implement any of the SNTPv4\n           optional extensions).\n\n           This SNTP server listens for UDP packets on port 123\n           and responds the current TOD clock time to any NTP v1,\n           v2, v3, or v4 client to a precision of 2 microseconds.\n\nNOTES    - 1. This server cannot alter the Time Of Day (TOD)\n              clock. If you specify the TOD +hhmm adjustment command\n              then that adjustment is applied each time a\n              TOD clock value is to be translated to an RFC2030\n              clock value for transmission to an NTP client.\n              Altering the actual hardware TOD clock requires\n              operator intervention and cannot be done by a\n              program alone.\n\n\nMEMBERS  - The list of members in the distribution PDS are:\n\n           $$$DOC   - This file.\n           ASM      - JCL to assemble/link the SNTP server.\n           C2X      - Macro to convert binary to displayable hex.\n           DEBUG    - Macro to assemble debug code.\n           EYECATCH - Macro to assemble an eye-catcher.\n           GETCMD   - Source code to obtain the next operator command.\n           GPL      - The GNU General Public License.\n           LOG      - Macro to conditionally print a log message.\n           RFC2030  - The SNTPv4 Request For Comments.\n           RUNJOB   - JCL to run the SNTP server as a job.\n           RUNPROC  - JCL to run the SNTP server as a proc (TCPSNTP).\n           SAY      - Macro to print a formatted log message.\n           SNTPD    - Source code for the SNTP server.\n           TCPSNTP  - JCL for the SNTP server proc.\n\nINSTALL  - To install and run:\n\n           1. Edit the ASM member and set the following JCL variables:\n\n              SET SRC=your.source.pds     (this PDS)\n              SET LIB=your.load.library   (where you want the loadmod)\n              SET SEZATCP=TCPIP.SEZATCP   (your SEZATCP target library)\n\n           2. Submit the ASM member to assemble/link the server.\n\n           3. Edit and submit the RUNJOB to run the server as a job.\n              You can cancel it to shut it down.\n\n           4. Edit the TCPSNTP member, customize it and put it in your\n              proclib concatenation. You may have to set up RACF to\n              allow TCPSNTP to be run as a started task.\n\n           5. Update your TCPIP.PROFILE to allow the TCPSNTP started\n              task to listen on port 123.  Add:\n\n              PORT\n                123 UDP TCPSNTP ; Simple Network Time Protocol server\n\n           6. Start the SNTP server started task by issuing:\n\n              S TCPSNTP\n\n              You can disable logging at start up by issuing:\n\n              S TCPSNTP,,,LOG 0\n\n           7. You can modify the logging level after start up by:\n\n              F TCPSNTP,,,LOG nn\n\n           8. You can stop the server by:\n\n              P TCPSNTP\n              or...\n              F TCPSNTP,STOP\n\n\nSTARTUP  - Sample command to start the server:\n\n           S TCPSNTP,,,LOGGING LEVEL IS 60\n\n           Multiple comma-separated commands may be entered on the\n           start command. For example:\n\n           S TCPSNTP,,,LOG 0,TOD +1000,NOSWAP\n\n           See below for the full list of commands.\n\n\nSHUTDOWN - Sample command to stop the server:\n\n           P TCPSNTP\n           ...or...\n           F TCPSNTP,STOP\n\n\nCOMMANDS - Operator commands supported are:\n\n           F TCPSNTP,cmd\n\n           Where, cmd is:\n\n           LOG nn\n              Set the logging level to nn, where nn is any  numb-\n              er between 0 and 255 and has the following (cumul-\n              ative) meanings:\n\n               0-9    NONE      No logging\n              10-19   ERROR     Error messages\n              20-24   WARNING   Warning messages\n              25-29   SUMMARY   Summary statistics\n              30-39   INFO      Information, short data contents\n              40-49   BANNER    Routine labels\n              50-59   DEBUG     Debugging messages\n              60-255  DATA      Full data message contents\n\n              For the LOG command, only the first three letters are\n              checked, so the following commands have the same effect:\n              LOG30\n              LOG 30\n              LOGGING 30\n              LOGGING LEVEL 30 PLEASE\n\n            TOD +hhmm\n            TOD -hhmm\n               Set the amount of time to be added to the current\n               Time Of Day (TOD) clock value to make it equal to\n               UCT (GMT) time. This is to accommodate those sites\n               that have their TOD clock set to local time rather\n               than UCT (GMT) time.\n\n               The hour (hh) must be between 00 and 23.\n               The minute (mm) must be between 00 and 59.\n\n               If not all digits are specified then the adjustment\n               is treated as follows:\n\n               +m          = +000m\n               +mm         = +00mm\n               +hmm        = +0hmm\n               +hhmm       = +hhmm\n\n            NOSWAP\n               Attempts to set the address space to run non-\n               swappable. The program needs to be APF-authorized if\n               this to occur (i.e. linkedit with AC=1 and run from\n               a load library in the APFLIST).\n\n            STRATUM n\n               Set the stratum level to n, where n is from 0 to 255\n               as follows (from RFC 2030):\n\n               Stratum  Meaning\n               -------- -------------------------------------\n               0        unspecified or unavailable\n               1        primary reference (e.g., radio clock)\n               2-15     secondary reference (via NTP or SNTP)\n               16-255   reserved\n\n               The default stratum is 2.\n\n            SHOW\n               Shows the current server settings.\n\nAUTHOR   - Andrew Armstrong (a.armstrong@optusnet.com.au)\n           Edigar Sobreira (edigar.sobreira@eds.com)\n\n\nHISTORY  - Date     By       Reason (most recent at the top pls)\n           -------- -------- ------------------------------------\n           20031205 AJA      Added SHOW command.\n           20031205 AJA      Added STRATUM command.\n           20031107 Edigar   Changed the STRATUM value to 2.\n           20031107 Edigar   Added F xxx,STOP possibility.\n           20031107 Edigar   Added NOSWAP command.\n           20031107 Edigar   Allowed multiples parm values.\n           20031106 AJA      Added TOD command.\n           20031025 AJA      Added OFFSET 0 to CBTTAPE.ORG.\n           20030516 AJA      Submitted V1.0 to CBTTAPE.ORG.\n           20011227 AJA      Added version to start up message.\n           20011128 AJA      Allowed NTP V4 clients to connect.\n           20011121 AJA      Added MODIFY command interface.\n           20010822 AJA      Initial version.\n\n----------------------------END OF $$$DOC-------------------------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE1": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x03\\x13o\\x01\\x03\\x13o\\t \\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-05-16T00:00:00", "modifydate": "2003-05-16T09:20:54", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:\n        sntp contribution\n   Date:\n        Fri, 16 May 2003 22:09:32 +1000\n   From:\n        \"Andrew Armstrong\" <andrew_armstrong@bigpond.com>\n     To:\n        <sbgolob@cbttape.org>\n\n\n\n\nHi Sam,\n\nI've uploaded sntp.xmi.zip to cbttape.org /incoming\n\nBTW...there is no /pub/incoming directory, contrary to the indication on\n\nhttp://www.cbttape.org/contribute.htm\n\nCheers,\nAndrew Armstrong\nSystems Programmer\nemail: andrew_armstrong@bigpond.com\nor: aarmstrong@mail.fairfax.com.au\nor: arms1and@police.nsw.gov.au\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x031\\x1f\\x01\\x031\\x1f\\x101\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-07T00:00:00", "modifydate": "2003-11-07T10:31:50", "lines": 17, "newlines": 17, "modlines": 0, "user": "SBGOLOB"}, "text": "Hi Sam,\n\nHere is a small update to file629 (an SNTP server).\n\nA user has requested that some way of adjusting the TOD clock\nvalues to match UCT (GMT) time be provided.  This is for sites\nthat run with their TOD clock set to local time instead of GMT.\n\nNow you can issue a modify command to set the adjustment on the\nfly as follows:\n\nF sntpproc,TOD +hhmm\nor\nF sntpproc,TOD -hhmm\n\nCheers,\nAndrew.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE629": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04@\\x00\\x00\\x01\\x034\\x1f\\x01\\x034\\x1f\\x01\\x12\\x002\\x002\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf4@@@'", "ispf": {"version": "04.64", "flags": 0, "createdate": "2003-12-07T00:00:00", "modifydate": "2003-12-07T01:12:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CBT-464"}, "text": "//***FILE 629 contains an SNTP server from Andrew Armstrong.        *   FILE 629\n//*                                                                 *   FILE 629\n//*           Andrew Armstrong                                      *   FILE 629\n//*           Systems Programmer                                    *   FILE 629\n//*           email: a.armstrong@optusnet.com.au                    *   FILE 629\n//*           or: aarmstrong@mail.fairfax.com.au                    *   FILE 629\n//*           or: arms1and@police.nsw.gov.au                        *   FILE 629\n//*                                                                 *   FILE 629\n//*     NAME     - SNTPD                                            *   FILE 629\n//*                                                                 *   FILE 629\n//*     TITLE    - SIMPLE NETWORK TIME DAEMON (SNTPD)               *   FILE 629\n//*                                                                 *   FILE 629\n//*     VERSION  - 1.0                                              *   FILE 629\n//*                                                                 *   FILE 629\n//*     FUNCTION - This is a Simple Network Time Protocol           *   FILE 629\n//*                (SNTPv3) server as defined by RFC2030 (which     *   FILE 629\n//*                defines SNTPv4, but this server does not         *   FILE 629\n//*                implement any of the SNTPv4 optional             *   FILE 629\n//*                extensions).                                     *   FILE 629\n//*                                                                 *   FILE 629\n//*                This SNTP server listens for UDP packets on      *   FILE 629\n//*                port 123 and responds the current TOD clock      *   FILE 629\n//*                time to any NTP v1, v2, v3, or v4 client to      *   FILE 629\n//*                a precision of 2 microseconds.                   *   FILE 629\n//*                                                                 *   FILE 629\n//*     MEMBERS  - The list of members in the distribution PDS      *   FILE 629\n//*                are:                                             *   FILE 629\n//*                                                                 *   FILE 629\n//*                $$$DOC   - This file.                            *   FILE 629\n//*                ASM      - JCL to assemble/link the SNTP         *   FILE 629\n//*                           server.                               *   FILE 629\n//*                C2X      - Macro to convert binary to            *   FILE 629\n//*                           displayable hex.                      *   FILE 629\n//*                DEBUG    - Macro to assemble debug code.         *   FILE 629\n//*                EYECATCH - Macro to assemble an eye-catcher.     *   FILE 629\n//*                GETCMD   - Source code to obtain the next        *   FILE 629\n//*                           operator command.                     *   FILE 629\n//*                GPL      - The GNU General Public License.       *   FILE 629\n//*                LOG      - Macro to conditionally print a        *   FILE 629\n//*                           log message.                          *   FILE 629\n//*                RFC2030  - The SNTPv4 Request For Comments.      *   FILE 629\n//*                RUNJOB   - JCL to run the SNTP server as a       *   FILE 629\n//*                           job.                                  *   FILE 629\n//*                RUNPROC  - JCL to run the SNTP server as a       *   FILE 629\n//*                           proc (TCPSNTP).                       *   FILE 629\n//*                SAY      - Macro to print a formatted log        *   FILE 629\n//*                           message.                              *   FILE 629\n//*                SNTPD    - Source code for the SNTP server.      *   FILE 629\n//*                TCPSNTP  - JCL for the SNTP server proc.         *   FILE 629\n//*                                                                 *   FILE 629\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASM": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x03\\x00\\x99\\x12_\\x01\\x033\\x9f\\x16\\x19\\x00,\\x00\\x19\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "1999-05-05T00:00:00", "modifydate": "2003-12-05T16:19:03", "lines": 44, "newlines": 25, "modlines": 0, "user": "FAJA"}, "text": "//jobname  JOB ,'SNTP',CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*--------------------------------------------------------------------*\n//*        Set installation specific dataset names here...\n//*--------------------------------------------------------------------*\n//*\n//         SET SRC=your.source.pds\n//         SET LIB=your.load.library\n//         SET SEZATCP=TCPIP.SEZATCP\n//*\n//*--------------------------------------------------------------------*\n//*        Assemble\n//*--------------------------------------------------------------------*\n//*\n//ASM     EXEC PGM=ASMA90,PARM='OBJECT,NODECK'\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODLIB\n//          DD DISP=SHR,DSN=&SEZATCP\n//          DD DISP=SHR,DSN=&SRC\n//SYSUT1    DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSIN     DD DISP=SHR,DSN=&SRC(SNTPD)\n//          DD DISP=SHR,DSN=&SRC(GETCMD)\n//*\n//*--------------------------------------------------------------------*\n//*        Link\n//*--------------------------------------------------------------------*\n//*\n//LINK    EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL,AC=1',COND=(8,LT,ASM)\n//SYSLIB    DD DISP=SHR,DSN=&SEZATCP\n//SYSLIN    DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD  DDNAME=SYSIN\n//SYSIN     DD *\n    INCLUDE SYSLIB(EZASOKET)\n    NAME    SNTPD(R)\n/*\n//SYSLMOD   DD DISP=SHR,DSN=&LIB\n//SYSUT1    DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSPRINT  DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "C2X": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x08\\x00\\x990/\\x00\\x990/\\x16 \\x00$\\x00\\x0e\\x00\\x00\\xe3\\xe9\\xc1\\xd9\\xd4\\xe2@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-10-29T00:00:00", "modifydate": "1999-10-29T16:20:08", "lines": 36, "newlines": 14, "modlines": 0, "user": "TZARMS"}, "text": "         MACRO\n&sLabel  C2X   &sTarget,&sSource,&n,&z\n.**********************************************************************\n.*                                                                   **\n.* FUNCTION - Converts binary to displayable hexadecimal. It is      **\n.*            named after the REXX c2x funciton and has that         **\n.*            function's semantics.  The length of the source field  **\n.*            determines the length of the target field.  The source **\n.*            field must be no longer than 7 bytes so as to avoid    **\n.*            the author having to think too hard.                   **\n.*                                                                   **\n.* ON ENTRY - &sTarget = Label of storage to receive result          **\n.*            &sSource = Label of source storage to be converted     **\n.*            &n       = Number of source bytes                      **\n.*            &z       = NOTRAIL if a trailing blank is to be omitted**\n.*                                                                   **\n.* EXAMPLES - sSource DC X'0123'         (Binary string)             **\n.*            sTarget DC CL4             (Displayable hex)           **\n.*            C2X sTarget,sSource        Converts the data at sSource**\n.*                                       to C'0123' and stores it at **\n.*                                       sTarget.                    **\n.*                                                                   **\n.**********************************************************************\n\n         AIF   ('&sLabel' EQ '').NOLABEL\n&sLabel  DS    0H\n.NOLABEL ANOP\n\n         UNPK  &sTarget.(2*&n+1),&sSource.(&n+1)\n         TR    &sTarget.(2*&n),=C'0123456789ABCDEF'-C'0'\n\n         AIF   ('&z' EQ 'NOTRAIL').NOTRAIL\n         MVI   &sTarget+2*&n,C' '\n.NOTRAIL ANOP\n\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEBUG": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x19\\x00\\x990/\\x00\\x990/\\x16\\x03\\x00;\\x001\\x00\\x00\\xe3\\xe9\\xc1\\xd9\\xd4\\xe2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-10-29T00:00:00", "modifydate": "1999-10-29T16:03:19", "lines": 59, "newlines": 49, "modlines": 0, "user": "TZARMS"}, "text": "         MACRO\n&sLabel  DEBUG &sText\n.**********************************************************************\n.*                                                                   **\n.* FUNCTION - Conditionally ASSEMBLE code to log a debug message.    **\n.*                                                                   **\n.*                                                                   **\n.* ON ENTRY - &sText   = Message to be logged                        **\n.*                    or ON if code generation is to be enabled      **\n.*                    or OFF if code generation is to be disabled    **\n.*                                                                   **\n.*                                                                   **\n.**********************************************************************\n\n         GBLB  &bDebug\n         AIF   ('&sText' EQ 'ON').ON\n         AIF   ('&sText' EQ 'OFF').OFF\n         AIF   (NOT &bDebug).EXIT\n\n         AIF   (N'&SYSLIST EQ 0).S0,                                   X\n               (N'&SYSLIST EQ 1).S1,                                   X\n               (N'&SYSLIST EQ 2).S2,                                   X\n               (N'&SYSLIST EQ 3).S3,                                   X\n               (N'&SYSLIST EQ 4).S4\n         AGO   .S4\n\n.S0      ANOP\n&sLabel  SAY   &sLabel\n         MEXIT\n\n.S1      ANOP\n&sLabel  SAY   &SYSLIST(1)\n         MEXIT\n\n.S2      ANOP\n&sLabel  SAY   &SYSLIST(1),&SYSLIST(2)\n         MEXIT\n\n.S3      ANOP\n&sLabel  SAY   &SYSLIST(1),&SYSLIST(2),&SYSLIST(3)\n         MEXIT\n\n.S4      ANOP\n&sLabel  SAY   &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4)\n         MEXIT\n\n.ON      ANOP\n&bDebug  SETB  1\n         MEXIT\n\n.OFF     ANOP\n&bDebug  SETB  0\n         MEXIT\n\n.EXIT    ANOP\n         AIF   ('&sLabel' EQ '').MEND\n&sLabel  DS    0H\n.MEND    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EYECATCH": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00F\\x00\\x990/\\x01\\x00\\x06\\x9f\\x127\\x00\\x11\\x00\\x0b\\x00\\x00\\xe3\\xe9\\xc1\\xd9\\xd4\\xe2@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-10-29T00:00:00", "modifydate": "2000-03-09T12:37:46", "lines": 17, "newlines": 11, "modlines": 0, "user": "TZARMS"}, "text": "         MACRO\n&sLabel  EYECATCH\n         LCLC  &sYYYY,&sMM,&sDD,&sHR,&sMI\n.*--------------------------------------------------------------------*\n.*       Eye-catcher                                                  *\n.*--------------------------------------------------------------------*\n&sYYYY   SETC  '&SYSDATC'(1,4)\n&sMM     SETC  '&SYSDATC'(5,2)\n&sDD     SETC  '&SYSDATC'(7,2)\n&sHR     SETC  '&SYSTIME'(1,2)\n&sMI     SETC  '&SYSTIME'(4,2)\n         J     A&SYSNDX           Jump over eye-catcher\n&sLabel  DC    CL8'&SYSECT'            CSECT name\n         DC    CL10'&sYYYY/&sMM/&sDD'  Assembly date\n         DC    CL6' &sHR:&sMI'         Assembly time\nA&SYSNDX DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETCMD": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00#\\x01\\x010_\\x01\\x031\\x1f\\x17C\\x01$\\x00\\xfd\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2001-11-01T00:00:00", "modifydate": "2003-11-07T17:43:23", "lines": 292, "newlines": 253, "modlines": 0, "user": "FAJA"}, "text": "***********************************************************************\n**                                                                   **\n** NAME     - GETCMD                                                 **\n**                                                                   **\n** TITLE    - MVS CONSOLE COMMAND INTERFACE                          **\n**                                                                   **\n** FUNCTION - This routine is an MVS console command handler.        **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R1  -> Return structure consisting of:                 **\n**                   A(VERB) -> CL1'x'  Command verb (e.g. 'F')      **\n**                   A(DATA) -> CL256'operands'                      **\n**                   A(ECB)  -> ECB                                  **\n**            R13 -> Register save area                              **\n**            R14 -> Return point                                    **\n**            R15 -> Entry point                                     **\n**                                                                   **\n** ON EXIT  - R15 =  0                                               **\n**                                                                   **\n** EXAMPLE  - The operator starts the address space:                 **\n**                                                                   **\n**            S stcname,,optional operands                           **\n**                                                                   **\n**            The FIRST time the calling program executes:           **\n**              CALL GETCMD,(cVerb,sOperands,pECB),MF=E              **\n**              ...the return values for the call will be:           **\n**                 cVerb = 'S'    ...for the START command           **\n**                 sOperands = 'optional operands'                   **\n**                 pECB -> ECB to optionally wait upon               **\n**                                                                   **\n**            The operator issues: F stcname,STOP IMMEDIATE          **\n**                                                                   **\n**            The calling program, which may have been waiting on    **\n**            the returned ECB, executes:                            **\n**              CALL GETCMD,(cVerb,sOperands,pECB),MF=E              **\n**              ...the return values for the call will be:           **\n**                 cVerb = 'F'                                       **\n**                 sOperands = 'STOP IMMEDIATE'                      **\n**                 pECB -> ECB to optionally wait upon               **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1.  The first time this routine is called, the START   **\n**                command and its parameters will be returned.       **\n**                                                                   **\n**            2.  This routine can be called at any time.  If one    **\n**                or more commands are pending, then the first of    **\n**                them is returned and then deleted from the queue.  **\n**                If no command is pending then the command verb is  **\n**                set to X'00'.                                      **\n**                                                                   **\n**            3.  After the first call to this routine, the ECB      **\n**                address is set.  The calling program may choose to **\n**                wait on this ECB, which is posted by MVS when      **\n**                an operator has issued a command to this address   **\n**                space, and call this routine to obtain the command **\n**                just issued.  Alternatively, the calling program   **\n**                may simply check the command verb and, if it is    **\n**                X'00', then there is no operator command to process.*\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <a.armstrong@optusnet.com.au>      **\n**            HPO Computer Services Pty Ltd                          **\n**            A.B.N. 22 003 198 543                                  **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20011031 AJA Massage for a non-C calling program.      **\n**            19951208 AJA Original version.                         **\n**                                                                   **\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         R E G I S T E R S                           *\n*                                                                     *\n***********************************************************************\n\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          M A I N L I N E                            *\n*                                                                     *\n***********************************************************************\n\nGETCMD   CSECT\nGETCMD   AMODE 31\nGETCMD   RMODE ANY\nEYECATCH EYECATCH                 Put eye-catcher in CSECT storage\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING GETCMD,R12\n*        -----------------\n\n         LR    R4,R1              -> Parameter list\n         USING PARMLIST,R4        Map parameter list\n*        -----------------\n\n         STORAGE OBTAIN,LENGTH=WORKAREA_LENGTH,LOC=BELOW\n         LTR   R15,R15\n         JNZ   Quit\n\n         ST    R13,4(,R1)         Chain forward\n         ST    R1,8(,R13)         Chain backward\n         LR    R13,R1             -> My save area + work area\n         USING WORKAREA,R13\n*        ------------------\n\n*---------------------------------------------------------------------*\n*        Validate parameters passed                                   *\n*---------------------------------------------------------------------*\n\n         LTR   R4,R4           Parameter passed?\n         JZ    setRC12         No, jump\n\n         TM    pLastParm,X'80'    Correct number of parameters?\n         JNO   setRC12            No, jump\n\n*---------------------------------------------------------------------*\n*        Extract address of COM data area                             *\n*---------------------------------------------------------------------*\n\n         LA    R8,pCOM            -> Fullword to store COM address\n         EXTRACT (R8),FIELDS=COMM,MF=(E,ELIST)\n\n*---------------------------------------------------------------------*\n*        Initialise return values                                     *\n*---------------------------------------------------------------------*\n\n         L     R8,pCOM            -> COM data area\n         USING COM,R8\n*        ------------\n         L     R7,COMECBPT        -> ECB supplied by MVS\n         L     R1,pECB            -> A(ECB) in callers parameter list\n         ST    R7,0(,R1)          -> ECB\n\n         L     R7,pcCommand       -> Command verb\n         MVI   0(R7),0\n\n         L     R7,psOperand       -> Command operands\n         XC    0(256,R7),0(R7)\n\n*---------------------------------------------------------------------*\n*        Get the operator command and parameters                      *\n*---------------------------------------------------------------------*\n\n         L     R7,COMCIBPT        -> First Command Input Buffer\n         LTR   R7,R7              Are there any CIBs in the chain?\n         JZ    continue           No, branch\n\n         USING CIB,R7\n*        ------------\n         L     R9,pcCommand       -> Command verb\n\n         CLI   CIBVERB,CIBMODFY   Is this a MODIFY command CIB?\n         JNE   checkStop\n         MVI   0(R9),C'F'         Indicate MODIFY command\n         J     copyData\n\ncheckStop DS   0H\n         CLI   CIBVERB,CIBSTOP    Is this a STOP command CIB?\n         JNE   checkStart\n         MVI   0(R9),C'P'         Indicate STOP command\n         J     copyData\n\ncheckStart DS   0H\n         CLI   CIBVERB,CIBSTART   Is this a START command CIB?\n         JNE   deleteCIB\n         MVI   0(R9),C'S'         Indicate START command\n         J     copyData\n\ncopyData DS    0H\n         LH    R5,CIBDATLN        Get L'data (multiples of 8 bytes)\n         BCTR  R5,*-*             -1 for EX\n         LTR   R5,R5              Is there any command data?\n         JM    deleteCIB          No, branch\n\n         L     R9,psOperand       -> Command operands\ncopyOps  MVC   0(*-*,R9),CIBDATA Copy command data\n         EX    R5,copyOps\n         J     deleteCIB\n\n*---------------------------------------------------------------------*\n*        Delete this command from the Command Input Buffer chain      *\n*---------------------------------------------------------------------*\n\ndeleteCIB DS   0H\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R7)  Delete this CIB\n\n*---------------------------------------------------------------------*\n*        Ensure MODIFY commands are enabled                           *\n*---------------------------------------------------------------------*\n\ncontinue DS    0H\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=5    Enable MODIFY commands\n         J     setRC0\n         DROP  R7,R8\n*        -----------\n\n*---------------------------------------------------------------------*\n*        Return to caller                                             *\n*---------------------------------------------------------------------*\n\nsetRC12  DS    0H\n         LA    R15,12             R15 = 12\n         J     return\n\nsetRC0   DS    0H\n         SLR   R15,R15            R15 = 0\n\nreturn   DS    0H\n         L     R13,4(,R13)        -> Caller's save area\nQuit     DS    0H\n         RETURN (14,12),RC=(15)\n\n*==========================END OF ROUTINE=============================*\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          L I T E R A L S                            *\n*                                                                     *\n***********************************************************************\n\n         LTORG ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         C O N S T A N T S                           *\n*                                                                     *\n***********************************************************************\n\nELIST    EXTRACT MF=L\n         EJECT\n***********************************************************************\n*                                                                     *\n*                            D S E C T S                              *\n*                                                                     *\n***********************************************************************\n\n*---------------------------------------------------------------------*\n*         Parameter list passed on entry                              *\n*---------------------------------------------------------------------*\n\nPARMLIST DSECT\npcCommand DS    A                 -> CL1'x'  Console command\npsOperand DS    A                 -> CL256'command operands'\npECB      DS    A                 -> ECB to wait on\npLastParm EQU   *-4\n\n*---------------------------------------------------------------------*\n*        Map area returned by EXTRACT FIELDS=COMM                     *\n*---------------------------------------------------------------------*\n\nCOM      DSECT\n         IEZCOM ,\n\n*---------------------------------------------------------------------*\n*        Map Command Input Buffer (CIB) chain entry                   *\n*---------------------------------------------------------------------*\n\nCIB      DSECT\n         IEZCIB ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          W O R K A R E A                            *\n*                                                                     *\n***********************************************************************\n\nWORKAREA DSECT\nSAVEAREA DS    18F\n\npCOM     DS    A                  -> Area mapped by COM DSECT\n\nWORKAREA_LENGTH EQU *-WORKAREA\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GPL": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x03\\x12\\x9f\\x01\\x03\\x13o\\x13)\\x01\\x1c\\x01\\x1c\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-05-09T00:00:00", "modifydate": "2003-05-16T13:29:24", "lines": 284, "newlines": 284, "modlines": 0, "user": "FAJA"}, "text": "            GNU GENERAL PUBLIC LICENSE\n               Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\n            GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n             END OF TERMS AND CONDITIONS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOG": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00(\\x00\\x990/\\x01\\x013\\x0f\\x12@\\x009\\x00+\\x00\\x00\\xe3\\xe9\\xc1\\xd9\\xd4\\xe2@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-10-29T00:00:00", "modifydate": "2001-11-26T12:40:28", "lines": 57, "newlines": 43, "modlines": 0, "user": "TZARMS"}, "text": "         MACRO\n&sLabel  LOG   &LEVEL=NONE,&WRITER=Say\n.**********************************************************************\n.*                                                                   **\n.* FUNCTION - Generate and conditionally execute code to log a       **\n.*            message.                                               **\n.*                                                                   **\n.* ON ENTRY - &LEVEL   = Message level between 0 and 255.  The       **\n.*                       message is not logged if the current level  **\n.*                       as defined by cLogLevel is lower than this  **\n.*                       value.                                      **\n.*                                                                   **\n.**********************************************************************\n\n         AIF   ('&sLabel' EQ '').NOLABEL\n&sLabel  DS    0H\n.NOLABEL ANOP\n\n         AIF   ('&LEVEL' EQ 'NONE').NONE\n\n         CLI   cLogLevel,&LEVEL   Check current logging level\n         JL    L&SYSNDX           Jump if low\n\n.NONE    ANOP\n         AIF   (N'&SYSLIST EQ 0).S0,                                   X\n               (N'&SYSLIST EQ 1).S1,                                   X\n               (N'&SYSLIST EQ 2).S2,                                   X\n               (N'&SYSLIST EQ 3).S3,                                   X\n               (N'&SYSLIST EQ 4).S4\n         AGO   .S4\n\n.S0      ANOP\n         SAY   &sLabel,WRITER=&WRITER\n         AGO   .EXIT\n\n.S1      ANOP\n         SAY   &SYSLIST(1),WRITER=&WRITER\n         AGO   .EXIT\n\n.S2      ANOP\n         SAY   &SYSLIST(1),&SYSLIST(2),WRITER=&WRITER\n         AGO   .EXIT\n\n.S3      ANOP\n         SAY   &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),WRITER=&WRITER\n         AGO   .EXIT\n\n.S4      ANOP\n         SAY   &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),WRITER=&X\n               WRITER\n         AGO   .EXIT\n\n.EXIT    ANOP\n         AIF   ('&LEVEL' EQ 'NONE').NONE2\nL&SYSNDX DS    0H\n.NONE2   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RFC2030": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x03\\x13o\\x01\\x03\\x13o\\x13)\\x03\\xf3\\x03\\xf3\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-05-16T00:00:00", "modifydate": "2003-05-16T13:29:20", "lines": 1011, "newlines": 1011, "modlines": 0, "user": "FAJA"}, "text": "\n\n\n\n\n\nNetwork Working Group                                           D. Mills\nRequest for Comments: 2030                        University of Delaware\nObsoletes: 1769                                             October 1996\nCategory: Informational\n\n\n             Simple Network Time Protocol (SNTP) Version 4\n                         for IPv4, IPv6 and OSI\n\nStatus of this Memo\n\n   This memo provides information for the Internet community.  This memo\n   does not specify an Internet standard of any kind.  Distribution of\n   this memo is unlimited.\n\nAbstract\n\n   This memorandum describes the Simple Network Time Protocol (SNTP)\n   Version 4, which is an adaptation of the Network Time Protocol (NTP)\n   used to synchronize computer clocks in the Internet. SNTP can be used\n   when the ultimate performance of the full NTP implementation\n   described in RFC-1305 is not needed or justified. When operating with\n   current and previous NTP and SNTP versions, SNTP Version 4 involves\n   no changes to the NTP specification or known implementations, but\n   rather a clarification of certain design features of NTP which allow\n   operation in a simple, stateless remote-procedure call (RPC) mode\n   with accuracy and reliability expectations similar to the UDP/TIME\n   protocol described in RFC-868.\n\n   The only significant protocol change in SNTP Version 4 over previous\n   versions of NTP and SNTP is a modified header interpretation to\n   accommodate Internet Protocol Version 6 (IPv6) \u00ddDEE96\u00a8 and OSI\n   \u00ddCOL94\u00a8 addressing. However, SNTP Version 4 includes certain optional\n   extensions to the basic Version 3 model, including an anycast mode\n   and an authentication scheme designed specifically for multicast and\n   anycast modes. While the anycast mode extension is described in this\n   document, the authentication scheme extension will be described in\n   another document to be published later. Until such time that a\n   definitive specification is published, these extensions should be\n   considered provisional.\n\n   This memorandum obsoletes RFC-1769, which describes SNTP Version 3.\n   Its purpose is to correct certain inconsistencies in the previous\n   document and to clarify header formats and protocol operations for\n   current NTP Version 3 (IPv4) and proposed NTP Version 4 (IPv6 and\n   OSI), which are also used for SNTP. A working knowledge of the NTP\n   Version 3 specification RFC-1305 is not required for an\n   implementation of SNTP.\n\n\n\nMills                        Informational                      \u00ddPage 1\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n1. Introduction\n\n   The Network Time Protocol (NTP) Version 3 specified in RFC-1305\n   \u00ddMIL92\u00a8 is widely used to synchronize computer clocks in the global\n   Internet. It provides comprehensive mechanisms to access national\n   time and frequency dissemination services, organize the time-\n   synchronization subnet and adjust the local clock in each\n   participating subnet peer. In most places of the Internet of today,\n   NTP provides accuracies of 1-50 ms, depending on the characteristics\n   of the synchronization source and network paths.\n\n   RFC-1305 specifies the NTP Version 3 protocol machine in terms of\n   events, states, transition functions and actions and, in addition,\n   engineered algorithms to improve the timekeeping quality and mitigate\n   among several synchronization sources, some of which may be faulty.\n   To achieve accuracies in the low milliseconds over paths spanning\n   major portions of the Internet of today, these intricate algorithms,\n   or their functional equivalents, are necessary. However, in many\n   cases accuracies in the order of significant fractions of a second\n   are acceptable. In such cases, simpler protocols such as the Time\n   Protocol \u00ddPOS83\u00a8, have been used for this purpose. These protocols\n   usually involve an RPC exchange where the client requests the time of\n   day and the server returns it in seconds past some known reference\n   epoch.\n\n   NTP is designed for use by clients and servers with a wide range of\n   capabilities and over a wide range of network delays and jitter\n   characteristics. Most users of the Internet NTP synchronization\n   subnet of today use a software package including the full suite of\n   NTP options and algorithms, which are relatively complex, real-time\n   applications (see http://www.eecis.udel.edu/~ntp). While the software\n   has been ported to a wide variety of hardware platforms ranging from\n   personal computers to supercomputers, its sheer size and complexity\n   is not appropriate for many applications. Accordingly, it is useful\n   to explore alternative access strategies using simpler software\n   appropriate for less stringent accuracy expectations.\n\n   This document describes the Simple Network Time Protocol (SNTP)\n   Version 4, which is a simplified access strategy for servers and\n   clients using NTP Version 3 as now specified and deployed in the\n   Internet, as well as NTP Version 4 now under development. The access\n   paradigm is identical to the UDP/TIME Protocol and, in fact, it\n   should be easily possible to adapt a UDP/TIME client implementation,\n   say for a personal computer, to operate using SNTP. Moreover, SNTP is\n   also designed to operate in a dedicated server configuration\n   including an integrated radio clock. With careful design and control\n   of the various latencies in the system, which is practical in a\n   dedicated design, it is possible to deliver time accurate to the\n\n\n\nMills                        Informational                      \u00ddPage 2\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   order of microseconds.\n\n   SNTP Version 4 is designed to coexist with existing NTP and SNTP\n   Version 3 clients and servers, as well as proposed Version 4 clients\n   and servers. When operating with current and previous versions of NTP\n   and SNTP, SNTP Version 4 requires no changes to the protocol or\n   implementations now running or likely to be implemented specifically\n   for NTP ir SNTP Version 4. To a NTP or SNTP server, NTP and SNTP\n   clients are undistinguishable; to a NTP or SNTP client, NTP and SNTP\n   servers are undistinguishable. Like NTP servers operating in non-\n   symmetric modes, SNTP servers are stateless and can support large\n   numbers of clients; however, unlike most NTP clients, SNTP clients\n   normally operate with only a single server. NTP and SNTP Version 3\n   servers can operate in unicast and multicast modes. In addition, SNTP\n   Version 4 clients and servers can implement extensions to operate in\n   anycast mode.\n\n   It is strongly recommended that SNTP be used only at the extremities\n   of the synchronization subnet. SNTP clients should operate only at\n   the leaves (highest stratum) of the subnet and in configurations\n   where no NTP or SNTP client is dependent on another SNTP client for\n   synchronization. SNTP servers should operate only at the root\n   (stratum 1) of the subnet and then only in configurations where no\n   other source of synchronization other than a reliable radio or modem\n   time service is available. The full degree of reliability ordinarily\n   expected of primary servers is possible only using the redundant\n   sources, diverse subnet paths and crafted algorithms of a full NTP\n   implementation. This extends to the primary source of synchronization\n   itself in the form of multiple radio or modem sources and backup\n   paths to other primary servers should all sources fail or the\n   majority deliver incorrect time. Therefore, the use of SNTP rather\n   than NTP in primary servers should be carefully considered.\n\n   An important provision in this document is the reinterpretation of\n   certain NTP Versino 4 header fields which provide for IPv6 and OSI\n   addressing and optional anycast extensions designed specifically for\n   multicast service. These additions are in conjunction with the\n   proposed NTP Version 4 specification, which will appear as a separate\n   document. The only difference between the current NTP Version 3 and\n   proposed NTP Version 4 header formats is the interpretation of the\n   four-octet Reference Identifier field, which is used primarily to\n   detect and avoid synchronization loops. In Version 3 and Version 4\n   primary (stratum-1) servers, this field contains the four-character\n   ASCII reference identifier defined later in this document. In Version\n   3 secondary servers and clients, it contains the 32-bit IPv4 address\n   of the synchronization source. In Version 4 secondary servers and\n   clients, it contains the low order 32 bits of the last transmit\n   timestamp received from the synchronization source.\n\n\n\nMills                        Informational                      \u00ddPage 3\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   In the case of OSI, the Connectionless Transport Service (CLTS) is\n   used \u00ddISO86\u00a8. Each SNTP packet is transmitted as tht TS-Userdata\n   parameter of a T-UNITDATA Request primitive. Alternately, the header\n   can be encapsulated in a TPDU which itself is transported using UDP\n   \u00ddDOB91\u00a8. It is not advised that NTP be operated at the upper layers\n   of the OSI stack, such as might be inferred from \u00ddFUR94\u00a8, as this\n   could seriously degrade accuracy. With the header formats defined in\n   this document, it is in principle possible to interwork between\n   servers and clients of one protocol family and another, although the\n   practical difficulties may make this inadvisable.\n\n      In the following, indented paragraphs such as this one contain\n      information not required by the formal protocol specification, but\n      considered good practice in protocol implementations.\n\n2. Operating Modes and Addressing\n\n   SNTP Version 4 can operate in either unicast (point to point),\n   multicast (point to multipoint) or anycast (multipoint to point)\n   modes. A unicast client sends a request to a designated server at its\n   unicast address and expects a reply from which it can determine the\n   time and, optionally, the roundtrip delay and local clock offset\n   relative to the server. A multicast server periodically sends a\n   unsolicited message to a designated IPv4 or IPv6 local broadcast\n   address or multicast group address and ordinarily expects no requests\n   from clients. A multicast client listens on this address and\n   ordinarily sends no requests. An anycast client sends a request to a\n   designated IPv4 or IPv6 local broadcast address or multicast group\n   address. One or more anycast servers reply with their individual\n   unicast addresses. The client binds to the first one received, then\n   continues operation in unicast mode.\n\n      Multicast servers should respond to client unicast requests, as\n      well as send unsolicited multicast messages. Multicast clients may\n      send unicast requests in order to determine the network\n      propagation delay between the server and client and then continue\n      operation in multicast mode.\n\n   In unicast mode, the client and server end-system addresses are\n   assigned following the usual IPv4, IPv6 or OSI conventions. In\n   multicast mode, the server uses a designated local broadcast address\n   or multicast group address. An IP local broadcast address has scope\n   limited to a single IP subnet, since routers do not propagate IP\n   broadcast datagrams. On the other hand, an IP multicast group address\n   has scope extending to potentially the entire Internet. The scoping,\n   routing and group membership procedures are determined by\n   considerations beyond the scope of this document. For IPv4, the IANA\n   has assigned the multicast group address 224.0.1.1 for NTP, which is\n\n\n\nMills                        Informational                      \u00ddPage 4\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   used both by multicast servers and anycast clients. NTP multicast\n   addresses for IPv6 and OSI have yet to be determined.\n\n   Multicast clients listen on the designated local broadcast address or\n   multicast group address. In the case of local broadcast addresses, no\n   further provisions are necessary. In the case of IP multicast\n   addresses, the multicast client and anycast server must implement the\n   Internet Group Management Protocol (IGMP) \u00ddDEE89\u00a8, in order that the\n   local router joins the multicast group and relays messages to the\n   IPv4 or IPv6 multicast group addresses assigned by the IANA. Other\n   than the IP addressing conventions and IGMP, there is no difference\n   in server or client operations with either the local broadcast\n   address or multicast group address.\n\n      It is important to adjust the time-to-live (TTL) field in the IP\n      header of multicast messages to a reasonable value, in order to\n      limit the network resources used by this (and any other) multicast\n      service. Only multicast clients in scope will receive multicast\n      server messages. Only cooperating anycast servers in scope will\n      reply to a client request. The engineering principles which\n      determine the proper value to be used are beyond the scope of this\n      document.\n\n   Anycast mode is designed for use with a set of cooperating servers\n   whose addresses are not known beforehand by the client. An anycast\n   client sends a request to the designated local broadcast or multicast\n   group address as described below. For this purpose, the NTP multicast\n   group address assigned by the IANA is used. One or more anycast\n   servers listen on the designated local broadcast address or multicast\n   group address. Each anycast server, upon receiving a request, sends a\n   unicast reply message to the originating client. The client then\n   binds to the first such message received and continues operation in\n   unicast mode. Subsequent replies from other anycast servers are\n   ignored.\n\n      In the case of SNTP as specified herein, there is a very real\n      vulnerability that SNTP multicast clients can be disrupted by\n      misbehaving or hostile SNTP or NTP multicast servers elsewhere in\n      the Internet, since at present all such servers use the same IPv4\n      multicast group address assigned by the IANA. Where necessary,\n      access control based on the server source address can be used to\n      select only the designated server known to and trusted by the\n      client. The use of cryptographic authentication scheme defined in\n      RFC-1305 is optional; however, implementors should be advised that\n      extensions to this scheme are planned specifically for NTP\n      multicast and anycast modes.\n\n\n\n\n\nMills                        Informational                      \u00ddPage 5\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n      While not integral to the SNTP specification, it is intended that\n      IP broadcast addresses will be used primarily in IP subnets and\n      LAN segments including a fully functional NTP server with a number\n      of dependent SNTP multicast clients on the same subnet, while IP\n      multicast group addresses will be used only in cases where the TTL\n      is engineered specifically for each service domain.\n\n      In NTP Version 3, the reference identifier was often used to\n      walk-back the synchronization subnet to the root (primary server)\n      for management purposes. In NTP Version 4, this feature is not\n      available, since the addresses are longer than 32 bits. However,\n      the intent in the protocol design was to provide a way to detect\n      and avoid loops. A peer could determine that a loop was possible\n      by comparing the contents of this field with the IPv4 destination\n      address in the same packet. A NTP Version 4 server can accomplish\n      the same thing by comparing the contents of this field with the\n      low order 32 bits of the originate timestamp in the same packet.\n      There is a small possibility of false alarm in this scheme, but\n      the false alarm rate can be minimized by randomizing the low order\n      unused bits of the transmit timestamp.\n\n3. NTP Timestamp Format\n\n   SNTP uses the standard NTP timestamp format described in RFC-1305 and\n   previous versions of that document. In conformance with standard\n   Internet practice, NTP data are specified as integer or fixed-point\n   quantities, with bits numbered in big-endian fashion from 0 starting\n   at the left, or high-order, position. Unless specified otherwise, all\n   quantities are unsigned and may occupy the full field width with an\n   implied 0 preceding bit 0.\n\n   Since NTP timestamps are cherished data and, in fact, represent the\n   main product of the protocol, a special timestamp format has been\n   established. NTP timestamps are represented as a 64-bit unsigned\n   fixed-point number, in seconds relative to 0h on 1 January 1900. The\n   integer part is in the first 32 bits and the fraction part in the\n   last 32 bits. In the fraction part, the non-significant low order can\n   be set to 0.\n\n      It is advisable to fill the non-significant low order bits of the\n      timestamp with a random, unbiased bitstring, both to avoid\n      systematic roundoff errors and as a means of loop detection and\n      replay detection (see below). One way of doing this is to generate\n      a random bitstring in a 64-bit word, then perform an arithmetic\n      right shift a number of bits equal to the number of significant\n      bits of the timestamp, then add the result to the original\n      timestamp.\n\n\n\n\nMills                        Informational                      \u00ddPage 6\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   This format allows convenient multiple-precision arithmetic and\n   conversion to UDP/TIME representation (seconds), but does complicate\n   the conversion to ICMP Timestamp message representation, which is in\n   milliseconds. The maximum number that can be represented is\n   4,294,967,295 seconds with a precision of about 200 picoseconds,\n   which should be adequate for even the most exotic requirements.\n\n                        1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                           Seconds                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                  Seconds Fraction (0-padded)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   Note that, since some time in 1968 (second 2,147,483,648) the most\n   significant bit (bit 0 of the integer part) has been set and that the\n   64-bit field will overflow some time in 2036 (second 4,294,967,296).\n   Should NTP or SNTP be in use in 2036, some external means will be\n   necessary to qualify time relative to 1900 and time relative to 2036\n   (and other multiples of 136 years). There will exist a 200-picosecond\n   interval, henceforth ignored, every 136 years when the 64-bit field\n   will be 0, which by convention is interpreted as an invalid or\n   unavailable timestamp.\n\n      As the NTP timestamp format has been in use for the last 17 years,\n      it remains a possibility that it will be in use 40 years from now\n      when the seconds field overflows. As it is probably inappropriate\n      to archive NTP timestamps before bit 0 was set in 1968, a\n      convenient way to extend the useful life of NTP timestamps is the\n      following convention: If bit 0 is set, the UTC time is in the\n      range 1968-2036 and UTC time is reckoned from 0h 0m 0s UTC on 1\n      January 1900. If bit 0 is not set, the time is in the range 2036-\n      2104 and UTC time is reckoned from 6h 28m 16s UTC on 7 February\n      2036. Note that when calculating the correspondence, 2000 is not a\n      leap year. Note also that leap seconds are not counted in the\n      reckoning.\n\n4. NTP Message Format\n\n   Both NTP and SNTP are clients of the User Datagram Protocol (UDP)\n   \u00ddPOS80\u00a8, which itself is a client of the Internet Protocol (IP)\n   \u00ddDAR81\u00a8. The structure of the IP and UDP headers is described in the\n   cited specification documents and will not be detailed further here.\n   The UDP port number assigned to NTP is 123, which should be used in\n   both the Source Port and Destination Port fields in the UDP header.\n   The remaining UDP header fields should be set as described in the\n   specification.\n\n\n\nMills                        Informational                      \u00ddPage 7\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   Below is a description of the NTP/SNTP Version 4 message format,\n   which follows the IP and UDP headers. This format is identical to\n   that described in RFC-1305, with the exception of the contents of the\n   reference identifier field. The header fields are defined as follows:\n\n                           1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |LI | VN  |Mode |    Stratum    |     Poll      |   Precision   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                          Root Delay                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                       Root Dispersion                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                     Reference Identifier                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               |\n      |                   Reference Timestamp (64)                    |\n      |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               |\n      |                   Originate Timestamp (64)                    |\n      |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               |\n      |                    Receive Timestamp (64)                     |\n      |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               |\n      |                    Transmit Timestamp (64)                    |\n      |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                 Key Identifier (optional) (32)                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               |\n      |                                                               |\n      |                 Message Digest (optional) (128)               |\n      |                                                               |\n      |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   As described in the next section, in SNTP most of these fields are\n   initialized with pre-specified data. For completeness, the function\n   of each field is briefly summarized below.\n\n\n\n\n\n\n\nMills                        Informational                      \u00ddPage 8\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   Leap Indicator (LI): This is a two-bit code warning of an impending\n   leap second to be inserted/deleted in the last minute of the current\n   day, with bit 0 and bit 1, respectively, coded as follows:\n\n      LI       Value     Meaning\n      -------------------------------------------------------\n      00       0         no warning\n      01       1         last minute has 61 seconds\n      10       2         last minute has 59 seconds)\n      11       3         alarm condition (clock not synchronized)\n\n   Version Number (VN): This is a three-bit integer indicating the\n   NTP/SNTP version number. The version number is 3 for Version 3 (IPv4\n   only) and 4 for Version 4 (IPv4, IPv6 and OSI). If necessary to\n   distinguish between IPv4, IPv6 and OSI, the encapsulating context\n   must be inspected.\n\n   Mode: This is a three-bit integer indicating the mode, with values\n   defined as follows:\n\n      Mode     Meaning\n      ------------------------------------\n      0        reserved\n      1        symmetric active\n      2        symmetric passive\n      3        client\n      4        server\n      5        broadcast\n      6        reserved for NTP control message\n      7        reserved for private use\n\n   In unicast and anycast modes, the client sets this field to 3\n   (client) in the request and the server sets it to 4 (server) in the\n   reply. In multicast mode, the server sets this field to 5\n   (broadcast).\n\n   Stratum: This is a eight-bit unsigned integer indicating the stratum\n   level of the local clock, with values defined as follows:\n\n      Stratum  Meaning\n      ----------------------------------------------\n      0        unspecified or unavailable\n      1        primary reference (e.g., radio clock)\n      2-15     secondary reference (via NTP or SNTP)\n      16-255   reserved\n\n\n\n\n\n\nMills                        Informational                      \u00ddPage 9\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   Poll Interval: This is an eight-bit signed integer indicating the\n   maximum interval between successive messages, in seconds to the\n   nearest power of two. The values that can appear in this field\n   presently range from 4 (16 s) to 14 (16284 s); however, most\n   applications use only the sub-range 6 (64 s) to 10 (1024 s).\n\n   Precision: This is an eight-bit signed integer indicating the\n   precision of the local clock, in seconds to the nearest power of two.\n   The values that normally appear in this field range from -6 for\n   mains-frequency clocks to -20 for microsecond clocks found in some\n   workstations.\n\n   Root Delay: This is a 32-bit signed fixed-point number indicating the\n   total roundtrip delay to the primary reference source, in seconds\n   with fraction point between bits 15 and 16. Note that this variable\n   can take on both positive and negative values, depending on the\n   relative time and frequency offsets. The values that normally appear\n   in this field range from negative values of a few milliseconds to\n   positive values of several hundred milliseconds.\n\n   Root Dispersion: This is a 32-bit unsigned fixed-point number\n   indicating the nominal error relative to the primary reference\n   source, in seconds with fraction point between bits 15 and 16. The\n   values that normally appear in this field range from 0 to several\n   hundred milliseconds.\n\n   Reference Identifier: This is a 32-bit bitstring identifying the\n   particular reference source. In the case of NTP Version 3 or Version\n   4 stratum-0 (unspecified) or stratum-1 (primary) servers, this is a\n   four-character ASCII string, left justified and zero padded to 32\n   bits. In NTP Version 3 secondary servers, this is the 32-bit IPv4\n   address of the reference source. In NTP Version 4 secondary servers,\n   this is the low order 32 bits of the latest transmit timestamp of the\n   reference source. NTP primary (stratum 1) servers should set this\n   field to a code identifying the external reference source according\n   to the following list. If the external reference is one of those\n   listed, the associated code should be used. Codes for sources not\n   listed can be contrived as appropriate.\n\n\n\n\n\n\n\n\n\n\n\n\n\nMills                        Informational                     \u00ddPage 10\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n      Code     External Reference Source\n      ----------------------------------------------------------------\n      LOCL     uncalibrated local clock used as a primary reference for\n               a subnet without external means of synchronization\n      PPS      atomic clock or other pulse-per-second source\n               individually calibrated to national standards\n      ACTS     NIST dialup modem service\n      USNO     USNO modem service\n      PTB      PTB (Germany) modem service\n      TDF      Allouis (France) Radio 164 kHz\n      DCF      Mainflingen (Germany) Radio 77.5 kHz\n      MSF      Rugby (UK) Radio 60 kHz\n      WWV      Ft. Collins (US) Radio 2.5, 5, 10, 15, 20 MHz\n      WWVB     Boulder (US) Radio 60 kHz\n      WWVH     Kaui Hawaii (US) Radio 2.5, 5, 10, 15 MHz\n      CHU      Ottawa (Canada) Radio 3330, 7335, 14670 kHz\n      LORC     LORAN-C radionavigation system\n      OMEG     OMEGA radionavigation system\n      GPS      Global Positioning Service\n      GOES     Geostationary Orbit Environment Satellite\n\n   Reference Timestamp: This is the time at which the local clock was\n   last set or corrected, in 64-bit timestamp format.\n\n   Originate Timestamp: This is the time at which the request departed\n   the client for the server, in 64-bit timestamp format.\n\n   Receive Timestamp: This is the time at which the request arrived at\n   the server, in 64-bit timestamp format.\n\n   Transmit Timestamp: This is the time at which the reply departed the\n   server for the client, in 64-bit timestamp format.\n\n   Authenticator (optional): When the NTP authentication scheme is\n   implemented, the Key Identifier and Message Digest fields contain the\n   message authentication code (MAC) information defined in Appendix C\n   of RFC-1305.\n\n5. SNTP Client Operations\n\n   A SNTP client can operate in multicast mode, unicast mode or anycast\n   mode. In multicast mode, the client sends no request and waits for a\n   broadcast (mode 5) from a designated multicast server. In unicast\n   mode, the client sends a request (mode 3) to a designated unicast\n   server and expects a reply (mode 4) from that server. In anycast\n   mode, the client sends a request (mode 3) to a designated local\n   broadcast or multicast group address and expects a reply (mode 4)\n   from one or more anycast servers. The client uses the first reply\n\n\n\nMills                        Informational                     \u00ddPage 11\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   received to establish the particular server for subsequent unicast\n   operations. Later replies from this server (duplicates) or any other\n   server are ignored. Other than the selection of address in the\n   request, the operations of anycast and unicast clients are identical.\n   Requests are normally sent at intervals from 64 s to 1024 s,\n   depending on the frequency tolerance of the client clock and the\n   required accuracy.\n\n   A unicast or anycast client initializes the NTP message header, sends\n   the request to the server and strips the time of day from the\n   Transmit Timestamp field of the reply. For this purpose, all of the\n   NTP header fields shown above can be set to 0, except the first octet\n   and (optional) Transmit Timestamp fields. In the first octet, the LI\n   field is set to 0 (no warning) and the Mode field is set to 3\n   (client). The VN field must agree with the version number of the\n   NTP/SNTP server; however, Version 4 servers will also accept previous\n   versions. Version 3 (RFC-1305) and Version 2 (RFC-1119) servers\n   already accept all previous versions, including Version 1 (RFC-1059).\n   Note that Version 0 (RFC-959) is no longer supported by any other\n   version.\n\n   Since there will probably continue to be NTP and SNTP servers of all\n   four versions interoperating in the Internet, careful consideration\n   should be given to the version used by SNTP Version 4 clients. It is\n   recommended that clients use the latest version known to be supported\n   by the selected server in the interest of the highest accuracy and\n   reliability. SNTP Version 4 clients can interoperate with all\n   previous version NTP and SNTP servers, since the header fields used\n   by SNTP clients are unchanged. Version 4 servers are required to\n   reply in the same version as the request, so the VN field of the\n   request also specifies the version of the reply.\n\n   While not necessary in a conforming client implementation, in unicast\n   and anycast modes it highly recommended that the transmit timestamp\n   in the request is set to the time of day according to the client\n   clock in NTP timestamp format. This allows a simple calculation to\n   determine the propagation delay between the server and client and to\n   align the local clock generally within a few tens of milliseconds\n   relative to the server. In addition, this provides a simple method to\n   verify that the server reply is in fact a legitimate response to the\n   specific client request and avoid replays. In multicast mode, the\n   client has no information to calculate the propagation delay or\n   determine the validity of the server, unless the NTP authentication\n   scheme is used.\n\n   To calculate the roundtrip delay d and local clock offset t relative\n   to the server, the client sets the transmit timestamp in the request\n   to the time of day according to the client clock in NTP timestamp\n\n\n\nMills                        Informational                     \u00ddPage 12\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   format. The server copies this field to the originate timestamp in\n   the reply and sets the receive timestamp and transmit timestamp to\n   the time of day according to the server clock in NTP timestamp\n   format.\n\n   When the server reply is received, the client determines a\n   Destination Timestamp variable as the time of arrival according to\n   its clock in NTP timestamp format. The following table summarizes the\n   four timestamps.\n\n      Timestamp Name          ID   When Generated\n      ------------------------------------------------------------\n      Originate Timestamp     T1   time request sent by client\n      Receive Timestamp       T2   time request received by server\n      Transmit Timestamp      T3   time reply sent by server\n      Destination Timestamp   T4   time reply received by client\n\n   The roundtrip delay d and local clock offset t are defined as\n\n      d = (T4 - T1) - (T2 - T3)     t = ((T2 - T1) + (T3 - T4)) / 2.\n\n   The following table summarizes the SNTP client operations in unicast,\n   anycast and multicast modes. The recommended error checks are shown\n   in the Reply and Multicast columns in the table. The message should\n   be considered valid only if all the fields shown contain values in\n   the respective ranges. Whether to believe the message if one or more\n   of the fields marked \"ignore\" contain invalid values is at the\n   discretion of the implementation.\n\n      Field Name              Unicast/Anycast          Multicast\n                              Request    Reply\n      ----------------------------------------------------------\n      LI                      0          0-2           0-2\n      VN                      1-4        copied from   1-4\n                                         request\n      Mode                    3          4             5\n      Stratum                 0          1-14          1-14\n      Poll                    0          ignore        ignore\n      Precision               0          ignore        ignore\n      Root Delay              0          ignore        ignore\n      Root Dispersion         0          ignore        ignore\n      Reference Identifier    0          ignore        ignore\n      Reference Timestamp     0          ignore        ignore\n      Originate Timestamp     0          (see text)    ignore\n      Receive Timestamp       0          (see text)    ignore\n      Transmit Timestamp      (see text) nonzero       nonzero\n      Authenticator           optional   optional      optional\n\n\n\n\nMills                        Informational                     \u00ddPage 13\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n6. SNTP Server Operations\n\n   A SNTP Version 4 server operating with either a NTP or SNTP client of\n   the same or previous versions retains no persistent state. Since a\n   SNTP server ordinarily does not implement the full set of NTP\n   algorithms intended to support redundant peers and diverse network\n   paths, a SNTP server should be operated only in conjunction with a\n   source of external synchronization, such as a reliable radio clock or\n   telephone modem. In this case it always operates as a primary\n   (stratum 1) server.\n\n   A SNTP server can operate in unicast mode, anycast mode, multicast\n   mode or any combination of these modes. In unicast and anycast modes,\n   the server receives a request (mode 3), modifies certain fields in\n   the NTP header, and sends a reply (mode 4), possibly using the same\n   message buffer as the request. In anycast mode, the server listens on\n   the designated local broadcast or multicast group address assigned by\n   the IANA, but uses its own unicast address in the source address\n   field of the reply. Other than the selection of address in the reply,\n   the operations of anycast and unicast servers are identical.\n   Multicast messages are normally sent at poll intervals from 64 s to\n   1024 s, depending on the expected frequency tolerance of the client\n   clocks and the required accuracy.\n\n   In unicast and anycast modes, the VN and Poll fields of the request\n   are copied intact to the reply. If the Mode field of the request is 3\n   (client), it is set to 4 (server) in the reply; otherwise, this field\n   is set to 2 (symmetric passive) in order to conform to the NTP\n   specification. This allows clients configured in symmetric active\n   (mode 1) to interoperate successfully, even if configured in possibly\n   suboptimal ways. In multicast (unsolicited) mode, the VN field is set\n   to 4, the Mode field is set to 5 (broadcast), and the Poll field set\n   to the nearest integer base-2 logarithm of the poll interval.\n\n      Note that it is highly desirable that, if a server supports\n      multicast mode, it also supports unicast mode. This is so a\n      potential multicast client can calculate the propagation delay\n      using a client/server exchange prior to regular operation using\n      only multicast mode. If the server supports anycast mode, then it\n      must support unicast mode. There does not seem to be a great\n      advantage to operate both multicast and anycast modes at the same\n      time, although the protocol specification does not forbid it.\n\n   In unicast and anycast modes, the server may or may not respond if\n   not synchronized to a correctly operating radio clock, but the\n   preferred option is to respond, since this allows reachability to be\n   determined regardless of synchronization state. In multicast mode,\n   the server sends broadcasts only if synchronized to a correctly\n\n\n\nMills                        Informational                     \u00ddPage 14\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   operating reference clock.\n\n   The remaining fields of the NTP header are set in the following way.\n   Assuming the server is synchronized to a radio clock or other primary\n   reference source and operating correctly, the LI field is set to 0\n   and the Stratum field is set to 1 (primary server); if not, the\n   Stratum field is set to 0 and the LI field is set to 3. The Precision\n   field is set to reflect the maximum reading error of the local clock.\n   For all practical cases it is computed as the negative of the number\n   of significant bits to the right of the decimal point in the NTP\n   timestamp format. The Root Delay and Root Dispersion fields are set\n   to 0 for a primary server; optionally, the Root Dispersion field can\n   be set to a value corresponding to the maximum expected error of the\n   radio clock itself. The Reference Identifier is set to designate the\n   primary reference source, as indicated in the table of Section 5 of\n   this document.\n\n   The timestamp fields are set as follows. If the server is\n   unsynchronized or first coming up, all timestamp fields are set to\n   zero. If synchronized, the Reference Timestamp is set to the time the\n   last update was received from the radio clock or modem. In unicast\n   and anycast modes, the Receive Timestamp and Transmit Timestamp\n   fields are set to the time of day when the message is sent and the\n   Originate Timestamp field is copied unchanged from the Transmit\n   Timestamp field of the request. It is important that this field be\n   copied intact, as a NTP client uses it to avoid replays. In multicast\n   mode, the Originate Timestamp and Receive Timestamp fields are set to\n   0 and the Transmit Timestamp field is set to the time of day when the\n   message is sent. The following table summarizes these actions.\n\n      Field Name              Unicast/Anycast          Multicast\n                              Request    Reply\n      ----------------------------------------------------------\n      LI                      ignore     0 or 3        0 or 3\n      VN                      1-4        copied from   4\n                                         request\n      Mode                    3          2 or 4        5\n      Stratum                 ignore     1             1\n      Poll                    ignore     copied from   log2 poll\n                                         request       interval\n      Precision               ignore     -log2 server  -log2 server\n                                         significant   significant\n                                         bits          bits\n      Root Delay              ignore     0             0\n      Root Dispersion         ignore     0             0\n      Reference Identifier    ignore     source ident  source ident\n      Reference Timestamp     ignore     time of last  time of last\n                                         radio update  radio update\n\n\n\nMills                        Informational                     \u00ddPage 15\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n      Originate Timestamp     ignore     copied from   0\n                                         transmit\n                                         timestamp\n      Receive Timestamp       ignore     time of day   0\n      Transmit Timestamp      (see text) time of day   time of day\n      Authenticator           optional   optional      optional\n\n   There is some latitude on the part of most clients to forgive invalid\n   timestamps, such as might occur when first coming up or during\n   periods when the primary reference source is inoperative. The most\n   important indicator of an unhealthy server is the LI field, in which\n   a value of 3 indicates an unsynchronized condition. When this value\n   is displayed, clients should discard the server message, regardless\n   of the contents of other fields.\n\n7. Configuration and Management\n\n   Initial setup for SNTP servers and clients can be done using a\n   configuration file if a file system is available, or a serial port if\n   not. It is intended that in-service management of NTP and SNTP\n   Version 4 servers and clients be performed using SNMP and a suitable\n   MIB to be published later. Ordinarily, SNTP servers and clients are\n   expected to operate with little or no site-specific configuration,\n   other than specifying the IP address and subnet mask or OSI NSAP\n   address.\n\n   Unicast clients must be provided with the designated server name or\n   address. If a server name is used, the address of one of more DNS\n   servers must be provided. Multicast servers and anycast clients  must\n   be provided with the TTL and local broadcast or multicast group\n   address. Anycast servers and multicast clients may be configured with\n   a list of address-mask pairs for access control, so that only those\n   clients or servers known to be trusted will be used. These servers\n   and clients must implement the IGMP protocol and be provided with the\n   local broadcast or multicast group address as well. The configuration\n   data for cryptographic authentication is beyond the scope of this\n   document.\n\n   There are several scenarios which provide automatic server discovery\n   and selection for SNTP clients with no pre-specified configuration,\n   other than the IP address and subnet mask or OSI NSAP address. For a\n   IP subnet or LAN segment including a fully functional NTP server, the\n   clients can be configured for multicast mode using the local\n   broadcast address. The same approach can be used with other servers\n   using the multicast group address. In both cases, provision of an\n   access control list is a good way to insure only trusted sources can\n   be used to set the local clock.\n\n\n\n\nMills                        Informational                     \u00ddPage 16\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   In another scenario suitable for an extended network with significant\n   network propagation delays, clients can be configured for anycast\n   mode, both upon initial startup and after some period when the\n   currently selected unicast source has not been heard. Following the\n   defined protocol, the client binds to the first reply heard and\n   continues operation in unicast mode. In this mode the local clock can\n   be automatically adjusted to compensate for the propagation delay.\n\n   In still another scenario suitable for any network and where\n   multicast service is not available, the DNS can be set up with a\n   common CNAME, like time.domain.net, and a list of address records for\n   NTP servers in the same domain. Upon resolving time.domain.net and\n   obtaining the list, the client selects a server at random and begins\n   operation in unicast mode with that server. Many variations on this\n   theme are possible.\n\n8. Acknowledgements\n\n   Jeff Learman was helpful in developing the OSI model for this\n   protocol. Ajit Thyagarajan provided valuable suggestions and\n   corrections.\n\n9. References\n\n   \u00ddCOL94\u00a8 Colella, R., R. Callon, E. Gardner, Y. Rekhter, \"Guidelines\n   for OSI NSAP allocation in the Internet\", RFC 1629, NIST, May 1994.\n\n   \u00ddDAR81\u00a8 Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n   USC Information Sciences Institute, September 1981.\n\n   \u00ddDEE89\u00a8 Deering, S., \"Host extensions for IP multicasting\", STD 5,\n   RFC 1112, Stanford University, August 1989.\n\n   \u00ddDEE96\u00a8 Deering, S., R. Hinden, \"Internet Protocol, Version 6 (IPv6)\n   Specification\", RFC 1883, Xerox and Ipsilon, January 1996.\n\n   \u00ddDOB91\u00a8 Dobbins, K, W. Haggerty, C. Shue, \"OSI connectionless\n   transport services on top of UDP - Version: 1\", RFC 1240, Open\n   Software Foundation, June 1991.\n\n   \u00ddEAS95\u00a8 Eastlake, D., 3rd., and C. Kaufman, \"Domain Name System\n   Security Extensions\", Work in Progress.\n\n   \u00ddFUR94\u00a8 Furniss, P., \"Octet sequences for upper-layer OSI to support\n   basic communications applications\", RFC 1698, Consultant,\n   October 1994.\n\n\n\n\n\nMills                        Informational                     \u00ddPage 17\u00a8\n\nRFC 2030             SNTPv4 for IPv4, IPv6 and OSI          October 1996\n\n\n   \u00ddHIN96\u00a8 Hinden, R., and S. Deering, \"IP Version 6 addressing\n   Architecture\", RFC 1884, Ipsilon and Xerox, January 1996.\n\n   \u00ddISO86\u00a8 International Standards 8602 - Information Processing Systems\n   - OSI: Connectionless Transport Protocol Specification. International\n   Standards Organization, December 1986.\n\n   \u00ddMIL92\u00a8 Mills, D., \"Network Time Protocol (Version 3) specification,\n   implementation and analysis\", RFC 1305, University of Delaware,\n   March 1992.\n\n   \u00ddPAR93\u00a8 Partridge, C., T. Mendez and W. Milliken, \"Host anycasting\n   service\", RFC 1546, Bolt Beranek Newman, November 1993.\n\n   \u00ddPOS80\u00a8 Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n   USC Information Sciences Institute, August 1980.\n\n   \u00ddPOS83\u00a8 Postel, J., \"Time Protocol\", STD 26, RFC 868,\n   USC Information Sciences Institute, May 1983.\n\nSecurity Considerations\n\n   Security issues are not discussed in this memo.\n\nAuthor's Address\n\n   David L. Mills\n   Electrical Engineering Department\n   University of Delaware\n   Newark, DE 19716\n\n   Phone: (302) 831-8247\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMills                        Informational                     \u00ddPage 18\u00a8\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RUNJOB": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00!\\x01\\x01$\\x1f\\x01\\x03\\x13o\\x13)\\x00\\x0f\\x00\\x1e\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-08-29T00:00:00", "modifydate": "2003-05-16T13:29:21", "lines": 15, "newlines": 30, "modlines": 0, "user": "FAJA"}, "text": "//jobname  JOB ,'SNTP',CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*--------------------------------------------------------------------*\n//*        Set installation specific dataset names here...\n//*--------------------------------------------------------------------*\n//*\n//         SET LIB=your.load.library\n//*\n//*--------------------------------------------------------------------*\n//*        Go\n//*--------------------------------------------------------------------*\n//SNTP    EXEC PGM=SNTPD,PARM='LOGGING LEVEL IS 30'\n//STEPLIB   DD DISP=SHR,DSN=&LIB\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RUNPROC": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\"\\x01\\x01%o\\x01\\x03\\x13o\\x13)\\x00\\r\\x00\\t\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-09-13T00:00:00", "modifydate": "2003-05-16T13:29:22", "lines": 13, "newlines": 9, "modlines": 0, "user": "FAJA"}, "text": "//jobname  JOB ,'SNTP',CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*--------------------------------------------------------------------*\n//*        Set installation specific dataset names here...\n//*--------------------------------------------------------------------*\n//*\n//         SET LIB=your.load.library\n//*\n//*--------------------------------------------------------------------*\n//*        Go\n//*--------------------------------------------------------------------*\n//SNTP    EXEC PROC=TCPSNTP\n//STEPLIB   DD DISP=SHR,DSN=&LIB\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SAY": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00I\\x00\\x990/\\x01\\x012_\\x14\\t\\x01\\x10\\x00\\xad\\x00\\x00\\xe3\\xe9\\xc1\\xd9\\xd4\\xe2@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1999-10-29T00:00:00", "modifydate": "2001-11-21T14:09:49", "lines": 272, "newlines": 173, "modlines": 0, "user": "TZARMS"}, "text": "         MACRO\n&sLabel  SAY   &BUFFER=,&WRITER=Say\n.**********************************************************************\n.*                                                                   **\n.* FUNCTION - Generate code to format and write a message.  Writing  **\n.*            of the generated message is accomplished by a call to  **\n.*            the routine specified by &WRITER (which returns on R10).*\n.*                                                                   **\n.* ON ENTRY - &BUFFER  = Label of storage to receive result.  If     **\n.*                       specified then Say is not called (allowing  **\n.*                       a message to be built at that location),    **\n.*                       else the message is built at sMsgText and   **\n.*                       Say is called to write it.                  **\n.*                                                                   **\n.*            &WRITER  = Label of routine to be called to write the  **\n.*                       message to its ultimate destination.        **\n.*                                                                   **\n.*            &SYSLIST = Message to be formatted.  Variables in the  **\n.*                       message are identified by a '%' prefix.     **\n.*                       To force a hex conversion, use a # prefix.  **\n.*                       To dereference a pointer, use a * prefix.   **\n.*                       To specify a register, use an R prefix.     **\n.*                                                                   **\n.* EXAMPLES -         SAY 'Hi' - Writes 'Hi' to CSML.                **\n.*                                                                   **\n.*                    Hello   DC   C'Hi'                             **\n.*                    SAY '%Hello' - Writes 'Hi' to CSML.            **\n.*                    SAY '#Hello' - Writes 'C889' to CSML.          **\n.*                                                                   **\n.*                    SAY '%R2' - Writes hex contents of register 2  **\n.*                                to CSML.                           **\n.*                                                                   **\n.*                    SAY '%*R2' - Writes hex contents of 4 bytes of **\n.*                                data addressed by R2 to CSML.      **\n.*                                                                   **\n.**********************************************************************\n\n         LCLA  &i,&j,&nFormat,&nBeg,&nLen,&nOff,&nLists,&nList\n         LCLA  &nSrcOff\n         LCLB  &bTrail\n         LCLC  &sFormat,&s,&sType,&sTarget,&sPrefix,&sESC\n\n&nLists  SETA  N'&SYSLIST\n&sTarget SETC  'sMsgText'\n&nOff    SETA  0\n&bTrail  SETB  0\n&nList   SETA  0\n\n         AIF   ('&sLabel' EQ '').NOLABEL\n&sLabel  DS    0H\n.NOLABEL ANOP\n\n.*--------------------------------------------------------------------*\n.*       For each sublist eg SAY (s1a,s1b,(s2a,s2b,s2c))\n.*--------------------------------------------------------------------*\n\n.NEXTS   ANOP\n&nList   SETA  &nList+1\n         AIF   (&nList GT &nLists).SAY\n&sFormat SETC  '&SYSLIST(&nList)'\n         AIF   ('&sFormat' EQ '').NEXTS\n         AIF   ('&sFormat'(1,1) NE '''').NOQUOTE\n&nLen    SETA  K'&sFormat-2\n&sFormat SETC  '&sFormat'(2,&nLen)\n.NOQUOTE ANOP\n\n&nFormat SETA  K'&sFormat\n&nBeg    SETA  1\n\n.*--------------------------------------------------------------------*\n.*       For each character\n.*--------------------------------------------------------------------*\n\n.NEXTC   ANOP\n&nLen    SETA  0\n&i       SETA  &nBeg\n\n.NEXTCHR ANOP\n         AIF   (&i GT &nFormat).END\n&sESC    SETC  '&sFormat'(&i,1)\n         AIF   ('&sESC' EQ '%').VAR\n         AIF   ('&sESC' EQ '#').VAR\n&i       SETA  &i+1\n&nLen    SETA  &nLen+1\n         AGO   .NEXTCHR\n\n.*--------------------------------------------------------------------*\n.*       Variable prefix found (ie #name or %name)\n.*--------------------------------------------------------------------*\n\n.VAR     ANOP\n         AIF   (&nLen EQ 0).LEN0\n&bTrail  SETB  0\n&s       SETC  '&sFormat'(&nBeg,&nLen)\n         AIF   (&nLen EQ 1).LEN1\n         MVC   &sTarget+&nOff.(&nLen),=C'&s'\n         AGO   .LEN0\n\n.LEN1    ANOP\n         MVI   &sTarget+&nOff,C'&s'\n         AGO   .LEN0\n\n.LEN0    ANOP\n&nOff    SETA  &nOff+&nLen\n&nBeg    SETA  &i+1\n&i       SETA  &nBeg\n&nLen    SETA  0\n\n.*--------------------------------------------------------------------*\n.*       Determine end of variable name\n.*--------------------------------------------------------------------*\n\n.NEXTV   ANOP\n         AIF   (&i GT &nFormat).VAREND\n&s       SETC  '&sFormat'(&i,1)\n         AIF   ('&s' EQ '@').VARCONT,                                  X\n               ('&s' EQ '$').VARCONT,                                  X\n               ('&s' EQ '*').VARCONT,                                  X\n               ('&s' EQ '_').VARCONT,                                  X\n               ('&s' LT 'a').VAREND   Cheap and nasty\n.VARCONT ANOP\n&i       SETA  &i+1\n&nLen    SETA  &nLen+1\n         AGO   .NEXTV\n\n.VAREND  ANOP\n&s       SETC  '&sFormat'(&nBeg,&nLen)\n\n.*--------------------------------------------------------------------*\n.*       Process variable depending on its type and/or prefix\n.*--------------------------------------------------------------------*\n\n&nBeg    SETA  &i\n&sType   SETC  T'&s\n&sPrefix SETC  '&s'(1,1)\n         MNOTE *,'Esc <&sESC> Var <&s> Prefix <&sPrefix> Type <&sType>'\n         AIF   ('&sPrefix' EQ 'R').REG,          Register              X\n               ('&sPrefix' EQ '*').DEREF,        Dereference first     X\n               ('&sESC' EQ '#').X,               Force hex             X\n               ('&sType' EQ 'C').C,              Character string      X\n               ('&sType' EQ 'H').H,              Halfword              X\n               ('&sType' EQ 'F').F,              Fullword              X\n               ('&sType' EQ 'A').F,              Address=Fullword      X\n               ('&sType' EQ 'X').X,              Hex string            X\n               ('&sType' EQ 'B').X,              Binary string         X\n               ('&sType' EQ 'D').C               Double word\n         MNOTE 8,'Unsupported data type &sType for &s'\n         AGO   .END\n\n.*--------------------------------------------------------------------*\n.*       Register\n.*--------------------------------------------------------------------*\n\n.REG     ANOP\n         ST    &s,dWork\n         C2X   &sTarget+&nOff,dWork,4,NOTRAIL\n&bTrail  SETB  1\n&nOff    SETA  &nOff+2*4\n         AGO   .NEXTC\n\n.*--------------------------------------------------------------------*\n.*       Dereference\n.*--------------------------------------------------------------------*\n\n.DEREF   ANOP\n&s       SETC  '&s'(2,*)\n         AIF   (T'&s EQ 'U').DEREFR\n         L     R1,&s\n         UNPK  &sTarget+&nOff.(2*4+1),0(4+1,R1)\n         TR    &sTarget+&nOff.(2*4),=C'0123456789ABCDEF'-C'0'\n&bTrail  SETB  1\n&nOff    SETA  &nOff+8\n         AGO   .NEXTC\n\n.DEREFR  ANOP\n         UNPK  &sTarget+&nOff.(2*4+1),0(4+1,&s)\n         TR    &sTarget+&nOff.(2*4),=C'0123456789ABCDEF'-C'0'\n&bTrail  SETB  1\n&nOff    SETA  &nOff+2*4\n         AGO   .NEXTC\n\n.*--------------------------------------------------------------------*\n.*       Fullword\n.*--------------------------------------------------------------------*\n\n.F       ANOP\n         C2X   &sTarget+&nOff,&s,4,NOTRAIL\n&bTrail  SETB  1\n&nOff    SETA  &nOff+2*4\n         AGO   .NEXTC\n\n.*--------------------------------------------------------------------*\n.*       Halfword\n.*--------------------------------------------------------------------*\n\n.H       ANOP\n         C2X   &sTarget+&nOff,&s,2,NOTRAIL\n&bTrail  SETB  1\n&nOff    SETA  &nOff+2*2\n         AGO   .NEXTC\n\n.*--------------------------------------------------------------------*\n.*       Character (string)\n.*--------------------------------------------------------------------*\n\n.C       ANOP\n         MVC   &sTarget+&nOff.(L'&s),&s\n&nlen    SETA  L'&s\n&nOff    SETA  &nOff+&nLen\n&bTrail  SETB  0\n         AGO   .NEXTC\n\n.*--------------------------------------------------------------------*\n.*       Hex (printable)\n.*--------------------------------------------------------------------*\n\n.X       ANOP\n&nLen    SETA  L'&s\n&nSrcOff SETA  0\n.XNEXT   ANOP\n         AIF   (&nLen LE 7).XLAST\n         C2X   &sTarget+&nOff,&s+&nSrcOff,7,NOTRAIL\n&nLen    SETA  &nLen-7\n&nOff    SETA  &nOff+2*7\n&nSrcOff SETA  &nSrcOff+7\n         AGO   .XNEXT\n.XLAST   ANOP\n         C2X   &sTarget+&nOff,&s+&nSrcOff,&nLen,NOTRAIL\n&bTrail  SETB  1\n&nOff    SETA  &nOff+2*&nLen\n         AGO   .NEXTC\n\n.*--------------------------------------------------------------------*\n.*       Determine whether to append a trailing blank\n.*--------------------------------------------------------------------*\n\n.END     ANOP\n         AIF   (&nBeg GT &nFormat).NEXTS\n&nLen    SETA  &nFormat-&nBeg+1\n&s       SETC  '&sFormat'(&nBeg,&nLen)\n&bTrail  SETB  0\n         AIF   (&nLen EQ 1).TRAIL1\n         MVC   &sTarget+&nOff.(&nLen),=C'&s'\n&nOff    SETA  &nOff+&nLen\n         AGO   .NEXTS\n\n.TRAIL1  ANOP\n         MVI   &sTarget+&nOff,C'&s'\n&nOff    SETA  &nOff+&nLen\n         AGO   .NEXTS\n\n.*--------------------------------------------------------------------*\n.*       Copy result to the specified buffer\n.*--------------------------------------------------------------------*\n\n.SAY     ANOP\n         AIF  (NOT &bTrail).JUSTSAY\n         MVI   &sTarget+&nOff,C' '\n\n.JUSTSAY ANOP\n         AIF   ('&BUFFER' EQ '').NIKE\n         MVC   &BUFFER,&sTarget\n         AGO   .EXIT\n\n.*--------------------------------------------------------------------*\n.*       Call the 'Say' routine to process the buffer\n.*--------------------------------------------------------------------*\n\n.NIKE    ANOP\n         BRAS  R10,&WRITER\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNTPD": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x01\\x033\\x9f\\x01\\x033\\x9f\\x16)\\x076\\x075\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-12-05T00:00:00", "modifydate": "2003-12-05T16:29:15", "lines": 1846, "newlines": 1845, "modlines": 0, "user": "FAJA"}, "text": "***********************************************************************\n*                                                                     *\n* SNTPD v1.2 - Simple Network Time Protocol server                    *\n*                                                                     *\n* Copyright (C) 2003 Andrew J. Armstrong                              *\n* a.armstrong@optusnet.com.au                                         *\n*                                                                     *\n* This program is free software; you can redistribute it and/or modify*\n* it under the terms of the GNU General Public License as published by*\n* the Free Software Foundation; either version 2 of the License, or   *\n* (at your option) any later version.                                 *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License for more details.                        *\n* You should have received a copy of the GNU General Public License   *\n* along with this program; if not, write to the Free Software         *\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307*\n*                                                                     *\n***********************************************************************\n***********************************************************************\n**                                                                   **\n** NAME     - SNTPD                                                  **\n**                                                                   **\n** TITLE    - SIMPLE NETWORK TIME DAEMON (SNTPD)                     **\n**                                                                   **\n** VERSION  - 1.2                                                    **\n**                                                                   **\n** FUNCTION - This is a Simple Network Time Protocol (SNTPv3)        **\n**            server as defined by RFC2030 (which defines SNTPv4,    **\n**            but this server does not implement any of the SNTPv4   **\n**            optional extensions).                                  **\n**                                                                   **\n**            This SNTP server listens for UDP packets on port 123   **\n**            and responds the current TOD clock time to any NTP v1, **\n**            v2, v3, or v4 client to a precision of 2 microseconds. **\n**                                                                   **\n**                                                                   **\n** LOGIC    - 0. Initialise TCP sockets.                             **\n**                                                                   **\n**            1. Execute any command supplied on the EXEC PARM.      **\n**                                                                   **\n**            2. Execute any command supplied on the START command.  **\n**                                                                   **\n**            3. Wait next incoming UDP packet or operator command.  **\n**                                                                   **\n**            4. If a UDP packet has arrived:                        **\n**                                                                   **\n**               a. Receive it.                                      **\n**                                                                   **\n**               b. Store current time and build a reply UDP packet. **\n**                                                                   **\n**               c. Send reply packet.                               **\n**                                                                   **\n**            5. If an operator command was issued:                  **\n**                                                                   **\n**               a. Execute the operator command.                    **\n**                                                                   **\n**            6. Repeat 3-to-5 until operator stops/cancels task.    **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1. The assembler variable naming convention used is:   **\n**                                                                   **\n**               Prefix DS      Meaning            Content example   **\n**               ------ ------- ------------------ ---------------   **\n**                 n    F       Fullword number    F'-123'           **\n**                 h    H       Halfword number    H'-123'           **\n**                 x    CLn     Hex string         C'09AB'           **\n**                 s    CLn     String             C'Hello'          **\n**                 c    CL1     Single character   C'A'              **\n**                 d    D       Double word        D'0'              **\n**                 p    A       Pointer            A(EXIT)           **\n**                 b    B       Boolean            B'1'              **\n**                                                                   **\n**                                                                   **\n**            2. In comments, each occurrence of '->' means          **\n**               'pointer to' or 'address of'.                       **\n**                                                                   **\n**            3. This server cannot alter the Time Of Day (TOD)      **\n**               clock. If you specify the TOD +hhmm adjustment      **\n**               command then that adjustment is applied each time a **\n**               TOD clock value is to be translated to an RFC2030   **\n**               clock value for transmission to an NTP client.      **\n**               Altering the actual hardware TOD clock requires     **\n**               operator intervention and cannot be done by a       **\n**               program alone.                                      **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R1 -> Parameter list...                                **\n**                  A(execparms) -> AL2(len),CL(len)'parm data'      **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n** BUILD JCL- Sample JCL to assemble/link is as follows:             **\n**                                                                   **\n**            //jobname  JOB ,'acct',CLASS=A,MSGCLASS=X,             **\n**            //             NOTIFY=&SYSUID                          **\n**            //*                                                    **\n**            //*--------------------------------------------------- **\n**            //*        Set installation specific stuff here...     **\n**            //*--------------------------------------------------- **\n**            //*                                                    **\n**            //         SET SRC=your.source.pds                     **\n**            //         SET LIB=your.load.library                   **\n**            //         SET SEZATCP=TCPIP.SEZATCP                   **\n**            //*                                                    **\n**            //*--------------------------------------------------- **\n**            //*        Assemble                                    **\n**            //*--------------------------------------------------- **\n**            //*                                                    **\n**            //ASM     EXEC PGM=ASMA90,PARM='OBJECT,NODECK'         **\n**            //SYSLIB    DD DISP=SHR,DSN=SYS1.MODGEN                **\n**            //          DD DISP=SHR,DSN=SYS1.MACLIB                **\n**            //          DD DISP=SHR,DSN=&SEZATCP                   **\n**            //          DD DISP=SHR,DSN=&SRC                       **\n**            //SYSUT1    DD DSN=&&SYSUT1,                           **\n**            //             SPACE=(4096,(120,120),,,ROUND),         **\n**            //             UNIT=VIO,DCB=BUFNO=1                    **\n**            //SYSPRINT  DD SYSOUT=*                                **\n**            //SYSLIN    DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND), **\n**            //             UNIT=VIO,DISP=(MOD,PASS),               **\n**            //             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,   **\n**            //             BUFNO=1)                                **\n**            //SYSIN     DD DISP=SHR,DSN=&SRC(SNTPD)                **\n**            //          DD DISP=SHR,DSN=&SRC(GETCMD)               **\n**            //*                                                    **\n**            //*--------------------------------------------------- **\n**            //*        Link                                        **\n**            //*--------------------------------------------------- **\n**            //*                                                    **\n**            //LINK    EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL,AC=1', **\n**            //             COND=(8,LT,ASM)                         **\n**            //SYSLIB    DD DISP=SHR,DSN=&SEZATCP                   **\n**            //SYSLIN    DD  DSN=&&OBJ,DISP=(OLD,DELETE)            **\n**            //          DD  DDNAME=SYSIN                           **\n**            //SYSIN     DD *                                       **\n**                INCLUDE SYSLIB(EZASOKET)                           **\n**                NAME    SNTPD(R)                                   **\n**            /*                                                     **\n**            //SYSLMOD   DD DISP=SHR,DSN=&LIB                       **\n**            //SYSUT1    DD DSN=&&SYSUT1,                           **\n**            //             SPACE=(1024,(120,120),,,ROUND),         **\n**            //             UNIT=VIO,DCB=BUFNO=1                    **\n**            //SYSPRINT  DD SYSOUT=*                                **\n**                                                                   **\n** RUN JCL  - Sample started task JCL is as follows:                 **\n**                                                                   **\n**            //TCPSNTP  PROC                                        **\n**            //*                                                    **\n**            //*--------------------------------------------------- **\n**            //*        Set installation specific stuff here...     **\n**            //*--------------------------------------------------- **\n**            //*                                                    **\n**            //         SET LIB=your.load.library                   **\n**            //*                                                    **\n**            //TCPSNTP  EXEC PGM=SNTPD,REGION=0K,TIME=NOLIMIT,      **\n**            // PARM='LOG 30,NOSWAP,TOD +1000,STRATUM 2'            **\n**            //STEPLIB   DD DISP=SHR,DSN=&LIB                       **\n**            //SYSPRINT  DD SYSOUT=*                                **\n**            //SYSUDUMP  DD SYSOUT=*                                **\n**            //         PEND                                        **\n**                                                                   **\n** STARTUP  - Sample command to start the server:                    **\n**                                                                   **\n**            S TCPSNTP,,,LOGGING LEVEL IS 60                        **\n**                                                                   **\n** SHUTDOWN - Sample command to stop the server:                     **\n**                                                                   **\n**            P TCPSNTP                                              **\n**                                                                   **\n**            ...or...                                               **\n**                                                                   **\n**            F TCPSNTP,STOP                                         **\n**                                                                   **\n** COMMANDS - Operator commands supported are:                       **\n**                                                                   **\n**            F TCPSNTP,cmd                                          **\n**                                                                   **\n**            Where, cmd is:                                         **\n**                                                                   **\n**            LOG nn                                                 **\n**               Set the logging level to nn, where nn is any  numb- **\n**               er between 0 and 255 and has the following (cumul-  **\n**               ative) meanings:                                    **\n**                                                                   **\n**                0-9    NONE      No logging                        **\n**               10-19   ERROR     Error messages                    **\n**               20-24   WARNING   Warning messages                  **\n**               25-29   SUMMARY   Summary statistics                **\n**               30-39   INFO      Information, short data contents  **\n**               40-49   BANNER    Routine labels                    **\n**               50-59   DEBUG     Debugging messages                **\n**               60-255  DATA      Full data message contents        **\n**                                                                   **\n**            TOD +hhmm                                              **\n**            TOD -hhmm                                              **\n**               Set the amount of time to be added to the current   **\n**               Time Of Day (TOD) clock value to make it equal to   **\n**               UCT (GMT) time. This is to accommodate those sites  **\n**               that have their TOD clock set to local time rather  **\n**               than UCT (GMT) time.                                **\n**                                                                   **\n**               If not all digits are specified then the adjustment **\n**               is treated as follows:                              **\n**                                                                   **\n**               +m          = +000m                                 **\n**               +mm         = +00mm                                 **\n**               +hmm        = +0hmm                                 **\n**               +hhmm       = +hhmm                                 **\n**                                                                   **\n**            NOSWAP                                                 **\n**               Attempts to set the address space to run non-       **\n**               swappable. The program needs to be APF-authorized if**\n**               this to occur (i.e. linkedit with AC=1 and run from **\n**               a load library in the APFLIST).                     **\n**                                                                   **\n**            STRATUM n                                              **\n**               Set the stratum level to n, where n is from 0 to 255**\n**               as follows (from RFC 2030):                         **\n**                                                                   **\n**               Stratum  Meaning                                    **\n**               -------- -------------------------------------      **\n**               0        unspecified or unavailable                 **\n**               1        primary reference (e.g., radio clock)      **\n**               2-15     secondary reference (via NTP or SNTP)      **\n**               16-255   reserved                                   **\n**                                                                   **\n**               The default stratum is 2.                           **\n**                                                                   **\n**            SHOW                                                   **\n**               Shows the current server settings.                  **\n**                                                                   **\n** AUTHOR   - Andrew Armstrong (a.armstrong@optusnet.com.au)         **\n**            Edigar Sobreira (edigar.sobreira@eds.com)              **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date     By       Reason (most recent at the top pls)  **\n**            -------- -------- ------------------------------------ **\n**            20031205 AJA      Added SHOW command.                  **\n**            20031205 AJA      Added STRATUM command.               **\n**            20031107 Edigar   Changed the STRATUM value to 2.      **\n**            20031107 Edigar   Added F xxx,STOP possibility.        **\n**            20031107 Edigar   Added NOSWAP command.                **\n**            20031107 Edigar   Allowed multiples parm values.       **\n**            20031106 AJA      Added TOD command.                   **\n**            20011227 AJA      Added version to start up message.   **\n**            20011128 AJA      Allowed NTP V4 clients to connect.   **\n**            20011121 AJA      Added MODIFY command interface.      **\n**            20010822 AJA      Initial version.                     **\n**                                                                   **\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         R E G I S T E R S                           *\n*                                                                     *\n***********************************************************************\n\nR0       EQU   0                  Work\nR1       EQU   1                  Work\nR2       EQU   2                  Work\nR3       EQU   3                  Work\nR4       EQU   4                  Work\nR5       EQU   5                  Work\nR6       EQU   6                  Work\nR7       EQU   7                  Work\nR8       EQU   8                  Work\nR9       EQU   9                  Internal linkage\nR10      EQU   10                 Internal linkage\nR11      EQU   11                 -> CSECT+4096 (Base register 2)\nR12      EQU   12                 -> CSECT+0    (Base register 1)\nR13      EQU   13                 -> Working storage\nR14      EQU   14                 External linkage\nR15      EQU   15                 External linkage\n\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          M A I N L I N E                            *\n*                                                                     *\n***********************************************************************\n         DEBUG OFF\n\nSNTPD    AMODE 31\nSNTPD    RMODE 24                 Keep DCB below the 16MB line\nSNTPD    CSECT\nEYECATCH EYECATCH                 Put eye-catcher in CSECT storage\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         LA    R11,4095(R12)\n         LA    R11,1(R11)\n         USING SNTPD,R12,R11\n*        -------------------\n         LR    R4,R1             -> A(AL2(len),CL(len)'exec parm data')\n\n         STORAGE OBTAIN,LENGTH=WORKAREA_LENGTH,LOC=ANY\n         LTR   R15,R15\n         JNZ   Quit\n\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING WORKAREA,R13\n*        ------------------\n\n*---------------------------------------------------------------------*\n*        Initialise                                                   *\n*---------------------------------------------------------------------*\n\n         MVC   sEyeCatch,EYECATCH Put eye-catcher in working storage\n         MVC   sWorkArea,=C'WORKAREA'\n         MVC   dClockAdj,=D'0'\n         MVI   cClockSign,C'+'\n         MVI   cLogLevel,INFO Set logging level\n         MVI   cStratumReq,NTP_STRATUM_SECONDARY\n         MVI   sMsg,C' '\n         MVC   sMsg+1(L'sMsg-1),sMsg\n\n*---------------------------------------------------------------------*\n*        Open the log file                                            *\n*---------------------------------------------------------------------*\n\n         OPEN  (SYSPRINT,OUTPUT),MODE=31\n         LTR   R15,R15\n         JNZ   Release\n         LOG   'Starting time server V1.2.&SYSDATC',                   X\n               WRITER=ToLogAndOper\n\n*---------------------------------------------------------------------*\n*        Execute command in the PARM= operand of the EXEC card        *\n*---------------------------------------------------------------------*\n\n         BRAS  R10,getParmCommand\n\n*---------------------------------------------------------------------*\n*        Execute command passed on the START command                  *\n*---------------------------------------------------------------------*\n\n         BRAS  R10,getConsoleCommand\n\n*---------------------------------------------------------------------*\n*        Print activity log headings                                  *\n*---------------------------------------------------------------------*\n\n         LOG   'Source Address        Received Clock   Difference Sent X\n               Clock       TOD Clock       '\n         LOG   '--------------------- ---------------- ---------- -----X\n               ----------- ----------------'\n\n*---------------------------------------------------------------------*\n*        Create UDP socket (INITAPI will be done implicitly)          *\n*---------------------------------------------------------------------*\n\n         LOG   'Socket()',LEVEL=DEBUG\n\n         MVC   sCall,sSocket      What we are doing (for error msgs)\n\n         CALL  EZASOKET,                                               X\n               (sSocket,          Function                             X\n               nFamily,           Address family (AF_INET)             X\n               nSocType,          Socket type (DGRAM)                  X\n               nProto,            Protocol (UDP)                       X\n               nErrNo,                                                 X\n               nRetCode),                                              X\n               VL,                                                     X\n               MF=(E,sParms)\n\n         CLC   nRetCode,=F'-1'    Did it work?\n         JE    ErrSock            No, branch\n\n         MVC   hSocket,nRetCode+2 Save socket descriptor\n\n*---------------------------------------------------------------------*\n*        Bind the socket to port 123 (ntpd)                           *\n*---------------------------------------------------------------------*\n\n         LOG   'Bind()',LEVEL=DEBUG\n\n         MVC   hServerFamily,=AL2(AF_INET)\n         MVC   hServerPort,hPort             Listen on ntpd port (123)\n         MVC   nServerAddress,IN_ADDR_ANY    Listen on all interfaces\n\n         MVC   sCall,sBind        What we are doing (for error msgs)\n\n         CALL  EZASOKET,                                               X\n               (sBind,            Function                             X\n               hSocket,           Socket to bind                       X\n               sServer,           Server socket name                   X\n               nErrNo,                                                 X\n               nRetCode),                                              X\n               VL,                                                     X\n               MF=(E,sParms)\n\n         CLC   nRetCode,=F'-1'    Did it work?\n         JE    ErrBind            No, branch\n\n*---------------------------------------------------------------------*\n*        Wait for network or operator activity                        *\n*---------------------------------------------------------------------*\n\nawaitActivity LOG LEVEL=BANNER\n         MVC   sCall,sSelectEx    What we are doing (for error msgs)\n\n         LHI   R7,-1              Set mask to all ones\n         ST    R7,nOutRMask       Read mask\n         ST    R7,nOutEMask       Error mask\n\n         LHI   R7,0               Set mask to all zeros\n         ST    R7,nOutWMask       Write mask\n         ST    R7,nInRMask\n         ST    R7,nInWMask\n         ST    R7,nInEMask\n\n         L     R7,pECB            -> Console command ECB\n\n         CALL  EZASOKET,                                               X\n               (sSelectEx,        Function                             X\n               nMaxSoc,           Bit-width of masks (sort of)         X\n               dTimeOut,          Timeout  =A(seconds,microseconds)    X\n               nOutRMask,         Read mask                            X\n               nOutWMask,         Write mask                           X\n               nOutEMask,         Error mask                           X\n               nInRMask,          Sockets ready to read                X\n               nInWMask,          Sockets ready to write               X\n               nInEMask,          Sockets in error                     X\n               (R7),              -> Console command ECB               X\n               nErrNo,                                                 X\n               nRetCode),                                              X\n               VL,                                                     X\n               MF=(E,sParms)\n\n         DEBUG 'selectex() rc=#nRetCode rmask=#nInRMask emask=#nInEMaskX\n                ecb at %R7=%*R7'\n\n         L     R7,nRetCode        Get return code\n         LTR   R7,R7              Did it work?\n         JM    ErrSelect          No, branch (maybe TCPIP coming down)\n         JP    Incoming           Yes, network activity\n\n*                                 Return code is zero, so...\n         L     R7,pECB            -> Console command ECB\n         TM    0(R7),B'01000000'  Was console command ECB posted?\n         JO    Operator           Yes, process console command\n         J     TimeOut            No, must be a timeout\n\n*---------------------------------------------------------------------*\n*        Process network timeout (only if dTimeOut value is positive) *\n*---------------------------------------------------------------------*\n\nTimeOut  LOG   LEVEL=BANNER\n         J     awaitActivity\n\n*---------------------------------------------------------------------*\n*        Retrieve and execute operator command                        *\n*---------------------------------------------------------------------*\n\nOperator DS    0H\n         BRAS  R10,getConsoleCommand\n         J     awaitActivity\n\n*---------------------------------------------------------------------*\n*        Receive next incoming UDP packet                             *\n*---------------------------------------------------------------------*\n\nIncoming LOG   LEVEL=BANNER\n\n         LA    R6,L'sPacket       Maximum incoming packet length\n         LA    R7,sPacket         -> Where incoming packet is to go\n\n         BRAS  R10,RecvFrom\n\n*---------------------------------------------------------------------*\n*        Get address of sender                                        *\n*---------------------------------------------------------------------*\n\n         LH    R0,hClientPort\n         L     R1,nClientAddress\n         BRAS  R10,ntoa\n\n*---------------------------------------------------------------------*\n*        Get the current time of day clock value                      *\n*---------------------------------------------------------------------*\n\n         STCK  dClock            Bit 51 = microseconds since 1/1/1900\n\n*---------------------------------------------------------------------*\n*        Optionally, adjust the TOD value by +/-hhmm                  *\n*---------------------------------------------------------------------*\n\n         CLC   dClockAdj,=D'0'   Did the user specify an adjustment?\n         JE    NoClockAdj        No, jump\n\n         LM    R0,R1,dClock      Get TOD clock value\n         AL    R1,dClockAdj+4    Add low order word of adjustment\n         BRC   B'1100',NoCarry   Jump if no carry to account for\n         AL    R0,=F'1'          Else add carry out to high order word\nNoCarry  DS    0H\n         AL    R0,dClockAdj+0    Add high order word of adjustment\n         STM   R0,R1,dClock      Update the stored TOD clock value\n\nNoClockAdj DS  0H\n\n*---------------------------------------------------------------------*\n*        Log the arrival of a request                                 *\n*---------------------------------------------------------------------*\n\n         LOG   'Received from %sAddr at TOD #dClock',LEVEL=DEBUG\n\n*---------------------------------------------------------------------*\n*        Dump packet received (only if log level=DEBUG or higher)     *\n*---------------------------------------------------------------------*\n\n         L     R6,nByte           Length of incoming packet\n         LA    R7,sPacket         -> Data to dump\n         MVC   sMsgAction,=C'Recv'\n         BRAS  R10,Dump\n\n*---------------------------------------------------------------------*\n*       Build reply packet                                            *\n*---------------------------------------------------------------------*\n\n*        Validate version number (ignore if not 1, 2, 3, or 4)...\n         MVC   cVersion,cHeader\n         NI    cVersion,NTP_VERSION_MASK\n         CLI   cVersion,0\n         JE    awaitActivity\n         CLI   cVersion,NTP_VERSION_4                          20011128\n         JH    awaitActivity\n\n*        Set leap indicator...\n         NI    cHeader,X'FF'-NTP_LEAP_INDICATOR_MASK\n         OI    cHeader,NTP_LEAP_NO_WARNING     Set no warning\n\n*        Massage the mode according to RFC2030...\n         MVC   cMode,cHeader         Copy header\n         NI    cHeader,X'FF'-NTP_MODE_MASK  Clear mode bits in header\n         NI    cMode,NTP_MODE_MASK   Isolate mode bits\n         CLI   cMode,NTP_MODE_CLIENT Client mode?\n         JE    SetServerMode         Yes, set server mode\n         OI    cHeader,NTP_MODE_SYMETRIC_PASSIVE No, set symetric mode\n         J     GetTime\n\nSetServerMode  DS 0H\n         OI    cHeader,NTP_MODE_SERVER\n         J     GetTime\n\n*        Get the time we received the packet...\nGetTime  DS    0H\n         LM    R0,R1,dClock      R0/1=Time Of Day clock\n\n         SRDL  R0,12+1           R0/1=2us units since 1/1/1900\n         D     R0,=F'1000000'    R0=0-999999 x 2us units, R1=2s units\n         LR    R2,R1                                      R2=2s units\n\n         XR    R1,R1             R0/1=0-999999 2us units x 2**32\n         SRDL  R0,1              R0/1=0-999999 2us units x 2**31\n         D     R0,=F'1000000'    R0=junk, R1=binary fraction of 4s\n         SLL   R1,1              R0=junk, R1=binary fraction of 2s\n\n         LR    R0,R2             R0=2s units, R1=binary fraction of 2s\n         SLDL  R0,1              R0=1s units, R1=binary fraction of 1s\n\n         STM   R0,R1,dTimeRef    Store seconds since 1/1/1900\n\n         MVC   dTimeOrg,dTimeTx   Original time = Client's TX time\n         MVC   dTimeRx,dTimeRef\n         MVC   dTimeTx,dTimeRef\n\n         MVC   cStratum,cStratumReq Set stratum\n         MVI   cPrecision,X'ED' Set precision = -19 (approx. 2us)\n         XC    nDelay,nDelay    Set root delay = 0\n         XC    nDisp,nDisp      Set root dispersion = 0\n         MVC   sRefId,=X'4C4F434C' Set refid = ascii('LOCL')\n\n*---------------------------------------------------------------------*\n*        Log this transaction (showing remote/local time difference)  *\n*---------------------------------------------------------------------*\n\n         LM    R0,R1,dTimeTx      Get local time  R0=secs R1=fraction\n         LM    R2,R3,dTimeOrg     Get remote time R2=secs R3=fraction\n         SRDL  R0,1               Ensure sign bit is zero (by halving)\n         SRDL  R2,1               Ensure sign bit is zero (by halving)\n         SR    R0,R2              R0 = secs difference (signed)\n         SLR   R1,R3              R1 = fraction difference (unsigned)\n         BRC   B'0001',noAdjust   Jump if carry (n/a,nz+nc,z+c,nz+c)\n         BCTR  R0,*-*             Else subtract 1 second\nnoAdjust DS    0H\n         SLDA  R0,1               Double (retaining sign)\n\n         LTR   R4,R0              Save sign\n         JNM   NotNeg             Jump if zero or positive\n*        R0/1 is negative, so compute twos complement...\n         X     R0,=F'-1'          Invert high order word\n         X     R1,=F'-1'          Invert low order word\n         AL    R1,=F'1'           Add to low order word\n         BRC   B'1100',NotNeg     Jump no carry (z+nc,nz+nc,z+c,nz+c)\n         AHI   R0,1               Else add 1 to high order word\nNotNeg   DS    0H\n*                                 R0/1 = nnnnnnnn ffffffff (n.f secs)\n*        But we only want 1/4096 second (0.0002s) precision, so...\n         SRDL  R0,32-12           R0/1 = 00000nnn nnnnnfff (n.f secs)\n\n         LTR   R0,R0              Is R0 zero? (can only multiply R1)\n         JZ    NumOK              Yes, continue\n         MVC   sDiff,=CL10'+Overflow' No, indicate overflow\n         J     SetSign            ...and set the sign\n\nNumOK    DS    0H\n         M     R0,=F'1000'        R0/1 = vvvvvvvv vvvvvwww (v.w ms)\n         SLDL  R0,32-12           R0/1 = vvvvvvvv www00000 (R0=v ms)\n         CVD   R0,d0              Difference in milliseconds\n*                        b 0 0 0 0 0 . 0 0 0\n         MVC   sDiff,=X'2120202020204B212020' Set edit pattern\n         ED    sDiff,d0+3         C' abcde.fgh' <-- X'0abcdefghC'\n\nSetSign  DS    0H\n         MVI   sDiff,C'+'         C'+abcde.fgh'\n         LTR   R4,R4              Was sign originally negative?\n         JNM   SignOK             No, jump\n         MVI   sDiff,C'-'         C'-abcde.fgh'\nSignOK   DS    0H\n\n         LOG   '%sAddr #dTimeOrg %sDiff #dTimeTx #dClock',             X\n               LEVEL=INFO\n\n*---------------------------------------------------------------------*\n*        Dump reply to be sent (only if loglevel=DEBUG or higher)     *\n*---------------------------------------------------------------------*\n\n         LHI   R6,PACKET_LENGTH   Length of outgoing packet\n         LA    R7,sPacket         -> Data to dump\n         MVC   sMsgAction,=C'Send'\n         BRAS  R10,Dump\n\n*---------------------------------------------------------------------*\n*        Send reply UDP packet                                        *\n*---------------------------------------------------------------------*\n\n         LOG   'SendTo()',LEVEL=DEBUG\n\n         LHI   R6,PACKET_LENGTH   Length of outgoing packet\n         LA    R7,sPacket         -> Data to dump\n         BRAS  R10,SendTo         If we come back, then it worked\n\n         J     awaitActivity\n\n*---------------------------------------------------------------------*\n*        End of job                                                   *\n*---------------------------------------------------------------------*\n\nExit     DS    0H\n         LOG   'Time server shutting down',WRITER=ToLogAndOper\n\n         CLOSE (SYSPRINT,FREE),MODE=31\n\n*---------------------------------------------------------------------*\n*        Release work area                                            *\n*---------------------------------------------------------------------*\n\nRelease  DS    0H\n         LR    R1,R13             -> Area to be released\n         L     R13,4(,R13)        -> Callers savearea\n         SLR   R2,R2\n         ST    R2,16(,R13)        Set return code\n         LHI   R0,WORKAREA_LENGTH\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0) Release work area\n\n*---------------------------------------------------------------------*\n*        Return                                                       *\n*---------------------------------------------------------------------*\n\nQuit     DS    0H\n         LM    R14,R12,12(R13)\n         BR    R14\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Execute the command passed on the PARM= operand of the **\n**            EXEC JCL statement.                                    **\n**                                                                   **\n** ON ENTRY - R4  -> A(AL2(len),CL(len)'exec parm data')             **\n**            R10  = Return address                                  **\n**                                                                   **\n** ON EXIT  - sCommand = PARM data                                   **\n**                                                                   **\n***********************************************************************\n\ngetParmCommand DS 0H\n         ST    R10,nR10Prm\n\n         L     R4,0(,R4)          -> AL2(len),CL(len)'parm data'\n         LH    R1,0(,R4)          Get length of PARM= data\n         LTR   R1,R1              Any PARM= data present?\n         JNP   ParmRet            No, jump\n\n         XC    wCommand,wCommand\n         BCTR  R1,*-*             -1 for EX\nCopyParm MVC   wCommand(*-*),2(R4)\n         EX    R1,CopyParm        Copy PARM= data to sCommand\n\n*---------------------------------------------------------------------*\n*        Get next comma-separated command                             *\n*---------------------------------------------------------------------*\n\n         LH    R3,0(,R4)          Get length of command(s) buffer\n         LA    R4,wCommand        -> Source command(s) buffer\n\nnextCommand DS  0H\n         LA    R2,sCommand        -> Target command buffer\n\nnextCommandByte DS 0H\n         CLI   0(R4),C','         End of command?\n         JE    executeCommand     Yes, jump\n\n         MVC   0(1,R2),0(R4)      No, append next character\n         LA    R4,1(,R4)          -> Next source byte\n         LA    R2,1(,R2)          -> Next target byte\n         BCT   R3,nextCommandByte\n\n         BRAS  R10,Command        Execute last command in sCommand\n         J     ParmRet\n\nexecuteCommand DS 0H\n         BRAS  R10,Command        Execute next command in sCommand\n         XC    sCommand,sCommand\n         LA    R4,1(,R4)\n         BCT   R3,nextCommand\n\nParmRet  DS    0H\n         L     R10,nR10Prm\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Get next console command issued by the operator.       **\n**                                                                   **\n**                                                                   **\n** ON ENTRY -                                                        **\n**            R10  = Return address                                  **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n***********************************************************************\n\ngetConsoleCommand DS 0H\n         ST    R10,nR10Opr\n\n         CALL  GETCMD,                                                 X\n               (cCmdChar,         For example, 'F' for MODIFY          X\n               sCommand,          Command operands (padded with nulls) X\n               pECB),             -> ECB to wait on for next command   X\n               VL,                                                     X\n               MF=(E,sParms)\n\n         LOG   'Command=%cCmdChar ECB=%pECB',LEVEL=DEBUG\n\n         CLI   cCmdChar,C'F'      MODIFY command issued?\n         JE    ModifyCommand      Yes, jump\n\n         CLI   cCmdChar,C'S'      START command issued?\n         JE    StartCommand       Yes, jump\n\n         CLI   cCmdChar,C'P'      STOP command issued?\n         JE    StopCommand        Yes, jump\n\n         J     CommandRet         No, ignore this command\n\n*---------------------------------------------------------------------*\n*        Process MODIFY command                                       *\n*---------------------------------------------------------------------*\n\nModifyCommand DS 0H\n         BRAS  R10,Command\n         J     CommandRet\n\n*---------------------------------------------------------------------*\n*        Process START  command                                       *\n*---------------------------------------------------------------------*\n\nStartCommand  DS 0H\n         BRAS  R10,Command\n         J     CommandRet\n\n*---------------------------------------------------------------------*\n*        Process STOP   command                                       *\n*---------------------------------------------------------------------*\n\nStopCommand DS 0H\n         J     Exit               Exit, stage left...\n\nCommandRet DS  0H\n         L     R10,nR10Opr\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Execute a command.                                     **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R10 =  Return address                                  **\n**            sCommand = Command to be executed.                     **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n***********************************************************************\n\nCommand  DS    0H\n         ST    R10,nR10Cmd\n\n         CLI   sCommand,0         Command given?\n         JE    CommandDone        No, return immediately\n\n         LOG   'Command=%sCmdShort',LEVEL=INFO\n\n         MVC   nNumbers,=F'0'     Count of numbers found in input\n\n*        ----- cycle through valid commands here        -----\n*        ----- possibly using a command table           -----\n\n         CLC   =C'LOG',sCommand\n         JE    LogCommand\n\n         CLC   =C'TOD ',sCommand\n         JE    TodCommand\n\n         CLC   =C'NOSWAP',sCommand\n         JE    NoSwap\n\n         CLC   =C'STOP',sCommand\n         JE    StopCommand\n\n         CLC   =C'STRATUM',sCommand\n         JE    StratumCommand\n\n         CLC   =C'SHOW',sCommand\n         JE    ShowCommand\n\n         J     CommandInvalid\n\n*---------------------------------------------------------------------*\n*        Process command: LOG nn                                      *\n*---------------------------------------------------------------------*\n\nLogCommand DS  0H\n         LA    R2,sCommand        -> LOG command\n         LA    R1,L'sCommand      Length of command\n\n         BRAS  R10,GetNum         Get first number if any\n         CHI   R0,DATA            Is logging level too high?\n         JNH   SetLoggingLevel    No, jump\n         LHI   R0,DATA            Yes, set to maximum\n\nSetLoggingLevel DS 0H\n         STC   R0,cLogLevel\n         BRAS  R9,showLoggingLevel\n         J     CommandDone\n\n*---------------------------------------------------------------------*\n*        Process command: TOD +hhmm                                   *\n*---------------------------------------------------------------------*\n\nTodCommand DS  0H\n         LA    R2,sCommand        -> 'TOD +hhmm'\n         LA    R1,L'sCommand      Length of command\n\n         BRAS  R10,GetNum         Get first number into R0\n         ST    R0,nClockAdj       Save it for later\n\n         SLR   R0,R0              R0=0\n         L     R1,nClockAdj       R0=0          R1=hhmm\n         D     R0,=F'100'         R0=mm         R1=hh\n\n         CHI   R0,59              Is the minute valid (0-59)?\n         JH    BadMinute          No, jump\n\n         CHI   R1,23              Is the hour valid (0-23)?\n         JH    BadHour            No, jump\n\n         MH    R1,=H'60'                        R1=hh*60\n         AR    R1,R0                            R1=hh*60+mm\n         MH    R1,=H'60'                        R1=(hh*60+mm)*60\n         SLR   R0,R0              R0=0          R1=(hh*60+mm)*60\n\n         MVI   cClockSign,C'+'\n         CLI   sCommand+4,C'-'    Negative adjustment?\n         JNE   TodStore           No, jump\n\n         MVI   cClockSign,C'-'\n         LCR   R1,R1              R0=0          R1=-((hh*60+mm)*60)\n\nTodStore DS    0H\n         M     R0,=F'15625'       R0/1 bits 0-63 = +/-n x 64 usecs\n         SLDL  R0,12+6            R0/1 bits 0-51 = +/-microseconds\n         STM   R0,R1,dClockAdj    R0/1 bits 0-51 = +/-microseconds\n\n         BRAS  R9,showTodAdjustment\n\n         J     CommandDone\n\nBadMinute DS   0H\n         LOG   'Invalid minute value. Specify 00 to 59.',              X\n               LEVEL=ERROR\n         J     CommandDone\n\nBadHour   DS   0H\n         LOG   'Invalid hour value. Specify 00 to 23.',                X\n               LEVEL=ERROR\n         J     CommandDone\n\n*---------------------------------------------------------------------*\n*        Process command: NOSWAP                                      *\n*---------------------------------------------------------------------*\n\nNoSwap   DS  0H\n         TESTAUTH                    Test for APF authorization\n         LTR   R15,R15               Are we authorized?\n         JZ    setNoSwap             Yes, jump\n\n         LOG   'Address space is not APF-authorized.',                 X\n               WRITER=ToLogAndOper\n         J     CommandDone\n\nsetNoSwap DS   0H\n         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state\n         XR    R1,R1                 No ECB posting\n         SYSEVENT TRANSWAP           Make ourself non-swappable\n         MODESET MODE=PROB,KEY=NZERO Back to problem state\n         LOG   'Address space is now running Non-swappable.',          X\n               WRITER=ToLogAndOper\n         J     CommandDone\n\n*---------------------------------------------------------------------*\n*        Process command: STRATUM nn                                  *\n*---------------------------------------------------------------------*\n\nStratumCommand DS  0H\n         LA    R2,sCommand        -> STRATUM command\n         LA    R1,L'sCommand      Length of command\n\n         BRAS  R10,GetNum         Get first number if any\n         CHI   R0,255             Is stratum number too high?\n         JNH   setStratum         No, jump\n         LHI   R0,255             Yes, set to maximum\n\nsetStratum  DS 0H\n         STC   R0,cStratumReq\n         BRAS  R9,showStratum\n         J     CommandDone\n\n*---------------------------------------------------------------------*\n*        Process command: SHOW                                        *\n*---------------------------------------------------------------------*\n\nShowCommand    DS  0H\n         BRAS  R9,showStratum\n         BRAS  R9,showLoggingLevel\n         BRAS  R9,showTodAdjustment\n         J     CommandDone\n\nshowStratum    DS  0H\n         SLR   R0,R0\n         IC    R0,cStratumReq\n         CVD   R0,dWork\n         UNPK  sStratum,dWork+6(2)\n         OI    sStratum+2,X'F0'\n         LOG   'Stratum is now %sStratum',                             X\n               WRITER=ToLogAndOper\n         BR    R9\n\nshowLoggingLevel DS 0H\n         SLR   R0,R0\n         IC    R0,cLogLevel\n         CVD   R0,dWork\n         UNPK  sLogLevel,dWork+6(2)\n         OI    sLogLevel+2,X'F0'\n         LOG   'Logging level is now %sLogLevel',                      X\n               WRITER=ToLogAndOper\n         BR    R9\n\nshowTodAdjustment DS 0H\n         L     R0,nClockAdj       Get hhmm specified\n*                                     +0 1 2 3 4 5 6 7\n         CVD   R0,dWork              X'00000000000hhmmC'\n         UNPK  sClockAdj,dWork+5(3)  X'F0FhFhFmCm'\n         OI    sClockAdj+4,X'F0'     X'F0FhFhFmFm'\n         MVC   sClockAdj(1),cClockSign  C'+hhmm'\n         LOG   'TOD adjustment is now %sClockAdj (hhmm)',              X\n               WRITER=ToLogAndOper\n         BR    R9\n\n*---------------------------------------------------------------------*\n*        Process invalid command                                      *\n*---------------------------------------------------------------------*\n\nCommandInvalid DS 0H\n         LOG   'Unknown command: %sCmdShort',                          X\n               WRITER=ToLogAndOper\n         LOG   'Valid commands are:',                                  X\n               WRITER=ToLogAndOper\n         LOG   '  LOG nn     - Set logging level (0-60)',              X\n               WRITER=ToLogAndOper\n         LOG   '  NOSWAP     - Make the time server NONSWAPPABLE',     X\n               WRITER=ToLogAndOper\n         LOG   '  SHOW       - Show current server settings',          X\n               WRITER=ToLogAndOper\n         LOG   '  STOP       - Shut down the time server',             X\n               WRITER=ToLogAndOper\n         LOG   '  STRATUM nn - Set the server''s stratum (0-255)',     X\n               WRITER=ToLogAndOper\n         LOG   '  TOD +hhmm  - Adjust TOD clock by +/- hhmm',          X\n               WRITER=ToLogAndOper\n         J     CommandDone\n\nCommandDone DS 0H\n         L     R10,nR10Cmd\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Find and convert the next number in an input string    **\n**            to binary.                                             **\n**                                                                   **\n** ON ENTRY - R10 =  Return address                                  **\n**            R2  -> String to search                                **\n**            R1  =  L'String to search                              **\n**            nNumbers = n                                           **\n**                                                                   **\n** ON EXIT  - R2  -> First non-numeric digit after the found number  **\n**            R1  =  L'String left to search                         **\n**            R0  =  Number (or zero if no number was found)         **\n**            nNumbers = n+1 if a number was found                   **\n**                                                                   **\n***********************************************************************\n\nGetNum   DS    0H\n\n         SLR   R0,R0              Return 0 by default\n\n         LTR   R1,R1              Any remaining string to search?\n         JNP   RetNum             No, return 0\n\nSkipDig  DS    0H\n         CLI   0(R2),C'0'         Is this a digit?\n         JL    SkipNext           No, skip it\n         CLI   0(R2),C'9'         Is this a digit?\n         JNH   First              Yes, branch (first digit found)\nSkipNext DS    0H\n         LA    R2,1(,R2)          -> Next input character\n         BRCT  R1,SkipDig         ...until input exhausted...\n         J     RetNum             in which case return 0\n\nFirst    DS    0H                 R2  -> 'nnnxx...'\n         LR    R15,R2             R15 -> 'nnnxx...'\nNextDig  DS    0H\n         CLI   0(R2),C'0'         Is this a digit?\n         JL    Last               No, branch (end of number found)\n         CLI   0(R2),C'9'         Is this a digit?\n         JH    Last               No, branch (end of number found)\n         LA    R2,1(,R2)          -> Next input character\n         BRCT  R1,NextDig         ...until input exhausted...\n*                                 in which case return the number\n\nLast     DS    0H                 R15 -> 'nnnxx...'\n         LR    R14,R2\n         SR    R14,R15            R14 = Number of digits\n         JNP   RetNum             Safety check\n\n         CHI   R14,16             Too long for a PACK instruction?\n         JNH   DigOK              No, branch\n\n         LR    R15,R2             Yes, accept only the last 16 digits\n         LHI   R14,16\n         SR    R15,R14\n\nDigOK    DS    0H\n         BCTR  R14,*-*\nPackDig  PACK  dWork,0(*-*,R15)\n         EX    R14,PackDig\n\n         CVB   R0,dWork\n\n         L     R15,nNumbers\n         AHI   R15,1\n         ST    R15,nNumbers\n\nRetNum   DS    0H\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Dump characters to log.   For the first line only, the **\n**            length of the data is displayed.  For subsequent lines **\n**            the offset into the data is displayed.                 **\n**                                                                   **\n** ON ENTRY - R7  -> Text to dump                                    **\n**            R6   = Length of text to be dumped                     **\n**            R10  = Return address                                  **\n**                                                                   **\n** ON EXIT  - R5, R6 Clobbered                                       **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nDump     DS    0H\n         STM   R9,R10,dDump\n         CLI   cLogLevel,DEBUG    Dump at this logging level?\n         JL    DumpRet            No, branch (do not dump)\n\n         ST    R6,nWork           Save length to be displayed\n\n         CLI   cLogLevel,DATA     Data or higher logging level?\n         JNL   DumpFull           Yes, dump full message content\n\n         CHI   R6,L'sMsgString    At least one line to dump?\n         JL    DumpFull           No, dump short line\n\n         LHI   R6,L'sMsgString    Yes, dump only one line\n\nDumpFull DS    0H\n\n         LA    R7,0(,R7)          Knock the top bit off\n         LR    R9,R7              -> Data to be dumped\n\n         BRAS  R10,SetupMsg       Build message header\n\nDumpNext DS    0H\n         LTR   R6,R6              Is there any more to be logged?\n         JNP   DumpRet            Yes, branch\n\n         LHI   R5,L'sMsgString    Get length of chunk\n         CR    R6,R5              Is there more than a chunk to log?\n         JNL   DumpCopy           Yes, branch\n\n         LR    R5,R6              No, log the residual then\nDumpCopy MVC   sMsgString(*-*),0(R9)\n         SR    R6,R5              Compute length remaining\n\n         MVI   sMsgPlus,C'+'      Indicate that it is an offset\n         LR    R0,R9              -> Some way into the text\n         SR    R0,R7              Compute offset into the text\n         JNZ   OffsetNotZero\n\n         L     R0,nWork           Get length to be displayed\n         MVI   sMsgPlus,C' '      Indicate that it is a length\n\nOffsetNotZero DS  0H\n         CVD   R0,dWork\n         UNPK  sMsgOffset,dWork+5(3)\n         OI    sMsgOffset+4,X'F0'\n\n         MVC   sMsgQuote1,=C' '''\n\n         BCTR  R5,*-*             -1 for EX\n         EX    R5,DumpCopy        Copy next chunk\n\n         LA    R5,sMsgString+1(R5)\n         MVI   0(R5),C''''\n\n         BRAS  R10,ToLog          Log chunk\n\n         MVI   sMsgText,C' '\n         MVC   sMsgText+1(L'sMsgText-1),sMsgText\n\n         LA    R9,L'sMsgString(,R9) -> Next input chunk\n         J     DumpNext\n\nDumpRet  DS    0H\n         LM    R9,R10,dDump\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Send the requested number of bytes to the socket.      **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R6   = Number of bytes to send                         **\n**            R7  -> Send buffer                                     **\n**            R10  = Return address                                  **\n**                                                                   **\n** ON EXIT  - R7  -> Byte after the last byte sent                   **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nSendTo   DS    0H\n         MVC   sCall,sSendTo      What we are doing (for error msgs)\n         ST    R6,nByte           Set number of bytes to send\n\n         CALL  EZASOKET,                                               X\n               (sSendTo,          Function                             X\n               hSocket,           Socket descriptor                    X\n               nFlag,             Flag indicating 'send data'          X\n               nByte,             Length of data to be sent            X\n               (R7),              -> Data to be sent                   X\n               sClient,           Client socket name                   X\n               nErrNo,                                                 X\n               nRetCode),                                              X\n               VL,                                                     X\n               MF=(E,sParms)\n\n         L     R15,nRetCode       Get return code\n         LTR   R15,R15            Did it work?\n         JM    ErrSend            No, branch\n\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Read the requested number of bytes from the socket.    **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R6   = Number of bytes to receive                      **\n**            R7  -> Receive buffer                                  **\n**            R10  = Return address                                  **\n**                                                                   **\n** ON EXIT  - R7  -> Byte after the last byte received               **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nRecvFrom DS    0H\n         MVC   sCall,sRecvFrom    What we are doing (for error msgs)\n         ST    R6,nByte           Set number of bytes to read\n\n         CALL  EZASOKET,                                               X\n               (sRecvFrom,        Function                             X\n               hSocket,           Socket descriptor                    X\n               nFlag,             Flag indicating 'read data'          X\n               nByte,             Length of data to be read            X\n               (R7),              -> Buffer to hold data received      X\n               sClient,           Client socket name                   X\n               nErrNo,                                                 X\n               nRetCode),                                              X\n               VL,                                                     X\n               MF=(E,sParms)\n\n         L     R15,nRetCode       Get return code\n         LTR   R15,R15            Did it work?\n         JM    ErrRead            No, branch\n*------- JZ    ErrDisc            No, closed by other end\n\n         ST    R15,nByte          Set number of bytes actually read\n\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Error processing routines.                             **\n**                                                                   **\n**                                                                   **\n** ON ENTRY -                                                        **\n**                                                                   **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nErrSock  DS    0H                       Socket() failed\n         BRAS  R10,SaySock\n         MVC   sErrText(L'sErrSock),sErrSock\n         J     ErrReturnMsgSock\n\nErrBind  DS    0H                       Bind() failed\n         BRAS  R10,SaySock\n         MVC   sErrText(L'sErrBind),sErrBind\n         J     ErrReturnMsgSock\n\nErrSelect DS    0H                      SelectEx() failed\n         BRAS  R10,SaySock\n         MVC   sErrText(L'sErrSelect),sErrSelect\n         J     ErrReturnMsgSock\n\nErrSend  DS    0H                       SendTo() failed\n         BRAS  R10,SaySock\n         MVC   sErrText(L'sErrSend),sErrSend\n         J     ErrReturnMsgSock\n\nErrRead  DS    0H                       Read() failed\n         BRAS  R10,SaySock\n         MVC   sErrText(L'sErrRead),sErrRead\n         J     ErrReturnMsgSock\n\n\nErrReturnMsgSock DS 0H\nErrReturnMsg DS 0H                      WTO and then return message\n         MVC   sMsgText(L'sErrText),sErrText\n         BRAS  R10,ToLogAndOper\n         LA    R7,sErrText\n         MVC   nLength,=A(L'sErrText)\n         J     Exit\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - This routine converts a binary IP address and port     **\n**            number into a printable string.                        **\n**                                                                   **\n** ON ENTRY - R0  = Binary IP port number                            **\n**            R1  = Binary IP address                                **\n**            R10 = Return address                                   **\n**                                                                   **\n** ON EXIT  - sAddr = Dotted decimal IP address and port             **\n**                                                                   **\n***********************************************************************\n\nntoa     DS    0H\n*                                    R0       R1\n*                              0000pppp aabbccdd\n         CVD   R0,d0           Convert port number (pppp) to decimal\n\n         SLR   R0,R0           00000000 aabbccdd\n         SLDL  R0,8            000000aa bbccdd00\n         CVD   R0,d1           IP address digit 1\n\n         SLR   R0,R0           00000000 bbccdd00\n         SLDL  R0,8            000000bb ccdd0000\n         CVD   R0,d2           IP address digit 2\n\n         SLR   R0,R0           00000000 ccdd0000\n         SLDL  R0,8            000000cc dd000000\n         CVD   R0,d3           IP address digit 3\n\n         SLR   R0,R0           00000000 dd000000\n         SLDL  R0,8            000000dd 00000000\n         CVD   R0,d4           IP address digit 4\n\n*                                     0....+...10....+...20\n         UNPK  sAddr+00(3),d1+6(2)    nnx\n         OI    sAddr+02,X'F0'         nnn\n         MVI   sAddr+03,C'.'          nnn.\n         UNPK  sAddr+04(3),d2+6(2)    nnn.nnx\n         OI    sAddr+06,X'F0'         nnn.nnn.\n         MVI   sAddr+07,C'.'          nnn.nnn.\n         UNPK  sAddr+08(3),d3+6(2)    nnn.nnn.nnx\n         OI    sAddr+10,X'F0'         nnn.nnn.nnn\n         MVI   sAddr+11,C'.'          nnn.nnn.nnn.\n         UNPK  sAddr+12(3),d4+6(2)    nnn.nnn.nnn.nnx\n         OI    sAddr+14,X'F0'         nnn.nnn.nnn.nnn\n         MVI   sAddr+15,C':'          nnn.nnn.nnn.nnn:\n         UNPK  sAddr+16(5),d0+5(3)    nnn.nnn.nnn.nnn:nnnnx\n         OI    sAddr+20,X'F0'         nnn.nnn.nnn.nnn:nnnnn\n*                                     0....+...10....+...20\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Write a message to the operator console for a socket   **\n**            error.                                                 **\n**                                                                   **\n** ON ENTRY - R10  = Return address                                  **\n**                                                                   **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nSaySock  DS    0H\n         ST    R10,nR10Sock\n\n         L     R1,nErrNo\n         CVD   R1,dWork\n         MVC   sErrNo,=X'402020202120'\n         ED    sErrNo,dWork+5   nnnnn\n\n         LOG   'Socket errno%sErrNo during %sCall',                    X\n               LEVEL=ERROR\n\n         L     R10,nR10Sock\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Log a status message for debugging.                    **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R10  = Return address                                  **\n**                                                                   **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nSay      DS    0H\n         ST    R10,nR10\n\n         BRAS  R10,SetupMsg       Build message header\n\n         BRAS  R10,ToLog          Write message to log\n\n         MVI   sMsgText,C' '\n         MVC   sMsgText+1(L'sMsgText-1),sMsgText\n\n         L     R10,nR10\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Log a status message for debugging.                    **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R10  = Return address                                  **\n**                                                                   **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nToLogAndOper DS 0H\n         ST    R10,nR10\n\n         BRAS  R10,SetupMsg       Build message header\n\n         BRAS  R10,ToLog          Write message to log\n\n         BRAS  R10,ToOper         Write message to operator\n\n         MVI   sMsgText,C' '\n         MVC   sMsgText+1(L'sMsgText-1),sMsgText\n\n         L     R10,nR10\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Set up all the system fields in the error message.     **\n**            That is, date, time, sysid, tranid and progname.       **\n**                                                                   **\n** ON ENTRY - R10  = Return address                                  **\n**                                                                   **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nSetupMsg DS    0H\n\n         TIME  DEC,sTimeDate,                                          X\n               DATETYPE=YYYYMMDD,                                      X\n               LINKAGE=SYSTEM\n*        sTimeDate DS             XL8'HHMMSSthmiju0000'\n*                  DS             XL8'YYYYMMDD00000000'\n*                  DS             XL8'0000000000000000'\n\n         MVC   sTimeDate+8+4(8),sTimeDate\n*        sTimeDate DS             XL8'HHMMSSthmiju0000'\n*                  DS             XL8'YYYYMMDDHHMMSSth'\n*                  DS             XL8'miju000000000000'\n\n         MVC   sMsgDate-1(L'sPattern),sPattern\n         ED    sMsgDate-1(L'sPattern),sTimeDate+8\n\n         BR    R10\n*                   y y y y / m m / d d   h h : m m : s s . n n n\nsPattern DC    X'40212020206120206120204021207A20207A20204B202020'\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Write a message to the log.                            **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R10  = Return address                                  **\n**                                                                   **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nToLog    DS    0H\n         ST    R10,nR10Log\n\n         PUT   SYSPRINT,sMsg\n\n         L     R10,nR10Log\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Write a message to the operator (and log).             **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R10  = Return address                                  **\n**                                                                   **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n\nToOper   DS    0H\n\n         LHI   R1,L'sMsgWTO       Length of message\n         STH   R1,hMsgWTO\n\n         MVC   sMsgWTO,sMsgText\n\n         LA    R2,hMsgWTO          -> H'len',CL(len)'message text'\n         WTO   TEXT=(R2)\n\n         BR    R10\n\n*========================== END OF ROUTINE ===========================*\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           E Q U A T E S                             *\n*                                                                     *\n***********************************************************************\n\n*---------------------------------------------------------------------*\n*        Logging levels                                               *\n*---------------------------------------------------------------------*\n\nNONE     EQU   0\nERROR    EQU   10\nWARNING  EQU   20\nSUMMARY  EQU   25\nINFO     EQU   30\nBANNER   EQU   40\nDEBUG    EQU   50\nDATA     EQU   60\n\n*---------------------------------------------------------------------*\n*        Socket constants                                             *\n*---------------------------------------------------------------------*\n\nAF_INET       EQU   2             TCP/IP sockets addressing family\n\nSOCK_STREAM   EQU   1             Stream socket type\nSOCK_DGRAM    EQU   2             Datagram socket type\nSOCK_RAW      EQU   3             Raw socket type\n\nPROT_DEFAULT  EQU   0             Default protocol for the socket type\n\nEINPROGRESS   EQU   36\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          L I T E R A L S                            *\n*                                                                     *\n***********************************************************************\n\n         LTORG\n\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         C O N S T A N T S                           *\n*                                                                     *\n***********************************************************************\n\n*---------------------------------------------------------------------*\n*        Socket API constants                                         *\n*---------------------------------------------------------------------*\n\n               DS    0D\nsInitAPI       DC    CL16'INITAPI'       Initialise the Socket API\nsSocket        DC    CL16'SOCKET'        Create a socket\nsBind          DC    CL16'BIND'          Bind a socket\nsSendTo        DC    CL16'SENDTO'        Send data to a remote host\nsRecvFrom      DC    CL16'RECVFROM'      Receive data from remote host\nsSelectEx      DC    CL16'SELECTEX'      Select (extended)\n\nnFamily  DC    A(AF_INET)         Addressing family\nnSocType DC    A(SOCK_DGRAM)      Socket type\nnProto   DC    A(PROT_DEFAULT)    Default protocol (UDP for datagrams)\n\ndTimeOut DC    A(-1,-1)           Select timeout (seconds,microseconds)\nnMaxSoc  DC    F'31'              Maximum sockets\n\nnOutWMask  DC  F'0'\nnOutRMask  DC  F'0'\nnOutEMask  DC  F'0'\nnInWMask   DC  F'0'\nnInRMask   DC  F'0'\nnInEMask   DC  F'0'\n\nnFlag    DC    F'0'               RecvFrom flag = 0 (read data)\nhPort    DC    H'123'             Port to listen on\nIN_ADDR_ANY DC F'0'               IP address 0.0.0.0\n\n*---------------------------------------------------------------------*\n*        Message constants                                            *\n*---------------------------------------------------------------------*\n\n*                0....+...10....+...20....+...30....+...40....+...50\nsErrSock   DC  C'Socket() call failed'\nsErrBind   DC  C'Bind() call failed'\nsErrSend   DC  C'SendTo() call failed'\nsErrRead   DC  C'RecvFrom() call failed'\nsErrSelect DC  C'SelectEx() call failed'\n*                0....+...10....+...20....+...30....+...40....+...50\n\n*---------------------------------------------------------------------*\n*        Other constants                                              *\n*---------------------------------------------------------------------*\n\n         DS    0F\nnErrMsg  DC    A(sErrMsgZ-sErrMsg) Length of WTO error message\n\n*---------------------------------------------------------------------*\n*        Log file DCB                                                 *\n*---------------------------------------------------------------------*\n\nSYSPRINT DCB   DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               RECFM=FB,                                               X\n               LRECL=L'sMsg,                                           X\n               BLKSIZE=10*L'sMsg,                                      X\n               DCBE=DCBE,                                              X\n               DDNAME=SYSPRINT                                         X\n\nDCBE     DCBE  SYNAD=Release\n         EJECT\n***********************************************************************\n*                                                                     *\n*                            D S E C T S                              *\n*                                                                     *\n***********************************************************************\n\n         CVT   DSECT=YES\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          W O R K A R E A                            *\n*                                                                     *\n***********************************************************************\n\nWORKAREA  DSECT\nSAVEAREA  DS   18F                <-- NB: MUST be first in DSECT\n\nsEyeCatch DC   CL8'SNTPD'         Eye-catcher in dumps\nsWorkArea DC   CL8'WORKAREA'      Eye-catcher in dumps\n\ndClock   DS    D                  TOD clock\ndClockAdj DS   D                  TOD clock adjustment\ndWork    DS    D                  Work area\ndTime    DS    D                  Work area\ndDump    DS    D                  Work area\nd0       DS    D                  Work area\nd1       DS    D                  Work area\nd2       DS    D                  Work area\nd3       DS    D                  Work area\nd4       DS    D                  Work area\n\ncClockSign DS  CL1'+'\nsClockAdj  DS  CL5'0HHMM'\nsDiff    DS    C'+nnnnn.nnn'\n\nsTimeDate DS   XL24\n\nnWork    DS    F                  Work area\nnR10     DS    F                  Work area\nnR10Sock DS    F                  Work area\nnR10Err  DS    F                  Work area\nnR10Log  DS    F                  Work area\nnR10Opr  DS    F                  Work area\nnR10Prm  DS    F                  Work area\nnR10Cmd  DS    F                  Work area\nnClockAdj DS   F                  Work area\n\nnNumbers DS    F                  Number of numbers\nn1       DS    F                  Number 1\n\nsAddr     DS    C'nnn.nnn.nnn.nnn:nnnnn'  Dotted IP address and port\n\ncLogLevel   DS    X               Logging level requested\nsLogLevel   DS    CL3             Logging level requested (decimal)\ncStratumReq DS    X               Stratum level requested\nsStratum    DS    CL3             Stratum level requested (decimal)\n\n*---------------------------------------------------------------------*\n*        Operator command interface                                   *\n*---------------------------------------------------------------------*\n\ncCmdChar    DS    C\nsCmdShort   DS    0CL32\nsCommand    DS    CL256\nwCommand    DS    CL256\npECB        DS    A\n\n*---------------------------------------------------------------------*\n*        Error message buffer                                         *\n*---------------------------------------------------------------------*\n\nnLength  DS    F\n\nsErrMsg     DS    0C\nsErrText    DS    CL60            Brief message text\nsErrMsgZ    EQU   *\n\n*---------------------------------------------------------------------*\n*        Error message buffer                                         *\n*---------------------------------------------------------------------*\n\nhMsgWTO     DS    H\nsMsgWTO     DS    CL70\n\n            DS    C  <--- Pad (do not move away from sMsg...)\nsMsg        DS    0CL132         ----     LOG MESSAGE STARTS HERE-----\nsMsgDate    DS    C'yyyy/mm/dd hh:mm:ss.nnn'\n            DS    C\nsMsgText    DS    CL(L'sMsg-(*-sMsg))\n\n            ORG   sMsgText       ----     WTO MESSAGE STARTS HERE-----\nsMsgAction  DS    CL4'Send' or 'Recv'\n            DS    C' '\nsMsgPlus    DS    C'+'\nsMsgOffset  DS    C'nnnnn'\nsMsgQuote1  DS    C' '''\nsMsgString  DS    CL50\nsMsgQuote2  DS    C''''\n\n            ORG   ,\nsMsgZ       EQU   *\n            DS    CL80            Pad (do not remove)\n\nsErrNo      DS    CL6' nnnnn'\n\n\n*---------------------------------------------------------------------*\n*        Parameter list for all socket calls                          *\n*---------------------------------------------------------------------*\n\nsParms   DS    30A\n\n*---------------------------------------------------------------------*\n*        Parameters for some socket calls                             *\n*---------------------------------------------------------------------*\n\nsCall    DS    CL16               Socket function name\n\nnRetCode DS    F                  Socket return code\nnErrNo   DS    F                  Socket error number\nnByte    DS    F                  Number of bytes\nhSocket  DS    H                  Socket descriptor\n\n*---------------------------------------------------------------------*\n*        Internet socket address structures                           *\n*---------------------------------------------------------------------*\n\n               DS    0D\nsServer        DS    0CL16        Socket name\nhServerFamily  DS    H            Address family (=AF_INET)\nhServerPort    DS    H            Port number\nnServerAddress DS    F            IP address\n               DS    XL8          ...not used for AF_INET family\n\n               DS    0D\nsClient        DS    0CL16        Socket name\nhClientFamily  DS    H            Address family (=AF_INET)\nhClientPort    DS    H            Port number\nnClientAddress DS    F            IP address\n               DS    XL8          ...not used for AF_INET family\n\ncVersion       DS    X\ncMode          DS    X\n\n*---------------------------------------------------------------------*\n*        Input/Output packet                                          *\n*---------------------------------------------------------------------*\n\n            DS   0D\nsPacket     DS   XL512\n            ORG  sPacket\n\ncHeader     DS   XL1\n\nNTP_LEAP_INDICATOR_MASK EQU B'11000000'  Impending leap-second warning:\n*--------------------------------------\nNTP_LEAP_NO_WARNING     EQU B'00000000'  No warning\nNTP_LEAP_LAST_61        EQU B'01000000'  Last minute has 61 seconds\nNTP_LEAP_LAST_59        EQU B'10000000'  Last minute has 59 seconds\nNTP_LEAP_ALARM          EQU B'11000000'  Alarm (clock not synchronized)\n\nNTP_VERSION_MASK        EQU B'00111000'  NTP/SNTP version number:\n*--------------------------------------\nNTP_VERSION_1           EQU B'00001000'\nNTP_VERSION_2           EQU B'00010000'\nNTP_VERSION_3           EQU B'00011000'\nNTP_VERSION_4           EQU B'00100000'\n\nNTP_MODE_MASK             EQU B'00000111' NTP/SNTP mode:\n*----------------------------------------\nNTP_MODE_RESERVED         EQU B'00000000'\nNTP_MODE_SYMETRIC_ACTIVE  EQU B'00000001'\nNTP_MODE_SYMETRIC_PASSIVE EQU B'00000010'\nNTP_MODE_CLIENT           EQU B'00000011'\nNTP_MODE_SERVER           EQU B'00000100'\nNTP_MODE_BROADCAST        EQU B'00000101'\n\ncStratum    DS   XL1\nNTP_STRATUM_UNSPECIFIED   EQU 0\nNTP_STRATUM_PRIMARY       EQU 1\nNTP_STRATUM_SECONDARY     EQU 2\n\ncPoll       DS   XL1              Max interval between polls\ncPrecision  DS   XL1              Precision of local clock\nnDelay      DS   XL4              Roundtrip delay to primary ref source\nnDisp       DS   XL4              Nominal error from primary ref source\nsRefId      DS   CL4              Id of ref source\ndTimeRef    DS   XL8              Time local clock last set/corrected\ndTimeOrg    DS   XL8              Time request left client\ndTimeRx     DS   XL8              Time request arrived at server\ndTimeTx     DS   XL8              Time reply departed server\nPACKET_LENGTH  EQU  *-sPacket\n\n           ORG  ,\n\nWORKAREA_LENGTH EQU *-WORKAREA          Length of work area\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCPSNTP": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00#\\x01\\x01%_\\x01\\x03\\x13o\\x13)\\x00\\x15\\x00*\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-09-12T00:00:00", "modifydate": "2003-05-16T13:29:23", "lines": 21, "newlines": 42, "modlines": 0, "user": "FAJA"}, "text": "//*********************************************************************\n//**                                                                 **\n//** NAME     - TCPSNTP (SIMPLE NETWORK TIME PROTOCOL SERVER)        **\n//**                                                                 **\n//** FUNCTION - This is a Simple Network Time Protocol (SNTPv3)      **\n//**            server as defined by RFC2030 (which defines SNTPv4,  **\n//**            but this server does not implement any of the SNTPv4 **\n//**            optional extensions).                                **\n//**                                                                 **\n//** HISTORY  - Date     By       Reason (most recent at the top)    **\n//**            -------- -------- ---------------------------------- **\n//**            20010912 TZARMS   Initial version.                   **\n//**                                                                 **\n//**                                                                 **\n//*********************************************************************\n//TCPSNTP  PROC\n//TCPSNTP  EXEC PGM=SNTPD,REGION=0K,TIME=NOLIMIT\n//STEPLIB   DD DISP=SHR,DSN=your.load.library\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//         PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT629/FILE629.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT629", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}