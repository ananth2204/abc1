 TITLE 'BRWSPOOL - OUTPUT JOB SUMMARY OF CONDITION CODES'
 PRINT GEN
*______________________________________________________________________
*
* This module reads JESYSMSG for the job it is running in and finds
* the step condition codes for all previous steps and then
* outputs them in a nice box.
* This should be the last step in the job so it can report on
* all preceding steps. It does not report on itself as it
* has not yet finished.
*______________________________________________________________________
*
BRWSPOOL PRGDEF FSEG=MAIN_PART,RMODE=24
*
IN_REC         DS    CL256
T_STAMP        DS    CL14
STEP_NAME      DS    CL8
PROC_NAME      DS    CL8
COND_CODE      DS    CL9
CPU_TIME       DS    CL8
IEF032I_MESS_A DS    CL80
IEF032I_MESS_B DS    CL80
IEF142I_MESS   DS    CL80
IEF374I_MESS   DS    CL80
E_O_F          DS    C
*
         PRGEDEF
         USING IHADCB,SYSIN            map DCBD over SYSIN
*______________________________________________________________________
*
 SEGS MAIN_PART
*
   SEGDO DYNALLOC_JESYSMSG
*
   MVI   MESS_TXT,C'+'
   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT
   SEGDO WRITE_LOG
   MVC   MESS_TXT+2(12),=C'JOB  SUMMARY'
   MVC   MESS_TXT+22(12),=C'JOB  SUMMARY'
   MVC   MESS_TXT+42(12),=C'JOB  SUMMARY'
   SEGDO WRITE_LOG
   MVI   MESS_TXT,C'+'
   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT
   SEGDO WRITE_LOG
*
   SEGDO OPEN_SYSIN
*
   DO INF
     SEGDO GET_SYSIN
   DOEXIT (CLI,E_O_F,EQ,C'Y')
     SEGDO PROCESS_RECORD
   ENDDO
*
   SEGDO CLOSE_SYSIN
*
   MVI   MESS_TXT,C'+'
   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT
   SEGDO WRITE_LOG
   MVC   MESS_TXT+2(12),=C'SUMMARY  END'
   MVC   MESS_TXT+22(12),=C'SUMMARY  END'
   MVC   MESS_TXT+42(12),=C'SUMMARY  END'
   SEGDO WRITE_LOG
   MVI   MESS_TXT,C'+'
   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT
   SEGDO WRITE_LOG
*
   SEGDO RELEASE_JESYSMSG
*
 SEGE MAIN_PART
*______________________________________________________________________
*
 SEGS DYNALLOC_JESYSMSG
*
*    names of temporary dataset in JES are:-
*
*    useridi#.jobname#.JOBnnnnn.Dnnnnnnn.?
*    a.b.JOBnnnnn.Dnnnnnnn.?
*
*    userid and jobname can be 1 to 8 characters (as of z/OS 2.3)
*    so find the third '.' and add JESYSMSG to the end
*
   RDJFCB SYSOUT
   MVC   KEYADSN(28),JFCBDSNM          more than enough to work with
   LA    R14,KEYADSN                   point to DSN
   LA    R15,L'KEYADSN                 get length
   XR    R1,R1                         clear '.' counter
   DO FROM=(R15)
   DOEXIT (CHI,R1,EQ,3)                quit when counter is 3
     IF (CLI,0(R14),EQ,C'.')
       LA    R1,1(,R1)                 increment counter
     ENDIF
     LA    R14,1(,R14)
   ENDDO
   IF (LTR,R15,R15,Z)                  did not find three '.'
     MVC   MESS_TXT(14),=CL14'PARSING FAILED'
     SEGDO WRITE_LOG
     PRGQUIT RC=16
   ENDIF
   MVC   0(17,R14),=CL17'JESYSMSG'     tack JESYSMSG on the end
*
   USING S99RBP,R4               make S99RBP DSECT addressible
   USING S99RB,R3                make RB DSECT addressible
   L     R4,STORADR
   LA    R3,S99RBPTR+4           point 4 bytes after S99RBPTR
   ST    R3,S99RBPTR             make 'RBPTR' point to RB
   OI    S99RBPTR,S99RBPND       set high-order bit on in RBPTR
   XC    S99RB(RBLEN),S99RB      zeroise complete 'RB'
   MVI   S99RBLN,RBLEN           put length of RB in length field
   MVC   S99ERROR,=H'0'
   MVC   S99INFO,=H'0'
   LA    R2,24(R4)               start of text address pointers
   ST    R2,S99TXTPP
   MVI   S99VERB,S99VRBAL        set allocate verb
   XR    R1,R1                   clear R1 prior to access
   EPAR  R1                      go get ASID
   STH   R1,BTOKASID
   LA    R1,KEYA
   ST    R1,0(R2)                store key address
   LA    R1,KEYADS
   ST    R1,4(R2)                store key address
   LA    R1,KEYADISP
   ST    R1,8(R2)                store key address
   LA    R1,KEYSSID
   ST    R1,12(R2)               store key address
   LA    R1,KEYTOKEN
   ST    R1,16(R2)               store key address
   OI    16(R2),X'80'            indicate end of address list
   L     R1,STORADR              set R1 to addr. of RB pointer
   DYNALLOC

   IF (LTR,R15,R15,NZ)
     MVC   MESS_TXT(14),=CL14'DYNALLOC   RC='
     XUNPK (R15),4,MESS_TXT+14
     XUNPK S99ERROR,2,MESS_TXT+24
     XUNPK S99ERROR,2,MESS_TXT+30
     SEGDO WRITE_LOG
     MVC   MESS_TXT(8),KEYADDNM
     MVC   MESS_TXT+10(44),KEYADSN
     SEGDO WRITE_LOG
     PRGQUIT RC=16
   ENDIF
   DROP  R4
   DROP  R3
*
 SEGE DYNALLOC_JESYSMSG
*______________________________________________________________________
*
 SEGS RELEASE_JESYSMSG
*
   USING S99RBP,R4               make S99RBP dsect addressible
   USING S99RB,R3                make RB dsect addressible
   L     R4,STORADR
   LA    R3,S99RBPTR+4           point 4 bytes after s99rbptr
   ST    R3,S99RBPTR             make 'RBPTR' point to RB
   OI    S99RBPTR,S99RBPND       set on high-order bit in RBPTR
   XC    S99RB(RBLEN),S99RB      zeroise complete 'RB'
   MVI   S99RBLN,RBLEN           put length of RB in length field
   MVC   S99ERROR,=H'0'
   MVC   S99INFO,=H'0'
   LA    R2,24(R4)               start of text address pointers
   ST    R2,S99TXTPP
   MVI   S99VERB,S99VRBUN        set un-allocate verb
   LA    R1,KEYA
   ST    R1,0(R2)                store key address
   LA    R1,KEYADS
   ST    R1,4(R2)                store key address
   OI    4(R2),X'80'             indicate end of address list
   L     R1,STORADR              set R1 to addr. of RB pointer
   DYNALLOC

   IF (LTR,R15,R15,NZ)
     MVC   MESS_TXT(14),=CL14'UN-ALLOC   RC='
     XUNPK (R15),4,MESS_TXT+14
     XUNPK S99ERROR,2,MESS_TXT+24
     XUNPK S99ERROR,2,MESS_TXT+30
     SEGDO WRITE_LOG
     MVC   MESS_TXT(8),KEYADDNM
     MVC   MESS_TXT+10(44),KEYADSN
     SEGDO WRITE_LOG
     PRGQUIT RC=16
   ENDIF
   DROP  R4
   DROP  R3
*
 SEGE RELEASE_JESYSMSG
*______________________________________________________________________
*
 SEGS PROCESS_RECORD
*
*  it seems that IEF142I is always there but sometimes IEF374I is
*  present and sometimes IEF032I which is in multiple lines,
*  so cope with either
*
   IF (CLC,=C'IEF142I',EQ,IN_REC+1)
     MVC   IEF142I_MESS(60),IN_REC+9
   ELSEIF (CLC,=C'IEF374I',EQ,IN_REC+1)
     MVC   IEF374I_MESS(60),IN_REC+9
     IF (CLC,IEF142I_MESS,GT,SPACES)
       SEGDO FORMAT_OUTPUT
     ENDIF
     MVC   IEF142I_MESS,SPACES
     MVC   IEF374I_MESS,SPACES
   ELSEIF (CLC,=C'IEF032I',EQ,IN_REC+1)
     MVC   IEF032I_MESS_A(60),IN_REC+9
   ELSEIF (CLC,IEF032I_MESS_A,GT,SPACES)
     MVC   IEF032I_MESS_B(60),IN_REC+9
     IF (CLC,IEF142I_MESS,GT,SPACES)
       SEGDO FORMAT_OUTPUT
     ENDIF
     MVC   IEF142I_MESS,SPACES
     MVC   IEF032I_MESS_A,SPACES
     MVC   IEF032I_MESS_B,SPACES
   ENDIF
*
 SEGE PROCESS_RECORD
*______________________________________________________________________
*
 SEGS FORMAT_OUTPUT
*
   LA    R4,IEF142I_MESS
   LA    R5,60
   SEGDO FIND_BLANK
   IF (LTR,R5,R5,Z)
     MVC   MESS_TXT(20),=CL20'FAILED 1'
     SEGDO WRITE_LOG
     SEGQUIT
   ENDIF
   LA    R4,1(,R4)
   LA    R8,0(,R4)
   SEGDO FIND_BLANK
   IF (LTR,R5,R5,Z)
     MVC   MESS_TXT(20),=CL20'FAILED 2'
     SEGDO WRITE_LOG
     SEGQUIT
   ENDIF
   LR    R1,R4
   SR    R1,R8
   BCTR  R1,0
   EX    R1,MVC_STEPNAME
   LA    R4,1(,R4)
   LA    R8,0(,R4)
   IF (CLI,0(R8),NE,C'-')
     SEGDO FIND_BLANK
     IF (LTR,R5,R5,Z)
       MVC   MESS_TXT(20),=CL20'FAILED 3'
       SEGDO WRITE_LOG
       SEGQUIT
     ENDIF
     LR    R1,R4
     SR    R1,R8
     BCTR  R1,0
     EX    R1,MVC_PROCNAME
   ENDIF
   SEGDO FIND_COND_CODE
   IF (LTR,R5,R5,Z)
     MVC   MESS_TXT(20),=CL20'FAILED 4'
     SEGDO WRITE_LOG
     SEGQUIT
   ENDIF
   LA    R4,10(,R4)                    point after 'COND CODE '
   MVC   COND_CODE(4),=C'Cond'         insert only 'Cond'
   MVC   COND_CODE+5(4),0(R4)          copy value
   IF (CLC,=C'0000',EQ,COND_CODE+5)    if 0000
     MVC   COND_CODE+5(3),=C'---'      make it easier to see
   ELSEIF (CLC,=C'0004',EQ,COND_CODE+5) if 0004
     MVC   COND_CODE+5(2),=C'---'      make it easier to see
   ELSEIF (CLC,=C'0008',EQ,COND_CODE+5) if 0008
     MVI   COND_CODE+5,C'-'            make it easier to see
   ENDIF
*
   IF (CLC,IEF374I_MESS,GT,SPACES)
     MVC   T_STAMP(4),IEF374I_MESS+20
     MVI   T_STAMP+4,C'.'
     MVC   T_STAMP+5(6),IEF374I_MESS+24
     MVI   T_STAMP+8,C' '
     MVI   T_STAMP+11,C':'
     MVC   T_STAMP+12(2),IEF374I_MESS+30
     MVC   CPU_TIME(2),IEF374I_MESS+39
     MVI   CPU_TIME+2,C':'
     MVC   CPU_TIME+3(5),IEF374I_MESS+45
   ELSE
     MVC   T_STAMP(4),IEF032I_MESS_A+20
     MVI   T_STAMP+4,C'.'
     MVC   T_STAMP+5(6),IEF032I_MESS_A+24
     MVI   T_STAMP+8,C' '
     MVI   T_STAMP+11,C':'
     MVC   T_STAMP+12(2),IEF032I_MESS_A+30
     MVC   CPU_TIME(2),IEF032I_MESS_B+15
     MVI   CPU_TIME+2,C':'
     MVC   CPU_TIME+3(5),IEF032I_MESS_B+23
     IF (CLI,CPU_TIME,EQ,C'0')
       MVI   CPU_TIME,C' '
     ENDIF
   ENDIF
*
   IF (CLC,PROC_NAME,GT,SPACES)
     MVC   MESS_TXT+1(8),PROC_NAME
     MVC   MESS_TXT+11(8),STEP_NAME
   ELSE
     MVC   MESS_TXT+1(8),STEP_NAME
   ENDIF
   MVC   MESS_TXT+21(L'COND_CODE),COND_CODE
   MVC   MESS_TXT+33(L'CPU_TIME),CPU_TIME
   MVC   MESS_TXT+44(L'T_STAMP),T_STAMP
   SEGDO WRITE_LOG
   MVC   STEP_NAME,SPACES
   MVC   PROC_NAME,SPACES
*
 SEGE FORMAT_OUTPUT
*______________________________________________________________________
*
 SEGS FIND_BLANK
*
   IF (LTR,R5,R5,NZ)
     DO FROM=(R5)
     DOEXIT (CLI,0(R4),EQ,C' ')
       LA    R4,1(,R4)
     ENDDO
   ENDIF
*
 SEGE FIND_BLANK
*______________________________________________________________________
*
 SEGS FIND_CHAR
*
   IF (LTR,R5,R5,NZ)
     DO FROM=(R5)
     DOEXIT (CLI,0(R4),EQ,C' ')
       LA    R4,1(,R4)
     ENDDO
   ENDIF
*
 SEGE FIND_CHAR
*______________________________________________________________________
*
 SEGS FIND_COND_CODE
*
   IF (LTR,R5,R5,NZ)
     DO FROM=(R5)
     DOEXIT (CLC,=C'COND CODE',EQ,0(R4))
       LA    R4,1(,R4)
     ENDDO
   ENDIF
*
 SEGE FIND_COND_CODE
*______________________________________________________________________
*
 SEGS WRITE_LOG
*
   WTOX
*
 SEGE WRITE_LOG
*______________________________________________________________________
*
 PRGDCBI DCB=SYSIN,EOF=E_O_F,V2F=IN_REC
*______________________________________________________________________
*
         PRGSTAT
*
SPACES   DC    CL80' '
MVC_STEPNAME   MVC   STEP_NAME(0),0(R8)
MVC_PROCNAME   MVC   PROC_NAME(0),0(R8)
DYNA_THIS_DATASET    DC    CL44' '
*
SYSIN    DCB   DSORG=PS,DDNAME=BRWSPDCB,MACRF=(GL),EODAD=END_SYSIN
*
*  SYSOUT is defined only for RDJFCB to get userid, jobname and jobid
*  so it should be in the JCL as SYSOUT=*
*
SYSOUT   DCB   DSORG=PS,DDNAME=SYSOUT,MACRF=(PM),RECFM=FB,LRECL=80,    /
               EXLST=LIST1
LIST1    DS    0F
         DC    X'87',AL3(MY_JFCB)
         PUSH  PRINT,NOPRINT
         PRINT NOGEN
MY_JFCB  DS    0F
         IEFJFCBN LIST=NO
         POP   PRINT,NOPRINT
*
         DS    0D
STORADR  DC    A(MY_DYN_AREA)
RBLEN    EQU   S99RBEND-S99RB
*
KEYA     DC    Y(DALDDNAM)
         DC    X'0001'                1 ENTRY
         DC    X'0008'                LENGTH IS 8
KEYADDNM DC    CL8'BRWSPDCB'          DDNAME FOR ALLOCATION
*
KEYADS   DC    Y(DALDSNAM)
         DC    X'0001'                1 ENTRY
KEYADSL  DC    H'44'                  LENGTH IS 44
KEYADSN  DC    CL44' '                DATASET NAME
*
KEYADISP DC    Y(DALSTATS)            DISP=
         DC    X'0001'                1 ENTRY
         DC    X'0001'                LENGTH IS 1
         DC    X'08'                  DISP=SHR
*
KEYSSID  DC    Y(DALUASSR)            JES2=
         DC    X'0001'                1 ENTRY
         DC    X'0004'                LENGTH IS 4
         DC    C'JES2'                JES2
*
KEYTOKEN DC    Y(DALBRTKN)            BROWSE TOKEN
         DC    X'0007'                7 ENTRIES
BTOKPL1  DC    XL2'4'              ID LENGTH
BTOKID   DC    CL4'BTOK'           ID FIELD
*
BTOKPL2  DC    XL2'2'              VERSION LENGTH
BTOKVER  DS    0XL2                SERVICE VERSION NUMBER
BTOKTYPE DC    XL1'3'              CONTROL BLOCK TYPE
BTOKBRWS EQU   0                   BLOCK CREATED FOR BROWSE
*        EQU   1                   RESERVED - DO NOT EVER USE
BTOKSAPI EQU   2                   BLOCK CREATED BY SYSOUT API
BTOKSTKN EQU   3                   SPOOL DATA SET OR CLIENT
*                                    TOKEN ALLOCATION
BTOKVERS DC    XL1'3'              VERSION
BTOKVRNM EQU   3                   VERSION OS/390 RELEASE 10
**
BTOKPL3  DC    XL2'4'              SPOOL TOKEN LENGTH
BTOKIOTP DC    XL4'0'              IOT MTTR (OR ZERO)          @R10LSDB
BTOKSAPT EQU   BTOKIOTP,L'BTOKIOTP,T'BTOKIOTP  SAPI TOKEN      @R10LSDB
BTOKSPLT EQU   BTOKIOTP,L'BTOKIOTP,T'BTOKIOTP  CLIENT/DS TOKEN @R10LSDB
**
BTOKPL4  DC    XL2'4'              JOB KEY LENGTH
BTOKJKEY DC    XL4'0'              JOB KEY IN HEX
**
BTOKPL5  DC    XL2'2'              ASID LENGTH
BTOKASID DS    XL2                 ASID IN HEX
**
BTOKPL6  DC    XL2'8'              NETWORK RECEIVER USERID LENGTH
BTOKRCID DC    CL8'SPURT'          NETWORK RECEIVER USERID
**
BTOKPL7  DC    AL2(255)            LOG STRING PARAMETER LENGTH
BTOKLOGS DS    0CL255              LOG STRING PARAMETER
BTOKLSDL DC    XL1'0'              LOG STRING DATA LENGTH (0-254 BYTES)
BTOKLSDA DS    CL254               LOG STRING DATA
BTOKEND  EQU   *                   END OF BTOK
BTOKSIZE EQU   *-BTOKPL1           SIZE OF BTOK
*
         PUSH  PRINT,NOPRINT
         PRINT NOGEN
         DCBD  DSORG=QS,DEVD=DA
         IEFTIOT1
BRWSPOOL CSECT
         IEFZB4D0
         IEFZB4D2
         POP   PRINT,NOPRINT
*
BRWSPOOL CSECT
*
         LTORG
*
MY_DYN_AREA    DS    4096CL1
*
*  possible exit list values
*        07    JFCB exit
*        05    Data control block OPEN exit    EXLDCBEX
*        11    DCB abend exit
*  UT1ABEND EQU   *
*           L     R8,0(,R1)           GET COMPLETION CODE
*           N     R8,=A(X'FFF0FF00')  ensure nybles 4, 7 and 8 are zero
*           CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND
*           BE    UT1MEMBR            YES, BRANCH
*           MVI   4(R1),0             NO, ABNORMALLY TERMINATE
*           BR    R14
*  UT1MEMBR OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND
*           MVI   3(R1),4             IGNORE THE ABEND
*           BR    R14
*           DROP  R9
*        13    Allocation retrieval list       EXLARL
*
* Table 1. DCB exit list format and contents
* Entry Type                 Hex Code     Symbol
* Inactive entry                00      EXLINACT
* Input header label exit       01      EXLIHLAB
* Output header label exit      02      EXLOHLAB
* Input trailer label exit      03      EXLITLAB
* Output trailer label exit     04      EXLOTLAB
* Data control block OPEN exit  05      EXLDCBEX
* End-of-volume exit            06      EXLEOVEX
* JFCB exit                     07      EXLRJFCB
*                               08      Reserved
*                               09      Reserved
* User totaling area            0A      EXLUSTOT
* Block count unequal exit      0B      EXLBLCNT
* Defer input trailer label     0C      EXLDFRIT
* Defer nonstandard input trailer label         0D
*                               0E-0F   Reserved.
* FCB image                     10      EXLFCBIM
* DCB abend exit                11      EXLDCBAB
* QSAM parallel input           12      EXLPDAB
* Allocation retrieval list     13      EXLARL
*                               14      Reserved
* JFCBE exit                    15      EXLJFCBE
*                               16      Reserved
* OPEN/EOV nonspecific tape volume mount        17      EXLDCBSL
* OPEN/EOV volume security/verification         18      EXLDCBSC
*                               1A-7F   Reserved
* Last entry                    80      EXLLASTE
         PRGESTAT
         PRGEND
         END
