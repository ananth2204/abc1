./ ADD NAME=###DOC##
The following macros are part of the Concept 14 structured programming
macros which were written by Marvin Kessler in 1970.
They have been amended by John Gateley to use branch relative on
condition instead of branch on condition.

DO
DOEXIT
DOPROC
ELSE
ELSEIF
ENDDO
ENDEVAL
ENDIF
EVALUATE
GBLVARS
GETCC
IF
IFPROC
IFTEST
OTHERWSE
PLIST
POPINS
POPNEST
PUSHINS
PUSHLAB
PUSHNEST
STKINS
TESTNEST
WHEN

JRGTIOT   Copy of the MVT macro IEFTIOT1
          amended to make the DSECTs explicit.

The PRG*  macros are used to create structured programs which can
          be reentrant. Code RENT=Y.

PRGDEF    Module initialisation
          This sets up standard linkage and register equates.
          The modue defaults to AMODE=31 RMODE=ANY but this can
          be overridden.
          The following OPSYN commands are used so that any branch
          statements in macros are converted to branch relative.
          B          OPSYN BRU
          BAL        OPSYN BAS
          BALR       OPSYN BASR
          The LOCTR statement is used to split the module into #DATA
          and #CODE sections with the #DATA section first. The #DATA
          section starts with eye catchers of the module name and
          the assembly timestamp and is based on register 12.
          The FSEG parameter indicates the first code segment to
          be performed. Each code segment reuses register 11 as
          its base register and this is automatically maintained
          when other segments are performed using SEGDO.
          Note, NEVER branch out of a segment as the code base
          register will then have an invalid value and anything
          could happen. To exit a segment use SEGQUIT which returns
          to where the segment was called, or to exit the program
          use PRGQUIT.
          If RENT=Y is used the storage defined between PRGDEF and
          PRGEDEF will be getmained on entry to the program and
          freemained on exit. If RENT=N then this storage will map
          over an area in PRGSTAT.
          Facilities for writing rexx functions are provided by
          use of REXX=Y and INREX=Y. REXX=Y means that the program
          will be called as a rexx function and registers 7 to 10
          will map rexx programming interfaces. INREX=Y means that
          the program will be called by another REXX aware program
          and the registers will be maintained.
          A reentrant form of the WTO macro will be included and
          the field MESS_TXT should be used to build an output
          message and WTOX will write this and clear the area to
          spaces.

PRGEDEF   Module termination - storage defined between these macros
          is based on register 13 after the save area
          This handles exit processing and if rexx is active it
          checks if EVALBLOCK result has been set, if not is is
          populated with the return code in field R_C.
          R_C can be populated with SETRC RC=? or PRGQUIT RC=?.

PRGPARM   grap any parameter from R1 - use for JCL invocation

PRGSTAT   Module static storage for constants and DCB.
          This reestablishes the #DATA LOCTR so that this storage
          is based on register 12 and comes directly after timestamp.

PRGESTAT  Module end of static storage

PRGEND    Module end

PRGDCBI   Generate code segments for an input file (open,get,close)
          works with spanned records

PRGDCBO   Generate code segments for an output file (open,put,close)
          works with spanned records

PRGQUIT   Go directly to the module termination routine

PRGSTEM   Define storage for use in program PROCSTEM which looks
          after dropping and defining a rexx stem variable

SEGDO     perform a segment of code

SEGS      start a segment of code - when used with PRG* macros
          the same register is used as code base in all segments
          so each segment could be up to 4K. Never blow a base.

SEGQUIT   exit from this code segment back to wherever it came from.

SEGE      end of a segment of code

SETRC     set the R_C return code value in PRG*

BEDIT     build an edit pattern to use in ED or EDMK based on the
          size of the packed decimal field.

XEDIT     build an edit pattern to use in ED or EDMK based on the
          size of the packed decimal field and actually execute
          the ED or EDMK.

STRING    acts like the COBOL STRING verb and allows conversion
          of integer and packed-decimal values to numeric and
          register values to hexadecimal display.

STRINGIT  program used by STRING

TRIM      trim blanks from a variable
          removes leading and extra blanks from a variable.
          that is ' A  B ' becomes 'A B   '
          after completion R15 contains the length of the string
          ALL=Y can be used to remove all blanks
          that is ' A  B ' becomes 'AB    '

TRIMIT    program used by TRIM

TSTMP     generate a timestamp from STCKE
          FORMAT=DB2  - CL26'2017-04-01-12.34.56.789012'
                 CHAR - CL20'20170401123456789012'
                 PACK - PL11'020170401123456789012C'

WTOX      does a WTO from MESS_TXT which is defined in PRGDEF
          and then clears MESS_TXT to spaces unless CLEAR=N

XEDIT     build an edit pattern and execute it

XPACK     pack a character string to hex       C'C1F1' X'A1'
          uses a translate table that is automatically generated in
          PRGSTAT if XPACK has been used in the program.

XUNPK     unpack a hex string to character     X'A1' C'C1F1'
          uses a translate table that is automatically generated in
          PRGSTAT if XUNPK has been used in the program.

./ ADD NAME=BEDIT
         MACRO
&LABEL   BEDIT &INL,&PAD=' ',&DEC='.',&DECP=0,&THOU=',',&SIGN=
.**********************************************************************
.*
.* Created by John Gateley
.*
.*  This macro builds an edit pattern with the name specified
.*  which can then be copied into the output area and used in
.*  and ED or EDMK instruction.
.*  For EDMK &LABEL.S is equated to the offset from the start of
.*  the significant byte to be put in register 1 before executing.
.*  &LABEL.D is equated to the offset from the start to the
.*  decimal point. A comparison of the values in different edit
.*  patterns can be used to align the decimal point from multiple
.*  edit patterns to produce a nicely formatted report.
.*
.*       &INL  length of the packed field in bytes
.*
.*       &PAD  value for pad character       ' '
.*       &DEC  value for decimal point       '.'
.*       &DECP number of decimal places
.*       &THOU value for thousand separator  ','
.*       &SIGN value for sign, e.g.  SIGN=-  SIGN='-'  SIGN=' (CR)'
.*
.*  BEDIT 5                            for PL5
.*
.*  BEDIT 5,DECP=2                     for PL5 with two decimals
.*
.*  BEDIT 5,THOU=                      to give no separator
.*
.*  BEDIT 3,PAD=0,DEC=',',DECP=2,THOU='.',SIGN=' (CR)'
.*
.*  BEDIT 4,PAD=' ',DEC='.',DECP=0,THOU=','
.*
.*      MVC   LONG_CHAR1,LONG_EDP_1
.*      LA    R1,LONG_CHAR1
.*      AHI   R1,LONG_EDP_1L
.*      EDMK  LONG_CHAR1,LONG_PACK1
.*      BCTR  R1,0
.*      MVI   0(R1),C'$'
.*
.* LONG_PACK1     DC    PL8'12345678'
.* LONG_EDP_1     BEDIT 8,DECP=3,SIGN='-'
.* LONG_CHAR1     DS    CL(L'LONG_EDP_1)
.*
&CNT     SETA  0                         * set pattern count to 0
&CNTMRK  SETA  0                         * set EDMK offset
&CNTDEC  SETA  0                         * set decimal point offset
&SEL     SETC  '20'                      * set digit selector
&SIG     SETC  '21'                      * set significant digit sel
&PATN    SETC  ''                        * start with empty pattern
         AIF   ('&PAD' EQ '').NOPAD
         AIF   ('&PAD'(1,1) EQ '''').QUOT1  * value in quotes
&MPAD    SETC  '&PAD'
         AGO   .QUOT1A
.QUOT1   ANOP
&MPAD    SETC  '&PAD'(2,K'&PAD-2)
.QUOT1A  ANOP
&MPAD    SETC  C2X('&MPAD')              * convert to hex
&PATN    SETC  '&PATN&MPAD'              * put in pad character
&MYLEN   SETA  K'&MPAD/2                 * get length of pad
         AIF   (&MYLEN NE 1).MERR1       * can only be one
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
.NOPAD   ANOP
.*
&LENR    SETA  &INL                      * get input length
&LENR    SETA  &LENR*2                   * multiply by 2
&LENR    SETA  &LENR-1                   * subtract 1 gives no. digits
&LENR    SETA  &LENR-&DECP               * subtract number of decimals
.*
.AGAIN   ANOP
         AIF   (&LENR EQ 2).IS2
&PATN    SETC  '&PATN&SEL'               * put in digit select
         AGO   .NOT2
.IS2     ANOP
&PATN    SETC  '&PATN&SIG'               * put in significant digit
&CNTMRK  SETA  &CNT+1                    * set significant offset
.NOT2    ANOP
&CNT     SETA  &CNT+1                    * add to count in pattern
&LENR    SETA  &LENR-1                   * subtract 1 from remaining
         AIF   (&LENR EQ 0).NOAGIN
&LENT    SETA  (&LENR/3)*3               * divide by 3 and multiply
.*
         AIF   ('&THOU' EQ '').NOTHOU    * no thousand separator
         AIF   (&LENT NE &LENR).NOTHOU   * not multiple of 3 left
         AIF   ('&THOU'(1,1) EQ '''').QUOT2  * value in quotes
&MTHOU   SETC  '&THOU'
         AGO   .QUOT2A
.QUOT2   ANOP
&MTHOU   SETC  '&THOU'(2,K'&THOU-2)
.QUOT2A  ANOP
&MTHOU   SETC  C2X('&MTHOU')             * convert to hex
&PATN    SETC  '&PATN&MTHOU'             * put in thousand separator
&MYLEN   SETA  K'&MTHOU/2                * get length of thou separator
         AIF   (&MYLEN NE 1).MERR2       * can only be one
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
.NOTHOU  ANOP
         AIF   (&LENR GT 0).AGAIN        * anything remaining - repeat
.*
.NOAGIN  ANOP
.*
.* so now we have run out of digits before the decimal place (if any)
.*
         AIF   (&DECP EQ 0).TRYSGN       * if none try sign
         AIF   ('&DEC' EQ '').TRYSGN      * value in quotes
         AIF   ('&DEC'(1,1) EQ '''').QUOT3  * value in quotes
&MDEC    SETC  '&DEC'
         AGO   .QUOT3A
.QUOT3   ANOP
&MDEC    SETC  '&DEC'(2,K'&DEC-2)
.QUOT3A  ANOP
&MDEC    SETC  C2X('&MDEC')              * convert to hex
&PATN    SETC  '&PATN&MDEC'              * put in decimal separator
&CNTDEC  SETA  &CNT                      * set decimal point offset
&MYLEN   SETA  K'&MDEC/2                 * get length of dec separator
         AIF   (&MYLEN NE 1).MERR3       * can only be one
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
&LEND    SETA  &DECP                     * copy decimal places
.*
.TRYDEC  ANOP
&PATN    SETC  '&PATN&SEL'               * put in digit select
&CNT     SETA  &CNT+1                    * add to count in pattern
&LEND    SETA  &LEND-1                   * reduce decimal place count
         AIF   (&LEND NE 0).TRYDEC       * places remaining - so loop
.*
.TRYSGN  ANOP
         AIF   ('&SIGN' EQ '').NOSIGN    * sign byte required
         AIF   ('&SIGN'(1,1) EQ '''').QUOT9  * value in quotes
&MSIGN   SETC  '&SIGN'
         AGO   .QUOT9A
.QUOT9   ANOP
&MSIGN   SETC  '&SIGN'(2,K'&SIGN-2)
.QUOT9A  ANOP
&MSIGN   SETC  C2X('&MSIGN')             * convert to hex
&PATN    SETC  '&PATN.&MSIGN'            * put in sign value
&MYLEN   SETA  K'&MSIGN/2                * get length of record area
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
.NOSIGN  ANOP
.*
&LABEL   DC    X'&PATN'                  * create edit pattern
&LABEL.S EQU   &CNTMRK                   * significant digit offset R1
&LABEL.D EQU   &CNTDEC                   * decimal point offset
         MEXIT
.*
.MERR1   MNOTE 16,'Pad character can only be 1 byte'
         MEXIT
.MERR2   MNOTE 16,'Thousand separator can only be 1 byte'
         DC    'thou=&THOU'
         MEXIT
.MERR3   MNOTE 16,'Decimal separator can only be 1 byte'
         MEND
./ ADD NAME=DO
         MACRO
         DO    &P1,&FROM=,&TO=,&BY=,&UNTIL=,&WHILE=
         LCLA  &POSNO
         PUSHNEST DO
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*                                                                   *
.*  THE FOLLOWING SECTION HAS BEEN ADDED TO PREVENT MORE THAN ONE    *
.*  CONDITION FROM BEING SPECIFIED ON A "DO UNTIL" OR A "DO WHILE" . *
.*  THE MACRO ONLY EXPECTS ONE CONDITION, BUT DOES NOT REJECT        *
.*  MULTIPLE CONDITIONS.                                             *
.*                                                                   *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
         AIF   (T'&P1 EQ 'O').CHKPOS    IF NO POSITIONAL PARAMETER
         AIF   ('&P1' EQ 'INF').EXPAND  IF PARAMETER VALID
         MNOTE 50,'INVALID PARAMETER "&P1"'
         MNOTE 50,'DO MACRO - EXPANSION TERMINATED'
         MEXIT
.*
.CHKPOS  ANOP
&POSNO   SETA  N'&SYSLIST            NUMBER OF POSITIONAL PARMS
         AIF   (&POSNO EQ 0).EXPAND
         MNOTE 50,'TOO MANY POSITIONAL PARAMETERS SPECIFIED'
         MNOTE 50,'DO MACRO - EXPANSION TERMINATED'
         MEXIT
.*
.EXPAND  ANOP
.* * * * *  E N D   O F   A D D E D   S E C T I O N  * * * * * * * * *
         DOPROC &FROM,&TO,&BY,&UNTIL,&WHILE,&P1
         MEND
./ ADD NAME=DOEXIT
  MACRO
  DOEXIT   &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                   /
               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /
               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /
               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /
               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=
 GBLA &CCVAL
 GBLA &CTR
 GBLA &SEQ
 GBLA &AI
 GBLA &CI
 GBLA &II
 GBLA &LI
 GBLA &NI
 GBLA &AIND(50)
 GBLA &CIND1(200)
 GBLA &MULT(50)
 GBLA &ST(51)
 GBLC &CIND2(200)
 GBLC &IIND1(100)
 GBLC &IIND2(100)
 GBLC &I22(100)
 GBLC &I23(100)
 GBLC &I24(100)
 GBLC &IIND3(100)
 GBLC &I32(100)
 GBLC &I33(100)
 GBLC &I34(100)
 GBLC &IIND4(100)
 GBLC &I42(100)
 GBLC &I43(100)
 GBLC &IIND5(100)
 GBLC &LIND(101)
 GBLC &NEST(50)
 GBLC &RIND(50)
 PUSHLAB
&NEST(&NI) SETC '&NEST(&NI)'(1,4)'DO'
 IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                  /
               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /
               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /
               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /
               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50
  MEND
./ ADD NAME=DOPROC
  MACRO
  DOPROC &FROM,&TO,&BY,&UNTIL,&WHILE,&P1
  GBLA  &CCVAL   COND CODE VARIABLE
  GBLA  &CTR   MACRO PARAMETER COUNTER
  GBLA  &SEQ   LABEL NUMBER GENERATOR
  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK
  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS
  GBLA  &II   PTR TO INST STKS
  GBLA  &LI   INDEX FOR LABEL NUMBER STK
  GBLA  &NI   PTR TO NEST STK
  GBLA  &AIND(50)  TOTAL CASES STK
  GBLA  &CIND1(200)  CASE NUMBER STK
  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER
  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL
  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES
  GBLC  &IIND1(100)  INSTRUCTION STK 1
  GBLC  &IIND2(100)  INSTRUCTION STK 2
  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART
  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART
  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART
  GBLC  &IIND3(100)  INSTRUCTION STK 3
  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART
  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART
  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART
  GBLC  &IIND4(100)  INSTRUCTION STK 4
  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART
  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART
  GBLC  &IIND5(100)  INSTRUCTION NAME STACK
  GBLC  &LIND(101)  LABEL NUMBER STK
  GBLC  &NEST(50)  NESTING STK
  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO
  LCLA  &I
  LCLC  &LCLWK1
    PUSHLAB
    PUSHINS (EQU,*,,,,&LIND(&LI))
&ST(&NI)   SETA    &II+1
    PUSHLAB
    AIF  (T'&FROM EQ 'O').NOIND
  AIF   ('&FROM(3)' EQ '').INCR
    LA &FROM(3),&LIND(&LI)
.INCR  ANOP
&I  SETA  &I+1
  AIF   ('&SYSLIST(&I,2)' EQ '').TEST
    AIF ('&SYSLIST(&I,2)'(1,1) EQ '(').GENLR
      AIF ('&SYSLIST(&I,2)' EQ '0').GENSR
        AIF ('&SYSLIST(&I,2)'(1,1) EQ '-').NEGVAL
   AIF (T'&SYSLIST(&I,2) EQ 'N').POSVAL
     LA  &SYSLIST(&I,1),&SYSLIST(&I,2)
     AGO .TEST
.POSVAL   AIF (&SYSLIST(&I,2) GE 4096).TSTMAG
     LA  &SYSLIST(&I,1),&SYSLIST(&I,2)
     AGO .TEST
.TSTMAG   AIF (&SYSLIST(&I,2) GE 32768).FULLIT
     AGO .HALFLIT
.NEGVAL        ANOP
&LCLWK1   SETC '&SYSLIST(&I,2)'(2,7)
   AIF (&LCLWK1 GE 32768).FULLIT
.HALFLIT       LHI &SYSLIST(&I,1),&SYSLIST(&I,2)
   AGO .TEST
.FULLIT        L &SYSLIST(&I,1),=F'&SYSLIST(&I,2)'
   AGO .TEST
.GENSR      SR &SYSLIST(&I,1),&SYSLIST(&I,1)
        AGO .TEST
.GENLR    LR &SYSLIST(&I,1),&SYSLIST(&I,2)
.TEST  AIF   (&I LT 3).INCR
    AIF  (T'&UNTIL NE 'O').ERRMG2
.CKWHILE     AIF   (T'&WHILE NE 'O').COMPGEN
&LIND(&LI) EQU  *
.POSTIND   AIF  (T'&P1 EQ 'O').GETIND
      AIF   (T'&BY NE 'O').PFB
        AIF   (T'&TO NE 'O').PFT
   AIF   ('&FROM(3)' NE '').BCTRZ
     PUSHINS (BRCT,&FROM(1),&LIND(&LI))
   AGO   .ERRMG
.BCTRZ   PUSHINS (BCTR,&FROM(1),&FROM(3))
        AGO     .ERRMG
.PFT        PUSHINS (&P1,&FROM(1),&TO(1),&LIND(&LI))
      MEXIT
.PFB      PUSHINS (&P1,&FROM(1),&BY(1),&LIND(&LI))
    MEXIT
.GETIND    AIF  ('&FROM(3)' EQ '').BCTR1
      PUSHINS (BCTR,&FROM(1),&FROM(3))
    MEXIT
.BCTR1    AIF  (T'&BY NE 'O').FB
      AIF   (T'&TO EQ 'O').FONLY
        PUSHINS (BXLE,&FROM(1),&TO(1),&LIND(&LI))
      MEXIT
.FONLY      PUSHINS (BRCT,&FROM(1),&LIND(&LI))
    MEXIT
.FB    AIF  (T'&TO NE 'O').FTB
      AIF   ('&BY(2)' EQ '').GENBXLE
      AIF   ('&BY(2)'(1,1) NE '-').GENBXLE
    AGO  .GENBXH
.FTB    AIF  ('&TO(2)' EQ '' OR '&FROM(2)' EQ '').GENBXLE
      AIF   ('&FROM(2)'(1,1) EQ '(').GENBXLE
      AIF   ('&FROM(2)'(1,1) EQ '-').TRYTNEG
      AIF   (T'&FROM(2) NE 'N').GENBXLE
      AIF   ('&TO(2)'(1,1) EQ '(').GENBXLE
      AIF   ('&TO(2)'(1,1) EQ '-').GENBXH
      AIF   (T'&TO(2) NE 'N').GENBXLE
      AIF   (&FROM(2) GT &TO(2)).GENBXH
.GENBXLE   PUSHINS (BXLE,&FROM(1),&BY(1),&LIND(&LI))
    MEXIT
.TRYTNEG   AIF  ('&TO(2)'(1,1) NE '-').GENBXLE
    AIF  ('&FROM(2)'(2,7) GE '&TO(2)'(2,7)).GENBXLE
.GENBXH    PUSHINS (BXH,&FROM(1),&BY(1),&LIND(&LI))
    MEXIT
.NOIND      AIF   (T'&WHILE EQ 'O').NOWHILE
        AIF   (T'&UNTIL NE 'O').COMPGEN
.* BC    15,&LIND(&LI)
   BRC   15,&LIND(&LI)
   PUSHLAB
&LI   SETA &LI-1
&LIND(&LI+1)  EQU  *
   AIF   ('&WHILE(6)' EQ '').OKSUBL
     STKINS &WHILE
     MEXIT
.OKSUBL   STKINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),      X
        &WHILE(5),&LIND(&LI))
   AIF   ('&WHILE(2)' EQ '').LABEL
     PUSHINS (BRC,&CCVAL,&LIND(&LI+1))
     MEXIT
.LABEL   PUSHINS   (BRC,&CCVAL,&LIND(&LI+1),,,&LIND(&LI))
   MEXIT
.NOWHILE     AIF   (T'&UNTIL EQ 'O').TRYINF
&LIND(&LI)   EQU   *
.UNT        STKINS &UNTIL
        PUSHINS (BRC,15-&CCVAL,&LIND(&LI))
      MEXIT
.TRYINF        AIF   ('&P1' NE 'INF').ERRMG1
&LIND(&LI)  EQU *
   PUSHINS (BRC,15,&LIND(&LI))
        MEXIT
.COMPGEN     AIF   ('&WHILE(6)' EQ '').OK
        STKINS &WHILE
        AGO   .BCHINST
.OK      STKINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),        X
        &WHILE(5),&LIND(&LI))
      AIF   (N'&WHILE GT 1).ENDCOMP
&LIND(&LI)     BC    15-&CCVAL,&LIND(&LI-1)
*&LIND(&LI)     BRC   15-&CCVAL,&LIND(&LI-1)
        AGO   .FLAGEQU
.ENDCOMP     ANOP
&ST(&NI+1)   SETA  &II
      POPINS &ST(&NI+1)
.BCHINST     BC    15-&CCVAL,&LIND(&LI-1)
*.BCHINST     BRC   15-&CCVAL,&LIND(&LI-1)
.FLAGEQU     ANOP
&NEST(&NI)   SETC  '   Y'.'&NEST(&NI)'(5,4)
      AIF   (T'&FROM NE 'O').POSTIND
    AGO  .UNT
.ERRMG  MNOTE 4,'POSITIONAL PARAMETER IGNORED. BCT/BCTR LOOP END USED'
  MEXIT
.ERRMG2  MNOTE 4,'UNTIL KEYWORD INVALID WITH INDEXING GROUP. IGNORED'
  AGO   .CKWHILE
.ERRMG1  MNOTE 4,'NO WHILE,UNTIL,OR INDEXING PARAMETERS ON DO MACRO.'
  MEND
./ ADD NAME=ELSE
  MACRO
  ELSE
        COPY GBLVARS
  GBLC  &LASTIF
  IFTEST ELSE
&LIND(&LI+1) SETC '&LIND(&LI)'
&LI  SETA &LI-1
  PUSHLAB
.*BC    15,&LIND(&LI)
  BRC   15,&LIND(&LI)
&LIND(&LI+1)   EQU   *
        MEND
./ ADD NAME=ELSEIF
 MACRO
 ELSEIF  &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                     /
               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /
               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /
               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /
               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=
  COPY GBLVARS
  GBLC  &LASTIF
  IFTEST ELSEIF
&LIND(&LI+1) SETC '&LIND(&LI)'
&LI  SETA  &LI-1
  PUSHLAB
.*BC   15,&LIND(&LI-1)
  BRC  15,&LIND(&LI-1)
&LIND(&LI+1) EQU   *
  IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                 /
               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /
               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /
               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /
               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50
 MEND
./ ADD NAME=ENDDO
  MACRO
  ENDDO
  GBLA &ST(51),&NI,&LI,&II
  POPINS &ST(&NI)
&II  SETA &II-1
  POPNEST DO
&LI  SETA &LI-2
  MEND
./ ADD NAME=ENDEVAL
         MACRO
&LAB     ENDEVAL
.*
.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE
.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.
.*
.* THE GENERAL STRUCTURE IS AS FOLLOWS -
.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)
.*      WHEN   OP2REST,OP2REST
.*      WHEN   OP2REST-OP2REST,OP2REST
.*      OTHERWSE
.*    ENDEVAL
.*
.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &ON(16)
.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &OE(16)
.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)
         GBLA  &OD
.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OELSE(16)
.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OPTN(16)
.* OPT INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OPTI(16)
.*
.IF0     AIF   (T'&LAB EQ 'O').END0
&LAB     EQU   *
.END0    ANOP
.IF0A    AIF   (&OD NE 0).END0A
         MNOTE 16,'UNMATCHED ENDOPT'
         MEXIT
.END0A   ANOP
.IF1     AIF   (&OD LE 16).END1
         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'
         AGO   .REDUCE
.END1    ANOP
.* SET OPTION INDICATOR OFF
&OPTN(&OD) SETB (0)
.IF3     AIF   ((&OELSE(&OD)) EQ (1)).END3
.* WHEN NO OPTELSE CLAUSE NEED CURRENT GENERATION NUMBER LABEL
@D&OD.N&ON(&OD) EQU   *
.END3    ANOP
&OELSE(&OD) SETB (0)
&OPTI(&OD) SETB (0)
.* SET LABEL FOR STRAIGHT END EXIT
@D&OD.E&OE(&OD) EQU   *
.REDUCE  ANOP
.* REDUCE DEPTH COUNT
&OD      SETA  &OD-1
         MEND
./ ADD NAME=ENDIF
  MACRO
  ENDIF
        COPY GBLVARS
  GBLC  &LASTIF
  IFTEST ENDIF
  POPNEST IF
&LIND(&LI) EQU *
&LIND(&LI-1) EQU *
&LI  SETA &LI-2
  MEND
./ ADD NAME=EVALUATE
         MACRO
&LAB     EVALUATE &OPCODE,&OPER1,&OPER2
.*
.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE
.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.
.*
.* THE GENERAL STRUCTURE IS AS FOLLOWS -
.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)
.*      WHEN   OP2REST,OP2REST
.*      WHEN   OP2REST-OP2REST,OP2REST
.*      OTHERWSE
.*    ENDEVAL
.*
.* OPCODE FOR EACH POSSIBLE TYPE
         GBLC  &OP(16)
.*
.* COMPONENTS OF OP1 FOR EACH POSSIBLE DEPTH
         GBLC  &OP1(16)
.*
.* OP2.REP.TYPE.LTH FOR EACH POSSIBLE DEPTH
         GBLC  &OP2(16)
.*
.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &ON(16)
.*
.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &OE(16)
.*
.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)
         GBLA  &OD
.*
.* IMMEDIATE INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OI(16)
.*
.* QUOTES INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OQ(16)
.*
.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OPTN(16)
.*
.* STATUS INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OS(16)
.*
.* LOCAL WORK FIELDS
         LCLA  &A
         LCLC  &C1,&C2,&C3,&C4,&C5,&C6,&C7,&C8
.*
.IF0     AIF   (T'&LAB EQ 'O').END0
&LAB     EQU   *
.END0    ANOP
.IF0A    AIF   (&OD EQ 0).END0A
.IF0B    AIF   ((&OPTN(&OD)) EQ (0)).END0B
         MNOTE 16,'DUPLICATE OPTION'
&OS(&OD) SETB  (1)
         MEXIT
.END0B   ANOP
.END0A   ANOP
.* INCREMENT COUNT OF DEPTH OF NESTING
&OD      SETA  &OD+1
.IF1     AIF   (&OD LE 16).END1
         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'
         MEXIT
.END1    ANOP
.* SET OPTION INDICATOR FOR THIS DEPTH (1= OPTION MACRO LAST MET)
&OPTN(&OD) SETB (1)
.* ZEROISE STATUS INDICATOR FOR THIS DEPTH (1= OPTION STATEMENT ERROR)
&OS(&OD) SETB  (0)
.* ZEROISE IMMEDIATE INDICATOR FOR THIS DEPTH (1= CLI OPCODE)
&OI(&OD) SETB  (0)
.* ZEROISE QUOTES INDICATOR FOR THIS DEPTH (1= QUOTES EXPECTED)
&OQ(&OD) SETB  (0)
.* INCREMENT LABEL GENERATION NUMBER FOR THIS DEPTH
&ON(&OD) SETA  &ON(&OD)+1
.* SAVE LABEL GENERATION NUMBER FOR END LABEL FOR THIS DEPTH
&OE(&OD) SETA  &ON(&OD)
.* INCREMENT LABEL GENERATION NUMBER FOR THIS DEPTH
&ON(&OD) SETA  &ON(&OD)+1
.IF2A    AIF  (K'&OPCODE GT 0).END2A
         MNOTE 16,'NO OPCODE SPECIFIED'
&OS(&OD) SETB  (1)
         AGO   .MEND
.END2A   ANOP
.OKOLTH  AIF   ('&OPCODE'(1,1) EQ 'C').OKC
         MNOTE 16,'INVALID OPCODE'
&OS(&OD) SETB  (1)
         AGO   .MEND
.OKC     AIF   ('&OPCODE' NE 'CLI').END2AA
&OI(&OD) SETB  (1)
.END2AA  ANOP
&OP(&OD) SETC  '&OPCODE'
.IF2B    AIF   (T'&OPER1 NE 'O').END2B
         MNOTE 16,'NO FIRST OPERAND SPECIFIED'
&OS(&OD) SETB  (1)
         AGO   .MEND
.END2B   ANOP
&OP1(&OD) SETC '&OPER1'
.IF3     AIF   (T'&OPER2 NE 'O').ELS3
&OQ(&OD) SETB  (0)
&OP2(&OD) SETC ''
         AGO   .END3
.ELS3    ANOP
.IF3A    AIF   (K'&OPER2 LE 8).END3A
         MNOTE 16,'THIRD PARAMETER OVERLONG'
&OS(&OD) SETB  (1)
         AGO   .MEND
.END3A   ANOP
         AIF   ('&OPER2'(1,1) NE '=').TRYI
         AIF   ((&OI(&OD)) EQ (0)).TRYSOLO
         MNOTE 16,'ILLEGAL IMMEDIATE OPERAND'
&OS(&OD) SETB  (1)
         AGO   .MEND
.TRYSOLO AIF   (K'&OPER2 NE 1).OKOP2
&OQ(&OD) SETB  (0)
&OP2(&OD) SETC '&OPER2'
         AGO   .END3
.TRYI    AIF   ((&OI(&OD)) EQ (1)).OKOP2
         MNOTE 16,'ILLEGAL LITERAL'
&OS(&OD) SETB  (1)
         AGO   .MEND
.OKOP2   ANOP
&OQ(&OD) SETB  (1)
&OP2(&OD) SETC '&OPER2'
.END3    ANOP
.MEND    ANOP
         BRU   @D&OD.N&ON(&OD)
         MEXIT
.*
.*  EXAMPLES OF USING EVALUATE
.*
.*  EVALUATE
.*
.*  EVALUATE is used to select which of several pieces of code is to
.*  be executed when that selection depends upon the value of a
.*  particular field.  In such cases, EVALUATE is more elegant, more
.*  readable, and more logical than the overused ELSEIF.
.*  The general format is:
.*
.*               EVALUATE opcode,op1(,op2)
.*                 WHEN op2value
.*                   code
.*                 WHEN op2value1-op2value2
.*                   code
.*                 WHEN op2value1-op2value2,op2value
.*                   code
.*                 OTHERWSE
.*                   code
.*               ENDOPT
.*
.*  where: 'opcode' is one of - CLC, CLI, CP, CH, C, CLR, CL, CR;
.*         'op1' is the address of the determinant field;
.*         'op2' is the constant type and length (if this is common
.*               to all the WHEN values).
.*
.*  The EVALUATE macro declares the type of comparison to be done on
.*  the determinant field.  It is followed by a series of WHEN clauses,
.*  each of which specifies a list of values and/or ranges, and heads
.*  the lines of code to be executed if that WHEN is selected. Only
.*  one WHEN clause, the first to satisfy the test, will be executed.
.*  OPTELSE, if coded, should follow the final WHEN (and will often
.*  head a 'value not found' error procedure).  The OTHERWSE code will
.*  be executed if none of the WHEN values matches the determinant;
.*  if there is no match and no OTHERWSE clause, processing continues
.*  normally, without any of the WHEN clauses having been executed.
.*  ENDOPT terminates the EVALUATE block.
.*
.*  Processing will be most efficient when the WHEN clauses are written
.*  in order of decreasing probability of selection, and when the
.*  values within each WHEN are in order of decreasing probability of
.*  occurrence.
.*  EVALUATE blocks can be nested to a maximum depth of 16.
.*  No registers are corrupted by OPTION.
.*
.*  The following examples illustrate OPTION's commoner modes of use.
.*
.*  1.  EVALUATE CP,COUNT,=P
.*        WHEN '1'
.*          code
.*        WHEN '2'
.*          code
.*        WHEN '3','4','5'
.*          code
.*        WHEN '6'-'99'
.*          code
.*        OTHERWSE
.*          code
.*      ENDOPT
.*
.*  2.  EVALUATE CP,TAX(3)
.*        WHEN =P'0'
.*          code
.*        WHEN =P'1',=P'1000'
.*          code
.*        WHEN PFLDA(3)-PFLDB(5),0(5,R6)
.*          code
.*        WHEN PHIGH
.*          code
.*      ENDOPT
.*
.*  3.  EVALUATE CLI,BDETCRR3,C
.*        WHEN 'A'
.*          ZAP ACUSELDS,=P'-5'
.*        WHEN 'B'
.*          ZAP ACUSELDS,=P'-4'
.*        WHEN 'D'
.*          ZAP ACUSELDS,=P'-2'
.*        WHEN 'E'
.*          ZAP ACUSELDS,=P'-1'
.*        OTHERWSE
.*          PERFORM ERRSCORE
.*      ENDOPT
.*
.*  4.  EVALUATE CLI,BDETDKCN,X           SELECT BY COMPANY
.*        WHEN '53'                       COUNTRY GARDEN
.*          PERFORM CGPOST
.*        WHEN '26'                       SHOWCASE
.*          MVI OSNOPPCH,C'0'             NOT YET CHARGED
.*          ZAP OSNOPANP,=P'150'          POST AND PACK CHARGE
.*        WHEN '63'                       SHOPPING SENSE
.*          MVI OSNOPPCH,C'0'             NOT YET CHARGED
.*          ZAP OSNOPANP,=P'195'          POST AND PACK CHARGE
.*        OTHERWSE
.*          IF (CLC,CUSTNO(3),E,=C'184')  BARGAIN BASEMENT
.*            MVI OSNOPPCH,C'0'           NOT YET CHARGED
.*            ZAP OSNOPANP,=P'200'        POST AND PACK CHARGE
.*          ELSE
.*            IF (CLC,CUSTNO(3),E,=C'183')  NEW HORIZONS
.*              PERFORM NHPOST
.*            ENDIF
.*          ENDIF
.*      ENDOPT
.*
.*  5.  EVALUATE CH,R2,=H
.*        WHEN '0'
.*          PERFORM READPBDF
.*        WHEN '4'
.*          L R5,0(R1)
.*          ST R5,PARMADDR
.*          .
.*          .
.*          .
.*        WHEN '12'
.*          IF (CLI,FIRSTSW,E,C'Y')
.*            MVI FIRSTSW,C'N'
.*          ENDIF
.*          PERFORM READPBCF
.*      ENDOPT
.*
.*  6.  EVALUATE CLC,ACUSCLUS,=CL2
.*        WHEN '04','13','14','27'
.*          MVC C200PRCI,=C'20'
.*        WHEN '19','24'-'26'
.*          MVC C200PRCI,=C'30'
.*        WHEN '10','11','16'-'18','22','29'
.*          MVC C200PRCI,=C'40'
.*        WHEN '01','03','07','08','12'
.*          MVC C200PRCI,=C'50'
.*        WHEN '05','06','09','15','20','21','23','28','30'
.*          MVC C200PRCI,=C'60'
.*        OTHERWSE
.*          MVC C200PRCI,=C'70'
.*      ENDOPT
.*
.*  In the above example, since the implicit length of ACUSCLUS is
.*  two bytes, 'OPTION CLC,ACUSCLUS,=C' could have been coded;
.*  or even 'OPTION CLC,ACUSCLUS' with 'OPT =C'04',=C'13'...'.
.*
.*  7.  EVALUATE C,R2
.*        WHEN =F'0',0(R3)
.*          code
.*        WHEN 4(R3)-8(R3)
.*          code
.*        WHEN FWORD1-FWORD2
.*          code
.*        WHEN =F'4000'-FWORD3
.*          code
.*        WHEN =4X'FF'
.*          code
.*      ENDOPT
.*
.*  8.  EVALUATE CR,R2
.*        WHEN R6-R7,R8
.*          code
.*        WHEN R9
.*          code
.*      ENDOPT
.*
         MEND
./ ADD NAME=GBLVARS
   GBLA &CCVAL        COND CODE VARIABLE
   GBLA &CTR        MACRO PARAMETER COUNTER
   GBLA &SEQ        LABEL NUMBER GENERATOR
   GBLA &AI        INDEX FOR TOTAL NO. CASES STK
   GBLA &CI        INDEX FOR CASE AND LBL NO. STKS
   GBLA &II        PTR TO INST STKS
   GBLA &LI        INDEX FOR LABEL NUMBER STK
   GBLA &NI        PTR TO NEXT STK
   GBLA &AIND(50)       TOTAL CASES STK
   GBLA &CIND1(200)       CASE NUMBER STK
   GBLA &MULT(50)       CASE NUMBER MULTIPLIER
   GBLA &ST(51)        INST STK INCREASE AT EACH LEVEL
   GBLC &CIND2(200)       LABEL NUMBER STK FOR CASES
   GBLC &IIND1(100)       INSTRUCTION STK 1
   GBLC &IIND2(100)       INSTRUCTION STK 2
   GBLC &I22(100)       INSTRUCTION STK 2,2ND PART
   GBLC &I23(100)       INSTRUCTION STK 2,3RD PART
   GBLC &I24(100)       INSTRUCTION STK 2,4TH PART
   GBLC &IIND3(100)       INSTRUCTION STK 3
   GBLC &I32(100)       INSTRUCTION STK 3,2ND PART
   GBLC &I33(100)       INSTRUCTION STK 3,3RD PART
   GBLC &I34(100)       INSTRUCTION STK 3,4TH PART
   GBLC &IIND4(100)       INSTRUCTION STK 4
   GBLC &I42(100)       INSTRUCTION STK 4,2ND PART
   GBLC &I43(100)       INSTRUCTION STK 4,3RD PART
   GBLC &IIND5(100)       INSTRUCTION NAME STACK
   GBLC &LIND(101)       LABEL NUMBER STK
   GBLC &NEST(50)       NESTING STK
   GBLC &RIND(50)       REG STK FOR CASENTRY MACRO
   GBLC &SEGNAME       SEGMENT NAME
   GBLC &SEGSTRT       SEGMENT START
./ ADD NAME=GETCC
  MACRO
  GETCC &COND
  GBLA  &CCVAL
  LCLC  &LWK1
  AIF   ('&COND'(1,1) LT '0' OR '&COND'(1,1) GT '9').NOTNUM
&CCVAL    SETA  &COND
    MEXIT
.NOTNUM  AIF   (K'&COND NE 1).TWOCHAR
&LWK1    SETC  '&COND'
    AGO  .CALCC
.TWOCHAR AIF   (K'&COND NE 2).INVCOND
    AIF  ('&COND'(1,1) NE 'N').OTHERMN
&LWK1      SETC  '&COND'(2,1)
    AGO  .CALCC
.OTHERMN   AIF  ('&COND' EQ 'EQ').BC8
    AIF  ('&COND' EQ 'LT').BC4
    AIF  ('&COND' NE 'LE').TRYGT
&CCVAL      SETA  13
    MEXIT
.TRYGT    AIF  ('&COND' EQ 'GT').BC2
    AIF  ('&COND' NE 'GE').INVCOND
&CCVAL      SETA  11
    MEXIT
.CALCC  AIF   ('&LWK1' NE 'O').TRYH
&CCVAL    SETA 1
  AGO   .TSTN
.TRYH  AIF   ('&LWK1' EQ 'P' OR '&LWK1' EQ 'H').BC2
    AIF ('&LWK1' EQ 'L' OR '&LWK1' EQ 'M').BC4
      AIF ('&LWK1' EQ 'E' OR '&LWK1' EQ 'Z').BC8
        AGO   .INVCOND
.BC8      ANOP
&CCVAL      SETA 8
      AGO   .TSTN
.BC4    ANOP
&CCVAL    SETA 4
    AGO  .TSTN
.BC2  ANOP
&CCVAL  SETA  2
.TSTN  AIF   ('&COND'(1,1) NE 'N').DONE
&CCVAL      SETA  15-&CCVAL
.DONE  MEXIT
.INVCOND ANOP
&CCVAL  SETA  15
  MNOTE 4,'INVALID CONDITION MNEMONIC. NOP GENERATED'
  MEND
./ ADD NAME=IF
      MACRO
      IF &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                     /
               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /
               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /
               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /
               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=
      COPY  GBLVARS
      GBLC  &LASTIF
      IFTEST IF
      PUSHNEST IF
      PUSHLAB
      PUSHLAB
      IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,             /
               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /
               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /
               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /
               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50
      MEND
./ ADD NAME=IFPROC
    MACRO
    IFPROC
  GBLA  &CCVAL   COND CODE VARIABLE
  GBLA  &CTR   MACRO PARAMETER COUNTER
  GBLA  &SEQ   LABEL NUMBER GENERATOR
  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK
  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS
  GBLA  &II   PTR TO INST STKS
  GBLA  &LI   INDEX FOR LABEL NUMBER STK
  GBLA  &NI   PTR TO NEST STK
  GBLA  &AIND(50)  TOTAL CASES STK
  GBLA  &CIND1(200)  CASE NUMBER STK
  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER
  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL
  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES
  GBLC  &IIND1(100)  INSTRUCTION STK 1
  GBLC  &IIND2(100)  INSTRUCTION STK 2
  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART
  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART
  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART
  GBLC  &IIND3(100)  INSTRUCTION STK 3
  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART
  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART
  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART
  GBLC  &IIND4(100)  INSTRUCTION STK 4
  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART
  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART
  GBLC  &IIND5(100)  INSTRUCTION NAME STACK
  GBLC  &LIND(101)  LABEL NUMBER STK
  GBLC  &NEST(50)  NESTING STK
  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO
    LCLB &ANDIND,&ORIND
    PUSHLAB
&CTR    SETA 2
&ST(&NI+1) SETA &II+1
&NEST(&NI) SETC '  R'.'&NEST(&NI)'(4,5)
    AIF (T'&SYSLIST(1) EQ 'O').LOOP
    AIF (&SYSLIST(1) LE 0 OR &SYSLIST(1) GE 15).INVALCC
&CCVAL      SETA &SYSLIST(1)
      AIF ('&SYSLIST(2)' EQ '').ENDBOOL
  MNOTE 4,'CC KEYWORD USED. OTHER PARAMETERS IGNORED'
  AGO .ENDBOOL
.INVALCC MNOTE 4,'CC OUTSIDE VALID RANGE OF 1 TO 14. NOP GENERATED'
&CCVAL  SETA  15
    AGO .ENDBOOL
.LOOP    STKINS &SYSLIST(&CTR),&SYSLIST(&CTR+1),&SYSLIST(&CTR+2),      /
               &SYSLIST(&CTR+3),&SYSLIST(&CTR+4)
    AIF ('&SYSLIST(&CTR+1)' EQ 'AND').ANDPROC
    AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF').TESTOR
.ANDPROC     PUSHINS (BRC,15-&CCVAL,&LIND(&LI-1))
&ANDIND      SETB 1
      AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF' OR NOT &ORIND).TESTLP
        POPINS &ST(&NI+1)
&LIND(&LI)     EQU *
&ORIND        SETB 0
&LI        SETA &LI-1
        PUSHLAB
      AGO .TESTLP
.TESTOR    AIF ('&SYSLIST(&CTR+1)' EQ 'OR').ORPROC
    AIF ('&SYSLIST(&CTR+1)' NE 'ORIF').TESTLP
.ORPROC      PUSHINS (BRC,&CCVAL,&LIND(&LI))
&ORIND      SETB 1
      AIF ('&SYSLIST(&CTR+1)' NE 'ORIF' OR NOT &ANDIND).TESTLP
        PUSHINS (EQU,*,,,,&LIND(&LI-1))
&ANDIND        SETB 0
        PUSHLAB
&LI        SETA &LI-1
&LIND(&LI-1)   SETC '&LIND(&LI+1)'
.TESTLP    ANOP
&CTR    SETA &CTR+2
    AIF ('&SYSLIST(&CTR-1)' NE '').LOOP
.ENDBOOL     AIF ('&NEST(&NI)'(5,4) EQ 'DO').DOEND
      POPINS &ST(&NI+1)
.*    BC   15-&CCVAL,&LIND(&LI-1)
      BRC  15-&CCVAL,&LIND(&LI-1)
      AIF (NOT &ORIND).POPLBL
&LIND(&LI)     EQU *
.POPLBL      ANOP
&LI      SETA &LI-1
    MEXIT
.DOEND    ANOP
&CTR    SETA  &ST(&NI+1)
    AGO  .ENDLBL
.NXTLBL    AIF  ('&IIND3(&CTR)' NE '&LIND(&LI)').INCTR
&IIND3(&CTR) SETC  '&LIND(&LI-3)'
.INCTR    ANOP
&CTR    SETA  &CTR+1
.ENDLBL    AIF  (&CTR LE &II).NXTLBL
    POPINS &ST(&NI+1)
.*  BC   &CCVAL,&LIND(&LI-3)
    BRC  &CCVAL,&LIND(&LI-3)
    AIF  (NOT &ANDIND).POP2LBL
&LIND(&LI-1) EQU  *
.POP2LBL   ANOP
&LI    SETA   &LI-2
&NEST(&NI) SETC  '   Y'.'&NEST(&NI)'(5,4)
    MEND
./ ADD NAME=IFTEST
  MACRO
  IFTEST &THISIF
  GBLC  &LASTIF
  COPY  GBLVARS
.*
.*   THIS MACRO ENSURES THAT THE 'IF' MACROS HAVE BEEN CODED
.*   IN A SYNTACTICALLY CORRECT SEQUENCE.
.*
  AIF   ('&LASTIF' EQ '').OK
  AIF   ('&LASTIF' EQ 'ENDIF').OK
  AIF   ('&THISIF' EQ 'ENDIF').OK
  AIF   ('&THISIF' EQ 'IF').OK
  AIF   ('&THISIF' EQ 'ELSEIF' AND '&LASTIF' EQ 'ELSEIF').OK
  AIF   ('&THISIF' EQ 'ELSEIF' AND '&LASTIF' EQ 'IF').OK
  AIF   ('&THISIF' EQ 'ELSE' AND '&LASTIF' EQ 'ELSEIF').OK
  AIF   ('&THISIF' EQ 'ELSE' AND '&LASTIF' EQ 'IF').OK
 MNOTE 8,'ERROR - ''&THISIF'' MACRO INVALID AFTER ''&LASTIF''.'
  MEXIT
.*
.OK  ANOP
&LASTIF  SETC  '&THISIF'
  MEND
./ ADD NAME=JRGTIOT
* % GOTO TIOTBSL;   /*
*
*  THIS IS A COPY OF THE PUBLIC DOMAIN MVT MACRO WHICH HAS
*  BEEN AMENDED TO MAKE THE 2 DSECTS EXPLICIT AND THEREFORE
*  EASIER TO USE.
*
         MACRO
         JRGTIOT
*
*    RELEASE 20, 3/04/71, LEVEL=1
*    RELEASE 21, 3/05/71, LEVEL=1
*
TIOT1    DSECT
TIOCNJOB DS    CL8  -       JOBNAME
TIOCSTEP DS    CL16 -       STEPNAME
***********************************************************************
**             **
*   DD ENTRY:             *
*              *
* A DD ENTRY INCLUDES A DEVICE ENTRY. BEFORE ALLOCATION, THERE  *
* MAY BE SEVERAL DEVICE ENTRIES IN EACH DD ENTRY.        *
**             **
***********************************************************************
TIOENTRY EQU   *
TIOENTRYD DSECT
TIOELNGH DS    FL1 -        LENGTH OF THIS ENTRY
TIOESTTA DS    B -        STATUS -A-
TIOSLTYP EQU   X'80' -        NONSTANDARD LABEL (NOTE 1)
TIOSPLTP EQU   X'40' -        SPLIT CYLINDER PRIMARY
TIOSPLTS EQU   X'20' -        SPLIT CYLINDER SECONDARY
TIOSJBLB EQU   X'10' -        JOBLIB INDICATOR
TIOSDADS EQU   X'08' -        DADSM ALLOCATION NECESSRY
TIOSLABL EQU   X'04' -        LABELED/UNLABELED (NOTE 1)
TIOSDSP1 EQU   X'02' -        DISPOSITION BIT 1
TIOSDSP2 EQU   X'01' -        DISPOSITION BIT 2
*
*   NOTE 1 - IF BOTH BITS TIOSLTYP AND TIOSLABL ARE ON, THE VOLUME
*      IS A TAPE AND HAS AN 'ANSI' LABEL.
*
TIOERLOC DS    0CL2 -        REL. LOC OF POOL
TIOEWTCT DS    CL1 -        COUNT OF NUMBER OF DEVICES
*        DURING ALLOCATION STILL ELIGIBLE TO DADSM ALLOCATE
*        THIS DATA SETS REQUEST
TIOELINK DS    CL1 -        DURING ALLOCATION OF ALL
*        BUT POOLS THIS WILL BE A LINK TO THE APPROPRIATE PRIME
*        SPLIT,UNIT AFFIM,VOL AFFIN OR SUBALLOCATE
  SPACE 1
* FOLLOWING BIT MASKS APPLY TO THE 'TIOELINK' FIELD
  SPACE 1
TIOSYOUT EQU   X'80' - SYSOUT DATA SET THAT CONTAINS DATA
TIOTOPEN EQU   X'40' - DATA SET IS OPEN
TIOTTERM EQU   X'20' - THIS IS A TERMINAL
TIOEDYNM EQU   X'10' - 'DYNAM' KEYWORD USED
TIOEQNAM EQU   X'08' - 'QNAME' KEYWORD USED
TIOESYIN EQU   X'04' -  SYSIN
TIOESYOT EQU   X'02' -  SYSOUT
TIOESSDS EQU   X'02' -        ENTRY FOR A SUBSYSTEM DATA SET*
*
TIOEDDNM DS    CL8 -        DDNAME
TIOEJFCB DS    CL3 -        JFCB DISK ADDR
TIOESTTC DS    B -        STATUS -C-
TIOSDKCR EQU   X'80' -        CORE/DISK ADDRESS
TIOSDEFR EQU   X'40' -        DEFERRED MOUNT
TIOSAFFP EQU   X'20' -        UNIT AFFINITY PRIMARY
TIOSAFFS EQU   X'10' -        UNIT AFFINITY SECONDARY
TIOSVOLP EQU   X'08' -        VOLUME AFFINITY PRIMARY
TIOSVOLS EQU   X'04' -        VOLUME AFFINITY SECONDARY
TIOSBALP EQU   X'02' -        SUBALLOCATE PRIMARY
TIOSBALS EQU   X'01' -        SUBALLOCATE SECONDARY
***********************************************************************
**             **
*   DEVICE ENTRIES:            *
*              *
*      1. DURING ALLOCATION:           *
*   ONE DEVICE ENTRY FOR EACH DEVICE REQUIRED, OR FOR    *
*   EACH PUBLIC DEVICE ELIGIBLE.         *
*              *
*      2. DURING PROBLEM PROGRAM:          *
*   ONE DEVICE ENTRY FOR EACH ALLOCATED DEVICE       *
*              *
***********************************************************************
TIOESTTB DS    B -        STATUS -B-
TIOSUSED EQU   X'80' -        DATA SET IS ON DEVICE
TIOSREQD EQU   X'40' -        DATA SET WILL USE DEVICE
TIOSPVIO EQU   X'20' -        DEVICE VIOLATES SEPARATION
TIOSVLSR EQU   X'10' -        VOLUME SERIAL PRESENT
TIOSSETU EQU   X'08' -        SETUP MESSAGE REQUIRED
TIOSMNTD EQU   X'04' -        MOUNTED
TIOSUNLD EQU   X'02' -        UNLOAD REQUIRED
TIOSVERF EQU   X'01' -        VERIFICATION REQUIRED
TIOEFSRT DS    AL3 -        SRT POINTER
*  TIOT POOL ENTRY
POOLSTAR EQU   *
  DS    CL1 -
TIOPNSLT DS    FL1 -        NR.OF SLOTS FOR POOL
  DS    CL1 -
TIOPNSRT DS    FL1 -        NR.OF DEVICES (FILLED
*           SLOTS)
TIOPPOOL DS    CL8 -        POOL NAME
TIOPSTTB DS    XL1 -        STATUS OF SLOT
TIOPSLOT DS    AL3 -        SRT ADDRESS OR EMPTY SLOT
TIOTFEND DS    CL4 -        FINAL END OF AN ENTRY
*           OR THE TIOT
  MEND
* */ %TIOTBSL:;
*
* /* RELEASE 20, 3/04/71, LEVEL=1         */
* /* RELEASE 21, 3/05/71, LEVEL=1         */
*
* DECLARE
* 1 TIOT1 BASED(TIOTPTR) BDY(WORD),
*     5 TIOCNJOB CHAR(8),  /*  JOB NAME       */
*     5 TIOCSTEP CHAR(16);  /*  STEP NAME       */
*/********************************************************************/
*/*             */
*/* DD ENTRY:            */
*/*             */
*/* A DD ENTRY INCLUDES A DEVICE ENTRY. BEFORE ALLOCATION, THERE */
*/* MAY BE SEVERAL DEVICE ENTRIES IN EACH DD ENTRY.       */
*/*             */
*/********************************************************************/
*%IF TIOENPTR=''  %THEN
*%TIOENPTR='ADDR(TIOT1)+24';
* DECLARE
*     1 TIOENTRY   BASED(TIOENPTR),
*    10 TIOELNGH PTR(8),  /* LENGTH OF THIS ENTRY      */
*    10 TIOESTTA BIT(8),  /* STATUS -A-       */
*      11 TIOSLTYP BIT(1), /* NONSTANDARD LABEL (NOTE 1)*/
*      11 TIOSPLTP BIT(1), /* SPLIT CYLINDER PRIMARY    */
*      11 TIOSPLTS BIT(1), /* SPLIT CYLINDER SECONDARY  */
*      11 TIOSJBLB BIT(1), /* JOBLIB INDICATOR      */
*      11 TIOSDADS BIT(1), /* DADSM ALLOCATION NECESSARY*/
*      11 TIOSLABL BIT(1), /* LABELED/UNLABELED (NOTE 1)*/
*      11 TIOSDSP1 BIT(1), /* DISPOSITION BIT 1      */
*      11 TIOSDSP2 BIT(1), /* DISPOSITION BIT 2      */
*/*   NOTE 1 - IF BOTH BITS TIOSLTYP AND TIOSLABL ARE ON, THE VOLUME */
*/*        IS A TAPE AND HAS AN 'ANSI' LABEL.       */
*    10 TIOERLOC CHAR(2),  /* REL. LOC OF POOL      */
*    15 TIOEWTCT CHAR(1), /* COUNT OF NUMBER OF DEVICES
*        DURING ALLOCATION STILL
*        ELIGIBLE TO DADSM ALLOCATE
*        THIS DATA SET REQUEST     */
*    15 TIOELINK CHAR(1), /* DURING ALLOCATION OF
*        ALL BUT POOLS THIS WILL BE
*        A LINK TO THE APPROPRIATE
*        PRIME SPLIT,UNIT AFFIN
*        VOL.,AFFIN OR SUBALLOCATE */
*/* FOLLOWING BIT MASKS APPLY TO 'TIOELINK' FIELD */
*       17 TIOSYOUT BIT(1), /* SYSOUT D.S.THAT HAS DATA */
*       17 TIOTOPEN BIT(1), /* DATA SET IS OPEN      */
*       17 TIOTTERM BIT(1), /* THIS IS A TERMINAL      */
*       17 TIOEDYNM BIT(1), /* 'DYNAM' KEYWORD USED     */
*       17 TIOEQNAM BIT(1), /* 'QNAME' KEYWORD USED     */
*       17 * BIT(3),  /* RESERVED */
*    10 TIOEDDNM CHAR(8),  /* DDNAME       */
*    10 TIOEJFCB CHAR(3),  /* JFCB DISK ADDR      */
*    10 TIOESTTC BIT(8),  /* STATUS -C-       */
*     11 TIOSDKCR BIT(1),  /* CORE/DISK ADDRESS      */
*     11 TIOSDEFR BIT(1),  /* DEFERRED MOUNT      */
*     11 TIOSAFFP BIT(1),  /* UNIT AFFINITY PRIMARY     */
*     11 TIOSAFFS BIT(1),  /* UNIT AFFINITY SECONDARY   */
*     11 TIOSVOLP BIT(1),  /* VOLUME AFFINITY PRIMARY   */
*     11 TIOSVOLS BIT(1),  /* VOLUME AFFINITY SECONDARY */
*     11 TIOSBALP BIT(1),  /* SUBALLOCATE PRIMARY      */
*     11 TIOSBALS BIT(1),  /* SUBALLOCATE SECONDARY     */
*/********************************************************************/
*/*             */
*/* DEVICE ENTRIES:           */
*/*             */
*/*    1. DURING ALLOCATION:          */
*/*   ONE DEVICE ENTRY FOR EACH DEVICE REQUIRED, OR FOR   */
*/*   EACH PUBLIC DEVICE ELIGIBLE.        */
*/*             */
*/*    2. DURING PROBLEM PROGRAM:         */
*/*   ONE DEVICE ENTRY FOR EACH ALLOCATED DEVICE      */
*/*             */
*/********************************************************************/
*    10 TIOESTTB BIT(8),  /* STATUS -B-       */
*     11 TIOSUSED BIT(1),  /* DATA SET IS ON DEVICE     */
*     11 TIOSREQD BIT(1),  /* DATA SET WILL USE DEVICE  */
*     11 TIOSPVIO BIT(1),  /* DEVICE VIOLATES SEPARATION*/
*     11 TIOSVLSR BIT(1),  /* VOLUME SERIAL PRESENT     */
*     11 TIOSSETU BIT(1),  /* SETUP MESSAGE REQUIRED    */
*     11 TIOSMNTD BIT(1),  /* MOUNTED       */
*     11 TIOSUNLD BIT(1),  /* UNLOAD REQUIRED      */
*     11 TIOSVERF BIT(1),  /* VERIFICATION REQUIRED     */
*    10 TIOEFSRT PTR(24), /* SRT POINTER       */
*/********************************************************************/
*/*             */
*/*        TIOT POOL ENTRY          */
*/*             */
*/********************************************************************/
*     5 POOLSTAR,
*    10 *    CHAR(1),
*    10 TIOPNSLT PTR(8),        /*  NR. OF SLOTS FOR POOL     */
*    10 *    CHAR(1),
*    10 TIOPNSRT PTR(8),        /*  NR. OF DEVICES (FILLED
*          SLOTS)       */
*    10 TIOPPOOL CHAR(8),  /* POOL NAME       */
*    10 TIOPSTTB CHAR(1),  /* STATUS OF SLOT      */
*    10 TIOPSLOT PTR(24),  /* SRT ADDRESS OF EMPTY SLOT */
*    10 TIOTFEND CHAR(4);  /* FINAL END OF AN ENTRY OR
*        THE TIOT       */
./ ADD NAME=OTHERWSE
         MACRO
&LAB     OTHERWSE
.*
.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE
.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.
.*
.* THE GENERAL STRUCTURE IS AS FOLLOWS -
.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)
.*      WHEN   OP2REST,OP2REST
.*      WHEN   OP2REST-OP2REST,OP2REST
.*      OTHERWSE
.*    ENDEVAL
.*
.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &ON(16)
.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &OE(16)
.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)
         GBLA  &OD
.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OELSE(16)
.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OPTN(16)
.*
.IF0     AIF   (T'&LAB EQ 'O').END0
&LAB     EQU   *
.END0    ANOP
.IF0A    AIF   (&OD NE 0).END0A
         MNOTE 16,'OPTION MISSING'
         MEXIT
.END0A   ANOP
.IF1     AIF   (&OD LE 16).END1
         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'
         MEXIT
.END1    ANOP
.* SET EXIT FOR PREVIOUS CODE
         BRU   @D&OD.E&OE(&OD)
.* SET LABEL FOR ENTRY
@D&OD.N&ON(&OD) EQU   *
.* INCREMENT LABEL GENERATION NUMBER
&ON(&OD) SETA  &ON(&OD)+1
.* SET OPTION INDICATOR OFF
&OPTN(&OD) SETB  (0)
.IF1A    AIF   ((&OELSE(&OD)) EQ (0)).END1A
         MNOTE 16,'DUPLICATE OTHERWSE'
         MEXIT
.END1A   ANOP
&OELSE(&OD) SETB (1)
         MEND
./ ADD NAME=PLIST
 MACRO
&NAME  PLIST &P1
 LCLA &NPLIST,&CPLIST
 AIF ('&P1' EQ '').E2
 AIF ('&P1'(1,1) NE '(').E1
&NPLIST SETA N'&P1
&CPLIST SETA 1
&NAME  DS    0F
.B1 AIF ('&P1(&CPLIST)' EQ '').B2
  DC    A(&P1(&CPLIST))
 AGO .B3
.B2  DC    A(0)
.B3 ANOP
&CPLIST SETA 1+&CPLIST
 AIF (&CPLIST GT &NPLIST).B4
 AGO .B1
.B4  ORG   *-4
  DC    X'80'
  ORG   *+3
 MEXIT
.E1 MNOTE 2,'OPND NOT ENCLOSED IN PARENTHESES. STMT IGNORED.'
 MEXIT
.E2 MNOTE 2,'NO OPND. STATEMEMT IGNORED.'
 MEXIT
 MEND
./ ADD NAME=POPINS
  MACRO
  POPINS &P
  GBLA  &CCVAL   COND CODE VARIABLE
  GBLA  &CTR   MACRO PARAMETER COUNTER
  GBLA  &SEQ   LABEL NUMBER GENERATOR
  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK
  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS
  GBLA  &II   PTR TO INST STKS
  GBLA  &LI   INDEX FOR LABEL NUMBER STK
  GBLA  &NI   PTR TO NEST STK
  GBLA  &AIND(50)  TOTAL CASES STK
  GBLA  &CIND1(200)  CASE NUMBER STK
  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER
  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL
  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES
  GBLC  &IIND1(100)  INSTRUCTION STK 1
  GBLC  &IIND2(100)  INSTRUCTION STK 2
  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART
  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART
  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART
  GBLC  &IIND3(100)  INSTRUCTION STK 3
  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART
  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART
  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART
  GBLC  &IIND4(100)  INSTRUCTION STK 4
  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART
  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART
  GBLC  &IIND5(100)  INSTRUCTION NAME STACK
  GBLC  &LIND(101)  LABEL NUMBER STK
  GBLC  &NEST(50)  NESTING STK
  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO
  LCLA &W
&W  SETA &P
  AGO .TEST
.UNSTACK   AIF ('&IIND3(&W)' EQ '').ONEOP
      AIF ('&IIND4(&W)' NE '').THREEOP
&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)/
               &I32(&W)&I33(&W)&I34(&W)
      AGO .INCTR
.THREEOP       ANOP
&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)/
               &I32(&W)&I33(&W)&I34(&W),&IIND4(&W)&I42(&W)&I43(&W)
      AGO .INCTR
.ONEOP    ANOP
&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W)
.INCTR    ANOP
&W    SETA  &W+1
.TEST  AIF (&W LE &II).UNSTACK
&II  SETA &P-1
  AIF ('&NEST(&NI)'(3,1) NE ' ' OR '&NEST(&NI)'(4,1) EQ ' ').NEQ
&IIND5(&II) &IIND1(&II) &IIND2(&II)
.NEQ  AIF (&II GT 0 OR (&II EQ 0 AND '&NEST(&NI)'(5,4) EQ 'IF')).END
  MNOTE 8,'NEGATIVE INSTRUCTION STACK PTR. EXPANSION INVALID.'
.END  MEND
./ ADD NAME=POPNEST
  MACRO
 POPNEST &P1
 GBLA &CCVAL       COND CODE VARIABLE
 GBLA &CTR       MACRO PARAMETER COUNTER
 GBLA &SEQ       LABEL NUMBER GENERATOR
 GBLA &AI       INDEX FOR TOTAL NO. CASES STK
 GBLA &CI       INDEX FOR CASE AND LBL NO. STKS
 GBLA &II       PTR TO INST STKS
 GBLA &LI       INDEX FOR LABEL NUMBER STK
 GBLA &NI       PTR TO NEST STK
 GBLA &AIND(50)       TOTAL CASES STK
 GBLA &CIND1(200)      CASE NUMBER STK
 GBLA &MULT(50)       CASE NUMBER MULTIPLIER
 GBLA &ST(51)       INST STK INCREASE AT EACH LEVEL
 GBLC &CIND2(200)      LABEL NUMBER STK FOR CASES
 GBLC &IIND1(100)      INSTRUCTION STK 1
 GBLC &IIND2(100)      INSTRUCTION STK 2
 GBLC &I22(100)       INSTRUCTION STK 2, 2ND PART
 GBLC &I23(100)       INSTRUCTION STK 2, 3RD PART
 GBLC &I24(100)       INSTRUCTION STK 2, 4TH PART
 GBLC &IIND3(100)      INSTRUCTION STK 3
 GBLC &I32(100)       INSTRUCTION STK 3, 2ND PART
 GBLC &I33(100)       INSTRUCTION STK 3, 3RD PART
 GBLC &I34(100)       INSTRUCTION STK 3, 4TH PART
 GBLC &IIND4(100)      INSTRUCTION STK 4
 GBLC &I42(100)       INSTRUCTION STK 4, 2ND PART
 GBLC &I43(100)       INSTRUCTION STK 4, 3RD PART
 GBLC &IIND5(100)      INSTRUCTION NAME STACK
 GBLC &LIND(101)      LABEL NUMBER STK
 GBLC &NEST(50)       NESTING STK
 GBLC &RIND(50)       REG STK FOR CASENTRY MACRO
 LCLC &SUFFIX
&SUFFIX  SETC  '&NEST(&NI)'(5,4)
  AIF   ('&NEST(&NI)'(5,4) EQ '&P1').GOOD
  MNOTE 8,'&SUFFIX MACRO AT SAME LEVEL AS &P1 TERMINATOR.'
.GOOD  ANOP
&NI  SETA  &NI-1
  AIF   (&NI GE 0).OK
  MNOTE 8,'NEGATIVE NEST STACK POINTER. CHECK NUMBER OF ENDS.'
.OK  ANOP
  MEND
./ ADD NAME=PRGDCBI
         MACRO
         PRGDCBI &DCB=SYSIN,&REC=,&V2F=,&EOF=,&FLAGLEN=,               /
               &SPANA=,&SPANL=,&SPANM=
.**********************************************************************
.*
.*    Created by John Gateley
.*
.*    The easiest way to use this macro is with locate mode on
.*    the DCB and use the V2F parameter to ensure you get
.*    a fixed length record padded with spaces. This works with
.*    either fixed or variable length records.
.*    If you need to do processing based on the record length
.*    then use the REC method.
.*    If you are processing a VBS use the SPAN parameters instead.
.*
.*       This macro generates code to work with an input DCB.
.*
.* NOTE ==> The EODAD on the DCB should be END_&DCB
.*
.*       This macro generates three code segments to do the following
.*
.*          OPEN_&DCB              code to open the &DCB
.*
.*          GET_&DCB               code to read a record from &DCB
.*
.*          CLOSE_&DCB             code to close the &DCB
.*
.*       It also generates this segment when processing VBS datasets
.*       which is for internal use only.
.*          GET_&DCB._SEGMENT
.*
.*     &DCB    the label on the DCB macro.
.*     &REC    is where the input record will be read into
.*             if NOT supplied then locate mode will be used and
.*             R1 will contain the address of the record.
.*     &V2F    Use this when you do not know if the actual file
.*             will be fixed or variable, it will give you fixed.
.*             The record will be read using locate processing
.*             and copied to the specified data area, padded to
.*             the right with blanks.
.*     &FLAGLEN will be set to 'Y' if any records are truncated in
.*             V2F processing.
.*     &EOF    should be 1 byte and will be set to 'Y' when the
.*             end of file has been reached.
.*     &SPANA     area
.*     &SPANL     length
.*     &SPANM     max length
.*             adds support for VBS datasets.
.*             To use this facility &SPANA should be a fullword
.*             containing the address of the record area.
.*             SPANL should be a fullword and will contain the length
.*             of the reconstructed record.
.*             SPANM should be a fullword containing the length of
.*             the data area pointed to by SPANA.
.*             It is envisaged that the data area will be getmained
.*             storage of 1MB to allow plenty of room.
.*             If a record is > than SPANM then the program will
.*             end with RC=12.
.*
.*    This is an example of the code that should be used for SYSIN
.*    In this example all we are doing is counting the records.
.*
.*    SEGDO OPEN_SYSIN                    open the SYSIN file
.*    DO INF
.*      SEGDO GET_SYSIN
.*    DOEXIT (CLI,EOF_SYSIN,EQ,C'Y')      end of file
.*      LA    R3,1(,R3)                   increment count
.*    ENDDO
.*    SEGDO CLOSE_SYSIN                   close the SYSIN file
.*
.*  WARNING - if you have coded MACRF=GL but you get this message
.*    prgname - PRGDCBI - SYSIN Input DCB not MOV mode
.*  at run time, check you are not opening the file a second time
.*  without first closing it.
.*
.*          PRGDCBI DCB=SYSIN,EOF=EOF_SYSIN
.*  SYSIN   DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GL),EODAD=END_SYSIN
.*
         GBLC  &MODNAME
.*
         AIF   (T'&EOF NE 'O').EOFOK
         MNOTE 16,' EOF variable required'
         MEXIT
.EOFOK   ANOP
.*
 SEGS OPEN_&DCB
*
   MVI   &EOF,C'N'                     indicate NOT end of file
*                                      open &DCB
         AIF   (T'&SPANA NE 'O').ISLOCMD
         AIF   (T'&V2F NE 'O').ISLOCMD
         AIF   (T'&REC NE 'O').ISMOVMD
.*
.ISLOCMD ANOP
&TSTMOD  SETC  'LOC'
*                                      Check MACRF is locate mode
   IF (TM,&DCB+50,8,Z)
     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE
     SEGDO WRITE_LOG
     PRGQUIT RC=16                     then quit
   ENDIF
         AGO   .ENDMOD
.ISMOVMD ANOP
&TSTMOD  SETC  'MOV'
*                                      Check MACRF is move mode
   IF (TM,&DCB+50,16,Z)
     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE
     SEGDO WRITE_LOG
     PRGQUIT RC=16                     then quit
   ENDIF
.ENDMOD  ANOP
*
.*       allow for DCB in getmained storage
   LA    R14,&DCB
   OPEN  ((R14),INPUT),MODE=31
.* OPEN  (&DCB,INPUT)
   IF (LTR,R15,R15,NZ)                 quit if failed, gives RC=16
     WTO   '//&DCB     DD  ...         must be present in JCL',        /
               ROUTCDE=11,MCSFLAG=HRDCPY
     PRGQUIT RC=16
   ENDIF
*
   SEGQUIT
*
&DCB._WRONG_MODE   DC    C'&MODNAME - PRGDCBI - &DCB Input DCB not &TST'
               MOD mode'
*
 SEGE OPEN_&DCB
*______________________________________________________________________
*
 SEGS GET_&DCB
*
   MVI   &EOF,C'N'                     indicate NOT end of file
.*
   AIF   (T'&SPANA NE 'O').DOSPAN
.*
   AIF   (T'&V2F NE 'O').V2FPR1
   AIF   (T'&REC NE 'O').MOVMOD
*
.*       Do GET LOCATE processing
   GET   &DCB                          get locate mode
   AGO   .AFT
.*
.MOVMOD  ANOP
.*
.*       Do GET MOVE processing
   GET   &DCB,&REC                     get move mode
   AGO   .AFT
.*
.*       Do GET LOCATE and copy to record area
.V2FPR1  ANOP
&MYLEN   SETA  L'&V2F                  get length of record area
   AIF   (&MYLEN GT 256).DOMVCL1       <= 256 so use MVC to
   MVI   &V2F,C' '                     clear to spaces
   MVC   &V2F+1(L'&V2F-1),&V2F
   AGO   .NDMVCL1
.DOMVCL1   ANOP                        > 256 so use MVCL
   LA    R0,&V2F                       point to record area
   LA    R1,L'&V2F                     get length of record area
   LA    R15,C' '                      put in a space
   SLL   R15,24                        slide into high byte
   MVCL  R0,R14                        wipe to spaces
.NDMVCL1   ANOP
.*
   GET   &DCB
   LH    R15,&DCB+82                   get record length just read
   IF (TM,&DCB+36,X'40',NZ)            if variable length
     LA    R1,4(,R1)                   point past RDW
     AHI   R15,-4                      subtract RDW from length
   ENDIF
   IF (CHI,R15,GT,L'&V2F)              if greater than space available
     LA    R15,L'&V2F                  get maximum length
     AIF   (T'&FLAGLEN EQ 'O').NOFLAG
     MVI   &FLAGLEN,C'Y'               set truncated flag
.NOFLAG  ANOP
   ENDIF
   IF (CHI,R15,LE,256)                 record small enough for MVC?
     BCTR  R15,0                       less 1 for execute
     EX    R15,&DCB._COPY_INREC        copy record
   ELSE
     LR    R14,R1                      copy address of input record
     LR    R1,R15                      copy length
     LA    R0,&V2F                     point to record area
     MVCL  R0,R14                      copy record
   ENDIF
.AFT     ANOP
*
   SEGQUIT                             quit on good read
*
   AIF   (T'&V2F EQ 'O').V2FPR2
&DCB._COPY_INREC   MVC   &V2F.(0),0(R1)
*
.V2FPR2  ANOP
END_&DCB     DS    0H
*
   MVI   &EOF,C'Y'                     set end of file marker
*
 SEGE GET_&DCB
.*
         AGO   .AFTSPAN
.*
.*       Do GET LOCATE processing with VBS dataset
.*
.DOSPAN  ANOP
.*
   AIF   (T'&SPANL EQ 'O').MISSL
   AIF   (T'&SPANM EQ 'O').MISSM
.*
   IF (TM,&DCB+36,X'08',Z)             if not spanned write error
     MVC   MESS_TXT(L'&DCB._NOT_SPAN),&DCB._NOT_SPAN
     SEGDO WRITE_LOG
     PRGQUIT RC=16                     then quit
   ENDIF
   L     R0,&SPANA                     point to record area
   L     R1,&SPANL                     get last record length
   IF (CFI,R1,EQ,0)                    if 0
     L     R1,&SPANM                   get maximum length
   ENDIF
   XR    R15,R15
   MVCL  R0,R14                        wipe to low values
   XC    &SPANL,&SPANL                 set current length to 0
*
   ST    R2,#MVCLSAV                   save current R2 value
*
   DO INF
     SEGDO GET_&DCB._SEGMENT
   DOEXIT (CLI,&EOF,EQ,C'Y')
     LR    R2,R1                       copy segment address
     LA    R14,4(,R1)                  point past RDW/SDW
     LH    R15,0(,R1)                  get segment length
     AHI   R15,-4                      subtract for RDW/SDW
     L     R0,&SPANA                   point to start of area
     A     R0,&SPANL                   add current length
     LR    R1,R15                      copy segment length
     A     R1,&SPANL                   add current length
     ST    R1,&SPANL                   and save total
     IF (C,R1,GT,&SPANM)               is it too big ?
       MVC   MESS_TXT(L'&DCB._TOO_BIG),&DCB._TOO_BIG
       SEGDO WRITE_LOG
       PRGQUIT RC=16                   then quit
     ENDIF
     LR    R1,R15                      copy segment length again
     MVCL  R0,R14                      copy segment
   DOEXIT (CLI,2(R2),EQ,0)             single segment in record
   DOEXIT (CLI,2(R2),EQ,2)             last segment in record
   ENDDO
*
   L     R2,#MVCLSAV                   restore previous R2 value
*
   SEGQUIT                             QUIT seg, this keeps error
*                                      message addressable
*
&DCB._TOO_BIG      DC    C'&DCB Input record was too big'
&DCB._NOT_SPAN     DC    C'&DCB Input file not RECFM=VBS'
*
 SEGE GET_&DCB
*______________________________________________________________________
*
 SEGS GET_&DCB._SEGMENT
*
   MVI   &EOF,C'N'
*
   GET   &DCB
*
   SEGQUIT
*
END_&DCB     DS    0H
*
   MVI   &EOF,C'Y'                     set end of file marker
*
 SEGE GET_&DCB._SEGMENT
.*
.AFTSPAN   ANOP
*______________________________________________________________________
*
 SEGS CLOSE_&DCB
*                                      close &DCB
.*       allow for DCB in getmained storage
   LA    R14,&DCB
   CLOSE ((R14)),MODE=31
.* CLOSE (&DCB)
*                                      freepool &DCB
   FREEPOOL &DCB                       ensure buffer pool cleared
*
 SEGE CLOSE_&DCB
.*
         MEXIT
.MISSL   MNOTE 16,'SPANA defined but not SPANL'
         MEXIT
.MISSM   MNOTE 16,'SPANA defined but not SPANM'
         MEND
./ ADD NAME=PRGDCBO
         MACRO
         PRGDCBO &DCB=SYSOUT,&REC=,&CLEAR=Y,&SPANA=,&SPANL=,&SPANW=
.**********************************************************************
.*
.*     Created by John Gateley
.*
.*     This macro generates code to work with an output DCB.
.*
.*     This macro generates three code segments.
.*
.*        OPEN_&DCB                  code to open the &DCB DCB
.*
.*        PUT_&DCB                   code to write a line to &DCB
.*
.*        CLOSE_&DCB                 code to close the &DCB DCB
.*
.*     It also generates this segment when processing VBS datasets
.*     which is for internal use only.
.*        PUT_&DCB._SEGMENT
.*
.*     &REC=      where the output record will be written from.
.*     &CLEAR=Y   set &REC to spaces after the record is written.
.*           =N   leave the record as it is. If the record is variable
.*                then the RDW will not be set to spaces.
.*
.*     &SPANA     area                     DS    F
.*     &SPANL     length                   DS    F
.*     &SPANW     12 byte work area        DS    3F
.*             adds support for VBS datasets.
.*             To use this facility &SPANA should be a fullword
.*             containing the address of the record area.
.*             SPANL should be a fullword and will contain the length
.*             of the full record.
.*          When using VBS the DCB should be MACRF=PL
.*
.*          PRGDCBO DCB=SYSOUT,REC=MESS_TXT,CLEAR=Y
.*  SYSOUT  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSOUT,RECFM=FB,LRECL=80
.*
         GBLC  &MODNAME
.*
         AIF   (T'&SPANA NE 'O').RECOK
         AIF   (T'&REC NE 'O').RECOK
         MNOTE 16,' REC= variable required'
         MEXIT
.RECOK   ANOP
.*
 SEGS OPEN_&DCB
*                                      open &DCB
         AIF   (T'&SPANA NE 'O').ISLOCMD
         AIF   (T'&REC NE 'O').ISMOVMD
.*
.ISLOCMD ANOP
&TSTMOD  SETC  'LOC'
*                                      Check MACRF2 is locate mode
   IF (TM,&DCB+51,8,Z)
     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE
     SEGDO WRITE_LOG
     PRGQUIT RC=16                     then quit
   ENDIF
         AGO   .ENDMOD
.ISMOVMD ANOP
&TSTMOD  SETC  'MOV'
*                                      Check MACRF2 is move mode
   IF (TM,&DCB+51,16,Z)
     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE
     SEGDO WRITE_LOG
     PRGQUIT RC=16                     then quit
   ENDIF
.ENDMOD  ANOP
*
.*       allow for DCB in getmained storage
   LA    R14,&DCB
   OPEN  ((R14),OUTPUT),MODE=31
.* OPEN  (&DCB,OUTPUT),MODE=31
   IF (LTR,R15,R15,NZ)                 quit if failed, gives RC=16
     WTO   '//&DCB     DD  ...         must be present in JCL',        /
               ROUTCDE=11,MCSFLAG=HRDCPY
     PRGQUIT RC=16
   ENDIF
*
   SEGQUIT
*
&DCB._WRONG_MODE   DC    C'&MODNAME - PRGDCBO - &DCB Output DCB not &TS'
               TMOD mode'
*
 SEGE OPEN_&DCB
*______________________________________________________________________
*
 SEGS PUT_&DCB
*
   AIF   (T'&SPANA NE 'O').DOSPAN
.*
   PUT   &DCB,&REC                     put move mode
*
   AIF   ('&CLEAR' EQ 'N').NOCLEAR
.*
&MYLEN1  SETA  L'&REC                  get length of record area
&MYLEN2  SETA  L'&REC-4                get length of record area - RDW
.*
   AIF   (&MYLEN1 GT 256).DOMVCL       <= 256 so use MVC to
   IF (TM,&DCB+36,X'40',NZ)            if variable length
     MVI   &REC+4,C' '                 clear output record
     MVC   &REC+5(L'&REC-5),&REC+4     but not RDW
   ELSE
     MVI   &REC,C' '                   clear output record
     MVC   &REC+1(L'&REC-1),&REC
   ENDIF
   AGO   .NDMVCL
.*
.DOMVCL    ANOP                        > 256 so use MVCL
.*
   IF (TM,&DCB+36,X'40',NZ)            if variable length
     LA    R0,&REC+4                   point to after RDW
     LAY   R1,&MYLEN2                  get length to clear
     LA    R8,1
   ELSE
     LA    R0,&REC                     point to record area
     LAY   R1,&MYLEN1                  get length to clear
     LA    R8,2
   ENDIF
   LA    R15,C' '                      put in a space
   SLL   R15,24                        slide into high byte
   MVCL  R0,R14                        wipe to spaces
.*
.NDMVCL    ANOP
.*
.NOCLEAR ANOP
*
 SEGE PUT_&DCB
.*
         AGO   .AFTSPAN
.*
.DOSPAN  ANOP
.*
   AIF   (T'&SPANL EQ 'O').MISSL
   AIF   (T'&SPANW EQ 'O').MISSW
.*
   IF (TM,&DCB+36,X'08',Z)             if not spanned write error
     MVC   MESS_TXT(L'&DCB._NOT_SPAN),&DCB._NOT_SPAN
     SEGDO WRITE_LOG
     PRGQUIT RC=12                     then quit
   ENDIF
   MVC   &SPANW.(4),&SPANA             copy address of record
   MVC   &SPANW.+4(4),&SPANL           copy length of record
   MVI   &SPANW.+8,0                   indicate complete record
*
   DO INF
     SEGDO PUT_&DCB._SEGMENT           uses locate mode
     LR    R14,R1                      save address of output buffer
     LR    R15,R0                      save length of output buffer
     AHI   R15,-4                      subtract length of RDW/SDW
     XC    0(4,R14),0(R14)             clear RDW/SDW in output
     IF (C,R15,GE,&SPANW.+4)           only or final segment
       L     R15,&SPANW.+4             set length to write
       XC    &SPANW.+4(4),&SPANW.+4    show no more after this
       L     R0,&SPANW                 address to copy from
       IF (CLI,&SPANW.+8,NE,0)         writing segments
         MVI   2(R14),2                show last segment
       ENDIF
     ELSE
       L     R1,&SPANW.+4              get length remaining
       SR    R1,R15                    subtract this length
       ST    R1,&SPANW.+4              save new length remaining
       L     R0,&SPANW                 address to copy from
       L     R1,&SPANW                 address to copy from
       AR    R1,R15                    add this length
       ST    R1,&SPANW                 save new address
       IF (CLI,&SPANW.+8,EQ,0)         writing first segment
         MVI   2(R14),1                show first segment
         MVI   &SPANW.+8,1             show first segment written
       ELSE
         MVI   2(R14),3                show middle segment
       ENDIF
     ENDIF
     LA    R1,4(,R15)                  add RDW/SDW length
     STH   R1,0(R14)                   set RDW/SDW length
     LA    R14,4(,R14)                 point after RDW/SDW in output
     LR    R1,R15                      copy move length
     MVCL  R14,R0                      copy the data
   DOEXIT (CLC,=F'0',EQ,&SPANW.+4)     nothing else to write
   ENDDO
*
   SEGQUIT                             QUIT seg, this keeps error
*                                      message addressable
*
&DCB._NOT_SPAN     DC    C'&DCB Output file not RECFM=VBS'
*
 SEGE PUT_&DCB
*______________________________________________________________________
*
 SEGS PUT_&DCB._SEGMENT
*
   PUT   &DCB
*
 SEGE PUT_&DCB._SEGMENT
.*
.AFTSPAN   ANOP
*______________________________________________________________________
*
 SEGS CLOSE_&DCB
*                                      close &DCB
.*       allow for DCB in getmained storage
   LA    R14,&DCB
   CLOSE ((R14)),MODE=31
.* CLOSE (&DCB),MODE=31
*
 SEGE CLOSE_&DCB
.*
         MEXIT
.MISSL   MNOTE 16,'SPANA defined but not SPANL'
         MEXIT
.MISSW   MNOTE 16,'SPANA defined but not SPANW'
         MEXIT
         MEND
./ ADD NAME=PRGDEF
         MACRO
&LABEL   PRGDEF &FSEG=,&REXX=N,&AMODE=31,&RMODE=ANY,&INREX=N,          /
               &RENT=N,&MAXSEG=50,&SBAS2=N,&SBAS3=N,&MAXPAR=24,        /
               &RBAS2=N,&RBAS3=N,&RLOC=ANY,&WTOL=80
.*
.*  Created by John Gateley
.*
.*  This macro defines the start ot the program and is responsible
.*  for getting and releasing dynamic storage if RENT=Y is specified.
.*  RBAS2 and RBAS3 provide for additional reentrant storage
.*  base registers.
.*  SBAS2 and SBAS3 provide for additional static storage base
.*  registers.
.*
.*  The assembler LOCTR is used to build the object module with the
.*  static variables such as literals and constants at the top followed
.*  by the executable code. Code in the program should be segmented
.*  using SEGS and SEGE macros and segments should be performed by use
.*  of the SEGDO macro. A code base register is used to give
.*  addressability within each segment and is automatically
.*  maintained on entry to and exit from a segment. Branching to a
.*  label in another segment will usually cause an 'interesting' abend.
.*
.*  Example program layout
.*
.*   TITLE 'PROGRAM TITLE'
.*  NAME  PRGDEF FSEG=MAIN_BIT,REXX=Y,RENT=Y
.*  DYNAMIC_STORAGE_VARIABLE   DS    F
.*        PRGEDEF
.*   SEGS MAIN_BIT
.*     MVC   ....
.*     SEGDO SEGMENT_TWO
.*   SEGE MAIN_BIT
.*   SEGS SEGMENT_TWO
.*     MVC   ....
.*   SEGE SEGMENT_TWO
.*
.*        PRGSTAT
.*  A_CONSTANT   DC    C'SOME TEXT'
.*        PRGESTAT
.*        PRGEND
.*        END
.*
.*  An area of re-entrant storage called MESS_TXT is provided and is
.*  used by the WTOX macro to write to operator, this defaults to
.*  80 but can be up to 120 and is set by WTOL=80.
.*  An area is provided for building parameter lists MY_PARM the
.*  number of fullwords is set by MAXPAR=24.
.*  REXX=Y automatically includes the macros required for writing
.*  rexx functions in assembler. INREXX=Y is for rexx functions
.*  that are not called directly by rexx.
.*
.*  Registers used are
.*             R13            save area and base for re-entrant
.*                            storage between PRGDEF and PRGEDEF
.*             R12            base register for static variables which
.*                            are defined between PRGSTAT and PRGESTAT
.*             R11            segment code base register
.*             R10            rexx environment block
.*             R9             rexx EFPL
.*             R8             rexx ARGTABLE_ENTRY
.*             R7             rexx EVALBLOCK
.*
.*  Defaults are
.*             RENT=NO
.*             CBASE=R11      Code base register set in every segment
.*             AMODE=31
.*             RMODE=ANY
.*             MAXSEG=50      Maximium number of segments in program
.*             SBAS2=N        No second storage register
.*             SBAS3=N        No third storage register
.*             RBAS2=N        No second reentrant register
.*             RBAS3=N        No third reentrant register
.*             MAXPAR=24      Parameter list length
.*             WTOL=80        80 character message area.
.*
           GBLC  &MODNAME
           GBLC  &SETREX
           GBLC  &INREXX
           GBLC  &ISRBAS2,&ISRBAS3
           GBLC  &ISSBAS2,&ISSBAS3
           GBLC  &SEGSAVA
           GBLC  &BASSAVA
           GBLC  &SAMODE
           GBLC  &ISRENT
           GBLC  &SCBASER
           GBLC  &STRWRK
           GBLA  &SEGCNT
           GBLA  &SEGMAX
           GBLA  &PARMAX
           GBLA  &SCBASEC
           GBLA  &WHICHM
           LCLA  &CNT1,&CNT2
           AIF   ('&LABEL' EQ '').MNOTE1
           AIF   ('&FSEG' EQ '').MNOTE2
.*
*   Change branch to branch relative, ensure clean 31 bit addresses
B          OPSYN BRU
BAL        OPSYN BAS
BALR       OPSYN BASR
.*
&MODNAME   SETC  '&LABEL'
&ISRBAS2   SETC  '&RBAS2'
&ISRBAS3   SETC  '&RBAS3'
&ISSBAS2   SETC  '&SBAS2'
&ISSBAS3   SETC  '&SBAS3'
&ISRENT    SETC  '&RENT'(1,1)
&SAMODE    SETC  '&AMODE'
&SETREX    SETC  '&REXX'(1,1)
&INREXX    SETC  '&INREX'(1,1)
&SCBASER   SETC  'R11'
&STRWRK    SETC  '#STRING_WORK'
&SEGCNT    SETA  0
&SCBASEC   SETA  0
&SEGMAX    SETA  &MAXSEG
&PARMAX    SETA  &MAXPAR
&CNT1      SETA  1
&CNT2      SETA  &PARMAX
&WHICHM    SETA  5
*
&MODNAME   START 0
           AIF   ('&AMODE' EQ '31').ABIT31
           AIF   ('&AMODE' NE '24').MNOTE3
.ABIT24    ANOP
&MODNAME   AMODE 24
&MODNAME   RMODE 24
           AGO   .AFTR
.ABIT31    ANOP
&MODNAME   AMODE 31
           AIF   ('&RMODE' EQ '24').RBIT24
           AIF   ('&RMODE' EQ 'ANY').RBIT31
           AGO   .MNOTE4
.RBIT24    ANOP
&MODNAME   RMODE 24
           AGO   .AFTR
.RBIT31    ANOP
&MODNAME   RMODE ANY
.AFTR      ANOP
*
R0         EQU   0
R1         EQU   1
R2         EQU   2
R3         EQU   3
R4         EQU   4
R5         EQU   5
R6         EQU   6
           AIF   ('&SETREX' EQ 'Y').REXEQ
           AIF   ('&INREXX' EQ 'Y').REXEQ
R7         EQU   7
R8         EQU   8
R9         EQU   9
R10        EQU   10
           AGO   .REXEQX
.REXEQ     ANOP
R7         EQU   7                   * rexx EVALBLOCK
R8         EQU   8                   * rexx ARGTABLE_ENTRY
ARG_POINT  EQU   8                   * rexx ARGTABLE_ENTRY alt name
R9         EQU   9                   * rexx EFPL
R10        EQU   10                  * rexx ENVBLOCK
.REXEQX    ANOP
R11        EQU   11                  * segment base register
R12        EQU   12                  * module base register
R13        EQU   13                  * reentrant storage
R14        EQU   14
R15        EQU   15
.*
           AIF   ('&SETREX' EQ 'N').NOREX1
           AIF   ('&INREXX' EQ 'Y').MNOTE5
.NOREX1    ANOP
*
           BRUL  BEGIN
*
@DATA      LOCTR ,
           DC    CL10' &MODNAME'
&AADAT     SETC  '&SYSCLOCK'(1,19)
           DC    CL20'&AADAT'
           DC    CL48'Copyright (C) ------------------------'
           DS    0F
@CODE      LOCTR ,
BEGIN      DS    0H
           STM   R14,R12,12(R13)     * save registers in caller
           LARL  R12,&MODNAME        * get address of entry point
*
           AIF   ('&ISSBAS2' EQ 'N').NOS2BAS
           AIF   ('&ISSBAS3' EQ 'N').NOS3BAS
*
           USING &MODNAME,R12
           LA    &ISSBAS2,2048(,R12)
           LA    &ISSBAS2,2048(,&ISSBAS2)
           USING &MODNAME+4096,&ISSBAS2
           LA    &ISSBAS3,2048(,&ISSBAS2)
           LA    &ISSBAS3,2048(,&ISSBAS3)
           USING (&MODNAME+8192,BEGIN),&ISSBAS3
           AGO   .ENDSTAT
*
.NOS3BAS   ANOP
           USING &MODNAME,R12
           LA    &ISSBAS2,2048(,R12)
           LA    &ISSBAS2,2048(,&ISSBAS2)
           USING (&MODNAME+4096,BEGIN),&ISSBAS2
           AGO   .ENDSTAT
*
.NOS2BAS   ANOP
           USING (&MODNAME,BEGIN),R12
.ENDSTAT   ANOP
*
           LR    R9,R1               save parameter address
           AIF   ('&SETREX' EQ 'N').NO0001
           LR    R10,R0              save rexx environment block addr
.NO0001    ANOP
           AIF   ('&ISRENT' EQ 'Y').RNT001
*    Note that save area is NOT re-entrant
           LARL  R2,#RENT_AREA
           AGO   .RNT002
.RNT001    ANOP
*    Note that save area is re-entrant
           L     R2,#RENTSIZ
           AIF   ('&RLOC' NE 'ANY').SBIT24
           AIF   ('&AMODE' EQ '31').SBIT31
.SBIT24    ANOP
*          STORAGE OBTAIN,LENGTH=(R2),LOC=24
           CNOP  0,4
           BRAS  R15,#GET_LAB
           DC    BL1'00000000'
           DC    AL1(0*16)
           DC    AL1(0)
           DC    BL1'00010010'
#GET_LAB   DS    0F
           LR    0,R2
           L     15,0(,R15)
           L     14,16(0,0)
           L     14,772(14,0)
           L     14,160(14,0)
           PC    0(14)
           AGO   .ESTOR
.SBIT31    ANOP
*          STORAGE OBTAIN,LENGTH=(R2),LOC=31
           CNOP  0,4
           BRAS  R15,#GET_LAB
           DC    BL1'00000000'
           DC    AL1(0*16)
           DC    AL1(0)
           DC    BL1'01110010'
#GET_LAB   DS    0F
           LR    0,R2
           L     15,0(,R15)
           L     14,16(0,0)
           L     14,772(14,0)
           L     14,160(14,0)
           PC    0(14)              get storage
.ESTOR     ANOP
           LR    R2,R1               copy storage address
.RNT002    ANOP
           LR    R1,R9               restore parameter address
           ST    R13,4(R2)           chain save areas
           ST    R2,8(R13)
           LR    R13,R2
*
           AIF   ('&ISRBAS2' EQ 'N').NOR2BAS
           AIF   ('&ISRBAS3' EQ 'N').NOR3BAS
*
           USING #PRGAREA,R13
           LA    &ISRBAS2,2048(,R13)
           LA    &ISRBAS2,2048(,&ISRBAS2)
           USING &PRGAREA+4096,&ISRBAS2
           LA    &ISRBAS3,2048(,&ISRBAS2)
           LA    &ISRBAS3,2048(,&ISRBAS3)
           USING (#PRGAREA+8192,#E_RENT),&ISRBAS3
           AGO   .ENDRTAT
*
.NOR3BAS   ANOP
           USING #PRGAREA,R13
           LA    &ISRBAS2,2048(,R13)
           LA    &ISRBAS2,2048(,&ISRBAS2)
           USING (#PRGAREA+4096,#E_RENT),&ISRBAS2
           AGO   .ENDRTAT
*
.NOR2BAS   ANOP
           USING (#PRGAREA,#E_RENT),R13
.ENDRTAT   ANOP
*
           AIF   ('&SETREX' EQ 'N').NO0002
           LR    R0,R10              restore environment block address
.NO0002    ANOP
.*
           AIF   ('&SETREX' EQ 'N').NOREX2
           USING ENVBLOCK,R10        use environment block
           USING EFPL,R9
           L     R8,EFPLARG
           USING ARGTABLE_ENTRY,R8
           L     R7,EFPLEVAL
           L     R7,0(R7)
           USING EVALBLOCK,R7
           STM   R7,R10,#SAV_REX
           XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN
.NOREX2    ANOP
           AIF   ('&INREXX' NE 'Y').NOINREX
           L     R9,4(R13)
           MVC   #SAV_REX(4*4),#SAV_REX-#PRGAREA(R9)
           LM    R7,R10,#SAV_REX
           USING ENVBLOCK,R10
           USING EFPL,R9
           USING ARGTABLE_ENTRY,R8
           USING EVALBLOCK,R7
.NOINREX   ANOP
.*
           XC    R_C,R_C
           XC    MY_PARM(LEN_MY_PARM),MY_PARM
           STMH  R0,R15,#HIGH_HALF         * save high registers
           AIF   ('&ISRENT' NE 'Y').RNT003
*    initialise obtained storage to low-values if reentrant
           L     R15,#RENTSIZ              * length of reentrant area
           AR    R15,R13                   * start of area
           LA    R14,MY_PARM
           SR    R15,R14
           LR    R2,R1
           XR    R1,R1
           MVCL  R14,R0                    * wipe to low values
           LR    R1,R2                     * restore PARM address
.RNT003    ANOP
*
.*
.*       area for use by the WTOX macro the length of the message
.*       is set by macro parameter &WTOL which defaults to 80
.*       permitted values are 80 to 120
.*
&A         SETA  &WTOL                     * copy length
           AIF   (&A LT 80).MNOTE6
           AIF   (&A GT 120).MNOTE6
           MVC   #MESS_LEN,=H'&WTOL'       * set length of WTO text
           MVI   MESS_TEXT,C' '
           MVC   MESS_TEXT+1(L'MESS_TEXT-1),MESS_TEXT
.*
*          copy list form WTO expansion from PRGSTAT static storage
.*
           MVC   #ACT_WTO_LIST(L_#PTN_WTO_LIST),#PTN_WTO_LIST
*
           ST    R1,#PARM_ADDR             * save input PARM address
*
           BRAS  R14,##&FSEG               * go to main code
*
           BRU   #AFT_RENT                 * go to clean up
*
           DS    0F
*
&SEGSAVA   SETC  '#SEG_SAV'
.*
           AIF   ('&ISRENT' EQ 'Y').RNT004
#PRGAREA       DSECT                       * DSECT overlays #RENT_AREA
           AGO   .RNT005
.RNT004    ANOP
#PRGAREA       DSECT                       * DSECT overlays getmained
.RNT005    ANOP
#SAVAREA       DS    18F
#SAV_REX       DS    4F
#SEG_SAV       DS    &SEGMAX.F             * segment save area
               AIF   ('&SCBASER' EQ 'N').NOCBAS
#BAS_SAV       DS    &SEGMAX.F             * segment base reg save
&BASSAVA       SETC  '#BAS_SAV'
.NOCBAS        ANOP
R_C            DS    F
*
DOUB_WORD      DS    D
MY_PARM        DC    &PARMAX.F'0'          * define call parm area
               ORG   MY_PARM
.PLOOP         ANOP
MY_P_&CNT1     DS    F
&CNT1          SETA  &CNT1+1
               AIF   (&CNT1 LE &CNT2).PLOOP
.*
END_MY_PARM    EQU   *
LEN_MY_PARM    EQU   *-MY_PARM
#MVCLSAV       DC    4F'0'
#HIGH_HALF     DS    16F                   * high half of registers
LEN_SAY        DS    F
#PARM_ADDR     DS    F                     * contents of R1 on entry
HEXPACK_W2     DS    CL2                   * used in XPACK macro
HEXPACK_W3     DS    CL3                   * used in XPACK macro
#STRING_WORK   DS    CL32                  * used in STRING macro
#ACT_WTO_LIST  DS    CL(L_#PTN_WTO_LIST)   * area for WTOX macro
#MESS_LEN      DS    H                     * WTOX length
MESS_TEXT      DS    CL&WTOL               * WTOX text
               ORG   MESS_TEXT
MESS_TXT       DS    CL&WTOL               * WTOX text alternate name
*
         MEXIT
.MNOTE1  MNOTE 16,'The program name was not specified in column 1'
         MEXIT
.MNOTE2  MNOTE 16,'FSEG parameter was not specified'
         MEXIT
.MNOTE3  MNOTE 16,'AMODE not = 31 or 24'
         MEXIT
.MNOTE4  MNOTE 16,'RMODE not = ANY or 24'
         MEXIT
.MNOTE5  MNOTE 16,'REXX=YES and INREX=YES are mutually exclusive'
         MEXIT
.MNOTE6  MNOTE 16,'WTOL= permitted values are between 80 and 120'
         MEND
./ ADD NAME=PRGEDEF
           MACRO
           PRGEDEF
           GBLC  &MODNAME
           GBLC  &SETREX
           GBLC  &SAMODE
           GBLC  &INREXX
           GBLC  &ISRENT
           GBLA  &WHICHM
           AIF   ('&WHICHM' NE '5').MNOTE1
*
.* Created by John Gateley
.*
#PRGAREA   DSECT
*
#E_RENT    EQU   *
*
&MODNAME   CSECT
#AFT_RENT  DS    0H                        * start of goback code
*
           AIF   ('&SETREX' EQ 'N').NOREX
           L     R7,#SAV_REX               * point to rexx-evalblock
           L     R1,R_C                    * get return code
           LTR   R1,R1
           BRNZ  #AFT_RENT1                * R_C not zero then use it
           CLC   EVALBLOCK_EVLEN,=F'0'     * if output length not set
           BRNE  #AFT_RENT2                *   then use R_C anyway
#AFT_RENT1 DS    0H
           CVD   R1,DOUB_WORD              * put R_C into DOUB_WORD
           MVC   MY_P_7,=X'40202120'
           LA    R1,MY_P_7+3
           EDMK  MY_P_7(4),DOUB_WORD+6
           LA    R2,MY_P_8
           CP    DOUB_WORD,=P'0'
           BRNM  *+10
           BCTR  R1,0
           MVI   0(R1),C'-'                * set leading minus sign
           SR    R2,R1
           ST    R2,EVALBLOCK_EVLEN        * set length of output
           BCTR  R2,0
           EX    R2,#RC_SET                * copy return code to output
           XC    R_C,R_C
#AFT_RENT2 DS  0H
.NOREX     ANOP
           LMH   R0,R15,#HIGH_HALF         * restore high registers
           AIF   ('&ISRENT' EQ 'Y').RNT001
           L     R2,R_C                    * get return code
           L     R13,4(R13)                * get caller save area
           ST    R2,16(R13)                * save return code in R15
           AGO   .RNT002
.RNT001    ANOP
           L     R0,#RENTSIZ
           LR    R1,R13
           L     R2,R_C
           L     R13,4(R13)
           ST    R2,16(R13)
*          STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)
           CNOP  0,4
           BRAS  R15,#FRE_LAB
           DC    BL1'00000000'
           DC    AL1(0*16)
           DC    AL1(0)
           DC    BL1'00000011'
#FRE_LAB   DS    0F
           LR    0,R0
           LR    1,R1
           L     15,0(,R15)
           L     14,16(0,0)
           L     14,772(14,0)
           L     14,204(14,0)
           PC    0(14)
.RNT002    ANOP
           LM    R14,R12,12(R13)           * load callers + return code
           BSM   0,R14                     * return to caller
    EJECT
         MEXIT
.MNOTE1  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'
         MEND
./ ADD NAME=PRGEND
           MACRO
           PRGEND
           GBLC  &MODNAME
           GBLC  &SETREX
           GBLC  &INREXX
           GBLC  &ISRENT
           GBLC  &SEGNAM
           GBLA  &WHICHM
           AIF   ('&WHICHM' NE '5').MNOTE2
.*
.* Created by John Gateley
.*
&MODNAME   CSECT
           LTORG
           AIF   ('&SETREX' EQ 'Y').YESREX
           AIF   ('&INREXX' EQ 'Y').YESREX
           AGO   .NOREX1
.YESREX    ANOP
           IRXENVB
           IRXEXTE
           IRXEFPL
           IRXARGTB
           IRXEVALB
           IRXSHVB
.NOREX1    ANOP
*
&MODNAME   CSECT
           AIF   ('&ISRENT' EQ 'Y').RNT001
#RENT_AREA DS    0D
           DC    (#E_RENT-#PRGAREA)XL1'00'
#E_E_PROG  EQU   *
.RNT001    ANOP
*
         AIF   ('&SEGNAM' NE '').MNOTE1
         MEXIT
.MNOTE1  MNOTE 16,'Unequal number OF SEGS SEGE macros'
         MEXIT
.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'
         MEND
./ ADD NAME=PRGESTAT
           MACRO
           PRGESTAT
           GBLC  &MODNAME
           GBLA  &WHICHM
           AIF   ('&WHICHM' NE '5').MNOTE2
.*
&MODNAME   CSECT
           DS    0D
           LTORG
*
.*
.* Created by John Gateley
.*
##STATIC_E     EQU   *
               DS    0D
               DC    CL32'&MODNAME ##STATIC END'
@CODE      LOCTR ,
*
         MEXIT
.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'
         MEND
./ ADD NAME=PRGPARM
         MACRO
         PRGPARM &PARM,&LEN=
.**********************************************************************
.*
.*  Created by John Gateley
.*
.*     This macro generates the code to get the value of PARM='  '
.*     in the JCL.
.*
.*     &PARM      where the parameter value should be copied to
.*     &LEN=      a halfword which will contain its length (optional)
.*
         AIF   (T'&PARM EQ 'O').NOPARM
&MYLEN   SETA  L'&PARM
.*
   MVI   &PARM,C' '
   MVC   &PARM+1(L'&PARM-1),&PARM
.*
   L     R1,#PARM_ADDR                   restore R1 at entry
   IF (LTR,R1,R1,NZ)                     parm supplied
     L     R1,0(,R1)                     get address of it
.*
         AIF   (T'&LEN EQ 'O').NOLEN
.*
     MVC   &LEN,0(R1)                    copy length of parm
.*
.NOLEN   ANOP
.*
     IF (CLC,0(2,R1),NE,=H'0')           length not zero
       LA    R0,2(,R1)                   point R0 after length
       LH    R1,0(,R1)                   load length
       IF (CHI,R1,GT,&MYLEN)             > length of receiving field
         LHI   R1,&MYLEN                 use that length
       ENDIF
       LA    R14,&PARM                   point to receiving field
       LR    R15,R1                      copy length
       MVCL  R14,R0                      copy PARM value
     ENDIF
   ENDIF
.*
         MEXIT
.NOPARM  MNOTE 16,'PARM value not supplied (char 80)'
         MEXIT
         MEND
./ ADD NAME=PRGQUIT
           MACRO
           PRGQUIT &RC=0
.*
.* Created by John Gateley
.*
           GBLC  &SCBASER
           GBLC  &BASSAVA
.*
           AIF   ('&RC' EQ '0').NOCODE
.*
           MVI   R_C+3,&RC
.*
.NOCODE    ANOP
.*
           AIF   ('&SCBASER' EQ 'N').NOCBASE
           AIF   ('&SCBASER' EQ '').NOCBASE
           AIF   ('&BASSAVA' EQ '').MNOTE1
.*         restore code base register to initial value
           L     &SCBASER,&BASSAVA
.NOCBASE   ANOP
           BRUL  #AFT_RENT
.*
           MEXIT
.MNOTE1    MNOTE 8,'Macro variable "BASSAVA" has not been set'
           MEND
./ ADD NAME=PRGSTAT
           MACRO
           PRGSTAT
           GBLC  &MODNAME
           GBLC  &SETREX
           GBLC  &USETSTMP
           GBLC  &HEXPCK
           GBLC  &XUNPCK
           GBLC  &WRTLOGD
           GBLC  &WRTLOGU
           GBLA  &WHICHM
           AIF   ('&WHICHM' NE '5').MNOTE2
.*
.* Created by John Gateley
.*
&MODNAME   CSECT
.*
.*         see if segment WRITE_LOG is defined
           AIF   ('&WRTLOGD' EQ 'Y').NOWLOG
.*         see if segment WRITE_LOG is used but not defined
           AIF   ('&WRTLOGU' EQ 'N').NOWLOG
*SEGS WRITE_LOG
 SEGS WRITE_LOG
*
*  WTOX
   WTOX
*
*SEGE WRITE_LOG
 SEGE WRITE_LOG
*
.NOWLOG    ANOP
@DATA      LOCTR ,
##STATIC   DS    0D
           DC    CL32'&MODNAME ##STATIC START'
#RENTSIZ   DC    AL4(#E_RENT-#PRGAREA)
           AIF   ('&SETREX' EQ 'N').NOREX
#RC_SET    MVC   EVALBLOCK_EVDATA(1),0(R1)
.NOREX     ANOP
*
           AIF   ('&USETSTMP' NE 'Y').NOTIME
*                 2 0 0 2 - 1 2 - 3 1 - 1 2 : 3 6 : 1 2 . 1 2 3 4 5 6
##DAT_PAT  DC X'F0202020206020206020206020207A20207A20204B202020202020'
*
.NOTIME    ANOP
.*         define list form of WTO for use in WTOX macro
.*         WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY
#PTN_WTO_LIST    DS    0F
           DC    AL2(8)
           DC    B'1000001000010000'
           DC    AL4(0)
           DC    AL1(2)
           DC    B'00000000'
           DC    AL1(0)
           DC    AL1(104)
           DC    B'0000000010000000'
           DC    AL2(0)
           DC    AL4(0)
           DC    AL4(0)
           DC    AL4(0)
           DC    B'0000000000000000'
           DC    AL2(0)
           DC    XL16'00200000000000000000000000000000'
           DC    B'0000000000000000'
           DC    AL2(0)
           DC    CL8'        '
           DC    CL8'        '
           DC    CL8'        '
           DC    AL4(0)
           DC    AL4(0)
           DC    CL8'        '
           DC    CL8'        '
           DC    AL4(0)
           DC    AL4(0)
           DC    AL4(0)
L_#PTN_WTO_LIST  EQU   *-#PTN_WTO_LIST
           DS    0D
*
.*       If the macro hexpack has been used then include the
.*       required storage
               AIF   ('&HEXPCK' NE 'Y').NOHEXP
HEXPACK_TABLE  DC    X'AABBCCDDEEFF'           C1-C6
               DC    41X'0'                    C7-EF
               DC    X'00112233445566778899'   F0-F9
*
.NOHEXP        ANOP
               AIF   ('&XUNPCK' NE 'Y').NOXUNP
XUNPACK_TAB    DC    C'0123456789ABCDEF'
*
.NOXUNP        ANOP
         MEXIT
.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'
         MEND
./ ADD NAME=PRGSTEM
         MACRO
         PRGSTEM &DSECT=N,&PREF=STEM
.*
.*       This defines storage for calling program PROCSTEM
.*       which handles the population of a STEM variable
.*       on behalf of a REXX assembler function
.*
         AIF   ('&DSECT' EQ 'Y').DS1D02
.*
&PREF._AREA          DS    0D
.*
         AGO   .ST1D02
.*
.DS1D02  ANOP
.*
&PREF._AREA          DSECT
.*
.ST1D02  ANOP
.*
&PREF._NAME          DS    CL48
&PREF._NAME_ADR      DS    F
&PREF._NAME_LEN      DS    F
&PREF._MID_NAME      DS    CL20
&PREF._AFT_DOT       DS    F
&PREF._ZERO_COUNT    DS    PL4
&PREF._TEXT_ADR      DS    F
&PREF._TEXT_LEN      DS    F
&PREF._MAX_LEN       DS    F
&PREF._FUNCTION      DS    H
&PREF._TRIM_VAR      DS    C
&PREF._BLOCK_LEN     EQU   *-&PREF._NAME
.*
         MEND
./ ADD NAME=PUSHINS
      MACRO
      PUSHINS &PAM
  GBLA  &CCVAL   COND CODE VARIABLE
  GBLA  &CTR   MACRO PARAMETER COUNTER
  GBLA  &SEQ   LABEL NUMBER GENERATOR
  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK
  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS
  GBLA  &II   PTR TO INST STKS
  GBLA  &LI   INDEX FOR LABEL NUMBER STK
  GBLA  &NI   PTR TO NEST STK
  GBLA  &AIND(50)  TOTAL CASES STK
  GBLA  &CIND1(200)  CASE NUMBER STK
  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER
  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL
  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES
  GBLC  &IIND1(100)  INSTRUCTION STK 1
  GBLC  &IIND2(100)  INSTRUCTION STK 2
  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART
  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART
  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART
  GBLC  &IIND3(100)  INSTRUCTION STK 3
  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART
  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART
  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART
  GBLC  &IIND4(100)  INSTRUCTION STK 4
  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART
  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART
  GBLC  &IIND5(100)  INSTRUCTION NAME STACK
  GBLC  &LIND(101)  LABEL NUMBER STK
  GBLC  &NEST(50)  NESTING STK
  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO
      LCLA &WK,&I,&J,&K
&I      SETA  3
&J      SETA  4
&K      SETA  4
      AIF ('&PAM(1)'(1,1) EQ 'B' OR '&PAM(1)' EQ 'EQU').BCH
        AIF ('&PAM(5)' EQ '').TWOPERS
   AIF ('&PAM(1)'(1,1) EQ 'C').SETK
&J     SETA  5
   AGO .GETCOND
.TWOPERS       AIF ('&PAM(1)'(1,1) NE 'C').SETK
&I        SETA  4
&J        SETA  3
.SETK        ANOP
&K        SETA  5
.GETCOND  GETCC &PAM(&J)
.BCH      AIF   (&II GE 100).OVERI
&II        SETA  &II+1
&IIND1(&II)    SETC '&PAM(1)'
&IIND2(&II)    SETC '&PAM(2)'(1,8)
&WK    SETA K'&SYSLIST(1,2)
    AIF (&WK GE 25).LD24
&I24(&II)    SETC ''
      AIF (&WK GE 17).LD23
&I23(&II)      SETC ''
        AIF (&WK GE 9).LD22
&I22(&II)  SETC ''
   AGO .PAM3
.LD24        ANOP
.* &I24(&II)   SETC '&PAM(2)'(25,8)   *** OLD STATEMENT
.* CHANGE SO THAT OPERAND 2 IS NOT TRUNCATED TO 32 CHARACTERS (TSDER)
&I24(&II)      SETC '&PAM(2)'(25,&WK)
.LD23      ANOP
&I23(&II)    SETC '&PAM(2)'(17,8)
.LD22    ANOP
&I22(&II)  SETC  '&PAM(2)'(9,8)
.PAM3    AIF ('&PAM(&I)' NE '').LD31
&IIND3(&II)  SETC ''
      AGO  .BLKOUT3
.LD31    ANOP
&IIND3(&II)    SETC '&PAM(&I)'(1,8)
.BLKOUT3   ANOP
&WK    SETA K'&SYSLIST(1,&I)
    AIF (&WK GE 25).LD34
&I34(&II)    SETC ''
      AIF (&WK GE 17).LD33
&I33(&II)      SETC ''
        AIF (&WK GE 9).LD32
&I32(&II)  SETC ''
   AGO .PAM4
.LD34        ANOP
.* &I34(&II)   SETC '&PAM(&I)'(25,8)    *** OLD STATEMENT
.* CHANGE SO THAT OPERAND 4 IS NOT TRUNCATED TO 32 CHARACTERS (TSDER)
&I34(&II)      SETC '&PAM(&I)'(25,&WK)
.LD33      ANOP
&I33(&II)    SETC '&PAM(&I)'(17,8)
.LD32    ANOP
&I32(&II)  SETC  '&PAM(&I)'(9,8)
.PAM4    AIF ('&PAM(&K)' NE '').LD41
&IIND4(&II)  SETC ''
      AGO  .BLKOUT4
.LD41    ANOP
&IIND4(&II)  SETC '&PAM(&K)'(1,8)
.BLKOUT4   ANOP
&WK    SETA K'&SYSLIST(1,&K)
    AIF (&WK GE 17).LD43
&I43(&II)    SETC ''
      AIF (&WK GE 9).LD42
&I42(&II)      SETC ''
        AGO .PAM5
.LD43      ANOP
&I43(&II)    SETC '&PAM(&K)'(17,8)
.LD42    ANOP
&I42(&II)  SETC '&PAM(&K)'(9,8)
.PAM5    AIF ('&PAM(6)' EQ '').BLKOUT5
      AIF ('&PAM(6)'(1,4) NE '#@LB').BLKOUT5
&IIND5(&II)    SETC '&PAM(6)'
      MEXIT
.BLKOUT5   ANOP
&IIND5(&II)  SETC ''
    MEXIT
.OVERI  MNOTE 8,'INSTRN STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'
  MEND
./ ADD NAME=PUSHLAB
  MACRO
  PUSHLAB
  GBLA  &CCVAL   COND CODE VARIABLE
  GBLA  &CTR   MACRO PARAMETER COUNTER
  GBLA  &SEQ   LABEL NUMBER GENERATOR
  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK
  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS
  GBLA  &II   PTR TO INST STKS
  GBLA  &LI   INDEX FOR LABEL NUMBER STK
  GBLA  &NI   PTR TO NEST STK
  GBLA  &AIND(50)  TOTAL CASES STK
  GBLA  &CIND1(200)  CASE NUMBER STK
  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER
  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL
  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES
  GBLC  &IIND1(100)  INSTRUCTION STK 1
  GBLC  &IIND2(100)  INSTRUCTION STK 2
  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART
  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART
  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART
  GBLC  &IIND3(100)  INSTRUCTION STK 3
  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART
  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART
  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART
  GBLC  &IIND4(100)  INSTRUCTION STK 4
  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART
  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART
  GBLC  &IIND5(100)  INSTRUCTION NAME STACK
  GBLC  &LIND(101)  LABEL NUMBER STK
  GBLC  &NEST(50)  NESTING STK
  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO
  AIF   (&LI GE 100).OVER
&SEQ    SETA  &SEQ+1
&LI    SETA  &LI+1
&LIND(&LI) SETC '#@LB&SEQ'
  MEXIT
.OVER  MNOTE 8,' LABEL STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'
    MEND
./ ADD NAME=PUSHNEST
  MACRO
 PUSHNEST &P1
 GBLA &CCVAL       COND CODE VARIABLE
 GBLA &CTR       MACRO PARAMETER COUNTER
 GBLA &SEQ       LABEL NUMBER GENERATOR
 GBLA &AI       INDEX FOR TOTAL NO> CASES STK
 GBLA &CI       INDEX FOR CASE AND LBL NO. STKS
 GBLA &II       PTR TO INST STKS
 GBLA &LI       INDEX FOR LABEL NUMBER STK
 GBLA &NI       PTR TO NEST STK
 GBLA &AIND(50)       TOTAL CASES STK
 GBLA &CIND1(200)      CASE NUMBER STK
 GBLA &MULT(50)       CASE NUMBER MULTIPLIER
 GBLA &ST(51)       INST STK INCREASE AT EACH LEVEL
 GBLC &CIND2(200)      LABEL NUMBER STK FOR CASES
 GBLC &IIND1(100)      INSTRUCTION STK 1
 GBLC &IIND2(100)      INSTRUCTION STK 2
 GBLC &I22(100)       INSTRUCTION STK 2, 2ND PART
 GBLC &I23(100)       INSTRUCTION STK 2, 3RD PART
 GBLC &I24(100)       INSTRUCTION STK 2, 4TH PART
 GBLC &IIND3(100)      INSTRUCTION STK 3
 GBLC &I32(100)       INSTRUCTION STK 3, 2ND PART
 GBLC &I33(100)       INSTRUCTION STK 3, 3RD PART
 GBLC &I34(100)       INSTRUCTION STK 3, 4TH PART
 GBLC &IIND4(100)      INSTRUCTION STK 4
 GBLC &I42(100)       INSTRUCTION STK 4, 2ND PART
 GBLC &I43(100)       INSTRUCTION STK 4, 3RD PART
 GBLC &IIND5(100)      INSTRUCTION NAME STACK
 GBLC &LIND(101)      LABEL NUMBER STK
 GBLC &NEST(50)       NESTING STK
 GBLC &RIND(50)       REG STK FOR CASENTRY MACRO
&NI  SETA  &NI+1
  AIF   (&NI GE 50).OVER
&NEST(&NI) SETC '    &P1'
  MEXIT
.OVER  ANOP
  MNOTE 8,'NEST STACK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'
  MEND
./ ADD NAME=SEGDO
         MACRO
         SEGDO &NAME
.*
.* CREATED BY JOHN GATELEY
.*
         GBLC  &SEGNAM
.*
         AIF   ('&NAME' EQ '').MNOTE1
         AIF   ('&SEGNAM' EQ '##&NAME').MNOTE2
.*
           AIF   ('&NAME' NE 'WRITE_LOG').NOWLOG
           GBLC  &WRTLOGU
&WRTLOGU   SETC  'Y'
.NOWLOG    ANOP
.*
         BRAS  R14,##&NAME
.*
         MEXIT
.MNOTE1  MNOTE 8,'SEGMENT NAME OMITTED'
         MEXIT
.MNOTE2  MNOTE 8,'THE SEGMENT SPECIFIED IS THE CURRENT ONE'
         MEXIT
         MEND
./ ADD NAME=SEGE
           MACRO
           SEGE  &NAME
.*
.* Created by John Gateley
.*
           GBLC  &SEGSAVA
           GBLC  &SEGNAM
           GBLA  &SEGCNT
           GBLC  &SCBASER
           GBLA  &SCBASEC
           GBLC  &BASSAVA
           LCLA  &SEGNO
.*
           AIF   ('&SEGSAVA' EQ '').MNOTE3
           AIF   ('&NAME' EQ '').MNOTE1
           AIF   ('&SEGNAM' NE '##&NAME').MNOTE2
.*
&SEGNAM    SETC  ''
&SEGNO     SETA  &SEGCNT-1
.*
           L     R14,&SEGSAVA+(4*&SEGNO)
           AIF   ('&SCBASER' EQ 'N').NOCBASE
           AIF   ('&SCBASER' EQ '').NOCBASE
           AIF   ('&BASSAVA' EQ '').MNOTE4
#END_CBASE_&SCBASEC  DS    0H
           L     &SCBASER,&BASSAVA+(4*&SEGNO)
           DROP  &SCBASER
.NOCBASE   ANOP
           BR    R14
           EJECT
.*
           MEXIT
.MNOTE1    MNOTE 8,'segment name omitted'
           MEXIT
.*
.MNOTE2    MNOTE 8,'segment name does not match previous'
           MEXIT
.*
           MEXIT
.MNOTE3    MNOTE 8,'macro variable "SEGSAVA" has not been set'
           MEXIT
.MNOTE4    MNOTE 8,'macro variable "BASSAVA" has not been set'
           MEXIT
           MEND
./ ADD NAME=SEGQUIT
           MACRO
           SEGQUIT
.*
.* Created by John Gateley
.*
           GBLC  &SEGSAVA
           GBLA  &SEGCNT
           GBLC  &SCBASER
           GBLA  &SCBASEC
           GBLC  &BASSAVA
           LCLA  &SEGNO
.*
           AIF   ('&SEGSAVA' EQ '').MNOTE1
           AIF   ('&SEGCNT' EQ '0').MNOTE2
.*
&SEGNO     SETA  &SEGCNT-1
.*
           L     R14,&SEGSAVA+(4*&SEGNO)
           AIF   ('&SCBASER' EQ 'NO').NOCBASE
           AIF   ('&SCBASER' EQ '').NOCBASE
           AIF   ('&BASSAVA' EQ '').MNOTE3
           L     &SCBASER,&BASSAVA+(4*&SEGNO)
.NOCBASE   ANOP
           BR    R14
.*
           MEXIT
.MNOTE1    MNOTE 8,'macro variable "SEGSAVA" has not been set'
           MEXIT
.MNOTE2    MNOTE 8,'you are not actually in a segment'
           MEXIT
.MNOTE3    MNOTE 8,'macro variable "BASSAVA" has not been set'
           MEXIT
           MEND
./ ADD NAME=SEGS
           MACRO
           SEGS &NAME
.*
.* Created by John Gateley
.*
           GBLC  &SEGSAVA
           GBLC  &BASSAVA
           GBLC  &SEGNAM
           GBLA  &SEGCNT
           GBLA  &SEGMAX
           GBLC  &SCBASER
           GBLA  &SCBASEC
           AIF   (&SEGMAX NE 0).MAXOK
&SEGMAX    SETA  50
.MAXOK     ANOP
.*
           AIF   ('&SEGSAVA' EQ '').MNOTE4
           AIF   ('&SEGNAM' NE '').MNOTE1
           AIF   ('&NAME' EQ '').MNOTE2
           AIF   (&SEGCNT EQ &SEGMAX).MNOTE3
.*
&SEGNAM    SETC  '##&NAME'
.*
           AIF   ('&NAME' NE 'WRITE_LOG').NOWLOG
           GBLC  &WRTLOGD
&WRTLOGD   SETC  'Y'
.NOWLOG    ANOP
.*
           DC    H'0'           STOP A FALL INTO THIS SEG
&SEGNAM    ST    R14,&SEGSAVA+(4*&SEGCNT)
           AIF   ('&SCBASER' EQ 'N').NOCBASE
           AIF   ('&SCBASER' EQ '').NOCBASE
           AIF   ('&BASSAVA' EQ '').MNOTE5
&SCBASEC   SETA  1+&SCBASEC
           ST    &SCBASER,&BASSAVA+(4*&SEGCNT)
           BASR  &SCBASER,0
           USING (*,#END_CBASE_&SCBASEC),&SCBASER
.NOCBASE   ANOP
.*
&SEGCNT    SETA  1+&SEGCNT
.*
           MEXIT
.MNOTE1    MNOTE 8,'missing SEGE macro, or duplicate SEGS macro'
           MEXIT
.MNOTE2    MNOTE 8,'SEGS name omitted'
           MEXIT
.MNOTE3    MNOTE 8,'maximum segments exceeded '
           MEXIT
.MNOTE4    MNOTE 8,'macro variable "SEGSAVA" has not been set'
           MEXIT
.MNOTE5    MNOTE 8,'macro variable "BASSAVA" has not been set'
           MEXIT
           MEND
./ ADD NAME=SETRC
           MACRO
           SETRC &RC=0,&COND=N
.*
.* Created by John Gateley
.*
           AIF   ('&RC' EQ '0').MAKE0
           AIF   ('&COND' EQ 'N').NOCOND
           AIF   ('&COND' NE 'Y').MNOTE1
           CLI   R_C+3,&RC
           BH    RC&SYSNDX
           MVI   R_C+3,&RC
RC&SYSNDX  DS    0H
           MEXIT
.*
.MAKE0     ANOP
           XC    R_C,R_C
           MEXIT
.*
.NOCOND    ANOP
           XC    R_C,R_C
           MVI   R_C+3,&RC
           MEXIT
.*
.*
           MEXIT
.MNOTE1    MNOTE 16,'COND parameter was not Y or N'
           MEND
./ ADD NAME=STKINS
         MACRO
         STKINS &P1,&P2,&P3,&P4,&P5,&P6
         COPY  GBLVARS
         LCLC  &SIGN
.*
.* AUGUST 2014 - JOHN GATELEY - ADD SUPPORT FOR TAM AND TP
.*
         AIF    ('&P1(2)' EQ '').NOTSUBL
           AIF ('&P1(6)' EQ '' OR '&P1(6)' EQ '&LIND(&LI)').OKSUBL
             MNOTE 12,'TOO MANY OPERANDS INSIDE PARENTHESES'
             MEXIT
.OKSUBL  AIF   ('&P1(1)' EQ 'TP').TPST
         AIF   ('&P1(1)' EQ 'TAM').TAM24
         AIF   ('&P1(3)' EQ '').FILE
         PUSHINS (&P1(1),&P1(2),&P1(3),&P1(4),&P1(5),&P1(6))
             MEXIT
.NOTSUBL AIF   ('&P2' EQ '' OR '&P2' EQ 'OR' OR '&P2' EQ 'AND' OR '&P2'X
               EQ 'ORIF' OR '&P2' EQ 'ANDIF').SGLOPR
           AIF ('&P5' EQ 'OR' OR '&P5' EQ 'AND' OR '&P5' EQ 'ORIF' OR  X
               '&P5' EQ 'ANDIF').TWOPER2
             PUSHINS (&P1,&P2,&P3,&P4,&P5,&P6)
&CTR         SETA  &CTR+4
             MEXIT
.TWOPER2   PUSHINS (&P1,&P2,&P3,&P4,,&P6)
&CTR         SETA  &CTR+3
             MEXIT
.FILE    AIF   ('&P1(1)'(1,1) EQ '(').FILE1
&SIGN    SETC  '+'
.FILE1   AIF   ('&P1(2)' NE 'OPEN').FILE2
         PUSHINS (TM,X'30'&SIGN&P1(1),X'10',O,&P1(5),&P1(6))
         MEXIT
.FILE2   AIF   ('&P1(2)' NE 'NOTOPEN').FILE3
         PUSHINS (TM,X'30'&SIGN&P1(1),X'10',Z,&P1(5),&P1(6))
         MEXIT
.FILE3   AIF   ('&P1(2)' NE 'EOF').FILE4
         PUSHINS (TM,X'30'&SIGN&P1(1),X'04',O,&P1(5),&P1(6))
         MEXIT
.FILE4   AIF   ('&P1(2)' NE 'NOTEOF').FILE5
         PUSHINS (TM,X'30'&SIGN&P1(1),X'04',Z,&P1(5),&P1(6))
         MEXIT
.FILE5   AIF   ('&P1(2)' NE 'ENDPROG').FILE6
         PUSHINS (CLC,&P1(1),NE,=F'-1',&P1(5),&P1(6))
         MEXIT
.FILE6   AIF   ('&P1(2)' NE 'NOTENDPROG').FILE7
         PUSHINS (CLC,&P1(1),EQ,=F'-1',&P1(5),&P1(6))
         MEXIT
.FILE7   AIF   ('&P1(2)' NE 'INERROR').FILE8
         PUSHINS (CLC,&P1(1),NE,=F'0',&P1(5),&P1(6))
         MEXIT
.FILE8   AIF   ('&P1(2)' NE 'NOTINERROR').FILE9
         PUSHINS (CLC,&P1(1),EQ,=F'0',&P1(5),&P1(6))
         MEXIT
.FILE9   AIF   ('&P1(2)' NE 'SYNAD').FILE10
         PUSHINS (TM,X'2C'&SIGN&P1(1),X'30',O,&P1(5),&P1(6))
         MEXIT
.FILE10  AIF   ('&P1(2)' NE 'NOTSYNAD').FILE11
         PUSHINS (TM,X'2C'&SIGN&P1(1),X'30',Z,&P1(5),&P1(6))
         MEXIT
.FILE11  ANOP
         PUSHINS (TM,0(0),X'00',O,&P1(5),&P1(6))
         MNOTE 12,'INVALID INSTRUCTION &P1(1),&P1(2) - NOP GENERATED'
         MEXIT
.*
.TPST    ANOP
         PUSHINS (&P1(1),&P1(2),,&P1(3))
         MEXIT
.*
.TAM24   AIF   ('&P1(2)' NE '24').TAM31
         PUSHINS (&P1(1),*24,,8)
         MEXIT
.TAM31   AIF   ('&P1(2)' NE '31').TAM64
         PUSHINS (&P1(1),*31,,4)
         MEXIT
.TAM64   AIF   ('&P1(2)' NE '64').TAMERR
         PUSHINS (&P1(1),*64,,1)
         MEXIT
.TAMERR  ANOP
         MNOTE 12,'TAM CAN ONLY TEST 24 31 OR 64'
         MEXIT
.*
.SGLOPR  GETCC  &P1(1)
         MEND
./ ADD NAME=STRING
         MACRO
         STRING  &OUT=MESS_TXT,&WORK=,&SAVE=MY_PARM,&SLEN=0,           /
               &PAD=,&PADB=N,&FPAD=0,&NUM0=N
.**********************************************************************
.*
.* November  2016 - John Gateley - create
.*
.*       This macro uses program STRINGIT to concatenate the values
.*       of fields into an area.
.*
.*       This macro takes positional parameters in groups of two,
.*       as many as required. Followed by keyword parameters as
.*       detailed below.
.*
.*       The repeated values are field-name and C,X,B,P,I,U,S or V
.*         C means just copy it (character)
.*         X means output hexadecimal display
.*         B means output binary display
.*         P means packed decimal input, output numeric display
.*         I Fullword integer, output numeric display
.*         U Unsigned fullword integer, output numeric display
.*         S Halfword small integer, output numeric display
.*         V Unsigned halfword small integer, output numeric display
.*
.*       STRING (field1,c,field2,x,(R4),x),OUT=MESS_TXT,WORK=CL32
.*
.*       OUT=    the area in which the string is to be built
.*
.*       WORK=   a 32 byte work area for program STRINGIT
.*       If this is not provided a global macro variable STRWRK
.*       will be used as the work area. If neither of these is
.*       provided the macro will fail to expand.
.*       GBLC  &STRWRK
.*
.*
.*       If the value to be displayed is in a register just use
.*       register notation in the macro i.e. (R6) and use X or I
.*       depending on how you want to view the contents
.*
.*       STRING (field1,c,(R3),x,(R4),i),OUT=MESS_TXT,PAD=|
.*
.*       Note that if you want to use the value of a 64 bit
.*       register you will need to use STG to place the value into
.*       an 8 byte field and use that in the macro.
.*       This is because the actual register value is stored in the
.*       parameter list instead of an address and the parameter
.*       list consists of 32 bit words.
.*
.*       If the PAD= parameter is specified a pad byte will be
.*       included between each field which will contain the specified
.*       value.
.*       PADB=Y means have a pad byte but make it C' '
.*       PADB takes precedence over the PAD= macro parameter
.*
.*       FPAD is the number of pad bytes to be put at the start
.*       of the output area, this is to allow the text to be indented.
.*       Using OUT=MESS_TXT+2 instead of FPAD=2 is not recomended as
.*       although it will indent by 2 it will cause the macro to think
.*       that the output field is 4 bytes longer than it is.
.*       LA    R15,L'MESS_TXT+2 will take the length and add 2 to it
.*       when the effective length should be L'MESS_TXT-2
.*
.*       NUM0=N means do not output leading zeroes from numeric display
.*       change to Y if you want leading zeroes.
.*
.*       If the output message area is not big enough for all the
.*       required fields then program STRINGIT will abend with a
.*       suitable message. As the length of the strung output
.*       will not vary, if this works in test it will work in
.*       production.
.*
.*       The SAVE= parameter specifies an area in which the macro
.*       builds the parameter list for the call to STRINGIT, this
.*       defaults to MY_PARM.
.*
.*       Note that the last parameter will not have the high order
.*       bit set on as STRINGIT processing stops when the value
.*       x'FF' is found in the indicator list. This is because a
.*       register value could be negative.
.*
.*       SLEN= may be used to specify the number of fullwords
.*       available in the parameter list, this ensures that
.*       storage after the end of the parameter list is not
.*       overwritten.
.*       If this is not provided a global macro variable PARMAX
.*       will be used as the count of fullwords. If neither of
.*       these is provided the macro will fail to expand.
.*
.*       GBLA  &PARMAX
.*&PARMAX    SETA  18
.*
.*
.*       After the macro call STRINGIT R1 will contain the address
.*       of the byte after the last one modified. R15 will be zero.
.*
.*       Note that this macro and the STRINGIT program are reentrant.
.*
.*
.*       End of comments, down to business.
.*
.*
&A       SETA  N'&SYSLIST(1)             * get count of values in ( )
&B       SETA  &A/2                      * divide by 2
&C       SETA  1
&D       SETA  1
&E       SETA  6                         * minimum 6 parameters
&F       SETA  &B*2                      * multiply by 2
         AIF   (&F NE &A).NOTEVEN        * not equal means not even
.*
         LCLC  &INDS
         LCLA  &PARMS
         GBLA  &PARMAX
         GBLC  &STRWRK
.*
         AIF   ('&NUM0' EQ 'Y').NUMOK    * Y is OK
         AIF   ('&NUM0' EQ 'N').NUMOK    * N is OK
         AGO   .BADNUM
.NUMOK   ANOP
.*
&PARMS   SETA  &PARMAX
         AIF   ('&SLEN' EQ '0').NOTSLEN  * default to PARMAX
&PARMS   SETA  &SLEN
.NOTSLEN ANOP
         AIF   (&PARMS EQ 0).NOLEN       * flag expansion error
         AIF   (&PARMS LT 6).TOOMUCH     * filled up parameter area
.*
         AIF   (T'&OUT EQ 'O').NOOUT     * output area provided
.*
         AIF   (T'&WORK NE 'O').YESWORK  * work area provided
         AIF   ('&STRWRK' NE '').STWORK  * default to STRWRK
         AGO   .NOWORK
.YESWORK ANOP
&WRK     SETC  '&WORK'                   * use provided work area
         AGO   .AFTWORK
.STWORK  ANOP
&WRK     SETC  '&STRWRK'
.AFTWORK ANOP
.*
.*       first put in the address of the indicators, followed by
.*       the start and length of the output area and finally
.*       the work area address.
.*
         LA    R14,I&SYSNDX              * point to list of indicators
         LA    R15,&OUT                  * address of output string
         LA    R0,L'&OUT                 * length of output string
         LA    R1,&WRK                   * work area for STRINGIT
         STM   R14,R1,&SAVE              * save in parameters 1,2,3 + 4
         LA    R1,&SAVE+16               * point to fifth parameter
.*
.AGAIN   ANOP
.*                                       * is value in a register?
&RVAL    SETC  '&SYSLIST(1,&C)'
         AIF   ('&RVAL'(1,1) EQ '(').REGVAL
.*                                       * not register notation
         AIF   ('&RVAL'(1,1) EQ '''').QUOTVAL
.*                                       * not quoted string
         LA    R14,&SYSLIST(1,&C)        * sending field
         LA    R15,L'&SYSLIST(1,&C)      * length
         AGO   .AFTREG
.*
.QUOTVAL ANOP
&QLEN    SETA  K'&RVAL-2
         LA    R14,=C&RVAL
         LA    R15,&QLEN
         AGO   .AFTREG
.*
.REGVAL  ANOP
&RVAL2   SETC  '&SYSLIST(1,&C)'(2,K'&SYSLIST(1,&C)-2)
.*                                       * register notation
         LR    R14,&RVAL2                * copy register value
         LHI   R15,-4                    * say -4 to show in register
.*
.AFTREG  ANOP
         STM   R14,R15,0(R1)             * save in parameter list
.*
         AIF   ('&D' GE '&B').DONE1      * done last value?
&C       SETA  &C+2
&D       SETA  &D+1
&E       SETA  &E+2
         AIF   (&E GT &PARMS).TOOMUCH    * filled up parameter area
.DONE0   ANOP
         LA    R1,8(,R1)                 * point past these two
         AGO   .AGAIN                    * process next value
.DONE1   ANOP
.*
&A       SETA  N'&SYSLIST(1)             * get count of values
&B       SETA  &A/2                      * divide by 2
&C       SETA  1
&D       SETA  1
         B     A#&SYSNDX                 * branch past indicators
.*
.*   This code builds a string containing all the specified format
.*   indicators.
.*
.AGAIN2  ANOP
.*
         AIF   ('&SYSLIST(1,&C+1)' EQ 'C').CHAR
         AIF   ('&SYSLIST(1,&C+1)' EQ 'c').CHAR
         AIF   ('&SYSLIST(1,&C+1)' EQ 'X').HEX
         AIF   ('&SYSLIST(1,&C+1)' EQ 'x').HEX
         AIF   ('&SYSLIST(1,&C+1)' EQ 'B').BINARY
         AIF   ('&SYSLIST(1,&C+1)' EQ 'b').BINARY
         AIF   ('&SYSLIST(1,&C+1)' EQ 'P').PACKED
         AIF   ('&SYSLIST(1,&C+1)' EQ 'p').PACKED
         AIF   ('&SYSLIST(1,&C+1)' EQ 'I').INTEGER
         AIF   ('&SYSLIST(1,&C+1)' EQ 'i').INTEGER
         AIF   ('&SYSLIST(1,&C+1)' EQ 'U').UINT
         AIF   ('&SYSLIST(1,&C+1)' EQ 'u').UINT
         AIF   ('&SYSLIST(1,&C+1)' EQ 'S').SMALL
         AIF   ('&SYSLIST(1,&C+1)' EQ 's').SMALL
         AIF   ('&SYSLIST(1,&C+1)' EQ 'V').USMALL
         AIF   ('&SYSLIST(1,&C+1)' EQ 'v').USMALL
         AGO   .NEITHER                  * not valid
.CHAR    ANOP
&INDS    SETC  '&INDS.C'                 * say character
         AGO   .DONE3
.HEX     ANOP
&INDS    SETC  '&INDS.X'                 * say hexadecimal
         AGO   .DONE3
.BINARY  ANOP
&INDS    SETC  '&INDS.B'                 * say binary
         AGO   .DONE3
.PACKED  ANOP
&INDS    SETC  '&INDS.P'                 * say packed decimal
         AGO   .DONE3
.INTEGER ANOP
&INDS    SETC  '&INDS.I'                 * say integer
         AGO   .DONE3
.UINT    ANOP
&INDS    SETC  '&INDS.U'                 * say unsigned integer
         AGO   .DONE3
.SMALL   ANOP
&INDS    SETC  '&INDS.S'                 * say small integer
         AGO   .DONE3
.USMALL  ANOP
&INDS    SETC  '&INDS.V'                 * say unsigned small integer
         AGO   .DONE3
.DONE3   ANOP
.*
         AIF   ('&D' GE '&B').DONE4      * done last value?
&C       SETA  &C+2
&D       SETA  &D+1
         AGO   .AGAIN2                   * process next value
.DONE4   ANOP
.*
         AIF   ('&PADB' EQ 'N').TRYPAD
&UPAD    SETC  'Y '                      * pad with a blank
         AGO   .ENDPAD
.TRYPAD  ANOP
         AIF   (T'&PAD NE 'O').USEPAD    * use provided pad char
&UPAD    SETC  'N '                      * no padding
         AGO   .ENDPAD
.USEPAD  ANOP
&UPAD    SETC  'Y&PAD'                   * use pad character and value
.ENDPAD  ANOP
.*
I&SYSNDX DC    CL15'&UPAD&FPAD&NUM0'     * Currently 4 bytes of global
.*                                       * indicators but allow for 15
         DC    C'&INDS'                  * output all the indicators
         DC    X'FF'                     * flag end of indicators
A#&SYSNDX      DS    0H
         LA    R1,&SAVE                  * point to parameters
         L     R15,=V(STRINGIT)          * get string routine address
         BASR  R14,R15                   * and go there
         MEXIT
.NOTEVEN MNOTE 16,'Number of positional parameters not even'
         MEXIT
.NOOUT   MNOTE 16,'No output area provided OUT='
         MEXIT
.BADNUM  MNOTE 16,'NUM0 not equal to Y or N'
         MEXIT
.NEITHER MNOTE 16,'Second value must be C,X,B,P,I,U,S or V'
         MEXIT
.TOOMUCH MNOTE 16,'Too many values for supplied parameter area'
         MEXIT
.NOLEN   MNOTE 16,'Length of parameter area not supplied, SLEN='
         MEXIT
.NOWORK  MNOTE 16,'No work area was provided, WORK='
         MEND
./ ADD NAME=STRINGIT
STRINGIT CSECT
STRINGIT AMODE 31
STRINGIT RMODE ANY
*
* Created by John Gateley
*
*   This program is used by the STRING macro to convert fields
*   to the required format and to put them into the output area.
*
*   Note that on return from this program register 1 contains the
*   address of the byte in the output area after the strung data.
*
*   Input parameters generated by the STRING macro are
*     1, address of a series of format indicators terminated by x'FF'
*     2, address of output area
*     3, length of the output area
*     4, address of a 32 byte work area
*
*     5, address of input field
*     6, length of input field
*
*   Parameters 5 and 6 repeat for as many indicators as there are in
*   the list pointed to by parameter 1
*
*   note that this program does not have it's own save area because
*   it does not call anything and it needs to be re-entrant
*
         SAVE  (14,12)                   * save callers registers
         PRINT OFF
         YREGS
         PRINT ON
         LR    R12,R15                   * copy base address
         USING STRINGIT,R12
         LR    R10,R1                    * copy parameter address
         LM    R3,R6,0(R10)              * load first 4 parameters
*                              R3    string of output indicators
*                              R4    address of output field
*                              R5    length of output field
*                              R6    work area in caller
         USING WORKAREA,R6
         MVC   GLOB_IND,0(R3)        * copy global indicators
         LA    R3,L'GLOB_IND(,R3)    * point passed global indicators
         AR    R5,R4                 * point after output field
         LA    R7,16(,R10)     R7    * point to first address/length
*
         CLI   PAD_FRST,C'0'
         BNH   GO_AGAIN              * no initial pad char
         PACK  DOUB_WORD,PAD_FRST
         CVB   R1,DOUB_WORD
         LA    R4,0(R1,R4)           * point passed initial pad char
*
GO_AGAIN DS    0H
         LM    R8,R9,0(R7)           Get details of next field
*
*        if the length in R9 is negative it means that R8 contains
*        the value to be displayed not the address of the value
*
         LTR   R9,R9                     * test R9
         BP    IS_POS                    * if positive then use it
         LPR   R9,R9                     * make positive
         ST    R8,FULL_WORD              * save 32 bit value
         LA    R8,FULL_WORD              * and point to it
*
IS_POS   DS    0H
*
         CLI   0(R3),C'X'                * Hex output required
         BE    HEX_OUT
*
         CLI   0(R3),C'B'                * Binary output required
         BE    BIN_OUT
*
         CLI   0(R3),C'P'                * Pack output required
         BE    PACK_OUT
*
         CLI   0(R3),C'I'                * Integer output required
         BE    INT_OUT
*
         CLI   0(R3),C'U'                * Unsigned integer required
         BE    UINT_OUT
*
         CLI   0(R3),C'S'                * Small Int output required
         BE    SINT_OUT
*
         CLI   0(R3),C'V'                * Small unsigned int required
         BE    VINT_OUT
*
*        assume it must be character
*
*        Just copy the character value to the output area
*
CHAR_OUT DS    0H
         LA    R1,0(R9,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         BCTR  R9,0                      * -1 for execute
         EX    R9,MVC_IT                 * execute the move
         LA    R4,1(R9,R4)               * point past data copied
         B     DONE_IT
*
*        Take the value and convert to hexadecimal display
*
HEX_OUT  DS    0H
         LR    R2,R9                     * copy sending length
         SLL   R2,1                      * multiply by 2
         LA    R1,0(R2,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
HEX_OUT1 DS    0H
         MVC   WORK2(1),0(R8)            * copy one byte
         UNPK  WORK3,WORK2               * UNPK two bytes to three
         TR    WORK3(2),TR_TAB-240       * convert to displayable
         MVC   0(2,R4),WORK3             * copy to receiver
         LA    R4,2(,R4)                 * move past output bytes
         LA    R8,1(,R8)                 * move past input byte
         BCT   R9,HEX_OUT1               * do next byte
         B     DONE_IT
*
*        Take the value and convert to binary display
*        This puts the byte into the low byte of register 1 and then
*        for each iteration of the inner loop moves the next bit into
*        the low bit of byte three of the register and stores it.
*        So as the loop progresses the bit values become bytes in
*        the output string.
*
BIN_OUT  DS    0H
         LR    R2,R9                     * copy sending length
         SLL   R2,3                      * multiply by 8
         LA    R1,0(R2,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
BIN_OUT1 DS    0H
         IC    R1,0(R8)                  * get a byte
         LR    R14,R4                    * copy output address
         LA    R15,8                     * 8 bits to a byte
*
BIN_OUT2 DS    0H
         SLA   R1,1                      * slide left 1 bit
         STCM  R1,2,0(R14)               * store third byte
         NI    0(R14),1                  * switch of all but right bit
         LA    R14,1(,R14)               * next output byte
         BCT   R15,BIN_OUT2              * process next bit
*
         OC    0(8,R4),ZONES             * make zoned decimal
         LA    R4,8(,R4)                 * move past output bytes
         LA    R8,1(,R8)                 * move past input byte
         BCT   R9,BIN_OUT1               * do next byte
         B     DONE_IT
*
*        Input is packed convert to numeric display
*
PACK_OUT DS    0H
         LR    R2,R9                     * copy sending length
         SLL   R2,1                      * multiply by 2
         LA    R1,0(R2,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         CHI   R9,8                      * cannot unpk > 8 bytes
         BH    PACKLONG                  * so abend
         LR    R1,R9                     * get length of field
         BCTR  R1,0                      * less 1 for execute
         LR    R15,R1                    * copy for CP
         SLL   R15,4                     * left one nibble
         LR    R2,R9                     * get length of field
         BCTR  R2,0                      * subtact for EX and sign
         SLL   R2,1                      * multiply by 2
         LA    R14,0(R2,R4)              * position to last digit
         SLL   R2,4                      * left one nibble
         OR    R1,R2                     * merge lengths
         EX    R1,UNPK_IT                * unpack data
         OI    0(R14),X'F0'              * make last digit numeric
         EX    R15,CP_IT                 * check if negative
         BL    P_NEG                     * branch negative
         MVI   1(R14),C'+'
         B     P_DONE
P_NEG    DS    0H
         MVI   1(R14),C'-'
P_DONE   DS    0H
*
*        the following code is to remove leading zeroes, I know I
*        could have built an edit pattern and executed an edit
*        instruction but I thought this was easier. Also having a pad
*        character would increase the size of the output field.
*
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    P_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LR    R2,R9                     * get length of field
         BCTR  R2,0                      * subtract 1
         SLL   R2,1                      * multiply by 2
P_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   P_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,P_CHK0                 * check next
P_DONEX  DS    0H
         LA    R4,2(,R14)                * move past output bytes
         B     DONE_IT
*
*        Input is integer convert to numeric display
*
INT_OUT  DS    0H
         LA    R1,11(,R4)                * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         L     R1,0(R8)                  * get integer value
         CVD   R1,DOUB_WORD
         CP    DOUB_WORD,=P'0'
         BL    I_NEG
         MVI   10(R4),C'+'
         B     I_DONE
I_NEG    DS    0H
         MVI   10(R4),C'-'
I_DONE   DS    0H
         OI    DOUB_WORD+7,X'0F'
         UNPK  0(10,R4),DOUB_WORD
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    I_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,9                      * get length to check
I_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   I_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,I_CHK0                 * check next
I_DONEX  DS    0H
         LA    R4,11(,R4)                * move past output bytes
         B     DONE_IT
*
*        Input is un-signed integer convert to numeric display
*
UINT_OUT DS    0H
         LA    R1,10(,R4)                * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         L     R1,0(R8)                  * get integer value
         SRL   R1,1                      * divide by 2
         CVD   R1,DOUB_WORD              * convert to decimal
         MP    DOUB_WORD,=P'2'           * multiply by 2
         TM    3(R8),X'01'               * was low bit on
         BZ    U_DONE
         AP    DOUB_WORD,=P'1'           * add the one back in
U_DONE   DS    0H
         OI    DOUB_WORD+7,X'0F'         * set the sign
         UNPK  0(10,R4),DOUB_WORD        * unpack the value
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    U_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,9                      * get length to check
U_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   U_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,U_CHK0                 * check next
U_DONEX  DS    0H
         LA    R4,10(,R4)                * move past output bytes
         B     DONE_IT
*
*        Input is small integer convert to numeric display
*
SINT_OUT DS    0H
         LA    R1,6(,R4)                 * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         LH    R1,0(R8)                  * get small integer value
         CVD   R1,DOUB_WORD
         CP    DOUB_WORD,=P'0'
         BL    S_NEG
         MVI   5(R4),C'+'
         B     S_DONE
S_NEG    DS    0H
         MVI   5(R4),C'-'
S_DONE   DS    0H
         OI    DOUB_WORD+7,X'0F'
         UNPK  0(5,R4),DOUB_WORD
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    S_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,4                      * get length to check
S_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   S_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,S_CHK0                 * check next
S_DONEX  DS    0H
         LA    R4,6(,R4)                 * move past output bytes
         B     DONE_IT
*
*        Input is un-signed small integer convert to numeric display
*
VINT_OUT DS    0H
         LA    R1,5(,R4)                 * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         ICM   R1,3,0(R8)                * get small unsigned int val
         CVD   R1,DOUB_WORD
         OI    DOUB_WORD+7,X'0F'
         UNPK  0(5,R4),DOUB_WORD
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    V_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,4                      * get length to check
V_CHK0   CLI   0(R4),C'0'                * is this byte zero
         BNE   V_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,V_CHK0                 * check next
V_DONEX  DS    0H
         LA    R4,5(,R4)                 * move past output bytes
         B     DONE_IT
*
*        Processed that pair of address/length values - any more
*
DONE_IT  DS    0H
         LA    R3,1(,R3)                 * point to next indicator
         CLI   0(R3),X'FF'               * finished ?
         BE    GO_BACK                   * then goback
*
         LA    R7,8(,R7)                 * next pair of addresses
         CLI   PAD_DING,C'Y'             * any pad characted ?
         BNE   GO_AGAIN                  * not so go again
         MVC   0(1,R4),PAD_DING+1        * copy pad character
         LA    R4,1(,R4)                 * jump past pad
         B     GO_AGAIN                  * process next
*
*        Return to calling program setting R1 to the output byte after
*        the last byte used.
*
GO_BACK  DS    0H
         ST    R4,4(,R10)                * save current output address
*                                        * in parameter list
         LM    R14,R12,12(R13)           * restore callers registers
         XR    15,15                     * set return code
         L     R1,4(,R1)                 * retrieve current output adr
*                                        * from parameter list
         BR    R14                       * return to caller
*********
*
* error routines
*
* There is no room in the output area for the input value so abend
*
OVERFLOW DS    0H
         WTO   'STRINGIT - output overflow detected',                  /
               ROUTCDE=11,MCSFLAG=HRDCPY
         B     DO_AB
*
* Cannot unpack more than 8 bytes so abend
*
PACKLONG DS    0H
         WTO   'STRINGIT - packed field > 8',                          /
               ROUTCDE=11,MCSFLAG=HRDCPY
DO_AB    ABEND 500,DUMP,STEP             * ,REASON=1
*********
*
* storage
*
WORKAREA       DSECT
DOUB_WORD      DS    D
FULL_WORD      DS    F
WORK2          DS    CL2
WORK3          DS    CL3
GLOB_IND       DS    CL15
               ORG   GLOB_IND
PAD_DING       DS    CL2             * pad details  (Y/N + value)
PAD_FRST       DS    CL1             * pad first value   (numeric)
NUM_ZERO       DS    CL1             * output numeric leading zeroes
               ORG
*
STRINGIT       CSECT
ZONES          DC    C'00000000'
TR_TAB         DC    C'0123456789ABCDEF'
MVC_IT         MVC   0(1,R4),0(R8)
UNPK_IT        UNPK  0(1,R4),0(1,R8)
CP_IT          CP    0(1,R8),=P'0'
*
               LTORG
*
               END
./ ADD NAME=TESTNEST
  MACRO
 TESTNEST &P1
 GBLC &PGMNAME
 GBLC &ENDPROG
 GBLC &MODNAME
 GBLC &MODSTRT
 GBLC &ENDMOD
 GBLC &SEGNAME
 GBLC &SEGSTRT
 GBLA &EQUATE
 GBLA &CCVAL
 GBLA &CTR
 GBLA &SEQ
 GBLA &II
 GBLA &LI
 GBLA &NI
 GBLA &ST(51)
 GBLC &IIND1(100)
 GBLC &IIND2(100)
 GBLC &I22(100)
 GBLC &I23(100)
 GBLC &I24(100)
 GBLC &IIND3(100)
 GBLC &I32(100)
 GBLC &I33(100)
 GBLC &I34(100)
 GBLC &IIND4(100)
 GBLC &I42(100)
 GBLC &I43(100)
 GBLC &IIND5(100)
 GBLC &LIND(101)
 GBLC &NEST(50)
 GBLA &AI
 GBLA &CI
 GBLA &AIND(50)
 GBLA &MULT(50)
 GBLA &CIND1(200)
 GBLC &CIND2(200)
 GBLC &RIND(50)
 LCLC &STRUCT
&STRUCT  SETC  '&NEST(&NI)'(5,4)
  AIF   ('&STRUCT' EQ '&P1').GOOD
    MNOTE 8,'&STRUCT STRUCTURE AT SAME LEVEL AS &P1 MACRO SET'
.GOOD  ANOP
  MEND
./ ADD NAME=TRIM
         MACRO
         TRIM  &AREA,&LEN,&SAVE=MY_PARM,&ALL=N
.**********************************************************************
.*
.* Created by John Gateley
.*
.*       This macro removes leading and extra blanks from a field
.*       so that         '  some  text    in    a  field       x'
.*       becomes         'some text in a field x                '
.*
.*       Optionally, all blanks can be removed from the field by
.*       specifying ALL=Y.
.*
.*       On return R15 contains the number of occupied bytes
.*
.*       &AREA=   the field to trim, can be in a register (R14)
.*       &LEN=    length of the field, can be in a register (R15)
.*                it can also be omitted
.*       &SAVE=   name of parameter list to use
.*
.*       TRIM  MY_FIELD,20             length of 20
.*       TRIM  MY_FIELD                assumes L'MY_FIELD
.*       LA    R1,MY_FIELD
.*       LA    R2,L'MY_FIELD
.*       TRIM  (R1),(R2)
.*
         AIF   (T'&LEN NE 'O').USELEN        * parameter missing
         LA    R15,L'&AREA             use the implied length
         ST    R15,&SAVE+4             save as second parameter
         AGO   .NOTREGL
.*
.USELEN  ANOP
         AIF   ('&LEN'(1,1) EQ '(').REGVALL  * value in register
         LA    R15,&LEN                use the specified length
         ST    R15,&SAVE+4             save as second parameter
         AGO   .NOTREGL
.REGVALL ANOP
&LENR    SETC  '&LEN'(2,K'&LEN-2)
         ST    &LENR,&SAVE+4           save length as second parameter
.NOTREGL ANOP
.*
         AIF   ('&AREA'(1,1) EQ '(').REGVALA  * value in register
         LA    R14,&AREA               point at area
         ST    R14,&SAVE               save as first parameter
         AGO   .NOTREGA
.REGVALA ANOP
&VALR    SETC  '&AREA'(2,K'&LEN-2)
         ST    &VALR,&SAVE             save address as first parameter
.NOTREGA ANOP
.*
         AIF   ('&ALL' EQ 'Y').ALLYES
         LA    R1,0                    do not remove all blanks
         ST    R1,&SAVE+8
         AGO   .DOCALL
.ALLYES  ANOP
         LA    R1,1                    remove all blanks
         ST    R1,&SAVE+8
.DOCALL  ANOP
         LA    R1,&SAVE                point to parameter list
         L     R15,=V(TRIMIT)          get program address
         BASR  R14,R15                 call program
.*
         L     R15,&SAVE+4             load amended length
*        R15 now has the occupied byte count
.*
         MEND
./ ADD NAME=TRIMIT
TRIMIT   CSECT
TRIMIT   AMODE 31
TRIMIT   RMODE ANY
*
*   This program removes leading and extra blanks from a field
*   so that         '  some  text    in    a  field       x'
*   becomes         'some text in a field x                '
*
*   Optionally, all blanks can be removed from the field by
*   specifying ALL=Y in the TRIM macro resulting in
*                   'sometextinafieldx                     '
*
*   On return R15 contains the number of occupied bytes
*
*   Input parameters generated by the TRIM macro are
*     1, address of a string which should be trimmed
*     2, length of the string
*     3,  0    only remove repeated spaces
*        >0    remove all spaces
*
         SAVE  (14,12)                 save callers registers
         PRINT OFF
         YREGS
         PRINT ON
         LR    R12,R15                 copy base address
         USING TRIMIT,R12
         LR    R9,R1                   copy parameter address
         LM    R4,R6,0(R9)             get address, length and ind
         LA    R3,0(R4,R5)             point after string
         BCTR  R3,0                    point at last byte
*
         CHI   R6,0                    if positive
         BH    TRIM_ALL                trim all blanks
*
*  remove repeated spaces
*
         LA    R6,1                    flag next blank to be removed
STRTLOOP LR    R7,R5                   copy the length
         BCTR  R7,0                    subtract 1 for remaining length
         LR    R2,R7                   copy as inner loop count
         BCTR  R7,0                    subtract 1 for execute
COMPARE  CLI   0(R4),C' '              check if this byte blank
         BNE   SETNO                   no so set flag off
         CHI   R6,1                    is flag on
         BNE   SETYES                  no so set flag on
         LTR   R7,R7                   test remaining length
         BM    ENDLOOP                 negative then finish
         EX    R7,SLIDE_LEFT           slide bytes left
         MVI   0(R3),C' '              blank the last byte
         BCT   R2,COMPARE              loop to go and test again
         B     ENDLOOP                 branch past execute to end
SETYES   LA    R6,1                    flag next blank to be removed
         B     LOOPIT                  go and loop
SETNO    LA    R6,0                    flag next blank to be ignored
LOOPIT   LA    R4,1(,R4)               next byte in field
         BCT   R5,STRTLOOP             loop to check next byte
         B     ENDLOOP
*
*  remove all spaces
*
TRIM_ALL DS    0H
*
STRTLOO2 LR    R7,R5                   copy the length
         BCTR  R7,0                    subtract 1 for remaining length
         LR    R2,R7                   copy as inner loop count
         BCTR  R7,0                    subtract 1 for execute
COMPARE2 CLI   0(R4),C' '              check if this byte blank
         BNE   LOOPIT2                 no so set flag off
         LTR   R7,R7                   test remaining length
         BM    ENDLOOP                 negative then finish
         EX    R7,SLIDE_LEFT           slide bytes left
         MVI   0(R3),C' '              blank the last byte
         BCT   R2,COMPARE2             loop to go and test again
         B     ENDLOOP                 branch past execute to end
LOOPIT2  LA    R4,1(,R4)               next byte in field
         BCT   R5,STRTLOO2             loop to check next byte
*
*  trim accomplished
*
ENDLOOP  DS    0H
*
*  now get count of occupied bytes
*
         LR    R4,R3                   point at last byte
         L     R5,4(,R9)               get length
LOOP2    DS    0H
         CLI   0(R4),C' '              is the byte blank
         BNE   ENDLOOP2                no so quit
         BCTR  R4,0                    point to previous byte
         BCT   R5,LOOP2                loop until 0
ENDLOOP2 DS    0H
*        R5 now has the occupied byte count
         ST    R5,4(,R9)               put count in parameter list
*
GO_BACK  LM    R14,R12,12(R13)         restore callers registers
         L     R15,4(,R1)              load occupied byte count
         BR    R14                     return to caller
*
SLIDE_LEFT     MVC   0(0,R4),1(R4)     sliding move instruction
*
         LTORG
         END
./ ADD NAME=TSTMP
         MACRO
         TSTMP &AREA,&LOCAL=N,&FORMAT=DB2
.**********************************************************************
.*
.* Created by John Gateley
.*
.*       This macro uses STCKE to get the time from the system
.*       and then formats it.
.*
.*       &AREA   =  the field to put the timestamp in
.*       &LOCAL  =  N - just get the timestamp
.*                  Y - adjust to local time and leap second
.*       &FORMAT =  DB2  - CL26'2017-04-01-12.34.56.789012'
.*                  CHAR - CL20'20170401123456789012'
.*                  PACK - PL11'020170401123456789012C'
.*
.*       TSTMP WS_TIMESTAMP
.*
         GBLC  &USETSTMP
&USETSTMP      SETC  'Y'
.*
         STCKE #MVCLSAV                store time in PRGDEF field
.*
         AIF   ('&LOCAL' EQ 'Y').YESLOC
         AIF   ('&LOCAL' EQ 'N').NOLOC
         MNOTE 16,' Invalid LOCAL specified'
         MEXIT
.YESLOC  ANOP
*        L     R1,CVTPTR               point to CVT
         L     R1,16
*        L     R1,CVTEXT2-CVT(,R1)     point to extension 2
         L     R1,328(,R1)
*        USING CVTXTNT2,R1
*        LG    R14,CVTLDTO
         LG    R14,56(,R1)             adjust local time
*        SG    R14,CVTLSO
         SG    R14,80(,R1)             adjust leap seconds
*        DROP  R1
         LMG   R0,R1,#MVCLSAV          load STCKE output
         LGR   R15,R14
         SRAG  R14,R14,8
         SLLG  R15,R15,(64-8)
         ALGR  R1,R15
         ALCGR R0,R14
         STMG  R0,R1,#MVCLSAV          save amended STCKE output
.NOLOC   ANOP
.*
.*      STCKCONV STCKEVAL=#MVCLSAV,CONVVAL=#MVCLSAV,TIMETYPE=DEC,     /
         STCKCONV STCKEVAL=#MVCLSAV,CONVVAL=#MVCLSAV,TIMETYPE=DEC,     /
               DATETYPE=YYYYMMDD,MF=(E,MY_PARM)
         MVC   #STRING_WORK(4),#MVCLSAV+8    put in correct order
         MVC   #STRING_WORK+4(6),#MVCLSAV
         MVI   #STRING_WORK+10,X'0F'
.*
         AIF   ('&FORMAT' EQ 'DB2').DODB2
         AIF   ('&FORMAT' EQ 'CHAR').DOCHAR
         AIF   ('&FORMAT' EQ 'PACK').DOPACK
         MNOTE 16,' Invalid FORMAT specified'
         MEXIT
.*
.DOCHAR  ANOP
         MVC   #MVCLSAV(11),#STRING_WORK     copy out of the way
         UNPK  #STRING_WORK(15),#MVCLSAV(8)
         UNPK  #STRING_WORK+14(7),#MVCLSAV+7(4)
         MVC   &AREA.(20),#STRING_WORK
         MEXIT
.*
.DOPACK  ANOP
         SRP   #STRING_WORK(11),64-1,0       shift right 1 digit
         MVC   &AREA.(11),#STRING_WORK
         MEXIT
.*
.DODB2   ANOP
         MVC   #MVCLSAV(11),#STRING_WORK     copy out of the way
         MVI   #STRING_WORK,C' '
         MVC   #STRING_WORK+1(L'#STRING_WORK-1),#STRING_WORK
         MVC   #STRING_WORK(L'##DAT_PAT),##DAT_PAT
         ED    #STRING_WORK(L'##DAT_PAT),#MVCLSAV
         MVC   &AREA.(26),#STRING_WORK+1
.*
         MEND
./ ADD NAME=WHEN
         MACRO
&LAB     WHEN
.*
.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE
.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.
.*
.* THE GENERAL STRUCTURE IS AS FOLLOWS -
.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)
.*      WHEN   OP2REST,OP2REST
.*      WHEN   OP2REST-OP2REST,OP2REST
.*      OTHERWSE
.*    ENDEVAL
.*
.* OPCODE FOR EACH POSSIBLE DEPTH
         GBLC  &OP(16)
.* COMPONENTS OF OPERAND 1 FOR EACH POSSIBLE DEPTH
         GBLC  &OP1(16)
.* OPERAND 2 (REP.TYPE.LENGTH) IF ANY - FOR EACH POSSIBLE DEPTH
         GBLC  &OP2(16)
.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &ON(16)
.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH
         GBLA  &OE(16)
.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)
         GBLA  &OD
.* IMMEDIATE INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OI(16)
.* QUOTES INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OQ(16)
.* STATUS INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OS(16)
.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OELSE(16)
.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH
         GBLB  &OPTN(16)
.*
.* LOCAL WORK FIELDS
         LCLA  &A,&B,&C,&D,&E,&U
         LCLC  &L1,&L2,&L3,&L4,&L5,&L6,&L7
         LCLB  &H,&Z
.*
.IF0     AIF   (T'&LAB EQ 'O').END0
&LAB     EQU   *
.END0    ANOP
.IF0A    AIF   (&OD GT 0).END0A
         MNOTE 16,'OPTION MISSING'
         MEXIT
.END0A   ANOP
.IF1     AIF   (&OD LE 16).END1
         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'
         MEXIT
.END1    ANOP
.* SET EXIT FOR PREVIOUS CODE
         BRU   @D&OD.E&OE(&OD)
.* SET LABEL FOR ENTRY
@D&OD.N&ON(&OD) EQU   *
.* INCREMENT LABEL GENERATION NUMBER
&ON(&OD) SETA  &ON(&OD)+1
.* SET OPTION INDICATOR OFF
&OPTN(&OD) SETB (0)
.IF1AA   AIF   ((&OELSE(&OD)) EQ (0)).END1AA
         MNOTE 16,'OPTELSE PRECEDES OPT'
         MEXIT
.END1AA  ANOP
.* SAVE CURRENT LABEL GENERATION NUMBER FOR USER-CODE LABEL
&U       SETA  &ON(&OD)
.* INCREMENT LABEL GENERATION NUMBER
&ON(&OD) SETA  &ON(&OD)+1
.IF1AB   AIF   ((&OS(&OD)) EQ (0)).END1AB
         MNOTE 16,'OPTION STATEMENT ERROR'
         MEXIT
.END1AB  ANOP
&A       SETA  N'&SYSLIST
.IF1B    AIF   (&A NE 0).END1B
         MNOTE 16,'NO OPT PARAMETERS'
         MEXIT
.END1B   ANOP
&B       SETA  0
.DO1     AIF   (&A EQ &B).NDO1
.* DO FOR EACH PARAMETER OF OPT
&B       SETA  &B+1
&C       SETA  K'&SYSLIST(&B)
.IF2     AIF   ((&OQ(&OD)) EQ (0)).ELS2
         AIF   ('&SYSLIST(&B)'(1,1) NE '''').QMN
         AIF   ('&SYSLIST(&B)'(&C,1) EQ '''').OKQ
.QMN     MNOTE 16,'UNQUOTED OPT PARAMETER'
         MEXIT
.OKQ     AIF   (&C GT 2).END2
         MNOTE 16,'NULL QUOTES OPT PARAMETER'
         MEXIT
.ELS2    AIF   ('&SYSLIST(&B)'(1,1) NE '''').END2
         MNOTE 16,'MISQUOTED OPT PARAMETER'
         MEXIT
.END2    ANOP
.* FIND IF THERE IS A RANGE
&D       SETA  0
&H       SETB  (0)
.DO2     AIF   (&C EQ &D).NDO2
.* DO FOR EACH CHARACTER OF PARAMETER
&D       SETA  &D+1
         AIF   ('&SYSLIST(&B)'(&D,1) NE '-').ADO2
.IF4     AIF   ((&OQ(&OD)) EQ (0)).ELS4
         AIF   ('&SYSLIST(&B)'(&D-1,1) NE '''').ADO2
         AIF   ('&SYSLIST(&B)'(&D+1,1) NE '''').ADO2
         AIF   (&D EQ 2).ADO2
.* HAVE FOUND A HYPHEN (BETWEEN QUOTES BECAUSE QUOTES ARE CURRENT)
&H       SETB  (1)
         AGO   .NDO2
.ELS4    ANOP
.* HAVE FOUND A HYPHEN
&H       SETB  (1)
         AGO   .NDO2
.END4    ANOP
.ADO2    AGO   .DO2
.NDO2    ANOP
&L1      SETC  '&OP(&OD)'
&L2      SETC  '&OP1(&OD)'
&L3      SETC  '&OP2(&OD)'
.*
.* GENERATE LABEL FOR COMPARE CLAUSE IF NOT 1ST AND RANGE NOT PREVIOUS
.IF5     AIF   (&B EQ 1).END5
         AIF   ((&Z) EQ (0)).END5
@D&OD.N&ON(&OD) EQU *
.* INCREMENT LABEL GENERATION COUNT
&ON(&OD) SETA  &ON(&OD)+1
.END5    ANOP
.* GENERATE COMPARE CLAUSE LOGIC
.IF6     AIF   ((&H) EQ (0)).ELS6
.* WHEN A RANGE  &H IS 1 AND &D WILL HOLD HYPHEN OFFSET
&E       SETA  &D-1
&L4      SETC  '&SYSLIST(&B)'(1,&E)
         &L1   &L2,&L3&L4
         JL    @D&OD.N&ON(&OD)
&E       SETA  &C-&D
&L5      SETC  '&SYSLIST(&B)'(&D+1,&E)
         &L1   &L2,&L3&L5
.IF7     AIF   (&B EQ &A).ELS7
.* WHEN NOT LAST CLAUSE GENERATE BRANCH DIRECT TO USER-CODE
         JNH   @D&OD.N&U
         AGO   .END7
.ELS7    ANOP
.* FOR LAST CLAUSE GENERATE BRANCH TO NEXT OPTION
         JH    @D&OD.N&ON(&OD)
.IF7A    AIF   (&A EQ 1).END7A
.* GENERATE USER-CODE ENTRY LABEL WHEN MORE THAN A SINGLE PARAMETER
@D&OD.N&U EQU  *
.END7A   ANOP
.END7    ANOP
&Z       SETB  (1)
         AGO   .END6
.ELS6    ANOP
.* HAVE SIMPLE CLAUSE WITH SINGLE TERM
&L6      SETC  '&SYSLIST(&B)'(1,&C)
         &L1   &L2,&L3&L6
.IF8     AIF   (&B EQ &A).ELS8
.* WHEN NOT LAST CLAUSE GENERATE BRANCH DIRECT TO USER-CODE
         JE    @D&OD.N&U
         AGO   .END8
.ELS8    ANOP
.* FOR LAST CLAUSE GENERATE BRANCH TO NEXT OPTION
         JNE   @D&OD.N&ON(&OD)
.IF9     AIF   (&A EQ 1).END9
.* GENERATE USER-CODE ENTRY LABEL WHEN MORE THAN A SINGLE PARAMETER
@D&OD.N&U EQU  *
.END9    ANOP
.END8    ANOP
&Z       SETB  (0)
.END6    ANOP
.ADO1    AGO   .DO1
.NDO1    ANOP
         MEND
./ ADD NAME=WTOX
           MACRO
           WTOX  &CLEAR=Y
.*
.* Created by John Gateley
.*
.* PRGDEF has space for a reentrant WTO macro and PRGSTAT has the list
.* form which is copied into the reentrant storage at the start of the
.* program. This ensures that the program can execute correctly in
.* a program protected environment.
.*
.* WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY,MF=(E,#ACT_WTO_LIST)
.*
           ST    R2,#MVCLSAV
           LA    1,#ACT_WTO_LIST
           LA    2,#MESS_LEN
           ST    R2,4(0,1)
           LR    14,1
           LH    15,0(1,0)
           AR    14,15
           OI    4(14),B'00000000'
           OI    5(14),B'10000000'
           SVC   35
           L     R2,#MVCLSAV
           AIF   ('&CLEAR' EQ 'N').NOCLR
           MVI   MESS_TEXT,C' '
           MVC   MESS_TEXT+1(L'MESS_TEXT-1),MESS_TEXT
.NOCLR     ANOP
           MEND
./ ADD NAME=XEDIT
         MACRO
         XEDIT &IN,&INL,&OUT,&PAD=' ',&DEC='.',&DECP=0,                /
               &THOU=',',&SIGN=,&MARK=
.**********************************************************************
.*
.* Created by John Gateley
.*
.*  This macro builds an edit pattern and then EDits the data or
.*  if SIGN is specified an EDMK is used.
.*
.*       &IN   location of the packed field
.*       &INL  length of the packed field
.*       &OUT  where to build the edit pattern and put the result
.*
.*       &PAD  value for pad character       ' '
.*       &DEC  value for decimal point       '.'
.*       &DECP number of decimal places
.*       &THOU value for thousand separator  ','
.*       &SIGN value for sign, e.g.  SIGN=-  SIGN='-'  SIGN=' (CR)'
.*       &MARK if set then use EDMK instead of ED and use the provided
.*             value in the pattern, e.g. MARK=$
.*
.*  XEDIT VAL1_PACK,5,(R6)
.*
.*  XEDIT VAL1_PACK,5,(R6),THOU=         for no thousand separator
.*
.*  XEDIT VAL1_PACK,5,MESSTXT+10,DECP=2,MARK=$
.*
.*  XEDIT VAL1_PACK,3,MESSTXT+10,PAD=0,DEC=',',DECP=2,                /
.*              THOU='.',SIGN=' (CR)'
.*  XEDIT VAL2_PACK,4,MESSTXT+10,PAD=' ',DEC='.',DECP=0,              /
.*              THOU=',',MARK=¢
.*
         AIF   ('&OUT'(1,1) EQ '(').REGO1  * value in register
         LA    R14,&OUT                  * address of output string
         AGO   .NOREGO1
.REGO1   ANOP
&OUTR    SETC  '&IN'(2,K'&IN-2)
         LR    R14,&OUTR                 * address of output string
.NOREGO1 ANOP
.*
&CNT     SETA  0                         * set pattern count to 0
&CNTMRK  SETA  0                         * set EDMK offset to 0
&SEL     SETC  '20'                      * set digit selector
&SIG     SETC  '21'                      * set significant digit sel
&PATN    SETC  ''                        * start with empty pattern
         AIF   ('&PAD' EQ '').NOPAD
         AIF   ('&PAD'(1,1) EQ '''').QUOT1  * value in quotes
&MPAD    SETC  '&PAD'
         AGO   .QUOT1A
.QUOT1   ANOP
&MPAD    SETC  '&PAD'(2,K'&PAD-2)
.QUOT1A  ANOP
&MPAD    SETC  C2X('&MPAD')              * convert to hex
&PATN    SETC  '&PATN&MPAD'              * put in pad character
&MYLEN   SETA  K'&MPAD/2                 * get length of pad
         AIF   (&MYLEN NE 1).MERR1       * can only be one
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
.NOPAD   ANOP
.*
&LENR    SETA  &INL                      * get input length
&LENR    SETA  &LENR*2                   * multiply by 2
&LENR    SETA  &LENR-1                   * subtract 1 gives no. digits
&LENR    SETA  &LENR-&DECP               * subtract number of decimals
.*
.AGAIN   ANOP
         AIF   (&LENR EQ 2).IS2
&PATN    SETC  '&PATN&SEL'               * put in digit select
         AGO   .NOT2
.IS2     ANOP
&PATN    SETC  '&PATN&SIG'               * put in significant digit
&CNTMRK  SETA  &CNT+1                    * set significant offset
.NOT2    ANOP
&CNT     SETA  &CNT+1                    * add to count in pattern
&LENR    SETA  &LENR-1                   * subtract 1 from remaining
         AIF   (&LENR EQ 0).NOAGIN
&LENT    SETA  (&LENR/3)*3               * divide by 3 and multiply
.*
         AIF   ('&THOU' EQ '').NOTHOU    * no thousand separator
         AIF   (&LENT NE &LENR).NOTHOU   * not multiple of 3 left
         AIF   ('&THOU'(1,1) EQ '''').QUOT2  * value in quotes
&MTHOU   SETC  '&THOU'
         AGO   .QUOT2A
.QUOT2   ANOP
&MTHOU   SETC  '&THOU'(2,K'&THOU-2)
.QUOT2A  ANOP
&MTHOU   SETC  C2X('&MTHOU')             * convert to hex
&PATN    SETC  '&PATN&MTHOU'             * put in thousand separator
&MYLEN   SETA  K'&MTHOU/2                * get length of thou separator
         AIF   (&MYLEN NE 1).MERR2       * can only be one
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
.NOTHOU  ANOP
         AIF   (&LENR GT 0).AGAIN        * anything remaining - repeat
.*
.NOAGIN  ANOP
.*
.* so now we have run out of digits before the decimal place (if any)
.*
         AIF   (&DECP EQ 0).TRYSGN       * if none try sign
         AIF   ('&DEC' EQ '').TRYSGN      * value in quotes
         AIF   ('&DEC'(1,1) EQ '''').QUOT3  * value in quotes
&MDEC    SETC  '&DEC'
         AGO   .QUOT3A
.QUOT3   ANOP
&MDEC    SETC  '&DEC'(2,K'&DEC-2)
.QUOT3A  ANOP
&MDEC    SETC  C2X('&MDEC')              * convert to hex
&PATN    SETC  '&PATN&MDEC'              * put in decimal separator
&MYLEN   SETA  K'&MDEC/2                 * get length of dec separator
         AIF   (&MYLEN NE 1).MERR3       * can only be one
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
&LEND    SETA  &DECP                     * copy decimal places
.*
.TRYDEC  ANOP
&PATN    SETC  '&PATN&SEL'               * put in digit select
&CNT     SETA  &CNT+1                    * add to count in pattern
&LEND    SETA  &LEND-1                   * reduce decimal place count
         AIF   (&LEND NE 0).TRYDEC       * places remaining - so loop
.*
.TRYSGN  ANOP
         AIF   ('&SIGN' EQ '').NOSIGN    * sign byte required
         AIF   ('&SIGN'(1,1) EQ '''').QUOT9  * value in quotes
&MSIGN   SETC  '&SIGN'
         AGO   .QUOT9A
.QUOT9   ANOP
&MSIGN   SETC  '&SIGN'(2,K'&SIGN-2)
.QUOT9A  ANOP
&MSIGN   SETC  C2X('&MSIGN')             * convert to hex
&PATN    SETC  '&PATN.&MSIGN'            * put in sign value
&MYLEN   SETA  K'&MSIGN/2                * get length of record area
&CNT     SETA  &CNT+&MYLEN               * add to count in pattern
.NOSIGN  ANOP
.*
         MVC   0(&CNT,R14),=X'&PATN'     * copy pattern to output
         AIF   ('&MARK' NE '').DOMARK
         ED    0(&CNT,R14),&IN           * edit value to output
         MEXIT
.DOMARK  ANOP
         LA    R1,&CNTMRK.(,R14)         * set R1 for EDMK
         EDMK  0(&CNT,R14),&IN           * edit mark value to output
         BCTR  R1,0                      * back of one byte
         MVI   0(R1),C'&MARK'            * put in currency sign
.*
         MEXIT
.MERR1   MNOTE 16,'Pad character can only be 1 byte'
         MEXIT
.MERR2   MNOTE 16,'Thousand separator can only be 1 byte'
         MEXIT
.MERR3   MNOTE 16,'Decimal separator can only be 1 byte'
         MEND
./ ADD NAME=XPACK
         MACRO
         XPACK &IN,&INL,&OUT
.**********************************************************************
.*
.* Created by John Gateley
.*
.*       This macro packs character hexadecimal data into a string.
.*       so C'C1F16D' becomes X'C1F16D' or C'A1_'
.*
.*       In the above example
.*       XPACK =C'C1F16D',6,OUT_TXT
.*
.*       Alternatively omit length and L'=C'C1F16D' will be used
.*       XPACK =C'C1F16D',,OUT_TXT
.*
.*       If the input length is of the form L'AAA then it cannot be
.*       checked here, but if it is not then see if even.
.*
.*
.* indicate that XPACK macro was used so that the table can be
.* defined in PRGESTAT
.*
         GBLC  &HEXPCK
&HEXPCK  SETC  'Y'
.*
         AIF   (T'&INL EQ 'O').NOCHK     * parameter missing
         AIF   ('&INL'(1,2) EQ 'L''').NOCHK
&A       SETA  &INL                      * copy length
&B       SETA  &A/2                      * divide by 2
&C       SETA  &B*2                      * multiply by 2
         AIF   (&A NE &C).NOTEVEN        * not equal means not even
.*
.NOCHK   ANOP
         LA    R14,&IN                   * address of input string
         AIF   (T'&INL NE 'O').USELEN    * parameter missing
         LA    R15,L'&IN                 * use the implied length
         AGO   .NOLEN
.*
.USELEN  ANOP
         LA    R15,&INL                  * length of input string
.NOLEN   ANOP
         LA    R1,&OUT                   * address of output area
B#&SYSNDX      DS    0H
         MVC   HEXPACK_W3(2),0(R14)      * copy two bytes
         TR    HEXPACK_W3(2),HEXPACK_TABLE-C'A' * Convert to packable
         PACK  HEXPACK_W2,HEXPACK_W3     * pack it
         MVC   0(1,R1),HEXPACK_W2        * output one byte
         LA    R14,2(R14)                * next in input
         LA    R1,1(R1)                  * next in output
         AHI   R15,-2                    * subtract the 2 processed
         BP    B#&SYSNDX                 * positive then go again
         MEXIT
.NOTEVEN MNOTE 16,'Length specified is not multiple of 2'
         MEND
./ ADD NAME=XUNPK
         MACRO
         XUNPK &IN,&INL,&OUT
.**********************************************************************
.*
.* Created by John Gateley
.*
.*       This macro unpacks character data into hexadecimal format.
.*       so X'C1F16D' or C'A1_' becomes C'C1F16D'
.*
.*       In the above example
.*       XUNPK =X'C1F16D',3,OUT_TXT
.*
.*       XUNPK FIELDA,,OUT_TXT          generates L'FIELDA for length
.*
.*
.* indicate that XUNPK macro was used so that the table can be
.* defined in PRGESTAT
.*
         GBLC  &XUNPCK
&XUNPCK  SETC  'Y'
.*
         AIF   ('&IN'(1,1) EQ '(').REGVAL   * value in register
         LA    R14,&IN                   * address of input string
         AGO   .NOTREG
.REGVAL  ANOP
&INR     SETC  '&IN'(2,K'&IN-2)
         ST    &INR,LEN_SAY              * this exists in PRGDEF
         LA    R14,LEN_SAY               * address of input string
         LA    R15,4                     * it is 4 bytes
         AGO   .LENDON
.*
.NOTREG  ANOP
         AIF   (T'&INL EQ 'O').NOLEN     * parameter missing
         LA    R15,&INL                  * length of input string
         AGO   .LENDON
.NOLEN   ANOP
         LA    R15,L'&IN
.*
.LENDON  ANOP
         LA    R1,&OUT                   * address of output area
B#&SYSNDX      DS    0H
         MVC   HEXPACK_W2(1),0(R14)      * copy one byte
         UNPK  HEXPACK_W3,HEXPACK_W2     * UNPK two bytes to three
         TR    HEXPACK_W3(2),XUNPACK_TAB-240 * convert to displayable
         MVC   0(2,R1),HEXPACK_W3        * copy to receiver
         LA    R14,1(,R14)               * next in input
         LA    R1,2(,R1)                 * next in output
         BCT   R15,B#&SYSNDX             * subtract and branch
         MEND
