{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013555000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1469650, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 15, "INMDSNAM": "CBT.V500.FILE953.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1469650, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1469650, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE953.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x18\\x08'", "DS1TRBAL": "b']<'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xeb\\x00\\r\\t\\xed\\x00\\x07\\x00\\x19'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x12\\x01 4O\\x01 4O\\x11V\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-09T00:00:00", "modifydate": "2020-12-09T11:56:12", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  953\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE953\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 57 MEMBERS COUNTED; CUMULATIVE SIZE IS 13,279 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/09/20    11:56:12    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PDSLOAD": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00\\x18\\x01\\x026_\\x01\\x17\\x05? '\\x00#\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2017-02-22T20:27:18", "lines": 35, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*    PDSLOAD JOB TO CREATE GATELEY MACLIB\n//*\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT496.FILE953(PDSLOAD)')\n   DSN('SBGOLOB.GATELEY.LOAD')  VOL(WORKA2)\n/*\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT496.FILE953',      <=== CHANGE\n//             OPRE=SBGOLOB,\n//             QUAL=GATELEY,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=DATA04,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.GATELEY.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=MACLIB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE953": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x06\\x01 4O\\x01 4O\\x11V\\x00\\xab\\x00\\xab\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-09T00:00:00", "modifydate": "2020-12-09T11:56:06", "lines": 171, "newlines": 171, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 953 is from John Gateley and contains several of his      *   FILE 953\n//*           programs, with his macro library, which could be of   *   FILE 953\n//*           much use in itself.  The macro library is in PDSLOAD  *   FILE 953\n//*           (like IEBUPDTE) format, but PDSLOAD preserves ISPF    *   FILE 953\n//*           statistics.  A copy of PDSLOAD and JCL to create      *   FILE 953\n//*           the macro library are included in this pds.           *   FILE 953\n//*                                                                 *   FILE 953\n//*           email:  jrg.spurtle@outlook.com                       *   FILE 953\n//*                                                                 *   FILE 953\n//*       MACRO LIB:   Generated by the $PDSLOAD job from the       *   FILE 953\n//*                    member MACLIB.                               *   FILE 953\n//*                                                                 *   FILE 953\n//*       PROGRAMS :                                                *   FILE 953\n//*                                                                 *   FILE 953\n//*         BRWSPOOL - A batch program that runs as the last step   *   FILE 953\n//*                    in a jobstream and reads JESYSMSG for        *   FILE 953\n//*                    the job it is running in.                    *   FILE 953\n//*                    It finds the messages about return code and  *   FILE 953\n//*                    start and end time and produces a summary    *   FILE 953\n//*                    of the return codes.                         *   FILE 953\n//*                                                                 *   FILE 953\n//*         LISTAPF  - A batch program to determine which of        *   FILE 953\n//*                    your libraries in a STEPLIB or JOBLIB        *   FILE 953\n//*                    IS NOT APF-authorized.  In other words,      *   FILE 953\n//*                    you want to find out which library or        *   FILE 953\n//*                    libraries in a concatenation, is spoiling    *   FILE 953\n//*                    the concatenation's APF authorization.       *   FILE 953\n//*                    Copes with situations where there are two    *   FILE 953\n//*                    versions of an dataset one catalogued and    *   FILE 953\n//*                    the other not in catalog. It can be that     *   FILE 953\n//*                    the authorised dataset is not the catalogued *   FILE 953\n//*                    one that is in the JCL.                      *   FILE 953\n//*                                                                 *   FILE 953\n//*         JRGULOAD - Unloads a PDS to a sequential file with      *   FILE 953\n//*                    IEBUPDTE like control cards. A hex constant  *   FILE 953\n//*                    of x'FACE' is put after the member name in   *   FILE 953\n//*                    control card so that it can be used to       *   FILE 953\n//*                    unload members which contain IEBUPDTE        *   FILE 953\n//*                    control cards. Any statistics follow the     *   FILE 953\n//*                    constant.                                    *   FILE 953\n//*                    RECFM can be VB or FB any LRECL <= 1000.     *   FILE 953\n//*                    PGM=JRGULOAD,PARM=NOSTATS can be used.       *   FILE 953\n//*                                                                 *   FILE 953\n//*         JRGUPDTE - Loads a file to a new PDS using the output   *   FILE 953\n//*                    from JRGULOAD. If statistics are present     *   FILE 953\n//*                    they are stowed in the PDS directory.        *   FILE 953\n//*                    The program checks for the hex constant      *   FILE 953\n//*                    output by JRGULOAD to decide if the          *   FILE 953\n//*                    './ ADD NAME=' card came from that program   *   FILE 953\n//*                    or the data. Code PARM='NOFACE' to           *   FILE 953\n//*                    disable this processing'                     *   FILE 953\n//*                                                                 *   FILE 953\n//*         CNTRECS  - A batch program that counts the records in   *   FILE 953\n//*                    all datasets concatenated to SYSIN and       *   FILE 953\n//*                    outputs a report in SYSOUT like this         *   FILE 953\n//*                                                                 *   FILE 953\n//*    86  SDJRG.ASM(###DOC##)                                      *   FILE 953\n//*     0  SDJRG.JCL(EMPTY)                                         *   FILE 953\n//*     0  IBMUSER.BIG.LONG.DATASET.NAME.HOW.ABOUT.THIS(EMPTY)      *   FILE 953\n//*     5  IBMUSER.BIG.LONG.DATASET.NAME.HOW.ABOUT.THIS(NOTEMPTY)   *   FILE 953\n//*   386  SDJRG.ASM(CNTRECS)                                       *   FILE 953\n//*     3  /u/sdjrg/some.txt                                        *   FILE 953\n//*   181  SDJRG.ASM(SPRSDISP)                                      *   FILE 953\n//*                                                                 *   FILE 953\n//*   661                                                           *   FILE 953\n//*                                                                 *   FILE 953\n//*         CHECKAPF - A rexx program which does a similar job to   *   FILE 953\n//*                    LISTAPF but as it is in rexx you must        *   FILE 953\n//*                    supply the list of datasets as it does not   *   FILE 953\n//*                    have access to JOBLIB or STEPLIB.            *   FILE 953\n//*                                                                 *   FILE 953\n//*         GETCNCAT - subroutine to populate an array with the     *   FILE 953\n//*                    dataset names (and members) concatanated     *   FILE 953\n//*                    to a DDNAME. TRYCNCAT is a COBOL example.    *   FILE 953\n//*                    If the UNIX PATH= is used to concatanate     *   FILE 953\n//*                    a UNIX file it will be handled.              *   FILE 953\n//*                                                                 *   FILE 953\n//*         GETDSNAM - REXX function to get concatanated            *   FILE 953\n//*                    DSNAME(s) for a DDNAME. Assembler code.      *   FILE 953\n//*                    This handles UNIX path names.                *   FILE 953\n//*                    See TRYGDSN                                  *   FILE 953\n//*                                                                 *   FILE 953\n//*         CHKAUTH  - REXX function to check if the user is        *   FILE 953\n//*                    authorised to access a dataset.              *   FILE 953\n//*                    Find if you are authorised before attempting *   FILE 953\n//*                    to browse the dataset. Information security  *   FILE 953\n//*                    will never know. Assembler code.             *   FILE 953\n//*                    See TRYAUTH                                  *   FILE 953\n//*                                                                 *   FILE 953\n//*         PIPECNT  - Reads a delimited file and finds the longest *   FILE 953\n//*                    value in each field.                         *   FILE 953\n//*                    Delimiter can be specified on PARM.          *   FILE 953\n//*                    Outputs a brief summary of the file.         *   FILE 953\n//*                                                                 *   FILE 953\n//*         PIPESET  - Reads a delimited file and the output from   *   FILE 953\n//*                    PIPECNT and produces a new fiel where all    *   FILE 953\n//*                    the field are fixed length, can also create  *   FILE 953\n//*                    Assembler and COBOL copybooks.               *   FILE 953\n//*                                                                 *   FILE 953\n//*         STRINGIT - Assembler program needed by the STRING       *   FILE 953\n//*                    macro (in the MACRO library).                *   FILE 953\n//*                                                                 *   FILE 953\n//*         STEMSORT - REXX function to sort a STEM variable        *   FILE 953\n//*         STEMSR15 - E15 exit which is part of STEMSORT           *   FILE 953\n//*         STEMSR35 - E35 exit which is part of STEMSORT           *   FILE 953\n//*                    Assembler code.                              *   FILE 953\n//*                    See TRYSTEM                                  *   FILE 953\n//*                                                                 *   FILE 953\n//*         PROCSTEM - module to handle stem variable manipulation  *   FILE 953\n//*                    this is used in STEMSORT and GETDSNAM        *   FILE 953\n//*                                                                 *   FILE 953\n//*         DODYNPRC - module to DYNALLOC a dataset                 *   FILE 953\n//*                    this is used in STEMSORT                     *   FILE 953\n//*                                                                 *   FILE 953\n//*         TRIMIT   - Assembler program needed by the TRIM         *   FILE 953\n//*                    macro (in the MACRO library).                *   FILE 953\n//*                                                                 *   FILE 953\n//*         TRYGDSN  - REXX example program that uses GETDSNAM to   *   FILE 953\n//*                    get and output concatenated dataset details. *   FILE 953\n//*                                                                 *   FILE 953\n//*         TRYAUTH  - REXX example program that uses CHKAUTH to    *   FILE 953\n//*                    check if authorised for dataset.             *   FILE 953\n//*                                                                 *   FILE 953\n//*         TRYCNCAT - COBOL example program to call GETCNCAT       *   FILE 953\n//*                                                                 *   FILE 953\n//*         TRYSTEM  - REXX example program that uses STEMSORT to   *   FILE 953\n//*                    sort a stem.                                 *   FILE 953\n//*                                                                 *   FILE 953\n//*         TRYVOL   - REXX example program that uses VOLUMESR to   *   FILE 953\n//*                    populate a stem with volume details'         *   FILE 953\n//*                                                                 *   FILE 953\n//*         E35DROP  - An E35 exit for the system sort that gives   *   FILE 953\n//*                    more control. (Can be used as E15 as well.)  *   FILE 953\n//*                    If you have multiple records in a file that  *   FILE 953\n//*                    have different timestamp then sort on value  *   FILE 953\n//*                    then timestamp descending, the exit will     *   FILE 953\n//*                    tell the SORT to ignore records which have   *   FILE 953\n//*                    the same key as one that has already been    *   FILE 953\n//*                    output.                                      *   FILE 953\n//*                                                                 *   FILE 953\n//*         E35TABL  - An E35 exit for the system sort that gives   *   FILE 953\n//*                    more control. (Can be used as E15 as well.)  *   FILE 953\n//*                    If you have multiple IF conditions that you  *   FILE 953\n//*                    wish to use for a field in a file, but do    *   FILE 953\n//*                    not want to code them all then just put      *   FILE 953\n//*                    them in the TABLIN file and code a compare   *   FILE 953\n//*                    for the exit. The exit will tell the SORT    *   FILE 953\n//*                    to ignore records that either do or do not   *   FILE 953\n//*                    match.  This has been tested with 10,000     *   FILE 953\n//*                    values but it could handle much more.        *   FILE 953\n//*                                                                 *   FILE 953\n//*         SUBNEXT  - This is a VERY basic schedule system that    *   FILE 953\n//*         SUBNEXT1   reads a PDS member (the schedule) and        *   FILE 953\n//*                    submits the first named job. An extra step   *   FILE 953\n//*                    is added to the job which contains a list    *   FILE 953\n//*                    of subsequent jobs to be run if the first    *   FILE 953\n//*                    job runs successfully.                       *   FILE 953\n//*                                                                 *   FILE 953\n//*         VOLUMES  - Assembler program that uses UCBSCAN to get   *   FILE 953\n//*                    all on-line DASD volumes and report          *   FILE 953\n//*                    total space, used space, free space          *   FILE 953\n//*                    and percentage free.                         *   FILE 953\n//*                                                                 *   FILE 953\n//*         VOLUMESR - A version of VOLUMES that works as a REXX    *   FILE 953\n//*                    function to populate a STEM variable         *   FILE 953\n//*                    Uses PROCSTEM                                *   FILE 953\n//*                    See  TRYVOL                                  *   FILE 953\n//*                                                                 *   FILE 953\n//*         VOLUMESX - A version of VOLUMES that does not use       *   FILE 953\n//*                    my structured programming macros             *   FILE 953\n//*                                                                 *   FILE 953\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BRWSPOOL": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x183\\x0f\\x01\\x183\\x0f\\x17\\x15\\x01\\xf7\\x01\\xf7\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-11-26T00:00:00", "modifydate": "2018-11-26T17:15:12", "lines": 503, "newlines": 503, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'BRWSPOOL - OUTPUT JOB SUMMARY OF CONDITION CODES'\n PRINT GEN\n*______________________________________________________________________\n*\n* This module reads JESYSMSG for the job it is running in and finds\n* the step condition codes for all previous steps and then\n* outputs them in a nice box.\n* This should be the last step in the job so it can report on\n* all preceding steps. It does not report on itself as it\n* has not yet finished.\n*______________________________________________________________________\n*\nBRWSPOOL PRGDEF FSEG=MAIN_PART,RMODE=24\n*\nIN_REC         DS    CL256\nT_STAMP        DS    CL14\nSTEP_NAME      DS    CL8\nPROC_NAME      DS    CL8\nCOND_CODE      DS    CL9\nCPU_TIME       DS    CL8\nIEF032I_MESS_A DS    CL80\nIEF032I_MESS_B DS    CL80\nIEF142I_MESS   DS    CL80\nIEF374I_MESS   DS    CL80\nE_O_F          DS    C\n*\n         PRGEDEF\n         USING IHADCB,SYSIN            map DCBD over SYSIN\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   SEGDO DYNALLOC_JESYSMSG\n*\n   MVI   MESS_TXT,C'+'\n   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT\n   SEGDO WRITE_LOG\n   MVC   MESS_TXT+2(12),=C'JOB  SUMMARY'\n   MVC   MESS_TXT+22(12),=C'JOB  SUMMARY'\n   MVC   MESS_TXT+42(12),=C'JOB  SUMMARY'\n   SEGDO WRITE_LOG\n   MVI   MESS_TXT,C'+'\n   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT\n   SEGDO WRITE_LOG\n*\n   SEGDO OPEN_SYSIN\n*\n   DO INF\n     SEGDO GET_SYSIN\n   DOEXIT (CLI,E_O_F,EQ,C'Y')\n     SEGDO PROCESS_RECORD\n   ENDDO\n*\n   SEGDO CLOSE_SYSIN\n*\n   MVI   MESS_TXT,C'+'\n   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT\n   SEGDO WRITE_LOG\n   MVC   MESS_TXT+2(12),=C'SUMMARY  END'\n   MVC   MESS_TXT+22(12),=C'SUMMARY  END'\n   MVC   MESS_TXT+42(12),=C'SUMMARY  END'\n   SEGDO WRITE_LOG\n   MVI   MESS_TXT,C'+'\n   MVC   MESS_TXT+1(L'MESS_TXT-21),MESS_TXT\n   SEGDO WRITE_LOG\n*\n   SEGDO RELEASE_JESYSMSG\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS DYNALLOC_JESYSMSG\n*\n*    names of temporary dataset in JES are:-\n*\n*    useridi#.jobname#.JOBnnnnn.Dnnnnnnn.?\n*    a.b.JOBnnnnn.Dnnnnnnn.?\n*\n*    userid and jobname can be 1 to 8 characters (as of z/OS 2.3)\n*    so find the third '.' and add JESYSMSG to the end\n*\n   RDJFCB SYSOUT\n   MVC   KEYADSN(28),JFCBDSNM          more than enough to work with\n   LA    R14,KEYADSN                   point to DSN\n   LA    R15,L'KEYADSN                 get length\n   XR    R1,R1                         clear '.' counter\n   DO FROM=(R15)\n   DOEXIT (CHI,R1,EQ,3)                quit when counter is 3\n     IF (CLI,0(R14),EQ,C'.')\n       LA    R1,1(,R1)                 increment counter\n     ENDIF\n     LA    R14,1(,R14)\n   ENDDO\n   IF (LTR,R15,R15,Z)                  did not find three '.'\n     MVC   MESS_TXT(14),=CL14'PARSING FAILED'\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16\n   ENDIF\n   MVC   0(17,R14),=CL17'JESYSMSG'     tack JESYSMSG on the end\n*\n   USING S99RBP,R4               make S99RBP DSECT addressible\n   USING S99RB,R3                make RB DSECT addressible\n   L     R4,STORADR\n   LA    R3,S99RBPTR+4           point 4 bytes after S99RBPTR\n   ST    R3,S99RBPTR             make 'RBPTR' point to RB\n   OI    S99RBPTR,S99RBPND       set high-order bit on in RBPTR\n   XC    S99RB(RBLEN),S99RB      zeroise complete 'RB'\n   MVI   S99RBLN,RBLEN           put length of RB in length field\n   MVC   S99ERROR,=H'0'\n   MVC   S99INFO,=H'0'\n   LA    R2,24(R4)               start of text address pointers\n   ST    R2,S99TXTPP\n   MVI   S99VERB,S99VRBAL        set allocate verb\n   XR    R1,R1                   clear R1 prior to access\n   EPAR  R1                      go get ASID\n   STH   R1,BTOKASID\n   LA    R1,KEYA\n   ST    R1,0(R2)                store key address\n   LA    R1,KEYADS\n   ST    R1,4(R2)                store key address\n   LA    R1,KEYADISP\n   ST    R1,8(R2)                store key address\n   LA    R1,KEYSSID\n   ST    R1,12(R2)               store key address\n   LA    R1,KEYTOKEN\n   ST    R1,16(R2)               store key address\n   OI    16(R2),X'80'            indicate end of address list\n   L     R1,STORADR              set R1 to addr. of RB pointer\n   DYNALLOC\n\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(14),=CL14'DYNALLOC   RC='\n     XUNPK (R15),4,MESS_TXT+14\n     XUNPK S99ERROR,2,MESS_TXT+24\n     XUNPK S99ERROR,2,MESS_TXT+30\n     SEGDO WRITE_LOG\n     MVC   MESS_TXT(8),KEYADDNM\n     MVC   MESS_TXT+10(44),KEYADSN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16\n   ENDIF\n   DROP  R4\n   DROP  R3\n*\n SEGE DYNALLOC_JESYSMSG\n*______________________________________________________________________\n*\n SEGS RELEASE_JESYSMSG\n*\n   USING S99RBP,R4               make S99RBP dsect addressible\n   USING S99RB,R3                make RB dsect addressible\n   L     R4,STORADR\n   LA    R3,S99RBPTR+4           point 4 bytes after s99rbptr\n   ST    R3,S99RBPTR             make 'RBPTR' point to RB\n   OI    S99RBPTR,S99RBPND       set on high-order bit in RBPTR\n   XC    S99RB(RBLEN),S99RB      zeroise complete 'RB'\n   MVI   S99RBLN,RBLEN           put length of RB in length field\n   MVC   S99ERROR,=H'0'\n   MVC   S99INFO,=H'0'\n   LA    R2,24(R4)               start of text address pointers\n   ST    R2,S99TXTPP\n   MVI   S99VERB,S99VRBUN        set un-allocate verb\n   LA    R1,KEYA\n   ST    R1,0(R2)                store key address\n   LA    R1,KEYADS\n   ST    R1,4(R2)                store key address\n   OI    4(R2),X'80'             indicate end of address list\n   L     R1,STORADR              set R1 to addr. of RB pointer\n   DYNALLOC\n\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(14),=CL14'UN-ALLOC   RC='\n     XUNPK (R15),4,MESS_TXT+14\n     XUNPK S99ERROR,2,MESS_TXT+24\n     XUNPK S99ERROR,2,MESS_TXT+30\n     SEGDO WRITE_LOG\n     MVC   MESS_TXT(8),KEYADDNM\n     MVC   MESS_TXT+10(44),KEYADSN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16\n   ENDIF\n   DROP  R4\n   DROP  R3\n*\n SEGE RELEASE_JESYSMSG\n*______________________________________________________________________\n*\n SEGS PROCESS_RECORD\n*\n*  it seems that IEF142I is always there but sometimes IEF374I is\n*  present and sometimes IEF032I which is in multiple lines,\n*  so cope with either\n*\n   IF (CLC,=C'IEF142I',EQ,IN_REC+1)\n     MVC   IEF142I_MESS(60),IN_REC+9\n   ELSEIF (CLC,=C'IEF374I',EQ,IN_REC+1)\n     MVC   IEF374I_MESS(60),IN_REC+9\n     IF (CLC,IEF142I_MESS,GT,SPACES)\n       SEGDO FORMAT_OUTPUT\n     ENDIF\n     MVC   IEF142I_MESS,SPACES\n     MVC   IEF374I_MESS,SPACES\n   ELSEIF (CLC,=C'IEF032I',EQ,IN_REC+1)\n     MVC   IEF032I_MESS_A(60),IN_REC+9\n   ELSEIF (CLC,IEF032I_MESS_A,GT,SPACES)\n     MVC   IEF032I_MESS_B(60),IN_REC+9\n     IF (CLC,IEF142I_MESS,GT,SPACES)\n       SEGDO FORMAT_OUTPUT\n     ENDIF\n     MVC   IEF142I_MESS,SPACES\n     MVC   IEF032I_MESS_A,SPACES\n     MVC   IEF032I_MESS_B,SPACES\n   ENDIF\n*\n SEGE PROCESS_RECORD\n*______________________________________________________________________\n*\n SEGS FORMAT_OUTPUT\n*\n   LA    R4,IEF142I_MESS\n   LA    R5,60\n   SEGDO FIND_BLANK\n   IF (LTR,R5,R5,Z)\n     MVC   MESS_TXT(20),=CL20'FAILED 1'\n     SEGDO WRITE_LOG\n     SEGQUIT\n   ENDIF\n   LA    R4,1(,R4)\n   LA    R8,0(,R4)\n   SEGDO FIND_BLANK\n   IF (LTR,R5,R5,Z)\n     MVC   MESS_TXT(20),=CL20'FAILED 2'\n     SEGDO WRITE_LOG\n     SEGQUIT\n   ENDIF\n   LR    R1,R4\n   SR    R1,R8\n   BCTR  R1,0\n   EX    R1,MVC_STEPNAME\n   LA    R4,1(,R4)\n   LA    R8,0(,R4)\n   IF (CLI,0(R8),NE,C'-')\n     SEGDO FIND_BLANK\n     IF (LTR,R5,R5,Z)\n       MVC   MESS_TXT(20),=CL20'FAILED 3'\n       SEGDO WRITE_LOG\n       SEGQUIT\n     ENDIF\n     LR    R1,R4\n     SR    R1,R8\n     BCTR  R1,0\n     EX    R1,MVC_PROCNAME\n   ENDIF\n   SEGDO FIND_COND_CODE\n   IF (LTR,R5,R5,Z)\n     MVC   MESS_TXT(20),=CL20'FAILED 4'\n     SEGDO WRITE_LOG\n     SEGQUIT\n   ENDIF\n   LA    R4,10(,R4)                    point after 'COND CODE '\n   MVC   COND_CODE(4),=C'Cond'         insert only 'Cond'\n   MVC   COND_CODE+5(4),0(R4)          copy value\n   IF (CLC,=C'0000',EQ,COND_CODE+5)    if 0000\n     MVC   COND_CODE+5(3),=C'---'      make it easier to see\n   ELSEIF (CLC,=C'0004',EQ,COND_CODE+5) if 0004\n     MVC   COND_CODE+5(2),=C'---'      make it easier to see\n   ELSEIF (CLC,=C'0008',EQ,COND_CODE+5) if 0008\n     MVI   COND_CODE+5,C'-'            make it easier to see\n   ENDIF\n*\n   IF (CLC,IEF374I_MESS,GT,SPACES)\n     MVC   T_STAMP(4),IEF374I_MESS+20\n     MVI   T_STAMP+4,C'.'\n     MVC   T_STAMP+5(6),IEF374I_MESS+24\n     MVI   T_STAMP+8,C' '\n     MVI   T_STAMP+11,C':'\n     MVC   T_STAMP+12(2),IEF374I_MESS+30\n     MVC   CPU_TIME(2),IEF374I_MESS+39\n     MVI   CPU_TIME+2,C':'\n     MVC   CPU_TIME+3(5),IEF374I_MESS+45\n   ELSE\n     MVC   T_STAMP(4),IEF032I_MESS_A+20\n     MVI   T_STAMP+4,C'.'\n     MVC   T_STAMP+5(6),IEF032I_MESS_A+24\n     MVI   T_STAMP+8,C' '\n     MVI   T_STAMP+11,C':'\n     MVC   T_STAMP+12(2),IEF032I_MESS_A+30\n     MVC   CPU_TIME(2),IEF032I_MESS_B+15\n     MVI   CPU_TIME+2,C':'\n     MVC   CPU_TIME+3(5),IEF032I_MESS_B+23\n     IF (CLI,CPU_TIME,EQ,C'0')\n       MVI   CPU_TIME,C' '\n     ENDIF\n   ENDIF\n*\n   IF (CLC,PROC_NAME,GT,SPACES)\n     MVC   MESS_TXT+1(8),PROC_NAME\n     MVC   MESS_TXT+11(8),STEP_NAME\n   ELSE\n     MVC   MESS_TXT+1(8),STEP_NAME\n   ENDIF\n   MVC   MESS_TXT+21(L'COND_CODE),COND_CODE\n   MVC   MESS_TXT+33(L'CPU_TIME),CPU_TIME\n   MVC   MESS_TXT+44(L'T_STAMP),T_STAMP\n   SEGDO WRITE_LOG\n   MVC   STEP_NAME,SPACES\n   MVC   PROC_NAME,SPACES\n*\n SEGE FORMAT_OUTPUT\n*______________________________________________________________________\n*\n SEGS FIND_BLANK\n*\n   IF (LTR,R5,R5,NZ)\n     DO FROM=(R5)\n     DOEXIT (CLI,0(R4),EQ,C' ')\n       LA    R4,1(,R4)\n     ENDDO\n   ENDIF\n*\n SEGE FIND_BLANK\n*______________________________________________________________________\n*\n SEGS FIND_CHAR\n*\n   IF (LTR,R5,R5,NZ)\n     DO FROM=(R5)\n     DOEXIT (CLI,0(R4),EQ,C' ')\n       LA    R4,1(,R4)\n     ENDDO\n   ENDIF\n*\n SEGE FIND_CHAR\n*______________________________________________________________________\n*\n SEGS FIND_COND_CODE\n*\n   IF (LTR,R5,R5,NZ)\n     DO FROM=(R5)\n     DOEXIT (CLC,=C'COND CODE',EQ,0(R4))\n       LA    R4,1(,R4)\n     ENDDO\n   ENDIF\n*\n SEGE FIND_COND_CODE\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n PRGDCBI DCB=SYSIN,EOF=E_O_F,V2F=IN_REC\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nSPACES   DC    CL80' '\nMVC_STEPNAME   MVC   STEP_NAME(0),0(R8)\nMVC_PROCNAME   MVC   PROC_NAME(0),0(R8)\nDYNA_THIS_DATASET    DC    CL44' '\n*\nSYSIN    DCB   DSORG=PS,DDNAME=BRWSPDCB,MACRF=(GL),EODAD=END_SYSIN\n*\n*  SYSOUT is defined only for RDJFCB to get userid, jobname and jobid\n*  so it should be in the JCL as SYSOUT=*\n*\nSYSOUT   DCB   DSORG=PS,DDNAME=SYSOUT,MACRF=(PM),RECFM=FB,LRECL=80,    /\n               EXLST=LIST1\nLIST1    DS    0F\n         DC    X'87',AL3(MY_JFCB)\n         PUSH  PRINT,NOPRINT\n         PRINT NOGEN\nMY_JFCB  DS    0F\n         IEFJFCBN LIST=NO\n         POP   PRINT,NOPRINT\n*\n         DS    0D\nSTORADR  DC    A(MY_DYN_AREA)\nRBLEN    EQU   S99RBEND-S99RB\n*\nKEYA     DC    Y(DALDDNAM)\n         DC    X'0001'                1 ENTRY\n         DC    X'0008'                LENGTH IS 8\nKEYADDNM DC    CL8'BRWSPDCB'          DDNAME FOR ALLOCATION\n*\nKEYADS   DC    Y(DALDSNAM)\n         DC    X'0001'                1 ENTRY\nKEYADSL  DC    H'44'                  LENGTH IS 44\nKEYADSN  DC    CL44' '                DATASET NAME\n*\nKEYADISP DC    Y(DALSTATS)            DISP=\n         DC    X'0001'                1 ENTRY\n         DC    X'0001'                LENGTH IS 1\n         DC    X'08'                  DISP=SHR\n*\nKEYSSID  DC    Y(DALUASSR)            JES2=\n         DC    X'0001'                1 ENTRY\n         DC    X'0004'                LENGTH IS 4\n         DC    C'JES2'                JES2\n*\nKEYTOKEN DC    Y(DALBRTKN)            BROWSE TOKEN\n         DC    X'0007'                7 ENTRIES\nBTOKPL1  DC    XL2'4'              ID LENGTH\nBTOKID   DC    CL4'BTOK'           ID FIELD\n*\nBTOKPL2  DC    XL2'2'              VERSION LENGTH\nBTOKVER  DS    0XL2                SERVICE VERSION NUMBER\nBTOKTYPE DC    XL1'3'              CONTROL BLOCK TYPE\nBTOKBRWS EQU   0                   BLOCK CREATED FOR BROWSE\n*        EQU   1                   RESERVED - DO NOT EVER USE\nBTOKSAPI EQU   2                   BLOCK CREATED BY SYSOUT API\nBTOKSTKN EQU   3                   SPOOL DATA SET OR CLIENT\n*                                    TOKEN ALLOCATION\nBTOKVERS DC    XL1'3'              VERSION\nBTOKVRNM EQU   3                   VERSION OS/390 RELEASE 10\n**\nBTOKPL3  DC    XL2'4'              SPOOL TOKEN LENGTH\nBTOKIOTP DC    XL4'0'              IOT MTTR (OR ZERO)          @R10LSDB\nBTOKSAPT EQU   BTOKIOTP,L'BTOKIOTP,T'BTOKIOTP  SAPI TOKEN      @R10LSDB\nBTOKSPLT EQU   BTOKIOTP,L'BTOKIOTP,T'BTOKIOTP  CLIENT/DS TOKEN @R10LSDB\n**\nBTOKPL4  DC    XL2'4'              JOB KEY LENGTH\nBTOKJKEY DC    XL4'0'              JOB KEY IN HEX\n**\nBTOKPL5  DC    XL2'2'              ASID LENGTH\nBTOKASID DS    XL2                 ASID IN HEX\n**\nBTOKPL6  DC    XL2'8'              NETWORK RECEIVER USERID LENGTH\nBTOKRCID DC    CL8'SPURT'          NETWORK RECEIVER USERID\n**\nBTOKPL7  DC    AL2(255)            LOG STRING PARAMETER LENGTH\nBTOKLOGS DS    0CL255              LOG STRING PARAMETER\nBTOKLSDL DC    XL1'0'              LOG STRING DATA LENGTH (0-254 BYTES)\nBTOKLSDA DS    CL254               LOG STRING DATA\nBTOKEND  EQU   *                   END OF BTOK\nBTOKSIZE EQU   *-BTOKPL1           SIZE OF BTOK\n*\n         PUSH  PRINT,NOPRINT\n         PRINT NOGEN\n         DCBD  DSORG=QS,DEVD=DA\n         IEFTIOT1\nBRWSPOOL CSECT\n         IEFZB4D0\n         IEFZB4D2\n         POP   PRINT,NOPRINT\n*\nBRWSPOOL CSECT\n*\n         LTORG\n*\nMY_DYN_AREA    DS    4096CL1\n*\n*  possible exit list values\n*        07    JFCB exit\n*        05    Data control block OPEN exit    EXLDCBEX\n*        11    DCB abend exit\n*  UT1ABEND EQU   *\n*           L     R8,0(,R1)           GET COMPLETION CODE\n*           N     R8,=A(X'FFF0FF00')  ensure nybles 4, 7 and 8 are zero\n*           CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n*           BE    UT1MEMBR            YES, BRANCH\n*           MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n*           BR    R14\n*  UT1MEMBR OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n*           MVI   3(R1),4             IGNORE THE ABEND\n*           BR    R14\n*           DROP  R9\n*        13    Allocation retrieval list       EXLARL\n*\n* Table 1. DCB exit list format and contents\n* Entry Type                 Hex Code     Symbol\n* Inactive entry                00      EXLINACT\n* Input header label exit       01      EXLIHLAB\n* Output header label exit      02      EXLOHLAB\n* Input trailer label exit      03      EXLITLAB\n* Output trailer label exit     04      EXLOTLAB\n* Data control block OPEN exit  05      EXLDCBEX\n* End-of-volume exit            06      EXLEOVEX\n* JFCB exit                     07      EXLRJFCB\n*                               08      Reserved\n*                               09      Reserved\n* User totaling area            0A      EXLUSTOT\n* Block count unequal exit      0B      EXLBLCNT\n* Defer input trailer label     0C      EXLDFRIT\n* Defer nonstandard input trailer label         0D\n*                               0E-0F   Reserved.\n* FCB image                     10      EXLFCBIM\n* DCB abend exit                11      EXLDCBAB\n* QSAM parallel input           12      EXLPDAB\n* Allocation retrieval list     13      EXLARL\n*                               14      Reserved\n* JFCBE exit                    15      EXLJFCBE\n*                               16      Reserved\n* OPEN/EOV nonspecific tape volume mount        17      EXLDCBSL\n* OPEN/EOV volume security/verification         18      EXLDCBSC\n*                               1A-7F   Reserved\n* Last entry                    80      EXLLASTE\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKAPF": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x18\\x03o\\x01\\x18\\x03o\\x15G\\x00|\\x00i\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-02-05T00:00:00", "modifydate": "2018-02-05T15:47:03", "lines": 124, "newlines": 105, "modlines": 0, "user": "SDJRG"}, "text": "/* rexx       CHECKAPF     written by John Gateley\n\n   This will read a list of load libraries from SYSIN to check if\n   they are in the APF authorised list.\n   First it populates a stem variable containing all APF\n   authorised libraries. NOTE that only the dynamic list\n   has been tested because I do not have access to a system\n   with static list.\n   Then it reads the SYSIN list and checks if the dataset is in the\n   APF list. All dataset names are output to SYSTSPRT with the volume\n   name and are flagged if they are not authorised.\n   Note that the volume the dataset is on must match the volume of the\n   APF authorised dataset. This is to catch those cases where there\n   are two versions of a dataset, one in the catalogue and another\n   in the APF list.\n\n   This program uses some code from Mark Zelden's IPLINFO rexx exec\n   to access undocumented control blocks. IPLINFO does not build\n   a stem when the static list is used which is why I do not know\n   if it will work correctly, it should but my error if it does not.\n       http://mzelden.com/mvsutil.html\n\n   Example use\n\n   //STEP1   EXEC PGM=IKJEFT01,DYNAMNBR=20\n   //SYSTSIN  DD  *\n     EXEC 'a.b.c.d.FILE953(CHECKAPF)'\n   //SYSIN    DD  *\n     IGY410.SIGYCOMP\n     EQA810.SEQABMOD\n     EQA810.SEQAAUTH\n     GIM.SGIMLMD0\n     MAD.COW.SICKNESS\n     FAN140.SEAGLPA\n     DIT130.SDITMOD1\n     IOE.SIOELMOD\n     NORMAL.LOADLIB\n     AUTH.LOADLIB\n   //SYSTSPRT DD  SYSOUT=*\n\n*/\nNumeric digits 20                           /* dflt of 9 not enough  */\n                                            /* 20 can handle 64-bit  */\nline_break = substr('-',1,50,'-')           /* 50 bytes of '-'       */\nsay line_break\n\nCVT      = C2d(Storage(10,4))\nCVTAUTHL = C2d(Storage(D2x(CVT + 484),4))\nIf CVTAUTHL <> C2d('7FFFF001'x) then do      /* dynamic list ?       */\n  NUMAPF   = C2d(Storage(D2x(CVTAUTHL),2))   /* # APF libs in table  */\n  Say   'APF Library List  ('NUMAPF' libraries):'\n  APFOFF   = 2                               /* first ent in APF tbl */\n  VOL.0    = NUMAPF                          /* set the stem head    */\n  DSN.0    = NUMAPF                          /* set the stem head    */\n  Do I = 1 to NUMAPF                         /* for all datasets     */\n    LEN = C2d(Storage(D2x(CVTAUTHL+APFOFF),1)) /* length of entry    */\n    VOL.I = Storage(D2x(CVTAUTHL+APFOFF+1),6)  /* VOLSER of APF LIB  */\n    DSN.I = Storage(D2x(CVTAUTHL+APFOFF+1+6),LEN-6) /* DSN of apflib */\n    APFOFF = APFOFF + LEN +1\n    APFPOS   = Right(I,4)                      /*position in APF list*/\n  End\nEnd\nElse Do\n  ECVT     = C2d(Storage(D2x(CVT + 140),4))    /* point to CVTECVT   */\n  ECVTCSVT = C2d(Storage(D2x(ECVT + 228),4))   /* point to CSV table */\n  APFA = C2d(Storage(D2x(ECVTCSVT + 12),4))    /* APFA               */\n  AFIRST = C2d(Storage(D2x(APFA + 8),4))       /* First entry        */\n  ALAST  = C2d(Storage(D2x(APFA + 12),4))      /* Last  entry        */\n  LASTONE = 0   /* flag for end of list     */\n  NUMAPF = 1    /* tot # of entries in list */\n  Do forever\n    DSN.NUMAPF = Storage(D2x(AFIRST+24),44)    /* DSN of APF library */\n    DSN.NUMAPF = Strip(DSN.NUMAPF,'T')         /* remove blanks      */\n    CKSMS = Storage(D2x(AFIRST+4),1)           /* DSN of APF library */\n    if  bitand(CKSMS,'80'x)  = '80'x           /*  SMS data set?     */\n      then VOL.NUMAPF = '*SMS* '               /* SMS control dsn    */\n    else VOL.NUMAPF = Storage(D2x(AFIRST+68),6)    /* VOL of APF lib */\n    If Substr(DSN.NUMAPF,1,1) <> X2c('00')     /* check for deleted  */\n      then NUMAPF = NUMAPF + 1                 /*   APF entry        */\n    AFIRST = C2d(Storage(D2x(AFIRST + 8),4))   /* next  entry        */\n    if LASTONE = 1 then leave\n    If  AFIRST = ALAST then LASTONE = 1\n  End\n  Say   'APF Library List  - Dynamic ('NUMAPF - 1' libraries):'\nEnd\n\nSay   'VOLUME     DSNAME'\nSay   '======     ======'\nDo I = 1 to NUMAPF-1\n  APFPOS   = Right(I,4)                      /*position in APF list*/\n  Say   VOL.I '   ' DSN.I\nEnd\n\n/*  Now read the list of datasets from SYSIN, get the volume name from\n    the catalogue and see if they are authorised.\n    If the dataset does not exist warn the user.               */\n\nSay   '   '\nSay   'Input library list'\nSay   'VOLUME     DSNAME'\nSay   '======     ======'\n\"EXECIO * DISKR SYSIN (FINIS STEM IN_LIN.\"   /* populate stem        */\nDo I = 1 to IN_LIN.0                         /* for each input DSN   */\n  DSN_NAM = Strip(IN_LIN.I)                  /* strip any spaces     */\n  VAR_NAM = \"'\" || DSN_NAM || \"'\"            /* prepare for LISTDSI  */\n  DSINFO  = LISTDSI(VAR_NAM)                 /* get dataset details  */\n  IF DSINFO /= 0 then                        /* not catalogued       */\n    say '          ' SUBSTR(DSN_NAM,1,44) 'not catalogued'\n  else do\n    DSN_VOL = SYSVOLUME                      /* copy dataset volume  */\n    got_it  = 0                              /* flag not matched     */\n    Do J = 1 to NUMAPF-1                     /* for all APF datasets */\n      IF  VOL.J    = DSN_VOL then do         /* matching volume      */\n         IF DSN.J  = DSN_NAM THEN            /* matching dataset     */\n            got_it = 1                       /* flag matched         */\n      End\n    End\n    IF got_it = 1 then                       /* if matched           */\n       say DSN_VOL '   ' DSN_NAM\n    else\n       say DSN_VOL '   ' SUBSTR(DSN_NAM,1,44) 'not authorised'\n  End\nEnd\nsay line_break\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHKAUTH": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00H\\x01\\x17\\x06\\x0f\\x01\\x17\\x10?\\x06\\x11\\x00\\xdb\\x00\\xda\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-03-01T00:00:00", "modifydate": "2017-04-13T06:11:48", "lines": 219, "newlines": 218, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'CHKAUTH - REXX FUNCTION TO CHECK DATASET AUTHORISATION'\n PRINT GEN\n*\nCHKAUTH PRGDEF FSEG=MAIN_BIT,REXX=Y,RENT=N\n*______________________________________________________________________\n*\n*  This is for people who are not systems programmers, those who\n*  if they try and browse a dataset and are not authorised may\n*  have to justify their reasons for trying to browse it.\n*______________________________________________________________________\n*\n* This program acts as a REXX function\n*\n*    Input\n*         up to 44 bytes containing the name of a dataset to check\n*         if RACF authorised to read/update\n*\n*    Output\n*         Authorised to update         length=20\n*         Authorised to read           length=18\n*         Not authorised               length=14\n*         Error message                length=30\n*       OR\n*         ### rc of saf                length=22\n*______________________________________________________________________\n*\n*                        Parameters\n*______________________________________________________________________\n*\n*\n*  Parameter 1    -    dataset name to check\n*\n*______________________________________________________________________\n*\n*  REENTRANT STORAGE\n*\nTHE_DATASET          DS    CL44\nIS_AUTH_READ         DS    CL1\nIS_AUTH_UPDATE       DS    CL1\n*\nERR_NO               DS    CL1\nCHAR_9A              DS    CL9\nCHAR_9B              DS    CL9\n*\n        PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   SEGDO GET_ARGUMENTS\n*\n   SEGDO CHECK_AUTHORISED\n*\n   MVI   EVALBLOCK_EVDATA,C' '\n   MVC   EVALBLOCK_EVDATA+1(80),EVALBLOCK_EVDATA\n   IF (CLI,IS_AUTH_READ,EQ,C'Y')\n     MVC   EVALBLOCK_EVDATA(14),=C'Authorised to '\n     IF (CLI,IS_AUTH_UPDATE,EQ,C'Y')\n       MVC   EVALBLOCK_EVDATA+14(6),=C'update'\n       LA    R1,20\n     ELSE\n       MVC   EVALBLOCK_EVDATA+14(4),=C'read'\n       LA    R1,18\n     ENDIF\n   ELSEIF (CLI,IS_AUTH_READ,EQ,C'X')   SAF error\n     MVC   EVALBLOCK_EVDATA(L'SAF_ERR),SAF_ERR\n     MVC   EVALBLOCK_EVDATA+13(8),CHAR_9A\n     MVC   EVALBLOCK_EVDATA+25(8),CHAR_9B\n     LA    R1,L'SAF_ERR\n   ELSE\n     MVC   EVALBLOCK_EVDATA(14),=C'Not Authorised'\n     LA    R1,14\n   ENDIF\n   ST    R1,EVALBLOCK_EVLEN\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS GET_ARGUMENTS\n*\n   MVC   THE_DATASET,SPACES\n*\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')    no arguments\n     MVI   ERR_NO,1\n     SEGDO NOT_VALID\n   ENDIF\n   IF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')   zero length argument\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ENDIF\n   IF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'44')  name > 44 bytes\n     MVI   ERR_NO,3\n     SEGDO NOT_VALID\n   ENDIF\n   L     R15,ARGTABLE_ARGSTRING_PTR              get address\n   L     R14,ARGTABLE_ARGSTRING_LENGTH           get length\n   BCTR  R14,0\n   EX    R14,COPY_ARGUMENT             copy dataset name to check\n   OC    THE_DATASET,SPACES            ensure uppercase\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       point to second argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')   should be none\n     MVI   ERR_NO,4\n     SEGDO NOT_VALID\n   ENDIF\n*\n SEGE GET_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS CHECK_AUTHORISED\n*\n   MVC   DS_NAME(44),THE_DATASET       dataset name\n   LA    R14,DS_NAME+43\n   DO FROM=(R15,43)\n   DOEXIT (CLI,0(R14),GT,C' ')\n     BCTR  R14,0\n   ENDDO\n   LA    R14,1(,R14)\n   LR    R2,R14\n   LOCATE CAM_LISV                     get volume serial\n   IF (LTR,R15,R15,NZ)                 not found\n     IF (LTR,R0,R0,Z)\n       MVC   0(3,R2),=C'(0)'           try for a GDG\n       LOCATE CAM_LISV                 get volume serial\n     ENDIF\n     IF (LTR,R15,R15,NZ)               not found\n       MVI   ERR_NO,6\n       SEGDO NOT_VALID\n     ENDIF\n   ENDIF\n   IF (CLC,=C'MIGRAT',EQ,CAM_VOL+6)    if migrated then quit\n     MVI   ERR_NO,5\n     SEGDO NOT_VALID\n   ENDIF\n*\nC1 RACROUTE    REQUEST=AUTH,                                           /\n               ATTR=READ,                                              /\n               ENTITY=DS_NAME,                                         /\n               VOLSER=CAM_VOL+6,                                       /\n               MSGSUPP=YES,                                            /\n               RELEASE=7720,                                           /\n               WORKA=SAFWORK2,                                         /\n               CLASS='DATASET',MF=S\n   IF (CFI,R15,EQ,0)\n     MVI   IS_AUTH_READ,C'Y'\n   ELSEIF (CFI,R15,EQ,4)               error in SAF\n     MVI   IS_AUTH_READ,C'X'\n     UNPK  CHAR_9A,C1+4(5)             copy return and reason codes\n     UNPK  CHAR_9B,C1+8(5)\n     SEGQUIT                           bail out\n   ENDIF\n*\n   RACROUTE    REQUEST=AUTH,                                           /\n               ATTR=UPDATE,                                            /\n               ENTITY=DS_NAME,                                         /\n               VOLSER=CAM_VOL+6,                                       /\n               MSGSUPP=YES,                                            /\n               RELEASE=7720,                                           /\n               WORKA=SAFWORK2,                                         /\n               CLASS='DATASET',MF=S\n   IF (CFI,R15,EQ,0)\n     MVI   IS_AUTH_UPDATE,C'Y'\n   ENDIF\n*\n SEGE CHECK_AUTHORISED\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'No argument passed'\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument was zero length'\n   ELSEIF (CLI,ERR_NO,EQ,3)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 44 bytes'\n   ELSEIF (CLI,ERR_NO,EQ,4)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Second argument received'\n   ELSEIF (CLI,ERR_NO,EQ,5)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Dataset is migrated'\n   ELSEIF (CLI,ERR_NO,EQ,6)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Dataset not found'\n   ELSE\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Unknown error, RC='\n     XR    R1,R1\n     IC    R1,ERR_NO\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  EVALBLOCK_EVDATA+18(4),DOUB_WORD\n     XC    R_C,R_C\n   ENDIF\n   MVC   EVALBLOCK_EVLEN,=F'30'        set output length\n*\n   PRGQUIT\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nSAF_ERR  DC    C'SAF error RC=######## RS=########'\nSPACES   DC    80CL1' '\n*\nCOPY_ARGUMENT  MVC   THE_DATASET(1),0(R15)\n*\n         LTORG\n*\n*        GET VOLUME SERIAL FOR GIVEN DATASET\nCAM_LISV CAMLST NAME,DS_NAME,,CAM_VOL\n         DS    0D\nDS_NAME  DC    CL44' '\nCAM_VOL  DS    CL265              CAMLST WORK AREA\n         ORG   CAM_VOL\nSAFWORK2 DS    CL512\n         ORG\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHKAUTH$": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x17\\x06\\x0f\\x01\\x17\\x06\\x0f\\x15#\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-03-01T00:00:00", "modifydate": "2017-03-01T15:23:15", "lines": 30, "newlines": 30, "modlines": 0, "user": "SDJRG"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(CHKAUTH)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   CHKAUTH\n SETSSI  CB496953\n ENTRY   CHKAUTH\n NAME    CHKAUTH(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNTRECS": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x19\\x02/\\x01\\x19\\x02/\\x067\\x01\\x82\\x01\\x82\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-01-22T00:00:00", "modifydate": "2019-01-22T06:37:17", "lines": 386, "newlines": 386, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'CNTRECS - count records in all datasets concatenated to SYSIN'\n PRINT GEN\n*______________________________________________________________________\n*\n*  This count all all records in the datasets concatenated to SYSIN\n*  and outputs individual dataset counts along with the name.\n*\n*  This uses the value in the DCB TIOT field to know which dataset\n*  the record actually came from.\n*______________________________________________________________________\n*\nCNTRECS  PRGDEF FSEG=MAIN_PART,RMODE=24\n*\nCONCAT_DETS_A          DS    F         address of concatenated list\nCONCAT_DETS_C          DS    F         count of entries\nTOTAL_COUNT            DS    F         count of total records\nATIOT                  DS    F         TIOT address\nOPEN_TIOT              DS    H         save TIOT offset on open\nCHECK_DDNAME           DS    CL8\nSYSOUT_REC             DS    CL80\nE_O_F                  DS    C\n*\nTHE_VALUE              DS    CL54\n                       ORG   THE_VALUE\nTHE_DSNAME             DS    CL44\nOPEN_PARENTHESES       DS    CL1\nTHE_MEMNAME            DS    CL8\nCLOSE_PARENTHESES      DS    CL1\n                       ORG\n*\nWS_GETCNCAT            DSECT\nWS_GETCN_NEXT          DS    F         next entry in linked list\nWS_GETCN_COUNT         DS    F         count of entries\nWS_GETCN_OFFSET        DS    H         offset of this in TIOT\nWS_GETCN_DSNAME        DS    CL44      dataset name\nWS_GETCN_MEMNAME       DS    CL8       member name\nWS_GETCN_FULL          DS    CL54      dataset(member)\nWS_GETCN_PATH_LEN      DS    H\nWS_GETCN_PATH_TXT      DS    CL255     UNIX pathname\n                       DS    0D\nWS_GETCN_LEN           EQU   *-WS_GETCNCAT\n*\n         USING WS_GETCNCAT,R10\n         USING IHADCB,SYSIN\n         USING ARA,R4\n*\n         PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   MVI   SYSOUT_REC,C' '\n   MVC   SYSOUT_REC+1(L'SYSOUT_REC-1),SYSOUT_REC\n*\n   SEGDO GET_TIOT_ADDRESS\n*\n   MVC   CHECK_DDNAME,=CL8'SYSIN'\n   SEGDO CHECK_FOR_DDNAME\n*\n   MVC   CHECK_DDNAME,=CL8'SYSOUT'\n   SEGDO CHECK_FOR_DDNAME\n*\n   SEGDO OPEN_SYSOUT\n*\n   XR    R10,R10                       show table does not exist\n   SEGDO GET_CONCATENATED_NAMES\n*\n   SEGDO MATCH_TIOT_WITH_LIST\n*\n   SEGDO READ_AND_COUNT_SYSIN\n*\n   SEGDO REPORT_ON_SYSIN_CONTENTS\n*\n   SEGDO CLOSE_SYSOUT\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS READ_AND_COUNT_SYSIN\n*\n   SEGDO OPEN_SYSIN\n   DO INF\n     SEGDO GET_SYSIN                   rec address into R1\n   DOEXIT (CLI,E_O_F,EQ,C'Y')\n     L     R10,CONCAT_DETS_A           address of dataset list\n     L     R9,CONCAT_DETS_C            count of datasets\n     DO FROM=(R9)\n     DOEXIT (CLC,DCBTIOT,EQ,WS_GETCN_OFFSET)\n       L     R10,WS_GETCN_NEXT         point to next slot\n     ENDDO\n     IF (LTR,R9,R9,NZ)\n       L     R1,WS_GETCN_COUNT         get record count\n       LA    R1,1(,R1)\n       ST    R1,WS_GETCN_COUNT         save record count\n     ENDIF\n     L     R1,TOTAL_COUNT\n     LA    R1,1(,R1)\n     ST    R1,TOTAL_COUNT\n   ENDDO\n   SEGDO CLOSE_SYSIN\n*\n SEGE READ_AND_COUNT_SYSIN\n*______________________________________________________________________\n*\n SEGS REPORT_ON_SYSIN_CONTENTS\n*\n   L     R10,CONCAT_DETS_A             address of dataset list\n   L     R9,CONCAT_DETS_C              count of datasets\n   DO FROM=(R9)\n     L     R1,WS_GETCN_COUNT           get record count\n     CVD   R1,DOUB_WORD\n     MVC   SYSOUT_REC(L'EDPAT),EDPAT\n     ED    SYSOUT_REC(L'EDPAT),DOUB_WORD\n     IF (CLC,WS_GETCN_PATH_LEN,EQ,=H'0')     not a UNIX path name?\n       MVC   SYSOUT_REC+L'EDPAT+2(54),WS_GETCN_FULL  full name\n       SEGDO PUT_SYSOUT\n     ELSE\n       LH    R3,WS_GETCN_PATH_LEN\n       LA    R4,WS_GETCN_PATH_TXT\n       DO INF\n       DOEXIT (LTR,R3,R3,NP)           quit when no more\n         IF (CHI,R3,GT,54)\n           MVC   SYSOUT_REC+L'EDPAT+2(54),0(R4)\n           AHI   R3,-54\n           LA    R4,54(,R4)\n           SEGDO PUT_SYSOUT\n         ELSE\n           BCTR  R3,0\n           EX    R3,COPY_OUT\n           LA    R3,0\n         ENDIF\n         SEGDO PUT_SYSOUT\n       ENDDO\n     ENDIF\n     LA    R2,WS_GETCN_LEN             length of storage\n     LR    R1,R10                      copy address\n     L     R10,WS_GETCN_NEXT           point to next slot\n     STORAGE RELEASE,LENGTH=(R2),ADDR=(R1)\n   ENDDO\n   SEGDO PUT_SYSOUT                    output blank line\n   L     R1,TOTAL_COUNT                get total record count\n   CVD   R1,DOUB_WORD\n   MVC   SYSOUT_REC(L'EDPAT),EDPAT\n   ED    SYSOUT_REC(L'EDPAT),DOUB_WORD\n   SEGDO PUT_SYSOUT\n*\n SEGE REPORT_ON_SYSIN_CONTENTS\n*______________________________________________________________________\n*\n SEGS CHECK_FOR_DDNAME\n*\n   L     R2,ATIOT\n   USING TIOT1,R2\n*\n   LA    R14,TIOENTRY\n   DROP  R2\n   USING TIOENTRYD,R14\n   XR    R2,R2                         length register\n   DO INF\n     ICM   R2,1,TIOELNGH               get entry length\n   DOEXIT (LTR,R2,R2,Z)                zero length, DDNAME not found\n   DOEXIT (CLC,TIOEDDNM,EQ,CHECK_DDNAME)\n     AR   R14,R2                       next entry\n   ENDDO\n*\n   IF (LTR,R2,R2,Z)                    could not find DDNAME\n     MVC   MESS_TXT(8),CHECK_DDNAME\n     MVC   MESS_TXT+10(L'MISSING_DD),MISSING_DD\n     SEGDO WRITE_LOG\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE CHECK_FOR_DDNAME\n*______________________________________________________________________\n*\n SEGS MATCH_TIOT_WITH_LIST\n*\n   L     R2,ATIOT\n   USING TIOT1,R2\n*\n   LA    R14,TIOENTRY\n   DROP  R2\n   USING TIOENTRYD,R14\n   XR    R2,R2                         length register\n   DO INF\n     ICM   R2,1,TIOELNGH               get entry length\n   DOEXIT (LTR,R2,R2,Z)                zero length, DDNAME not found\n   DOEXIT (CLC,TIOEDDNM,EQ,=CL8'SYSIN')\n     AR   R14,R2                       next entry\n   ENDDO\n*\n   IF (LTR,R2,R2,Z)                    could not find DDNAME\n     MVC   SYSOUT_REC(8),=CL8'SYSIN'\n     MVC   SYSOUT_REC+10(L'MISSING_DD),MISSING_DD\n     SEGDO PUT_SYSOUT\n     PRGQUIT RC=8\n   ENDIF\n   L     R10,CONCAT_DETS_A             address of dataset list\n   LR    R15,R14                       copy address\n   S     R15,ATIOT                     calculate offset in TIOT\n   STH   R15,WS_GETCN_OFFSET           save offset of this entry\n   AR    R14,R2                        next entry\n   DO INF\n     ICM   R2,1,TIOELNGH               get entry length\n   DOEXIT (LTR,R2,R2,Z)                zero length, DDNAME not found\n   DOEXIT (CLC,TIOEDDNM,NE,=CL8' ')    quit when DDNAME not blank\n     L     R10,WS_GETCN_NEXT           next entry\n     LR    R15,R14                     copy address\n     S     R15,ATIOT                   calculate offset in TIOT\n     STH   R15,WS_GETCN_OFFSET         save offset of this entry\n     AR    R14,R2                      next entry\n   ENDDO\n*\n SEGE MATCH_TIOT_WITH_LIST\n*______________________________________________________________________\n*\n SEGS GET_CONCATENATED_NAMES\n*\n   OI    ARLOPT1,ARLUSS                get USS path name\n   RDJFCB  (SYSIN)                     get list of allocated files\n   IF (LTR,R15,R15,NZ)\n     MVC   SYSOUT_REC(8),=CL8'SYSIN'\n     MVC   SYSOUT_REC+10(L'FAIL_RDJFCB),FAIL_RDJFCB\n     SEGDO PUT_SYSOUT\n     PRGQUIT RC=8\n   ENDIF\n*  if there is only 1 dataset allocated then the details are in\n*  INFMJFCB otherwise all the details are placed in a getmained\n*  area of storage and the code needs to look at them in turn\n   L     R4,ARLAREA\n   USING ARA,R4\n   LH    R5,ARLRTRVD\n   IF (LTR,R5,R5,NZ)                     anything here\n     DO FROM=(R5)\n       MVC   INFMJFCB(JFCBLGTH),ARAJFCB  copy next dataset details\n       SEGDO PROC_DATASET_DETS           process this one\n       AH    R4,ARALEN                   point to next\n     ENDDO\n*    having processed all the datasets free the storage\n     L     R2,ARLAREA\n     XR    R5,R5\n     ICM   R5,B'0111',ARLRLEN\n     XR    R15,R15\n     IC    R15,ARLPOOL\n     FREEMAIN RU,LV=(R5),A=(R2),SP=(R15)\n     SEGDO PUT_SYSOUT\n   ELSE\n     SEGDO PROC_DATASET_DETS\n   ENDIF\n*\n SEGE GET_CONCATENATED_NAMES\n*______________________________________________________________________\n*\n SEGS PROC_DATASET_DETS\n*\n   LA    R2,WS_GETCN_LEN\n   STORAGE OBTAIN,LENGTH=(R2),LOC=31\n   XC    0(256,R1),0(R1)               wipe to low values\n   XC    0(WS_GETCN_LEN-256,R1),0(R1)  wipe to low values\n*\n   IF (LTR,R10,R10,Z)                  first dataset?\n     ST    R1,CONCAT_DETS_A            store in anchor\n   ELSE\n     ST    R1,WS_GETCN_NEXT            store in previous entry\n   ENDIF\n   LR    R10,R1                        point to new entry\n   L     R1,CONCAT_DETS_C              increment count of entries\n   LA    R1,1(,R1)\n   ST    R1,CONCAT_DETS_C\n*\n*  now copy name or path\n*\n   XC    WS_GETCN_PATH_LEN,WS_GETCN_PATH_LEN\n   XC    WS_GETCN_PATH_TXT,WS_GETCN_PATH_TXT\n   IF (CLC,=C'...PATH=.SPECIFIED...',EQ,JFCBDSNM)\n     MVI   WS_GETCN_FULL,C' '          wipe to spaces\n     MVC   WS_GETCN_FULL+1(L'WS_GETCN_FULL-1),WS_GETCN_FULL\n     MVC   WS_GETCN_DSNAME,WS_GETCN_FULL\n     MVC   WS_GETCN_MEMNAME,WS_GETCN_FULL\n     IF (TM,ARAFLG,ARAXINF,NZ)         is the extended info there ?\n       XR    R3,R3\n       IC    R3,ARAXINOF               get length in double words\n       SLL   R3,3                      multiply by 8\n       AR    R3,R4                     point to extended info\n       IF (CLC,2(2,R3),NE,=H'0')       is pathname there\n         AH    R3,2(,R3)               offset to pathname\n         MVC   WS_GETCN_PATH_LEN,0(R3)\n         MVC   WS_GETCN_PATH_TXT,2(R3)\n       ENDIF\n     ENDIF\n   ELSE\n     MVC   THE_DSNAME,JFCBDSNM         copy dataset name\n     MVC   THE_MEMNAME,JFCBELNM        and member name (if there)\n     MVC   WS_GETCN_DSNAME,JFCBDSNM    copy dataset name\n     MVC   WS_GETCN_MEMNAME,JFCBELNM   and member name (if there)\n     IF (CLC,THE_MEMNAME,GT,=CL8' ')   is member name present ?\n       MVI   OPEN_PARENTHESES,C'('     put in the brackets\n       MVI   CLOSE_PARENTHESES,C')'\n     ELSE\n       MVI   OPEN_PARENTHESES,C' '     remove the brackets\n       MVI   CLOSE_PARENTHESES,C' '\n     ENDIF\n     TRIM  THE_VALUE,ALL=Y\n     MVC   WS_GETCN_FULL,THE_VALUE\n   ENDIF\n*\n SEGE PROC_DATASET_DETS\n*______________________________________________________________________\n*\n SEGS GET_TIOT_ADDRESS\n*\n   L     R1,CVTPTR                     get CVT address\n   L     R1,CVTASVT-CVT(R1)            get ASVT table @\n   LA    R1,ASVTENTY-ASVT(R1)          get @ of ASCB entry table\n*\n   XR    R2,R2                         clear R2 prior to access\n   EPAR  R2                            go get ASID\n   BCTR  R2,0                          subtract  1\n   MH    R2,=H'4'                      multiply by  4\n   L     R1,0(R2,R1)                   get @ from offset in table\n   L     R1,ASCBASXB-ASCB(R1)          get address space extension\n   TM    ASCBCS1-ASCB(R1),ASCBXMPA\n   L     R1,ASXBITCB-ASXB(R1)          get TCB\n   L     R1,TCBTIO-TCB(R1)             get TIOT\n   ST    R1,ATIOT                      save address\n*\n SEGE GET_TIOT_ADDRESS\n*______________________________________________________________________\n*\n PRGDCBI DCB=SYSIN,EOF=E_O_F                 generate code for SYSIN\n*\n PRGDCBO DCB=SYSOUT,REC=SYSOUT_REC           generate code for SYSOUT\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nMISSING_DD     DC    C'missing from JCL'\nFAIL_RDJFCB    DC    C'RDJFCB failed'\n*\nEDPAT    DC    X'40202020202020202020202020202120'\nCOPY_OUT MVC   SYSOUT_REC+L'EDPAT+2(0),0(R4)\n*\nSYSIN    DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GL),EODAD=END_SYSIN,       /\n               EXLST=LIST1\n*\nSYSOUT   DCB   DSORG=PS,DDNAME=SYSOUT,MACRF=(PM),RECFM=FB,LRECL=80\nLIST1    DS    0F\n         DC    X'13',AL3(MY_JFCB_13)   list 13\n         DC    X'87',AL3(MY_JFCB_07)   list 07 (8 means last one)\n*\nMY_JFCB_07     DS    0F\n               PUSH  PRINT,NOPRINT\n               PRINT GEN\n               IEFJFCBN\n               POP   PRINT,NOPRINT\nLEN_MY_JFCB_07 EQU   *-MY_JFCB_07\n*\n               PUSH  PRINT,NOPRINT\n               PRINT GEN\n               DCBD  DSORG=QS,DEVD=DA\n               POP   PRINT,NOPRINT\n               JRGTIOT\n*\nCNTRECS        CSECT\n*\n               PUSH  PRINT,NOPRINT\n               PRINT GEN\nMY_JFCB_13     IHAARL DSECT=NO\n               IHAARA\n               POP   PRINT,NOPRINT\n*\nCNTRECS        CSECT\n*\n         CVT   DSECT=YES,LIST=NO\n         IHAASCB LIST=NO\n         IHAASXB LIST=NO\n         IHAASVT LIST=NO\n         IKJTCB  LIST=NO\n*\nCNTRECS  CSECT\n*\n         LTORG\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CNTRECS$": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x19\\x02/\\x01\\x19\\x02/\\x06A\\x00\"\\x00\"\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-01-22T00:00:00", "modifydate": "2019-01-22T06:41:56", "lines": 34, "newlines": 34, "modlines": 0, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'CNTRECS   A/L/R ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*******************************************************\n//ASM01   EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(CNTRECS)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(CNTRECS)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(CNTRECS)\n//*******************************************************\n//LINK1   EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(CNTRECS)\n    ENTRY CNTRECS\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(CNTRECS)\n//SYSPRINT DD  SYSOUT=*                                 *\n//*******************************************************\n//TESTIT  EXEC PGM=CNTRECS\n//STEPLIB  DD  DISP=SHR,DSN=SDJRG.LOADLIB\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(###DOC##)\n//         DD  DISP=SHR,DSN=SDJRG.JCL(EMPTY)\n//         DD  DISP=SHR,\n// DSN=IBMUSER.BIG.LONG.DATASET.NAME.HOW.ABOUT.THIS(EMPTY)\n//         DD  DISP=SHR,\n// DSN=IBMUSER.BIG.LONG.DATASET.NAME.HOW.ABOUT.THIS(NOTEMPTY)\n//         DD  DISP=SHR,DSN=SDJRG.ASM(CNTRECS)\n//         DD  PATH='/u/sdjrg/some.txt',FILEDATA=TEXT\n//         DD  DISP=SHR,DSN=SDJRG.ASM(SPRSDISP)\n//SYSOUT   DD  SYSOUT=*\n//*******************************************************\n//STATUS  EXEC JRGSTAT\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DODYNP$$": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01 4O\\x01 4O\\x08\\x13\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-12-09T00:00:00", "modifydate": "2020-12-09T08:13:28", "lines": 8, "newlines": 8, "modlines": 0, "user": "SDJRG"}, "text": "//ASM01   EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(DODYNPRC)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(DODYNPRC)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(DODYNPRC)\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DODYNPRC": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01 4O\\x01 4O\\x08\\t\\x00\\xbc\\x00\\xbc\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-12-09T00:00:00", "modifydate": "2020-12-09T08:09:12", "lines": 188, "newlines": 188, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'DODYNPRC - MODULE TO DYNALLOC'\n*______________________________________________________________________\n*\n*   THIS IS A SUB-ROUTINE TO DYNAMICALLY ALLOCATE A DATASET\n*   TO A DDNAME, OR TO DE-ALLOCATE.\n*______________________________________________________________________\n*\nDODYNPRC PRGDEF FSEG=MAIN_PART,RMODE=24\n*\nERR_NO         DS    CL1\n*\nINPUT_PARM     DSECT\nINPUT_ACTION   DS    CL1              'A'  ALLOCATE\n*                                     'D'  DE-ALLOCATE\nINPUT_DDNAME   DS    CL8              DDNAME\nINPUT_DATASET  DS    CL44             DATASET\nINPUT_MEMBER   DS    CL8              OPTIONAL MEMBER NAME\n*\n         PRGEDEF\n*\n         USING S99RBP,R10             MAKE S99RBP DSECT ADDRESSIBLE\n         USING S99RB,R9               MAKE RB DSECT ADDRESSIBLE\n         USING INPUT_PARM,R4\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   L     R4,0(,R1)                    COPY INPUT PARAMETER LIST\n*\n   IF (CLI,INPUT_ACTION,EQ,C'A')      ALLOCATE\n     SEGDO ALLOCATE_DATASET\n   ELSEIF (CLI,INPUT_ACTION,EQ,C'D')  DE-ALLOCATE\n     SEGDO DEALLOCATE_DATASET\n   ELSE\n     SETRC RC=8\n   ENDIF\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS ALLOCATE_DATASET\n*\n   L     R1,STORADR\n   IF (LTR,R1,R1,Z)\n     LH    R0,=H'4096'           LENGTH OF STORAGE AREA\n     GETMAIN R,LV=(R0)           GET STORAGE AREA FOR DYNALLOC\n     ST    R1,STORADR            SAVE ADDRESS OF STORAGE\n   ENDIF\n   L     R10,STORADR\n   LA    R9,S99RBPTR+4           POINT 4 BYTES AFTER S99RBPTR\n   ST    R9,S99RBPTR             MAKE 'RBPTR' POINT TO RB\n   OI    S99RBPTR,S99RBPND       SET ON HIGH-ORDER BIT IN RBPTR\n   XC    S99RB(RBLEN),S99RB      ZEROISE COMPLETE 'RB'\n   MVI   S99RBLN,RBLEN           PUT LENGTH OF RB IN LENGTH FIELD\n   MVC   S99ERROR,=H'0'\n   MVC   S99INFO,=H'0'\n   LA    R8,24(R10)              START OF TEXT ADDRESS POINTERS\n   ST    R8,S99TXTPP\n*\n   MVC   KEYADDNM,INPUT_DDNAME\n   MVC   KEYADSN,INPUT_DATASET\n   MVC   KEYAMEN,INPUT_MEMBER\n*\n   MVI   S99VERB,S99VRBAL        SET ALLOCATE VERB\n   LA    R1,KEYA\n   ST    R1,0(R8)                STORE KEY ADDRESS\n   LA    R1,KEYADS\n   ST    R1,4(R8)                STORE KEY ADDRESS\n   IF (CLC,=C'DUMMY ',EQ,INPUT_DATASET)\n     LA    R1,KEYDUMY\n     ST    R1,8(R8)              STORE KEY ADDRESS\n     OI    8(R8),X'80'           INDICATE END OF ADDRESS LIST\n   ELSE\n     LA    R1,KEYADISP\n     ST    R1,8(R8)              STORE KEY ADDRESS\n     IF (CLC,KEYAMEN,GT,SPACES)\n       LA    R1,KEYAME\n       ST    R1,12(R8)           STORE KEY ADDRESS\n       OI    12(R8),X'80'        INDICATE END OF ADDRESS LIST\n     ELSE\n       OI    8(R8),X'80'         INDICATE END OF ADDRESS LIST\n     ENDIF\n   ENDIF\n*\n   L     R1,STORADR              SET R1 TO ADDR. OF RB POINTER\n   DYNALLOC\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(12),=CL12'DYNALLOC RC='\n     CVD   R15,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  MESS_TXT+12(3),DOUB_WORD+6(2)\n     LH    R15,S99ERROR\n     CVD   R15,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  MESS_TXT+16(5),DOUB_WORD+5(3)\n     MVC   MESS_TXT+24(44),KEYADSN\n     MVC   MESS_TXT+70(8),KEYAMEN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16\n   ENDIF\n*\n SEGE ALLOCATE_DATASET\n*______________________________________________________________________\n*\n SEGS DEALLOCATE_DATASET\n*\n   L     R10,STORADR\n   LA    R9,S99RBPTR+4           POINT 4 BYTES AFTER S99RBPTR\n   ST    R9,S99RBPTR             MAKE 'RBPTR' POINT TO RB\n   OI    S99RBPTR,S99RBPND       SET ON HIGH-ORDER BIT IN RBPTR\n   XC    S99RB(RBLEN),S99RB      ZEROISE COMPLETE 'RB'\n   MVI   S99RBLN,RBLEN           PUT LENGTH OF RB IN LENGTH FIELD\n   MVC   S99ERROR,=H'0'\n   MVC   S99INFO,=H'0'\n   LA    R8,24(R10)              START OF TEXT ADDRESS POINTERS\n   ST    R8,S99TXTPP\n*\n   MVI   S99VERB,S99VRBUN        SET DEALLOCATE VERB\n   LA    R1,KEYA\n   ST    R1,0(R8)                STORE KEY ADDRESS\n   OI    0(R8),X'80'             INDICATE END OF ADDRESS LIST\n   L     R1,STORADR              SET R1 TO ADDR. OF RB POINTER\n   DYNALLOC\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(14),=CL14'DYNUNALLOC RC='\n     CVD   R15,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  MESS_TXT+14(3),DOUB_WORD+6(2)\n     LH    R15,S99ERROR\n     CVD   R15,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  MESS_TXT+16(5),DOUB_WORD+5(3)\n     MVC   MESS_TXT+24(44),KEYADSN\n     MVC   MESS_TXT+70(8),KEYAMEN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16\n   ENDIF\n*\n SEGE DEALLOCATE_DATASET\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nSPACES   DC    CL80' '\n*______________________________________________________________________\n*\n         LTORG\n*______________________________________________________________________\n*\n         DS    0D\nSTORADR  DC    A(0)\nRBLEN    EQU   S99RBEND-S99RB\n*\nKEYA     DC    Y(DALDDNAM)\n         DC    X'0001'                1 ENTRY\n         DC    X'0008'                LENGTH IS 8\nKEYADDNM DC    CL8'        '          DDNAME FOR ALLOCATION\n*\nKEYADS   DC    Y(DALDSNAM)\n         DC    X'0001'                1 ENTRY\nKEYADSL  DC    H'44'                  LENGTH IS 44\nKEYADSN  DC    CL44' '                DATASET NAME\n*\nKEYAME   DC    Y(DALMEMBR)\n         DC    X'0001'                1 ENTRY\nKEYAMEL  DC    H'8'                   LENGTH IS 8\nKEYAMEN  DC    CL8' '                 MEMBER NAME\n*\nKEYADISP DC    Y(DALSTATS)            DISP=\n         DC    X'0001'                1 ENTRY\n         DC    X'0001'                LENGTH IS 1\n         DC    X'08'                  DISP=SHR\n*\nKEYDUMY  DC    Y(DALDUMMY)\n         DC    X'0000'                NO ENTRIES\n*\nKEYAL    EQU   *-KEYA\n*______________________________________________________________________\n*\n         IEFZB4D0\n         IEFZB4D2\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "E35DROP": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x01\\x18\\x02\\x0f\\x01\\x18\\x02\\x0f\\x18Q\\x00\\xad\\x00\\xa9\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-01-20T00:00:00", "modifydate": "2018-01-20T18:51:23", "lines": 173, "newlines": 169, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'E35DROP - E35 SORT EXIT TO DROP DUPLICATES'\n*______________________________________________________________________\n*\n*    THIS IS AN E35 EXIT FOR THE SORT. IT GETS CONTROL JUST BEFORE\n*    THE OUTPUT RECORD IS WRITTEN TO THE SORTOUT DATASET I.E. AFTER\n*    ANY CHANGES TO THE RECORD HAVE BEEN DONE.\n*    N.B. AFTER OUTREC FIELDS=\n*\n*    IT CAN BE USED AS AN E15 EXIT AS WELL, IN WHICH CASE IT SEES\n*    THE RECORD BEFORE THE INREC DOES, I.E. AS ON DISK (OR TAPE)\n*\n*    ITS PURPOSE IS TO FILTER OUTPUT RECORDS BY SPECIFYING A POSITION\n*    AND LENGTH IN THE E35DROP DATASET, IF THE DATA IN THE RECORD\n*    AT THE GIVEN POSITION AND LENGTH IS THE SAME AS THE PREVIOUS\n*    RECORD OUTPUT THEN THIS RECORD IS DROPPED.\n*    USED WHEN SORTING DATA WHICH INCLUDES A DATE/TIME AND YOU ONLY\n*    WANT THE MOST RECENT RECORD.\n*\n*    EXAMPLE OF HOW TO USE THIS.\n*\n*    //SYSIN    DD  *\n*       INREC   FIELDS=(1,10,                  *A KEY\n*                       100,20)                *CHANGABLE DATA\n*                       273,26)                *A TIMESTAMP\n*       SORT    FIELDS=(1,10,BI,A              *SORT ON SOME DATA ASC\n*                       31,26,BI,D)            *AND TIMESTAMP DESC\n*       MODS    E35=(E35DROP,2000,,N)          *PROGRAM AND WORK AREA\n*       END\n*\n*    //E35DROP  DD  *\n*    00001,030                POSITION IS AS FOR SORT I.E. WITH RDW\n*                             USE ALL DIGITS IN POSITION AND LENGTH\n*\n*    AT THE END OF THE RUN THE OUTPUT WOULD CONTAIN THE LATEST DATA\n*    FOR A GIVEN KEY + CHANGABLE DATA\n*\nE35DROP  START\n         YREGS\n         USING *,R12\nE35DROP  AMODE 31\nE35DROP  RMODE 24\n         STM   14,12,12(R13)\n         LR    R12,R15                   SET BASE REGISTER\n         LA    R2,SAV_AREA\n         ST    R13,4(R2)                 CHAIN SAVE AREAS\n         ST    R2,8(R13)\n         LR    R13,R2\n         B     AFT_SAVE\nSAV_AREA DS    18F\nAFT_SAVE DS    0H\n*\n         LR    R3,R1                     COPY INPUT PARM LIST\n         CLI   FIRST_TIME,C'Y'           FIRST TIME IN\n         BE    IS_FIRST\n*\nAFT_INIT DS    0H\n*\n         L     R4,0(,R3)                 GET RECORD ADDRESS\n         LTR   R4,R4                     IS THERE ONE\n         BZ    NO_REC                    NO\n         LR    R8,R4                     COPY RECORD ADDRESS\n         AH    R8,DISP_LACE              MOVE ALONG RECORD\nTEST_IT  CLC   0(1,R8),SAVE_RECORD\n         BE    MATCHED\nSAVE_IT  MVC   SAVE_RECORD,0(R8)         COPY THIS RECORD\n         L     R1,4(R13)                 POINT TO CALLERS SAVE AREA\n         ST    R4,24(R1)                 STORE RECORD ADDRESS\n         LA    R15,0                     SET RETURN CODE\n         B     GOBACK\n*\nMATCHED  LA    R15,4                     SET RETURN CODE\n         B     GOBACK\nNO_REC   LA    R15,8                     RC=8 DON'T CALL AGAIN\n*\nGOBACK   DS    0H                        R15 SHOULD CONTAIN RETURN CODE\n         L     R13,4(R13)                POINT TO CALLERS SAVE AREA\n         ST    R15,16(R13)               PUT IN CALLERS SAVE AREA\n         LM    R14,R12,12(R13)           RESTORE REGISTERS AND RC\n         BSM   0,R14                     RETURN TO CALLER\n*______________________________________________________________________\n*\n*        THIS READS FROM DDNAME=E35DROP\n*\nIS_FIRST DS    0H\n*\n         MVI   FIRST_TIME,C'N'                 SHOW NOT FIRST TIME\n*\n         OPEN  (E35DROPF,INPUT)\n         LTR   R15,R15\n         BZ    OPEN_OK\n         LA    R15,16\n         B     GOBACK\n*\nOPEN_OK  DS    0H\n*\n         GET   E35DROPF\n         MVC   PARM_CARD,0(R1)                 COPY INPUT RECORD\n         CLOSE E35DROPF\n         TRT   PARM_CARD(5),NUM_TAB\n         BNZ   INVALID_PARAMETER\n         CLI   PARM_CARD+5,C','\n         BNE   INVALID_PARAMETER\n         TRT   PARM_CARD+6(3),NUM_TAB\n         BNZ   INVALID_PARAMETER\n         PACK  DOUB_WORD,PARM_CARD(5)\n         CVB   R1,DOUB_WORD\n         BCTR  R1,0\n         STH   R1,DISP_LACE\n         PACK  DOUB_WORD,PARM_CARD+6(3)\n         CVB   R1,DOUB_WORD\n         CHI   R1,256\n         BH    INVALID_PARAMETER\n         BCTR  R1,0\n         STH   R1,LEN_GTH\n         MVC   TEST_IT+1(1),LEN_GTH+1          MODIFY TEST\n         MVC   SAVE_IT+1(1),LEN_GTH+1          MODIFY SAVE\n         B     AFT_INIT\n*______________________________________________________________________\n*\nINVALID_PARAMETER  DS    0H\n*\n         MVC   MESS_TXT(L'INV_PARM_1),INV_PARM_1\n         BAL   R8,WRITE_LOG\n         MVC   MESS_TXT(72),PARM_CARD\n         BAL   R8,WRITE_LOG\n         MVC   MESS_TXT(L'INV_PARM_2),INV_PARM_2\n         BAL   R8,WRITE_LOG\n         MVC   MESS_TXT(L'INV_PARM_3),INV_PARM_3\n         BAL   R8,WRITE_LOG\n         MVC   MESS_TXT(L'INV_PARM_4),INV_PARM_4\n         BAL   R8,WRITE_LOG\n         LA    R15,16\n         B     GOBACK\n*______________________________________________________________________\n*\nWRITE_LOG  DS    0H\n*\n         LA    R2,MESS_LEN\n         WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY\n         MVI   MESS_TXT,C' '\n         MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n         BR    R8\n*______________________________________________________________________\n*\nLEN_GTH        DC    H'0'\nDISP_LACE      DC    H'0'\nMESS_LEN       DC    H'80'\nMESS_TXT       DC    CL80'  '\nFIRST_TIME     DC    C'Y'\n*\nINV_PARM_1     DC    C'E35DROP - INVALID PARAMETER SPECIFIED'\nINV_PARM_2     DC    C'00009,003         WOULD BE VALID'\nINV_PARM_3     DC    C'POSITION AND LENGTH IN RECORD'\nINV_PARM_4     DC    C'LENGTH SPECIFIED MUST NOT EXCEED 256'\n*\nEND_E35DROP    DS    0H\n               LA    R15,16\n               B     GOBACK\n*\nDOUB_WORD      DS    D\nPARM_CARD      DS    CL72\nSAVE_RECORD    DS    CL256               SAVE IMPORTANT PART OF RECORD\n*\nE35DROPF DCB   DSORG=PS,MACRF=(GL),DDNAME=E35DROP,EODAD=END_E35DROP\n*\n         LTORG\n*\nNUM_TAB  DC    256X'FF'\n         ORG   NUM_TAB+C'0'\n         DC    10X'00'\n         ORG\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "E35DROP$": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x18\\x02\\x0f\\x01\\x18\\x02\\x0f\\x16U\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-20T00:00:00", "modifydate": "2018-01-20T16:55:07", "lines": 30, "newlines": 30, "modlines": 0, "user": "SDJRG"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(E35DROP)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   E35DROP\n SETSSI  CB496953\n ENTRY   E35DROP\n NAME    E35DROP(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "E35TABL": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x18\\x02\\x0f\\x01\\x18\\x02\\x0f\\x18P\\x01\\n\\x01\\x06\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-01-20T00:00:00", "modifydate": "2018-01-20T18:50:46", "lines": 266, "newlines": 262, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'E35TABL - E35 SORT EXIT FOR TABLIN PROCESSING'\n*______________________________________________________________________\n*\n*    THIS IS AN E35 EXIT FOR THE SORT. IT GETS CONTROL JUST BEFORE\n*    THE OUTPUT RECORD IS WRITTEN TO THE SORTOUT DATASET I.E. AFTER\n*    ANY CHANGES TO THE RECORD HAVE BEEN DONE.\n*    N.B. AFTER OUTREC FIELDS=\n*\n*    IT CAN BE USED AS AN E15 EXIT AS WELL, IN WHICH CASE IT SEES\n*    THE RECORD BEFORE THE INREC DOES, I.E. AS ON DISK (OR TAPE)\n*\n*    EXAMPLE OF HOW TO USE THIS.\n*\n*    //SYSIN    DD  *\n*       INCLUDE COND=(9,4,CH,NE,C'DCUS',AND,9,4,CH,NE,C'    ')\n*       INREC   FIELDS=(9,5,230,3)             *CTRL+MPED\n*       SORT    FIELDS=(6,3,CH,A,1,5,PD,A)\n*       MODS    E35=(E35TABL,1048576,,N)\n*       END\n*\n*    //E35TABL  DD  *\n*    00006,003,IN             POSITION IS AS FOR SORT I.E. WITH RDW\n*                             USE ALL DIGITS IN POSITION AND LENGTH\n*\n*    //TABLIN   DD  *         THIS CAN BE A SEQUENTIAL DATASET\n*    AWL\n*    JDW\n*    FW\n*    OXO\n*\n*    //E35TABL    CONTAINS THE COMPARISON REQUIRED\n*    IN THIS CASE POSITION 6 FOR 3 BYTES IS CHECKED TO SEE IF IT\n*    MATCHES ANY OF THE RECORDS CONTAINED 'IN' THE TABLIN DATASET\n*    ANY RECORDS THAT DO NOT MATCH ARE EXCLUDED FROM THE OUTPUT\n*\n*    IF THE THIRD PARAMETER HAD BEEN 'NI' THEN THOSE RECORDS\n*    WHICH DO MATCH WOULD BE EXCLUDED.\n*\nE35TABL  START\n         YREGS\n         USING *,R12\nE35TABL  AMODE 31\nE35TABL  RMODE 24\n         STM   14,12,12(R13)\n         LR    R12,R15                   SET BASE REGISTER\n         LA    R2,SAV_AREA\n         ST    R13,4(R2)                 CHAIN SAVE AREAS\n         ST    R2,8(R13)\n         LR    R13,R2\n         B     AFT_SAVE\nSAV_AREA DS    18F\nAFT_SAVE DS    0H\n*\n         LR    R3,R1                     COPY INPUT PARM LIST\n         CLI   FIRST_TIME,C'Y'           FIRST TIME IN\n         BE    IS_FIRST\n*\nAFT_INIT DS    0H\n         L     R4,0(,R3)                 GET RECORD ADDRESS\n         LTR   R4,R4                     IS THERE ONE\n         BZ    NO_REC                    NO\n         MVC   TEST_IT+1(1),LEN_GTH+1    SET LENGTH OF COMPARE\n         L     R9,TABLE_ADDR\n         LR    R6,R4\n         AH    R6,DISP_LACE\nDO_TEST  DS    0H\nTEST_IT  CLC   0(1,R9),0(R6)\n         BE    MAT_CHED\n         AH    R9,REC_LEN_GTH\n         C     R9,TABLE_ADDR_E           QUIT WHEN NO MORE VALUES\n         BL    TEST_IT\n*                                        DID NOT FIND THE VALUE\n         CLC   TY_PE,=C'IN'              DID WE WANT TO FIND IT ?\n         BE    NOT_WANT                  YES - SO DROP RECORD\n         B     WAN_TED                   NO  - SO KEEP RECORD\n*\nMAT_CHED DS    0H                        WE FOUND THE VALUE\n         CLC   TY_PE,=C'IN'              DID WE WANT TO FIND IT ?\n         BE    WAN_TED                   YES - SO KEEP RECORD\n         B     NOT_WANT                  NO  - SO DROP RECORD\n*\nWAN_TED  DS    0H\n         L     R1,4(R13)                 POINT TO CALLERS SAVE AREA\n         ST    R4,24(R1)                 STORE RECORD ADDRESS\n         LA    R15,0                     INDICATES KEEP RECORD\n         B     GOBACK\n*\nNOT_WANT DS    0H\n         LA    R15,4                     INDICATES DROP RECORD\n         B     GOBACK\n*\nNO_REC   DS    0H                        END OF FILE SO FREE STORAGE\n         L     R2,TABLE_LENGTH\n         L     R9,TABLE_ADDR\n         FREEMAIN RU,LV=(R2),A=(R9)      RELEASE STORAGE\n         LA    R15,8                     RC=8 DON'T CALL AGAIN\n*\nGOBACK   DS    0H                        R15 SHOULD CONTAIN RETURN CODE\n         L     R13,4(R13)                POINT TO CALLERS SAVE AREA\n         ST    R15,16(R13)               PUT IN CALLERS SAVE AREA\n         LM    R14,R12,12(R13)           RESTORE REGISTERS AND RC\n         BSM   0,R14                     RETURN TO CALLER\n*______________________________________________________________________\n*\n*        THIS READS FROM DDNAME=E35TABL\n*\nIS_FIRST DS    0H\n*\n         MVI   FIRST_TIME,C'N'           SHOW NOT FIRST TIME\n*\n         OPEN  (E35TABLF,INPUT)\n         LTR   R15,R15\n         BZ    OPEN_OK\n         LA    R15,16\n         B     GOBACK\n*\nOPEN_OK  DS    0H\n*\n         GET   E35TABLF\n         MVC   PARM_CARD,0(R1)                 COPY INPUT RECORD\n         CLOSE E35TABLF\n         TRT   PARM_CARD(5),NUM_TAB\n         BNZ   INVALID_PARAMETER\n         CLI   PARM_CARD+5,C','\n         BNE   INVALID_PARAMETER\n         TRT   PARM_CARD+6(3),NUM_TAB\n         BNZ   INVALID_PARAMETER\n         CLI   PARM_CARD+9,C','\n         BNE   INVALID_PARAMETER\n         CLC   PARM_CARD+10(2),=C'IN'\n         BE    OK_10\n         CLC   PARM_CARD+10(2),=C'NI'\n         BNE   INVALID_PARAMETER\nOK_10    DS    0H\n         PACK  DOUB_WORD,PARM_CARD(5)\n         CVB   R1,DOUB_WORD\n         BCTR  R1,0\n         STH   R1,DISP_LACE\n         PACK  DOUB_WORD,PARM_CARD+6(3)\n         CVB   R1,DOUB_WORD\n         CHI   R1,256\n         BH    INVALID_PARAMETER\n         STH   R1,REC_LEN_GTH\n         BCTR  R1,0\n         STH   R1,LEN_GTH\n         MVC   TY_PE,PARM_CARD+10\n*\n         BAS   R8,COUNT_TABLIN\n*\n         MH    R9,REC_LEN_GTH\n         ST    R9,TABLE_LENGTH\n         GETMAIN RU,LV=(R9),LOC=31       GET STORAGE TO HOLD ALL VALUES\n         ST    R1,TABLE_ADDR\n         LR    R9,R1\n*\n         BAS   R8,LOAD_TABLIN\n*\n         B     AFT_INIT\n*______________________________________________________________________\n*\nCOUNT_TABLIN   DS    0H\n*\n         OPEN  (TABLIN1,INPUT)\n         LTR   R15,R15\n         BZ    OP_CT_OK\n         LA    R15,16\n         B     GOBACK\n*\nOP_CT_OK DS    0H\n         XR    R9,R9\nNEXT_CT  DS    0H\n         GET   TABLIN1\n         LA    R9,1(,R9)\n         B     NEXT_CT\nEND_TABLIN1  DS    0H\n         CLOSE TABLIN1\n*\n         BR    R8\n*______________________________________________________________________\n*\nLOAD_TABLIN    DS    0H\n*\n         OPEN  (TABLIN2,INPUT)\n         LTR   R15,R15\n         BZ    OP_LT_OK\n         LA    R15,16\n         B     GOBACK\n*\nOP_LT_OK DS    0H\n         MVC   COP+1(1),LEN_GTH+1        SET THE LENGTH OF THE MOVE\nNEXT_LT  DS    0H\n         GET   TABLIN2\nCOP      MVC   0(1,R9),0(R1)             COPY VALUE\n         AH    R9,REC_LEN_GTH            POINT TO NEXT SLOT\n         B     NEXT_LT\nEND_TABLIN2  DS    0H\n         CLOSE TABLIN2\n         ST    R9,TABLE_ADDR_E           SAVE END OF TABLE ADDRESS\n*\n         BR    R8\n*______________________________________________________________________\n*\nINVALID_PARAMETER  DS    0H\n*\n         MVC   MESS_TXT(L'INV_PARM_1),INV_PARM_1\n         BAS   R8,WRITE_LOG\n         MVC   MESS_TXT(72),PARM_CARD\n         BAS   R8,WRITE_LOG\n         MVC   MESS_TXT(L'INV_PARM_2),INV_PARM_2\n         BAS   R8,WRITE_LOG\n         MVC   MESS_TXT(L'INV_PARM_3),INV_PARM_3\n         BAS   R8,WRITE_LOG\n         MVC   MESS_TXT(L'INV_PARM_4),INV_PARM_4\n         BAS   R8,WRITE_LOG\n         LA    R15,16\n         B     GOBACK\n*______________________________________________________________________\n*\nWRITE_LOG  DS    0H\n*\n         LA    R2,MESS_LEN\n         WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY\n         MVI   MESS_TXT,C' '\n         MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n         BR    R8\n*______________________________________________________________________\n*\nTABLE_ADDR     DC    F'0'\nTABLE_ADDR_E   DC    F'0'\nTABLE_LENGTH   DC    F'0'\nREC_LEN_GTH    DC    H'0'\nLEN_GTH        DC    H'0'\nDISP_LACE      DC    H'0'\nMESS_LEN       DC    H'80'\nMESS_TXT       DC    CL80'  '\nTY_PE          DC    C'  '\nFIRST_TIME     DC    C'Y'\n*\nINV_PARM_1     DC    C'E35TABL - INVALID PARAMETER SPECIFIED'\nINV_PARM_2     DC    C'00009,003,IN      WOULD BE VALID'\nINV_PARM_3     DC    C'POSITION AND LENGTH IN RECORD'\nINV_PARM_4     DC    C'LENGTH SPECIFIED MUST NOT EXCEED 256'\nIN_THERE       DC    C'AFTER INIT'\nGOT_ONE        DC    C'RECORD READ'\nEND_JOB        DC    C'END OF INPUT'\nNEVER_H        DC    C'SHOULD NEVER HAPPEN'\n*\nEND_E35TABL    DS    0H\n               LA    R15,16\n               B     GOBACK\n*\nDOUB_WORD      DS    D\nPARM_CARD      DS    CL72\n*\nE35TABLF DCB   DSORG=PS,MACRF=(GL),DDNAME=E35TABL,EODAD=END_E35TABL\nTABLIN1  DCB   DSORG=PS,MACRF=(GL),DDNAME=TABLIN,EODAD=END_TABLIN1\nTABLIN2  DCB   DSORG=PS,MACRF=(GL),DDNAME=TABLIN,EODAD=END_TABLIN2\n*\n         LTORG\n*\nNUM_TAB  DC    256X'FF'\n         ORG   NUM_TAB+C'0'\n         DC    10X'00'\n         ORG\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "E35TABL$": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x18\\x02\\x0f\\x01\\x18\\x02\\x0f\\x16U\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-20T00:00:00", "modifydate": "2018-01-20T16:55:48", "lines": 30, "newlines": 30, "modlines": 0, "user": "SDJRG"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(E35TABL)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   E35TABL\n SETSSI  CB496953\n ENTRY   E35TABL\n NAME    E35TABL(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GENDSN$$": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x17\\x05?\\x01\\x17\\x16_\\x10\\x11\\x00\\x15\\x00\\x12\\x00\\x03\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-06-14T10:11:49", "lines": 21, "newlines": 18, "modlines": 3, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'GETDSNAM ASS/LNK ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*\n//*  NOTE THAT PROCSTEM NEEDS TO BE ASSEMBLED AS WELL\n//*\n//ASM     EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(GETDSNAM)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(GETDSNAM)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(GETDSNAM)\n//*******************************************************\n//LINK    EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(GETDSNAM)\n    ENTRY GETDSNAM\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(GETDSNAM)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETCNCA$": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x176O\\x01\\x176O\\x15X\\x00.\\x00.\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-12-30T00:00:00", "modifydate": "2017-12-30T15:58:09", "lines": 46, "newlines": 46, "modlines": 0, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'GETCNCAT   A/L/R ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*******************************************************\n//ASM01   EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(GETCNCAT)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(GETCNCAT)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(GETCNCAT)\n//*******************************************************\n//COBOL   EXEC PGM=IGYCRCTL,REGION=0M\n//STEPLIB  DD  DISP=SHR,DSN=IGY420.SIGYCOMP\n//*                         SYS1.SIGYCOMP\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.COB(TRYCNCAT)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&LOADSET,UNIT=SYSALLDA,\n//             DISP=(MOD,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(BLKSIZE=3200)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSUT2   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSUT3   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSUT4   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSUT5   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSUT6   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSUT7   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//*******************************************************\n//LINK    EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//         DD  DISP=SHR,DSN=CEE.SCEELKED\n//SYSLIN   DD  DSNAME=&LOADSET,DISP=(OLD,PASS)\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB.POBJ(TRYCNCAT)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n//RUNIT   EXEC PGM=TRYCNCAT,COND=(0,NE)\n//STEPLIB  DD  DISP=SHR,DSN=SDJRG.LOADLIB.POBJ\n//SYSIN    DD  *\n//SYSOUT   DD  SYSOUT=*\n//INDDN    DD  DISP=SHR,DSN=SDJRG.ASM(GETCNCAT)\n//         DD  DISP=SHR,DSN=SDJRG.COB(TRYCNCAT)\n//         DD  DISP=SHR,DSN=SDJRG.ASM(###DOC##)\n//         DD  DISP=SHR,DSN=SDJRG.ASM(#REXPCRE)\n//         DD  DISP=SHR,DSN=SDJRG.ASM(#RXPCRE2)\n//*******************************************************\n//STATUS  EXEC JRGSTAT\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETCNCAT": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x176O\\x01\\x18\\x00\\x1f\\x13U\\x01\\x1e\\x01\\x07\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-12-30T00:00:00", "modifydate": "2018-01-01T13:55:18", "lines": 286, "newlines": 263, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'GETCNCAT - Program to get DSNAME(S) for DDNAME'\n PRINT GEN\n*\nGETCNCAT PRGDEF FSEG=MAIN_BIT,RMODE=24\n*______________________________________________________________________\n*\n* This program acts as a sub-routine to get a list of all\n* datasets concatanated to a DD name.\n*\n*    example call from COBOL\n*\n*         CALL GETCNCAT USING WS-GETCNCAT\n*\n*         set WS-GETCN-DDNAME to the required DDNAME\n*         and WS-GETCN-COUNT-AVAIL to the space in the array\n*             in this case 40.\n*         on return WS-GETCN-DSNAMES will be populated with\n*         the concatanated dataset names, if there is insufficient\n*         space in the array then WS-GETCN-MORE will contain 'Y'\n*\n*         01  WS-GETCNCAT.\n*           03  WS-GETCN-DDNAME        PIC X(8).\n*           03  WS-GETCN-COUNT-AVAIL   PIC S9(4) COMP VALUE 40.\n*           03  WS-GETCN-COUNT-ACTUAL  PIC S9(4) COMP.\n*           03  WS-GETCN-MESSAGE       PIC X(47).\n*           03  WS-GETCN-MORE          PIC X.\n*           03  WS-GETCN-DSNAMES       OCCURS 40.\n*             05  WS-GETCN-DSNAME      PIC X(44).\n*             05  WS-GETCN-MEMNAME     PIC X(8).\n*             05  WS-GETCN-FULL        PIC X(54).\n*             05  WS-GETCN-PATH-LEN    PIC S9(4) COMP.\n*             05  WS-GETCN-PATH-TXT    PIC X(255).\n*______________________________________________________________________\n*\nATIOT                  DS    F\nTHE_VALUE              DS    CL54\n                       ORG   THE_VALUE\nTHE_DSNAME             DS    CL44\nOPEN_PARENTHESES       DS    CL1\nTHE_MEMNAME            DS    CL8\nCLOSE_PARENTHESES      DS    CL1\n                       ORG\n*\nERR_NO                 DS    CL1\n*\n        PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   USING WS_GETCNCAT,R10\n   USING WS_LIST,R9\n   USING ARA,R4\n   USING IHADCB,TESTDCB\n*\n   L     R10,0(,R1)                    get parameter address\n   LA    R9,WS_GETCN_DSNAMES           point to list in parameter\n*\n   MVI   THE_VALUE,C' '\n   MVC   THE_VALUE+1(L'THE_VALUE-1),THE_VALUE\n   MVI   WS_GETCN_MESSAGE,C' '\n   MVC   WS_GETCN_MESSAGE+1(L'WS_GETCN_MESSAGE-1),WS_GETCN_MESSAGE\n   XC    WS_GETCN_COUNT_ACTUAL,WS_GETCN_COUNT_ACTUAL\n   MVI   WS_GETCN_MORE,C'N'\n*\n   SEGDO CHECK_FOR_DDNAME\n*\n   SEGDO GET_DSNAME\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS CHECK_FOR_DDNAME\n*\n   SEGDO GET_TIOT_ADDRESS\n*\n   L     R2,ATIOT\n   USING TIOT1,R2\n*\n   LA    R14,TIOENTRY\n   DROP  R2\n   USING TIOENTRYD,R14\n   XR    R2,R2                         length register\n   DO INF\n     ICM   R2,1,TIOELNGH               get entry length\n   DOEXIT (LTR,R2,R2,Z)                zero length, DDNAME not found\n   DOEXIT (CLC,TIOEDDNM,EQ,WS_GETCN_DDNAME)\n     AR   R14,R2                       next entry\n   ENDDO\n*\n   IF (LTR,R2,R2,Z)                    could not find DDNAME\n     MVI   ERR_NO,1\n     SEGDO NOT_VALID\n   ENDIF\n*\n SEGE CHECK_FOR_DDNAME\n*______________________________________________________________________\n*\n SEGS GET_DSNAME\n*\n   LA    R8,TESTDCB                    point to test DCB\n   MVC   DCBDDNAM,WS_GETCN_DDNAME      copy DDNAME\n   OI    ARLOPT1,ARLUSS                get USS path name\n   RDJFCB  ((R8))                      get list of allocated files\n   IF (LTR,R15,R15,NZ)\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ENDIF\n*  if there is only 1 dataset allocated then the details are in\n*  INFMJFCB otherwise all the details are placed in a getmained\n*  area of storage and the code needs to look at them in turn\n   L     R4,ARLAREA\n   USING ARA,R4\n   LH    R5,ARLRTRVD\n   IF (LTR,R5,R5,NZ)                     anything here\n     DO FROM=(R5)\n       MVC   INFMJFCB(JFCBLGTH),ARAJFCB  copy next dataset details\n       SEGDO PROC_DATASET_DETS           process this one\n       AH    R4,ARALEN                   point to next\n     DOEXIT (CLI,WS_GETCN_MORE,EQ,C'Y')  no more space in caller\n     ENDDO\n*    having processed all the datasets free the storage\n     L     R2,ARLAREA\n     XR    R5,R5\n     ICM   R5,B'0111',ARLRLEN\n     XR    R15,R15\n     IC    R15,ARLPOOL\n     FREEMAIN RU,LV=(R5),A=(R2),SP=(R15)\n   ELSE\n     SEGDO PROC_DATASET_DETS\n   ENDIF\n*\n SEGE GET_DSNAME\n*______________________________________________________________________\n*\n SEGS PROC_DATASET_DETS\n*\n   LH    R1,WS_GETCN_COUNT_ACTUAL\n   LA    R1,1(,R1)\n   IF (CH,R1,GT,WS_GETCN_COUNT_AVAIL)  are the slots full ?\n     MVI   WS_GETCN_MORE,C'Y'          yes\n     SEGQUIT                           quit segment\n   ENDIF\n   STH   R1,WS_GETCN_COUNT_ACTUAL\n   XC    WS_GETCN_PATH_LEN,WS_GETCN_PATH_LEN\n   XC    WS_GETCN_PATH_TXT,WS_GETCN_PATH_TXT\n   IF (CLC,=C'...PATH=.SPECIFIED...',EQ,JFCBDSNM)\n     MVI   WS_GETCN_FULL,C' '          wipe to spaces\n     MVC   WS_GETCN_FULL+1(L'WS_GETCN_FULL-1),WS_GETCN_FULL\n     MVC   WS_GETCN_DSNAME,WS_GETCN_FULL\n     MVC   WS_GETCN_MEMNAME,WS_GETCN_FULL\n     IF (TM,ARAFLG,ARAXINF,NZ)         is the extended info there ?\n       XR    R3,R3\n       IC    R3,ARAXINOF               get length in double words\n       SLL   R3,3                      multiply by 8\n       AR    R3,R4                     point to extended info\n       IF (CLC,2(2,R3),NE,=H'0')       is pathname there\n         AH    R3,2(,R3)               offset to pathname\n         MVC   WS_GETCN_PATH_LEN,0(R3)\n         MVC   WS_GETCN_PATH_TXT,2(R3)\n       ENDIF\n     ENDIF\n   ELSE\n     MVC   THE_DSNAME,JFCBDSNM         copy dataset name\n     MVC   THE_MEMNAME,JFCBELNM        and member name (if there)\n     MVC   WS_GETCN_DSNAME,JFCBDSNM    copy dataset name\n     MVC   WS_GETCN_MEMNAME,JFCBELNM   and member name (if there)\n     IF (CLC,THE_MEMNAME,GT,SPACES)    is member name present ?\n       MVI   OPEN_PARENTHESES,C'('     put in the brackets\n       MVI   CLOSE_PARENTHESES,C')'\n     ELSE\n       MVI   OPEN_PARENTHESES,C' '     remove the brackets\n       MVI   CLOSE_PARENTHESES,C' '\n     ENDIF\n     TRIM  THE_VALUE,L'THE_VALUE,ALL=Y\n     MVC   WS_GETCN_FULL,THE_VALUE\n   ENDIF\n*\n   LA    R9,WS_LIST_NEXT               point to next slot\n*\n SEGE PROC_DATASET_DETS\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   WS_GETCN_MESSAGE(21),=C'Could not find DDNAME'\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   WS_GETCN_MESSAGE(15),=C'Error in RDJFCB'\n   ENDIF\n*\n   PRGQUIT RC=4\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n SEGS GET_TIOT_ADDRESS\n*\n   L     R1,CVTPTR                     get CVT address\n   L     R1,CVTASVT-CVT(R1)            get ASVT table @\n   LA    R1,ASVTENTY-ASVT(R1)          get @ of ASCB entry table\n*\n   XR    R2,R2                         clear R2 prior to access\n   EPAR  R2                            go get ASID\n   BCTR  R2,0                          subtract  1\n   MH    R2,=H'4'                      multiply by  4\n   L     R1,0(R2,R1)                   get @ from offset in table\n   L     R1,ASCBASXB-ASCB(R1)          get address space extension\n   TM    ASCBCS1-ASCB(R1),ASCBXMPA\n   L     R1,ASXBITCB-ASXB(R1)          get TCB\n   L     R1,TCBTIO-TCB(R1)             get TIOT\n   ST    R1,ATIOT                      save address\n*\n SEGE GET_TIOT_ADDRESS\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n           PRGSTAT\n*\nSPACES     DC    80CL1' '\n*\n           LTORG\n*______________________________________________________________________\n*\nTESTDCB    DCB   DDNAME=XXXXXXXX,MACRF=(GL),DSORG=PS,EXLST=LIST1\nLIST1      DS    0F\n           DC    X'13',AL3(MY_JFCB_13)   list 13\n           DC    X'87',AL3(MY_JFCB_07)   list 07 (8 means last one)\n*______________________________________________________________________\n*\nMY_JFCB_07     DS    0F\n               PUSH  PRINT,NOPRINT\n               PRINT GEN\n               IEFJFCBN\n               POP   PRINT,NOPRINT\nLEN_MY_JFCB_07 EQU   *-MY_JFCB_07\n*______________________________________________________________________\n*\n               PUSH  PRINT,NOPRINT\n               PRINT GEN\n               DCBD  DSORG=QS,DEVD=DA\n               POP   PRINT,NOPRINT\n               JRGTIOT\n*\nGETCNCAT       CSECT\n*\n               PUSH  PRINT,NOPRINT\n               PRINT GEN\nMY_JFCB_13     IHAARL DSECT=NO\n               IHAARA\n               POP   PRINT,NOPRINT\n*\nGETCNCAT       CSECT\n*______________________________________________________________________\n*\n         CVT   DSECT=YES,LIST=NO\n         IHAASCB LIST=NO\n         IHAASXB LIST=NO\n         IHAASVT LIST=NO\n         IKJTCB  LIST=NO\n*\nWS_GETCNCAT            DSECT\nWS_GETCN_DDNAME        DS    CL8\nWS_GETCN_COUNT_AVAIL   DS    H\nWS_GETCN_COUNT_ACTUAL  DS    H\nWS_GETCN_MESSAGE       DS    CL47\nWS_GETCN_MORE          DS    C\nWS_GETCN_DSNAMES       EQU   *\nWS_LIST                DSECT\nWS_GETCN_DSNAME        DS    CL44\nWS_GETCN_MEMNAME       DS    CL8\nWS_GETCN_FULL          DS    CL54\nWS_GETCN_PATH_LEN      DS    H\nWS_GETCN_PATH_TXT      DS    CL255\nWS_LIST_NEXT           EQU   *\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDSNA$": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x17\\x05?\\x01\\x17\\x05?\\x19\\x11\\x00\\x1e\\x00\\x12\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-02-22T19:11:22", "lines": 30, "newlines": 18, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(GETDSNAM)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   GETDSNAM\n SETSSI  CB496953\n ENTRY   GETDSNAM\n NAME    GETDSNAM(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETDSNAM": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x01\\x01\\x17\\x15\\x1f\\x01\\x18\\x00\\x1f\\x13\\x13\\x01v\\x01`\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-05-31T00:00:00", "modifydate": "2018-01-01T13:13:01", "lines": 374, "newlines": 352, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'GETDSNAM - REXX function to get DSNAME(S) for DDNAME'\n PRINT GEN\n*\nGETDSNAM PRGDEF FSEG=MAIN_BIT,RMODE=24,REXX=Y\n*______________________________________________________________________\n*\n* This program acts as a REXX function\n*\n*    INPUT\n*         DDNAME to look for\n*         Name of a STEM variable\n*\n*    OUTPUT\n*         IF   successfull\n*              RC=0\n*              STEM variable contains DSNAMES on the DDNAME\n*         ELSE\n*              RC=Error message\n*         ENDIF\n*______________________________________________________________________\n*\n* EXAMPLE USAGE\n*\n* /*REXX*/\n*   \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('MY.LOAD.LIBRARY')\"\n*   MY_DDN  = \"ISPSLIB\"\n*   MY_STEM = \"WANG\"\n*\n*   DROP WANG.\n*\n*   RE_SPONSE = GETDSNAM(MY_DDN,MY_STEM)\n*   IF  RE_SPONSE = 0 THEN DO\n*      DO LO_OP_R = 1 TO WANG.0\n*         SAY  WANG.LO_OP_R\n*      END\n*   END\n*   DROP WANG.\n*   \"ISPEXEC LIBDEF ISPLLIB \"\n*   EXIT\n*______________________________________________________________________\n*\n*                        PARAMETERS\n*______________________________________________________________________\n*\n*\n*  PARAMETER 1    -    DDNAME\n*  PARAMETER 2    -    STEM VARIABLE NAME\n*\n*______________________________________________________________________\n*\n*  REENTRANT STORAGE\n*\nUSE_DDNAME           DS    CL8\n*\n                     PRGSTEM\n*\nATIOT                DS    F\nTHE_VALUE            DS    CL54\n                     ORG   THE_VALUE\nTHE_DSNAME           DS    CL44\nOPEN_PARENTHESES     DS    CL1\nTHE_MEMNAME          DS    CL8\nCLOSE_PARENTHESES    DS    CL1\n                     ORG\n*\nERR_NO               DS    CL1\n*\n        PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   USING ARA,R4\n   USING IHADCB,TESTDCB\n*\n   MVI   THE_VALUE,C' '\n   MVC   THE_VALUE+1(L'THE_VALUE-1),THE_VALUE\n*\n   SEGDO GET_ARGUMENTS\n*\n   SEGDO CHECK_FOR_DDNAME\n*\n   SEGDO GET_DSNAME\n*\n   MVI   EVALBLOCK_EVDATA,C' '\n   MVC   EVALBLOCK_EVDATA+1(80),EVALBLOCK_EVDATA\n   MVI   EVALBLOCK_EVDATA,C'0'\n   LA    R1,1\n   ST    R1,EVALBLOCK_EVLEN\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS GET_ARGUMENTS\n*\n   MVC   USE_DDNAME,SPACES\n*\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,1\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'8')\n     MVI   ERR_NO,3\n     SEGDO NOT_VALID\n   ENDIF\n   L     R15,ARGTABLE_ARGSTRING_PTR\n   L     R14,ARGTABLE_ARGSTRING_LENGTH\n   BCTR  R14,0\n   LA    R1,USE_DDNAME\n   EX    R14,COPY_ARGUMENT\n   OC    USE_DDNAME,SPACES             ensure uppercase\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for second argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,4\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,5\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'8')\n     MVI   ERR_NO,6\n     SEGDO NOT_VALID\n   ENDIF\n   MVC   STEM_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   STEM_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for third argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n     MVI   ERR_NO,7\n     SEGDO NOT_VALID\n   ENDIF\n*\n   MVI   STEM_TRIM_VAR,C'Y'            say trim all spaces from var\n   MVHHI STEM_FUNCTION,1               init STEM.0\n   SEGDO CALL_PROCSTEM\n*\n SEGE GET_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS CHECK_FOR_DDNAME\n*\n   SEGDO GET_TIOT_ADDRESS\n*\n   L     R2,ATIOT\n   USING TIOT1,R2\n*\n   LA    R4,TIOENTRY\n   DROP  R2\n   USING TIOENTRYD,R4\n   XR    R2,R2                         length register\n   DO INF\n     ICM   R2,1,TIOELNGH               get entry length\n   DOEXIT (LTR,R2,R2,Z)                zero length, DDNAME not found\n   DOEXIT (CLC,TIOEDDNM,EQ,USE_DDNAME)\n     AR   R4,R2                        next entry\n   ENDDO\n*\n   IF (LTR,R2,R2,Z)                    could not find DDNAME\n     MVI   ERR_NO,8\n     SEGDO NOT_VALID\n   ENDIF\n*\n SEGE CHECK_FOR_DDNAME\n*______________________________________________________________________\n*\n SEGS GET_DSNAME\n*\n   LA    R8,TESTDCB                    point to test DCB\n   MVC   DCBDDNAM,USE_DDNAME           copy DDNAME\n   OI    ARLOPT1,ARLUSS                get USS path name\n   RDJFCB  ((R8))                      get list of allocated files\n   IF (LTR,R15,R15,NZ)\n     MVI   ERR_NO,9\n     SEGDO NOT_VALID\n   ENDIF\n*  if there is only 1 dataset allocated then the details are in\n*  INFMJFCB otherwise all the details are placed in a getmained\n*  area of storage and the code needs to look at them in turn\n   L     R4,ARLAREA\n   USING ARA,R4\n   LH    R5,ARLRTRVD\n   IF (LTR,R5,R5,NZ)                   anything here\n     DO FROM=(R5)\n       MVC   INFMJFCB(JFCBLGTH),ARAJFCB  copy next dataset details\n       SEGDO PROC_DATASET_DETS\n       AH    R4,ARALEN                 point to next\n     ENDDO\n*    having processed all the datasets free the storage\n     L     R2,ARLAREA\n     XR    R5,R5\n     ICM   R5,B'0111',ARLRLEN\n     XR    R15,R15\n     IC    R15,ARLPOOL\n     FREEMAIN RU,LV=(R5),A=(R2),SP=(R15)\n   ELSE\n     SEGDO PROC_DATASET_DETS\n   ENDIF\n*\n   MVHHI STEM_FUNCTION,3               set STEM.0 to total lines\n   SEGDO CALL_PROCSTEM\n*\n SEGE GET_DSNAME\n*______________________________________________________________________\n*\n SEGS PROC_DATASET_DETS\n*\n   IF (CLC,=C'...PATH=.SPECIFIED...',EQ,JFCBDSNM)\n     IF (TM,ARAFLG,ARAXINF,NZ)         is the extended info there ?\n       XR    R3,R3\n       IC    R3,ARAXINOF               get length in double words\n       SLL   R3,3                      multiply by 8\n       AR    R3,R4                     point to extended info\n       IF (CLC,2(2,R3),NE,=H'0')       is pathname there\n         AH    R3,2(,R3)               offset to pathname\n         LH    R1,0(R3)                get length of pathname\n         ST    R1,STEM_TEXT_LEN        and put in STEM length\n         LA    R1,2(,R3)               address of pathname\n         ST    R1,STEM_TEXT_ADR        and put in STEM address\n         MVHHI STEM_FUNCTION,2         set STEM value\n         SEGDO CALL_PROCSTEM\n       ENDIF\n     ENDIF\n   ELSE\n     MVC   THE_DSNAME,JFCBDSNM         copy dataset name\n     MVC   THE_MEMNAME,JFCBELNM        and member name (if there)\n     IF (CLC,THE_MEMNAME,GT,SPACES)    if member name present\n       MVI   OPEN_PARENTHESES,C'('     put in the brackets\n       MVI   CLOSE_PARENTHESES,C')'\n     ELSE\n       MVI   OPEN_PARENTHESES,C' '     remove the brackets\n       MVI   CLOSE_PARENTHESES,C' '\n     ENDIF\n     LA    R1,THE_VALUE\n     ST    R1,STEM_TEXT_ADR\n     LA    R1,L'THE_VALUE\n     ST    R1,STEM_TEXT_LEN\n     MVHHI STEM_FUNCTION,2             set STEM value\n     SEGDO CALL_PROCSTEM\n   ENDIF\n*\n SEGE PROC_DATASET_DETS\n*______________________________________________________________________\n*\n SEGS CALL_PROCSTEM\n*\n   LA    R1,STEM_AREA                  point to PRGSTEM area\n   ST    R1,MY_P_1                     save as first parm\n   LA    R1,MY_PARM                    point to parameter list\n   L     R15,=V(PROCSTEM)              get program address\n   BASR  R14,R15                       go and set stem value\n   IF (LTR,R15,R15,NZ)                 error ?\n     ST    R15,R_C                     set return code\n     PRGQUIT                           QUIT\n   ENDIF\n*\n SEGE CALL_PROCSTEM\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 not entered'\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 was zero length'\n   ELSEIF (CLI,ERR_NO,EQ,3)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 > 8 bytes'\n   ELSEIF (CLI,ERR_NO,EQ,4)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 not entered'\n   ELSEIF (CLI,ERR_NO,EQ,5)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 was zero length'\n   ELSEIF (CLI,ERR_NO,EQ,6)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 > 8 bytes'\n   ELSEIF (CLI,ERR_NO,EQ,7)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Third argument supplied'\n   ELSEIF (CLI,ERR_NO,EQ,8)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Could not find DDNAME'\n   ELSEIF (CLI,ERR_NO,EQ,9)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Error in RDJFCB'\n   ELSE\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Unknown error, rc='\n     XR    R1,R1\n     IC    R1,ERR_NO\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  EVALBLOCK_EVDATA+18(4),DOUB_WORD\n     XC    R_C,R_C\n   ENDIF\n   MVC   EVALBLOCK_EVLEN,=F'30'\n*\n   PRGQUIT\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n SEGS GET_TIOT_ADDRESS\n*\n   L      R1,CVTPTR                    get CVT address\n   L      R1,CVTASVT-CVT(R1)           get ASVT table @\n   LA     R1,ASVTENTY-ASVT(R1)         get @ of ASCB entry table\n*\n   XR     R2,R2                        clear R2 prior to access\n   EPAR   R2                           go get ASID\n   BCTR   R2,0                         subtract  1\n   MH     R2,=H'4'                     multiply by  4\n   L      R1,0(R2,R1)                  get @ from offset in table\n   L      R1,ASCBASXB-ASCB(R1)         get address space extension\n   TM     ASCBCS1-ASCB(R1),ASCBXMPA\n   L      R1,ASXBITCB-ASXB(R1)         get TCB\n   L      R1,TCBTIO-TCB(R1)            get TIOT\n   ST     R1,ATIOT                     save address\n*\n SEGE GET_TIOT_ADDRESS\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n           PRGSTAT\n*\nCOPY_ARGUMENT  MVC   0(1,R1),0(R15)\nDO_MOVE        MVC   0(1,R3),0(R1)\n*\nSPACES     DC    80CL1' '\n*\n           LTORG\n*______________________________________________________________________\n*\nTESTDCB    DCB   DDNAME=XXXXXXXX,MACRF=(GL),DSORG=PS,EXLST=LIST1\nLIST1      DS    0F\n           DC    X'13',AL3(MY_JFCB_13)\n           DC    X'87',AL3(MY_JFCB_07)\n*______________________________________________________________________\n*\nMY_JFCB_07     DS    0F\n               PUSH  PRINT,NOPRINT\n               PRINT GEN\n               IEFJFCBN\n               POP   PRINT,NOPRINT\nLEN_MY_JFCB_07 EQU   *-MY_JFCB_07\n*______________________________________________________________________\n*\n         PUSH  PRINT,NOPRINT\n         PRINT GEN\n         DCBD  DSORG=QS,DEVD=DA\n         POP   PRINT,NOPRINT\n         JRGTIOT\n*\nGETDSNAM CSECT\n*\n           PUSH  PRINT,NOPRINT\n           PRINT GEN\nMY_JFCB_13 IHAARL DSECT=NO\n           IHAARA\n           POP   PRINT,NOPRINT\n*\nGETDSNAM CSECT\n*______________________________________________________________________\n*\n         CVT   DSECT=YES,LIST=NO\n         IHAASCB LIST=NO\n         IHAASXB LIST=NO\n         IHAASVT LIST=NO\n         IKJTCB  LIST=NO\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JRGULOA$": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x19\\x02/\\x01\\x19\\x02/\\x06S\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-01-22T00:00:00", "modifydate": "2019-01-22T06:53:20", "lines": 19, "newlines": 19, "modlines": 0, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'JRGULOAD   A/L/R ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*******************************************************\n//ASM01   EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(JRGULOAD)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(JRGULOAD)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(JRGULOAD)\n//*******************************************************\n//LINK1   EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(JRGULOAD)\n    ENTRY JRGULOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(JRGULOAD)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRGULOAD": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x10\\x01\\x19\\x02/\\x01\\x19\\x02\\x8f\\x16\\x16\\x01\\xaf\\x01\\xa0\\x01\\xaf\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-01-22T00:00:00", "modifydate": "2019-01-28T16:16:10", "lines": 431, "newlines": 416, "modlines": 431, "user": "SDJRG"}, "text": " TITLE 'JRGULOAD - UNLOAD A PDS TO A SEQUENTIAL FILE'\n*______________________________________________________________________\n*\nJRGULOAD PRGDEF  FSEG=MAIN_PART,RMODE=24\n*\n*  This unloads selected members of a PDS in IEBUPDTE format.\n*\n*  Use PGM=JRGULOAD,PARM=NOSTATS if statistics are not required.\n*\n*  This reads parameters to get get member names to select and then\n*  outputs the contents of the members preceeded by\n*  './ ADD NAME=????????'\n*\n*  PDSIN is the PDS and OUTPUT is the sequential file.\n*\n*  A restriction is that the RECFM and LRECL of PDSIN and OUTPUT\n*  must match.\n*\n*  SYSIN should contain a list of member names in column 1 (as many\n*  as required) or a pattern such as '********' or 'AB123***'\n*\nTTR_ADDR       DS    F\nTAB_SYSIN_L          DS    F\nTAB_SYSIN_A          DS    F\nTAB_SYSIN_A_END      DS    F\nLEN_STATS      DS    H\nPARM_LEN       DS    H\nPARM_VALUE     DS    CL80\nSYSIN_REC      DS    CL80              input record\nSYSOUT_REC     DS    CL80\nEOF_SYSIN      DS    CL1\nMATCH_ED       DS    CL1\nDO_STATS       DS    CL1\nEND_OF_MEMBER  DS    CL1\nTEST_MEMBER    DS    CL8\nMEMBER_COUNT   DS    PL7\nTOT_REC_COUNT  DS    PL7\n*\nPDS      USING IHADCB,PDSIN            map DCBD over PDSIN\nOUT      USING IHADCB,OUTPUT           map DCBD over OUTPUT\n*\nMAP_THEM DSECT\n         DS    0D\nM_NAME   DS    CL8\nM_NAME2  DS    CL8\nM_NEXT   EQU   *\nM_LEN    EQU   *-M_NAME\n*\n         PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   MVI   DO_STATS,C'Y'                 default to preserve statistics\n   PRGPARM PARM_VALUE,LEN=PARM_LEN\n   IF (CLC,=C'NOSTATS ',EQ,PARM_VALUE)\n     MVI   DO_STATS,C'N'               statistics not wanted\n   ENDIF\n   MVI   SYSOUT_REC,C' '\n   MVC   SYSOUT_REC+1(L'SYSOUT_REC-1),SYSOUT_REC\n   ZAP   MEMBER_COUNT,=P'0'\n   ZAP   TOT_REC_COUNT,=P'0'\n   SEGDO OPEN_SYSOUT\n*\n   SEGDO OPEN_PDSIN\n*\n   SEGDO LOAD_SYSIN\n*\n   SEGDO PROCESS_MEMBERS\n*\n   SEGDO CLOSE_PDSIN\n*\n   SEGDO PUT_SYSOUT\n   MVC   SYSOUT_REC+1(L'EDPAT),EDPAT\n   ED    SYSOUT_REC+1(L'EDPAT),MEMBER_COUNT\n   MVC   SYSOUT_REC+1+L'EDPAT(8),=C' members'\n   MVC   SYSOUT_REC+1+L'EDPAT+8(L'EDPAT),EDPAT\n   ED    SYSOUT_REC+1+L'EDPAT+8(L'EDPAT),TOT_REC_COUNT\n   MVC   SYSOUT_REC+1+L'EDPAT+8+L'EDPAT(14),=C' total records'\n   SEGDO PUT_SYSOUT\n*\n   SEGDO CLOSE_SYSOUT\n*\n   L     R2,TAB_SYSIN_L\n   L     R1,TAB_SYSIN_A\n   IF (LTR,R1,R1,NZ)\n     FREEMAIN RU,LV=(R2),A=(R1)\n   ENDIF\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS LOAD_SYSIN\n*\n   ZAP   DOUB_WORD,=P'0'\n   SEGDO OPEN_SYSIN\n   DO INF\n     SEGDO GET_SYSIN\n   DOEXIT (CLI,EOF_SYSIN,EQ,C'Y')       exit on end of file\n     AP    DOUB_WORD,=P'1'              increment record count\n   ENDDO\n   SEGDO CLOSE_SYSIN\n*\n   IF (CP,DOUB_WORD,EQ,=P'0')           no input so quit\n     MVC   SYSOUT_REC(32),=C'SYSIN contained no control cards'\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n*\n   CVB   R2,DOUB_WORD\n   MH    R2,=AL2(M_LEN)\n   ST    R2,TAB_SYSIN_L                 length of table\n   GETMAIN RU,LV=(R2),LOC=31\n   ST    R1,TAB_SYSIN_A                 save address of table\n   AR    R1,R2\n   ST    R1,TAB_SYSIN_A_END             set end of table\n*\n   PUSH  USING\n   USING MAP_THEM,R4\n*\n   L     R4,TAB_SYSIN_A                 address of input\n   SEGDO OPEN_SYSIN\n   DO INF\n     SEGDO GET_SYSIN\n   DOEXIT (CLI,EOF_SYSIN,EQ,C'Y')\n   DOEXIT (CLC,SYSIN_REC(2),EQ,=C'/*')\n     MVC   M_NAME,SYSIN_REC\n     TR    M_NAME,TRTAB                 translate member to skeletal\n     MVC   M_NAME2,M_NAME               forms 1 and 2 in M_NAME\n     TR    M_NAME2,TRTAB1               and M_NAME2\n     LA    R4,M_NEXT\n     MVC   SYSOUT_REC(72),SYSIN_REC     copy record to output\n     SEGDO PUT_SYSOUT\n   ENDDO\n   SEGDO CLOSE_SYSIN                    close the SYSIN file\n   SEGDO PUT_SYSOUT                     output blank line\n*\n   POP   USING\n*\n SEGE LOAD_SYSIN\n*______________________________________________________________________\n*\n SEGS PROCESS_MEMBERS\n*\n   OPEN  (MEMLIST,INPUT)\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=16\n   ENDIF\n*\n   DO INF\n     GET   MEMLIST\n     LH    R3,0(R1)                    number of active bytes in block\n     LA    R3,0(R3,R1)                 point to end of block\n     LA    R9,2(0,R1)                  jump past length\n     DO INF\n     DOEXIT (CR,R9,GE,R3)              at end of the block\n     DOEXIT (CLC,0(8,R9),EQ,HIGHVALS)  end of directory\n     DOEXIT (CLC,0(8,R9),EQ,LOWVALS)   not wanted\n       L     R1,8(R9)\n       STCM  R1,B'1110',TTR_ADDR       track address of member\n       SLL   R1,27                     last byte contains length of\n       SRL   R1,26                     ..user data in halfwords so dump\n       STH   R1,LEN_STATS              ..the rest and make it bytes\n       SEGDO CHECK_MEMBER_WANTED\n       LA    R9,12(,R9)                add standard length\n       AH    R9,LEN_STATS              plus length of user stats\n     ENDDO\n   DOEXIT (CLC,0(8,R9),EQ,HIGHVALS)    thats all\n   ENDDO\n*\nERR      DS    0H\nDIREND   DS    0H\n*\n   CLOSE MEMLIST\n*\n SEGE PROCESS_MEMBERS\n*______________________________________________________________________\n*\n SEGS CHECK_MEMBER_WANTED\n*\n   PUSH  USING\n   USING MAP_THEM,R14\n*\n   L     R14,TAB_SYSIN_A                address of required members\n   DO INF\n   DOEXIT (C,R14,GE,TAB_SYSIN_A_END)\n     MVC   TEST_MEMBER,0(R9)            copy member name\n     OC    TEST_MEMBER,M_NAME2          transform to test\n     IF (CLC,TEST_MEMBER(8),EQ,M_NAME)  do we want this ?\n       IF (TM,11(R9),X'80',NZ)          member is an alias\n         MVC   SYSOUT_REC(8),0(R9)\n         MVC   SYSOUT_REC+12(L'NOT_SEL_ALIAS),NOT_SEL_ALIAS\n         SEGDO PUT_SYSOUT\n       ELSEIF (TM,11(R9),X'60',NZ)      TTR's in user data\n         MVC   SYSOUT_REC(8),0(R9)\n         MVC   SYSOUT_REC+12(L'NOT_SEL_TTR),NOT_SEL_TTR\n         SEGDO PUT_SYSOUT\n       ELSE\n         SEGDO OUTPUT_MEMBER\n       ENDIF\n       L     R14,TAB_SYSIN_A_END\n     ENDIF\n     LA    R14,M_NEXT\n   ENDDO\n*\n   POP   USING\n*\n SEGE CHECK_MEMBER_WANTED\n*______________________________________________________________________\n*\n SEGS OUTPUT_MEMBER\n*\n   MVC   SYSOUT_REC(8),0(R9)\n   MVC   SYSOUT_REC+12(16),=CL16'member selected'\n   SEGDO PUT_SYSOUT\n   AP    MEMBER_COUNT,=P'1'\n*\n   IF (TM,OUT.DCBRECFM,DCBRECF,NZ)     fixed records\n     LA    R6,IEB_CARD+4\n   ELSE\n     LA    R6,IEB_CARD                 else variable\n   ENDIF\n   MVC   IEB_CARD+4+12(8),0(R9)        copy member name\n   MVC   IEB_CARD+4+12+8(2),=X'FACE'   set indicator bytes\n*\n   IF (CLI,DO_STATS,EQ,C'Y')\n     LH   R1,LEN_STATS\n     IF (LTR,R1,R1,P)                  if something there\n       EX    R1,COPY_STATS             copy length byte + stats\n       IF (TM,OUT.DCBRECFM,DCBRECV,NZ) variable records\n         LHI   R15,26                  normal length\n         LA    R15,1(R1,R15)           add stats length\n         STH   R15,IEB_CARD            save new length\n       ENDIF\n     ELSE\n       MVC   IEB_CARD(2),=H'26'        set record length (variable)\n     ENDIF\n   ENDIF\n   SEGDO PUT_OUTPUT\n   MVI   IEB_CARD+4+12,C' '            wipe to blanks\n   MVC   IEB_CARD+4+13(60),IEB_CARD+4+12\n*\n   FIND  PDSIN,TTR_ADDR,C\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=100\n   ENDIF\n   MVI   END_OF_MEMBER,C'N'\n   XR    R6,R6\n   XR    R7,R7\n   XR    R8,R8\n*\n   DO INF\n     SEGDO GET_NEXT_RECORD\n   DOEXIT (CLI,END_OF_MEMBER,EQ,C'Y')\n   ENDDO\n*\n SEGE OUTPUT_MEMBER\n*______________________________________________________________________\n*\n SEGS GET_NEXT_RECORD\n*\n   IF (CR,R6,GE,R8)\n     SEGDO READ_PDSIN\n   ENDIF\n*\n   IF (CLI,END_OF_MEMBER,EQ,C'N')\n     SEGDO PUT_OUTPUT\n     AP    TOT_REC_COUNT,=P'1'\n   ENDIF\n*\n   IF (TM,PDS.DCBRECFM,DCBRECV,NZ)     variable records\n     AH    R6,0(R6)\n   ELSE\n     LA    R6,0(R7,R6)                 point to next record in block\n   ENDIF\n*\n SEGE GET_NEXT_RECORD\n*______________________________________________________________________\n*\n SEGS READ_PDSIN\n*\n   MVI   END_OF_MEMBER,C'N'\n   READ  DECB1,SF,PDSIN,REC_AREA,'S'\n   CHECK DECB1\n   B     *+8                           branch after the MVI\nEND_PDSIN  DS    0H\n   MVI   END_OF_MEMBER,C'Y'\n*\n   IF (CLI,END_OF_MEMBER,EQ,C'N')\n     LA    R6,REC_AREA\n     LH    R7,PDSIN+82                 get record length\n     L     R1,DECB1+16                 point to status area\n     LH    R8,PDSIN+62                 get blocksize\n     SH    R8,14(,R1)                  subtract residual count to\n     LA    R8,0(R6,R8)                 point past block\n     IF (TM,PDS.DCBRECFM,DCBRECV,NZ)   if variable records\n       LA    R6,4(,R6)                 point after block length\n     ENDIF\n   ENDIF\n*\n SEGE READ_PDSIN\n*______________________________________________________________________\n*\n SEGS OPEN_PDSIN\n*\n   OPEN  (PDSIN,INPUT)\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=35\n   ELSEIF (TM,PDS.DCBDSRG1,DCBDSGPO,Z)\n     MVC   SYSOUT_REC(L'PDS_NOT),PDS_NOT\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n*\n   MVC   OUT.DCBLRECL,PDS.DCBLRECL     copy block size\n   MVC   OUT.DCBBLKSI,PDS.DCBBLKSI          record format\n   MVC   OUT.DCBRECFM,PDS.DCBRECFM          record length\n   XC    IEB_CARD(4),IEB_CARD          allow for cariable record\n   MVC   IEB_CARD(2),=H'26'            set record length (variable)\n   MVC   IEB_CARD+4(12),=CL12'./ ADD NAME='    IEBUPDTE card\n*\n   SEGDO OPEN_OUTPUT\n*\n SEGE OPEN_PDSIN\n*______________________________________________________________________\n*\n SEGS CLOSE_PDSIN\n*\n   SEGDO CLOSE_OUTPUT\n*\n   CLOSE PDSIN\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=38\n   ENDIF\n*\n SEGE CLOSE_PDSIN\n*______________________________________________________________________\n*\n SEGS OUTPUT_REQUIREMENTS\n*\n*  Output how to use this program\n*\n   SEGDO PUT_SYSOUT\n   LA    R4,REQ_MNT                    point to output text\n   LH    R3,REQ_CNT                    count of lines\n   DO FROM=(R3)\n     LH    R1,0(,R4)                   get length of message -1\n     EX    R1,COPY_2_SYSOUT            copy message\n     LA    R4,3(R1,R4)                 point to next message\n     SEGDO PUT_SYSOUT\n   ENDDO\n*\n SEGE OUTPUT_REQUIREMENTS\n*______________________________________________________________________\n*\n PRGDCBI DCB=SYSIN,REC=SYSIN_REC,EOF=EOF_SYSIN\n*\n PRGDCBO DCB=OUTPUT,REC=0(R6),CLEAR=N\n*\n PRGDCBO DCB=SYSOUT,REC=SYSOUT_REC\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nCOPY_STATS     MVC   IEB_CARD+4+12+10(0),11(R9)\nCOPY_2_SYSOUT  MVC   SYSOUT_REC(0),2(R4) copy message text\nLOWVALS        DC    8XL1'00'\nHIGHVALS       DC    8XL1'FF'\n*\nEDPAT          DC    X'4020202020202020202020202120'\nIEB_CARD       DC    CL84' '\nEOF_MEMLIST    DC    C'N'\n*\nNOT_SEL_ALIAS  DC    C'not selected - it is an alias'\nNOT_SEL_TTR    DC    C'not selected - user TTR present'\n*\nPDS_NOT  DC    C'//PDSIN    DD  ...         must be a PDS'\n*\nREQ_CNT  DC    H'6'                    count of instructions\nREQ_MNT  EQU   *                       start of instructions\nRQ_0     DC    AL2((RQ_1-RQ_0)-3)      length of message -1\n         DC    C'   Instructions for use'\nRQ_1     DC    AL2((RQ_2-RQ_1)-3)\n         DC    C'//SYSIN    DD   input - control cards - list of '\n         DC    C'members or pattern ********'\nRQ_2     DC    AL2((RQ_3-RQ_2)-3)\n         DC    C'//SYSOUT   DD   SYSOUT=*   report'\nRQ_3     DC    AL2((RQ_4-RQ_3)-3)\n         DC    C'//PDSIN    DD   DSN=  the PDS to unload'\nRQ_4     DC    AL2((RQ_5-RQ_4)-3)\n         DC    C'//OUTPUT   DD   DSN=  file to unload into - DISP=NEW'\nRQ_5     DC    AL2((RQ_6-RQ_5)-3)\n         DC    C'                      Do NOT set RECFM and LRECL'\nRQ_6     EQU   *\n*\nSYSIN    DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GM),EODAD=END_SYSIN\n*\nMEMLIST  DCB   DDNAME=PDS,MACRF=(GL),DSORG=PS,EODAD=DIREND,            /\n               LRECL=256,BLKSIZE=256,RECFM=FB\n*\nPDSIN    DCB   DDNAME=PDS,DSORG=PO,MACRF=R,EODAD=END_PDSIN\n*\nOUTPUT   DCB   DDNAME=OUTPUT,MACRF=(PM),DSORG=PS\n*\nSYSOUT   DCB   DDNAME=SYSOUT,MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80\n*\nHIGH_VALUES    DC    8XL1'FF'\n*\nTRTAB    DC   256AL1(*-TRTAB)\n         ORG  TRTAB+C'*'\n         DC   X'FF'\n         ORG\nTRTAB1   DC   256X'00'\n         ORG  TRTAB1+X'FF'\n         DC   X'FF'\n         ORG\n*______________________________________________________________________\n*\n         LTORG\n*______________________________________________________________________\n*\nREC_AREA DS    CL32760\n*______________________________________________________________________\n*\n         DCBD  DSORG=(QS,PO),DEVD=DA\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JRGUPDT$": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x19\\x02/\\x01\\x19\\x02/\\x06V\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-01-22T00:00:00", "modifydate": "2019-01-22T06:56:09", "lines": 19, "newlines": 19, "modlines": 0, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'JRGUPDTE   A/L/R ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*******************************************************\n//ASM01   EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(JRGUPDTE)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(JRGUPDTE)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(JRGUPDTE)\n//*******************************************************\n//LINK1   EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(JRGUPDTE)\n    ENTRY JRGUPDTE\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(JRGUPDTE)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRGUPDTE": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x19\\x02/\\x01\\x19\\x02\\x8f\\x16\\x16\\x01\\xb0\\x01\\x9d\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-01-22T00:00:00", "modifydate": "2019-01-28T16:16:46", "lines": 432, "newlines": 413, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'JRGUPDTE - IEBUPDTE version for any LRECL'\n*______________________________________________________________________\n*\nJRGUPDTE PRGDEF FSEG=MAIN_PART,RMODE=24,RENT=Y\n*\n*  This works like IEBUPDTE except it can handle fixed and variable\n*  length records of any length up to 1000 bytes (arbitrary figure)\n*  SYSIN should point to the input sequential file which contains\n*  the './ ADD NAME=????????' control cards followed by the records\n*  that make up the member.\n*  JRGULOAD writes the HEX constant x'FACE' immediately after the\n*  member name in the control card so this program checks for that\n*  constant, if not there the control card is ignored. Done to\n*  allow actual members to contain IEBUPDTE control cards.\n*  To switch this processing of use PGM=JRGUPDTE,PARM=NOFACE\n*\n*  PDSOUT must point to an empty PDS.\n*\n*  A restriction is that the RECFM and LRECL of SYSIN and PDSOUT\n*  must match. Also the PDS must be blocked.\n*\nEND_BLOCK      DS    F                 address of end of output block\nSAV_DCBLRECL   DS    H                 PDS record length\nSAV_DCBBLKSI   DS    H                 PDS block size\nSAV_DCBRECFM   DS    CL1               PDS record format\nSAV_FIX_VAR    DS    CL1               fixed/variable indicator\nRECORD_COUNT   DS    PL7               record count of this member\nTOT_REC_COUNT  DS    PL7               record count of all members\nMEMBER_COUNT   DS    PL7               count of members\nPARM_LEN       DS    H\nPARM_VALUE     DS    CL80\n*\nFACE_CHECK     DS    C                 x'FACE' check active\nE_O_F          DS    C                 end of file SYSIN\nSYSIN_REC      DS    CL1000            input record\n               DS    0F\nBIG_BLOCK      DS    32770CL1          bigger than maximum block size\n*\nIN       USING IHADCB,SYSIN            map DCBD over SYSIN\nPDS      USING IHADCB,PDSOUT           map DCBD over PDSOUT\n*\n         PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   PRGPARM PARM_VALUE,LEN=PARM_LEN\n   IF (CLC,=C'NOFACE ',EQ,PARM_VALUE)\n     MVI   FACE_CHECK,C'N'             do not check for x'FACE'\n   ENDIF\n   SEGDO OPEN_SYSIN\n   SEGDO OPEN_SYSOUT\n*\n   SEGDO OPEN_PDSOUT\n*\n   SEGDO CHECK_PDS_EMPTY               must be after OPEN to avoid\n*                                      blocksize of 256\n*\n   LA    R6,BIG_BLOCK                  point to output block\n   LH    R1,SAV_DCBBLKSI               get block size\n   LA    R1,0(R6,R1)                   add to start of block\n   ST    R1,END_BLOCK                  store end of block\n   IF (CLI,SAV_FIX_VAR,EQ,C'V')        if variable length\n     LA    R6,4(,R6)                   point after block descriptor\n   ENDIF\n   LR    R4,R6                         copy address to R4\n*\n   ZAP   RECORD_COUNT,=P'0'            initialise record count\n   ZAP   TOT_REC_COUNT,=P'0'           initialise total record count\n   ZAP   MEMBER_COUNT,=P'0'            initialise member count\n   DO INF\n     XC    SYSIN_REC(80),SYSIN_REC\n     SEGDO GET_SYSIN\n   DOEXIT (CLI,E_O_F,EQ,C'Y')          quit at end of file\n     MVC   NEW_MEMBER,SPACES           say not a new member\n     IF (TM,IN.DCBRECFM,DCBRECF,NZ)    fixed records\n       IF (CLC,=C'./ ADD NAME=',EQ,SYSIN_REC)\n         IF (CLC,=X'FACE',EQ,SYSIN_REC+20)\n           MVC   NEW_MEMBER,SYSIN_REC+12 copy new member name\n           MVI   NMEMC,0                 clear statistics\n           XC    NMEMUSER,NMEMUSER\n           IF (CLI,SYSIN_REC+22,NE,C' '),AND,                          /\n               (CLI,SYSIN_REC+22,NE,X'00')\n             MVC   NMEMC,SYSIN_REC+22\n             MVC   NMEMUSER,SYSIN_REC+23\n           ENDIF\n         ELSEIF (CLI,FACE_CHECK,EQ,C'N')\n           MVC   NEW_MEMBER,SYSIN_REC+12 copy new member name\n           MVI   NMEMC,0                 clear statistics\n           XC    NMEMUSER,NMEMUSER\n         ENDIF\n       ENDIF\n     ELSE  *                           must be variable\n       IF (CLC,=C'./ ADD NAME=',EQ,SYSIN_REC+4)\n         IF (CLC,=X'FACE',EQ,SYSIN_REC+24)\n           MVC   NEW_MEMBER,SYSIN_REC+16 copy new member name\n           MVI   NMEMC,0                 clear statistics\n           XC    NMEMUSER,NMEMUSER\n           IF (CLC,IN.DCBLRECL,GT,=H'26')  stats available\n             IF (CLI,SYSIN_REC+26,NE,C' '),AND,                        /\n               (CLI,SYSIN_REC+26,NE,X'00')\n               MVC   NMEMC,SYSIN_REC+26\n               MVC   NMEMUSER,SYSIN_REC+27\n             ENDIF\n           ENDIF\n         ELSEIF (CLI,FACE_CHECK,EQ,C'N')\n           MVC   NEW_MEMBER,SYSIN_REC+16 copy new member name\n           MVI   NMEMC,0                 clear statistics\n           XC    NMEMUSER,NMEMUSER\n         ENDIF\n       ENDIF\n     ENDIF\n     IF (CLC,NEW_MEMBER,NE,SPACES)     it is a new member\n       OC    NEW_MEMBER,SPACES         ensure uppercase\n       IF (CLC,THIS_MEMBER,GT,SPACES)  previous in progress\n         IF (CR,R6,GT,R4)              something in block\n           SEGDO OUTPUT_PDS            write out current block\n         ENDIF\n         SEGDO STORE_MEMBER            finish previous member\n       ENDIF\n       MVC   THIS_MEMBER,NEW_MEMBER    copy new member name\n       MVC   TMEMTTR,NMEMTTR\n       MVC   TMEMC,NMEMC\n       MVC   TMEMUSER,NMEMUSER\n       LR    R6,R4                     effective start of block\n     ELSE\n       L     R1,END_BLOCK              point to end of block\n       SH    R1,IN.DCBLRECL            subtract this record length\n       IF (CR,R1,LT,R6)                not enough space for record\n         SEGDO OUTPUT_PDS              write out current block\n       ENDIF\n       LH    R15,IN.DCBLRECL           get input record length\n       BCTR  R15,0                     minus 1 for execute\n       EX    R15,COPY_INREC            copy input to buffer\n       LA    R6,1(R15,R6)              point after copied record\n       AP    RECORD_COUNT,=P'1'        increment member record count\n       AP    TOT_REC_COUNT,=P'1'       increment total record count\n     ENDIF\n   ENDDO\n*\n   IF (CLC,THIS_MEMBER,GT,SPACES)      previous in progress\n     IF (CR,R6,GT,R4)                  something in block\n       SEGDO OUTPUT_PDS                write out current block\n     ENDIF\n     SEGDO STORE_MEMBER                finish previous member\n   ENDIF\n*\n   SEGDO PUT_SYSOUT\n   MVC   SYSOUT_REC+1(L'EDPAT),EDPAT\n   ED    SYSOUT_REC+1(L'EDPAT),MEMBER_COUNT\n   MVC   SYSOUT_REC+1+L'EDPAT(8),=C' members'\n   MVC   SYSOUT_REC+1+L'EDPAT+8(L'EDPAT),EDPAT\n   ED    SYSOUT_REC+1+L'EDPAT+8(L'EDPAT),TOT_REC_COUNT\n   MVC   SYSOUT_REC+1+L'EDPAT+8+L'EDPAT(14),=C' total records'\n   SEGDO PUT_SYSOUT\n*\n   SEGDO CLOSE_SYSIN\n   SEGDO CLOSE_SYSOUT\n   CLOSE (PDSOUT)\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS OUTPUT_PDS\n*\n*  Output a block to the PDS\n*\n   SR    R6,R4                         calculate actual block size\n   IF (CLI,SAV_FIX_VAR,EQ,C'V')\n     LA    R6,4(,R6)                   add block descriptor length\n     STH   R6,BIG_BLOCK                set block length in BDW\n   ENDIF\n   STH   R6,PDS.DCBBLKSI               set block length in DCB\n   LA    R6,BIG_BLOCK                  point to output block\n   WRITE PDSDECB,SF,PDSOUT,(R6),'S'\n   CHECK PDSDECB                       wait for I/O completion\n   MVC   PDS.DCBBLKSI,SAV_DCBBLKSI     reset block size to max\n   LR    R6,R4                         effective start of block\n*\n SEGE OUTPUT_PDS\n*______________________________________________________________________\n*\n SEGS STORE_MEMBER\n*\n*  This adds the member name to the PDS directory\n*\n   STOW  PDSOUT,THIS_MEMBER,A\n   IF (LTR,R15,R15,NZ)\n     LR    R3,R15                      copy return code\n     LR    R2,R0                       copy reason code\n     CVD   R15,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     MVC   STOW_MEM(8),THIS_MEMBER\n     MVC   SYSOUT_REC(L'STOW_BAD),STOW_BAD\n     UNPK  SYSOUT_REC+L'STOW_BAD(3),DOUB_WORD+6(2)\n     CVD   R2,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     MVC   SYSOUT_REC+L'STOW_BAD+4(3),=C'RS='\n     UNPK  SYSOUT_REC+L'STOW_BAD+4+3(5),DOUB_WORD+5(3)\n     SEGDO PUT_SYSOUT\n     IF (CHI,R3,EQ,12)                 directory full\n       MVC   SYSOUT_REC(L'NO_SPACE),NO_SPACE\n       SEGDO PUT_SYSOUT\n     ELSEIF (CHI,R3,EQ,16)             dataset is full\n       MVC   SYSOUT_REC(L'IS_FULL),IS_FULL\n       SEGDO PUT_SYSOUT\n     ENDIF\n     PRGQUIT RC=8\n   ENDIF\n   MVC   SYSOUT_REC(7),=C'Member '\n   MVC   SYSOUT_REC+7(8),THIS_MEMBER\n   MVC   SYSOUT_REC+7+8(8),=C' created'\n   MVC   SYSOUT_REC+7+8+8(L'EDPAT),EDPAT\n   ED    SYSOUT_REC+7+8+8(L'EDPAT),RECORD_COUNT\n   MVC   SYSOUT_REC+7+8+8+L'EDPAT(8),=C' records'\n   SEGDO PUT_SYSOUT\n   ZAP   RECORD_COUNT,=P'0'            initialise record count\n   AP    MEMBER_COUNT,=P'1'            increment member count\n*\n SEGE STORE_MEMBER\n*______________________________________________________________________\n*\n*  Ensure that the PDS is empty\n*\n SEGS CHECK_PDS_EMPTY\n*\n   XR    R7,R7                         initialise member count\n   OPEN  (PDSDIR,INPUT)                open the PDS directory\n   IF (LTR,R15,R15,NZ)\n     MVC   SYSOUT_REC(L'BAD_DIR),BAD_DIR could not read PDS directory\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n   DO INF\n     GET   PDSDIR                      get directory block\n     LH    R3,0(R1)                    get length of block\n     LA    R3,0(R3,R1)                 point to end of block\n     LA    R6,2(0,R1)                  point to first directory entry\n     DO INF\n     DOEXIT (CR,R6,GE,R3)              at end of block\n     DOEXIT (CLC,0(8,R6),EQ,HIGHVALS)  no more details\n     DOEXIT (CLC,0(8,R6),EQ,LOWVALS)   no more details\n*      MVC   THIS_MEMBER,0(R6)         would be member name\n       L     R1,8(R6)                  track num and length of this\n*      STCM  R1,B'1110',TTR_ADDR       track address of member\n       SLL   R1,27                     wipe out track address\n       SRL   R1,26                     make length even\n       LA    R6,12(R1,R6)              next directory entry\n*      SEGDO CHECK_MEMBER_WANTED\n       LA    R7,1(R7)                  increment member count\n     ENDDO\n   DOEXIT (CLC,0(8,R6),EQ,HIGHVALS)    end of directory\n   ENDDO\nDIREND   DS    0H\n   CLOSE PDSDIR\n*\n   IF (LTR,R7,R7,NZ)                   any members in the PDS\n     MVC   SYSOUT_REC(L'NOT_EMP),NOT_EMP\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE CHECK_PDS_EMPTY\n*______________________________________________________________________\n*\n SEGS OPEN_PDSOUT\n*\n   MVC   PDS.DCBLRECL,IN.DCBLRECL\n   MVC   PDS.DCBRECFM,IN.DCBRECFM\n   XC    PDS.DCBBLKSI,PDS.DCBBLKSI\n   OPEN  (PDSOUT,(OUTPUT))\n   IF (LTR,R15,R15,NZ)\n     MVC   SYSOUT_REC(L'PDS_MIS),PDS_MIS\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ELSEIF (TM,PDS.DCBDSRG1,DCBDSGPO,Z)\n     MVC   SYSOUT_REC(L'PDS_NOT),PDS_NOT\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n   MVC   SAV_DCBLRECL,PDS.DCBLRECL     copy block size\n   MVC   SAV_DCBBLKSI,PDS.DCBBLKSI          record format\n   MVC   SAV_DCBRECFM,PDS.DCBRECFM          record length\n   IF (TM,PDS.DCBRECFM,DCBRECF,NZ)\n     MVI   SAV_FIX_VAR,C'F'\n   ELSEIF (TM,PDS.DCBRECFM,DCBRECV,NZ)\n     MVI   SAV_FIX_VAR,C'V'\n   ELSE\n     MVC   SYSOUT_REC(L'PDS_FV),PDS_FV must be fixed or variable\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n   IF (TM,PDS.DCBRECFM,DCBRECBR,NZ)    should be blocked records\n*    this is what we want\n   ELSEIF (TM,PDS.DCBRECFM,DCBRECSB,NZ)\n     MVC   SYSOUT_REC(L'PDS_NSP),PDS_NSP cannot be spanned\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ELSE\n     MVC   SYSOUT_REC(L'PDS_BLK),PDS_BLK must be blocked records\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n   IF (CLC,IN.DCBLRECL,NE,PDS.DCBLRECL),OR,                            /\n               (CLC,IN.DCBRECFM,NE,PDS.DCBRECFM)\n     MVC   SYSOUT_REC(L'MAT_CH),MAT_CH RECFM+LRECL must match\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n   IF (CLC,IN.DCBLRECL,GT,=H'1000')\n     MVC   SYSOUT_REC(L'L_1000),L_1000 maximum record length is 1000\n     SEGDO PUT_SYSOUT\n     SEGDO OUTPUT_REQUIREMENTS\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE OPEN_PDSOUT\n*______________________________________________________________________\n*\n SEGS OUTPUT_REQUIREMENTS\n*\n*  Output how to use this program\n*\n   SEGDO PUT_SYSOUT\n   LA    R4,REQ_MNT                    point to output text\n   LH    R3,REQ_CNT                    count of lines\n   DO FROM=(R3)\n     LH    R1,0(,R4)                   get length of message -1\n     EX    R1,COPY_2_SYSOUT            copy message\n     LA    R4,3(R1,R4)                 point to next message\n     SEGDO PUT_SYSOUT\n   ENDDO\n*\n SEGE OUTPUT_REQUIREMENTS\n*______________________________________________________________________\n*\n PRGDCBI DCB=SYSIN,REC=SYSIN_REC,EOF=E_O_F\n*\n PRGDCBO DCB=SYSOUT,REC=SYSOUT_REC\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nCOPY_IN_TO_OUT MVC   SYSOUT_REC(0),SYSIN_REC\nCOPY_INREC     MVC   0(0,R6),SYSIN_REC   copy in=rec to output block\nCOPY_2_SYSOUT  MVC   SYSOUT_REC(0),2(R4) copy message text\nEDPAT          DC    X'4020202020202020202020202120'\n*\nSYSOUT_REC     DC    CL80' '\nSPACES         DC    CL80' '\nLOWVALS        DC    8XL1'00'\nHIGHVALS       DC    8XL1'FF'\n*\nBAD_DIR  DC    C'//PDSOUT   DD  ...     directory could not be read'\nSTOW_BAD DC    C'STOW of member xxxxxxxx failed RC='\n         ORG   STOW_BAD+15      start of 'xxxxxxxx'\nSTOW_MEM DS    CL8\n         ORG\nNO_SPACE DC    C'No space left in the PDS directory'\nIS_FULL  DC    C'The dataset is full'\nNOT_EMP  DC    C'//PDSOUT   DD  ...     members already present'\nPDS_MIS  DC    C'//PDSOUT   DD  ...         must be in JCL'\nPDS_NOT  DC    C'//PDSOUT   DD  ...         must be a PDS'\nPDS_FV   DC    C'//PDSOUT   DD  ...         must be RECFM= F or V'\nPDS_NSP  DC    C'//PDSOUT   DD  ...         cannot be SPANNED'\nPDS_BLK  DC    C'//PDSOUT   DD  ...         must be blocked'\nMAT_CH   DC    C'SYSIN and PDSOUT must have matching RECFM and LRECL'\nL_1000   DC    C'SYSIN must have LRECL <= 1000'\n*\nREQ_CNT  DC    H'5'                    count of instructions\nREQ_MNT  EQU   *                       start of instructions\nRQ_0     DC    AL2((RQ_1-RQ_0)-3)      length of message -1\n         DC    C'   Instructions for use'\nRQ_1     DC    AL2((RQ_2-RQ_1)-3)\n         DC    C'//SYSIN    DD   input - control cards plus data'\nRQ_2     DC    AL2((RQ_3-RQ_2)-3)\n         DC    C'//SYSOUT   DD   SYSOUT=*   report'\nRQ_3     DC    AL2((RQ_4-RQ_3)-3)\n         DC    C'//PDSOUT   DD   DSN=  an empty PDS DISP=NEW'\nRQ_4     DC    AL2((RQ_5-RQ_4)-3)\n         DC    C'                      Do NOT set RECFM and LRECL'\nRQ_5     EQU   *\n*\nSYSIN    DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GM),EODAD=END_SYSIN\nSYSOUT   DCB   DSORG=PS,DDNAME=SYSOUT,MACRF=(PM),RECFM=FB,LRECL=80\nPDSDIR   DCB   DSORG=PS,DDNAME=PDSOUT,MACRF=(GL),RECFM=FB,BLKSIZE=256, /\n               LRECL=256,EODAD=DIREND,EROPT=SKP\nPDSOUT   DCB   DSORG=PO,DDNAME=PDSOUT,MACRF=W\n*\nNEW_MEMBER     DS    CL8               new member name\nNMEMTTR        DC    XL3'00'           empty TTR\nNMEMC          DS    XL1               length/2 of use statistics\nNMEMUSER       DS    CL40              SPF statistics\nLEN_MEM        EQU   *-NEW_MEMBER\n*\nTHIS_MEMBER    DS    CL8               member name\nTMEMTTR        DC    XL3'00'           empty TTR\nTMEMC          DS    XL1               length/2 of use statistics\nTMEMUSER       DS    CL40              SPF statistics\n         ORG   TMEMUSER                                           C0909\nSPFVM    DS    XL2                 VERSION, LEVEL\nSPFFLAGS DS    X                   FLAGS                          A0909\nSPFSCLM  EQU   X'80'               SCLM-MANAGED                   A0909\nSPFXSTAT EQU   X'20'               EXTENDED STATISTICS            A0909\nSPFSECS  DS    X                   TIME LAST UPDATED (SS)         A0909\nSPFCREDT DS    PL4                 DATE CREATED\nSPFCHGDT DS    PL4                 DATE LAST UPDATED\nSPFHHMM  DS    XL2                 TIME LAST UPDATED (HHMM)\nSPFCCNT  DS    H                   CURRENT SIZE\nSPFICNT  DS    H                   INITIAL SIZE\nSPFMOD   DS    H                   MODS\nSPFUSER  DS    CL8                 USERID                         C1701\nSPFBLANK DS    CL2                 CLASSICALLY TWO BLANKS         C1701\n         ORG   SPFBLANK                                           C1701\nSPFXCCNT DS    F                   CURRENT SIZE                   A0909\nSPFXICNT DS    F                   INITIAL SIZE                   A0909\nSPFXMOD  DS    F                   MODS                           A0909\n         ORG\n*\n         DCBD  DSORG=(QS,PO),DEVD=DA\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTAP$$": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x15\\x01\\x17\\x05?\\x01\\x17\\x05?\\x15$\\x003\\x00)\\x00\\n\\xc1\\xe2\\xd4P\\xd9\\xe4\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-02-22T15:24:15", "lines": 51, "newlines": 41, "modlines": 10, "user": "ASM&RUN"}, "text": "//SDJRGASS JOB (0),'LISTAPF   A/L/R  ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*******************************************************\n//JOBLIB   DD  DISP=SHR,DSN=FEK910.SFEKAUTH\n//         DD  DISP=SHR,DSN=IDID10.SIDIAUTH\n//         DD  DISP=SHR,DSN=IDID10.SIDIAUT2\n//         DD  DISP=SHR,DSN=DFH520.CICS.SDFHEXCI\n//         DD  DISP=SHR,DSN=DFH520.CICS.SDFHAUTH\n//         DD  DISP=SHR,DSN=DFH520.CICS.SDFJAUTH\n//         DD  DISP=SHR,DSN=DFH520.CPSM.SEYUAUTH\n//         DD  DISP=SHR,DSN=DFH520.CICS.SDFHLPA\n//         DD  DISP=SHR,DSN=SDJRG.LOADLIB\n//*******************************************************\n//ASM     EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(LISTAPF)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(LISTAPF)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(LISTAPF)\n//*******************************************************\n//LINK    EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(LISTAPF)\n    ENTRY LISTAPF\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(LISTAPF)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n//RUN     EXEC PGM=LISTAPF,COND=(0,NE)\n//STEPLIB  DD  DISP=SHR,DSN=IMS1210.SDXRRESL\n//         DD  DISP=SHR,DSN=CSQ800.SCSQLINK\n//         DD  DISP=SHR,DSN=CSQ800.SCSQAUTH\n//         DD  DISP=SHR,DSN=CSQ800.SCSQMVR1\n//         DD  DISP=SHR,DSN=CSQ800.CSQ8.SCSQAUTH\n//         DD  DISP=SHR,DSN=CSQ800.SCSQANLE\n//         DD  DISP=SHR,DSN=CSQ800.SCSQSNLE\n//         DD  DISP=SHR,DSN=CSQ710.CSQ7.SCSQAUTH\n//         DD  DISP=SHR,DSN=DSNB10.SDSNLINK\n//         DD  DISP=SHR,DSN=DSNB10.DBBG.SDSNEXIT\n//         DD  DISP=SHR,DSN=DSNB10.SDSNLOAD\n//         DD  DISP=SHR,DSN=DSNB10.SDSNLOD2\n//         DD  DISP=SHR,DSN=DSNB10.SDXRRESL\n//         DD  DISP=SHR,DSN=ADBB10.SADBLINK\n//         DD  DISP=SHR,DSN=DSNA10.SDSNLINK\n//         DD  DISP=SHR,DSN=DSNA10.DBAG.SDSNEXIT\n//         DD  DISP=SHR,DSN=DSNA10.SDSNLOAD\n//         DD  DISP=SHR,DSN=DSNA10.SDXRRESL\n//         DD  DISP=SHR,DSN=SDJRG.LOADLIB\n//SYSOUT   DD  SYSOUT=*\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTAP#": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x01\\x17\\x05?\\x01\\x17\\x05?\\x19U\\x00\\x1f\\x00)\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-02-22T19:55:23", "lines": 31, "newlines": 41, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGOLOBA JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*******************************************************\n//JOBLIB   DD  DISP=SHR,DSN=IDID10.SIDIAUTH\n//         DD  DISP=SHR,DSN=IDID10.SIDIAUT2\n//         DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//*******************************************************\n//RUN     EXEC PGM=LISTAPF,COND=(0,NE)\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.LINKLIB\n//         DD  DISP=SHR,DSN=SYS1.SVCLIB\n//         DD  DISP=SHR,DSN=SYS1.COMMON.LINKLIB\n//         DD  DISP=SHR,DSN=SYS1.COMMON.LPALIB\n//         DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//         DD  DISP=SHR,DSN=SYS1.SHASLNKE\n//         DD  DISP=SHR,DSN=SYS1.SIEAMIGE\n//         DD  DISP=SHR,DSN=SYS1.MIGLIB\n//         DD  DISP=SHR,DSN=SYS1.SERBLINK\n//         DD  DISP=SHR,DSN=SYS1.SIEALNKE\n//         DD  DISP=SHR,DSN=SYS1.CSSLIB\n//         DD  DISP=SHR,DSN=IGY520.SIGYCOMP\n//         DD  DISP=SHR,DSN=EQAD10.SEQABMOD\n//         DD  DISP=SHR,DSN=EQAD10.SEQAAUTH\n//         DD  DISP=SHR,DSN=GIM.SGIMLMD0\n//         DD  DISP=SHR,DSN=FAN140.SEAGLPA\n//         DD  DISP=SHR,DSN=DIT130.SDITMOD1\n//         DD  DISP=SHR,DSN=CSQ800.SCSQLINK\n//         DD  DISP=SHR,DSN=CSQ800.SCSQAUTH\n//         DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSOUT   DD  SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTAPF": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00I\\x01\\x17\\x05?\\x01\\x18\\x12O\\x05\\x19\\x01\\x0f\\x00\\xe3\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2018-05-04T05:19:49", "lines": 271, "newlines": 227, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'LISTAPF - List all APF datasets'\n PRINT GEN\n*______________________________________________________________________\n*\n*  Written by John Gateley in February 2017.\n*  March 2017 John Gateley output volume information as well.\n*  May   2018 John Gateley use CSVAPF to access list of APF libraries\n*                          instead of undocumented.\n*\n*    D I S C L A I M E R\n*    -------------------\n*\n*  This program is FREEWARE. Use at your own risk.  Neither John\n*  Gateley, nor other contributing organizations or individuals\n*  accept any liability of any kind howsoever arising out of the use\n*  of this program. You are free to use and modify this program as\n*  you desire, however, the author does ask that you leave his name\n*  in the source and give credit to him as the original programmer.\n*  You can also just grab the bit of code you want if you do not like\n*  all the structured programming macros.\n*______________________________________________________________________\n*\n*  This program gets a list of dynamic APF authorised libraries and\n*  outputs them to SYSOUT.\n*\n*  It then gets all the dataset names concatenated to STEPLIB and\n*  checks if they are in the APF authorised list, if not it lists them.\n*\n*  Finally it does the same for JOBLIB.\n*\nLISTAPF PRGDEF FSEG=MAIN_BIT,RMODE=24,RENT=Y\n*\n* RENT=Y means the storage up to PRGEDEF is dynamically allocated at\n* run time but program is not re-entrant due to SYSOUT DCB.\n*\n               DS    0D\nDSN_COUNT      DS    PL8\nUSE_LIB        DS    CL8\nAPF_TOTL       DS    F\nRETCODE        DS    F\nRSNCODE        DS    F\n*\nKEEP_ARLAREA   DC    F'0'\nKEEP_ARLRLEN   DC    F'0'\nKEEP_ARLPOOL   DC    H'0'\nKEEP_ARLRTRVD  DC    H'0'\nTHIS_ARL_REQ   DC    H'0'\n*\nTEST_IT        DS    CL50\n*\n&MAX_APF       SETA  2000              should be enough slots\n*&MAX_APF       SETA  100               should NOT be enough slots\n*\nHEAD_APF       DS    (APFHDR_LEN)CL1\nDETAIL_APF     DS    (&MAX_APF*APFE_LEN)CL1\nTOTAL_APF_LEN  EQU   HEAD_APF\n*\n         CSVAPFAA\n*\n         PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   USING APFHDR,HEAD_APF\n*\n   SEGDO OPEN_SYSOUT                   open output file\n*\n   SEGDO BUILD_APF_LIST\n*\n*  L     R1,APFHNUMREM                 number not returned\n   L     R1,APFH#REM                   number not returned\n   IF (LTR,R1,R1,NZ)\n     MVC   MESS_TXT(L'ERR_MESS_1),ERR_MESS_1\n     SEGDO PUT_SYSOUT\n     SETRC RC=4                        set return code to 4\n   ELSE\n     MVC   USE_LIB,=CL8'STEPLIB'       first try STEPLIB\n     SEGDO CHECK_CONCAT\n     MVC   USE_LIB,=CL8'JOBLIB'        then try JOBLIB\n     SEGDO CHECK_CONCAT\n   ENDIF\n*\n   SEGDO CLOSE_SYSOUT\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS BUILD_APF_LIST\n*\n   LHI   R1,&MAX_APF                   number of entries available\n   MHI   R1,APFE_LEN                   multiply by the entry length\n   AHI   R1,APFHDR_LEN                 add length of header\n   ST    R1,APF_TOTL\n   CSVAPF REQUEST=LIST,ANSAREA=HEAD_APF,ANSLEN=APF_TOTL,               /\n               RETCODE=RETCODE,RSNCODE=RSNCODE\n   IF (LTR,R15,R15,NZ)\n     XUNPK RETCODE,4,ERR_MESS_2_RC\n     XUNPK RSNCODE,4,ERR_MESS_2_RS\n*    L     R1,APFHNUMREC               number received\n     L     R1,APFH#REC                 number received\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  ERR_MESS_2_AV,DOUB_WORD\n*    A     R1,APFHNUMREM               number remaining\n     A     R1,APFH#REM                 number remaining\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  ERR_MESS_2_TL,DOUB_WORD\n     MVC   MESS_TXT(ERR_MESS_2_L),ERR_MESS_2\n     SEGDO PUT_SYSOUT                  output error message\n     PRGQUIT RC=16\n   ENDIF\n*\n   MVC   MESS_TXT+17(L'APF_HEADING),APF_HEADING\n   SEGDO PUT_SYSOUT                    output concatenation name\n   MVI   MESS_TXT+17,C'-'\n   MVC   MESS_TXT+18(L'APF_HEADING-1),MESS_TXT+17\n   SEGDO PUT_SYSOUT                    underline it\n*\n   ZAP   DSN_COUNT,=P'0'               initialise\n*  L     R5,APFHNUMREC                 number of libraries\n   L     R5,APFH#REC                   number of libraries\n   LA    R6,APFHDR\n   A     R6,APFHOFF\n   USING APFE,R6\n   DO FROM=(R5)\n     AP    DSN_COUNT,=P'1'             increment count\n     MVC   MESS_TXT(L'ED_PAT),ED_PAT         set edit mask\n     ED    MESS_TXT(L'ED_PAT),DSN_COUNT      edit name count\n     MVC   MESS_TXT+L'ED_PAT+1(6),APFEVOLUME      volume\n     MVC   MESS_TXT+L'ED_PAT+8(44),APFEDSNAME     dataset name\n     SEGDO PUT_SYSOUT                  output details\n     AH    R6,APFELEN\n   ENDDO\n*\n SEGE BUILD_APF_LIST\n*______________________________________________________________________\n*\n SEGS CHECK_CONCAT\n*\n   SEGDO PUT_SYSOUT                    output blank line\n   MVC   MESS_TXT+8(8),USE_LIB\n   MVC   MESS_TXT+16(L'CON_CAT),CON_CAT\n   SEGDO PUT_SYSOUT                    output concatenation name\n   MVI   MESS_TXT+8,C'-'\n   MVC   MESS_TXT+9(L'CON_CAT+7),MESS_TXT+8\n   SEGDO PUT_SYSOUT                    underline it\n*\n   LA    R8,TESTDCB                    point to TESTDCB\n   USING IHADCB,R8                     map DCBD\n   MVC   DCBDDNAM,USE_LIB              copy required DDNAME\n   RDJFCB  ((R8))                      read details of DDNAME\n   IF (LTR,R15,R15,NZ)                 not available\n     MVC   MESS_TXT+8(L'MISS_MESS),MISS_MESS\n     SEGDO PUT_SYSOUT                  output missing message\n     SEGQUIT                           get out of segment\n   ENDIF\n*\n   MVC   KEEP_ARLAREA,ARLAREA          save ARLA details\n   MVC   KEEP_ARLRTRVD,ARLRTRVD\n   XC    KEEP_ARLRLEN,KEEP_ARLRLEN\n   MVC   KEEP_ARLRLEN+1(3),ARLRLEN\n   XC    KEEP_ARLPOOL,KEEP_ARLPOOL\n   MVC   KEEP_ARLPOOL+1(1),ARLPOOL\n   MVC   THIS_ARL_REQ,=H'1'\n*\n   DO INF\n     MVC   TEST_IT(6),JFCBVOLS         copy first volume of DSN\n     MVC   TEST_IT+6(L'JFCBDSNM),JFCBDSNM  and dataset name\n     MVC   MESS_TXT(6),JFCBVOLS        output first volume of DSN\n     MVC   MESS_TXT+8(L'JFCBDSNM),JFCBDSNM\n     LA    R6,APFHDR\n     A     R6,APFHOFF\n*    L     R15,APFHNUMREC              get count\n     L     R15,APFH#REC                get count\n     DO FROM=(R15)\n     DOEXIT (CLC,TEST_IT,EQ,APFEVOLUME)  matching volume+dataset name\n       AH    R6,APFELEN\n     ENDDO\n     IF (LTR,R15,R15,Z)                not found in list\n       MVC   MESS_TXT+10+L'JFCBDSNM(L'MISS_ING),MISS_ING\n     ENDIF\n     SEGDO PUT_SYSOUT                  output dataset name\n   DOEXIT (CLC,KEEP_ARLRTRVD,LE,THIS_ARL_REQ)  exit at end of list\n     SEGDO GET_NEXT_CONCATENATED_DETAILS\n   ENDDO\n*\n   L     R2,KEEP_ARLAREA               release RDJFCB storage\n   L     R3,KEEP_ARLRLEN\n   LH    R15,KEEP_ARLPOOL\n   FREEMAIN RU,LV=(R3),A=(R2),SP=(R15)\n*\n   DROP  R8\n*\n SEGE CHECK_CONCAT\n*______________________________________________________________________\n*\n SEGS GET_NEXT_CONCATENATED_DETAILS\n*\n   L     R1,KEEP_ARLAREA               point to start\n   IF (LTR,R1,R1,NZ)                   something there\n     PUSH  USING\n     USING ARA,R1\n     IF (CLC,THIS_ARL_REQ,LT,KEEP_ARLRTRVD)  not at last dataset\n       LH    R15,THIS_ARL_REQ                get dataset number\n       MH    R15,ARALEN                      multiply by length\n       LA    R1,0(R15,R1)                    point at details\n       MVC   INFMJFCB(JFCBLGTH),ARAJFCB      and copy\n       LH    R15,THIS_ARL_REQ                increment count\n       LA    R15,1(,R15)\n       STH   R15,THIS_ARL_REQ\n     ENDIF\n     POP   USING\n   ENDIF\n*\n SEGE GET_NEXT_CONCATENATED_DETAILS\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n PRGDCBO DCB=SYSOUT,REC=MESS_TXT,CLEAR=Y\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nED_PAT         DC    X'40202020202020202020202020202020'\nAPF_HEADING    DC    C'APF libraries'\nCON_CAT        DC    C' concatenation'\nMISS_ING       DC    C' not APF authorised'\nMISS_MESS      DC    C'DDNAME not available or RDJFCB error'\nERR_MESS_0     DC    C'//SYSOUT DD SYSOUT=* is required in the JCL'\nERR_MESS_1     DC    C'More than &MAX_APF APF authorised libraries'\nERR_MESS_2     DC    C'Error in CSVAPF macro RC='\nERR_MESS_2_RC  DC    CL8' '\n               DC    C'x RS='\nERR_MESS_2_RS  DC    CL8' '\n               DC    C'x Avail='\nERR_MESS_2_AV  DC    CL7' '\n               DC    C' Required='\nERR_MESS_2_TL  DC    CL7' '\nERR_MESS_2_L   EQU   *-ERR_MESS_2\n*\nSYSOUT   DCB   DSORG=PS,DDNAME=SYSOUT,LRECL=80,MACRF=(PM),RECFM=FB\n*\n*        A DCB used to get list of concatanated datasets\nTESTDCB  DCB   DDNAME=XXXXXXXX,MACRF=(GL),DSORG=PS,EXLST=LIST1\nLIST1    DS    0F\n         DC    X'13',AL3(MY_JFCB_13)\n         DC    X'87',AL3(MY_JFCB_07)\n*\n               LTORG\n*\n               PUSH  PRINT,NOPRINT\n               PRINT NOGEN\nMY_JFCB_07     DS    0F\n               IEFJFCBN\nLEN_MY_JFCB_07 EQU   *-MY_JFCB_07\nMY_JFCB_13     IHAARL DSECT=NO\n               IHAARA\n               DCBD  DSORG=QS,DEVD=DA\n               POP   PRINT,NOPRINT\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTAPF$": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00H\\x01\\x17\\x05?\\x01\\x18\\x12\\x7f\\x08$\\x00\\x1e\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2018-05-07T08:24:48", "lines": 30, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(LISTAPF)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   LISTAPF\n SETSSI  CB496953\n ENTRY   LISTAPF\n NAME    LISTAPF(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTAPFO": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x19\\x01\\x17\\x05?\\x01\\x17\\x12\\x8f\\x16\\x02\\x00\\xf2\\x00\\xe3\\x00\\x00\\xd6\\xd3\\xc4\\xd9\\xc3\\xd6\\xc4\\xc5@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-05-08T16:02:19", "lines": 242, "newlines": 227, "modlines": 0, "user": "OLDRCODE"}, "text": " TITLE 'LISTAPF - List all APF datasets'\n PRINT GEN\n*______________________________________________________________________\n*\n*  Written by John Gateley in February 2017.\n*  March 2017 John Gateley output volume information as well.\n*\n*    D I S C L A I M E R\n*    -------------------\n*\n*  This program is FREEWARE. Use at your own risk.  Neither John\n*  Gateley, nor other contributing organizations or individuals\n*  accept any liability of any kind howsoever arising out of the use\n*  of this program. You are free to use and modify this program as\n*  you desire, however, the author does ask that you leave his name\n*  in the source and give credit to him as the original programmer.\n*______________________________________________________________________\n*\n*  This program uses some code from Mark Zelden's IPLINFO rexx exec\n*  to access undocumented control blocks.\n*\n*      http://mzelden.com/mvsutil.html\n*\n*  Mark's warning is reproduced below and it is now tested on 2.2.\n*\n*  NOTE: The dynamic APF and dynamic LNKLST code in this exec\n*        use undocumented IBM control blocks and may break at\n*        any time!\n*      ... tested on MVS ESA V4.3 up through z/OS 2.1.\n*______________________________________________________________________\n*\n*  This program gets a list of dynamic APF authorised libraries and\n*  outputs them to SYSOUT.\n*\n*  It then gets all the dataset names concatenated to STEPLIB and\n*  checks if they are in the APF authorised list, if not it lists them.\n*\n*  Finally it does the same for JOBLIB.\n*\nLISTAPF PRGDEF FSEG=MAIN_BIT,RMODE=24,RENT=Y\n*\n* RENT=Y means the storage up to PRGEDEF is dynamically allocated at\n* run time but program is not re-entrant due to SYSOUT DCB.\n*\n               DS    0D\nDSN_COUNT      DS    PL8\nUSE_LIB        DS    CL8\n*\nKEEP_ARLAREA   DC    F'0'\nKEEP_ARLRLEN   DC    F'0'\nKEEP_ARLPOOL   DC    H'0'\nKEEP_ARLRTRVD  DC    H'0'\nTHIS_ARL_REQ   DC    H'0'\n*\nTEST_IT        DS    CL50\n*\n               LCLA  &MAX_APF\n&MAX_APF       SETA  2000              should be enough names\nALL_APF        DS    (&MAX_APF)CL50    allow for MAX_APF datasets\nLEN_APF        EQU   50                set length of slot\n*\n         PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   SEGDO OPEN_SYSOUT                   open output file\n*\n   SEGDO BUILD_APF_LIST\n*\n   IF (CP,DSN_COUNT,GT,=P'&MAX_APF')\n     MVC   MESS_TXT(L'ERR_MESS_1),ERR_MESS_1\n     SEGDO PUT_SYSOUT\n     SETRC RC=4                        set return code to 4\n   ELSE\n     MVC   USE_LIB,=CL8'STEPLIB'       first try STEPLIB\n     SEGDO CHECK_CONCAT\n     MVC   USE_LIB,=CL8'JOBLIB'        then try JOBLIB\n     SEGDO CHECK_CONCAT\n   ENDIF\n*\n   SEGDO CLOSE_SYSOUT\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS BUILD_APF_LIST\n*\n   L     R1,16                         point to CVT\n   L     R1,140(,R1)                   point to CVTECVT\n   L     R1,228(,R1)                   point to CSV table\n   L     R1,12(,R1)                    point to APFA\n   L     R4,8(,R1)                     point to first name\n   L     R5,12(,R1)                    point to last name\n   LA    R6,ALL_APF                    point to my list\n*\n   MVC   MESS_TXT+17(L'APF_HEADING),APF_HEADING\n   SEGDO PUT_SYSOUT                    output concatenation name\n   MVI   MESS_TXT+17,C'-'\n   MVC   MESS_TXT+18(L'APF_HEADING-1),MESS_TXT+17\n   SEGDO PUT_SYSOUT                    underline it\n*\n   ZAP   DSN_COUNT,=P'0'               initialise\n   DO INF\n     IF (CLI,24(R4),NE,X'00')          if not deleted\n       AP    DSN_COUNT,=P'1'           increment count\n       MVC   MESS_TXT(L'ED_PAT),ED_PAT         set edit mask\n       ED    MESS_TXT(L'ED_PAT),DSN_COUNT      edit name count\n       MVC   MESS_TXT+L'ED_PAT+1(6),24+44(R4)  copy volume\n       MVC   MESS_TXT+L'ED_PAT+8(44),24(R4)    copy dataset name\n       SEGDO PUT_SYSOUT\n       IF (CP,DSN_COUNT,LE,=P'&MAX_APF')       still space for name\n         MVC   0(6,R6),24+44(R4)       copy volume name        list\n         MVC   6(44,R6),24(R4)         copy dataset name\n         LA    R6,LEN_APF(,R6)         point to next slot\n       ENDIF\n     ENDIF\n   DOEXIT (CR,R4,EQ,R5)                exit when processed last\n     L     R4,8(,R4)                   point to next name\n   ENDDO\n*\n SEGE BUILD_APF_LIST\n*______________________________________________________________________\n*\n SEGS CHECK_CONCAT\n*\n   LA    R8,TESTDCB                    point to TESTDCB\n   USING IHADCB,R8                     map DCBD\n   MVC   DCBDDNAM,USE_LIB              copy required DDNAME\n   RDJFCB  ((R8))                      read details of DDNAME\n   IF (LTR,R15,R15,NZ)                 not available\n     SEGQUIT                           get out of segment\n   ENDIF\n*\n   MVC   KEEP_ARLAREA,ARLAREA          save ARLA details\n   MVC   KEEP_ARLRTRVD,ARLRTRVD\n   XC    KEEP_ARLRLEN,KEEP_ARLRLEN\n   MVC   KEEP_ARLRLEN+1(3),ARLRLEN\n   XC    KEEP_ARLPOOL,KEEP_ARLPOOL\n   MVC   KEEP_ARLPOOL+1(1),ARLPOOL\n   MVC   THIS_ARL_REQ,=H'1'\n*\n   SEGDO PUT_SYSOUT                    output blank line\n   MVC   MESS_TXT+8(8),USE_LIB\n   MVC   MESS_TXT+16(L'CON_CAT),CON_CAT\n   SEGDO PUT_SYSOUT                    output concatenation name\n   MVI   MESS_TXT+8,C'-'\n   MVC   MESS_TXT+9(L'CON_CAT+7),MESS_TXT+8\n   SEGDO PUT_SYSOUT                    underline it\n*\n   DO INF\n     MVC   TEST_IT(6),JFCBVOLS         copy first volume of DSN\n     MVC   TEST_IT+6(L'JFCBDSNM),JFCBDSNM  and dataset name\n     MVC   MESS_TXT(6),JFCBVOLS        output first volume of DSN\n     MVC   MESS_TXT+8(L'JFCBDSNM),JFCBDSNM\n     LA    R14,ALL_APF                 point to list of APF datasets\n     CVB   R15,DSN_COUNT               get count\n     DO FROM=(R15)\n     DOEXIT (CLC,TEST_IT,EQ,0(R14))    matching volume+dataset name\n       LA    R14,LEN_APF(,R14)         point to next\n     ENDDO\n     IF (LTR,R15,R15,Z)                not found in list\n       MVC   MESS_TXT+10+L'JFCBDSNM(L'MISS_ING),MISS_ING\n     ENDIF\n     SEGDO PUT_SYSOUT                  output dataset name\n   DOEXIT (CLC,KEEP_ARLRTRVD,LE,THIS_ARL_REQ)  exit at end of list\n     SEGDO GET_NEXT_CONCATENATED_DETAILS\n   ENDDO\n*\n   L     R2,KEEP_ARLAREA               release RDJFCB storage\n   L     R3,KEEP_ARLRLEN\n   LH    R15,KEEP_ARLPOOL\n   FREEMAIN RU,LV=(R3),A=(R2),SP=(R15)\n*\n   DROP  R8\n*\n SEGE CHECK_CONCAT\n*______________________________________________________________________\n*\n SEGS GET_NEXT_CONCATENATED_DETAILS\n*\n   L     R1,KEEP_ARLAREA               point to start\n   IF (LTR,R1,R1,NZ)                   something there\n     PUSH  USING\n     USING ARA,R1\n     IF (CLC,THIS_ARL_REQ,LT,KEEP_ARLRTRVD)  not at last dataset\n       LH    R15,THIS_ARL_REQ                get dataset number\n       MH    R15,ARALEN                      multiply by length\n       LA    R1,0(R15,R1)                    point at details\n       MVC   INFMJFCB(JFCBLGTH),ARAJFCB      and copy\n       LH    R15,THIS_ARL_REQ                increment count\n       LA    R15,1(,R15)\n       STH   R15,THIS_ARL_REQ\n     ENDIF\n     POP   USING\n   ENDIF\n*\n SEGE GET_NEXT_CONCATENATED_DETAILS\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n PRGDCBO DCB=SYSOUT,REC=MESS_TXT,CLEAR=Y\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nED_PAT         DC    X'40202020202020202020202020202020'\nAPF_HEADING    DC    C'APF libraries'\nCON_CAT        DC    C' concatenation'\nMISS_ING       DC    C' not APF authorised'\nERR_MESS_0     DC    C'//SYSOUT DD SYSOUT=* is required in the JCL'\nERR_MESS_1     DC    C'More than &MAX_APF APF authorised libraries'\n*\nSYSOUT   DCB   DSORG=PS,DDNAME=SYSOUT,LRECL=80,MACRF=(PM),RECFM=FB\n*\n*        A DCB used to get list of concatanated datasets\nTESTDCB  DCB   DDNAME=XXXXXXXX,MACRF=(GL),DSORG=PS,EXLST=LIST1\nLIST1    DS    0F\n         DC    X'13',AL3(MY_JFCB_13)\n         DC    X'87',AL3(MY_JFCB_07)\n*\n               LTORG\n*\n               PUSH  PRINT,NOPRINT\n               PRINT NOGEN\nMY_JFCB_07     DS    0F\n               IEFJFCBN\nLEN_MY_JFCB_07 EQU   *-MY_JFCB_07\nMY_JFCB_13     IHAARL DSECT=NO\n               IHAARA\n               DCBD  DSORG=QS,DEVD=DA\n               POP   PRINT,NOPRINT\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MACDOC": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x17&\\x0f\\x01\\x174\\x0f\\x15#\\x00\\x9b\\x00\\x01\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-09-17T00:00:00", "modifydate": "2017-12-06T15:23:49", "lines": 155, "newlines": 1, "modlines": 0, "user": "SDJRG"}, "text": "The first member in MACLIB is the macro documentation, it is\nreproduced here.\n\n------------------------------------------------------------\n\nThe following macros are part of the Concept 14 structured programming\nmacros which were written by Marvin Kessler in 1970.\nThey have been amended by John Gateley to use branch relative on\ncondition instead of branch on condition.\n\nDO\nDOEXIT\nDOPROC\nELSE\nELSEIF\nENDDO\nENDEVAL\nENDIF\nEVALUATE\nGBLVARS\nGETCC\nIF\nIFPROC\nIFTEST\nOTHERWSE\nPLIST\nPOPINS\nPOPNEST\nPUSHINS\nPUSHLAB\nPUSHNEST\nSTKINS\nTESTNEST\nWHEN\n\nJRGTIOT   Copy of the MVT macro IEFTIOT1\n          amended to make the DSECTs explicit.\n\nThe PRG*  macros are used to create structured programs which can\n          be reentrant. Code RENT=Y.\n\nPRGDEF    Module initialisation\n          This sets up standard linkage and register equates.\n          The modue defaults to AMODE=31 RMODE=ANY but this can\n          be overridden.\n          The following OPSYN commands are used so that any branch\n          statements in macros are converted to branch relative.\n          B          OPSYN BRU\n          BAL        OPSYN BAS\n          BALR       OPSYN BASR\n          The LOCTR statement is used to split the module into #DATA\n          and #CODE sections with the #DATA section first. The #DATA\n          section starts with eye catchers of the module name and\n          the assembly timestamp and is based on register 12.\n          The FSEG parameter indicates the first code segment to\n          be performed. Each code segment reuses register 11 as\n          its base register and this is automatically maintained\n          when other segments are performed using SEGDO.\n          Note, NEVER branch out of a segment as the code base\n          register will then have an invalid value and anything\n          could happen. To exit a segment use SEGQUIT which returns\n          to where the segment was called, or to exit the program\n          use PRGQUIT.\n          If RENT=Y is used the storage defined between PRGDEF and\n          PRGEDEF will be getmained on entry to the program and\n          freemained on exit. If RENT=N then this storage will map\n          over an area in PRGSTAT.\n          Facilities for writing rexx functions are provided by\n          use of REXX=Y and INREX=Y. REXX=Y means that the program\n          will be called as a rexx function and registers 7 to 10\n          will map rexx programming interfaces. INREX=Y means that\n          the program will be called by another REXX aware program\n          and the registers will be maintained.\n          A reentrant form of the WTO macro will be included and\n          the field MESS_TXT should be used to build an output\n          message and WTOX will write this and clear the area to\n          spaces.\n\nPRGEDEF   Module termination - storage defined between these macros\n          is based on register 13 after the save area\n          This handles exit processing and if rexx is active it\n          checks if EVALBLOCK result has been set, if not is is\n          populated with the return code in field R_C.\n          R_C can be populated with SETRC RC=? or PRGQUIT RC=?.\n\nPRGPARM   grap any parameter from R1 - use for JCL invocation\n\nPRGSTAT   Module static storage for constants and DCB.\n          This reestablishes the #DATA LOCTR so that this storage\n          is based on register 12 and comes directly after timestamp.\n\nPRGESTAT  Module end of static storage\n\nPRGEND    Module end\n\nPRGDCBI   Generate code segments for an input file (open,get,close)\n          works with spanned records\n\nPRGDCBO   Generate code segments for an output file (open,put,close)\n          works with spanned records\n\nPRGQUIT   Go directly to the module termination routine\n\nPRGSTEM   Define storage for use in program PROCSTEM which looks\n          after dropping and defining a rexx stem variable\n\nSEGDO     perform a segment of code\n\nSEGS      start a segment of code - when used with PRG* macros\n          the same register is used as code base in all segments\n          so each segment could be up to 4K. Never blow a base.\n\nSEGQUIT   exit from this code segment back to wherever it came from.\n\nSEGE      end of a segment of code\n\nSETRC     set the R_C return code value in PRG*\n\nBEDIT     build an edit pattern to use in ED or EDMK based on the\n          size of the packed decimal field.\n\nXEDIT     build an edit pattern to use in ED or EDMK based on the\n          size of the packed decimal field and actually execute\n          the ED or EDMK.\n\nSTRING    acts like the COBOL STRING verb and allows conversion\n          of integer and packed-decimal values to numeric and\n          register values to hexadecimal display.\n\nSTRINGIT  program used by STRING\n\nTRIM      trim blanks from a variable\n          removes leading and extra blanks from a variable.\n          that is ' A  B ' becomes 'AB    '\n          after completion R15 contains the length of the string\n          ALL=Y can be used to remove all blanks.\n\nTRIMIT    program used by TRIM\n\nTSTMP     generate a timestamp from STCK\n          FORMAT=DB2  - CL26'2017-04-01-12.34.56.789012'\n                 CHAR - CL20'20170401123456789012'\n                 PACK - PL11'020170401123456789012C'\n\nWTOX      does a WTO from MESS_TXT which is defined in PRGDEF\n          and then clear MESS_TXT to spaces unless CLEAR=N\n\nXPACK     pack a character string to hex       C'C1F1' X'A1'\n          uses a translate table that is automatically generated in\n          PRGSTAT if XPACK has been used in the program.\n\nXUNPK     unpack a hex string to character     X'A1' C'C1F1'\n          uses a translate table that is automatically generated in\n          PRGSTAT if XUNPK has been used in the program.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MACLIB": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18(?\\x01\\x18(?\\x12I\\x12.\\x12.\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-10-10T00:00:00", "modifydate": "2018-10-10T12:49:03", "lines": 4654, "newlines": 4654, "modlines": 0, "user": "SDJRG"}, "text": "./ ADD NAME=###DOC##\nThe following macros are part of the Concept 14 structured programming\nmacros which were written by Marvin Kessler in 1970.\nThey have been amended by John Gateley to use branch relative on\ncondition instead of branch on condition.\n\nDO\nDOEXIT\nDOPROC\nELSE\nELSEIF\nENDDO\nENDEVAL\nENDIF\nEVALUATE\nGBLVARS\nGETCC\nIF\nIFPROC\nIFTEST\nOTHERWSE\nPLIST\nPOPINS\nPOPNEST\nPUSHINS\nPUSHLAB\nPUSHNEST\nSTKINS\nTESTNEST\nWHEN\n\nJRGTIOT   Copy of the MVT macro IEFTIOT1\n          amended to make the DSECTs explicit.\n\nThe PRG*  macros are used to create structured programs which can\n          be reentrant. Code RENT=Y.\n\nPRGDEF    Module initialisation\n          This sets up standard linkage and register equates.\n          The modue defaults to AMODE=31 RMODE=ANY but this can\n          be overridden.\n          The following OPSYN commands are used so that any branch\n          statements in macros are converted to branch relative.\n          B          OPSYN BRU\n          BAL        OPSYN BAS\n          BALR       OPSYN BASR\n          The LOCTR statement is used to split the module into #DATA\n          and #CODE sections with the #DATA section first. The #DATA\n          section starts with eye catchers of the module name and\n          the assembly timestamp and is based on register 12.\n          The FSEG parameter indicates the first code segment to\n          be performed. Each code segment reuses register 11 as\n          its base register and this is automatically maintained\n          when other segments are performed using SEGDO.\n          Note, NEVER branch out of a segment as the code base\n          register will then have an invalid value and anything\n          could happen. To exit a segment use SEGQUIT which returns\n          to where the segment was called, or to exit the program\n          use PRGQUIT.\n          If RENT=Y is used the storage defined between PRGDEF and\n          PRGEDEF will be getmained on entry to the program and\n          freemained on exit. If RENT=N then this storage will map\n          over an area in PRGSTAT.\n          Facilities for writing rexx functions are provided by\n          use of REXX=Y and INREX=Y. REXX=Y means that the program\n          will be called as a rexx function and registers 7 to 10\n          will map rexx programming interfaces. INREX=Y means that\n          the program will be called by another REXX aware program\n          and the registers will be maintained.\n          A reentrant form of the WTO macro will be included and\n          the field MESS_TXT should be used to build an output\n          message and WTOX will write this and clear the area to\n          spaces.\n\nPRGEDEF   Module termination - storage defined between these macros\n          is based on register 13 after the save area\n          This handles exit processing and if rexx is active it\n          checks if EVALBLOCK result has been set, if not is is\n          populated with the return code in field R_C.\n          R_C can be populated with SETRC RC=? or PRGQUIT RC=?.\n\nPRGPARM   grap any parameter from R1 - use for JCL invocation\n\nPRGSTAT   Module static storage for constants and DCB.\n          This reestablishes the #DATA LOCTR so that this storage\n          is based on register 12 and comes directly after timestamp.\n\nPRGESTAT  Module end of static storage\n\nPRGEND    Module end\n\nPRGDCBI   Generate code segments for an input file (open,get,close)\n          works with spanned records\n\nPRGDCBO   Generate code segments for an output file (open,put,close)\n          works with spanned records\n\nPRGQUIT   Go directly to the module termination routine\n\nPRGSTEM   Define storage for use in program PROCSTEM which looks\n          after dropping and defining a rexx stem variable\n\nSEGDO     perform a segment of code\n\nSEGS      start a segment of code - when used with PRG* macros\n          the same register is used as code base in all segments\n          so each segment could be up to 4K. Never blow a base.\n\nSEGQUIT   exit from this code segment back to wherever it came from.\n\nSEGE      end of a segment of code\n\nSETRC     set the R_C return code value in PRG*\n\nBEDIT     build an edit pattern to use in ED or EDMK based on the\n          size of the packed decimal field.\n\nXEDIT     build an edit pattern to use in ED or EDMK based on the\n          size of the packed decimal field and actually execute\n          the ED or EDMK.\n\nSTRING    acts like the COBOL STRING verb and allows conversion\n          of integer and packed-decimal values to numeric and\n          register values to hexadecimal display.\n\nSTRINGIT  program used by STRING\n\nTRIM      trim blanks from a variable\n          removes leading and extra blanks from a variable.\n          that is ' A  B ' becomes 'A B   '\n          after completion R15 contains the length of the string\n          ALL=Y can be used to remove all blanks\n          that is ' A  B ' becomes 'AB    '\n\nTRIMIT    program used by TRIM\n\nTSTMP     generate a timestamp from STCKE\n          FORMAT=DB2  - CL26'2017-04-01-12.34.56.789012'\n                 CHAR - CL20'20170401123456789012'\n                 PACK - PL11'020170401123456789012C'\n\nWTOX      does a WTO from MESS_TXT which is defined in PRGDEF\n          and then clears MESS_TXT to spaces unless CLEAR=N\n\nXEDIT     build an edit pattern and execute it\n\nXPACK     pack a character string to hex       C'C1F1' X'A1'\n          uses a translate table that is automatically generated in\n          PRGSTAT if XPACK has been used in the program.\n\nXUNPK     unpack a hex string to character     X'A1' C'C1F1'\n          uses a translate table that is automatically generated in\n          PRGSTAT if XUNPK has been used in the program.\n\n./ ADD NAME=BEDIT\n         MACRO\n&LABEL   BEDIT &INL,&PAD=' ',&DEC='.',&DECP=0,&THOU=',',&SIGN=\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*  This macro builds an edit pattern with the name specified\n.*  which can then be copied into the output area and used in\n.*  and ED or EDMK instruction.\n.*  For EDMK &LABEL.S is equated to the offset from the start of\n.*  the significant byte to be put in register 1 before executing.\n.*  &LABEL.D is equated to the offset from the start to the\n.*  decimal point. A comparison of the values in different edit\n.*  patterns can be used to align the decimal point from multiple\n.*  edit patterns to produce a nicely formatted report.\n.*\n.*       &INL  length of the packed field in bytes\n.*\n.*       &PAD  value for pad character       ' '\n.*       &DEC  value for decimal point       '.'\n.*       &DECP number of decimal places\n.*       &THOU value for thousand separator  ','\n.*       &SIGN value for sign, e.g.  SIGN=-  SIGN='-'  SIGN=' (CR)'\n.*\n.*  BEDIT 5                            for PL5\n.*\n.*  BEDIT 5,DECP=2                     for PL5 with two decimals\n.*\n.*  BEDIT 5,THOU=                      to give no separator\n.*\n.*  BEDIT 3,PAD=0,DEC=',',DECP=2,THOU='.',SIGN=' (CR)'\n.*\n.*  BEDIT 4,PAD=' ',DEC='.',DECP=0,THOU=','\n.*\n.*      MVC   LONG_CHAR1,LONG_EDP_1\n.*      LA    R1,LONG_CHAR1\n.*      AHI   R1,LONG_EDP_1L\n.*      EDMK  LONG_CHAR1,LONG_PACK1\n.*      BCTR  R1,0\n.*      MVI   0(R1),C'$'\n.*\n.* LONG_PACK1     DC    PL8'12345678'\n.* LONG_EDP_1     BEDIT 8,DECP=3,SIGN='-'\n.* LONG_CHAR1     DS    CL(L'LONG_EDP_1)\n.*\n&CNT     SETA  0                         * set pattern count to 0\n&CNTMRK  SETA  0                         * set EDMK offset\n&CNTDEC  SETA  0                         * set decimal point offset\n&SEL     SETC  '20'                      * set digit selector\n&SIG     SETC  '21'                      * set significant digit sel\n&PATN    SETC  ''                        * start with empty pattern\n         AIF   ('&PAD' EQ '').NOPAD\n         AIF   ('&PAD'(1,1) EQ '''').QUOT1  * value in quotes\n&MPAD    SETC  '&PAD'\n         AGO   .QUOT1A\n.QUOT1   ANOP\n&MPAD    SETC  '&PAD'(2,K'&PAD-2)\n.QUOT1A  ANOP\n&MPAD    SETC  C2X('&MPAD')              * convert to hex\n&PATN    SETC  '&PATN&MPAD'              * put in pad character\n&MYLEN   SETA  K'&MPAD/2                 * get length of pad\n         AIF   (&MYLEN NE 1).MERR1       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOPAD   ANOP\n.*\n&LENR    SETA  &INL                      * get input length\n&LENR    SETA  &LENR*2                   * multiply by 2\n&LENR    SETA  &LENR-1                   * subtract 1 gives no. digits\n&LENR    SETA  &LENR-&DECP               * subtract number of decimals\n.*\n.AGAIN   ANOP\n         AIF   (&LENR EQ 2).IS2\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n         AGO   .NOT2\n.IS2     ANOP\n&PATN    SETC  '&PATN&SIG'               * put in significant digit\n&CNTMRK  SETA  &CNT+1                    * set significant offset\n.NOT2    ANOP\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LENR    SETA  &LENR-1                   * subtract 1 from remaining\n         AIF   (&LENR EQ 0).NOAGIN\n&LENT    SETA  (&LENR/3)*3               * divide by 3 and multiply\n.*\n         AIF   ('&THOU' EQ '').NOTHOU    * no thousand separator\n         AIF   (&LENT NE &LENR).NOTHOU   * not multiple of 3 left\n         AIF   ('&THOU'(1,1) EQ '''').QUOT2  * value in quotes\n&MTHOU   SETC  '&THOU'\n         AGO   .QUOT2A\n.QUOT2   ANOP\n&MTHOU   SETC  '&THOU'(2,K'&THOU-2)\n.QUOT2A  ANOP\n&MTHOU   SETC  C2X('&MTHOU')             * convert to hex\n&PATN    SETC  '&PATN&MTHOU'             * put in thousand separator\n&MYLEN   SETA  K'&MTHOU/2                * get length of thou separator\n         AIF   (&MYLEN NE 1).MERR2       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOTHOU  ANOP\n         AIF   (&LENR GT 0).AGAIN        * anything remaining - repeat\n.*\n.NOAGIN  ANOP\n.*\n.* so now we have run out of digits before the decimal place (if any)\n.*\n         AIF   (&DECP EQ 0).TRYSGN       * if none try sign\n         AIF   ('&DEC' EQ '').TRYSGN      * value in quotes\n         AIF   ('&DEC'(1,1) EQ '''').QUOT3  * value in quotes\n&MDEC    SETC  '&DEC'\n         AGO   .QUOT3A\n.QUOT3   ANOP\n&MDEC    SETC  '&DEC'(2,K'&DEC-2)\n.QUOT3A  ANOP\n&MDEC    SETC  C2X('&MDEC')              * convert to hex\n&PATN    SETC  '&PATN&MDEC'              * put in decimal separator\n&CNTDEC  SETA  &CNT                      * set decimal point offset\n&MYLEN   SETA  K'&MDEC/2                 * get length of dec separator\n         AIF   (&MYLEN NE 1).MERR3       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n&LEND    SETA  &DECP                     * copy decimal places\n.*\n.TRYDEC  ANOP\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LEND    SETA  &LEND-1                   * reduce decimal place count\n         AIF   (&LEND NE 0).TRYDEC       * places remaining - so loop\n.*\n.TRYSGN  ANOP\n         AIF   ('&SIGN' EQ '').NOSIGN    * sign byte required\n         AIF   ('&SIGN'(1,1) EQ '''').QUOT9  * value in quotes\n&MSIGN   SETC  '&SIGN'\n         AGO   .QUOT9A\n.QUOT9   ANOP\n&MSIGN   SETC  '&SIGN'(2,K'&SIGN-2)\n.QUOT9A  ANOP\n&MSIGN   SETC  C2X('&MSIGN')             * convert to hex\n&PATN    SETC  '&PATN.&MSIGN'            * put in sign value\n&MYLEN   SETA  K'&MSIGN/2                * get length of record area\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOSIGN  ANOP\n.*\n&LABEL   DC    X'&PATN'                  * create edit pattern\n&LABEL.S EQU   &CNTMRK                   * significant digit offset R1\n&LABEL.D EQU   &CNTDEC                   * decimal point offset\n         MEXIT\n.*\n.MERR1   MNOTE 16,'Pad character can only be 1 byte'\n         MEXIT\n.MERR2   MNOTE 16,'Thousand separator can only be 1 byte'\n         DC    'thou=&THOU'\n         MEXIT\n.MERR3   MNOTE 16,'Decimal separator can only be 1 byte'\n         MEND\n./ ADD NAME=DO\n         MACRO\n         DO    &P1,&FROM=,&TO=,&BY=,&UNTIL=,&WHILE=\n         LCLA  &POSNO\n         PUSHNEST DO\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*                                                                   *\n.*  THE FOLLOWING SECTION HAS BEEN ADDED TO PREVENT MORE THAN ONE    *\n.*  CONDITION FROM BEING SPECIFIED ON A \"DO UNTIL\" OR A \"DO WHILE\" . *\n.*  THE MACRO ONLY EXPECTS ONE CONDITION, BUT DOES NOT REJECT        *\n.*  MULTIPLE CONDITIONS.                                             *\n.*                                                                   *\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n         AIF   (T'&P1 EQ 'O').CHKPOS    IF NO POSITIONAL PARAMETER\n         AIF   ('&P1' EQ 'INF').EXPAND  IF PARAMETER VALID\n         MNOTE 50,'INVALID PARAMETER \"&P1\"'\n         MNOTE 50,'DO MACRO - EXPANSION TERMINATED'\n         MEXIT\n.*\n.CHKPOS  ANOP\n&POSNO   SETA  N'&SYSLIST            NUMBER OF POSITIONAL PARMS\n         AIF   (&POSNO EQ 0).EXPAND\n         MNOTE 50,'TOO MANY POSITIONAL PARAMETERS SPECIFIED'\n         MNOTE 50,'DO MACRO - EXPANSION TERMINATED'\n         MEXIT\n.*\n.EXPAND  ANOP\n.* * * * *  E N D   O F   A D D E D   S E C T I O N  * * * * * * * * *\n         DOPROC &FROM,&TO,&BY,&UNTIL,&WHILE,&P1\n         MEND\n./ ADD NAME=DOEXIT\n  MACRO\n  DOEXIT   &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                   /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=\n GBLA &CCVAL\n GBLA &CTR\n GBLA &SEQ\n GBLA &AI\n GBLA &CI\n GBLA &II\n GBLA &LI\n GBLA &NI\n GBLA &AIND(50)\n GBLA &CIND1(200)\n GBLA &MULT(50)\n GBLA &ST(51)\n GBLC &CIND2(200)\n GBLC &IIND1(100)\n GBLC &IIND2(100)\n GBLC &I22(100)\n GBLC &I23(100)\n GBLC &I24(100)\n GBLC &IIND3(100)\n GBLC &I32(100)\n GBLC &I33(100)\n GBLC &I34(100)\n GBLC &IIND4(100)\n GBLC &I42(100)\n GBLC &I43(100)\n GBLC &IIND5(100)\n GBLC &LIND(101)\n GBLC &NEST(50)\n GBLC &RIND(50)\n PUSHLAB\n&NEST(&NI) SETC '&NEST(&NI)'(1,4)'DO'\n IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                  /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50\n  MEND\n./ ADD NAME=DOPROC\n  MACRO\n  DOPROC &FROM,&TO,&BY,&UNTIL,&WHILE,&P1\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n  LCLA  &I\n  LCLC  &LCLWK1\n    PUSHLAB\n    PUSHINS (EQU,*,,,,&LIND(&LI))\n&ST(&NI)   SETA    &II+1\n    PUSHLAB\n    AIF  (T'&FROM EQ 'O').NOIND\n  AIF   ('&FROM(3)' EQ '').INCR\n    LA &FROM(3),&LIND(&LI)\n.INCR  ANOP\n&I  SETA  &I+1\n  AIF   ('&SYSLIST(&I,2)' EQ '').TEST\n    AIF ('&SYSLIST(&I,2)'(1,1) EQ '(').GENLR\n      AIF ('&SYSLIST(&I,2)' EQ '0').GENSR\n        AIF ('&SYSLIST(&I,2)'(1,1) EQ '-').NEGVAL\n   AIF (T'&SYSLIST(&I,2) EQ 'N').POSVAL\n     LA  &SYSLIST(&I,1),&SYSLIST(&I,2)\n     AGO .TEST\n.POSVAL   AIF (&SYSLIST(&I,2) GE 4096).TSTMAG\n     LA  &SYSLIST(&I,1),&SYSLIST(&I,2)\n     AGO .TEST\n.TSTMAG   AIF (&SYSLIST(&I,2) GE 32768).FULLIT\n     AGO .HALFLIT\n.NEGVAL        ANOP\n&LCLWK1   SETC '&SYSLIST(&I,2)'(2,7)\n   AIF (&LCLWK1 GE 32768).FULLIT\n.HALFLIT       LHI &SYSLIST(&I,1),&SYSLIST(&I,2)\n   AGO .TEST\n.FULLIT        L &SYSLIST(&I,1),=F'&SYSLIST(&I,2)'\n   AGO .TEST\n.GENSR      SR &SYSLIST(&I,1),&SYSLIST(&I,1)\n        AGO .TEST\n.GENLR    LR &SYSLIST(&I,1),&SYSLIST(&I,2)\n.TEST  AIF   (&I LT 3).INCR\n    AIF  (T'&UNTIL NE 'O').ERRMG2\n.CKWHILE     AIF   (T'&WHILE NE 'O').COMPGEN\n&LIND(&LI) EQU  *\n.POSTIND   AIF  (T'&P1 EQ 'O').GETIND\n      AIF   (T'&BY NE 'O').PFB\n        AIF   (T'&TO NE 'O').PFT\n   AIF   ('&FROM(3)' NE '').BCTRZ\n     PUSHINS (BRCT,&FROM(1),&LIND(&LI))\n   AGO   .ERRMG\n.BCTRZ   PUSHINS (BCTR,&FROM(1),&FROM(3))\n        AGO     .ERRMG\n.PFT        PUSHINS (&P1,&FROM(1),&TO(1),&LIND(&LI))\n      MEXIT\n.PFB      PUSHINS (&P1,&FROM(1),&BY(1),&LIND(&LI))\n    MEXIT\n.GETIND    AIF  ('&FROM(3)' EQ '').BCTR1\n      PUSHINS (BCTR,&FROM(1),&FROM(3))\n    MEXIT\n.BCTR1    AIF  (T'&BY NE 'O').FB\n      AIF   (T'&TO EQ 'O').FONLY\n        PUSHINS (BXLE,&FROM(1),&TO(1),&LIND(&LI))\n      MEXIT\n.FONLY      PUSHINS (BRCT,&FROM(1),&LIND(&LI))\n    MEXIT\n.FB    AIF  (T'&TO NE 'O').FTB\n      AIF   ('&BY(2)' EQ '').GENBXLE\n      AIF   ('&BY(2)'(1,1) NE '-').GENBXLE\n    AGO  .GENBXH\n.FTB    AIF  ('&TO(2)' EQ '' OR '&FROM(2)' EQ '').GENBXLE\n      AIF   ('&FROM(2)'(1,1) EQ '(').GENBXLE\n      AIF   ('&FROM(2)'(1,1) EQ '-').TRYTNEG\n      AIF   (T'&FROM(2) NE 'N').GENBXLE\n      AIF   ('&TO(2)'(1,1) EQ '(').GENBXLE\n      AIF   ('&TO(2)'(1,1) EQ '-').GENBXH\n      AIF   (T'&TO(2) NE 'N').GENBXLE\n      AIF   (&FROM(2) GT &TO(2)).GENBXH\n.GENBXLE   PUSHINS (BXLE,&FROM(1),&BY(1),&LIND(&LI))\n    MEXIT\n.TRYTNEG   AIF  ('&TO(2)'(1,1) NE '-').GENBXLE\n    AIF  ('&FROM(2)'(2,7) GE '&TO(2)'(2,7)).GENBXLE\n.GENBXH    PUSHINS (BXH,&FROM(1),&BY(1),&LIND(&LI))\n    MEXIT\n.NOIND      AIF   (T'&WHILE EQ 'O').NOWHILE\n        AIF   (T'&UNTIL NE 'O').COMPGEN\n.* BC    15,&LIND(&LI)\n   BRC   15,&LIND(&LI)\n   PUSHLAB\n&LI   SETA &LI-1\n&LIND(&LI+1)  EQU  *\n   AIF   ('&WHILE(6)' EQ '').OKSUBL\n     STKINS &WHILE\n     MEXIT\n.OKSUBL   STKINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),      X\n        &WHILE(5),&LIND(&LI))\n   AIF   ('&WHILE(2)' EQ '').LABEL\n     PUSHINS (BRC,&CCVAL,&LIND(&LI+1))\n     MEXIT\n.LABEL   PUSHINS   (BRC,&CCVAL,&LIND(&LI+1),,,&LIND(&LI))\n   MEXIT\n.NOWHILE     AIF   (T'&UNTIL EQ 'O').TRYINF\n&LIND(&LI)   EQU   *\n.UNT        STKINS &UNTIL\n        PUSHINS (BRC,15-&CCVAL,&LIND(&LI))\n      MEXIT\n.TRYINF        AIF   ('&P1' NE 'INF').ERRMG1\n&LIND(&LI)  EQU *\n   PUSHINS (BRC,15,&LIND(&LI))\n        MEXIT\n.COMPGEN     AIF   ('&WHILE(6)' EQ '').OK\n        STKINS &WHILE\n        AGO   .BCHINST\n.OK      STKINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),        X\n        &WHILE(5),&LIND(&LI))\n      AIF   (N'&WHILE GT 1).ENDCOMP\n&LIND(&LI)     BC    15-&CCVAL,&LIND(&LI-1)\n*&LIND(&LI)     BRC   15-&CCVAL,&LIND(&LI-1)\n        AGO   .FLAGEQU\n.ENDCOMP     ANOP\n&ST(&NI+1)   SETA  &II\n      POPINS &ST(&NI+1)\n.BCHINST     BC    15-&CCVAL,&LIND(&LI-1)\n*.BCHINST     BRC   15-&CCVAL,&LIND(&LI-1)\n.FLAGEQU     ANOP\n&NEST(&NI)   SETC  '   Y'.'&NEST(&NI)'(5,4)\n      AIF   (T'&FROM NE 'O').POSTIND\n    AGO  .UNT\n.ERRMG  MNOTE 4,'POSITIONAL PARAMETER IGNORED. BCT/BCTR LOOP END USED'\n  MEXIT\n.ERRMG2  MNOTE 4,'UNTIL KEYWORD INVALID WITH INDEXING GROUP. IGNORED'\n  AGO   .CKWHILE\n.ERRMG1  MNOTE 4,'NO WHILE,UNTIL,OR INDEXING PARAMETERS ON DO MACRO.'\n  MEND\n./ ADD NAME=ELSE\n  MACRO\n  ELSE\n        COPY GBLVARS\n  GBLC  &LASTIF\n  IFTEST ELSE\n&LIND(&LI+1) SETC '&LIND(&LI)'\n&LI  SETA &LI-1\n  PUSHLAB\n.*BC    15,&LIND(&LI)\n  BRC   15,&LIND(&LI)\n&LIND(&LI+1)   EQU   *\n        MEND\n./ ADD NAME=ELSEIF\n MACRO\n ELSEIF  &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                     /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=\n  COPY GBLVARS\n  GBLC  &LASTIF\n  IFTEST ELSEIF\n&LIND(&LI+1) SETC '&LIND(&LI)'\n&LI  SETA  &LI-1\n  PUSHLAB\n.*BC   15,&LIND(&LI-1)\n  BRC  15,&LIND(&LI-1)\n&LIND(&LI+1) EQU   *\n  IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                 /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50\n MEND\n./ ADD NAME=ENDDO\n  MACRO\n  ENDDO\n  GBLA &ST(51),&NI,&LI,&II\n  POPINS &ST(&NI)\n&II  SETA &II-1\n  POPNEST DO\n&LI  SETA &LI-2\n  MEND\n./ ADD NAME=ENDEVAL\n         MACRO\n&LAB     ENDEVAL\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OELSE(16)\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.* OPT INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTI(16)\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD NE 0).END0A\n         MNOTE 16,'UNMATCHED ENDOPT'\n         MEXIT\n.END0A   ANOP\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         AGO   .REDUCE\n.END1    ANOP\n.* SET OPTION INDICATOR OFF\n&OPTN(&OD) SETB (0)\n.IF3     AIF   ((&OELSE(&OD)) EQ (1)).END3\n.* WHEN NO OPTELSE CLAUSE NEED CURRENT GENERATION NUMBER LABEL\n@D&OD.N&ON(&OD) EQU   *\n.END3    ANOP\n&OELSE(&OD) SETB (0)\n&OPTI(&OD) SETB (0)\n.* SET LABEL FOR STRAIGHT END EXIT\n@D&OD.E&OE(&OD) EQU   *\n.REDUCE  ANOP\n.* REDUCE DEPTH COUNT\n&OD      SETA  &OD-1\n         MEND\n./ ADD NAME=ENDIF\n  MACRO\n  ENDIF\n        COPY GBLVARS\n  GBLC  &LASTIF\n  IFTEST ENDIF\n  POPNEST IF\n&LIND(&LI) EQU *\n&LIND(&LI-1) EQU *\n&LI  SETA &LI-2\n  MEND\n./ ADD NAME=EVALUATE\n         MACRO\n&LAB     EVALUATE &OPCODE,&OPER1,&OPER2\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* OPCODE FOR EACH POSSIBLE TYPE\n         GBLC  &OP(16)\n.*\n.* COMPONENTS OF OP1 FOR EACH POSSIBLE DEPTH\n         GBLC  &OP1(16)\n.*\n.* OP2.REP.TYPE.LTH FOR EACH POSSIBLE DEPTH\n         GBLC  &OP2(16)\n.*\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.*\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.*\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.*\n.* IMMEDIATE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OI(16)\n.*\n.* QUOTES INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OQ(16)\n.*\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.*\n.* STATUS INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OS(16)\n.*\n.* LOCAL WORK FIELDS\n         LCLA  &A\n         LCLC  &C1,&C2,&C3,&C4,&C5,&C6,&C7,&C8\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD EQ 0).END0A\n.IF0B    AIF   ((&OPTN(&OD)) EQ (0)).END0B\n         MNOTE 16,'DUPLICATE OPTION'\n&OS(&OD) SETB  (1)\n         MEXIT\n.END0B   ANOP\n.END0A   ANOP\n.* INCREMENT COUNT OF DEPTH OF NESTING\n&OD      SETA  &OD+1\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         MEXIT\n.END1    ANOP\n.* SET OPTION INDICATOR FOR THIS DEPTH (1= OPTION MACRO LAST MET)\n&OPTN(&OD) SETB (1)\n.* ZEROISE STATUS INDICATOR FOR THIS DEPTH (1= OPTION STATEMENT ERROR)\n&OS(&OD) SETB  (0)\n.* ZEROISE IMMEDIATE INDICATOR FOR THIS DEPTH (1= CLI OPCODE)\n&OI(&OD) SETB  (0)\n.* ZEROISE QUOTES INDICATOR FOR THIS DEPTH (1= QUOTES EXPECTED)\n&OQ(&OD) SETB  (0)\n.* INCREMENT LABEL GENERATION NUMBER FOR THIS DEPTH\n&ON(&OD) SETA  &ON(&OD)+1\n.* SAVE LABEL GENERATION NUMBER FOR END LABEL FOR THIS DEPTH\n&OE(&OD) SETA  &ON(&OD)\n.* INCREMENT LABEL GENERATION NUMBER FOR THIS DEPTH\n&ON(&OD) SETA  &ON(&OD)+1\n.IF2A    AIF  (K'&OPCODE GT 0).END2A\n         MNOTE 16,'NO OPCODE SPECIFIED'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.END2A   ANOP\n.OKOLTH  AIF   ('&OPCODE'(1,1) EQ 'C').OKC\n         MNOTE 16,'INVALID OPCODE'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.OKC     AIF   ('&OPCODE' NE 'CLI').END2AA\n&OI(&OD) SETB  (1)\n.END2AA  ANOP\n&OP(&OD) SETC  '&OPCODE'\n.IF2B    AIF   (T'&OPER1 NE 'O').END2B\n         MNOTE 16,'NO FIRST OPERAND SPECIFIED'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.END2B   ANOP\n&OP1(&OD) SETC '&OPER1'\n.IF3     AIF   (T'&OPER2 NE 'O').ELS3\n&OQ(&OD) SETB  (0)\n&OP2(&OD) SETC ''\n         AGO   .END3\n.ELS3    ANOP\n.IF3A    AIF   (K'&OPER2 LE 8).END3A\n         MNOTE 16,'THIRD PARAMETER OVERLONG'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.END3A   ANOP\n         AIF   ('&OPER2'(1,1) NE '=').TRYI\n         AIF   ((&OI(&OD)) EQ (0)).TRYSOLO\n         MNOTE 16,'ILLEGAL IMMEDIATE OPERAND'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.TRYSOLO AIF   (K'&OPER2 NE 1).OKOP2\n&OQ(&OD) SETB  (0)\n&OP2(&OD) SETC '&OPER2'\n         AGO   .END3\n.TRYI    AIF   ((&OI(&OD)) EQ (1)).OKOP2\n         MNOTE 16,'ILLEGAL LITERAL'\n&OS(&OD) SETB  (1)\n         AGO   .MEND\n.OKOP2   ANOP\n&OQ(&OD) SETB  (1)\n&OP2(&OD) SETC '&OPER2'\n.END3    ANOP\n.MEND    ANOP\n         BRU   @D&OD.N&ON(&OD)\n         MEXIT\n.*\n.*  EXAMPLES OF USING EVALUATE\n.*\n.*  EVALUATE\n.*\n.*  EVALUATE is used to select which of several pieces of code is to\n.*  be executed when that selection depends upon the value of a\n.*  particular field.  In such cases, EVALUATE is more elegant, more\n.*  readable, and more logical than the overused ELSEIF.\n.*  The general format is:\n.*\n.*               EVALUATE opcode,op1(,op2)\n.*                 WHEN op2value\n.*                   code\n.*                 WHEN op2value1-op2value2\n.*                   code\n.*                 WHEN op2value1-op2value2,op2value\n.*                   code\n.*                 OTHERWSE\n.*                   code\n.*               ENDOPT\n.*\n.*  where: 'opcode' is one of - CLC, CLI, CP, CH, C, CLR, CL, CR;\n.*         'op1' is the address of the determinant field;\n.*         'op2' is the constant type and length (if this is common\n.*               to all the WHEN values).\n.*\n.*  The EVALUATE macro declares the type of comparison to be done on\n.*  the determinant field.  It is followed by a series of WHEN clauses,\n.*  each of which specifies a list of values and/or ranges, and heads\n.*  the lines of code to be executed if that WHEN is selected. Only\n.*  one WHEN clause, the first to satisfy the test, will be executed.\n.*  OPTELSE, if coded, should follow the final WHEN (and will often\n.*  head a 'value not found' error procedure).  The OTHERWSE code will\n.*  be executed if none of the WHEN values matches the determinant;\n.*  if there is no match and no OTHERWSE clause, processing continues\n.*  normally, without any of the WHEN clauses having been executed.\n.*  ENDOPT terminates the EVALUATE block.\n.*\n.*  Processing will be most efficient when the WHEN clauses are written\n.*  in order of decreasing probability of selection, and when the\n.*  values within each WHEN are in order of decreasing probability of\n.*  occurrence.\n.*  EVALUATE blocks can be nested to a maximum depth of 16.\n.*  No registers are corrupted by OPTION.\n.*\n.*  The following examples illustrate OPTION's commoner modes of use.\n.*\n.*  1.  EVALUATE CP,COUNT,=P\n.*        WHEN '1'\n.*          code\n.*        WHEN '2'\n.*          code\n.*        WHEN '3','4','5'\n.*          code\n.*        WHEN '6'-'99'\n.*          code\n.*        OTHERWSE\n.*          code\n.*      ENDOPT\n.*\n.*  2.  EVALUATE CP,TAX(3)\n.*        WHEN =P'0'\n.*          code\n.*        WHEN =P'1',=P'1000'\n.*          code\n.*        WHEN PFLDA(3)-PFLDB(5),0(5,R6)\n.*          code\n.*        WHEN PHIGH\n.*          code\n.*      ENDOPT\n.*\n.*  3.  EVALUATE CLI,BDETCRR3,C\n.*        WHEN 'A'\n.*          ZAP ACUSELDS,=P'-5'\n.*        WHEN 'B'\n.*          ZAP ACUSELDS,=P'-4'\n.*        WHEN 'D'\n.*          ZAP ACUSELDS,=P'-2'\n.*        WHEN 'E'\n.*          ZAP ACUSELDS,=P'-1'\n.*        OTHERWSE\n.*          PERFORM ERRSCORE\n.*      ENDOPT\n.*\n.*  4.  EVALUATE CLI,BDETDKCN,X           SELECT BY COMPANY\n.*        WHEN '53'                       COUNTRY GARDEN\n.*          PERFORM CGPOST\n.*        WHEN '26'                       SHOWCASE\n.*          MVI OSNOPPCH,C'0'             NOT YET CHARGED\n.*          ZAP OSNOPANP,=P'150'          POST AND PACK CHARGE\n.*        WHEN '63'                       SHOPPING SENSE\n.*          MVI OSNOPPCH,C'0'             NOT YET CHARGED\n.*          ZAP OSNOPANP,=P'195'          POST AND PACK CHARGE\n.*        OTHERWSE\n.*          IF (CLC,CUSTNO(3),E,=C'184')  BARGAIN BASEMENT\n.*            MVI OSNOPPCH,C'0'           NOT YET CHARGED\n.*            ZAP OSNOPANP,=P'200'        POST AND PACK CHARGE\n.*          ELSE\n.*            IF (CLC,CUSTNO(3),E,=C'183')  NEW HORIZONS\n.*              PERFORM NHPOST\n.*            ENDIF\n.*          ENDIF\n.*      ENDOPT\n.*\n.*  5.  EVALUATE CH,R2,=H\n.*        WHEN '0'\n.*          PERFORM READPBDF\n.*        WHEN '4'\n.*          L R5,0(R1)\n.*          ST R5,PARMADDR\n.*          .\n.*          .\n.*          .\n.*        WHEN '12'\n.*          IF (CLI,FIRSTSW,E,C'Y')\n.*            MVI FIRSTSW,C'N'\n.*          ENDIF\n.*          PERFORM READPBCF\n.*      ENDOPT\n.*\n.*  6.  EVALUATE CLC,ACUSCLUS,=CL2\n.*        WHEN '04','13','14','27'\n.*          MVC C200PRCI,=C'20'\n.*        WHEN '19','24'-'26'\n.*          MVC C200PRCI,=C'30'\n.*        WHEN '10','11','16'-'18','22','29'\n.*          MVC C200PRCI,=C'40'\n.*        WHEN '01','03','07','08','12'\n.*          MVC C200PRCI,=C'50'\n.*        WHEN '05','06','09','15','20','21','23','28','30'\n.*          MVC C200PRCI,=C'60'\n.*        OTHERWSE\n.*          MVC C200PRCI,=C'70'\n.*      ENDOPT\n.*\n.*  In the above example, since the implicit length of ACUSCLUS is\n.*  two bytes, 'OPTION CLC,ACUSCLUS,=C' could have been coded;\n.*  or even 'OPTION CLC,ACUSCLUS' with 'OPT =C'04',=C'13'...'.\n.*\n.*  7.  EVALUATE C,R2\n.*        WHEN =F'0',0(R3)\n.*          code\n.*        WHEN 4(R3)-8(R3)\n.*          code\n.*        WHEN FWORD1-FWORD2\n.*          code\n.*        WHEN =F'4000'-FWORD3\n.*          code\n.*        WHEN =4X'FF'\n.*          code\n.*      ENDOPT\n.*\n.*  8.  EVALUATE CR,R2\n.*        WHEN R6-R7,R8\n.*          code\n.*        WHEN R9\n.*          code\n.*      ENDOPT\n.*\n         MEND\n./ ADD NAME=GBLVARS\n   GBLA &CCVAL        COND CODE VARIABLE\n   GBLA &CTR        MACRO PARAMETER COUNTER\n   GBLA &SEQ        LABEL NUMBER GENERATOR\n   GBLA &AI        INDEX FOR TOTAL NO. CASES STK\n   GBLA &CI        INDEX FOR CASE AND LBL NO. STKS\n   GBLA &II        PTR TO INST STKS\n   GBLA &LI        INDEX FOR LABEL NUMBER STK\n   GBLA &NI        PTR TO NEXT STK\n   GBLA &AIND(50)       TOTAL CASES STK\n   GBLA &CIND1(200)       CASE NUMBER STK\n   GBLA &MULT(50)       CASE NUMBER MULTIPLIER\n   GBLA &ST(51)        INST STK INCREASE AT EACH LEVEL\n   GBLC &CIND2(200)       LABEL NUMBER STK FOR CASES\n   GBLC &IIND1(100)       INSTRUCTION STK 1\n   GBLC &IIND2(100)       INSTRUCTION STK 2\n   GBLC &I22(100)       INSTRUCTION STK 2,2ND PART\n   GBLC &I23(100)       INSTRUCTION STK 2,3RD PART\n   GBLC &I24(100)       INSTRUCTION STK 2,4TH PART\n   GBLC &IIND3(100)       INSTRUCTION STK 3\n   GBLC &I32(100)       INSTRUCTION STK 3,2ND PART\n   GBLC &I33(100)       INSTRUCTION STK 3,3RD PART\n   GBLC &I34(100)       INSTRUCTION STK 3,4TH PART\n   GBLC &IIND4(100)       INSTRUCTION STK 4\n   GBLC &I42(100)       INSTRUCTION STK 4,2ND PART\n   GBLC &I43(100)       INSTRUCTION STK 4,3RD PART\n   GBLC &IIND5(100)       INSTRUCTION NAME STACK\n   GBLC &LIND(101)       LABEL NUMBER STK\n   GBLC &NEST(50)       NESTING STK\n   GBLC &RIND(50)       REG STK FOR CASENTRY MACRO\n   GBLC &SEGNAME       SEGMENT NAME\n   GBLC &SEGSTRT       SEGMENT START\n./ ADD NAME=GETCC\n  MACRO\n  GETCC &COND\n  GBLA  &CCVAL\n  LCLC  &LWK1\n  AIF   ('&COND'(1,1) LT '0' OR '&COND'(1,1) GT '9').NOTNUM\n&CCVAL    SETA  &COND\n    MEXIT\n.NOTNUM  AIF   (K'&COND NE 1).TWOCHAR\n&LWK1    SETC  '&COND'\n    AGO  .CALCC\n.TWOCHAR AIF   (K'&COND NE 2).INVCOND\n    AIF  ('&COND'(1,1) NE 'N').OTHERMN\n&LWK1      SETC  '&COND'(2,1)\n    AGO  .CALCC\n.OTHERMN   AIF  ('&COND' EQ 'EQ').BC8\n    AIF  ('&COND' EQ 'LT').BC4\n    AIF  ('&COND' NE 'LE').TRYGT\n&CCVAL      SETA  13\n    MEXIT\n.TRYGT    AIF  ('&COND' EQ 'GT').BC2\n    AIF  ('&COND' NE 'GE').INVCOND\n&CCVAL      SETA  11\n    MEXIT\n.CALCC  AIF   ('&LWK1' NE 'O').TRYH\n&CCVAL    SETA 1\n  AGO   .TSTN\n.TRYH  AIF   ('&LWK1' EQ 'P' OR '&LWK1' EQ 'H').BC2\n    AIF ('&LWK1' EQ 'L' OR '&LWK1' EQ 'M').BC4\n      AIF ('&LWK1' EQ 'E' OR '&LWK1' EQ 'Z').BC8\n        AGO   .INVCOND\n.BC8      ANOP\n&CCVAL      SETA 8\n      AGO   .TSTN\n.BC4    ANOP\n&CCVAL    SETA 4\n    AGO  .TSTN\n.BC2  ANOP\n&CCVAL  SETA  2\n.TSTN  AIF   ('&COND'(1,1) NE 'N').DONE\n&CCVAL      SETA  15-&CCVAL\n.DONE  MEXIT\n.INVCOND ANOP\n&CCVAL  SETA  15\n  MNOTE 4,'INVALID CONDITION MNEMONIC. NOP GENERATED'\n  MEND\n./ ADD NAME=IF\n      MACRO\n      IF &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,                     /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50,&CC=\n      COPY  GBLVARS\n      GBLC  &LASTIF\n      IFTEST IF\n      PUSHNEST IF\n      PUSHLAB\n      PUSHLAB\n      IFPROC &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,             /\n               &P11,&P12,&P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,      /\n               &P21,&P22,&P23,&P24,&P25,&P26,&P27,&P28,&P29,&P30,      /\n               &P31,&P32,&P33,&P34,&P35,&P36,&P37,&P38,&P39,&P40,      /\n               &P41,&P42,&P43,&P44,&P45,&P46,&P47,&P48,&P49,&P50\n      MEND\n./ ADD NAME=IFPROC\n    MACRO\n    IFPROC\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n    LCLB &ANDIND,&ORIND\n    PUSHLAB\n&CTR    SETA 2\n&ST(&NI+1) SETA &II+1\n&NEST(&NI) SETC '  R'.'&NEST(&NI)'(4,5)\n    AIF (T'&SYSLIST(1) EQ 'O').LOOP\n    AIF (&SYSLIST(1) LE 0 OR &SYSLIST(1) GE 15).INVALCC\n&CCVAL      SETA &SYSLIST(1)\n      AIF ('&SYSLIST(2)' EQ '').ENDBOOL\n  MNOTE 4,'CC KEYWORD USED. OTHER PARAMETERS IGNORED'\n  AGO .ENDBOOL\n.INVALCC MNOTE 4,'CC OUTSIDE VALID RANGE OF 1 TO 14. NOP GENERATED'\n&CCVAL  SETA  15\n    AGO .ENDBOOL\n.LOOP    STKINS &SYSLIST(&CTR),&SYSLIST(&CTR+1),&SYSLIST(&CTR+2),      /\n               &SYSLIST(&CTR+3),&SYSLIST(&CTR+4)\n    AIF ('&SYSLIST(&CTR+1)' EQ 'AND').ANDPROC\n    AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF').TESTOR\n.ANDPROC     PUSHINS (BRC,15-&CCVAL,&LIND(&LI-1))\n&ANDIND      SETB 1\n      AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF' OR NOT &ORIND).TESTLP\n        POPINS &ST(&NI+1)\n&LIND(&LI)     EQU *\n&ORIND        SETB 0\n&LI        SETA &LI-1\n        PUSHLAB\n      AGO .TESTLP\n.TESTOR    AIF ('&SYSLIST(&CTR+1)' EQ 'OR').ORPROC\n    AIF ('&SYSLIST(&CTR+1)' NE 'ORIF').TESTLP\n.ORPROC      PUSHINS (BRC,&CCVAL,&LIND(&LI))\n&ORIND      SETB 1\n      AIF ('&SYSLIST(&CTR+1)' NE 'ORIF' OR NOT &ANDIND).TESTLP\n        PUSHINS (EQU,*,,,,&LIND(&LI-1))\n&ANDIND        SETB 0\n        PUSHLAB\n&LI        SETA &LI-1\n&LIND(&LI-1)   SETC '&LIND(&LI+1)'\n.TESTLP    ANOP\n&CTR    SETA &CTR+2\n    AIF ('&SYSLIST(&CTR-1)' NE '').LOOP\n.ENDBOOL     AIF ('&NEST(&NI)'(5,4) EQ 'DO').DOEND\n      POPINS &ST(&NI+1)\n.*    BC   15-&CCVAL,&LIND(&LI-1)\n      BRC  15-&CCVAL,&LIND(&LI-1)\n      AIF (NOT &ORIND).POPLBL\n&LIND(&LI)     EQU *\n.POPLBL      ANOP\n&LI      SETA &LI-1\n    MEXIT\n.DOEND    ANOP\n&CTR    SETA  &ST(&NI+1)\n    AGO  .ENDLBL\n.NXTLBL    AIF  ('&IIND3(&CTR)' NE '&LIND(&LI)').INCTR\n&IIND3(&CTR) SETC  '&LIND(&LI-3)'\n.INCTR    ANOP\n&CTR    SETA  &CTR+1\n.ENDLBL    AIF  (&CTR LE &II).NXTLBL\n    POPINS &ST(&NI+1)\n.*  BC   &CCVAL,&LIND(&LI-3)\n    BRC  &CCVAL,&LIND(&LI-3)\n    AIF  (NOT &ANDIND).POP2LBL\n&LIND(&LI-1) EQU  *\n.POP2LBL   ANOP\n&LI    SETA   &LI-2\n&NEST(&NI) SETC  '   Y'.'&NEST(&NI)'(5,4)\n    MEND\n./ ADD NAME=IFTEST\n  MACRO\n  IFTEST &THISIF\n  GBLC  &LASTIF\n  COPY  GBLVARS\n.*\n.*   THIS MACRO ENSURES THAT THE 'IF' MACROS HAVE BEEN CODED\n.*   IN A SYNTACTICALLY CORRECT SEQUENCE.\n.*\n  AIF   ('&LASTIF' EQ '').OK\n  AIF   ('&LASTIF' EQ 'ENDIF').OK\n  AIF   ('&THISIF' EQ 'ENDIF').OK\n  AIF   ('&THISIF' EQ 'IF').OK\n  AIF   ('&THISIF' EQ 'ELSEIF' AND '&LASTIF' EQ 'ELSEIF').OK\n  AIF   ('&THISIF' EQ 'ELSEIF' AND '&LASTIF' EQ 'IF').OK\n  AIF   ('&THISIF' EQ 'ELSE' AND '&LASTIF' EQ 'ELSEIF').OK\n  AIF   ('&THISIF' EQ 'ELSE' AND '&LASTIF' EQ 'IF').OK\n MNOTE 8,'ERROR - ''&THISIF'' MACRO INVALID AFTER ''&LASTIF''.'\n  MEXIT\n.*\n.OK  ANOP\n&LASTIF  SETC  '&THISIF'\n  MEND\n./ ADD NAME=JRGTIOT\n* % GOTO TIOTBSL;   /*\n*\n*  THIS IS A COPY OF THE PUBLIC DOMAIN MVT MACRO WHICH HAS\n*  BEEN AMENDED TO MAKE THE 2 DSECTS EXPLICIT AND THEREFORE\n*  EASIER TO USE.\n*\n         MACRO\n         JRGTIOT\n*\n*    RELEASE 20, 3/04/71, LEVEL=1\n*    RELEASE 21, 3/05/71, LEVEL=1\n*\nTIOT1    DSECT\nTIOCNJOB DS    CL8  -       JOBNAME\nTIOCSTEP DS    CL16 -       STEPNAME\n***********************************************************************\n**             **\n*   DD ENTRY:             *\n*              *\n* A DD ENTRY INCLUDES A DEVICE ENTRY. BEFORE ALLOCATION, THERE  *\n* MAY BE SEVERAL DEVICE ENTRIES IN EACH DD ENTRY.        *\n**             **\n***********************************************************************\nTIOENTRY EQU   *\nTIOENTRYD DSECT\nTIOELNGH DS    FL1 -        LENGTH OF THIS ENTRY\nTIOESTTA DS    B -        STATUS -A-\nTIOSLTYP EQU   X'80' -        NONSTANDARD LABEL (NOTE 1)\nTIOSPLTP EQU   X'40' -        SPLIT CYLINDER PRIMARY\nTIOSPLTS EQU   X'20' -        SPLIT CYLINDER SECONDARY\nTIOSJBLB EQU   X'10' -        JOBLIB INDICATOR\nTIOSDADS EQU   X'08' -        DADSM ALLOCATION NECESSRY\nTIOSLABL EQU   X'04' -        LABELED/UNLABELED (NOTE 1)\nTIOSDSP1 EQU   X'02' -        DISPOSITION BIT 1\nTIOSDSP2 EQU   X'01' -        DISPOSITION BIT 2\n*\n*   NOTE 1 - IF BOTH BITS TIOSLTYP AND TIOSLABL ARE ON, THE VOLUME\n*      IS A TAPE AND HAS AN 'ANSI' LABEL.\n*\nTIOERLOC DS    0CL2 -        REL. LOC OF POOL\nTIOEWTCT DS    CL1 -        COUNT OF NUMBER OF DEVICES\n*        DURING ALLOCATION STILL ELIGIBLE TO DADSM ALLOCATE\n*        THIS DATA SETS REQUEST\nTIOELINK DS    CL1 -        DURING ALLOCATION OF ALL\n*        BUT POOLS THIS WILL BE A LINK TO THE APPROPRIATE PRIME\n*        SPLIT,UNIT AFFIM,VOL AFFIN OR SUBALLOCATE\n  SPACE 1\n* FOLLOWING BIT MASKS APPLY TO THE 'TIOELINK' FIELD\n  SPACE 1\nTIOSYOUT EQU   X'80' - SYSOUT DATA SET THAT CONTAINS DATA\nTIOTOPEN EQU   X'40' - DATA SET IS OPEN\nTIOTTERM EQU   X'20' - THIS IS A TERMINAL\nTIOEDYNM EQU   X'10' - 'DYNAM' KEYWORD USED\nTIOEQNAM EQU   X'08' - 'QNAME' KEYWORD USED\nTIOESYIN EQU   X'04' -  SYSIN\nTIOESYOT EQU   X'02' -  SYSOUT\nTIOESSDS EQU   X'02' -        ENTRY FOR A SUBSYSTEM DATA SET*\n*\nTIOEDDNM DS    CL8 -        DDNAME\nTIOEJFCB DS    CL3 -        JFCB DISK ADDR\nTIOESTTC DS    B -        STATUS -C-\nTIOSDKCR EQU   X'80' -        CORE/DISK ADDRESS\nTIOSDEFR EQU   X'40' -        DEFERRED MOUNT\nTIOSAFFP EQU   X'20' -        UNIT AFFINITY PRIMARY\nTIOSAFFS EQU   X'10' -        UNIT AFFINITY SECONDARY\nTIOSVOLP EQU   X'08' -        VOLUME AFFINITY PRIMARY\nTIOSVOLS EQU   X'04' -        VOLUME AFFINITY SECONDARY\nTIOSBALP EQU   X'02' -        SUBALLOCATE PRIMARY\nTIOSBALS EQU   X'01' -        SUBALLOCATE SECONDARY\n***********************************************************************\n**             **\n*   DEVICE ENTRIES:            *\n*              *\n*      1. DURING ALLOCATION:           *\n*   ONE DEVICE ENTRY FOR EACH DEVICE REQUIRED, OR FOR    *\n*   EACH PUBLIC DEVICE ELIGIBLE.         *\n*              *\n*      2. DURING PROBLEM PROGRAM:          *\n*   ONE DEVICE ENTRY FOR EACH ALLOCATED DEVICE       *\n*              *\n***********************************************************************\nTIOESTTB DS    B -        STATUS -B-\nTIOSUSED EQU   X'80' -        DATA SET IS ON DEVICE\nTIOSREQD EQU   X'40' -        DATA SET WILL USE DEVICE\nTIOSPVIO EQU   X'20' -        DEVICE VIOLATES SEPARATION\nTIOSVLSR EQU   X'10' -        VOLUME SERIAL PRESENT\nTIOSSETU EQU   X'08' -        SETUP MESSAGE REQUIRED\nTIOSMNTD EQU   X'04' -        MOUNTED\nTIOSUNLD EQU   X'02' -        UNLOAD REQUIRED\nTIOSVERF EQU   X'01' -        VERIFICATION REQUIRED\nTIOEFSRT DS    AL3 -        SRT POINTER\n*  TIOT POOL ENTRY\nPOOLSTAR EQU   *\n  DS    CL1 -\nTIOPNSLT DS    FL1 -        NR.OF SLOTS FOR POOL\n  DS    CL1 -\nTIOPNSRT DS    FL1 -        NR.OF DEVICES (FILLED\n*           SLOTS)\nTIOPPOOL DS    CL8 -        POOL NAME\nTIOPSTTB DS    XL1 -        STATUS OF SLOT\nTIOPSLOT DS    AL3 -        SRT ADDRESS OR EMPTY SLOT\nTIOTFEND DS    CL4 -        FINAL END OF AN ENTRY\n*           OR THE TIOT\n  MEND\n* */ %TIOTBSL:;\n*\n* /* RELEASE 20, 3/04/71, LEVEL=1         */\n* /* RELEASE 21, 3/05/71, LEVEL=1         */\n*\n* DECLARE\n* 1 TIOT1 BASED(TIOTPTR) BDY(WORD),\n*     5 TIOCNJOB CHAR(8),  /*  JOB NAME       */\n*     5 TIOCSTEP CHAR(16);  /*  STEP NAME       */\n*/********************************************************************/\n*/*             */\n*/* DD ENTRY:            */\n*/*             */\n*/* A DD ENTRY INCLUDES A DEVICE ENTRY. BEFORE ALLOCATION, THERE */\n*/* MAY BE SEVERAL DEVICE ENTRIES IN EACH DD ENTRY.       */\n*/*             */\n*/********************************************************************/\n*%IF TIOENPTR=''  %THEN\n*%TIOENPTR='ADDR(TIOT1)+24';\n* DECLARE\n*     1 TIOENTRY   BASED(TIOENPTR),\n*    10 TIOELNGH PTR(8),  /* LENGTH OF THIS ENTRY      */\n*    10 TIOESTTA BIT(8),  /* STATUS -A-       */\n*      11 TIOSLTYP BIT(1), /* NONSTANDARD LABEL (NOTE 1)*/\n*      11 TIOSPLTP BIT(1), /* SPLIT CYLINDER PRIMARY    */\n*      11 TIOSPLTS BIT(1), /* SPLIT CYLINDER SECONDARY  */\n*      11 TIOSJBLB BIT(1), /* JOBLIB INDICATOR      */\n*      11 TIOSDADS BIT(1), /* DADSM ALLOCATION NECESSARY*/\n*      11 TIOSLABL BIT(1), /* LABELED/UNLABELED (NOTE 1)*/\n*      11 TIOSDSP1 BIT(1), /* DISPOSITION BIT 1      */\n*      11 TIOSDSP2 BIT(1), /* DISPOSITION BIT 2      */\n*/*   NOTE 1 - IF BOTH BITS TIOSLTYP AND TIOSLABL ARE ON, THE VOLUME */\n*/*        IS A TAPE AND HAS AN 'ANSI' LABEL.       */\n*    10 TIOERLOC CHAR(2),  /* REL. LOC OF POOL      */\n*    15 TIOEWTCT CHAR(1), /* COUNT OF NUMBER OF DEVICES\n*        DURING ALLOCATION STILL\n*        ELIGIBLE TO DADSM ALLOCATE\n*        THIS DATA SET REQUEST     */\n*    15 TIOELINK CHAR(1), /* DURING ALLOCATION OF\n*        ALL BUT POOLS THIS WILL BE\n*        A LINK TO THE APPROPRIATE\n*        PRIME SPLIT,UNIT AFFIN\n*        VOL.,AFFIN OR SUBALLOCATE */\n*/* FOLLOWING BIT MASKS APPLY TO 'TIOELINK' FIELD */\n*       17 TIOSYOUT BIT(1), /* SYSOUT D.S.THAT HAS DATA */\n*       17 TIOTOPEN BIT(1), /* DATA SET IS OPEN      */\n*       17 TIOTTERM BIT(1), /* THIS IS A TERMINAL      */\n*       17 TIOEDYNM BIT(1), /* 'DYNAM' KEYWORD USED     */\n*       17 TIOEQNAM BIT(1), /* 'QNAME' KEYWORD USED     */\n*       17 * BIT(3),  /* RESERVED */\n*    10 TIOEDDNM CHAR(8),  /* DDNAME       */\n*    10 TIOEJFCB CHAR(3),  /* JFCB DISK ADDR      */\n*    10 TIOESTTC BIT(8),  /* STATUS -C-       */\n*     11 TIOSDKCR BIT(1),  /* CORE/DISK ADDRESS      */\n*     11 TIOSDEFR BIT(1),  /* DEFERRED MOUNT      */\n*     11 TIOSAFFP BIT(1),  /* UNIT AFFINITY PRIMARY     */\n*     11 TIOSAFFS BIT(1),  /* UNIT AFFINITY SECONDARY   */\n*     11 TIOSVOLP BIT(1),  /* VOLUME AFFINITY PRIMARY   */\n*     11 TIOSVOLS BIT(1),  /* VOLUME AFFINITY SECONDARY */\n*     11 TIOSBALP BIT(1),  /* SUBALLOCATE PRIMARY      */\n*     11 TIOSBALS BIT(1),  /* SUBALLOCATE SECONDARY     */\n*/********************************************************************/\n*/*             */\n*/* DEVICE ENTRIES:           */\n*/*             */\n*/*    1. DURING ALLOCATION:          */\n*/*   ONE DEVICE ENTRY FOR EACH DEVICE REQUIRED, OR FOR   */\n*/*   EACH PUBLIC DEVICE ELIGIBLE.        */\n*/*             */\n*/*    2. DURING PROBLEM PROGRAM:         */\n*/*   ONE DEVICE ENTRY FOR EACH ALLOCATED DEVICE      */\n*/*             */\n*/********************************************************************/\n*    10 TIOESTTB BIT(8),  /* STATUS -B-       */\n*     11 TIOSUSED BIT(1),  /* DATA SET IS ON DEVICE     */\n*     11 TIOSREQD BIT(1),  /* DATA SET WILL USE DEVICE  */\n*     11 TIOSPVIO BIT(1),  /* DEVICE VIOLATES SEPARATION*/\n*     11 TIOSVLSR BIT(1),  /* VOLUME SERIAL PRESENT     */\n*     11 TIOSSETU BIT(1),  /* SETUP MESSAGE REQUIRED    */\n*     11 TIOSMNTD BIT(1),  /* MOUNTED       */\n*     11 TIOSUNLD BIT(1),  /* UNLOAD REQUIRED      */\n*     11 TIOSVERF BIT(1),  /* VERIFICATION REQUIRED     */\n*    10 TIOEFSRT PTR(24), /* SRT POINTER       */\n*/********************************************************************/\n*/*             */\n*/*        TIOT POOL ENTRY          */\n*/*             */\n*/********************************************************************/\n*     5 POOLSTAR,\n*    10 *    CHAR(1),\n*    10 TIOPNSLT PTR(8),        /*  NR. OF SLOTS FOR POOL     */\n*    10 *    CHAR(1),\n*    10 TIOPNSRT PTR(8),        /*  NR. OF DEVICES (FILLED\n*          SLOTS)       */\n*    10 TIOPPOOL CHAR(8),  /* POOL NAME       */\n*    10 TIOPSTTB CHAR(1),  /* STATUS OF SLOT      */\n*    10 TIOPSLOT PTR(24),  /* SRT ADDRESS OF EMPTY SLOT */\n*    10 TIOTFEND CHAR(4);  /* FINAL END OF AN ENTRY OR\n*        THE TIOT       */\n./ ADD NAME=OTHERWSE\n         MACRO\n&LAB     OTHERWSE\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OELSE(16)\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD NE 0).END0A\n         MNOTE 16,'OPTION MISSING'\n         MEXIT\n.END0A   ANOP\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         MEXIT\n.END1    ANOP\n.* SET EXIT FOR PREVIOUS CODE\n         BRU   @D&OD.E&OE(&OD)\n.* SET LABEL FOR ENTRY\n@D&OD.N&ON(&OD) EQU   *\n.* INCREMENT LABEL GENERATION NUMBER\n&ON(&OD) SETA  &ON(&OD)+1\n.* SET OPTION INDICATOR OFF\n&OPTN(&OD) SETB  (0)\n.IF1A    AIF   ((&OELSE(&OD)) EQ (0)).END1A\n         MNOTE 16,'DUPLICATE OTHERWSE'\n         MEXIT\n.END1A   ANOP\n&OELSE(&OD) SETB (1)\n         MEND\n./ ADD NAME=PLIST\n MACRO\n&NAME  PLIST &P1\n LCLA &NPLIST,&CPLIST\n AIF ('&P1' EQ '').E2\n AIF ('&P1'(1,1) NE '(').E1\n&NPLIST SETA N'&P1\n&CPLIST SETA 1\n&NAME  DS    0F\n.B1 AIF ('&P1(&CPLIST)' EQ '').B2\n  DC    A(&P1(&CPLIST))\n AGO .B3\n.B2  DC    A(0)\n.B3 ANOP\n&CPLIST SETA 1+&CPLIST\n AIF (&CPLIST GT &NPLIST).B4\n AGO .B1\n.B4  ORG   *-4\n  DC    X'80'\n  ORG   *+3\n MEXIT\n.E1 MNOTE 2,'OPND NOT ENCLOSED IN PARENTHESES. STMT IGNORED.'\n MEXIT\n.E2 MNOTE 2,'NO OPND. STATEMEMT IGNORED.'\n MEXIT\n MEND\n./ ADD NAME=POPINS\n  MACRO\n  POPINS &P\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n  LCLA &W\n&W  SETA &P\n  AGO .TEST\n.UNSTACK   AIF ('&IIND3(&W)' EQ '').ONEOP\n      AIF ('&IIND4(&W)' NE '').THREEOP\n&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)/\n               &I32(&W)&I33(&W)&I34(&W)\n      AGO .INCTR\n.THREEOP       ANOP\n&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)/\n               &I32(&W)&I33(&W)&I34(&W),&IIND4(&W)&I42(&W)&I43(&W)\n      AGO .INCTR\n.ONEOP    ANOP\n&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W)\n.INCTR    ANOP\n&W    SETA  &W+1\n.TEST  AIF (&W LE &II).UNSTACK\n&II  SETA &P-1\n  AIF ('&NEST(&NI)'(3,1) NE ' ' OR '&NEST(&NI)'(4,1) EQ ' ').NEQ\n&IIND5(&II) &IIND1(&II) &IIND2(&II)\n.NEQ  AIF (&II GT 0 OR (&II EQ 0 AND '&NEST(&NI)'(5,4) EQ 'IF')).END\n  MNOTE 8,'NEGATIVE INSTRUCTION STACK PTR. EXPANSION INVALID.'\n.END  MEND\n./ ADD NAME=POPNEST\n  MACRO\n POPNEST &P1\n GBLA &CCVAL       COND CODE VARIABLE\n GBLA &CTR       MACRO PARAMETER COUNTER\n GBLA &SEQ       LABEL NUMBER GENERATOR\n GBLA &AI       INDEX FOR TOTAL NO. CASES STK\n GBLA &CI       INDEX FOR CASE AND LBL NO. STKS\n GBLA &II       PTR TO INST STKS\n GBLA &LI       INDEX FOR LABEL NUMBER STK\n GBLA &NI       PTR TO NEST STK\n GBLA &AIND(50)       TOTAL CASES STK\n GBLA &CIND1(200)      CASE NUMBER STK\n GBLA &MULT(50)       CASE NUMBER MULTIPLIER\n GBLA &ST(51)       INST STK INCREASE AT EACH LEVEL\n GBLC &CIND2(200)      LABEL NUMBER STK FOR CASES\n GBLC &IIND1(100)      INSTRUCTION STK 1\n GBLC &IIND2(100)      INSTRUCTION STK 2\n GBLC &I22(100)       INSTRUCTION STK 2, 2ND PART\n GBLC &I23(100)       INSTRUCTION STK 2, 3RD PART\n GBLC &I24(100)       INSTRUCTION STK 2, 4TH PART\n GBLC &IIND3(100)      INSTRUCTION STK 3\n GBLC &I32(100)       INSTRUCTION STK 3, 2ND PART\n GBLC &I33(100)       INSTRUCTION STK 3, 3RD PART\n GBLC &I34(100)       INSTRUCTION STK 3, 4TH PART\n GBLC &IIND4(100)      INSTRUCTION STK 4\n GBLC &I42(100)       INSTRUCTION STK 4, 2ND PART\n GBLC &I43(100)       INSTRUCTION STK 4, 3RD PART\n GBLC &IIND5(100)      INSTRUCTION NAME STACK\n GBLC &LIND(101)      LABEL NUMBER STK\n GBLC &NEST(50)       NESTING STK\n GBLC &RIND(50)       REG STK FOR CASENTRY MACRO\n LCLC &SUFFIX\n&SUFFIX  SETC  '&NEST(&NI)'(5,4)\n  AIF   ('&NEST(&NI)'(5,4) EQ '&P1').GOOD\n  MNOTE 8,'&SUFFIX MACRO AT SAME LEVEL AS &P1 TERMINATOR.'\n.GOOD  ANOP\n&NI  SETA  &NI-1\n  AIF   (&NI GE 0).OK\n  MNOTE 8,'NEGATIVE NEST STACK POINTER. CHECK NUMBER OF ENDS.'\n.OK  ANOP\n  MEND\n./ ADD NAME=PRGDCBI\n         MACRO\n         PRGDCBI &DCB=SYSIN,&REC=,&V2F=,&EOF=,&FLAGLEN=,               /\n               &SPANA=,&SPANL=,&SPANM=\n.**********************************************************************\n.*\n.*    Created by John Gateley\n.*\n.*    The easiest way to use this macro is with locate mode on\n.*    the DCB and use the V2F parameter to ensure you get\n.*    a fixed length record padded with spaces. This works with\n.*    either fixed or variable length records.\n.*    If you need to do processing based on the record length\n.*    then use the REC method.\n.*    If you are processing a VBS use the SPAN parameters instead.\n.*\n.*       This macro generates code to work with an input DCB.\n.*\n.* NOTE ==> The EODAD on the DCB should be END_&DCB\n.*\n.*       This macro generates three code segments to do the following\n.*\n.*          OPEN_&DCB              code to open the &DCB\n.*\n.*          GET_&DCB               code to read a record from &DCB\n.*\n.*          CLOSE_&DCB             code to close the &DCB\n.*\n.*       It also generates this segment when processing VBS datasets\n.*       which is for internal use only.\n.*          GET_&DCB._SEGMENT\n.*\n.*     &DCB    the label on the DCB macro.\n.*     &REC    is where the input record will be read into\n.*             if NOT supplied then locate mode will be used and\n.*             R1 will contain the address of the record.\n.*     &V2F    Use this when you do not know if the actual file\n.*             will be fixed or variable, it will give you fixed.\n.*             The record will be read using locate processing\n.*             and copied to the specified data area, padded to\n.*             the right with blanks.\n.*     &FLAGLEN will be set to 'Y' if any records are truncated in\n.*             V2F processing.\n.*     &EOF    should be 1 byte and will be set to 'Y' when the\n.*             end of file has been reached.\n.*     &SPANA     area\n.*     &SPANL     length\n.*     &SPANM     max length\n.*             adds support for VBS datasets.\n.*             To use this facility &SPANA should be a fullword\n.*             containing the address of the record area.\n.*             SPANL should be a fullword and will contain the length\n.*             of the reconstructed record.\n.*             SPANM should be a fullword containing the length of\n.*             the data area pointed to by SPANA.\n.*             It is envisaged that the data area will be getmained\n.*             storage of 1MB to allow plenty of room.\n.*             If a record is > than SPANM then the program will\n.*             end with RC=12.\n.*\n.*    This is an example of the code that should be used for SYSIN\n.*    In this example all we are doing is counting the records.\n.*\n.*    SEGDO OPEN_SYSIN                    open the SYSIN file\n.*    DO INF\n.*      SEGDO GET_SYSIN\n.*    DOEXIT (CLI,EOF_SYSIN,EQ,C'Y')      end of file\n.*      LA    R3,1(,R3)                   increment count\n.*    ENDDO\n.*    SEGDO CLOSE_SYSIN                   close the SYSIN file\n.*\n.*  WARNING - if you have coded MACRF=GL but you get this message\n.*    prgname - PRGDCBI - SYSIN Input DCB not MOV mode\n.*  at run time, check you are not opening the file a second time\n.*  without first closing it.\n.*\n.*          PRGDCBI DCB=SYSIN,EOF=EOF_SYSIN\n.*  SYSIN   DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GL),EODAD=END_SYSIN\n.*\n         GBLC  &MODNAME\n.*\n         AIF   (T'&EOF NE 'O').EOFOK\n         MNOTE 16,' EOF variable required'\n         MEXIT\n.EOFOK   ANOP\n.*\n SEGS OPEN_&DCB\n*\n   MVI   &EOF,C'N'                     indicate NOT end of file\n*                                      open &DCB\n         AIF   (T'&SPANA NE 'O').ISLOCMD\n         AIF   (T'&V2F NE 'O').ISLOCMD\n         AIF   (T'&REC NE 'O').ISMOVMD\n.*\n.ISLOCMD ANOP\n&TSTMOD  SETC  'LOC'\n*                                      Check MACRF is locate mode\n   IF (TM,&DCB+50,8,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n         AGO   .ENDMOD\n.ISMOVMD ANOP\n&TSTMOD  SETC  'MOV'\n*                                      Check MACRF is move mode\n   IF (TM,&DCB+50,16,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n.ENDMOD  ANOP\n*\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   OPEN  ((R14),INPUT),MODE=31\n.* OPEN  (&DCB,INPUT)\n   IF (LTR,R15,R15,NZ)                 quit if failed, gives RC=16\n     WTO   '//&DCB     DD  ...         must be present in JCL',        /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   SEGQUIT\n*\n&DCB._WRONG_MODE   DC    C'&MODNAME - PRGDCBI - &DCB Input DCB not &TST'\n               MOD mode'\n*\n SEGE OPEN_&DCB\n*______________________________________________________________________\n*\n SEGS GET_&DCB\n*\n   MVI   &EOF,C'N'                     indicate NOT end of file\n.*\n   AIF   (T'&SPANA NE 'O').DOSPAN\n.*\n   AIF   (T'&V2F NE 'O').V2FPR1\n   AIF   (T'&REC NE 'O').MOVMOD\n*\n.*       Do GET LOCATE processing\n   GET   &DCB                          get locate mode\n   AGO   .AFT\n.*\n.MOVMOD  ANOP\n.*\n.*       Do GET MOVE processing\n   GET   &DCB,&REC                     get move mode\n   AGO   .AFT\n.*\n.*       Do GET LOCATE and copy to record area\n.V2FPR1  ANOP\n&MYLEN   SETA  L'&V2F                  get length of record area\n   AIF   (&MYLEN GT 256).DOMVCL1       <= 256 so use MVC to\n   MVI   &V2F,C' '                     clear to spaces\n   MVC   &V2F+1(L'&V2F-1),&V2F\n   AGO   .NDMVCL1\n.DOMVCL1   ANOP                        > 256 so use MVCL\n   LA    R0,&V2F                       point to record area\n   LA    R1,L'&V2F                     get length of record area\n   LA    R15,C' '                      put in a space\n   SLL   R15,24                        slide into high byte\n   MVCL  R0,R14                        wipe to spaces\n.NDMVCL1   ANOP\n.*\n   GET   &DCB\n   LH    R15,&DCB+82                   get record length just read\n   IF (TM,&DCB+36,X'40',NZ)            if variable length\n     LA    R1,4(,R1)                   point past RDW\n     AHI   R15,-4                      subtract RDW from length\n   ENDIF\n   IF (CHI,R15,GT,L'&V2F)              if greater than space available\n     LA    R15,L'&V2F                  get maximum length\n     AIF   (T'&FLAGLEN EQ 'O').NOFLAG\n     MVI   &FLAGLEN,C'Y'               set truncated flag\n.NOFLAG  ANOP\n   ENDIF\n   IF (CHI,R15,LE,256)                 record small enough for MVC?\n     BCTR  R15,0                       less 1 for execute\n     EX    R15,&DCB._COPY_INREC        copy record\n   ELSE\n     LR    R14,R1                      copy address of input record\n     LR    R1,R15                      copy length\n     LA    R0,&V2F                     point to record area\n     MVCL  R0,R14                      copy record\n   ENDIF\n.AFT     ANOP\n*\n   SEGQUIT                             quit on good read\n*\n   AIF   (T'&V2F EQ 'O').V2FPR2\n&DCB._COPY_INREC   MVC   &V2F.(0),0(R1)\n*\n.V2FPR2  ANOP\nEND_&DCB     DS    0H\n*\n   MVI   &EOF,C'Y'                     set end of file marker\n*\n SEGE GET_&DCB\n.*\n         AGO   .AFTSPAN\n.*\n.*       Do GET LOCATE processing with VBS dataset\n.*\n.DOSPAN  ANOP\n.*\n   AIF   (T'&SPANL EQ 'O').MISSL\n   AIF   (T'&SPANM EQ 'O').MISSM\n.*\n   IF (TM,&DCB+36,X'08',Z)             if not spanned write error\n     MVC   MESS_TXT(L'&DCB._NOT_SPAN),&DCB._NOT_SPAN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n   L     R0,&SPANA                     point to record area\n   L     R1,&SPANL                     get last record length\n   IF (CFI,R1,EQ,0)                    if 0\n     L     R1,&SPANM                   get maximum length\n   ENDIF\n   XR    R15,R15\n   MVCL  R0,R14                        wipe to low values\n   XC    &SPANL,&SPANL                 set current length to 0\n*\n   ST    R2,#MVCLSAV                   save current R2 value\n*\n   DO INF\n     SEGDO GET_&DCB._SEGMENT\n   DOEXIT (CLI,&EOF,EQ,C'Y')\n     LR    R2,R1                       copy segment address\n     LA    R14,4(,R1)                  point past RDW/SDW\n     LH    R15,0(,R1)                  get segment length\n     AHI   R15,-4                      subtract for RDW/SDW\n     L     R0,&SPANA                   point to start of area\n     A     R0,&SPANL                   add current length\n     LR    R1,R15                      copy segment length\n     A     R1,&SPANL                   add current length\n     ST    R1,&SPANL                   and save total\n     IF (C,R1,GT,&SPANM)               is it too big ?\n       MVC   MESS_TXT(L'&DCB._TOO_BIG),&DCB._TOO_BIG\n       SEGDO WRITE_LOG\n       PRGQUIT RC=16                   then quit\n     ENDIF\n     LR    R1,R15                      copy segment length again\n     MVCL  R0,R14                      copy segment\n   DOEXIT (CLI,2(R2),EQ,0)             single segment in record\n   DOEXIT (CLI,2(R2),EQ,2)             last segment in record\n   ENDDO\n*\n   L     R2,#MVCLSAV                   restore previous R2 value\n*\n   SEGQUIT                             QUIT seg, this keeps error\n*                                      message addressable\n*\n&DCB._TOO_BIG      DC    C'&DCB Input record was too big'\n&DCB._NOT_SPAN     DC    C'&DCB Input file not RECFM=VBS'\n*\n SEGE GET_&DCB\n*______________________________________________________________________\n*\n SEGS GET_&DCB._SEGMENT\n*\n   MVI   &EOF,C'N'\n*\n   GET   &DCB\n*\n   SEGQUIT\n*\nEND_&DCB     DS    0H\n*\n   MVI   &EOF,C'Y'                     set end of file marker\n*\n SEGE GET_&DCB._SEGMENT\n.*\n.AFTSPAN   ANOP\n*______________________________________________________________________\n*\n SEGS CLOSE_&DCB\n*                                      close &DCB\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   CLOSE ((R14)),MODE=31\n.* CLOSE (&DCB)\n*                                      freepool &DCB\n   FREEPOOL &DCB                       ensure buffer pool cleared\n*\n SEGE CLOSE_&DCB\n.*\n         MEXIT\n.MISSL   MNOTE 16,'SPANA defined but not SPANL'\n         MEXIT\n.MISSM   MNOTE 16,'SPANA defined but not SPANM'\n         MEND\n./ ADD NAME=PRGDCBO\n         MACRO\n         PRGDCBO &DCB=SYSOUT,&REC=,&CLEAR=Y,&SPANA=,&SPANL=,&SPANW=\n.**********************************************************************\n.*\n.*     Created by John Gateley\n.*\n.*     This macro generates code to work with an output DCB.\n.*\n.*     This macro generates three code segments.\n.*\n.*        OPEN_&DCB                  code to open the &DCB DCB\n.*\n.*        PUT_&DCB                   code to write a line to &DCB\n.*\n.*        CLOSE_&DCB                 code to close the &DCB DCB\n.*\n.*     It also generates this segment when processing VBS datasets\n.*     which is for internal use only.\n.*        PUT_&DCB._SEGMENT\n.*\n.*     &REC=      where the output record will be written from.\n.*     &CLEAR=Y   set &REC to spaces after the record is written.\n.*           =N   leave the record as it is. If the record is variable\n.*                then the RDW will not be set to spaces.\n.*\n.*     &SPANA     area                     DS    F\n.*     &SPANL     length                   DS    F\n.*     &SPANW     12 byte work area        DS    3F\n.*             adds support for VBS datasets.\n.*             To use this facility &SPANA should be a fullword\n.*             containing the address of the record area.\n.*             SPANL should be a fullword and will contain the length\n.*             of the full record.\n.*          When using VBS the DCB should be MACRF=PL\n.*\n.*          PRGDCBO DCB=SYSOUT,REC=MESS_TXT,CLEAR=Y\n.*  SYSOUT  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSOUT,RECFM=FB,LRECL=80\n.*\n         GBLC  &MODNAME\n.*\n         AIF   (T'&SPANA NE 'O').RECOK\n         AIF   (T'&REC NE 'O').RECOK\n         MNOTE 16,' REC= variable required'\n         MEXIT\n.RECOK   ANOP\n.*\n SEGS OPEN_&DCB\n*                                      open &DCB\n         AIF   (T'&SPANA NE 'O').ISLOCMD\n         AIF   (T'&REC NE 'O').ISMOVMD\n.*\n.ISLOCMD ANOP\n&TSTMOD  SETC  'LOC'\n*                                      Check MACRF2 is locate mode\n   IF (TM,&DCB+51,8,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n         AGO   .ENDMOD\n.ISMOVMD ANOP\n&TSTMOD  SETC  'MOV'\n*                                      Check MACRF2 is move mode\n   IF (TM,&DCB+51,16,Z)\n     MVC   MESS_TXT(L'&DCB._WRONG_MODE),&DCB._WRONG_MODE\n     SEGDO WRITE_LOG\n     PRGQUIT RC=16                     then quit\n   ENDIF\n.ENDMOD  ANOP\n*\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   OPEN  ((R14),OUTPUT),MODE=31\n.* OPEN  (&DCB,OUTPUT),MODE=31\n   IF (LTR,R15,R15,NZ)                 quit if failed, gives RC=16\n     WTO   '//&DCB     DD  ...         must be present in JCL',        /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   SEGQUIT\n*\n&DCB._WRONG_MODE   DC    C'&MODNAME - PRGDCBO - &DCB Output DCB not &TS'\n               TMOD mode'\n*\n SEGE OPEN_&DCB\n*______________________________________________________________________\n*\n SEGS PUT_&DCB\n*\n   AIF   (T'&SPANA NE 'O').DOSPAN\n.*\n   PUT   &DCB,&REC                     put move mode\n*\n   AIF   ('&CLEAR' EQ 'N').NOCLEAR\n.*\n&MYLEN1  SETA  L'&REC                  get length of record area\n&MYLEN2  SETA  L'&REC-4                get length of record area - RDW\n.*\n   AIF   (&MYLEN1 GT 256).DOMVCL       <= 256 so use MVC to\n   IF (TM,&DCB+36,X'40',NZ)            if variable length\n     MVI   &REC+4,C' '                 clear output record\n     MVC   &REC+5(L'&REC-5),&REC+4     but not RDW\n   ELSE\n     MVI   &REC,C' '                   clear output record\n     MVC   &REC+1(L'&REC-1),&REC\n   ENDIF\n   AGO   .NDMVCL\n.*\n.DOMVCL    ANOP                        > 256 so use MVCL\n.*\n   IF (TM,&DCB+36,X'40',NZ)            if variable length\n     LA    R0,&REC+4                   point to after RDW\n     LAY   R1,&MYLEN2                  get length to clear\n     LA    R8,1\n   ELSE\n     LA    R0,&REC                     point to record area\n     LAY   R1,&MYLEN1                  get length to clear\n     LA    R8,2\n   ENDIF\n   LA    R15,C' '                      put in a space\n   SLL   R15,24                        slide into high byte\n   MVCL  R0,R14                        wipe to spaces\n.*\n.NDMVCL    ANOP\n.*\n.NOCLEAR ANOP\n*\n SEGE PUT_&DCB\n.*\n         AGO   .AFTSPAN\n.*\n.DOSPAN  ANOP\n.*\n   AIF   (T'&SPANL EQ 'O').MISSL\n   AIF   (T'&SPANW EQ 'O').MISSW\n.*\n   IF (TM,&DCB+36,X'08',Z)             if not spanned write error\n     MVC   MESS_TXT(L'&DCB._NOT_SPAN),&DCB._NOT_SPAN\n     SEGDO WRITE_LOG\n     PRGQUIT RC=12                     then quit\n   ENDIF\n   MVC   &SPANW.(4),&SPANA             copy address of record\n   MVC   &SPANW.+4(4),&SPANL           copy length of record\n   MVI   &SPANW.+8,0                   indicate complete record\n*\n   DO INF\n     SEGDO PUT_&DCB._SEGMENT           uses locate mode\n     LR    R14,R1                      save address of output buffer\n     LR    R15,R0                      save length of output buffer\n     AHI   R15,-4                      subtract length of RDW/SDW\n     XC    0(4,R14),0(R14)             clear RDW/SDW in output\n     IF (C,R15,GE,&SPANW.+4)           only or final segment\n       L     R15,&SPANW.+4             set length to write\n       XC    &SPANW.+4(4),&SPANW.+4    show no more after this\n       L     R0,&SPANW                 address to copy from\n       IF (CLI,&SPANW.+8,NE,0)         writing segments\n         MVI   2(R14),2                show last segment\n       ENDIF\n     ELSE\n       L     R1,&SPANW.+4              get length remaining\n       SR    R1,R15                    subtract this length\n       ST    R1,&SPANW.+4              save new length remaining\n       L     R0,&SPANW                 address to copy from\n       L     R1,&SPANW                 address to copy from\n       AR    R1,R15                    add this length\n       ST    R1,&SPANW                 save new address\n       IF (CLI,&SPANW.+8,EQ,0)         writing first segment\n         MVI   2(R14),1                show first segment\n         MVI   &SPANW.+8,1             show first segment written\n       ELSE\n         MVI   2(R14),3                show middle segment\n       ENDIF\n     ENDIF\n     LA    R1,4(,R15)                  add RDW/SDW length\n     STH   R1,0(R14)                   set RDW/SDW length\n     LA    R14,4(,R14)                 point after RDW/SDW in output\n     LR    R1,R15                      copy move length\n     MVCL  R14,R0                      copy the data\n   DOEXIT (CLC,=F'0',EQ,&SPANW.+4)     nothing else to write\n   ENDDO\n*\n   SEGQUIT                             QUIT seg, this keeps error\n*                                      message addressable\n*\n&DCB._NOT_SPAN     DC    C'&DCB Output file not RECFM=VBS'\n*\n SEGE PUT_&DCB\n*______________________________________________________________________\n*\n SEGS PUT_&DCB._SEGMENT\n*\n   PUT   &DCB\n*\n SEGE PUT_&DCB._SEGMENT\n.*\n.AFTSPAN   ANOP\n*______________________________________________________________________\n*\n SEGS CLOSE_&DCB\n*                                      close &DCB\n.*       allow for DCB in getmained storage\n   LA    R14,&DCB\n   CLOSE ((R14)),MODE=31\n.* CLOSE (&DCB),MODE=31\n*\n SEGE CLOSE_&DCB\n.*\n         MEXIT\n.MISSL   MNOTE 16,'SPANA defined but not SPANL'\n         MEXIT\n.MISSW   MNOTE 16,'SPANA defined but not SPANW'\n         MEXIT\n         MEND\n./ ADD NAME=PRGDEF\n         MACRO\n&LABEL   PRGDEF &FSEG=,&REXX=N,&AMODE=31,&RMODE=ANY,&INREX=N,          /\n               &RENT=N,&MAXSEG=50,&SBAS2=N,&SBAS3=N,&MAXPAR=24,        /\n               &RBAS2=N,&RBAS3=N,&RLOC=ANY,&WTOL=80\n.*\n.*  Created by John Gateley\n.*\n.*  This macro defines the start ot the program and is responsible\n.*  for getting and releasing dynamic storage if RENT=Y is specified.\n.*  RBAS2 and RBAS3 provide for additional reentrant storage\n.*  base registers.\n.*  SBAS2 and SBAS3 provide for additional static storage base\n.*  registers.\n.*\n.*  The assembler LOCTR is used to build the object module with the\n.*  static variables such as literals and constants at the top followed\n.*  by the executable code. Code in the program should be segmented\n.*  using SEGS and SEGE macros and segments should be performed by use\n.*  of the SEGDO macro. A code base register is used to give\n.*  addressability within each segment and is automatically\n.*  maintained on entry to and exit from a segment. Branching to a\n.*  label in another segment will usually cause an 'interesting' abend.\n.*\n.*  Example program layout\n.*\n.*   TITLE 'PROGRAM TITLE'\n.*  NAME  PRGDEF FSEG=MAIN_BIT,REXX=Y,RENT=Y\n.*  DYNAMIC_STORAGE_VARIABLE   DS    F\n.*        PRGEDEF\n.*   SEGS MAIN_BIT\n.*     MVC   ....\n.*     SEGDO SEGMENT_TWO\n.*   SEGE MAIN_BIT\n.*   SEGS SEGMENT_TWO\n.*     MVC   ....\n.*   SEGE SEGMENT_TWO\n.*\n.*        PRGSTAT\n.*  A_CONSTANT   DC    C'SOME TEXT'\n.*        PRGESTAT\n.*        PRGEND\n.*        END\n.*\n.*  An area of re-entrant storage called MESS_TXT is provided and is\n.*  used by the WTOX macro to write to operator, this defaults to\n.*  80 but can be up to 120 and is set by WTOL=80.\n.*  An area is provided for building parameter lists MY_PARM the\n.*  number of fullwords is set by MAXPAR=24.\n.*  REXX=Y automatically includes the macros required for writing\n.*  rexx functions in assembler. INREXX=Y is for rexx functions\n.*  that are not called directly by rexx.\n.*\n.*  Registers used are\n.*             R13            save area and base for re-entrant\n.*                            storage between PRGDEF and PRGEDEF\n.*             R12            base register for static variables which\n.*                            are defined between PRGSTAT and PRGESTAT\n.*             R11            segment code base register\n.*             R10            rexx environment block\n.*             R9             rexx EFPL\n.*             R8             rexx ARGTABLE_ENTRY\n.*             R7             rexx EVALBLOCK\n.*\n.*  Defaults are\n.*             RENT=NO\n.*             CBASE=R11      Code base register set in every segment\n.*             AMODE=31\n.*             RMODE=ANY\n.*             MAXSEG=50      Maximium number of segments in program\n.*             SBAS2=N        No second storage register\n.*             SBAS3=N        No third storage register\n.*             RBAS2=N        No second reentrant register\n.*             RBAS3=N        No third reentrant register\n.*             MAXPAR=24      Parameter list length\n.*             WTOL=80        80 character message area.\n.*\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &INREXX\n           GBLC  &ISRBAS2,&ISRBAS3\n           GBLC  &ISSBAS2,&ISSBAS3\n           GBLC  &SEGSAVA\n           GBLC  &BASSAVA\n           GBLC  &SAMODE\n           GBLC  &ISRENT\n           GBLC  &SCBASER\n           GBLC  &STRWRK\n           GBLA  &SEGCNT\n           GBLA  &SEGMAX\n           GBLA  &PARMAX\n           GBLA  &SCBASEC\n           GBLA  &WHICHM\n           LCLA  &CNT1,&CNT2\n           AIF   ('&LABEL' EQ '').MNOTE1\n           AIF   ('&FSEG' EQ '').MNOTE2\n.*\n*   Change branch to branch relative, ensure clean 31 bit addresses\nB          OPSYN BRU\nBAL        OPSYN BAS\nBALR       OPSYN BASR\n.*\n&MODNAME   SETC  '&LABEL'\n&ISRBAS2   SETC  '&RBAS2'\n&ISRBAS3   SETC  '&RBAS3'\n&ISSBAS2   SETC  '&SBAS2'\n&ISSBAS3   SETC  '&SBAS3'\n&ISRENT    SETC  '&RENT'(1,1)\n&SAMODE    SETC  '&AMODE'\n&SETREX    SETC  '&REXX'(1,1)\n&INREXX    SETC  '&INREX'(1,1)\n&SCBASER   SETC  'R11'\n&STRWRK    SETC  '#STRING_WORK'\n&SEGCNT    SETA  0\n&SCBASEC   SETA  0\n&SEGMAX    SETA  &MAXSEG\n&PARMAX    SETA  &MAXPAR\n&CNT1      SETA  1\n&CNT2      SETA  &PARMAX\n&WHICHM    SETA  5\n*\n&MODNAME   START 0\n           AIF   ('&AMODE' EQ '31').ABIT31\n           AIF   ('&AMODE' NE '24').MNOTE3\n.ABIT24    ANOP\n&MODNAME   AMODE 24\n&MODNAME   RMODE 24\n           AGO   .AFTR\n.ABIT31    ANOP\n&MODNAME   AMODE 31\n           AIF   ('&RMODE' EQ '24').RBIT24\n           AIF   ('&RMODE' EQ 'ANY').RBIT31\n           AGO   .MNOTE4\n.RBIT24    ANOP\n&MODNAME   RMODE 24\n           AGO   .AFTR\n.RBIT31    ANOP\n&MODNAME   RMODE ANY\n.AFTR      ANOP\n*\nR0         EQU   0\nR1         EQU   1\nR2         EQU   2\nR3         EQU   3\nR4         EQU   4\nR5         EQU   5\nR6         EQU   6\n           AIF   ('&SETREX' EQ 'Y').REXEQ\n           AIF   ('&INREXX' EQ 'Y').REXEQ\nR7         EQU   7\nR8         EQU   8\nR9         EQU   9\nR10        EQU   10\n           AGO   .REXEQX\n.REXEQ     ANOP\nR7         EQU   7                   * rexx EVALBLOCK\nR8         EQU   8                   * rexx ARGTABLE_ENTRY\nARG_POINT  EQU   8                   * rexx ARGTABLE_ENTRY alt name\nR9         EQU   9                   * rexx EFPL\nR10        EQU   10                  * rexx ENVBLOCK\n.REXEQX    ANOP\nR11        EQU   11                  * segment base register\nR12        EQU   12                  * module base register\nR13        EQU   13                  * reentrant storage\nR14        EQU   14\nR15        EQU   15\n.*\n           AIF   ('&SETREX' EQ 'N').NOREX1\n           AIF   ('&INREXX' EQ 'Y').MNOTE5\n.NOREX1    ANOP\n*\n           BRUL  BEGIN\n*\n@DATA      LOCTR ,\n           DC    CL10' &MODNAME'\n&AADAT     SETC  '&SYSCLOCK'(1,19)\n           DC    CL20'&AADAT'\n           DC    CL48'Copyright (C) ------------------------'\n           DS    0F\n@CODE      LOCTR ,\nBEGIN      DS    0H\n           STM   R14,R12,12(R13)     * save registers in caller\n           LARL  R12,&MODNAME        * get address of entry point\n*\n           AIF   ('&ISSBAS2' EQ 'N').NOS2BAS\n           AIF   ('&ISSBAS3' EQ 'N').NOS3BAS\n*\n           USING &MODNAME,R12\n           LA    &ISSBAS2,2048(,R12)\n           LA    &ISSBAS2,2048(,&ISSBAS2)\n           USING &MODNAME+4096,&ISSBAS2\n           LA    &ISSBAS3,2048(,&ISSBAS2)\n           LA    &ISSBAS3,2048(,&ISSBAS3)\n           USING (&MODNAME+8192,BEGIN),&ISSBAS3\n           AGO   .ENDSTAT\n*\n.NOS3BAS   ANOP\n           USING &MODNAME,R12\n           LA    &ISSBAS2,2048(,R12)\n           LA    &ISSBAS2,2048(,&ISSBAS2)\n           USING (&MODNAME+4096,BEGIN),&ISSBAS2\n           AGO   .ENDSTAT\n*\n.NOS2BAS   ANOP\n           USING (&MODNAME,BEGIN),R12\n.ENDSTAT   ANOP\n*\n           LR    R9,R1               save parameter address\n           AIF   ('&SETREX' EQ 'N').NO0001\n           LR    R10,R0              save rexx environment block addr\n.NO0001    ANOP\n           AIF   ('&ISRENT' EQ 'Y').RNT001\n*    Note that save area is NOT re-entrant\n           LARL  R2,#RENT_AREA\n           AGO   .RNT002\n.RNT001    ANOP\n*    Note that save area is re-entrant\n           L     R2,#RENTSIZ\n           AIF   ('&RLOC' NE 'ANY').SBIT24\n           AIF   ('&AMODE' EQ '31').SBIT31\n.SBIT24    ANOP\n*          STORAGE OBTAIN,LENGTH=(R2),LOC=24\n           CNOP  0,4\n           BRAS  R15,#GET_LAB\n           DC    BL1'00000000'\n           DC    AL1(0*16)\n           DC    AL1(0)\n           DC    BL1'00010010'\n#GET_LAB   DS    0F\n           LR    0,R2\n           L     15,0(,R15)\n           L     14,16(0,0)\n           L     14,772(14,0)\n           L     14,160(14,0)\n           PC    0(14)\n           AGO   .ESTOR\n.SBIT31    ANOP\n*          STORAGE OBTAIN,LENGTH=(R2),LOC=31\n           CNOP  0,4\n           BRAS  R15,#GET_LAB\n           DC    BL1'00000000'\n           DC    AL1(0*16)\n           DC    AL1(0)\n           DC    BL1'01110010'\n#GET_LAB   DS    0F\n           LR    0,R2\n           L     15,0(,R15)\n           L     14,16(0,0)\n           L     14,772(14,0)\n           L     14,160(14,0)\n           PC    0(14)              get storage\n.ESTOR     ANOP\n           LR    R2,R1               copy storage address\n.RNT002    ANOP\n           LR    R1,R9               restore parameter address\n           ST    R13,4(R2)           chain save areas\n           ST    R2,8(R13)\n           LR    R13,R2\n*\n           AIF   ('&ISRBAS2' EQ 'N').NOR2BAS\n           AIF   ('&ISRBAS3' EQ 'N').NOR3BAS\n*\n           USING #PRGAREA,R13\n           LA    &ISRBAS2,2048(,R13)\n           LA    &ISRBAS2,2048(,&ISRBAS2)\n           USING &PRGAREA+4096,&ISRBAS2\n           LA    &ISRBAS3,2048(,&ISRBAS2)\n           LA    &ISRBAS3,2048(,&ISRBAS3)\n           USING (#PRGAREA+8192,#E_RENT),&ISRBAS3\n           AGO   .ENDRTAT\n*\n.NOR3BAS   ANOP\n           USING #PRGAREA,R13\n           LA    &ISRBAS2,2048(,R13)\n           LA    &ISRBAS2,2048(,&ISRBAS2)\n           USING (#PRGAREA+4096,#E_RENT),&ISRBAS2\n           AGO   .ENDRTAT\n*\n.NOR2BAS   ANOP\n           USING (#PRGAREA,#E_RENT),R13\n.ENDRTAT   ANOP\n*\n           AIF   ('&SETREX' EQ 'N').NO0002\n           LR    R0,R10              restore environment block address\n.NO0002    ANOP\n.*\n           AIF   ('&SETREX' EQ 'N').NOREX2\n           USING ENVBLOCK,R10        use environment block\n           USING EFPL,R9\n           L     R8,EFPLARG\n           USING ARGTABLE_ENTRY,R8\n           L     R7,EFPLEVAL\n           L     R7,0(R7)\n           USING EVALBLOCK,R7\n           STM   R7,R10,#SAV_REX\n           XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN\n.NOREX2    ANOP\n           AIF   ('&INREXX' NE 'Y').NOINREX\n           L     R9,4(R13)\n           MVC   #SAV_REX(4*4),#SAV_REX-#PRGAREA(R9)\n           LM    R7,R10,#SAV_REX\n           USING ENVBLOCK,R10\n           USING EFPL,R9\n           USING ARGTABLE_ENTRY,R8\n           USING EVALBLOCK,R7\n.NOINREX   ANOP\n.*\n           XC    R_C,R_C\n           XC    MY_PARM(LEN_MY_PARM),MY_PARM\n           STMH  R0,R15,#HIGH_HALF         * save high registers\n           AIF   ('&ISRENT' NE 'Y').RNT003\n*    initialise obtained storage to low-values if reentrant\n           L     R15,#RENTSIZ              * length of reentrant area\n           AR    R15,R13                   * start of area\n           LA    R14,MY_PARM\n           SR    R15,R14\n           LR    R2,R1\n           XR    R1,R1\n           MVCL  R14,R0                    * wipe to low values\n           LR    R1,R2                     * restore PARM address\n.RNT003    ANOP\n*\n.*\n.*       area for use by the WTOX macro the length of the message\n.*       is set by macro parameter &WTOL which defaults to 80\n.*       permitted values are 80 to 120\n.*\n&A         SETA  &WTOL                     * copy length\n           AIF   (&A LT 80).MNOTE6\n           AIF   (&A GT 120).MNOTE6\n           MVC   #MESS_LEN,=H'&WTOL'       * set length of WTO text\n           MVI   MESS_TEXT,C' '\n           MVC   MESS_TEXT+1(L'MESS_TEXT-1),MESS_TEXT\n.*\n*          copy list form WTO expansion from PRGSTAT static storage\n.*\n           MVC   #ACT_WTO_LIST(L_#PTN_WTO_LIST),#PTN_WTO_LIST\n*\n           ST    R1,#PARM_ADDR             * save input PARM address\n*\n           BRAS  R14,##&FSEG               * go to main code\n*\n           BRU   #AFT_RENT                 * go to clean up\n*\n           DS    0F\n*\n&SEGSAVA   SETC  '#SEG_SAV'\n.*\n           AIF   ('&ISRENT' EQ 'Y').RNT004\n#PRGAREA       DSECT                       * DSECT overlays #RENT_AREA\n           AGO   .RNT005\n.RNT004    ANOP\n#PRGAREA       DSECT                       * DSECT overlays getmained\n.RNT005    ANOP\n#SAVAREA       DS    18F\n#SAV_REX       DS    4F\n#SEG_SAV       DS    &SEGMAX.F             * segment save area\n               AIF   ('&SCBASER' EQ 'N').NOCBAS\n#BAS_SAV       DS    &SEGMAX.F             * segment base reg save\n&BASSAVA       SETC  '#BAS_SAV'\n.NOCBAS        ANOP\nR_C            DS    F\n*\nDOUB_WORD      DS    D\nMY_PARM        DC    &PARMAX.F'0'          * define call parm area\n               ORG   MY_PARM\n.PLOOP         ANOP\nMY_P_&CNT1     DS    F\n&CNT1          SETA  &CNT1+1\n               AIF   (&CNT1 LE &CNT2).PLOOP\n.*\nEND_MY_PARM    EQU   *\nLEN_MY_PARM    EQU   *-MY_PARM\n#MVCLSAV       DC    4F'0'\n#HIGH_HALF     DS    16F                   * high half of registers\nLEN_SAY        DS    F\n#PARM_ADDR     DS    F                     * contents of R1 on entry\nHEXPACK_W2     DS    CL2                   * used in XPACK macro\nHEXPACK_W3     DS    CL3                   * used in XPACK macro\n#STRING_WORK   DS    CL32                  * used in STRING macro\n#ACT_WTO_LIST  DS    CL(L_#PTN_WTO_LIST)   * area for WTOX macro\n#MESS_LEN      DS    H                     * WTOX length\nMESS_TEXT      DS    CL&WTOL               * WTOX text\n               ORG   MESS_TEXT\nMESS_TXT       DS    CL&WTOL               * WTOX text alternate name\n*\n         MEXIT\n.MNOTE1  MNOTE 16,'The program name was not specified in column 1'\n         MEXIT\n.MNOTE2  MNOTE 16,'FSEG parameter was not specified'\n         MEXIT\n.MNOTE3  MNOTE 16,'AMODE not = 31 or 24'\n         MEXIT\n.MNOTE4  MNOTE 16,'RMODE not = ANY or 24'\n         MEXIT\n.MNOTE5  MNOTE 16,'REXX=YES and INREX=YES are mutually exclusive'\n         MEXIT\n.MNOTE6  MNOTE 16,'WTOL= permitted values are between 80 and 120'\n         MEND\n./ ADD NAME=PRGEDEF\n           MACRO\n           PRGEDEF\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &SAMODE\n           GBLC  &INREXX\n           GBLC  &ISRENT\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE1\n*\n.* Created by John Gateley\n.*\n#PRGAREA   DSECT\n*\n#E_RENT    EQU   *\n*\n&MODNAME   CSECT\n#AFT_RENT  DS    0H                        * start of goback code\n*\n           AIF   ('&SETREX' EQ 'N').NOREX\n           L     R7,#SAV_REX               * point to rexx-evalblock\n           L     R1,R_C                    * get return code\n           LTR   R1,R1\n           BRNZ  #AFT_RENT1                * R_C not zero then use it\n           CLC   EVALBLOCK_EVLEN,=F'0'     * if output length not set\n           BRNE  #AFT_RENT2                *   then use R_C anyway\n#AFT_RENT1 DS    0H\n           CVD   R1,DOUB_WORD              * put R_C into DOUB_WORD\n           MVC   MY_P_7,=X'40202120'\n           LA    R1,MY_P_7+3\n           EDMK  MY_P_7(4),DOUB_WORD+6\n           LA    R2,MY_P_8\n           CP    DOUB_WORD,=P'0'\n           BRNM  *+10\n           BCTR  R1,0\n           MVI   0(R1),C'-'                * set leading minus sign\n           SR    R2,R1\n           ST    R2,EVALBLOCK_EVLEN        * set length of output\n           BCTR  R2,0\n           EX    R2,#RC_SET                * copy return code to output\n           XC    R_C,R_C\n#AFT_RENT2 DS  0H\n.NOREX     ANOP\n           LMH   R0,R15,#HIGH_HALF         * restore high registers\n           AIF   ('&ISRENT' EQ 'Y').RNT001\n           L     R2,R_C                    * get return code\n           L     R13,4(R13)                * get caller save area\n           ST    R2,16(R13)                * save return code in R15\n           AGO   .RNT002\n.RNT001    ANOP\n           L     R0,#RENTSIZ\n           LR    R1,R13\n           L     R2,R_C\n           L     R13,4(R13)\n           ST    R2,16(R13)\n*          STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)\n           CNOP  0,4\n           BRAS  R15,#FRE_LAB\n           DC    BL1'00000000'\n           DC    AL1(0*16)\n           DC    AL1(0)\n           DC    BL1'00000011'\n#FRE_LAB   DS    0F\n           LR    0,R0\n           LR    1,R1\n           L     15,0(,R15)\n           L     14,16(0,0)\n           L     14,772(14,0)\n           L     14,204(14,0)\n           PC    0(14)\n.RNT002    ANOP\n           LM    R14,R12,12(R13)           * load callers + return code\n           BSM   0,R14                     * return to caller\n    EJECT\n         MEXIT\n.MNOTE1  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n./ ADD NAME=PRGEND\n           MACRO\n           PRGEND\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &INREXX\n           GBLC  &ISRENT\n           GBLC  &SEGNAM\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE2\n.*\n.* Created by John Gateley\n.*\n&MODNAME   CSECT\n           LTORG\n           AIF   ('&SETREX' EQ 'Y').YESREX\n           AIF   ('&INREXX' EQ 'Y').YESREX\n           AGO   .NOREX1\n.YESREX    ANOP\n           IRXENVB\n           IRXEXTE\n           IRXEFPL\n           IRXARGTB\n           IRXEVALB\n           IRXSHVB\n.NOREX1    ANOP\n*\n&MODNAME   CSECT\n           AIF   ('&ISRENT' EQ 'Y').RNT001\n#RENT_AREA DS    0D\n           DC    (#E_RENT-#PRGAREA)XL1'00'\n#E_E_PROG  EQU   *\n.RNT001    ANOP\n*\n         AIF   ('&SEGNAM' NE '').MNOTE1\n         MEXIT\n.MNOTE1  MNOTE 16,'Unequal number OF SEGS SEGE macros'\n         MEXIT\n.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n./ ADD NAME=PRGESTAT\n           MACRO\n           PRGESTAT\n           GBLC  &MODNAME\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE2\n.*\n&MODNAME   CSECT\n           DS    0D\n           LTORG\n*\n.*\n.* Created by John Gateley\n.*\n##STATIC_E     EQU   *\n               DS    0D\n               DC    CL32'&MODNAME ##STATIC END'\n@CODE      LOCTR ,\n*\n         MEXIT\n.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n./ ADD NAME=PRGPARM\n         MACRO\n         PRGPARM &PARM,&LEN=\n.**********************************************************************\n.*\n.*  Created by John Gateley\n.*\n.*     This macro generates the code to get the value of PARM='  '\n.*     in the JCL.\n.*\n.*     &PARM      where the parameter value should be copied to\n.*     &LEN=      a halfword which will contain its length (optional)\n.*\n         AIF   (T'&PARM EQ 'O').NOPARM\n&MYLEN   SETA  L'&PARM\n.*\n   MVI   &PARM,C' '\n   MVC   &PARM+1(L'&PARM-1),&PARM\n.*\n   L     R1,#PARM_ADDR                   restore R1 at entry\n   IF (LTR,R1,R1,NZ)                     parm supplied\n     L     R1,0(,R1)                     get address of it\n.*\n         AIF   (T'&LEN EQ 'O').NOLEN\n.*\n     MVC   &LEN,0(R1)                    copy length of parm\n.*\n.NOLEN   ANOP\n.*\n     IF (CLC,0(2,R1),NE,=H'0')           length not zero\n       LA    R0,2(,R1)                   point R0 after length\n       LH    R1,0(,R1)                   load length\n       IF (CHI,R1,GT,&MYLEN)             > length of receiving field\n         LHI   R1,&MYLEN                 use that length\n       ENDIF\n       LA    R14,&PARM                   point to receiving field\n       LR    R15,R1                      copy length\n       MVCL  R14,R0                      copy PARM value\n     ENDIF\n   ENDIF\n.*\n         MEXIT\n.NOPARM  MNOTE 16,'PARM value not supplied (char 80)'\n         MEXIT\n         MEND\n./ ADD NAME=PRGQUIT\n           MACRO\n           PRGQUIT &RC=0\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SCBASER\n           GBLC  &BASSAVA\n.*\n           AIF   ('&RC' EQ '0').NOCODE\n.*\n           MVI   R_C+3,&RC\n.*\n.NOCODE    ANOP\n.*\n           AIF   ('&SCBASER' EQ 'N').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE1\n.*         restore code base register to initial value\n           L     &SCBASER,&BASSAVA\n.NOCBASE   ANOP\n           BRUL  #AFT_RENT\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'Macro variable \"BASSAVA\" has not been set'\n           MEND\n./ ADD NAME=PRGSTAT\n           MACRO\n           PRGSTAT\n           GBLC  &MODNAME\n           GBLC  &SETREX\n           GBLC  &USETSTMP\n           GBLC  &HEXPCK\n           GBLC  &XUNPCK\n           GBLC  &WRTLOGD\n           GBLC  &WRTLOGU\n           GBLA  &WHICHM\n           AIF   ('&WHICHM' NE '5').MNOTE2\n.*\n.* Created by John Gateley\n.*\n&MODNAME   CSECT\n.*\n.*         see if segment WRITE_LOG is defined\n           AIF   ('&WRTLOGD' EQ 'Y').NOWLOG\n.*         see if segment WRITE_LOG is used but not defined\n           AIF   ('&WRTLOGU' EQ 'N').NOWLOG\n*SEGS WRITE_LOG\n SEGS WRITE_LOG\n*\n*  WTOX\n   WTOX\n*\n*SEGE WRITE_LOG\n SEGE WRITE_LOG\n*\n.NOWLOG    ANOP\n@DATA      LOCTR ,\n##STATIC   DS    0D\n           DC    CL32'&MODNAME ##STATIC START'\n#RENTSIZ   DC    AL4(#E_RENT-#PRGAREA)\n           AIF   ('&SETREX' EQ 'N').NOREX\n#RC_SET    MVC   EVALBLOCK_EVDATA(1),0(R1)\n.NOREX     ANOP\n*\n           AIF   ('&USETSTMP' NE 'Y').NOTIME\n*                 2 0 0 2 - 1 2 - 3 1 - 1 2 : 3 6 : 1 2 . 1 2 3 4 5 6\n##DAT_PAT  DC X'F0202020206020206020206020207A20207A20204B202020202020'\n*\n.NOTIME    ANOP\n.*         define list form of WTO for use in WTOX macro\n.*         WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY\n#PTN_WTO_LIST    DS    0F\n           DC    AL2(8)\n           DC    B'1000001000010000'\n           DC    AL4(0)\n           DC    AL1(2)\n           DC    B'00000000'\n           DC    AL1(0)\n           DC    AL1(104)\n           DC    B'0000000010000000'\n           DC    AL2(0)\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    B'0000000000000000'\n           DC    AL2(0)\n           DC    XL16'00200000000000000000000000000000'\n           DC    B'0000000000000000'\n           DC    AL2(0)\n           DC    CL8'        '\n           DC    CL8'        '\n           DC    CL8'        '\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    CL8'        '\n           DC    CL8'        '\n           DC    AL4(0)\n           DC    AL4(0)\n           DC    AL4(0)\nL_#PTN_WTO_LIST  EQU   *-#PTN_WTO_LIST\n           DS    0D\n*\n.*       If the macro hexpack has been used then include the\n.*       required storage\n               AIF   ('&HEXPCK' NE 'Y').NOHEXP\nHEXPACK_TABLE  DC    X'AABBCCDDEEFF'           C1-C6\n               DC    41X'0'                    C7-EF\n               DC    X'00112233445566778899'   F0-F9\n*\n.NOHEXP        ANOP\n               AIF   ('&XUNPCK' NE 'Y').NOXUNP\nXUNPACK_TAB    DC    C'0123456789ABCDEF'\n*\n.NOXUNP        ANOP\n         MEXIT\n.MNOTE2  MNOTE 50,'You are mixing your macros - PRGDEF PRGEDEF PRGEND'\n         MEND\n./ ADD NAME=PRGSTEM\n         MACRO\n         PRGSTEM &DSECT=N,&PREF=STEM\n.*\n.*       This defines storage for calling program PROCSTEM\n.*       which handles the population of a STEM variable\n.*       on behalf of a REXX assembler function\n.*\n         AIF   ('&DSECT' EQ 'Y').DS1D02\n.*\n&PREF._AREA          DS    0D\n.*\n         AGO   .ST1D02\n.*\n.DS1D02  ANOP\n.*\n&PREF._AREA          DSECT\n.*\n.ST1D02  ANOP\n.*\n&PREF._NAME          DS    CL48\n&PREF._NAME_ADR      DS    F\n&PREF._NAME_LEN      DS    F\n&PREF._MID_NAME      DS    CL20\n&PREF._AFT_DOT       DS    F\n&PREF._ZERO_COUNT    DS    PL4\n&PREF._TEXT_ADR      DS    F\n&PREF._TEXT_LEN      DS    F\n&PREF._MAX_LEN       DS    F\n&PREF._FUNCTION      DS    H\n&PREF._TRIM_VAR      DS    C\n&PREF._BLOCK_LEN     EQU   *-&PREF._NAME\n.*\n         MEND\n./ ADD NAME=PUSHINS\n      MACRO\n      PUSHINS &PAM\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n      LCLA &WK,&I,&J,&K\n&I      SETA  3\n&J      SETA  4\n&K      SETA  4\n      AIF ('&PAM(1)'(1,1) EQ 'B' OR '&PAM(1)' EQ 'EQU').BCH\n        AIF ('&PAM(5)' EQ '').TWOPERS\n   AIF ('&PAM(1)'(1,1) EQ 'C').SETK\n&J     SETA  5\n   AGO .GETCOND\n.TWOPERS       AIF ('&PAM(1)'(1,1) NE 'C').SETK\n&I        SETA  4\n&J        SETA  3\n.SETK        ANOP\n&K        SETA  5\n.GETCOND  GETCC &PAM(&J)\n.BCH      AIF   (&II GE 100).OVERI\n&II        SETA  &II+1\n&IIND1(&II)    SETC '&PAM(1)'\n&IIND2(&II)    SETC '&PAM(2)'(1,8)\n&WK    SETA K'&SYSLIST(1,2)\n    AIF (&WK GE 25).LD24\n&I24(&II)    SETC ''\n      AIF (&WK GE 17).LD23\n&I23(&II)      SETC ''\n        AIF (&WK GE 9).LD22\n&I22(&II)  SETC ''\n   AGO .PAM3\n.LD24        ANOP\n.* &I24(&II)   SETC '&PAM(2)'(25,8)   *** OLD STATEMENT\n.* CHANGE SO THAT OPERAND 2 IS NOT TRUNCATED TO 32 CHARACTERS (TSDER)\n&I24(&II)      SETC '&PAM(2)'(25,&WK)\n.LD23      ANOP\n&I23(&II)    SETC '&PAM(2)'(17,8)\n.LD22    ANOP\n&I22(&II)  SETC  '&PAM(2)'(9,8)\n.PAM3    AIF ('&PAM(&I)' NE '').LD31\n&IIND3(&II)  SETC ''\n      AGO  .BLKOUT3\n.LD31    ANOP\n&IIND3(&II)    SETC '&PAM(&I)'(1,8)\n.BLKOUT3   ANOP\n&WK    SETA K'&SYSLIST(1,&I)\n    AIF (&WK GE 25).LD34\n&I34(&II)    SETC ''\n      AIF (&WK GE 17).LD33\n&I33(&II)      SETC ''\n        AIF (&WK GE 9).LD32\n&I32(&II)  SETC ''\n   AGO .PAM4\n.LD34        ANOP\n.* &I34(&II)   SETC '&PAM(&I)'(25,8)    *** OLD STATEMENT\n.* CHANGE SO THAT OPERAND 4 IS NOT TRUNCATED TO 32 CHARACTERS (TSDER)\n&I34(&II)      SETC '&PAM(&I)'(25,&WK)\n.LD33      ANOP\n&I33(&II)    SETC '&PAM(&I)'(17,8)\n.LD32    ANOP\n&I32(&II)  SETC  '&PAM(&I)'(9,8)\n.PAM4    AIF ('&PAM(&K)' NE '').LD41\n&IIND4(&II)  SETC ''\n      AGO  .BLKOUT4\n.LD41    ANOP\n&IIND4(&II)  SETC '&PAM(&K)'(1,8)\n.BLKOUT4   ANOP\n&WK    SETA K'&SYSLIST(1,&K)\n    AIF (&WK GE 17).LD43\n&I43(&II)    SETC ''\n      AIF (&WK GE 9).LD42\n&I42(&II)      SETC ''\n        AGO .PAM5\n.LD43      ANOP\n&I43(&II)    SETC '&PAM(&K)'(17,8)\n.LD42    ANOP\n&I42(&II)  SETC '&PAM(&K)'(9,8)\n.PAM5    AIF ('&PAM(6)' EQ '').BLKOUT5\n      AIF ('&PAM(6)'(1,4) NE '#@LB').BLKOUT5\n&IIND5(&II)    SETC '&PAM(6)'\n      MEXIT\n.BLKOUT5   ANOP\n&IIND5(&II)  SETC ''\n    MEXIT\n.OVERI  MNOTE 8,'INSTRN STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'\n  MEND\n./ ADD NAME=PUSHLAB\n  MACRO\n  PUSHLAB\n  GBLA  &CCVAL   COND CODE VARIABLE\n  GBLA  &CTR   MACRO PARAMETER COUNTER\n  GBLA  &SEQ   LABEL NUMBER GENERATOR\n  GBLA  &AI   INDEX FOR TOTAL NO. CASES STK\n  GBLA  &CI   INDEX FOR CASE AND LBL NO. STKS\n  GBLA  &II   PTR TO INST STKS\n  GBLA  &LI   INDEX FOR LABEL NUMBER STK\n  GBLA  &NI   PTR TO NEST STK\n  GBLA  &AIND(50)  TOTAL CASES STK\n  GBLA  &CIND1(200)  CASE NUMBER STK\n  GBLA  &MULT(50)  CASE NUMBER MULTIPLIER\n  GBLA  &ST(51)   INST STK INCREASE AT EACH LEVEL\n  GBLC  &CIND2(200)  LABEL NUMBER STK FOR CASES\n  GBLC  &IIND1(100)  INSTRUCTION STK 1\n  GBLC  &IIND2(100)  INSTRUCTION STK 2\n  GBLC  &I22(100)  INSTRUCTION STK 2, 2ND PART\n  GBLC  &I23(100)  INSTRUCTION STK 2, 3RD PART\n  GBLC  &I24(100)  INSTRUCTION STK 2, 4TH PART\n  GBLC  &IIND3(100)  INSTRUCTION STK 3\n  GBLC  &I32(100)  INSTRUCTION STK 3, 2ND PART\n  GBLC  &I33(100)  INSTRUCTION STK 3, 3RD PART\n  GBLC  &I34(100)  INSTRUCTION STK 3, 4TH PART\n  GBLC  &IIND4(100)  INSTRUCTION STK 4\n  GBLC  &I42(100)  INSTRUCTION STK 4, 2ND PART\n  GBLC  &I43(100)  INSTRUCTION STK 4, 3RD PART\n  GBLC  &IIND5(100)  INSTRUCTION NAME STACK\n  GBLC  &LIND(101)  LABEL NUMBER STK\n  GBLC  &NEST(50)  NESTING STK\n  GBLC  &RIND(50)  REG STK FOR CASENTRY MACRO\n  AIF   (&LI GE 100).OVER\n&SEQ    SETA  &SEQ+1\n&LI    SETA  &LI+1\n&LIND(&LI) SETC '#@LB&SEQ'\n  MEXIT\n.OVER  MNOTE 8,' LABEL STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'\n    MEND\n./ ADD NAME=PUSHNEST\n  MACRO\n PUSHNEST &P1\n GBLA &CCVAL       COND CODE VARIABLE\n GBLA &CTR       MACRO PARAMETER COUNTER\n GBLA &SEQ       LABEL NUMBER GENERATOR\n GBLA &AI       INDEX FOR TOTAL NO> CASES STK\n GBLA &CI       INDEX FOR CASE AND LBL NO. STKS\n GBLA &II       PTR TO INST STKS\n GBLA &LI       INDEX FOR LABEL NUMBER STK\n GBLA &NI       PTR TO NEST STK\n GBLA &AIND(50)       TOTAL CASES STK\n GBLA &CIND1(200)      CASE NUMBER STK\n GBLA &MULT(50)       CASE NUMBER MULTIPLIER\n GBLA &ST(51)       INST STK INCREASE AT EACH LEVEL\n GBLC &CIND2(200)      LABEL NUMBER STK FOR CASES\n GBLC &IIND1(100)      INSTRUCTION STK 1\n GBLC &IIND2(100)      INSTRUCTION STK 2\n GBLC &I22(100)       INSTRUCTION STK 2, 2ND PART\n GBLC &I23(100)       INSTRUCTION STK 2, 3RD PART\n GBLC &I24(100)       INSTRUCTION STK 2, 4TH PART\n GBLC &IIND3(100)      INSTRUCTION STK 3\n GBLC &I32(100)       INSTRUCTION STK 3, 2ND PART\n GBLC &I33(100)       INSTRUCTION STK 3, 3RD PART\n GBLC &I34(100)       INSTRUCTION STK 3, 4TH PART\n GBLC &IIND4(100)      INSTRUCTION STK 4\n GBLC &I42(100)       INSTRUCTION STK 4, 2ND PART\n GBLC &I43(100)       INSTRUCTION STK 4, 3RD PART\n GBLC &IIND5(100)      INSTRUCTION NAME STACK\n GBLC &LIND(101)      LABEL NUMBER STK\n GBLC &NEST(50)       NESTING STK\n GBLC &RIND(50)       REG STK FOR CASENTRY MACRO\n&NI  SETA  &NI+1\n  AIF   (&NI GE 50).OVER\n&NEST(&NI) SETC '    &P1'\n  MEXIT\n.OVER  ANOP\n  MNOTE 8,'NEST STACK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'\n  MEND\n./ ADD NAME=SEGDO\n         MACRO\n         SEGDO &NAME\n.*\n.* CREATED BY JOHN GATELEY\n.*\n         GBLC  &SEGNAM\n.*\n         AIF   ('&NAME' EQ '').MNOTE1\n         AIF   ('&SEGNAM' EQ '##&NAME').MNOTE2\n.*\n           AIF   ('&NAME' NE 'WRITE_LOG').NOWLOG\n           GBLC  &WRTLOGU\n&WRTLOGU   SETC  'Y'\n.NOWLOG    ANOP\n.*\n         BRAS  R14,##&NAME\n.*\n         MEXIT\n.MNOTE1  MNOTE 8,'SEGMENT NAME OMITTED'\n         MEXIT\n.MNOTE2  MNOTE 8,'THE SEGMENT SPECIFIED IS THE CURRENT ONE'\n         MEXIT\n         MEND\n./ ADD NAME=SEGE\n           MACRO\n           SEGE  &NAME\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SEGSAVA\n           GBLC  &SEGNAM\n           GBLA  &SEGCNT\n           GBLC  &SCBASER\n           GBLA  &SCBASEC\n           GBLC  &BASSAVA\n           LCLA  &SEGNO\n.*\n           AIF   ('&SEGSAVA' EQ '').MNOTE3\n           AIF   ('&NAME' EQ '').MNOTE1\n           AIF   ('&SEGNAM' NE '##&NAME').MNOTE2\n.*\n&SEGNAM    SETC  ''\n&SEGNO     SETA  &SEGCNT-1\n.*\n           L     R14,&SEGSAVA+(4*&SEGNO)\n           AIF   ('&SCBASER' EQ 'N').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE4\n#END_CBASE_&SCBASEC  DS    0H\n           L     &SCBASER,&BASSAVA+(4*&SEGNO)\n           DROP  &SCBASER\n.NOCBASE   ANOP\n           BR    R14\n           EJECT\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'segment name omitted'\n           MEXIT\n.*\n.MNOTE2    MNOTE 8,'segment name does not match previous'\n           MEXIT\n.*\n           MEXIT\n.MNOTE3    MNOTE 8,'macro variable \"SEGSAVA\" has not been set'\n           MEXIT\n.MNOTE4    MNOTE 8,'macro variable \"BASSAVA\" has not been set'\n           MEXIT\n           MEND\n./ ADD NAME=SEGQUIT\n           MACRO\n           SEGQUIT\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SEGSAVA\n           GBLA  &SEGCNT\n           GBLC  &SCBASER\n           GBLA  &SCBASEC\n           GBLC  &BASSAVA\n           LCLA  &SEGNO\n.*\n           AIF   ('&SEGSAVA' EQ '').MNOTE1\n           AIF   ('&SEGCNT' EQ '0').MNOTE2\n.*\n&SEGNO     SETA  &SEGCNT-1\n.*\n           L     R14,&SEGSAVA+(4*&SEGNO)\n           AIF   ('&SCBASER' EQ 'NO').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE3\n           L     &SCBASER,&BASSAVA+(4*&SEGNO)\n.NOCBASE   ANOP\n           BR    R14\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'macro variable \"SEGSAVA\" has not been set'\n           MEXIT\n.MNOTE2    MNOTE 8,'you are not actually in a segment'\n           MEXIT\n.MNOTE3    MNOTE 8,'macro variable \"BASSAVA\" has not been set'\n           MEXIT\n           MEND\n./ ADD NAME=SEGS\n           MACRO\n           SEGS &NAME\n.*\n.* Created by John Gateley\n.*\n           GBLC  &SEGSAVA\n           GBLC  &BASSAVA\n           GBLC  &SEGNAM\n           GBLA  &SEGCNT\n           GBLA  &SEGMAX\n           GBLC  &SCBASER\n           GBLA  &SCBASEC\n           AIF   (&SEGMAX NE 0).MAXOK\n&SEGMAX    SETA  50\n.MAXOK     ANOP\n.*\n           AIF   ('&SEGSAVA' EQ '').MNOTE4\n           AIF   ('&SEGNAM' NE '').MNOTE1\n           AIF   ('&NAME' EQ '').MNOTE2\n           AIF   (&SEGCNT EQ &SEGMAX).MNOTE3\n.*\n&SEGNAM    SETC  '##&NAME'\n.*\n           AIF   ('&NAME' NE 'WRITE_LOG').NOWLOG\n           GBLC  &WRTLOGD\n&WRTLOGD   SETC  'Y'\n.NOWLOG    ANOP\n.*\n           DC    H'0'           STOP A FALL INTO THIS SEG\n&SEGNAM    ST    R14,&SEGSAVA+(4*&SEGCNT)\n           AIF   ('&SCBASER' EQ 'N').NOCBASE\n           AIF   ('&SCBASER' EQ '').NOCBASE\n           AIF   ('&BASSAVA' EQ '').MNOTE5\n&SCBASEC   SETA  1+&SCBASEC\n           ST    &SCBASER,&BASSAVA+(4*&SEGCNT)\n           BASR  &SCBASER,0\n           USING (*,#END_CBASE_&SCBASEC),&SCBASER\n.NOCBASE   ANOP\n.*\n&SEGCNT    SETA  1+&SEGCNT\n.*\n           MEXIT\n.MNOTE1    MNOTE 8,'missing SEGE macro, or duplicate SEGS macro'\n           MEXIT\n.MNOTE2    MNOTE 8,'SEGS name omitted'\n           MEXIT\n.MNOTE3    MNOTE 8,'maximum segments exceeded '\n           MEXIT\n.MNOTE4    MNOTE 8,'macro variable \"SEGSAVA\" has not been set'\n           MEXIT\n.MNOTE5    MNOTE 8,'macro variable \"BASSAVA\" has not been set'\n           MEXIT\n           MEND\n./ ADD NAME=SETRC\n           MACRO\n           SETRC &RC=0,&COND=N\n.*\n.* Created by John Gateley\n.*\n           AIF   ('&RC' EQ '0').MAKE0\n           AIF   ('&COND' EQ 'N').NOCOND\n           AIF   ('&COND' NE 'Y').MNOTE1\n           CLI   R_C+3,&RC\n           BH    RC&SYSNDX\n           MVI   R_C+3,&RC\nRC&SYSNDX  DS    0H\n           MEXIT\n.*\n.MAKE0     ANOP\n           XC    R_C,R_C\n           MEXIT\n.*\n.NOCOND    ANOP\n           XC    R_C,R_C\n           MVI   R_C+3,&RC\n           MEXIT\n.*\n.*\n           MEXIT\n.MNOTE1    MNOTE 16,'COND parameter was not Y or N'\n           MEND\n./ ADD NAME=STKINS\n         MACRO\n         STKINS &P1,&P2,&P3,&P4,&P5,&P6\n         COPY  GBLVARS\n         LCLC  &SIGN\n.*\n.* AUGUST 2014 - JOHN GATELEY - ADD SUPPORT FOR TAM AND TP\n.*\n         AIF    ('&P1(2)' EQ '').NOTSUBL\n           AIF ('&P1(6)' EQ '' OR '&P1(6)' EQ '&LIND(&LI)').OKSUBL\n             MNOTE 12,'TOO MANY OPERANDS INSIDE PARENTHESES'\n             MEXIT\n.OKSUBL  AIF   ('&P1(1)' EQ 'TP').TPST\n         AIF   ('&P1(1)' EQ 'TAM').TAM24\n         AIF   ('&P1(3)' EQ '').FILE\n         PUSHINS (&P1(1),&P1(2),&P1(3),&P1(4),&P1(5),&P1(6))\n             MEXIT\n.NOTSUBL AIF   ('&P2' EQ '' OR '&P2' EQ 'OR' OR '&P2' EQ 'AND' OR '&P2'X\n               EQ 'ORIF' OR '&P2' EQ 'ANDIF').SGLOPR\n           AIF ('&P5' EQ 'OR' OR '&P5' EQ 'AND' OR '&P5' EQ 'ORIF' OR  X\n               '&P5' EQ 'ANDIF').TWOPER2\n             PUSHINS (&P1,&P2,&P3,&P4,&P5,&P6)\n&CTR         SETA  &CTR+4\n             MEXIT\n.TWOPER2   PUSHINS (&P1,&P2,&P3,&P4,,&P6)\n&CTR         SETA  &CTR+3\n             MEXIT\n.FILE    AIF   ('&P1(1)'(1,1) EQ '(').FILE1\n&SIGN    SETC  '+'\n.FILE1   AIF   ('&P1(2)' NE 'OPEN').FILE2\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'10',O,&P1(5),&P1(6))\n         MEXIT\n.FILE2   AIF   ('&P1(2)' NE 'NOTOPEN').FILE3\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'10',Z,&P1(5),&P1(6))\n         MEXIT\n.FILE3   AIF   ('&P1(2)' NE 'EOF').FILE4\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'04',O,&P1(5),&P1(6))\n         MEXIT\n.FILE4   AIF   ('&P1(2)' NE 'NOTEOF').FILE5\n         PUSHINS (TM,X'30'&SIGN&P1(1),X'04',Z,&P1(5),&P1(6))\n         MEXIT\n.FILE5   AIF   ('&P1(2)' NE 'ENDPROG').FILE6\n         PUSHINS (CLC,&P1(1),NE,=F'-1',&P1(5),&P1(6))\n         MEXIT\n.FILE6   AIF   ('&P1(2)' NE 'NOTENDPROG').FILE7\n         PUSHINS (CLC,&P1(1),EQ,=F'-1',&P1(5),&P1(6))\n         MEXIT\n.FILE7   AIF   ('&P1(2)' NE 'INERROR').FILE8\n         PUSHINS (CLC,&P1(1),NE,=F'0',&P1(5),&P1(6))\n         MEXIT\n.FILE8   AIF   ('&P1(2)' NE 'NOTINERROR').FILE9\n         PUSHINS (CLC,&P1(1),EQ,=F'0',&P1(5),&P1(6))\n         MEXIT\n.FILE9   AIF   ('&P1(2)' NE 'SYNAD').FILE10\n         PUSHINS (TM,X'2C'&SIGN&P1(1),X'30',O,&P1(5),&P1(6))\n         MEXIT\n.FILE10  AIF   ('&P1(2)' NE 'NOTSYNAD').FILE11\n         PUSHINS (TM,X'2C'&SIGN&P1(1),X'30',Z,&P1(5),&P1(6))\n         MEXIT\n.FILE11  ANOP\n         PUSHINS (TM,0(0),X'00',O,&P1(5),&P1(6))\n         MNOTE 12,'INVALID INSTRUCTION &P1(1),&P1(2) - NOP GENERATED'\n         MEXIT\n.*\n.TPST    ANOP\n         PUSHINS (&P1(1),&P1(2),,&P1(3))\n         MEXIT\n.*\n.TAM24   AIF   ('&P1(2)' NE '24').TAM31\n         PUSHINS (&P1(1),*24,,8)\n         MEXIT\n.TAM31   AIF   ('&P1(2)' NE '31').TAM64\n         PUSHINS (&P1(1),*31,,4)\n         MEXIT\n.TAM64   AIF   ('&P1(2)' NE '64').TAMERR\n         PUSHINS (&P1(1),*64,,1)\n         MEXIT\n.TAMERR  ANOP\n         MNOTE 12,'TAM CAN ONLY TEST 24 31 OR 64'\n         MEXIT\n.*\n.SGLOPR  GETCC  &P1(1)\n         MEND\n./ ADD NAME=STRING\n         MACRO\n         STRING  &OUT=MESS_TXT,&WORK=,&SAVE=MY_PARM,&SLEN=0,           /\n               &PAD=,&PADB=N,&FPAD=0,&NUM0=N\n.**********************************************************************\n.*\n.* November  2016 - John Gateley - create\n.*\n.*       This macro uses program STRINGIT to concatenate the values\n.*       of fields into an area.\n.*\n.*       This macro takes positional parameters in groups of two,\n.*       as many as required. Followed by keyword parameters as\n.*       detailed below.\n.*\n.*       The repeated values are field-name and C,X,B,P,I,U,S or V\n.*         C means just copy it (character)\n.*         X means output hexadecimal display\n.*         B means output binary display\n.*         P means packed decimal input, output numeric display\n.*         I Fullword integer, output numeric display\n.*         U Unsigned fullword integer, output numeric display\n.*         S Halfword small integer, output numeric display\n.*         V Unsigned halfword small integer, output numeric display\n.*\n.*       STRING (field1,c,field2,x,(R4),x),OUT=MESS_TXT,WORK=CL32\n.*\n.*       OUT=    the area in which the string is to be built\n.*\n.*       WORK=   a 32 byte work area for program STRINGIT\n.*       If this is not provided a global macro variable STRWRK\n.*       will be used as the work area. If neither of these is\n.*       provided the macro will fail to expand.\n.*       GBLC  &STRWRK\n.*\n.*\n.*       If the value to be displayed is in a register just use\n.*       register notation in the macro i.e. (R6) and use X or I\n.*       depending on how you want to view the contents\n.*\n.*       STRING (field1,c,(R3),x,(R4),i),OUT=MESS_TXT,PAD=|\n.*\n.*       Note that if you want to use the value of a 64 bit\n.*       register you will need to use STG to place the value into\n.*       an 8 byte field and use that in the macro.\n.*       This is because the actual register value is stored in the\n.*       parameter list instead of an address and the parameter\n.*       list consists of 32 bit words.\n.*\n.*       If the PAD= parameter is specified a pad byte will be\n.*       included between each field which will contain the specified\n.*       value.\n.*       PADB=Y means have a pad byte but make it C' '\n.*       PADB takes precedence over the PAD= macro parameter\n.*\n.*       FPAD is the number of pad bytes to be put at the start\n.*       of the output area, this is to allow the text to be indented.\n.*       Using OUT=MESS_TXT+2 instead of FPAD=2 is not recomended as\n.*       although it will indent by 2 it will cause the macro to think\n.*       that the output field is 4 bytes longer than it is.\n.*       LA    R15,L'MESS_TXT+2 will take the length and add 2 to it\n.*       when the effective length should be L'MESS_TXT-2\n.*\n.*       NUM0=N means do not output leading zeroes from numeric display\n.*       change to Y if you want leading zeroes.\n.*\n.*       If the output message area is not big enough for all the\n.*       required fields then program STRINGIT will abend with a\n.*       suitable message. As the length of the strung output\n.*       will not vary, if this works in test it will work in\n.*       production.\n.*\n.*       The SAVE= parameter specifies an area in which the macro\n.*       builds the parameter list for the call to STRINGIT, this\n.*       defaults to MY_PARM.\n.*\n.*       Note that the last parameter will not have the high order\n.*       bit set on as STRINGIT processing stops when the value\n.*       x'FF' is found in the indicator list. This is because a\n.*       register value could be negative.\n.*\n.*       SLEN= may be used to specify the number of fullwords\n.*       available in the parameter list, this ensures that\n.*       storage after the end of the parameter list is not\n.*       overwritten.\n.*       If this is not provided a global macro variable PARMAX\n.*       will be used as the count of fullwords. If neither of\n.*       these is provided the macro will fail to expand.\n.*\n.*       GBLA  &PARMAX\n.*&PARMAX    SETA  18\n.*\n.*\n.*       After the macro call STRINGIT R1 will contain the address\n.*       of the byte after the last one modified. R15 will be zero.\n.*\n.*       Note that this macro and the STRINGIT program are reentrant.\n.*\n.*\n.*       End of comments, down to business.\n.*\n.*\n&A       SETA  N'&SYSLIST(1)             * get count of values in ( )\n&B       SETA  &A/2                      * divide by 2\n&C       SETA  1\n&D       SETA  1\n&E       SETA  6                         * minimum 6 parameters\n&F       SETA  &B*2                      * multiply by 2\n         AIF   (&F NE &A).NOTEVEN        * not equal means not even\n.*\n         LCLC  &INDS\n         LCLA  &PARMS\n         GBLA  &PARMAX\n         GBLC  &STRWRK\n.*\n         AIF   ('&NUM0' EQ 'Y').NUMOK    * Y is OK\n         AIF   ('&NUM0' EQ 'N').NUMOK    * N is OK\n         AGO   .BADNUM\n.NUMOK   ANOP\n.*\n&PARMS   SETA  &PARMAX\n         AIF   ('&SLEN' EQ '0').NOTSLEN  * default to PARMAX\n&PARMS   SETA  &SLEN\n.NOTSLEN ANOP\n         AIF   (&PARMS EQ 0).NOLEN       * flag expansion error\n         AIF   (&PARMS LT 6).TOOMUCH     * filled up parameter area\n.*\n         AIF   (T'&OUT EQ 'O').NOOUT     * output area provided\n.*\n         AIF   (T'&WORK NE 'O').YESWORK  * work area provided\n         AIF   ('&STRWRK' NE '').STWORK  * default to STRWRK\n         AGO   .NOWORK\n.YESWORK ANOP\n&WRK     SETC  '&WORK'                   * use provided work area\n         AGO   .AFTWORK\n.STWORK  ANOP\n&WRK     SETC  '&STRWRK'\n.AFTWORK ANOP\n.*\n.*       first put in the address of the indicators, followed by\n.*       the start and length of the output area and finally\n.*       the work area address.\n.*\n         LA    R14,I&SYSNDX              * point to list of indicators\n         LA    R15,&OUT                  * address of output string\n         LA    R0,L'&OUT                 * length of output string\n         LA    R1,&WRK                   * work area for STRINGIT\n         STM   R14,R1,&SAVE              * save in parameters 1,2,3 + 4\n         LA    R1,&SAVE+16               * point to fifth parameter\n.*\n.AGAIN   ANOP\n.*                                       * is value in a register?\n&RVAL    SETC  '&SYSLIST(1,&C)'\n         AIF   ('&RVAL'(1,1) EQ '(').REGVAL\n.*                                       * not register notation\n         AIF   ('&RVAL'(1,1) EQ '''').QUOTVAL\n.*                                       * not quoted string\n         LA    R14,&SYSLIST(1,&C)        * sending field\n         LA    R15,L'&SYSLIST(1,&C)      * length\n         AGO   .AFTREG\n.*\n.QUOTVAL ANOP\n&QLEN    SETA  K'&RVAL-2\n         LA    R14,=C&RVAL\n         LA    R15,&QLEN\n         AGO   .AFTREG\n.*\n.REGVAL  ANOP\n&RVAL2   SETC  '&SYSLIST(1,&C)'(2,K'&SYSLIST(1,&C)-2)\n.*                                       * register notation\n         LR    R14,&RVAL2                * copy register value\n         LHI   R15,-4                    * say -4 to show in register\n.*\n.AFTREG  ANOP\n         STM   R14,R15,0(R1)             * save in parameter list\n.*\n         AIF   ('&D' GE '&B').DONE1      * done last value?\n&C       SETA  &C+2\n&D       SETA  &D+1\n&E       SETA  &E+2\n         AIF   (&E GT &PARMS).TOOMUCH    * filled up parameter area\n.DONE0   ANOP\n         LA    R1,8(,R1)                 * point past these two\n         AGO   .AGAIN                    * process next value\n.DONE1   ANOP\n.*\n&A       SETA  N'&SYSLIST(1)             * get count of values\n&B       SETA  &A/2                      * divide by 2\n&C       SETA  1\n&D       SETA  1\n         B     A#&SYSNDX                 * branch past indicators\n.*\n.*   This code builds a string containing all the specified format\n.*   indicators.\n.*\n.AGAIN2  ANOP\n.*\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'C').CHAR\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'c').CHAR\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'X').HEX\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'x').HEX\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'B').BINARY\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'b').BINARY\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'P').PACKED\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'p').PACKED\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'I').INTEGER\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'i').INTEGER\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'U').UINT\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'u').UINT\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'S').SMALL\n         AIF   ('&SYSLIST(1,&C+1)' EQ 's').SMALL\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'V').USMALL\n         AIF   ('&SYSLIST(1,&C+1)' EQ 'v').USMALL\n         AGO   .NEITHER                  * not valid\n.CHAR    ANOP\n&INDS    SETC  '&INDS.C'                 * say character\n         AGO   .DONE3\n.HEX     ANOP\n&INDS    SETC  '&INDS.X'                 * say hexadecimal\n         AGO   .DONE3\n.BINARY  ANOP\n&INDS    SETC  '&INDS.B'                 * say binary\n         AGO   .DONE3\n.PACKED  ANOP\n&INDS    SETC  '&INDS.P'                 * say packed decimal\n         AGO   .DONE3\n.INTEGER ANOP\n&INDS    SETC  '&INDS.I'                 * say integer\n         AGO   .DONE3\n.UINT    ANOP\n&INDS    SETC  '&INDS.U'                 * say unsigned integer\n         AGO   .DONE3\n.SMALL   ANOP\n&INDS    SETC  '&INDS.S'                 * say small integer\n         AGO   .DONE3\n.USMALL  ANOP\n&INDS    SETC  '&INDS.V'                 * say unsigned small integer\n         AGO   .DONE3\n.DONE3   ANOP\n.*\n         AIF   ('&D' GE '&B').DONE4      * done last value?\n&C       SETA  &C+2\n&D       SETA  &D+1\n         AGO   .AGAIN2                   * process next value\n.DONE4   ANOP\n.*\n         AIF   ('&PADB' EQ 'N').TRYPAD\n&UPAD    SETC  'Y '                      * pad with a blank\n         AGO   .ENDPAD\n.TRYPAD  ANOP\n         AIF   (T'&PAD NE 'O').USEPAD    * use provided pad char\n&UPAD    SETC  'N '                      * no padding\n         AGO   .ENDPAD\n.USEPAD  ANOP\n&UPAD    SETC  'Y&PAD'                   * use pad character and value\n.ENDPAD  ANOP\n.*\nI&SYSNDX DC    CL15'&UPAD&FPAD&NUM0'     * Currently 4 bytes of global\n.*                                       * indicators but allow for 15\n         DC    C'&INDS'                  * output all the indicators\n         DC    X'FF'                     * flag end of indicators\nA#&SYSNDX      DS    0H\n         LA    R1,&SAVE                  * point to parameters\n         L     R15,=V(STRINGIT)          * get string routine address\n         BASR  R14,R15                   * and go there\n         MEXIT\n.NOTEVEN MNOTE 16,'Number of positional parameters not even'\n         MEXIT\n.NOOUT   MNOTE 16,'No output area provided OUT='\n         MEXIT\n.BADNUM  MNOTE 16,'NUM0 not equal to Y or N'\n         MEXIT\n.NEITHER MNOTE 16,'Second value must be C,X,B,P,I,U,S or V'\n         MEXIT\n.TOOMUCH MNOTE 16,'Too many values for supplied parameter area'\n         MEXIT\n.NOLEN   MNOTE 16,'Length of parameter area not supplied, SLEN='\n         MEXIT\n.NOWORK  MNOTE 16,'No work area was provided, WORK='\n         MEND\n./ ADD NAME=STRINGIT\nSTRINGIT CSECT\nSTRINGIT AMODE 31\nSTRINGIT RMODE ANY\n*\n* Created by John Gateley\n*\n*   This program is used by the STRING macro to convert fields\n*   to the required format and to put them into the output area.\n*\n*   Note that on return from this program register 1 contains the\n*   address of the byte in the output area after the strung data.\n*\n*   Input parameters generated by the STRING macro are\n*     1, address of a series of format indicators terminated by x'FF'\n*     2, address of output area\n*     3, length of the output area\n*     4, address of a 32 byte work area\n*\n*     5, address of input field\n*     6, length of input field\n*\n*   Parameters 5 and 6 repeat for as many indicators as there are in\n*   the list pointed to by parameter 1\n*\n*   note that this program does not have it's own save area because\n*   it does not call anything and it needs to be re-entrant\n*\n         SAVE  (14,12)                   * save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                   * copy base address\n         USING STRINGIT,R12\n         LR    R10,R1                    * copy parameter address\n         LM    R3,R6,0(R10)              * load first 4 parameters\n*                              R3    string of output indicators\n*                              R4    address of output field\n*                              R5    length of output field\n*                              R6    work area in caller\n         USING WORKAREA,R6\n         MVC   GLOB_IND,0(R3)        * copy global indicators\n         LA    R3,L'GLOB_IND(,R3)    * point passed global indicators\n         AR    R5,R4                 * point after output field\n         LA    R7,16(,R10)     R7    * point to first address/length\n*\n         CLI   PAD_FRST,C'0'\n         BNH   GO_AGAIN              * no initial pad char\n         PACK  DOUB_WORD,PAD_FRST\n         CVB   R1,DOUB_WORD\n         LA    R4,0(R1,R4)           * point passed initial pad char\n*\nGO_AGAIN DS    0H\n         LM    R8,R9,0(R7)           Get details of next field\n*\n*        if the length in R9 is negative it means that R8 contains\n*        the value to be displayed not the address of the value\n*\n         LTR   R9,R9                     * test R9\n         BP    IS_POS                    * if positive then use it\n         LPR   R9,R9                     * make positive\n         ST    R8,FULL_WORD              * save 32 bit value\n         LA    R8,FULL_WORD              * and point to it\n*\nIS_POS   DS    0H\n*\n         CLI   0(R3),C'X'                * Hex output required\n         BE    HEX_OUT\n*\n         CLI   0(R3),C'B'                * Binary output required\n         BE    BIN_OUT\n*\n         CLI   0(R3),C'P'                * Pack output required\n         BE    PACK_OUT\n*\n         CLI   0(R3),C'I'                * Integer output required\n         BE    INT_OUT\n*\n         CLI   0(R3),C'U'                * Unsigned integer required\n         BE    UINT_OUT\n*\n         CLI   0(R3),C'S'                * Small Int output required\n         BE    SINT_OUT\n*\n         CLI   0(R3),C'V'                * Small unsigned int required\n         BE    VINT_OUT\n*\n*        assume it must be character\n*\n*        Just copy the character value to the output area\n*\nCHAR_OUT DS    0H\n         LA    R1,0(R9,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         BCTR  R9,0                      * -1 for execute\n         EX    R9,MVC_IT                 * execute the move\n         LA    R4,1(R9,R4)               * point past data copied\n         B     DONE_IT\n*\n*        Take the value and convert to hexadecimal display\n*\nHEX_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nHEX_OUT1 DS    0H\n         MVC   WORK2(1),0(R8)            * copy one byte\n         UNPK  WORK3,WORK2               * UNPK two bytes to three\n         TR    WORK3(2),TR_TAB-240       * convert to displayable\n         MVC   0(2,R4),WORK3             * copy to receiver\n         LA    R4,2(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,HEX_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Take the value and convert to binary display\n*        This puts the byte into the low byte of register 1 and then\n*        for each iteration of the inner loop moves the next bit into\n*        the low bit of byte three of the register and stores it.\n*        So as the loop progresses the bit values become bytes in\n*        the output string.\n*\nBIN_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,3                      * multiply by 8\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nBIN_OUT1 DS    0H\n         IC    R1,0(R8)                  * get a byte\n         LR    R14,R4                    * copy output address\n         LA    R15,8                     * 8 bits to a byte\n*\nBIN_OUT2 DS    0H\n         SLA   R1,1                      * slide left 1 bit\n         STCM  R1,2,0(R14)               * store third byte\n         NI    0(R14),1                  * switch of all but right bit\n         LA    R14,1(,R14)               * next output byte\n         BCT   R15,BIN_OUT2              * process next bit\n*\n         OC    0(8,R4),ZONES             * make zoned decimal\n         LA    R4,8(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,BIN_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Input is packed convert to numeric display\n*\nPACK_OUT DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         CHI   R9,8                      * cannot unpk > 8 bytes\n         BH    PACKLONG                  * so abend\n         LR    R1,R9                     * get length of field\n         BCTR  R1,0                      * less 1 for execute\n         LR    R15,R1                    * copy for CP\n         SLL   R15,4                     * left one nibble\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtact for EX and sign\n         SLL   R2,1                      * multiply by 2\n         LA    R14,0(R2,R4)              * position to last digit\n         SLL   R2,4                      * left one nibble\n         OR    R1,R2                     * merge lengths\n         EX    R1,UNPK_IT                * unpack data\n         OI    0(R14),X'F0'              * make last digit numeric\n         EX    R15,CP_IT                 * check if negative\n         BL    P_NEG                     * branch negative\n         MVI   1(R14),C'+'\n         B     P_DONE\nP_NEG    DS    0H\n         MVI   1(R14),C'-'\nP_DONE   DS    0H\n*\n*        the following code is to remove leading zeroes, I know I\n*        could have built an edit pattern and executed an edit\n*        instruction but I thought this was easier. Also having a pad\n*        character would increase the size of the output field.\n*\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    P_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtract 1\n         SLL   R2,1                      * multiply by 2\nP_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   P_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,P_CHK0                 * check next\nP_DONEX  DS    0H\n         LA    R4,2(,R14)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is integer convert to numeric display\n*\nINT_OUT  DS    0H\n         LA    R1,11(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    I_NEG\n         MVI   10(R4),C'+'\n         B     I_DONE\nI_NEG    DS    0H\n         MVI   10(R4),C'-'\nI_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(10,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    I_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nI_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   I_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,I_CHK0                 * check next\nI_DONEX  DS    0H\n         LA    R4,11(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed integer convert to numeric display\n*\nUINT_OUT DS    0H\n         LA    R1,10(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         SRL   R1,1                      * divide by 2\n         CVD   R1,DOUB_WORD              * convert to decimal\n         MP    DOUB_WORD,=P'2'           * multiply by 2\n         TM    3(R8),X'01'               * was low bit on\n         BZ    U_DONE\n         AP    DOUB_WORD,=P'1'           * add the one back in\nU_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'         * set the sign\n         UNPK  0(10,R4),DOUB_WORD        * unpack the value\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    U_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nU_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   U_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,U_CHK0                 * check next\nU_DONEX  DS    0H\n         LA    R4,10(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is small integer convert to numeric display\n*\nSINT_OUT DS    0H\n         LA    R1,6(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         LH    R1,0(R8)                  * get small integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    S_NEG\n         MVI   5(R4),C'+'\n         B     S_DONE\nS_NEG    DS    0H\n         MVI   5(R4),C'-'\nS_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    S_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nS_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   S_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,S_CHK0                 * check next\nS_DONEX  DS    0H\n         LA    R4,6(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed small integer convert to numeric display\n*\nVINT_OUT DS    0H\n         LA    R1,5(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         ICM   R1,3,0(R8)                * get small unsigned int val\n         CVD   R1,DOUB_WORD\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    V_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nV_CHK0   CLI   0(R4),C'0'                * is this byte zero\n         BNE   V_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,V_CHK0                 * check next\nV_DONEX  DS    0H\n         LA    R4,5(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Processed that pair of address/length values - any more\n*\nDONE_IT  DS    0H\n         LA    R3,1(,R3)                 * point to next indicator\n         CLI   0(R3),X'FF'               * finished ?\n         BE    GO_BACK                   * then goback\n*\n         LA    R7,8(,R7)                 * next pair of addresses\n         CLI   PAD_DING,C'Y'             * any pad characted ?\n         BNE   GO_AGAIN                  * not so go again\n         MVC   0(1,R4),PAD_DING+1        * copy pad character\n         LA    R4,1(,R4)                 * jump past pad\n         B     GO_AGAIN                  * process next\n*\n*        Return to calling program setting R1 to the output byte after\n*        the last byte used.\n*\nGO_BACK  DS    0H\n         ST    R4,4(,R10)                * save current output address\n*                                        * in parameter list\n         LM    R14,R12,12(R13)           * restore callers registers\n         XR    15,15                     * set return code\n         L     R1,4(,R1)                 * retrieve current output adr\n*                                        * from parameter list\n         BR    R14                       * return to caller\n*********\n*\n* error routines\n*\n* There is no room in the output area for the input value so abend\n*\nOVERFLOW DS    0H\n         WTO   'STRINGIT - output overflow detected',                  /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         B     DO_AB\n*\n* Cannot unpack more than 8 bytes so abend\n*\nPACKLONG DS    0H\n         WTO   'STRINGIT - packed field > 8',                          /\n               ROUTCDE=11,MCSFLAG=HRDCPY\nDO_AB    ABEND 500,DUMP,STEP             * ,REASON=1\n*********\n*\n* storage\n*\nWORKAREA       DSECT\nDOUB_WORD      DS    D\nFULL_WORD      DS    F\nWORK2          DS    CL2\nWORK3          DS    CL3\nGLOB_IND       DS    CL15\n               ORG   GLOB_IND\nPAD_DING       DS    CL2             * pad details  (Y/N + value)\nPAD_FRST       DS    CL1             * pad first value   (numeric)\nNUM_ZERO       DS    CL1             * output numeric leading zeroes\n               ORG\n*\nSTRINGIT       CSECT\nZONES          DC    C'00000000'\nTR_TAB         DC    C'0123456789ABCDEF'\nMVC_IT         MVC   0(1,R4),0(R8)\nUNPK_IT        UNPK  0(1,R4),0(1,R8)\nCP_IT          CP    0(1,R8),=P'0'\n*\n               LTORG\n*\n               END\n./ ADD NAME=TESTNEST\n  MACRO\n TESTNEST &P1\n GBLC &PGMNAME\n GBLC &ENDPROG\n GBLC &MODNAME\n GBLC &MODSTRT\n GBLC &ENDMOD\n GBLC &SEGNAME\n GBLC &SEGSTRT\n GBLA &EQUATE\n GBLA &CCVAL\n GBLA &CTR\n GBLA &SEQ\n GBLA &II\n GBLA &LI\n GBLA &NI\n GBLA &ST(51)\n GBLC &IIND1(100)\n GBLC &IIND2(100)\n GBLC &I22(100)\n GBLC &I23(100)\n GBLC &I24(100)\n GBLC &IIND3(100)\n GBLC &I32(100)\n GBLC &I33(100)\n GBLC &I34(100)\n GBLC &IIND4(100)\n GBLC &I42(100)\n GBLC &I43(100)\n GBLC &IIND5(100)\n GBLC &LIND(101)\n GBLC &NEST(50)\n GBLA &AI\n GBLA &CI\n GBLA &AIND(50)\n GBLA &MULT(50)\n GBLA &CIND1(200)\n GBLC &CIND2(200)\n GBLC &RIND(50)\n LCLC &STRUCT\n&STRUCT  SETC  '&NEST(&NI)'(5,4)\n  AIF   ('&STRUCT' EQ '&P1').GOOD\n    MNOTE 8,'&STRUCT STRUCTURE AT SAME LEVEL AS &P1 MACRO SET'\n.GOOD  ANOP\n  MEND\n./ ADD NAME=TRIM\n         MACRO\n         TRIM  &AREA,&LEN,&SAVE=MY_PARM,&ALL=N\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro removes leading and extra blanks from a field\n.*       so that         '  some  text    in    a  field       x'\n.*       becomes         'some text in a field x                '\n.*\n.*       Optionally, all blanks can be removed from the field by\n.*       specifying ALL=Y.\n.*\n.*       On return R15 contains the number of occupied bytes\n.*\n.*       &AREA=   the field to trim, can be in a register (R14)\n.*       &LEN=    length of the field, can be in a register (R15)\n.*                it can also be omitted\n.*       &SAVE=   name of parameter list to use\n.*\n.*       TRIM  MY_FIELD,20             length of 20\n.*       TRIM  MY_FIELD                assumes L'MY_FIELD\n.*       LA    R1,MY_FIELD\n.*       LA    R2,L'MY_FIELD\n.*       TRIM  (R1),(R2)\n.*\n         AIF   (T'&LEN NE 'O').USELEN        * parameter missing\n         LA    R15,L'&AREA             use the implied length\n         ST    R15,&SAVE+4             save as second parameter\n         AGO   .NOTREGL\n.*\n.USELEN  ANOP\n         AIF   ('&LEN'(1,1) EQ '(').REGVALL  * value in register\n         LA    R15,&LEN                use the specified length\n         ST    R15,&SAVE+4             save as second parameter\n         AGO   .NOTREGL\n.REGVALL ANOP\n&LENR    SETC  '&LEN'(2,K'&LEN-2)\n         ST    &LENR,&SAVE+4           save length as second parameter\n.NOTREGL ANOP\n.*\n         AIF   ('&AREA'(1,1) EQ '(').REGVALA  * value in register\n         LA    R14,&AREA               point at area\n         ST    R14,&SAVE               save as first parameter\n         AGO   .NOTREGA\n.REGVALA ANOP\n&VALR    SETC  '&AREA'(2,K'&LEN-2)\n         ST    &VALR,&SAVE             save address as first parameter\n.NOTREGA ANOP\n.*\n         AIF   ('&ALL' EQ 'Y').ALLYES\n         LA    R1,0                    do not remove all blanks\n         ST    R1,&SAVE+8\n         AGO   .DOCALL\n.ALLYES  ANOP\n         LA    R1,1                    remove all blanks\n         ST    R1,&SAVE+8\n.DOCALL  ANOP\n         LA    R1,&SAVE                point to parameter list\n         L     R15,=V(TRIMIT)          get program address\n         BASR  R14,R15                 call program\n.*\n         L     R15,&SAVE+4             load amended length\n*        R15 now has the occupied byte count\n.*\n         MEND\n./ ADD NAME=TRIMIT\nTRIMIT   CSECT\nTRIMIT   AMODE 31\nTRIMIT   RMODE ANY\n*\n*   This program removes leading and extra blanks from a field\n*   so that         '  some  text    in    a  field       x'\n*   becomes         'some text in a field x                '\n*\n*   Optionally, all blanks can be removed from the field by\n*   specifying ALL=Y in the TRIM macro resulting in\n*                   'sometextinafieldx                     '\n*\n*   On return R15 contains the number of occupied bytes\n*\n*   Input parameters generated by the TRIM macro are\n*     1, address of a string which should be trimmed\n*     2, length of the string\n*     3,  0    only remove repeated spaces\n*        >0    remove all spaces\n*\n         SAVE  (14,12)                 save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                 copy base address\n         USING TRIMIT,R12\n         LR    R9,R1                   copy parameter address\n         LM    R4,R6,0(R9)             get address, length and ind\n         LA    R3,0(R4,R5)             point after string\n         BCTR  R3,0                    point at last byte\n*\n         CHI   R6,0                    if positive\n         BH    TRIM_ALL                trim all blanks\n*\n*  remove repeated spaces\n*\n         LA    R6,1                    flag next blank to be removed\nSTRTLOOP LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE  CLI   0(R4),C' '              check if this byte blank\n         BNE   SETNO                   no so set flag off\n         CHI   R6,1                    is flag on\n         BNE   SETYES                  no so set flag on\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE              loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nSETYES   LA    R6,1                    flag next blank to be removed\n         B     LOOPIT                  go and loop\nSETNO    LA    R6,0                    flag next blank to be ignored\nLOOPIT   LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOOP             loop to check next byte\n         B     ENDLOOP\n*\n*  remove all spaces\n*\nTRIM_ALL DS    0H\n*\nSTRTLOO2 LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE2 CLI   0(R4),C' '              check if this byte blank\n         BNE   LOOPIT2                 no so set flag off\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE2             loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nLOOPIT2  LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOO2             loop to check next byte\n*\n*  trim accomplished\n*\nENDLOOP  DS    0H\n*\n*  now get count of occupied bytes\n*\n         LR    R4,R3                   point at last byte\n         L     R5,4(,R9)               get length\nLOOP2    DS    0H\n         CLI   0(R4),C' '              is the byte blank\n         BNE   ENDLOOP2                no so quit\n         BCTR  R4,0                    point to previous byte\n         BCT   R5,LOOP2                loop until 0\nENDLOOP2 DS    0H\n*        R5 now has the occupied byte count\n         ST    R5,4(,R9)               put count in parameter list\n*\nGO_BACK  LM    R14,R12,12(R13)         restore callers registers\n         L     R15,4(,R1)              load occupied byte count\n         BR    R14                     return to caller\n*\nSLIDE_LEFT     MVC   0(0,R4),1(R4)     sliding move instruction\n*\n         LTORG\n         END\n./ ADD NAME=TSTMP\n         MACRO\n         TSTMP &AREA,&LOCAL=N,&FORMAT=DB2\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro uses STCKE to get the time from the system\n.*       and then formats it.\n.*\n.*       &AREA   =  the field to put the timestamp in\n.*       &LOCAL  =  N - just get the timestamp\n.*                  Y - adjust to local time and leap second\n.*       &FORMAT =  DB2  - CL26'2017-04-01-12.34.56.789012'\n.*                  CHAR - CL20'20170401123456789012'\n.*                  PACK - PL11'020170401123456789012C'\n.*\n.*       TSTMP WS_TIMESTAMP\n.*\n         GBLC  &USETSTMP\n&USETSTMP      SETC  'Y'\n.*\n         STCKE #MVCLSAV                store time in PRGDEF field\n.*\n         AIF   ('&LOCAL' EQ 'Y').YESLOC\n         AIF   ('&LOCAL' EQ 'N').NOLOC\n         MNOTE 16,' Invalid LOCAL specified'\n         MEXIT\n.YESLOC  ANOP\n*        L     R1,CVTPTR               point to CVT\n         L     R1,16\n*        L     R1,CVTEXT2-CVT(,R1)     point to extension 2\n         L     R1,328(,R1)\n*        USING CVTXTNT2,R1\n*        LG    R14,CVTLDTO\n         LG    R14,56(,R1)             adjust local time\n*        SG    R14,CVTLSO\n         SG    R14,80(,R1)             adjust leap seconds\n*        DROP  R1\n         LMG   R0,R1,#MVCLSAV          load STCKE output\n         LGR   R15,R14\n         SRAG  R14,R14,8\n         SLLG  R15,R15,(64-8)\n         ALGR  R1,R15\n         ALCGR R0,R14\n         STMG  R0,R1,#MVCLSAV          save amended STCKE output\n.NOLOC   ANOP\n.*\n.*      STCKCONV STCKEVAL=#MVCLSAV,CONVVAL=#MVCLSAV,TIMETYPE=DEC,     /\n         STCKCONV STCKEVAL=#MVCLSAV,CONVVAL=#MVCLSAV,TIMETYPE=DEC,     /\n               DATETYPE=YYYYMMDD,MF=(E,MY_PARM)\n         MVC   #STRING_WORK(4),#MVCLSAV+8    put in correct order\n         MVC   #STRING_WORK+4(6),#MVCLSAV\n         MVI   #STRING_WORK+10,X'0F'\n.*\n         AIF   ('&FORMAT' EQ 'DB2').DODB2\n         AIF   ('&FORMAT' EQ 'CHAR').DOCHAR\n         AIF   ('&FORMAT' EQ 'PACK').DOPACK\n         MNOTE 16,' Invalid FORMAT specified'\n         MEXIT\n.*\n.DOCHAR  ANOP\n         MVC   #MVCLSAV(11),#STRING_WORK     copy out of the way\n         UNPK  #STRING_WORK(15),#MVCLSAV(8)\n         UNPK  #STRING_WORK+14(7),#MVCLSAV+7(4)\n         MVC   &AREA.(20),#STRING_WORK\n         MEXIT\n.*\n.DOPACK  ANOP\n         SRP   #STRING_WORK(11),64-1,0       shift right 1 digit\n         MVC   &AREA.(11),#STRING_WORK\n         MEXIT\n.*\n.DODB2   ANOP\n         MVC   #MVCLSAV(11),#STRING_WORK     copy out of the way\n         MVI   #STRING_WORK,C' '\n         MVC   #STRING_WORK+1(L'#STRING_WORK-1),#STRING_WORK\n         MVC   #STRING_WORK(L'##DAT_PAT),##DAT_PAT\n         ED    #STRING_WORK(L'##DAT_PAT),#MVCLSAV\n         MVC   &AREA.(26),#STRING_WORK+1\n.*\n         MEND\n./ ADD NAME=WHEN\n         MACRO\n&LAB     WHEN\n.*\n.* THIS MACRO IS ONE OF A RELATED SET OF MACROS WHICH ENGINEER THE\n.* SELECTED EXECUTION OF CODE DEPENDING ON THE CONTENTS OF A FIELD.\n.*\n.* THE GENERAL STRUCTURE IS AS FOLLOWS -\n.*    EVALUATE OPCODE,OP1(,OP2.REP.TYPE.LTH)\n.*      WHEN   OP2REST,OP2REST\n.*      WHEN   OP2REST-OP2REST,OP2REST\n.*      OTHERWSE\n.*    ENDEVAL\n.*\n.* OPCODE FOR EACH POSSIBLE DEPTH\n         GBLC  &OP(16)\n.* COMPONENTS OF OPERAND 1 FOR EACH POSSIBLE DEPTH\n         GBLC  &OP1(16)\n.* OPERAND 2 (REP.TYPE.LENGTH) IF ANY - FOR EACH POSSIBLE DEPTH\n         GBLC  &OP2(16)\n.* CURRENT LABEL GENERATION NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &ON(16)\n.* CURRENT END LABEL NUMBER FOR EACH POSSIBLE DEPTH\n         GBLA  &OE(16)\n.* CURRENT DEPTH OF OPTION NESTING (1 TO 16)\n         GBLA  &OD\n.* IMMEDIATE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OI(16)\n.* QUOTES INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OQ(16)\n.* STATUS INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OS(16)\n.* OPTELSE INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OELSE(16)\n.* OPTION INDICATOR FOR EACH POSSIBLE DEPTH\n         GBLB  &OPTN(16)\n.*\n.* LOCAL WORK FIELDS\n         LCLA  &A,&B,&C,&D,&E,&U\n         LCLC  &L1,&L2,&L3,&L4,&L5,&L6,&L7\n         LCLB  &H,&Z\n.*\n.IF0     AIF   (T'&LAB EQ 'O').END0\n&LAB     EQU   *\n.END0    ANOP\n.IF0A    AIF   (&OD GT 0).END0A\n         MNOTE 16,'OPTION MISSING'\n         MEXIT\n.END0A   ANOP\n.IF1     AIF   (&OD LE 16).END1\n         MNOTE 16,'MAX OPTION NESTING OF 16 EXCEEDED'\n         MEXIT\n.END1    ANOP\n.* SET EXIT FOR PREVIOUS CODE\n         BRU   @D&OD.E&OE(&OD)\n.* SET LABEL FOR ENTRY\n@D&OD.N&ON(&OD) EQU   *\n.* INCREMENT LABEL GENERATION NUMBER\n&ON(&OD) SETA  &ON(&OD)+1\n.* SET OPTION INDICATOR OFF\n&OPTN(&OD) SETB (0)\n.IF1AA   AIF   ((&OELSE(&OD)) EQ (0)).END1AA\n         MNOTE 16,'OPTELSE PRECEDES OPT'\n         MEXIT\n.END1AA  ANOP\n.* SAVE CURRENT LABEL GENERATION NUMBER FOR USER-CODE LABEL\n&U       SETA  &ON(&OD)\n.* INCREMENT LABEL GENERATION NUMBER\n&ON(&OD) SETA  &ON(&OD)+1\n.IF1AB   AIF   ((&OS(&OD)) EQ (0)).END1AB\n         MNOTE 16,'OPTION STATEMENT ERROR'\n         MEXIT\n.END1AB  ANOP\n&A       SETA  N'&SYSLIST\n.IF1B    AIF   (&A NE 0).END1B\n         MNOTE 16,'NO OPT PARAMETERS'\n         MEXIT\n.END1B   ANOP\n&B       SETA  0\n.DO1     AIF   (&A EQ &B).NDO1\n.* DO FOR EACH PARAMETER OF OPT\n&B       SETA  &B+1\n&C       SETA  K'&SYSLIST(&B)\n.IF2     AIF   ((&OQ(&OD)) EQ (0)).ELS2\n         AIF   ('&SYSLIST(&B)'(1,1) NE '''').QMN\n         AIF   ('&SYSLIST(&B)'(&C,1) EQ '''').OKQ\n.QMN     MNOTE 16,'UNQUOTED OPT PARAMETER'\n         MEXIT\n.OKQ     AIF   (&C GT 2).END2\n         MNOTE 16,'NULL QUOTES OPT PARAMETER'\n         MEXIT\n.ELS2    AIF   ('&SYSLIST(&B)'(1,1) NE '''').END2\n         MNOTE 16,'MISQUOTED OPT PARAMETER'\n         MEXIT\n.END2    ANOP\n.* FIND IF THERE IS A RANGE\n&D       SETA  0\n&H       SETB  (0)\n.DO2     AIF   (&C EQ &D).NDO2\n.* DO FOR EACH CHARACTER OF PARAMETER\n&D       SETA  &D+1\n         AIF   ('&SYSLIST(&B)'(&D,1) NE '-').ADO2\n.IF4     AIF   ((&OQ(&OD)) EQ (0)).ELS4\n         AIF   ('&SYSLIST(&B)'(&D-1,1) NE '''').ADO2\n         AIF   ('&SYSLIST(&B)'(&D+1,1) NE '''').ADO2\n         AIF   (&D EQ 2).ADO2\n.* HAVE FOUND A HYPHEN (BETWEEN QUOTES BECAUSE QUOTES ARE CURRENT)\n&H       SETB  (1)\n         AGO   .NDO2\n.ELS4    ANOP\n.* HAVE FOUND A HYPHEN\n&H       SETB  (1)\n         AGO   .NDO2\n.END4    ANOP\n.ADO2    AGO   .DO2\n.NDO2    ANOP\n&L1      SETC  '&OP(&OD)'\n&L2      SETC  '&OP1(&OD)'\n&L3      SETC  '&OP2(&OD)'\n.*\n.* GENERATE LABEL FOR COMPARE CLAUSE IF NOT 1ST AND RANGE NOT PREVIOUS\n.IF5     AIF   (&B EQ 1).END5\n         AIF   ((&Z) EQ (0)).END5\n@D&OD.N&ON(&OD) EQU *\n.* INCREMENT LABEL GENERATION COUNT\n&ON(&OD) SETA  &ON(&OD)+1\n.END5    ANOP\n.* GENERATE COMPARE CLAUSE LOGIC\n.IF6     AIF   ((&H) EQ (0)).ELS6\n.* WHEN A RANGE  &H IS 1 AND &D WILL HOLD HYPHEN OFFSET\n&E       SETA  &D-1\n&L4      SETC  '&SYSLIST(&B)'(1,&E)\n         &L1   &L2,&L3&L4\n         JL    @D&OD.N&ON(&OD)\n&E       SETA  &C-&D\n&L5      SETC  '&SYSLIST(&B)'(&D+1,&E)\n         &L1   &L2,&L3&L5\n.IF7     AIF   (&B EQ &A).ELS7\n.* WHEN NOT LAST CLAUSE GENERATE BRANCH DIRECT TO USER-CODE\n         JNH   @D&OD.N&U\n         AGO   .END7\n.ELS7    ANOP\n.* FOR LAST CLAUSE GENERATE BRANCH TO NEXT OPTION\n         JH    @D&OD.N&ON(&OD)\n.IF7A    AIF   (&A EQ 1).END7A\n.* GENERATE USER-CODE ENTRY LABEL WHEN MORE THAN A SINGLE PARAMETER\n@D&OD.N&U EQU  *\n.END7A   ANOP\n.END7    ANOP\n&Z       SETB  (1)\n         AGO   .END6\n.ELS6    ANOP\n.* HAVE SIMPLE CLAUSE WITH SINGLE TERM\n&L6      SETC  '&SYSLIST(&B)'(1,&C)\n         &L1   &L2,&L3&L6\n.IF8     AIF   (&B EQ &A).ELS8\n.* WHEN NOT LAST CLAUSE GENERATE BRANCH DIRECT TO USER-CODE\n         JE    @D&OD.N&U\n         AGO   .END8\n.ELS8    ANOP\n.* FOR LAST CLAUSE GENERATE BRANCH TO NEXT OPTION\n         JNE   @D&OD.N&ON(&OD)\n.IF9     AIF   (&A EQ 1).END9\n.* GENERATE USER-CODE ENTRY LABEL WHEN MORE THAN A SINGLE PARAMETER\n@D&OD.N&U EQU  *\n.END9    ANOP\n.END8    ANOP\n&Z       SETB  (0)\n.END6    ANOP\n.ADO1    AGO   .DO1\n.NDO1    ANOP\n         MEND\n./ ADD NAME=WTOX\n           MACRO\n           WTOX  &CLEAR=Y\n.*\n.* Created by John Gateley\n.*\n.* PRGDEF has space for a reentrant WTO macro and PRGSTAT has the list\n.* form which is copied into the reentrant storage at the start of the\n.* program. This ensures that the program can execute correctly in\n.* a program protected environment.\n.*\n.* WTO   TEXT=(R2),ROUTCDE=11,MCSFLAG=HRDCPY,MF=(E,#ACT_WTO_LIST)\n.*\n           ST    R2,#MVCLSAV\n           LA    1,#ACT_WTO_LIST\n           LA    2,#MESS_LEN\n           ST    R2,4(0,1)\n           LR    14,1\n           LH    15,0(1,0)\n           AR    14,15\n           OI    4(14),B'00000000'\n           OI    5(14),B'10000000'\n           SVC   35\n           L     R2,#MVCLSAV\n           AIF   ('&CLEAR' EQ 'N').NOCLR\n           MVI   MESS_TEXT,C' '\n           MVC   MESS_TEXT+1(L'MESS_TEXT-1),MESS_TEXT\n.NOCLR     ANOP\n           MEND\n./ ADD NAME=XEDIT\n         MACRO\n         XEDIT &IN,&INL,&OUT,&PAD=' ',&DEC='.',&DECP=0,                /\n               &THOU=',',&SIGN=,&MARK=\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*  This macro builds an edit pattern and then EDits the data or\n.*  if SIGN is specified an EDMK is used.\n.*\n.*       &IN   location of the packed field\n.*       &INL  length of the packed field\n.*       &OUT  where to build the edit pattern and put the result\n.*\n.*       &PAD  value for pad character       ' '\n.*       &DEC  value for decimal point       '.'\n.*       &DECP number of decimal places\n.*       &THOU value for thousand separator  ','\n.*       &SIGN value for sign, e.g.  SIGN=-  SIGN='-'  SIGN=' (CR)'\n.*       &MARK if set then use EDMK instead of ED and use the provided\n.*             value in the pattern, e.g. MARK=$\n.*\n.*  XEDIT VAL1_PACK,5,(R6)\n.*\n.*  XEDIT VAL1_PACK,5,(R6),THOU=         for no thousand separator\n.*\n.*  XEDIT VAL1_PACK,5,MESSTXT+10,DECP=2,MARK=$\n.*\n.*  XEDIT VAL1_PACK,3,MESSTXT+10,PAD=0,DEC=',',DECP=2,                /\n.*              THOU='.',SIGN=' (CR)'\n.*  XEDIT VAL2_PACK,4,MESSTXT+10,PAD=' ',DEC='.',DECP=0,              /\n.*              THOU=',',MARK=\u00a2\n.*\n         AIF   ('&OUT'(1,1) EQ '(').REGO1  * value in register\n         LA    R14,&OUT                  * address of output string\n         AGO   .NOREGO1\n.REGO1   ANOP\n&OUTR    SETC  '&IN'(2,K'&IN-2)\n         LR    R14,&OUTR                 * address of output string\n.NOREGO1 ANOP\n.*\n&CNT     SETA  0                         * set pattern count to 0\n&CNTMRK  SETA  0                         * set EDMK offset to 0\n&SEL     SETC  '20'                      * set digit selector\n&SIG     SETC  '21'                      * set significant digit sel\n&PATN    SETC  ''                        * start with empty pattern\n         AIF   ('&PAD' EQ '').NOPAD\n         AIF   ('&PAD'(1,1) EQ '''').QUOT1  * value in quotes\n&MPAD    SETC  '&PAD'\n         AGO   .QUOT1A\n.QUOT1   ANOP\n&MPAD    SETC  '&PAD'(2,K'&PAD-2)\n.QUOT1A  ANOP\n&MPAD    SETC  C2X('&MPAD')              * convert to hex\n&PATN    SETC  '&PATN&MPAD'              * put in pad character\n&MYLEN   SETA  K'&MPAD/2                 * get length of pad\n         AIF   (&MYLEN NE 1).MERR1       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOPAD   ANOP\n.*\n&LENR    SETA  &INL                      * get input length\n&LENR    SETA  &LENR*2                   * multiply by 2\n&LENR    SETA  &LENR-1                   * subtract 1 gives no. digits\n&LENR    SETA  &LENR-&DECP               * subtract number of decimals\n.*\n.AGAIN   ANOP\n         AIF   (&LENR EQ 2).IS2\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n         AGO   .NOT2\n.IS2     ANOP\n&PATN    SETC  '&PATN&SIG'               * put in significant digit\n&CNTMRK  SETA  &CNT+1                    * set significant offset\n.NOT2    ANOP\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LENR    SETA  &LENR-1                   * subtract 1 from remaining\n         AIF   (&LENR EQ 0).NOAGIN\n&LENT    SETA  (&LENR/3)*3               * divide by 3 and multiply\n.*\n         AIF   ('&THOU' EQ '').NOTHOU    * no thousand separator\n         AIF   (&LENT NE &LENR).NOTHOU   * not multiple of 3 left\n         AIF   ('&THOU'(1,1) EQ '''').QUOT2  * value in quotes\n&MTHOU   SETC  '&THOU'\n         AGO   .QUOT2A\n.QUOT2   ANOP\n&MTHOU   SETC  '&THOU'(2,K'&THOU-2)\n.QUOT2A  ANOP\n&MTHOU   SETC  C2X('&MTHOU')             * convert to hex\n&PATN    SETC  '&PATN&MTHOU'             * put in thousand separator\n&MYLEN   SETA  K'&MTHOU/2                * get length of thou separator\n         AIF   (&MYLEN NE 1).MERR2       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOTHOU  ANOP\n         AIF   (&LENR GT 0).AGAIN        * anything remaining - repeat\n.*\n.NOAGIN  ANOP\n.*\n.* so now we have run out of digits before the decimal place (if any)\n.*\n         AIF   (&DECP EQ 0).TRYSGN       * if none try sign\n         AIF   ('&DEC' EQ '').TRYSGN      * value in quotes\n         AIF   ('&DEC'(1,1) EQ '''').QUOT3  * value in quotes\n&MDEC    SETC  '&DEC'\n         AGO   .QUOT3A\n.QUOT3   ANOP\n&MDEC    SETC  '&DEC'(2,K'&DEC-2)\n.QUOT3A  ANOP\n&MDEC    SETC  C2X('&MDEC')              * convert to hex\n&PATN    SETC  '&PATN&MDEC'              * put in decimal separator\n&MYLEN   SETA  K'&MDEC/2                 * get length of dec separator\n         AIF   (&MYLEN NE 1).MERR3       * can only be one\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n&LEND    SETA  &DECP                     * copy decimal places\n.*\n.TRYDEC  ANOP\n&PATN    SETC  '&PATN&SEL'               * put in digit select\n&CNT     SETA  &CNT+1                    * add to count in pattern\n&LEND    SETA  &LEND-1                   * reduce decimal place count\n         AIF   (&LEND NE 0).TRYDEC       * places remaining - so loop\n.*\n.TRYSGN  ANOP\n         AIF   ('&SIGN' EQ '').NOSIGN    * sign byte required\n         AIF   ('&SIGN'(1,1) EQ '''').QUOT9  * value in quotes\n&MSIGN   SETC  '&SIGN'\n         AGO   .QUOT9A\n.QUOT9   ANOP\n&MSIGN   SETC  '&SIGN'(2,K'&SIGN-2)\n.QUOT9A  ANOP\n&MSIGN   SETC  C2X('&MSIGN')             * convert to hex\n&PATN    SETC  '&PATN.&MSIGN'            * put in sign value\n&MYLEN   SETA  K'&MSIGN/2                * get length of record area\n&CNT     SETA  &CNT+&MYLEN               * add to count in pattern\n.NOSIGN  ANOP\n.*\n         MVC   0(&CNT,R14),=X'&PATN'     * copy pattern to output\n         AIF   ('&MARK' NE '').DOMARK\n         ED    0(&CNT,R14),&IN           * edit value to output\n         MEXIT\n.DOMARK  ANOP\n         LA    R1,&CNTMRK.(,R14)         * set R1 for EDMK\n         EDMK  0(&CNT,R14),&IN           * edit mark value to output\n         BCTR  R1,0                      * back of one byte\n         MVI   0(R1),C'&MARK'            * put in currency sign\n.*\n         MEXIT\n.MERR1   MNOTE 16,'Pad character can only be 1 byte'\n         MEXIT\n.MERR2   MNOTE 16,'Thousand separator can only be 1 byte'\n         MEXIT\n.MERR3   MNOTE 16,'Decimal separator can only be 1 byte'\n         MEND\n./ ADD NAME=XPACK\n         MACRO\n         XPACK &IN,&INL,&OUT\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro packs character hexadecimal data into a string.\n.*       so C'C1F16D' becomes X'C1F16D' or C'A1_'\n.*\n.*       In the above example\n.*       XPACK =C'C1F16D',6,OUT_TXT\n.*\n.*       Alternatively omit length and L'=C'C1F16D' will be used\n.*       XPACK =C'C1F16D',,OUT_TXT\n.*\n.*       If the input length is of the form L'AAA then it cannot be\n.*       checked here, but if it is not then see if even.\n.*\n.*\n.* indicate that XPACK macro was used so that the table can be\n.* defined in PRGESTAT\n.*\n         GBLC  &HEXPCK\n&HEXPCK  SETC  'Y'\n.*\n         AIF   (T'&INL EQ 'O').NOCHK     * parameter missing\n         AIF   ('&INL'(1,2) EQ 'L''').NOCHK\n&A       SETA  &INL                      * copy length\n&B       SETA  &A/2                      * divide by 2\n&C       SETA  &B*2                      * multiply by 2\n         AIF   (&A NE &C).NOTEVEN        * not equal means not even\n.*\n.NOCHK   ANOP\n         LA    R14,&IN                   * address of input string\n         AIF   (T'&INL NE 'O').USELEN    * parameter missing\n         LA    R15,L'&IN                 * use the implied length\n         AGO   .NOLEN\n.*\n.USELEN  ANOP\n         LA    R15,&INL                  * length of input string\n.NOLEN   ANOP\n         LA    R1,&OUT                   * address of output area\nB#&SYSNDX      DS    0H\n         MVC   HEXPACK_W3(2),0(R14)      * copy two bytes\n         TR    HEXPACK_W3(2),HEXPACK_TABLE-C'A' * Convert to packable\n         PACK  HEXPACK_W2,HEXPACK_W3     * pack it\n         MVC   0(1,R1),HEXPACK_W2        * output one byte\n         LA    R14,2(R14)                * next in input\n         LA    R1,1(R1)                  * next in output\n         AHI   R15,-2                    * subtract the 2 processed\n         BP    B#&SYSNDX                 * positive then go again\n         MEXIT\n.NOTEVEN MNOTE 16,'Length specified is not multiple of 2'\n         MEND\n./ ADD NAME=XUNPK\n         MACRO\n         XUNPK &IN,&INL,&OUT\n.**********************************************************************\n.*\n.* Created by John Gateley\n.*\n.*       This macro unpacks character data into hexadecimal format.\n.*       so X'C1F16D' or C'A1_' becomes C'C1F16D'\n.*\n.*       In the above example\n.*       XUNPK =X'C1F16D',3,OUT_TXT\n.*\n.*       XUNPK FIELDA,,OUT_TXT          generates L'FIELDA for length\n.*\n.*\n.* indicate that XUNPK macro was used so that the table can be\n.* defined in PRGESTAT\n.*\n         GBLC  &XUNPCK\n&XUNPCK  SETC  'Y'\n.*\n         AIF   ('&IN'(1,1) EQ '(').REGVAL   * value in register\n         LA    R14,&IN                   * address of input string\n         AGO   .NOTREG\n.REGVAL  ANOP\n&INR     SETC  '&IN'(2,K'&IN-2)\n         ST    &INR,LEN_SAY              * this exists in PRGDEF\n         LA    R14,LEN_SAY               * address of input string\n         LA    R15,4                     * it is 4 bytes\n         AGO   .LENDON\n.*\n.NOTREG  ANOP\n         AIF   (T'&INL EQ 'O').NOLEN     * parameter missing\n         LA    R15,&INL                  * length of input string\n         AGO   .LENDON\n.NOLEN   ANOP\n         LA    R15,L'&IN\n.*\n.LENDON  ANOP\n         LA    R1,&OUT                   * address of output area\nB#&SYSNDX      DS    0H\n         MVC   HEXPACK_W2(1),0(R14)      * copy one byte\n         UNPK  HEXPACK_W3,HEXPACK_W2     * UNPK two bytes to three\n         TR    HEXPACK_W3(2),XUNPACK_TAB-240 * convert to displayable\n         MVC   0(2,R1),HEXPACK_W3        * copy to receiver\n         LA    R14,1(,R14)               * next in input\n         LA    R1,2(,R1)                 * next in output\n         BCT   R15,B#&SYSNDX             * subtract and branch\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSLOAD": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x17\\x05?\\x01\\x17\\x05?  \\x00}\\x00}\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-02-22T20:20:08", "lines": 125, "newlines": 125, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PIPE$$$": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01 \\x01\\x7f\\x01 \\x01\\x7f\\x07\\x03\\x00#\\x00#\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-01-17T00:00:00", "modifydate": "2020-01-17T07:03:03", "lines": 35, "newlines": 35, "modlines": 0, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'PIPE$$$   A/L/R ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*******************************************************\n//ASM01   EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(PIPECNT)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(PIPECNT)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(PIPECNT)\n//*******************************************************\n//ASM02   EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(PIPESET)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(PIPESET)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(PIPESET)\n//*******************************************************\n//LINK1   EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(PIPECNT)\n    ENTRY PIPECNT\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(PIPECNT)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n//LINK2   EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(PIPESET)\n    ENTRY PIPECNT\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(PIPESET)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PIPECNT": {"ttr": 4610, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x01\\x7f\\x01 \\x01\\x7f\\x06V\\x00\\xe7\\x00\\xe7\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-01-17T00:00:00", "modifydate": "2020-01-17T06:56:10", "lines": 231, "newlines": 231, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'PIPECNT - PIPE SYMBOL COUNTER'\n*______________________________________________________________________\n*\n*    READ A PIPE \u00a6 DELIMITED FILE IN SYSIN COUNTING THE NUMBER OF\n*    PIPES IN EACH RECORD AND THE MAXIMUM LENGTH OF EACH FIELD.\n*    OUTPUT FILE SUMMARY.\n*\n*    CAN SPECIFY DELIMETER USING PARM='|' IN JCL\n*______________________________________________________________________\n*\nPIPECNT  PRGDEF  FSEG=MAIN_PART,RMODE=24\n*\nADDR_OUTREC            DC    F'0'\nADDR_OUTREC_POS        DC    F'0'\nADDR_OUTREC_CNT        DC    F'0'\n*\nWORK8                  DS    CL8\nTHIS_COUNT             DS    PL4\n*\nWAS_DELI_METER         DS    CL1\nEOF_SYSIN              DS    CL1\nVARIABLE_RECORD        DS    CL1\nSYSOUT_REC             DS    CL80\n*\nOUTREC_DSECT           DSECT\nMAX_COUNT              DC    PL4'0'\nNEXT_OUTREC            DC    F'0'\nLEN_OUTREC             EQU   *-OUTREC_DSECT\n*\n         PRGEDEF\n*\n    USING OUTREC_DSECT,R9\n    USING IHADCB,SYSIN\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   L     R1,0(,R1)               GET PARAMETER ADDRESS\n   IF (CLC,0(2,R1),EQ,=H'1')\n     MVC   DELI_METER,2(R1)\n   ENDIF\n*\n   MVI   SYSOUT_REC,C' '\n   MVC   SYSOUT_REC+1(L'SYSOUT_REC-1),SYSOUT_REC\n*\n   SEGDO OPEN_SYSIN\n   SEGDO OPEN_SYSOUT\n*\n   MVC   SYSOUT_REC(30),=CL30'PROGRAM STARTING'\n   SEGDO WRITE_SYSOUT\n   SEGDO WRITE_SYSOUT\n   MVC   SYSOUT_REC(30),=CL30'  DELIMITER USED WAS '\n   MVC   SYSOUT_REC+30(1),DELI_METER\n   SEGDO WRITE_SYSOUT\n   SEGDO WRITE_SYSOUT\n*\n   DO INF\n     SEGDO GET_SYSIN\n   DOEXIT (CLI,EOF_SYSIN,EQ,C'Y')\n     SEGDO MAIN_PROCESS\n   ENDDO\n*\n   L     R9,ADDR_OUTREC\n   DO INF\n   DOEXIT (LTR,R9,R9,Z)\n     MVC   SYSOUT_REC+1(L'ED_PL4),ED_PL4\n     ED    SYSOUT_REC+1(L'ED_PL4),MAX_COUNT\n     SEGDO WRITE_SYSOUT\n     L     R9,NEXT_OUTREC\n   ENDDO\n*\n*  use LNKDEL to free the linked list built by LNKBLD\n*\n   LNKDEL  START=ADDR_OUTREC,NEXT=NEXT_OUTREC,                         /\n               REG=R9,LENGTH=LEN_OUTREC\n*\n   SEGDO WRITE_SYSOUT\n   MVC   SYSOUT_REC(30),=CL30'PROGRAM TERMINATING'\n   SEGDO WRITE_SYSOUT\n*\n   SEGDO CLOSE_SYSIN\n   SEGDO CLOSE_SYSOUT\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS MAIN_PROCESS\n*\n   IF (CLI,VARIABLE_RECORD,EQ,C'Y')\n     LH    R5,0(,R8)                   get actual record length\n     SH    R5,=H'4'                    subtract RDW length\n     LA    R8,4(,R8)                   point to data start\n   ELSE\n     LH    R5,DCBLRECL                 get record length\n   ENDIF\n*\n   ZAP   THIS_COUNT,=P'0'\n   L     R9,ADDR_OUTREC                point to first entry in list\n   MVI   WAS_DELI_METER,C'N'\n   DO FROM=(R5)\n     IF (CLC,0(1,R8),EQ,DELI_METER)    found delimeter\n       MVI   WAS_DELI_METER,C'Y'       flag it\n       IF (LTR,R9,R9,Z)                no current list item\n         SEGDO ADD_TO_OUTREC_TABLE\n       ENDIF\n       IF (CP,THIS_COUNT,GT,MAX_COUNT)\n         ZAP   MAX_COUNT,THIS_COUNT    set new maximum field length\n       ENDIF\n       L     R9,NEXT_OUTREC            point to next item\n       ZAP   THIS_COUNT,=P'0'          reset field length\n     ELSE\n       MVI   WAS_DELI_METER,C'N'\n       AP    THIS_COUNT,=P'1'          increment field length\n     ENDIF\n     LA    R8,1(,R8)\n   ENDDO\n   IF (CLI,WAS_DELI_METER,NE,C'Y')     did not end on a delimeter\n     IF (LTR,R9,R9,Z)                  no current list item\n       SEGDO ADD_TO_OUTREC_TABLE\n     ENDIF\n     IF (CP,THIS_COUNT,GT,MAX_COUNT)\n       ZAP   MAX_COUNT,THIS_COUNT      set new maximum field length\n     ENDIF\n     L     R9,NEXT_OUTREC              point to next item\n     ZAP   THIS_COUNT,=P'0'\n   ENDIF\n*\n SEGE MAIN_PROCESS\n*______________________________________________________________________\n*\n SEGS ADD_TO_OUTREC_TABLE\n*\n   L     R9,ADDR_OUTREC_POS\n*\n*  use LNKBLD to build a linked table of getmained storage containing\n*  the count of characters between each delimiter.\n*\n   LNKBLD  START=ADDR_OUTREC,NEXT=NEXT_OUTREC,LOC=31,                  /\n               REG=R9,LENGTH=LEN_OUTREC,                               /\n               END=ADDR_OUTREC_POS,COUNT=ADDR_OUTREC_CNT\n*\n   XC    NEXT_OUTREC,NEXT_OUTREC       initialise next pointer\n   ZAP   MAX_COUNT,=P'0'               initialise count\n*\n SEGE ADD_TO_OUTREC_TABLE\n*______________________________________________________________________\n*\n SEGS WRITE_SYSOUT\n*\n   PUT   SYSOUT,SYSOUT_REC\n*\n   MVI   SYSOUT_REC,C' '\n   MVC   SYSOUT_REC+1(L'SYSOUT_REC-1),SYSOUT_REC\n*\n SEGE WRITE_SYSOUT\n*______________________________________________________________________\n*\n SEGS OPEN_SYSOUT\n*\n   OPEN  (SYSOUT,OUTPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=32\n   ENDIF\n*\n SEGE OPEN_SYSOUT\n*______________________________________________________________________\n*\n SEGS CLOSE_SYSOUT\n*\n   CLOSE (SYSOUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=34\n   ENDIF\n*\n SEGE CLOSE_SYSOUT\n*______________________________________________________________________\n*\n SEGS OPEN_SYSIN\n*\n   OPEN  (SYSIN,INPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=36\n   ENDIF\n   IF (TM,DCBRECFM,DCBRECV,NZ)\n     MVI   VARIABLE_RECORD,C'Y'\n   ENDIF\n*\n SEGE OPEN_SYSIN\n*______________________________________________________________________\n*\n SEGS CLOSE_SYSIN\n*\n   CLOSE (SYSIN),MODE=31\n   IF (LTR,R15,R15,NZ)\n     PRGQUIT RC=38\n   ENDIF\n*\n SEGE CLOSE_SYSIN\n*______________________________________________________________________\n*\n SEGS GET_SYSIN\n*\n   MVI   EOF_SYSIN,C'N'\n   GET   SYSIN\n   LR    R8,R1\n   SEGQUIT                             return to calling segment\n*\nENDOFEM    DS    0H                    it is the end of SYSIN\n   MVI   EOF_SYSIN,C'Y'                so flag it\n*\n SEGE GET_SYSIN\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nSYSIN    DCB   DDNAME=SYSIN,MACRF=(GL),DSORG=PS,EODAD=ENDOFEM\nSYSOUT   DCB   DDNAME=SYSOUT,MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80\n*\nDELI_METER     DC    C'\u00a6'\nED_PL4         DC    X'4020202020202120'\n*______________________________________________________________________\n*\n         LTORG\n*______________________________________________________________________\n*\n         DCBD  DSORG=QS,DEVD=DA\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PIPESET": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01 \\x01\\x7f\\x01 \\x01\\x7f\\x06V\\x01\\x93\\x01\\x93\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-01-17T00:00:00", "modifydate": "2020-01-17T06:56:22", "lines": 403, "newlines": 403, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'PIPESET - UNPIPE A PIPE DELIMITED INPUT FILE'\n*______________________________________________________________________\n*\n*    THIS PROGRAM EXPECTS TO READ THE SYSOUT FROM PIPECNT IN SYSIN.\n*______________________________________________________________________\n*\n*    READ A PIPE \u00a6 DELIMITED FILE IN PIPEIN SPLITTING THE FIELDS UP\n*    INTO THE LENGTHS SPECIFIED BY THE SYSIN FROM PIPECNT.\n*    OPTIONALLY YOU CAN SPECIFY THE NUMBER OF BYTES SPACING THERE\n*    SHOULD BE BETWEEN EACH FIELD AS A PARAMETER.\n*    E.G. PARM=1\n*    PARM=0 IS THE DEFAULT\n*______________________________________________________________________\n*\nPIPESET  PRGDEF  FSEG=MAIN_PART,RMODE=24\n*\nFIELD_COUNT      DS    D\nRECORD_ADDRESS   DS    F\nFIELD_SPACE      DS    H\nFIELD_SPACE2     DS    H\n*\nASM_REC          DS    CL80\nCOBOL_REC        DS    CL80\nASM_REC_F        DS    CL80            FOR FILLER FIELDS\nCOBOL_REC_F      DS    CL80            FOR FILLER FIELDS\n*\nSYSIN_REC        DS    CL80\nEOF_SYSIN        DS    CL1\nEOF_PIPEIN       DS    CL1\nVARIABLE_RECORD  DS    CL1\n*\n         PRGEDEF\n*\n         USING OUTREC_DSECT,R9\nIN       USING IHADCB,PIPEIN\nOUT      USING IHADCB,PIPEOUT\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   L     R1,0(,R1)                     GET PARAMETER ADDRESS\n   IF (CLC,0(2,R1),GT,=H'0')\n     LH    R2,0(R1)\n     BCTR  R2,0\n     IF (EX,R2,TRT_IT,NZ)\n       WTO   'PARM WAS NOT NUMERIC',ROUTCDE=11,MCSFLAG=HRDCPY\n       PRGQUIT RC=16\n     ENDIF\n     EX    R2,PACK_IT\n     CVB   R1,DOUB_WORD\n     STH   R1,FIELD_SPACE\n   ENDIF\n   ZAP   FIELD_COUNT,=P'0'\n*\n   SEGDO OPEN_SYSIN\n   XR    R4,R4\n   DO INF\n     SEGDO GET_SYSIN\n   DOEXIT (CLI,EOF_SYSIN,EQ,C'Y')\n     IF (CLC,SYSIN_REC(19),EQ,=C'  DELIMITER USED WAS')\n       MVC   DELI_METER,SYSIN_REC+30\n     ELSEIF (CLC,SYSIN_REC(16),NE,=C'PROGRAM STARTING'),AND,           /\n               (CLC,SYSIN_REC(19),NE,=C'PROGRAM TERMINATING'),AND,     /\n               (CLC,SYSIN_REC(19),NE,=C'                   ')\n       SEGDO ADD_TO_OUTREC_TABLE\n       PACK  DOUB_WORD,SYSIN_REC(9)\n       IF (CP,DOUB_WORD,EQ,=P'0')      ZERO LENGTH FIELD (NO DATA)\n         AP    DOUB_WORD,=P'1'         MAKE IT ONE\n       ENDIF\n       CVB   R1,DOUB_WORD\n       STH   R1,THIS_SIZE              SIZE OF THIS FIELD\n       LA    R4,0(R1,R4)               TOTAL RECORD LENGTH\n       AP    FIELD_COUNT,=P'1'         ADD TO COUNT OF FIELDS\n     ENDIF\n   ENDDO\n   SEGDO CLOSE_SYSIN\n*\n   SP    FIELD_COUNT,=P'1'             SPACES 1 LESS THAN FIELDS\n   CVB   R1,FIELD_COUNT\n   IF (CLC,FIELD_SPACE,NE,=H'0')\n     LH    R14,FIELD_SPACE\n     LA    R14,1(,R14)\n     STH   R14,FIELD_SPACE2\n     MH    R1,FIELD_SPACE2\n   ENDIF\n   LA    R4,0(R1,R4)\n   STH   R4,OUT.DCBLRECL               SET PIPEOUT RECORD LENGTH\n   LR    R2,R4                         COPY RECORD LENGTH\n   STORAGE OBTAIN,LENGTH=(R2),LOC=BELOW\n   ST    R1,RECORD_ADDRESS\n*\n   SEGDO OPEN_PIPEIN\n   SEGDO OPEN_PIPEOUT\n*\n   DO INF\n     SEGDO GET_PIPEIN\n   DOEXIT (CLI,EOF_PIPEIN,EQ,C'Y')\n     SEGDO MAIN_PROCESS\n   ENDDO\n*\n   SEGDO CREATE_COPYBOOKS\n*\n   SEGDO CLOSE_PIPEIN\n   SEGDO CLOSE_PIPEOUT\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS MAIN_PROCESS\n*\n   IF (CLI,VARIABLE_RECORD,EQ,C'Y')\n     LH    R5,0(,R8)\n     SH    R5,=H'4'\n     LA    R8,4(,R8)\n   ELSE\n     LH    R5,IN.DCBLRECL\n   ENDIF\n*\n   L     R14,RECORD_ADDRESS\n   LH    R15,OUT.DCBLRECL\n   IC    R1,=C' '\n   SLL   R1,24\n   MVCL  R14,R0                        INITIALISE TO SPACES\n*\n   L     R9,ADDR_OUTREC\n   L     R4,RECORD_ADDRESS\n   LR    R7,R4                         COPY RECORD ADDRESS\n   AH    R7,THIS_SIZE                  POINT TO END OF FIELD\n   DO FROM=(R5)\n     IF (CLC,0(1,R8),EQ,DELI_METER)\n       MVI   0(R7),C'\u00a6'\n       LA    R7,1(,R7)                 POINT AFTER \u00a6\n       AH    R7,FIELD_SPACE            ADD SPACING BETWEEN FIELDS\n       LR    R4,R7                     COPY ADDR OF NEXT FIELD\n       L     R9,NEXT_OUTREC\n       AH    R7,THIS_SIZE              POINT TO END OF FIELD\n     ELSEIF (CR,R4,GE,R7)              TO MUCH DATA?\n       LH    R1,FIELD_NUMB\n       CVD   R1,DOUB_WORD\n       OI    DOUB_WORD+7,X'0F'\n       UNPK  T_1+8+6(5),DOUB_WORD\nT_1    WTO   'FIELD XXXXX IS LONGER THAN SPECIFIED                 ',  /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n       SEGDO WRITE_PIPEOUT\n       PRGQUIT RC=16\n     ELSE\n       MVC   0(1,R4),0(R8)\n       LA    R4,1(,R4)\n     ENDIF\n     LA    R8,1(,R8)\n   ENDDO\n   SEGDO WRITE_PIPEOUT\n*\n SEGE MAIN_PROCESS\n*______________________________________________________________________\n*\n SEGS ADD_TO_OUTREC_TABLE\n*\n   L     R9,ADDR_OUTREC_POS\n*\n*  USE LNKBLD TO BUILD A LINKED TABLE OF GETMAINED STORAGE CONTAINING\n*  THE COUNT OF CHARACTERS BETWEEN EACH DELIMITER.\n*\n   LNKBLD  START=ADDR_OUTREC,NEXT=NEXT_OUTREC,LOC=31,                  /\n               REG=R9,LENGTH=LEN_OUTREC,                               /\n               END=ADDR_OUTREC_POS\n*\n   XC    NEXT_OUTREC,NEXT_OUTREC       INITIALISE NEXT POINTER\n   LA    R7,1(,R7)\n   STH   R7,FIELD_NUMB\n*\n SEGE ADD_TO_OUTREC_TABLE\n*______________________________________________________________________\n*\n SEGS CREATE_COPYBOOKS\n*\n   MVI   ASM_REC,C' '\n   MVC   ASM_REC+1(159),ASM_REC        CLEAR BOTH RECORDS\n*\n   MVI   ASM_REC_F,C' '\n   MVC   ASM_REC_F+1(159),ASM_REC_F    CLEAR BOTH FILL RECORDS\n   MVC   COBOL_REC_F+12(11),=C'03   FILLER'\n   MVC   COBOL_REC_F+50(14),=C'PIC  X(00000).'\n   MVC   ASM_REC_F+17(2),=C'DS'\n   MVC   ASM_REC_F+23(7),=C'CL00000'\n   LH    R1,FIELD_SPACE\n   LA    R1,1(,R1)                     ADD 1 FOR \u00a6 SYMBOL\n   CVD   R1,DOUB_WORD\n   OI    DOUB_WORD+7,X'0F'\n   UNPK  COBOL_REC_F+57(5),DOUB_WORD\n   UNPK  ASM_REC_F+25(5),DOUB_WORD\n*\n   ZAP   FIELD_COUNT,=P'0'\n   L     R9,ADDR_OUTREC\n   DO INF\n   DOEXIT (LTR,R9,R9,Z)\n     AP    FIELD_COUNT,=P'1'           ADD TO COUNT OF FIELDS\n     MVC   COBOL_REC+12(16),=C'03   FIELD-00000'\n     MVC   ASM_REC(11),=C'FIELD_00000'\n     MVC   COBOL_REC+50(14),=C'PIC  X(00000).'\n     MVC   ASM_REC+17(2),=C'DS'\n     MVC   ASM_REC+23(7),=C'CL00000'\n     LH    R1,THIS_SIZE\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  COBOL_REC+57(5),DOUB_WORD\n     UNPK  ASM_REC+25(5),DOUB_WORD\n*\n     OI    FIELD_COUNT+7,X'0F'\n     UNPK  COBOL_REC+23(5),FIELD_COUNT\n     UNPK  ASM_REC+6(5),FIELD_COUNT\n     SEGDO WRITE_PRT_ASM_COB\n*\n     IF (CLC,NEXT_OUTREC,NE,=F'0')\n       MVC   ASM_REC,ASM_REC_F\n       MVC   COBOL_REC,COBOL_REC_F\n       SEGDO WRITE_PRT_ASM_COB\n     ENDIF\n*\n     LR    R4,R9\n     LA    R2,LEN_OUTREC\n     L     R9,NEXT_OUTREC\n     STORAGE RELEASE,LENGTH=(R2),ADDR=(R4)\n   ENDDO\n*\n SEGE CREATE_COPYBOOKS\n*______________________________________________________________________\n*\n SEGS WRITE_PIPEOUT\n*\n   L     R4,RECORD_ADDRESS\n   PUT   PIPEOUT,0(R4)\n*\n SEGE WRITE_PIPEOUT\n*______________________________________________________________________\n*\n SEGS WRITE_PRT_ASM_COB\n*\n   PUT   PRTASM,ASM_REC\n   PUT   PRTCOB,COBOL_REC\n   MVI   ASM_REC,C' '\n   MVC   ASM_REC+1(159),ASM_REC        CLEAR BOTH RECORDS\n*\n SEGE WRITE_PRT_ASM_COB\n*______________________________________________________________________\n*\n SEGS OPEN_PIPEOUT\n*\n   OPEN  (PIPEOUT,OUTPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR OPENING PIPEOUT',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   OPEN  (PRTASM,OUTPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR OPENING PRTASM',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   OPEN  (PRTCOB,OUTPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR OPENING PRTCOB',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n SEGE OPEN_PIPEOUT\n*______________________________________________________________________\n*\n SEGS CLOSE_PIPEOUT\n*\n   CLOSE (PIPEOUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR CLOSING PIPEOUT',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   CLOSE (PRTASM),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR CLOSING PRTASM',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n   CLOSE (PRTCOB),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR CLOSING PRTCOB',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n SEGE CLOSE_PIPEOUT\n*______________________________________________________________________\n*\n SEGS OPEN_SYSIN\n*\n   OPEN  (SYSIN,INPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR OPENING SYSIN',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n SEGE OPEN_SYSIN\n*______________________________________________________________________\n*\n SEGS CLOSE_SYSIN\n*\n   CLOSE (SYSIN),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR CLOSING SYSIN',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n SEGE CLOSE_SYSIN\n*______________________________________________________________________\n*\n SEGS GET_SYSIN\n*\n   MVI   EOF_SYSIN,C'N'\n   GET   SYSIN\n   MVC   SYSIN_REC,0(R1)\n   SEGQUIT                             RETURN TO CALLING SEGMENT\n*\nENDOFEMS   DS    0H                    IT IS THE END OF SYSIN\n   MVI   EOF_SYSIN,C'Y'\n*\n SEGE GET_SYSIN\n*______________________________________________________________________\n*\n SEGS OPEN_PIPEIN\n*\n   OPEN  (PIPEIN,INPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR OPENING PIPEIN',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n   IF (TM,IN.DCBRECFM,DCBRECV,NZ)\n     MVI   VARIABLE_RECORD,C'Y'\n   ENDIF\n*\n SEGE OPEN_PIPEIN\n*______________________________________________________________________\n*\n SEGS CLOSE_PIPEIN\n*\n   CLOSE (PIPEIN),MODE=31\n   IF (LTR,R15,R15,NZ)\n     WTO   'ERROR CLOSING PIPEIN',ROUTCDE=11,MCSFLAG=HRDCPY\n     PRGQUIT RC=16\n   ENDIF\n*\n SEGE CLOSE_PIPEIN\n*______________________________________________________________________\n*\n SEGS GET_PIPEIN\n*\n   MVI   EOF_PIPEIN,C'N'\n   GET   PIPEIN\n   LR    R8,R1\n   SEGQUIT\n*\nENDOFEMP   DS    0H                    IT IS THE END OF SYSIN\n   MVI   EOF_PIPEIN,C'Y'\n*\n SEGE GET_PIPEIN\n*______________________________________________________________________\n*\n         PRGSTAT\n*\nPACK_IT  PACK  DOUB_WORD,2(1,R1)\nTRT_IT   TRT   2(1,R1),NUMTAB\n*\nADDR_OUTREC            DC    F'0'\nADDR_OUTREC_POS        DC    F'0'\n*\nSYSIN    DCB   DDNAME=SYSIN,MACRF=(GL),DSORG=PS,EODAD=ENDOFEMS\nPRTASM   DCB   DDNAME=PRTASM,MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80\nPRTCOB   DCB   DDNAME=PRTCOB,MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80\nPIPEIN   DCB   DDNAME=PIPEIN,MACRF=(GL),DSORG=PS,EODAD=ENDOFEMP\nPIPEOUT  DCB   DDNAME=PIPEOUT,MACRF=(PM),DSORG=PS,RECFM=FB\n*\nDELI_METER     DC    C'\u00a6'\n*______________________________________________________________________\n*\nNUMTAB   DC    256X'01'                TABLE FOR NUMERIC VALIDATION\n         ORG   NUMTAB+X'F0'\n         DC    10X'00'\n         ORG\n*\n         DC    CL00034' '\n         LTORG\n*______________________________________________________________________\n*\nOUTREC_DSECT           DSECT\nTHIS_SIZE              DC    H'0'\nFIELD_NUMB             DC    H'0'\nNEXT_OUTREC            DC    F'0'\nLEN_OUTREC             EQU   *-OUTREC_DSECT\n*\n         DCBD  DSORG=QS,DEVD=DA\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROCST$$": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x17\\x15\\x1f\\x01\\x17\\x15\\x1f\\x11S\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-31T00:00:00", "modifydate": "2017-05-31T11:53:37", "lines": 9, "newlines": 9, "modlines": 0, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'PROCSTEM ASS     ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//ASM     EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(PROCSTEM)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(PROCSTEM)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(PROCSTEM)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROCSTEM": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00E\\x01\\x17\\x15\\x1f\\x01 4O\\x08\\x08\\x02\\x1a\\x01\\x03\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-05-31T00:00:00", "modifydate": "2020-12-09T08:08:45", "lines": 538, "newlines": 259, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'PROCSTEM - REXX Inner program for STEM manipulation'\n*\nPROCSTEM PRGDEF FSEG=MAIN_BIT,INREX=Y\n*______________________________________________________________________\n*\n* Written by John Gateley - use at your own risk\n*\n* This program handles STEM variable manipulation for an outer\n* REXX function. All modules in the assembler calling chain should\n* have INREX=Y except the top level which should have REXX=Y.\n*\n*   STEM_FUNCTION   =   1   drop variable then set stem.0 to 0\n*                       2   set a stem variable with the number in\n*                           STEM_ZERO_COUNT, this is automatically\n*                           incremented so if you want to reset a\n*                           previous value set this to the count-1\n*                       3   set STEM.0 to STEM_ZERO_COUNT\n*                       4   get STEM.0 value\n*                       5   get next STEM.? value\n*                      21   scan stem to get max var length and count\n*                      31   drop all vars > STEM_ZERO_COUNT and\n*                           then set STEM.0 to input STEM_ZERO_COUNT\n*\n* If you have multiple stems in your program then use the PRGSTEM\n* macro with PREF=???? to generate seperate storage for each one.\n*\n* If you want multi-part stem names you can have them,\n* use STEM_MID_NAME for the middle part.\n* Do not include a '.' in STEM_MID_NAME.\n* This is because the DROP processing can get confused.\n*\n* If you have this\n*              WANG.0\n*              WANG_NAME.?\n*              WANG_POS.?\n* then WANG_NAME.0 and WANG_POS.0 will also be maintained and\n*\n* The following should be set before function 1\n*     STEM_NAME_ADR\n*     STEM_NAME_LEN\n*     STEM_MID_NAME                    if required\n*     Do not initialise STEM_ZERO_COUNT it needs to be invalid packed\n*     on the first call as the code checks for this.\n*\n* The following should be set before function 2\n*     STEM_TEXT_ADR\n*     STEM_TEXT_LEN\n*     STEM_TRIM_VAR                    Y if spaces should be removed\n*\n*                    the parameter area used to call irxexcom\nIX_PARM              DS    4F\nSAVE_R14             DS    F\n*\nVAR_TEXT             DS    CL8\n*\n                     DS    0D\nORIGINAL_COUNT       DS    PL8\n*\nERR_NO               DS    CL1\nJUST_LOOKING         DS    CL1\n*\nPARM_AREA            DS    (SHVBLEN)XL1\n*\n        PRGEDEF\n*\n                     USING STEM_AREA,R5\n                     USING SHVBLOCK,R6\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   L     R5,0(R1)\n   XC    IX_PARM(4*4),IX_PARM\n   LA    R1,=CL8'IRXEXCOM'\n   ST    R1,IX_PARM\n   LA    R6,PARM_AREA\n*\n   IF (TP,STEM_ZERO_COUNT,NZ)          first time in ?\n     ZAP   STEM_ZERO_COUNT,=P'0'       initialise count\n     MVI   STEM_NAME,C' '\n     MVC   STEM_NAME+1(L'STEM_NAME-1),STEM_NAME\n     L     R15,STEM_NAME_ADR           address of name\n     L     R14,STEM_NAME_LEN           length of name\n     BCTR  R14,0                       minus 1 for execute\n     LA    R1,0(R14,R15)               POINT TO LAST BYTE\n     IF (CLI,0(R1),EQ,C'.')\n       ST    R14,STEM_NAME_LEN         save new length\n       BCTR  R14,0                     minus 1 for execute\n     ENDIF\n     LA    R1,STEM_NAME                point to stem name\n     EX    R14,COPY_STEM_NAME          copy input name to working\n     LA    R1,1(R14,R1)                point after copied name\n     MVI   0(R1),C'.'                  add a period\n     LA    R1,1(,R1)                   point after\n     ST    R1,STEM_AFT_DOT             store addr of this byte\n     L     R2,STEM_NAME_LEN            get length of name\n     IF (CLC,STEM_MID_NAME,GT,SPACES)  is there a middle part ?\n       LR    R15,R1                    point at current end\n       BCTR  R15,0                     back one\n       MVI   0(R15),C'_'               replace dot with underscore\n       LA    R14,STEM_MID_NAME         point at it\n       LA    R15,L'STEM_MID_NAME       get length of field\n       DO FROM=(R15)\n       DOEXIT (CLI,0(R14),LE,C' ')     quit when <= blank\n         MVC   0(1,R1),0(R14)          copy one byte\n         LA    R1,1(,R1)               next output byte\n         LA    R2,1(,R2)               add to length\n         LA    R14,1(,R14)             next input byte\n       ENDDO\n       MVI   0(R1),C'.'                add a period\n       LA    R1,1(,R1)                 point after period\n       LA    R2,1(,R2)                 add to length\n       ST    R1,STEM_AFT_DOT           store addr of this byte\n     ENDIF\n     LA    R2,2(,R2)                   add 2 for .0\n     ST    R2,STEM_NAME_LEN            save actual length\n   ENDIF\n*\n   LA    R15,STEM_NAME+L'STEM_NAME\n   L     R14,STEM_AFT_DOT\n   SR    R15,R14                       calc length remaining\n   DO FROM=(R15)\n     MVI   0(R14),C' '                 blank out rest of name\n     LA    R14,1(,R14)\n   ENDDO\n   OC    STEM_NAME,SPACES\n*\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVC   SHVBUFL,=F'0'\n   MVI   SHVCODE,SHVSYSET              command is set variable\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n*\n   IF (CLHHSI,STEM_FUNCTION,EQ,1)\n     SEGDO DROP_ENTIRE_STEM            drop the stem.\n     MVI   SHVCODE,SHVSTORE            reset command to store variable\n     SEGDO INIT_STEM_ZERO              initialise stem.0\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,2)\n     SEGDO SET_STEM_LINE               create new variable\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,3)\n     SEGDO SET_STEM_ZERO               set stem.0 with the total\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,4)\n     SEGDO GET_STEM_ZERO               get stem.0 value\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,5)\n     SEGDO GET_STEM_LINE               get next stem.? value\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,21)\n     SEGDO GET_STEM_TOTALS             get max var length and count\n   ELSEIF (CLHHSI,STEM_FUNCTION,EQ,31)\n     SEGDO DROP_EXCESS_VARS            drop unused stem members\n   ELSE\n     MVC   MESS_TXT(22),=CL22'PROCSTEM invalid call'\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8                      invalid function so quit\n   ENDIF\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS GET_STEM_TOTALS\n*\n   SEGDO GET_STEM_ZERO\n*\n   L     R1,STEM_TEXT_LEN              length of variable returned\n   L     R14,STEM_TEXT_ADR\n   BCTR  R1,0\n   EX    R1,PACK_STEM_0                save number of items\n   ZAP   DOUB_WORD,STEM_ZERO_COUNT\n   CVB   R14,DOUB_WORD\n   XR    R4,R4\n   ZAP   STEM_ZERO_COUNT,=P'0'         initialise count\n   MVI   JUST_LOOKING,C'Y'\n   DO FROM=(R14)\n     ST    R14,SAVE_R14\n     LA    R15,STEM_NAME+L'STEM_NAME\n     L     R14,STEM_AFT_DOT\n     SR    R15,R14                       calc length remaining\n     DO FROM=(R15)\n       MVI   0(R14),C' '                 blank out rest of name\n       LA    R14,1(,R14)\n     ENDDO\n     SEGDO GET_STEM_LINE\n     IF (C,R4,LT,STEM_TEXT_LEN)\n       L     R4,STEM_TEXT_LEN\n     ENDIF\n     L     R14,SAVE_R14\n   ENDDO\n   NI    JUST_LOOKING,0\n   ST    R4,STEM_MAX_LEN\n*\n SEGE GET_STEM_TOTALS\n*______________________________________________________________________\n*\n SEGS DROP_EXCESS_VARS\n*\n*  After a sort with a sum statement there can be redundant stem\n*  variables, this routine removes them.\n*\n   ZAP   ORIGINAL_COUNT,STEM_ZERO_COUNT  original count\n*\n   SEGDO GET_STEM_ZERO                 get current count\n*\n   L     R1,STEM_TEXT_LEN              length of variable returned\n   L     R14,STEM_TEXT_ADR\n   BCTR  R1,0\n   EX    R1,PACK_STEM_0                copy current value\n   SP    ORIGINAL_COUNT,STEM_ZERO_COUNT\n   CVB   R4,ORIGINAL_COUNT             now has difference in value\n*\n   DO FROM=(R4)\n     AP    STEM_ZERO_COUNT,=P'1'       increment variable number\n     LA    R15,STEM_NAME+L'STEM_NAME\n     L     R14,STEM_AFT_DOT\n     SR    R15,R14                     calc length remaining\n     DO FROM=(R15)\n       MVI   0(R14),C' '               blank out rest of name\n       LA    R14,1(,R14)\n     ENDDO\n     SEGDO DROP_STEM_VARIABLE\n   ENDDO\n*\n SEGE DROP_EXCESS_VARS\n*______________________________________________________________________\n*\n SEGS DROP_ENTIRE_STEM\n*\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVDROPV              command is drop variable\n   MVC   SHVBUFL,=F'0'\n   MVC   SHVVALA,=F'0'\n   MVC   SHVVALL,=F'0'\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n   L     R1,STEM_NAME_LEN              get length including .0\n   BCTR  R1,0                          drop the 0\n   ST    R1,SHVNAML                    use as length\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_D_STEM_0),E_D_STEM_0\n     XUNPK (R15),4,MESS_TXT+L'E_D_STEM_0\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE DROP_ENTIRE_STEM\n*______________________________________________________________________\n*\n SEGS DROP_STEM_VARIABLE\n*\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVDROPV              command is drop variable\n   MVC   SHVBUFL,=F'0'\n   MVC   SHVVALA,=F'0'\n   MVC   SHVVALL,=F'0'\n   MVC   VAR_TEXT,=X'4020202020202120' copy edit pattern\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1      point to last digit\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT      edit number into mask\n   LA    R2,VAR_TEXT+L'VAR_TEXT-1      point at last byte\n   SR    R2,R1                         get length for execute\n   L     R3,STEM_AFT_DOT\n   EX    R2,COPY_VAR_NUMB              copy number after STEM.\n   LA    R3,1(R2,R3)                   point past copied stuff\n   LA    R1,STEM_NAME\n   SR    R3,R1\n   ST    R3,SHVNAML\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_D_STEM_LINE),E_D_STEM_LINE\n     XUNPK (R15),4,MESS_TXT+L'E_D_STEM_LINE\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE DROP_STEM_VARIABLE\n*______________________________________________________________________\n*\n SEGS INIT_STEM_ZERO\n*\n   L     R1,STEM_AFT_DOT\n   MVI   0(R1),C'0'\n   MVC   SHVNAML,STEM_NAME_LEN\n\n   LA    R1,=C'0'                      set STEM.0 to '0'\n   ST    R1,SHVVALA\n   LA    R1,1                          length of 1\n   ST    R1,SHVVALL\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_I_STEM_0),E_I_STEM_0\n     XUNPK (R15),4,MESS_TXT+L'E_I_STEM_0\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE INIT_STEM_ZERO\n*______________________________________________________________________\n*\n SEGS SET_STEM_LINE\n*\n   AP    STEM_ZERO_COUNT,=P'1'         increment count\n   MVC   VAR_TEXT,=X'4020202020202120' copy edit pattern\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1      point to last digit\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT      edit number into mask\n   LA    R2,VAR_TEXT+L'VAR_TEXT-1      point at last byte\n   SR    R2,R1                         get length for execute\n   L     R3,STEM_AFT_DOT\n   EX    R2,COPY_VAR_NUMB              copy number after STEM.\n   LA    R3,1(R2,R3)                   point past copied stuff\n   LA    R1,STEM_NAME\n   SR    R3,R1\n   ST    R3,SHVNAML\n   IF (CLI,STEM_TRIM_VAR,EQ,C'Y')      want to remove all blanks ?\n     MVC   SHVVALA,STEM_TEXT_ADR       copy address of value\n     L     R14,STEM_TEXT_ADR           point to value\n     L     R15,STEM_TEXT_LEN           get length of value\n     TRIM  (R14),(R15),ALL=Y           remove all blanks\n     ST    R15,SHVVALL                 R15 has length of the result\n   ELSE\n     MVC   SHVVALA,STEM_TEXT_ADR       copy address\n     MVC   SHVVALL,STEM_TEXT_LEN       copy length\n   ENDIF\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_S_STEM_LINE),E_S_STEM_LINE\n     XUNPK (R15),4,MESS_TXT+L'E_S_STEM_LINE\n*    MVC   MESS_TXT+L'E_S_STEM_LINE+10(1),SHVCODE\n*    MVC   MESS_TXT+L'E_S_STEM_LINE+12(1),SHVRET\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE SET_STEM_LINE\n*______________________________________________________________________\n*\n SEGS SET_STEM_ZERO\n*\n   L     R1,STEM_AFT_DOT\n   MVI   0(R1),C'0'                    STEM.0\n   MVC   SHVNAML,STEM_NAME_LEN\n\n   MVC   VAR_TEXT,=X'4020202020202120'\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT\n   LA    R2,VAR_TEXT+L'VAR_TEXT\n   SR    R2,R1                         calc length of value\n   ST    R1,SHVVALA                    store address of value\n   ST    R2,SHVVALL                    store length of value\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_S_STEM_ZERO),E_S_STEM_ZERO\n     XUNPK (R15),4,MESS_TXT+L'E_S_STEM_ZERO\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE SET_STEM_ZERO\n*______________________________________________________________________\n*\n SEGS GET_STEM_ZERO\n*\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVFETCH              command is fetch variable\n   MVC   SHVBUFL,STEM_MAX_LEN\n   MVC   SHVVALL,=F'0'\n   MVC   SHVVALA,STEM_TEXT_ADR\n*\n   L     R1,STEM_AFT_DOT\n   MVI   0(R1),C'0'                    STEM.0\n   MVC   SHVNAML,STEM_NAME_LEN\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'E_G_STEM_ZERO),E_G_STEM_ZERO\n     XUNPK (R15),4,MESS_TXT+L'E_G_STEM_ZERO\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ELSEIF (CLI,SHVRET,EQ,SHVNEWV)\n     MVC   MESS_TXT(L'NEW_VARIABLE_3),NEW_VARIABLE_3\n     SEGDO CALL_IRXSAY\n     MVC   MESS_TXT(L'STEM_NAME),STEM_NAME\n     SEGDO CALL_IRXSAY\n   ENDIF\n   MVC   STEM_TEXT_LEN,SHVVALL\n*\n SEGE GET_STEM_ZERO\n*______________________________________________________________________\n*\n SEGS GET_STEM_LINE\n*\n   LA    R1,STEM_NAME                  point to stem name\n   ST    R1,SHVNAMA                    store in function call\n   MVC   SHVNEXT,=F'0'\n   MVC   SHVUSER,=F'0'\n   MVI   SHVCODE,SHVFETCH              command is fetch variable\n   MVC   SHVBUFL,STEM_MAX_LEN          copy length\n   MVC   SHVVALA,STEM_TEXT_ADR         copy address\n   MVC   SHVVALL,=F'0'\n*\n   AP    STEM_ZERO_COUNT,=P'1'         increment count\n   MVC   VAR_TEXT,=X'4020202020202120' copy edit pattern\n   LA    R1,VAR_TEXT+L'VAR_TEXT-1      point to last digit\n   EDMK  VAR_TEXT,STEM_ZERO_COUNT      edit number into mask\n   LA    R2,VAR_TEXT+L'VAR_TEXT-1      point at last byte\n   SR    R2,R1                         get length for execute\n   L     R3,STEM_AFT_DOT\n   EX    R2,COPY_VAR_NUMB              copy number after STEM.\n   LA    R3,1(R2,R3)                   point past copied stuff\n   LA    R1,STEM_NAME\n   SR    R3,R1\n   ST    R3,SHVNAML\n*\n   SEGDO CALL_IRXEXCOM\n*\n   IF (LTR,R15,R15,NZ)\n     IF (CFI,R15,EQ,4),AND,(CLI,JUST_LOOKING,EQ,C'Y'),AND,             /\n               (CLI,SHVRET,EQ,SHVTRUNC)\n* do not mind truncation as we only want the variable length\n     ELSE\n       MVC   MESS_TXT(L'ERR_STEM_LINE),ERR_STEM_LINE\n       XUNPK (R15),4,MESS_TXT+L'ERR_STEM_LINE\n       MVC   MESS_TXT+L'ERR_STEM_LINE+9(7),=C'SHVRET='\n       MVC   MESS_TXT+L'ERR_STEM_LINE+16(1),SHVRET\n       SEGDO CALL_IRXSAY\n       MVC   MESS_TXT(L'STEM_NAME),STEM_NAME\n       SEGDO CALL_IRXSAY\n       PRGQUIT RC=8\n     ENDIF\n   ELSEIF (CLI,SHVRET,EQ,SHVNEWV)\n     MVC   MESS_TXT(L'NEW_VARIABLE_1),NEW_VARIABLE_1\n     SEGDO CALL_IRXSAY\n     MVC   MESS_TXT(L'NEW_VARIABLE_2),NEW_VARIABLE_2\n     SEGDO CALL_IRXSAY\n     MVC   MESS_TXT(L'STEM_NAME),STEM_NAME\n     SEGDO CALL_IRXSAY\n     PRGQUIT RC=8\n   ENDIF\n   MVC   STEM_TEXT_LEN,SHVVALL\n*\n SEGE GET_STEM_LINE\n*______________________________________________________________________\n*\n SEGS CALL_IRXEXCOM\n*\n   LA    R1,PARM_AREA\n   ST    R1,IX_PARM+12\n   OI    IX_PARM+12,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,IX_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXEXCOM\n   DROP  15\n   BASR  14,15\n*\n SEGE CALL_IRXEXCOM\n*______________________________________________________________________\n*\n SEGS CALL_IRXSAY\n*\n   LA    R1,=CL8'WRITE'\n   ST    R1,MY_P_1\n   LA    R1,MESS_TXT\n   ST    R1,MY_P_8\n   LA    R1,MY_P_8\n   ST    R1,MY_P_2\n   LA    R1,L'MESS_TXT\n   ST    R1,MY_P_9\n   LA    R1,MY_P_9\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,MY_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXSAY\n   DROP  15\n   BASR  14,15\n   IF (LTR,R15,R15,NZ)\n     ST    R15,R_C\n     SEGDO WRITE_LOG\n     MVC   MESS_TXT(19),=C'Return code on SAY='\n     XUNPK R_C,4,MESS_TXT+19\n     SEGDO WRITE_LOG\n   ENDIF\n   MVI   MESS_TXT,C' '\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE CALL_IRXSAY\n*______________________________________________________________________\n*\n*SEGS WRITE_LOG\n*\n*  WTOX\n*\n*SEGE WRITE_LOG\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nCOPY_STEM_NAME MVC   0(1,R1),0(R15)\nCOPY_VAR_NUMB  MVC   0(1,R3),0(R1)\nPACK_STEM_0    PACK  STEM_ZERO_COUNT,0(0,R14)\n*\nE_D_STEM_0     DC    C'Error in drop_stem_zero RC='\nE_I_STEM_0     DC    C'Error in init_stem_zero RC='\nE_D_STEM_LINE  DC    C'Error in drop_stem_line RC='\nE_G_STEM_ZERO  DC    C'Error in get_stem_zero  RC='\nE_S_STEM_LINE  DC    C'Error in set_stem_line  RC='\nE_S_STEM_ZERO  DC    C'Error in set_stem_zero  RC='\nERR_STEM_LINE  DC    C'Error reading stem.? RC='\nNEW_VARIABLE_1 DC    C'Warning - the fetched variable was created'\nNEW_VARIABLE_2 DC    C'The STEM.0 count is probably incorrect'\nNEW_VARIABLE_3 DC    C'Warning - the fetched variable was created'\nSPACES         DC    80CL1' '\n*\n               LTORG\n*\n               PRGSTEM DSECT=Y\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STEMSO$$": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00D\\x01\\x17\\x16_\\x01 4O\\x08\\x16\\x00&\\x00\\x1a\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-06-14T00:00:00", "modifydate": "2020-12-09T08:16:44", "lines": 38, "newlines": 26, "modlines": 0, "user": "SDJRG"}, "text": "//SDJRGASS JOB (0),'STEMSORT ASS     ',MSGCLASS=H,\n//             MSGLEVEL=(1,1),CLASS=A,NOTIFY=SDJRG\n//*\n//*  NOTE THAT PROCSTEM AND DODYNPRC NEED TO BE ASSEMBLED AS WELL\n//*\n//*******************************************************\n//ASM1    EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(STEMSORT)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(STEMSORT)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(STEMSORT)\n//*******************************************************\n//ASM2    EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(STEMSR15)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(STEMSR15)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(STEMSR15)\n//*******************************************************\n//ASM3    EXEC PGM=ASMA90\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.C14.MACRO\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SDJRG.ASM(STEMSR35)\n//SYSLIN   DD  DISP=SHR,DSN=SDJRG.OBJLIB(STEMSR35)\n//SYSPRINT DD  DISP=SHR,DSN=SDJRG.LISTING.ASM(STEMSR35)\n//*******************************************************\n//LINK    EXEC PGM=HEWL,PARM='CALL,LIST,MAP,XREF,LET'\n//SYSLIB   DD  DISP=SHR,DSN=SDJRG.OBJLIB\n//SYSLIN   DD  *\n    INCLUDE SYSLIB(STEMSORT)\n    ENTRY STEMSORT\n//SYSLMOD  DD  DISP=SHR,DSN=SDJRG.LOADLIB(STEMSORT)\n//SYSPRINT DD  SYSOUT=*\n//*******************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STEMSORT": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x17\\x16_\\x01 4O\\x08\\t\\x01\\xd9\\x01\\x99\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-06-14T00:00:00", "modifydate": "2020-12-09T08:09:46", "lines": 473, "newlines": 409, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'STEMSORT - REXX function to sort a STEM. variable'\n*\nSTEMSORT PRGDEF FSEG=MAIN_BIT,REXX=Y,RENT=YES\n*______________________________________________________________________\n*\n* Written by John Gateley - use at your own risk\n*\n* This program acts as a REXX function to sort a stem. variable\n* either ascending or descending.\n*\n*    Note that the SYSOUT from SORT will be sent to SORTPRT\n*    this can be allocated to DUMMY.\n*\n*    INPUT\n*         Name       of STEM variable (e.g. WANG or WANG.BANG)\n*         SORT       parameter A or D (ascending/descending)\n*\n*    OUTPUT\n*         IF   successfull\n*              RC=0\n*              and the STEM is sorted\n*         ELSE\n*              RC=Error message\n*         ENDIF\n*\n*  Alternatively you can suply the full SORT statement yourself.\n*    SORT FIELDS=(1,7,CH,A,8,4,CH,D)\n*  If you want to include a SUM statement then put that first\n*  as the function will add ',FILSZ=nnnnnn' at the end of the\n*  sort statement.\n*______________________________________________________________________\n*\n* EXAMPLE USAGE\n*\n* /*REXX*/\n*   \"ALLOC FI(SORTPRT)  DUMMY\"\n*   \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('MY.LOAD.LIBRARY')\"\n*\n*   WANG.0    = \"6\"\n*   WANG.1    = \"ZAK\"\n*   WANG.2    = \"JOHN\"\n*   WANG.3    = \"YANGTANGBANG\"\n*   WANG.4    = \"ADAM\"\n*   WANG.5    = \"CHARLES\"\n*   WANG.6    = \"JOHN GATELEY WROTE THIS\"\n*\n*   DO LO_OP_R = 1 TO WANG.0\n*      SAY  ':' || WANG.LO_OP_R || ':'\n*   END\n*\n*   SAY ' '\n*\n*   R_C = STEMSORT(WANG,'A')\n*   IF  R_C      /= 0 THEN SAY R_C\n*   ELSE\n*      DO LO_OP_R = 1 TO WANG.0\n*         SAY  ':' || WANG.LO_OP_R || ':'\n*      END\n*\n*   DROP WANG.\n*\n*   \"ISPEXEC LIBDEF ISPLLIB \"\n*   \"FREE FILE(SORTPRT)\"\n*   EXIT\n*______________________________________________________________________\n*\n*  REENTRANT STORAGE\n*\nARG_SORT_STMT_ADR    DS    F\nARG_SORT_STMT_LEN    DS    F\n*\nSTORE_LENGTH         DS    F\nSTORE_ADDR           DS    F\nARG_A_OR_D           DS    CL1\nERR_NO               DS    CL1\nDUMMY_VAR_TEXT       DS    CL10\nCHAR_SRT_LEN         DS    CL5\nCHAR_REC_LEN         DS    CL5\nCHAR_REC_COUNT       DS    CL11\nIS_NOMSG             DS    CL5\n*\nDODYNPRC_PARM        DS    0D          parameter area for DODYNPRC\nDODYNPRC_ACTION      DS    CL1\nDODYNPRC_DDNAME      DS    CL8\nDODYNPRC_DATASET     DS    CL44\nDODYNPRC_MEMBER      DS    CL8\n                     DS    0H\nTHE_SORT_STATEMENT   DS    CL500\n*\n        PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_BIT\n*\n   MVC   RX_#SAV_REX(4*4),#SAV_REX     copy rexx routine addresses\n   SEGDO GET_ARGUMENTS\n*\n   LA    R1,DUMMY_VAR_TEXT             point to variable area\n   ST    R1,THE_STEM_TEXT_ADR          save address\n   LA    R1,L'DUMMY_VAR_TEXT           length of variable area\n   ST    R1,THE_STEM_MAX_LEN           save length\n*\n   MVI   THE_STEM_TRIM_VAR,C'N'        do not strip spaces\n*\n   MVHHI THE_STEM_FUNCTION,21          get STEM max length + count\n   SEGDO CALL_PROCSTEM\n*\n   ZAP   RX_TOT_RECS,THE_STEM_ZERO_COUNT   copy stem count for E15\n   LA    R1,THE_STEM_AREA              point to PRGSTEM area\n   ST    R1,RX_THE_STEM                stem area for E15/E35 exit\n   L     R1,THE_STEM_MAX_LEN           get maximum variable length\n   ST    R1,RX_REC_LEN                 length for E15 and E35 exits\n   CVD   R1,DOUB_WORD\n   OI    DOUB_WORD+7,X'0F'\n   UNPK  CHAR_SRT_LEN,DOUB_WORD\n   LA    R1,4(,R1)                     add 4 for original var length\n   ST    R1,STORE_LENGTH               save length of getmain\n   CVD   R1,DOUB_WORD\n   OI    DOUB_WORD+7,X'0F'\n   UNPK  CHAR_REC_LEN,DOUB_WORD\n   OI    THE_STEM_ZERO_COUNT+L'THE_STEM_ZERO_COUNT-1,X'0F'\n   UNPK  CHAR_REC_COUNT,THE_STEM_ZERO_COUNT  set sort record count\n*\n   L     R2,STORE_LENGTH               keep length of getmain\n   STORAGE OBTAIN,LENGTH=(R2),LOC=31\n   ST    R1,STORE_ADDR                 save getmain address\n   ST    R1,RX_REC_ADR                 record for E15 and E35 exits\n   ST    R1,THE_STEM_TEXT_ADR          used to read/write values\n   A     R1,THE_STEM_MAX_LEN           add base length to address\n   ST    R1,RX_VAR_LEN_ADR             position for length of variable\n*\n   SEGDO BUILD_SORT_STATEMENT\n*\n   IF (CLC,IS_NOMSG,EQ,=C'NOMSG')\n     SEGDO DYNALLOC_A\n   ENDIF\n*\n   ZAP   THE_STEM_ZERO_COUNT,=P'0'     tell E15 to start at beginning\n*\n   LA    R1,THE_SORT_STATEMENT\n   ST    R1,MY_P_1\n   L     R1,=V(STEMSR15)               E15 EXIT\n   ST    R1,MY_P_2\n   OI    MY_P_2,X'80'\n   L     R1,=V(STEMSR35)               E35 EXIT\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   MVC   MY_P_4,=X'FFFFFFFF'\n   LA    R1,MY_PARM\n   LINK  EP=SORT\n   LR    R3,R15\n   SEGDO RELEASE_STORAGE               free the storage\n   IF (CLC,IS_NOMSG,EQ,=C'NOMSG')\n     SEGDO DYNALLOC_D\n   ENDIF\n   IF (LTR,R3,R3,NZ)\n     MVC   MESS_TXT(L'SORT_FAIL_MES),SORT_FAIL_MES\n     XUNPK (R3),4,MESS_TXT+16\n     MVC   EVALBLOCK_EVDATA(80),MESS_TXT\n     SEGDO SAY_MESSAGE\n     PRGQUIT RC=16\n   ENDIF\n*\n   IF (CP,THE_STEM_ZERO_COUNT,LT,RX_TOT_RECS)  fewer records after sort\n     LA    R1,DUMMY_VAR_TEXT           point to variable area\n     ST    R1,THE_STEM_TEXT_ADR        save address\n     LA    R1,L'DUMMY_VAR_TEXT         length of variable area\n     ST    R1,THE_STEM_MAX_LEN         save length\n     ZAP   THE_STEM_ZERO_COUNT,RX_TOT_RECS   copy original count\n     MVHHI THE_STEM_FUNCTION,31        drop all > RX_TOT_RECS\n     SEGDO CALL_PROCSTEM\n   ENDIF\n*\n   MVI   EVALBLOCK_EVDATA,C' '\n   MVC   EVALBLOCK_EVDATA+1(80),EVALBLOCK_EVDATA\n   MVI   EVALBLOCK_EVDATA,C'0'         set result value\n   LA    R1,1\n   ST    R1,EVALBLOCK_EVLEN            set result length\n*\n SEGE MAIN_BIT\n*______________________________________________________________________\n*\n SEGS DYNALLOC_A\n*\n   MVI   DODYNPRC_ACTION,C'A'        dynamically allocate\n   MVC   DODYNPRC_DDNAME,=CL8'SORTPRT'\n   MVC   DODYNPRC_DATASET,SPACES\n   MVC   DODYNPRC_DATASET(5),=C'DUMMY'\n   XC    DODYNPRC_MEMBER,DODYNPRC_MEMBER\n   LA    R1,DODYNPRC_PARM\n   ST    R1,MY_P_1\n   LA    R1,MY_PARM\n   L     R15,=V(DODYNPRC)\n   BASR  R14,R15\n   IF (CFI,R15,NE,0)\n     ST    R15,R_C\n     PRGQUIT\n   ENDIF\n*\n SEGE DYNALLOC_A\n*______________________________________________________________________\n*\n SEGS DYNALLOC_D\n*\n   MVI   DODYNPRC_ACTION,C'D'        dynamically de-allocate\n   LA    R1,DODYNPRC_PARM\n   ST    R1,MY_P_1\n   LA    R1,MY_PARM\n   L     R15,=V(DODYNPRC)\n   BASR  R14,R15\n*\n SEGE DYNALLOC_D\n*______________________________________________________________________\n*\n SEGS BUILD_SORT_STATEMENT\n*\n   LA    R14,THE_SORT_STATEMENT+2\n   IF (CLI,ARG_A_OR_D,GT,C' ')         automatic sort\n     MVC   0(16,R14),=C' SORT FIELDS=(1,'\n     MVC   16(5,R14),CHAR_SRT_LEN\n     MVC   21(6,R14),=C',BI, )'\n     MVC   25(1,R14),ARG_A_OR_D\n     LA    R14,27(,R14)\n     LA    R15,27\n   ELSE\n     MVI   THE_SORT_STATEMENT+2,C' '\n     LA    R14,THE_SORT_STATEMENT+3\n     L     R0,ARG_SORT_STMT_ADR\n     L     R1,ARG_SORT_STMT_LEN\n     LR    R15,R1\n     MVCL  R14,R0\n     LA    R14,THE_SORT_STATEMENT+3\n     L     R15,ARG_SORT_STMT_LEN\n     LA    R14,0(R15,R14)              point to end of statement\n     LA    R15,1(,R15)                 plus 1 for leading space\n   ENDIF\n   MVC   0(7,R14),=C',FILSZ='\n   MVC   7(11,R14),CHAR_REC_COUNT\n   MVC   18(L'OPT_IONS,R14),OPT_IONS\n   LA    R14,L'OPT_IONS+18(,R14)\n   LA    R15,L'OPT_IONS+18(,R15)\n   MVC   0(5,R14),CHAR_REC_LEN\n   MVC   5(2,R14),=C') '\n   LA    R14,7(,R14)\n   LA    R15,7(,R15)\n   STH   R15,THE_SORT_STATEMENT        set length of sort statement\n*\n SEGE BUILD_SORT_STATEMENT\n*______________________________________________________________________\n*\n SEGS GET_ARGUMENTS\n*\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,1\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,3\n     SEGDO NOT_VALID\n   ENDIF\n   MVC   THE_STEM_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   THE_STEM_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for second argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,4\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,5\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'1')\n     L     R15,ARGTABLE_ARGSTRING_PTR\n     MVC   ARG_A_OR_D,0(R15)\n     OI    ARG_A_OR_D,C' '             make uppercase\n     IF (CLI,ARG_A_OR_D,NE,C'A'),AND,(CLI,ARG_A_OR_D,NE,C'D')\n       MVI   ERR_NO,7\n       SEGDO NOT_VALID\n     ENDIF\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'400') arbitary limit\n     MVI   ERR_NO,6\n     SEGDO NOT_VALID\n   ELSE\n     L     R14,ARGTABLE_ARGSTRING_PTR\n     L     R15,ARGTABLE_ARGSTRING_LENGTH\n     DO FROM=(R15)\n     DOEXIT (CLI,0(R14),GT,C' ')\n       LA    R14,1(,R14)\n     ENDDO\n     IF (LTR,R15,R15,Z)\n       MVI   ERR_NO,9\n       SEGDO NOT_VALID\n     ENDIF\n     LA    R1,0(R15,R14)\n     BCTR  R1,0\n     DO FROM=(R15)\n     DOEXIT (CLI,0(R1),GT,C' ')\n       BCTR  R1,0\n     ENDDO\n     IF (LTR,R15,R15,Z)\n       MVI   ERR_NO,9\n       SEGDO NOT_VALID\n     ENDIF\n     IF (CLI,0(R1),NE,C')')\n       MVI   ERR_NO,10\n       SEGDO NOT_VALID\n     ENDIF\n     ST    R14,ARG_SORT_STMT_ADR\n     ST    R15,ARG_SORT_STMT_LEN\n   ENDIF\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       check for third argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n     IF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'5')\n       L     R15,ARGTABLE_ARGSTRING_PTR\n       MVC   IS_NOMSG,0(R15)\n       OC    IS_NOMSG,SPACES             make uppercase\n       IF (CLC,IS_NOMSG,NE,=C'NOMSG')\n         MVI   ERR_NO,11\n         SEGDO NOT_VALID\n       ENDIF\n     ELSE\n       MVI   ERR_NO,11\n       SEGDO NOT_VALID\n     ENDIF\n     LA    ARG_POINT,ARGTABLE_NEXT       check for fourth argument\n     IF (CLC,ARGTABLE_ARGSTRING_PTR,NE,=8X'FF')\n       MVI   ERR_NO,8\n       SEGDO NOT_VALID\n     ENDIF\n   ENDIF\n*\n SEGE GET_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS CALL_PROCSTEM\n*\n   LA    R1,THE_STEM_AREA              point to PRGSTEM area INPUT\n   ST    R1,MY_P_1                     save as first parm\n   LA    R1,MY_PARM                    point to parameter list\n   L     R15,=V(PROCSTEM)              get program address\n   BASR  R14,R15                       go and set stem value\n   IF (LTR,R15,R15,NZ)                 error ?\n     ST    R15,R_C                     set return code\n     SEGDO RELEASE_STORAGE             free the storage\n     PRGQUIT                           QUIT\n   ENDIF\n*\n SEGE CALL_PROCSTEM\n*______________________________________________________________________\n*\n SEGS RELEASE_STORAGE\n*\n   L     R2,STORE_LENGTH\n   IF (LTR,R2,R2,NZ)\n     L     R1,STORE_ADDR\n     STORAGE RELEASE,LENGTH=(R2),ADDR=(R1)\n     XC    STORE_LENGTH,STORE_LENGTH\n   ENDIF\n*\n SEGE RELEASE_STORAGE\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n   MVC   EVALBLOCK_EVLEN,=F'30'\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 not entered'\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 was zero length'\n   ELSEIF (CLI,ERR_NO,EQ,3)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 > 20 bytes'\n   ELSEIF (CLI,ERR_NO,EQ,4)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 not entered'\n   ELSEIF (CLI,ERR_NO,EQ,5)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 was zero length'\n   ELSEIF (CLI,ERR_NO,EQ,6)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 > 1 byte'\n   ELSEIF (CLI,ERR_NO,EQ,7)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 not A or D'\n   ELSEIF (CLI,ERR_NO,EQ,8)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Fourth argument supplied'\n   ELSEIF (CLI,ERR_NO,EQ,9)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Sort statement was blank'\n   ELSEIF (CLI,ERR_NO,EQ,10)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Sort statement must end with )'\n   ELSEIF (CLI,ERR_NO,EQ,11)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Third argument must be NOMSG'\n   ELSE\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Unknown error, rc='\n     XR    R1,R1\n     IC    R1,ERR_NO                   take error number\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  EVALBLOCK_EVDATA+18(4),DOUB_WORD    put in output message\n     XC    R_C,R_C\n   ENDIF\n*\n   PRGQUIT\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n SEGS SAY_MESSAGE\n*\n   LA    R1,=CL8'WRITE'\n   ST    R1,MY_P_1\n   LA    R1,MESS_TXT\n   ST    R1,MY_P_8\n   LA    R1,MY_P_8\n   ST    R1,MY_P_2\n   LA    R1,L'MESS_TXT\n   ST    R1,MY_P_9\n   LA    R1,MY_P_9\n   ST    R1,MY_P_3\n   OI    MY_P_3,X'80'\n   L     R0,#SAV_REX+12                rexx environment block addr\n   LA    R1,MY_PARM\n   USING IRXEXTE,15\n   L     15,ENVBLOCK_IRXEXTE\n   L     15,IRXSAY\n   DROP  15\n   BASR  14,15\n   IF (LTR,R15,R15,NZ)\n     ST    R15,R_C\n     SEGDO WRITE_LOG\n     MVC   MESS_TXT(19),=C'Return code on SAY='\n     XUNPK R_C,4,MESS_TXT+19\n     SEGDO WRITE_LOG\n   ENDIF\n   MVI   MESS_TXT,C' '\n   MVC   MESS_TXT+1(L'MESS_TXT-1),MESS_TXT\n*\n SEGE SAY_MESSAGE\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n         PRGSTAT\n*\n                     PRGSTEM PREF=THE_STEM\n*\nCOPY_ARGUMENT        MVC   0(1,R1),0(R15)\nDO_MOVE              MVC   0(1,R3),0(R1)\n*\nOPT_IONS       DC    C' OPTION MSGDDN=SORTPRT RECORD TYPE=F,LENGTH=('\nSORT_FAIL_MES  DC    C'SORT  failed RC=xxxxxxxx'\n*\nSPACES         DC    CL80' '\n*\n         LTORG\n*______________________________________________________________________\n*\n               ENTRY STMSRTLN\nSTMSRTLN       DS    0F\nRX_REC_LEN     DS    F\nRX_REC_ADR     DS    F\nRX_THE_STEM    DS    F\nRX_VAR_LEN_ADR DS    F\nRX_#SAV_REX    DS    4F\nRX_TOT_RECS    DS    PL4\nLEN_STMSRTLN   EQU   *-STMSRTLN\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMSR15": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x17\\x16_\\x01\\x17\\x16_\\x03\\x02\\x00U\\x00U\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-06-14T00:00:00", "modifydate": "2017-06-14T03:02:25", "lines": 85, "newlines": 85, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'STEMSR15 - E15 exit for the SORT, part of STEMSORT'\n*______________________________________________________________________\n*\n* Written by John Gateley - use at your own risk\n*\n* This is called by the SORT to obtain the input record.\n*______________________________________________________________________\n*\nSTEMSR15 PRGDEF FSEG=MAIN_PART,INREX=Y\n*\n         USING STMSRTLN,R2\n         USING STEM_AREA,R5\n*\n         PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n*  R2 points to    RX_REC_LEN     DS    F\n*                  RX_REC_ADR     DS    F\n*                  RX_THE_STEM    DS    F\n*                  RX_VAR_LEN_ADR DS    F\n*                  RX_#SAV_REX    DS    4F\n*                  RX_TOT_RECS    DS    PL4\n*\n   L     R2,=V(STMSRTLN)               point to stuff in STEMSORT\n   LM    R3,R6,0(R2)\n*                            R3        record length\n*                            R4        record area address\n*                            R5        get input stem area\n*                            R6        adr for length of variable\n   MVC   #SAV_REX(4*4),RX_#SAV_REX     copy IRX addresses\n   IF (CP,STEM_ZERO_COUNT,LT,RX_TOT_RECS)\n     LR    R14,R4                      copy record address\n     LR    R15,R3                      copy record length\n     LA    R1,C' '                     set to blank\n     SLL   R1,24                       put in high byte\n     MVCL  R14,R0                      clear record to spaces\n     MVHHI STEM_FUNCTION,5             get stem.? next\n     ST    R5,MY_P_1                   save as first parm\n     LA    R1,MY_PARM                  point to parameter list\n     L     R15,=V(PROCSTEM)            get program address\n     BASR  R14,R15                     go and get stem value\n     IF (LTR,R15,R15,NZ)               error ?\n       ST    R15,R_C                   set return code\n       PRGQUIT                         QUIT\n     ENDIF\n     L     R15,STEM_TEXT_ADR           get address of record read\n     MVC   0(4,R6),STEM_TEXT_LEN       put length on end of record\n     L     R1,4(R13)                   point to callers save area\n     ST    R15,24(R1)                  put in record address\n     SETRC RC=12                       input record provided\n   ELSE\n     ZAP   STEM_ZERO_COUNT,=P'0'       make 0 for E35 exit\n     SETRC RC=8                        no more input\n   ENDIF\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n         PRGSTAT\n*\n         LTORG\n*\n         PRGSTEM DSECT=Y\n*\nSTMSRTLN       DSECT\nRX_REC_LEN     DS    F\nRX_REC_ADR     DS    F\nRX_THE_STEM    DS    F\nRX_VAR_LEN_ADR DS    F\nRX_#SAV_REX    DS    4F                rexx environment addresses\nRX_TOT_RECS    DS    PL4\nLEN_STMSRTLN   EQU   *-STMSRTLN\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STEMSR35": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x17\\x16_\\x01\\x17\\x16_\\x03\\x02\\x00W\\x00W\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-06-14T00:00:00", "modifydate": "2017-06-14T03:02:36", "lines": 87, "newlines": 87, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'STEMSR35 - E35 exit for the SORT, part of STEMSORT'\n*______________________________________________________________________\n*\n* Written by John Gateley - use at your own risk\n*\n* This is called by the SORT to output the sorted record.\n*______________________________________________________________________\n*\nSTEMSR35 PRGDEF FSEG=MAIN_PART,INREX=Y\n*\n         USING STMSRTLN,R3\n         USING STEM_AREA,R6\n*\n         PRGEDEF\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n*  R3 points to    RX_REC_LEN     DS    F\n*                  RX_REC_ADR     DS    F\n*                  RX_THE_STEM    DS    F\n*                  RX_VAR_LEN_ADR DS    F\n*                  RX_#SAV_REX    DS    4F\n*                  RX_TOT_RECS    DS    PL4\n*\n   L     R7,0(,R1)                     address of the output record\n   L     R3,=V(STMSRTLN)               point to stuff in STEMSORT\n   L     R4,RX_REC_LEN                 get sort length\n   L     R6,RX_THE_STEM                get output stem area\n   ST    R6,MY_P_1                     save as first parm\n   MVC   #SAV_REX(4*4),RX_#SAV_REX     copy IRX routine addresses\n   IF (LTR,R7,R7,NZ)                   is there a record to output\n     ST    R7,STEM_TEXT_ADR            save output record address\n     LA    R7,0(R4,R7)                 point to end of record\n     MVC   STEM_TEXT_LEN,0(R7)         copy original length\n     MVHHI STEM_FUNCTION,2             set STEM value\n     LA    R1,MY_PARM                  point to parameter list\n     L     R15,=V(PROCSTEM)            get program address\n     BASR  R14,R15                     go and set stem value\n     IF (LTR,R15,R15,NZ)               error ?\n       ST    R15,R_C                   set return code\n       MVC   MESS_TXT(20),=CL20'PROCSTEM failed  RC='\n       XUNPK R_C,4,MESS_TXT+20\n       SEGDO WRITE_LOG\n       PRGQUIT                         QUIT\n     ENDIF\n     SETRC RC=4                        next record wanted\n   ELSE\n     MVHHI STEM_FUNCTION,3             set stem.0 to STEM_ZERO_COUNT\n     LA    R1,MY_PARM                  point to parameter list\n     L     R15,=V(PROCSTEM)            get program address\n     BASR  R14,R15                     go and get stem value\n     IF (LTR,R15,R15,NZ)               error ?\n       ST    R15,R_C                   set return code\n       PRGQUIT                         QUIT\n     ENDIF\n     SETRC RC=8                        no more output records\n   ENDIF\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n         PRGSTAT\n*\n         LTORG\n*\n         PRGSTEM DSECT=Y\n*\nSTMSRTLN       DSECT\nRX_REC_LEN     DS    F\nRX_REC_ADR     DS    F\nRX_THE_STEM    DS    F\nRX_VAR_LEN_ADR DS    F\nRX_#SAV_REX    DS    4F                rexx environment addresses\nRX_TOT_RECS    DS    PL4\nLEN_STMSRTLN   EQU   *-STMSRTLN\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRINGI$": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00G\\x01\\x17\\x05?\\x01\\x17\\x05? 9\\x00\\x1e\\x00\\x12\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-02-22T20:39:47", "lines": 30, "newlines": 18, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(STRINGIT)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   STRINGIT\n SETSSI  CB496953\n ENTRY   STRINGIT\n NAME    STRINGIT(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STRINGIT": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x17\\x05?\\x01\\x17\\x06\\x8f\\t\\x06\\x01\\x83\\x01w\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-03-09T09:06:46", "lines": 387, "newlines": 375, "modlines": 0, "user": "SDJRG"}, "text": "STRINGIT CSECT\nSTRINGIT AMODE 31\nSTRINGIT RMODE ANY\n*\n* November  2016 - John Gateley - create\n* March     2017 - John Gateley - cannot UNPK more than PL8 - abend\n*\n*   This program is used by the STRING macro to convert fields\n*   to the required format and to put them into the output area.\n*\n*   Note that on return from this program register 1 contains the\n*   address of the byte in the output area after the strung data.\n*\n*   Input parameters generated by the STRING macro are\n*     1, address of a series of format indicators terminated by x'FF'\n*     2, address of output area\n*     3, length of the output area\n*     4, address of a 32 byte work area\n*\n*     5, address of input field\n*     6, length of input field\n*\n*   Parameters 5 and 6 repeat for as many indicators as there are in\n*   the list pointed to by parameter 1\n*\n*   note that this program does not have it's own save area because\n*   it does not call anything and it needs to be re-entrant\n*\n         SAVE  (14,12)                   * save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                   * copy base address\n         USING STRINGIT,R12\n         LR    R10,R1                    * copy parameter address\n         LM    R3,R6,0(R10)              * load first 4 parameters\n*                              R3    string of output indicators\n*                              R4    address of output field\n*                              R5    length of output field\n*                              R6    work area in caller\n         USING WORKAREA,R6\n         MVC   GLOB_IND,0(R3)        * copy global indicators\n         LA    R3,L'GLOB_IND(,R3)    * point passed global indicators\n         AR    R5,R4                 * point after output field\n         LA    R7,16(,R10)     R7    * point to first address/length\n*\n         CLI   PAD_FRST,C'0'\n         BNH   GO_AGAIN              * no initial pad char\n         PACK  DOUB_WORD,PAD_FRST\n         CVB   R1,DOUB_WORD\n         LA    R4,0(R1,R4)           * point passed initial pad char\n*\nGO_AGAIN DS    0H\n         LM    R8,R9,0(R7)           Get details of next field\n*\n*        if the length in R9 is negative it means that R8 contains\n*        the value to be displayed not the address of the value\n*\n         LTR   R9,R9                     * test R9\n         BP    IS_POS                    * if positive then use it\n         LPR   R9,R9                     * make positive\n         ST    R8,FULL_WORD              * save 32 bit value\n         LA    R8,FULL_WORD              * and point to it\n*\nIS_POS   DS    0H\n*\n         CLI   0(R3),C'X'                * Hex output required\n         BE    HEX_OUT\n*\n         CLI   0(R3),C'B'                * Binary output required\n         BE    BIN_OUT\n*\n         CLI   0(R3),C'P'                * Pack output required\n         BE    PACK_OUT\n*\n         CLI   0(R3),C'I'                * Integer output required\n         BE    INT_OUT\n*\n         CLI   0(R3),C'U'                * Unsigned integer required\n         BE    UINT_OUT\n*\n         CLI   0(R3),C'S'                * Small Int output required\n         BE    SINT_OUT\n*\n         CLI   0(R3),C'V'                * Small unsigned int required\n         BE    VINT_OUT\n*\n*        assume it must be character\n*\n*        Just copy the character value to the output area\n*\nCHAR_OUT DS    0H\n         LA    R1,0(R9,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         BCTR  R9,0                      * -1 for execute\n         EX    R9,MVC_IT                 * execute the move\n         LA    R4,1(R9,R4)               * point past data copied\n         B     DONE_IT\n*\n*        Take the value and convert to hexadecimal display\n*\nHEX_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nHEX_OUT1 DS    0H\n         MVC   WORK2(1),0(R8)            * copy one byte\n         UNPK  WORK3,WORK2               * UNPK two bytes to three\n         TR    WORK3(2),TR_TAB-240       * convert to displayable\n         MVC   0(2,R4),WORK3             * copy to receiver\n         LA    R4,2(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,HEX_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Take the value and convert to binary display\n*        This puts the byte into the low byte of register 1 and then\n*        for each iteration of the inner loop moves the next bit into\n*        the low bit of byte three of the register and stores it.\n*        So as the loop progresses the bit values become bytes in\n*        the output string.\n*\nBIN_OUT  DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,3                      * multiply by 8\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\nBIN_OUT1 DS    0H\n         IC    R1,0(R8)                  * get a byte\n         LR    R14,R4                    * copy output address\n         LA    R15,8                     * 8 bits to a byte\n*\nBIN_OUT2 DS    0H\n         SLA   R1,1                      * slide left 1 bit\n         STCM  R1,2,0(R14)               * store third byte\n         NI    0(R14),1                  * switch of all but right bit\n         LA    R14,1(,R14)               * next output byte\n         BCT   R15,BIN_OUT2              * process next bit\n*\n         OC    0(8,R4),ZONES             * make zoned decimal\n         LA    R4,8(,R4)                 * move past output bytes\n         LA    R8,1(,R8)                 * move past input byte\n         BCT   R9,BIN_OUT1               * do next byte\n         B     DONE_IT\n*\n*        Input is packed convert to numeric display\n*\nPACK_OUT DS    0H\n         LR    R2,R9                     * copy sending length\n         SLL   R2,1                      * multiply by 2\n         LA    R1,0(R2,R4)               * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         CHI   R9,8                      * cannot unpk > 8 bytes\n         BH    PACKLONG                  * so abend\n         LR    R1,R9                     * get length of field\n         BCTR  R1,0                      * less 1 for execute\n         LR    R15,R1                    * copy for CP\n         SLL   R15,4                     * left one nibble\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtact for EX and sign\n         SLL   R2,1                      * multiply by 2\n         LA    R14,0(R2,R4)              * position to last digit\n         SLL   R2,4                      * left one nibble\n         OR    R1,R2                     * merge lengths\n         EX    R1,UNPK_IT                * unpack data\n         OI    0(R14),X'F0'              * make last digit numeric\n         EX    R15,CP_IT                 * check if negative\n         BL    P_NEG                     * branch negative\n         MVI   1(R14),C'+'\n         B     P_DONE\nP_NEG    DS    0H\n         MVI   1(R14),C'-'\nP_DONE   DS    0H\n*\n*        the following code is to remove leading zeroes, I know I\n*        could have built an edit pattern and executed an edit\n*        instruction but I thought this was easier. Also having a pad\n*        character would increase the size of the output field.\n*\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    P_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LR    R2,R9                     * get length of field\n         BCTR  R2,0                      * subtract 1\n         SLL   R2,1                      * multiply by 2\nP_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   P_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,P_CHK0                 * check next\nP_DONEX  DS    0H\n         LA    R4,2(,R14)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is integer convert to numeric display\n*\nINT_OUT  DS    0H\n         LA    R1,11(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    I_NEG\n         MVI   10(R4),C'+'\n         B     I_DONE\nI_NEG    DS    0H\n         MVI   10(R4),C'-'\nI_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(10,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    I_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nI_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   I_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,I_CHK0                 * check next\nI_DONEX  DS    0H\n         LA    R4,11(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed integer convert to numeric display\n*\nUINT_OUT DS    0H\n         LA    R1,10(,R4)                * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         L     R1,0(R8)                  * get integer value\n         SRL   R1,1                      * divide by 2\n         CVD   R1,DOUB_WORD              * convert to decimal\n         MP    DOUB_WORD,=P'2'           * multiply by 2\n         TM    3(R8),X'01'               * was low bit on\n         BZ    U_DONE\n         AP    DOUB_WORD,=P'1'           * add the one back in\nU_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'         * set the sign\n         UNPK  0(10,R4),DOUB_WORD        * unpack the value\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    U_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,9                      * get length to check\nU_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   U_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,U_CHK0                 * check next\nU_DONEX  DS    0H\n         LA    R4,10(,R4)                * move past output bytes\n         B     DONE_IT\n*\n*        Input is small integer convert to numeric display\n*\nSINT_OUT DS    0H\n         LA    R1,6(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         LH    R1,0(R8)                  * get small integer value\n         CVD   R1,DOUB_WORD\n         CP    DOUB_WORD,=P'0'\n         BL    S_NEG\n         MVI   5(R4),C'+'\n         B     S_DONE\nS_NEG    DS    0H\n         MVI   5(R4),C'-'\nS_DONE   DS    0H\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    S_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nS_CHK0   CLI   0(R1),C'0'                * is this byte zero\n         BNE   S_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,S_CHK0                 * check next\nS_DONEX  DS    0H\n         LA    R4,6(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Input is un-signed small integer convert to numeric display\n*\nVINT_OUT DS    0H\n         LA    R1,5(,R4)                 * point after receiving\n         CR    R1,R5                     * is the output full\n         BNL   OVERFLOW                  * yes error\n*\n         ICM   R1,3,0(R8)                * get small unsigned int val\n         CVD   R1,DOUB_WORD\n         OI    DOUB_WORD+7,X'0F'\n         UNPK  0(5,R4),DOUB_WORD\n         CLI   NUM_ZERO,C'Y'             * show leading zeroes\n         BE    V_DONEX                   * they are there\n         LR    R1,R4                     * get address of output\n         LA    R2,4                      * get length to check\nV_CHK0   CLI   0(R4),C'0'                * is this byte zero\n         BNE   V_DONEX                   * no so job done\n         MVI   0(R1),C' '                * blank it\n         LA    R1,1(,R1)                 * next byte\n         BCT   R2,V_CHK0                 * check next\nV_DONEX  DS    0H\n         LA    R4,5(,R4)                 * move past output bytes\n         B     DONE_IT\n*\n*        Processed that pair of address/length values - any more\n*\nDONE_IT  DS    0H\n         LA    R3,1(,R3)                 * point to next indicator\n         CLI   0(R3),X'FF'               * finished ?\n         BE    GO_BACK                   * then goback\n*\n         LA    R7,8(,R7)                 * next pair of addresses\n         CLI   PAD_DING,C'Y'             * any pad characted ?\n         BNE   GO_AGAIN                  * not so go again\n         MVC   0(1,R4),PAD_DING+1        * copy pad character\n         LA    R4,1(,R4)                 * jump past pad\n         B     GO_AGAIN                  * process next\n*\n*        Return to calling program setting R1 to the output byte after\n*        the last byte used.\n*\nGO_BACK  DS    0H\n         ST    R4,4(,R10)                * save current output address\n*                                        * in parameter list\n         LM    R14,R12,12(R13)           * restore callers registers\n         XR    15,15                     * set return code\n         L     R1,4(,R1)                 * retrieve current output adr\n*                                        * from parameter list\n         BR    R14                       * return to caller\n*********\n*\n* error routines\n*\n* There is no room in the output area for the input value so abend\n*\nOVERFLOW DS    0H\n         WTO   'STRINGIT - output overflow detected',                  /\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         B     DO_AB\n*\n* Cannot unpack more than 8 bytes so abend\n*\nPACKLONG DS    0H\n         WTO   'STRINGIT - packed field > 8',                          /\n               ROUTCDE=11,MCSFLAG=HRDCPY\nDO_AB    ABEND 500,DUMP,STEP             * ,REASON=1\n*********\n*\n* storage\n*\nWORKAREA       DSECT\nDOUB_WORD      DS    D\nFULL_WORD      DS    F\nWORK2          DS    CL2\nWORK3          DS    CL3\nGLOB_IND       DS    CL15\n               ORG   GLOB_IND\nPAD_DING       DS    CL2             * pad details  (Y/N + value)\nPAD_FRST       DS    CL1             * pad first value   (numeric)\nNUM_ZERO       DS    CL1             * output numeric leading zeroes\n               ORG\n*\nSTRINGIT       CSECT\nZONES          DC    C'00000000'\nTR_TAB         DC    C'0123456789ABCDEF'\nMVC_IT         MVC   0(1,R4),0(R8)\nUNPK_IT        UNPK  0(1,R4),0(1,R8)\nCP_IT          CP    0(1,R8),=P'0'\n*\n               LTORG\n*\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBNEXT": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x18\\x14o\\x01\\x18\\x14o\\x14U\\x00\\x8b\\x00\\x8b\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-26T00:00:00", "modifydate": "2018-05-26T14:55:08", "lines": 139, "newlines": 139, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n/*                                                                 */\n/*  The purpose of this is to create a VERY basic schedule system  */\n/*  so that putting a list of JCL members in a 'schedule' and      */\n/*  then executing it using this EXEC, will cause the list of      */\n/*  jobs to be copied into a stem variable. This stem is examined  */\n/*  and any lines that do NOT begin with '*' are copied to a       */\n/*  second stem and this is used to build the jobs.                */\n/*                                                                 */\n/*  The first job is then read into another stem and an extra      */\n/*  step added which will cause the next job to be submitted       */\n/*  if the first job ends with RC=0.                               */\n/*                                                                 */\n/*  In this example an additional step is also added to output     */\n/*  job statistics. This is done by the PROC FLOWER.               */\n/*  The job is then submitted.                                     */\n/*                                                                 */\n/*  If the job is successful then the extra step will submit       */\n/*  the next job in the schedule.                                  */\n/*                                                                 */\n/*  This is repeated until the full schedule has completed.        */\n/*                                                                 */\n/*  If a job fails then correct the error and re-submit, the       */\n/*  schedule will then continue.                                   */\n/*  ##                                                             */\n/*  Re-submit from the output queue using SJ command !!            */\n/*  ##                                                             */\n/*                                                                 */\n/*  Run it like this                                               */\n/*      TSO EXEC 'MY.EXEC(SUBNEXT)' 'TEST.JCL(#SCHD01)'            */\n/*                                                                 */\n/*  e.g. TEST.JCL(#SCHD01) contains                                */\n/*            TEST.JCL(MEMB06)                                     */\n/*            TEST.JCL(MEMB02)                                     */\n/*            TEST.JCL(MEMB01)                                     */\n/*        *   TEST.JCL(MEMB03)      not executed                   */\n/*            TEST.JCL(MEMB05)                                     */\n/*            TEST.JCL(MEMB04)                                     */\n/*                                                                 */\n\n  ARG  sched_name\n  if sched_name = '' then pull sched_name\n  sched_name = strip(sched_name)\n\n  say  'input schedule is' sched_name\n\n  /* check the current setting of PROFILE PREFIX                   */\n  /* if a prefix exists then save it and switch to NOPREFIX        */\n  pro_file = ''\n  X = OUTTRAP('ML.')\n  \"PROFILE\"\n  X = OUTTRAP('OFF')\n  DO I = 1 TO ML.0\n     pro_file = pro_file || ML.I\n  END\n  pro_pos = POS('PREFIX(',pro_file)\n  if pro_pos > 0 then do\n     pre_fix = substr(pro_file,pro_pos+7)\n     pro_pos = POS(')',pre_fix)\n     pre_fix = substr(pre_fix,1,pro_pos-1)\n     \"PROFILE NOPREFIX\"\n     say 'profile changed'\n  end\n\n  /* read the schedule into a stem variable                        */\n  \"ALLOC FILE(INFILE) DSN(\"sched_name\") SHR\"\n  al_o = rc\n  if al_o /= 0 then do\n     say 'allocation INFILE to' sched_name\n     say 'failed rc = ' al_o\n     exit 12\n  end\n  \"EXECIO * DISKR INFILE (STEM SCHED. FINIS\"\n  \"FREE  FILE(INFILE)\"\n\n  /* examine each line in the schedule and copy the first word of  */\n  /* those that do NOT start with an asterix.                      */\n  cou_nt = 0\n  DO I = 1 TO SCHED.0\n     test_comment = word(SCHED.I,1)\n     if substr(test_comment,1,1) \\= '*' then do\n        cou_nt = cou_nt + 1\n        sched2.cou_nt = test_comment\n     end\n  END\n  sched2.0 =  cou_nt\n\n  first_job = sched2.1                     /* copy first jobname   */\n  say  'first job is     ' first_job\n\n  /* read the first job into a stem variable                       */\n  \"ALLOC FILE(INFILE) DSN(\"first_job\") SHR\"\n  al_o = rc\n  if al_o /= 0 then do\n     say 'allocation INFILE to' first_job\n     say 'failed rc = ' al_o\n     exit 12\n  end\n  \"EXECIO * DISKR INFILE (STEM THEJOB. FINIS\"\n  \"FREE  FILE(INFILE)\"\n\n  /* QUEUE each line of JCL until no more in stem                  */\n  /* quit if a line contains just '//' in columns 1 and 2 as this  */\n  /* is treated as end of file by SUBMIT.                          */\n  DO I = 1 TO THEJOB.0\n     test_end = strip(thejob.i)\n     if length(test_end) = 2 then\n        if test_end = \"//\" then leave\n     QUEUE thejob.i\n  END\n\n  /* if there are more jobs in the schedule then include an        */\n  /* additional step which will submit the subsequent jobs         */\n  if sched2.0 > 1 then do\n     Queue \"//****************************                   \"\n     Queue \"//CHECKRC EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(0,NE)   \"\n     Queue \"//SYSTSIN  DD  *                                 \"\n     Queue \"  PROFILE NOPREFIX                               \"\n     Queue \"  EXEC 'MY.EXEC(SUBNEXT1)'                       \"\n     DO I = 2 TO SCHED2.0         /* output rest of schedule       */\n        th_is = strip(sched2.i)\n        Queue \"   \" th_is   \"                                \"\n     END\n     Queue \"//SYSTSPRT DD  SYSOUT=*                          \"\n  end\n\n  /* finally add a step to output job statistics                   */\n  Queue \"//****************************                      \"\n  Queue \"//STATS   EXEC FLOWER                               \"\n  Queue \"ZZ\"\n  \"SUBMIT * END(ZZ)\"\n\n  /* if a prefix existed before then put it back                   */\n  if pro_pos > 0 then do\n     \"PROFILE PREFIX(\"pre_fix\")\"\n     say 'profile reset'\n  end\n\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBNEXT1": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x18\\x14o\\x01\\x18\\x14o\\x14U\\x00N\\x00N\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-26T00:00:00", "modifydate": "2018-05-26T14:55:22", "lines": 78, "newlines": 78, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n/*                                                                 */\n/*  This is the second part of the VERY basic schedule system.     */\n/*  It is run by the step that is added to the end of the job      */\n/*  to submit the next job.                                        */\n/*                                                                 */\n/*  This reads the list of remaining jobs and submits the first    */\n/*  and includes the rest of the job list.                         */\n/*                                                                 */\n/*  If there are no more jobs in the list then the extra step      */\n/*  is not added.                                                  */\n/*                                                                 */\n/*  Do not run this except from the step added by SUBNEXT          */\n/*                                                                 */\n/*      TSO EXEC 'MY.EXEC(SUBNEXT)' 'TEST.JCL(#SCHD01)'            */\n/*                                                                 */\n\n  ni = 0\n  ab = 0\n\n  /* read in the list of all the other jobs in the schedule        */\n  do while ab = 0\n     pull sched_name\n     say  sched_name\n     if sched_name = '' then ab = 1\n     else do\n        ni = ni + 1\n        SCHED.ni = strip(sched_name)\n     end\n  end\n  SCHED.0 = ni     /* put the total into the stem header           */\n\n  first_job = strip(SCHED.1)           /* copy first jobname    */\n  first_job = word(first_job,1)        /* trim any extra text   */\n  say 'first job is ' first_job\n\n  /* read the first job into a stem variable                       */\n  \"ALLOC FILE(INFILE) DSN(\"first_job\") SHR\"\n  al_o = rc\n  if al_o /= 0 then do\n     say 'allocation INFILE to' first_job\n     say 'alloc rc = ' al_o\n     exit 12\n  end\n  \"EXECIO * DISKR INFILE (STEM THEJOB. FINIS\"\n  \"FREE  FILE(INFILE)\"\n\n  /* QUEUE each line of JCL until no more in stem                  */\n  /* quit if a line contains just '//' in columns 1 and 2 as this  */\n  /* is treated as end of file by SUBMIT.                          */\n  DO I = 1 TO THEJOB.0        /* read all the lines of the member */\n     test_end = strip(thejob.i)\n     if length(test_end) = 2 then\n        if test_end = \"//\" then leave               /* end of job */\n     QUEUE thejob.i           /* and queue them                   */\n  END\n\n  /* if there are more jobs in the schedule then include an        */\n  /* additional step which will submit the subsequent jobs         */\n  if sched.0 > 1 then do\n     Queue \"//****************************                   \"\n     Queue \"//CHECKRC EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(0,NE)   \"\n     Queue \"//SYSTSIN  DD  *                                 \"\n     Queue \"  PROFILE NOPREFIX                               \"\n     Queue \"  EXEC 'MY.EXEC(SUBNEXT1)'                       \"\n     DO I = 2 TO SCHED.0         /* output rest of schedule     */\n        th_is = strip(sched.i)\n        Queue \"   \" th_is   \"                                \"\n     END\n     Queue \"//SYSTSPRT DD  SYSOUT=*                          \"\n  end\n\n  /* finally add a step to output job statistics                   */\n  Queue \"//****************************                      \"\n  Queue \"//STATS   EXEC FLOWER                               \"\n  Queue \"ZZ\"\n  \"SUBMIT * END(ZZ)\"\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRIMIT": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00I\\x01\\x17\\x12\\x8f\\x01\\x18!o\\x16V\\x00f\\x00D\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-05-08T00:00:00", "modifydate": "2018-08-04T16:56:49", "lines": 102, "newlines": 68, "modlines": 0, "user": "SDJRG"}, "text": "TRIMIT   CSECT\nTRIMIT   AMODE 31\nTRIMIT   RMODE ANY\n*\n*   This program removes leading and extra blanks from a field\n*   so that         '  some  text    in    a  field       x'\n*   becomes         'some text in a field x                '\n*\n*   Optionally, all blanks can be removed from the field by\n*   specifying ALL=Y in the TRIM macro resulting in\n*                   'sometextinafieldx                     '\n*\n*   On return R15 contains the number of occupied bytes\n*\n*   Input parameters generated by the TRIM macro are\n*     1, address of a string which should be trimmed\n*     2, length of the string\n*     3,  0    only remove repeated spaces\n*        >0    remove all spaces\n*\n         SAVE  (14,12)                 save callers registers\n         PRINT OFF\n         YREGS\n         PRINT ON\n         LR    R12,R15                 copy base address\n         USING TRIMIT,R12\n         LR    R9,R1                   copy parameter address\n         LM    R4,R6,0(R9)             get address, length and ind\n         LA    R3,0(R4,R5)             point after string\n         BCTR  R3,0                    point at last byte\n*\n         CHI   R6,0                    if positive\n         BH    TRIM_ALL                trim all blanks\n*\n*  remove repeated spaces\n*\n         LA    R6,1                    flag next blank to be removed\nSTRTLOOP LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE  CLI   0(R4),C' '              check if this byte blank\n         BNE   SETNO                   no so set flag off\n         CHI   R6,1                    is flag on\n         BNE   SETYES                  no so set flag on\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE              loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nSETYES   LA    R6,1                    flag next blank to be removed\n         B     LOOPIT                  go and loop\nSETNO    LA    R6,0                    flag next blank to be ignored\nLOOPIT   LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOOP             loop to check next byte\n         B     ENDLOOP\n*\n*  remove all spaces\n*\nTRIM_ALL DS    0H\n*\nSTRTLOO2 LR    R7,R5                   copy the length\n         BCTR  R7,0                    subtract 1 for remaining length\n         LR    R2,R7                   copy as inner loop count\n         BCTR  R7,0                    subtract 1 for execute\nCOMPARE2 CLI   0(R4),C' '              check if this byte blank\n         BNE   LOOPIT2                 no so set flag off\n         LTR   R7,R7                   test remaining length\n         BM    ENDLOOP                 negative then finish\n         EX    R7,SLIDE_LEFT           slide bytes left\n         MVI   0(R3),C' '              blank the last byte\n         BCT   R2,COMPARE2             loop to go and test again\n         B     ENDLOOP                 branch past execute to end\nLOOPIT2  LA    R4,1(,R4)               next byte in field\n         BCT   R5,STRTLOO2             loop to check next byte\n*\n*  trim accomplished\n*\nENDLOOP  DS    0H\n*\n*  now get count of occupied bytes\n*\n         LR    R4,R3                   point at last byte\n         L     R5,4(,R9)               get length\nLOOP2    DS    0H\n         CLI   0(R4),C' '              is the byte blank\n         BNE   ENDLOOP2                no so quit\n         BCTR  R4,0                    point to previous byte\n         BCT   R5,LOOP2                loop until 0\nENDLOOP2 DS    0H\n*        R5 now has the occupied byte count\n         ST    R5,4(,R9)               put count in parameter list\n*\nGO_BACK  LM    R14,R12,12(R13)         restore callers registers\n         L     R15,4(,R1)              load occupied byte count\n         BR    R14                     return to caller\n*\nSLIDE_LEFT     MVC   0(0,R4),1(R4)     sliding move instruction\n*\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRIMIT$": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x17\\x12\\x8f\\x01\\x17\\x12\\x8f\\x16\\t\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-05-08T00:00:00", "modifydate": "2017-05-08T16:09:05", "lines": 30, "newlines": 30, "modlines": 0, "user": "SDJRG"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(TRIMIT)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   TRIMIT\n SETSSI  CB496953\n ENTRY   TRIMIT\n NAME    TRIMIT(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRYAUTH": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x17\\x06\\x0f\\x01\\x17\\x16_\\x046\\x00)\\x00(\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-03-01T00:00:00", "modifydate": "2017-06-14T04:36:03", "lines": 41, "newlines": 40, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX     Check if RACF authorised to access a dataset  */\n\n/*         CHKAUTH is an assembler program which acts as a        */\n/*         REXX function and checks if the user is authorised     */\n/*         to read or update the specified dataset.               */\n\n  arg the_dsn\n  parse upper var the_dsn the_dsn\n\n  address TSO \"CLEAR\"\n  say ' '\n\n  \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB') STACK \"\n  if rc /= 0 then do\n     say 'allocation to ispllib failed.'\n     exit\n  end\n\n/* if dataset looks like a PDS member then remove the member name */\n\n  test1=index(the_dsn,'(')\n  if test1>'0' then do\n     parse var the_dsn  the_dsn \"(\" the_mem \")\"\n  end\n\n  if length(the_dsn) = 0 then do\n     say 'Enter dataset name to check RACF authorisation'\n     say ' '\n     parse upper pull the_dsn\n     end\n  else say the_dsn\n\n  the_dsn = strip(the_dsn)\n  re_sult = chkauth(the_dsn)\n\n  say ' '\n  say re_sult\n\n  \"ISPEXEC LIBDEF ISPLLIB \"\n  if rc /= 0 then\n     say 'deallocation to ispllib failed.'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRYCNCAT": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x06\\x01\\x176O\\x01\\x18\\x02\\x7f\\x19#\\x006\\x00-\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-12-30T00:00:00", "modifydate": "2018-01-27T19:23:06", "lines": 54, "newlines": 45, "modlines": 0, "user": "SDJRG"}, "text": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. 'TRYCNCAT'.\n      **************************************************\n      *           GETCNCAT demonstration program       *\n      **************************************************\n      * This is an example of calling GETCNCAT to obtain a list\n      * of all datasets concatanated to a DDNAME.\n\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  WS-PROC-COUNT            PIC S9(4) COMP.\n       01  WS-GETCN-COUNT-DISP      PIC Z(5)9.\n\n       01  WS-GETCNCAT.\n         03  WS-GETCN-DDNAME        PIC X(8).\n         03  WS-GETCN-COUNT-AVAIL   PIC S9(4) COMP VALUE 40.\n         03  WS-GETCN-COUNT-ACTUAL  PIC S9(4) COMP.\n         03  WS-GETCN-MESSAGE       PIC X(47).\n         03  WS-GETCN-MORE          PIC X.\n         03  WS-GETCN-DSNAMES       OCCURS 40.\n           05  WS-GETCN-DSNAME      PIC X(44).\n           05  WS-GETCN-MEMNAME     PIC X(8).\n           05  WS-GETCN-FULL        PIC X(54).\n           05  WS-GETCN-PATH-LEN    PIC S9(4) COMP.\n           05  WS-GETCN-PATH-TXT    PIC X(255).\n\n       PROCEDURE DIVISION.\n\n           MOVE 'INDDN' TO WS-GETCN-DDNAME\n           CALL 'GETCNCAT' USING WS-GETCNCAT\n           IF RETURN-CODE > 0\n              DISPLAY WS-GETCN-MESSAGE\n           ELSE\n              MOVE WS-GETCN-COUNT-ACTUAL TO WS-GETCN-COUNT-DISP\n              DISPLAY 'Number returned ' WS-GETCN-COUNT-DISP\n              PERFORM VARYING WS-PROC-COUNT FROM 1 BY 1\n                      UNTIL   WS-PROC-COUNT > WS-GETCN-COUNT-ACTUAL\n                 IF WS-GETCN-DSNAME (WS-PROC-COUNT) NOT = SPACES\n      *             DISPLAY  WS-GETCN-DSNAME  (WS-PROC-COUNT)\n      *                      WS-GETCN-MEMNAME (WS-PROC-COUNT)\n                    DISPLAY  WS-GETCN-FULL    (WS-PROC-COUNT)\n                 END-IF\n                 IF WS-GETCN-PATH-LEN (WS-PROC-COUNT) > 0\n                   DISPLAY WS-GETCN-PATH-TXT (WS-PROC-COUNT) (1:80)\n                 END-IF\n              END-PERFORM\n              IF WS-GETCN-MORE = 'Y'\n                 DISPLAY 'More available'\n              END-IF\n           END-IF\n           GOBACK\n           .\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRYGDSN": {"ttr": 5647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x17\\x05O\\x01\\x17\\x05O\\x05\"\\x008\\x008\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-02-23T00:00:00", "modifydate": "2017-02-23T05:22:30", "lines": 56, "newlines": 56, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n/*                                                                 */\n/*  This uses the assembler rexx function GETDSNAM to get all      */\n/*  dataset names allocated to a DDNAME.                           */\n\n  \"ISPEXEC SELECT PGM(CLEAR)\"\n\n  \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB') STACK\"\n  if rc /= 0 then do\n     say 'allocation to ispllib failed.'\n     exit\n  end\n\n  MY_ddn  = \"ispslib\"\n  my_stem = \"wang\"\n\n  DROP wang.\n\n  say 'ISPSLIB'\n  RE_SPONSE = getdsnam(MY_ddn,my_stem)\n  if  re_sponse = 0 then do\n     DO LO_OP_R = 1 TO wang.0\n        SAY '  ' wang.LO_OP_R\n     END\n  end\n\n  MY_ddn  = \"ispplib\"\n  my_stem = \"wang\"\n\n  my_stem = \"wang\"\n\n  DROP wang.\n  say 'ISPPLIB'\n  RE_SPONSE = getdsnam(MY_ddn,my_stem)\n  if  re_sponse = 0 then do\n     DO LO_OP_R = 1 TO wang.0\n        SAY '  ' wang.LO_OP_R\n     END\n  end\n  DROP wang.\n\n  MY_ddn  = \"sysproc\"\n  my_stem = \"wang\"\n\n  DROP wang.\n  say 'SYSPROC'\n  RE_SPONSE = getdsnam(MY_ddn,my_stem)\n  if  re_sponse = 0 then do\n     DO LO_OP_R = 1 TO wang.0\n        SAY '  ' wang.LO_OP_R\n     END\n  end\n  DROP wang.\n\n  \"ISPEXEC LIBDEF ISPLLIB \"\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRYREXX": {"ttr": 5649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x17\\x05O\\x01\\x17\\x05O\\x05\"\\x008\\x008\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-02-23T00:00:00", "modifydate": "2017-02-23T05:22:30", "lines": 56, "newlines": 56, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n/*                                                                 */\n/*  This uses the assembler rexx function GETDSNAM to get all      */\n/*  dataset names allocated to a DDNAME.                           */\n\n  \"ISPEXEC SELECT PGM(CLEAR)\"\n\n  \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB') STACK\"\n  if rc /= 0 then do\n     say 'allocation to ispllib failed.'\n     exit\n  end\n\n  MY_ddn  = \"ispslib\"\n  my_stem = \"wang\"\n\n  DROP wang.\n\n  say 'ISPSLIB'\n  RE_SPONSE = getdsnam(MY_ddn,my_stem)\n  if  re_sponse = 0 then do\n     DO LO_OP_R = 1 TO wang.0\n        SAY '  ' wang.LO_OP_R\n     END\n  end\n\n  MY_ddn  = \"ispplib\"\n  my_stem = \"wang\"\n\n  my_stem = \"wang\"\n\n  DROP wang.\n  say 'ISPPLIB'\n  RE_SPONSE = getdsnam(MY_ddn,my_stem)\n  if  re_sponse = 0 then do\n     DO LO_OP_R = 1 TO wang.0\n        SAY '  ' wang.LO_OP_R\n     END\n  end\n  DROP wang.\n\n  MY_ddn  = \"sysproc\"\n  my_stem = \"wang\"\n\n  DROP wang.\n  say 'SYSPROC'\n  RE_SPONSE = getdsnam(MY_ddn,my_stem)\n  if  re_sponse = 0 then do\n     DO LO_OP_R = 1 TO wang.0\n        SAY '  ' wang.LO_OP_R\n     END\n  end\n  DROP wang.\n\n  \"ISPEXEC LIBDEF ISPLLIB \"\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRYSTEM": {"ttr": 5651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00D\\x01\\x17\\x16_\\x01 4O\\x081\\x00`\\x00H\\x00%\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-06-14T00:00:00", "modifydate": "2020-12-09T08:31:44", "lines": 96, "newlines": 72, "modlines": 37, "user": "SDJRG"}, "text": "/* REXX                                                        */\n\n/* Examples of sorting a stem variable ascending, descending   */\n/* and with a specific sort program command.                   */\n\n\n/* The SORT has been told to send messages to SORTPRT so       */\n/* allocate SORTPRT to DUMMY to hide SORT messages             */\n/* or to the teminal if you want to see them.                  */\n\n/* Alternatively add a third argument to the call of 'NOMSG'   */\n/* which dynamically allocates SORTPRT to DUMMY while the      */\n/* command runs and then de-allocates.                         */\n\n    \"ALLOC FI(SORTPRT)  DUMMY\"\n\n/* Concatenate the load library                                */\n\n    \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB') STACK\"\n    if rc /= 0 then do\n       say 'allocation to ispllib failed.'\n       exit\n    end\n\n    SORT_STMT = 'SUM FIELDS=(21,5,ZD) SORT FIELDS=(1,20,CH,A)'\n    WANG.0    = \"16\"\n    WANG.1    = \"ZAK                 00001\"\n    WANG.2    = \"JOHN                00001\"\n    WANG.3    = \"YANGTANGBANG        00001\"\n    WANG.4    = \"ADAM                00001\"\n    WANG.5    = \"CHARLES             00001\"\n    WANG.6    = \"JOHn GATELEY        00001\"\n    WANG.7    = \"Kingsley Amis       00001\"\n    WANG.8    = \"KING KONG           00001\"\n    WANG.9    = \"ZAK                 00001\"\n    WANG.10   = \"JOHN                00001\"\n    WANG.11   = \"YANGTANGBANG        00001\"\n    WANG.12   = \"ADAM                00001\"\n    WANG.13   = \"CHARLES             00001\"\n    WANG.14   = \"JOHn GATELEY        00001\"\n    WANG.15   = \"Kingsley Amis       00001\"\n    WANG.16   = \"KING KONG           00001\"\n\n    DO LO_OP_R = 1 TO WANG.0\n       SAY  'Original  :' || WANG.LO_OP_R || ':'\n    END\n\n    SAY ' '\n\n    /* sort and sum all   */\n    R_C = STEMSORT(WANG,SORT_STMT)\n    IF  R_C      /= 0 THEN SAY 'R_C was ' R_C\n    ELSE\n       DO LO_OP_R = 1 TO WANG.0\n          SAY  'Sort 1    :' || WANG.LO_OP_R || ':'\n       END\n\n    SAY ' '\n\n\n    R_C = STEMSORT(WANG,'D')    /* sort the whole variable Desc */\n    IF  R_C      /= 0 THEN SAY 'R_C was ' R_C\n    ELSE\n       DO LO_OP_R = 1 TO WANG.0\n          SAY  'Sort 2    :' || WANG.LO_OP_R || ':'\n       END\n\n    SAY ' '\n\n    /*  You can provide a specific sort command.                */\n    /*  if you wish to provided a SUM statement put it first    */\n    /*  as the program needs to add ',FILSZ=nnnnnn' to the      */\n    /*  sort command. Do not include an INREC or OUTREC         */\n    /*  statement as the results will not be as expected.       */\n\n    sort_cmd = ' SORT FIELDS=(1,3,CH,A,4,5,CH,D) '\n    R_C = STEMSORT(WANG,sort_cmd)\n    IF  R_C      /= 0 THEN SAY 'R_C was ' R_C\n    ELSE\n       DO LO_OP_R = 1 TO WANG.0\n          SAY  'Sort 3    :' || WANG.LO_OP_R || ':'\n       END\n\n    SAY ' '\n\n    DROP WANG.\n\n/* Free the load library                                       */\n\n    \"ISPEXEC LIBDEF ISPLLIB \"\n\n/* Free SORTPRT                                                */\n\n    \"FREE FILE(SORTPRT)\"\n\n    EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRYVOL": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x19\\x03\\x8f\\x01\\x19\\x03\\x8f\\x06P\\x00\"\\x00\"\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-02-07T00:00:00", "modifydate": "2019-02-07T06:50:17", "lines": 34, "newlines": 34, "modlines": 0, "user": "SDJRG"}, "text": "/*REXX*/\n\n  clear\n\n  \"ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB')\"\n\n  arg vol_pat\n  parse upper var vol_pat vol_pat\n\n  re_sponse = VOLUMESR(vol_pat,'vol_dets')\n\n  if vol_dets.0 = 0 then say 'no matching volumes'\n  else do\n    select\n       when re_sponse = 0 then do\n          to_tal = vol_dets.0\n          li_nes = vol_dets.0 - 1\n          say 'Number of volumes = ' li_nes\n          do lo_op_r = 1 to li_nes\n             say '|'|| vol_dets.lo_op_r||'|'\n          end\n          say 'Totals'\n          say '|'|| vol_dets.to_tal ||'|'\n         end\n       Otherwise\n          say 'Error :' re_sponse\n    end\n  end\n\n  drop vol_dets.\n\n  \"ispexec libdef ispllib \"\n\n  exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VOLUMES": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x18!\\x0f\\x01\\x18!\\x0f\\x16\\x11\\x00\\xfc\\x00\\xfc\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-07-29T00:00:00", "modifydate": "2018-07-29T16:11:46", "lines": 252, "newlines": 252, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'VOLUMES  - OBTAIN VTOC DETAILS OF VOLUMES MATCHING PATTERN'\n*______________________________________________________________________\n*\nVOLUMES  PRGDEF FSEG=MAIN_PART,RMODE=24\n*\nPL_16          DS    PL16\nWORK8          DS    CL8\nVOL_PATTERN    DS    CL6\n*\nSYSOUT_REC     DS    CL80\n*\n         PRGEDEF\n*\n         USING VOL_DETS,U#F4DSCB\n         USING UCB_DETS,U#COPY\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   MVC   VOL_PATTERN,=C'******'\n   L     R1,0(R1)\n   IF (CLC,0(2,R1),NE,=H'0')\n     IF (CLC,0(2,R1),GT,=H'6')\n       MVC   MESS_TXT(L'PARM_ERR),PARM_ERR\n       SEGDO WRITE_LOG\n       PRGQUIT RC=8\n     ENDIF\n     LH    R2,0(R1)\n     BCTR  R2,0\n     EX    R2,COPY_VOL_PAT\n   ENDIF\n   MVI   SYSOUT_REC,C' '\n   MVC   SYSOUT_REC+1(L'SYSOUT_REC-1),SYSOUT_REC\n*\n   SEGDO OPEN_SYSOUT\n   SEGDO WRITE_HEADINGS\n*\n   XC    U#WORK,U#WORK\n   DO INF\n     UCBSCAN COPY,WORKAREA=U#WORK,UCBAREA=U#COPY,DEVCLASS=DASD,        /\n               DYNAMIC=YES,DEVNCHAR=DEVNCHAR,RANGE=ALL\n   DOEXIT (LTR,R15,R15,NZ)             QUIT IF NO MORE UCB\n     IF (TM,UCBSTAT,UCBONLI,NZ)        IT'S ONLINE\n       IF (CLC,UCBVOLI(1),EQ,VOL_PATTERN),OR,                          /\n               (CLI,VOL_PATTERN,EQ,C'*'),ANDIF,                        /\n               (CLC,UCBVOLI+1(1),EQ,VOL_PATTERN+1),OR,                 /\n               (CLI,VOL_PATTERN+1,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+2(1),EQ,VOL_PATTERN+2),OR,                 /\n               (CLI,VOL_PATTERN+2,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+3(1),EQ,VOL_PATTERN+3),OR,                 /\n               (CLI,VOL_PATTERN+3,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+4(1),EQ,VOL_PATTERN+4),OR,                 /\n               (CLI,VOL_PATTERN+4,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+5(1),EQ,VOL_PATTERN+5),OR,                 /\n               (CLI,VOL_PATTERN+5,EQ,C'*')\n         SEGDO MAIN_PROCESS\n         AP    NUM_VOLS,=P'1'\n         AP    TOTAL_FREE,VOLUME_FREE\n         AP    TOTAL_TRACKS,VOLUME_TRACKS\n       ENDIF\n     ENDIF\n   ENDDO\n*\n   SEGDO WRITE_SYSOUT\n*\n   MVC   SYSOUT_REC(L'ED_PL4),ED_PL4\n   ED    SYSOUT_REC(L'ED_PL4),NUM_VOLS\n   IF (CP,NUM_VOLS,GT,=P'0')\n     MVC   SYSOUT_REC+10(L'ED_PL6),ED_PL6\n     ED    SYSOUT_REC+10(L'ED_PL6),TOTAL_TRACKS+2    TOTAL TRACKS\n     ZAP   DOUB_WORD,TOTAL_TRACKS\n     SP    DOUB_WORD,TOTAL_FREE\n     MVC   SYSOUT_REC+25(L'ED_PL6),ED_PL6\n     ED    SYSOUT_REC+25(L'ED_PL6),DOUB_WORD+2       TOTAL USED\n     MVC   SYSOUT_REC+40(L'ED_PL6),ED_PL6\n     ED    SYSOUT_REC+40(L'ED_PL6),TOTAL_FREE+2      TOTAL FREE TRACKS\n*\n     IF (CP,TOTAL_TRACKS,GT,=P'0')\n       ZAP   PL_16,TOTAL_FREE          TOTAL NUMBER OF FREE TRACKS\n       MP    PL_16,=P'100000'\n       DP    PL_16,TOTAL_TRACKS        TOTAL NUMBER OF AVAILABLE TRA\n       SRP   PL_16(8),64-1,5\n       MVC   SYSOUT_REC+55(L'ED_PL6D2),ED_PL6D2\n       ED    SYSOUT_REC+55(L'ED_PL6D2),PL_16+2       % FREE SPACE\n     ENDIF\n   ENDIF\n   SEGDO WRITE_SYSOUT\n*\n   SEGDO CLOSE_SYSOUT\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS MAIN_PROCESS\n*\n   MVC   SYSOUT_REC+4(6),UCBVOLI\n*\n   LA    R3,U#COPY\n   LSPACE UCB=(R3),EXPMSG=U#EXPMSG,F4DSCB=U#F4DSCB\n*\n   PACK  DOUB_WORD,U#EXPMSG+6(6)       NUMBER OF FREE CYLINDERS\n   CVB   R1,DOUB_WORD                  CONVERT TO BINARY\n   MH    R1,DS4DSTRK                   NUMBER OF TRACKS PER CYL\n   CVD   R1,DOUB_WORD                  CONVERT TO DECIMAL\n   PACK  FREE_TRKS,U#EXPMSG+13(6)      NUMBER OF EXTRA TRACKS\n   AP    DOUB_WORD,FREE_TRKS           TOTAL FREE\n   ZAP   VOLUME_FREE,DOUB_WORD\n*\n*\n   LH    R1,DS4DSCYL                   TOTAL NUMBER OF CYLINDERS\n   MH    R1,DS4DSTRK                   NUMBER OF TRACKS PER CYL\n   CVD   R1,VOLUME_TRACKS              GIVE AVAILABLE TRACKS\n   MVC   SYSOUT_REC+10(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+10(L'ED_PL6),VOLUME_TRACKS+2    TOTAL TRACKS\n*\n   ZAP   DOUB_WORD,VOLUME_TRACKS\n   SP    DOUB_WORD,VOLUME_FREE\n   MVC   SYSOUT_REC+25(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+25(L'ED_PL6),DOUB_WORD+2        USED TRACKS\n   MVC   SYSOUT_REC+40(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+40(L'ED_PL6),VOLUME_FREE+2      FREE TRACKS\n*\n   IF (CP,VOLUME_TRACKS,GT,=P'0')\n     ZAP   PL_16,VOLUME_FREE\n     MP    PL_16,=P'100000'\n     DP    PL_16,VOLUME_TRACKS\n     SRP   PL_16(8),64-1,5\n     MVC   SYSOUT_REC+55(L'ED_PL6D2),ED_PL6D2\n     ED    SYSOUT_REC+55(L'ED_PL6D2),PL_16+2         % FREE SPACE\n   ENDIF\n   SEGDO WRITE_SYSOUT\n*\n SEGE MAIN_PROCESS\n*______________________________________________________________________\n*\n SEGS WRITE_HEADINGS\n*\n   MVC   SYSOUT_REC(L'HEAD_L_1),HEAD_L_1\n   MVC   SYSOUT_REC+L'HEAD_L_1-6(6),VOL_PATTERN\n   SEGDO WRITE_SYSOUT\n   SEGDO WRITE_SYSOUT\n   MVC   SYSOUT_REC(L'HEAD_L_2),HEAD_L_2\n   SEGDO WRITE_SYSOUT\n   MVC   SYSOUT_REC(L'HEAD_L_3),HEAD_L_3\n   SEGDO WRITE_SYSOUT\n   SEGDO WRITE_SYSOUT\n*\n SEGE WRITE_HEADINGS\n*______________________________________________________________________\n*\n SEGS WRITE_SYSOUT\n*\n   SAM24\n   PUT   SYSOUT,SYSOUT_REC\n   SAM31\n*\n   MVI   SYSOUT_REC,C' '\n   MVC   SYSOUT_REC+1(L'SYSOUT_REC-1),SYSOUT_REC\n*\n SEGE WRITE_SYSOUT\n*______________________________________________________________________\n*\n SEGS OPEN_SYSOUT\n*\n   OPEN  (SYSOUT,OUTPUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'OPEN_ERR),OPEN_ERR\n     SEGDO WRITE_LOG\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE OPEN_SYSOUT\n*______________________________________________________________________\n*\n SEGS CLOSE_SYSOUT\n*\n   CLOSE (SYSOUT),MODE=31\n   IF (LTR,R15,R15,NZ)\n     MVC   MESS_TXT(L'CLOSE_ERR),CLOSE_ERR\n     SEGDO WRITE_LOG\n     PRGQUIT RC=8\n   ENDIF\n*\n SEGE CLOSE_SYSOUT\n*______________________________________________________________________\n*\n SEGS WRITE_LOG\n*\n   WTOX\n*\n SEGE WRITE_LOG\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nCOPY_VOL_PAT   MVC   VOL_PATTERN(1),2(R1)\n*\nSYSOUT   DCB   DDNAME=SYSOUT,MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80\n*\nDEVNCHAR       DC    CL4' '\n*\nL#VOL          DS    CL6\nU#COPY         DS    XL48\nU#WORK         DS    XL100\nU#EXPMSG       DS    XL40\nU#F4DSCB       DS    XL96\n*\nFREE_TRKS      DC    PL3'0'\nVOLUME_FREE    DC    PL8'0'\nVOLUME_TRACKS  DC    PL8'0'\nTOTAL_FREE     DC    PL8'0'\nTOTAL_TRACKS   DC    PL8'0'\nNUM_VOLS       DC    PL4'0'\n*\nPARM_ERR       DC    C'Parm error - length > 6'\nOPEN_ERR       DC    C'Error opening SYSOUT'\nCLOSE_ERR      DC    C'Error closing SYSOUT'\n*\nHEAD_L_1 DC  C'Show online dasd volumes matching pattern=XXXXXX'\nHEAD_L_2 DC  C'    volume          total           used           free /\n                        %free'\nHEAD_L_3 DC  C'    ------          -----           ----           ---- /\n                        -----'\nED_PL4         DC    X'40206B2020206B20212060'\nED_PL6         DC    X'4020206B2020206B2020206B20212060'\nED_PL6D2       DC    X'402020206B2020206B2021204B202060'\n*______________________________________________________________________\n*\nSSOB_PTR       DS    A(SSOB+X'80000000')\nSSOB_WRK       DS    XL(SSOBHSIZ)            SSOB\nSSSA_WRK       DS    XL(SSSALN+SSSA1LN+L'SSSA1NMS)\n*______________________________________________________________________\n*\n               LTORG\n*______________________________________________________________________\n*\nVOL_DETS       DSECT\n               IECSDSL1 (4)            GEN FMT 4 DSCB LABELS\nUCB_DETS       DSECT\n               IEFUCBOB\nVOLUMES        CSECT\n               CVT   DSECT=YES         CVT\n               IEFJESCT                JES CVT\n               IEFJSSOB ,              SSOB HEADER DSECT\n               IEFSSSA                 SSOB EXTENSION FOR SMS\n*              IGDVLD                  VOLUME DEFINITION\n               IGDSGD                  STORAGE GROUP DEFINITION\n*______________________________________________________________________\n*\n               PRGESTAT\n               PRGEND\n               END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VOLUMES$": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x18!\\x0f\\x01\\x18!\\x0f\\x16\\x17\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-07-29T00:00:00", "modifydate": "2018-07-29T16:17:30", "lines": 30, "newlines": 30, "modlines": 0, "user": "SDJRG"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//****************************************************\n//*                                                  *\n//*     ASM LINKEDIT FROM SOURCE ASM                 *\n//*                                                  *\n//****************************************************\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.GATELEY.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD  DISP=SHR,DSN=SBGOLOB.CBT496.FILE953(VOLUMES)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//             DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='CALL,MAP,LIST,XREF,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   VOLUMES\n SETSSI  CB496953\n ENTRY   VOLUMES\n NAME    VOLUMES(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VOLUMESR": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x19\\x03\\x8f\\x01\\x19\\x03\\x8f\\x06F\\x01\\x15\\x01\\x15\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-02-07T00:00:00", "modifydate": "2019-02-07T06:46:16", "lines": 277, "newlines": 277, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'VOLUMESR  - Obtain vtoc details of VOLUMES matching pattern'\n*______________________________________________________________________\n*\nVOLUMESR PRGDEF FSEG=MAIN_PART,RMODE=24,REXX=Y\n*\n*  Created by John Gateley\n*\n*  This is a REXX enabled version of volumes which, instead of writing\n*  to SYSOUT populates a REXX stem variable with the results.\n*______________________________________________________________________\n*\n* This program acts as a REXX function\n*\n*    Input\n*         6 bytes containing a pattern for the volume name\n*         the name of a stem variable to populate\n*\n*    Output\n*         stem_name.0                  count of stem variable\n*         stem_name.?                  volume details\n*______________________________________________________________________\n*\nPL_16          DS    PL16\nWORK8          DS    CL8\nVOL_PATTERN    DS    CL6\n*\nATIOT          DS    F                 address of TIOT\n*\nSYSOUT_REC     DS    CL80\nERR_NO         DS    C\n*\n         PRGSTEM\n*\n         PRGEDEF\n*\n         USING VOL_DETS,U#F4DSCB\n         USING UCB_DETS,U#COPY\n*______________________________________________________________________\n*\n SEGS MAIN_PART\n*\n   SEGDO GET_ARGUMENTS\n*\n   XC    U#WORK,U#WORK\n   DO INF\n     UCBSCAN COPY,WORKAREA=U#WORK,UCBAREA=U#COPY,DEVCLASS=DASD,        /\n               DYNAMIC=YES,DEVNCHAR=DEVNCHAR,RANGE=ALL\n   DOEXIT (LTR,R15,R15,NZ)             quit if no more UCB\n     IF (TM,UCBSTAT,UCBONLI,NZ)        is it online\n       IF (CLC,UCBVOLI(1),EQ,VOL_PATTERN),OR,                          /\n               (CLI,VOL_PATTERN,EQ,C'*'),ANDIF,                        /\n               (CLC,UCBVOLI+1(1),EQ,VOL_PATTERN+1),OR,                 /\n               (CLI,VOL_PATTERN+1,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+2(1),EQ,VOL_PATTERN+2),OR,                 /\n               (CLI,VOL_PATTERN+2,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+3(1),EQ,VOL_PATTERN+3),OR,                 /\n               (CLI,VOL_PATTERN+3,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+4(1),EQ,VOL_PATTERN+4),OR,                 /\n               (CLI,VOL_PATTERN+4,EQ,C'*'),ANDIF,                      /\n               (CLC,UCBVOLI+5(1),EQ,VOL_PATTERN+5),OR,                 /\n               (CLI,VOL_PATTERN+5,EQ,C'*')\n         SEGDO PROCESS_UCB\n         AP    NUM_VOLS,=P'1'\n         AP    TOTAL_FREE,VOLUME_FREE\n         AP    TOTAL_TRACKS,VOLUME_TRACKS\n       ENDIF\n     ENDIF\n   ENDDO\n*\n   MVC   SYSOUT_REC(L'ED_PL4),ED_PL4\n   ED    SYSOUT_REC(L'ED_PL4),NUM_VOLS\n   IF (CP,NUM_VOLS,GT,=P'0')\n     MVC   SYSOUT_REC+10(L'ED_PL6),ED_PL6\n     ED    SYSOUT_REC+10(L'ED_PL6),TOTAL_TRACKS+2    total tracks\n     ZAP   DOUB_WORD,TOTAL_TRACKS\n     SP    DOUB_WORD,TOTAL_FREE\n     MVC   SYSOUT_REC+25(L'ED_PL6),ED_PL6\n     ED    SYSOUT_REC+25(L'ED_PL6),DOUB_WORD+2       total used\n     MVC   SYSOUT_REC+40(L'ED_PL6),ED_PL6\n     ED    SYSOUT_REC+40(L'ED_PL6),TOTAL_FREE+2      total free tracks\n*\n     IF (CP,TOTAL_TRACKS,GT,=P'0')\n       ZAP   PL_16,TOTAL_FREE          total number of free tracks\n       MP    PL_16,=P'100000'\n       DP    PL_16,TOTAL_TRACKS        total number of available tra\n       SRP   PL_16(8),64-1,5           shift right, normal rounding\n       MVC   SYSOUT_REC+55(L'ED_PL6D2),ED_PL6D2\n       ED    SYSOUT_REC+55(L'ED_PL6D2),PL_16+2       % free space\n     ENDIF\n     SEGDO WRITE_STEM\n   ENDIF\n*\n   MVHHI STEM_FUNCTION,3               set STEM.0 to total lines\n   SEGDO CALL_PROCSTEM\n*\n SEGE MAIN_PART\n*______________________________________________________________________\n*\n SEGS PROCESS_UCB\n*\n   MVC   SYSOUT_REC+4(6),UCBVOLI\n*\n   LA    R3,U#COPY\n   LSPACE UCB=(R3),EXPMSG=U#EXPMSG,F4DSCB=U#F4DSCB\n*\n   PACK  DOUB_WORD,U#EXPMSG+6(6)       number of free cylinders\n   CVB   R1,DOUB_WORD                  convert to binary\n   MH    R1,DS4DSTRK                   number of tracks per cyl\n   CVD   R1,DOUB_WORD                  convert to decimal\n   PACK  FREE_TRKS,U#EXPMSG+13(6)      number of extra tracks\n   AP    DOUB_WORD,FREE_TRKS           total free\n   ZAP   VOLUME_FREE,DOUB_WORD\n*\n*\n   LH    R1,DS4DSCYL                   total number of cylinders\n*  BCTR  R1,0                          minus 1 for vtoc\n   MH    R1,DS4DSTRK                   number of tracks per cyl\n   CVD   R1,VOLUME_TRACKS              give available tracks\n   MVC   SYSOUT_REC+10(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+10(L'ED_PL6),VOLUME_TRACKS+2     total tracks\n*\n   ZAP   DOUB_WORD,VOLUME_TRACKS\n   SP    DOUB_WORD,VOLUME_FREE\n   MVC   SYSOUT_REC+25(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+25(L'ED_PL6),DOUB_WORD+2         used tracks\n   MVC   SYSOUT_REC+40(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+40(L'ED_PL6),VOLUME_FREE+2       free tracks\n*\n   IF (CP,VOLUME_TRACKS,GT,=P'0')\n     ZAP   PL_16,VOLUME_FREE\n     MP    PL_16,=P'100000'\n     DP    PL_16,VOLUME_TRACKS\n     SRP   PL_16(8),64-1,5\n     MVC   SYSOUT_REC+55(L'ED_PL6D2),ED_PL6D2\n     ED    SYSOUT_REC+55(L'ED_PL6D2),PL_16+2         % free space\n   ENDIF\n   SEGDO WRITE_STEM\n*\n SEGE PROCESS_UCB\n*______________________________________________________________________\n*\n SEGS WRITE_STEM\n*\n   LA    R1,SYSOUT_REC\n   ST    R1,STEM_TEXT_ADR\n   LA    R1,70                       just output 70 bytes\n   ST    R1,STEM_TEXT_LEN\n   MVHHI STEM_FUNCTION,2             set STEM value\n   SEGDO CALL_PROCSTEM\n*\n SEGE WRITE_STEM\n*______________________________________________________________________\n*\n SEGS GET_ARGUMENTS\n*\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')    no arguments\n     MVI   ERR_NO,1\n     SEGDO NOT_VALID\n   ENDIF\n   IF (CLC,ARGTABLE_ARGSTRING_LENGTH,NE,=F'6')   length not 6\n     MVI   ERR_NO,2\n     SEGDO NOT_VALID\n   ENDIF\n   L     R15,ARGTABLE_ARGSTRING_PTR              get address\n   MVC   VOL_PATTERN,0(R15)                      copy volume pattern\n   OC    VOL_PATTERN,=C'      '                  ensure uppercase\n*\n   LA    ARG_POINT,ARGTABLE_NEXT       point to second argument\n   IF (CLC,ARGTABLE_ARGSTRING_PTR,EQ,=8X'FF')\n     MVI   ERR_NO,3\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,EQ,=F'0')\n     MVI   ERR_NO,4\n     SEGDO NOT_VALID\n   ELSEIF (CLC,ARGTABLE_ARGSTRING_LENGTH,GT,=F'20')\n     MVI   ERR_NO,5\n     SEGDO NOT_VALID\n   ENDIF\n   MVC   STEM_NAME_ADR,ARGTABLE_ARGSTRING_PTR\n   MVC   STEM_NAME_LEN,ARGTABLE_ARGSTRING_LENGTH\n*\n   MVI   STEM_TRIM_VAR,C'N'            do not trim spaces from var\n   MVHHI STEM_FUNCTION,1               init STEM.0\n   SEGDO CALL_PROCSTEM\n*\n SEGE GET_ARGUMENTS\n*______________________________________________________________________\n*\n SEGS CALL_PROCSTEM\n*\n   LA    R1,STEM_AREA                  point to PRGSTEM area\n   ST    R1,MY_P_1                     save as first parm\n   LA    R1,MY_PARM                    point to parameter list\n   L     R15,=V(PROCSTEM)              get program address\n   BASR  R14,R15                       go and set stem value\n   IF (LTR,R15,R15,NZ)                 error ?\n     ST    R15,R_C                     set return code\n     PRGQUIT                           QUIT\n   ENDIF\n*\n SEGE CALL_PROCSTEM\n*______________________________________________________________________\n*\n SEGS NOT_VALID\n*\n   IF (CLI,ERR_NO,EQ,1)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 not entered'\n   ELSEIF (CLI,ERR_NO,EQ,2)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 1 was not 6'\n   ELSEIF (CLI,ERR_NO,EQ,3)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 not entered'\n   ELSEIF (CLI,ERR_NO,EQ,4)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 was zero length'\n   ELSEIF (CLI,ERR_NO,EQ,5)\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Argument 2 was > 20'\n   ELSE\n     MVC   EVALBLOCK_EVDATA(30),=CL30'Unknown error, rc='\n     XR    R1,R1\n     IC    R1,ERR_NO\n     CVD   R1,DOUB_WORD\n     OI    DOUB_WORD+7,X'0F'\n     UNPK  EVALBLOCK_EVDATA+18(4),DOUB_WORD\n     XC    R_C,R_C\n   ENDIF\n   MVC   EVALBLOCK_EVLEN,=F'30'\n*\n   PRGQUIT\n*\n SEGE NOT_VALID\n*______________________________________________________________________\n*\n               PRGSTAT\n*\nDEVNCHAR       DC    CL4' '\n*\nL#VOL          DS    CL6\nU#COPY         DS    XL48\nU#WORK         DS    XL100\nU#EXPMSG       DS    XL40\nU#F4DSCB       DS    XL96\n*\nFREE_TRKS      DC    PL3'0'\nVOLUME_FREE    DC    PL8'0'\nVOLUME_TRACKS  DC    PL8'0'\nTOTAL_FREE     DC    PL8'0'\nTOTAL_TRACKS   DC    PL8'0'\nNUM_VOLS       DC    PL4'0'\n*\nED_PL4         DC    X'40206B2020206B20212060'\nED_PL6         DC    X'4020206B2020206B2020206B20212060'\nED_PL6D2       DC    X'402020206B2020206B2021204B202060'\n*______________________________________________________________________\n*\nSSOB_PTR DS    A(SSOB+X'80000000')\nSSOB_WRK DS    XL(SSOBHSIZ)            SSOB\nSSSA_WRK DS    XL(SSSALN+SSSA1LN+L'SSSA1NMS)\n*______________________________________________________________________\n*\n         LTORG\n*______________________________________________________________________\n*\nVOL_DETS DSECT\n         IECSDSL1 (4)                  GEN FMT 4 DSCB LABELS\nUCB_DETS DSECT\n         IEFUCBOB\nVOLUMESR CSECT\n         CVT   DSECT=YES               CVT\n         IEFJESCT                      JES CVT\n         IEFJSSOB ,                    SSOB HEADER DSECT\n         IEFSSSA                       SSOB EXTENSION FOR SMS\n*        IGDVLD                        VOLUME DEFINITION\n         IGDSGD                        STORAGE GROUP DEFINITION\n*______________________________________________________________________\n*\n         PRGESTAT\n         PRGEND\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VOLUMESX": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x18!\\x1f\\x01\\x18!\\x1f\\x16I\\x01$\\x01$\\x00\\x00\\xe2\\xc4\\xd1\\xd9\\xc7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-07-30T00:00:00", "modifydate": "2018-07-30T16:49:26", "lines": 292, "newlines": 292, "modlines": 0, "user": "SDJRG"}, "text": " TITLE 'VOLUMESX - OBTAIN VTOC DETAILS OF VOLUMES MATCHING PATTERN'\n*______________________________________________________________________\n*\nVOLUMESX START 0\nVOLUMESX AMODE 31\nVOLUMESX RMODE 24\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING VOLUMESX,R12\n         LA    R2,SAVE_AREA\n         ST    R13,4(R2)\n         ST    R2,8(R13)\n         LR    R13,R2\n         XC    RETURN_CODE,RETURN_CODE\n*\n         B     MAIN_PART\n*\nDOUB_WORD      DS    D\nRETURN_CODE    DS    F\nSAVE_AREA      DS    18F\n*\nGET_OUT  L     R2,RETURN_CODE\n         L     R13,4(R13)\n         ST    R2,16(R13)\n         LM    R14,R12,12(R13)\n         BSM   0,R14                   return to caller\n*\n         USING VOL_DETS,U#F4DSCB\n         USING UCB_DETS,U#COPY\n*______________________________________________________________________\n*\nMAIN_PART  DS    0F\n*\n   MVC   VOL_PATTERN,=C'******'        default volume pattern\n   L     R1,0(R1)\n   CLC   0(2,R1),=H'0'                 no parm - OK\n   BE    OK_PARM\n   CLC   0(2,R1),=H'6'                 6 bytes of parn - OK\n   BE    SET_PAT\n   WTO   'INVALID PARM',ROUTCDE=11,MCSFLAG=HRDCPY\n   MVC   RETURN_CODE,=F'16'            no good so set RC\n   B     GET_OUT                       and leave\n*\n*\nSET_PAT  DS    0H\n   MVC   VOL_PATTERN(6),2(R1)          copy parm value\n*\nOK_PARM  DS    0H\n*\n   OPEN  (SYSOUT,OUTPUT),MODE=31\n   LTR   R15,R15\n   BZ    OK_OPEN\n   WTO   'SYSIN OPEN FAILED',ROUTCDE=11,MCSFLAG=HRDCPY\n   MVC   RETURN_CODE,=F'16'\n   B     GET_OUT\n*\nOK_OPEN  DS    0H\n*\n*        write report headers\n   MVC   SYSOUT_REC(L'HEAD_L_1),HEAD_L_1\n   MVC   SYSOUT_REC+L'HEAD_L_1-6(6),VOL_PATTERN\n   BAS   R4,WRITE_SYSOUT\n   MVC   SYSOUT_REC(L'HEAD_L_2),HEAD_L_2\n   BAS   R4,WRITE_SYSOUT\n   MVC   SYSOUT_REC(L'HEAD_L_3),HEAD_L_3\n   BAS   R4,WRITE_SYSOUT\n   BAS   R4,WRITE_SYSOUT\n*\n   XC    U#WORK,U#WORK\n*\nLOOP_1   DS    0H\n     UCBSCAN COPY,WORKAREA=U#WORK,UCBAREA=U#COPY,DEVCLASS=DASD,        /\n               DYNAMIC=YES,DEVNCHAR=DEVNCHAR,RANGE=ALL\n     LTR   R15,R15                    did it work\n     BNZ   END_LOOP_1                 no so must be end\n     TM    UCBSTAT,UCBONLI            is it online\n     BZ    LOOP_1                     no so try next\n*\n     CLC   UCBVOLI(1),VOL_PATTERN\n     BE    OK_1\n     CLI   VOL_PATTERN,C'*'\n     BE    OK_1\n     B     LOOP_1\n*\nOK_1 DS    0H\n     CLC   UCBVOLI+1(1),VOL_PATTERN+1\n     BE    OK_2\n     CLI   VOL_PATTERN+1,C'*'\n     BE    OK_2\n     B     LOOP_1\n*\nOK_2 DS    0H\n     CLC   UCBVOLI+2(1),VOL_PATTERN+2\n     BE    OK_3\n     CLI   VOL_PATTERN+2,C'*'\n     BE    OK_3\n     B     LOOP_1\n*\nOK_3 DS    0H\n     CLC   UCBVOLI+3(1),VOL_PATTERN+3\n     BE    OK_4\n     CLI   VOL_PATTERN+3,C'*'\n     BE    OK_4\n     B     LOOP_1\n*\nOK_4 DS    0H\n     CLC   UCBVOLI+4(1),VOL_PATTERN+4\n     BE    OK_5\n     CLI   VOL_PATTERN+4,C'*'\n     BE    OK_5\n     B     LOOP_1\n*\nOK_5 DS    0H\n     CLC   UCBVOLI+5(1),VOL_PATTERN+5\n     BE    OK_6\n     CLI   VOL_PATTERN+5,C'*'\n     BE    OK_6\n     B     LOOP_1\n*\nOK_6 DS    0H\n*\n     BAS   R6,PROCESS_UCB\n     AP    NUM_VOLS,=P'1'\n     AP    TOTAL_FREE,VOLUME_FREE\n     AP    TOTAL_TRACKS,VOLUME_TRACKS\n     B     LOOP_1\n*\nEND_LOOP_1 DS    0H\n*\n   BAS   R4,WRITE_SYSOUT\n*\n   MVC   SYSOUT_REC(L'ED_PL4),ED_PL4\n   ED    SYSOUT_REC(L'ED_PL4),NUM_VOLS\n   CP    NUM_VOLS,=P'0'\n   BNH   NO_VOLS\n   MVC   SYSOUT_REC+10(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+10(L'ED_PL6),TOTAL_TRACKS+2    total tracks\n   ZAP   DOUB_WORD,TOTAL_TRACKS\n   SP    DOUB_WORD,TOTAL_FREE\n   MVC   SYSOUT_REC+25(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+25(L'ED_PL6),DOUB_WORD+2       total used\n   MVC   SYSOUT_REC+40(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+40(L'ED_PL6),TOTAL_FREE+2      total free tracks\n*\n   CP    TOTAL_TRACKS,=P'0'\n   BNH   NO_VOLS\n   ZAP   PL_16,TOTAL_FREE          total number of free tracks\n   MP    PL_16,=P'100000'\n   DP    PL_16,TOTAL_TRACKS        total number of available tra\n   SRP   PL_16(8),64-1,5           shift right, normal rounding\n   MVC   SYSOUT_REC+55(L'ED_PL6D2),ED_PL6D2\n   ED    SYSOUT_REC+55(L'ED_PL6D2),PL_16+2       % free space\n*\nNO_VOLS  DS    0H\n   BAS   R4,WRITE_SYSOUT\n*\n   CLOSE (SYSOUT),MODE=31\n*\n   B     GET_OUT\n*______________________________________________________________________\n*\nPROCESS_UCB    DS    0H\n*\n   MVC   SYSOUT_REC+4(6),UCBVOLI\n*\n   LA    R3,U#COPY\n   LSPACE UCB=(R3),EXPMSG=U#EXPMSG,F4DSCB=U#F4DSCB\n*\n   PACK  DOUB_WORD,U#EXPMSG+6(6)       number of free cylinders\n   CVB   R1,DOUB_WORD                  convert to binary\n   MH    R1,DS4DSTRK                   number of tracks per cyl\n   CVD   R1,DOUB_WORD                  convert to decimal\n   PACK  FREE_TRKS,U#EXPMSG+13(6)      number of extra tracks\n   AP    DOUB_WORD,FREE_TRKS           total free\n   ZAP   VOLUME_FREE,DOUB_WORD\n*\n*\n   LH    R1,DS4DSCYL                   total number of cylinders\n   MH    R1,DS4DSTRK                   number of tracks per cyl\n   CVD   R1,VOLUME_TRACKS              give available tracks\n   MVC   SYSOUT_REC+10(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+10(L'ED_PL6),VOLUME_TRACKS+2     total tracks\n*\n   ZAP   DOUB_WORD,VOLUME_TRACKS\n   SP    DOUB_WORD,VOLUME_FREE\n   MVC   SYSOUT_REC+25(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+25(L'ED_PL6),DOUB_WORD+2         used tracks\n   MVC   SYSOUT_REC+40(L'ED_PL6),ED_PL6\n   ED    SYSOUT_REC+40(L'ED_PL6),VOLUME_FREE+2       free tracks\n*\n   CP    VOLUME_TRACKS,=P'0'\n   BNH   NO_TRACKS\n*\n   ZAP   PL_16,VOLUME_FREE\n   MP    PL_16,=P'100000'\n   DP    PL_16,VOLUME_TRACKS\n   SRP   PL_16(8),64-1,5\n   MVC   SYSOUT_REC+55(L'ED_PL6D2),ED_PL6D2\n   ED    SYSOUT_REC+55(L'ED_PL6D2),PL_16+2         % free space\n*\nNO_TRACKS  DS    0H\n   BAS   R4,WRITE_SYSOUT\n*\n   BR    R6\n*______________________________________________________________________\n*\nWRITE_SYSOUT   DS    0H\n*\n   SAM24\n   PUT   SYSOUT,SYSOUT_REC\n   SAM31\n*\n   MVI   SYSOUT_REC,C' '\n   MVC   SYSOUT_REC+1(L'SYSOUT_REC-1),SYSOUT_REC\n*\n   BR    R4\n*______________________________________________________________________\n*\nPL_16          DS    PL16\nVOL_PATTERN    DS    CL6\n*\nSYSOUT_REC     DC    CL80' '\n*\n*\nSYSOUT   DCB   DDNAME=SYSOUT,MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80\n*\nDEVNCHAR       DC    CL4' '\n*\nL#VOL          DS    CL6\nU#COPY         DS    XL48\nU#WORK         DS    XL100\nU#EXPMSG       DS    XL40\nU#F4DSCB       DS    XL96\n*\nTOT_TRACKS     DC    PL4'50055'\n*\nFREE_TRKS      DC    PL3'0'\nVOLUME_FREE    DC    PL8'0'\nVOLUME_TRACKS  DC    PL8'0'\nTOTAL_FREE     DC    PL8'0'\nTOTAL_TRACKS   DC    PL8'0'\nNUM_VOLS       DC    PL4'0'\n*\nHEAD_L_1 DC  C'Show online DASD volumes matching pattern=XXXXXX'\nHEAD_L_2 DC  C'    volume          total           used           free /\n                        %free'\nHEAD_L_3 DC  C'    ------          -----           ----           ---- /\n                        -----'\nED_PL4         DC    X'40206B2020206B20212060'\nED_PL6         DC    X'4020206B2020206B2020206B20212060'\nED_PL6D2       DC    X'402020206B2020206B2021204B202060'\n*______________________________________________________________________\n*\nSSOB_PTR DS    A(SSOB+X'80000000')\nSSOB_WRK DS    XL(SSOBHSIZ)            SSOB\nSSSA_WRK DS    XL(SSSALN+SSSA1LN+L'SSSA1NMS)\n*______________________________________________________________________\n*\n         LTORG\n*______________________________________________________________________\n*\nVOL_DETS DSECT\n         IECSDSL1 (4)                  GEN FMT 4 DSCB LABELS\nUCB_DETS DSECT\n         IEFUCBOB\nVOLUMESX CSECT\n         CVT   DSECT=YES               CVT\n         IEFJESCT                      JES CVT\n         IEFJSSOB ,                    SSOB HEADER DSECT\n         IEFSSSA                       SSOB EXTENSION FOR SMS\n*        IGDVLD                        VOLUME DEFINITION\n         IGDSGD                        STORAGE GROUP DEFINITION\n*______________________________________________________________________\n*\nVOLUMESX CSECT\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT953/FILE953.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT953", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}