A 'LOGONBY' feature for DMKRPW

One very interesting feature available with a VM security
package is the ability to log-on to a specific user-id (let's call
him Joe), after being correctly identified to the system as a
recognized user (eg Jane) who has been granted the right to use
the Joe virtual machine.

This basically means that more than one person can log-on to a
given virtual machine without the need to publicize passwords.
In this way we can allow 'group' user-ids for several people,
and still maintain security of the target virtual machine.

Over the last few years, there have been quite a few articles in
VM Update on the subject of getting log-on and link passwords
belonging to other users, something that is often needed in the
course of standard systems work. With this 'LOGONBY'
capability, we no longer need nor care what the real log-on
password is, as long as we of the systems group are recognized
as authorized to log-on to other users' virtual machines, using
our own password. The same module in CP that controls
'LOGONBY' access will also allow us to AUTOLOG other
virtual machines without knowing the log-on password of the
target virtual machine.

The CP module DMKRPW is part of the Access Control
Interface (ACI) which is utilized by security products (RACF
etc). In a system where no security package has been installed,
the default 'do-nothing' version of DMKRPW, from IBM, is in
the nucleus. This module is for our use, so here is an example
of what we can do with it.

Whenever a LOGON or AUTOLOG command is performed,
CP invokes the DMKRPW module with an ACIPARMS
workarea. This workarea contains a one byte field called the
ACICODE, where the ACI routine returns its decision. The
valid values for this field include codes denying access,
allowing access even without a password, or deferring the
decision to CP, on the basis of standard password validation.
(The latter is what the default DMKRPW does in all cases.)

In order to reduce the amount of data to be coded in the
DMKRPW module, I did not choose to allow special log-on
and AUTOLOG privileges by user-id, but by ACIGROUP. The
ACIGROUP of a user is set with the ACIGROUP statement in
the system directory, and all users of the same security
classification may be in the same group. In order to add
additional ACIGROUPs to the authorized list, they should be
added to the DMKRPW module, and CP regenerated. Since
this is sometimes inconvenient when the change is needed
immediately, I have put 'dummy' ACIGROUPs into the
module, which can be changed using an STCP command, until
the next IPL can be performed.

The external appearance of the 'LOGONBY' feature that I
wrote, as well as the term itself, are taken from VMSECURE
(from Systems Center). When logging on, DMKRPW is called
before CP prompts for a password. At this time, DMKRPW
will itself request the log-on password (unless it was already
entered on the logo screen). If 'LOGONBY' processing is not
needed, control is returned to CP, which will allow the log-on,
or not, depending on the validity of the password supplied. In
order to request 'LOGONBY' processing, the user performing
the log-on must enter three items of data: the keyword 'BY' to
signify that log-on is not being performed by the actual owner
of the virtual machine; the user-id belonging to the user
performing the 'LOGONBY'; and the directory password for
that user-id. This data may be entered in one input line by
concatenating all three into one string, with only a slash (/) (but
no blanks) between items. For example, if we take the names
mentioned above, and say that Jane is an authorized member of
the systems group, and that her ACIGROUP is known to the
DMKRPW module, then she can log-on to Joe's virtual
machine as follows:

      l joe
      Enter password (it will not appear when typed):
      by/jane/janespwd

Another method of entering the data is in separate input lines.
The enter key may be pressed instead of the slash key, at either
of the two slashes shown in the example above. If enter is
pressed immediately after 'by', the user will be prompted for
the 'byuser' id, and then for that user's password, as follows:

      l joe
      Enter password (it will not appear when typed):
      by
      POLACI062R ENTER LOGONBY USERID:
      jane
      POLACI104R ENTER LOGONBY PASSWORD:
      janespwd

In the example above, Jane could have skipped the 'ENTER
LOGONBY USER ID:' prompt, by typing 'by/jane' in
response to 'Enter password ...'.

The other feature of my DMKRPW is that users belonging to
authorized ACIGROUPs (not the same list of ACIGROUPs
that defines 'LOGONBY' authorization) can perform the CP
AUTOLOG command (if they have the correct CP class),
without any password at all.

In order to install this feature, the following short list of steps
must be completed.

1      Compile the new DMKRPW module from the source
      supplied here in the form of an update file.

2      Compile the accompanying module XMKEPS (which
      performs the prompts) from the Assembler source also
      supplied here.

3      Add module XMKEPS to the CP LOADLIST EXEC
      (CPLOAD, H50CPLOD, etc), immediately following the
      entry for DMKRPW.

4      After backing up your current CP nucleus, regenerate CP,
      and enjoy!

Since the IBM DMKRPW module does nothing, the local mod
is an entire program module. File DMKRPW POLACIBY will
contain the mod. In order to add it to DMKRPW the following
record must be added to the top of DMKRPW AUXSP (or your
local AUX file):

POLACIBY LCL ALLOW LOGONBY, AND AUTOLOG WITHOUT PWD, FOR PRIV ACIGROUPS

Build the update file DMKRPW POLACIBY.


DMKRPW POLACIBY

/ R 00340000          $ 344990 4990                  02/01/91 14:51:29
*        SET ACICODE FIELD TO A VALID VALUE AND RETURN TO ALLE%POLACI
/ I 00410000          $ 415000 5000                  02/01/91 14:51:29
*              R10 - ACIPARMS                                  %POLACI
/ R 00810000          $ 812990 2990                  02/01/91 14:51:29
        USING PSA,0                                           %POLACI
        USING DMKRPW,R12                                      %POLACI
/ R 01070000          $ 1071990 1990                 02/01/91 14:51:29
*        DEFAULT: RETURN TO CALLER WITH RETURN CODE OF 4       %POLACI
*                 (ACIDEFR) IN ACICODE FIELD OF ACIPARMS.      %POLACI
*                                                              %POLACI
*        SPECIAL CASES:                                        %POLACI
/ I 01080000          $ 1080400 400                  02/01/91 14:51:29
*        ACIFCN = ACILOG (USER ATTEMPTING LOGON):              %POLACI
*                                                              %POLACI
*           IF USER ENTERS PWD OF 'BY/UID/PWD', WHERE UID      %POLACI
*           IS USER-ID OF A USER IN A PRIVILEGED ACIGROUP,     %POLACI
*           AND PWD IS CORRECT FOR THAT USER, ALLOW LOG-ON.    %POLACI
*                                                              %POLACI
*        ACIFCN = ACILOG (AUTOLOG):                            %POLACI
*                                                              %POLACI
*           IF REQUESTER IS IN AUTHORIZED ACIGROUP, ALLOW      %POLACI
*              THE AUTOLOG WITH NO PASSWORD.                   %POLACI
*                                                              %POLACI
*        SPECIAL ACIGROUPS FOR AUTOLOG:                        %POLACI
*           THE LIST AT LABEL AUTGST TO AUTGFN IS A DBLWORD    %POLACI
*           ALIGNED GROUP OF 8CHAR ACIGROUP NAMES.             %POLACI
*           DUMMY ENTRIES ARE SET TO '>>>><<<<' TO ENABLE      %POLACI
*           ADDITION WITH STCP, WITHOUT A CP IPL. (REMEMBER    %POLACI
*           TO BUILD A NEW NUC WHEN STORAGE IS CHANGED!)       %POLACI
*           THE LIST HAS A DUMP FLAG OF 'ACILIST:' TO HELP     %POLACI
*           FIND IT.                                           %POLACI
*                                                              %POLACI
./ I 01210000          $ 1212000 2000                 02/01/91 14:51:29
*              SAVEWRK1 - ACICODE TO RETURN                    %POLACI
*              SAVEWRK2-3 - BYUSER USERID, BYUSER PWD RECEIVED %POLACI
*              SAVEWRK4-9 - UDIRBLOK, XMKEPSWD INPUT           %POLACI
1./ R 01250000          $ 1250990 990                  02/01/91 14:51:29
*        EXTERNAL REFERENCES - EXECUTABLE -                    %POLACI
*              XMKEPSWD      - GET USER-ID, PASSWORD           %POLACI
*              DMKUDRFU      - VALIDATE USER-ID                %POLACI
*              DMKUDRMD      - GET UMACBLOK (POR PWD)          %POLACI
*              DMKUDRRV      - RELEASE UMACBLOK PAGE           %POLACI
./ R 01310000          $ 1314990 4990                 02/01/91 14:51:29
*        1. SET DEFAULT ACICODE = ACIDEFR.                     %POLACI
./ I 01320000          $ 1320300 300                  02/01/91 14:51:29
*        2. IF CALLED FOR AN ACICODE OTHER THAN 'LOG-ON'       %POLACI
*           (OR AUTOLOG), THEN RETURN.                         %POLACI
*                                                              %POLACI
*        3. IF AUTOLOG, GO TO STEP 12.                         %POLACI
*                                                              %POLACI
*        4. IF NO PWD RECEIVED YET FROM USER (FROM LOGO SCREEN)%POLACI
*           CALL XMKEPSWD TO GET IT.                           %POLACI
*                                                              %POLACI
*        5. IF PWD BEGINS 'BY/' OR 'BY ', CHECK FOR VALID      %POLACI
*           BYUSER. OTHERWISE RETURN THE PWD TO CALLER.        %POLACI
*                                                              %POLACI
*        6. SETUP INVALID PWD IN CALLERS PWD AREA, TO BE       %POLACI
*           REJECTED BY CALLER IF WE DECIDE TO RETURN CONTROL. %POLACI
*           FOR 'BY/', PARSE FOR USER-ID AND PWD. JOIN COMMON  %POLACI
*           CODE AT 8.                                         %POLACI
*                                                              %POLACI
*        7. PROMPT FOR LOGONBY USER-ID.                        %POLACI
*                                                              %POLACI
*        8. VERIFY THAT USER-ID EXITS, AND IS OF AUTHORIZED    %POLACI
*           ACIGROUP. IF NOT, RETURN TO CALLER.                %POLACI
*                                                              %POLACI
*        9. IF PWD RECEIVED AT STEP 6, SKIP TO 10, OTHERWISE   %POLACI
*           PROMPT FOR BYUSER'S PWD.                           %POLACI
*                                                              %POLACI
*       10. GET UMACBLOK OF BYUSER, AND COMPARE TO RECEIVED    %POLACI
*           PASSWORD. IF EQUAL, SET ACICODE = ACIAUTH.         %POLACI
*                                                              %POLACI
*      11. RETURN UMACBLOK BUFFER, AND RETURN CTL TO CALLER.   %POLACI
*                                                              %POLACI
*      12. ---AUTOLOG ROUTINE---                               %POLACI
*          DESCRIPTION BELOW, AT LABEL RPWAUTO.                %POLACI
*                                                              %POLACI
./ I 01340000          $ 1342000 2000                 02/01/91 14:51:29
         EXTRN XMKEPSWD                                        %POLACI
         EXTRN DMKUDRFU                                        %POLACI
         EXTRN DMKUDRMD                                        %POLACI
         EXTRN DMKUDRRV                                        %POLACI
./ R 01360000 01390000 $ 1360090 90                   02/01/91 14:51:29
         LR    R10,R1              PRESERVE ACIPARMS ADDRESS   %POLACI
         USING ACIPARMS,R10                                    %POLACI
         MVI   SAVEWRK1,ACIDEFR    PREPARE DEFAULT CODE        %POLACI
         CLI   ACIFCN,ACILOG       IS THIS A LOG/AUTOLOG REQ?  %POLACI
         BE    CHKAUTO             VALID FCN, CHECK AUTOLOG REQ%POLACI
         CLI   ACIFCN,ACINPMT      (AUTO)LOG-ON NOPROMPT?      %POLACI
         BNE   RPWLEAVE            NO OTHER SPECIAL CASES      %POLACI
CHKAUTO  CLC   SAVER8(4),=C'AUTO'  IS THIS AN AUTOLOG?         %POLACI
         BE    RPWAUTO             IF SO,CHECK INVOKER'S ACIGRP%POLACI
*                                                              %POLACI
*-----------------------------------------------------------   %POLACI
* HERE WE CHECK IF USER LOGGING ON CAN 'LOGONBY'               %POLACI
*-----------------------------------------------------------   %POLACI
*                                                              %POLACI
*  1ST, ENSURE THAT ONLY WE ASK FOR PWDS!                      %POLACI
         L     R1,SAVER13          GET CALLER'S SAVE AREA      %POLACI
         MVC   SAVEWRK8-SAVEAREA(8,R1),ZEROES                  %POLACI
         CLI   ACIPASS,NULL        PWD ALREADY IN?             %POLACI
         BE    ACIMSG1             IF NOT, ASK FOR IT          %POLACI
         CLI   ACIPASS+20,NULL     DOES PWD END BY 20TH CHAR?  %POLACI
         BNE   RPWLEAVE            >20! RETURN TO CALLER       %POLACI
*                                                              %POLACI
* NOW SCAN ACIPASS FOR FIRST NULL. (ACIPASS IS NOT PADDED WITH %POLACI
* BLANKS!) COPY CHARS TILL NULL INTO XMKEPSWD INPUT AREA AT    %POLACI
* SAVEWRK5, WITH BLANK PADDING.                                %POLACI
*                                                              %POLACI
         MVI   SAVEWRK5,BLANK      START TO CLEAN OUR BUFFER   %POLACI
         MVC   SAVEWRK5+1(19),SAVEWRK5   CLEAN UP THE REST     %POLACI
*                                                              %POLACI
         LA    R4,ACIPASS          1ST CHAR OF PWD STRING      %POLACI
         LA    R2,1                INCREMENT, CHK 1 CHAR/LOOP  %POLACI
         LA    R3,ACIPASS+20       TILL DEFINITE NULL          %POLACI
ACIPWL   EQU   *                   CHECK FOR DELIMITER         %POLACI
         CLI   0(R4),NULL          FOUND NULL                  %POLACI
         BE    ACICOPY             GO COPY ACIPASS             %POLACI
         BXLE  R4,R2,ACIPWL        CONTINUE SCAN               %POLACI
*                                                              %POLACI
ACICOPY  EQU   *                                               %POLACI
         LA    R1,ACIPASS          ADDRESS OF START            %POLACI
         SR    R4,R1               GET LENGTH TILL NULL        %POLACI
         BCTR  R4,0                DECREMENT FOR EXECUTE       %POLACI
         EX    R4,MOVACIPW         COPY ACI PWD, TO BLANK PAD  %POLACI
         B     CHKBY0              GO CHECK FOR 'BY'           %POLACI
ACIMSG1  LA    R0,RPWMS1      POINT TO MSG FOR XMKEPS          %POLACI
         LA    R1,SAVEWRK5    R1 POINTS TO 20BYTE BUFFER       %POLACI
         CALL  XMKEPSWD       ASK FOR PASSWORD NOW             %POLACI
         BNZ   RPWLEAVE       PWD TOO LONG, OR TERM ERR        %POLACI
CHKBY0   CLC   SAVEWRK5(2),BY2     WAS IT 'BY...'?             %POLACI
         BE    CHKBY1              SEE NEXT CHAR ...           %POLACI
*                                                              %POLACI
* WE GOT USER'S PWD BUT NOT 'BY'. LET DMKLOG USE IT.           %POLACI
*                                                              %POLACI
         L     R1,SAVER13          GET CALLER'S SAVE AREA      %POLACI
         MVC   SAVEWRK8-SAVEAREA(8,R1),SAVEWRK5 COPY OUR WRK5  %POLACI
*                                  TO CALLERS WRK8-9           %POLACI
         B     RPWLEAVE                                        %POLACI
*                                                              %POLACI
* NOW SEE IF 'BY' IS FOLLOWED BY BLANK - PROMPT FOR USER-ID    %POLACI
*                             BY '/'   - SCAN FOR USER-ID      %POLACI
*                             ANYTHING ELSE : LIKE NO 'BY'     %POLACI
CHKBY1   EQU   *                                               %POLACI
         XR    R8,R8               IF SLASHES, R8-9 HOLD PWD   %POLACI
         XR    R9,R9               SO WE CLEAN THEM 1ST.       %POLACI
         CLI   SAVEWRK5+2,BLANK    'BY ' ?                     %POLACI
         BNE   CHKSLSH1            GO CHECK 'BY/'              %POLACI
*                                                              %POLACI
* IF 'BY ', ASK FOR USER-ID.                                   %POLACI
*                                                              %POLACI
         LA    R0,RPWMS2      POINT TO MSG FOR XMKEPS          %POLACI
         LA    R1,SAVEWRK5    R1 POINTS TO 20BYTE BUFFER       %POLACI
         CALL  XMKEPSWD       ASK FOR LOGONBY USER-ID NOW      %POLACI
         BNZ   RPWLEAVE       PWD TOO LONG OR TERM ERR         %POLACI
         MVC   SAVEWRK2(8),SAVEWRK5   MOVE LOGONBY UID         %POLACI
         B     BYCOMNU             COMMON 'USERID' CODE        %POLACI
*-----------------------------------------------------------   %POLACI
* HERE WE CHECK BY/.... INPUT. IF 2ND SLASH FOUND, THE         %POLACI
*      ACTUAL PWD WILL BE STORED (TILL LABEL XXX) IN R8-9      %POLACI
*      SINCE CALLING DMKUDRFU CLOBBERS THE XMKEPSWD INPUT.     %POLACI
*-----------------------------------------------------------   %POLACI
CHKSLSH1 CLI   SAVEWRK5+2,SLASH                                %POLACI
         BNE   RPWLEAVE            NOT LOGONBY FMT, RETURN IT  %POLACI
*                                                              %POLACI
* NOW WE MUST LOOP OVER THE FIRST 8 CHARACTERS AFTER THE '/',  %POLACI
* TO GET THE LOGONBY USER-ID. WHEN WE FIND THE FIRST '/' OR    %POLACI
* BLANK, (SIGNIFYING END OF USER-ID) WE MOVE THE USER-ID TO    %POLACI
* SAVEWRK2-3.                                                  %POLACI
* IF 'END-OF-USERID' WAS FOUND BY BLANK, BRANCH TO BYCOMNU,    %POLACI
* COMMON CODE FOR CHECKING 'BYUSER' ID. IT WILL THEN PROMPT    %POLACI
* FOR THE PASSWORD.                                            %POLACI
* IF END WAS FOUND BY A SLASH ('/'), CHECK FOR A BLANK AFTER   %POLACI
* IT. IF NOT FOLLOWED BY BLANK, LOAD THE FIRST 8 CHARS         %POLACI
* (BYUSER PASSWORD) TO REG8-9. THIS WILL PREVENT CODE AFTER    %POLACI
* BYCOMNU FROM PROMPTING AGAIN FOR PWD.                        %POLACI
*                                                              %POLACI
         LA    R4,SAVEWRK5+3       1ST CHAR AFTER '/'          %POLACI
         LA    R2,1                INCREMENT, CHK 1 CHAR/LOOP  %POLACI
         LA    R3,8(0,R4)          TILL '/' AFTER 8 CHARS      %POLACI
BYUSCN   EQU   *                   CHECK FOR DELIMITER         %POLACI
         CLI   0(R4),SLASH         FOUND SLASH?                %POLACI
         BE    RPBYUID             GO SAVE BYUSER ID           %POLACI
         CLI   0(R4),BLANK         FOUND BLANK                 %POLACI
         BE    RPBYUID             GO SAVE BYUSER ID           %POLACI
         BXLE  R4,R2,BYUSCN        CONTINUE SCAN               %POLACI
* IF WE FALL THRU HERE, IT MEANS WE SCANNED 8 CHARS, AND THE   %POLACI
* NEXT POS DID -NOT- HAVE A SLASH! SINCE 9 CHAR UID IS NOGOOD, %POLACI
* RETURN TO DMKLOG WITH JUNK IN PWD FIELD.                     %POLACI
         B     RPWLEAVE                                        %POLACI
RPBYUID  MVC   SAVEWRK2(8),BLANKS  PREPARE UID FIELD           %POLACI
         LR    R1,R4               ADDRESS OF DELIMITER        %POLACI
         LA    R2,SAVEWRK5+3       1ST CHAR OF UID AGAIN       %POLACI
         SR    R1,R2               GET LENGTH OF FIELD         %POLACI
         BCTR  R1,0                DECREMENT FOR EXECUTE       %POLACI
         EX    R1,MOVUID           COPY UID TO SAVEWRK2-3      %POLACI
         CLI   0(R4),BLANK         WAS DELIMITER A BLANK?      %POLACI
         BE    BYCOMNU             JOIN COMMON UID CODE        %POLACI
* DELIMITER MUST BE SLASH ('/') IF WE GOT HERE!                %POLACI
         CLI   1(R4),BLANK         IS SLASH FOLLOWED BY BLANK? %POLACI
         BE    RPWLEAVE            NO PWD! FLUNK HIM!          %POLACI
* JUST ENSURE THAT PWD GIVEN IS <= 8 CHARACTERS.               %POLACI
* IF SO, WE CAN LOAD IT FOR FUTURE CHECKING.                   %POLACI
         CLI   9(R4),BLANK         DOES PWD END BY 9TH CHAR?   %POLACI
         BNE   RPWLEAVE            NO SENSE CHECKING BYUSER    %POLACI
         ICM   R8,B'1111',1(R4)    1ST HALF OF USER PWD        %POLACI
         ICM   R9,B'1111',5(R4)    2ND HALF OF USER PWD        %POLACI
*                                                              %POLACI
* COMMON CODE TO CHECK 'BYUSER' ID. WE GET HERE EITHER AFTER   %POLACI
* ASKING FOR BYUSER ID (WITH XMKEPSWD) OR AFTER SCANNING       %POLACI
* SUPPLIED ACIPASS AFTER THE FIRST SLASH.                      %POLACI
* IN EITHER CASE, THE USER-ID IS NOW IN SAVEWRK2-3. WE CALL    %POLACI
* DMKUDRFU TO VERIFY USER'S EXISTENCE, AND THEN WE CAN CHECK   %POLACI
* ACIGROUP, AND COMPARE PASSWORDS.                             %POLACI
*                                                              %POLACI
BYCOMNU  EQU   *                                               %POLACI
         LA    R0,L'VMUSER         LENGTH OF USER-ID           %POLACI
         LA    R1,SAVEWRK2         ADDRESS OF UID IN QUESTION  %POLACI
         LA    R2,SAVEWRK4         UDIRBLOK TO WRK4-9          %POLACI
         CALL  DMKUDRFU            VALIDATE UID                %POLACI
         BNZ   RPWLEAVE            IF NOSUCH, RETURN           %POLACI
         TM    SAVEWRK4+(UDIRFLG1-UDIRBLOK),UDIRNLG+UDIRPRF    %POLACI
*                                  INVALID USER?               %POLACI
         BNZ   RPWLEAVE            IF SO, RETURN               %POLACI
*----------------------------------------------------------    %POLACI
*  SCAN ACIGROUPS TO SEE IF THE GUY HAS A CHANCE.              %POLACI
*----------------------------------------------------------    %POLACI
         LA    R4,LBYGST           START OF AUTH GRPS          %POLACI
         LA    R2,8                SIZE OF EACH GROUP NAME     %POLACI
         LA    R3,LBYGFN           END OF AUTH GROUPS          %POLACI
LBYGRP   EQU   *                   CHECK FOR AUTH GROUP NAME   %POLACI
         CLC   0(8,R4),SAVEWRK4+(UDIRGRPN-UDIRBLOK)            %POLACI
*                                  IS BYUSER'S GROUP IN LIST?  %POLACI
         BE    RPBYPWD             GO CHECK BYUSER'S PWD       %POLACI
         BXLE  R4,R2,LBYGRP        CONTINUE SCAN               %POLACI
*                                                              %POLACI
* SEARCH EXHAUSTED, BUT BYUSER'S ACIGROUP NOT FOUND.           %POLACI
         B     RPWLEAVE            RETURN WITH CODE=DEFER      %POLACI
*-----------------------------------------------------------   %POLACI
* NOW WE KNOW THE BYUSER IS VALID, LETS CHECK HIS PWD.         %POLACI
*-----------------------------------------------------------   %POLACI
RPBYPWD  EQU   *                                               %POLACI
         C     R8,F0               WAS PWD ENTERED W/SLASHES?  %POLACI
         BNZ   CHKSLSH2            REBUILD INTO SAVEWRK2       %POLACI
*                                                              %POLACI
* SINCE PWD WAS NOT PREVIOUSLY RECEIVED (FROM ACIPASS), WE     %POLACI
* MUST PROMPT FOR IT WITH XMKEPSWD. HOWEVER, BEFORE WE DO,     %POLACI
* WE NEED TO SAVE UDIRDASD, WHICH IS IN SAVEWRK4+4 (SAVEWRK5). %POLACI
* WE'LL STASH IT FOR A MOMENT INTO R7!                         %POLACI
*                                                              %POLACI
*                                                              %POLACI
         L     R7,SAVEWRK5         KEEP UDIDASD SAFE!          %POLACI
         LA    R0,RPWMS3      POINT TO MSG FOR XMKEPS          %POLACI
         LA    R1,SAVEWRK5    R1 POINTS TO 20BYTE BUFFER       %POLACI
         CALL  XMKEPSWD       ASK FOR BYUSER PASSWORD NOW      %POLACI
         BNZ   RPWLEAVE       PWD TOO LONG OR TERM ERR         %POLACI
         MVC   SAVEWRK2(8),SAVEWRK5   MOVE BYUSER'S PWD        %POLACI
         ST    R7,SAVEWRK5         RESTORE UDIRDASD            %POLACI
         B     BYCOMNP             COMMON 'PASSWORD' CODE      %POLACI
*                                                              %POLACI
CHKSLSH2 EQU   *                                               %POLACI
* COME HERE IF R8-9 ARE NOT = X'0'. THIS MEANS THAT A PWD      %POLACI
* WAS FOUND AT CHKSLSH1 AND SAVED FOR HERE.                    %POLACI
* SET IT UP IN SAVEWRK2-3                                      %POLACI
*                                                              %POLACI
         STCM  R8,B'1111',SAVEWRK2 1ST HALF OF USER PWD        %POLACI
         STCM  R9,B'1111',SAVEWRK3 2ND HALF OF USER PWD        %POLACI
*                                                              %POLACI
* COMMON CODE TO CHECK 'BYUSER' PWD. WE GET HERE EITHER AFTER  %POLACI
* ASKING FOR BYUSER PWD (WITH XMKEPSWD) OR AFTER SCANNING      %POLACI
* SUPPLIED ACIPASS AFTER THE SECOND SLASH.                     %POLACI
* IN EITHER CASE, THE PWD IS NOW IN SAVEWRK2-3. WE GET FREE    %POLACI
* STORAGE FOR THE UMACBLOK, AND CALL DMKUDRMD, IN ORDER TO     %POLACI
* COMPARE PASSWORDS.                                           %POLACI
*                                                              %POLACI
BYCOMNP  EQU   *                                               %POLACI
         LA    R0,UDBFSIZE*2+2 COMPUTE SIZE OF UDBFBLOKS       %POLACI
         CALL  DMKFREE        ACQUIRE BUFFER                   %POLACI
         LR    R2,R1          SAVE UDBFBLOK BUFFER ADDRESS     %POLACI
         USING UDBFBLOK,R2                                     %POLACI
         XC    UDBFVADD(8),UDBFVADD  CLEAR PAGE ADDRESS FIELD  %POLACI
         DROP  R2                                              %POLACI
*  SAVEWRK4-5 STILL HAVE UDIRDISP+DASD AT +2                   %POLACI
         LA    R1,SAVEWRK4+(UDIRDISP-UDIRBLOK)                 %POLACI
*                                  GET DASD INFO FOR DMKUDRMD  %POLACI
         CALL  DMKUDRMD       GO READ UMACBLOK                 %POLACI
         BNZ   FRTUDBFB       DIRECTORY ERROR!? R2 = A(BUFFER) %POLACI
         USING UMACBLOK,R2                                     %POLACI
         CLC   SAVEWRK2(L'UMACPASS),UMACPASS  COMPARE PASSWORD %POLACI
         DROP  R2                                              %POLACI
         BNE      FRTUDBFB         FRET THE UDBFBLOK           %POLACI
         MVI   SAVEWRK1,ACIAUTH    WOW! HE DID IT!             %POLACI
         LR    R9,R2               SAVE BUFFER ADDR AROUND MSG %POLACI
         LA    R0,L'LBYSUCC   'SUCCESSFUL' MSG LENGTH          %POLACI
         LA    R1,LBYSUCC     'SUCCESSFUL' MSG ADDR            %POLACI
         CALL  DMKQCNWT,PARM=NORET SHOUT IT OUT!               %POLACI
         LR    R2,R9               RESTORE BUFF ADDR           %POLACI
FRTUDBFB EQU   *                                               %POLACI
         CALL  DMKUDRRV       RELEASE VIRT. PAGE SLOT AT R2.   %POLACI
         LR    R1,R2          POINTER TO UDBFBLOK FOR DMKFRET  %POLACI
         LA    R0,UDBFSIZE*2+2  THE SIZE WE'VE BEEN USING      %POLACI
         CALL  DMKFRET        AND GIVE IT BACK (WITH THANKS)   %POLACI
         B     RPWLEAVE            RETURN WITH CODE=AUTH       %POLACI
*                                                              %POLACI
*-----------------------------------------------------------   %POLACI
* HERE WE CHECK IF USER AUTOLOGGING NEEDS A PWD                %POLACI
*-----------------------------------------------------------   %POLACI
*  1. FIND ACIGROUP OF REQUESTING USER:                        %POLACI
*     SAVER10 HAS AVMBLOCK OF AUTOLOGGING USER                 %POLACI
*     VMCGRPN (IN VMBLOCK) HAS GROUP NAME OF INVOKING USER     %POLACI
*  2. LOOP OVER AUTHORIZED GROUP NAMES, FROM SYSGST TO         %POLACI
*     SYSGFN. IF REQUESTER NOT INCLUDED, EXIT AT RPWLEAVE      %POLACI
*  3. IF REQUESTER IS AUTHORIZED TO AUTOLOG A USER             %POLACI
*     WITHOUT ENTERING A PASSWORD, PREPARE ACIAUTH IN WRK1     %POLACI
*  4. B  RPWLEAVE TO RETURN.                                   %POLACI
*************************************************************  %POLACI
RPWAUTO  EQU   *                   CHECK IF ELIGIBLE TO AUTLOG %POLACI
*                                  WITHOUT ENTERING A PASSWORD.%POLACI
         L     R5,SAVER10          GET CALLERS R10, VMBLOK PTR %POLACI
         LA    R4,AUTGST           START OF AUTH GRPS          %POLACI
         LA    R2,8                SIZE OF EACH GROUP NAME     %POLACI
         LA    R3,AUTGFN           END OF AUTH GROUPS          %POLACI
RPWGRP   EQU   *                   CHECK FOR AUTH GROUP NAME   %POLACI
         CLC   0(8,R4),VMCGRPN-VMBLOK(R5)  IS CALLER IN LIST?  %POLACI
         BE    RPALLOWA            GO ALLOW AUTOLOG            %POLACI
         BXLE  R4,R2,RPWGRP        CONTINUE SCAN               %POLACI
         B     RPWLEAVE            RETURN WITH CODE=DEFER      %POLACI
RPALLOWA MVI   SAVEWRK1,ACIAUTH    SET CODE TO 'OK!'           %POLACI
         B     RPWLEAVE            RETURN WITH CODE=AUTH       %POLACI
* HERE IS THE GENERAL EXIT POINT FROM ALL DMKRPW ROUTINES.     %POLACI
RPWLEAVE MVC   ACICODE,SAVEWRK1    LOAD CHOSEN CODE            %POLACI
         EXIT                                                  %POLACI
*                                                              %POLACI
./ I 01400000          $ 1400100 100                  02/01/91 14:51:29
*-----------------------------------------------------------   %POLACI
* HERE ARE PROMPTS/MSGS DISPLAYED BY XMKEPSWD/DMKQCNWT         %POLACI
*-----------------------------------------------------------   %POLACI
RPWMS1   DC    AL1(L'RPWMS1T)                                  %POLACI
RPWMS1T  DC C'ENTER PASSWORD (IT WILL NOT APPEAR WHEN TYPED):' %POLACI
RPWMS2   DC    AL1(L'RPWMS2T)                                  %POLACI
RPWMS2T  DC    C'POLACI062R ENTER LOGONBY USERID:'             %POLACI
RPWMS3   DC    AL1(L'RPWMS3T)                                  %POLACI
RPWMS3T  DC    C'POLACI104R ENTER LOGONBY PASSWORD:'           %POLACI
LBYSUCC  DC    C'POLACILBY! SUCCESSFUL LOGONBY!'               %POLACI
* EXECUTED COMMANDS                                            %POLACI
         DS    0F                                              %POLACI
MOVUID   MVC   SAVEWRK2(*-*),SAVEWRK5+3 ID AFTER BY/ TO WRK2-3 %POLACI
MOVACIPW MVC   SAVEWRK5(*-*),ACIPASS    COPY ACIPASS TO BUF    %POLACI
BY2      DC    CL2'BY'                                         %POLACI
BLANK    EQU   C' '                                            %POLACI
SLASH    EQU   C'/'                                            %POLACI
NULL     EQU   X'00'                                           %POLACI
* HERE IS THE LIST OF ACIGROUPS THAT CAN AUTOLOG W/O PWD       %POLACI
         DS    0D                  ALIGNMENT                   %POLACI
         DC    C'AUTOLOG '         DUMP FLAG 1                 %POLACI
         DC    C'ACILIST:'         DUMP FLAG 2                 %POLACI
AUTGST   EQU   *                   START OF AUTH GRPS          %POLACI
         DC    CL8'SYSGROUP'       SYSTEM GROUP                %POLACI
         DC    CL8'ADMGROUP'       ADMINISTRATION GROUP        %POLACI
         DC    CL8'>>>><<<1'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<2'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<3'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<4'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<5'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<6'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<7'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<8'       DUMMY ACIGROUP              %POLACI
AUTGFN   DC    8X'AB'              END OF AUTH GROUPS          %POLACI
* HERE IS THE LIST OF ACIGROUPS THAT CAN DO 'LOGONBY'          %POLACI
         DS    0D                  ALIGNMENT                   %POLACI
         DC    C'LOGONBY '         DUMP FLAG 1                 %POLACI
         DC    C'ACILIST:'         DUMP FLAG 2                 %POLACI
LBYGST   EQU   *                   START OF AUTH GRPS          %POLACI
         DC    CL8'SYSGROUP'       SYSTEM GROUP                %POLACI
         DC    CL8'ADMGROUP'       ADMINISTRATION GROUP        %POLACI
         DC    CL8'>>>><<<1'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<2'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<3'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<4'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<5'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<6'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<7'       DUMMY ACIGROUP              %POLACI
         DC    CL8'>>>><<<8'       DUMMY ACIGROUP              %POLACI
LBYGFN   DC    8X'AB'              END OF AUTH GROUPS          %POLACI
*                                                              %POLACI
./ I 01420000          $ 1423000 3000                 02/01/91 14:51:29
         COPY  VMBLOK                                          %POLACI
         COPY  UDIRECT                                         %POLACI
./ I 01430000          $ 1435000 5000                 02/01/91 14:51:29
         PSA                                                   %POLACI

Compile the accompanying module XMKEPS (which performs
the prompts) from the Assembler source also supplied here.


XMKEPS ASSEMBLE

EPS      TITLE 'XMKEPS  FOR  VM/SP   * VIRTUAL MACHINE SYSTEM PRODUCT'
***                        XMKEPS                                   ***
***    BASED ON DMKEPS ((C) IBM), DISPLAYS A PROMPTING MESSAGE      ***
***    AND GETS A USER REPLY (PASSWORD, ETC.).                      ***
         ISEQ  73,80          VALIDATE SEQUENCING OF SYSIN
*
* MODULE NAME -
*        XMKEPS
* FUNCTION -
*        TO PROMPT THE USER TO ENTER A PASSWORD,
*        READ THE PASSWORD FROM THE
*        TERMINAL, AND RETURN IT TO CALLER.
* ATTRIBUTES -
*        REENTRANT, PAGEABLE, CALLED VIA SVC
* ENTRY POINT -
*        XMKEPSWD
* ENTRY CONDITIONS -
*        GPR  0 = ADDRESS OF MSG CONSTANT TO DISPLAY, AS FOLLOWS:
*                 AL1(L'MSGTEXT),CL(NN)'MSGTEXT'
*        GPR  1 = ADDRESS OF 20 BYTE (5 WRD) BUFFER FOR PWD RECEIVED.
*        GPR 11 = ADDRESS OF USER'S VMBLOK
*        GPR 12 = ADDRESS OF XMKEPSWD
*        GPR 13 = ADDRESS OF STANDARD SAVE AREA
*
* EXIT CONDITIONS -
*        CC = 0 IF SUCCESSFUL
*        CC = 2 IF PWD TOO LONG
*        CC = 3 IF PERMANENT ERROR ON TERMINAL
* CALLS TO OTHER ROUTINES -
*        DMKFREE  - OBTAIN FREE STORAGE
*        DMKQCNWT - SEND PROMPTING MESSAGE TO TERMINAL
*        DMKQCORD - READ PASSWORD FROM TERMINAL
*        DMKDSPCH - GO TO 'DISPATCH' WHILE AWAITING PASSWORD
*        DMKSCNFD - GET PASSWORD FROM TERMINAL INPUT LINE
*        DMKFRET  - RETURN FREE STORAGE
*
* EXTERNAL REFERENCES -
*        NONE
* TABLES / WORK AREAS / CONTROL BLOCKS
*        VMBLOK
* REGISTER USAGE -
*        GPR   9   = ADDRESS OF COMMAND BUFFER
*        GPR  11   = VMBLOK ADDRESS
*        GPR  12   = BASE REGISTER
*        GPR  13   = ADDRESS OF STANDARD SAVE AREA
*        GPRS 0-4 AND 14-15 ARE WORK REGISTERS
*        GPR 3, 6-8, AND 10 ARE NOT USED
* NOTES -
*        THIS MODULE WAS COPIED FROM DMKEPS, AND CHANGED TO ALLOW
*        VARIABLE PROMPT MESSAGES, AND TO RETURN ENTIRE USER PWD,
*        UP TO 20 CHARACTERS.
         EJECT
* OPERATION -
*        1. TYPES PROMPTING MESSAGE SPECIFIED BY GPR 0 AT INPUT.
*        2.  CALLS DMKFREE TO GET A BUFFER INTO WHICH TO READ THE
*        PASSWORD.
*        3. DMKQCORD IS CALLED TO HAVE THE PASSWORD ENTERED, AND
*        CONTROL IS THEN TRANSFERRED TO DMKDSPCH, WITH THE RETURN
*        SPECIFIED TO COME BACK TO STEP 4 WHEN THE PASSWORD HAS BEEN
*        ENTERED.
*        4.  WHEN THE PASSWORD HAS BEEN ENTERED, XMKEPSWD CHECKS FOR
*        A PERMANENT ERROR ON THE TERMINAL (WHICH COULD OCCUR, FOR
*        EXAMPLE, IF THE USER TURNED OFF THE TERMINAL INSTEAD OF
*        ENTERING THE PASSWORD, OR IF THE COMMUNICATIONS LINE OPENED);
*        IF SO, RETURNS THE FREE STORAGE AND EXITS TO THE CALLER WITH
*        A CONDITION-CODE 3.
*        IF THERE WAS NO PROBLEM OF THIS KIND, XMKEPSWD CHECKS FOR
*        A ZERO BYTE COUNT (IE NULL LINE WAS ENTERED).  IF YES, GOES
*        TO STEP 9.
*        5.  OTHERWISE, BLANK-FILLS A 20-BYTE AREA SUPPLIED BY CALLER,
*        CALLS DMKSCNFD TO OBTAIN THE PASSWORD.  IF THE LINE WAS BLANK,
*        GOES TO STEP 9.  IF THE PASSWORD WAS MORE THAN 20 BYTES,
*        TREATS AS AN ERROR (RETURNS CONDITION-CODE 2 TO THE CALLER
*        AFTER RETURNING THE FREE STORAGE IN STEP 7).
         EJECT
*        6.  IF THE PASSWORD IS NOT NULL, AND NO MORE THAN 20 BYTES,
*        THEN IT IS SAVED IN CALLERS PARMAREA.
*        7.  THE FREE STORAGE USED FOR THE INPUT BUFFER IS NOW RETURNED
*        VIA A CALL TO DMKFRET.
*        8.  (STEP REMOVED)
*        9.  IF A NULL OR BLANK LINE WAS ENTERED, THEN
*        REJOINS MAIN LOGIC AT STEP 3 ABOVE, TO HAVE THE USER
*        ENTER THE PASSWORD AGAIN.
*
         EJECT
         COPY OPTIONS
         COPY LOCAL
         EJECT
XMKEPS   CSECT
         DC    C'XMKEPS  '         MODULE IDENTIFIER
         EXTRN DMKQCORD
         EXTRN DMKSCNFD
         USING PSA,R0
         USING VMBLOK,R11
         USING SAVEAREA,R13
         SPACE
         ENTRY XMKEPSWD       LOCAL "ENTER PASSWORD" ENTRY
         USING XMKEPSWD,R12
         SPACE
XMKEPSWD ENTER                "ENTER PASSWORD" ENTRY
         TM    VMOSTAT,VMKILL IS THE USER BEING LOGGGED OFF?
         BO    SETCC3         YES--EXIT WITH CC=3
* SET UP MSG TO DISPLAY
         L     R4,SAVER0           GET ADDRESS OF LLXXXXXXX...
         XR    R0,R0               1ST CLEAR IT
         IC    R0,0(,R4)           GET 1BYTE LENGTH FIELD
         LA    R1,1(R4)            A(MSG)
         CALL  DMKQCNWT,PARM=NORET DISPLAY THE PROMPT MSG
         LA    R0,BUFSIZE     NOW WE NEED AN INPUT BUFFER
         CALL  DMKFREE        GET ONE FOR THE PASSWORD
         LR    R9,R1          INTO R9 THE ADDRESS SHALL GO
ENTP03   EQU   *              READ THE RESPONSE
         LA    R0,BUFINLTH-2  SET EXPECTED INPUT COUNT
         LR    R1,R9          RESTORE R1 IN CASE RETRYING READ
         CALL  DMKQCORD,PARM=(EDIT+UCASE+INHIBIT)
         BZ    ENTP04         ALL OK - CHECK COUNT
         C     R2,F8          ATTN OR LINE DROP?
         BH    ENTP13         LINE DROP - EXIT GRACEFULLY
         B     ENTP03         RETRY THE READ
         EJECT
1ENTP04   EQU   *              CHECK FOR VALID INPUT COUNT
         LTR   R2,R0          BE CAREFUL OF ZERO INPUT COUNT
         BNP   ENTP03         TRY AGAIN IF NULL LINE
         USING BUFFER,R9
         STM   R1,R2,BUFNXT   STORE POINTER AND COUNT FOR SCANFLD
         L     R4,SAVER1           GET ADDRESS OF 5WRD BUFFER
         MVI   0(R4),BLANK         BLANK-FILL 1ST CHR FOR PWD
         MVC   1(19,R4),0(R4)      SHMEER 19 MORE BYTES
         CALL  DMKSCNFD       GET THE PASSWORD
         BNZ   ENTP03         TRY AGAIN IF NULL INPUT
         C     R0,F20         PASSWORD MORE THAN 20 BYTES ?
         BH    PAS2LONG       BRANCH IF PASSWORD > 20 BYTES
         LR    R15,R0
         BCTR  R15,0
         EX    R15,SAVEPASS   SAVE PASSWORD
PASSFRET LA    R0,BUFSIZE     NOW GIVE BACK THE INPUT BUFFER
         LR    R1,R9          ...
         CALL  DMKFRET        ...
         CR    R0,R0               SET CC=0
PASSEXIT DS    0H             EXIT WITH CONDITION-CODE SET
         EXIT
PAS2LONG DS    0H             HANDLE PASSWORD > 8 BYTES LONG
         LA    R0,BUFSIZE     NOW GIVE BACK THE INPUT BUFFER
         LR    R1,R9          ...
         CALL  DMKFRET        ...
         CL    R12,ZEROES          SET CC=2
         B     PASSEXIT            RETURN
         SPACE
*        FATAL ERROR FROM TERMINAL ON ENTRY OF PASSWORD:              *
ENTP13   LA    R0,BUFSIZE     GIVE BACK THE FREE STORAGE BUFFER
         LR    R1,R9          ...
         CALL  DMKFRET        ...
SETCC3   ST    R11,SAVER11    BE SURE TO RETURN CORRECT R11
         TM    FFS,X'FF'      SET CONDITION-CODE 3
         EXIT                 AND EXIT FORTHWITH.
         DROP  R9,R12
         EJECT
BLANK    EQU   C' '
*        EXECUTED INSTRUCTION
SAVEPASS MVC   0(*-*,R4),0(R1)     TO SAVE THE PASSWORD
         SPACE 1
         LTORG
         EJECT
         PSA                  (R0)
         COPY  SAVE           (R13)
         COPY  VMBLOK         (R11)
         COPY  EQU
         COPY  CONBUF
         END

Add module XMKEPS to the CP LOADLIST EXEC
(CPLOAD, H50CPLOD, etc), immediately following the entry
for DMKRPW.

In the LOADLIST EXEC used to build your VM system, find
the line defining DMKRPW:

      &1 &2 &3 DMKRPW

Add the following line immediately below it:

      &1 &2 &3 XMKEPS

Since XMKEPS is a very small module (less than a quarter of
1KB), this ensures that it will be in the same nucleus page as
DMKRPW, and will not be paged out when DMKRPW is
active.

Always back up your current nucleus before making the
slightest change in CP! I hope you find the 'LOGONBY'
feature as great a convenience as I do.


Shimon Lebowitz
VM Systems Programmer
Israel Police National HQ (Israel)                    Israel Police 1992

