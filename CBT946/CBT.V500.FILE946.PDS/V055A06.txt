PROP routing routine

Our shop relies heavily on PROP because we have 14 MVS
guests and 25 service machines that all run disconnected.  We
needed the ability to dynamically change which CMS users
receive PROP messages.  Although this feature can be done
through the NICKNAMES facility, it is a bulky and expensive
way of maintaining a dynamic list of users.

Our SMSPOS package was developed to allow a CMS user to
add or delete himself from an alternative operator list.  Any
user who has ALTOPS turned on will receive messages from
PROP.  Users can also limit who they receive PROP messages
from.  For example, CMS1 can set up ALTOPS to receive
messages that come from only MVS2.

SMSPOS serves as a replacement for the IBM DMSPOS
module.  The SMSPOS module is added to PROPLIB
LOADLIB and is called from the routing table.

Not only does SMSPOS provide flexibility, but it is also
significantly faster than DMSPOS, especially in VM/SP.  This
code has been tested under VM/SP HPO Release 5 and
VM/XA SP Release 2.

SMSPOS consists of the following parts:

o      Ten Assembler files: SMSPOS, SMSPOSMN,
      SMSPOSAB, PATTERN, QBUILD, QFRET, QGET,
      QLOC, QPUSH, QPURGE.

o      Seven macros: QMNT, QHEAD, QENTRY, QPLIST,
      OPSDATA, CMSSVC, PSWD.

o      A linkedit control file: SMSPOS LKEDCTRL.

o      Two EXECs: ALTOPS, ISMSPOS

o      A message repository: SMSUME REPOS.

o      A definition language for command syntax (DLCS) file:
      SMSUPA DLCS.

Assemble each of the 10 source files to create TEXT decks.
Copy your current PROPLIB LOADLIB to your A disk and
link the SMSPOS module into it by issuing VMFLKED
SMSPOS.

Generate the SMS language files by entering:

      GENMSG SMSUME REPOS A SMS AMENG

and

      CONVERT COMMANDS SMSUPA (USER

The output from these commands is three TEXT files that
should be copied to a shared disk so all CMS users have access
to them.  (These commands are documented in the CMS
Application Development Guide.)

The ALTOPS EXEC should also reside on a shared CMS disk.
This EXEC is a user-friendly front-end for SMSPOS.

Use the ISMSPOS EXEC to load SMSPOS as a nucleus
extension. We put this code in the operator's PROFILE EXEC
just before PROP is started by a PROPST DISC command.

Update the PROP routing table to make SMSPOS ALTOPS the
action routine to be called for any messages you want SMSPOS
to route.  SMSPOS can route all messages by leaving all other
fields blank and specifying SMSPOS as the action routine and
ALTOPS as the parameters.

Any CMS user can become an alternative operator for all
messages by entering ALTOPS ON.  Likewise ALTOPS OFF
removes the user from the alternative operator pool.  By
specifying a source user-id, you can selectively receive
messages.   For example, ALTOPS ON MVS2 will only route
messages from MVS2.  ALTOPS LIST provides a list of
alternative operators.

SMSPOS can also be called from PROP action routines to
route messages by executing 'SMSPOS ROUTE msg-text'.

SMSPOS ASSEMBLE serves as a replacement for DMSPOS,
the PROP message router.  SMSPOS maintains a queue of
user-ids (alternative operators) that are to receive messages
from PROP.  For each user-id there is a queue of source user-
ids that indicate which messages are to be routed to the
alternative operators.  SMSPOS is more efficient than
DMSPOS, routing messages in about a tenth of the time, and
generates fewer extraneous messages such as DMK...057
(USER IS DISCONNECTED).  Currently SMSPOS does not
handle internode messages, but this could be added by
including a node field for each alternative operator and, if the
node is different to the current node for the PROP user, route
the message to the alternative operator via RSCS or the CMS
TELL command.  Note: the PROP user must have ECMODE
ON in order to use this program because of the use of STOSM
and STNSM instructions in the queue maintenance routines.

Figure 1 shows the control block structure.

The NUCUSERX field is specified by a global SETC at the
beginning of the SMSPOS module.  If there is a conflict in the
use of this field, four NUCUSER fields are available
(NUCUSER1-NUCUSER4).  The control blocks are in
DMSFREE TYPE=NUCLEUS STORAGE, and they are not
freed unless CMS is IPLd.  This allows the current list of
alternative operators to remain in effect even when PROP
comes down or the module is NUCXDROPd.  The source user-
id can be a user-id mask following standard CMS masking
conventions, (eg a mask of '*' will cause routing of all message
to the alternative operator).

Syntax:

                  ON
    SMSPOS        OFF <GVM_1 GVM_2 ... GVM_N> ( OPTIONS
                  LIST
                  CLEAR

                  ROUTE <MESSAGE_TEXT>

                  SEND <SRC_GVM> <SRC_NODE> <MESSAGE_TEXT>


OPTIONS are USER <USER_ID>.


SMSPOS ASSEMBLE

SMSPOS   TITLE 'PROP MESSAGE PROCESSING ROUTINE'
         GBLC  &NUCUSER
&NUCUSER SETC  'NUCUSER1'
         PRINT GEN
         AIF   ('&SYSPARM' NE 'SUP').START
         PRINT NOGEN
.START   ANOP
* PROP MESSAGE PROCESSING ROUTINE                                     *
* ENTRY:                                                              *
*    R0 --> EXTENDED PLIST (MAYBE)                                    *
*    R1 --> TOKENIZED PLIST                                           *
*    R2 --> SCBLOCK (NUCLEUS EXTENSION ANCHOR BLOCK)                  *
* EXIT:                                                               *
*    R15 = 0 - NORMAL PROCESSING                                      *
*        = 8 - ERROR DURING INITIALIZATION OR CALLING 2ND LEVEL RTN   *
SMSPOS   START 0
         REGEQU
         USING NUCON,0
         USING PVCENTRY,R10
         USING UQENTRY,R9
         USING XQENTRY,R8
         USING QHDESC,R7
         USING SCBLOCK,R2
         EJECT
*              ADDRESSABILITY AND SAVE AREA LINKAGE                   *
         USING *,R11
         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS
         LR    R11,R15
         B     SKIPDCS                 BRANCH PAST DC
PGMNAME  DC    CL8'SMSPOS  '           CSECT ID
         DC    CL8'&SYSDATE'           DATE OF ASSEMBLY
         DC    CL8'&SYSTIME'           TIME OF ASSEMBLY
SKIPDCS  EQU   *
         LA    R3,SAVEAREA             R3 --> THIS CSECT'S SA
         ST    R13,SAVEAREA+4          SAVE ADDR OF CALLER'S SA
         ST    R3,8(R13)               CHAIN SA'S
         LR    R13,R3                  R13 --> THIS CSECT'S SA
         EJECT
* CHECK CALLING PARAMETERS, ETC                                       *
* WE MUST EXECUTE AS A NUCLEUS EXTENSION WITH THE 'SYSTEM' AND        *
* 'SERVICE' ATTRIBUTES SO THAT WE CAN GET CONTROL IN CASE OF AN       *
* ABEND OR NUCXDROP. IF WE ARE NOT A NUCLEUS EXTENSION, WE END WITH   *
* AN ERROR MESSAGE. IF WE DO NOT HAVE THE SYSTEM AND SERVICE          *
* ATTRIBUTES, WE NUCXDROP AND NUCXADD OURSELVES WITH THE PROPER       *
* ATTRIBUTES.                                                         *
         SPKA  X'00'
         SSM   ENABLE
         LA    R12,OPSDATA             GET ADDRESS OF COMMON AREA
         STM   R0,R2,@EPLIST           SAVE ADDRESSES OF PLISTS & SCB
         C     R11,SCBENTR             IS THIS AN SCBLOCK W/OUR ADDR?
         BNE   ERR000                  NO, DISP ERRMSG AND EXIT
         CLI   @TPLIST,X'FF'           IS THIS A SERVICE CALL?
         BE    OPSSVC                  YES, GO DEAL WITH IT
         TM    SCBSFLAG,SCBSFSYS       DO WE HAVE SYSTEM ATTR?
         BNO   NUCXRES                 NOPE
         TM    SCBSFLAG,SCBSFSER       DO WE HAVE SERVICE ATTR?
         BNO   NUCXRES                 NOPE
         B     INITCHK
NUCXRES  EQU   *                       RESET NUCX ATTRIBUTES
         DMSKEY NUCLEUS,NOSTACK        MUST BE IN NUCLEUS KEY
         MVC   NUCXNAME,SCBNAME        OUR NUCEXT NAME
         LM    R5,R6,SCBXORG           SAVE ORIGIN AND LENGTH
         XC    NUCXADDR,NUCXADDR       CLEAR FOR CANCEL FUNCTION
         CMSSVC NUCXLIST               CANCEL CURRENT NUCEXT
         ST    R11,NUCXADDR            PUT OUR ADDRESS IN NUCXLIST
         STM   R5,R6,NUCXORG           PUT ORIGIN AND LEN IN PLIST
         MVI   NUCXATTR,SCBSFSYS+SCBSFSER     SYSTEM AND SERVICE
         CMSSVC NUCXLIST               RE-DECLARE OURSELVES
         XC    NUCXORG(8),NUCXORG      CLEAR ORIGIN AND LENGTH FIELDS
         MVI   NUCXATTR,0              CLEAR ATTRIBUTES FIELD
         EJECT
* CALL SECOND LEVEL PROCESSING ROUTINE                                *
* SETUP FOR CALL TO 2ND LEVEL ROUTINE                                 *
INITCHK  EQU   *
         TM    FLAG,FLAGINIT           HAVE WE BEEN CALLED BEFORE?
         BO    INITCHK2                YES, CALL 2ND LEVEL ROUTINE
         ST    R12,SCBWKWRD            THE ADDRESS OF THE COMMON DATA
*                                         AREA GOES IN THE SCB SO IT
*                                         IS ACCESSIBLE BY OTHERS
         B     INITNUCX                SKIP ABNEXIT CLR FIRST TIME
INITABCL EQU   *                       CLEAR EXISTING ABEND EXIT
         L     R3,ABNDADDR
         ABNEXIT CLR,EXIT=(R3),MF=(E,ABXLIST)
* WE MUST DEFINE THE 2ND LEVEL (MAIN) ROUTINE AS A NUCLEUS EXTENSION. *
* IN SUBSEQUENT INVOCATIONS, WE WILL CALL SMSPOSMN VIA SVC202. WE DO  *
* THIS BECAUSE WE ARE A SYSTEM ROUTINE (NUCEXT SYSTEM ATTRIBUTE)      *
* WHICH MEANS THAT A PROGRAM INTERRUPT WILL CAUSE CMS TO GO INTO A    *
* DISABLED WAIT WITHOUT GIVING ANY RECOVERY ROUTINES CONTROL. SINCE   *
* SMSPOSMN IS A NUCLEUS EXTENSION WITHOUT THE SYSTEM ATTRIBUTE AND    *
* HAS BEEN CALLED VIA SVC202, ANY PROGRAM INTERRUPTS IN SMSPOSMN      *
* WILL ALLOW OUR ABEND EXIT (SMSPOSAB) TO GET CONTROL, CLEAN UP,      *
* AND RETRY WITHOUT DISTURBING PROP AND CMS.                          *
INITNUCX EQU   *
         MVC   NUCXPSW,=X'FFE0'
         MVC   NUCXNAME,LEV2NAME       NAME TO NUCEXT PLIST
         MVC   NUCXADDR,LEV2ADDR       ADDRESS TO NUCEXT PLIST
         CMSSVC NUCXLIST               DEFINE LEV2 ROUTINE
         OI    FLAG,FLAGINIT           INDICATE INIT COMPLETE
INITCHK2 EQU   *
         ICM   R7,B'1111',&NUCUSER     GET NUCLEUS ANCHOR
         BZ    INITGETH
         CLC   QHEND(8),OPSDNAME       CHECK FOR OUR EYECATCHER
         BE    INITEXIT                GOT OUR QUEUE HEAD
*                                      IF NOT THERE, ASSUME GARBAGE
*                                         IN NUCUSER FIELD
INITGETH EQU   *
         LA    R0,QHDLEN+1             GET NUMBER OF DOUBLE WORDS IN
*                                         QHEAD + 1 FOR EYECATCHER
         DMSFREE DWORDS=(0),TYPE=NUCLEUS
         LR    R7,R1
         L     R2,NUCXFRES             GET CURRENT NUCLEUS STORAGE CNT
         AR    R2,R0                   ADD WHAT WE JUST GOT
         ST    R2,NUCXFRES             STORE UPDATED DWORD COUNT
         ST    R7,&NUCUSER             ANCHOR IN NUCLEUS
         XC    QHDESC(QHLEN),QHDESC    CLEAR THE CONTROL BLOCK
         ST    R7,QHTAIL               TAIL-->HEAD IN EMPTY QUEUE
         MVC   QHEND(8),OPSDNAME
INITEXIT EQU   *
         ST    R7,USERQ                SAVE PTR TO QHEAD
         SPACE
* SETUP ABEND EXIT ROUTINE                                            *
         L     R3,ABNDADDR             GET ADDRESS OF ABEND EXIT
         NI    FLAG,255-FLAGABND       CAN'T BE RECURSION YET
         ABNEXIT SET,EXIT=(R3),UWORD=(R12),MF=(E,ABXLIST)
         SPACE ,
* XCTL TO PROCESSING ROUTINE                                          *
XCTL     EQU   *
         CMSSVC LEV2NAME
         LTR   R2,R15                  SAVE RETURN CODE
         BNM   XCTLEXIT                CLEAN UP BEFORE LEAVING
         CH    R15,=Y(-3)              NOT FOUND?
         BNE   ERR001                  NO, SOME OTHER ERROR
         B     INITABCL                YES, LOST OUR NUCEXT SOMEHOW
XCTLEXIT EQU   *
         SPACE ,
* CLEAR ABEND EXIT                                                    *
         L     R3,ABNDADDR
         ABNEXIT CLR,EXIT=(R3),MF=(E,ABXLIST)
         LR    R15,R2                  RESTORE LEV-2 RETURN CODE
         B     RETURN
         EJECT
* SERVICE CALL                                                        *
OPSSVC   EQU   *
         CLC   =CL8'RESET',8(R1)       IS THIS A RESET CALL?
         BNE   RETURN0                 NO, IGNORE IT
         MVC   NUCXNAME,LEV2NAME       NAME TO NUCEXT PLIST
         XC    NUCXADDR,NUCXADDR       INDICATES CANCEL PLIST
         CMSSVC NUCXLIST               REMOVE 2ND NUCEXT
         B     OPSSVC95                DON'T CLEAR QUEUES AT NUCXDROP
* THIS CODE FREES ALL THE TYPE=NUCLEUS STORAGE WE HAVE USED. IT IS    *
* NEVER EXECUTED, BUT HAS BEEN LEFT IN IN CASE FUTURE ENHANCEMENTS    *
* MAKE USE OF IT.                                                     *
         L     R7,USERQ
         XC    QHCURR,QHCURR           START AT BEGINNING
OPSSVC10 EQU   *
         L     R7,USERQ
         QMNT  LOC,(R7),LOAD=@QLOC,ERROR=OPSSVC90,MF=(E,QMLIST)
         L     R9,QPELMT-QPLIST(,R1)   LOAD USER QUEUE BASE
         LA    R7,UQEHDR               POINT TO GVM QUEUE
         QMNT  PURGE,(R7),LOAD=@QPURGE,MF=(E,QMLIST)
         B     OPSSVC10
OPSSVC90 EQU   *
         L     R7,USERQ
         QMNT  PURGE,LOAD=@QPURGE,(R7),MF=(E,QMLIST)
OPSSVC95 EQU   *
         APPLMSG APPLID=SMS,COMP=YES,DISP=ERRMSG,HEADER=YES,           X
               NUM=199,FMT=1,LINE=*,                                   X
               MF=(E,MSGLIST)
         B     RETURN0
         EJECT
* ERROR RETURNS                                                       *
ERR000   EQU   *                       NOT CALLED AS NUCLEUS EXTENSION
         APPLMSG APPLID=SMS,COMP=YES,DISP=ERRMSG,HEADER=YES,           X
               NUM=100,FMT=1,LINE=*,                                   X
               SUB=(CHARA,(PGMNAME,8)),                                X
               MF=(E,MSGLIST)
         LA    R15,8
         B     RETURN
ERR001   EQU   *                       ERROR DURING XCTL TO PROC RTN
         APPLMSG APPLID=SMS,COMP=YES,DISP=ERRMSG,HEADER=YES,           X
               NUM=101,FMT=1,LINE=*,                                   X
               SUB=(CHARA,(LEV2NAME,8),DEC,((R2),4)),                  X
               MF=(E,MSGLIST)
         LA    R15,8
         B     RETURN
         EJECT
* RETURN TO CALLER                                                    *
RETURN0  EQU   *
         XR    R15,R15
RETURN   EQU   *
         L     R13,SAVEAREA+4          R13 --> CALLER'S SA
         LM    R0,R12,20(R13)          RESTORE REGISTERS
         L     R14,12(,R13)            RESTORE R14
         BR    R14
         LTORG
*              S T O R A G E    D E F I N I T I O N S                 *
SAVEAREA DS    9D                      REGISTER SAVE AREA
OPSDNAME DC    CL8'OPSQHEAD'
LEV2ADDR DC    V(SMSPOSMN)             ADDRESS OF 2ND LEVEL ROUTINE
LEV2NAME DC    CL8'SMSPOSMN'           NAME OF 2ND LEVEL ROUTINE
LEV2EPL  DC    A(LEV2NAME,0,0,0)
ABNDADDR DC    V(SMSPOSAB)             ADDRESS OF ABEND HANDLER
NUCXLIST DC    CL8'NUCEXT'             NAME FOR SVC202
NUCXNAME DS    CL8                     NUCEXT NAME
NUCXPSW  DC    X'0000'
NUCXATTR DC    AL1(0)
         DC    AL1(0)
NUCXADDR DC    A(0)                    ADDRESS OF NUCEXT
NUCXUSER DC    A(OPSDATA)              USER WORD
NUCXORG  DC    A(0)                    ORGIN ADDRESS
NUCXLEN  DC    A(0)                    LENGTH OF ROUTINE
OPSDATA  DS    0D                      START OF COMMON DATA AREA
         OPSDATA DSECT=NO
         EJECT
*           M I S C E L L A N E O U S    D S E C T S                  *
         PUSH  PRINT
         AIF   ('&SYSPARM' NE 'SUP').MAPMAC
         PRINT OFF,NOGEN
.MAPMAC  ANOP
         QPLIST
         QHEAD
         EJECT
         QENTRY PREFIX=UQE,BODY=8+QHLEN
         ORG   UQEDATA
UQEULEN  DS    A
UQEUSER  DS    CL8
UQEHDR   QHEAD DSECT=NO
         ORG
         EJECT
         QENTRY PREFIX=XQE,BODY=12
         ORG   XQEDATA
XQEULEN  DS    A
XQEUSER  DS    CL8
         EJECT
         PARSERCB ,
         PVCENTRY ,
         EJECT
         COPY  PROP
         SCBLOCK ,
         EJECT
         NUCON ,
         POP   PRINT
         END


SMSPOSMN ASSEMBLE

SMSPOSMN TITLE 'MAIN SMSPOS PROCESSING ROUTINE'
         PRINT GEN,DATA
         AIF   ('&SYSPARM' NE 'SUP').START
*        PRINT NOGEN
.START   ANOP
* SMSPOS MAIN PROCESSING ROUTINE                                      *
* FUNCTION - ROUTES MESSAGES TO ALTERNATIVE OPERATORS AND MAINTAINS   *
* THE ALTERNATIVE OPERATOR QUEUES. IF THE HIGH-ORDER BYTE OF R1 IS    *
* X'00', WE ASSUME THIS IS A PROP MESSAGE. WE SEARCH THE ALTOPS       *
* QUEUES AND ROUTE THE MESSAGE TO APPROPRIATE ALTERNATIVE OPERATORS.  *
* OTHERWISE, WE ASSUME THIS IS A COMMAND CALL. WE PARSE THE COMMAND   *
* LINE, SEARCH THE COMMANDS TABLE (LABEL OPTSTRT), AND BRANCH TO      *
* THE APPROPRIATE PROCESSING ROUTINE.                                 *
*                                                                     *
* ENTRY: (STANDARD CMS SVC202 CALL)                                   *
*    R0 --> EXTENDED PLIST                                            *
*    R1 --> TOKENIZED PLIST                                           *
*                                                                     *
* EXIT:                                                               *
*    R15 = 0                                                          *
SMSPOSMN START 0
         REGEQU
         USING OPSDATA,R12
         USING PVCENTRY,R10
         USING UQENTRY,R9
         USING XQENTRY,R8
         USING QHDESC,R7
         USING SCBLOCK,R2
         USING NUCON,0
         EJECT
*              ADDRESSABILITY AND SAVE AREA LINKAGE                   *
**  THIS PROGRAM WAS ORIGINALLY WRITTEN UNDER VM/SP.  WHEN WE        **
**  CONVERTED TO VM/XA THE PROGRAM WENT BEYOND 4K AND ONE BASE       **
**  REGISTER WOULD NOT COVER THE CODE.  TO GET AROUND THE PROBLEM    **
**  R5 IS BEING USED IN THE FIRST PART OF THE PROGRAM AS A BASE      **
**  REGISTER.  THIS PROGRAM NEEDS TO BE REWRITTEN TO ELIMINATE       **
**  THIS PROBLEM.  TEMPORARILY, R5 AND THEN R11 ARE USED AS BASE     **
**  REGISTERS.  COMMENTS NOTE WHERE CHANGES WERE MADE.        CPR0   **
*                                      TEMP BASE REGISTER KLUGE       *
         USING *,R5                    R5 IS USED AS BASE             *
*                                      END KLUGE                      *
         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS
*                                      TEMP BASE REGISTER KLUGE       *
         LR    R5,R15                  LOAD R5 WITH BASE VALUE        *
*                                      END KLUGE                      *
         B     SKIPDCS                 BRANCH PAST DC
PGMNAME  DC    CL8'SMSPOSMN'           CSECT ID
         DC    CL8'&SYSDATE'           DATE OF ASSEMBLY
         DC    CL8'&SYSTIME'           TIME OF ASSEMBLY
SKIPDCS  EQU   *
         SPKA  X'00'                   WE WANT TO BE IN NUCLEUS KEY
         LA    R3,SAVEAREA             R3 --> THIS CSECT'S SA
         ST    R13,SAVEAREA+4          SAVE ADDR OF CALLER'S SA
         ST    R3,8(R13)               CHAIN SA'S
         LR    R13,R3                  R13 --> THIS CSECT'S SA
*                                      TEMP BASE REGISTER KLUGE       *
         LA    R11,CALLORTN+2          LOAD R11 WITH ITS BASE VALUE   *
*                                      END KLUGE                      *
         EJECT
* CHECK CALLING PARAMETERS, ETC                                       *
         LR    R3,R14
*                                      TEMP BASE REGISTER KLUGE       *
*        C     R11,SCBENTR             IS THIS AN SCBLOCK W/OUR ADDR? *
         C     R5,SCBENTR             IS THIS AN SCBLOCK W/OUR ADDR?  *
*                                      END KLUGE                      *
         BNE   ERR001                  NO, DISP ERRMSG AND EXIT
         ICM   R12,B'1111',SCBWKWRD    GET USER WORD
         BZ    ERR000                  NOT THERE
         CLC   OPSDATA(4),=C'OPSD'     DOES R12 --> OPSDATA AREA?
         BNE   ERR000                  NO, DISP ERRMSG AND EXIT
         LR    R14,R3
         ST    R14,ABPSW+4             ABEND RETRY ADDRESS
         EJECT
* CHECK TYPE OF CALL                                                  *
CALLCHK  EQU   *
*                                      TEMP BASE REGISTER KLUGE       *
         MVC   OPUSER,BLANKIES         ASSUME NO USERID PASSED        *
*                                      END KLUGE                      *
         CLI   @TPLIST,X'00'           IS THIS A PROP CALL?
         BE    OPSPROP                 YES
*                                      NO, ASSUME STANDARD SVC202
         SPACE
* PARSE THE COMMAND LINE                                              *
         LM    R0,R1,@EPLIST           RESTORE ORIGINAL PLIST REGS
         PARSECMD UNIQID='30D.SMSPOS',APPLID='SMS',                    X
               MSGDISP=ERRMSG,MSGBUFF=0,ERROR=RETURN8
         L     R10,PARPVCAD-PARSERCB(,R1) GET ADDRESS OF PVC TABLE
         ST    R10,@PVCTAB             STORE FOR LATER
         EJECT
* DETERMINE CALLING OPTION AND BRANCH TO PROPER ROUTINE               *
* COMMAND BUFFER                                                      *
*    PARM 1 - ROUTINE NAME                                            *
*    PARM 2 - FUNCTION TO BE PERFORMED                                *
*    PARM 3 - OPERAND 1 TO FUNCTION                                   *
*    PARM N - OPERAND N TO FUNCTION                                   *
*         ( - START OF OPTIONS                                        *
*    OPT  1 - 'USERID' KEYWORD                                        *
*    OPT  2 - USERID OF ISSUER OF COMMAND                             *
         ICM   R10,B'1111',PVCNEXTA    BUMP PAST ROUTINE NAME
         BZ    ERR002                  NO FUNCTION NAME
         L     R6,PVCTTOKA             GET ADDRESS OF FUNCTION NAME
         MVC   FUNCNAME,0(R6)          SAVE FUNCTION NAME
         LA    R1,DFLTPVC              GET DUMMY OPERAND PVCENTRY
         ST    R1,@PVCTOPR             IN CASE NO OPERANDS
         XC    @PVCTOPT,@PVCTOPT       IN CASE NO OPTIONS
CALLOPRS EQU   *
         ICM   R10,B'1111',PVCNEXTA    GET ADDRESS OF OPERANDS
         BZ    CALLORTN                NOTHING TO GET
         CLI   PVCCODE,PVCOPTST        IS THIS START OF OPTIONS?
         BE    CALLOPTS                YES..GO PROCESS OPTIONS
         ST    R10,@PVCTOPR            NO...SAVE START OF OPERANDS
CALLFOPT EQU   *                       FIND START OF OPTIONS
         ICM   R10,B'1111',PVCNEXTA
         BZ    CALLORTN                END OF PARAMETERS
         CLI   PVCCODE,PVCOPTST        IS THIS START OF OPTIONS?
         BE    CALLOPTS                YES..GO PROCESS OPTIONS
         B     CALLFOPT                NO...KEEP LOOKING
CALLOPTS EQU   *
         ST    R10,@PVCTOPT            SAVE START OF OPTIONS
CALLOPT1 EQU   *
         ICM   R10,B'1111',PVCNEXTA    GET OPTION KEYWORD
         BZ    CALLORTN                NOTHING THERE
         CLI   PVCCODE,PVCKWORD        IS THIS A KEYWORD?
         BNE   CALLOPT1                NO, GET NEXT ONE
         L     R15,PVCTTOKA            POINT TO TOKEN VALUE
         CLC   0(8,R15),=CL8'USERID'   IS THIS THE USERID OPTION?
         BNE   CALLOPT2                NO, SKIP THIS
         ICM   R10,B'1111',PVCNEXTA    GET OPTION VALUE
         BZ    CALLORTN                JUST IN CASE
         L     R15,PVCTTOKA            POINT TO USERID VALUE
         MVC   OPUSER,0(R15)           SAVE USERID
*                                      TEMP BASE REGISTER KLUGE       *
         OC    OPUSER,BLANKIES         TRANS TO UPPER CASE            *
*                                      END KLUGE                      *
         L     R15,PVCETOKL            WE WANT LENGTH ALSO
         ST    R15,OPULEN              STORE LENGTH IN COMMON AREA
CALLOPT2 EQU   *
*                                      PROCESS FUTURE OPTIONS HERE
         B     CALLOPT1                GET NEXT OPERAND
* SPIN THROUGH FUNCTION TABLE TILL WE FIND A MATCH                    *
* LOAD THE ADDRESS OF THE PROCESSING ROUTINE                          *
* BRANCH TO THE ROUTINE                                               *
*                                      TEMP BASE REGISTER KLUGE       *
BLANKIES DC    CL32' '                 BLANKS COVERED BY R5           *
*                                      END KLUGE                      *
CALLORTN EQU   *                       SETUP FOR SEARCH
*                                      TEMP BASE REGISTER KLUGE       *
         DROP  R5                      R5 NO LONGER BASE              *
         BALR  R11,0                   SET UP R11 AS BASE             *
         USING *,R11                   LOAD BASE VALUE                *
*                                      END KLUGE                      *
         LA    R3,OPTSTRT              GET START OF OPTIONS TABLE
         LA    R4,12                   EACH ENTRY IS 12 BYTES
         LA    R5,OPTSEND              GET END OF OPTIONS TABLE
CALLOTOP EQU   *                       GET OPTION AND BRANCH
         L     R15,8(,R3)              ASSUME THIS IS IT, GET ADDRESS
         CLC   FUNCNAME,0(R3)          IS IT?
         BER   R15                     YES, CALL PROPER OPTION ROUTINE
         BXLE  R3,R4,CALLOTOP          NO, KEEP LOOKING
         BR    R15                     CALL DEFAULT OPTION ROUTINE
         EJECT
* PROP CALL (ROUTE A MESSAGE)                                         *
* ENTRY R1 --> PLIST                                                  *
*              +0 ROUTINE NAME                                        *
*              +8 PTR TO PROP COMMON AREA                             *
*             +12 PTR TO PROP PARM LIST                               *
         PUSH  USING
         USING PARMLIST,R4
         USING PROPCOM,R3
OPSPROP  EQU   *
         L     R1,@TPLIST              GET PLIST POINTER
         LM    R3,R4,8(R1)             LOAD COM AND PARM BASES
         L     R1,MSGCNTI              GET INBOUND MESSAGE COUNT
         LA    R1,1(,R1)
         ST    R1,MSGCNTI              INCREMENT
* GET MESSAGE DATA INFO                                               *
* WE ARE GOING TO CONSTRUCT A BUFFER FOR A CP MSGNOH COMMAND. WE      *
* NEED THE KEYWORD 'MSGNOH', THE USERID TO WHOM THE MESSAGE IS TO     *
* BE SENT, AND THE TEXT OF THE MESSAGE. UP FRONT WE KNOW THE 1ST      *
* AND THIRD OF THESE, BUT THE USERID WILL CHANGE EACH TIME THE        *
* MESSAGE IS SENT. FURTHERMORE, NOT ALL USERIDS ARE THE SAME LENGTH.  *
* CP USES AS MESSAGE TEXT EVERYTHING AFTER THE FIRST BLANK FOLLOWING  *
* THE USERID, SO MESSAGES TO USERIDS THAT ARE SHORTER THAN EIGHT      *
* CHARACTERS WILL BE PREFIXED BY EXTRA BLANKS, MAKING THE MESSAGES    *
* UNSIGHTLY. TO DEAL WITH THIS PROBLEM WE PUT THE MESSAGE TEXT, THE   *
* SOURCE USERID, AND THE SOURCE NODE IN A FIXED PART OF THE BUFFER.   *
* THEN WE BACK UP FROM THERE TO INSERT THE 'MSGNOH' KEYWORD AND THE   *
* VARIABLE-LENGTH USERID.                                             *
         LM    R5,R6,PARMMSG           GET MESSAGE AND LENGTH ADDRS
         L     R6,0(,R6)               GET LENGTH
         BCTR  R6,0                    MACHINE LENGTH
         EX    R6,OPSPMVC              MESSAGE TO CPCMD BUFFER
         L     R5,PARMRUSR             POINT TO RUSER
         MVC   CPCMDFRM(CPCMDLEN),BLANKS    CLEAR HEADER AREA
         MVC   CPCMDFRM,0(R5)          PUT IN MESSAGE BUFFER
         ST    R5,PATTPARM             SAVE RUSER ADDR FOR PATT MATCH
         LA    R2,8                    MAX LENGTH OF RUSER NAME
         LA    R1,7(,R5)               --> LAST BYTE OF RUSER
OPSPR00  EQU   *
         CLI   0(R1),C' '              IS THIS BLANK?
         BNE   OPSPR02                 NO, FOUND END
         BCTR  R1,0                    BACK UP 1
         BCT   R2,OPSPR00
OPSPR02  EQU   *
         ST    R2,PATTPARM+4           SAVE RUSER LEN
         LTR   R2,R2                    CHECK FOR ZERO LENGTH
         BZ    OPSPR03
         MVC   FUSER,BLANKS             CLEAR FIELD TO HOLD RUSER
         BCTR  R2,0                     MACHINE LENGTH
         EX    R2,OPSPUMV3              SAVE RUSER FOR LATER
OPSPR03  EQU   *
         L     R5,PARMRNOD             POINT TO RUSER'S NODE
         MVC   CPCMDNOD,0(R5)          PUT IN MESSAGE BUFFER
         CLI   CPCMDFRM,C' '           FROM USER BLANK?
         BNE   OPSPR05                 NO, SKIP THIS
         L     R5,PARMPUSR             POINT TO PROP USERID NAME
         MVC   CPCMDFRM,0(R5)          MOVE TO MESSAGE FIELD
         L     R5,PARMPNOD             POINT TO PROP USERID NODE
         MVC   CPCMDNOD,0(R5)          MOVE TO MESSAGE HEADER
OPSPR05  EQU   *
         MVC   CPCMDSEP,=CL2': '       INSERT SEPARATOR CHARACTERS
         LA    R6,CPCMDLEN+1(,R6)      LEN OF CP BUFFER SO FAR
         ST    R6,CPCMDHLN             SAVE FOR LATER
         SPACE ,
* FIGURE OUT WHO WE WANT TO ROUTE THIS MESSAGE TO                     *
* WE SPIN THROUGH THE HORIZONTAL QUEUE OF ALTERNATIVE OPERATORS. FOR  *
* EACH ALTERNATIVE OPERATOR WE SPIN THROUGH THE VERTICAL QUEUE OF     *
* USERID MASKS. IF WE FIND NO MASKS THAT MATCH THE MESSAGE SOURCE     *
* USERID, WE GO ON TO THE NEXT ALTERNATIVE OPERATOR. IF WE FIND A MASK*
* THAT MATCHES, WE FINISH BUILDING THE MESSAGE (IE PREFIX THE         *
* MESSAGE BUFFER WITH THE ALTOPS USERID), SEND THE MESSAGE, AND       *
* GO ON TO THE NEXT ALTERNATIVE OPERATOR SO THAT WE DO NOT SEND THE   *
* SAME MESSAGE TWICE TO THE SAME ALTERNATIVE OPERATOR.                *
         L     R7,USERQ                SPIN THROUGH USER QUEUE
         XC    QHCURR,QHCURR           START AT BEGINNING
OPSPR10  EQU   *
         L     R7,USERQ                JUST TO BE SURE
         QMNT  LOC,(R7),ERROR=OPSPR90,LOAD=@QLOC,MF=(E,QMLIST)
         L     R9,QPELMT-QPLIST(,R1)   GET USER QENTRY BASE
         L     R2,UQEULEN              GET LENGTH OF USERID
         LA    R3,L'CPCMDTXT+1(,R2)    R3 HAS LEN OF USER PLUS COMMAND
         LA    R4,CPCMDFRM             R4--> FIXED PART OF BUFFER
         SR    R4,R3                   BACK UP TO MAKE ROOM FOR PREFIX
         ST    R4,DIAGPARM             SAVE POINTER TO CMDTXT
         A     R3,CPCMDHLN             THIS IS TOTAL LENGTH
         ICM   R3,B'1000',=X'40'       INDICATE WE WANT REPLY
         ST    R3,DIAGPARM+8
         MVC   0(L'CPCMDTXT,R4),CPCMDTXT MOVE IN COMMAND TXT
         LA    R4,L'CPCMDTXT(,R4)      BUMP FOR USERID
         BCTR  R2,0                    MACHINE LENGTH OF USERID
         EX    R2,OPSPUMVC             MOVE USERID TO BUFFER
         MVC   TUSER,BLANKS             CLEAR USERID FIELD
         EX    R2,OPSPUMV2              SAVE USERID FOR LATER
* IF THE 'FROM' AND 'TO' USERS ARE THE SAME THERE IS A STRONG CHANCE  *
* THAT A FEEDBACK LOOP WILL BE SET UP. ALSO, IT IS UNNECESSARY TO     *
* SEND A MESSAGE TO SOMEONE THAT HAS PRESUMABLY ALREADY SEEN IT.      *
         CLC   FUSER,TUSER              FROM/TO SAME USER?
         BE    OPSPR10                  YES, SKIP THIS
         LA    R4,1(R2,R4)             BUMP PAST USERID
         MVI   0(R4),C' '              AESTHETICS
         LA    R7,UQEHDR               POINT TO GVM Q FOR THIS USER
         XC    QHCURR,QHCURR           START AT BEGINNING
OPSPR20  EQU   *
         QMNT  LOC,(R7),ERROR=OPSPR10,LOAD=@QLOC,MF=(E,QMLIST)
         L     R8,QPELMT-QPLIST(,R1)   GET GVM QENTRY BASE
         LA    R4,XQEUSER              GET ADDRESS OF STRING
         L     R5,XQEULEN              GET LENGTH OF STRING
         STM   R4,R5,PATTPARM+8        PARMS FOR PATTERN MATCH RTN
         LA    R1,PATTPARM             R1 --> PARMS
         L     R15,=V(PATTERN)
         BALR  R14,R15                 CALL PATTERN MATCHING ROUTINE
         BNE   OPSPR20                 NOT A MATCH
         LM    R3,R6,DIAGPARM          LOAD REGS FOR DIAG
         DIAG  R3,R5,8                 ISSUE CP MSGNOH COMMAND
         L     R1,MSGCNTO              BUMP OUTBOUND MESSAGE COUNT
         LA    R1,1(,R1)
         ST    R1,MSGCNTO
         B     OPSPR10                 DON'T SEND MESSAGE 2X TO = USR
OPSPR90  EQU   *
         B     RETURN0
OPSPMVC  MVC   CPCMDMSG(0),0(R5)       PUT MESSAGE IN BUFFER
OPSPUMVC MVC   0(0,R4),UQEUSER         WHO WE WILL SEND MESSAGE TO
OPSPUMV2 MVC   TUSER(0),UQEUSER        SAVE USERID
OPSPUMV3 MVC   FUSER(0),0(R5)          SAVE USERID
         DROP  R3,R4
         POP   USING
         EJECT
* SMSPOS ON - ADD ALTERNATIVE OPERATOR AND/OR USERID MASK.            *
OPSON    EQU   *
         CLI   OPUSER,C' '             WAS USER PASSED?
         BE    ERR003                  NO, ISSUE ERROR MESSAGE
         NI    FLAG,255-FLAGQADD       CLEAR FLAG BIT
         L     R7,USERQ
         XC    QHCURR,QHCURR           START AT BEGINNING
         QMNT  LOC,(R7),OPUSER,L'OPUSER,UQEUSER-UQENTRY,EQ,            X
               ERROR=OPSON20,LOAD=@QLOC,                               X
               MF=(E,QMLIST)           IS USER ALREADY THERE?
         L     R9,QPELMT-QPLIST(,R1)   GET QENTRY BASE
         LA    R7,UQEHDR               LOAD VERTICAL QHEAD BASE
         B     OPSON30
         SPACE ,
OPSON20  EQU   *                       DID NOT FIND USER IN QUEUE
         QMNT  BUILD,,,UQEQLEN,NUCLEUS,LOAD=@QBUILD,                   X
               MF=(E,QMLIST)           GET USER QENTRY
         L     R9,QPELMT-QPLIST(,R1)   GET QENTRY BASE
         MVC   UQEUSER,OPUSER          PUT USERID IN ENTRY
         MVC   UQEULEN,OPULEN          PUT LENGTH IN ENTRY
         LA    R7,UQEHDR               LOAD QHEAD BASE
         XC    QHHEAD(QHLEN),QHHEAD    CLEAR GVM QHEAD
         ST    R7,QHTAIL               EMPTY Q TAIL POINTS TO HEAD
         L     R8,USERQ
         QMNT  PUSH,(R8),UQENTRY,LOAD=@QPUSH,MF=(E,QMLIST)
         SPACE
* SPIN THROUGH LIST OF GVMS TO BE ADDED TO THIS ALTERNATIVE OPERATOR'S*
* QUEUE                                                               *
* REGISTERS:                                                          *
*    R7 --> GVM_ENTRY QUEUE HEAD (VERTICAL QUEUE HEAD)                *
*    R10 --> PVC_ENTRY WE ARE WORKING WITH                            *
*    R9  --> USERID_QUEUE ENTRY FOR THIS USER                         *
*    R8  --> GVM_QUEUE ENTRY WE ARE WORKING WITH                      *
OPSON30  EQU   *                       ADD LIST OF GVMS TO QUEUE
         L     R10,@PVCTOPR            GET PVC OPERANDS ADDRESS
OPSON35  EQU   *                       TOP OF OPERAND LOOP
         XC    QHCURR,QHCURR           START AT BEGINNING
OPSON40  EQU   *
         QMNT  LOC,(R7),0,EMPTY=OPSON50,                               X
               LOAD=@QLOC,ERROR=OPSON60,MF=(E,QMLIST)
         L     R8,QPELMT-QPLIST(,R1)   LOAD QUEUE ENTRY BASE #2
         LA    R2,XQEUSER              GET ADDRESS OF STRING
         L     R3,XQEULEN              GET LENGTH OF STRING
         L     R4,PVCTTOKA             GET ADDR & LEN OF PATTERN
         OC    0(8,R4),BLANKS          TRANS TO UPPER CASE
         L     R5,PVCETOKL             GET ADDR & LEN OF PATTERN
         STM   R2,R5,PATTPARM          PARMS FOR PATTERN MATCH RTN
         LA    R1,PATTPARM             R1 --> PARMS
         L     R15,=V(PATTERN)
         BALR  R14,R15                 CALL PATTERN MATCHING ROUTINE
         BNZ   OPSON42                 NEW PATTERN DOES NOT REPL OLD
         QMNT  GET,(R7),POS=(R8),LOAD=@QGET,MF=(E,QMLIST)
         QMNT  FRET,(R7),(R8),LOAD=@QFRET,MF=(E,QMLIST)
         OI    FLAG,FLAGQADD           WE SHOULD ADD NEW ENTRY
         B     OPSON40                 KEEP GOING
OPSON42  EQU   *
         LM    R2,R3,PATTPARM+8
         LM    R4,R5,PATTPARM
         STM   R2,R5,PATTPARM          REVERSE PARMS
         LA    R1,PATTPARM
         L     R15,=V(PATTERN)
         BALR  R14,R15                 TRY AGAIN
         BE    OPSON80                 IF CC=0, THE NEW IS LESS
*                                         GENERIC THAN THE OLD...
*                                         WE WILL KEEP THE OLD
         OI    FLAG,FLAGQADD           WE SHOULD ADD NEW ENTRY
         B     OPSON40                 KEEP GOING
OPSON50  EQU   *
         OI    FLAG,FLAGQADD           QUEUE WAS EMPTY, WE ADD
         B     OPSON60
         SPACE ,
* WE WILL HIT HERE ONLY AFTER WE HAVE SPUN THROUGH THE GUEST MACHINE  *
* (VERTICAL) QUEUE. IF BIT_X OF THE FLAG FIELD IS ON, IT MEANS WE     *
* SHOULD ADD THE NEW GUEST MACHINE PATTERN TO THE QUEUE. IN THE       *
* PROCESS OF SEARCHING, WE HAVE ALREADY REMOVED ALL ENTRIES THAT      *
* WERE LESS GENERIC THAN THE NEW ONE.                                 *
OPSON60  EQU   *
         TM    FLAG,FLAGQADD           CHECK FLAG
         BNO   OPSON80                 IF NOT ON, GET NEXT ENTRY
         QMNT  BUILD,,,XQEQLEN,NUCLEUS,LOAD=@QBUILD,                   X
               MF=(E,QMLIST)
         L     R8,QPELMT-QPLIST(,R1)   LOAD XQENTRY BASE
         L     R4,PVCTTOKA             GET TOKEN ADDRESS
         OC    0(8,R4),BLANKS          TRANS TO UPPER CASE
         L     R5,PVCETOKL             GET TOKEN LENGTH
         ST    R5,XQEULEN              PUT LENGTH IS QUEUE ENTRY
         MVC   XQEUSER,0(R4)           PUT USERID IN QUEUE ENTRY
         QMNT  PUSH,(R7),XQENTRY,LOAD=@QPUSH,MF=(E,QMLIST)
         SPACE ,
* GET NEXT PVC ENTRY AND LOOP                                         *
OPSON80  EQU   *                       BOTTOM OF LOOP
         ICM   R10,B'1111',PVCNEXTA    BUMP TO NEXT ENTRY
         BZ    OPSON90                 NO MORE ENTRIES
         CLI   PVCCODE,PVCOPTST        IS THIS START OF OPTIONS?
         BE    OPSON90                 YES, NO MORE ENTRIES
         B     OPSON35                 NO, PROCESS NEXT ENTRY
OPSON90  EQU   *                       OPSON EXIT
         APPLMSG APPLID=SMS,COMP=YES,DISP=ERRMSG,HEADER=YES,           X
               NUM=122,FMT=1,LINE=*,                                   X
               SUB=(CHARA,(OPUSER,8)),                                 X
               MF=(E,MSGLIST)
         B     OPSL00
         EJECT
* SMSPOS OFF - REMOVE ALTERNATIVE OPERATOR AND/OR USERID MASK         *
OPSOFF   EQU   *
         CLI   OPUSER,C' '             WAS USER PASSED?
         BE    ERR003                  NO, ISSUE ERROR MESSAGE
         L     R7,USERQ
         XC    QHCURR,QHCURR           START AT BEGINNING
         QMNT  LOC,(R7),OPUSER,L'OPUSER,UQEUSER-UQENTRY,EQ,            X
               ERROR=OPSOF20,LOAD=@QLOC,                               X
               MF=(E,QMLIST)           IS USER THERE?
         L     R9,QPELMT-QPLIST(,R1)   GET QENTRY BASE
         LA    R7,UQEHDR               LOAD VERTICAL QHEAD BASE
         B     OPSOF30
         SPACE ,
OPSOF20  EQU   *                       DID NOT FIND USER IN QUEUE
         APPLMSG APPLID=SMS,COMP=YES,DISP=ERRMSG,HEADER=YES,           X
               NUM=121,FMT=1,LINE=*,                                   X
               SUB=(CHARA,(OPUSER,8)),                                 X
               MF=(E,MSGLIST)
         B     RETURN8
         SPACE
* SPIN THROUGH LIST OF GVMS TO BE ADDED TO THIS ALTERNATIVE OPERATOR'S*
* QUEUE                                                               *
* REGISTERS:                                                          *
*    R7 --> GVM_ENTRY QUEUE HEAD (VERTICAL QUEUE HEAD)                *
*    R10 --> PVC_ENTRY WE ARE WORKING WITH                            *
*    R9  --> USERID_QUEUE ENTRY FOR THIS USER                         *
*    R8  --> GVM_QUEUE ENTRY WE ARE WORKING WITH                      *
OPSOF30  EQU   *                       ADD LIST OF GVMS TO QUEUE
         L     R10,@PVCTOPR            GET PVC OPERANDS ADDRESS
OPSOF35  EQU   *                       TOP OF OPERAND LOOP
         XC    QHCURR,QHCURR           START AT BEGINNING
OPSOF40  EQU   *
         QMNT  LOC,(R7),0,EMPTY=OPSOF92,LOAD=@QLOC,                    X
               ERROR=OPSOF80,MF=(E,QMLIST)
         L     R8,QPELMT-QPLIST(,R1)   LOAD QUEUE ENTRY BASE #2
         LA    R2,XQEUSER              GET ADDRESS OF STRING
         L     R3,XQEULEN              GET LENGTH OF STRING
         L     R4,PVCTTOKA             GET ADDR & LEN OF PATTERN
         OC    0(8,R4),BLANKS          TRANS TO UPPER CASE
         L     R5,PVCETOKL
         STM   R2,R5,PATTPARM          PARMS FOR PATTERN MATCH RTN
         LA    R1,PATTPARM             R1 --> PARMS
         L     R15,=V(PATTERN)
         BALR  R14,R15                 CALL PATTERN MATCHING ROUTINE
         BNZ   OPSOF40                 NEW PATTERN DOES NOT REPL OLD
         QMNT  GET,(R7),POS=(R8),LOAD=@QGET,MF=(E,QMLIST)
         QMNT  FRET,*,(R8),LOAD=@QFRET,MF=(E,QMLIST)
         B     OPSOF40                 KEEP GOING
         SPACE ,

This article will be continued next month.

Michael L Brocious and Dennis Hoover
Shared Medical Systems Corporation (USA)

