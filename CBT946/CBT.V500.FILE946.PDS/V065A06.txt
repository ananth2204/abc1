Directory maintenance (continued)

This month we continue the article describing a software
package that automates operations to the CP directory, and
reduces the systems programmer's actions to a minimum, while
at the same time doing all the necessary checks to the input
provided by the systems programmer.

/* ONLY IF THE START OF THE MDISK IS MOVED CHECK FOR GAP.             */
    PARSE VAR OLDDISK . . . OLDSTART .
    PARSE VAR NEWDISK . . . NEWSTART NEWSIZE NEWVOL .
    MAPFLAG = 0
    IF OLDSTART ¬= NEWSTART
        THEN DO
          SAY 'CHECKING ON: ' NEWSTART NEWSIZE NEWVOL
          CALL CHECKMAP NEWVOL, NEWSIZE, NEWSTART
          IF MAPFLAG ¬= 0
               THEN DO
                  SAY
                  SAY 'USER ' USER.J 'WILL NOT BE MODIFIED.'
                  CALL LOGERROR 8, USER.J
               END
        END
    IF MAPFLAG ¬= 0 THEN ITERATE J
    SAY
    SAY "GETTING DSKMOVER'S ORIGINAL DIRECTORY ......"
    CALL FETCHDIREC 1
    'RENAME' USERID.1 'DIRECT A KEEP = ='
    LINENUM = 0
    'MAKEBUF'
    SAY
    SAY "MODIFYING DSKMOVER'S DIRECTORY ......"
    DO FOREVER
        CALL READLINE 'KEEP', 'DIRECT'
        IF RC ¬= 0 THEN LEAVE
        PARSE VAR LINE MDISK  .
        CALL WRITELINE USERID.1, LINENUM
        IF SPACE(MDISK) = 'MDISK'
            THEN DO
                LINE = OLDDISK
                CALL WRITELINE USERID.1, LINENUM
                LINE = NEWDISK
                CALL WRITELINE USERID.1, LINENUM
            END
    END
    'DROPBUF'
    'FINIS KEEP DIRECT A'
    'FINIS' USERID.1 'DIRECT A'
    CALL REPLACEDIREC 1
    'SET CMSTYPE HT'
    'DIRECT USER DIRECT A'
    'SET CMSTYPE RT'
/* ACTIVATE THE DSKMOVER MACHINE .                                    */
    'CLRSCRN'
    SAY 'NOW MOVING THE DISK FOR USER: ' USER.J '.......'
    'CP SPOOL CON START NOTERM'
    'BRINGUP' USERID.1
/* WAIT UNTIL DSKMOVER HAS LOGGED OFF.                                */
    DO UNTIL (RC ¬= 0)
        'EXECIO 0 CP ( STRING Q' USERID.1
    END
    'CP SPOOL CON STOP TERM'
    'CP SPOOL CON PURGE'
    'CLRSCRN'
/* REINSTALL DSKMOVER'S OLD DIRECTORY, AND PUT NEW DIRECTORY FOR USER.*/
    SAY "RETURNING DSKMOVER'S MACHINE TO ITS ORIGINAL FORM...."
    'RENAME KEEP DIRECT A' USERID.1 '= ='
    CALL REPLACEDIREC 1
    CALL SUBDISK USER.J, 'DIRECT'
    'ERASE' USER.J 'DIRECT A'
    'ERASE' USER.J 'OLD A'
END                /* OUTER LARGE LOOP */
USERID.1 = USERHOLD              /* SET THE VALUE BACK */
RETURN
/* SUBDISK IS CALLED BY ADDDISK AND MODDISK. IT INSERTS THE NEW USER'S**
** DIRECTORY INTO CP DIRECTORY, AND PERFORMS THE HOUSEKEEPING, SUCH AS**
** DELETING FILES NOT NEEDED ANYMORE.                                 */
SUBDISK:
ARG FLN, FLT
SAY 'INSERTING ' USER.J 'IN THE CP DIRECTORY, WITH MDISK ADD/MODIFY ...'
LINENUM = 0
STATUS = 'CONTINUE'
DO WHILE (STATUS = 'CONTINUE')      /*.......  MAIN LOOP .....*/
    CALL READLINE 'USER', 'DIRECT'
    IF RESULT ¬= 0
        THEN STATUS = 'STOP'
        ELSE DO
            PARSE VAR LINE USER USERID .
            IF (USER = 'USER') & (USERID = FLN)
               THEN DO
                   DO FOREVER
                       CALL READLINE FLN, FLT
                       IF RESULT ¬= 0
                           THEN LEAVE
                           ELSE CALL WRITELINE 'NEWUSER', LINENUM
                   END
                   USER = '*'
                   DO WHILE (USER ¬= 'USER')  /* IGNORE */
                      CALL READLINE 'USER', 'DIRECT'
                      IF RESULT ¬= 0
                         THEN DO
                            STATUS = 'STOP'
                            LEAVE
                         END
                         ELSE PARSE VAR LINE USER USERID .
                   END    /* IGNORE */
                   IF STATUS = 'CONTINUE'
                        THEN CALL WRITELINE 'NEWUSER', LINENUM
               END
               ELSE CALL WRITELINE 'NEWUSER', LINENUM
       END
END                                   /*...  MAIN LOOP ...*/
'FINIS' FLN FLT 'A'
'FINIS USER DIRECT A'
'FINIS NEWUSER DIRECT A'
'ERASE USER DIRECT A'
'RENAME NEWUSER DIRECT A USER = ='  /* DIRECT WITH NEW MDISK ENTRIES */
SAY 'USER-ID: ' USER.J 'HAS BEEN MODIFIED. THIS IS FINAL DISKMAP UPDATE.'
CALL UPDATEMAP
RETURN
/* SUBEND IS CALLED BY DELEND AND MODEND TO SHRINK THE PROGRAM.       */
SUBEND:
SUBCODE = ARG(1)
SELECT
    WHEN SUBCODE = 1 THEN DO
        ARG SUBCODE, RETCODE, COUNT, FILENAME, ACTION
        CALL UPDATEDIREC
/* IN MODIFY, IF MDISK STATEMENTS ARE CHANGED, THEN SUBMOD INSERT WILL**
** ALREADY HAVE UPDATED THE DISKMAP. NO NEED TO REDO THAT AGAIN HERE. */
        IF ACTION == 'DELETED.' THEN CALL UPDATEMAP
        'CLRSCRN'
        SAY 'THE NEW DIRECTORY IS ON LINE.',
            'A NEW DISKMAP HAS BEEN CREATED.'
        IF RETCODE = 0
            THEN DO
                SAY
                IF FILENAME = ''
                    THEN SAY 'USER: ' USERID.1 'HAS BEEN' ACTION
                    ELSE DO
                        SAY 'ALL USERS IN THE LIST:' FILENAME,
                            'HAVE BEEN' ACTION
                    END
            END
            ELSE DO
                SAY
                SAY 'THE FOLLOWING USER(S) WERE NOT FOUND',
                    'IN THE DIRECTORY !!!!!'
                SAY
                DO I = 1 TO COUNT
                    IF FLAG.I = 0 THEN SAY USERID.I
                END
                SAY
                SAY 'ALL OTHERS HAVE BEEN' ACTION
                CALL LOGERROR 5, COUNT, FILENAME
            END
    END
    WHEN SUBCODE = 2 THEN DO
        ARG SUBCODE, FILENAME
        IF FILENAME = ''
        THEN SAY 'THE USER:' USERID.1 'WAS NOT FOUND IN THE DIRECTORY !'
        ELSE SAY 'NO ONE INCLUDED IN THE LIST:' FILENAME,
                 'WAS FOUND IN THE DIRECTORY !!!'
        SAY
        SAY 'THEREFORE, NO ACTION WAS TAKEN.'
    END
    OTHERWISE NOP
END
RETURN
/*     This is the   END  of MODIFY MODULE   ................         */
/* QUIT IS CALLED ONLY BY THE MAIN MENU. PREPARES FOR EXIT.         **
** THE FILE MAINT NETLOG IS CREATED WHEN NEW USERS ARE ADDED, OR    **
** WHEN THE PROFILE STUDENT IS SENT. SINCE NETLOGS KEEP GROWING, IT **
** IS ERASED HERE. THIS IS FFF DISK AND NOT 191 THAT MAY HAVE THE   **
** USUAL NETLOG FILE.                                               */
QUIT:
'SET CMSTYPE HT'
'ERASE * NETLOG'
'SET CMSTYPE RT'
'CLRSCRN'
'CP SET MSG ON'
'CP SET IMSG ON'
'CP SET EMSG ON'
'CP SET SMSG ON'
RETURN '*'
/* FINDLIST RECEIVES THE NAME OF THE LIST WHICH CONTAINS USER-IDS.  **
** IT IS CALLED BY: ADDLIST, DELLIST AND MODLIST, AND RETURNS THE   **
** THE NUMBER OF USER-IDS IN THE LIST. IT ALSO PUTS THE USER-IDS IN **
** THE ARRAY USERID.I . WHEN READING THE LISTFILE, BLANK LINES AND  **
** LINES BEGINNING WITH * ARE IGNORED. ONLY THE FIRST STRING IS     **
** PUT IN USERID.I, ALL OTHER STRINGS ON THAT LINE ARE IGNORED. SO, **
** IN THE LISTFILE, AFTER ENTERING USER-ID, ONE CAN ENTER USER'S    **
** NAME, SSN, AND OTHER INFORMATION. FIRST STRING ON A LINE DOES    **
** NOT HAVE TO START AT COLUMN ONE.                                 */
FINDLIST:
LISTNAME = ARG(1)
SAY 'GETTING USERS FROM' LISTNAME 'USERLIST A'
'SET CMSTYPE HT'
'STATE' LISTNAME 'USERLIST A'
IF RC ¬= 0 THEN CALL ERRMSG 1, RC, LISTNAME, 'USERLIST', 'A'
'MAKEBUF'
COUNT = 0
DO FOREVER
    'EXECIO 1 DISKR' LISTNAME 'USERLIST A (VAR LINE'
    IF RC ¬= 0 THEN
        IF RC ¬= 2 THEN CALL ERRMSG 2, RC, LISTNAME, 'USERLIST', 'A'
                   ELSE LEAVE
    PARSE VAR LINE USERID .
    IF ( LENGTH(USERID) > 0 ) & ( LEFT(USERID, 1) ¬= '*' )
        THEN DO
            COUNT = COUNT + 1
            USERID.COUNT = USERID
        END
END
'DROPBUF'
'FINIS' LISTNAME 'USERLIST A'
'SET CMSTYPE RT'
DUPFLAG = 'FALSE'   /* NO DUPLICATE */
IF COUNT > 0 THEN DO    /* CHECK FOR DUPLICATE NAMES IN LIST */
    DUP. = 0            /* ALL USER-IDS ARE UNIQUE */
    DO I = 1 TO COUNT - 1
        DO J = I+1 TO COUNT
            IF USERID.J = USERID.I THEN DO
                DUPFLAG = 'TRUE'
                DUP.I = 1
            END
        END
    END
END
IF DUPFLAG = 'TRUE' THEN DO
    SAY
    SAY 'THE FOLLOWING USER-ID(S) ARE DUPLICATE IN THE LIST.'
    SAY 'CHECK THE LIST, AND THEN PROCEED.'
    SAY
    DO I = 1 TO COUNT
        IF DUP.I = 1 THEN SAY USERID.I
    END
    CALL LOGERROR 7, COUNT, LISTNAME
    RETURN -1
END
RETURN COUNT
/* CHECKMAP IS CALLED BY ADDEND, ONLY. IT CHECKS FOR                 **
** GAP TO FIT THE USER(S) ON THE REQUESTED VOLUME (VOLSER). A LIST OF**
** USERS WILL BE ALLOCATED CONTIGUOUSLY. IF VOLSER IS NOT VALID, OR  **
** A LARGE ENOUGH GAP IS NOT FOUND, A MESSAGE IS ISSUED AND PROCESS  **
** TERMINATES. IF READ OR WRITE ERRORS OCCUR, THE PROGRAM ABORTS.    */
CHECKMAP:
ARG VOLSER, GAPSIZE, BEGINBLK
MAPFLAG = 0           /* THERE IS ENOUGH GAP */
/* CHECK IF MAP EXISTS. IF NOT, CREATE ONE BEFORE PROCEEDING.         */
'SET CMSTYPE HT'
'STATE USER DISKMAP A'
RETCODE = RC
'SET CMSTYPE RT'
IF RETCODE ¬= 0 THEN DO   /* DISKMAP NOT FOUND, CREATE A NEW ONE */
  SAY
  SAY 'DISKMAP WAS NOT FOUND. A NEW ONE WILL BE MADE BEFORE PROCEEDING.'
  CALL UPDATEMAP
  END
/* THE DISKMAP IS READY, PROCEED WITH GAP CHECKING.  *****************/
SAY
SAY 'CHECKING DISKMAP FOR OVERLAPS .......'
'MAKEBUF'
DO FOREVER        /* BIGLOOP, TO RESTART IF DISKMAP WAS DAMAGED */
/* FIRST CHECK IF VOLSER IS A VALID VOLUME ON THE SYSTEM.            */
DO FOREVER
    'EXECIO 1 DISKR USER DISKMAP A (VAR LINE'
    IF RC ¬= 0 THEN
        IF RC ¬= 2 THEN CALL ERRMSG 2, RC, 'USER', 'DISKMAP', 'A'
             ELSE DO
             CALL MAPERR 1
             SIGNAL GETOUT
             END
    PARSE VAR LINE VOLUME .
    IF SPACE(VOLUME) = VOLSER THEN LEAVE
END
/* NOW SEE IF THERE IS A LARGE ENOUGH GAP TO FIT THE USER(S).        */
DO FOREVER
    'EXECIO 1 DISKR USER DISKMAP A (VAR LINE'
    IF RC ¬= 0 THEN
        IF RC ¬= 2 THEN CALL ERRMSG 2, RC, 'USER', 'DISKMAP', 'A'
             ELSE DO
             CALL MAPERR 2
             SIGNAL GETOUT
             END
    PARSE VAR LINE FIELD1 FIELD2 SIZE GAP
    IF FIELD1 = 'VOLUME'
             THEN DO
             CALL MAPERR 2
             SIGNAL GETOUT
             END
    IF DATATYPE(FIELD1, W)
        THEN DO
        IF SPACE(GAP) ¬== 'GAP'
             THEN DO        /* DISKMAP NOT VALID, CREATE A NEW ONE */
                 'FINIS USER DISKMAP A'
                 SAY
                 SAY 'DISKMAP FILE IS NOT VALID. ',
                     'A NEW ONE WILL BE MADE FOR OVERLAP CHECKING'
                 CALL UPDATEMAP
                 LEAVE            /* START AT TOP OF BIGLOOP */
                 END
        IF  (BEGINBLK <  FIELD1)
             THEN DO
             CALL MAPERR 2
             SIGNAL GETOUT
             END
        IF ((BEGINBLK >= FIELD1) & (TOTAL <= FIELD2 +1))
                   THEN SIGNAL GETOUT   /* GAP WAS FOUND */
        END
END
END           /* BIGLOOP */
GETOUT:
'DROPBUF'
'FINIS USER DISKMAP A'
RETURN MAPFLAG
/* MAPERR IS ONLY CALLED BY CHECKMAP TO PRINT AN ERROR MESSAGE.       */
MAPERR:
MAPFLAG = ARG(1)       /* INSUFFICIENT GAP */
SELECT
    WHEN MAPFLAG = 1 THEN DO
SAY
SAY 'THE VOLUME' VOLSER 'DOES NOT EXIST ON THE DISKMAP !!!!'
    END
    WHEN MAPFLAG = 2 THEN DO
SAY
SAY 'THERE IS NOT A GAP OF SIZE' GAPSIZE 'ON' VOLSER,
    'STARTING AT' BEGINBLK '!!!'
    END
    OTHERWISE NOP
END
RETURN
/* SUBMOD: EXISTDIREC. CHECKS IF USER DIRECT, IS ON MAINT DISK FFF    **
** ACCESSED AS A. IF NOT, IT WILL TRY TO COPY THE LAST BACK-UP FROM   **
** MAINT 191, ACCESSED AS C, ON A DISK. IF ALL FAILS, PROGRAM ABORTS. **
** IT IS CALLED BY: ADDEND, DELEND, MODEND.                           */
EXISTDIREC:
'SET CMSTYPE HT'
'STATE USER DIRECT A'
IF RC ¬= 0 THEN DO
        'STATE USER DIRECT C'
        IF RC ¬= 0 THEN CALL ERRMSG 1, RC, 'USER', 'DIRECT', 'C'
              ELSE DO
                 'COPYFILE USER DIRECT C = = A'
                 IF RC ¬= 0 THEN CALL ERRMSG 10
              END
END
'SET CMSTYPE RT'
'MAKEBUF'
CALL READLINE 'USER', 'DIRECT'
CALL READLINE 'USER', 'DIRECT'      /* CHECK FOR TIME AND DATE */
PARSE VAR LINE  . TIME .
'DROPBUF'
IF SPACE(TIME) ¬= 'TIME:'
   THEN DO
      'FINIS USER DIRECT A'
      LINENUM = 0
      LINE.4 = '**************************************************'
      LINE.4 = LINE.4'********************'
      LINE = LINE.4
      CALL WRITELINE 'CUSTTEMP', LINENUM
      CALL PUTTIMEDIR 'CUSTTEMP', LINENUM
      LINE = LINE.4
      CALL WRITELINE 'CUSTTEMP', LINENUM
      'MAKEBUF'
      DO FOREVER
         CALL READLINE 'USER', 'DIRECT'
         IF RESULT ¬= 0 THEN LEAVE
         CALL WRITELINE 'CUSTTEMP', LINENUM
      END
      'FINIS CUSTTEMP DIRECT A'
      'DROPBUF'
      'ERASE USER DIRECT A'
      'RENAME CUSTTEMP DIRECT A USER = ='
   END
'FINIS USER DIRECT A'
RETURN
/* SUBMOD: PUTTIMEDIR. PUTS CURRENT TIME AT TOP OF DIRECTORY.         **
** THE CALLER MUST HAVE WRITTEN THE FIRST LINE (ALL *), AND SO WILL   **
** HAVE INITIALIZED LINENUM TO 0. THE SECOND LINE IN THE DIRECTORY IS **
** TIME AND DATE. IT IS READ AND IGNORED HERE (DROPBUF). THIS SUBMOD, **
** THEN WRITES THE NEW TIME AND DATE AS THE SECOND LINE. THE REST OF  **
** THE DIRECTORY MUST BE COPIED BY THE CALLER.                        */
PUTTIMEDIR:
ARG FNAME, LINENUM
SAY
SAY 'INSERTING TIME AND DATE AT TOP OF DIRECTORY.....'
'MAKEBUF'
CALL READLINE 'USER', 'DIRECT'        /* IGNORE PREVIOUS TIME LINE */
'Q TIME ( STACK'
PULL . . TIME . DAY DATE
LINE = '*          TIME: 'TIME
LINE = SUBSTR(LINE, 1, 30, ' ')
LINE = LINE'DAY: 'DAY
LINE = SUBSTR(LINE, 1, 50, ' ')
LINE = LINE'DATE: 'DATE
LINE = SUBSTR(LINE, 1, 69, ' ')
LINE = LINE'*'
CALL WRITELINE FNAME, LINENUM
'DROPBUF'
RETURN
/* SUBMOD: CHECKDIR. USED ONLY BY ADDUSERS MODULE, CHECKS IF THE NEW  **
** USER-IDS ARE ALREADY USED IN THE CP DIRECTORY. IF SO, THE MATCHES  **
** ARE PRINTED TO THE SCREEN, AND LOGGED IN USERS ERRORLOG. THE ADD   **
** OPERATION CANNOT PROCEED UNTIL ALL MATCHING USER-IDS ARE CHANGED.  */
CHECKDIR:
ARG COUNT, FILENAME
SAY
SAY 'CHECKING THE DIRECTORY FOR DUPLICATE USER-ID(S).....'
/* EXISTENCE OF USER DIRECT HAS BEEN CHECKED BY EXISTDIREC ***********/
'MAKEBUF'
FLAG. = 0             /* EVERY USER-ID IS UNIQUE */
FOUND = 'FALSE'       /* NO MATCHES FOUND */
DO FOREVER            /* CHECK EVERY USER IN CP AGAINST THE NEW USERS */
    CALL READLINE 'USER', 'DIRECT'
    IF RC ¬= 0 THEN LEAVE      /* EOF */
    PARSE VAR LINE USER USERID .
    IF USER = 'USER' THEN           /* A USER STATEMENT IN CP */
            DO I=1 TO COUNT
                IF USERID = USERID.I THEN DO   /* MATCHES NEW USER */
                      FLAG.I = 1
                      FOUND = 'TRUE'
                      IF COUNT > 1
                          THEN LEAVE         /* FOR A LIST, CONTINUE */
                          ELSE SIGNAL NOMORE  /* SINGLE USER, DONE */
                END
            END
END
NOMORE:
'FINIS USER DIRECT A'
'DROPBUF'
IF FOUND = 'TRUE' THEN DO      /* MATCHES WERE FOUND */
    'CLRSCRN'
    SAY 'THE FOLLOWING NAME(S) ARE ALREADY USED AND MUST BE CHANGED.'
    SAY
    IF COUNT > 1 THEN
        DO I = 1 TO COUNT
            IF FLAG.I ¬= 0 THEN SAY USERID.I
        END
                 ELSE SAY USERID.1
    CALL LOGERROR 6, COUNT, FILENAME
    RETURN 1                  /* TELL CALLER THERE WERE MATCHES */
END
RETURN 0                      /* TELL CALLER IT IS OK TO PROCEED */
/* UPDATEDIREC EXECUTES THE DIREC COMMAND. IS CALLED BEFORE UPDATEMAP.*/
UPDATEDIREC:
'MAKEBUF'
LINENUM = 0
CALL READLINE 'USER', 'DIRECT'
CALL WRITELINE 'CUSTTEMP', LINENUM
CALL PUTTIMEDIR 'CUSTTEMP', LINENUM
DO FOREVER
   CALL READLINE 'USER', 'DIRECT'
   IF RESULT ¬= 0 THEN LEAVE
   CALL WRITELINE 'CUSTTEMP', LINENUM
END
'DROPBUF'
'FINIS CUSTTEMP DIRECT A'
'ERASE USER DIRECT A'
'RENAME CUSTTEMP DIRECT A USER = ='
SAY
SAY 'NOW EXECUTING: DIRECT USER DIRECT A .....'
'SET CMSTYPE HT'
'DIRECT USER DIRECT A'
IF RC ¬= 0 THEN CALL ERRMSG 7, RC
'COPY USER DIRECT A = = C ( REPLACE'
'SET CMSTYPE RT'
DIRECTFLAG = 1          /* USED IN MAIN MENU, BEFORE QUIT, FOR BACKUP */
RETURN
/* UPDATEMAP IS CALLED BY ADDEND, DELEND, MODEND AND EXISTMAP.        */
UPDATEMAP:
SAY
SAY 'NOW EXECUTING: DISKMAP USER DIRECT .....'
'SET CMSTYPE HT'
'DISKMAP USER DIRECT'
IF RC ¬= 0 THEN CALL ERRMSG 8, RC
'SET CMSTYPE RT'
RETURN
/* GETRESPONSE STAYS IN LOOP UNTIL INPUT IS ENTERED BY USER, WHICH IT **
** RETURNS TO CALLER.                                                 */
GETRESPONSE:
PROCEDURE
SAY
RESPONSE = ''
DO WHILE (RESPONSE = '')
    PULL RESPONSE
END
RESPONSE = SPACE(RESPONSE)
IF LEFT(RESPONSE, 1) == '*' THEN RETURN '*'
RETURN RESPONSE
/* READLINE IS ONLY USED TO READ A LINE FROM THE CP DIRECTORY, OR     **
** USER'S DIRECTORY ENTRIES. RETURN CODE INDICATES EOF.               */
READLINE:
ARG FILEN, FILET
'EXECIO 1 DISKR' FILEN FILET 'A ( VAR LINE'
IF RC ¬= 0 THEN
    IF RC ¬= 2 THEN CALL ERRMSG 9, RC
               ELSE RETURN 2
RETURN 0
/* WRITELINE IS CALLED TO WRITE TO FILES WITH FIXED FORMAT. THESE WILL**
** NEED A LINE NUMBER. THE VARIABLE LINENUM IS INITIALIZED TO 0 BY THE**
** CALLER. AFTER THAT WRITELINE WILL KEEP TRACK OF IT.                */
WRITELINE:
ARG FILEN, LINENUM
LINENUM = LINENUM + 1
'EXECIO 1 DISKW' FILEN 'DIRECT A' LINENUM 'F 80 (STRING' LINE
IF RC ¬= 0 THEN CALL ERRMSG 9, RC
RETURN
/* WRITEFILE IS CALLED TO WRITE TO FILES WITH VARIABLE FORMAT, WHICH  **
** WILL NOT NEED A LINE NUMBER. MODDISK CALLS THIS SUBMOD.            */
WRITEFILE:
ARG FILNA, FILTY
'EXECIO 1 DISKW' FILNA FILTY 'A (STRING' LINE
IF RC ¬= 0 THEN CALL ERRMSG 9, RC       /***** CHECK IF SUITABLE ***/
RETURN
/* WAITLOOP GIVES USER A CHANCE TO SEE THE SCREEN BEFORE MOVING ON.   */
WAITLOOP:
IF LOGFLAG ¬= 0
   THEN DO
   SAY
   SAY 'WARNING! MAKE SURE TO CHECK: USERS ERRORLOG, ON MAINT FFF DISK.'
   END
IF LOGWRTFLG ¬= 0
   THEN DO
   SAY
   SAY 'ERROR' LOGWRTFLG 'WHEN WRITING TO USERS ERRORLOG FILE.'
   END
SAY
SAY
SAY
SAY
SAY 'PRESS RETURN TO CONTINUE..........'
PULL ANSWER
RETURN
/* LOGERROR LOGS CERTAIN ERRORS FOR FUTURE USE. FOR EXAMPLE A LIST OF **
** USER-IDS MAY CONTAIN SEVERAL DUPLICATES. THEY ARE PRINTED TO THE   **
** SCREEN, BUT ALSO WRITTEN TO: USERS ERRORLOG FILE FOR CONVENIENCE.  */
LOGERROR:
CODE = ARG(1)
'MAKEBUF'               /* FOR DISKW */
IF LOGFLAG = 0
    THEN DO
        LOGFLAG = 1
        'MAKEBUF'
        'Q TIME ( STACK'
        PULL . . TIME . DAY DATE
        'DROPBUF'
        ERRORM = '* ERROR(S) OCCURRED ON' DAY DATE 'TIME' TIME '*'
        ASTERISK = SUBSTR('*', 1, LENGTH(ERRORM), '*')
        CALL WRITELOG ASTERISK
        CALL WRITELOG ERRORM
        CALL WRITELOG ASTERISK
    END
SELECT
    WHEN CODE = 1 THEN DO
    ARG CODE, CMSERR, USERID
    ERRORM = 'ERROR' CMSERR 'RECEIVED WHEN SENDING FILE: PROFILE '
    ERRORM = ERRORM'STUDENT TO: ' USERID
        END
    WHEN CODE = 2 THEN DO
    ARG CODE, CMSERR, USERID
    ERRORM = 'ERROR' CMSERR 'RECEIVED WHEN AUTOLOGING' USERID
        END
    WHEN CODE = 3 THEN DO
    ARG CODE, CMSERR, USERID
    ERRORM = 'ERROR' CMSERR 'RECEIVED WHEN EXECUTING CP SEND: ' USERID
        END
    WHEN CODE = 4 THEN DO
    ARG CODE
    ERRORM = 'MAINT 191 WAS FULL. OLD DIRECTORY IS ON FFF: OLDUSER '
    ERRORM = ERRORM'DIRECT. MAKE BACKUP ON 191, NOW.'
        END
    WHEN CODE = 5 THEN DO
    ARG CODE, COUNT, FNAME
    ERRORM = 'THE FOLLOWING USER-ID(S) WERE NOT FOUND IN THE DIRECTORY.'
    CALL WRITELOG ERRORM
    IF COUNT > 1 THEN DO
        ERRORM = 'WHEN DELETING/MODIFYING THE LIST:' FNAME
        CALL WRITELOG ERRORM
        ERRORM = '                '
        CALL WRITELOG ERRORM
        DO I = 1 TO COUNT
            IF FLAG.I = 0 THEN CALL WRITELOG USERID.I
        END
        ERRORM = 'THIS IS THE END OF LIST ..............'
                 END
                 ELSE DO
        ERRORM = '                '
        CALL WRITELOG ERRORM
        ERRORM = USERID.1
                 END
        END
    WHEN CODE = 6 THEN DO
    ARG CODE, COUNT, FNAME
    ERRORM = 'THE FOLLOWING USER-ID(S) ARE ALREADY IN CP DIRECTORY.'
    CALL WRITELOG ERRORM
    IF COUNT > 1 THEN DO
        ERRORM = 'CHANGE THEM, AND THEN ADD THE LIST.' FNAME
        CALL WRITELOG ERRORM
        ERRORM = '             '
        CALL WRITELOG ERRORM
        DO I = 1 TO COUNT
            IF FLAG.I = 1 THEN CALL WRITELOG USERID.I
        END
        ERRORM = 'THIS IS THE END OF LIST ..............'
                END
                ELSE DO
        CALL WRITELOG USERID.1
        ERRORM = '             '
        CALL WRITELOG ERRORM
        ERRORM = 'IT MUST BE CHANGED BEFORE ADDING TO CP DIRECTORY.'
                END
        END
    WHEN CODE = 7 THEN DO   /* CAN ONLY HAPPEN IN A LIST, NOT SINGLE */
    ARG CODE, COUNT, FNAME
    ERRORM = 'THE FOLLOWING USER-IDS ARE DUPLICATED IN: ' FNAME
    CALL WRITELOG ERRORM
    ERRORM = 'CHECK THE LIST, CHANGE THEM, THEN PROCEED.'
    CALL WRITELOG ERRORM
    ERRORM = '             '
    CALL WRITELOG ERRORM
    DO I = 1 TO COUNT
        IF DUP.I = 1 THEN CALL WRITELOG USERID.I
    END
    ERRORM = 'THIS IS THE END OF LIST ..............'
        END
    WHEN CODE = 8 THEN DO
    ARG CODE, USER
    ERRORM = USER 'HAS NOT BEEN MODIFIED BECAUSE OF MDISK OVERLAP.'
    CALL WRITELOG ERRORM
    ERRORM = '             '
        END
END
CALL WRITELOG ERRORM
'FINIS USERS ERRORLOG A'
'DROPBUF'                  /* FOR DISKW */
RETURN
/* WRITELOG IS ONLY CALLED BY LOGERROR. IT WRITES TO: USERS ERRORLOG. */
WRITELOG:
ARG LOGSTATEMENT
IF LOGWRTFLG = 0 THEN
    'EXECIO 1 DISKW USERS ERRORLOG A (STRING' LOGSTATEMENT
LOGWRTFLG = RC
RETURN
/* ERRMSG IS ONLY CALLED IN CASE OF SERIOUS ERRORS. PROGRAM WILL **
** ABORT WHEN IT REACHES THIS POINT.                                  */
This article will be concluded next month.

Zorabi Honargohar
Professor and System Administrator
Emporia State University (USA)

