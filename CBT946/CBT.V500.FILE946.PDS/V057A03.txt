Mapping CMS shared memory

Issue 48 of VM Update had an article entitled Virtual memory
map, which produces a virtual memory map for CMS shared
memory.  My program overcomes some of the problems
associated with that article.

I believe that all software programmers have spent much of
their time making modifications to the positions of the shared
segments in CMS storage.  When we install any version of VM
with CMS, IBM gives us the CMS storage already mapped,
with all the segments already defined.  However, we often
encounter one of the following situations:

o      Installing a new version of a program product that uses a
      shared segment, while maintaining, as active, the old one.

o      Installing non-IBM products, which use a shared segment.

o      Increasing the size of a shared segment, eg larger GCS,
      resulting from an increase in the CSA size.

o      Migrating a shared segment to another position.  For
      example, when a shared segment resides just above the
      CMS machine's virtual storage top address and we have to
      increase the size of the CMS machine's virtual storage.

o      Any other reason.

It is difficult to find the best place to put a shared segment
because the map generated by SNTMAP EXEC doesn't show
us clearly the relative positions of the segments, their overlaps,
or the free space in the shared memory.  The map doesn't show
us the end addresses of the segments, and so, if we forget to
look into the system table (DMKSNT), we can increase the
virtual storage of some service machine, unintentionally putting
the segment end address into the storage used by another
segment.

In such situations we need a map that gives us a more visible
layout of the shared memory.  I've seen that for many releases
of VM/SP and VM/SP HPO, IBM has maintained the same
format for the file MEMORY SNTMAP, which is the input file
for this program.

The MAPSNT EXEC generates a file showing the range of
addresses used by shared segments.   After this, it reads a file
called MEMORY SNTMAP A, which is generated by
SNTMAP EXEC, and creates a file containing the
characteristics of the segments.   Using this file, it constructs
the final map over the first file.  Finally it closes the map file,
and deletes all files that are no longer required.  The printing of
the map overlaps the form page limits.  If it did not, the result
would be a segmented map, which would be much more
difficult to use.  An example of the output is shown in Figure
1.


MAPSNT EXEC

/*               Mapping 'CMS SHARED MEMORY'.                   */
/*                                                              */
/*        For device type other than '3380',  change informa-   */
/*        tion on the top of the map.                           */
/*        This EXEC is usually executed on MAINT's user-id.     */
/*        A mini disk accessed as 'A' is necessary.             */
say ' '
say 'This processing is about TWO MINUTES long...'
say 'It creates a CMS file ( MAPSNT LISTING A ) with the SHARED memory map.'
say ' '
_SETPARMS_:
/*  Setting variables used in the processing...  */
 i         = 0
 j         = 0
 k         = 0
 y         = 0
 z         = 0
 cont      = 0
 rcode     = 0
 page      = 0
 segment   = 0
 chrgpoint = d2x(cont)
 'cp set emsg off'
 'erase MAPSNT   LISTING A'
 'erase SNT_SEGS SNTFILE A'
_HEADING_:
/*  Building map's top...   */
queue   '0'
queue '                         *****                                     *****'
queue '+                        *****                                     *****'
queue '                         *****      .SHARED.    MEMORY    MAP      *****'
queue '+                        *****      .SHARED.                       *****'
queue '                         *****                                     *****'
queue '+                        *****                                     *****'
queue   '0'
queue   '-OBS :    1 .SEGMENT. = 64 Kbytes = X(10000) = 16 .PAGES.'
queue   '+OBS :      .SEGMENT.                          16 .PAGES.'
queue   '          1 .PAGE.    =  4 Kbytes = X(1000).'
queue   '+           .PAGE.'
queue   '0         All .SEGMENTS. are on device type .3380.'
queue   '+             .SEGMENTS.                    .3380.'
queue   '          The device .3380. has .150 PAGES. per cylinder.'
queue   '+                    .3380.     .150 PAGES.'
queue   '0'
queue   ' Charge Page Seg'
queue   '+Charge Page Seg'
queue   ' Addres Numb Num         *****     .Shared Segments'.  Name      *****'
queue   '+Addres Numb Num         *****     .Shared Segments'.            *****'
queue   '0'
queue
_WRITEHEAD_:
/*  Writing map's top...   */
 execio '*' diskw MAPSNT LISTING A 0 f 133
 if rc ¬= 0 then signal _WRTNOTOK_
_GENADDR_:
/*  Generating the range of addresses...  */
 do 255
 page = page + 16
 page = right(page,4,0)
 segment = segment + 1
 segment = right(segment,3,0)
 cont = cont + 1
 chrgpoint = d2x(cont)
 chrgpoint = right(chrgpoint,2,0)
 queue ' 'chrgpoint||0000  page  segment
 and
 queue
_WRITEADDR_:
/*  Writing the range of addresses...  */
 execio '*' diskw MAPSNT LISTING A 0 f 133 '(finis'
_READMAP_:
/*  Reading 'MEMORY SNTMAP A' and building the file 'SNT_SEGS SNTFILE A'  */
/*           which contains all the characteristics of the segments... '  */
/*           It assumes, for the input file, the format maintained by  '  */
/* '        'IBM' for 'VM/HPO REL-5.0' and earlier releases...         '  */
 desbuf
 execio '*' diskr MEMORY SNTMAP A 8 '(finis'
 if rc = 24 then signal _NFOUND_
 queue 'SNT*SEGS'
 DO FOREVER
 pull REC_MEM
 if substr(REC_MEM,1,3) = "***" | substr(REC_MEM,1,3) = "   " then nop
    else do
    if substr(REC_MEM,1,3) = "---" then
           do forever
             pull REC_MEM
             if substr(REC_MEM,1,8) = "SNT*SEGS" then signal _WRTSEGS_
           end
_BLDSEGS1_:
    NAME_SEG = substr(REC_MEM,08,8)
    FRST_SEG = substr(REC_MEM,17,3)
    LAST_SEG = substr(REC_MEM,21,3)
    NUMB_SEG = substr(REC_MEM,31,2)
    NAME_SEG = left(NAME_SEG,8,' ')
    FRST_SEG = right(FRST_SEG,3,'0')
    LAST_SEG = right(LAST_SEG,3,'0')
    if LAST_SEG = ' ' then LAST_SEG = FRST_SEG
    QTDE_SEG = LAST_SEG - FRST_SEG + 1
    QTDE_SEG = right(QTDE_SEG,2,'0')
    queue NAME_SEG FRST_SEG LAST_SEG QTDE_SEG
    end
 END
_WRTSEGS_:
/*  Writing the characteristics of the segments...'  */
 queue
 execio '*' diskw SNT_SEGS SNTFILE A
_PREPMAP_:
/*  Reading the characteristics of the segments, adding the name of  */
/*          the segments, building the individual records and        */
/*          writing them, thus constructing the final map...         */
 DO FOREVER
    desbuf
    execio '1' diskr SNT_SEGS SNTFILE A
    if rc = 2 then signal _EXIT_
    pull REC_SEG
    SEG_INI = substr(REC_SEG,10,3)
    SEG_NAM = substr(REC_SEG,1,8)
    SEG_NME = center(strip(SEG_NAM),8,'-')
    SEG_QTD = substr(REC_SEG,18,2)
    desbuf
    execio '*' diskr MAPSNT ,
                      LISTING A 1 '(zone 14 16 locate /'SEG_INI'/ finis'
    pull REC_LINE
    LINE = substr(REC_LINE,8,3)
    pull REC_ADD
    x = 18
    y = 08
    z = 10
    DO WHILE substr(REC_ADD,x,y) ¬= '        '
       x = x + z
       END
    REC_MAP = overlay(SEG_NME,REC_ADD,x)
call _WRITE_
END
signal _EXIT_
_WRITE_:
    desbuf
    queue REC_MAP
    execio '1' diskw MAPSNT LISTING A line '(finis'
    SEG_QTD = SEG_QTD - 1
    if SEG_QTD ¬= '0' then do
                      LINE = LINE + 1
                      SEG_NME = 'IIIIIIII'
                      execio '1' diskr MAPSNT LISTING A line
                      pull REC_ADD
                      REC_MAP = overlay(SEG_NME,REC_ADD,x)
                      signal _WRITE_
                      end
return
_WRTNOTOK_:
/*  Something failed...  */
say ' '
say ' Problem has ocurred on writing...'
say ' Verify mdisk accessed as "A".'
say ' '
signal _EXIT_
_NFOUND_:
/*  The first input file was not found.  This file is generated  */
/*      executing  'SNTMAP'  EXEC, which resides on Maint's CMS  */
/*      mini-disk "193", acessed as "R"...                       */
say ' '
say ' File "MEMORY SNTMAP" not found...'
say ' You must generate it using "SNTMAP" EXEC.'
say ' '
_EXIT_:
/*  MAP created and saved. Clearing of buffers, erasing the file  */
/*      no more required, and resetting the EMSG status, to com-  */
/*      plete the "EXIT"...                                       */
desbuf
'erase SNT_SEGS SNTFILE A'
'cp set emsg on'
exit


SNT_SEGS SNTFILE

Part of an example input file.

XQBESEG  048 058 11
QMF230E  052 079 28
STAIRS   066 067 02
DAS1V151 067 076 10
DTRSEG   071 071 01
GOODIES  072 072 01
ESCMDCSS 073 073 01
DASSSV40 074 095 22
DCFMODS  076 078 03


