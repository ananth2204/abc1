 DL/I scan
DLISCAN is a REXX EXEC that will scan the DBD/PSB source library and create one
member with all the DBDs found (DBDLIST DLI) and another member with all the
PSBs found (PSBLIST DLI).  This is very helpful if you ever have to reassemble
all your DBDs and PSBs.  At our company we were changing our DASDs from 3370
(FBA devices) to 3380 (CKD devices).  We have 10 modules of COPICS installed
with a few hundred DBDs and PSBs.  It was a major task to distinguish DBDs from
PSBs because COPICS does not conform to the same naming convention with all
modules.  This EXEC made it easy for us because we were able to identify all our
DBDs and it took little time to punch out, change, catalog, and reassemble them.
This EXEC could be modified to scan any source library with any search argument.
The two CMS members created are input to the DBD EXEC and the PSB EXEC.  These
two EXECs generate the JCL necessary to reassemble all the modules.  Also these
two EXECs can be used to reassemble one module at a time.  This will catalog the
module first before re-assembling it.
DLISCAN REXX EXEC
/* THIS EXEC WILL SCAN THE DLI SOURCE LIBRARY AND CREATE TWO */
/* CMS MEMBERS, ONE WITH ALL THE DBDS AND THE OTHER WITH ALL */
/* THE PSBS.                                                 */
TRACE OFF
'VMFCLEAR'
SAY 'DLISCAN EXEC IN PROGRESS -- PLEASE WAIT . . . . . '
SAY ' '
'SET CMSTYPE HT'
'ERASE DBDLIST DLI A'
'ERASE PSBLIST DLI A'
'ACCESS 420 G'
'SET DOS ON G'
'SET DOSPART 128K'
'ACCESS 505   H'
'ASSGN SYSSLB H'
'DLBL IJSYSSL H DSN DLI.PRIVATE.SLB (SYSSLB'
'SET CMSTYPE RT'
SAY 'DLI DSERV BEING PREPARED . . . . . . .'
SAY ' '
'SET CMSTYPE HT'
'CP SPOOL PRT CLASS D NOCONT'
'CP SPOOL PUN CLASS D CONT'
DSERV:
/* PUT DSERV LISTING IN VIRTUAL PRINT                          */
'SET IMPEX OFF'
'DSERV SD ( SORT PRINT'
'SPOOL PRT CLASS A NOCONT'
'SET CMSTYPE RT'
SAY 'DSERV MAP BEING TRANSFERRED . . . . . .'
SAY ' '
'SET CMSTYPE HT'
/* TRANSFER DSERV LISTING FROM VIRTUAL PRINT TO VIRTUAL READER */
/* AND THEN PUT IT IN THE PROGRAM STACK (FIFO).                */
'EXECIO 0 CP ( FIFO STRING TRANSFER PRINT CLASS D TO * RDR'
'EXECIO * CARD ( FIFO'
'SET CMSTYPE RT'
SAY 'DLI SSERV BEING PREPARED . . . . . . . .'
SAY ' '
'SET CMSTYPE HT'
/*   READ THE DSERV LISTING FROM THE PROGRAM STACK AND SSERV    */
/*   EACH A.MEMBER AND PLACE THEM IN THE PROGRAM STACK (FIFO).  */
/*   EACH 'CATALS' LINE IDENTIFIES THE ACTUAL MEMBER NAME.      */
SSERV:
DO QUEUED()
  PULL LINE
  IF SUBSTR(LINE,6,7) = 'A     ' & SUBSTR(LINE,13,8) ¬= ' ' THEN
    DO
      PUSH 'CATALS 'SUBSTR(LINE,13,8)
      'EXECIO 1 PUNCH'
      'SSERV A ' SUBSTR(LINE,13,8) ' (PUNCH'
     END
  IF SUBSTR(LINE,72,7) = 'A      ' & SUBSTR(LINE,79,8) ¬= ' ' THEN
    DO
      PUSH 'CATALS 'SUBSTR(LINE,79,8)
      'EXECIO 1 PUNCH'
      'SSERV A ' SUBSTR(LINE,79,8) ' ( PUNCH'
    END
END
'SPOOL PUN CLOSE NOCONT'
'SET CMSTYPE RT'
SAY 'SSERV MAP BEING TRANSFERRED . . . . . '
SAY ' '
'SET CMSTYPE HT'
/* TRANSFER SSERV MEMBERS FROM VIRTUAL PUNCH TO VIRTUAL READER */
/* AND THEN PUT IT IN THE PROGRAM STACK (FIFO).                */
'EXECIO 0 CP ( FIFO STRING TRANSFER PUNCH CLASS D TO * RDR'
'EXECIO * CARD ( FIFO'
'SET CMSTYPE RT'
SAY 'DBD/PSB ARRAYS BEING CREATED. . . . . .'
SAY ' '
'SET CMSTYPE HT'
/*  READ THE SSERV MEMBERS FROM THE PROGRAM STACK AND BUILD         */
/*  TWO ARRAYS, ONE FOR ALL PSBS AND THE OTHER FOR ALL DBDS.        */
X = 0
Y = 0
LINES = QUEUED()
DO I = 1 TO LINES
  PULL LINE
    IF INDEX(LINE,'CATALS') = 1 THEN
      DO
        MEMNAME = SUBSTR(LINE,8,8)
      END
    ELSE
/* LOCATE DBD MACRO BETWEEN COLUMNS 1 THRU 20                       */
      IF INDEX(LINE,' DBD ') > 0  & INDEX(LINE,' DBD ') < 20 THEN
        DO
          IF SUBSTR(LINE,1,1) ¬='*' THEN
          DO
            IF INDEX(LINE,'NAME=') ¬= 0 THEN
              DO
                X = X + 1
                DBD.X = MEMNAME
              END
            ELSE
              DO
                PULL LINE
                I = I + 1
                IF INDEX(LINE,'NAME=') ¬= 0 THEN
                  DO
                    X = X + 1
                    DBD.X = MEMNAME
                  END
              END
          END
      END
       ELSE
        IF INDEX(LINE,'PSBNAME=') ¬= 0 & SUBSTR(LINE,1,1) ¬= '*' THEN
            DO
              IF PSB.Y ¬= MEMNAME THEN
                DO
                  Y = Y + 1
                  PSB.Y = MEMNAME
                END
            END
END
'SET CMSTYPE RT'
 SAY 'DBD/PSB MEMBERS BEING CREATED . . . . .'
SAY ' '
'SET CMSTYPE HT'
/* CREATE DBD MEMBER   */
PUSH '@DBDLIST'
'EXECIO 1 DISKW DBDLIST DLI A 0 F 80'
DO I = 1 TO X
  PUSH 'DBD 'DBD.I
  'EXECIO 1 DISKW DBDLIST DLI A 0 F 80'
END
/* CREATE PSB MEMBER    */
PUSH '@PSBLIST'
'EXECIO 1 DISKW PSBLIST DLI A 0 F 80'
DO I = 1 TO Y
  PUSH 'PSB 'PSB.I
  'EXECIO 1 DISKW PSBLIST DLI A 0 F 80'
END
'SET CMSTYPE RT'
SAY 'DBD/PSB MEMBERS BEING SORTED. . . . . .'
SAY ' '
'SET CMSTYPE HT'
QUEUE 'SORT * A 01 12'
QUEUE 'FILE'
XEDIT 'DBDLIST DLI A'
QUEUE 'SORT * A 01 12'
QUEUE 'FILE'
XEDIT 'PSBLIST DLI A'
SIGNAL EXIT
EXIT:
'REL 420'
'REL 505'
'SET DOS OFF
'SET IMPEX ON'
EXIT
The DBD EXEC and the PSB EXEC are almost identical.  The DBD EXEC is printed
here with the additional lines required for the PSB EXEC added as comments.
DBD REXX EXEC
TRACE OFF
'ID (LIFO'
PULL USERID .
USERNAME = ''
USERCLASS= ''
PUSH USERID USERNAME USERCLASS
EXEC LOOKUP
PULL USERID USERNAME USERCLASS
STR1 = 'DBD'USERNAME',DISP=D,CLASS=0,USER='USERCLASS
STR2 = 'DBD'USERNAME
BJM = Q
IF USERCLASS = 'TECHSUPPORT'   THEN BJM  = T
PARSE UPPER ARG LINE
LOC = INDEX(LINE,'(')
IF LOC ¬= 0  THEN  NEW_ARGS = LEFT(LINE,LOC-1)
  ELSE  NEW_ARGS = LINE;
PARSE UPPER VAR NEW_ARGS  FN  FT  FM .
IF FN = ''      THEN  SIGNAL  HELP
IF FN = 'HELP'  THEN  SIGNAL  HELP
IF FT = ''      THEN  FT = 'JCL'
IF FM = ''      THEN  FM = '*'
FILE_INFO = FN FT FM
MAIN_FILE_SIZE = FILE_SIZE(FILE_INFO)
NOCLOSE = 0
NOCONTROL = 0
DEST_MACHINE = PHILA
IF LOC = 0 THEN  SIGNAL NOOPTIONS
OPTIONS = SUBSTR(LINE,LOC+1)
PARSE UPPER VAR OPTIONS OPTION.1 OPTION.2 OPTION.3 .
 NUMBER_OF_OPTIONS = 3
DO I = 1 TO NUMBER_OF_OPTIONS
 SELECT;
 WHEN OPTION.I = ''          THEN  ITERATE
 WHEN OPTION.I = 'NOCLOSE'   THEN  NOCLOSE = 1
 WHEN OPTION.I = 'CLOSE'     THEN  NOCLOSE = 0
 WHEN OPTION.I = 'P'         THEN  DEST_MACHINE = 'PHILA'
 WHEN OPTION.I = 'PHILA'     THEN  DEST_MACHINE = 'PHILA'
 WHEN OPTION.I = 'S'         THEN  DEST_MACHINE = 'SPART'
 WHEN OPTION.I = 'START'     THEN  DEST_MACHINE = 'SPART'
 OTHERWISE
  DO
   SAY 'INVALID OPTION = 'OPTION.I
   SAY 'DBD ABORTED.'
   EXIT 8
  END
 END
END I
NOOPTIONS:
'EXECIO 1 DISKR 'FILE_INFO '(FINI'
IF RC ¬= 0 THEN SIGNAL    FIRST_LINE_ERROR
PULL LINE1
IF NOCLOSE = 0  THEN             /* SHOULD WE OPEN THE SPOOL FILE? */
 DO
  'SPOOL PUN TO 'DEST_MACHINE'VSE CLASS A CONT'
END;
IF LEFT(LINE1,8) = '@DBDLIST' THEN    /* use @PSBLIST for PSB EXEC */
  DO  I = 2 TO MAIN_FILE_SIZE
    'EXECIO 1 DISKR 'FILE_INFO I '(FINIS'
    IF RC ¬= 0  THEN  SIGNAL  GET_LINE_ERROR
    PULL SUB_DBD SUB_NAME .
    IF LEFT(SUB_NAME,2) = '* ' THEN  ITERATE
    SUB_NAMED = LEFT(SUB_NAME,8)
    SAY '*>SUBMITTING  'SUB_NAMED' TO  'DEST_MACHINE'VSE'
       'EXECIO 1 PUNCH ( STRING * $$ JOB JNM='STR1
       'EXECIO 1 PUNCH ( STRING * $$ LST CLASS='BJM
       'EXECIO 1 PUNCH ( STRING // JOB 'STR2 '--- FOR 'USERNAME
       'EXECIO 1 PUNCH ( STRING // OPTION CATAL'
       'EXECIO 1 PUNCH ( STRING // LIBDEF CL,SEARCH=(DLICL),TO=DLICL'
       'EXECIO 1 PUNCH ( STRING // LIBDEF RL,SEARCH=(DLIRL,MFGRL)'
       'EXECIO 1 PUNCH ( STRING // LIBDEF SL,SEARCH=(DLISL,MFGSL),
       'EXECIO 1 PUNCH ( STRING // EXEC ASSEMBLY'
       'EXECIO 1 PUNCH ( STRING          COPY 'SUB_NAME
       'EXECIO 1 PUNCH ( STRING          END'
       'EXECIO 1 PUNCH ( STRING /*'
       'EXECIO 1 PUNCH ( STRING // EXEC LNKEDT'
*       'EXECIO 1 PUNCH ( STRING // LIBDEF CL,SEARCH=(DLICL),
*                                                  FROM=DLICL,TO=DLICL'
*       'EXECIO 1 PUNCH ( STRING //OPTION CATAL'
*       'EXECIO 1 PUNCH ( STRING // EXEC DLZUACBO,SIZE=128K'
*                                    STR3 = SUB_NAME',OUT=LINK,DMB=YES'
*       'EXECIO 1 PUNCH ( STRING      BUILD PSB='STR3
*       'EXECIO 1 PUNCH ( STRING /*'
*       'EXECIO 1 PUNCH ( STRING // EXEC LNKEDT'
       'EXECIO 1 PUNCH ( STRING /&'
       'EXECIO 1 PUNCH ( STRING * $$ EOJ'
  END I
 ELSE DO
/* SAVE THE EXISTING PF3 KEY... */
'EXECIO 1 CP ( LIFO STRING QUERY PF03'
PULL GOODPF3
/* SET THE PF3 KEY TO SOMETHING WE CAN UNDERSTAND... */
/CP SET PF03 IMMED ABORT'
SAY '*              CATALOG AND ASSEMBLE DBD TO DLILIB             *'
SAY '*  COMMAND: DBD  'FN  'CLASS='BJM'                            *'
SAY '*    PRESS ENTER TO CONTINUE OR PF3 KEY TO ABORT THIS REQUEST *'
 PULL ANSWER
IF ANSWER =  'ABORT'         THEN SIGNAL USER_ABORTED
       'EXECIO 1 PUNCH ( STRING * $$ JOB JNM='STR1
       'EXECIO 1 PUNCH ( STRING * $$ LST CLASS ='BJM
       'EXECIO 1 PUNCH ( STRING // JOB 'STR2 '--- FOR 'USERNAME
       'EXECIO 1 PUNCH ( STRING // LIBDEF SL,TO=DLISL'
       'EXECIO 1 PUNCH ( STRING // EXEC MAINT'
          STRN =  'A.'FN
       'EXECIO 1 PUNCH ( STRING      CATALS ' STRN
       'EXECIO 1 PUNCH ( STRING       BKEND ' STRN
                 'PUNCH 'FILE_INFO' (NOH'
       'EXECIO 1 PUNCH ( STRING       BKEND'
       'EXECIO 1 PUNCH ( STRING /*'
       'EXECIO 1 PUNCH ( STRING // OPTION CATAL'
       'EXECIO 1 PUNCH ( STRING // LIBDEF CL,SEARCH=(DLICL),TO=DLICL'
       'EXECIO 1 PUNCH ( STRING // LIBDEF RL,SEARCH=(DLIRL,MFGRL)'
       'EXECIO 1 PUNCH ( STRING // LIBDEF SL,SEARCH=(DLISL,MFGSL)'
       'EXECIO 1 PUNCH ( STRING // EXEC ASSEMBLY'
       'EXECIO 1 PUNCH ( STRING          COPY 'FN
       'EXECIO 1 PUNCH ( STRING          END'
       'EXECIO 1 PUNCH ( STRING /*'
       'EXECIO 1 PUNCH ( STRING // EXEC LNKEDT'
*      'EXECIO 1 PUNCH ( STRING // LIBDEF CL,SEARCH=(DLICL),
*                                                 FROM=DLICL,TO=DLICL'
*      'EXECIO 1 PUNCH ( STRING // OPTION CATAL'
*      'EXECIO 1 PUNCH ( STRING // EXEC DLZUACBO,SIZE=128K'
*                                         STR3 = FN',OUT=LINK,DMB=YES'
*      'EXECIO 1 PUNCH ( STRING      BUILD PSB='STR3
*      'EXECIO 1 PUNCH ( STRING /*'
*      'EXECIO 1 PUNCH ( STRING // EXEC LNKEDT'
       'EXECIO 1 PUNCH ( STRING /&'
       'EXECIO 1 PUNCH ( STRING * $$ EOJ'
END
IF NOCLOSE = 0  THEN
 DO
    'SPOOL PUN CLOSE '
    'SPOOL PUN TO SYSTEM NOCONT'
     SAY 'DONE SUBMITTING  'FN FT FM' TO 'DEST_MACHINE'VSE'
 END;
SIGNAL EXIT
/* ERROR ROUTINES */
USER_ABORTED:
SAY 'FUNCTION ABORTED AT USER'S REQUEST... NO ACTION TAKEN'
SIGNAL EXIT
HELP:
VMFCLEAR
SAY ' DBD:'                                /* use PSB for PSB EXEC */
SAY '   THIS EXEC IS USED TO SEND JOBS TO BE EXECUTED ON PHILAVSE OR'
SAY '   SPARTVSE.  THE CALLING PARAMETERS ARE:'
SAY '      DBD   FN|HELP  <FT FM  < (  PHILA|SPART  ) >  '
SAY '           DEFAULTS:  FT       JCL   '
SAY '                      FM        *    '
SIGNAL EXIT
GET_LINE_ERROR:
CODER = RC
VMFCLEAR
SAY ' ERROR DURING GET LINE OF 'FN FT FM
SAY ' ERROR CODE ='CODER
SAY ' PLEASE INFORM TECH SUPPORT.'
SIGNAL EXIT
FIRST_LINE_ERROR:
CODER = RC
VMFCLEAR
SAY ' ERROR DURING GET LINE OF 'FN FT FM
SAY ' ERROR CODE ='CODER
SAY ' PLEASE CHECK AND TRY AGAIN.'
 SIGNAL EXIT
EXIT:
/* RESET THE PF3 KEY BACK TO WHAT IT ONCE WAS... */
'CP SET 'GOODPF3
EXIT
FILE_SIZE:
'ESTATE 'ARG(1)
IF RC ¬= 0 THEN
 DO
   VMFCLEAR
   SAY 'CANNOT OPEN FILE = 'ARG(1)
   SAY 'ERROR CODE = 'RC
   SAY 'PLEASE CHECK & TRY AGAIN.'
   SAY
   SIGNAL EXIT
 END;
'LISTFILE 'ARG(1)' (LABEL FIFO'
PULL FN FT FM FORMAT LRECL NUMBER_OF_RECS BLOCKS DATE TIME LABEL
RETURN(NUMBER_OF_RECS);
Robert Ferro
Systems Programmer
Progress (USA)      ) Xephon 1988












































