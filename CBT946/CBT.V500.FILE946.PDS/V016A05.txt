 3270 I/O synchronisation (continued)

Last month we published the first part of this article which describes the QTS
Library. This is a small set of Assembler subroutines for VM/CMS which provides
basic language-independent tools for synchronising IBM 3270 terminal I/O
operations.  This month we publish the second part of the article.



BUGS AND INSECURITIES

%    While interrupts are disabled, which they must be between check time and
wait time, only one interrupt will queue on the system and others will be lost.
These periods of time are very short, but are, nonetheless, there.

%    The interval timer is used for timing, but is it the best?

%    The interrupt handler should be a nucleus extension so users don't pay such
a heavy price when their programs forget to clear a handler (or abend before
they get a chance to).

%    There is no control over the order in which devices are scanned for
interrupts in a multi-device environment.

%    The internal data structure used for book-keeping is inefficient.

%    Some routines need to change the system mask in the PSW, and, when they
restore it before returning, they always restore it to FF.  They should restore
it to the state it was in when they were called.

%    There are arbitrary internal limits to:  maximum number of queued
conditions, maximum number of queued interrupts, maximum number of active
devices.  These limits should be removed by using free memory chains instead of
static data structure allocation.

%    The code is not ADCON free.


QTS ERROR CODES

Most QTS routines return an error code if there is something they don't like.
All possible error codes generated by QTS routines are listed here.  Since the
QTT (timer utilities) family is subordinate to the QTS family, QTT error codes
may bubble up and be returned by QTS routines.

18901     QTSFND    device not active
18902     QTSADV    device already active
18903     QTSINT    handler already active
18904     QTSADV    no slots available for the new device
18905     QTSDDV    device not active
18906     QTSCLR    handler not active
18907     QTSWFS    no conditions to satisfy
18908     QTSSTC    too many conditions
18909     QTSSTC    invalid condition
18910     QTSWFA    no active devices
18911     QTSWFS    timeout and conditions still unsatisfied
18912     QTSWFA    timeout and conditions still unsatisfied
18913     QTSWFA    no conditions to satisfy
18914     QTSRMC    no conditions in queue
18981     QTSCKI         CSW shows funny bits on
18982     QTSCKI         CSW shows CE
18983     QTSCKI         CSW shows DE
18984     QTSCKI         CSW shows ATTN
18985     QTSCKI         CSW shows unit check
18986     QTSCKI         CSW shows unit exception
18987     QTSCKI         CSW shows program controlled interruption
 18988     QTSCKI         CSW shows busy
18989     QTSCKI         CSW shows incorrect length
18990     QTSCKI         CSW shows program check
18991     QTSCKI         CSW shows protection check
18992     QTSCKI         CSW   shows channel data check
18993     QTSCKI         CSW shows channel control check
18994     QTSCKI         CSW shows interface control check
18995     QTSCKI         CSW shows chaining check
18996     QTSCKI         CSW shows control unit end



LIBRARY ORGANISATION/REQUIREMENTS

%    All interface subroutines may be compiled with the standard CMS Assembler,
using the CMSLIB and DMSSP MACLIBs, as illustrated in the QTSA EXEC.

%    Some interface subroutines contain undocumented, externally visible labels,
but these are for internal use only.

%    All interface subroutines must be called in the VS/FORTRAN convention, that
is, R15-entry, R14-return, R13-save area, R1-parameter list, and the parameter
list is a list of addresses.

%    Test program filenames all have the name QTSTnn, where nn is a number, and
the program name is the same as the filename.

%    Sample program filenames all have the name QTSSMPnn, where nn is a number,
and the program name SMPnn.

%    Test and sample programs may be compiled with VS/FORTRAN release 4.


LINKAGE REQUIREMENTS

%    The interface routines make references only to the QTT family routines;  no
VS/FORTRAN routines are needed.

%    The sample and test routines do need the VS/FORTRAN link library.

%    The test routines need, in addition, the QYK routines from the QUSEFUL
library, as illustrated in the QTSTEST EXEC.


RUN-TIME REQUIREMENTS

%    CP SET TIMER REAL must be effective for timeouts to work properly.

%    There are no other run-time requirements beyond normal memory needs.


REFERENCES

1    Principles of Operation (GA22-7000) Interruptions chapter, I/O section;
Input/Output Operations chapter.

2    VM System Programmer's Guide (SC19-6203) DIAGNOSE and Interruption Handling
chapters.

3    CP Command Reference for General Users (SC19-6211) READY, RESET and ATTN
commands.


QTS PROGRAMS

QTSSAMP   EXEC      (to run a sample
 QTSSMP01  FORTRAN   (sample
QTSSMP02  FORTRAN   (sample
QTSADB    COPY           (Active Device Block
QTSCODES  COPY      (CSW codes
QTSCONST  COPY      (family constants
QTSENTER  COPY      (prolog code
QTSITAB   COPY      (interrupt queue table
QTSLEAVE  COPY      (epilog code
QTSCWT    ASSEMBLE  (interface
QTSADV    ASSEMBLE  (interface
QTSCKI    ASSEMBLE  (interface
QTSCLR    ASSEMBLE  (interface
QTSCPC    ASSEMBLE  (interface
QTSDDV    ASSEMBLE  (interface
QTSINT    ASSEMBLE  (interface
QTSIOS    ASSEMBLE  (interface
QTSQCN    ASSEMBLE  (interface
QTSQDV    ASSEMBLE  (interface
QTSQIN    ASSEMBLE  (interface
QTSRMC    ASSEMBLE  (interface
QTSSTC    ASSEMBLE  (interface
QTSWAC    ASSEMBLE  (interface
QTSWFA    ASSEMBLE  (interface
QTSWFS    ASSEMBLE  (interface
QTSVER    ASSEMBLE  (version subroutine
QTSFND    ASSEMBLE  (internal
QTSWAI    ASSEMBLE  (internal


QTSAMP EXEC

/* Run a QTS sample program. Syntax EXEC QTSSAMP name
 *   name is the name of a QTS sample program                      */
  parse upper arg name
  cpsave()                             /* Save the CP settings.    */
  d(0,'CPSET TIMER REAL')              /* Needed by QTS.           */
  d(0,'GLOBAL TXTLIB QTSSAMP',         /* Libraries for load.      */
     'QTCOMM VFORTLIB')
  d(0,'GLOBAL LOADLIB VFLODLIB')       /* Run-time FORTRAN stuff.   */
  d(0,'LOAD' name '(NOAUTO NOMAP')     /* Load the program.         */
  d(0,'START *')                       /* Go for it.                */
  call exit 0
exit:
  'CP SET TIMER' cpsave.timer          /* Restore the timer value.  */
exit arg(1)
s:cmd = arg(2)                         /* Say+do, quit if bad.      */
  conwait                              /* Wait for other I/O.       */
  i(cmd)                               /* Say the command we'll do. */
  conwait                              /* Wait for say to finish.   */
  address command cmd                  /* Do the command.           */
  if rc < 0 | rc > arg(1)              /* Quit if bad RC.           */
    then call exit rc
return '*'                             /* Return null CMS command.  */
d:cmd = arg(2)                         /* Do, say+quit if bad.      */
  conwait                              /* Wait for other I/O.       */
  address command cmd                  /* Do the command.           */
  if rc < 0 | rc > arg(1)              /* Bad RC?                   */
  then do                              /* Yes.                      */
    crc = rc                           /* Remember the RC.          */
    conwait                            /* Wait for other I/O.       */
    i(cmd '(rc='crc')')                /* Say command and RC.       */
    call exit crc                      /* Quit.                     */
  end
return '*'                             /* Return null CMS command.  */
i:parse upper source . . proc .        /* Say with procname.        */
  say substr(proc,1,8)':' arg(1)
 return '*'                             /* Return null CMS command.  */
cpsave: procedure expose cpsave.       /* Save the CP SET values.   */
  p = queued()
  d(0,'EXECIO * CP (LIFO',             /* Inquire.                  */
    'STRING QUERY SET')
  do while queued() > p                /* Loop through lines.       */
    parse pull line                    /* Get the line.             */
    do while line Â¬= ''                /* Loop through values.      */
      parse value line with,           /* Get the value.            */
        opt value','line
      cpsave.opt = value               /* Put it in the stem.       */
    end
  end
return '*'

QTSSMP01 FORTRAN

C QTS Family Sample Program 1 Show how to wait for an interrupt or
C timeout from the console. Address 9 is assumed to be the console.
C This program requires you to have CP SET TIMER REAL effective.
C To run this program you must:
C   CP SET TIMER REAL
C   FORTVS QTSSMP01
C   GLOBAL TXTLIB QTCOMM VFORTLIB
C   LOAD QTSSMP01 (NOAUTO
C   START
C   hit ENTER or wait 5 seconds
         PROGRAM SMP01
C                                      Give instructions.
         WRITE(5,*) ' '
         WRITE(5,*) 'hit ENTER to quit'
         WRITE(5,*) '      or'
         WRITE(5,*) 'wait 5 seconds'
C                                      Finish I/O at the console.
         CALL QTSCWT
C                                      Activate console.
         ICON = 9
         CALL QTSADV(ICON, 1, IERR1)
         IF (IERR1 .NE. 0) GOTO 1010
C                                      Attention is expected on cons.
         CALL QTSSTC(ICON, 18984,
     >     1, IERR2)
         IF (IERR2 .NE. 0) GOTO 1010
C                                      Start handler.
         CALL QTSINT(1, IERR3)
         IF (IERR3 .NE. 0) GOTO 1000
C                                      Wait for condition or timeout.
         LWAIT = 5000
         CALL QTSWFS(ICON, LWAIT,
     >     ICSW, IREM, IERR4)
C                                      Clear handler.
 1000    CONTINUE
         CALL QTSCLR(1, IERR5)
C                                      Stopping before handler set.
 1010    CONTINUE
C                                      Check the errors.
         IF      (IERR1 .NE. 0) THEN
           WRITE(5,*)                 'console activation error', IERR
         ELSE IF (IERR2 .NE. 0) THEN
           WRITE(5,*)                 'set cons condition error', IERR
         ELSE IF (IERR3 .NE. 0) THEN
           WRITE(5,*)                 'init handler error',       IERR
         ELSE IF (IERR4 .EQ. 18911)
     >   THEN
C                                      Timed out?
           WRITE(5,*) ' '
            WRITE(5,*)
     >       'timeout before you ',
     >       'hit enter'
         ELSE IF (IERR4 .NE. 0) THEN
           WRITE(5,*)                 'wait for condition error', IERR
         ELSE IF (IERR5 .NE. 0) THEN
           WRITE(5,*)                 'clear handler error',      IERR
         ELSE
C                                      Must not have timed out.
           WRITE(5,*) ' '
           WRITE(5,*) 'interrupted ',
     >       'at console before ',
     >       'timeout'
         ENDIF
         END

QTSSMP02 FORTRAN

C QTS Family Sample Program 2 Show how to wait on two devices: ENTER
C on the console or DIAL  from another terminal. Address 9 is assumed
C to be the console. Address hex 063 is assumed free to be dialed to.
C After the DIAL, the device at hex 063 is NOT detached by the
C program.
C To run this program you must:
C   FORTVS QTSSMP02
C   GLOBAL TXTLIB QTCOMM VFORTLIB
C   LOAD QTSSMP02 (NOAUTO
C   START
C   DIAL yourself        (from another terminal)
C   or hit ENTER
C   DETACH 063
         PROGRAM SMP02
C                                      Give instructions.
         WRITE(5,*) ' '
         WRITE(5,*) 'waiting for DIAL'
         WRITE(5,*) '      or'
         WRITE(5,*) 'hit ENTER to quit'
C                                      Finish I/O at the console.
         CALL QTSCWT
C                                      CP command to define address.
         CALL QTSCPC('DEFINE GRAF 063',
     >     IERR0)
C                                      Error 92 is 'already defined'.
         IF (IERR0 .EQ. 92) IERR0 = 0
         IF (IERR0 .NE. 0) GOTO 1010
C                                      Activate console.
         ICON = 9
         CALL QTSADV(ICON, 1, IERR1)
         IF (IERR1 .NE. 0) GOTO 1010
C                                      Activate device.
         IDEV = 99
         CALL QTSADV(IDEV, 1, IERR2)
         IF (IERR2 .NE. 0) GOTO 1010
C                                      Attention is expected on cons.
         CALL QTSSTC(ICON, 18984,
     >     1, IERR3)
         IF (IERR3 .NE. 0) GOTO 1010
C                                      DE is expected at DIAL.
         CALL QTSSTC(IDEV, 18983,
     >     1, IERR4)
         IF (IERR4 .NE. 0) GOTO 1010
C                                      Start handler.
         CALL QTSINT(1, IERR5)
         IF (IERR5 .NE. 0) GOTO 1000
C                                      Wait for satisfied condition.
         CALL QTSWFA(-1, KDEV,
      >     ICSW, IREM, IERR6)
C                                      Clear handler.
 1000    CONTINUE
         CALL QTSCLR(1, IERR7)
C                                      Stopping before handler set.
 1010    CONTINUE
C                                      Check the errors.
         IF      (IERR0 .NE. 0) THEN
           WRITE(5,*)                 'CP DEFINE error',          IERR
         ELSE IF (IERR1 .NE. 0) THEN
           WRITE(5,*)                 'console activation error', IERR
         ELSE IF (IERR2 .NE. 0) THEN
           WRITE(5,*)                 'device activation error',  IERR
         ELSE IF (IERR3 .NE. 0) THEN
           WRITE(5,*)                 'set cons condition error', IERR
         ELSE IF (IERR4 .NE. 0) THEN
           WRITE(5,*)                 'set dev condition error',  IERR
         ELSE IF (IERR5 .NE. 0) THEN
           WRITE(5,*)                 'init handler error',       IERR
         ELSE IF (IERR6 .NE. 0) THEN
           WRITE(5,*)                 'wait for condition error', IERR
         ELSE IF (IERR7 .NE. 0) THEN
           WRITE(5,*)                 'clear handler error',      IERR
         ELSE
C                                      Everything must have worked.
           WRITE(5,*) ' '
C                                      Console interrupt?
           IF (KDEV .EQ. ICON) THEN
C                                      Yes, say it.
             WRITE(5,*) 'interrupted ',
     >         'at console, dial ',
     >         'never received'
C                                      Dial interrupt?
           ELSE
C                                      Yes, say it.
             WRITE(5,*) 'interrupted ',
     >         'by DIAL from device '
           ENDIF
         ENDIF
         END

QTSADB COPY

* MACRO/COPY file QTSADB
* Map the Active Device Block. Include the queue table mapping.
         COPY QTSITAB
QTSADB   DSECT                        Active device block.
QTSADBAD DS   1F                      Virtual address.
QTSADBNC DS   1F                      Number of outstanding conds.
QTSADBMC EQU  8                       Max number of conditions.
QTSADBLC DS   XL(QTSADBMC*4)          List of outstanding conds.
QTSADBRC DS   XL(QTSADBMC*4)          Remarks about outstanding conds.
QTSADBL1 EQU  *-QTSADB                Length of part needing cleared.
QTSADBIT DS   XL(QTSITLEN)            Interrupt table.
QTSADBL  EQU  *-QTSADB                Length of the ADB.

QTSCODES COPY

* MACRO/COPY file QTSCODES
* Codes that live in the unit and channel status bytes of the CSW.
UC       EQU  X'02'                   Unit check.
UE       EQU  X'01'                   Unit exception
PCI      EQU  X'80'                   Program controlled interruption.
BUSY     EQU  X'10'                   Busy.
IL       EQU  X'40'                   Incorrect length.
PC       EQU  X'20'                   Program check.
 PRC      EQU  X'10'                   Protection check.
CDC      EQU  X'08'                   Channel data check.
CCC      EQU  X'04'                   Channel control check.
ICC      EQU  X'02'                   Interface control check.
CC       EQU  X'01'                   Chaining check.
CUE      EQU  X'20'                   Control unit end.
DE       EQU  X'04'                   Device end.
CE       EQU  X'08'                   Channel end.
ATTN     EQU  X'80'                   Attention.

Further sub-routines will be published next month.























































