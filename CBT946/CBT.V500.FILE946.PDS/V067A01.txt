System performance analysis

I wrote the following programs to help me analyse system
performance, and I have found them useful in spotting potential
problems and identifying bottlenecks in the system.

There are seven REXX EXECs which run in a VM/XA system
and display the status and resource usage for each virtual
machine logged on. VMSTAT invokes a selection display.
VMACT displays a summary of virtual machine activity,
including CPU activity, real storage usage, and I/O and paging
activity. VMPAG gives a graph-like display showing the
paging activity per machine. VMCPU gives a graph-like
display showing the amount of CPU utilization per virtual
machine. DASDIO displays the I/O count for each DASD
device in the system. CHANIO gives a channel activity
display. STORUTL gives a graph-like display of storage usage
per virtual machine. INDVM is a snapshot display of each
virtual machine's CPU usage, which can be useful when CPU
utilization suddenly peaks - the machine using excessive CPU
can be identified immediately.

An example of the output from VMACT is shown in Figure 1,
output from VMPAG is shown in Figure 2, output from
VMCPU is shown in Figure 3, output from DASDIO is shown
in Figure 4, output from CHANIO is shown in Figure 5, and
output from STORUTL is shown in Figure 6.


VMSTAT

/* */
HI='1DF8'X
LO='1DF0'X
TOP:
VMFCLEAR
SAY HI' VM SYSTEM DISPLAY TOOLS'LO
SAY ' '
SAY HI'1'LO'VIRTUAL MACHINE ACTIVITY'
SAY ' '
SAY HI'2'LO'VIRTUAL MACHINE CPU UTILIZATION'
SAY ' '
SAY HI'3'LO'VIRTUAL MACHINE STORAGE UTILIZATION'
SAY ' '
SAY HI'4'LO'VIRTUAL MACHINE PAGING ACTIVITY'
SAY ' '
SAY HI'5'LO'DASD I/O ACTIVITY'
SAY ' '
SAY HI'6'LO'CHANNEL ACTIVITY'
SAY ' '
SAY HI'X'LO'EXIT'
PULL RESP .
RESP=STRIP(RESP)
SELECT
     WHEN RESP='1' THEN CALL VMACT
     WHEN RESP='2' THEN CALL VMCPU
     WHEN RESP='3' THEN CALL STORUTL
     WHEN RESP='4' THEN CALL VMPAG
     WHEN RESP='5' THEN CALL DASDIO
     WHEN RESP='6' THEN CALL CHANIO
     WHEN RESP='X' THEN EXIT
     OTHERWISE EXIT
END
SIGNAL TOP


VMACT

/* VMACT - VIRTUAL MACHINE ACTIVITY DISPLAY                         */
/* THIS REXX EXEC DISPLAYS THE STATUS OF VIRTUAL MACHINES IN A VM   */
/* SYSTEM. THE DISPLAY CONSISTS OF SEVEN COLUMNS CONTAINING THE     */
/* FOLLOWING INFORMATION:                                           */
/* VM ID      : VIRTUAL MACHINE NAME                                */
/* INREAL     : THE AMOUNT OF REAL STORAGE CURRENTLY OCCUPIED BY    */
/*              THIS MACHINE IN K                                   */
/* PAGING IO  : THE NUMBER OF PAGING I/O'S CAUSED BY THIS MACHINE   */
/*              AND THIS NUMBER AS A PERCENTAGE OF TOTAL PAGING I/O */
/* PCT DSA    : THE PERCENTAGE OF THE DYNAMIC STORAGE AREA OCCUPIED */
/*              BY THIS MACHINE.                                    */
/* PROJ WSS   : THE ESTIMATED WORKING SET SIZE                      */
/* IO ACTIVITY: THE NUMBER OF I/O'S PERFORMED BY THIS MACHINE       */
/* STATUS     : THE STATUS OF THE MACHINE                           */
ARG LOOP
PARSE SOURCE . . . . FM .
HI='1DF8'X
LO='1DF0'X
DSASIZE='64218'              /* DYNAMIC PAGE AREA SIZE IN K */
TOP:
EXECIO '* CP (STR Q N'
MCLOGGED=1;PGT=0;PWST=0;PGP=0;TPGR=0;TIO=0;PDST=0
DO Z=1 TO QUEUED() BY 1
   PULL LINE
   LINE=TRANSLATE(LINE,' ',',')
   DO  WHILE INDEX(LINE,'-L0')¬=0
       LINE=OVERLAY('- 0',LINE,INDEX(LINE,'-L0'),3)
   END
   DO Y=1 TO 12 BY 3
     MC.MCLOGGED= WORD(LINE,Y)
     IF SUBSTR(MC.MCLOGGED,1,1)='Ý' THEN ITERATE
     STAT.MCLOGGED=WORD(LINE,Y+2)
     IF INDEX(STAT.MCLOGGED,'DSC')¬=0 THEN STAT.MCLOGGED=' DISCONNECTED'
                            ELSE STAT.MCLOGGED=' ON GRAF 'STAT.MCLOGGED
      IF STRIP(MC.MCLOGGED)='' THEN LEAVE
      IF SUBSTR(MC.MCLOGGED,1,5)='LOGON' THEN MCLOGGED=MCLOGGED-1
      MCLOGGED=MCLOGGED+1
   END
END
MCLOGGED=MCLOGGED-1
DO X=1 TO MCLOGGED BY 1
EXECIO '* CP (STR LOCATE 'MC.X
PULL . . VMBLOK .
/*  PAGING */
ADDR=D2X(X2D(VMBLOK)+X2D(6BC))
EXECIO '* CP (STR D H'ADDR'.10'
PULL . PGWAITS PGSTOLN PGWRITES PGREADS .
PGR.X=' 'X2D(PGREADS)+X2D(PGWRITES)
TPGR=TPGR+(X2D(PGREADS)+X2D(PGWRITES))
/*  PAGES IN CORE */
ADDR=D2X(X2D(VMBLOK)+X2D(6B4))
EXECIO '* CP (STR D H'ADDR'.4'
PULL . ADDR .
INR.X=' 'RIGHT((X2D(ADDR)*4'K'),6)
PGT=PGT+(X2D(ADDR)*4)
/*  I/O  */
ADDR=D2X(X2D(VMBLOK)+X2D(5E8))
EXECIO '* CP (STR D H'ADDR'.4'
PULL T WORD .
IO.X=' 'X2D(WORD)
TIO=TIO+X2D(WORD)
/*  ESTIMATED CORE WORKING SET SIZE */
ADDR=D2X(X2D(VMBLOK)+X2D(6CC))
EXECIO '* CP (STR D H'ADDR'.4'
PULL T WORD .
PWS.X=' 'X2D(WORD)*4'K'
PWST=PWST+X2D(WORD)*4
END
/* END OF MAIN LOOP */
/*  PERCENTAGES   */
DO X=1 TO MCLOGGED BY 1
PDS.X=TRANSLATE(INR.X,' ','K')
PDS.X=STRIP(PDS.X)
PDST=PDST+PDS.X
PDS.X=TRUNC(((PDS.X)/DSASIZE)*100,1)'%'
PDS.X=RIGHT(PDS.X,5)
END
/*  TOTALS   */
PDST=''TRUNC(((PDST)/DSASIZE)*100,1)
INR.X=PGT'K'
PWS.X=PWST'K'
PDS.X=PDST'%'
IO.X=TIO
DO X=1 TO MCLOGGED
PPGR=TRUNC((PGR.X/TPGR)*100)
PGR.X=LEFT(PGR.X,8)'('PPGR'%)'
END
Y=MCLOGGED+1
STAT.Y='QUIT=EXIT'
PGR.X=STRIP(TPGR)'       '
VMFCLEAR
SAY HI'                      VIRTUAL MACHINE ACTIVITY                '
SAY 'VM ID    INREAL  PAGING IO    PCT DSA  PROJ WSS   I/O ACTIVITY',
                                                          '    STATUS'LO
DO Y=1 TO X BY 1
MC.Y=LEFT(MC.Y,8)
INR.Y=RIGHT(INR.Y,6)
PGR.Y=RIGHT(PGR.Y,14)
PDS.Y=RIGHT(PDS.Y,5)
PWS.Y=RIGHT(PWS.Y,10)
IO.Y=RIGHT(IO.Y,14)
STAT.Y=RIGHT(STAT.Y,14)
IF Y=X THEN SAY COPIES('-',78)
SAY MC.Y     INR.Y    PGR.Y         PDS.Y   PWS.Y      IO.Y,
         STAT.Y
END
PULL RESP
IF STRIP(RESP)¬='' THEN EXIT
SIGNAL TOP
EXIT


VMPAG

/* THIS REXX EXEC DISPLAYS PAGING ACTIVITY PER USER-ID.              */
ARG LOOP
PARSE SOURCE . . . . FM .
INIT=YES
HI='1DF8'X
LO='1DF0'X
TOP:LTTOTPAG=0;
EXECIO '* CP (STR Q N'
MCLOGGED=1
DO Z=1 TO QUEUED() BY 1
   PULL LINE
   LINE=TRANSLATE(LINE,' ',',')
   DO  WHILE INDEX(LINE,'-L0')¬=0
       LINE=OVERLAY('- 0',LINE,INDEX(LINE,'-L0'),3)
   END
   DO Y=1 TO 12 BY 3
      MC.MCLOGGED= WORD(LINE,Y)
      IF SUBSTR(MC.MCLOGGED,1,1)='Ý' THEN ITERATE
      IF STRIP(MC.MCLOGGED)='' THEN LEAVE
      IF SUBSTR(MC.MCLOGGED,1,5)='LOGON' THEN MCLOGGED=MCLOGGED-1
      MCLOGGED=MCLOGGED+1
   END
END
MCLOGGED=MCLOGGED-1
DO X=1 TO MCLOGGED BY 1
EXECIO '* CP (STR LOCATE 'MC.X
PULL . . VMBLOK .
ADDR=D2X(X2D(VMBLOK)+X2D(6BC))
EXECIO '* CP (STR D H'ADDR'.10'
PULL . PAGWAIT PAGSTLN PAGWRITE PAGREAD .
TOTPAG.X=X2D(PAGREAD)+X2D(PAGWRITE)
IF SYMBOL('LTOTPAG.X')='VAR' THEN DO
    PAGING.X=TOTPAG.X-LTOTPAG.X
    PAGR.X=X2D(PAGREAD)-LPAGR.X
    PAGW.X=X2D(PAGWRITE)-LPAGW.X
END
    ELSE DO;PAGING.X=0;PAGR=0;PAGW=0;LTIME=TIME(S);END
PAGSEC.X=RIGHT(PAGING.X,10)
LTOTPAG.X=TOTPAG.X
LTTOTPAG=LTTOTPAG+PAGING.X
LPAGR.X=X2D(PAGREAD)
LPAGW.X=X2D(PAGWRITE)
NSECS=TIME(S)-LTIME
END
IF INIT='YES' THEN DO;INIT=NO;SIGNAL TOP;END
L=LTTOTPAG
IF LTTOTPAG=0 THEN LTTOTPAG=1
DO X=1 TO MCLOGGED BY 1
PPAG.X=RIGHT(TRUNC((PAGING.X/LTTOTPAG)*100,2),6)
IF NSECS=0 THEN NSECS=1
PPS=TRUNC(LTTOTPAG/NSECS);
IF L=0 THEN PPS=0
IF SUBSTR(PPAG.X,(INDEX(PPAG.X,'.')+1),1)>4 THEN ADD=1
                                            ELSE ADD=0
PAGING.X=COPIES('R',PAGR.X)
PAGING.X=PAGING.X||COPIES('W',PAGW.X)
IF LENGTH(PAGING.X)>48 THEN PAGING.X=SUBSTR(PAGING.X,1,48)'>'
END
LTIME=TIME(S)
VMFCLEAR
SAY HI'                VIRTUAL MACHINE PAGING ACTIVITY'
SAY 'VM ID      PAGING    PAGING IN LAST 'NSECS 'SECONDS='L   '(' ,
                                          PPS  '/ SEC)          %PAGE'LO
DO X=1 TO MCLOGGED BY 1
MC.X=LEFT(MC.X,10)
PAGSEC.X=RIGHT(PAGSEC.X,6)
PAGING.X=LEFT(PAGING.X,54)
PPAG.X=RIGHT(TRUNC(PPAG.X),3)'%'
SAY MC.X      PAGSEC.X  PAGING.X                                          PPAG.X
END
PULL RESP
IF STRIP(RESP)¬='' THEN EXIT
SIGNAL TOP
EXIT


VMCPU

/* */
/* THIS REXX EXEC DISPLAYS CPU USAGE BY USER-ID                     */
ARG LOOP
PARSE SOURCE . . . . FM .
INIT=Y
HI='1DF8'X
LO='1DF0'X
/*SIGNAL ON SYNTAX*/
NUMERIC DIGITS 14
TOP:CPUTOT=0;PNT=0
EXECIO '* CP (STR IND LOAD'              /* GET TOTAL CPU LOAD       */
PULL CPULOAD;DESBUF
CPULOAD=SUBSTR(CPULOAD,9,3)
EXECIO '* CP (STR Q N'                   /* GET LOGGED ON USER-IDS   */
MCLOGGED=1
DO Z=1 TO QUEUED() BY 1
   PULL LINE
   LINE=TRANSLATE(LINE,' ',',')          /* GET RID OF COMMAS AND    */
   DO  WHILE INDEX(LINE,'-L0')¬=0        /* LOGICAL TERM ADDRESS PREF*/
       LINE=OVERLAY('- 0',LINE,INDEX(LINE,'-L0'),3)
   END
   DO Y=1 TO 12 BY 3                     /* BUILD ARRAY OF USER-IDS  */
      MC.MCLOGGED= WORD(LINE,Y)
      IF SUBSTR(MC.MCLOGGED,1,1)='Ý' THEN ITERATE      /* SDI CACHE  */
      IF STRIP(MC.MCLOGGED)='' THEN LEAVE
      IF SUBSTR(MC.MCLOGGED,1,5)='LOGON' THEN MCLOGGED=MCLOGGED-1
      MCLOGGED=MCLOGGED+1
   END
END
MCLOGGED=MCLOGGED-1
DO X=1 TO MCLOGGED BY 1
EXECIO '* CP (STR LOCATE 'MC.X           /* LOCATE VMDBK             */
PULL . . VMBLOK .
ADDR=D2X(X2D(VMBLOK)+X2D(550))           /* CPU COUNT AT VMDBK+X'550'*/
EXECIO '* CP (STR D H'ADDR'.8'           /* DISPLAY REAL STORAGE     */
PULL . CPUSEC CPUSEC2 .
GELL=CPUSEC' 'CPUSEC2
CPUSEC2=SUBSTR(CPUSEC2,1,4)
CPUSEC2=RIGHT(CPUSEC2,4,"0")
CPUSEC2=D2X(X2D(FFFF)-X2D(CPUSEC2))      /* CONVERT TO SECS           */
CPUSEC=D2X(X2D(80000000)-X2D(CPUSEC))
CPUSECS=CPUSEC||RIGHT(CPUSEC2,4,'0')
CPUSEC.X=RIGHT(TRUNC(X2D(CPUSECS)/X2D(F424),2),10) /* 1 SEC = X'F424' */
LCPU=CPUSEC.X
IF SYMBOL('CPUSECL.X')¬='VAR' THEN CPUSECL.X=0     /* IF FIRST SCAN   */
CPUSEC.X=RIGHT((CPUSEC.X-CPUSECL.X),10)            /* CPU SECS USED   */
CPUSECL.X=LCPU                                     /* BETWEEN SCANS   */
CPUTOT=RIGHT(CPUTOT+CPUSEC.X,10)                   /* ADD TO TOTAL    */
END
DO X=1 TO MCLOGGED BY 1                            /* CALC PERCENTAGE */
PNK.X=RIGHT(TRUNC((CPUSEC.X/CPUTOT)*CPULOAD,2),5)
PNT=PNT+PNK.X
IF SUBSTR(PNK.X,(INDEX(PNK.X,'.')+1),1)>4 THEN ADD=1  /* ROUND UP */
                                          ELSE ADD=0
CPUPCT.X=COPIES('>',SUBSTR(PNK.X,1,(INDEX(PNK.X,'.')-1))+ADD)
IF LENGTH(CPUPCT.X)>50 THEN CPUPCT.X=SUBSTR(CPUPCT.X,1,48)
END
IF INIT=Y THEN DO                /* IF INITIAL SCAN */
   INIT=N
   SIGNAL TOP
END
VMFCLEAR
SAY HI'                    VIRTUAL MACHINE CPU UTILIZATION'
SAY ' VM ID      CPU SECS  CPU ACTIVITY SINCE LAST SCREEN (',
                                                CPUTOT'  )      % CPU'LO
DO X=1 TO MCLOGGED BY 1
MC.X=LEFT(MC.X,10)
CPUSEC.X=RIGHT(CPUSEC.X,9)
CPUPCT.X=LEFT(CPUPCT.X,50)
SAY  MC.X      CPUSEC.X  CPUPCT.X                                          PNK.X
END
SAY '15'X
SAY 'CPULOAD 'CPULOAD
PULL RESP
IF STRIP(RESP)¬='' THEN EXIT
SIGNAL TOP
EXIT


DASDIO

/* THIS REXX EXEC DISPLAYS I/O COUNTS FOR DASD DEVICES.              */
SIGNAL ON SYNTAX
PARSE SOURCE . . . . FM .
HI='1DF8'X
LO='1DF0'X
INITIAL=YES;
TOP:DESBUF;CHANN=' ';CHANC=''
DO X=1 TO 16 BY 1;CHAN.X=0;END
EXECIO '* CP (STRING Q DASD'
MDISK=QUEUED()
DO X=1 TO MDISK BY 1
 PULL . CUU . . VOL.X .
 EXECIO '* CP (LIFO ST LOCATE' CUU
 PULL ADDR .;PULL .
  EXECIO '* CP (LIFO STR D H'D2X(X2D(ADDR)+X2D(CC))'.4'
  PULL . IO .
  CUU=SUBSTR(CUU,2,3)
  CHANADDR=X2D(SUBSTR(CUU,1,1));CHAN.CHANADDR=CHAN.CHANADDR+X2D(IO)
  IF INITIAL='NO' THEN C.X=RIGHT((X2D(IO)-LIOC.X),5)
                  ELSE C.X=''
  U.X=STRIP(CUU)
  IO.X=X2D(STRIP(IO))
 END
DO Y=1 TO 16 BY 1;
            IF CHAN.Y¬=0 THEN CHANN=CHANN''RIGHT(' CHANNEL 'Y,11);END
DO Y=1 TO 16 BY 1;IF CHAN.Y¬=0 THEN CHANC=CHANC''RIGHT(CHAN.Y,11);END
DO X=1 TO MDISK BY 1;LIOC.X=IO.X;END;INITIAL='NO'
VMFCLEAR
SAY HI'                            DASD I/O STATISTICS'
SAY 'CUU VOLUME IOCOUNT LASTIO  CUU VOLUME IOCOUNT LASTIO  CUU VOLUME ',
                                                       'IOCOUNT LAST'LO
DO X=1 TO MDISK BY 3
Y=X+1
Z=X+2
U.X=LEFT(U.X,3);U.Y=LEFT(U.Y,3);U.U=LEFT(U.Z,3)
VOL.X=LEFT(VOL.X,7);VOL.Y=LEFT(VOL.Y,7);VOL.Z=LEFT(VOL.Z,7)
IO.X=LEFT(IO.X,9);IO.Y=LEFT(IO.Y,9);IO.Z=LEFT(IO.Z,9)
C.X=RIGHT(C.X,4);C.Y=RIGHT(C.Y,4);C.Z=RIGHT(C.Z,4)
SAY U.X  VOL.X   IO.X    C.X   U.Y  VOL.Y  IO.Y    C.Y   U.Z  VOL.Z  IO.Z  C.Z
END
SAY HI
SAY CHANN
SAY CHANC''LO
PULL RESP .
IF STRIP(RESP)¬='' THEN EXIT
SIGNAL TOP
SYNTAX: SET 'CMSTYPE RT'
SAY 'REQUIRE CP PRIVILEGE CLASS C'
EXIT 8


CHANIO

/* THIS REXX EXEC DISPLAYS REAL CHANNEL ACTIVITY.                   */
INITIAL=YES;
PARSE SOURCE . . . . FM .
HI='1DF8'X
LO='1DF0'X
DO X=0 TO 15 BY 1;LCHAN.X=0;END;
TOP:TIMES=TIME(S);DESBUF;
DO X=0 TO 15 BY 1;CHAN.X=0;END
EXECIO '* CP (STRING Q 00E'   /* Devices which are not tape/graf/dasd */
EXECIO '* CP (STRING Q 00F'
EXECIO '* CP (STRING Q C40'
EXECIO '* CP (STRING Q 880'
EXECIO '* CP (STRING Q DASD'
EXECIO '* CP (STRING Q TAPE'
EXECIO '* CP (STRING Q GRAF'
MDISK=QUEUED()
DO X=1 TO MDISK BY 1
 PULL . CUU .
 EXECIO '* CP (LIFO ST LOCATE' CUU
 PULL  ADDR .;PULL .
  EXECIO '* CP (LIFO STR D H'D2X(X2D(ADDR)+X2D(CC))'.4'
 CUU=SUBSTR(CUU,2,3)
  PULL . IO .
  CHANADDR=X2D(SUBSTR(CUU,1,1));CHAN.CHANADDR=CHAN.CHANADDR+X2D(IO)
 END
IF INITIAL='YES' THEN DO;
DO X=0 TO 15 BY 1;LCHAN.X=CHAN.X;END;
INITIAL=NO;SIGNAL TOP;END
TIMEE=TIME(S)
TIMELS=TIMEE-TIMES
IF TIMELS<1 THEN TIMELS=1
DO X=0 TO 15 BY 1
IOR.X=RIGHT(TRUNC((CHAN.X-LCHAN.X)/TIMELS),6)
IORAT=TRUNC(IOR.X)
IF IORAT>55 THEN IORAT=55
IORATE.X=COPIES('>',(TRUNC(IORAT)))
B=55-LENGTH(IORATE.X)
IF B>0 THEN IORATE.X=IORATE.X''COPIES(' ',B)
END
DO X=0 TO 15 BY 1;LCHAN.X=CHAN.X;CHAN.X=RIGHT(CHAN.X,10);END;
VMFCLEAR
SAY HI'                             CHANNEL I/O'
SAY 'C   I/O COUNT  CHANNEL I/O SINCE LAST SCREEN REFRESH                ,
'LAST I/O'LO
DO X=0 TO 15 BY 1
CHAN.X=LEFT(CHAN.X,12)
Y=LEFT(D2X(X),2)
IOR.X=RIGHT(IOR.X,5)
SAY Y    CHAN.X    IORATE.X                                                IOR.X
END
INITIAL='NO'
PULL RESP
IF STRIP(RESP)¬='' THEN EXIT
SIGNAL TOP
EXIT


STORUTL

/* THIS REXX EXEC DISPLAYS REAL STORAGE USAGE BY USER-ID             */
ARG LOOP
PARSE SOURCE . . . . FM .
HI='1DF8'X
LO='1DF0'X
TOP:MCLOGGED=1;PGT=0;PGF=0
EXECIO '* CP (STR Q N'
DO Z=1 TO QUEUED() BY 1
   PULL LINE
   LINE=TRANSLATE(LINE,' ',',')
   DO  WHILE INDEX(LINE,'-L0')¬=0
       LINE=OVERLAY('- 0',LINE,INDEX(LINE,'-L0'),3)
   END
   DO Y=1 TO 12 BY 3
      MC.MCLOGGED= WORD(LINE,Y)
      IF SUBSTR(MC.MCLOGGED,1,1)='Ý' THEN ITERATE
      IF STRIP(MC.MCLOGGED)='' THEN LEAVE
      MCLOGGED=MCLOGGED+1
   END
END
MCLOGGED=MCLOGGED-1
DO X=1 TO MCLOGGED BY 1
IF SUBSTR(MC.X,1,5)='LOGON' THEN X=X+1
IF SUBSTR(MC.X,1,5)¬='LOGON' THEN EXECIO '* CP (STR LOCATE 'MC.X
PULL . . VMBLOK .
ADDR=D2X(X2D(VMBLOK)+X2D(6B4))
EXECIO '* CP (STR D H'ADDR'.8'
PULL . ADDR .
PGW.X=X2D(ADDR)*4
PGT=PGT+PGW.X
NK=TRUNC((PGW.X/30268)*100,0)
PNK.X=RIGHT(TRUNC((PGW.X/30268)*100,1),4)
IF SUBSTR(PNK.X,(INDEX(PNK.X,'.')+1),1)>5 THEN ADD=1
                                          ELSE ADD=0
PGF.X=COPIES('>',(TRUNC(NK+ADD)))
PGW.X=RIGHT(PGW.X'K',6)
END
PGTT=PGT'K)'
VMFCLEAR
SAY HI'                 VIRTUAL MACHINE STORAGE UTILIZATION'
SAY 'VM ID      INREAL PERCENTAGE OF REAL STORAGE USED ('PGTT'          % UTL'LO
DO X=1 TO MCLOGGED BY 1
MC.X=LEFT(MC.X,10)
PGW.X=RIGHT(PGW.X,6)
PGF.X=LEFT(PGF.X,54)
SAY  MC.X     PGW.X  PGF.X                                                PNK.X
END
PULL RESP
IF STRIP(RESP)¬='' THEN EXIT
SIGNAL TOP
EXIT


INDVM

/*
- THIS REXX EXEC DISPLAYS A 'SNAPSHOT' VIEW OF THE VM/XA USERS.
- AT INVOCATION IT SCANS THROUGH ALL LOGGED ON USERS' VMBLOKS
- AND NOTES HOW MANY CPU SECONDS THEY HAVE EACH USED. IT THEN
- WAITS ONE SECOND, RE-SCANS, AND CALCULATES HOW MUCH CPU TIME
- HAS BEEN USED BY EACH VM-ID, AND DISPLAYS THIS AS A PERCENTAGE
- OF THE TOTAL CPU LOAD. THE AMOUNT OF REAL STORAGE USED IS ALSO GIVEN.
- THIS EXEC CAN BE USEFUL WHEN CPU UTILIZATION SUDDENLY PEAKS AND
- YOU WANT TO FIND OUT WHO IS USING IT ALL UP
-
- PARAMETERS:
- PRE         PREFIX, SPECIFIES THAT ONLY VM-ID'S STARTING WITH THESE
              CHARACTERS SHOULD BE DISPLAYED. YOU MAY, FOR INSTANCE,
              SET THIS TO 'VSE' SO THAT ONLY THE VSE MACHINES ARE
              DISPLAYED. OTHER USER-IDS ARE THEN ADDED TOGETHER AND
              DISPLAYED AS 'REST'
- WAIT        NUMBER OF SECONDS TO WAIT BEFORE RE-SCANNING.
              THE LARGER THE NUMBER, THE MORE ACCURATE THE PERCENTAGE.
              DEFAULT 1.

- THIS EXEC REQUIRES CP PRIVILEGE CLASSES C OR E.
SYSTEM: VM/XA
*/
ARG PRE WAIT .
SIGNAL ON SYNTAX
IF WAIT='' THEN WAIT=1
IF PRE='*' THEN PRE=''
LPRE=LENGTH(STRIP(PRE))
IF DATATYPE(WAIT)¬='NUM' THEN WAIT=1
NUMERIC DIGITS 14
INITALISING='Y';INRTOT=0
TOP:CPUTOT=0;PNT=0;RESTTOT=0;RESTCOR=0
DESBUF
EXECIO '* CP (STR IND'
PULL TOTCPUPCT .
DESBUF; TOTCPUPCT = SUBSTR(TOTCPUPCT,9,3);
EXECIO '* CP (STR Q N'
MCLOGGED=1
DO Z=1 TO QUEUED() BY 1
   PULL LINE
   LINE=TRANSLATE(LINE,' ',',')
   DO  WHILE INDEX(LINE,'-L0')¬=0
       LINE=OVERLAY('- 0',LINE,INDEX(LINE,'-L0'),3)
   END
   DO Y=1 TO 12 BY 3
      MC.MCLOGGED= WORD(LINE,Y)
      IF SUBSTR(MC.MCLOGGED,1,1)='Ý' THEN ITERATE
      IF STRIP(MC.MCLOGGED)='' THEN LEAVE
      IF SUBSTR(MC.MCLOGGED,1,5)='LOGON' THEN MCLOGGED=MCLOGGED-1
      MCLOGGED=MCLOGGED+1
   END
END
MCLOGGED=MCLOGGED-1
DO X=1 TO MCLOGGED BY 1
EXECIO '* CP (STR LOCATE 'MC.X
PULL . . VMBLOK .
IF INITALISING='Y' THEN DO
   ADDR=D2X(X2D(VMBLOK)+X2D(6B4))
   EXECIO '* CP (STR D H'ADDR'.4'
   PULL . ADDR .
   INR.X=' 'X2D(ADDR)*4
   INRTOT=INRTOT+X2D(ADDR)
END
ADDR=D2X(X2D(VMBLOK)+X2D(550))
EXECIO '* CP (STR D H'ADDR'.8'
PULL . CPUSEC CPUSEC2 .
CPUSEC2=SUBSTR(CPUSEC2,1,4)
CPUSEC2=RIGHT(CPUSEC2,4,"0")
CPUSEC2=D2X(X2D(FFFF)-X2D(CPUSEC2))
CPUSEC=D2X(X2D(80000000)-X2D(CPUSEC))
CPUSECS=CPUSEC||RIGHT(CPUSEC2,4,'0')
CPUSEC.X=RIGHT(TRUNC(X2D(CPUSECS)/X2D(F424),2),10)
LCPU=CPUSEC.X
IF SYMBOL('CPUSECL.X')¬='VAR' THEN CPUSECL.X=0
CPUSEC.X=RIGHT((CPUSEC.X-CPUSECL.X),10)
CPUSECL.X=LCPU
CPUTOT=RIGHT(CPUTOT+CPUSEC.X,10)
END
IF INITALISING='Y' THEN DO;INITALISING='N';SLEEP WAIT' SEC';SIGNAL TOP;
END
SAY 'TOTAL    =  'TOTCPUPCT'%' RIGHT(INRTOT*4,6)'K'
DO X=1 TO MCLOGGED BY 1
PNK.X=RIGHT(TRUNC((CPUSEC.X/CPUTOT)*TOTCPUPCT,2),5)
PNT=PNT+PNK.X
IF SUBSTR(PNK.X,(INDEX(PNK.X,'.')+1),1)>4 THEN ADD=1
                                          ELSE ADD=0
CPUPCT.X=SUBSTR(PNK.X,1,(INDEX(PNK.X,'.')-1))+ADD
IF PRE='' THEN DO
                SAY LEFT(MC.X,8) '=' RIGHT(CPUPCT.X,4)'%' RIGHT(INR.X,6)'K'
                ITERATE
                END
IF SUBSTR(MC.X,1,LPRE)=PRE ,
THEN SAY LEFT(MC.X,8) '=' RIGHT(CPUPCT.X,4)'%' RIGHT(INR.X,6)'K'
   ELSE DO
   RESTTOT=RESTTOT+CPUPCT.X
   RESTCOR=RESTCOR+INR.X
  END
END
SAY 'REST     =' RIGHT(RESTTOT,4)'%' RIGHT(RESTCOR,6)'K'
EXIT
SYNTAX:
SAY 'REQUIRE CP PRIVILEGE CLASS C OR E'

Richard Keane
Systems Programmer (Germany)

