T3380 mapping utility

The following code, a main program and two subroutines,
provides a means for a correctly privileged user to obtain an in-
depth report of the current status of TDSK.  Since in our
environment all we have are 3380 disks, that is all this is coded
for.  However, with a little expansion it could handle any or all
TDSK set-ups.

The pieces of system modules that are of particular interest are:

%   DMKCQQ in the code for Query TDSK
%   DMKSCN particularly in the scan for virtual address
%   DMKPGT primarily for the various types of TDSK anchors.

The procedure operates in three different modes.  If invoked
directly with no parameters it will give a report of the allocated
TDSKs broken down into assigned and available.  For the
assigned blocks it will give the user-id virtual address and
actual real device cylinders.  If invoked with a parameter of
'MAP' it will produce the report without the users' allocations.
If invoked from the REXX environment and passed a
parameter other than 'BOTH' or 'MAP' it will not display any
lines but will treat the passed parameter as a REXX variable
name and will return the value of the largest contiguous
available area in that variable.

This procedure has been coded for VM/SP Release 4.

         MACRO
         FRBEGIN &A
.*  1. A CSECT or START statement must precede this macro call.
.*  2. A USING statement is inserted.
         LCLA  &REG,&TIMES
&REG     SETA  &REG+1
&TIMES   SETA  1
         USING *,R15
         GENRG
         STM   R14,R12,12(R13)    SAVE THE CALLERS REGS
         LR    R3,R13             SAVE SAVE ADDRESS
         LA    R13,$REGSV         POINT TO OUR SAVE
         ST    R13,8(R3)          FORWARD CHAIN SAVE AREAS
         ST    R3,4(R13)          BACK CHAIN SAVE AREAS
         L     R3,32(R3)          RESTORE ORIGINAL R3 CONTENTS
         ST    R1,0(R13)          SAVE PARAMETER POINTER
         B     SETBASE
$REGSV   DS    9D
         DROP  R15
SETBASE  DS    0H
         AIF   ('&SYSECT' EQ '').EO
         USING $REGSV,R13
.GO      AIF   ('&SYSLIST(&REG)' EQ '').DONE
         USING $REGSV+4080*&TIMES,&SYSLIST(&REG)
&REG     SETA  &REG+1
&TIMES   SETA  &TIMES+1
         AGO   .GO
.DONE    ANOP
&REG     SETA  1
         AIF   ('&SYSLIST(&REG)' EQ '').FINISH
         AIF   (&REG GT 1).GO2
         LA    &SYSLIST(&REG),4080(R13)
         AGO   .GO3
.GO2     LA    &SYSLIST(&REG),4080(&SYSLIST(&REG-1))
.GO3     ANOP
&REG     SETA  &REG+1
         AIF   ('&SYSLIST(&REG)' EQ '').FINISH
         AGO   .GO2
.FINISH  ANOP
.CONT1   B     $$USER             BRANCH AROUND IDENTIFYING LITERALS
         PUSH  PRINT
         PRINT GEN                SHOW THE SETUP IN THE LISTING
         DC    CL4' '
         DC    CL8'********'
         DC    CL4' '
         DC    C'&SYSECT &SYSDATE - SYSTIME'
         DC    C' FRANK RUSSELL DEVELOPED PROGRAM'
         DC    CL4' '
         DC    CL8'********'
         DC    CL4' '
$$USER   DS    0D                  BEGIN FUNCTION CODE
.SEQ1    ANOP
         POP   PRINT
         MEXIT
.E0      MNOTE '*** CSECT/START STMT MUST PRECEDE BEGIN MACRO ***'
         MEXIT
.E1      MNOTE '*** INVALID REGISTER FIELD ''&REG'' ***'
         MEXIT
.E2      MNOTE '*** MORE THAN TWO BASE REGS DEFINED ***'
         MEND
         MACRO
         GENRG
R0       EQU  0
R1       EQU  1
R2       EQU  2
R3       EQU  3
R4       EQU  4
R5       EQU  5
R6       EQU  6
R7       EQU  7
R8       EQU  8
R9       EQU  9
R10      EQU  10
R11      EQU  11
R12      EQU  12
R13      EQU  13
R14      EQU  14
R15      EQU  15
R00      EQU  0
R01      EQU  1
R02      EQU  2
R03      EQU  3
R04      EQU  4
R05      EQU  5
R06      EQU  6
R07      EQU  7
R08      EQU  8
R09      EQU  9
         MEND
         MACRO
&NAME    FTNOP &TRPOINT
         AIF   ('&TRPOINT' EQ '').ERR
&NAME    BC    0,&TRPOINT
         OI    *-3,X'F0'
         MEXIT
.ERR     MNOTE 'OPERAND IS MISSING.'
         MEND
         TITLE 'T-DSK Mapping Utility
*   ***********  Program Summary:   ***********************************
* This program will prepare and display a listing of t-dsk allocations*
* it will also show what is still available and what is allocated and *
* to whom.                                                            *
* Assembly of this program requires DMKSP DMSSP and CMSLIB MacLibs.   *
**        General Purpose Register Usage:                             *
*  Reg    Usage                                                       *
*  R0                                                                 *
*  R1     Work (also starting real address for DIAG4)                 *
*  R2     Work (also Numbers of words for DIAG4) USING USERENT        *
*  R3     Work (also Target location for DIAG4)                       *
*  R4     Work                                                        *
*  R5     Work                                                        *
*  R6     Work & using for VCHBLOK                                    *
*  R7     Work & using for VCUBLOK                                    *
*  R8     Work & using for VDEVBLOK                                   *
*  R9     Work                                                        *
*  R10    Addressability to ALOCBLOK or VMBLOK                        *
*  R11    Addressability to RDEVBLOK Labels                           *
*  R12    Second Program base                                         *
*  R13    Program Base register (also pointer to Save area)           *
*  R14    Linkage & return                                            *
*  R15    Linkage and Return code                                     *
*        External References (Subroutines Called)                     *
*   Routine:   Purpose                                                *
*   GETNAM     obtain the Userids for Logged on users                 *
*   SORTI      CMS sort Extended entry in core sort                   *
*   SHRVAR     To optionally store Largest block                      *
* CP Dsects from DMKSP Maclib                                         *
         PRINT NOGEN
         PSA
         COPY  DEVTYPES
         COPY  ALLOC
ALOCLEN  EQU   (ALOCMAP-ALOCBLOK)/4
         COPY  RBLOKS
         COPY  VMBLOK
         COPY  VBLOKS
*              Begin Program Code                                     *
TDSKMAP  CSECT
         FRBEGIN R12               Housekeeping etc
         USING PSA,R0              Addressability to PSA labels
         USING RDEVBLOK,R11        Addressability
         USING USERENT,R2          Addressability
         CLI   8(R1),X'FF'         Any parms?
         BE    GO                  No--go start
         MVC   OPTN,8(R1)          Transfer it
         B     GO                  Branch to start
* the following subroutine has been relocated here to insure that     *
* the request and data areas are in the same page                     *
*         General Purpose Real Storage retreival                      *
* Entry conditions:                                                   *
*   R1  The Real Storage Address to start                             *
*   R2  The number of Full words required (64 maximum)                *
*   R3  The Program target address                                    *
GETSTOR  DS    0H
         ST    R14,GTSTRSV         Save return link
         STM   R7,R9,STSVM         save current contents of WRk Regs
         LR    R8,R2               Transfer count to work
         LA    R7,ADDRLIST         Point to start of list
BLDLST   DS    0H
         ST    R1,0(R7)            Location to list
         LA    R1,4(R1)            Set for next location
         LA    R7,4(R7)            Next list slot
         BCT   R8,BLDLST           Any left Loop
* List has been built.  Issue the DIAG 4 for the storage              *
         LA    R7,ADDRLIST         Point to the addresses
         LR    R8,R2               Transfer the count wanted
         LA    R9,ADDRCONT         set up the return
         DC    X'83',X'78',X'004'  get some real storage
* Now move results to target location                                 *
         SLL   R2,2                Count times 4
         BCTR  R2,0                Less one for execute
         EX    R2,MVSTOR           Transfer to final location
* Restore Regs and get out of here                                    *
         LM    R7,R9,STSVM         Restore work Regs
         L     R14,GTSTRSV         Get return link
         BR    R14                 And return
MVSTOR   MVC   0(*-*,R3),0(R9)    Executed move
GTSTRSV  DS    F                   Save for Link address
STSVM    DS    3F                  Save area for work regs
ADDRLIST DS    64F                 List of requested real addresses
ADDRCONT DS    64F                 Contents of those locations
* As the first step we will find out who is running us and validate   *
* that he will have the correct privilege class to issue DIAG4.       *
GO       DS    0H
         LA    R3,USERSTUF   Point to our program area
         LA    R4,32         Set the size of our area
         DC    X'83340000'   Get current USERID
* This first LOCATE command is used for the purpose of insuring that  *
* the invoker will have the privileges necessary for the rest of      *
* the program.                                                        *
         MVC   LOCUSER,USERNAME    Transfer the ID to locate
         LM    R6,R9,DIAGLOC       Set Registers for Diagnose 8
         DC    X'83',X'68',AL2(X'0008') request the locate function
         C     R8,=F'1'            Return code 1 not class c
         BNE   PROCEED             No--we will continue
         SR    R15,R15             Clear R15 for a quiet exit
         B     ALLDONE             And pretend we never got here
* Privileges validated continue                                      *
PROCEED  DS    0H
         CLC   OPTN,=CL8'BOTH'     Full report requested?
         BE    DOUSERS             Yes--go do it
         MVC   USERCNT,=F'0'       Set for no table entries
         B     GETANCHR            And branch
* issue a query names to get the id's currently logged on             *
DOUSERS  DS    0H
         LA    R1,ONPARM           Point to parm list
         L     R15,=V(GETNAM)      get the entry point
         BALR  R14,R15             and go do it
NXTVMB   DS    0H
         LT    R1,ACTNUM           Get residual table count
         BNP   USERDONE            None left done this phase
         BCTR  R1,0                Decrement by one
         ST    R1,ACTNUM           And save for next pass
         L     R2,USERADDR         Point to the entry
         MVC   LOCUSER,0(R2)       Transfer the ID to Locate
         LA    R2,8(R2)            Point to next Id
         ST    R2,USERADDR         and store for next pass
         LM    R6,R9,DIAGLOC       Set Registers for Diagnose 8
         DC    X'83',X'68',AL2(X'0008') request the locate function
         CLC   DIAGBUFF(8),=C'VMBLOK =' Good return?
         BNE   NXTVMB              No--Process the next one
* Lets convert the address back into a real address and then save it  *
         MVC   HEXHLD,DIAGBUFF+9   Set to convert back to real address
         MVC   HEXARG(2),=C'OO'    Reinitialize the high order to zero
         TR    HEXARG,HEXEQUIV     Trans arg into hex equivalent
         BAL   R14,TRANSLAT        And Convert to Hex value
         L     R2,HEXARG           Load address of VMBLoK
         ST    R2,ACTVLRG          Set for VMBLoK retrieval
         LA    R10,DIAGBUFF        And set up addressability to it
         USING VMBL0K,R10
* Retrieve the Next vmblok and run a check to any t-dsk assigned to   *
* Him                                                                 *
         LA    R9,VMBSIZE*8         Get size in Bytes
         BAL   R14,GETLARGE         And go retrieve it
         LH    R9,VMDVCNT           Get count of virtual devices
         LTR   R9,R9                Are there any?
         BNP   NXTVMB               none there go for next user
         L     R1,VMDVSTRT          Get address of 1'st vdevblok
         ST    R1,ACTVLRG           Remember Where we are
         LA    R8,MYVDEV            Set addressability
         USING VDEVBLOK,R8          To the labels
GETVDEV  DS    0H
         L     R1,ACTVLRG           Get memory address we are after
         LA    R2,VDEVSIZE*2        Get its size in words
         LA    R3,MYVDEV            Point to our location
         BAL   R14,GETSTOR          And retrieve it
         TM    VDEVADD,X'80'        Is it a valid blok
         BO    NEXTVDV              No--skip it
         TM    VDEVTYPC,CLASDASD    Is it disk
         BZ    NXTVDV               No--skip it
         TM    VDEVFLAG,VDEVTDSK   Is it T-disk
         BZ    NXTVDV              No--forget it
         L     R1,VDEVREAL         Get the real device blok
         LA    R2,RDEVSIZE*2       Size in full   words
         LA    R3,MYDEV            Point to target area
         BAL   R14,GETSTOR         And get it
         LA    R11,MYDEV           Point to the area
         L     R1,USERCNT          Get current table count
         LA    R1,1(R1)            Add 1 for next entry
         ST    R1,USERCNT          Store for next
         SLL   R1,5                Times entry length
         L     R2,=A(USERTBL)
         AR    R2,R1               Point to next entry
         MVC   TUSER,VMUSER        Move his id
         MVC   TVOLSER,RDEVSER     Get the real volume
         LH    R1,VDEVRELN         Get the relo cylinder
         ST    R1,TSTART           And save that as well
         LH    R14,VDEVBND         Get the total allocation
         ST    R14,TTOT            Save It
         AR    R1,R14              Calc End cylinder
         BCTR  R1,0                Make zero based
         ST    R1,TEND             And store this
* Now we will develop the virtual address for this. The following is  *
* modified code taken from DMKSCN (Entry DMKSCNVD).                   *
         ST    R2,SCNSV2           Save Address in table
         LA    R4,2            LOAD INDEX INCREMENT
         LA    R5,30           LOAD INDEX COMPARAND
         SR    R1,R1           ZERO VMCHTBL INDEX
SCNNCH   LH    R6,VMCHTBL(R1)  LOAD NEXT CHANNEL BLOK INDEX
         LTR   R6,R6           DOES CHANNEL EXIST ?
         BM    SCNXCH          NO, INDEX TO NEXT ONE
         A     R6,VMCHSTRT     POINT TO VCHBLOK
         STM   R1,R3,SCNSAVE   Save regs now
         LR    R1,R6           Transfer location
         LA    R2,RCHSIZE*2    Size in Words
         LA    R3,MYVCHAN      target
         BAL   R14,GETSTOR     Get it
         LM    R1,R3,SCNSAVE
         LA    R6,MYVCHAN
         USING VCHBLOK,R6
         SR    R2,R2           ZERO VCHCUTBL INDEX
SCNNCU   LH    R7,VCHCUTBL(R2)     LOAD NEXT CU BLOK INDEX
         LTR   R7,R7               DOES CONTROL UNIT EXIST
         BM    SCNXCU              NO, INDEX TO NEXT ONE
         A     R7,VMCUSTRT         POINT To VCUBLOK
         STM   R1,R3,SCNSAVE       Save regs now
         LR    R1,R7               Transfer location
         LA    R2,RCUSIZE*2        Size in Words
         LA    R3,MYVCU            target
         BAL   R14,GETSTOR         Get it
         LM    R1,R3,SCNSAVE
         LA    R7,MYVCU
         USING VCUBLOK,R7
         LH    R3,VDEVADD     VIRTUAL DEVICE ADDRESS BITS INTO R3,
         ALR   R3,R3          DOUBLE IT TO FORM CU/DEV INDEX HALFWORD
         LH    R14,VCUDVTBL(R3)     LOAD DEVICE BLOK INDEX
         LTR   R14,R14          DOES DEVICE EXIST ?
         BM    SCNXCU           NO, INDEX TO NEXT CONTROL UNIT
         A     R14,VMDVSTRT     POINT TO VDEVBLOK
         C     R14,ACTVLRG      IS IT THE ONE WE WERE LOOKING FOR?
         BE    SCNFOUND         YES - GOOD SHOW.
SCNXCU   DS    0H
         BXLE  R2,R4,SCNNCU   BRANCH IF MORE CONTROL UNITS ON THIS CHAN
SCNXCH   DS    0H
         BXLE  R1,R4,SCNNCH   BRANCH IF MORE CHANNELS ON THIS MACHINE
         B     NXTVDV         NOT FOUND - SOMEBODY GOOFED; RESTORE REGS
* WE HAVE FOUND ALL THREE BLOCKS ASSOCIATED WITH THE DEVICE:
SCNFOUND DS    0H
         LH    R1,VCHADD      GET CHANNEL BITS,
         AH    R1,VCUADD      'OR' IN CONTROL UNIT BITS,
         AH    R1,VDEVADD     AND DEVICE BITS
         L     R2,SCNSV2      RESTORE Table addressability
         ST    R1,TVADDR      Save the virtual address
         DROP  R6
         DROP  R7
NXTVDV   DS    0H
         L     R1,ACTVLRG          Get start for last one
         LA    R2,VDEVSIZE*8       Get it's size in BYTES
         AR    R1,R2               Point to next one
         ST    R1,ACTVLRG          And save it
         BCT   R9,GETVDEV          Any left loop
         B     NXTVMB              Else on to the next id
         DROP  R8
         DROP  R10
* Now sort the table into order by VOLSER and start Cylinder          *
USERDONE DS    0H
         L     R1,USERCNT          Get the table Count
         LA    R1,1(R1)            Make relative to 1
         ST    R1,USERCNT          Store it back
         LTR   R1,R1               Did we find any?
         BNP   GETANCHR            No--Skip the sort
         CLC   USERCNT,=F'1'       only one?
         BE    GETANCHR            Yes--skip the sort
         LA    R1,SORTPARM         POINT TO OUR PARM LIST
         L     R15,=V(SORTI)       GET ENTRY POINT FOR SORT
         BALR  R14,R15             AND GO OUT TO IT
         CLC   RETCODE,=F'O'       CLEAN SORT
         BE    GETANCHR            YES--Continue
*  SORT PROBLEM                                                       *
         L     R15,RETCODE         RESTORE RETURN CODE
         LINEDIT TEXT='Sort Error Rc ....',SUB=(DEC,(R15)),DOT=NO
* Since all we have is 3380 we will only extract the T3380 anchor     *
* Currently it is not in DMKSYM. However until DMKPGT changes it is   *
* 260 bytes beyond DMKPGTPN, which is in the symbol table.            *
GETANCHR DS    0H
         CLC   OPTN,=CL8'BOTH'     Full report
         BE    ISPRINT             Yes are printing
         CLC   OPTN,=CL8'MAP'      Map only?
         BNE   ARNDHD              No is request for variable
ISPRINT  DS    0H
         MVI   PRINTSW,C'Y'        Indicate we have terminal output
* Lets go ahead and clear the screen now;                             *
         BAL   R1,CLRSVC
         DC    CL8'VMFCLEAR'
         DC    8X'FF'
CLRSVC   SVC   202
         DC    AL4(1)
         WRTERM '           T-DSK Allocations'
ARNDHD   DS    0H
         LA    R2,DIAGBUFF          Point to our buffer area
         DC    X'83200038'          Get the symbol table
         L     R2,=A(DIAGBUFF)      Point to start of buffer
         LA    R9,2048(R2)          Set End limit for scan
         LA    R9,2048(R9)          ....
         LA    R8,12                Increment by 12
COMPARE  OC    0(1,R2),0(R2)        Scan symbol table, end of table
         BE    NOTFND               Is indicated by x'00000000'
         CLC   0(8,R2),=C'DMKPGTPN' Have we found it
         BE    FOUND                Yes...continue
         BXLE  R2,R8,COMPARE        No...compare next entry
         B     NOTFND               Not found...exit
FOUND    L     R1,8(R2)             Get the address
         LA    R1,260(R1)           Increment to where we want
         ST    R1,PGT8A             Save T3380 Anchor address
         LA    R2,1                 Now ask for 1 word
         LA    R3,MYALLOC           Tell him where to put it
         BAL   R14,GETSTOR          Get first address in chain
* Next we will Walk the ALOCBLOK Chain.                               *
         LA    R10,MYALLOC          Addressability for labels
         USING ALOCBLOK,R10         Addressability
TDSKLOOP DS    0H
         LT    R1,ALOCPNT           Next ALOCBLOK
         BZ    NOMORE               Is None we will wrap this up
         LA    R2,ALOCLEN           Get words in base portion
         LR    R3,R2                **************
         SLL   R3,2                 *  Calculate and save
         AR    R3,R1                *  the address for the Map Portion
         ST    R3,ACTVLRG           *****
         LA    R3,MYALLOC           Tell where to put the Base portion
         BAL   R14,GETSTOR          Get it
         LH    R7,ALOCCYL1          Start cylinder
         LH    R8,ALOCCYL2          END Cylinder
         LR    R9,R8                End to work
         SR    R9,R7                Lets start
         LA    R9,1(R9)             Adjust for what is really there
         L     R14,TOTALA           Get previous allocated
         AR    R14,R9               Add to total allocated
         ST    R14,TOTALA           Save result
         L     R1,ALOCDEVP          Get Address of RDEVBLOK
         LA    R2,RDEVSIZE*2        Size in full words
         LA    R3,MYDEV             Point to target area
         BAL   R14,GETSTOR          And get it
         LA    R11,MYDEV            Point to the area
         CLI   PRINTSW,C'Y'         Are we printing
         BNE   AROUND1              No--skip the output
         WRTERM ' '                 Blank line to separate
         LINEDIT TEXT='......    Cylinder .... To .... Total ....',    X
               SUB=(CHARA,RDEVSER,DEC,(R7),DEC,(R8),DEC,(R9)),         X
               RENT=NO,DOT=NO,COMP=NO
* Now get the allocation map for this ALOCBLOK and then analyze it    *
* for Allocated and free extents. A value of x'82' is an allocated    *
* cylinder x'02' is a free cylinder                                   *
AROUND1  DS    0H
         BAL   R14,GETLARGE        Get the map portion into DIAGBUFF
* The Map Information is in DIAGBUFF. R7 = Start Cylinder R9 = the    *
* Number of bytes to check.  We will use the CLCL instruction to      *
* Parse into Allocated and Available chunks.                          *
         L     R4,=A(DIAGBUFF)     Point to start
         LR    R5,R9               Transfer count
         XR    R9,R9               Clear it For work
SETSCAN  DS    0H
         LR    R2,R4               Make sure R2 is at valid address
         SR    R3,R3               Length 0 for CLCL ...
         ICM   R3,B'1000',0(R4)    Pad = whatever R4 pointing to
* CLCL will no stop on any change of first value                      *
         LR    R14,R4              Remember the start point
         LR    R9,R5               Assume rest are the same
         CLCL  R4,R2               Do the scan
         BE    SCANDONE            Have finished. Wrap Last chunk
         SR    R9,R5               Subtract characters left
* R9 now contains the length of the last chunk we looked at.          *
* R14 points to the value we were scanning for. Update the ending     *
* cylinder and format and print the line.                             *
SCANDONE DS    0H
         LR    R8,R7               Start to work
         AR    R8,R9               + length of chunk
         BCTR  R8,0                Make it zero based
         MVC   TYPEALOC,=C'Available' Default to free
         TM    0(R14),X'80'        Is it really
         BZ    SHOWIT              Yes--continue
         MVC   TYPEALOC,=C'Assigned ' Make it allocated
SHOWIT   DS    0H
         CLI   PRINTSW,C'Y'        Printing?
         BNE   AROUND2             No--skip output line
         LINEDIT TEXT='   ........    .... To .... Total ....',        X
               SUB=(CHARA,TYPEALOC,DEC,(R7),DEC,(R8),DEC,(R9)),        X
               RENT=NO,DOT=NO,COMP=NO
AROUND2  DS    0H
         CLC   TYPEALOC,=C'Available' was it available
         BNE   MAPUSER             No--go check if user to map in
         L     R14,TOTFREE         Get previous free count
         AR    R14,R9              Add this chunk
         ST    R14,TOTFREE         Save this
         C     R9,LGST             Compare this to largest so far
         BNH   SHOWINCR            Not greater branch
         ST    R9,LGST             Save new Largest
* If we are printing the report and the current block was assigned    *
* locate the entry in the user allocation table and print the line    *
* showing the suballocation of the assigned block.                    *
MAPUSER  DS    0H
         CLI   PRINTSW,C'Y'        Are we reporting?
         BNE   SHOWINCR            No--skip this whole thing
         L     R2,=A(USERTBL)      Point to the mapping table
         LT    R3,USERCNT          Get the count of entries
         BNP   SHOWINCR            If no entries branch
MAPLOC   DS    0H
         CLC   TVOLSER,RDEVSER     Compare entry to current VoLSER
         BH    SHOWINCR            Table is high--we are done
         BL    MAPINCR             Table low--look at next
         C     R8,TSTART           Compare current end to table start
         BL    MAPINCR             Not for this block
         C     R7,TEND             Compare current start to end
         BH    MAPINCR             Not for this block
         LINEDIT TEXT='       ........ As ... .... To .... Total ....',X
               SUB=(CHARA,TUSER,HEXA,TVADDR,DECA,TSTART,DECA,TEND,     X
               DECA,TTOT),DOT=NO,COMP=NO,RENT=NO
MAPINCR  DS    0H
         LA    R2,32(R2)           Point to next
         BCT   R3,MAPLOC           Any more loop
SHOWINCR DS    0H
         LTR   R5,R5               Are we done with this
         BZ    TDSKLOOP            Yes--go after next one
         LR    R7,R8               Set new start Cylinder
         LA    R7,1(R7)            ....
         B     SETSCAN             And go process next
* Routine to Extract Multiple 64 word chunks of memory.               *
* R9 contains the Bytes needed. Convert this value to Full words and  *
* retrieve the memory in 64 word chunks.                              *
GETLARGE DS    0H
         ST    R14,LRGSV           Save return link
         LA    R2,DIAGBUFF         Point to start
         ST    R2,NXTLOC           Set start point
         ST    R9,GTLGSV9          Save the byte count for restore
         LA    R9,3(R9)            Set for Round up
         SRL   R9,2                Divide by 4 for full words
GETLRGLP DS    0H
         LTR   R9,R9               Any left to get
         BNP   LRGXIT              No--all are done exit
         C     R9,=F'64'           More than 64 words?
         BNH   USEALL              No--branch
         L     R2,='64'            Set to Max
         B     ASKLRG              And go get this chunk
USEALL   LR    R2,R9               Transfer what is left
ASKLRG   DS    0H
         SR    R9,R2               Update residual count
         L     R1,ACTVLRG          Get real storage address
         LR    R14,R1              Update next start point
         LA    R14,256(R14)        As if 64 words
         ST    R14,ACTVLRG         And store for next iteration
         L     R3,NXTLOC           Retrieve the target address
         LR    R14,R3              Update for next target
         LA    R14,256(R14)        As if 64 words
         ST    R14,NXTLOC          And save for next pass
         BAL   R14,GETSTOR         Get this chunk
         B     GETLRGLP            And loop
LRGXIT   DS    0H
         L     R9,GTLGSV9          Restore the byte count
         L     R14,LRGSV           Restore Link address
         BR    R14                 Return to caller
* DMKPGTPN not in symbol table. Tell him and quit.                    *
NOTFND   WRTERM MSG2,LMSG2         not found message displayed
         LA    R15,4
         B     ALLDONE
* End of Program--Return to System                                    *
NOMORE   DS    0H
         CLI   PRINTSW,C'Y'        Were we printing
         BNE   STRVAR              No--request was for variable store
* write the summary line and return                                   *
         WRTERM ' '
         LINEDIT TEXT='            Total .... Free .... Largest ....', X
               SUB=(DECA,TOTALA,DECA,TOTFREE,DECA,LGST),               X
               DOT=NO,COMP=NO,RENT=NO
         SR    R15,R15             Set zero return code
         B     ALLDONE
* Request was for largest contiguous block to be stored in the        *
* named REXX variable                                                 *
STRVAR   DS    0H
         L     R15,LGST            Get the largest value
         CVD   R15,DBL             Convert to decimal
         OI    DBL+7,X'0F'         Unsigned
         UNPK  LGDISP,DBL          And unpack for output
         LA    R1,SHRPARM          Point to the parm list
         L     R15,=V(SHRVAR)      Get routine entry
         BALR  R14,R15             And go do it
ALLDONE  DS    0H
         L     R13,4(R13)          Restore system save area pointer
         L     R14,12(R13)         Get R14 (leave R15 return code)
         LM    R0,R12,20(R13)      Restore the rest of REGS
         BR    R14                 And go back to system
* Routine to convert hex display field to actual hex value; Translate *
* Result of LOCATE to actual address                                  *
TRANSLAT DS   0H
         LA   R6,HEXARG            Point to Value
         LA   R1,HEXARG            And do it again
TRANSLT2 DS   0H
         LA   R7,2                 Number of Half words we will get
         SR   R2,R2                Clear work register
LOADUP   LA   R8,4                 Number of shift iterations
         L    R3,0(R6)             Get the first word of Hex equivalent
SHIFT    SLL  R3,4                 Drop the zone portion
         SLDL R2,4                 Shift the numeric portion to R2
         BCT  R8,SHIFT             Any more return
         STH  R2,0(R1)             Store this half word
         LA   R1,2(R1)             Advance output pointer
         LA   R6,4(R6)             Advance input pointer
         BCT  R7,LOADUP            Any more return
         BR   R14                  Else exit
*      C O N S T A N T S  A N D  W O R K  A R E A S                   *
TYPEALOC DC   CL9' '
OPTN     DC   CL8'BOTH'            Default both parts
         DC   CL4' '               Blank fill
LGDISP   DC   CL3' '
DBL      DS   D
* Area for Diagnose 0 results                                         *
         DS   0D
USERSTUF DC   C'   VM/370'    8 Bytes for this
         DC   3X'0'           Version,Level,PLC
         DC   X'0'            STIPD CoDE
         DC   2X'0'           MCEL LENGTH
         DC   2X'0'           STORE CPU ADDRESS
USERNAME DC   8C' '           Userid stored here
         DC   8X'00'          PROGRAM PRODUCT BIT MAP
* work reg save areas                                                 *
SCNSV2   DS   F
SCNSAVE  DS   3F
* Summary counters                                                    *
TOTALA   DS   F                    Total Tdsk allocated
TOTFREE  DS   F                    Total still free
LGST     DS   F                    Largest Contiguous block
* Various real Storage retrieval hold areas                           *
PGT8A    DS   F                    T3380 anchor block address
LRGSV    DS   F                    Link address save area
ACTVLRG  DS   F                    Address of allocation map
NXTLOC   DS   F                    Target address for map
GTLGSV9  DS   F                    R9 Save area
MYDEV    DS   0D,XL(RDEVSIZE*8)    Retrieved RDEVBLOK
MYVDEV   DS   0D,XL(VDEVSIZE*8)    Retrieved VDEVBLOK
MYVCHAN  DS   0D,XL(VCHSIZE*8)     Retrieved VCHBLOK
MYVCU    DS   0D,XL(VCUSIZE*8)     Retrieved VCUBLOK
MYALLOC  DS   0D,XL(ALOCLEN*4)     Base portion of ALOCBLOK
* Translate work areas                                                *
HEXARG   DS   0D
         DC   C'00'
HEXHLD   DS   CL6
* Translate table for Hex equivalents                                 *
HEXEQUIV DC   193X'00'
         DC   X'0A0B0C0D0E0F'
         DC   41X'00'
         DC   X'00010203040506070809'
         DC   6X'00'
* Various messages and stuff                                          *
MSG2     DC   C'DMKPGTPN is not in DMKSYM'
LMSG2    EQU  *-MSG2
*  Parm lists                                                         *
ONPARM   DC   A(MAXNUM),A(ACTNUM),B'10000000',AL3(USERT)
SHRPAM   DC   A(RETCODE),A(SHVCODE),A(SET),A(OPTN),A(LGDISP)
         DC   B'10000000',AL3(THREE)
SORTPARM DS   0F
         DC   A(USERTBL)           Address of User Table
         DC   A(USERCNT)           Number of entries to sortT
         DC   A(LENGTH)            Length of entry in bytes
         DC   A(RETCODE)           Return code field
         DC   A(THRTEEN)           Start position
         DC   A(TWLV)              Length of key
         DC   A(CH)                Character format
         DC   B'10000000'          Flag last parm
         DC   AL3(A)               Ascending sequence
* THE ACTUAL VALUES FOR THE PARMS                                     *
RETCODE  DS   F                    Place for sort return code
SHVCODE  DS   F                    SHV return code
LENGTH   DC   F'32'                LENGTH OF EACH TABLE ENTRY
TWLV     DC   F'12'                Length of the key
THRTEEN  DC   F'13'                START POSITION FOR SORT
THREE    DC   F'3'                 Length of Variable value
CH       DC   C'CH'                CHARACTER FORMAT
A        DC   C'A'                 ASCENDING SEQUENCE
PRINTSW  DC   C'N'
SET      DC   CL4'SET'
* Diagnose 8 buffers and pointers                                     *
DIAGLOC  DS   0D
         DC   A(DIAGMLOC)          Address of Command stream
         DC   A(DIAGBUFF)          Address for CP Return
         DC   X'40'                Indicate return output to us
         DC   AL3(DIAGLL)          Length of Command string
         DC   A(BUFFLN)            Length of our buffer
* Diagnose 8 command streams                                          *
         DS   0D
DIAGMLOC EQU  *
         DC   C'LOCATE '
LOCUSER  DC   CL8' '
DIAGLL   EQU  *-DIAGMLOC
         LTORG
* Table to store User T-DSK allocations                               *
USERCNT  DC   F'-1'                Count of entries in table
SEQ      DC   F'0'                 sort sequence indicator
MAXNUM   DC   F'200'               Max Number of users we can handle
ACTNUM   DS   F                    Actual Number of users
USERADDR DC   A(USERT)             Pointer to next id
PGMLN    EQU  *-TDSKMAP            Keep track of how big we are
* Set the following work area on a page boundary (For Symbol table)   *
         ORG   TDSKMAP+4096
DIAGBUFF DS    CL4096              Diagnose 8 and symbol return area
BUFFLN   EQU   *-DIAGBUFF
USERTBL  DC    200XL32'00'         Allocate entries by user
USERT    DS    200CL8              Table of logged users
* Labels for a user entry                                             *
USERENT  DSECT
TUSER    DS    CL8                 UserId for t-dsk allocation
TVADDR   DS    F                   His virtual address
TVOLSER  DS    CL6                 Label of Real device
         DS    XL2                 Fill for boundary alignment
TSTART   DS    F                   Real Start Cylinder
TEND     DS    F                   Real End   Cylinder
TTOT     DS    F
         END
GETNAM   CSECT
         PRINT NOGEN
*  A subroutine to obtain the names of logged users                   *
         FRBEGIN
         LR    R3,R1               Remember the Parm List
         USING PARMSECT,R3
* Issue a diag8 for QUERY NAMES with the output returned to us       *
         LM    R4,R7DIAGSTF         Set our Registers for CP Diagnose
         DC    X'83',X'46',AL2(X'0008')   Diagnose 8
         BZ    CONT                Everything OK--continue
*  Our buffer wasn't big enough.  R7 contains the bytes unused.       *
*  Reset this to max buffer length. Will ignore this condition        *
         L     R7,=F'8192'          Was overflow--Set to buffer length
*        We have the info in the buffer pointed at by r5              *
*        r7 contains the length of the response.                      *
*        Break this up into individual 14 byte User slots             *
CONT     DS    0H
         L     R1,MAXNUM            Pointer to his MAX
         L     R1,0(R1)             Get the actual value
         L     R2,HISBUFF           Get pointer to the Name array
         SR    R9,R9                Clear our Count Register
         LTR   R7,R7                Make sure we got some
         BZ    RETURN               No--Just quit
         AR    R7,R5                R7 Now points to end returned
         BCTR  R7,0                 Back up 1
         LR    R4,R5                Start of buffer into R4
         L     R6,=F'1'             Set increment for BXL instruction
*  Scan through the buffer ignoring X'15' C',' and leading ' '        *
COMPARE  DS    0H
         CLI   0(R4),X'15'          CP new Line??
         BE    UPIT                 Yes--go past it
         CLI   0(R4),C' '           Pointing at Blank
         BE    UPIT                 Yes--ignore it
         CLI   0(R4),C','           Is this the comma delimitor
         BNE   SETID                No--We have it
UPIT     DS    0H
         BXLE  R4,R6,COMPARE        Any left to check return
         B     RETURN               No--go wrap it up
*        Extract the information and move to his table                *
SETID    DS    0H
         CLC   0(4,R4),=C'LOGO'    In logon process?
         BE    SKIPLOG             Yes--skip him for now
         CR    R9,R1               Are we at his max??
         BNL   RETURN              Yes--Quit
         LA    R9,1(R9)            Add 1 to our Count
         MVC   0(08,R2),0(R4)      Move the entry to his table
SETIDINC DS    0H
         LA    R2,8(R2)            Bump his table pointer
SKIPLOG  DS    0H
         LA    R4,14(R4)           Bump the buffer pointer
         CR    R4,R7               still some more to look
         BL    COMPARE             yes--return to scan routine
         SPACE2
*  The scan is now done.  Update the count for the caller             *
*  and then sort the passed array into user order within logon id     *
RETURN   DS    0H
         L     R1,HISNUM           Get location for actual
         ST    R9,0(R1)            And store our count
         L     R13,4(R13)          Restore Caller's Save Registers
         RETURN (14,12),RC=15)     And Return to Caller
         SPACE 3
*             Constants and Work areas
*    The particulars for the Diagnose query names                     *
DIAGSTF  DS    0D
         DC    A(DIAGMSG)          ADDRESS OF COMMAND STREAM
         DC    A(DIAGBUFF)         ADDRESS FOR CP RETURN
         DC    X'40'               INDICATE RETURN OUTPUT TO US
         DC    AL3(DIAGLN)         LENGTH OF COMMAND STRING
         DC    A(BUFFLN)           LENGTH OF OUR BUFFER
*       The     Diagnose Command literals                             *
         DS    0D
DIAGMSG  EQU   *
         DC    C'QUERY NAMES'
DIAGLN   EQU   *-DIAGMSG
         LTORG
*        Here's where it goes                                         *
         DS    0D
DIAGBUFF DS    CL8192
BUFFLN   EQU   *-DIAGBUFF
*         Labels for passed argument list                            *
PARMSECT DS    0H
MAXNUM   DS    F                   Address for MAX for name slots
HISNUM   DS    F                   Address for actual Number returned
HISBUFF  DS    F                   Address for his Name Buffer
         END
         TITLE 'EXECCOMM Direct interface to current Variables'
*  ************  Program Summary: ********************************    *
*  The purpose of this subroutine is to provide to programs running   *
*  in the REXX environment the ability to directly retrieve or        *
*  set values in REXX Public variables.  The symbolic Interface is    *
*  the version we have chosen to implement.                           *
*        General Purpose Register Usage:                              *
*  Reg    Usage                                                       *
*  R0     Work                                                        *
*  R1     Work                                                        *
*  R2     Work                                                        *
*  R3     Work                                                        *
*  R4     Work                                                        *
*  R5                                                                 *
*  R6     Addressability to SHVBLOCK                                  *
*  R7                                                                 *
*  R8                                                                 *
*  R9     Work                                                        *
*  R10    Addressability to passed Parm list                          *
*  R11                                                                *
*  R12                                                                *
*  R13    Program Base register (also pointer to Save area)           *
*  R14    Linkage & return                                            *
*  R15    Linkage & return code                                       *
*        External References (subroutines Called)                     *
*   Routine:   Purpose                                                *
*  No External subroutines are called                                 *
SHRVAR   CSECT
         PRINT NOGEN
         PLIBEGIN
         USING SHVBLOCK,R6         Labels in shared Variable Block
         LA    R6,SHVDATA          Point to the block
         LR    R10,R1              Get the parm list pointer
         USING PARMBLK,R10         Addressability to Parm List
         XC    SV15,SV15           Default to zero return code
         MVI   SHVRET,SHVCLEAN     In SHVRET as well
         FTNOP ARNDCHK             First time only verify REXX active
* Fill in the Extended PLIST                                          *
         LA    R1,SHVCMND
         ST    R1,SHVPLIST
         ST    R6,SHVPLIST+12
* First time we will verify that the REXX environment is active.      *
* We will then set the appropriate switch which can be checked by     *
* The rest of the routines.                                           *
         LA    R2,VERSION          Will do Private on Version
         LA    R3,STKDATA          Point to our work buffer
         LA    R9,64               Set Expected Return
         BAL   R14,BLDRQST         Build Request
         MVI   SHVCODE,SHVPRIV     Request Private (REXX supported)
         BAL   R14,DOSHV           Go try shared variable command
         CL    R15,=F'-3'          Any EXECCOMM?
         BE    NOTREXX             No, set switch and return code
         TM    SHVRET,SHVBADF      Is REXX really in control?
         BZ    ARNDCHK             Yes--Continue with request
*  REXX not active, we can't do anything for him                    *
NOTREXX  DS    0H
         MVC   SV15,=F'300'        Set error return code
         MVI   REXXACT,C'N'        Remember it is not active
         B     RETURN              And get out of here
* Verify REXX active then process the request                       *
ARNDCHK  DS    0H
         CLI   REXXACT,C'Y'        Is it active
         BNE   NOTREXX             No--quit
         LM    R1,R4,ACTION        Get the Parm pointers into Regs
         CLC   0(4,R1),=C'CLRN'    Is request to clear Number field
         BE    CLEARN              Yes--Branch
         CLC   0(4,R1),=C'CLRC'    Is request to clear Non Numeric
         BE    CLEARC              Yes--Branch
         CLC   0(4,R1),=C'DROP'    Is request to drop the variable
         BE    DROP                Yes--Branch
         CLC   0(4,R1),=C'SET '    Is request to set value
         BE    SET                 Yes-Branch
         CLC   0(4,R1),=C'GET '    Is requst to Retreive a value
         BE    GET                 Yes--Branch
         CLC   0(4,R1),=C'PRIV'    Is request for Private Info
         BE    PRIVATE             Yes--Branch
         CLC   0(4,R1),=C'NEXT'    Is request for NEXTV
         BE    NEXT                Yes--Branch
         MVC   SV15,=F'500'        Set invalid function code
* Common exit point. Error code if any is in SV15. Pass this back     *
RETURN   DS    0H
         SR    R15,R15             Clear for insert
         IC    R15,SHVRET          Insert the SHV return code
         L     R1,HISSHVR          Get address of where to put it
         ST    R15,0(R1)           And put the code there
         L     R15,SV15            Get return code
         L     R1,HISRET           Get where to put it
         ST    R15,0(R1)           Put it there
         L     R13,4(R13)          Get pointer to his save
         RETURN (14,12),RC=(15)    And go back
* This routine will retrieve the Current value of the requested       *
* variable and pass it back to the caller                             *
GET      DS    0H
         L     R9,0(R4)            Retrieve Max buffer value
         BAL   R14,BLDRQST         Build the Request
         MVI   SHVCODE,SHVSYFET    Set request value for Fetch
         BAL   R14,DOSHV           Go do request
* This code is common to the Various Retrieval functions              *
GETRET   DS    0H
         L     R1,HISRLNG          Get pointer to return length
         MVC   0(4,R1),SHVVALL     Tell him how much there is
         B     RETURN              And return to caller
* Request to null non numeric field                                   *
CLEARC   DS    0H
         SR    R9,R9               Set length to zero
         B     SETNULL             And join common code
* Request to null numeric field                                       *
CLEARN   DS    0H
         MVI   STKDATA,C'0'        Set value zero
         LA    R9,1                Set length of 1
* Common code for both types of null request                          *
SETNULL  DS    0H
         LA    R3,STKDATA          Point to my buffer
         BAL   R14,BLDRQST         Build request
         MVI   SHVCODE,SHVSYSET    Request store of new value
         BAL   R14,DOSHV           And go do it
         B     RETURN              And return to caller
* Routine to set value in a variable                                  *
SET      DS    0H
         L     R9,0(R4)            Get the actual length for store
         BAL   R14,BLDRQST         Build the rest of the command
         MVI   SHVCODE,SHVSYSET    Request store value
         BAL   R14,DOSHV           Perform the function
         B     RETURN              And return to caller
* Retrieve Private info                                               *
PRIVATE  DS    0H
         L     R9,0(R4)            Get buffer length
         BAL   R14,BLDRQST         Build the Request
         MVI   SHVCODE,SHVPRIV     Set request for Private
         LA    R14,GETRET          Set to return to common retrieve
         B     DOSHV               Go do request
* Next Variable Request.                                              *
NEXT     DS    0H
         L     R9,0(R4)            Get data buffer length
         BAL   R14,BLDRQST         Finish the request
         MVI   SHVCODE,SHVNEXTV    NEXTV request
* Modify a few things for this request                                *
         MVC   SHVUSER,=F'12'      Set our arbitrary limit on name
         MVC   SHVNAML,=F'0'       Default - no next
         MVC   SHVVALL,=F'0'       ....
         BAL   R14,DOSHV           Do the request
         L     R1,NAMLNG           Get place for Name length
         MVC   0(4,R1),SHVNAML     Tell him how long
         B     GETRET              And go Pass back the value
* Drop a variable name                                                *
DROP     DS    0H
         LA    R3,STKDATA          Point some place
         LA    R9,0                But set zero length
         BAL   R14,BLDRQST         Finish the request
         MVI   SHVCODE,SHVSYDRO    Request Drop Variable
         BAL   R14,DOSHV           Perform the function
         B     RETURN              And return to caller
* Set up standard caller data into SHVBLOCK                           *
BLDRQST  DS    0H
         ST    R2,SHVNAMA          Store address of Name field
         LA    R1,12               Our Arbitrary Limit on Name
         ALR   R2,R1               Start address + Length = End+1
STRPNAM  DS    0H
         BCTR  R2,0                Decrement to point to previous
         TM    0(R2),X'BF'         Blank or null?
         BNZ   ENDNAM              No--we are done here
         BCT   R1,STRPNAM          Any more Loop
ENDNAM   DS    0H
         ST    R1,SHVNAML          Store length of variable name
         ST    R3,SHVVALA          Store address of Data buffer
         ST    R9,SHVBUFL          Store Expected value length
         ST    R9,SHVVALL          ...
         BR    R14                 and Return to caller
* Sub routine to actually call EXECCOMM                               *
DOSHV    DS    0H
         ST    R14,SV14            Save return link
         LA    R1,SHVCMND          Normal Plist
         LA    R0,SHVPLIST         And extended Plist
         ICM   R1,B'1000',=X'02'   Insert subcommand call flag
         SVC   202                 Issue SVC
         DC    AL4(1)              Next Instruction on error
         ST    R15,SV15            Save the Return code
         L     R14,SV14            Restore Link
         BR    R14                 Return to caller
* Constants and storage                                               *
SV15     DS    F                   R15 Return code save area
SV14     DS    F                   R14 Link address save area
* Exec Variable data areas                                            *
* This is described in DMSSP member SHVBLOCK                          *
SHVDATA  DC    8F'0'          Shared variable work area
* Extended Plist (filled in by First time processing)                 *
SHVPLIST DC    4A(0)
SHVCMND  DC    CL8'EXECCOMM'  Name of EXEC SUBCOM name
VERSION  DC    CL12'VERSION'  Version request to verify
STKDATA  DC    XL64'00'       Place to move data To/From Variables
REXXACT  DC    C'Y'           REXX Active indicator
         LTORG
         SHVBLOCK
* Additional equates for Symbolic Interface                           *
SHVSYSET EQU   C's'                Symbolic set
SHVSYFET EQU   C'f'                Symbolic fetch
SHVSYDRO EQU   C'd'                Symbolic Drop
* Layout of Callers Passed Parm list                                  *
PARMBLK  DSECT
HISRET   DS    F              Address for return code
HISSHVR  DS    F              Address for SHV sub code Return
ACTION   DS    F              Address of request type
NAME     DS    F              Address of Variable Name
HISVAL   DS    F              Address for Value
MAXLEN   DS    F              Address of length of value
HISRLNG  DS    F              Address of length of value returned
NAMLNG   DS    F              Return Name length on next function
         END


Maurice Smyth
Senior Systems Programmer
Frank Russell Company (USA) ) Frank Russell Company 1990


