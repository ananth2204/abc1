 Encrypted code and literals in CMS modules
ÝEditor's note: because security within a system is so important we are
returning to the subject and printing this article, which gives an alternative
approach to that of the articles in issues 8 and 11.¨
THE PROBLEM
Sensitive literals can be read from modules when these are edited.  Such
literals can be passwords, tables or CP/CMS commands that the installations does
not wish to disclose to users or unauthorised personnel.
THE SOLUTION
We have developed a procedure that allows encryption of modules and dynamic
decryption at execution time.  It should run under any release of CMS.
It has two components:
1    An Assembler macro called KRYP, which decrypts code during execution.
2    A program also called KRYP, which encrypts modules which contains code
generated by the KRYP macro.
Usage of KRYP procedure:
After saving registers and establishing addressability in your program, you
should code
     KRYP KEY=nn
where nn  is any hexadecimal key from 01 to 39 or 41 to FF (code X'00' will not
work and X'40' will just translate literals to upper or lower case).  Of course,
the macro should be added to any global MACLIB in order to be reachable by the
CMS Assembler.
Kryp will generate two fences X'ECEEED', one at the expanded code and another at
the literal pool.  At running time, it will check one key byte.  If it is X'00',
the module has been encrypted by the KRYP program and this macro will loop an XI
instruction with the key (nn) chosen.  If not, it will execute normally as with
no encryption.
After assembling, loading and generating your module, type in CMS:
     KRYP module-name
and it will be encrypted and ready for production.  KRYP will not change either
a module without those fences or one that has been already encrypted.
Literals and code will be unrecognisable for unsophisticated users.  The
remainder will spend some time figuring out the key and coding a program to
'uncrypt' the module.
NOTE OF CAUTION
Take care to save R1 before coding the KRYP macro if you wish to process
arguments passed by CMS (KRYP users R1 and R2 registers).
The easiest way to find what was encrypted is to display the memory where the
module was loaded, after execution.
One way to counter that is to zero the loaded area with an NI instruction loop
just before exiting to CMS.
A better solution is to code a self-relocatable module, which will be transient-
loaded, will self-bootstrap (encrypted) into a DMSFREE'd area, uncrypt itself,
execute and at last will DMSFRET itself.  CMS will take care of zeroing this
DMSFRET'd area.  This technique is used by our installation and was borrowed
from command BROWSE code.  It also guarantees re-entrant code, while the first
option obviously does not.
KRYP encrypts all code from its position up to the literal pool.  If you want to
access areas before the decryption begins, be sure to force the literal pool
(coding LTORG) and define those areas after that.
Encryption is restricted to 4K of code.
The following code is:
y    A sample program (CRYPSMPL) using KRYP macro and the first solution to
destroy decrypted core.
y    Source code of KRYP macro.
y    Source code of KRYP program.
CRYPSMPL ASSEMBLE
* THIS SAMPLE PROGRAM SHOWS USAGE OF KRYP MACRO AND ALSO AN OPTIONAL
* ROUTINE FOR DESTROYING SENSITIVE CORE BEFORE EXITING TO CMS.
CRYPSMPL CSECT
         USING *,R12               ESTABLISH ADDRESSABILITY
         STM   R0,R14,8(R13)       SAVE REGS
         LR    R8,R1               SAVE ARGUMENT POINTER
         KRYP  KEY=33              (DEFAULT FOR KEY IS X'75')
         LR    R1,R8               RESTORE ARGUMENT POINTER
 *  ALL CODE FROM HERE TO THE LITERAL POOL WILL BE EN- & DECRYPTED.
*  DON'T FORGET TO ENCRYP THIS MODULE USING THE KRYP PROGRAM
         BAL   R9,NULLCORE         CORE-NULLIFYING ROUTINE
         LM    R0,R14,8(R13)       RESTORE REGS
         XR    R15,R15             ZERO RETURN CODE
         BR    R14,                BACK TO CMS
*     KEEP THIS ROUTINE HERE - IT NULLS  CORE FROM NULLINIT UP TO THE
*     LITERAL POOL
NULLCORE EQU   *
         LA    R4,NULLINIT         START
         LA    R5,=X'ECEEED'       END (FENCE GENERATEDED BY KRYP MACRO)
         LA    R5,3(R5)            INCLUDE FENCE
         SR    R5,R4               AREA IN BYTES
         NI    0(R4),X'00'         NULL FIRST BYTE
         LA    R4,1(R4)            BUMP POINTER
         BCT   R5,*-8              DO THEM ALL
         BR    R9                  RETURN
NULLINIT EQU   *
*     SUBROUTINES, DATA, ETC
         PRINT NOGEN
         DC    C'THIS LITERAL WILL BE EN- DECRYPTED AND DESTROYED'
         LTORG                         TO FORCE END OF ENCRYPTION
         REGEQU
         DC    C'THIS LITERAL WILL REMAIN UNTOUCHED'
         END   CRYPSMPL

KRYP MACRO
         MACRO
&LABEL   KRYP  &KEY=75             DEFAULT VALUE FOR KEY
         AIF   ('&KEY' NE '00' AND '&KEY' NE '40').KEYOK
         MNOTE 4,'  00 OR 40 ARE INVALID VALUES FOR KEY'
         MEXIT
.*  MACRO TO DECRYPT CODE AT RUN TIME
.KEYOK   ANOP
&LABEL   CLI   TEX&SYSNDX-1,X'00'  MODULE IS ENCRYPTED?
         BNE   TEX&SYSNDX          NO ... LEAVE
         LA    2,=X'ECEEED'        LOAD FENCE
         LA    1,TEX&SYSNDX        START ADDRESS
         SR    2,1                 RANGE IN R2
         XI    0(1),X'&KEY'        RESTORE ...
         LA    1,1(1)              ENCRYPTED ...
         BCT   2,*-8               AREA ...
         B     TEX&SYSNDX
         DC    X'ECEEED',AL1(X'&KEY')
TEX&SYSNDX DS 0H
         MEND

KRYP ASSEMBLE
*   THIS PROGRAM ENCRYPTS MODULES WHICH CONTAIN CODE GENERATED BY
*   THE KRYP MACRO. IT SEARCHES FOR A FENCE X'ECEEED' AND AN
*   ENCRYPTION BYTE AFTER IT. THE KEY IS XORE'D WITH ITSELF
*   (BECOMING X'00') TO BE TESTED AS A FLAG TO AVOID REPEATED
*   ENCRYPTIONS. THE CODE IS XORE'D UP TO THE NEXT FENCE IN THE CODE.
*   THE MODULE WILL BE DECRYPTED AT EXECUTION TIME.
         PRINT NOGEN
KRYP     CSECT
         USING *,R12                 ESTABLISH ADDRESSABILITY
         USING FSCBD,R10             ADDRESSABILITY FOR FSCB DSECT
         STM   R0,R14,8(R13)         SAVE REGISTERS
         LA    R10,FSCB              LOAD BASE FOR FSCB
         CLI   8(R1),X'FF'           ANY ARGS?
         BE    HELP                  NO ... ARGUMENT REQUIRED
         CLI   8(R1),C'?'            HELP WANTED
         BE    HELP                  YES ...
         MVC   FSCBFN,8(R1)          MOVE FILENAME
         FSOPEN FSCB=FSCB,ERROR=OPENERR  OPEN MODULE
          L     R0,FSCBSIZE           LRECL TO GET A READ BUFFER
         A     R0,=F'7'              ROUND IT AND CONVERT ...
         SRL   R0,3                  TO DOUBLE WORDS FOR DMSFREE
         DMSFREE DWORDS=(0),ERR=DMSFRER,TYPE=USER  GET FREE STORAGE
         STM   R0,R1,SAVER0R1        SAVE DMSFREE'D DATA
         LR    R4,R1                 R4 POINTS TO READ BUFFER
*   WE READ THE SECOND RECORD WHICH CONTAINS THE CODE PROPER.
*   BECAUSE OF ADDRESSABILITY CONSTRAINTS, UP TO 4K CAN BE ENCRYPTED
         FSREAD FSCB=FSCB,RECNO=2,BUFFER=(R4)
         LA    R6,1                  INCREMENT FOR BXLE
         L     R7,FSCBSIZE           LOAD LRECL
         AR    R7,R4                 LIMIT FOR SCAN
SCANLUP  EQU   *
         BXH   4,6,NOTFND            FENCE NOT FOUND
         CLC   0(3,R4),FENCE         FENCE ?
         BNE   SCANLUP               NO, KEEP LOOKING
         CLI   3(R4),X'00'           ALREADY ENCRYPTED ?
         BE    DONE                  YES ...
         LA    R4,3(R4)              BUMP POINTER TO ENCRYPTION KEY
         MVC   CRYPKEY,0(R4)         SAVE IT FOR XC LOOP
XCLOOP   EQU   *
         XC    0(1,R4),CRYPKEY       XOR BYTE TO BYTE
         BXH   4,6,NOTFND            INCREMENT AND TEST LIMIT
         CLC   0(3,R4),FENCE         FENCE ?
         BNE   XCLOOP                NO, KEEP DECRYPTING
         L     R4,SAVER0R1+4         R4 POINTS TO WRITE BUFFER
*  THE SECOND RECORD IS WRITTEN BACK INTO THE MODULE
         FSWRITE FSCB=FSCB,RECNO=2,ERROR=WRTERR,BUFFER=(R4)
DMSFRET  EQU   *
         LM    R0,R1,SAVER0R1        RESTORE R0 AND R1 FOR  DMSFRET
         DMSFRET DWORDS=(0),LOC=(1)  RETURN DMSFREE'D AREA
         LR    R8,R15                RETURN CODE FOR DMSFRET
CLOSE    EQU   *
         FSCLOSE FSCB=FSCB           CLOSE FILE
EXIT     EQU   *
         LR    R15,R8                LOAD RETURN CODE
         LM    R0,R14,8(R13)         RESTORE REGS
         BR    R14                   BACK TO CMS
*                          MESSAGES
OPENERR  LR    R8,R15                RETURN CODE
         LINEDIT TEXT='ERROR .. READING ........ MODULE ..',RENT=NO,  *
               SUB=(DEC,(8),CHAR8A,FSCBFN,CHAR8A,FSCBFM),DOT=NO
         B     EXIT
WRTERR   LR    R8,R15                RETURN CODE
         LINEDIT TEXT='ERROR .. WRITING ........ MODULE ..',RENT=NO,  *
               SUB=(DEC,(8),CHAR8A,FSCBFN,CHAR8A,FSCBFM),DOT=NO
         B     DMSFRET
DMSFRER  LR    R8,R15                RETURN CODE
         LINEDIT TEXT='DMSFREE ERROR ..',SUB=(DEC,(8))
         B     CLOSE
NOTFND   LINEDIT TEXT='NO KRYP CODE FOUND IN ........ MODULE ..',     *
               SUB=(CHAR8A,FSCBFN,CHAR8A,FSCBFM),DOT=NO,RENT=NO
         B     DMSFRET
DONE     LINEDIT TEXT='........ MODULE .. IS ALREADY ENCRYPTED'       *
               SUB=(CHAR8A,FSCBFN,CHAR8A,FSCBFM),RENT=NO,DOT=NO
         B     DMSFRET
HELP     WRTERM 'FORMAT  : KRYP MODULE-NAME'
         WRTERM 'FUNCTION: ENCRYPT MODULES CONTAINING MACRO KRYP CODE'
         SR    R8,R8                 ZERO RETURN CODE
         B     EXIT
         DS    0D
SAVER0R1 DS    D
FSCB     FSCB  '12345678 MODULE * '
FENCE    DC    X'ECEEED'
CRYPKEY  DS    X
         FSCBD
          REGEQU
         END
Daniel Arany
Texaco (Brazil)     ) Texaco Brasil 1988






























































