{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012438000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE603.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE603.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x05'", "DS1TRBAL": "b'\\xa6j'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04g\\x00\\x01\\x04g\\x00\\x07\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x047\\x00\\x00\\x01\\x022o\\x01\\x022o\\x109\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf5@@@'", "ispf": {"version": "04.55", "flags": 0, "createdate": "2002-11-22T00:00:00", "modifydate": "2002-11-22T10:39:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-455"}, "text": "REGULAR CBT TAPE - VERSION 455    FILE:  603\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT455.FILE603\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 15 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,418 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/22/02    10:38:59    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE603": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x047\\x00\\x00\\x01\\x022o\\x01\\x022o\\x107\\x005\\x005\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf5@@@'", "ispf": {"version": "04.55", "flags": 0, "createdate": "2002-11-22T00:00:00", "modifydate": "2002-11-22T10:37:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "CBT-455"}, "text": "//***FILE 603 is from Sebastian Welton, and contains a powerful     *   FILE 603\n//*           pds scanning tool called QWIKSCAN, which is meant     *   FILE 603\n//*           to run under TSO/ISPF.                                *   FILE 603\n//*                                                                 *   FILE 603\n//*           email:    sebastian@welton.de                         *   FILE 603\n//*           website:  www.welton.de                               *   FILE 603\n//*                                                                 *   FILE 603\n//*     Short description:                                          *   FILE 603\n//*                                                                 *   FILE 603\n//*     Basically QWIKSCAN is a low level, high performance PDS     *   FILE 603\n//*     scanning utility that will perform character-by-character   *   FILE 603\n//*     comparisons of PDS members for up to 234 bytes of user      *   FILE 603\n//*     data. User data is defined as:                              *   FILE 603\n//*                                                                 *   FILE 603\n//*     * Up to 78 bytes of 'if' data                               *   FILE 603\n//*     * Up to 78 bytes of 'and' data                              *   FILE 603\n//*     * Up to 78 bytes of 'or' data                               *   FILE 603\n//*                                                                 *   FILE 603\n//*     In addition to this the user may enhance the performance    *   FILE 603\n//*     of QWIKSCAN by means of giving it delimiting 'stop after'   *   FILE 603\n//*     instructions in either its regular mode of operation or     *   FILE 603\n//*     it's super-locate mode.                                     *   FILE 603\n//*                                                                 *   FILE 603\n//*     While QWIKSCAN is running, the user's terminal is           *   FILE 603\n//*     updated after the first 50 and every subsequent 50 PDS      *   FILE 603\n//*     members are processed.  The updated panel will tell the     *   FILE 603\n//*     user how many members have been processed so far, and       *   FILE 603\n//*     how many successful matches have been located.              *   FILE 603\n//*                                                                 *   FILE 603\n//*     Assuming that at least one successful match has been        *   FILE 603\n//*     made, a temporary ISPF table is updated with the member     *   FILE 603\n//*     name, ISPF statistics, etc. and when the search completes   *   FILE 603\n//*     this table will be presented to the user.  They may then    *   FILE 603\n//*     select any or all displayed members (multiple row selects   *   FILE 603\n//*     are honoured.)                                              *   FILE 603\n//*                                                                 *   FILE 603\n//*     If a member is selected for processing, QWIKSCAN will       *   FILE 603\n//*     initiate an ISPF BROWSE session with the nominated          *   FILE 603\n//*     member(s).  Prior to displaying the member, QWIKSCAN will   *   FILE 603\n//*     pre-format the control line of the BROWSE panel with the    *   FILE 603\n//*     command required to find the user 'if' character string.    *   FILE 603\n//*     So, all the user has to do to locate the data they are      *   FILE 603\n//*     interested in, is to press ENTER and use the RFIND key      *   FILE 603\n//*     to display further occurrences, if any.                     *   FILE 603\n//*                                                                 *   FILE 603\n//*     As a rough guide to performance, QWIKSCAN requires about    *   FILE 603\n//*     0.9 seconds, elapsed time, to search a PDS member fixed     *   FILE 603\n//*     at 80 bytes, containing approximately 80 lines of data      *   FILE 603\n//*     for a 4 byte search string (and not finding it.)  Having    *   FILE 603\n//*     said this the processing time is ultimately dependent       *   FILE 603\n//*     upon machine type, IPS settings, allocated SU's, etc.  It   *   FILE 603\n//*     is possible, as explained later, to instruct QWIKSCAN to    *   FILE 603\n//*     operate far quicker than this.                              *   FILE 603\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QWIK": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x01\\x022_\\x01\\x022_\\x07\\x15\\x01\\x14\\x01\\x10\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-11-21T00:00:00", "modifydate": "2002-11-21T07:15:19", "lines": 276, "newlines": 272, "modlines": 0, "user": "OPSUPP"}, "text": "/*%NOCOMMENT rexx ******************************************************\n*                                                                      *\n* Program: QWIK - QWIKSCAN Maximised PDS Scanner                       *\n*                                                                      *\n* Syntax: TSO QWIK                                                     *\n*                                                                      *\n* Function: Scan a PDS for a string in foreground quickly and with     *\n*           various options available                                  *\n*                                                                      *\n* Calls: Program QWIKSCAN                                              *\n*                                                                      *\n* Called:                                                              *\n*                                                                      *\n* Notes: Make sure you have the correct ISPF panel and message         *\n*        libraries specified and a LOAD library                        *\n*                                                                      *\n*        Sorry...no warranty but questions or inquiries can be         *\n*        directed to: sebastian\u00a7welton.de                              *\n*                     www.welton.de                                    *\n*                                                                      *\n* Created: OPSUPP on 09/05/02                                          *\n*                                                                      *\n************************************************************************\n* Updates:                                                             *\n* 09/05/02 - userid:  add comments here                                *\n*                                                                      *\n* Version 1.0.0 *******************************************************/\n/* ************************************************************ *\n * We always come in here, call our main routines and if all    *\n * goes according to plan we should exit from here              *\n * ************************************************************ */\nSignal On Syntax                        /* Syntax Error              */\nSignal On Novalue                       /* Novalue error             */\nSignal On Halt                          /* Program halted            */\nSignal On Error                         /* Program error             */\nCall tool_init                          /* System and debug variables*/\nCall tool_wrapup                        /* Lets go home|             */\n\n/* ************************************************************ *\n * Main routine, also set up a number of constants and          *\n * variables that will be used during the run (if necessary).   *\n * ************************************************************ */\n          /*-------------------------------------------------*\n          * Start your tool processing in this section only  *\n          *-------------------------------------------------*/\ntool_start:\ntool_start_adr = Address()\nsub_proc = 'TOOL_START'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc': START...'\nqwikplib = Userid()||'.USER.PLIB'       /* Change to ISPF panel lib  */\nqwikmlib = Userid()||'.USER.MLIB'       /* Change to ISPF msgs lib   */\nqwikload = Userid()||'.USER.LOAD'       /* Change to LOAD library    */\nAddress Ispexec\n'LIBDEF ISPLLIB DATASET ID('\"'\"qwikload\"'\"') STACK'\n'LIBDEF ISPMLIB DATASET ID('\"'\"qwikmlib\"'\"') STACK'\n'LIBDEF ISPPLIB DATASET ID('\"'\"qwikplib\"'\"') STACK'\nAddress Ispexec 'SELECT PGM(QWIKSCAN)'\np_rc = Rc\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc': ENDE. RC='p_rc\nAddress Value tool_start_adr\nReturn\n\n/* -------------------------------------------------------------- *\n * This is where we exit our program and perform some cleanup.    *\n * -------------------------------------------------------------- */\ntool_wrapup:\ntool_wrapup_adr = Address()\nsub_proc = 'TOOL_WRAPUP'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc' - START'\nAddress Ispexec\n'LIBDEF ISPLLIB'\n'LIBDEF ISPMLIB'\n'LIBDEF ISPPLIB'\nresult = p_rc                           /* Set exit return code      */\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc': ENDE. RC='p_rc\nAddress Value tool_wrapup_adr\nExit result\n\n          /*-------------------------------------------------*\n          * Simple, very basic help. If the program is called*\n          * with HELP or ? after (( then this sections will  *\n          * be called (also used in error conditions)        *\n          *-------------------------------------------------*/\ntool_help:\ntool_help_adr = Address()\nCall tool_saystart\n/*\nSee documentation for full details\n*/\nCall tool_sayend\nAddress Value tool_help_adr\np_rc = 1\nCall tool_wrapup\n\ntool_saystart:\ntool_saystart_adr = Address()\nsay_start = Sigl + 2\nAddress Value tool_saystart_adr\nReturn\n\ntool_sayend:\ntool_sayend_adr = Address()\nsay_end = Sigl - 2\nDo i_i = say_start To say_end\n  Say Sourceline(i_i)\nEnd\nAddress Value tool_sayend_adr\nReturn\n\n/* -------------------------------------------------------------- *\n * N O V A L U E Error                                            *\n * -------------------------------------------------------------- */\nnovalue:\nnovalue_adr = Address()\nsub_proc = 'NOVALUE'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc' - START'\nIf Words(Sigl) > 1 Then Do\n  sigl = Space(sigl,1,'_')\n  Call tool_msg '001' 'E' 'S' sigl\nEnd\nElse Call tool_msg '001' 'E' 'S' sigl\nvar = Condition('D')\nIf Words(var) > 1 Then Do\n  var = Space(var,1,'_')\n  Call tool_msg '002' 'E' 'S' var\nEnd\nElse Call tool_msg '002' 'E' 'S' var\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc ': ENDE. RC=' p_rc\nAddress Value novalue_adr\nReturn\n\n/* -------------------------------------------------------------- *\n * S Y N T A X Error                                              *\n * -------------------------------------------------------------- */\nsyntax:\nsyntax_adr = Address()\nsub_proc = 'SYNTAX'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc' - START'\nabend_rc = rc\nabend_rc = Errortext(abend_rc)\nline1 = sigl\nline2 = Sourceline(line1)\nIf Words(line1) > 1 Then Do\n  line1 = Space(line1,1,'_')\n  Call tool_msg '003' 'E' 'S' line1\nEnd\nElse Call tool_msg '003' 'E' 'S' line1\nCall tool_msg '004' 'E' 'A' abend_rc\nIf Words(line2) > 1 Then Do\n  line2 = Space(line2,1,'_')\n  Call tool_msg '005' 'E' 'S' line2\nEnd\nElse Call tool_msg '005' 'E' 'S' line2\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc ': ENDE. RC=' p_rc\nAddress Value syntax_adr\nReturn\n\n/* -------------------------------------------------------------- *\n * E R R O R Error                                                *\n * -------------------------------------------------------------- */\nerror:\nerror_adr = Address()\nsub_proc = 'ERROR'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc' - START'\nabend_rc = rc\nline5 = sigl\nline3 = line5||'. RC:' abend_rc\nline4 = Sourceline(line5)\nIf Words(line3) > 1 Then Do\n  line3 = Space(line3,1,'_')\n  Call tool_msg '006' 'E' 'S' line3\nEnd\nElse Do\n  Call tool_msg '006' 'E' 'S' line5\nEnd\nIf Words(line4) > 1 Then Do\n  line4 = Space(line4,1,'_')\n  Call tool_msg '007' 'E' 'S' line4\n  Call tool_msg '008' 'I' 'S'\nEnd\nElse Do\n  Call tool_msg '007' 'E' 'S' line4\n  Call tool_msg '008' 'I' 'S'\nEnd\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc ': ENDE. RC=' p_rc\nAddress Value error_adr\nReturn\n\n/* -------------------------------------------------------------- *\n * H A L T Error                                                  *\n * -------------------------------------------------------------- */\nhalt:\nhalt_adr = Address()\nsub_proc = 'HALT'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc' - START'\nCall tool_msg '009' 'I' 'S'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc ': ENDE. RC=' p_rc\nAddress Value halt_adr\nReturn\n\n\n          /*-------------------------------------------------*\n          * Set all debug and trace options                  *\n          *-------------------------------------------------*/\ntool_init:\ntool_init_adr = Address()\nAddress Tso\nParse Source sys_id how_invokt exec_name dd_nm te.ds_nm ,\n as_invokt cmd_env addr_spc usr_tokn\nrif = Sysvar('sysenv')\nIf rif = 'FORE' Then rif = 'Y'\nElse rif = 'N'\niia = Sysvar('sysispf')\nIf iia = 'ACTIVE' Then iia = 'Y'\nElse iia = 'N'\nproc_trace = 'N'                      /* No tracing and no display */\ntrace_level = 'O'                     /* of procedure statements   */\nIf proc_trace = 'Y' Then Trace Value trace_level\np_rc = 0                                /* Standard return code      */\nmsg_prefix = exec_name\nCall tool_start\nAddress Value tool_init_adr\nReturn\n\n/* -------------------------------------------------------------- *\n *                                                                *\n * -------------------------------------------------------------- */\ntool_msg:\ntool_msg_adr = Address()\nsub_proc = 'TOOL_MSG'\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc' - START'\nParse Arg tool_msg_no severity where arg1 arg2 arg3 arg4 arg5\nSelect\n  When tool_msg_no = '001' Then ,\n   text = 'NOVALUE for data at:' arg1'.'\n  When tool_msg_no = '002' Then ,\n   text = 'Variable' arg1 'has no value.'\n  When tool_msg_no = '003' Then ,\n   text = exec_name 'program has a syntax error at line:' arg1'.'\n  When tool_msg_no = '004' Then ,\n   text = 'The cause is:' arg1'.'\n  When tool_msg_no = '005' Then ,\n   text = 'And the code is:' arg1'.'\n  When tool_msg_no = '006' Then ,\n   text = exec_name 'has an error at line' arg1'.'\n  When tool_msg_no = '007' Then ,\n   text = 'And the code is:' arg1'.'\n  When tool_msg_no = '008' Then ,\n   text = 'If RC = 2 and the code is EXECIO then this is not an error.'\n  When tool_msg_no = '009' Then ,\n   text = exec_name 'has been stopped by operator.'\n  Otherwise text = 'No message text for this message.'\nEnd\nSelect\n  When where = 'S' Then Do\n    If rif = 'Y' & iia = 'Y' Then Do\n      zedlmsg = msg_prefix||tool_msg_no||severity text\n      Address Ispexec 'SETMSG MSG(ISRZ001)'\n    End\n    Else Say msg_prefix||tool_msg_no||severity text\n    Return\n  End\n  When where = 'O' Then Do\n    Say msg_prefix||tool_msg_no||severity text\n    'SEND' msg_prefix||apk_msg_no||severity text ',BRDCST'\n    Return\n  End\n  Otherwise Do\n    Say msg_prefix||tool_msg_no||severity text\n    Return\n  End\nEnd\nIf proc_trace = 'Y' Then Say exec_name'-'sub_proc ': ENDE. RC=' p_rc\nAddress Value tool_msg_adr\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QWIKDOC": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x022o\\x01\\x022o\\x109\\x02G\\x02G\\x00\\x00\\xe6\\xd6\\xd9\\xc4\\xf9\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-22T00:00:00", "modifydate": "2002-11-22T10:39:00", "lines": 583, "newlines": 583, "modlines": 0, "user": "WORD97"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "QWIKSCA$": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x022o\\x01\\x022o\\x00G\\x00\\xea\\x00\\xea\\x00\\x00\\xe3\\xc5\\xe7\\xe3\\xc4\\xd6\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-22T00:00:00", "modifydate": "2002-11-22T00:47:00", "lines": 234, "newlines": 234, "modlines": 0, "user": "TEXTDOC"}, "text": "QWIKSCAN\nMaximised PDS Scanning\n\n\nContents\nContents                           2\nIntroduction                       3\nInstalling QWIKSCAN                4\nStructured Testing of QWIKSCAN     5\nTesting                            5\nQWIKSCAN Modes of Operation        6\nNormal Locate                      6\nSuper Locate                       6\nMask Matching Fields               7\n\nIntroduction\nQWIKSCAN is written in S/370 Assembler H and executes within an\nISPF environment. QWIKSCAN requires ISPF Release 2 Version 0 or\nabove to process, it also requires a terminal type of 3192-2 (or\nsimilar) or above.\n\nBasically QWIKSCAN is a low level, high performance PDS scanning\nutility that will perform character-by-character comparisons of\nPDS members for up to 234 bytes of user data. User data is\ndefined as:\n\n* Up to 78 bytes of 'if' data\n* Up to 78 bytes of 'and' data\n* Up to 78 bytes of 'or' data\n\nIn addition to this the user may enhance the performance of\nQWIKSCAN by means of giving it delimiting 'stop after'\ninstructions in either it's regular mode of operation or it's\nsuper-locate mode.\n\nWhilst QWIKSCAN is running the users terminal is updated after\nthe first 50 and every subsequent 50 PDS members are processed.\nThe updated panel will tell the user how many members have been\nprocessed so far and how many successful matches have been\nlocated.\n\nAssuming that at least one successful match has been made,  a\ntemporary ISPF table is updated with the member name, ISPF\nstatistics, etc. and when the search completes this table will be\npresented to the user. They may then select any or all displayed\nmembers (multiple row selects are honoured.)\n\nIf a member is selected for processing, QWIKSCAN will initiate an\nISPF BROWSE session with the nominated member(s). Prior to\ndisplaying the member, QWIKSCAN will pre-format the control line\nof the BROWSE panel with the command required to find the user\n'if' character string. So, all the user has to do to locate the\ndata they are interested in, is to press ENTER and use the RFIND\nkey to display further occurrences, if any.\n\nAs a rough guide to performance, QWIKSCAN requires about 0.9\nseconds, elapsed time, to search a PDS member fixed at 80 bytes,\ncontaining approximately 80 lines of data for a 4 byte search\nstring (and not finding it.) Having said this the processing time\nis ultimately dependent upon machine type, IPS settings,\nallocated SU's, etc. It is possible, as explained later, to\ninstruct QWIKSCAN to operate far quicker than this.\n\n\nInstalling QWIKSCAN\nThe following PDS members should be obtained and copied to their\nrespective datasets (in the case of load libraries, the source\nmust first be assembled):\n\nName                    Library\n----                    -------\nQWIKSCN1                ISPF Panel Dataset\nQWIKSCN2                ISPF Panel Dataset\nQWIKSCN3                ISPF Panel Dataset\nQWIKS00                 ISPF Message Dataset\nQWIKS01                 ISPF Message Dataset\nQWIKSCAN                ISPF Load Dataset\nQWKF                    ISPF Load Dataset\nQWKX                    ISPF Load Dataset\nQWIK                    SYSEXEC Dataset\nQWIKASM                 JCL Dataset\n\nOnce this has been done you are now ready to perform a series of\nstructured tests of QWIKSCAN.\n\nStructured Testing of QWIKSCAN\n\nNow that you have installed the various modules to their correct\nlocations it is possible to determine if QWIKSCAN is functioning\nproperly. Follow the series of tests described below, assuming\nthat everything is working correctly you may now use QWIKSCAN\nhowever you wish. For the purpose of these test you must know the\nname of the ISPF Message Library, this contains 2 QWIKSCAN\nmembers and will be the target of the tests.\n\nTesting\n1. Exit and re-initialise ISPF. This will force the inclusion of\n   all new ISPF objects\n2. From ISPF option 6 enter QWIKSCAN\n3. The primary QWIKSCAN panel will be displayed\n4. Enter the following values in the fields:\n* The PDS name which is your ISPF Message Library\n* ALARM which is the string to search for\n5. Now press ENTER\n6. The dialog will respond with the message: Enter GO to start\n7. Enter GO in the command field\n8. After a second or two, the second QWIKSCAN will be displayed\n   showing 4 table entries. The ISPF LMSG will display: 'Scanned 4\n   members, matched 4 members'\n9. Enter an 'S' in each of the 'SEL' fields and press ENTER\n10. QWIKSCAN will initiate a browse for each of the selected members\n11. The command 'F ALARM' will be formatted in the command line\n12. Press PF3 until you are back at the first QWIKSCAN screen\n13. The values you entered will still be displayed on the panel\n14. In the STATS mask field 'CREATED' enter '**/' and enter GO on\n   the command line\n15. After a second or two the 'IF' data field will start to blink\n   and the message: 'No data located' will be displayed\n\nAssuming that all of these tests met with the expected results it\nis probable that QWIKSCAN is working okay.\n\nQWIKSCAN Modes of Operation\n\nQWIKSCAN operates in two modes, normal locate and super locate.\nThe difference between the two modes is that normal locate uses\ninternal delimiting logic whilst super locate uses ISPF\nstatistics to enhance the performance of the program.\n\nIn order to use super locate the user is expected to know more\nthan just what data string is to be located.\n\nNormal Locate\nNormal locate isn't an inefficient method of scanning a PDS. It\ndoes imply though that a 'full scan' is performed. There are 6\nfields used in normal locate, these are as follows:\n\nTARGET PDS NAME\nThe name of the PDS that is to be scanned. Maximum of 42\ncharacters. No quotes\n\nIF DATA STRING\nUp to 78 bytes of character data (upper case) that defines the\nprimary search argument. The program will halt processing the\ncurrent PDS member when it finds the first occurrence of this\nstring. Generally the longer the string the more efficient the\nprogram will be. Imbedded and multiple blanks are allowed. There\nare no requirements for the string to be suffixed or prefixed\nwith special characters within the target PDS\n\nAND DATA STRING\nSame rules as 'IF'. If used the program will check that the 'AND'\ndata does not exist on the same record as the 'IF' data and not a\nmember level\n\nNOT DATA STRING\nSame rules as 'IF'. If used the program will check that the 'NOT'\ndata does not exist on the same record as the 'IF' and/or 'AND'\ndata\n\nMAX MEMBERS\n4 byte numeric field that tells the program to stop processing\nthe PDS after n members have been scanned\n\nMAX RECORDS\n4 byte numeric filed that tells the program to stop processing\nthe current member after n records have been processed\n\n Super Locate\nSuper locate is used in conjunction with normal locate to enhance\nthe programs ability to scan a PDS. The implication of using\nsuper locate is that not all members will be selected for\nscanning. The reason for this is that user super locate values\nare masked against ISPF PDS member statistics. If the mask fails\nthen the member will not be selected for further processing, i.e.\nit will not be opened and read.\n\nIn addition to providing the equal-to mask values it is possible\nto code two not-equal-to mask values for the created and updated\nfields. This option should be used when ISPF statistics do not\nexist for some members and those are the members that you are\ninterested in.\n\nFor instance, assume that you are interested in PDS members that\nhave been created by an application as opposed to a user, no\nstatistics will exist for them. To tell QWIKSCAN that these are\nthe members to scan, simply code: '**/**/**', in either (or both)\nthe two date fields, you may also code part of this string as it\nis a mask that will be applied to the actual data.\n\nOne important point to understand when using super locate mask\nmatching is that because you are applying a mask it is not\nnecessary to conform to any syntactical standards. Another point\nto note is that QWIKSCAN will rearrange the dates into the\nEuropean standard of dd/mm/yy, so any date masking should reflect\nthis. For instance should you only be interested in looking at\nmembers updated in July 1999, you would code '/07/99' in the\nupdated field. You could also code '/07/' but this wouldn't\nguarantee that you only got 1999 data.\n\nMask Matching Fields\n\nUSER\nAny fully qualified user name, partially qualified to the left,\nright or middle allowed. For instance if the target was Userid\nUSER1 the following would pick it up:\n\n* USER\n* US\n* USER1\n\nIf you are searching your own PDS, always use this field\n\nCREATE\n\nThe date the member was created in the format dd/mm/yy. If\nstatistics do not exist for a member the value **/**/** will be\ninserted by QWIKSCAN. For example, to pick up members created in\nJuly 1999 any of the following will work:\n\n* **/\n* /**/\n* *\n* */**/*\n\nUPDATE\n\nAs for CREATE but probably the better field to use\n\nMEMBER\n\nThe member name mask, its efficiency is enhanced by the proper\nnaming standards\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QWIKSCAN": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x01\\x01\\x01'\\x1f\\x01\\x022_\\x07\\x16\\x01\\xa9\\x01\\xa9\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-09-28T00:00:00", "modifydate": "2002-11-21T07:16:01", "lines": 425, "newlines": 425, "modlines": 0, "user": "OPSUPP"}, "text": "         PRINT ON\n* SORRY...NO WARRANTY BUT QUESTIONS OR INQUIRIES CAN BE\n* DIRECTED TO: SEBASTIAN\u00a7WELTON.DE\n*              WWW.WELTON.DE\nQWIKSCAN CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12)                            STANDARD H/K\n         LR    R12,R15                            STANDARD H/K\n         LA    R8,4095\n         AR    R8,R12\n         LA    R8,1(R8)\n         USING QWIKSCAN,R12,R8                    STANDARD H/K\n         ST    13,SAVE+4                          STANDARD H/K\n         LA    R11,SAVE                           STANDARD H/K\n         ST    R11,8(R13)                         STANDARD H/K\n         LR    R13,R11                            STANDARD H/K\n         EJECT\n* ------------------------------ *\n* INSTRUCTIONS AFTER THIS POINT  *\n* ------------------------------ *\n*\n*\nMAIN0000 EQU   *\n         BAL   R9,SUB00000                        ISPF/PROG DEFINES\n*\nMAIN0100 EQU   *                                  DISPLAY PANEL #1\n         BAL   R9,SUB01000\n*\n         B     END#\n*\nSUB00000 EQU   *\n         CALL  ISPLINK,(VDEFINE,I_PV1,P_PV1,CHAR,L44),VL\n         CALL  ISPLINK,(VDEFINE,I_PV2,P_PV2,CHAR,L78),VL\n         CALL  ISPLINK,(VDEFINE,I_PV3,P_PV3,CHAR,L78),VL\n         CALL  ISPLINK,(VDEFINE,I_PV4,P_PV4,CHAR,L78),VL\n         CALL  ISPLINK,(VDEFINE,I_PV5,P_PV5,CHAR,L04),VL\n         CALL  ISPLINK,(VDEFINE,I_PV6,P_PV6,CHAR,L04),VL\n         CALL  ISPLINK,(VDEFINE,I_PV7,P_PV7,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_PV8,P_PV8,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_PV9,P_PV9,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_PV10,P_PV10,CHAR,L05),VL\n         CALL  ISPLINK,(VDEFINE,I_PV11,P_PV11,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_ZLCD,P_ZLCD,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_ZLCM,P_ZLCM,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_ZLCU,P_ZLCU,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_ZLCN,P_ZLCN,CHAR,L05),VL\n         CALL  ISPLINK,(VDEFINE,I_ACC,P_ACC,CHAR,L05),VL\n         CALL  ISPLINK,(VDEFINE,I_MTH,P_MTH,CHAR,L03),VL\n         CALL  ISPLINK,(VDEFINE,I_DATA,P_DATA,CHAR,L256),VL\n         CALL  ISPLINK,(VDEFINE,I_LEN,P_LEN,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_MSG,P_MSG,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_MEM,P_MEM,CHAR,L08),VL\n         CALL  ISPLINK,(VDEFINE,I_DATAID,P_DATAID,CHAR,L08),VL\n         CALL  ISPLINK,(VGET,VGETLST),VL\n         CALL  ISPLINK,(CONTROL,ERRORS,RET),VL\n         BR    R9\n*\nSUB01000 EQU   *\n         CLI   TIND,C'Y'\n         BE    SUB01065\n         MVC   PANEL(08),=CL8'QWIKSCN1'\n         CALL  ISPLINK,(DISPLAY,PANEL),VL\n         LTR   R15,R15\n         BZ    SUB01005\n         BR    R9\nSUB01005 EQU   *\n         MVI   QWKF_O,C'F'\n         PACK  XACC(03),P_PV5(04)\n         PACK  PMAX(03),P_PV6(04)\n         ZAP   SACC(03),=P'0'\n         ZAP   PACC(02),=P'0'\n         ZAP   TACC(03),=P'0'\n         MVI   TIND,C'N'\n         CALL  ISPLINK,(TBEND,QWIKTBL),VL\n         CALL  ISPLINK,(TBCREATE,QWIKTBL,QWIKTBLK,QWIKTBLN,NOWRITE),VL\n         CALL  ISPLINK,(LMINIT,DATAID,PROJ,GR1,GR2,GR3,GR4,TP,P_PV1),VL\n         LTR   R15,R15\n         BZ    SUB01010\n         MVC   MSGID(08),=CL8'QWIKS006'\n         MVC   P_MSG(08),=CL8'QWIKS006'\n         CALL  ISPLINK,(SETMSG,MSGID),VL\n         B     SUB01000\nSUB01010 EQU   *\n         CALL  ISPLINK,(LMOPEN,P_DATAID),VL\n         LTR   R15,R15\n         BZ    SUB01015\n         MVC   MSGID(08),=CL8'QWIKS007'\n         MVC   P_MSG(08),=CL8'QWIKS007'\n         CALL  ISPLINK,(SETMSG,MSGID),VL\n         B     SUB01000\nSUB01015 EQU   *\n         MVC   P_MEM(08),=CL8' '\n         CALL  ISPLINK,(LMMLIST,P_DATAID,FREE),VL\nSUB01020 EQU   *\n         BAL   R10,SUB01025\n         CALL  ISPLINK,(LMMLIST,P_DATAID,FREE),VL\n         CALL  ISPLINK,(LMCLOSE,P_DATAID),VL\n         CALL  ISPLINK,(LMFREE,P_DATAID),VL\n         B     SUB01000\nSUB01025 EQU   *\n         CALL  ISPLINK,(LMMLIST,P_DATAID,LIST,MEM,STATS),VL\n         LTR   R15,R15\n         BZ    SUB01030\n         C     R15,=F'12'\n         BE    SUB01027\n         CLI   TIND,C'Y'\n         BNE   SUB01026\n         BR    R10\nSUB01026 EQU   *\n         MVC   MSGID(08),=CL8'QWIKS012'\n         MVC   P_MSG(08),=CL8'QWIKS012'\n         CALL  ISPLINK,(SETMSG,MSGID),VL\n         BR    R10\nSUB01027 EQU   *\n         MVC   MSGID(08),=CL8'QWIKS016'\n         CALL  ISPLINK,(SETMSG,MSGID),VL\n         BR    R10\nSUB01030 EQU   *\n         ZAP   TMAX(03),=P'0'\n         AP    SACC(03),=P'1'\n         CP    SACC(03),=P'50'\n         BL    SUB01031\n         AP    TACC(03),SACC(03)\n         UNPK  P_ACC(05),TACC(03)\n         OI    P_ACC+04,X'F0'\n         UNPK  P_MTH(03),PACC(02)\n         OI    P_MTH+02,X'F0'\n         MVC   MSGID(08),=CL8'QWIKS013'\n         MVC   P_MSG(08),=CL8'QWIKS013'\n         CALL  ISPLINK,(SETMSG,MSGID),VL\n         CALL  ISPLINK,(CONTROL,DISPLAY,LOCK),VL\n         CALL  ISPLINK,(DISPLAY,PANEL),VL\n         ZAP   SACC(03),=P'0'\nSUB01031 EQU   *\n         ZAP   ZACC(03),=P'0'\n         AP    ZACC(03),TACC(03)\n         AP    ZACC(03),SACC(03)\n         CP    ZACC(03),XACC(03)\n         BL    SUB01032\n         AP    TACC(03),SACC(03)\n         UNPK  P_ACC(05),TACC(03)\n         OI    P_ACC+04,X'F0'\n         UNPK  P_MTH(03),PACC(02)\n         OI    P_MTH+02,X'F0'\n         MVC   MSGID(08),=CL8'QWIKS015'\n         MVC   P_MSG(08),=CL8'QWIKS015'\n         CALL  ISPLINK,(SETMSG,MSGID),VL\n         BR    R10\nSUB01032 EQU   *\n         MVC   DATEP+00(02),P_ZLCD+06\n         MVC   DATEP+03(02),P_ZLCD+03\n         MVC   DATEP+06(02),P_ZLCD+00\n         CLC   DATEP(02),=C'  '\n         BNE   SUB01033\n         MVC   DATEP(08),=C'**/**/**'\nSUB01033 EQU   *\n         MVC   P_ZLCD(08),DATEP\n         MVC   DATEP+00(02),P_ZLCM+06\n         MVC   DATEP+03(02),P_ZLCM+03\n         MVC   DATEP+06(02),P_ZLCM+00\n         CLC   DATEP(02),=C'  '\n         BNE   SUB01034\n         MVC   DATEP(08),=C'**/**/**'\nSUB01034 EQU   *\n         MVC   P_ZLCM(08),DATEP\nSUB01035 EQU   *\n         CLI   P_PV7,C' '\n         BE    SUB01040\n         MVC   QWKX_T(08),P_ZLCU\n         MVC   QWKX_M(08),P_PV7\n         CALL  QWKX,(QWKX_P),VL\n         LTR   R15,R15\n         BNZ   SUB01025\nSUB01040 EQU   *\n         CLI   P_PV8,C' '\n         BE    SUB01045\n         MVC   QWKX_T(08),P_ZLCD\n         MVC   QWKX_M(08),P_PV8\n         CALL  QWKX,(QWKX_P),VL\n         LTR   R15,R15\n         BNZ   SUB01025\nSUB01045 EQU   *\n         CLI   P_PV9,C' '\n         BE    SUB01050\n         MVC   QWKX_T(08),P_ZLCM\n         MVC   QWKX_M(08),P_PV9\n         CALL  QWKX,(QWKX_P),VL\n         LTR   R15,R15\n         BNZ   SUB01025\nSUB01050 EQU   *\n         CLI   P_PV11,C' '\n         BE    SUB01055\n         MVC   QWKX_T(08),P_MEM\n         MVC   QWKX_M(08),P_PV11\n         CALL  QWKX,(QWKX_P),VL\n         LTR   R15,R15\n         BNZ   SUB01025\nSUB01055 EQU   *\n         CALL  ISPLINK,(LMMFIND,P_DATAID,P_MEM),VL\nSUB01060 EQU   *\n         CALL  ISPLINK,(LMGET,P_DATAID,INVAR,DATALOC,LENVAR,L256),VL\n         LTR   R15,R15\n         BNZ   SUB01025\n         AP    TMAX(03),=P'1'\n         CP    TMAX(03),PMAX(03)\n         BH    SUB01025\n         MVC   QWKF_T(256),P_DATA\n         MVC   QWKF_I(078),P_PV2\n         MVC   QWKF_A(078),P_PV3\n         MVC   QWKF_N(078),P_PV4\n         MVC   QWKF_L(008),P_LEN\n         CALL  QWKF,(QWKF_O),VL\n         LTR   R15,R15\n         BNZ   SUB01060\n         MVI   TIND,C'Y'\n         CALL  ISPLINK,(TBADD,QWIKTBL),VL\n         AP    PACC(02),=P'1'\n         B     SUB01025\nSUB01065 EQU   *\n         MVI   TIND,C'N'\n         AP    TACC(03),SACC(03)\n         UNPK  P_ACC(05),TACC(03)\n         OI    P_ACC+04,X'F0'\n         UNPK  P_MTH(03),PACC(02)\n         OI    P_MTH+02,X'F0'\n         MVC   MSGID(08),=CL8'QWIKS015'\n         MVC   P_MSG(08),=CL8'QWIKS015'\n         CALL  ISPLINK,(SETMSG,MSGID),VL\n         CALL  ISPLINK,(TBTOP,QWIKTBL),VL\nSUB01070 EQU   *\n         MVC   P_MEM(10),=CL10' '\n         MVC   PANEL(08),=CL8'QWIKSCN2'\n         CALL  ISPLINK,(TBDISPL,QWIKTBL,PANEL),VL\n         ST    R15,TBRC\n         C     R15,=F'8'\n         BE    SUB01000\n         LH    R3,=H'43'\nSUB01075 EQU   *\n         LA    R2,P_PV1\n         AR    R2,R3\n         CLI   0(R2),X'7D'\n         BE    SUB01080\n         BCT   R3,SUB01075\n         ABEND 99,REASON=4\nSUB01080 EQU   *\n         SH    R3,=H'1'\n         MVC   DSN(56),=CL56' '\n         LA    R2,DSN\n         EX    R3,DATAMVC\n         AH    R3,=H'1'\n         AR    R2,R3\n         MVI   0(R2),C'('\n         LH    R4,=H'7'\nSUB01085 EQU   *\n         LA    R5,P_MEM\n         AR    R5,R4\n         CLI   0(R5),C' '\n         BNE   SUB01090\n         BCT   R4,SUB01085\n         ABEND 99,REASON=8\nSUB01090 EQU   *\n         MVC   1(2,R5),=X'5D7D'\n         MVC   1(10,R2),P_MEM\n         MVC   PANEL(08),=CL8'QWIKSCN3'\n         CALL  ISPLINK,(CONTROL,DISPLAY,SVE),VL\n         CALL  ISPLINK,(BROWSE,DSN,VOL,PWD,PANEL),VL\n         CALL  ISPLINK,(CONTROL,DISPLAY,RST),VL\n         L     R15,TBRC\n         C     R15,=F'0'\n         BE    SUB01070\n         MVC   P_MEM(10),=CL10' '\n         CALL  ISPLINK,(TBDISPL,QWIKTBL),VL\n         ST    R15,TBRC\n         B     SUB01075\n*\nEND#     L     R13,SAVE+4                         RESTORE CALLERS AREA\n         RETURN (14,12),RC=(15)                   AND RETURN TO CALLER\n         LTORG\nSAVE     DS    9D                                 CALLERS AREA\nTBRC     DS    F                                  CALLERS AREA\nL44      DC    F'44'\nL78      DC    F'78'\nL05      DC    F'5'\nL04      DC    F'4'\nL03      DC    F'3'\nL08      DC    F'8'\nL256     DC    F'256'\n*\nDATAMVC  MVC   0(0,R2),P_PV1\nDSN      DS    CL56\n         DS    0H\nLMGET    DC    CL8'LMGET'\nLMMFIND  DC    CL8'LMMFIND'\nBROWSE   DC    CL8'BROWSE'\nCONTROL  DC    CL8'CONTROL'\nERRORS   DC    CL8'ERRORS'\nRET      DC    CL8'RETURN'\nLOCK     DC    CL8'LOCK'\nVOL      DC    CL8' '\nPWD      DC    CL8' '\nRST      DC    CL8'RESTORE'\nSVE      DC    CL8'SAVE'\nINVAR    DC    CL8'INVAR'\nDATALOC  DC    CL8'DATA'\nLENVAR   DC    CL8'LEN'\nDISPLAY  DC    CL8'DISPLAY'\nPANEL    DS    CL8\nVDEFINE  DC    CL8'VDEFINE'\nTBEND    DC    CL8'TBEND'\nTBCREATE DC    CL8'TBCREATE'\nSETMSG   DC    CL8'SETMSG'\nMSGID    DC    CL8'QWIKS008'\nNOWRITE  DC    CL8'NOWRITE'\nTBDISPL  DC    CL8'TBDISPL'\nTBTOP    DC    CL8'TBTOP'\nLMINIT   DC    CL8'LMINIT'\nLMMLIST  DC    CL8'LMMLIST'\nTBADD    DC    CL8'TBADD'\nFREE     DC    CL8'FREE'\nLIST     DC    CL8'LIST'\nMEM      DC    CL8'MEM'\nSTATS    DC    CL8'YES'\nLMOPEN   DC    CL8'LMOPEN'\nINPUT    DC    CL8'INPUT'\nLMCLOSE  DC    CL8'LMCLOSE'\nLMFREE   DC    CL8'LMFREE'\nVGET     DC    CL8'VGET'\nVGETLST  DC    CL42'(SV1 SV2 SV3 SV4 SV5 SV6 SV7 SV8 SV9 SV11)'\nQWIKTBL  DC    CL8'QWIKTBL'\nQWIKTBLK DC    CL3'( )'\nQWIKTBLN DC    CL36'(MEM ZLUSER ZLCDATE ZLCNORC ZLMDATE)'\nDATAID   DC    CL8'XYZ'\nI_DATAID DC    CL5'(XYZ)'\nP_DATAID DC    CL8' '\nPROJ     DC    CL8' '\nGR1      DC    CL8' '\nGR2      DC    CL8' '\nGR3      DC    CL8' '\nGR4      DC    CL8' '\nTP       DC    CL8' '\nTIND     DS    CL1\nQWKX_P   DS    0CL16\nQWKX_T   DS    CL8\nQWKX_M   DS    CL8\nI_PV1    DC    CL5'(PV1)'\nI_PV2    DC    CL5'(PV2)'\nI_PV3    DC    CL5'(PV3)'\nI_PV4    DC    CL5'(PV4)'\nI_PV5    DC    CL5'(PV5)'\nI_PV6    DC    CL5'(PV6)'\nI_PV7    DC    CL5'(PV7)'\nI_PV8    DC    CL5'(PV8)'\nI_PV9    DC    CL5'(PV9)'\nI_PV10   DC    CL6'(PV10)'\nI_PV11   DC    CL6'(PV11)'\nI_MEM    DC    CL5'(MEM)'\nI_MTH    DC    CL5'(MTH)'\nI_ACC    DC    CL5'(ACC)'\nI_ZLCD   DC    CL9'(ZLCDATE)'\nI_ZLCM   DC    CL9'(ZLMDATE)'\nI_ZLCN   DC    CL9'(ZLCNORC)'\nI_ZLCU   DC    CL8'(ZLUSER)'\nI_DATA   DC    CL6'(DATA)'\nI_LEN    DC    CL5'(LEN)'\nI_MSG    DC    CL5'(MSG)'\nDATEP    DS    0CL8\n         DS    CL2\n         DC    CL1'/'\n         DS    CL2\n         DC    CL1'/'\n         DS    CL2\nP_PV1    DC    CL44' '\nP_PV2    DC    CL78' '\nP_PV3    DC    CL78' '\nP_PV4    DC    CL78' '\nP_PV5    DC    CL04' '\nP_PV6    DC    CL04' '\nP_PV7    DC    CL08' '\nP_PV8    DC    CL08' '\nP_PV9    DC    CL08' '\nP_PV10   DC    CL05' '\nP_PV11   DC    CL08' '\nP_MEM    DC    CL10' '\nP_MTH    DS    CL3' '\nP_ACC    DS    CL5\nSACC     DS    CL3\nTACC     DS    CL3\nPMAX     DS    CL3\nTMAX     DS    CL3\nXACC     DS    CL3\nZACC     DS    CL3\nPACC     DS    CL2\nP_ZLCD   DC    CL08' '\nP_ZLCM   DC    CL08' '\nP_ZLCU   DC    CL08' '\nP_ZLCN   DC    CL05' '\nP_DATA   DC    CL256' '\nP_LEN    DC    CL08' '\nP_MSG    DC    CL08'QWIKS008'\nCHAR     DC    CL8'CHAR'\nQWKF_P   DS    0CL499\nQWKF_O   DS    CL1\nQWKF_T   DS    CL256\nQWKF_I   DS    CL78\nQWKF_A   DS    CL78\nQWKF_N   DS    CL78\nQWKF_L   DS    CL8\nNUMCHK   DS    CL5\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QWIKSCN1": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x12\\x006\\x01\\x01'\\x1f\\x01\\x022_\\x07\\x19\\x00`\\x00\\\\\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@\"", "ispf": {"version": "01.18", "flags": 0, "createdate": "2001-09-28T00:00:00", "modifydate": "2002-11-21T07:19:36", "lines": 96, "newlines": 92, "modlines": 0, "user": "OPSUPP"}, "text": ")attr\n+ type(text) intens(low) color(turq) skip(on)\n% type(text) intens(high) color(white) skip(on)\n_ type(input) intens(high) color(red) caps(on)\n\u00f8 type(text) intens(low) color(yellow) skip(on) hilite(reverse)\n$ type(text) intens(high) color(blue) skip(on) hilite(reverse)\n| type(output) intens(high) color(yellow) skip(on)\n\u00ac type(text) intens(high) color(red) skip(on)\n\u00e4 type(output) intens(high) color(red) just(right)\n\u00fc type(output) intens(high) color(pink)\n)body expand(##) lmsg(lmsg) smsg(smsg)\n+# #\u00f8 QWIKSCAN +# #\n+# #\u00f8 Maximised PDS Scanning +# #\n+\n%COMMAND ==>_zcmd     +\n+\n\u00fcz                                                         \u00e4z\n+\n%QWIKSCAN+will search any partitioned dataset for a number of%logical+conditions\n+these are%if+logic,%and+logic, and%not+logic. In addition to this you may\n+supply ISPF stats values that tell%QWIKSCAN+you are%only+interested in certain\n+members. Assuming the scan is successful you will be taken into another panel\n+which will allow you to%browse+any or all displayed members. Whilst the scan is\n+taking place your screen will be locked but will be updated by%QWIKSCAN+to show\n+you how the scan is going. Press%PF3+to terminate%QWIKSCAN.+\n+\n+\n\u00ac<1>+Enter the PDS name        :_z\n+\n\u00ac<2>+Scan%if +string           :_z\n\u00ac<3>+Scan%and+string           :_z\n\u00ac<4>+Scan%not+string           :_z\n+\n\u00ac<5>+Max member count          :_z   +\n+\n\u00ac<6>+Max record count          :_z   +\n+\n+\n%Statistics Masking+will speed up processing%and+no data%is+QWIKSCAN validated.\n+\n+      User:_z       +Created:_z       +Updated:_z       +Member:_z       +\n)init\n.zvars = '(lmsg smsg sv1 sv2 sv3 sv4 sv5 sv6 sv7 +\n           sv8 sv9 sv11)'\nif (&msg = QWIKS008)  .attr(smsg) = 'color(green)'\nif (&msg = QWIKS012)  .attr(smsg) = 'hilite(blink)'\n                      .attr(sv2)  = 'hilite(blink) color(pink)'\n                      .cursor = sv2\nif (&msg = QWIKS006)  .attr(sv1)  = 'hilite(blink) color(pink)'\n                      .cursor = sv1\nif (&msg = QWIKS007)  .attr(sv1)  = 'hilite(blink) color(pink)'\n                      .cursor = sv1\n&zcmd  = &z\n)reinit\nif (.msg = QWIKS000)  .attr(sv1) = 'color(pink) hilite(blink)'\nif (.msg = QWIKS001)  .attr(sv2) = 'color(pink) hilite(blink)'\nif (.msg = QWIKS003)\n    .attr(sv5) = 'color(pink) pad(-) just(right)'\nif (.msg = QWIKS004)\n    .attr(sv6) = 'color(pink) pad(-) just(right)'\nif (.msg = QWIKS009)  .attr(sv8) = 'color(pink) hilite(blink)'\nif (.msg = QWIKS010)  .attr(sv9) = 'color(pink) hilite(blink)'\nif (.msg = QWIKS011)  .attr(sv10)= 'color(pink) pad(-) just(right)'\nif (.msg = QWIKS008)  .attr(smsg) = 'color(green)'\nif (.msg = QWIKS014)  .attr(sv11) = 'color(pink) pad(-) just(right)'\n&zcmd  = &z\nrefresh(*)\n)proc\nif (&msg \u00ac= QWIKS013)\n   ver (&sv1,nb,dsname,msg=qwiks000)\n   ver (&sv2,nb,msg=qwiks001)\n   if  (&sv5 \u00ac= &z)\n       ver (&sv5,pict,9999,msg=qwiks003)\n   if  (&sv6 \u00ac= &z)\n       ver (&sv6,pict,9999,msg=qwiks004)\n   if  (.msg = &Z) ver (&zcmd,nb,list,GO,msg=qwiks002)\n   if  (.msg = &Z) vput (sv1 sv2 sv3 sv4 sv5 sv6 sv7 sv8 sv9 sv11)      profile\n                   &pv1  = '''&sv1'''\n                   &pv2  = '&sv2<'\n                   &pv7  = &sv7\n                   &pv8  = &sv8\n                   &pv9  = &sv9\n                   &pv11  = &sv11\n                   if (&sv3 \u00ac= &z) &pv3 = '&sv3<'\n                   if (&sv3  = &z) &pv3 = &z\n                   if (&sv4 \u00ac= &z) &pv4 = '&sv4<'\n                   if (&sv4  = &z) &pv4 = &z\n                   if (&sv5 \u00ac= &z) &pv5 = '&sv5'\n                   if (&sv5  = &z) &pv5 = '9999'\n                   if (&sv6 \u00ac= &z) &pv6 = '&sv6'\n                   if (&sv6  = &z) &pv6 = '9999'\n                   if (&pv10 = &z) &pv10= '99999'\n)end\n/* SORRY...NO WARRANTY BUT QUESTIONS OR INQUIRIES CAN BE\n/* DIRECTED TO: SEBASTIAN\u00a7WELTON.DE\n/*              WWW.WELTON.DE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QWIKSCN2": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00E\\x01\\x01\\'\\x1f\\x01\\x022_\\x07\\x19\\x00%\\x00\"\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-09-28T00:00:00", "modifydate": "2002-11-21T07:19:45", "lines": 37, "newlines": 34, "modlines": 0, "user": "OPSUPP"}, "text": ")attr\n # type(text) color(yellow) skip(on)\n % type(text) color(turq) skip(on)\n $ type(text) color(red) skip(on)\n ~ type(text) color(yellow) hilite(reverse) skip(on)\n @ type(output) color(pink) caps(off) skip(on)\n [ type(output) color(pink) caps(off) skip(on)\n ] type(output) color(pink) caps(off) skip(on)\n _ type(input) color(yellow) pad(' ')\n \u00a7 type(input) color(yellow) pad('_')\n)body width(&zscreenw) expand(//) lmsg(lmsg) smsg(smsg)\n%/ /~ QWIKSCAN - Maximised PDS Scanning +/ /\n]lmsg\n# Command ==> _zcmd\n[smsg\n#   %Press$PF3%to exit or$PF7%and$PF8%to scroll up or down.\n#\n#/-/\n$S%  Member    Last            Last           Size        Created\n    %Found     User           Update\n#/-/\n)model  clear(mem zluser zlmdate zlcnorc zlcdate) rows(all)\n\u00a7Z+@mem     + @zluser    +  @zlmdate   +  @zlcnorc   +   @zlcdate   +\n)init\n &select = ' '\n .zvars = '(select)'\n vget(mem zluser zlmdate zlcnorc zlcdate) shared\n  &ztdmark = '          ----------> End Of PDS Member List <----------'\n  .cursor = zcmd\n)reinit\n &select = ' '\n refresh(*)\n)proc\n)end\n/* SORRY...NO WARRANTY BUT QUESTIONS OR INQUIRIES CAN BE\n/* DIRECTED TO: SEBASTIAN\u00a7WELTON.DE\n/*              WWW.WELTON.DE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QWIKSCN3": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\"\\x01\\x01\\'\\x1f\\x01\\x022_\\x07\\x19\\x000\\x00\\x00\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2001-09-28T00:00:00", "modifydate": "2002-11-21T07:19:22", "lines": 48, "newlines": 0, "modlines": 0, "user": "OPSUPP"}, "text": ")attr\n_ type(input) caps(off) intens(high) format(&mixed)\n] area(dynamic) extend(on) scroll(on)\n+ type(text) intens(low)\n| type(output) intens(high) pad(-)\n$ type(text) intens(high) color(yellow)\n01 type(dataout) intens(low)\n02 type(dataout) intens(high)\n0b type(dataout) intens(high) format(dbcs)\n0c type(dataout) intens(high) format(ebcdic)\n0d type(dataout) intens(high) format(&mixed)\n10 type(dataout) intens(low) format(dbcs)\n11 type(dataout) intens(low) format(ebcdic)\n12 type(dataout) intens(low) format(&mixed)\n)body width(&zwidth) expand(//)\n$QWIKSCAN%- &ztitle ---------------------------/-/---%line|zlines  %col|zcolums+\n%command ===>_zcmd                             / /            %scroll ===>_z   +\n]zdata ---------------------------------/ /------------------------------------]\n]                                       / /                                    ]\n] --------------------------------------/-/------------------------------------]\n)init\n  .help = isr10000         /* default tutorial name     */\n  .zvars = 'zscbr'         /* scroll amt variable name  */\n  &zcmd = 'F ''&sv2'''\n  if (&zmemb \u00ac= ' ')\n    &ztitle = '&zdsnt(&zmemb)&zlevel '       /* oz91708 */\n  if (&zmemb = ' ')\n    &ztitle = '&zdsn&zlevel '\n  &mixed = mix\n  if (&zpdmix = n)         /* ebcdic mode requested     */\n    &mixed = ebcdic\n\n)reinit\n  refresh(zcmd,zscbr,zdata,zlines,zcolums)\n  .attrchar(+) = 'intens(&zinten)'\n\n)proc\n  &zcursor = .cursor\n  &zcsroff = .csrpos\n  &zlvline = lvline(zdata)\n\n)end\n\n/*  dynamic area screen width from pquery. (80,132,160)\n/*  dynamic area screen depth from pquery. (24,32,43,27,60)\n/* SORRY...NO WARRANTY BUT QUESTIONS OR INQUIRIES CAN BE\n/* DIRECTED TO: SEBASTIAN\u00a7WELTON.DE\n/*              WWW.WELTON.DE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QWIKS00": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x009\\x01\\x01)\\x9f\\x01\\x022_\\x07 \\x00\\x14\\x00\\x14\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-10-26T00:00:00", "modifydate": "2002-11-21T07:20:39", "lines": 20, "newlines": 20, "modlines": 0, "user": "OPSUPP"}, "text": "QWIKS000 'ENTER PDS NAME     ' .ALARM=YES\n'A VALID PARTITIONED DATASET NAME MUST BE ENTERED TO WORK'\nQWIKS001 'SEARCH FOR WHAT ?  ' .ALARM=YES\n'ENTER A STRING OF SEARCH CHARACTERS HERE'\nQWIKS002 'ENTER GO TO START  ' .ALARM=YES\n'ENTERING GO WILL START QWIKSCAN'\nQWIKS003 'PRESS HELP'          .ALARM=YES\n'THE MAXIMUM MEMBER COUNT MUST BE 4 BYTES, NUMERIC'\nQWIKS004 'PRESS HELP'          .ALARM=YES\n'THE MAXIMUM RECORD COUNT MUST BE 4 BYTES, NUMERIC'\nQWIKS005 'QWIKSCAN TERMINATED'\n'QWIKSCAN HAS BEEN TERMINATED ON USER REQUEST'\nQWIKS006 'PDS ALLOCATION FAILED' .ALARM=YES\n'QWIKSCAN WAS UNABLE TO ALLOCATE &PV1'\nQWIKS007 'PDS OPEN FAILURE'      .ALARM=YES\n'QWIKSCAN WAS UNABLE TO OPEN &PV1'\nQWIKS008 'QWIKSCAN INITIALISED'\n'QWIKSCAN IS NOW READY FOR WORK'\nQWIKS009 'DATE INVALID' .ALARM=YES\n'THE CREATION DATE MUST BE IN DD/MM/YY FORMAT'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QWIKS01": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x01\\x022_\\x01\\x022_\\x07!\\x00\\x10\\x00\\x10\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-21T00:00:00", "modifydate": "2002-11-21T07:21:04", "lines": 16, "newlines": 16, "modlines": 0, "user": "OPSUPP"}, "text": "QWIKS010 'DATE INVALID' .ALARM=YES\n'THE LAST-UPDATED DATE MUST BE IN DD/MM/YY FORMAT'\nQWIKS011 'INVALID AMOUNT' .ALARM=YES\n'MEMBER RECORD COUNT MUST BE IN RANGE 00001-65535'\nQWIKS012 'NO DATA LOCATED'  .ALARM=YES\n'QWIKSCAN FOUND NO DATA USING USER-LOGIC'\nQWIKS013\n'SCANNED &ACC MEMBERS, MATCHED &MTH  PLEASE WAIT'\nQWIKS014 'APPL CODE INVALID'  .ALARM=YES\n'IF PRESENT, THE APPL CODE MUST BE 2 CHARACTERS LONG'\nQWIKS015\n'SCANNED &ACC MEMBERS, MATCHED &MTH'\nQWIKS016 'DATASET NOT A PDS' .ALARM=YES\n'DATASET &PV1 IS NOT A PDS'\nQWIKS017 'QWIKSCAN EXPIRED'  .ALARM=YES\n'QWIKSCAN DOES NOT CURRENTLY HAVE A VALID LICENSE'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QWIKTXT": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x022_\\x01\\x022_\\x07\\x18\\x00\\xe3\\x00\\xe3\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-21T00:00:00", "modifydate": "2002-11-21T07:18:16", "lines": 227, "newlines": 227, "modlines": 0, "user": "OPSUPP"}, "text": "\n                           QWIKSCAN\n                    Maximised PDS Scanning\n\n\nContents\nContents                                                     2\nInstalling QUIKSCAN                                          4\nStructured Testing of QUIKSCAN                               5\n Testing                                                    5\nQUIKSCAN Modes of Operation                                  6\n Normal Locate                                              6\n Super Locate                                               6\n   Mask Matching Fields                                     7\n   Introduction\nQWIKSCAN is written in S/370 Assembler H and executes within an\nISPF environment. QWIKSCAN requires ISPF Release 2 Version 0 or\nabove  to  process, it also requires a terminal type of  3192-2\n(or similar) or above.\n\nBasically  QWIKSCAN  is  a  low  level,  high  performance  PDS\nscanning   utility  that  will  perform  character-by-character\ncomparisons  of PDS members for up to 234 bytes of  user  data.\nUser data is defined as:\n\n\u00fa   Up to 78 bytes of 'if' data\n\u00fa   Up to 78 bytes of 'and' data\n\u00fa   Up to 78 bytes of 'or' data\n\nIn  addition  to  this the user may enhance the performance  of\nQWIKSCAN  by  means  of  giving  it  delimiting  'stop   after'\ninstructions in either it's regular mode of operation  or  it's\nsuper-locate mode.\n\nWhilst QWIKSCAN is running the users terminal is updated  after\nthe first 50 and every subsequent 50 PDS members are processed.\nThe updated panel will tell the user how many members have been\nprocessed  so  far  and how many successful matches  have  been\nlocated.\n\nAssuming that at least one successful match has been  made,   a\ntemporary  ISPF  table is updated with the  member  name,  ISPF\nstatistics, etc. and when the search completes this table  will\nbe  presented  to  the user. They may then select  any  or  all\ndisplayed members (multiple row selects are honoured.)\n\nIf  a member is selected for processing, QWIKSCAN will initiate\nan  ISPF BROWSE session with the nominated member(s). Prior  to\ndisplaying  the  member, QWIKSCAN will pre-format  the  control\nline of the BROWSE panel with the command required to find  the\nuser  'if'  character string. So, all the user  has  to  do  to\nlocate  the data they are interested in, is to press ENTER  and\nuse the RFIND key to display further occurrences, if any.\n\nAs  a  rough guide to performance, QWIKSCAN requires about  0.9\nseconds,  elapsed  time, to search a PDS  member  fixed  at  80\nbytes,  containing approximately 80 lines of data for a 4  byte\nsearch  string  (and  not finding it.)  Having  said  this  the\nprocessing time is ultimately dependent upon machine type,  IPS\nsettings,  allocated  SU's, etc. It is possible,  as  explained\nlater, to instruct QWIKSCAN to operate far quicker than this.\n\n\nInstalling QWIKSCAN\nThe  following  PDS members should be obtained  and  copied  to\ntheir  respective datasets (in the case of load libraries,  the\nsource must first be assembled):\n\nName             Library\nQWIKSCN1         ISPF Panel Dataset\nQWIKSCN2         ISPF Panel Dataset\nQWIKSCN3         ISPF Panel Dataset\nQWIKS00          ISPF         Message\n                 Dataset\nQWIKS01          ISPF         Message\n                 Dataset\nQWIKSCAN         ISPF Load Dataset\nQWKF             ISPF Load Dataset\nQWKX             ISPF Load Dataset\nQWIK             SYSEXEC Dataset\nQWIKASM          JCL Dataset\n\nOnce  this has been done you are now ready to perform a  series\nof structured tests of QWIKSCAN.\n\n\nStructured Testing of QWIKSCAN\nNow  that  you  have  installed the various  modules  to  their\ncorrect  locations it is possible to determine if  QWIKSCAN  is\nfunctioning  properly.  Follow the series  of  tests  described\nbelow,  assuming that everything is working correctly  you  may\nnow  use  QWIKSCAN however you wish. For the purpose  of  these\ntest  you must know the name of the ISPF Message Library,  this\ncontains  2  QWIKSCAN members and will be  the  target  of  the\ntests.\n\nTesting\n1.   Exit and re-initialise ISPF. This will force the inclusion\n  of all new ISPF objects\n2.  From ISPF option 6 enter QWIKSCAN\n3.  The primary QWIKSCAN panel will be displayed\n4.  Enter the following values in the fields:\n  \u00fa   The PDS name which is your ISPF Message Library\n  \u00fa   ALARM which is the string to search for\n5.  Now press ENTER\n6.   The  dialog  will respond with the message:  Enter  GO  to\n  start\n7.  Enter GO in the command field\n8.   After  a  second  or  two,  the second  QWIKSCAN  will  be\n  displayed showing 4 table entries. The ISPF LMSG will display:\n  'Scanned 4 members, matched 4 members'\n9.  Enter an 'S' in each of the 'SEL' fields and press ENTER\n10.  QWIKSCAN  will initiate a browse for each of the  selected\n  members\n11.  The  command  'F ALARM' will be formatted in  the  command\n  line\n12. Press PF3 until you are back at the first QWIKSCAN screen\n13.  The  values  you  entered will still be displayed  on  the\n  panel\n14.  In the STATS mask field 'CREATED' enter '**/' and enter GO\n  on the command line\n15.  After  a second or two the 'IF' data field will  start  to\n  blink and the message: 'No data located' will be displayed\n\nAssuming that all of these tests met with the expected  results\nit is probable that QWIKSCAN is working okay.\n\nQWIKSCAN Modes of Operation\nQWIKSCAN operates in two modes, normal locate and super locate.\nThe difference between the two modes is that normal locate uses\ninternal  delimiting  logic  whilst  super  locate  uses   ISPF\nstatistics to enhance the performance of the program.\n\nIn  order to use super locate the user is expected to know more\nthan just what data string is to be located.\n\nNormal Locate\nNormal locate isn't an inefficient method of scanning a PDS. It\ndoes imply though that a 'full scan' is performed. There are  6\nfields used in normal locate, these are as follows:\n\nTARGET PDS NAME   The  name  of the PDS that is to be  scanned.\n                  Maximum of 42 characters. No quotes\nIF DATA STRING    Up  to  78  bytes  of character  data  (upper\n                  case)   that   defines  the  primary   search\n                  argument.  The  program will halt  processing\n                  the  current  PDS member when  it  finds  the\n                  first  occurrence  of this string.  Generally\n                  the  longer the string the more efficient the\n                  program   will  be.  Imbedded  and   multiple\n                  blanks    are   allowed.   There    are    no\n                  requirements  for the string to  be  suffixed\n                  or  prefixed  with special characters  within\n                  the target PDS\nAND DATA STRING   Same  rules as 'IF'. If used the program will\n                  check  that the 'AND' data does not exist  on\n                  the  same record as the 'IF' data and  not  a\n                  member level\nNOT DATA STRING   Same  rules as 'IF'. If used the program will\n                  check  that the 'NOT' data does not exist  on\n                  the  same  record  as the 'IF'  and/or  'AND'\n                  data\nMAX MEMBERS       4  byte  numeric field that tells the program\n                  to  stop  processing the PDS after n  members\n                  have been scanned\nMAX RECORDS       4  byte  numeric filed that tells the program\n                  to  stop processing the current member  after\n                  n records have been processed\n\n Super Locate\nSuper  locate  is  used in conjunction with  normal  locate  to\nenhance the programs ability to scan a PDS. The implication  of\nusing super locate is that not all members will be selected for\nscanning. The reason for this is that user super locate  values\nare  masked  against ISPF PDS member statistics.  If  the  mask\nfails  then  the  member  will  not  be  selected  for  further\nprocessing, i.e. it will not be opened and read.\n\nIn  addition  to  providing  the equal-to  mask  values  it  is\npossible  to code two not-equal-to mask values for the  created\nand  updated  fields.  This option should  be  used  when  ISPF\nstatistics  do  not exist for some members and  those  are  the\nmembers that you are interested in.\n\nFor  instance,  assume that you are interested in  PDS  members\nthat  have been created by an application as opposed to a user,\nno  statistics will exist for them. To tell QWIKSCAN that these\nare the members to scan, simply code: '**/**/**', in either (or\nboth)  the  two  date fields, you may also code  part  of  this\nstring as it is a mask that will be applied to the actual data.\n\nOne  important point to understand when using super locate mask\nmatching  is  that because you are applying a mask  it  is  not\nnecessary  to  conform  to any syntactical  standards.  Another\npoint  to  note is that QWIKSCAN will rearrange the dates  into\nthe  European standard of dd/mm/yy, so any date masking  should\nreflect  this.  For instance should you only be  interested  in\nlooking  at  members  updated in  July  1999,  you  would  code\n'/07/99'  in the updated field. You could also code '/07/'  but\nthis wouldn't guarantee that you only got 1999 data.\n\nMask Matching Fields\nUSER      Any  fully  qualified user name, partially  qualified\n          to  the  left, right or middle allowed. For  instance\n          if  the  target was Userid USER1 the following  would\n          pick it up:\n          \u00fa   USER\n          \u00fa   US\n          \u00fa   USER1\n          If  you  are searching your own PDS, always use  this\n          field\nCREATE    The  date  the  member  was  created  in  the  format\n          dd/mm/yy.  If  statistics do not exist for  a  member\n          the  value **/**/** will be inserted by QWIKSCAN. For\n          example, to pick up members created in July 1999  any\n          of the following will work:\n          \u00fa   **/\n          \u00fa   /**/\n          \u00fa   *\n          \u00fa   */**/*\nUPDATE    As for CREATE but probably the better field to use\nMEMBER    The  member name mask, its efficiency is enhanced  by\n          the proper naming standards\n\n* SORRY...NO WARRANTY BUT QUESTIONS OR INQUIRIES CAN BE\n* DIRECTED TO: SEBASTIAN\u00a7WELTON.DE\n*              WWW.WELTON.DE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QWKASM": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00H\\x01\\x02(\\x8f\\x01\\x022_\\x07(\\x00_\\x00\\x19\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-10-15T00:00:00", "modifydate": "2002-11-21T07:28:48", "lines": 95, "newlines": 25, "modlines": 0, "user": "OPSUPP"}, "text": "//* DONT FORGET A JOBCARD\n//*\n//********************************************************************\n//*\n//* All lines ending with @@@ must have changes made to them. Mainly\n//* they need the SYSIN dataset or LOAD library\n//*\n//********************************************************************\n//*\n//* --------------------------------------------------------- *\n//* ASSEMBLE AND COMPILE QWKF                                 *\n//* --------------------------------------------------------- *\n//QWKF   EXEC PGM=ASMA90,\n//   PARM='BATCH,OBJ,NODECK,XREF(FULL),LIST'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB)\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB,SYSUT1)\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(1700,(600,100))\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJ(M),UNIT=SYSDA,SPACE=(500,(200,200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DISP=SHR,DSN=source_dataset_for_QWKF(QWKF)        @@@\n//STEP2 EXEC PGM=IEWL,COND=(8,LT),\n//  REGION=512K,PARM='LIST,XREF,LET,MAP'\n//SYSUT1 DD DISP=(MOD,DELETE,DELETE),DSN=&&UT1,UNIT=SYSDA,\n//  SPACE=(1700,(400,50))\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=CEE.SCEERUN\n//         DD DISP=SHR,DSN=CEE.SCEELKED\n//         DD DISP=SHR,DSN=your_load_library_for_QWIKSCAN        @@@\n//SYSLMOD  DD DISP=SHR,DSN=your_load_library_for_QWIKSCAN(QWKF)  @@@\n//SYSLIN  DD DSN=&&OBJ(M),DISP=(OLD,DELETE,DELETE)\n//*\n//* --------------------------------------------------------- *\n//* ASSEMBLE AND COMPILE QWKX                                 *\n//* --------------------------------------------------------- *\n//QWKX   EXEC PGM=ASMA90,\n//   PARM='BATCH,OBJ,NODECK,XREF(FULL),LIST'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=source_dataset_for_QWKX              @@@\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB)\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB,SYSUT1)\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(1700,(600,100))\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJ(M),UNIT=SYSDA,SPACE=(500,(200,200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DISP=SHR,DSN=source_dataset_for_QWKX(QWKX)        @@@\n//STEP2 EXEC PGM=IEWL,COND=(8,LT),\n//  REGION=512K,PARM='LIST,XREF,LET,MAP'\n//SYSUT1 DD DISP=(MOD,DELETE,DELETE),DSN=&&UT1,UNIT=SYSDA,\n//  SPACE=(1700,(400,50))\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=CEE.SCEERUN\n//         DD DISP=SHR,DSN=CEE.SCEELKED\n//         DD DISP=SHR,DSN=your_load_library_for_QWIKSCAN        @@@\n//SYSLMOD  DD DISP=SHR,DSN=your_load_library_for_QWIKSCAN(QWKX)  @@@\n//SYSLIN  DD DSN=&&OBJ(M),DISP=(OLD,DELETE,DELETE)\n//*\n//* --------------------------------------------------------- *\n//* ASSEMBLE AND COMPILE QWIKSCAN                             *\n//* --------------------------------------------------------- *\n//QWIKSCAN  EXEC PGM=ASMA90,\n//   PARM='BATCH,OBJ,NODECK,XREF(FULL),LIST'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=source_dataset_for_QWIKSCAN          @@@\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB)\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB,SYSUT1)\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(1700,(600,100))\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJ(M),UNIT=SYSDA,SPACE=(500,(200,200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DISP=SHR,DSN=source_dataset_for_QWIKSCAN(QWIKSCAN)   @@@\n//STEP2 EXEC PGM=IEWL,COND=(8,LT),\n//  REGION=512K,PARM='LIST,XREF,LET,MAP'\n//SYSUT1 DD DISP=(MOD,DELETE,DELETE),DSN=&&UT1,UNIT=SYSDA,\n//  SPACE=(1700,(400,50))\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=CEE.SCEERUN\n//         DD DISP=SHR,DSN=CEE.SCEELKED\n//         DD DISP=SHR,DSN=your_load_library_for_QWIKSCAN        @@@\n//         DD DISP=SHR,DSN=your_ISPF_LOAD_library_where_ISPLINK_is  @@@\n//SYSLMOD  DD DISP=SHR,DSN=your_load_library_for_QWIKSCAN(QWIKSCAN) @@@\n//SYSLIN  DD DSN=&&OBJ(M),DISP=(OLD,DELETE,DELETE)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QWKF": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x01\\x01)\\x0f\\x01\\x022_\\x07\\x16\\x00\\xd1\\x00\\xce\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-10-17T00:00:00", "modifydate": "2002-11-21T07:16:19", "lines": 209, "newlines": 206, "modlines": 0, "user": "OPSUPP"}, "text": "         PRINT ON\n* SORRY...NO WARRANTY BUT QUESTIONS OR INQUIRIES CAN BE\n* DIRECTED TO: SEBASTIAN\u00a7WELTON.DE\n*              WWW.WELTON.DE\nQWKF     CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12)                            STANDARD H/K\n         LR    R12,R15                            STANDARD H/K\n         USING QWKF,R12                           STANDARD H/K\n         ST    13,SAVE+4                          STANDARD H/K\n         LA    R11,SAVE                           STANDARD H/K\n         ST    R11,8(R13)                         STANDARD H/K\n         LR    R13,R11                            STANDARD H/K\n         EJECT\n*\n* REMARKS\n*\n* MAY BE USED BY A CALLING PROGRAM TO SEARCH FOR IF/AND/NOT LOGICAL\n* SEARCHES. PARM MUST BE AS FOLLOWS:-\n*\n* OP-CODE  :  CHAR 001, ON ENTRY 'F', RESET TO 'N'\n* TARGET   :  CHAR 256, DATA TO BE SEARCHED\n* IF-MASK  :  CHAR 078, IF 'DATA-STRING' MASK\n* AND-MASK :  CHAR 078, AN 'DATA-STRING' MASK\n* NOT-MASK :  CHAR 078, NO 'DATA-STRING' MASK\n*\n* RETURN-CODES\n*\n* 0  : SEARCH SUCCESSFUL\n* 4  : SEARCH NOT SUCCESSFUL\n* 12 : NO DELIMT CHARACTER FOUND FOR IF MASK\n* 16 : NO TARGET DATA SUPPLIED\n*\n* OP-CODE IS USED TO ENSURE THAT QWKF DOES THE MINIMUM AMOUNT OF WORK,\n* THE CALLING PROGRAM SHOULD NOT INTERFERE WITH IT AFTER IT HAS BEEN\n* RESET BY QWKF.\n*\n* ONLY TARGET-DATA AND IF-MASK ARE REQUIRED BY QWKF\n*\n* ------------------------------ *\n* INSTRUCTIONS AFTER THIS POINT  *\n* ------------------------------ *\n*\nMAIN0000 EQU   *                                  MAIN PROC SECTION\n         BAL   R9,SUB0000                         BAL TO SUB-SECTION\n*\nMAIN0100 EQU   *                                  MAIN PROC SECTION\n         BAL   R9,SUB0100                         BAL TO SUB-SECTION\n*\n         LA    R15,0                              SET RETURN-CODE\n         CLC   MASK(03),=C'YYN'                   CHECK MASK\n         BE    END#                               OK, GO END\n         LA    R15,4                              RESET RC TO 04\n*\nEND#     L     R13,SAVE+4                         RESTORE CALLERS AREA\n         RETURN (14,12),RC=(15)                   AND RETURN TO CALLER\n*\nSUB0000  L     R10,0(R1)                          ADDRESS PARM\n         ST    R10,PARMADDR                       AND SAVE ADDRESS\n         MVC   D#D(256),1(R10)                    SHIFT TARGET DATA\n         MVC   OP(1),0(R10)                       AND SAVE 1ST BYTE\n         MVI   OP,C'F'                            AND SAVE 1ST BYTE\n         MVC   MASK(03),=C'NNY'                   INITIALISE MASK\n         PACK  DOUBLE(8),491(8,R10)\n         CVB   R3,DOUBLE\n*        LH    R3,=H'255'                         AND SET REV-COUNTER\nSUB0005  LA    R2,D#D                             ADDRESS TARGET DATA\n         AR    R2,R3                              INCREMENT ADDRESS\n         CLI   0(R2),C' '                         SPACES ?\n         BNE   SUB0010                            NO, DATA LOCATED\n         BCT   R3,SUB0005                         DECREMENT AND LOOP\n         LA    R15,16                             NO DATA\n         L     R13,SAVE+4                         RESTORE CALLERS AREA\n         RETURN (14,12),RC=(15)                   AND RETURN TO CALLER\nSUB0010  AH    R3,=H'1'                           INCREMENT COUNTER\n         STH   R3,D#L                             AND SAVE DATA LENGTH\n         MVC   INDX(02),=X'0003'                  INITIALISE INDEX\n         CLI   OP,C'F'                            OP-CODE 'F' (FIRST)\n         BE    SUB0011                            YES, GO PROCESS\n         BR    R9                                 NO, BRANCH BACK\nSUB0011  MVC   I#D(78),257(R10)                   SHIFT IF  DATA MASK\n         MVC   A#D(78),335(R10)                   SHIFT AND DATA MASK\n         MVC   N#D(78),413(R10)                   SHIFT NOT DATA MASK\n         MVI   0(R10),C'N'                        RESET OP-CODE\nSUB0015  LH    R3,INDX                            LOAD INDEX\n         SH    R3,=H'1'                           DECREMENT\n         STH   R3,INDX                            AND SAVE\n         CH    R3,=H'0'                           COMPARE TO ZERO\n         BNL   SUB0020                            NOT LOW, GO PROCESS\n         BR    R9                                 BRANCH BACK\nSUB0020  LH    R3,INDX                            LOAD INDEX\n         MH    R3,=H'80'                          MULTIPLY BY OFFSET\n         LA    R2,I#L                             ADDRESS IF DATA LEN\n         AR    R2,R3                              AND INCREMENT ADDRESS\n         LH    R3,=H'77'                          INITIALISE COUNTER\nSUB0025  LR    R4,R2                              COPY REGISTER 2\n         LA    R4,2(R4)                           OFFSET TO DATA\n         AR    R4,R3                              INCREMENT ADDRESS\n         CLI   0(R4),C'<'                         DELIMIT CHARACTER ?\n         BE    SUB0030                            YES, GO PROCESS\n         BCT   R3,SUB0025                         DECREMENT AND LOOP\n         LH    R3,INDX                            LOAD INDEX\n         CH    R3,=H'0'                           ZERO ?\n         BNE   SUB0015                            NO, SO ALL OK\n         LA    R15,12                             NO IF DATA SUPPLIED\n         L     R13,SAVE+4                         RESTORE CALLERS AREA\n         RETURN (14,12),RC=(15)                   AND RETURN TO CALLER\nSUB0030  STH   R3,0(R2)                           SAVE DATA LENGTH\n         B     SUB0015                            PROCESS NEXT ENTRY\nSUB0100  MVC   INDX(02),=X'0003'                  INITIALISE INDEX\nSUB0105  LH    R3,INDX                            LOAD INDEX\n         SH    R3,=H'1'                           DECREMENT\n         STH   R3,INDX                            SAVE\n         CH    R3,=H'0'                           COMPARE TO ZERO\n         BNL   SUB0110                            BRANCH ON NOT-LOW\n         BR    R9                                 RETURN\nSUB0110  MH    R3,=H'80'                          MULTIPLY BY OFFSET\n         LA    R2,I#L                             ADDRESS 1ST LEN ADDR\n         AR    R2,R3                              AND INCREMENT ADDRESS\n         CLC   0(2,R2),=X'0000'                   EQUAL TO ZEROS ?\n         BNE   SUB0115                            NO, GO PROCESS\n         LH    R3,INDX                            LOAD INDEX\n         MH    R3,=H'1'                           MULTIPLY BY OFFSET\n         LA    R2,MASK                            ADDRESS MASK\n         AR    R2,R3                              INCREMENT ADDRESS\n         MVI   0(R2),C'Y'                         AND INSERT MASK-CHAR\n         LH    R3,INDX                            LOAD INDEX\n         CH    R3,=H'2'                           NOT DATA ?\n         BNE   SUB0105                            NO, ALL OK\n         MVI   0(R2),C'N'                         INSERT NOT CHAR\n         B     SUB0105                            PROCESS NEXT ENTRY\nSUB0115  LH    R4,0(R2)                           LOAD DATA LENGTH\n         CH    R4,D#L                             COMPARE TO TARGET\n         BL    SUB0120                            LOW, ALL OK\n         LH    R3,INDX                            LOAD INDEX\n         CH    R3,=H'2'                           EQUAL TO NOT DATA\n         BE    SUB0116                            YES\n         BR    R9                                 GIVE UP\nSUB0116  MVC   MASK+02(01),=C'N'                  INSERT MASK CHAR\n         B     SUB0105                            PROCESS NEXT ENTRY\nSUB0120  LH    R5,D#L                             LOAD DATA LENGTH\n         SR    R5,R4                              CALC MAX COUNT\n         LH    R3,=H'0'                           INITIALISE COUNTER\n         LA    R2,2(R2)                           ADDRESS DATA\n         SH    R4,=H'1'                           DECREMENT FOR EX\nSUB0125  LA    R6,D#D                             ADDRESS TARGET DATA\n         AR    R6,R3                              INCREMENT ADDRESS\n         EX    R4,DATACLC                         RUN CLC INSTRUCTION\n         BE    SUB0135                            AHA, DATA FOUND\n         AH    R3,=H'1'                           INCREMENT COUNTER\n         CR    R3,R5                              COMPARE TO MAX\n         BNH   SUB0125                            NOT HIGH, RE-LOOP\n         LH    R3,INDX                            LOAD INDEX\n         CH    R3,=H'2'                           NOT DATA ?\n         BE    SUB0130                            YES, BRANCH\n         BR    R9                                 GIVE UP\nSUB0130  MVC   MASK+02(1),=C'N'                   SHIFT MASK-CHAR\n         B     SUB0105                            PROCESS NEXT ENTRY\nSUB0135  LH    R3,INDX                            LOAD INDEX\n         CH    R3,=H'2'                           NOT DATA ?\n         BNE   SUB0140                            NO\n         MVC   MASK+02(1),=C'Y'                   SHIFT MASK-CHAR\n         BR    R9                                 AND GIVE UP\nSUB0140  MH    R3,=H'1'                           MULTIPLY BY OFFSET\n         LA    R2,MASK                            ADDRESS MASK\n         AR    R2,R3                              INCREMENT ADDRESS\n         MVI   0(R2),C'Y'                         SHIFT MASK-CHAR\n         B     SUB0105                            PROCESS NEXT ENTRY\n*\n         LTORG\nSAVE     DS    9D                                 CALLERS AREA\nPARMADDR DS    F                                  PARM ADDRESS\n*\n         DS    0D\nDOUBLE   DS    D\n*\nDATACLC  CLC   0(0,R6),0(R2)                      USED VIA EX\n*\n         DS    0H                                 ALIGN\nINDX     DS    XL2                                INDEX\nMASK     DS    CL3                                MASK\nOP       DC    CL1'F'                             OP-CODE\n*\n         DS    0H                                 ALIGN\nD#L      DC    XL2'0000'                          TARGET LENGTH\nD#D      DS    CL256                              TARGET DATA\nI#L      DC    XL2'0000'                          IF     LENGTH\nI#D      DS    CL78                               IF     DATA\nA#L      DC    XL2'0000'                          AND    LENGTH\nA#D      DS    CL78                               AND    DATA\nN#L      DC    XL2'0000'                          NOT    LENGTH\nN#D      DS    CL78                               NOT    DATA\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QWKX": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00&\\x01\\x01)\\x0f\\x01\\x022_\\x07\\x17\\x00W\\x00T\\x00\\x00\\xd6\\xd7\\xe2\\xe4\\xd7\\xd7@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-10-17T00:00:00", "modifydate": "2002-11-21T07:17:26", "lines": 87, "newlines": 84, "modlines": 0, "user": "OPSUPP"}, "text": "         PRINT ON\n* SORRY...NO WARRANTY BUT QUESTIONS OR INQUIRIES CAN BE\n* DIRECTED TO: SEBASTIAN\u00a7WELTON.DE\n*              WWW.WELTON.DE\nQWKX     CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12)                            STANDARD H/K\n         LR    R12,R15                            STANDARD H/K\n         USING QWKX,R12                           STANDARD H/K\n         ST    13,SAVE+4                          STANDARD H/K\n         LA    R11,SAVE                           STANDARD H/K\n         ST    R11,8(R13)                         STANDARD H/K\n         LR    R13,R11                            STANDARD H/K\n         EJECT\n*\n* ------------------------------ *\n* INSTRUCTIONS AFTER THIS POINT  *\n* ------------------------------ *\n*\n         L     R10,0(R1)                          LOAD PARM ADDRESS\n         MVC   FLD#1(08),0(R10)                   SHIFT TARGET FIELD\n         MVC   FLD#2(08),8(R10)                   SHIFT MASK FIELD\n         LH    R3,=H'7'                           LOAD MAX OFFSET\nQWKX010  LA    R2,FLD#1                           ADDRESS BIG FIELD\n         AR    R2,R3                              ADD TO ADDRESS\n         CLI   0(R2),C' '                         CHECK FOR SPACE\n         BNE   QWKX015                            AHA, NO SPACE\n         BCT   R3,QWKX010                         DECREMENT/LOOP\n         LA    R15,4                              NO DATA, SET RC\n         B     END#                               FINISH\nQWKX015  AH    R3,=H'1'                           INCREMENT LENGTH\n         STH   R3,LEN#1                           STORE RESULT\n         LH    R3,=H'7'                           LOAD MAX OFFSET\nQWKX020  LA    R2,FLD#2                           ADDRESS LITTLE FIELD\n         AR    R2,R3                              ADD TO ADDRESS\n         CLI   0(R2),C' '                         CHECK FOR SPACE\n         BNE   QWKX025                            AHA, GOT IT\n         BCT   R3,QWKX020                         DECREMENT/LOOP\nQWKX025  LH    R4,LEN#1                           LOAD TARGET LENGTH\n         AH    R3,=H'1'                           INCREMENT MASK LEN\n         CR    R3,R4                              COMPARE LENGTHS\n         BNH   QWKX030                            MASK NOT HIGH, OK\n         LA    R15,4                              HIGH, SET RC\n         B     END#                               AND END\nQWKX030  LR    R5,R4                              COPY REGISTER 4\n         SR    R5,R3                              AND SUBTRACT R3\n         SH    R3,=H'1'                           DECREMENT R3 FOR EX\n         LH    R4,=H'0'                           INITIALISE INDEXER\nQWKX035  LA    R2,FLD#1                           ADDRESS TARGET DATA\n         AR    R2,R4                              ADD INDEX REG\n         EX    R3,DATACLC                         EXECUTE CLC\n         BE    QWKX040                            DATA MATCH FOUND\n         AH    R4,=H'1'                           INCREMENT INDEXER\n         CR    R4,R5                              COMPARE TO MAXIMUM\n         BNH   QWKX035                            NOT HIGH, LOOP ROUND\n         LA    R15,4                              SET RC (FAIL)\n         B     END#                               AND END\nQWKX040  LA    R15,0                              SET RC (SUCCESS)\n*\nEND#     L     R13,SAVE+4                         RESTORE CALLERS AREA\n         RETURN (14,12),RC=(15)                   AND RETURN TO CALLER\n         LTORG\nSAVE     DS    9D                                 CALLERS AREA\n*\nDATACLC  CLC   0(0,R2),FLD#2                      USED VIA EX\n*\n         DS    0H\nLEN#1    DS    XL2\nLEN#2    DS    XL2\nFLD#1    DS    CL8\nFLD#2    DS    CL8\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT603/FILE603.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT603", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}