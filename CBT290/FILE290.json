{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011648000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE290.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE290.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\r'", "DS1TRBAL": "b'\\x05\\xb6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xfb\\x00\\x02\\x01\\xfb\\x00\\t\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x158\\x05\\xf3\\x05\\xf3\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:38:00", "lines": 1523, "newlines": 1523, "modlines": 0, "user": "GPSAM"}, "text": "1\n-\n-\n-\n-\n0                                     GPSAM\n                     General Purpose Subsystem Access Method\n-                         Version 1 Modification Level 0\n0                                 Nov. 29, 1982\n-\n0                                 Howard Gilbert\n                               Yale Computer Center\n                                 175 Whitney Ave.\n                            P.O. Box 2112 Yale Station\n                               New Haven, Ct 06520\n                         Bitnet address: GILBERT @ YALEVM\n-\n-\n-\n0                    (c) Copyright 1982 Yale Computer Center\n0                    Yale retains all commercial rights to\n                     the programs described herein. A\n                     perpetual license is hereby granted to\n                     any individual, company, or organization\n                     to use them for any purpose on their own\n                     machine and to distribute the programs\n                     to other users provided that no more\n                     than a nominal service charge is made\n                     for the distribution. Explicit\n                     permission of Yale is required to sell\n                     any product which incorporates any part\n                     of these programs or the accompanying\n                     documentation.\n1\n-\n                                  1.  HIGHLIGHTS\n+                                 1.  HIGHLIGHTS\n0             GPSAM lets you write your own \"access method\" and make it\n           look like a sequential dataset to any application program or\n           utility. It can be used to provide DBMS, VTAM, TSO\n           fullscreen, BTAM, or specialized device support.\n0             \u00ae Simple:  Installs on any MVS system. No IBM code is\n+               ______\n                modified.  Takes only a few minutes to run linkedit\n                steps and build procedures.\n0             \u00ae Small:  700 bytes in LPA. 160 bytes in private address\n+               _____\n                space.\n0             \u00ae Safe:  Only one instruction executes in key 0 and\n+               ____\n                modifies a general system control block. Another 18\n                instructions operate in a system key and only 4 of them\n                change storage, storing values in job related control\n                blocks in the private area. Even the most conservative\n                installation can desk check the single authorized CSECT\n                several times over in an hour.\n0             \u00ae Universal:  While a system programmer must install the\n+               _________\n                package in authorized libraries, any application\n                programmer can write his own \"access method\" in\n                assembler and use it from his own programs. The user\n                specifies the module name on his DD card or in the TSO\n                allocation of the ddname.  These user modules run in\n                problem state and can come from any library.  Control\n                is given to the routine from the OPEN, CLOSE, GET, PUT,\n                READ, or WRITE statements.\n0             \u00ae Secure:  MVS Integrity is maintained. If an authorized\n+               ______\n                program opens a GPSAM file, the \"access method\" module\n                is limited to those explicitly permitted by an\n                installation supplied name table and the module must\n                come from an APF library.\n0          GPSAM is distributed in source and object form. It is\n           written in structured assembler language using the HAL\u00a3\n           macro system.  There are no prerequisites for any IBM or\n           non-IBM program products.\n-\n-          \u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\n-          \u00a3 HAL provides IF, ELSEIF, ELSE, DO UNTIL, DO WHILE, BLOCK,\n             and LEAVE statements with logical expressions. It is is\n             distributed with GPSAM and other Yale packages. A separate\n             document describes its use and syntax.\n0                                     - 1 -\n1\n-\n                                 2.  HOW IT WORKS\n+                                2.  HOW IT WORKS\n0             GPSAM makes use of the subsystem dataset facility which\n+                                    _________ _______\n           is a standard part of MVS. The best known subsystems are\n           JES2 and JES3, and many programmers assume that a subsystem\n           must involve communication with a running system task. In\n           fact, the Subsystem Interface is more properly a set of\n           general system exits identified by control blocks rather\n           than linkedited into system modules.\n0             For example, to use GPSAM the system programmer adds the\n           name \"GPSM\" to the subsystem name table (a LINKLIB module in\n           SP 1.1 or member of PARMLIB in SP 1.3).  At IPL time the\n           system builds a 36 byte control block called a SSCVT and\n           stores the name \"GPSM\" in it.  The subsystem is the control\n+                                         ___ _________ __ ___ _______\n           block.  There is no stared task, job, address space, or\n+          _____\n           subtask associated with the name GPSM.\n0             It is necessary to run the GPSAM program after IPL.  This\n           authorized program fills in the SSCVT control block with a\n           pointer to exit routines which should get control when a\n           GPSM dataset is allocated, opened, or closed.  These exits\n           load the user supplied access method module.\n0             Many application programmers assume that since the\n           standard IBM access methods are part of the operating system\n           they operate like SVC routines.  In fact, BSAM and QSAM\n           operate as subroutines to the application program. The\n           supervisor state part of the I/O process is handled by the\n           separate EXCP SVC service.  An access method has no special\n           attributes and need not be a system program at all.\n0             GPSAM is not simply a single additional access method; it\n           is instead a way to write your own access methods. On the DD\n           card you specify a load module.  The load module is the\n+                                           ___ ____ ______ __ ___\n           dataset.\n+          _______\n0             On the EXEC card the programmer specifies a module name\n           and parameter.\n0             //stepname EXEC PGM=module,PARM='parameter'\n0          GPSAM allows the programmer to supply other module names and\n           parameter strings on the DD cards.\n0             //ddname DD SUBSYS=(GPSM,module,'parameter')\n0          When the main program opens this file name, the system calls\n           one of the GPSM exit routines. The exit finds the module\n           name from the DD card and issues a LOAD macro to bring it\n           into storage. It then calls the entry point of the module as\n           a problem state exit of OPEN (something like the DCB OPEN\n           exit which is described in the standard Data Managment\n-                                     - 2 -\n1\n-\n           manuals). The user routine must prepare to service program\n           input and output requests.  It is important to realize that\n           there is no real data associated with this SUBSYS ddname. In\n           many cases the user's entry point will open some other type\n           of dataset or other ddname to actually get access to the\n           data. The only absolute requirement for the entry point is\n           that it pass back the address of another subroutine which\n           will service the READ and WRITE or GET and PUT requests.\n           The main entry point of the module is reenterd to close the\n           dataset.\n-\n                                3.  POSSIBLE USES\n+                               3.  POSSIBLE USES\n0             The access method module is simply a dynamic subroutine\n           of the main program.  If you write the jobstep program\n           yourself in assembler language, and always get data from the\n           same source, then you do not need GPSAM and can achieve the\n           same function with the LOAD and LINK macros.\n0             GPSAM becomes useful if the program is a package which\n           you cannot modify, or is written in a high level language\n           which has limited linkage conventions, or if the program was\n           written to handle normal datasets and would be expensive to\n           convert for a single special job. After all, the whole\n           purpose of an access method is to free the program from\n           internal dependency on any specific device type. But while\n           QSAM and BSAM are fine for disk, tape, and unit record\n           devices, they do not support more exotic kinds of data\n           structures or device types.\n0             One of the most important advantages of the Database\n           Management concept is that it frees the application program\n           from dependence on the form or location of the data. A DBMS\n           does this for big online datasets, but it has a big setup\n           cost and is not useful for smaller casual files or for tape\n           datasets.  One of the simplest uses of GPSAM is to simply\n           reformat records to match the actual contents of a datset to\n           the format the program expects to see.  Suppose that changes\n           in tax laws, zip code size, audit requirements, or a merger\n           force changes in the format of archived tape files.  It is\n           possible to recopy all existing data, but this is expensive\n           and time consuming. Besides, there are lots of programs\n           which depend on the old format. Alternately, two small\n           assembler language programs could be written for GPSAM:\n0             //INPUT DD SUBSYS=(GPSM,OLDFORM,REALTAPE)\n              //REALTAPE DD definition of new format tape\n0          The OLDFORM module would read a record from the REALTAPE\n           ddname and reorganize the data to simulate the old format.\n           Old programs will continue to work and need not be converted\n-                                     - 3 -\n1\n-\n           until new function is desired.  A matching NEWFORM module\n           could take the old format tape and expand it to the new\n           format with default or dummy values inserted into the new\n           fields. This allows new programs to be run on the old tapes.\n0             While some examples of GPSAM access method modules are\n           supplied with the package, much of the program development\n           will be contributed by the user community. The following\n           examples show how GPSAM could be used. It is a wish list and\n           not a list of supplied funcitons:\n0             \u00ae SUBSYS=(GPSM,LOWCASE) - In TSO, when the terminal is\n                allocated for input using DA(*), the data typed in is\n                folded into upper case. If this is not desired, a GPSAM\n                module could do the TGET directly and pass the data\n                unmolested.  This is only one example of a large number\n                of potential terminal support routines to do things\n                which the standard IBM DA(*) support does not provide.\n                Examples include: fullscreen output to 3270s, support\n                of ASA carriage control characters when the terminal is\n                a hardcopy device, support of control characters for\n                graphics devices, file transfer to minicomputers\n                through the communications line, blank compression\n                where the terminal has tab stops, insertion of padding\n                characters when the terminal requires them, etc.\n0             \u00ae SUBSYS=(GPSM,SERIES1,ddname) - The IBM Series/1\n                mincomputer supports many different hardware interfaces\n                (GPIB, local area network, high speed parallel) and can\n                itself be channel attached as a simulated 3270 control\n                unit. Data acquired from lab equipment, point of sale,\n                factory floor, network, or ID card scanning devices\n                could be directly read or spooled to disk and\n                transferred later through a BTAM interface routine\n                connected through GPSAM.  The \"ddname\" supplied as the\n                third parameter would be the name on a related:\n                    //ddname DD UNIT=cuu\n                card which defines the Series/1 data transfer address.\n0             \u00ae SUBSYS=(GPSM,DACU,ddname) - The new IBM DACU hardware\n                product is similar to the previous example, except that\n                it provides an interface to a DEC UNIBUS.  The\n                interface routine would use the IBM GAM access method\n                to provide the real I/O support to the device.\n0             \u00ae SUBSYS=(GPSM,DBMSI,'query') - The I/O could be sent to\n                a Database Management System for resolution. The\n                parameter string could contain a query, and the\n                application program could then read records which are\n                the result of the query. Alternately, the program could\n                write the query to one file and then read the responses\n                from another file.\n-\n                                      - 4 -\n1\n-\n              \u00ae SUBSYS=(GPSM,VTAMI,'netaddr,filename') - A dataset can\n                be retrieved from a programmable node or other host in\n                an ACF VTAM network. The interface program would open\n                an ACB and establish a session with a service routine\n                at the remote location. The supplied \"filename\" would\n                be passed to locate the desired data in the remote\n                library structure. The data could then be read as a\n                sequential dataset by the local application program.\n0             \u00ae SUBSYS=(GPSM,NJEPACK,ddname) - An output dataset is to\n                be sent through JES NJE services to a remote location.\n                The \"ddname\" represents a SYSOUT=B card with routing\n                information to the desired target. The problem is that\n                the program producing the data does not want to produce\n                cards but assumes some other F, V, or U record format.\n                Records must be packed/blocked in card image compatible\n                with the IBM network interchange format for\n                transmission.\n-\n                            4.  HISTORICAL PERSPECTIVE\n+                           4.  HISTORICAL PERSPECTIVE\n0             Subsystem datasets were originally designed for use by\n           JES.  From Releases 2.0 to 3.7 the only subsystem datasets\n           were SYSIN and SYSOUT.  In the middle of Release 3.7,\n           Selectable Unit 29 generalized the subsystem dataset concept\n           with the SUBSYS keyword support.  Not many people took\n           notice of SU 29, however, because its nominal function was\n           to support the Vector Processor Subsystem for the 3838 array\n           processor and few customers purchased this device.\n0             It is well known that the product development is a small\n           part of IBM's overall software costs.  There are major\n           additional costs in testing, support, and education. The\n           product must be tested and supported in any environment the\n           customer may choose to use it.  When the product has a\n           rather technical function, is mostly required to support\n           other IBM products, and does not have a clear market demand,\n           IBM avoids the extra cost by declaring the program to be an\n           internal interface. While the interface may be documented in\n           some manuals, it is not given full field support and need be\n           tested only to ensure that it provides the functions\n           required by the other specific IBM products.\n0             The IBM market experts understand the requirements of\n           industrial, financial, and government customers. But there\n           come moments when an idea is \"right\" for reasons which a\n           programmer understands instinctively but which are difficult\n           to explain to salesmen.  The main advantage of the SUBSYS\n           interface is that it is \"slick\".  There is nothing it does\n           which cannot be done some other way. It makes some things\n           easier to accomplish and to document. It may not be quite as\n-                                     - 5 -\n1\n-\n           general as the UNIX \"pipe\" concept or the device driver\n           architecture in some minicomputer systems, but it is still\n           awfully clever.  When the people in White Plains ask the\n           question \"What will they pay for it\" or \"How many machines\n           will it sell,\" there is no easy way to put a dollar figure\n           on a sense of technical aesthetics.\n0             There is more opportunity for small useful products to\n           come from IBM as IUPs and FDPs. Some, like GPSAM, will be\n           written by customers and distributed through SHARE. If\n           potential users simply don't look at anything but the fully\n           supported products, then they shut themselves off from a\n           whole class of useful tools.\n-\n                         5.  SUBSYSTEM DATASET INTERFACE\n+                        5.  SUBSYSTEM DATASET INTERFACE\n0             For each SUBSYS file, exits are taken to the subsystem\n           when the JCL is parsed, then at allocation, open, close, and\n           deallocation time. GPSAM is only interested in open and\n           close and ignores the other calls.\n0             The application program opens a DCB to talk to the file,\n           but the OPEN SVC constructs an ACB and passes it to the\n           subsystem.  When the application program issues the standard\n           BSAM or QSAM I/O requests (GET, PUT, READ, WRITE, NOTE,\n           POINT, CHECK) the IBM Sequential Access Method Subsystem\n           Interface (SAMSI) modules convert these macros requests into\n           VSAM-like requests with an RPL and an ACB. This produces\n           some good news and some bad news.  The good news is that you\n           do not have to worry about the difference between QSAM or\n           BSAM because the IBM code delivers a common interface to\n           your program.  The bad news is that the interface looks like\n           an Entry Sequenced VSAM Dataset (ESDS) and this is a less\n           familiar interface to most programmers.\n0             Actually, the interface to the user \"access method\"\n           routine is fairly simple. On entry to the routine:\n0              R0   Contains a request code.\n               R1   Points to the Request Parameter List (RPL).\n               R13  Points to a save area.\n               R14  Is the return address.\n               R15  Is the entry address.\n0          There are a lot of codes which can exist in R0 if you wanted\n           to support them, but the only required codes are 0 (GET) and\n           1 (PUT).  You can treat the rest as No-Ops or logical\n           errors.  Within the RPL,\n-\n-                                     - 6 -\n1\n-\n              Offset  Name      Function\n              0C      RPLFDBWD  Return code from I/O request.\n              20      RPLAREA   Points to user buffer.\n              30      RPLRLEN   Has or gets the length of the data in\n           the buffer.\n              34      RPLBUFL   Has the full size of the user buffer.\n0          and any use of other fields is optional.  For a PUT request,\n           you must dispose of RPLRLEN bytes of data in the buffer\n           RPLAREA points to. For a GET request you fill the buffer\n           with no more than RPLBUFL bytes of data and put the actual\n           length in RPLRLEN.  In both cases, the first byte of\n           RPLFDBWD gets a summary I/O status code with one of three\n           values:\n0             Value   Name      Meaning\n              0       RPLNOERR  Normal end to request\n              8       RPLLOGER  Logical error (including end of file)\n             12       RPLPHYER  Physical error\n0          The third byte of RPLFDBWD, which can be accessed under the\n           label of RPLERRCD, is assigned a more detailed reason code.\n           Since the interface is based on pseudo-VSAM, the error codes\n           are taken from Figures 6 and 7 in the VSAM Programmer's\n+                                                ____ ____________\n           Guide.  These error codes are given symbolic names by the\n+          _____\n           IDARMRCD macro.  The most likely error values are:\n0             Value   Name      Meaning\n                4     RPLEODER  End of file\n               2C     RPLINBUF  Input buffer too small\n               44     RPLINACC  GET to output or PUT to input dataset\n               6C     RPLINLEN  RPLRECL is invalid (0, too small, too\n           big)\n0             All of the fields documented here would be part of any\n           possible interface. Imbedding the information in a VSAM\n           structure doesn't really add to the work.  There is one\n           delicate issue, and GPSAM makes it easy. If you want to\n           signal an abnormal condition (end of file, logical, or\n           physical error) then any appropriate exit routine which the\n           ACB points to should be called. The full required exit\n           processing logic is supplied by entry point GPSMEXIT in the\n           supplied GPSMSUBS module which can be linkedited with your\n           access method module. You simply set the correct feedback\n           code, then branch to that entry point to decide if an exit\n           should be called.\n-\n-\n-\n                                      - 7 -\n1\n-\n                          6.  CONCERNING DCB PARAMETERS\n+                         6.  CONCERNING DCB PARAMETERS\n0             Unlike JES files, there is no default DCB information for\n           a GPSM dataset. Therefore, if the program does not provide\n           such defaults, so RECFM, LRECL, and BLKSIZE must be given\n           when the file is defined. Since a subsystem processes\n           unblocked records, and since it does only synchronous I/O,\n           the RECFM should be F, V, or U but should not be B (blocked)\n           or S (spanned).  BUFNO should be 1, since a larger value for\n           BUFNO can cause FORTRAN to read-ahead, issuing a GET for the\n           next record before processing the previous one.\n0             In batch the DCB information can be provided on the DD\n           card in the usual manner:\n0             //ddname DD SUBSYS=(GPSM,module,'parameter'),\n              // DCB=(RECFM=U,BLKSIZE=80,BUFNO=1)\n0          In TSO the GPSMDD command accepts RECFM and LRECL keywords:\n0             GPSMDD ddname module 'parameter' RECFM(U) LRECL(80)\n0          GPSMDD calculates the BLKSIZE based on LRECL and defaults\n           BUFNO to 1.\n-\n                                 7.  INSTALLATION\n+                                7.  INSTALLATION\n0             The first step in installation is to define the name\n           \"GPSM\" as a subsystem, since this will not take effect until\n           the next IPL. Consult the correct level of the IBM manual\n           System Programming Library: Job Management for information\n+          ______ ___________ _______  ___ __________\n           on the definition of a new subsystem. Up to MVS SP1.1 it is\n           necessary to use AMASPZAP to place an entry in the IEFJSSNT\n           module in SYS1.LINKLIB. After SP 1.3 it is possible to\n           change the IEFJSSxx member of SYS1.PARMLIB.\n0             There are some supplied examples of GPSM access method\n           routines, but the GPSAM system proper consists of only four\n           modules:\n0          Name      Library  Attrib     Function\n           GPSAM     LPA      RENT,AC=1  Subsystem code itself\n           GPSMOPEN  LNKLST   RENT       Handles the open and close\n           GPSMSUBS  SYSLIB              Subroutine for access method module\n           GPSMDD    CMDLIB              TSO command to allocate GPSM dataset\n0          The distributed material consists of a documentation file\n           (you are reading it) and the source. The user must assemble\n           the source routines and link the object decks into the\n           appropriate libraries.\n-\n                                      - 8 -\n1\n-\n              The distributed source is a sequential dataset which can\n           be used as input to the IEBUPDTE utility to generate a\n           partitioned dataset:\n0             //GPSM EXEC PGM=IEBUPDTE,PARM=NEW\n              //SYSPRINT DD DUMMY\n              //SYSUT2 DD DSN=????.GPSAM.ASM,DISP=(,CATLG),UNIT= ...\n              //SYSIN DD ... (describe input tape)\n0          If GPSAM was received by itself the source is the second\n           file on the tape (this document is the first file). If GPSAM\n           is being distributed on a mods tape, then follow the\n           instructions of the mods tape authors in unloading the file.\n0             The source PDS also contains macros which are required\n           for assembly.  When assembling any of the GPSAM routines,\n           the SYSLIB should be defined as:\n0             //SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n              //       DD DSN=SYS1.AMODGEN,DISP=SHR\n              //       DD DSN=????.GPSAM.ASM,DISP=SHR\n0             No linkedit job stream is supplied with the package, but\n           the following example can be followed as a model.  Please\n           read carefully the discussion which follows it to understand\n           the attributes of each module which is being created.\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-                                     - 9 -\n1\n-\n           //GPSMLINK JOB\n           //**************************************************************/\n           //*    SAMPLE JOB TO INSTALL GPSAM ROUTINES                    */\n           //*    YOU CHANGE THE DATASET NAMES TO MATCH LOCAL REQUIREMENTS*/\n           //*    ASSUMES A \"LKED\" PROC IN PROCLIB                        */\n           //**************************************************************/\n           //GPSAM EXEC LKED,PARM='RENT,REUS,AC=1'\n           //**************************************************************/\n           //*    LINK THE GPSAM MODULE INTO LPALIB                       */\n           //*    NOT MUCH CHOICE HERE, THE MODULE MUST GO IN THE LINK    */\n           //*      PACK, ALTHOUGH FOR TEST PURPOSES IT CAN BE MLPA'ED    */\n           //*      INTO THE SYSTEM.                                      */\n           //**************************************************************/\n           //SYSLMOD DD DSN=SYS1.LPALIB,DISP=SHR\n           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR\n            INCLUDE GPSAM(GPSAM)\n            ALIAS GPSAMEND\n            NAME GPSAM\n           //GPSMOPEN EXEC LKED,PARM='RENT,REUS'\n           //**************************************************************/\n           //*    LINK THE GPSMOPEN MODULE INTO THE LINKLIST              */\n           //*    FOR TEST PURPOSES, THIS MODULE CAN COME FROM A STEPLIB  */\n           //*      PROVIDED THAT THE LIBRARY IS IN THE APF LIST.         */\n           //**************************************************************/\n           //SYSLMOD DD DSN=????.LINKLIB,DISP=SHR\n           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR\n            INCLUDE GPSAM(GPSMOPEN)\n            NAME GPSMOPEN\n           //GPSMDD   EXEC LKED\n           //**************************************************************/\n           //*    LINK THE GPSMDD MODULE INTO A TSO COMMAND LIBRARY       */\n           //*    NOTE THAT IT IS NOT REENTRANT AND CANNOT GO IN LPALIB   */\n           //*      ANY MEMBER OF THE LINKLIST WILL DO.                   */\n           //**************************************************************/\n           //SYSLMOD DD DSN=????.CMDLIB,DISP=SHR\n           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR\n            INCLUDE GPSAM(GPSMDD)\n            NAME GPSMDD\n           //GPSMDD   EXEC LKED\n           //**************************************************************/\n           //*    LINK A SAMPLE ACCESS METHOD ROUTINE INTO SOME           */\n           //*      USER LIBRARY. THIS ROUTINE PERMITS LOWERCASE INPUT    */\n           //*      FROM A TERMINAL. THIS STEP IS OPTIONAL IF YOU DON'T   */\n           //*      NEED THIS ROUTINE. IT IS JUST A SAMPLE OF GPSM USE.   */\n           //**************************************************************/\n           //SYSLMOD DD DSN=????.LINKLIB,DISP=SHR\n           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR\n            INCLUDE GPSAM(LOWCASAM)\n            INCLUDE GPSAM(GPSMSUBS)\n            NAME LOWCASAM\n-\n-                                     - 10 -\n1\n-\n              GPSAM is the only authorized module in the package.  It\n           contains all the subsystem exit routines and the SSVT\n           control block.  The GPSAM main entry point initializes the\n           subsystem. The module has a optional alternate entry point\n           GPSAMEND which can be defined by an ALIAS card and run to\n           deactivate the subsystem. There should never be any real\n           need to use GPSAMEND unless you are modifying the GPSAM\n           program itself.\n0             The GPSAM OPEN exit issues a LOAD macro for the entry\n           point name GPSMOPEN and uses the SYNCH macro to pass control\n           to it as a problem state exit.  The substantive part of OPEN\n           and CLOSE processing is done by this module.  While GPSMOPEN\n           could be in LPALIB, it is usually kept in one of the\n           libraries of the LNKLST concatenation instead.  This makes\n           it easier to modify if you want to test new versions.\n           Alternate versions of GPSMOPEN can also be supplied in a\n           STEPLIB if the library is APF authorized.  While GPSMOPEN\n           runs in problem state, it has certain integrity checking\n           functions to perform and can only be modified by system\n           programmers.  For this reason, GPSAM is careful to restrict\n           the loading of GPSMOPEN from only an APF library.\n0             GPSMSUBS is intended to contain subroutines which will be\n           helpful to the user supplied access method modules.\n           Currently the only such subroutine is GPSMEXIT which\n           provides the common error analysis and exit list processing\n           logic.  It can be kept in object form or linked into a local\n           subroutine library and used later to build the access method\n           module.  It is itself reentrant and should be given the REEN\n           attribute in case the rest of the access method module is\n           also reentrant.\n0             GPSMDD is a TSO command which can be used to allocate a\n           GPSM dataset. It is not reentrant and thus cannot go in\n           LPALIB.  It should be placed somewhere in the LNKLST\n           concatenation so it can be conveniently accessed by TSO\n           users.\n0             It is also important to provide a procedure which can be\n           used to initialize GPSAM. A suggestion is to add a member to\n           PROCLIB:\n0             ./ ADD NAME=GPSAM\n              //GPSAM EXEC PGM=GPSAM\n0          Once the system goes into production, some provision should\n           be made to issue the \"S GPSAM\" command at IPL.\n-\n-\n0                                     - 11 -\n1\n-\n                               8.  SYSTEM INTEGRITY\n+                              8.  SYSTEM INTEGRITY\n0             The thing about GPSAM is that it allows the user through\n           JCL to specify the loading of an arbitrary module while any\n           other program is running. No problem exists if the program\n           opening the dataset is unauthorized, but in the authorized\n           case some care must be given to preserve MVS integrity.\n0             The security checks are built into the GPSMOPEN module.\n           This module is itself loaded by the GPSAM exits while they\n           are in supervisor state, so the normal operating system LOAD\n           macro processing will ensure that GPSMOPEN can only come\n           from an APF library and is therefore itself valid.\n0             GPSMOPEN checks to see if the current jobstep is APF\n           authorized.  If so, then the access method module must come\n           from an APF library (LOAD will take care of this check\n           automatically). But in addition, the access method module\n           name must be in a table of specially approved access method\n           routines assembled into GPSMOPEN itself. This extra check is\n           added because any module in any APF library could otherwise\n+                        ___\n           be loaded through GPSAM into an authorized but unexpected\n           environment. With thousands of modules to choose from, some\n           routine could probably be found which would misinterpret the\n           parameters passed by GPSMOPEN and cause trouble to the\n           system.\n0             One problem which could not be solved by simple\n           limitations is the use of a GPSM dataset by a program which\n           is in supervisor state or system key when it opens the file\n           but which is not APF authorized and has a problem state TCB\n           protect key. The only likely such situation is a dataset\n           opened by an SVC routine running under an unauthorized task.\n           The LOAD macro will limit the source of the module to an APF\n           library if the program doing the LOAD is 1) APF authorized,\n           2) supervisor state, or 3) system key. GPSMOPEN never meets\n           tests 2 and 3, and if the jobstep is not APF then LOAD will\n           let the access method module come from anywhere. We cannot\n           pass back an arbitrary module entry point to a routine which\n           is itself in supervisor state and may be expected to branch\n           to this unknown module. This problem could not be solved by\n           table lookup, so GPSAM enforces a flat prohibition on its\n           use by any program which is supervisor or system key but not\n           also APF.\n-\n-\n-\n-                                     - 12 -\n1\n-\n                           9.  PROGRAMMING RESTRICTIONS\n+                          9.  PROGRAMMING RESTRICTIONS\n0             The GPSMOPEN program and the main entry point of the user\n           access method module run as exits of the OPEN SVC. The\n           system is holding an ENQ on one of the control blocks for\n           this dataset under the major name SYSZTIOT and this ENQ is\n           in conflict with any attempt to dynamically allocate any\n           dataset through SVC 99. This does not prevent other files\n           from being opened, it just prevents new allocations. Thus\n           files needed by your program at OPEN time, including all\n           catalogs accessed thorugh LOCATE, must already be allocated\n           before the OPEN occurs.\n-\n                       10.  WRITING AN ACCESS METHOD MODULE\n+                      10.  WRITING AN ACCESS METHOD MODULE\n0             The elements of a user written access method module are\n           illustrated by examples from the distributed LOWCASAM\n           routine.  It turns file input requests from a program into\n           terminal input requests though the TGET macro, but without\n           the translation of lower case to upper case associated with\n           normal DA(*) input datasets.\n0             The main entry point of the access method routine is\n           called by GPSMOPEN using standard subroutine linkage. On\n           entry, R1 points to a parameter block/work area:\n0          AMPARM   DSECT\n           GPSMMPRM DS    A                  POINTER TO MODULE PARM\n           GPSMSSOB DS    A                  POINT TO OPEN SSOB\n           GPSMAMEP DS    A                  RETURN ACB AM ENTRY POINT\n           GPSMSAVA DS    A                  WORD TO SAVE FOR CLOSE\n           GPSMDDN  DS    CL8                DDNAME\n                    DS    16A                WORK AREA\n0          GPSMMPRM is the address of the parameter field from file\n           allocation (either the third SUBSYS parameter in batch or\n           the third positional parameter on the GPSMDD TSO command).\n           This pointer is 0 if no parameter exists. The format of the\n           parameter is a one byte length field followed by the\n+                         ___ ____\n           character string. Quotes used to delimit the parameter will\n           have been removed.\n0             The GPSMSSOB field points to the Subsystem Options Block\n           created by OPEN to process this request. It is mapped by the\n           statement:\n0                   IEFJSSOB DA\n0          And its format can be found in the MVS Debugging Handbook.\n           There are three useful fields in this block:\n-\n                                      - 13 -\n1\n-\n             SSOBFUNC  which contains the request code\n                       (SSOBOPEN for OPEN, SSOBCLOS for CLOSE).\n             SSDAJFCB  which points to the JFCB for the dataset.\n             SSDADEBP  which points to the DEB. The DEBDCBAD field in\n           turn\n                       points to a protected copy of the ACB.\n-             GPSMDDN has the ddname for the dataset being opened. This\n           seems to be the most useful item which is not in the control\n           blocks passed direcly through the SSOB. Other control blocks\n           for the dataset (like the DSAB and the SIOT) can be found\n           using algorithms which can be copied from GPSMOPEN source.\n0             GPSMAMEP must be filled in with the entry point which\n           handles I/O macro requests (GET, PUT, etc.). This is the\n           only function which the main entry point of the access\n           method routine must perform.\n0          LOWCASAM CSECT\n                    USING *,R15\n                    SAVE  (14,12),,*\n                    LR    R10,R15\n                    USING LOWCASAM,R10\n                    DROP  R15\n                    LR    R2,R1\n                    USING AMPARM,R2\n                    L     R6,GPSMSSOB        GET SSOB POINTER\n                    USING SSOB,R6            NOW CHAIN DOWN TO ACB\n           OPENCLOS    IF    (SSOBFUNC+1,EQ,SSOBOPEN,CLI),THEN\n           *              ******************************************************\n           *              * FUNCTION IS OPEN.                                  *\n           *              ******************************************************\n                          LA    R1,PUTGET          PLACE PUT/GET ENTRY POINT\n                          ST    R1,GPSMAMEP        IN PARAMETER BLOCK\n                          MVC   BADIODD,GPSMDDN    SAVE DDNAME FOR MESSAGES\n                       ELSE  ,\n           *              ******************************************************\n           *              * THE FUNCTION IS CLOSE                              *\n           *              ******************************************************\n           *              (NOTHING DONE AT CLOSE TIME)\n                       BEND  OPENCLOS\n                    SPACE 5\n           RET      L     R13,4(R13)         BACK TO SAVE1\n                    RETURN (14,12),RC=0\n                    DROP  ,\n-             In the previous code, the entry point for normal I/O is\n           called PUTGET.  The SAM access method branches to this entry\n           point using the PUT or GET macros with the RPL= keyword\n           (VSAM syntax). The expansion of these macros generates the\n           following statements:\n-                                     - 14 -\n1\n-\n                    L     R1,RPL\n                    LA    R0,function\n                    L     R15,24(R1)         POINT TO ACB\n                    L     R15,8(R1)          POINT TO MY ENTRY POINT\n                    BALR  R14,R15\n0          The function code in r0 is 0 for a GET and 1 for a PUT.\n           These are the only functions which you are known to have to\n           support, though JES has support for NOTE, POINT, CHECK, and\n           ENDREQ and so these codes might be considered for\n           comprehensive support. The LOWCASAM module supports the GET\n           file I/O request by issuing a TGET terminal I/O request,\n           checks for \"/*\" to signal end of file, and rejects output\n           requests with a friendly but firm message.\n0          PUTGET      BLOCK ,\n                       SAVE  (14,12)\n                       BALR  R12,0\n                       USING *,R12\n                          IF    (R0,EQ,0),THEN     IF ITS A GET\n                             LR    R2,R1              SAVE RPL ADDRESS\n                             USING IFGRPL,R2\n                             L     R1,RPLAREA         PICK UP BUFFER\n                             LR    R3,R1\n                             L     R0,RPLBUFL         GET BUFFER LENGTH\n                             TGET  (1),(0),EDIT       READ DATA\n                             ST    R1,RPLRLEN\n                                IF    (R1,GE,2),AND,     LOOK FOR \"/*\"\n                                         (0(2,R3),EQ,SLSHSTAR,CLC)\n                                   MVC   RPLFDBK,EOFCODE\n                                ELSE  ,\n                                   XC    RPLFDBK,RPLFDBK\n                                BEND  ,\n                          ELSE  ,\n                             TPUT  BADIO,LBADIO\n                             MVC   RPLFDBK,ERRCODE\n                          BEND  ,\n                       LR    R1,R2\n                       L     R15,=V(GPSMEXIT)\n                       BR    R15\n                       BEND  PUTGET\n-             Note that the exit from the routine is through the\n           GPSMEXIT subroutine. It analyzes the error return code and\n           passes control to the appropriate ACB exit routine if one\n           exists.\n0             While it is possible for an access method routine to get\n           more complicated, the extra code would be required by the\n           function which it performs and not the GPSAM linkage or\n           conventions.\n-\n                                      - 15 -\n1\n-\n                      11.  PROGRAM DEVELOPMENT AND DEBUGGING\n+                     11.  PROGRAM DEVELOPMENT AND DEBUGGING\n0             Since the user supplied access method module is an\n           unauthorized subroutine of your program, you can debug it\n           using the standard facilities of TSO TEST. Your task is the\n           same as in the development of any application program. The\n           author of GPSAM, however, has no pratical hints on the use\n           of TEST because he used the the much more powerful locally\n           developed debugging program Debugging Controller (DBC)\u00a5.\n           DBC operates as the ESTAE exit of the program being debugged\n           or as the ESTAI of the attaching task.  TEST is intended to\n           handle simple user applications, but DBC was designed for\n           more complicated system programming tasks. It has a more\n           comprehensive view of the operating system and can map\n           external names and, if the module is linked with the TEST\n           option, internal labels of any routine in the system\n           (including mapping nucleus CSECTS or LPA modules). It has a\n           more sophisticated understanding of MVS task structure and\n           provides more information on TCB and RB attributes. It not\n           only disassembles and labels instructions in the program,\n           but can read DSECT definitions from the symbols of a load\n           module and can format all system and user control blocks.\n           It also can single step through a program or let\n           instructions execute up to the next branch.\n0             No special preparation is required to use DBC on the\n           access method (GET/PUT) part of the modules.  On the other\n           hand, the part that runs at OPEN time runs under the OPEN\n           ESTAE exit and use of DBC in this environment requires the\n           establishment of a local overriding ESTAE environment. This\n           step is built into each supplied module, but is disabled by\n           default. To use it, the high order bit of the storage\n           location FLAGWORD should be set to 1.\n0             If the access method module is linkedited with the TEST\n           and REUS attributes, it can be preloaded by the debugger and\n           breakpoints can be established before the main program even\n           begins execution. When the module goes into a production\n           library, however, it should not be marked reusable unless it\n           is also reentrant.\n0             Since the parts of GPSAM which run during OPEN cannot use\n           dynamic allocation, all module to be mapped must be\n           preloaded and mapped before the OPEN process begins.  While\n           it is not necessary for ordinary users to run authorized\n           when using GPSAM, the authors have found that debugginf of\n           the OPEN code in an APF authorized state is easier, since\n           \u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\n-          \u00a5 DBC is distributed as a Yale program product at a\n             relatively low cost through a third party.  For\n             information on DBC, contact Computer Systems Research at\n             203-678-1212.\n0                                     - 16 -\n1\n-\n           DBC can use system subpools for communication between tasks\n           and request block levels. Thus a typical session to debug\n           changes in GPSMOPEN would start out as follows (human input\n           in lower case, program response in upper case):\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n                                      - 17 -\n1\n-\n            apf dbccall iebgener\n            DBC830I DBC V4.3 ENTERED PRIVILEGED UNDER RB#3 FROM TCB#5\n            DBC831I THE ERROR LEVEL AND RETRY LEVEL ENVIRONMENTS ARE\n           THE SAME\n            DBC841I DEAD MSG 454 *** TO START PROGRAM EXECUTION, TYPE\n           GO ***\n            DBC\n            load gpsmopen; map gpsmopen gilbert.gpsam.load; set q\n           gpsmopen\n            NAME      TCB#  RB#  LOCATION  COUNT  ATTRIBUTES\n            IEBGENER  5     1    DBCCALL   2      3D02, RENT, REUS,\n           MINOR, NOXTL\n            GPSMOPEN  5          JPA KEY0  1      3122, RENT, REUS\n            IEBGENER  5          JPA       1      0322\n            MAPPING GPSMOPEN FROM GILBERT.GPSAM.LOAD\n            MAPPING GPSMOPEN.GPSMOPEN\n            DEFAULT MODULE NAME IS GPSMOPEN\n            DEFAULT  CSECT NAME IS GPSMOPEN\n            DBC\n            zap .flagword=80\n            DBC\n            go\n            DATA SET UTILITY - GENERATE\n            /*\n            DBC830I DBC V4.3 ENTERED PRIVILEGED UNDER RB#6 FROM TCB#5\n            DBC831I THE ERROR LEVEL AND RETRY LEVEL ENVIRONMENTS ARE\n           THE SAME\n            DBC841I DEAD MSG 1\n            DBC\n            dmap .ssob;dm .ifgacb;dm .gpsmparm\n            MAPPING SSOB FROM GILBERT.GPSAM.LOAD(GPSMOPEN)\n            MAPPING IFGACB FROM GILBERT.GPSAM.LOAD(GPSMOPEN)\n            MAPPING GPSMPARM FROM GILBERT.GPSAM.LOAD(GPSMOPEN)\n            DBC\n            format\n            0B85C2  ---  GPSMOPEN.GPSMOPEN+00006A\n            0B85C2                   EN1@1    EQU   *\n            0B85C2  5830 2010        EL1@1    L     R3,10(,R2)\n            0B85C6  5840 300C                 L     R4,C(,R3)\n            0B85CA  5850 4018                 L     R5,18(,R4)\n            0B85CE  5830 3008                 L     R3,8(,R3)\n            DBC\n            list rbs\n            RB#  TYPE   CREATED BY   NAME          CURRENT EXECUTION\n           LOCATION\n            1    PRB    ATTACH       IEBGENER      IEBGENER.X#1+0001F2\n            2    SVRB   SVC  19      OPEN          IFG019RA+0009FA\n            3    PRB    SYNCH                      IEBGENER.X#1+00039A\n            4    SVRB   SVC  19      OPEN          IGG0199G+0000C4\n            5    SVRB   SVC  22      OPEN-J        COMMON+18E896\n            6    PRB    SYNCH                      GPSMOPEN+000064\n            7    SVRB   #DIE TRAP    ABEND-0C1     IGC0001C.X#1+001F58\n            8    PRB    SYNCH                      DBC+00E58E (RETRY\n           LEVEL)\n0                                     - 18 -\n1\n-\n           and so on setting breakpoints, single stepping through code,\n           and displaying formatted system control blocks. The entire\n           GPSAM package was written by one person in one week using\n           DBC; without the debugging package it might never have been\n           written.\n-\n                            12.  FUTURES AND RESEARCH\n+                           12.  FUTURES AND RESEARCH\n0             This first version of GPSAM demonstrates 1) that the\n           thing is workable, 2) that there is very little code\n           involved, and 3) that it can be turned over to \"end users\"\n           with full system integrity. It gives everyone a thing to\n           play with, and does so little that it can do nothing wrong.\n           That is not the same thing, however, as providing all the\n           desirable function.\n0             One of the things I feel bad about is that there is no\n           subsystem specific default DCB information. JES does that at\n           allocation time, but in this system it must be done at OPEN\n           time and I am not sure if that is too late and what must be\n           done to carry it off. This is a topic for research.\n0             The application program can open an ACB to talk to the\n           subsystem directly. This would allow simulation of all forms\n           of RPL requests (keyed VSAM, RBA VSAM, VTAM, etc.).  One\n           question which is not clear is how much of the ACB must be\n           filled in to carry this off. PLIX will ABEND with an OC4 if\n           you open a file which claims to be VSAM to a SUBSYS dataset.\n           It is clear that VSAM is looking in the ACB for other\n           pointers (to the AMB?) but there is no clear documentation\n           on the fields which must be faked in order to allow the OPEN\n           to be accepted. This is also a research project.\n-\n-\n-\n-\n-\n-\n-\n                                      - 19 -\n1\n-\n                                 HAL (Version 2)\n0                     Structured Macros for 370 and Series/1\n0                              Yale Computer Center\n-\n-             The Handy Assembler Language (HAL) macros provide support\n           for structured programming techniques in IBM assembler\n           language coding. There are other macro systems for this\n           purpose, but HAL has some advantages:\n0             \u00ae HAL is a single maclib member included at the beginning\n                of an assembly with the COPY statement and therefore\n                looks to the assembler as \"inline\" macros. Thus the HAL\n                macros avoid any name conflicts with other MACLIB\n                members with the same names.\n0             \u00ae HAL is not copyrighted or proprietary in any way. You\n                can therefore use it to write your own programs and can\n                freely distribute it to anyone. Most other structured\n                macro systems are tied to some kind of program product.\n0             \u00ae HAL is available in two versions, one for IBM\n                370/303x/4300 computers and one for the GSD Series/1\n                minicomputer.  Furthermore, it is probably possible to\n                extend HAL to any other computer system with a standard\n                IBM-like assembler.\n0             Note that we are not going to claim among its advantages\n           that HAL is the \"best\" structured programming macro system\n           which can be developed. That is a subjective judgement which\n           simply is not worth arguing over. HAL works. We have found\n           it to be very valuable in our own coding projects.  People\n           who are more interested in programming languages than in\n           programming itself will probably not like HAL.  People who\n           understand the requirements of serious software production\n           may prefer this usable simple little system over more\n           technically virtuous but less practically usable macro and\n           preprocessor alternatives.\n0             There are three objectives of HAL. First, it makes\n           complicated software easier to program. Secondly, it reduces\n           the probability of certain kinds of logical errors by\n           encouraging more careful program design and by providing\n           programming structures which more closely resemble the\n           origninal design constructs. Finally, a program written in\n           HAL is easier to read than one written in unstructured\n           assembly, making subsequent maintenance easier and more\n           reliable.\n-                                     - 1 -\n1\n-\n              The reader is assumed to be familiar with assembler\n           language and with the common higher level language\n           structures \"IF-THEN-ELSE\", \"DO WHILE\", \"LEAVE blockname\",\n           and so on. The syntax of the various HAL statements will be\n           comprehensively documented below, but most programmers will\n           have little difficulty in following some simple examples\n           first which will provide a better view into the HAL concepts\n           and the programming structures which can be built using the\n           macros.\n0             There have been experiments in several places with the\n           use of assembler source indentation to represent the block\n+                           ______\n           structure of certain programs. The results appear favorable\n           to simple numeric computations or string handling and\n           lexical routines, but are quite unsatisfactory when applied\n           to system programming with extensive use of operating system\n           macro calls, much larger program modules, and more extensive\n           commenting requirements. HAL was originally designed to be\n           fairly readable without any indentation at all. Subsequently\n           we built a small formatting program to take the HAL source\n           in its 80 column card image file and expand it across a 132\n           column printer page with proper indentation and pagination.\n           There are two versions of this formatting program. The 370\n           version is itself written in 370 HAL. The Series/1 version\n           is written in the EDX native language.  We have found that\n           the best technique of program development is to use the\n           HALFMT listing output to highlight and summarize overall\n           program structure while using the assembler listing to get\n           offset information in DSECTS and executable code for\n           interactive debugging and to get symbol usage\n           crossreferences.\n0             A program written in HAL is divided up into blocks. Each\n           block begins with one of the HAL structure macros and ends\n           with the common block end macro BEND.\n0             The BLOCK block:\n                    name      BLOCK ,\n                              ...\n                              BEND  name\n0             The simple IF block:\n                    \u00ddname\u00a8    IF    (logical test),THEN\n                              ...\n                              BEND  \u00ddname\u00a8\n0             The IF-ELSE block:\n                    \u00ddname\u00a8    IF    (logical test),THEN\n                              \u00ddtrue code\u00a8\n                              ELSE  ,\n                              \u00ddfalse code\u00a8\n                              BEND  \u00ddname\u00a8\n-\n                                      - 2 -\n1\n-\n              The unconditional DO loop:\n                    name      DO    INF\n                              ...\n                              LEAVE name,IF,(logical expression)\n                              ...\n                              BEND  name\n0             The conditional DO loop:\n                    name      DO    UNTIL|WHILE,(logical expression)\n                              ...\n                              BEND  name\n0             The multiple choice (\"case\" or \"select\"):\n                    name      IF    (logical expression),THEN\n                              \u00ddcase 1 code\u00a8\n                              ELSEIF (logical expression),THEN\n                              \u00ddcase 2 code\u00a8\n                              ....\n                              ELSE  ,\n                              \u00ddall other cases\u00a8\n                              BEND  name\n-             The DO macro introduces a looping program structure. The\n           statements in the block will be executed repeatedly, subject\n           to an exit condition.  In a DO WHILE block a logical\n           expression is evaluated before the first and all subsequent\n           executions of the block and exit is made when the condition\n           evaluates FALSE. In a DO UNTIL block, the logical expression\n           is evaluated after the execution of the block, and exit is\n           made when the condition evaluates as TRUE.  In a DO\n           INFinite, the user must supply his own exit condition either\n           with a LEAVE or EXIT statement (see below) or by the native\n           exceptional condition handling of the operating system (such\n           as the EODAD option for end-of-file processing on the 370).\n0             An IF block contains a THEN clause and optionally an ELSE\n           clause. Subject to a test established in the IF macro, the\n           THEN clause may be executed or control may pass instead to\n           the ELSE clause (or the end of the block if no ELSE clause\n           exists).  The simple IF statement can be generalized to\n           three or more mutually exclusive alternatives with\n           additional ELSEIF clauses between the original IF and the\n           ELSE macro. The logical expressions on the IF and on each\n           ELSEIF will be evaluated in turn, and the first test which\n           evaluates \"true\" will cause the following clause to be\n           executed following which control will be transferred to the\n           BEND location. If a final ELSE is present, the last clause\n           will always be executed if all previous tests have failed.\n           If no ELSE is provided, no clause will be executed if all\n           tests fail.\n-\n0                                     - 3 -\n1\n-\n              A BLOCK macro introduces a simple non-iterative,\n           unconditional block.  It is a similar to the \"DO;\" of PL/I.\n           The existence of the BLOCK does not effect any other macros\n           or scope-of-names and does not produce any executable\n           statements. It can help, however, to organize the program\n           and to clarify the relationships of groups of statements.\n           One use of the BLOCK statement is simply to provide\n           appropriate indentation in the output listing of the HALFMT\n           program. Whenever a particuar range of statements jointly\n           perform a specific function, enclosing them in a BLOCK (and\n           putting a block comment at the front of the BLOCK to state\n           their purpose, assumptions, inputs, and outputs) can be a\n           very effective program commentary tool.  The BLOCK can also\n           be named in a LEAVE statement, providing a structured\n           programming tool to avoid GOTO.  Finally, the BLOCK\n           structure provides a method of reflecting in HAL program\n           structures which derive from other hardware or operating\n           system conventions which are not otherwise supported\n           expicitly in HAL. For example, a loop governed by a\n           branch-on-count or BXLE instruction, an asynchronous exit,\n           or an internal procedure can be enclosed in a HAL block.\n0                             BAL   R14,MYSUB\n                              ...\n                    MYSUB     BLOCK ,\n                              \u00ddsubroutine\u00a8\n                              BR    R14\n                              BEND  MYSUB\n-             A block is given a label from the name field of the\n           BLOCK, DO, or IF macro which begins it. Block labels are\n           optional on innermost blocks.  It is good practice to label\n           anything except a very short IF or DO group.\n0             There is a LEAVE macro which allows one to transfer\n           control out of an enclosing block. LEAVE will usually branch\n           to the statement following the BEND, so used in a THEN or\n           ELSE clause, it will terminate the entire IF block.  There\n           are special considerations for LEAVE when one is in a BLOCK\n           with an \"epilog\".  An epilog is a section of code at the end\n           of a BLOCK block which performs some required cleanup or\n           termination function.  One indicates that an epilog exists\n           by coding \"BLOCK EPILOG=YES\" and one signifies the start of\n           the epilog with an EPILOG macro.\n0             The concept of EPILOG is not part of any common higher\n           level languages, yet we have found that it represents one of\n           the most valuable contributions of HAL to proper structuring\n           of system programs. Often a program will acquire a resource\n           or modify the system in some manner which requires a\n           corresponding cleanup action later in the program. In MVS\n           some examples of common services and their cleanup include\n-                                     - 4 -\n1\n-\n           OPEN-CLOSE, ENQ-DEQ, GETMAIN-FREEMAIN, and balanced uses of\n           SETLOCK, SETFRR, ESTAE, and MODESET.  On the Series/1, an\n           epilog may be appropriate to balance EN and DIS, match IOPK\n           or SEAKR instructions, balance push and pop requests,\n           balance temporary register reassignments with IR, or simply\n           to hold the LMB on a return.  EPILOG provides a program\n           structure which explicitly reflects the altered internal\n           environment of the block and the unfinished business which\n           must be transacted before exit.\n0             A LEAVE statement for a block with an epilog transfers\n           control to the statement following the EPILOG macro.  One\n           cannot LEAVE an outer block from within any BLOCK with an\n           epilog.\n0          PROCESS  BLOCK\n                    ....\n           SPECIAL  BLOCK EPILOG=YES\n                    ....\n                    LEAVE PROCESS   ***\n                    ....\n                    EPILOG SPECIAL\n                    ....\n                    BEND  SPECIAL\n                    BEND  PROCESS\n0          The LEAVE statement marked above is illegal because any\n           attempt to leave block PROCESS at that point would bypass\n           the cleanup in the epilog for inner block SPECIAL.\n0             The DO and IF macros make use of logical expressions to\n           decide if the loop is to iterate again or which clause is to\n           be executed.  All logical expressions have a common syntax\n           which represents a compromise between assembler macro\n           language and common higher level language concepts. The\n           normal simple logical expression consists of an operand,\n           relation, and second operand, optionally followed by a\n           machine instruction which will set the condition code:\n           \"(op1,rel,op3)\" or \"(op1,rel,op3,inst)\".\n0                   (R0,LE,4)\n                    (PGMNAME,EQ,MYPROG,CLC)\n                    (BITFLGS,ON,BIT8)\n0          The relation \"rel\" is used to form a branch or jump\n           condition.  There are arithmetic and bit test relations.\n           Each relation has a positive form (GT) and a negative form\n           (NGT) formed by prefixing the positive relation with the\n           letter \"N\".  The permissible positive relations are:\n0             Arithmetic relations for both systems\n                 EQ, NE, GT, LT, GE, LE\n              Arithmetic 370 relations\n                 H, L, P, N, Z\n0                                     - 5 -\n1\n-\n              Arithmetic Series/1 relations\n                 LLT, LGT, LLE, LGE\n              Bit relations on both systems\n                 ON, OFF, MIX\n              Bit relations on 370\n                 O, Z, M\n0          If the user supplies an explicit condition code setting\n           instruction as the fourth positional parameter of the\n           logical expression sublist, then the macro expands this\n           logical test to:\n0                   370                           Series/1\n0                    inst   op1,op3               inst  op3,op1\n                     Bxx    yyyy                  Jxx   yyyy\n0          where xx is a condition calculated by the relation, and yyyy\n           is the label of a statement block determined by context.\n           Note that the order of the two operands is reversed\n           following the normal Series/1 conventions. The programmer\n           codes the logical expressions the same way for either system\n           and the macro system generates the correct form.\n0                   (R4,LT,XYZDATA)\n0          In a register storage or register literal operation the\n           register should come first.  The condition test is\n           calculated so that the relation reads correctly left to\n           right no matter how the operands are actually ordered.\n           Therefore, the above expression evaluates true if the\n           contents of R4 are less than the contents of the word at\n           storage location XYZDATA.\n0             Assembler macros cannot determine the data types of their\n           arguments, so if the instruction is not explicitly given, an\n           assumption must be made about the operands and the\n           appropriate instruction to use.  The default instructions\n           are determined by examining the relation and the third\n           operand. For arithmetic relations the default operation is:\n0             OP3        Series/1            370\n0             0          CWI  0,op1          LTR  op1,op1\n              number     CWI  op3,op1        CH   op1,=H'op3'\n              symbol     CW   op3,op1        C    op1,op3\n0          For logical relations ON, OFF, and MIX, the Series/1 default\n           is TWI and the 370 default is the TM instruction.\n0             It is possible for the condition code to be set by an\n           arithmetic instruction, but the use of arithmetic\n           instructions in a logical expression is difficult to follow.\n-                                     - 6 -\n1\n-\n           Instead, the user should use the degenerate form of the\n           logical expression which only provide the relation.  If you\n           wish to add a value to a register, then execute some code\n           only if the result is positive, you could do it with a\n           tricky use of the macro system:\n0                             IF    (R4,NP,XYZDATA,A),THEN\n0          Instead, it is better to use the more direct form:\n0                             A     R4,XYZDATA\n                              IF    NP,THEN\n0          which is much easier to read.\n0             Simple relations can be strung together by the logical\n           relations AND and OR. Evaluation of logical expressions\n           occurs from left to right. If the next conjuction is OR and\n           the previous expression was true, a branch is generated to\n           the \"true\" block. If the next conjunction is AND and the\n           previous relation evaluated as false, a branch is generated\n           to the \"false\" block. Otherwise, evaluation continues.\n0                             IF    (R0,EQ,0),OR,(OP,EQ,ENDER,CLC)\n                              DO    WHILE,(XYZFLG,OFF,ENDFLG),AND,\n                                    (XYZDATA,GT,MINDATA),AND,\n                                    (XYZDATA,LT,MAXDATA)\n-             Some note should be made of the statement labels generate\n           by HAL. Every block expands to a STart, ELse, and ENd label.\n           Except for an IF block with an ELSE macro, the EL and EN\n           labels occur together. The first number in the label\n           indicates a level of block nesting.  The second number\n           (following \"@\") is a unique block counter for that nesting\n           level.\n-\n-\n-\n-\n-\n-\n0                                     - 7 -\n1\n-\n                               Macro Syntax Summary\n0          \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |    blabel    |  BLOCK    EPILOG=YES                      |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             The BLOCK macro begins a block of statements. The block\n           ends with the next balancing BEND statement. The primary\n           purpose of a BLOCK is to provide a target for the LEAVE\n           macro. The EPILOG option inhibits one from accidentally\n           LEAVEing the block without executing necessary cleanup\n           operations.  The block label \"blabel\" is syntactically\n           optional, but an unlabelled BLOCK cannot have inner IF or DO\n           blocks and is therefore hardly worth defining.\n-\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |              |  BEND     \u00ddblabel\u00a8                        |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             The BEND statement ends a BLOCK, DO, or IF block of\n           statements. The BEND statement never has a label. The\n           \"blabel\" operand must match the block label on the macro\n           which began the block.\n-\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |    \u00ddlabel\u00a8   |  EPILOG    blabel                         |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             This macro begins the epilog section of a BLOCK\n           EPILOG=YES group of statements. It is illegal in any other\n           kind of block.  The epilog section extends to the BEND which\n           ends the complete block.\n-\n-\n0                                     - 8 -\n1\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |    \u00ddlabel\u00a8   |  LEAVE     blabel\u00dd,IF, exp\u00a8               |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             This macro can be used to exit from a BLOCK, IF, ELSE, or\n           DO block of statements. It usually transfers control to the\n           statement after the BEND which ends the block. In the case\n           of a BLOCK EPILOG=YES where the EPILOG macro has not been\n           encountered, LEAVE branches to the statement after the\n           EPILOG macro.  The \"blabel\" can name an outer block in which\n           the current statement is nested, but the LEAVE macro will\n           not permit the bypassing an EPILOG.  If the \"IF\" clause\n           appears trailed by logical expressions, the transfer out of\n           block will be conditioned by these tests.  On the Series/1,\n           enclosing the block label in parentheses is an indication\n           that the end of the block is too far away to use the \"J\"\n           instructions and a \"B\" transfer is required.\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n                                      - 9 -\n1\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |    \u00ddlabel\u00a8   |  EXIT     \u00ddslabel\u00a8\u00dd,IF, exp\u00a8              |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             One of the important things about structured programming\n           is that it does not have any GOTO statements. Well, here is\n           a GOTO statement in disguise. There are certain programming\n           constructs which cannot be naturally handled by a sparse\n           control structure such as that which HAL affords, so EXIT\n           was added to fill in the gaps. Used properly, EXIT appears\n           in two complimentary forms: one which defines a special\n           condition handling block and one which conditionally\n           transfers control to it. Consider the following \"search\"\n           block construct:\n-              SEARCH    BLOCK ,\n               SCAN      DO    WHILE,(not end-of-chain)\n                         prepare for test\n                         EXIT  FOUND,IF,(entry is good)\n                         prepare for next entry\n                         BEND  SCAN\n                         search failure code\n               FOUND     EXIT\n                         search success code\n                         BEND  SEARCH\n-             The first EXIT macro is the \"verb\" form (exit is used as\n           a verb because it has an object, the positional parameter\n           FOUND).  It is a disguised GOTO and transfers control\n           conditionally to the label FOUND. The HAL macros do no\n           checking on this label, so it can be any valid or invalid\n           symbol. However, if you want to use EXIT in a kosher way,\n           you generate the label with the \"noun\" form of the EXIT\n           macro.  An example of the noun form is given in the second\n           EXIT, which has no operands.  This form should be used only\n           if the current nesting level is a BLOCK statement. The EXIT\n           units should usually be gathered together at the end of the\n           BLOCK just before the BEND, or before the EPILOG if the\n           block has an EPILOG. Each EXIT expands to two statements: an\n           unconditional jump to the BEND and a entry label statement.\n           The only way to get into the EXIT clause is to use the verb\n           form of EXIT to transfer control to this label.\n-\n-\n-\n                                      - 10 -\n1\n-\n               B1        BLOCK EPILOG=YES\n                         (block processing code)\n                         (contains LEAVE B1,\n                          EXIT E1, and EXIT E2 stmts)\n               E1        EXIT  ,\n               E2        EXIT  ,\n                         EPILOG ,\n                         BEND  B1\n0             Note that the code in an EXIT block still transfers\n           control to the EPILOG. The EXIT is in addition to the EPILOG\n           and does not replace it.  On the Series/1, the first\n           positional parameter \"slabel\" can be enclosed in parentheses\n           if the transfer is too far away to use the \"J\" instructions\n           and a \"B\" should be used instead. This include the noun form\n           where\n                name   EXIT   ()\n           is used to introduce an exit unit where the end of the block\n           is still far away.\n-\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |    \u00ddblabel\u00a8  |  IF      exp \u00dd,THEN\u00a8                      |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             This macro begins an IF block. The logical expression is\n           evaluated. If it proves false, control is transferred to the\n           first ELSEIF or ELSE macro in the block if one exists,\n           otherwise control is passed to the statement after the BEND\n           which closes the block.  An optional \"THEN\" can be added\n           after the logical expressions for appearences; it will be\n           ignored.\n0             There are three basic IF constructs. The simple IF-BEND\n           has only one clause block. The IF-ELSE-BEND has two clauses,\n           one if the expression evaluates true, the other if it is\n           false.  The IF-ELSEIF-ELSEIF-...-ELSE-BEND clause has\n           multiple logical tests. First the IF test is evaluated. If\n           true, the code following IF is executed. Otherwise, control\n           passes to the first ELSEIF and its test is evaluated. If it\n           is true, the code following it is executed, otherwise\n           control passes to the second ELSEIF and so on.  the ELSE, if\n           present, will always be executed when all the tests fail.\n-\n-\n                                      - 11 -\n1\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |    \u00ddblabel\u00a8  |  ELSEIF  exp \u00dd,THEN\u00a8                      |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             This macro begins an ELSEIF clause of the IF block.  If\n           the expression evaluates true, this clause will be executed.\n           Otherwise, control passes to the next ELSEIF, or to the\n           ELSE, or the the BEND, whichever comes next.\n-\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |              |  ELSE                                     |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             This macro begins the \"else\" section of an IF block. It\n           is optional in an IF block and illegal in any other context.\n           The ELSE macro cannot have a label since it is part of the\n           containing IF block and should not be branched to directly.\n-\n-\n           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |                                                          |\n           |              |       INF                                 |\n           |    \u00ddblabel\u00a8  |  DO   WHILE  ,exp                         |\n           |              |       UNTIL  ,exp                         |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0             This macro produces a loop. If the INF option is chosen,\n           the loop will be unconditional and must be terminated by\n           executing a LEAVE statement. If the WHILE option is chosen,\n           the expression is evaluated at the beginning of the first\n           and each subsequent iteration of the loop and the loop is\n           exited when the expression evaluates false. If the UNTIL\n           option is chosen, the expression is evaluated before the\n           second and each subsequent iteration of the loop, and exit\n           occurs when the epression evaluates true.\n-\n-\n                                      - 12 -\n1\n-\n                                    HAL Logic\n0             Since HAL is intended to be COPY'd into the beginning of\n           an assembly program, it is designed to be relatively\n           compact.  There is little additional commentary, so the\n           program logic is described here.\n0             All of the global variable symbols and internal macro\n           names begin with the prefix \"YCC\" to avoid naming conflicts.\n           The current block nesting level is maintained in the global\n           symbol &YCCLVL. This is used to index into five global\n           variable symbol arrays:\n0             \u00ae &YCCTYPE is an array of numeric block type codes. The\n                type definitions are:\n                         0 EPILOG\n                         1 BLOCK\n                         2 DO UNTIL\n                         3 DO WHILE\n                         4 IF or ELSEIF\n                         5 other (ELSE or conditional LEAVE test)\n0             \u00ae &YCCBLK# is an numeric array indexed by nesting level\n                containing the current block number within this level.\n                One member of the array is incremented by 1 when a new\n                block is generated. The ST and TS labels are generated\n                with a suffix of &YCCLVL.@&YCCBLK#(&YCCLVL).\n0             \u00ae &YCCEN# is a numeric array identifying the current BEND\n                label. Its elements are equal to &YCCBLK# for every\n                program structure except an ELSEIF where &YCCEN# holds\n                the block number of the original IF.\n0             \u00ae &YCCBLKN contains the name of the block at each nesting\n                level.\n0             \u00ae &YCCEPLG is a logical variable indicating for a BLOCK\n                block if an EPILOG is expected.\n0             Since several macros begin a new block, there is an inner\n           macro YCCPUSH which pushes down the stack, adding 1 to\n           &YCCLVL and incrementing &YCCBLK#(&YCCLVL). All blocks end\n           in a BEND, so the pop logic is processed there.\n0             The logical expression evaluation and instruction\n           generation is performed by inner macro YCCTEST. This macro\n           knows what are the appropriate labels to use if the test\n           comes from an IF, DO UNTIL, DO WHILE, or ELSEIF macro based\n           on the current setting of &YCCTYPE(&YCCLVL).  However, when\n           the request is coming from a conditional LEAVE or EXIT\n           macro, it is necessary for the caller to provide the exit\n           label in the global symbol &YCCGO.\n-\n                                      - 13 -\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DIE": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x00\\x8e\\x00\\x8e\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "GPSAM"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ASCCTLAM": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x00}\\x00}\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 125, "newlines": 125, "modlines": 0, "user": "GPSAM"}, "text": "ACTL     TITLE 'ASCCTLAM - PROBLEM STATE SUBSYSTEM OPEN RTN'\n***************************************************************\n* NAME = ASCCTLAM                                             *\n* DESCRIPTIVE NAME = CONTROL CHARACTER TERMINAL OUTPUT        *\n* (C) COPYRIGHT 1982 YALE COMPUTER CENTER                     *\n* STATUS = VERSION 1 MODIFICATION LEVEL 0                     *\n* SYSTEM = MVS 3.8                                            *\n* ATTRIBUTES = NONE                                           *\n* LINKAGE = FROM GPSMOPEN AT OPEN AND CLOSE                   *\n* NORMAL RETURN =                                             *\n*      GPSMAMEP SET TO GET/PUT ENTRY POINT OF ROUTINE         *\n***************************************************************\n         PRINT OFF\n         COPY  HAL\n         PRINT ON\nASCCTLAM CSECT\n         USING *,R15\n         SAVE  (14,12),,*\n         LR    R10,R15\n         USING ASCCTLAM,R10\n         DROP  R15\n         LR    R2,R1\n         USING AMPARM,R2\n         L     R6,GPSMSSOB        GET SSOB POINTER\n         USING SSOB,R6            NOW CHAIN DOWN TO ACB\nDEBUG1   IF    (FLAGWORD,ON,DEBUG),THEN\n*        ******************************************************\n*        * IF ZAPPED ON, INVOKE THE YALE DEBUGGER             *\n*        ******************************************************\n         LOAD  EP=DBC\n         LR    R3,R0\n         ST    R3,DBCADDR         SAVE ADDRESS FOR PUT/GET\n         ESTAE (R3)\n         #DIE\n         BEND  DEBUG1\n         TITLE 'ASCCTLAM - PROCESS OPEN/CLOSE REQUEST'\nOPENCLOS IF    (SSOBFUNC+1,EQ,SSOBOPEN,CLI),THEN\n*        ******************************************************\n*        * FUNCTION IS OPEN.                                  *\n*        ******************************************************\n         LA    R1,PUTGET\n         ST    R1,GPSMAMEP\n         ELSE  ,\n*        ******************************************************\n*        * THE FUNCTION IS CLOSE                              *\n*        ******************************************************\n         IF    (FLAGWORD,ON,DEBUG),THEN\n         DELETE EP=DBC\n         BEND  ,\n         BEND  OPENCLOS\n         TITLE 'ASCCTLAM - RETURN TO CALLER'\nDEBUG2   IF    (FLAGWORD,ON,DEBUG),THEN\n*        ******************************************************\n*        * CANCEL THE YALE DEBUGGER                           *\n*        ******************************************************\n         ESTAE 0\n         BEND  DEBUG2\nRET      L     R13,4(R13)         BACK TO SAVE1\n         RETURN (14,12),RC=0\n         DROP  ,\n         TITLE 'ASCCTLAM - PUT/GET ROUTINE ENTRY POINT'\n***************************************************************\n* ENTRY = PUTGET                                              *\n* FUNCTION = HANDLE I/O REQUEST TO GPSAM FILE                 *\n* LINKAGE = FROM GET/PUT/NOTE/POINT/ ETC. MACRO               *\n*                                                             *\n*        L     R1,RPL                                         *\n*        LA    R0,FUNCTION                                    *\n*        L     R15,24(R1)         POINT TO ACB                *\n*        L     R15,8(R1)          POINT TO MY ENTRY POINT     *\n*        BALR  R14,R15                                        *\n*                                                             *\n* FUNCTION CODES:                                             *\n*        0     GET                READ LINE ASIS FROM TERM    *\n*        1     PUT                TPUT CONTROL                *\n*       >1                        NOT SUPPORTED               *\n***************************************************************\nPUTGET   BLOCK ,\n         SAVE  (14,12)\n         BALR  R12,0\n         USING *,R12\n         LR    R2,R1              SAVE RPL ADDRESS\n         USING IFGRPL,R2\n         L     R1,RPLAREA         PICK UP BUFFER\n         IF    (R0,EQ,0),THEN     IF ITS A GET\n         LR    R3,R1\n         L     R0,RPLBUFL         GET BUFFER LENGTH\n         TGET  (1),(0),ASIS       READ DATA\n         ST    R1,RPLRLEN\n         IF    (R1,GE,2),AND,     LOOK FOR \"/*\"                        X\n               (0(2,R3),EQ,SLSHSTAR,CLC)\n         MVC   RPLFDBK,EOFCODE\n         ELSE  ,\n         XC    RPLFDBK,RPLFDBK\n         BEND  ,\n         ELSE  ,\n         L     R0,RPLRLEN         GET DATA LENGTH\n         TPUT  (1),(0),CONTROL    TRANSMIT WITHOUT EDIT\n         XC    RPLFDBK,RPLFDBK    CLEAR RETURN CODE\n         BEND  ,\n         LR    R1,R2\n         L     R15,=V(GPSMEXIT)\n         BR    R15\n         BEND  PUTGET\n         TITLE 'ASCCTLAM - CONSTANTS, VARIABLE, AND DSECTS'\nFLAGWORD DC    AL1(0)\nDEBUG    EQU   X'80'\n         DC    3AL1(0)\nDBCADDR  DC    A(*-*)\nEOFCODE  DC    AL1(RPLLOGER,0,RPLEODER)\nSLSHSTAR DC    C'/*'\n         LTORG\n         SPACE 5\nAMPARM   DSECT\nGPSMMPRM DS    A                  POINTER TO MODULE PARM\nGPSMSSOB DS    A                  POINT TO OPEN SSOB\nGPSMAMEP DS    A                  RETURN ACB AM ENTRY POINT\nGPSMSAVA DS    A                  WORD TO SAVE FOR CLOSE\nGPSMDDN  DS    CL8                DDNAME\n         PRINT NOGEN\n         EQUREGS\n         IDARMRCD\n         IFGRPL\n         IEFJSSOB DA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQUREGS": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x00$\\x00$\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "GPSAM"}, "text": "         MACRO\n&LABEL   EQUREGS &L=R,&DO=(0,15,1),&SYM=\n.*--> MACRO: EQUREGS    GENERATE SYMBOLIC REGISTER EQUATES  . . . . . .\n.*                                 JOHN R. MASHEY/JULY'69/PSU 360/67  *\n.*       MACRO FOR SETTING UP SETS OF REGISTER EQUATES.               *\n.*       *** ARGUMENTS ***                                            *\n.*       L=        SYMBOL USED TO BEGIN EQUATES, SUCH AS R, REG,ETC.  *\n.*       DO=       (INITIAL,LIMIT,INCREMENT) WILL SET UP REGISTERS    *\n.*             EQUATED TO THE VALUE AS CONTROLLED BY THE DO PARAMATER.*\n.*             BEHAVES LIKE FORTRAN DO, INCLUDING ABILITY TO LEAVE OUT*\n.*             INCREMENT.                                             *\n.*       SYM=      LIST OF SYMBOLS TO BE CONCATENATED TO L PARM.      *\n.*             LIST WILL SET UP EQUATES INCLUDING SYM VALUES, FOR     *\n.*             FIRST SET OF EQUATES IN LIST, AND WILL THEN SET UP     *\n.*             NUMERIC EQUATES IF DO VALUES EXCEED NUMBER OF ELEMENTS *\n.*             IN SYM OPERAND.  MAY BE OMITTED ENTIRELY.              *\n.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         LCLA  &I,&J,&K            COUNTER,INCREMENT,SYM COUNTER\n         AIF   (N'&DO LT 2).XERROR           NOT ENOUGH ARGUMENTS-ERR\n&K       SETA  1                   INIT\n&I       SETA  &DO(1)              SET TO INITIAL VALUE\n&J       SETA  1                   SET TO DEFAULT VALUE\n         AIF   (N'&DO LT 3).XLOOP            DEFAULT VALUE IS OK\n&J       SETA  &DO(3)              USE VALUE PROVIDED\n.XLOOP   AIF   ('&SYM(&K)' EQ '').XLOOP1     USE NUMBER IF NO SYM VAL\n&L&SYM(&K) EQU &I\n&K       SETA  &K+1      INCREMENT TO GET NEXT SYM OPERAND\n         AGO   .XLOOP2             SKIP OVER NORMAL GENRATION\n.XLOOP1  ANOP\n&L&I     EQU   &I\n.XLOOP2  ANOP\n&I       SETA  &I+&J               ADD INCREMENT TO COUNTER\n         AIF   (&I LE &DO(2)).XLOOP          CONTINUE UNTIL DONE\n         MEXIT\n.XERROR  MNOTE 0,'** ERROR - EQUREGS REQUIRES AT LEAST 2 VALUES IN DO'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GPSAM": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x01/\\x01/\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 303, "newlines": 303, "modlines": 0, "user": "GPSAM"}, "text": "GPSAM    TITLE 'GPSAM - GENERAL PURPOSE SUBSYSTEM ACCESS METHOD'\n***************************************************************\n* NAME = GPSAM                                                *\n* DESCRIPTIVE NAME = GENERAL PURPOSE DD SUBSYS                *\n* (C) COPYRIGHT 1982 YALE COMPUTER CENTER                     *\n* STATUS = VERSION 1 MODIFICATION LEVEL 0                     *\n* SYSTEM = MVS 3.8                                            *\n* ATTRIBUTES = LPA, APF AUTHORIZED, RENT                      *\n* ASSEMBLE: NEEDS HAL MACRO, AMODGEN, AND MAYBE PVTMACS       *\n* LINKEDIT: RENT, ALIAS GPSAMEND                              *\n* DEPENDENCIES =                                              *\n*          \"SSNAME\" VALUE MUST BE VALID SUBSYSTEM NAME        *\n*          MODULE \"GPSMOPEN\" MUST EXIST IN STEPLIB OR LNKLST  *\n*                                                             *\n*  >>>>>    ENVIRONMENTAL IMPACT STATEMENT   <<<<<            *\n*                                                             *\n* THIS ROUTINE DOES VERY LITTLE WORK IN ANY SYSTEM KEY.       *\n* INSTRUCTIONS WHICH MODIFY STORAGE IN ANY SYSTEM KEY         *\n* ARE FLAGGED BY \"KEY N\" IN COL 64. THE ONLY REALLY           *\n* \"DANGEROUS\" STATEMENT IS THE SETTING OF THE SSCVT           *\n* POINTER TO THE SSVT, SINCE THAT CONTROL BLOCK IS            *\n* USED FREQUENTLY AND AN INVALID VALUE COULD CRASH            *\n* THE SYSTEM.                                                 *\n*                                                             *\n* ******* IF THIS ROUTINE IS LOADED INTO COMMON STORAGE *******\n* ******* TEMPORARILY WITH THE MODREP PROGRAM OR SP 1.3 *******\n* ******* LOAD GLOBAL=YES, THE GPSAMEND ENTRY POINT     *******\n* ******* MUST BE CALLED TO UN-INITIALIZE THE SSCVT     *******\n* ******* PRIOR TO DELETING THE MODULE. IF THIS MODULE  *******\n* ******* DISAPPEARS WHILE THE SSCVT STILL POINTS TO IT *******\n* ******* THE SYSTEM COULD CRASH. NORMAL USERS WHO DO   *******\n* ******* NOT TRY TO BE CLEVER BUT USE THE NORMAL IBM   *******\n* ******* METHODS TO INSTALL THIS MODULE IN THE LPA,    *******\n* ******* MLPA, OR FLPA NEED NOT WORRY. THE SYSTEM      *******\n* ******* CANNOT CRASH IN THAT CONFIGURATION. YOU HAVE  *******\n* ******* TO USE OTHER MODS TAPE PROGRAMS TO SCREW UP.  *******\n***************************************************************\n         MACRO\n         TAB   &ORG,&COD\n         ORG   &ORG\n         DC    AL1(&COD)\n         MEND\n         PRINT OFF\n         COPY  HAL\n         PRINT ON\n         TITLE 'GPSAM - INITIALIZE SSCVT/SSVT'\nGPSAM    CSECT\n***************************************************************\n* ENTRY = GPSAMINT                                            *\n* FUNCTION = INITIALIZE SSCVT/SSVT                            *\n* ATTRIBUTES = APF AUTHORIZED, INITIALLY PROBLEM STATE KEY 8  *\n* LINKAGE = JOBSTEP PROGRAM (FROM EXEC CARD)                  *\n* PARAMETERS = NONE                                           *\n* RETURN CODES =                                              *\n*      0 NORMAL RETURN                                        *\n*     12 SUBSYSTEM NAME NOT FOUND                             *\n*     16 THIS MODULE NOT IN COMMON STORAGE                    *\n***************************************************************\nGPSAMINT BLOCK ,\n         SAVE  (14,12)\n         LA    R10,0(R15)\n         USING GPSAMINT,R10\n         LA    R5,SSVT            SAVE SSVT POINTER\nGPSAMGO  BLOCK ,\n*        ******************************************************\n*        * VERIFY THAT WE ARE IN COMMON STORAGE BY CHECKING   *\n*        * PRIVATE AREA START AND STOP ADDRESSES IN PVT.      *\n*        * SEARCH SUBSYSTEM NAMES FOR A MATCH                 *\n*        *                                                    *\n*        * IN THIS BLOCK, R5 MUST NOT BE CHANGED. IT IS       *\n*        *     A(SSVT) IF ENTERED AT GPSAMINT                 *\n*        *     0       IF ENTERED AT GPSAMEND                 *\n*        ******************************************************\n         L     R1,CVTPTR\n         L     R2,CVTPVTP-CVT(,R1)\n         USING PVT,R2\n         SR    R3,R3\n         ICM   R3,B'0110',PVTLPRIV GET BOTTOM OF PRIVATE AREA\n         SR    R4,R4\n         ICM   R4,B'0110',PVTLCSA  AND BOTTOM OF CSA\n         IF    (R10,GT,R3,CR),AND,(R10,LT,R4,CR),THEN\n*        ******************************************************\n*        * THIS MODULE IS IN THE PRIVATE AREA. RETURN WITH    *\n*        * RC=16. OUR SSVT AND SUBSYSTEM ENTRY POINTS MUST    *\n*        * BE IN COMMON STORAGE AND ACCESSABLE FROM ALL       *\n*        * ADDRESS SPACES.                                    *\n*        ******************************************************\n         RETURN (14,12),RC=16     MODULE IN  PRIVATE AREA\n         BEND  ,\n         L     R2,CVTJESCT-CVT(,R1)  ->JES CONTROL TABLE\n         L     R2,JESSSCT-JESCT(,R2) ->FIRST SUBSYSTEM COMM TABLE\n         USING SSCT,R2\nFINDNAME DO    WHILE,(R2,NE,0)    SCAN ALL JESCVT BLOCKS\n*        ******************************************************\n*        * CHAIN FROM ONE SSCVT TO THE NEXT SEARCHING FOR     *\n*        * THE SUBSYSTEM NAME. FALL OUT AND RETURN WITH       *\n*        * RC=12 IF NO NAME IS FOUND                          *\n*        ******************************************************\n         EXIT  SSFOUND,IF,        LOOKING FOR MY NAME                  X\n               (SSCTSNAM,EQ,SSNAME,CLC)\n         L     R2,SSCTSCTA        CHAIN TO NEXT\n         BEND  FINDNAME           AND LOOP\n         RETURN (14,12),RC=12     SUBSYSTEM NOT SYSGENNED\n         BEND  GPSAMGO\nSSFOUND  EXIT  ,\n*        ******************************************************\n*        * SSCVT HAS BEEN FOUND. STORE POINTER TO INTERNAL    *\n*        * SSVT INTO IT INITIALIZING THE SUBSYSTEM FOR        *\n*        * REQUEST CALLS. NOTE THAT NO STARTED TASK WITH      *\n*        * THE SUBSYSTEM NAME IS RUNNING. THE ONLY PART       *\n*        * OF THE SUBSYSTEM IS THIS MODULE IN THE LPA.        *\n*        ******************************************************\n         MODESET KEY=ZERO,MODE=SUP\n         ST    R5,SSCTSSVT                                     KEY 0\n         MODESET KEY=NZERO,MODE=PROB\n         RETURN (14,12),RC=0\n         BEND  GPSAMINT\n         DROP  ,\n         SPACE 5\n***************************************************************\n* ENTRY = GPSAMEND                                            *\n* FUNCTION = DE-INITIALIZE SUBSYSTEM BY ZEROING OUT SSCVT     *\n*            POINTER TO SSVT                                  *\n***************************************************************\n         ENTRY GPSAMEND\nGPSAMEND BLOCK ,\n         USING *,R15\n         SAVE  (14,12)\n         L     R10,BASEADDR\n         USING GPSAMINT,R10\n         DROP  R15\n         SR    R5,R5\n         EXIT  GPSAMGO\n         BEND  GPSAMEND\n         DROP  ,\n         TITLE 'GSPAM - SUBSYSTEM NOOP ROUTINE'\n***************************************************************\n* ENTRY = SSNOOP                                              *\n*              SET RETURN CODE ZERO AND RETURN                *\n*              HANDLES UNALLOCATION, CONVERTER EXIT           *\n***************************************************************\nSSNOOP   BLOCK ,\n         USING SSOB,R1\n         XC    SSOBRETN,SSOBRETN  ZERO SSOB RETURN CODE        KEY 1\n         SR    R15,R15            ZERO R15 RETURN CODE\n         BR    R14                RETURN TO CALLER\n         BEND  SSNOOP\n         DROP  ,\n         TITLE 'GPSAM - SUPERVISOR STATE OPEN/CLOSE STUB'\n***************************************************************\n* ENTRY = SSOPEN                                              *\n* FUNCTION = OPEN AND CLOSE SUBSYS DATASET                    *\n* ATTRIBUTES = SUPERVISOR STATE AND DATA MANAGMENT KEY (5)    *\n*                                                             *\n* MOST OF THE WORK HERE IS DONE IN THE \"CALLRKEY\" BLOCK       *\n* WHERE WE HAVE TEMPORARLY CHANGED BACK TO THE NATIVE         *\n* PROTECT KEY OF THE TASK (USUALLY 8). NO PART OF THIS        *\n* BLOCK OPERATES IN KEY 0.                                    *\n***************************************************************\nSSOPEN   BLOCK ,\n         USING *,R15\n         SAVE  (14,12)\n         L     R10,BASEADDR\n         USING GPSAMINT,R10\n         DROP  R15\n         LR    R2,R1\n         USING SSOB,R2\n         XC    SSOBRETN,SSOBRETN                               KEY 5\n         LR    R11,R13            SAVE REGISTER\n         L     R12,PSATOLD-PSA\n         USING TCB,R12\n         MODESET EXTKEY=TCB,WORKREG=3\n         DROP  R12\nCALLRKEY BLOCK ,\n*        ******************************************************\n*        * THIS BLOCK RUNS IN TASK KEY (NORMALLY 8)           *\n*        * WE GET SOME PAGABLE, NON-FETCH PROTECTED,          *\n*        * TASK KEY, TASK RELATED, UNACCOUNTABLE STORAGE      *\n*        * FOR A PARAMETER BLOCK. THE BLOCK PROVIDES A        *\n*        * WORK AND PARAMETER AREA FOR GPSMOPEN.              *\n*        * WE COULD USE BRANCH ENTRY TO GETMAIN BUT WOULD     *\n*        * HAVE TO CHANGE TO KEY 0 TO DO IT. USING THE        *\n*        * SVC FORM ADDS OVERHEAD, BUT IT IS USEFUL TO BE     *\n*        * STATE TO THE SQUEEMISH POTENTIAL USER THAT NO      *\n*        * PART OF THIS CODE RUNS IN KEY 0 AND SO IT IS       *\n*        * PHYSICALLY IMPOSSIBLE FOR AN ERROR TO CRASH THE    *\n*        * SYSTEM. EVEN IN FREE CODE ONE MUST BE SENSITIVE    *\n*        * TO MARKETING ISSUES!                               *\n*        ******************************************************\n         GETMAIN R,LV=GPSMPLEN,SP=230\n         LR    R13,R1             SAVE UNPROTECTED BLOCK ADDR\n         XC    0(GPSMPLEN,R13),0(R13)\n         USING GPSMPARM,R13\n         ST    R2,GPSMSSOB        PASS SSOB AS PARAMETER\n         L     R3,SSOBINDV        NOW CHAIN TO USEFUL BLOCKS\n         USING SSOBGN,R3\n         L     R4,SSDADEBP\n         USING DEBBASIC,R4               DEB (PROTECTED)\n         L     R5,DEBDCBAD\n         USING IFGACB,R5                 ACB (PROTECTED)\n         IF    (SSOBFUNC+1,EQ,SSOBCLOS,CLI),THEN\n         L     R1,DEBIRBAD        PICK UP SAVED ADDRESS FROM OPEN\n         ST    R1,GPSMSAVA        PASS IT AS A PARAMETER\n         BEND  ,\nCALLRTN  BLOCK ,\n         LOAD  EP=GPSMOPEN        FIND LINKLIB MODULE\n         LR    R15,R0             EP ADDRESS IN R15\n         LA    R1,GPSMSSOB        POINT TO PARAMETER BLOCK\n         SYNCH (R15),RESTORE=YES  CALL ROUTINE IN PBLM STATE\n         DELETE EP=GPSMOPEN       DROP MODULE\n         BEND  CALLRTN\n         LM    R6,R7,GPSMAMEP     PICK UP PARAMETERS PASSED BACK\n         LR    R12,R13            REGISTER 13 INVALID FOR FREEMAIN\n         FREEMAIN R,A=(12),SP=230,LV=GPSMPLEN\n         MODESET EXTKEY=DATAMGT,WORKREG=3\n         DROP  R3\n         BEND  CALLRKEY\n         IF    (SSOBFUNC+1,EQ,SSOBOPEN,CLI),THEN\n         ST    R6,ACBINRTN        SAVE ACCESS METHOD EP        KEY 5\n         ST    R7,DEBIRBAD        SAVE CLOSE PARAMETER ADDR    KEY 5\n         BEND  ,\n         LR    R13,R11\n         RETURN (14,12),RC=0\n         BEND  SSOPEN\n         DROP  ,\n         TITLE 'GPSAM - CONSTANTS'\nSSNAME   DC    CL4'GPSM'          SUBSYSTEM NAME\nBASEADDR DC    A(GPSAMINT)        START OF MODULE\nSSVT     DC    H'0'               BUILTIN SSVT\nSSVTFNUM DC    H'2'               2 FUNCTIONS SUPPORTED\nSSVTFCOD DC    XL256'0'\n         TAB   SSVTFCOD+06,1      FREE\n         TAB   SSVTFCOD+15,2      OPEN\n         TAB   SSVTFCOD+16,2      CLOSE\n         TAB   SSVTFCOD+17,1      CHECKPOINT\n         TAB   SSVTFCOD+18,1      RESTART\n         TAB   SSVTFCOD+37,1      CONVERTER EXIT\n         TAB   SSVTFCOD+38,1      ALLOCATE GROUP\n         ORG\nSSVTFUN1 DC    A(SSNOOP)          POINTER TO NO OP FUNCTION\nSSVTFUN2 DC    A(SSOPEN)          POINTER TO OPEN/CLOSE FUNCTION\n         EQUREGS\n         LTORG\n         TITLE 'GPSAM - DSECTS'\nGPSMPARM DSECT\n         DS    18A                SAVE AREA:ENTRY TO GPSMOPEN\n         DS    18A                SAVE AREA:IN GPSMOPEN\n         DS    CL8                ROOM FOR MODULE NAME\nGPSMMPRM DS    A                  USED BY GPSMOPEN\nGPSMSSOB DS    A                  POINT TO OPEN SSOB\nGPSMAMEP DS    A                  RETURN ACB AM ENTRY POINT\nGPSMSAVA DS    A                  WORD TO SAVE FOR CLOSE\nGPSMDDN  DS    CL8                DDNAME\n         DS    16A                SCRATCH SPACE\nGPSMPLEN EQU   *-GPSMPARM\n         PRINT OFF\n***************************************************************\n* THE MAPPING MACROS BELOW INCLUDE ANYTHING USED OR           *\n* EVEN CONCEIVED OF. MACROS NOT ACTUALLY NEEDED ARE,          *\n* HOWEVER, COMMENTED OUT. THE EXPANSIONS ARE SUPRESSED        *\n* TO SAVE TREES                                               *\n***************************************************************\n         IEFJSCVT\n*        EJECT\n*        IEFJSSWA\n         EJECT\n         IEFJSSIB\n         EJECT\n         IEFJSSOB (AL,DA,CI,AG),CONTIG=NO\n*        EJECT\n*        IEFSSARB\n         EJECT\n         IFGACB\n*        EJECT\n*        IFGRPL\n*        EJECT\n*        IDARMRCD\n*        EJECT\n*        IFGEXLST\n         EJECT\n         IEZDEB LIST=YES\n*        EJECT\n*JFCB    DSECT\n*        IEFJFCBN\n         EJECT\n         IEFJESCT\n         EJECT\n         IHAPSA\n         EJECT\n         IHAPVT\n         EJECT\n         IKJTCB\n*        EJECT\n*        IHARB\n         EJECT\n         CVT   DSECT=YES\n*        EJECT\n*        IHAFRRS\n*        EJECT\n*        IHASDWA\n*        EJECT\n*        IHAWSAVT CLASS=GLOBAL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GPSMDD": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x00\\xb4\\x00\\xb4\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 180, "newlines": 180, "modlines": 0, "user": "GPSAM"}, "text": "DDSS     TITLE 'DDSUBSYS - TSO COMMAND TO ALLOCATE SUBSYS FILE'\n***************************************************************\n* NAME = DDSUBSYS                                             *\n* DESCRIPTIVE NAME = TSO COMMAND TO ALLOCATE SUBSYS FILE      *\n* (C) COPYRIGHT 1982 YALE COMPUTER CENTER                     *\n* STATUS = VERSION 1 MODIFICATION LEVEL 0                     *\n* SYSTEM = MVS 3.8                                            *\n* ATTRIBUTES = NONE                                           *\n* DEPENDENCIES = NONE                                         *\n*                                                             *\n* AUTHOR = HOWARD GILBERT                                     *\n*          YALE COMPUTER CENTER                               *\n*          175 WHITNEY AVE.                                   *\n*          P.O. BOX 2112 YALE STATION                         *\n*          NEW HAVEN, CT 06520                                *\n*          BITNET ADDRESS: GILBERT @ YALEVM                   *\n***************************************************************\n*        COPY  HAL\n         PRINT OFF\n         COPY  HAL\n         PRINT ON\nDDSUBSYS CSECT\n         SAVE  (14,12),,*\n         BALR  R12,0              STANDARD STARTUP STUFF\n         USING *,R12\n         ST    R1,DFCPPLP         SAVE FOR LATER\n         ST    R13,STORAGE+4\n         LA    R13,STORAGE\n         USING CPPL,R1\n         MVC   PPLUPT,CPPLUPT     INITIALIZE PARSE PARAMETERS\n         MVC   PPLECT,CPPLECT\n         MVC   PPLCBUF,CPPLCBUF\n         DROP  R1\n         XC    ECB,ECB\n         XC    PPLUWA,PPLUWA\n         LA    R1,PPL             POINT TO PARM BLOCK\nPARSE    CALLTSSR EP=IKJPARS      PARSE COMMAND\n         L     R9,ANS             PICK UP RESPONSE\n         USING IKJPARMD,R9\nPARSED   LA    R4,PDDN            FIND DDNAME\n         LA    R5,DDNAME+TEXTLEN\nDODDN    BAL   R14,MOVEDATA       MOVE DDNAME FROM PARSE TO TEXT\n         LA    R4,PMODNAM         FIND MODULE NAME IN PARSE\n         LA    R5,MODULE+TEXTLEN\nDOMODN   BAL   R14,MOVEDATA       MOVE MODULE TO TEXT\n         LH    R0,PPARM+4\n         IF    (R0,NE,0),THEN\n         LA    R4,PPARM           ADVANCE TO PARAMETER\nDOPARM   BAL   R14,MOVEDATA       MOVE PARAMETER TO TEXT\n         ELSE  ,\n         MVC   MODULE+COUNT,ONE   ONLY MODULE, NO PARAMETER\n         BEND  ,\n         LH    R1,PRECFM\nDORECFM  IF    (R1,EQ,1),THEN\n         MVI   RECFM+TEXTDATA,RECFMF\n         ELSEIF (R1,EQ,2),THEN\n         MVI   RECFM+TEXTDATA,RECFMV\n         ELSEIF (R1,EQ,3),THEN\n         MVI   RECFM+TEXTDATA,RECFMU\n         ELSE  ,\n         MVC   RECFM(2),NOTEXT\n         BEND  DORECFM\nDOLRECL  L     R15,PLRECL\n         IF    (R15,NE,0),THEN\n         L     R15,0(R15)\n         STH   R15,LRECL+TEXTDATA\n         IF    (R1,EQ,2),THEN\n         LA    R15,4(R15)\n         BEND  ,\n         STH   R15,BLKSIZE+TEXTDATA\n         ELSE  ,\n         MVC   LRECL(2),NOTEXT\n         MVC   BLKSIZE(2),NOTEXT\n         BEND  ,\nALLOCATE LA    R1,PARMLIST\n         SVC   99                 ALLOCATE SUBSYS DATASET\n         IF    (R15,NE,0),THEN\n         IF    (ERRCODE,EQ,NOGEN,CLC),THEN\n         TPUT  GENMSG,LGENMSG\n         ELSEIF (ERRCODE,EQ,NORUN,CLC),THEN\n         TPUT  RUNMSG,LRUNMSG\n         ELSE  ,\n         ST    R15,S99RETC\n         LA    R1,DFDAPLP\n         LINK  EP=IKJEFF18\n         BEND  ,\n         BEND  ,\nRETURN   L     R13,4(R13)         CHAIN BACK TO OLD SAVE AREA\n         RETURN (14,12),RC=(15)\nMOVEDATA L     R2,0(R4)           GET USER RESPONSE DATA\n         LH    R3,4(R4)           GET LENGTH\n         STH   R3,0(R5)           SAVE LENGTH IN TEXT\n         BCTR  R3,0               LESS 1 FOR MOVE\n         EX    R3,MOVER           MOVE DATA\n         AR    R5,R3              POINT AFTER END OF DATA\n         LA    R5,3(R5)\n         BR    R14\nMOVER    MVC   2(*-*,R5),0(R2)\nPARSPARM IKJPARM\nPDDN     IKJIDENT 'DDNAME',OTHER=ALPHANUM,MAXLNTH=8,PROMPT='DDNAME'\nPMODNAM  IKJIDENT 'MODULE',OTHER=ALPHANUM,MAXLNTH=8,PROMPT='MODULE'\nPPARM    IKJPOSIT QSTRING,DEFAULT=''''''\nFORMAT   IKJKEYWD\n         IKJNAME 'RECFM',SUBFLD=RECFMS\nBLOCK    IKJKEYWD\n         IKJNAME 'LRECL',SUBFLD=LRECLS\nRECFMS   IKJSUBF\nPRECFM   IKJKEYWD\n         IKJNAME 'F'\n         IKJNAME 'V'\n         IKJNAME 'U'\nLRECLS   IKJSUBF\nPLRECL   IKJIDENT 'NUMBER',FIRST=NUMERIC,OTHER=NUMERIC,INTEG\n         IKJENDP\nRUNMSG   DC    C'THE GPSM SUBSYSTEM HAS NOT BEEN STARTED'\nLRUNMSG  EQU   *-RUNMSG\nGENMSG   DC    C'THE GPSM SUBSYSTEM IS NOT DEFINED'\nLGENMSG  EQU   *-GENMSG\n         DS    0F\nPARMLIST DC    AL1(X'80'),AL3(VERBBLK)\nVERBBLK  DC    X'14010000'\nERRCODE  DC    H'0'\nINFOCODE DC    H'0'\n         DC    A(TEXTPTR)\n         DC    2A(0)\nTEXTPTR  DC    A(DDNAME)\n         DC    A(SUBSYS)\n         DC    A(MODULE)\n         DC    A(PERM)\n         DC    A(RECFM)\n         DC    A(LRECL)\n         DC    A(BLKSIZE)\n         DC    A(BUFNO)\n         DC    X'80000000'\nDDNAME   DC    X'0001',H'1',H'6',CL8'SYSUT2'\nSUBSYS   DC    X'005F',H'1',H'4',CL4'GPSM'\nMODULE   DC    X'0060',H'2',H'8',CL8'TESTINGS'\n         DC    H'128',CL128' '\nPERM     DC    X'0052',H'0'\nRECFM    DC    X'0049',H'1',H'1',H'0'\nLRECL    DC    X'0042',H'1',H'2',H'0'\nBLKSIZE  DC    X'0030',H'1',H'2',H'0'\nBUFNO    DC    X'0034',H'1',H'1',X'0100'\nCOUNT    EQU   2\nTEXTLEN  EQU   4\nTEXTDATA EQU   6\nRECFMF   EQU   X'80'\nRECFMV   EQU   X'40'\nRECFMU   EQU   X'C0'\nNOTEXT   DC    H'0'               FLAG TO SKIP THIS TEXT ITEM\nONE      DC    H'1'\nDFDAPLP  DC    A(VERBBLK)\nDFRCP    DC    A(S99RETC)\nDFJEFF02 DC    A(ZERO)\nDFIDP    DC    A(DFFLAGS)\nDFCPPLP  DC    A(*-*)\nDFBUFP   DC    A(0)\nS99RETC  DC    A(*-*)\nZERO     DC    A(0)\nDFFLAGS  DC    X'0032'\nNOGEN    DC    X'04B0'\nNORUN    DC    X'04AC'\nSTORAGE  DS    18A\nDSASECT  EQU   *\nPPL      DS    0A\nPPLUPT   DS    A              A(USER PROFILE TABLE)\nPPLECT   DS    A              A(ENVIRONMENT CONTROL TABLE)\nPPLECB   DC    A(ECB)         A(EVENT CONTROL BLOCK)\nPPLPCL   DC    V(PARSPARM)    A(PARAMETER CONTROL LIST)\nPPLANS   DC    A(ANS)         A(PARAMETER DESCRIPTOR LIST)\nPPLCBUF  DS    A              A(COMMAND BUFFER)\nPPLUWA   DS    A              A(WORKAREA)\nARGL     DS    A\nECB      DS    A\nANS      DS    A\n         LTORG\n         EQUREGS\n         IKJCPPL\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GPSMOPEN": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x00\\xe4\\x00\\xe4\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 228, "newlines": 228, "modlines": 0, "user": "GPSAM"}, "text": "GPSM     TITLE 'GPSMOPEN - PROBLEM STATE SUBSYSTEM OPEN RTN'\n***************************************************************\n* NAME = GPSMOPEN                                             *\n* DESCRIPTIVE NAME = PROBLEM STATE OPEN EXECUTOR              *\n* (C) COPYRIGHT 1982 YALE COMPUTER CENTER                     *\n* STATUS = VERSION 1 MODIFICATION LEVEL 0                     *\n* SYSTEM = MVS 3.8                                            *\n* ATTRIBUTES = NONE                                           *\n* LINKAGE = FROM GPSAM OPEN ROUTINE VIA SYNCH MACRO           *\n* NORMAL RETURN =                                             *\n*      GPSMAMEP SET TO GET/PUT ENTRY POINT OF ROUTINE         *\n* ERROR RETURN =                                              *\n*      ABEND U306 IF AUTHORIZATION FAILURE                    *\n* ASSEMBLE: NEEDS HAL MACRO, AMODGEN, AND MAYBE PVTMACS       *\n* LINKEDIT: MUST GO INTO AN APF LIBRARY. SHOULD NOT BE AC=1   *\n*                                                             *\n* AUTHOR = HOWARD GILBERT                                     *\n*          YALE COMPUTER CENTER                               *\n*          175 WHITNEY AVE.                                   *\n*          P.O. BOX 2112 YALE STATION                         *\n*          NEW HAVEN, CT 06520                                *\n*          BITNET ADDRESS: GILBERT @ YALEVM                   *\n*                                                             *\n* THIS PROGRAM SEARCHES THE PARAMETERS PASSED TO THE          *\n* SUBSYSTEM AS PART OF THE USER ALLOCATION:                   *\n*                                                             *\n*    //DDNAME DD SUBSYS=(GPSM,MODNAME,'...')                  *\n*                                                             *\n* THE FIRST PARAMETER MUST BE A MODULE NAME. THE NAMED        *\n* MODULE IS LOAD FROM THE SYSTEM OR USER LIBRARY TO DO        *\n* THE WORK. THE SECOND PARAMETER IS PASSED TO THE MODULE      *\n* AS PART OF THE R1 LINKAGE.                                  *\n*                                                             *\n* NOTE: SINCE THE PARM FIELDS OF THE SUBSYS KEYWORD ARE       *\n* NOT PART OF THE FORMAL PARAMETER INTERFACE, THIS MODULE     *\n* MUST HUNT THEM UP. IT IS THEREFORE DEPENDENT ON THE         *\n* FACT THAT THE JFCB WHICH IS PASSED AS A FORMAL PARAMETER    *\n* THROUGH THE INTERFACE IS IN FACT IMBEDDED IN THE O/C/E      *\n* WORK AREA MAPPED BY THE IECDSECT MACRO. THIS IS LIKELY      *\n* TO REMAIN TRUE FOREVER, BUT IT IS NOT A DOCUMENTED ELEMENT  *\n* OF THE SUBSYSTEM INTERFACE LINKAGE.                         *\n***************************************************************\n         PRINT OFF\n         COPY  HAL\n         PRINT ON\nGPSMOPEN CSECT\n         USING *,R15\n         SAVE  (14,12),,*\n         LR    R10,R15\n         USING GPSMOPEN,R10\n         DROP  R15\n         USING GPSMPARM,R13\n         ST    R13,SAVE2+4        ESTABLISH BACKCHAIN\n         LA    R13,SAVE2\n         USING SAVE2,R13\n         L     R2,GPSMSSOB        GET SSOB POINTER\n         USING SSOB,R2            NOW CHAIN DOWN TO ACB\nDEBUG1   IF    (FLAGWORD,ON,DEBUG),THEN\n*        ******************************************************\n*        * IF ZAPPED ON, INVOKE THE YALE DEBUGGER             *\n*        ******************************************************\n         LOAD  EP=DBC\n         LR    R3,R0\n         XC    ESTAEL(24),ESTAEL\n         ESTAE (R3),MF=(E,ESTAEL)\n         #DIE\n         BEND  DEBUG1\n         TITLE 'GPSMOPEN - FIND DATASET CONTROL BLOCKS'\n*        ******************************************************\n*        * LOAD UP A BUNCH OF USEFUL REGISTERS                *\n*        ******************************************************\n         L     R3,SSOBINDV\n         USING SSOBGN,R3\n         L     R4,SSDADEBP\n         USING DEBBASIC,R4\n         L     R5,DEBDCBAD\n         USING IFGACB,R5\n         L     R3,SSDAJFCB\n*        ******************************************************\n*        * THE JFCB WHICH I AM PASSED CONTAINS NO USEFUL      *\n*        * INFORMATION. HOWEVER, ELSEWHERE IN THE O/C/E       *\n*        * WORKAREA THERE IS A POINTER TO THE DSAB AND        *\n*        * FROM THERE I CAN FIND GOOD STUFF                   *\n*        ******************************************************\n         USING DXJBF,R3\n         L     R6,DXDSAB\n         ICM   R6,B'0111',DSABSSVA-DSAB(R6)\n         USING INDMSIOT-16,R6\n         MVC   GPSMDDN,SCTDDNAM   PICK UP DDNAME\n         ICM   R6,B'0111',SIOTSSWA\n         USING SSWA-16,R6         SSWA CONTAINS SUBSYS PARMS\nGETPARMS BLOCK ,\n         LH    R15,SSWAPRNO       GET NUMBER OF PARMS\n         LEAVE GETPARMS,IF,(R15,LT,1) GOTTA HAVE MODULE NAME\n         SR    R1,R1\n         IC    R1,SSWAPLEN        LENGTH OF FIRST PARM\n         LEAVE GETPARMS,IF,(R1,GT,8),OR,(R1,EQ,0)\n         BCTR  R1,0               LESS ONE FOR MOVE\n         MVI   MODNAME,C' '\n         MVC   MODNAME+1(7),MODNAME\n         EX    R1,MOVEMODN\nDOPARM   IF    (R15,GT,1),THEN    IF MODULE GETS PARM STRING\n         LA    R14,SSWAPVAL+1(R1) POINT PAST MODULE NAME\n         ST    R14,GPSMMPRM       SAVE PARM POINTER\n         BEND  DOPARM\n         LEAVE GETPARMS\nMOVEMODN MVC   MODNAME(*-*),SSWAPVAL  EXECUTED INSTRUCTION\n         DROP  R6\n         BEND  GETPARMS\n         TITLE 'GPSMOPEN - PROCESS OPEN REQUEST'\nOPENCLOS IF    (SSOBFUNC+1,EQ,SSOBOPEN,CLI),THEN\n*        ******************************************************\n*        * FUNCTION IS OPEN.                                  *\n*        ******************************************************\nAUTHCHEK BLOCK ,\n*        ******************************************************\n*        * WHEN WE DO THE LOAD WE WILL BE IN PROBLEM STATE    *\n*        * AND PROBLEM PROTECT KEY. THE LOAD WILL THEREFORE   *\n*        * BE PERMITTED TO FETCH MODULES FROM AN UNAUTHORIZED *\n*        * USER STEPLIB AS LONG AS THE JOBSTEP IS NOT APF     *\n*        * AUTHORIZED. TO AVOID MVS INTEGRITY PROBLEMS, WE    *\n*        * ADOPT A SIMPLE RULE:                               *\n*        *                                                    *\n*        *  1) IF WE ARE APF AUTHORIZED, THE MODULE MUST      *\n*        *     COME FROM AN APF LIBRARY (LOAD MACRO CHECKS    *\n*        *     THIS AUTOMATICALLY) AND MUST BE IN A TABLE     *\n*        *     PROVIDED BELOW.                                *\n*        *                                                    *\n*        *  2) IF WE ARE NOT AUTHORIZED, THE MODULE CAN COME  *\n*        *     FROM ANY STEPLIB.                              *\n*        *                                                    *\n*        *  3) THE USE OF GPSM IS PROHIBITED IF THE PROGRAM   *\n*        *     OPENING THE DATASET IS AUTHORIZED (IN          *\n*        *     SUPERVISOR STATE OR SYSTEM KEY) WHILE THE      *\n*        *     JOB STEP IS UNAUTHORIZED. THIS PREVENTS        *\n*        *     EXPOSURES IF AN UNAUTHORIZED GPSM MODULE WERE  *\n*        *     PASSED TO SYSUDUMP WHICH IS OPENED BY AN SVC.  *\n*        ******************************************************\n         L     R6,PSATOLD-PSA     -> TCB\n         USING TCB,R6\n         L     R7,TCBJSCB         APF AUTHORIZATION IS A BIT\n         USING IEZJSCB,R7         IN THE JSCB\nAPF      IF    (JSCBOPTS,ON,JSCBAUTH),THEN  APF AUTHORIZED\n         LA    R7,APFNAMES\n         DO    WHILE,(0(R7),NE,0,CLI)\n         LEAVE AUTHCHEK,IF,(MODNAME,EQ,0(R7),CLC)\n         LA    R7,8(R7)           NEXT NAME\n         BEND  ,\nAUTHFAIL WTO   'GPSM001 - OPEN FAILED, AUTHORIZATION RESTRICTION'\n         ABEND 306\n         BEND  APF\n         L     R7,TCBRBP          -> CURRENT RB (PRB FROM SYNCH)\n         USING RBBASIC,R7\n         L     R7,RBLINK          -> SVRB FROM OPEN TYPE=J\n         L     R7,RBLINK          -> SVRB FROM OPEN\n         L     R7,RBLINK          -> OPENER'S RB\n         EXIT  AUTHFAIL,IF,       QUIT IF AUTHORIZED CALLER BUT        X\n               (RBOPSWB2,NON,X'81') JOBSTEP IS NOT APF\n         DROP  R7\n         BEND  AUTHCHEK\n         LOAD  EPLOC=MODNAME      LET IT 806 ABEND IF NAME BAD\n         ST    R0,GPSMSAVA\n         LA    R1,GPSMMPRM\n         LR    R15,R0\n         BALR  R14,R15\n         TITLE 'GPSMOPEN - PROCESS THE CLOSE REQUEST'\n         ELSE  ,\n*        ******************************************************\n*        * THE FUNCTION IS CLOSE                              *\n*        ******************************************************\n         L     R15,GPSMSAVA\n         LA    R1,GPSMMPRM\n         BALR  R14,R15\n         DELETE EPLOC=MODNAME\n         BEND  OPENCLOS\n         TITLE 'GPSMOPEN - RETURN TO CALLER'\nDEBUG2   IF    (FLAGWORD,ON,DEBUG),THEN\n*        ******************************************************\n*        * CANCEL THE YALE DEBUGGER                           *\n*        ******************************************************\n         ESTAE 0\n         DELETE EP=DBC\n         BEND  DEBUG2\nRET      L     R13,4(R13)         BACK TO SAVE1\n         RETURN (14,12),RC=0\n         TITLE 'GPSMOPEN - CONSTANTS, VARIABLE, AND DSECTS'\nFLAGWORD DC    AL1(0)\nDEBUG    EQU   X'80'\n         DC    3AL1(0)\nAPFNAMES DC    5XL8'00'           AUTHORIZED AM MODULES\n         LTORG\n         SPACE 5\nGPSMPARM DSECT\nSAVE1    DS    18A                R13 SAVE AREA\nSAVE2    DS    18A                ANOTHER ONE FOR MY USE\nMODNAME  DS    CL8                MODULE NAME BUILD AREA\nGPSMMPRM DS    A                  POINTER TO MODULE PARM\nGPSMSSOB DS    A                  POINT TO OPEN SSOB\nGPSMAMEP DS    A                  RETURN ACB AM ENTRY POINT\nGPSMSAVA DS    A                  WORD TO SAVE FOR CLOSE\nGPSMDDN  DS    CL8                DDNAME\nESTAEL   DS    16A                ESTAE WORK AREA\n         PRINT NOGEN\n         EQUREGS\n         IEFJSSWA\n         EJECT\n         IEFJSSOB DA\n         EJECT\n         IFGACB\n         EJECT\n         IEZDEB LIST=YES\n         EJECT\n         IKJTCB\n         EJECT\n         IHARB\n         EJECT\n         IEZJSCB\n         EJECT\n         IHAPSA\n         EJECT\n         IHADSAB\n         EJECT\nSIOT     DSECT\n         IEFASIOT\n         EJECT\nFORCORE  DSECT\n         IECDSECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GPSMSUBS": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x00S\\x00S\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "GPSAM"}, "text": "GPSM     TITLE 'GPSMSUBS - GPSM SUBROUTINES'\n***************************************************************\n* NAME = GPSMSUBS                                             *\n* DESCRIPTIVE NAME = GPSM ACCESS METHOD COMMON SUBROUTINES    *\n* (C) COPYRIGHT 1982 YALE COMPUTER CENTER                     *\n* STATUS = VERSION 1 MODIFICATION LEVEL 0                     *\n* SYSTEM = MVS 3.8                                            *\n***************************************************************\n*        COPY  HAL\n         PRINT OFF\n         COPY  HAL\n         PRINT ON\n         TITLE 'GPSMEXIT - RETURN OR CALL ACB EXIT ROUTINE'\n***************************************************************\n* ENTRY =GPSMEXIT                                             *\n* FUNCTION = RETURN TO CALLER OR TO ACB EXIT ROUTINE          *\n* LINKAGE = FROM ACCESS METHOD ROUTINE BY BRANCH              *\n*      R13 MUST POINT TO SAVE AREA                            *\n*      R1 MUST POINT TO RPL                                   *\n*      RPLFDBK MUST CONTAIN VALID FEEDBACK CODES              *\n***************************************************************\nGPSMSUBS CSECT\n         ENTRY GPSMEXIT\nGPSMEXIT BLOCK ,\n         BALR  R12,0\n         USING *,R12\n         LR    R6,R1\n         USING IFGRPL,R6          SAVE RPL PTR\n         L     R7,RPLDACB         FIND ACB\n         USING IFGACB,R7\n         MVI   RPLCMPON,2         SET COMPONENT ID.\n         IF    (RPLOPT1,ON,RPLECBSW)\n         L     R1,RPLECB          POINT TO EXTERNAL ECB.\n         ELSE\n         LA    R1,RPLECB          ASSUME INTERNAL ECB.\n         BEND  ,\n         MVI   0(R1),X'40'        \"POST\" ECB FOR THIS I/O\n         SR    R8,R8              START WITH 0 RETURN CODE\nTAKEEXIT IF    (RPLFDBK,NE,0,CLI) IF ANY ERRORS\n         LA    R8,8               SET ERROR RETURN CODE\n         L     R4,ACBEXLST        POINT TO ACB'S EXIT LIST.\n         LEAVE TAKEEXIT,IF,       THERE'S NO EXIT LIST.                X\n               (R4,LT,1)\n         USING IFGEXLST,R4        SET EXLST ADDRESSABILITY.\n         LEAVE TAKEEXIT,IF,(EXLID,NE,EXLIDD,CLI) BAD ID\n         IF    (RPLRTNCD,EQ,RPLLOGER,CLI),THEN\n         IF    (RPLERRCD,EQ,RPLEODER,CLI),THEN\n         LA    R2,EXLEODF         POINT TO EOD ENTRY.\n         LA    R3,EXLEODL         GET MIN LENGTH FOR IT.\n         ELSE  ,\n         LA    R2,EXLLERF         POINT TO LOGICAL ERROR ENTRY.\n         LA    R3,EXLLERL         GET MIN LENGTH FOR IT.\n         BEND  ,\n         ELSE  ,\n         LA    R2,EXLSYNF         POINT TO PHYSICAL ERROR ENTRY.\n         LA    R3,EXLSYNL         GET MIN LENGTH FOR IT.\n         BEND  ,\n         LEAVE TAKEEXIT,IF,(R3,GT,EXLLEN,CH) NOT LONG ENOUGH\n         USING IFGEXLEF,R2        SET ENTRY ADDRESSABILITY.\n         LEAVE TAKEEXIT,IF,       NOT PRESENT AND ACTIVE               X\n               (EXLFLAG,NON,EXLPRES+EXLACTV)\n         ICM   R0,15,EXLEXITP\n         IF    (EXLFLAG,ON,EXLLINK)\n         LOAD  EPLOC=(0)          ELSE LOAD USER EXIT ROUTINE.\n         STCM  R0,15,EXLEXITP     SAVE FOR NEXT TIME\n         NI    EXLFLAG,255-EXLLINK SHOW ENTRY POINTS TO CODE.\n         BEND  ,\n         LM    R1,R12,24(R13)     RESTORE R1 THROUGH R12.\n         LR    R15,R0             SET R15 = USER EXIT ENTRY PT.\n         BALR  R14,R15            TAKE USER EXIT.\n         BEND  TAKEEXIT           IF USER EXIT RETURNS,\n         LR    R15,R8\n         RETURN (14,12),RC=(15)   RETURN TO PROGRAM\n         BEND  GPSMEXIT\n         TITLE 'GPSMSUBS - CONSTANTS, EQUATES, AND DSECTS'\n         LTORG\n         EQUREGS\n         PRINT NOGEN\n         IFGACB\n         IFGRPL\n         IFGEXLST\n         IDARMRCD\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HAL": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x01\\xc8\\x01\\xc8\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 456, "newlines": 456, "modlines": 0, "user": "GPSAM"}, "text": "***************************************************************\n*                                                             *\n* MODULE NAME = HAL                                           *\n*                                                             *\n* DESCRIPTIVE NAME = STRUCTURED ASSEMBLER MACROS              *\n*                                                             *\n* COPYRIGHT = NONE                                            *\n*                                                             *\n* VERSION = OS/VS/VM ASSEMBLERS                               *\n*                                                             *\n* STATUS = RELEASE 2 LEVEL 0                                  *\n*                                                             *\n* NOTES =                                                     *\n*                                                             *\n*     THESE MACROS ARE INTENDED TO BE COPIED INTO THE         *\n*     BEGINNING OF ASSEMBLIES WHERE THEY ARE TO BE            *\n*     USED. THIS AVOIDS NAMING CONFLICTS WITH OTHER           *\n*     MACROS IN THE SYSTEM LIBRARIES.                         *\n*                                                             *\n***************************************************************\n         SPACE 5\n*        ******************************************************\n*        *     BEND                                           *\n*        ******************************************************\n         MACRO\n         BEND  &BLKNM,&EPILOG=NO\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         AIF   (&YCCLVL GT 0).OKLVL\n         MNOTE 8,'BEND OR EPILOG STATEMENT OUTSIDE OF BLOCK'\n         SPACE 1\n         MEXIT\n.OKLVL   AIF   ('&BLKNM' NE '&YCCBLKN(&YCCLVL)').ERR1\n         AIF   (&YCCTYPE(&YCCLVL) EQ 0).DCRMT\n         AIF   (&YCCTYPE(&YCCLVL) NE 1 OR NOT &YCCEPLG(&YCCLVL) OR '&EP*\n               ILOG' NE 'NO').OK2\n         MNOTE 8,'MISSING EPILOG FOR THIS BLOCK'\n.OK2     ANOP\n         AIF   (&YCCTYPE(&YCCLVL) NE 2 AND &YCCTYPE(&YCCLVL) NE 3).NLP\n         B     TS&YCCLVL.@&YCCBLK#(&YCCLVL)\n&YCCL    SETC  'EN&YCCLVL.@&YCCEN#(&YCCLVL)'\n&YCCL    DS    0H\n&YCCL    SETC  'EL&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&YCCL    DS    0H\n         AGO   .DCRMT\n.NLP     AIF   (&YCCTYPE(&YCCLVL) EQ 1 OR &YCCTYPE(&YCCLVL) EQ 5).NELS\n&YCCL    SETC  'EL&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&YCCL    DS    0H\n.NELS    ANOP\n&YCCL    SETC  'EN&YCCLVL.@&YCCEN#(&YCCLVL)'\n&YCCL    DS    0H\n.DCRMT   ANOP\n         AIF   ('&EPILOG' EQ 'YES').EXIT\n&YCCLVL  SETA  &YCCLVL-1\n.EXIT    MEXIT\n.ERR1    MNOTE 8,'BLOCK NAME OMITTED OR DOES NOT MATCH CURRENT BLOCK'\n         SPACE 1\n         MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     BLOCK                                          *\n*        ******************************************************\n         MACRO\n&LAB     BLOCK &DUMMY,&EPILOG=NO\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         YCCPUSH NAME=&LAB,TYPE=BLOCK\n         AIF   ('&EPILOG' NE 'YES').EXITOK\n&YCCEPLG(&YCCLVL) SETB (1)\n.EXITOK  ANOP\n&LAB     DS    0H\n&YCCL    SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&YCCL    DS    0H\n         SPACE 1\n         MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     DO                                             *\n*        ******************************************************\n         MACRO\n&LAB     DO    &DUMMY\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         LCLA  &I\n&I       SETA  2\n         AIF   ('&DUMMY' NE 'WHILE' AND '&DUMMY' NE 'INF').TIL\n         YCCPUSH NAME=&LAB,TYPE=DOWILE\n         AIF   ('&LAB' EQ '').NOLAB\n&LAB     DS    0H\n.NOLAB   ANOP\n         AGO   .TESTS\n.TIL     AIF   ('&DUMMY' NE 'UNTIL').ERR1\n         YCCPUSH NAME=&LAB,TYPE=DOTIL\n         AIF   ('&LAB' EQ '').NOLAB2\n&LAB     DS    0H\n.NOLAB2  ANOP\n         B     ST&YCCLVL.@&YCCBLK#(&YCCLVL)\n         AGO   .TESTS\n.ERR1    MNOTE 8,'DO MUST BE (UNTIL|WHILE|INF)'\n.TESTS   ANOP\n&YCCL    SETC  'TS&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&YCCL    DS    0H\n.LP      AIF   ('&SYSLIST(&I)' EQ '').DONE\n         YCCTEST &SYSLIST(&I),&SYSLIST(&I+1)\n&I       SETA  &I+2\n         AGO   .LP\n.DONE    ANOP\n&YCCL    SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&YCCL    DS    0H\n         SPACE 1\n         MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     EPILOG                                         *\n*        ******************************************************\n         MACRO\n&LAB     EPILOG &BLKNM\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n&LAB     DS    0H\n         AIF   (&YCCTYPE(&YCCLVL) NE 1).ERR1\n         BEND  &BLKNM,EPILOG=YES\n&YCCTYPE(&YCCLVL) SETA 0\n&YCCEPLG(&YCCLVL) SETB (0)\n         MEXIT\n.ERR1    MNOTE 8,'EPILOG APPEARS OUT OF CONTEXT'\n         MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     EXIT                                           *\n*        ******************************************************\n         MACRO\n&LAB     EXIT  &LABNAM,&IF\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30),&YCCGO\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL,&O\n         LCLA  &I\n&O       SETC  'B'\n         AIF   ('&LABNAM' EQ '').NOTFAR\n         AIF   ('&LABNAM'(1,1) NE '(').NOTFAR\n&O       SETC  'B'\n.NOTFAR  ANOP\n         AIF   ('&LABNAM' NE '' AND '&LABNAM' NE '()').IF\n         AIF   (&YCCTYPE(&YCCLVL) EQ 1).BLKOK\n         MNOTE 8,'EXIT CODE DEFINION SHOULD BE IN A \"BLOCK\"'\n.BLKOK   ANOP\n         &O    EN&YCCLVL.@&YCCEN#(&YCCLVL)\n&LAB     DS    0H\n         SPACE 1\n         MEXIT\n.IF      ANOP\n&YCCGO   SETC  '&LABNAM(1)'\n         AIF   ('&IF' EQ '').GOTO\n         YCCPUSH NAME=&LAB,TYPE=IFLEAVE\n&I       SETA  3\n         AIF   ('&LAB' EQ '').NOLAB\n&LAB     DS    0H\n.NOLAB   ANOP\n&YCCL    SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n.LP2     AIF   ('&SYSLIST(&I)' EQ '').DONE\n         YCCTEST &SYSLIST(&I),&SYSLIST(&I+1),OP=&O\n&I       SETA  &I+2\n         AGO   .LP2\n.DONE    ANOP\n&YCCLVL  SETA  &YCCLVL-1\n&YCCL    DS    0H\n         SPACE 1\n         MEXIT\n.GOTO    ANOP\n&LAB     &O    &YCCGO\n         SPACE 1\n.END     MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     IF                                             *\n*        ******************************************************\n         MACRO\n&LAB     IF    &DUMMY\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         LCLA  &I\n         YCCPUSH NAME=&LAB,TYPE=IF\n&I       SETA  1\n         AIF   ('&LAB' EQ '').NOLAB\n&LAB     DS    0H\n.NOLAB   ANOP\n&YCCL    SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n.LP      AIF   ('&SYSLIST(&I)' EQ '').DONE\n         YCCTEST &SYSLIST(&I),&SYSLIST(&I+1)\n&I       SETA  &I+2\n         AGO   .LP\n.DONE    ANOP\n&YCCL    DS    0H\n         SPACE 1\n         MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     LEAVE                                          *\n*        ******************************************************\n         MACRO\n&LAB     LEAVE &BLKNM,&IF\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30),&YCCGO\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL,&O\n         LCLA  &LVL,&I\n&O       SETC  'B'\n         AIF   ('&BLKNM' EQ '' OR '&BLKNM'(1,1) NE '(').NOTFAR\n&O       SETC  'B'\n.NOTFAR  ANOP\n&LVL     SETA  &YCCLVL\n         AIF   ('&YCCBLKN(&LVL)' EQ '&BLKNM(1)' AND &YCCTYPE(&LVL) EQ 0*\n               ).ERR2\n.LP      AIF   (&LVL EQ 0).ERR\n         AIF   ('&BLKNM(1)' EQ '&YCCBLKN(&LVL)').OK\n         AIF   (&YCCEPLG(&LVL)).ERREXIT\n&LVL     SETA  &LVL-1\n         AGO   .LP\n.OK      ANOP\n         AIF   ('&IF' EQ 'IF').IF\n&LAB     &O    EN&LVL.@&YCCEN#(&LVL)\n         SPACE 1\n         MEXIT\n.IF      ANOP\n&YCCGO   SETC  'EN&LVL.@&YCCEN#(&LVL)'\n         YCCPUSH NAME=&LAB,TYPE=IFLEAVE\n&I       SETA  3\n         AIF   ('&LAB' EQ '').NOLAB\n&LAB     DS    0H\n.NOLAB   ANOP\n&YCCL    SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n.LP2     AIF   ('&SYSLIST(&I)' EQ '').DONE\n         YCCTEST &SYSLIST(&I),&SYSLIST(&I+1),OP=&O\n&I       SETA  &I+2\n         AGO   .LP2\n.DONE    ANOP\n&YCCLVL  SETA  &YCCLVL-1\n&YCCL    DS    0H\n         SPACE 1\n         MEXIT\n.ERR     MNOTE 8,'ATTEMPT TO LEAVE UNRECOGNIZED BLOCK'\n         SPACE 1\n.ERREXIT MNOTE 8,'CANNOT EXIT BEYOND BLOCK &YCCBLKN(&LVL)'\n         SPACE 1\n         MEXIT\n.ERR2    MNOTE 8,'YOU CANNOT LEAVE A BLOCK FROM ITS OWN EPILOG'\n.END     MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     ELSE                                           *\n*        ******************************************************\n         MACRO\n         ELSE  &DUMMY\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         B     EN&YCCLVL.@&YCCEN#(&YCCLVL)\n         AIF   (&YCCTYPE(&YCCLVL) NE 4).ERR1\n&YCCTYPE(&YCCLVL) SETA 5\n&YCCL    SETC  'EL&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&YCCL    DS    0H\n         SPACE 1\n         MEXIT\n.ERR1    MNOTE 8,'MISPLACED ELSE STATEMENT'\n         SPACE 1\n         MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     ELSEIF                                         *\n*        ******************************************************\n         MACRO\n&LAB     ELSEIF &DUMMY\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         LCLA  &I\n&I       SETA  1\n         ELSE\n&YCCTYPE(&YCCLVL) SETA  4         RESET TO \"IF\" TYPE\n&YCCBLK#(&YCCLVL) SETA &YCCBLK#(&YCCLVL)+1\n         AIF   ('&LAB' EQ '').NOLAB\n&LAB     DS    0H\n.NOLAB   ANOP\n&YCCL    SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n.LP      AIF   ('&SYSLIST(&I)' EQ '').DONE\n         YCCTEST &SYSLIST(&I),&SYSLIST(&I+1)\n&I       SETA  &I+2\n         AGO   .LP\n.DONE    ANOP\n&YCCL    DS    0H\n         SPACE 1\n         MEND ,\n         SPACE 5\n*        ******************************************************\n*        *     INTERNAL MACROS YCCTEST AND YCCPUSH            *\n*        ******************************************************\n         MACRO\n         YCCTEST &A,&B,&OP=B\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30),&YCCGO\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         LCLC  &N,&C,&GO,&O\n         LCLB  &NEG,&LOGIC\n         LCLA  &I\n         AIF   ('&B' EQ 'AND' OR '&B' EQ 'OR' OR '&B' EQ '' OR '&B' EQ *\n               'THEN').TCONJ\n         MNOTE 8,'&B SHOULD BE (AND|OR|THEN)'\n.TCONJ   ANOP\n         AIF   (&YCCTYPE(&YCCLVL) NE 5).NOLEV\n         AIF   ('&B' EQ 'AND').LVAND\n&GO      SETC  '&YCCGO'\n&NEG     SETB  (0)\n         AGO   .OKCONJ\n.LVAND   ANOP\n&GO      SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&NEG     SETB  (1)\n         AGO   .OKCONJ\n.NOLEV   AIF   (&YCCTYPE(&YCCLVL) EQ 2).TIL\n         AIF   ('&B' NE 'OR').IFAND\n&GO      SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&NEG     SETB  (0)\n         AGO   .OKCONJ\n.IFAND   ANOP\n&GO      SETC  'EL&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&NEG     SETB  (1)\n         AGO   .OKCONJ\n.TIL     AIF   ('&B' EQ 'AND').TILAND\n&GO      SETC  'EL&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&NEG     SETB  (0)\n         AGO   .OKCONJ\n.TILAND  ANOP\n&GO      SETC  'ST&YCCLVL.@&YCCBLK#(&YCCLVL)'\n&NEG     SETB  (1)\n.OKCONJ  ANOP\n         AIF   (N'&A NE 1).COMPND1\n&C       SETC  '&A'\n         AGO   .CONDS1\n.COMPND1 ANOP\n&C       SETC  '&A(2)'\n.CONDS1  ANOP\n         AIF   ('&C' EQ 'N').CONDS2\n         AIF   ('&C'(1,1) NE 'N').CONDS2\n&NEG     SETB  (NOT &NEG)\n&I       SETA  K'&C-1\n&C       SETC  '&C'(2,&I)\n.CONDS2  ANOP\n         AIF   ('&C' NE 'EQ').NOTEQ\n&C       SETC  'E'\n.NOTEQ   ANOP\n         AIF   ('&C' NE 'LT').NLT\n&C       SETC  'L'\n         AGO   .NOTNOT\n.NLT     ANOP\n         AIF   ('&C' NE 'GT').NGT\n&C       SETC  'H'\n         AGO   .NOTNOT\n.NGT     ANOP\n         AIF   ('&C' NE 'LE').NLE\n&NEG     SETB  (NOT &NEG)\n&C       SETC  'H'\n.NLE     ANOP\n         AIF   ('&C' NE 'GE').NGE\n&NEG     SETB  (NOT &NEG)\n&C       SETC  'L'\n         AGO   .NOTNOT\n.NGE     ANOP\n         AIF   ('&C' NE 'ON').NON\n&C       SETC  'O'\n&LOGIC   SETB  (1)\n         AGO   .NOTNOT\n.NON     ANOP\n         AIF   ('&C' NE 'OFF').NOFF\n&C       SETC  'Z'\n&LOGIC   SETB  (1)\n         AGO   .NOTNOT\n.NOFF    ANOP\n         AIF   ('&C' NE 'MIX').NMIX\n&C       SETC  'M'\n&LOGIC   SETB  (1)\n         AGO   .NOTNOT\n.NMIX    ANOP\n.NOTNOT  ANOP\n&N       SETC  'N'\n         AIF   (&NEG).NOTOK\n&N       SETC  ''\n.NOTOK   ANOP\n&O       SETC  '&OP.&N.&C'\n         AIF   (N'&A NE 1).COMPND2\n         &O    &GO\n         MEXIT\n.COMPND2 ANOP\n         AIF   ('&A(4)' EQ '').DFLT\n         &A(4) &A(1),&A(3)\n.NMZ     &O    &GO\n         MEXIT\n.DFLT    AIF   (&LOGIC).TM\n         AIF   (T'&A(3) NE 'N').NCH\n         AIF   ('&A(3)' NE '0').NLTR\n         LTR   &A(1),&A(1)\n         AGO   .TST\n.NLTR    ANOP\n         CH    &A(1),=H'&A(3)'\n         AGO   .TST\n.NCH     C     &A(1),&A(3)\n.TST     ANOP\n         &O    &GO\n         MEXIT\n.TM      TM    &A(1),&A(3)\n         &O    &GO\n         MEND ,\n         SPACE 5\n         MACRO\n         YCCPUSH &NAME=,&TYPE=\n         GBLA  &YCCLVL,&YCCBLK#(30),&YCCTYPE(30),&YCCEN#(30)\n         GBLC  &YCCBLKN(30)\n         GBLB  &YCCEPLG(30)\n         LCLC  &YCCL\n         AIF   (&YCCLVL EQ 30).OVFLOW\n&YCCLVL  SETA  &YCCLVL+1\n&YCCBLK#(&YCCLVL) SETA  &YCCBLK#(&YCCLVL)+1\n&YCCEN#(&YCCLVL) SETA  &YCCBLK#(&YCCLVL)\n&YCCBLKN(&YCCLVL) SETC  '&NAME'\n&YCCEPLG(&YCCLVL) SETB (0)\n         AIF   ('&TYPE' NE 'BLOCK').NBLK\n&YCCTYPE(&YCCLVL) SETA 1\n         MEXIT\n.NBLK    AIF ('&TYPE' NE 'DOTIL').NDOTIL\n&YCCTYPE(&YCCLVL) SETA 2\n         MEXIT\n.NDOTIL   AIF   ('&TYPE' NE 'DOWILE').NDOWILE\n&YCCTYPE(&YCCLVL) SETA 3\n         MEXIT\n.NDOWILE AIF   ('&TYPE' NE 'IF').NOTIF\n&YCCTYPE(&YCCLVL) SETA 4\n         MEXIT\n.NOTIF   AIF   ('&TYPE' NE 'IFLEAVE').NOTLEV\n&YCCTYPE(&YCCLVL) SETA 5\n         MEXIT\n.NOTLEV  MNOTE 8,'UNRECOGNIZED BLOCK TYPE'\n         MEXIT\n.OVFLOW  MNOTE 16,'BLOCKS NESTED TOO DEEPLY FOR HAL MACROS'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HALFMT": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x01G\\x01G\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 327, "newlines": 327, "modlines": 0, "user": "GPSAM"}, "text": "*****************************************************************\n*                                                               *\n* MODULE NAME = HALFMT                                          *\n*                                                               *\n* DESCRIPTIVE NAME = FORMAT PROGRAM WRITTEN IN HAL              *\n*                                                               *\n* COPYRIGHT = NONE                                              *\n*                                                               *\n* STATUS = VERSION 1 LEVEL 1                                    *\n*                                                               *\n* LINKAGE = STANDARD OS PROGRAM LINKAGE                         *\n*                                                               *\n* INPUT = DDNAME SYSIN HAS ASSEMBLER PROGRAM                    *\n*                                                               *\n* OUTPUT = SYSPRINT LISTING OF PROGRAM WITH INDENTATION         *\n*                                                               *\n* NOTES =                                                       *\n*                                                               *\n*        THE PURPOSE OF THIS PROGRAM IS TO FURTHER DOCUMENT     *\n*        HAL AND PROVIDE EXAMPLES OF ITS USE AS WELL AS         *\n*        PROVIDE A USEFUL SERVICE.                              *\n*                                                               *\n* CHANGES = ADD \"ELSEIF\", SPF SOURCE NUMBERING                  *\n*****************************************************************\n         TITLE 'HALFMT - INCLUDE HAL MACROS'\n         COPY  HAL\n         TITLE 'HALFMT - INITIALIZATION AND EQUATES'\nHALFMT   CSECT\n         SAVE  (14,12),,*\n         BALR  RBASE,0\n         USING *,RBASE\n         LR    R15,R13\n         LA    R13,SAVEAREA\n         ST    R15,4(R13)\n         ST    R13,8(R15)\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRSTCK    EQU   R9                 STACK REGISTER\nRIND     EQU   R10                INDENTATION COUNT\nRRETC    EQU   R11                RETURN CODE\nRBASE    EQU   R12                BASE REGISTER\n         SPACE 5\n*        ********************************************************\n*        *     PROCESS OS PARM FIELD*\n*        ********************************************************\n         L     R1,0(R1)\n         LH    R2,0(R1)\n         LA    R1,2(R1)\n         IF    (R2,EQ,3),AND,(SPF,EQ,0(R1),CLC),THEN\n         OI    FLGS,SPFFLG\n         BEND  ,\n         TITLE 'HALFMT - PROCESS DATASETS'\nOPENPR   BLOCK EPILOG=YES\n*        ********************************************************\n*        * THIS BLOCK OPENS THE SYSPRINT DATASET. WITHIN        *\n*        * THE BODY OF THIS BLOCK MESSAGES MAY BE WRITTEN ON    *\n*        * SYSPRINT. THE EPILOG FOR THE BLOCK CLOSES THE        *\n*        * FILE. BEFORE LEAVING THIS BLOCK, PUT A RETURN        *\n*        * CODE IN REGISTER 11                                  *\n*        ********************************************************\n         SR    R11,R11\n         OPEN  (SYSPR,(OUTPUT))\n         IF    (SYSPR+DCBOFLGS-IHADCB,OFF,DCBOFOPN),THEN\n         LA    R11,12             SYSPRINT NOT OPENED\n         LEAVE OPENPR\n         BEND\nOPENIN   BLOCK EPILOG=YES\n*        ********************************************************\n*        * THIS BLOCK OPENS DDNAME SYSIN. WITHIN THIS           *\n*        * BLOCK CARDS MAY BE READ. THE EPILOG FOR THIS         *\n*        * BLOCK CLOSES THE FILE. NOTE THAT THERE IS A          *\n*        * NO-STANDARD TRANSFER OF CONTROL IN THIS BLOCK        *\n*        * FROM THE 'GET' TO THE LABEL 'SYSINEOD' AT END        *\n*        * OF FILE.                                             *\n*        ********************************************************\n         OPEN  (SYSIN,(INPUT))\n         IF    (SYSIN+DCBOFLGS-IHADCB,OFF,DCBOFOPN),THEN\n         MVC   LINE,BLANKS\n         MVC   LINE(L'MSG1),MSG1\n         PUT   SYSPR,LINE\n         LA    R11,8\n         BEND\n*        ********************************************************\n*        * INITIALLY, THERE IS NO INDENTATION AND THE BLOCK     *\n*        * STACK IS EMPTY                                       *\n*        ********************************************************\n         SR    RIND,RIND\n         LA    RSTCK,STACK\n         MVC   LINE,BLANKS\nCARDSCAN DO    UNTIL,(OP,EQ,OPENDER,CLC)\n         GET   SYSIN,CARD\nOPSCAN   BLOCK\n         IF    (CARD,EQ,C'*',CLI),THEN\n*        ********************************************************\n*        * COMMENT CARDS MAY HAVE A MACRO NAME IN COLUMNS       *\n*        * 10-15 BUT THEY ARE NOT REALLY HAL CALLS              *\n*        ********************************************************\n         BAL   R14,PRINT\n         LEAVE OPSCAN\n         BEND\n         IF    (OP,EQ,OPDO,CLC),OR,                                    X\n               (OP,EQ,OPBLOCK,CLC),THEN\n*        ********************************************************\n*        * 'DO' OR 'BLOCK' BEGIN A BLOCK. THEY MUST             *\n*        * INDENTED AND THE CURRENT BLOCK STACK MUST            *\n*        * BE PUSHED DOWN.                                      *\n*        ********************************************************\n         A     RIND,INDENT\n         SR    R1,R1\n         BAL   R14,PUSH\n         BAL   R14,PRINT\n         LEAVE OPSCAN\n         BEND\n         IF    (OP,EQ,OPIF,CLC),THEN\n*        ********************************************************\n*        * IF BEGINS A BLOCK, BUT WE MUST MAKE                  *\n*        * PROVISION FOR SPECIAL FORMATTING SO THE              *\n*        * STATEMENTS ARE INDENTED BOTH BEFORE THE              *\n*        * IF AND BEFORE THE FIRST STATEMENT OF THE             *\n*        * THEN CLAUSE                                          *\n*        ********************************************************\n         A     RIND,INDENT\n         L     R1,INDENT\n         BAL   R14,PUSH\n         BAL   R14,PRINT\n         A     RIND,INDENT\n         LEAVE OPSCAN\n         BEND\n         IF    (OP,EQ,OPELSE,CLC),OR,(OP,EQ,OPELIF,CLC),THEN\n*        ********************************************************\n*        * ELSE DOES NOT BEGIN A BLOCK. IT MUST BE UNDENTED     *\n*        * FOR THIS LINE ONLY.                                  *\n*        ********************************************************\n         S     RIND,INDENT\n         BAL   R14,PRINT\n         A     RIND,INDENT\n         LEAVE OPSCAN\n         BEND\nISBEND   IF    (OP,EQ,OPBEND,CLC),THEN\n*        ********************************************************\n*        * THE BEND STATEMENT ENDS A BLOCK. NORMALLY            *\n*        * THE BEND STATEMENT IS PRINTED WITH THE               *\n*        * SAME INDENTATION AS THE PREVIOUS STATEMENT           *\n*        * AND THEN THE NEXT STATEMENT IS UNDENTED.             *\n*        * HOWEVER, WHEN ENDING AN 'IF' BLOCK THE               *\n*        * BEND IS UNDENTED BOTH BEFORE AND AFTER.              *\n*        ********************************************************\n         IF    (RIND,LE,0),THEN\n*        ********************************************************\n*        * A STACK UNDERFLOW HAS OCCURRED. MORE 'BEND'          *\n*        * STATEMENTS WERE ENCOUNTERED THAN BLOCKS WERE         *\n*        * STARTED. SEND HIM A MESSAGE AND SKIP THIS            *\n*        * CARD                                                 *\n*        ********************************************************\n         BAL   R14,PRINT\n         MVC   LINE,BLANKS\n         MVC   LINE(L'MSG2),MSG2\n         PUT   SYSPR,LINE\n         LA    RRETC,8\n         LEAVE OPSCAN\n         BEND\n         S     RSTCK,WORD\n         S     RIND,0(RSTCK)\n         BAL   R14,PRINT\n         S     RIND,INDENT\n         LEAVE OPSCAN\n         BEND  ISBEND\n         IF    (OP,EQ,OPTITLE,CLC),THEN\n*        ********************************************************\n*        * ALTHOUGH TITLE STATEMENTS ARE NOT                    *\n*        * REALLY PART OF HAL, IT MAKES THE LISTING             *\n*        * BETTER LOOKING IF THEY ARE RECOGNIZED                *\n*        ********************************************************\n         MVI   LINE,C'1'\n         BAL   R14,PRINT\n         MVI   LINE,C' '\n         LEAVE OPSCAN\n         BEND\n*        ********************************************************\n*        * THE ONLY THING THAT IS LEFT IS A REGULAR CARD        *\n*        * SO PRINT IT                                          *\n*        ********************************************************\n         BAL   R14,PRINT\n         BEND  OPSCAN\n         BEND  CARDSCAN\n*        ********************************************************\n*        * WE ARE AT THE END, SEE IF THINGS ARE SET UP          *\n*        * CORRECTLY                                            *\n*        ********************************************************\nSYSINEOD IF    (RIND,NE,0),THEN\n         MVC   LINE,BLANKS\n         MVC   LINE(L'MSG3),MSG3\n         PUT   SYSPR,LINE\n         LA    RRETC,8\n         BEND   SYSINEOD\n         EPILOG OPENIN\n*        ********************************************************\n*        * CLOSE SYSIN                                          *\n*        ********************************************************\n         IF    (SYSIN+DCBOFLGS-IHADCB,ON,DCBOFOPN),THEN\n         CLOSE (SYSIN)\n         BEND\n         BEND  OPENIN\n         EPILOG OPENPR\n*        ********************************************************\n*        * CLOSE SYSPRINT                                       *\n*        ********************************************************\n         IF    (SYSPR+DCBOFLGS-IHADCB,ON,DCBOFOPN),THEN\n         CLOSE (SYSPR)\n         BEND\n         BEND  OPENPR\n         L     R13,4(R13)\n         LR    R15,RRETC\n         RETURN (14,12),RC=(15)\n         TITLE 'HALFMT - INTERNAL ROUTINES'\nPUSH     BLOCK\n*        ********************************************************\n*        * ROUTINE 'PUSH' IS CALLED WHEN A NEW BLOCK IS         *\n*        * STARTED. IT ADDS A ZERO TO THE STACK FOR             *\n*        * 'DO' AND 'BLOCK' BLOCKS WHICH REQUIRE ONLY           *\n*        * SIMPLE INDENTATION, AND NON-ZERO INDENTATION         *\n*        * VALUE FOR 'IF' BLOCKS.                               *\n*        * STACK OVERFLOW IS CHECKED HERE. THE STACK IS POPPED  *\n*        * IN THE 'BEND' CODE ABOVE                             *\n*        ********************************************************\n         LR    R5,R14\n         IF    (RSTCK,EQ,STACKEND),THEN\n         MVC   LINE,BLANKS\n         MVC   LINE(L'MSG4),MSG4\n         BAL   R14,PRINT\n         LA    RRETC,8\n         ELSE\n         ST    R1,0(RSTCK)\n         A     RSTCK,WORD\n         BEND\n         BR    R5\n         BEND  PUSH\nPRINT    BLOCK\n*        ********************************************************\n*        * PRINT THE CURRENT CARD ON THE OUTPUT DATASET.        *\n*        * VARIOUS FIELDS ARE MOVED AROUND AND THE CURRENT      *\n*        * LEVEL OF INDENTATION IS REFLECTED IN THE OUTPUT      *\n*        ********************************************************\n         LR    R4,R14\n         MVC   LINE+1(132),BLANKS\n         IF    (FLGS,ON,SPFFLG),THEN\n         MVC   LINENUM,SEQN\n         ELSE  ,\n         MVC   LINENUM,SEQN+2\n         BEND  ,\n         MVC   LINENAME,CARDNAME\n         LA    R2,LINETEXT\n         LA    R2,0(R2,RIND)      LINE INDENTATION\n         LA    R3,LINEEND\n         SR    R3,R2              CALCULATE CHARS TO MOVE\n         IF    (R3,GT,61),THEN       CANT MOVE MORE THAN\n         LA    R3,61                 THE WHOLE CARD\n         BEND\n         IF    (R3,GT,0),THEN     INDENTED WHOLE CARD AWAY\n         EX    R3,TEXTMOVE\n         BEND\n         IF    (LINENAME,EQ,STARS,CLC),AND,                            X\n               (RIND,NE,0),THEN\n         EX    RIND,STARMOVE      CONTINUE ASTERISK LINE\n         BEND\n         PUT   SYSPR,LINE\n         BR    R4\n         BEND  PRINT\nTEXTMOVE MVC   0(*-*,R2),OP\nSTARMOVE MVC   LINENAME+8(*-*),LINENAME+7\n         TITLE 'HALFMT - CONSTANTS AND DATA AREAS'\nSAVEAREA DS    18A\nCARD     DS    0CL80\nCARDNAME DS    CL9\nOP       DS    CL6\nSTMT     DS    0CL57\nSTMTTEXT DS    CL56\nCONTINUE DS    C\nSEQN     DS    CL8\nLINE     DS    0CL133\nCC       DS    C\nLINENUM  DS    CL6\n         DS    C\nLINENAME DS    CL9\nLINETEXT DS    CL116\nLINEEND  DS    C\nFLGS     DC    X'00'\nSPFFLG   EQU   X'80'\nBLANKS   DC    CL133' '\nSTARS    DC    CL9'*********'\nSTACK    DS    40A\nSTACKEND DC    A(*)\nINDENT   DC    F'3'\nWORD     DC    F'4'\nOPDO     DC    CL6'DO'\nOPBLOCK  DC    CL6'BLOCK'\nOPIF     DC    CL6'IF'\nOPELSE   DC    CL6'ELSE'\nOPELIF   DC    CL6'ELSEIF'\nOPBEND   DC    CL6'BEND'\nOPTITLE  DC    CL6'TITLE'\nOPENDER  DC    CL6'END'\nSPF      DC    C'SPF'\nMSG1     DC    C' ******UNABLE TO OPEN ''SYSIN'' DDNAME'\nMSG2     DC    C' ******MORE ''BEND'' STATEMENTS THAN OPEN BLOCKS'\nMSG3     DC    C' ******THERE ARE STILL UNTERMINATED BLOCKS'\nMSG4     DC    C' ******BLOCKS ARE NESTED TOO DEEPLY FOR THIS PROGRAM'\n         PRINT NOGEN\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GM),EODAD=SYSINEOD\nSYSPR    DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),                    X\n               RECFM=FBA,LRECL=133,BLKSIZE=6650\n         DCBD\n         END   HALFMT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOWCASAM": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x823_\\x00\\x823_\\x157\\x00\\x9e\\x00\\x9e\\x00\\x00\\xc7\\xd7\\xe2\\xc1\\xd4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1982-12-01T15:37:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "GPSAM"}, "text": "LOWC     TITLE 'LOWCASAM - PROBLEM STATE SUBSYSTEM OPEN RTN'\n***************************************************************\n* NAME = LOWCASAM                                             *\n* DESCRIPTIVE NAME = LOWER CASE TERMINAL INPUT  ACCESS METHOD *\n* (C) COPYRIGHT 1982 YALE COMPUTER CENTER                     *\n* STATUS = VERSION 1 MODIFICATION LEVEL 0                     *\n* SYSTEM = MVS 3.8                                            *\n* ATTRIBUTES = NONE                                           *\n* LINKAGE = FROM GPSMOPEN AT OPEN AND CLOSE                   *\n* NORMAL RETURN =                                             *\n*      GPSMAMEP SET TO GET/PUT ENTRY POINT OF ROUTINE         *\n*                                                             *\n* AUTHOR = HOWARD GILBERT                                     *\n*          YALE COMPUTER CENTER                               *\n*          175 WHITNEY AVE.                                   *\n*          P.O. BOX 2112 YALE STATION                         *\n*          NEW HAVEN, CT 06520                                *\n*          BITNET ADDRESS: GILBERT @ YALEVM                   *\n***************************************************************\n         PRINT OFF\n         COPY  HAL\n         PRINT ON\nLOWCASAM CSECT\n         USING *,R15\n         SAVE  (14,12),,*\n         LR    R10,R15\n         USING LOWCASAM,R10\n         DROP  R15\n         LR    R2,R1\n         USING AMPARM,R2\n         L     R6,GPSMSSOB        GET SSOB POINTER\n         USING SSOB,R6            NOW CHAIN DOWN TO ACB\nDEBUG1   IF    (FLAGWORD,ON,DEBUG),THEN\n*        ******************************************************\n*        * IF ZAPPED ON, INVOKE THE YALE DEBUGGER             *\n*        * NOTE: THIS IS HERE JUST TO SHOW HOW IT'S DONE.     *\n*        * THERE IS NO REAL WORK DONE AT OPEN TIME IN THIS    *\n*        * ROUTINE, BUT IF YOU USE IT AS A MODEL AND REALLY   *\n*        * HAVE TO DO PROCESSING, THEN DEBUGGING DURING OPEN  *\n*        * WOULD BE USEFUL                                    *\n*        ******************************************************\n         LOAD  EP=DBC\n         LR    R3,R0\n         ST    R3,DBCADDR         SAVE ADDRESS FOR PUT/GET\n         ESTAE (R3)\n         #DIE\n         BEND  DEBUG1\n         TITLE 'LOWCASAM - PROCESS OPEN/CLOSE REQUEST'\nOPENCLOS IF    (SSOBFUNC+1,EQ,SSOBOPEN,CLI),THEN\n*        ******************************************************\n*        * FUNCTION IS OPEN.                                  *\n*        ******************************************************\n         LA    R1,PUTGET\n         ST    R1,GPSMAMEP\n         MVC   BADIODD,GPSMDDN\n         L     R7,SSOBINDV\n         L     R7,SSDAJFCB-SSOBGN(R7)\n         USING JFCB,R7\n         IF    (JFCRECFM,ON,JFCFIX),AND,(JFCRECFM,OFF,JFCVAR)\n         OI    VARFLAG,RECFMF\n         BEND  ,\n         ELSE  ,\n*        ******************************************************\n*        * THE FUNCTION IS CLOSE                              *\n*        ******************************************************\n         IF    (FLAGWORD,ON,DEBUG),THEN\n         DELETE EP=DBC\n         BEND  ,\n         BEND  OPENCLOS\n         SPACE 5\nDEBUG2   IF    (FLAGWORD,ON,DEBUG),THEN\n*        ******************************************************\n*        * CANCEL THE YALE DEBUGGER                           *\n*        ******************************************************\n         ESTAE 0\n         BEND  DEBUG2\nRET      L     R13,4(R13)         BACK TO SAVE1\n         RETURN (14,12),RC=0\n         DROP  ,\n         TITLE 'LOWCASAM - PUT/GET ROUTINE ENTRY POINT'\n***************************************************************\n* ENTRY = PUTGET                                              *\n* FUNCTION = HANDLE I/O REQUEST TO GPSAM FILE                 *\n* LINKAGE = FROM GET/PUT/NOTE/POINT/ ETC. MACRO               *\n*                                                             *\n*        L     R1,RPL                                         *\n*        LA    R0,FUNCTION                                    *\n*        L     R15,24(R1)         POINT TO ACB                *\n*        L     R15,8(R1)          POINT TO MY ENTRY POINT     *\n*        BALR  R14,R15                                        *\n*                                                             *\n* FUNCTION CODES:                                             *\n*        0     GET                READ RECORD FROM TERMINAL   *\n*        1     PUT                NOT SUPPORTED               *\n*       >1                        NOT SUPPORTED               *\n***************************************************************\nPUTGET   BLOCK ,\n         SAVE  (14,12)\n         BALR  R12,0\n         USING *,R12\n         IF    (R0,EQ,0),THEN     IF ITS A GET\n         LR    R2,R1              SAVE RPL ADDRESS\n         USING IFGRPL,R2\n         L     R1,RPLAREA         PICK UP BUFFER\n         LR    R3,R1\n         L     R0,RPLBUFL         GET BUFFER LENGTH\n         TGET  (1),(0),EDIT       READ DATA\n         IF    (VARFLAG,OFF,RECFMF),THEN\n         ST    R1,RPLRLEN         READ DATA LENGTH\n         ELSE  ,\n         L     R5,RPLDACB         OR LRECL (FOR RECFM=F)\n         LH    R5,ACBLRECL-IFGACB(R5)\n         ST    R5,RPLRLEN\n         BEND  ,\n         IF    (0(2,R3),EQ,SLSHSTAR,CLC),THEN\n         MVC   RPLFDBK,EOFCODE\n         ELSE  ,\n         XC    RPLFDBK,RPLFDBK\n         BEND  ,\n         ELSE  ,\n         TPUT  BADIO,LBADIO\n         MVC   RPLFDBK,ERRCODE\n         BEND  ,\n         LR    R1,R2\n         L     R15,=V(GPSMEXIT)\n         BR    R15\n         BEND  PUTGET\n         TITLE 'LOWCASAM - CONSTANTS, VARIABLE, AND DSECTS'\nFLAGWORD DS    0F\nZAPFLAG  DC    AL1(0)             ZAPPED FLAGS\nDEBUG    EQU   X'80'\nVARFLAG  DC    AL1(0)             FLAGS SET DURING PROCESSING\nRECFMF   EQU   X'80'              FIXED FORMAT PROCESSING\n         DC    H'0'               RESERVED\nDBCADDR  DC    A(*-*)\nEOFCODE  DC    AL1(RPLLOGER,0,RPLEODER)\nERRCODE  DC    AL1(RPLLOGER,0,RPLINACC)\nSLSHSTAR DC    C'/*'\nBADIO    DC    C'ONLY READ/GET REQUESTS PERMITTED TO LOWCASE FILE '\nBADIODD  DC    CL8' '\nLBADIO   EQU   *-BADIO\n         LTORG\n         SPACE 5\nAMPARM   DSECT\nGPSMMPRM DS    A                  POINTER TO MODULE PARM\nGPSMSSOB DS    A                  POINT TO OPEN SSOB\nGPSMAMEP DS    A                  RETURN ACB AM ENTRY POINT\nGPSMSAVA DS    A                  WORD TO SAVE FOR CLOSE\nGPSMDDN  DS    CL8                DDNAME\n         PRINT NOGEN\n         EQUREGS\n         IDARMRCD\n         IFGRPL\n         IFGACB\nJFCB     DSECT\n         IEFJFCBN\n         IEFJSSOB DA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT290/FILE290.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT290", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}