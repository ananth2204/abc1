/*REXX*/
numeric digits 15
/*-------------------------------------------------------------*/
/* Extract smf 100 records - written by Nguyen Duc Tuan        */
/*                                      ndt.db2Ã gmail.com      */
/*   4 jan 2016     Release 1.1                                */
/*  14 jan 2016     Release 1.2 add dsnqdst ddf stats          */
/*  11 fev 2016     Release 1.2.1 correct imprecision          */
/*                  on bp figures (numeric digits)             */
/*  25 fev 2016     Release 2.0   Ifcid225 cur. threads        */
/*                  vsm=Y   option to calculate max thread     */
/*                  possible + central storage usage           */
/*  15 Apr 2016     Release 2.1   More displays for threads    */
/*                  calculation - Verification OK with values  */
/*                  from IBM Rexx MEMU                         */
/*  20 Apr 2016     Release 2.2   More columns for storage     */
/*                  monitoring                                 */
/*  03 Jul 2016     Release 2.3   Process Data Manager Section */
/*                  (DSNDQIST macro with difference)           */
/*  06 Jul 2016     Release 2.4   Correction abend in TF=...   */
/*                  when number of tasks = 0                   */
/*                  Able to process  records from several days */
/*  29 Jul 2016     Release 2.5   Minor fixes +Logs created    */
/*  13 Oct 2016     Release 2.6   Add Q3ST stats               */
/*                  (Signon, Terminate, Create Threads ..)     */
/*                  and Datasets Stats                         */
/*  16 Dec 2016     Release 2.7   PageIns buffer Stats         */
/*  02 Mar 2017     Release 3.0   Improve Bufferpool stats     */
/*  21 Mar 2017     Release 3.1   More Bufferpools stats and   */
/*                  warning messages                           */
/*  25 Apr 2017     Release 3.2   BP memory usage in Real and  */
/*                  Auxiliary                                  */
/*  11 May 2017     DSC stats (Full Prepare, Short, ...) Locks */
/*  24 May 2017     Z/OS Stats (must activate zparm) R3.4      */
/*  16 Aug 2017     Add BP simulated stats R3.5                */
/*  11 Oct 2017     Release 3.6 Add Workfile usage stats       */
/*  02 Feb 2018     Release 3.7 Add more QISE stats (DBDsteal  */
/*  02 Mar 2018     Group Buffer Pool stats + check            */
/*-------------------------------------------------------------*/
/*Comment : Change datasets high level identifier              */
/*-------------------------------------------------------------*/
ARG SSID hlq smforig Alert BpSim
retcode=0
/* Display Warning messages (best practices)*/
if Alert ='' then Alert='Y'
/* Bufferpool simulation */
if BpSim <> 'Y' then BpSim='N'
say 'BPsim ' BpSim
/* Virtual storage monitoring Yes/No */
VSM='Y'

say ' '
say 'Processing for Subsys' ssid

ifcid1_seen=0
if smforig='' then smforig='A'
if smforig='A' then
do
     /* Input file : SMF extract sorted */
     oufl = hlq || '.SMFEXTS.OUT'
     "ALLOC DD(INP) DS('"oufl"') ,
                            SHR REU bufno(20)"
end

/* Report dataset on output (general stats) */
oufl = "'" || hlq || '.reports.' || ssid ||  "'"
"DELETE" oufl "PURGE"

/* Report dataset on output (BP stats) */
oufl2= "'" || hlq || '.reportsb.' || ssid ||  "'"
"DELETE" oufl2 "PURGE"

/* Report dataset on output (GBP stats) */
oufl5= "'" || hlq || '.reportsg.' || ssid ||  "'"
"DELETE" oufl5 "PURGE"

/* Report dataset on output (STOR stats) */
oufl3= "'" || hlq || '.reportst.' || ssid ||  "'"
"DELETE" oufl3 "PURGE"

/* Report dataset on output (BP Simulation stats) */
oufl4= "'" || hlq || '.repSimBP.' || ssid ||  "'"
"DELETE" oufl4 "PURGE"

"ALLOC FI(OUFL) DA("oufl") NEW CATALOG REUSE" ,
"LRECL(1400) RECFM(V B) TRACKS SPACE(50,50)"
rcalloc = rc
if rcalloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl  rcalloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end

"ALLOC FI(OUFL2) DA("oufl2") NEW CATALOG REUSE" ,
"LRECL(500) RECFM(V B) TRACKS SPACE(50,50)"
rcalloc = rc
if rcalloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl2 rcalloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end

"ALLOC FI(OUFL5) DA("oufl5") NEW CATALOG REUSE" ,
"LRECL(100) RECFM(V B) TRACKS SPACE(50,50)"
rcalloc = rc
if rcalloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl5 rcalloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end

"ALLOC FI(OUFL3) DA("oufl3") NEW CATALOG REUSE" ,
"LRECL(200) RECFM(V B) TRACKS SPACE(10,10)"
rcalloc = rc
if rcalloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl3 rcalloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end

if BPSim = 'Y' then
do
    "ALLOC FI(OUFL4) DA("oufl4") NEW CATALOG REUSE" ,
    "LRECL(200) RECFM(V B) TRACKS SPACE(90,15)"
    rcalloc = rc
    if rcalloc <> 0 then Do
         say "**********************************************"
         say "   Error allocating report file" oufl3 rcalloc
         say "   Abnormal end  "
         say "**********************************************"
         Exit 8
    end
end
/* init compteurs divers */
call init_var
/* WRITE report header */
CALL write_header

/* START PROCESSING */
DO FOREVER
  /* read SMF record one by one   */
  "EXECIO 1 DISKR INP"
  IF RC > 0 THEN DO
            if rc =  2 then
             do
              SAY 'End of input SMF file rc=' RC
              rcalloc = rc
             end
             else do
              SAY 'Error while reading SMF file rc=' RC
              rcalloc = 8
             end
              leave
            END
  PARSE PULL INPUT_REC
  reci=reci+1
  OFFSET = 1
  /* Decode SMF header */
  CALL DSNDQWST
  /* process only smf100 */
  IF (SM100RTY = 100  & SM100SSI = SSID  ) THEN
  DO
    /* record SMF records period   */
    if min_time > run_fmt_time then min_time=run_fmt_time
    if max_time < run_fmt_time then max_time=run_fmt_time
    if min_date > sm100dte     then min_date=sm100dte
    if max_date < sm100dte     then max_date=sm100dte

    /*sauvegarde offset_self car on le reutilise */
    offset_selfdef= offset
    /* on va sur le self def. section pour aller vers prod section*/
    offset = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset - 4 + 1
    /* traitement product section*/
    CALL DSNDQWHS
    offset=offset_selfdef
    /* ifcid 1 must start the stats group */
    if   ifcid =  1 then
    do
          ifcid1_seen = 1
    end
    else if   ifcid <> 1 & ifcid1_seen = 0 then
                     do
                        iterate
                        say 'Bypass' ifcid
                        say 'Ifcid 1 must start the group'
                     end
    recs=recs+1

    Select
         When ifcid     = 1  Then do
                                      CALL DSNDQWS0
                                      OFFSET = QWS00PSO - 4 + 1
                                  end
         When ifcid     = 2  Then do
                                      CALL DSNDQWS1
                                      OFFSET = QWS10PSO - 4 + 1
                                  end
     /*  When ifcid     = 199 Then do
                                      CALL QW0199
                                      OFFSET = QWS10PSO - 4 + 1
                                  end  */
         When ifcid     = 225 Then do
                                      CALL QW0225
                                      OFFSET = QWS10PSO - 4 + 1
                                  end
         Otherwise      do
                  /* add line here to avoid excessive displays */
                          if  ifcid = 202 then nop
                          else
                              if  ifcid = 230 then nop
                          else
                              say 'ifcid ' ifcid ' not processed'
                        end
    end   /* select */

    /*write report quand on a fait le tour des ifcids */
    if ifcid = 1 & recs > 1 then
       do
          call ifcid_diff
          Call write_report
       end
    else
    do
         if ifcid = 1 & recs = 1 then
         do
              Old_Mstrtcb =       Mstrtcb
              Old_MstrSrb =       MstrSrb
              Old_MstrpSRB=       MstrpSRB
              Old_MstrpSRB_ziip = MstrpSRB_ziip
              Old_dbm1Tcb =       dbm1Tcb
              Old_dbm1srb =       dbm1srb
              Old_dbm1pSRB=       dbm1pSRB
              Old_dbm1pSRB_ziip = dbm1pSRB_ziip
              Old_irlmTcb =       irlmTcb
              Old_irlmsrb =       irlmsrb
              Old_irlmpSRB=       irlmpSRB
              Old_irlmpSRB_ziip = irlmpSRB_ziip
              Old_distTcb =       distTcb
              Old_distsrb =       distsrb
              Old_distpSRB=       distpSRB
              Old_distpSRB_ziip = distpSRB_ziip
         end
    end
  END /*    IF SM101RTY = 101  */
END

/* close file */
address TSO "EXECIO 0 DISKW OUFL (FINIS"
rcwrite = rc
if rcwrite<> 0 then Do
   say "**********************************************"
   say "   Error writting OUFL file: " rcwrite
   say "   Abnormal end   "
   say "**********************************************"
   Exit 8
end
"EXECIO 0 DISKR INP (FINIS"
"FREE DD(INP)"
"FREE DD(OUFL)"

say "Input records =" reci
say "Output records=" reco
say 'SMF period : ' min_date "/" max_date min_time "/" max_time

/*-------------------------------------------------*/
/* F20 End of program display counters and figures */
/*-------------------------------------------------*/
call DisplayVStor

EXIT retcode

/*---------------------------------------*/
/* End of program body- Routines section */
/*---------------------------------------*/

/* MAP SELF-DEFINING SECT IFCID 001 LG = 112 */
DSNDQWS0:
  /*  OFFSET TO THE PRODUCT SECTION */
  QWS00PSO = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 4
  QWS00PSL = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  QWS00PSN = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  /*  Following sections are provided by DSNDQWST (Stats header) */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSA CPU TIME */
  QWS00R1O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 4
  QWS00R1L =  C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  QWS00R1N =  C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  save_offset = offset
  /* controle de coherence */
  if  QWS00R1N  > 4 then
      do
           say 'QWS00R1N is not equal to 4, abnormal end ' QWS00R1N
           exit 8
      end
  /* Load offset to DSNDQWSA section - decode db2 stc cpu section */
  OFFSET= QWS00R1O - 4 + 1
  i=0
  /* init DIST pas toujours pr!sent */
  DISTTcb      = 0
  DISTSrb      = 0
  DISTpSRB     = 0
  DISTpSRB_Ziip= 0
  do until i= QWS00R1N
         i = i+ 1
         call DSNDQWSA
  end

  /*restore offset */
  offset = save_offset

  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSB STATS COUNTERS*/
  /*  INSTRUMENTATION STATISTICS DATA ABOUT OUTPUT DESTINATION */
  QWS00R2O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSC */
  /*  IFCIDS RECORDED TO STATISTICS */
  QWS00R3O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ3ST */
  /*  Subsytem services fields */
  /*  SIGNON, IDEN, COMMITS, ABORTS ...*/
  QWS00R4O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  save_offset = offset
  offset = QWS00R4O - 4 + 1
  call DSNDQ3ST
  offset = save_offset
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ9ST */
  QWS00R5O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSD */
  /*  CHECKPOINT INFO, IFI COUNT    ...*/
  QWS00R6O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  save_offset = offset
  offset = QWS00R6O - 4 + 1
  call DSNDQWSD
  offset = save_offset
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVLS */
  /*  LATCH COUNTS                  ...*/
  QWS00R7O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVAS */
  /*  ASMC STATS NBRE DE SUSPENSIONS ..*/
  QWS00R8O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQSST */
  /*  STORAGE MANAGER */
  QWS00R9O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  save_offset = offset
  offset = QWS00R9O - 4 + 1
  call DSNDQSST
  offset = save_offset
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLST */
  /*  DDF STATS BY LOCATION */
  QWS00RAO = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQJST */
  /*  LOG MANAGER           */
  QWS00RBO = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  save_offset = offset
  offset = QWS00RBO - 4 + 1
  call DSNDQJST
  offset = save_offset
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQDST */
  /*  DBAT STATS            */
  QWS00RCO = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  save_offset = offset
  offset = QWS00RCO - 4 + 1
  call DSNDQDST
  offset = save_offset
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWOS */
  /*  ZOS STATS             */
  QWS00RDO = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  if  QWS00RDO > 0 then
  do
    offset = QWS00RDO - 4 + 1
    call DSNDQWOS
    offset = save_offset
  end
  else do
           QWOSLPRU=0
           QWOSDB2U=0
           QWOSLPIR=0
           QWOSDPIR=0
           QWOSLRST=0
           QWOSLRSF=0
           QWOSDRSU=0
           QWOSLUIC=0

  end
  /* LG = 112 = 14 SECTIONS * 8 */

  Return

/* This IFCID 199 seems not to be available with SMF
QW0199:
   numeric digits 15
       /* offset= offset of self definition section*/
       /* offset= offset + 8 : bypass pointer to Product  Section*/
       /* offset_d = offset de la 1ere data section */
       offset=offset+4+2+2 /*pointer to data section 1*/
       /*take the contents pointed by the offset */
       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))
       /* offset_d pointe sur la data section QW0199HE */
       if offset_d > 0 then say 'qw0199 offset1 present'
       /*dans tous les cas on va en data section 2 */
       offset=offset+8
       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))
       /* -------------- */
       /* data section 2 */
       /* -------------- */
       /* dbid */
       QW0199DB= C2D(SUBSTR(INPUT_REC,offset_d,2))
       say 'dbid ' QW0199DB
       offset_d=offset_d+2
       /* obid */
       QW0199OB= C2D(SUBSTR(INPUT_REC,offset_d,2))
       say 'obid' QW0199OB
       offset_d=offset_d+2
       /* dsnum*/
       QW0199DN= C2D(SUBSTR(INPUT_REC,offset_d,2))
       say 'dsn' QW0199DN
       offset_d=offset_d+2
       /* bpid */
       QW0199BP= X2D(SUBSTR(INPUT_REC,offset_d,1))
       say 'bpid' QW0199BP
       offset_d=offset_d+1
       /* Flags */
       QW0199DS= x2c(SUBSTR(INPUT_REC,offset_d,1))
       offset_d=offset_d+1
       say 'QW0199DS' QW0199DS
     /*QW0199SV
       QW0199SX  */
       offset_d=offset_d+8
       /* Total I/O Synchronous*/
       QW0199SP = C2D(SUBSTR(INPUT_REC,offset_d,4))
       say 'nb IO sync' QW0199SP
       offset_d=offset_d+4
     /*QW0199AD
       QW0199AX  */
       offset_d=offset_d+8
       /* Total I/O Pages ASynchronous*/
       QW0199AP = C2D(SUBSTR(INPUT_REC,offset_d,4))
       say 'total io pages' QW0199AP
       offset_d=offset_d+4
       /* Total I/O Count*/
       QW0199AC = C2D(SUBSTR(INPUT_REC,offset_d,4))
       say 'total io count' QW0199AC
       offset_d=offset_d+4
       /* Current pages count in this BP*/
       QW0199VP = C2D(SUBSTR(INPUT_REC,offset_d,4))
       say 'current pages ' QW0199VP
       offset_d=offset_d+4
       /* Current changed pages count in this BP*/
       QW0199VD = C2D(SUBSTR(INPUT_REC,offset_d,4))
       say 'current changed pages ' QW0199VD
       offset_d=offset_d+8
       /* Current number of getpages */
       QW0199GP = C2D(SUBSTR(INPUT_REC,offset_d,4))
       say 'current get pages ' QW0199GP
       offset_d=offset_d+4

   return
*/
QW0225:
numeric digits 15
       offset_save=offset /* sauvergarde offset debut data section*/
       /* offset= offset of self definition section*/
       /* offset= offset + 8 : bypass pointer to Product  Section*/
       /* offset_d = offset de la data section */
       offset=offset+4+2+2 /*pointer to data section 1*/
       /*take the contents pointed by the offset */
       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))

       /* -------------- */
       /* data section 1 */
       /* -------------- */
       /* Data section 1 = 2 parts, DBM1 and DIST */

       /* offset to dbm1 */
       offset_d=offset_d -4+1
       offset=offset+4

    /* say 'offs sect1'  offset_d */
       /* len of data section 1 : it will be repeated :*/
       /* One for DBM1 and one for DIST */
       len=      C2D(SUBSTR(INPUT_REC,OFFSET,2))
       offset=offset+2
       rep=      C2D(SUBSTR(INPUT_REC,OFFSET,2))
       offset=offset+2
    /* say 'len' len
       say 'rep' rep */

       /* offset to DIST */
       offset_d2=offset_d+len

    /* say 'offs sect2'  offset_d2 */

       QW0225AN =(SUBSTR(INPUT_REC,OFFSET_d,4))
       if  QW0225AN <> 'DBM1' then
       do
           say 'W0225 - Mapping error'
           exit 8
       end
    /***********************************/
    /* Processing DBM1 storage section */
    /***********************************/
       if  QW0225AN =  'DBM1' & vsm ='Y'  then
       do
           offset_d=offset_d+4
           /* extended region size */
           QW0225RG = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4+4+4
           QW0225EL = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4
           QW0225EH = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4 +4+4
           /* storage reserved fo must complete */
           /* before V10 depends on CTHREAD and MAXDBAT zparm*/
           QW0225CR = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4
           /* storage reserved for open/close datasets */
           /* depends on DSMAX value */
           QW0225MV = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4
           QW0225SO = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4
           QW0225GS = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4+4
           QW0225VR = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4
           QW0225FX = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4
           QW0225GM = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4
           /* 31 bit storage available */
           QW0225AV = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
           offset_d=offset_d+4+4+8+8+8+8
           QW0225RL_dbm1 = C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           /* 225RL = Real stor. frame used by the Address Space*/
           /*    this includes bufferpools storage qw0225bb */
           offset_d=offset_d+8
           QW0225AX_dbm1 = C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           offset_d=offset_d+8
           /* QW0225HVPagesInReal 64 bits private Real */
           QW0225HVPagesInReal =  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           offset_d=offset_d+8
           /* QW0225HVAuxSlots    64 bits private Aux */
           QW0225HVAuxSlots =  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           offset_d=offset_d+24
      /*   /* QW0225HWM           64 bits private Real*/
           QW0225HVGPagesInReal =  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           offset_d=offset_d+8
           /* QW0225HWM           64 bits private Aux */
           QW0225HVGAuxSlots=  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           offset_d=offset_d+8 */
           /* QW0225PagesInReal 64 bits private Real without BP */
           QW0225PriStg_Real=  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           offset_d=offset_d+8
           /* QW0225PagesInAux  64 bits private Aux  without BP */
           QW0225PriStg_Aux=  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
           offset_d=offset_d+8
           TotalRealUsedBP = QW0225HVPagesInReal - QW0225PriStg_Real
           TotalAuxUsedBP = QW0225HVAuxSlots    - QW0225PriStg_Aux
       end  /* if  QW0225AN =  'DBM1' & vsm = 'Y' then */

       /* rep = 2 : there is 2 parts , DBM1 and DDF */
       if rep = 2 then
       do
          /* partie DIST */
          QW0225AN =(SUBSTR(INPUT_REC,OFFSET_d2,4))
          if  QW0225AN <> 'DIST'  then
          do
              say 'W0225 - Mapping error DIST not found'
              say 'input_rec' input_rec
              say 'offset'   offset_d2
              exit 8
          end
          if  QW0225AN =  'DIST' & vsm='Y' then
          do
              offset_d2=offset_d2+4
              offset_d2=offset_d2+4+4+4
              offset_d2=offset_d2+4
              offset_d2=offset_d2+4 +4+4
              offset_d2=offset_d2+4
              offset_d2=offset_d2+4
              offset_d2=offset_d2+4
              offset_d2=offset_d2+4+4
              offset_d2=offset_d2+4
              offset_d2=offset_d2+4
              offset_d2=offset_d2+4+4+4+8+8+8+8
              QW0225RL_dist = C2D(SUBSTR(INPUT_REC,offset_d2,8))
              offset_d2=offset_d2+8
              QW0225AX_dist = C2D(SUBSTR(INPUT_REC,offset_d2,8))
          end  /* if  QW0225AN =  'DIST' & vsm = 'Y' then */
       end
       else /*if rep = 2 then*/
       do
              QW0225RL_dist = 0
              QW0225AX_dist = 0
       end

       /*pointer to data section 2*/

       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))
       offset_d=offset_d -4+1


       QW0225AT =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
       offset_d=offset_d+4 /*pointer on data section 2*/
       QW0225DB =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))

       if (QW0225AT + qw0225DB) < MinThdSee then
          do
              MinThdSee = QW0225AT + qw0225DB
              MinThdSeeTime= run_fmt_time
              MinThdSeeDate= sm100dte
          end
       if (QW0225AT + qw0225DB) > MaxThdSee then
          do
              MaxThdSee = QW0225AT + qw0225DB
              MaxThdSeeTime= run_fmt_time
              MaxThdSeeDate= sm100dte
          end
       /* say 'threads allied=' QW0225AT
          say 'threads dbat=' QW0225DB      */

       /*pointer to data section 3 : Shared and Common Storage */
       offset=offset+8 /* go to next pointer*/
       if vsm = 'Y' then
       do
          /* load address of section 3*/
          offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))
          offset_d=offset_d -4+1

          offset_d=offset_d +136
          QW0225SHRINREAL  =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
          offset_d=offset_d + 32
          QW0225ShrStg_Real=C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
          offset_d=offset_d + 8
          QW0225ShrStg_Aux =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
          offset_d=offset_d + 8
          QW0225ShrStkStg_Real=C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
          offset_d=offset_d + 8
          QW0225ShrStkStg_Aux =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
          offset_d=offset_d + 8
          QW0225ComStg_Real=C2D(SUBSTR(INPUT_REC,OFFSET_d,8))
          offset_d=offset_d + 8
          QW0225ComStg_Aux =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))

         /* formula from    Redbook V11 Monitoring */
         /* table 13-1 13-2                        */
         /* Calculation to be updated when V11 + Log Mgr control */
         /* in Real, Log. write buffers  */
          TotalRealUsedByDB2 = qw0225rl_dbm1+ qw0225rl_dist +,
                 QW0225ShrStg_Real + QW0225ShrStkStg_Real +,
                 QW0225ComStg_Real

      /*  TotalRealUsedByLPAR meaning not clear - value does not  */
      /*     corresponds with others z/OS monitoring tool         */
      /*  TotalRealUsedByLPAR= qw0225rl_dbm1+ qw0225rl_dist +,    */
      /*       QW0225ComStg_Real + -- in redbook but no where else*/
      /*                           QW0225SHRINREAL                */
          /* QW0225ComStg_Real Real in use 64 bit shared */
          /* QW0225SHRINREAL   Real in use 64 bit common */

      /*  if MaxRealLPAR  <  TotalRealUsedByLPAR then */
      /*       do                                     */
      /*           MaxRealLPAR = TotalRealUsedByLPAR  */
      /*           time_MaxRealLPAR = run_fmt_time    */
      /*       end                                    */

          offset_d=offset_d + 32
      /*  QW0225_WARN      =C2D(SUBSTR(INPUT_REC,OFFSET_d,4)) */
          offset_d=offset_d + 8
          QW0225_REALAVAIL =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))

          if MinQW0225_REALAVAIL > QW0225_REALAVAIL then
               do
                   MinQW0225_REALAVAIL = QW0225_REALAVAIL
                   time_MinQW0225_REALAVAIL = run_fmt_time
                   date_MinQW0225_REALAVAIL = sm100dte
               end
       end

       /*-------------------------*/
       /*pointer to data section 4*/
       /*-------------------------*/
       offset=offset+8

       /*-------------------------------------------------*/
       /*pointer to data section 5 : Pool storage details */
       /*-------------------------------------------------*/
       offset=offset+8
       if  vsm = 'Y' then
       do
         offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))
         offset_d= offset_d+4
       /* QW0225AS Total system agent storage 31 bits*/
         QW0225AS =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))
       /* QW0225BB Total buffer manager storage blocks */

       /*-------------------------------*/
       /* Calculate max threads allowed */
       /*-------------------------------*/

         /*Ici on a eu tous les infos on peut donc calculer le */
         /* nombre de threads max theoriques*/
         /* Source : IBM formula  */
         /* (Redbook V11 subsystem monitoring Chap. Virtual Stor*/
         /* Min and Max is used in a very defensive way */
         /* The excel proposed with MEMU deoesn't use min max */
         /* I also caculate this value (thdcomp2) */

         /*    Thread footprint calculation : */

         /* Basic Storage Cushion */
         BC = QW0225CR + QW0225MV + QW0225SO
         /* Non DB2 storage, retains max value for final calculation*/
         ND = QW0225EH-QW0225GM-QW0225GS-QW0225FX-QW0225VR
         if ND > MaxND then MaxND=ND
         /* Max Allowable storage */
         AS = QW0225RG-BC-MaxND
         AS2= QW0225RG-BC-ND
         if AS < MinAS then MinAS=AS
         /* Max Allowable storage for thread use*/
         TS = MinAS-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)
         TS2= AS2-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)
         if TS < MinTS then MinTS=TS
         /* Average thread footprint */
         if (QW0225AT + qdstcnat) = 0 then
            /* if threads in system = 0 then 1 */
            TF =  QW0225VR- QW0225AS + QW0225GS
         else
            TF = (QW0225VR-QW0225AS+QW0225GS)/(QW0225AT+qdstcnat)

         if TF > MaxTF then MaxTF=TF
         /* Max threads supported    */
         ThdComp=MinTS/MaxTF
         ThdComp2=TS2/TF
         StorBefContract=qw0225AV-(qw0225cr+qw0225SO+qw0225MV)
         /* Storage contraction ?*/
         if qw0225AV <  qw0225cr then
                do
                    say ' Storage critical condition',
                        'Ã  ' run_fmt_time
                end
         else do
              if qw0225AV <  (qw0225cr+ qw0225SO+qw0225MV) then
                do
                    say ' Full system contraction should happen',
                        'Ã  ' run_fmt_time
                end
         end /* else */

         if ThdComp < MinThdComp then do
                                     MinThdComp =ThdComp
                                     MinThdCompTime=run_fmt_time
                                     MinThdCompDate=sm100dte
                                   end
         if ThdComp2 < MinThdComp2 then do
                                     MinThdComp2 =ThdComp2
                                     MinThdComp2Time=run_fmt_time
                                     MinThdComp2Date=sm100dte
                                   end
         if ThdComp > MaxThdComp then do
                                     MaxThdComp =ThdComp
                                     MaxThdCompTime =run_fmt_time
                                     MaxThdCompDate =sm100dte
                                   end
         if ThdComp2 > MaxThdComp2 then do
                                     MaxThdComp2 =ThdComp2
                                     MaxThdComp2Time =run_fmt_time
                                     MaxThdComp2Date =sm100dte
                                   end

         Real4K_dbm1=(QW0225RL_dbm1 *4096)/ 1048576    /*1MB*/
         Real4K_dist=(QW0225RL_dist *4096)/ 1048576    /*1MB*/

         If MinReal4K_dbm1 > Real4K_dbm1 then
                          do
                             MinReal4K_dbm1=Real4K_dbm1
                             time_MinReal4K_dbm1=run_fmt_time
                             Date_MinReal4K_dbm1=sm100dte
                          end
         If MaxReal4K_dbm1 < Real4K_dbm1 then
                          do
                             MaxReal4K_dbm1=Real4K_dbm1
                             time_MaxReal4K_dbm1=run_fmt_time
                             Date_MaxReal4K_dbm1=sm100dte
                          end
         If MinReal4K_dist > Real4K_dist then
                          do
                             MinReal4K_dist=Real4K_dist
                             time_MinReal4K_dist=run_fmt_time
                             Date_MinReal4K_dist=sm100dte
                          end
         If MaxReal4K_dist < Real4K_dist then
                          do
                             MaxReal4K_dist=Real4K_dist
                             time_MaxReal4K_dist=run_fmt_time
                             Date_MaxReal4K_dist=sm100dte
                          end
         /* calculation to be updated when V11 + Log Mgr control */
         /* in aux - check IBM excel provided with memu */
         TotalAuxlUsedByDB2 = qw0225ax_dbm1+ qw0225ax_dist +,
               QW0225ComStg_Aux  + QW0225ShrStg_Aux  +  ,
                                   QW0225ShrStkStg_Aux
         If MaxDB2AuxUse < TotalAuxlUsedByDB2 then
                          do
                             MaxDB2AuxUse=TotalAuxlUsedByDB2
                             timeMaxDB2AuxUse=run_fmt_time
                             DateMaxDB2AuxUse=sm100dte
                          end
       end /* if vsm ... */
return
/* MAP SELF-DEFINING SECT IFCID 002 LG = 12X8 = 96 */
DSNDQWS1:
  /*  OFFSET TO THE PRODUCT SECTION */
  QWS10PSO = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  offset= offset + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQXST */
  /*  RDS stats block  */
  QWS10R1O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 8
  if  QWS10R1O > 0 then
  do
    save_offset = offset
    offset = QWS10R1O - 4 + 1
    call DSNDQXST
    offset = save_offset
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTST */
  /*  Binds counts, Plans allocated succ ... */
  QWS10R2O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  offset = OFFSET + 8
  if QWS10R2O > 0 then
  do
     save_offset = OFFSET
     offset = QWS10R2O - 4 + 1
     call DSNDQTST
     offset = save_offset
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBST */
  /*  Buffer manager stats                          */
  QWS10R3O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 4
  QWS10r3L = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  QWS10r3N = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  /* decode dsndqbst to have  buffer stats */
  if  QWS10R3O > 0 then
  do
      save_offset= offset
      offset=QWS10R3O - 4 + 1
      call init_sum_bpstats
      /*add code here if need figures by bufferpool ID */
      m=0
      do until m= QWS10r3N
             m = m+ 1
             call dsndqbst
      end
      call comp_sum_bpstats
      /* Just read => Old bpstats */
      call switch_bpstats
      offset=save_offset
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQIST */
  /*  Data   manager stats                          */
  QWS10R4O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  offset = OFFSET + 8
  if QWS10R4O > 0 then
  do
     save_offset = OFFSET
     offset = QWS10R4O - 4 + 1
     call DSNDQIST
     offset = save_offset
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTXA */
  /*  Lock   manager stats                          */
  QWS10R5O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  offset = OFFSET + 8
  if QWS10R5O > 0 then
  do
     save_offset = OFFSET
     offset = QWS10R5O - 4 + 1
     call DSNDQTXA
     offset = save_offset
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISE */
  /*  EDM Pool stats                                */
  QWS10R6O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 4
  QWS10R6L = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  QWS10R6N = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  if QWS10R6O > 0 then
  do
     save_offset = OFFSET
     offset = QWS10R6O - 4 + 1
     call DSNDQISE
     offset = save_offset
  end
  /*  Stop here if not BP Simul. */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBGL */
  /*  Group BufferPool stats                        */
  QWS10R7O = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  OFFSET = OFFSET + 6
  QWS10R7N = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  OFFSET = OFFSET + 2
  if  QWS10R7O > 0 then
  do
       save_offset = offset
       offset = QWS10R7O - 4 + 1
       call init_gbpstats
       m=0
       do until m= QWS10r7N
           m = m+ 1
           call DSNDQBGL
       end /* do until */
       call comp_diff_gbpstats
       call switch_gbpstats
       offset = save_offset
  end  /* QWS10R7O > 0  */
  /*  Others sections ...                           */
  /*  Jump to BP Simulated data */
  offset = offset + 32
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTGS */
  /*  Global Locking                                */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLES */
  /*  Language Envt Stats                           */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISJ */
  /*  Start Join    Stats                           */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ8ST */
  /*  Accelerator Services Stats                    */
  /*  */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBSP */
  /*  Simulated Buffer Pool Stats                   */
  if BPSim = 'N' then return /* haha */
  QWS10RCO = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  offset = offset + 4
  QWS10RCL = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  offset = offset + 2
  QWS10RCN = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  offset = offset + 2
  /* continuation flag from DSNDQBSP data */
  if  QWS10RCO > 0 then
  do
      save_offset= offset
      offset=QWS10RCO - 4 + 1
 /*  say SUBSTR(INPUT_REC,OFFSET,104)
  say SUBSTR(INPUT_REC,OFFSET+104,104) */
      m=0
      do until m= QWS10RCN
             m = m+ 1
             call DSNDQBSP
      end
      offset=save_offset
  end
  else
  do
      Simbp_entry.0=0
  end
  /*************************************/
  /* End of IFCID002 (for this moment) */
  /*************************************/
  return


/* MAP STANDARD HEADER PRODUCT SECTION */
DSNDQWHS:
  OFFSET = OFFSET + 2
  QWHSTYP = C2D(SUBSTR(INPUT_REC,OFFSET,1))
  OFFSET = OFFSET + 2
  /* QWHSIID DS XL2 IFCID */
  QWHSIID = C2D(SUBSTR(INPUT_REC,OFFSET,2))
  IFCID=QWHSIID
  OFFSET = OFFSET + 3
  /* release number */
  QWHSRN = C2X(SUBSTR(INPUT_REC,OFFSET,1))
  OFFSET = OFFSET + 5
  /* QWHSSSID DS CL4 SUBSYSTEM NAME */
  QWHSSSID = SUBSTR(INPUT_REC,OFFSET,4)
  OFFSET = OFFSET + 64
  /* TOTAL LENGTH = 76 */
  RETURN

/* STATISTICS CPU TIME MAPPING MACRO LG = 52*4*/
DSNDQWSA:
    numeric digits 15
    QWSAPROC =(SUBSTR(INPUT_REC,OFFSET,4))
    OFFSET = OFFSET + 4
    /*CONVERT INTO HEX VALUE*/
    QWSAEJST = C2X(SUBSTR(INPUT_REC,OFFSET,8))
    /*ELIMINATE 1.5 BYTES */
    QWSAEJST = X2D(SUBSTR(QWSAEJST,1,13))
    QWSAEJST = QWSAEJST/1000000
    OFFSET = OFFSET + 8

    QWSASRBT = C2X(SUBSTR(INPUT_REC,OFFSET,8))
    QWSASRBT = X2D(SUBSTR(QWSASRBT,1,13))
    QWSASRBT = QWSASRBT/1000000
    OFFSET = OFFSET + 8
    OFFSET = OFFSET + 8    /* saut zones */

    QWSAPSRB = C2X(SUBSTR(INPUT_REC,OFFSET,8))
    QWSAPSRB = X2D(SUBSTR(QWSAPSRB,1,13))
    QWSAPSRB = QWSAPSRB/1000000
    OFFSET = OFFSET + 8

    QWSAPSRB_zIIP = C2X(SUBSTR(INPUT_REC,OFFSET,8))
    QWSAPSRB_ziip = X2D(SUBSTR(QWSAPSRB_zIIP,1,13))
    QWSAPSRB_ziip = QWSAPSRB_ziip/1000000
    OFFSET = OFFSET + 8
    OFFSET = OFFSET + 8  /*saut */

    Select
         When qwsaproc  = 'MSTR' Then do
                    MstrTcb      =QWSAEJST
                    MstrSrb      =QWSAsrbt
                    MstrpSRB     =QWSApsrb
                    MstrpSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'DBM1' Then do
                    DBM1Tcb      =QWSAEJST
                    DBM1Srb      =QWSAsrbt
                    DBM1pSRB     =QWSApsrb
                    DBM1pSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'DIST' Then do
                    DISTTcb      =QWSAEJST
                    DISTSrb      =QWSAsrbt
                    DISTpSRB     =QWSApsrb
                    DISTpSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'IRLM' Then do
                    IRLMTcb      =QWSAEJST
                    IRLMSrb      =QWSAsrbt
                    IRLMpSRB     =QWSApsrb
                    IRLMpSRB_Ziip=QWSApsrb_ziip
                 end
         Otherwise      do
                          say 'qwsaproc NOT correct' qwsaproc
                          exit 8
                        end
    end   /* select */
RETURN

DSNDQISE:
    /* EDMPOOL STATS */
    numeric digits 15
    /* Fields from IFCID002  : all cumulative */
    /* calculate difference between interval */

    /*Â£ OF REQ FOR CT SECTIONS*/
    offset = offset + 8
    QISECTG = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF LOAD CT SECT FROM DASD*/
    offset = offset + 4
    QISECTL = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF REQUESTS FOR DBD*/
    offset = offset + 20
    QISEDBDG = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF LOAD DBD FROM DASD*/
    offset = offset + 4
    QISEDBDL = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF REQ FOR PT SECTIONS*/
    offset = offset + 4
    QISEKTG  = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF LOAD PT SECT FROM DASD*/
    offset = offset + 4
    QISEKTL = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 12
    /*Â£ OF Inserts  FOR DYN CACHE*/
    QISEDSI  = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF REQUESTS FOR DYN CACHE*/
    offset = offset +  4
    QISEDSG  = C2D(SUBSTR(INPUT_REC,offset,4))
    /*NUMBER OF PAGES IN DBD POOL*/
    offset = offset + 12
    QISEDPGE = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF FREE PG IN DBD FREE CHAIN*/
    offset = offset + 4
    QISEDFRE = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF FAIL DUE TO DBD POOL FULL*/
    offset = offset - 8
    QISEDFAL = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF PGS IN DYN STMT POOL*/
    offset = offset + 20
    QISECPGE = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF FREE PG IN STMT FREE CHAIN*/
    offset = offset + 4
    QISECFRE = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF FAIL DUE TO STMT POOL FULL*/
    offset = offset - 8
    QISECFAL = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF PAGES IN SKEL EDM POOL*/
    offset = offset + 24
    QISEKPGE = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF FREE PG IN SKEL EDM POOL FREE CHAIN */
    offset = offset + 4
    QISEKFRE = C2D(SUBSTR(INPUT_REC,offset,4))
    /*Â£ OF FAIL DUE TO STMT SKEL POOL FULL*/
    offset = offset - 8
    QISEKFAL = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 52
    /* Total stealable SKEL pages*/
    QISEKLRU = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* Total stealable DBD  pages*/
    QISEDLRU = C2D(SUBSTR(INPUT_REC,offset,4))

return
DSNDQWSD:
    /* Nbr of checkpoints cumulative value */
    QWSDCKPT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
 return
DSNDQSST:
    offset= offset+4
    /* eye catcher */
    eyec     = SUBSTR(INPUT_REC,OFFSET,4)
    if ( eyec     <> 'QSST' ) then
                  do
                      say 'DSNDQSST eye catcher not met, error'
                      exit(8)
                  end
    offset= offset+4*14
    /* full storage contraction*/
    QSSTCONT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    QSSTCRIT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    QSSTABND = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
 return
DSNDQTXA:
    /* Deadlocks */
    QTXADEA  = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 8
    /* TimeOuts  */
    QTXATIM  = C2D(SUBSTR(INPUT_REC,OFFSET,4))
 return

DSNDQTST:
    /* Service Controler Stats */
    offset= offset+4
    /* eye catcher */
    eyec     = SUBSTR(INPUT_REC,OFFSET,4)
    if ( eyec     <> 'QTST' ) then
                  do
                      say 'DSNDQTST eye catcher not met, error'
                      exit(8)
                  end
    offset= offset+72
    /* Datasets opened (snapshot)*/
    QTDSOPN  =  C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 48
    /* DS closed by drain DSMAX reached */
    QTDSDRN  =  C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* RWRO Convert */
    QTPCCT   =  C2D(SUBSTR(INPUT_REC,OFFSET,4))

 return
DSNDQ3ST:
    /* DB2 Subsystem services fields */
    offset= offset+4
    /* Signon, meaningful only with CICS or IMS */
    /* Nbr of signon for new user of an EXISTING thread*/
    /* If Signon > CrtThread then there is Thread reuse */
    Q3STSIGN = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* Create thread (does not include DBAT) */
    Q3STCTHD = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* Terminate     */
    Q3STTERM = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 8
    /* Commit1 */
    Q3STPREP = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* Commit2 */
    Q3STCOMM = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* Aborts */
    Q3STABRT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4*9
    /* HWM   IDBACK*/
    Q3STHWIB = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* HWM   IDFORE*/
    Q3STHWIF = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* HWM   CTHREAD*/
    Q3STHWCT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
 return

DSNDQJST:
    offset=offset+4
    /* eye catcher */
    eyec     = SUBSTR(INPUT_REC,OFFSET,4)
    if ( eyec     <> 'QJST' ) then
                  do
                      say 'DSNDQJST eye catcher not met, error'
                      exit(8)
                  end
    offset=offset+40
    /* active log output CI created */
    QJSTBFFL = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 16
    /* CI offloaded */
    QJSTCIOF = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    return
DSNDQDST:
    if QWS00RCO = 0 then
    /* No DDF information */
      do
          say 'There is no DDF information in this trace'
          say ' '
          QDSTQDBT =0
          QDSTQCRT =0
          QDSTQCIT =0
          QDSTQMIT =0
          QDSTCNAT =0
          QDSTHWAT =0
          QDSTHWDT =0
          QDSTCIN2 =0
          QDSTMIN2 =0
          return
      end
    /* dbat queued */
    QDSTQDBT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 20 /* 4x 5 */
    /* dbat rejected condbat reached */
    QDSTQCRT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* current inact 1 */
    QDSTQCIT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* max     inact 1 */
    QDSTQMIT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* curr pooled dbat : active and disconnect */
    QDSTCNAT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* max  pooled dbat : active and disconnect */
    QDSTHWAT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* max  dbat        : max active + inact    */
    QDSTHWDT = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 8
    /* cur inact 2        */
    QDSTCIN2 = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* max inact 2        */
    QDSTMIN2 = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    return

DSNDQXST:
    /*************************************************/
    /*  RDS STATISTICS BLOCK  DSNDQXST               */
    /*************************************************/
    /* Fields from IFCID002 : cumulative */
    /* calculate difference between interval */
    offset=offset+4
    /* eye catcher */
    eyec     = SUBSTR(INPUT_REC,OFFSET,4)
    if ( eyec     <> 'QXST' ) then
                  do
                      say 'offset=' offset
                      eyec = SUBSTR(INPUT_REC,1,100)
                      say 'eyec' eyec
                      say 'DSNDQXST eye catcher not met, error'
                      exit(8)
                  end
    offset  =  offset + 4
    /* Selects     */
    QXSELECT = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /* Inserts     */
    QXINSRT  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /* Update      */
    QXUPDTE  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /* Delete      */
    QXDELET  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8 * 20
    /* Fetch       */
    QXFETCH  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8 * 14
    /*---*/
    /*Â£RID List failed No storage */
    QXNSMIAP = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ Failed Limit exceeded */
    QXMRMIAP = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8*31
    /*Â£ Short Prepare */
    QXSTFND  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ Full Prepare */
    QXSTNFND  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ Implicit Prepare = FULL prepare */
    QXSTIPRP  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ Avoided  Prepare */
    QXSTNPRP  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ Stmt discarded - MAXKEEPD */
    QXSTDEXP  = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8*62
    /* (...) */
    /*Â£ RID list Overflowed to Workfile No Storage */
    QXWFRIDS = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ RID list overflowed to wKk Limit Exceeded   */
    QXWFRIDT = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ RID list append for a hybrid join was interrupt No Storage*/
    QXHJINCS = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
    /*Â£ RID list append for a hybrid join Limit exceeded*/
    QXHJINCT = C2D(SUBSTR(INPUT_REC,offset,8))
    offset  =  offset + 8
return
DSNDQXST0:
    QXSELECT = 0
    QXINSRT  = 0
    QXUPDTE  = 0
    QXDELET  = 0
    QXFETCH  = 0
    QXNSMIAP = 0
    QXSTFND  = 0
    QXSTNFND = 0
    QXSTIPRP = 0
    QXSTNPRP = 0
    QXSTDEXP = 0
    QXWFRIDS = 0
    QXWFRIDT = 0
    QXHJINCS = 0
    QXHJINCT = 0
    QXMRMIAP = 0
return

GET_FMT_TIME:
  RUN_HH = SM100TME % 360000
  RUN_HH = RIGHT(RUN_HH,2,'0')
  RUN_MIN = SM100TME % 6000 - RUN_HH*60
  RUN_MIN = RIGHT(RUN_MIN,2,'0')
  RUN_SEC = SM100TME % 100 - RUN_HH *3600 - RUN_MIN*60
  RUN_SEC = RIGHT(RUN_SEC,2,'0')
  RUN_FMT_TIME = RUN_HH||':'||RUN_MIN||':'||RUN_SEC
  RETURN


write_header:
  say 'CSV file ' oufl     ' will be produced'
  outrec.0= 1
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,MstrTCB,MstrSRB,MstrPSRB,"||,
         "MstrPSRB_Ziip,Dbm1TCB,DBm1SRB,DBm1PSRB,Dbm1PSRB_Ziip,"||,
                       "IrlmTCB,IrlmSRB,IrlmPSRB,IrlmPSRB_Ziip,"||,
                       "DistTCB,DistSRB,DistPSRB,DistPSRB_Ziip,"||,
         "Chkpt,"||,
         "CrtThd,Sign,Term,Comm1,Comm2,Abort,MaxIDBACK,"||,
         "MaxIDFOR,MaxCTHREAD,"||,
         "DSCur,DSClose,RWROSwitch,DSOpen,"||,
                  "Getpage,GpSeq,Syncio,Pgwritten,SyncWr,AsyncWr,"||,
                       "PageInR,PageInW,"||,
                       "SPrefIO,CastIO,DynPrfIO,LstPrfIO,BpSio,"||,
         "CurInac1,MaxInac1,CurActDbat,MaxActDbat,MaxAllDbat,"||,
         "CurInac2,MaxInac2,"||,
         "CurAldThds,CurActDbat,ThdMaxComp,ThdMaxComp2,"||,
         "TotRealUsedDB2,TotAuxUsedDB2,"||,/* Storage data*/
         "TotRealUsedBP,TotAuxUsedBP,RealAvail,"||,
         "ExtRegionSz,31bAvail,StorBefContrac,"||,
         "FullContractions,StorCrit,NbAbndsStor,"||,
         "NotOptColProc,"||,
      /* Workfiles block */ ,
         "32KbUsed4Prf,4KbUsed32Prf,MaxWfKB,"||,
         "CurWfKB,Cur4KWfKB,Cur32KWfKB,"||,
         "CurDMInMemWfNb,CurDMInMemWfKB,"||,
         "CurSRInMemWfNb,CurSRInMemWfKB,"||,
         "CurRIDsOvfWf,CurNonSRTWfNb,"||,
         "NbPhysWfCrt,MaxWfUsedThdKB,"||,
         "AllWfConfKB,DGTTWfConfKB,"||,
         "OthWfConfKB,"||,
         "CurDGTTUseKB,MaxDGTTUseKB,"||,
         "CurOthUseKB,MaxOthUseKB,"||,
     ,/* EDM Pool block  */
        "MaxRIDBlocks,"||,
        "ReqCT,LoadCT,ReqDBD,LoadDBD,ReqPT,LoadPT,ReqDynCach,"||,
         "InsDynC,"||,
         "DBDPg,DBDFree,DBDStealable,FailDBDFul,STMPoolPg,"||,
         "StmtFree,"||,
         "FailStmFul,SKelPg,SKelFree,SkelStealable,FailSkFul,"||,
    ,/* Locks           */
         "DdLok,TimO,"||,
    ,/* RID Pool block  */
         "Sel,Ins,Upd,Del,Fetch,"||,
         "Prepare,ShortP,ImplP,AvoidP,PrepMAXKD,"||,
         "RIDFailStor,RIDFailLim,RIDOvflStor,RIDOvflLim,"||,
         "RIDHybFailStor,RIDHybFailLim,"||,
         "RIDTrmRDS,RIDTrmDM,"||,
    ,/* Logging */
         "ActLogCI,CIOff,"||,
    ,/*ZOS Stats*/
         "CpuLpar,CpuDB2,PageInLpar,PageInDB2,RealLpar,RealFree,"||,
         "RealDB2,UIC"
     /*  Zones below correspond to the ibm provided excel columns */
     /*  "Z,BE,CV,CX,CZ,CU,CW,CY,CQ,Y,BD"  */

  "EXECIO 1 DISKW OUFL (STEM OUTREC. "

  /*------------------------------*/
  /* Header for Buffer pool stats */
  /*------------------------------*/
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,Bp,BpSize,"||,
                  "Getpage,GpSeq,Syncio,PgWritten,SyncWr,AsyncWr,"||,
                  "PageInR,PageInW,"||,
          "SPrefIO,CastIO,DynPrfIO,LstPrfIO,BpSio,"||,
                  "MinSRLU,MaxSLRU,NbSLRUFull,NbRandSLRU"

  "EXECIO 1 DISKW OUFL2 (STEM OUTREC. "

  /*------------------------------*/
  /* Header for GBP         stats */
  /*------------------------------*/
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,GBP,"||,
          "GBPGetp,XIReadRet,XIReadNoRet,XIMiss,AsyncW,SyncW"

  "EXECIO 1 DISKW OUFL5 (STEM OUTREC. "

  /*------------------------------*/
  /* Header for Storage     stats */
  /*------------------------------*/
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,TotalRealDB2,"||,
           "RealDBM1,RealDist,ShrReal,StkReal,ComReal," ||,
           "AuxDBM1,AuxDist,ShrAux,StkAux,ComAux," ||,
           "ShrRealLPAR," ||,
           "TotAuxDB2,TotRealBP,TotAuxBP,RealAvLPAR," ||,
           "ExtRegSz,StoAvDB2"

  "EXECIO 1 DISKW OUFL3 (STEM OUTREC. "

  if BPSim = 'N' then return
  /*--------------------------------*/
  /* Header for BP Simulation Stats */
  /*--------------------------------*/
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,BPId,"||,
           "SimSize,SeqPage,SyncIOAvoided,SeqSyncIO,AsyncPgRd," ||,
           "GSyncIO,GSeqSyncIO,GAsyncPgRd," ||,
           "PgMov,TotSyncIOWaitAvoided"

  "EXECIO 1 DISKW OUFL4 (STEM OUTREC. "

  return


write_report:
    reco= reco+ 1
    /* bypass first record because off difference calculation */
    if reco = 1 then return
    /* Warning messages or not ? */
    if Alert='Y' then call CheckForAlert
    /*---*/
    outrec.0= 1
    outrec.1= sm100sid  || ',' || sm100ssi || ','  ,
    || '"'sm100dte'"'   || ','   ,
    || run_fmt_time     || ','   ,
    || run_hh           || ','   ,
    || dif_MstrTcb      || ','   ,
    || dif_MstrSrb      || ','   ,
    || dif_MstrpSRB     || ','   ,
    || dif_MstrpSRB_ziip || ','   ,
    || dif_dbm1Tcb      || ','   ,
    || dif_dbm1Srb      || ','   ,
    || dif_dbm1pSRB     || ','   ,
    || dif_dbm1pSRB_ziip || ','   ,
    || dif_IrlmTcb      || ','   ,
    || dif_IrlmSrb      || ','   ,
    || dif_IrlmpSRB     || ','   ,
    || dif_IrlmpSRB_ziip || ','  ,
    || dif_DistTcb      || ','   ,
    || dif_DistSrb      || ','   ,
    || dif_DistpSRB     || ','    ,
    || dif_DistpSRB_ziip || ','   ,
    || Dif_QWSDCKPT      || ','   ,     /* Checkpoints */
    || Dif_Q3STCTHD  || ','        ,     /* Create Thd */
    || Dif_Q3STSIGN  || ','        ,     /* Signon  */
    || Dif_Q3STTERM  || ','        ,     /* Terminate*/
    || Dif_Q3STPREP  || ','        ,     /* Commit phase 1 */
    || Dif_Q3STCOMM  || ','        ,     /* Commit Ph 2*/
    || Dif_Q3STABRT  || ','        ,     /* Aborts */
    ||     Q3STHWIB  || ','        ,     /* Max IDBACK */
    ||     Q3STHWIF  || ','        ,     /* Max IDFORE */
    ||     Q3STHWCT  || ','        ,     /* Max CTHREAD */
    || QTDSOPN       || ','        ,     /* DS Current  */
    || Dif_QTDSDRN   || ','        ,     /* Close Drain */
    || Dif_QTPCCT    || ','        ,     /* RWRO switch */
    || Sum_QBSTDSO   || ','        ,     /* OPEN DS     */
    || Sum_QBSTGET   || ','        ,
    || Sum_QBSTSGT   || ','        ,     /* Sequential Getp */
    || Sum_QBSTRIO   || ','        ,
    || Sum_QBSTPWS   || ','        ,
    || Sum_QBSTIMW   || ','        ,
    || Sum_QBSTWIO   || ','        ,
    || Sum_QBSTRPI   || ','        ,
    || Sum_QBSTWPI   || ','        ,
    || Sum_QBSTPIO   || ','        ,
    || Sum_QBSTCIO   || ','        ,
    || Sum_QBSTDIO   || ','        ,
    || Sum_QBSTLIO   || ','        ,
    || Sum_QBSTSIO   || ','        ,
    || QDSTQCIT      || ','        ,     /* curr. inact type 1*/
    || QDSTQMIT      || ','        ,     /* max . inact type 1*/
    || QDSTCNAT      || ','        ,     /* curr. active dbat */
    || QDSTHWAT      || ','        ,     /* max active dbat */
    || QDSTHWDT      || ','        ,     /* max act & inact dbat */
    || QDSTCIN2      || ','        ,     /* current inactive */
    || QDSTMIN2      || ','        ,     /* hwm inactive */
    || QW0225AT      || ','        ,     /* curr. allied threads*/
    || QW0225DB      || ','        ,     /* curr . active dbat */
    || format(ThdComp ,4,0)   || ',' ,
    || format(ThdComp2,4,0)   || ',' ,
    || f2mb(TotalRealUsedByDB2)     || ',' ,
    || f2mb(TotalAuxlUsedByDB2)     || ',' ,
    || f2mb(TotalRealUsedBP)        || ',' ,
    || f2mb(TotalAuxUsedBP)         || ',' ,
    || f2mb(QW0225_REALAVAIL)       || ',' ,
    || b2mb(QW0225RG)               || ',' ,
    || b2mb(QW0225AV)               || ',' ,
    || b2mb(StorBefContract)        || ',' ,
    ||             QSSTCONT         || ',' ,
    ||             QSSTCRIT         || ',' ,
    ||             QSSTABND         || ',' ,
    ||         Dif_QISTCOLS         || ',' ,
  /* Workfiles block */ ,
    ||         Dif_QISTWFP1         || ',' ,
    ||         Dif_QISTWFP2         || ',' ,
    ||             QISTWMXU         || ',' ,
    /* Current all workfile usage in KB : DGTT and Sort */,
    || QISTWCTO     || ',' ,
    /* Current 4K wrkfile storage usage in KB*/ ,
    || QISTW4K      || ',' ,
    /* Current 32K wrkfile storage usage in KB*/,
    || QISTW32K     || ',' ,
    /* Nb DM in memory   wrkfiles active currently */ ,
    || QISTIMAC     || ',' ,
    /* Space DM in memory active currently in KB*/ ,
    || QISTIMSC     || ',' ,
    /* Nb SRT in memory   wrkfiles active currently */ ,
    || QISTSIAC     || ',' ,
    /* Space SRT in memory active currently in KB */ ,
    || QISTSISC     || ',' ,
    /* Current RID blocks overflowed (stored) in wrkfiles*/ ,
    || QISTWFRCUR   || ',' ,
    /* Current NON Sort related workfiles active */,
    || QISTI2AC     || ',' ,
    /* Physical  workfiles created */,
    || Dif_QISTI2OF || ',' ,
    /* HWM wkfile storage used by an agent */ ,
    || QISTAMXU     || ','  ,
    /* Current storage configured for wkfiles*/ ,
    || QISTWSTG     || ','  ,
    /* Current DGTT  configured for wkfile KB*/ ,
    || QISTDGTTSTG  || ',' ,
    /* Current others  configured for wkfile KB*/,
    || QISTWFSTG    || ',' ,
    /* Current DGTT  used  KB*/,
    || QISTDGTTCTO  || ',' ,
    /* HWM     DGTT  used  KB*/ ,
    || QISTDGTTMXU  || ',' ,
    /* Current others used  KB*/ ,
    || QISTWFCTO    || ',' ,
    /* HWM    others used KB*/ ,
    || QISTWFMXU    || ',' ,
  /* EDMPOOL block */ ,
    || QISTRHIG                     || ',' ,    /* Max RID blocks*/
    || Dif_QISECTG                  || ',' ,    /* requests CT*/
    || Dif_QISECTL                  || ',' ,    /* Load CT    */
    || Dif_QISEDBDG                 || ',' ,    /* Req DBD    */
    || Dif_QISEDBDL                 || ',' ,    /* Load DBD   */
    || Dif_QISEKTG                  || ',' ,    /* Req PT     */
    || Dif_QISEKTL                  || ',' ,    /* Load PT    */
    || Dif_QISEDSG                  || ',' ,    /* Req Dyn Cache */
    || Dif_QISEDSI                  || ',' ,    /* Ins Dyn Cache */
    ||     QISEDPGE                 || ',' ,    /* DBDPool used pages */
    ||     QISEDFRE                 || ',' ,    /* DBDPOOL free pages */
    ||     QISEDLRU                 || ',' ,    /* DBDPOOL stealable  */
    ||     QISEDFAL                 || ',' ,    /* Failed DBDPool Full*/
    ||     QISECPGE                 || ',' ,    /* Pages STMTPool */
    ||     QISECFRE                 || ',' , /* Pages STMTPool free */
    ||     QISECFAL                 || ',' , /* Failed STMTool Full*/
    ||     QISEKPGE                 || ',' , /* Pages in SkelPool */
    ||     QISEKFRE                 || ',' , /* Free pages SKELPool*/
    ||     QISEKLRU                 || ',' ,  /* Skel pages stealable*/
    ||     QISEKFAL                 || ',' ,  /* Failed SkelPoolFull*/
  /* Locks                              */,
    ||  Dif_QTXADEA                 || ',' ,
    ||  Dif_QTXATIM                 || ',' ,
  /* RID LIST BLOCK RID List processing */,
    ||  Dif_QXSELECT                || ',' ,
    ||  Dif_QXINSRT                 || ',' ,
    ||  Dif_QXUPDTE                 || ',' ,
    ||  Dif_QXDELET                 || ',' ,
    ||  Dif_QXFETCH                 || ',' ,
    ||  Dif_QXSTNFND                || ',' , /* Full  Prepare */
    ||  Dif_QXSTFND                 || ',' , /* Short Prepare */
    ||  Dif_QXSTIPRP                || ',' , /* Impl  Prepare */
    ||  Dif_QXSTNPRP                || ',' , /* Avoided Prepare */
    ||  Dif_QXSTDEXP                || ',' , /* Prepare MAXKEEPD reach*/
    ||  Dif_QXNSMIAP                || ',' ,  /*Failed Limit no Stor */
    ||  Dif_QXMRMIAP                || ',' ,  /*Failed Limit exc*/
    ||  Dif_QXWFRIDS                || ',' ,  /*Overflow no Stor. */
    ||  Dif_QXWFRIDT                || ',' ,  /*Overflow Limit    */
    ||  Dif_QXHJINCS                || ',' ,  /*Failed Hybrid Stor*/
    ||  Dif_QXHJINCT                || ',' ,  /*Failed Hybrid Limit*/
    ||         Dif_QISTRLLM         || ',' ,  /*RID end RDS limit */
                        ,   /* = MAX(25% table size, rid storage) */
    ||         Dif_QISTRPLM         || ',' ,  /*RID end DM limit  */
  /* Logging */ ,
    ||     Dif_QJSTBFFL             || ',' ,  /*Log created*/
    ||     Dif_QJSTCIOF             || ',' ,
    ||     QWOSLPRU                 || ',' ,  /* CPU util. LPAR */
    ||     QWOSDB2U                 || ',' ,  /* CPU util. DB2 */
    ||     QWOSLPIR                 || ',' ,  /* Page in rate LPAR */
    ||     QWOSDPIR                 || ',' ,  /* Page in DB2 */
    ||     QWOSLRST                 || ',' ,  /* Storage LPAR */
    ||     QWOSLRSF                 || ',' ,  /* Storage Free */
    ||     QWOSDRSU                 || ',' ,  /* Storage Used by this DB2*/
    ||     QWOSLUIC                 || ','    /* UIC */
  /*|| f2mb(qw0225ax_dbm1)          || ',' ,
    || f2mb(qw0225ax_dist)          || ',' ,
    || f2mb(QW0225ShrStg_Aux)       || ',' ,
    || f2mb(QW0225ShrStkStg_Aux)    || ',' ,
    || f2mb(QW0225ComStg_Aux)       || ',' ,
    || f2mb(QW0225ShrStg_Real)      || ',' ,
    || f2mb(QW0225ShrStkStg_Real)   || ',' ,
    || f2mb(QW0225ComStg_Real)      || ',' ,
    || f2mb(QW0225SHRINREAL)        || ',' ,
    || f2mb(qw0225rl_dbm1)          || ',' ,
    || f2mb(qw0225rl_dist)          || ','    */
    /* active thread =  QDSTCNAT +  QW0225AT */
  "EXECIO 1 DISKW OUFL (STEM OUTREC. "


  /*************************************/
  /* Second record for Detail Bufstats */
  /* Loop  for each bufferpool ID      */
  /*************************************/
  do i = 1 to nbbp_entry.0
        j = nbbp_entry.i
        /* decode BPID to BP name */
        Select
             When j >='0'   & j <= '50'    Then bpnm = 'BP'j
             When j >='100' & j <= '109'   Then do
                                                  k    = j-100
                                                  bpnm = 'BP8K'k
                                                end
             When j >='120' & j <= '129'   Then do
                                                  k    = j-120
                                                  bpnm = 'BP16K'k
                                                end
             When j >='80'  & j <= '89'    Then do
                                                  k    = j-80
                                                  bpnm = 'BP32K'k
                                                end
             Otherwise do
                         say 'Buffer pool ID ??? 'j
                         bpnm = '?'j
                       end
        end
        if bpnm = 'BP32K0' then bpnm = 'BP32K'
        outrec.1= sm100sid || ',' || sm100ssi || ','  ,
        || '"'sm100dte'"'  || ','   ,
        || run_fmt_time    || ','   ,
        || run_hh          || ','   ,
        || bpnm            || ','   ,
        || BufVPL.j      || ','  ,
        || Det_GET.j     || ','  ,
        || Det_SGT.j     || ','  ,
        || Det_RIO.j     || ','  ,
        || Det_PWS.j     || ','  ,
        || Det_IMW.j     || ','  ,
        || Det_WIO.j     || ','  ,
        || Det_RPI.j     || ','  ,
        || Det_WPI.j     || ','  ,
        || Det_PIO.j     || ','  ,
        || Det_CIO.j     || ','  ,
        || Det_DIO.j     || ','  ,
        || Det_LIO.j     || ','  ,
        || Det_SIO.j     || ','  ,
        || BufMIN.j      || ','  ,
        || BufMAX.j      || ','  ,
        || Det_HST.j     || ','  ,
        || Det_RHS.j
        "EXECIO 1 DISKW OUFL2 (STEM OUTREC. "
  end
  /***************************************************/
  /* Another record for Detail Group Bufferpool stats*/
  /* Loop  for each bufferpool ID                    */
  /***************************************************/
  do i = 1 to nbgbp_entry.0
        j = nbgbp_entry.i
        /* decode BPID to BP name */
        Select
             When j >='0'   & j <= '50'    Then bpnm = 'GBP'j
             When j >='100' & j <= '109'   Then do
                                                  k    = j-100
                                                  bpnm = 'GBP8K'k
                                                end
             When j >='120' & j <= '129'   Then do
                                                  k    = j-120
                                                  bpnm = 'GBP16K'k
                                                end
             When j >='80'  & j <= '89'    Then do
                                                  k    = j-80
                                                  bpnm = 'GBP32K'k
                                                end
             Otherwise do
                         say 'Group Buffer pool ID ??? 'j
                         bpnm = '?'j
                       end
        end
        if bpnm = 'GBP32K0' then bpnm = 'GBP32K'
        outrec.1= sm100sid || ',' || sm100ssi || ','  ,
        || '"'sm100dte'"'  || ','   ,
        || run_fmt_time    || ','   ,
        || run_hh          || ','   ,
        || bpnm            || ','   ,
        || Dif_GBPGetPage.j     || ','  ,
        || Dif_GBPXIReadRet.j     || ','  ,
        || Dif_GBPXIReadNoRet.j   || ','  ,
        || format(GBPXIMissRatio.j,4,2) || ','  ,
        || Dif_QBGLAW.j   || ','  ,
        || Dif_QBGLSW.j
        "EXECIO 1 DISKW OUFL5 (STEM OUTREC. "
  end

  /**************************************/
  /* Another record for Storage stats   */
  /*************************************/
        /* Buid output record */
        outrec.1= sm100sid || ',' || sm100ssi || ','  ,
        || '"'sm100dte'"'  || ','   ,
        || run_fmt_time    || ','   ,
        || run_hh          || ','   ,
        || f2mb(TotalRealUsedByDB2) || ','   ,
        || f2mb(qw0225rl_dbm1)   || ','   ,
        || f2mb(qw0225rl_dist)   || ','   ,
        || f2mb(qw0225ShrStg_Real)    || ','   ,
        || f2mb(qw0225ShrStkStg_Real) || ','   ,
        || f2mb(QW0225ComStg_Real) || ','   ,
    || f2mb(qw0225ax_dbm1)          || ',' ,
    || f2mb(qw0225ax_dist)          || ',' ,
    || f2mb(QW0225ShrStg_Aux)       || ',' , /* ShAux slots used SSID */
    || f2mb(QW0225ShrStkStg_Aux)    || ',' , /* ShStak slots SSID */
    || f2mb(QW0225ComStg_Aux)       || ',' , /* Common Aux SSID*/
    || f2mb(QW0225SHRINREAL)   || ',',       /* Share backed by Real*/
    || f2mb(TotalAuxlUsedByDB2)     || ',' ,        /*for LPAR*/
    || f2mb(TotalRealUsedBP)        || ',' ,
    || f2mb(TotalAuxUsedBP)         || ',' ,
    || f2mb(QW0225_REALAVAIL)       || ',' ,  /* Real Available LPAR */
    || b2mb(QW0225RG)               || ',' ,
    || b2mb(QW0225AV) /* How much DB2 thinks it is avail*/

        "EXECIO 1 DISKW OUFL3 (STEM OUTREC. "
  if BPSim  = 'Y' then
  do
  /*************************************/
  /* Simulation  Bufstats              */
  /* Loop  for each bufferpool ID      */
  /*************************************/
      do i = 1 to Simbp_entry.0
            j = Simbp_entry.i
            /* decode BPID to BP name */
            Select
                 When j >='0'   & j <= '50'    Then bpnm = 'BP'j
                 When j >='100' & j <= '109'   Then do
                                                      k    = j-100
                                                      bpnm = 'BP8K'k
                                                    end
                 When j >='120' & j <= '129'   Then do
                                                      k    = j-120
                                                      bpnm = 'BP16K'k
                                                    end
                 When j >='80'  & j <= '89'    Then do
                                                      k    = j-80
                                                      bpnm = 'BP32K'k
                                                    end
                 Otherwise do
                             say 'Buffer pool ID ??? 'j
                             bpnm = '?'j
                           end
            end
            if bpnm = 'BP32K0' then bpnm = 'BP32K'
            /* Buid output record */
            outrec.1= sm100sid || ',' || sm100ssi || ','  ,
            || '"'sm100dte'"'  || ','   ,
            || run_fmt_time    || ','   ,
            || run_hh          || ','   ,
            || bpnm            || ','   ,
            || DifSimPage.i         || ','   ,
            || DifSimSeqPage.i      || ','   ,
            || DifSimSyncIO.i       || ','   ,
            || DifSimSeqSyncIO.i    || ','   ,
            || DifSimAsyncPage.i    || ','   ,
            || DifSimGBPSyncIO.i    || ','   ,
            || DifSimGBPSeqSyncIO.i || ','   ,
            || DifSimGBPAsyncPage.i || ','   ,
            || DifSimPageMov.i      || ','   ,
            || DifSimWaitSyncIO.i
            "EXECIO 1 DISKW OUFL4 (STEM OUTREC. "
      end
  end  /* If BPSim='Y' */

return


/* SMF HEADER */
DSNDQWST:
   OFFSET = OFFSET + 1
   /* SM100RTY DS XL1 RECORD TYPE X'64' OR 100 */
   SM100RTY = C2D(SUBSTR(INPUT_REC,OFFSET,1))
   /* stop processing if not 100 */
   if sm100rty <> 100 then return
   OFFSET = OFFSET + 1
   /* SM100TME DS XL4 TIME SMF MOVED RECORD */
   SM100TME = C2D(SUBSTR(INPUT_REC,OFFSET,4))
   CALL GET_FMT_TIME
   OFFSET = OFFSET + 4
   field    = C2X(SUBSTR(INPUT_REC,OFFSET,4))
     parse value field with 1 . 2 c 3 yy 5 ddd 8 .
     if (c = 0) then
       yyyy = '19'||yy
     else
       yyyy = '20'||yy
   sm100dte    = yyyy||'.'||ddd
   /* save date of smf records processed */
   if reco = 0 then save_date=sm100dte
   else do
     if save_date <> sm100dte & displ = 0 then do
        displ=1
        say 'There is 2 different dates in this SMF extract'
        say '             '  save_date sm100dte
        say ' '
     end
   end
   OFFSET = OFFSET + 4
   sm100sid = SUBSTR(INPUT_REC,OFFSET,4)
   OFFSET = OFFSET + 4
   /* SM100SSI DS CL4 SUBSYSTEM ID */
   sm100ssi = SUBSTR(INPUT_REC,OFFSET,4)
   OFFSET = OFFSET + 10
   /* TOTAL LENGTH = 28 */
RETURN
DSNDQWOS:
    /* Nb CPU */
    QWOSLNCP =  C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* CPU use. LPAR      */
    QWOSLPRU = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* CPU use. DB2       */
    QWOSDB2U = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 12
    /* Page in rate LPAR       */
    QWOSLPIR = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* Page in rate DB2        */
    QWOSDPIR = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* Real Stor. LPAR         */
    QWOSLRST = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* Real Stor. Free LPAR    */
    QWOSLRSF = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* Real Stor. used by this DB2 */
    QWOSDRSU = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 16
    /* Real Stor. used by this DB2 */
    QWOSLUIC = C2D(SUBSTR(INPUT_REC,offset,4))
    return

dsndqist:
    numeric digits 15
    offset  =  offset +4
    /* Fields of these macro seems to be all cumulative */
    /* calculate difference between interval */
    /* check QIEYE */
      if  SUBSTR(INPUT_REC,OFFSET,4) <> 'QIST' then
        do
              say 'Mapping error QIST eye catcher not found'
              exit(8)
        end

    offset = offset + 4
    /* RID Term RDS Limit */
    QISTRLLM = C2D(SUBSTR(INPUT_REC,offset,4))
    offset = offset + 4
    /* RID Term DM  Limit */
    QISTRPLM = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* Highest RID blocks */
    QISTRHIG = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 16
    /* not optimal column proc */
    QISTCOLS = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    offset = offset + 36
    /* 32KB Wrkfile used instead of 4KB */
    QISTWFP1 = C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    /* 4 KB Wrkfile used instead of 32 KB */
    QISTWFP2 = C2D(SUBSTR(INPUT_REC,OFFSET,4))
  if QWHSRN= 'A1' then /* zones not available V10 */
  do
     QISTWMXU=0
     QISTWCTO=0
     QISTW4K=0
     QISTW32K=0
     QISTIMAC=0
     QISTIMSC=0
     QISTSIAC=0
     QISTSISC=0
     QISTWFRCUR=0
     QISTI2AC=0
     QISTI2OF=0
     QISTAMXU=0
     QISTWSTG=0
     QISTDGTTSTG=0
     QISTWFSTG=0
     QISTDGTTCTO=0
     QISTDGTTMXU=0
     QISTWFCTO=0
     QISTWFMXU=0
    return
  end
    offset = offset + 28
    /* hwm storage used by workfiles in KB */
    QISTWMXU = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current all workfile usage in KB : DGTT and Sort */
    QISTWCTO = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current 4K wrkfile storage usage in KB*/
    QISTW4K  = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current 32K wrkfile storage usage in KB*/
    QISTW32K = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Nb DM in memory   wrkfiles active currently */
    QISTIMAC = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Space DM in memory active currently in KB*/
    QISTIMSC = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 24
    /* Nb SRT in memory   wrkfiles active currently */
    QISTSIAC = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Space SRT in memory active currently in bytes */
    QISTSISC = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    QISTSISC = trunc(QISTSISC/1024) /* in KB */
    offset = offset + 32
    /* Current RID blocks overflowed (stored) in wrkfiles*/
    QISTWFRCUR=  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current NON Sort related workfiles active */
    QISTI2AC =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 16
    /* Physical  workfiles created */
    QISTI2OF =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 24
    /* HWM wkfile storage used by an agent */
    QISTAMXU =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current storage configured for wkfiles*/
    QISTWSTG =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current DGTT  configured for wkfile KB*/
    QISTDGTTSTG = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current DGTT  used  KB*/
    QISTDGTTCTO = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* HWM     DGTT  used  KB*/
    QISTDGTTMXU = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current others  configured for wkfile KB*/
    QISTWFSTG = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Current others used  KB*/
    QISTWFCTO = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* HWM    others used KB*/
    QISTWFMXU = C2D(SUBSTR(INPUT_REC,OFFSET,8))
    return

/***************************/
/* Group buffer pool stats */
/***************************/
dsndqbgl:
    numeric digits 15
    /* Group BPID */
    QBGLGN  =  C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    QBGLFLG  =  SUBSTR(INPUT_REC,OFFSET,1)
    offset = offset + 1 + 3
    /* GBP Dependent Getpage */
    QBGLGG  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Syn.Read(XI)-Data returned (A in the formula ) */
    QBGLXD  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Syn.Read(XI)-No Data Return (B in the formula) */
    QBGLXR  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 24
    /* Sync Write  (from local BP to GBP) called User Write */
    QBGLSW  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 56
    /* ASync Write  (from local BP to GBP) called Syst Write */
    QBGLAW  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 40
    /* Write requests failed no storage */
    /* QBGLWF  =  C2D(SUBSTR(INPUT_REC,OFFSET,8)) */
    offset = offset + 104
    /* Write requests failed no storage secondary GBP */
    /* QBGL2F  =  C2D(SUBSTR(INPUT_REC,OFFSET,8)) */
    /* Write Around */
    offset = offset + 136
    /* Page in write around  */
    /* QBGLWA  =  C2D(SUBSTR(INPUT_REC,OFFSET,8)) */
    /* go to end of macro QBGL */
    offset = offset + 32

    /*****************************/
    /* Processing the data read  */
    /*****************************/

    /* if there is a new bufferpool in the list */
    if qws10r7n > nbgbp_entry.0 then call record_gbp
    GBPGetPage.QBGLGN    = QBGLGG
    GBPXIReadRet.QBGLGN    = QBGLXD
    GBPXIReadNoRet.QBGLGN  = QBGLXR
    QBGLAW.QBGLGN  = QBGLAW
    QBGLSW.QBGLGN  = QBGLSW
    say 'GBPGetpage'    QBGLGN QBGLGG
    say 'GBPXIReadRet' QBGLGN QBGLXD
    say 'GBPXIReadNoRet' QBGLGN QBGLXR
    say 'QBGLAW ' QBGLGN QBGLAW
    say 'QBGLSW ' QBGLGN QBGLSW

    return

dsndqbst:
    numeric digits 15
    QBSTPID =  C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 8
    QBSTGET =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTRIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 40
    QBSTPWS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTWIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 16
    QBSTRPI =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTWPI =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Open Dataset */
    QBSTDSO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTIMW =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 16
    /* Pages read seq Prefetch */
    QBSTSPP =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 56
    /* OF SEQ PREFETCH (ASYNCHRONOUS) READ*/
    QBSTPIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 16
    /* nb wkfile not created due to buffers resource */
    QBSTMAX =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 48
    /* nb of workfiles denied during sort/merge */
    QBSTWFD =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* nb of time sort not optimized due to BP shortage*/
    QBSTWFF =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 40
    /* nb of cast out IO */
    QBSTCIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTVPL =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 24
    QBSTDIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTLIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTSGT =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    QBSTSIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 112 /* 8*14*/
    /* Min SRLU */
    QBSTSMIN=  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Max SRLU */
    QBSTSMAX=  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Nb times SLRU = VPSEQT */
    QBSTHST =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Nb times Random getpage found in SRLU chain */
    QBSTRHS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8

    /******************************/
    /* End of macro QBST DSNDQBST */
    /******************************/

         /* if there is a new bufferpool in the list */
         if qws10r3n > nbbp_entry.0 then call record_bp
         BufGet.QBSTPID = QBSTGET
         BufRIO.QBSTPID=  QBSTRIO
         BufPWS.QBSTPID=  QBSTPWS
         BufWIO.QBSTPID=  QBSTWIO
         BufRPI.QBSTPID=  QBSTRPI
         BufWPI.QBSTPID=  QBSTWPI
         BufIMW.QBSTPID=  QBSTIMW
         BufDSO.QBSTPID=  QBSTDSO
         BufPIO.QBSTPID=  QBSTPIO
         BufCIO.QBSTPID=  QBSTCIO
         BufVPL.QBSTPID=  QBSTVPL
         BufDIO.QBSTPID=  QBSTDIO
         BufLIO.QBSTPID=  QBSTLIO
         BufSIO.QBSTPID=  QBSTSIO
         BufSGT.QBSTPID=  QBSTSGT
         BufMIN.QBSTPID=  QBSTSMIN
         BufMAX.QBSTPID=  QBSTSMAX
         BufHST.QBSTPID=  QBSTHST
         BufRHS.QBSTPID=  QBSTRHS
    /*        'QBSTRIO=' QBSTRIO,     */
    /*        'QBSTWIO=' QBSTWIO,     */
    /*        'QBSTIMW=' QBSTIMW,     */
    /*    say 'QBSTPIO=' QBSTPIO,     */
    /*        'QBSTCIO=' QBSTCIO,     */
    /*        'QBSTDIO=' QBSTDIO,     */
    /*        'QBSTLIO=' QBSTLIO,     */
    /*        'QBSTSIO=' QBSTSIO      */
    return
/*--------------------*/
/* Simulated BP stats */
/*--------------------*/
DSNDQBSP:
    numeric digits 20
    /* Bpool ID */
    QBSPPID =  C2D(SUBSTR(INPUT_REC,OFFSET,4))
    offset = offset + 4
    QBSPCON = C2X(SUBSTR(INPUT_REC,OFFSET,1))
    offset = offset + 4
    /* Current Number of pages simulated */
    QBSPIUS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 16
    /* Current number of seq pages simulated */
    QBSPSUS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 16
    /* Random Sync read  */
    QBSPDRR =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Seq    Sync read  */
    QBSPDRS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Pages Async Reads */
    QBSPDRA =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* GBP Random Sync read  */
    QBSPGRR =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* GBP Seq Sync read  */
    QBSPGRS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* GBP Pages Async Reads */
    QBSPGRA =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Pages moved into Simulated pool */
    QBSPMVI =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 8
    /* Total wait for sync/IO  */
    QBSPDTM =  C2D(SUBSTR(INPUT_REC,OFFSET,8))
    offset = offset + 16 /* Yes, there is a bug */

    /* Check in simulated BP list */
    do i = 1 to Simbp_entry.0
              if QBSPPID = Simbp_entry.i then leave
    end
    /* not found => new entry */
    if i > Simbp_entry.0 then
           do
               Simbp_entry.0 = Simbp_entry.0 + 1
               j            = Simbp_entry.0
               Simbp_entry.j = QBSPPID

               SimPage.j = 0
               SimSeqPage.j = 0
               SimSyncIO.j = 0
               SimSeqSyncIO.j = 0
               SimAsyncPage.j = 0
               SimGBPSyncIO.j = 0
               SimGBPSeqSyncIO.j = 0
               SimGBPAsyncPage.j = 0
               SimPageMov.j = 0
               SimWaitSyncIO.j = 0
           end

    /* Check in simulated BP list */
    do i = 1 to Simbp_entry.0
              if QBSPPID = Simbp_entry.i then leave
    end
    /* not found => error  */
    if i > Simbp_entry.0 then
           do
               say 'Abnormal error '
               exit 8
           end
    /*-----------------------------------------------*/
    /* Difference between current and previous value */
    /*-----------------------------------------------*/

    /* Current Number of pages simulated */
    DifSimPage.i = QBSPIUS
    /* Current Number of seq pages simulated */
    DifSimSeqPage.i = QBSPSUS
    /* Random Sync read  */
    DifSimSyncIO.i = QBSPDRR - SimSyncIO.i
    /* Seq    Sync read  */
    DifSimSeqSyncIO.i = QBSPDRS - SimSeqSyncIO.i
    /* Pages Async Reads */
    DifSimAsyncPage.i = QBSPDRA - SimAsyncPage.i
    /* GBP Random Sync read  */
    DifSimGBPSyncIO.i = QBSPGRR - SimGBPSyncIO.i
    /* GBP Seq Sync read  */
    DifSimGBPSeqSyncIO.i = QBSPGRS - SimGBPSeqSyncIO.i
    /* GBP Pages Async Reads */
    DifSimGBPAsyncPage.i = QBSPGRA - SimGBPAsyncPage.i
    /* Pages moved into Simulated pool */
    DifSimPageMov.i = QBSPMVI - SimPageMov.i
    /* Total wait for sync/IO in ms  */
    DifSimWaitSyncIO.i = QBSPDTM - SimWaitSyncIO.i

    /*------------------------------------*/
    /* Save the values for next iteration */
    /* New => Previous                    */
    /*------------------------------------*/
    SimPage.i = QBSPIUS
    SimSeqPage.i = QBSPSUS
    SimSyncIO.i = QBSPDRR
    SimSeqSyncIO.i = QBSPDRS
    SimAsyncPage.i = QBSPDRA
    SimGBPSyncIO.i = QBSPGRR
    SimGBPSeqSyncIO.i = QBSPGRS
    SimGBPAsyncPage.i = QBSPGRA
    SimPageMov.i = QBSPMVI
    SimWaitSyncIO.i = QBSPDTM

    /******************************/
    /* End of macro QBST DSNDQBST */
    /******************************/

    return
ifcid_diff:
       /* Cumulative values, report only the difference */
       /* When diff is negative, this means that the value have been*/
       /* reset (Seen at DB2 restart , but probably also if they    */
       /* reach their max)                                          */
              Dif_MstrTcb =       MstrTcb       - Old_MstrTcb
              Dif_MstrSrb =       MstrSrb       - Old_MstrSrb
              Dif_MstrpSRB=       MstrpSRB      - Old_MstrpSRB
              Dif_MstrpSRB_ziip = MstrpSRB_ziip - Old_MstrpSRB_ziip
              Dif_dbm1Tcb =       dbm1Tcb       - Old_dbm1Tcb
              Dif_dbm1srb =       dbm1srb       - Old_dbm1srb
              Dif_dbm1pSRB=       dbm1pSRB      - Old_dbm1pSRB
              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip - Old_dbm1pSRB_ziip
              Dif_irlmTcb =       irlmTcb       - Old_irlmTcb
              Dif_irlmsrb =       irlmsrb       - Old_irlmsrb
              Dif_irlmpSRB=       irlmpSRB      - Old_irlmpSRB
              Dif_irlmpSRB_ziip = irlmpSRB_ziip - Old_irlmpSRB_ziip
              Dif_distTcb =       distTcb       - Old_distTcb
              Dif_distsrb =       distsrb       - Old_distsrb
              Dif_distpSRB=       distpSRB      - Old_distpSRB
              Dif_distpSRB_ziip = distpSRB_ziip - Old_distpSRB_ziip

        if    Dif_MstrTcb < 0 then
        do
              say '|||||||||||||||||||||||||||||||||||||||||||||||'
              say 'Cumulative fields reset, possible DB2 RECYCLE'
              say '      at' sm100dte run_fmt_time
              say '|||||||||||||||||||||||||||||||||||||||||||||||'
              say ''


              Dif_MstrTcb =       MstrTcb
              Dif_MstrSrb =       MstrSrb
              Dif_MstrpSRB=       MstrpSRB
              Dif_MstrpSRB_ziip = MstrpSRB_ziip
              Dif_dbm1Tcb =       dbm1Tcb
              Dif_dbm1srb =       dbm1srb
              Dif_dbm1pSRB=       dbm1pSRB
              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip
              Dif_irlmTcb =       irlmTcb
              Dif_irlmsrb =       irlmsrb
              Dif_irlmpSRB=       irlmpSRB
              Dif_irlmpSRB_ziip = irlmpSRB_ziip
              Dif_distTcb =       distTcb
              Dif_distsrb =       distsrb
              Dif_distpSRB=       distpSRB
              Dif_distpSRB_ziip = distpSRB_ziip

        end
              Old_Mstrtcb =       Mstrtcb
              Old_MstrSrb =       MstrSrb
              Old_MstrpSRB=       MstrpSRB
              Old_MstrpSRB_ziip = MstrpSRB_ziip
              Old_dbm1Tcb =       dbm1Tcb
              Old_dbm1srb =       dbm1srb
              Old_dbm1pSRB=       dbm1pSRB
              Old_dbm1pSRB_ziip = dbm1pSRB_ziip
              Old_irlmTcb =       irlmTcb
              Old_irlmsrb =       irlmsrb
              Old_irlmpSRB=       irlmpSRB
              Old_irlmpSRB_ziip = irlmpSRB_ziip
              Old_distTcb =       distTcb
              Old_distsrb =       distsrb
              Old_distpSRB=       distpSRB
              Old_distpSRB_ziip = distpSRB_ziip

       /*********************************/
       /* Subsystem services stats QTDS */
       /*********************************/
          Dif_QTDSDRN =     QTDSDRN-Old_QTDSDRN
          Dif_QTPCCT  =     QTPCCT -Old_QTPCCT
          if  Dif_QTDSDRN < 0 then
          do
              Dif_QTDSDRN = QTDSDRN
              Dif_QTPCCT  = QTPCCT
          end
          Old_QTDSDRN =   QTDSDRN
          Old_QTPCCT  =   QTPCCT
       /*********************************/
       /* Subsystem services stats Q3ST */
       /*********************************/
              Dif_Q3STSIGN =     Q3STSIGN-Old_Q3STSIGN
              Dif_Q3STTERM =     Q3STTERM-Old_Q3STTERM
              Dif_Q3STCTHD =     Q3STCTHD-Old_Q3STCTHD
              Dif_Q3STPREP =     Q3STPREP-Old_Q3STPREP
              Dif_Q3STCOMM =     Q3STCOMM-Old_Q3STCOMM
              Dif_Q3STABRT =     Q3STABRT-Old_Q3STABRT

          if  Dif_Q3STCTHD < 0 then
          do
              Dif_Q3STSIGN = Q3STSIGN
              Dif_Q3STTERM = Q3STTERM
              Dif_Q3STCTHD = Q3STCTHD
              Dif_Q3STPREP = Q3STPREP
              Dif_Q3STCOMM = Q3STCOMM
              Dif_Q3STABRT = Q3STABRT
          end

          Old_Q3STSIGN = Q3STSIGN
          Old_Q3STTERM = Q3STTERM
          Old_Q3STCTHD = Q3STCTHD
          Old_Q3STPREP = Q3STPREP
          Old_Q3STCOMM = Q3STCOMM
          Old_Q3STABRT = Q3STABRT

       /***************************/
       /* buffer pool stats       */
       /***************************/


      /****************************************/
      /* dsndqjst Log  Manager stats IFCID 001*/
      /****************************************/
      Dif_QJSTBFFL = QJSTBFFL - Old_QJSTBFFL
      Dif_QJSTCIOF = QJSTCIOF - Old_QJSTCIOF
      if  Dif_QJSTBFFL < 0 then  do
              Dif_QJSTBFFL = QJSTBFFL
              Dif_QJSTCIOF = QJSTCIOF
      end
      Old_QJSTBFFL = QJSTBFFL
      Old_QJSTCIOF = QJSTCIOF

      /****************************************/
      /* dsndqist Data Manager stats IFCID 002 */
      /****************************************/
              Dif_QWSDCKPT = QWSDCKPT - Old_QWSDCKPT /*checkpoints*/
              Dif_QTXADEA  = QTXADEA  - Old_QTXADEA
              Dif_QTXATIM  = QTXATIM  - Old_QTXATIM
              Dif_QXSELECT = QXSELECT - Old_QXSELECT
              Dif_QXINSRT  = QXINSRT  - Old_QXINSRT
              Dif_QXUPDTE  = QXUPDTE  - Old_QXUPDTE
              Dif_QXDELET  = QXDELET  - Old_QXDELET
              Dif_QXFETCH  = QXFETCH  - Old_QXFETCH
              Dif_QXSTFND  = QXSTFND  - Old_QXSTFND
              Dif_QXSTNFND = QXSTNFND - Old_QXSTNFND
              Dif_QXSTIPRP = QXSTIPRP - Old_QXSTIPRP
              Dif_QXSTNPRP = QXSTNPRP - Old_QXSTNPRP
              Dif_QXSTDEXP = QXSTDEXP - Old_QXSTDEXP
              Dif_QXNSMIAP = QXNSMIAP - Old_QXNSMIAP
              Dif_QXMRMIAP = QXMRMIAP - Old_QXMRMIAP
              Dif_QXWFRIDS = QXWFRIDS - Old_QXWFRIDS
              Dif_QXWFRIDT = QXWFRIDT - Old_QXWFRIDT
              Dif_QXHJINCS = QXHJINCS - Old_QXHJINCS
              Dif_QXHJINCT = QXHJINCT - Old_QXHJINCT
              Dif_QISECTG  = QISECTG  - Old_QISECTG
              Dif_QISECTL  = QISECTL  - Old_QISECTL
              Dif_QISEDBDG = QISEDBDG - Old_QISEDBDG
              Dif_QISEDBDL = QISEDBDL - Old_QISEDBDL
              Dif_QISEKTG  = QISEKTG  - Old_QISEKTG
              Dif_QISEKTL  = QISEKTL  - Old_QISEKTL
              Dif_QISEDSG  = QISEDSG  - Old_QISEDSG
              Dif_QISEDSI  = QISEDSI  - Old_QISEDSI
              Dif_QISTRLLM = QISTRLLM - Old_QISTRLLM
              Dif_QISTRPLM = QISTRPLM - Old_QISTRPLM
              Dif_QISTCOLS = QISTCOLS - Old_QISTCOLS
              Dif_QISTWFP1 = QISTWFP1 - Old_QISTWFP1
              Dif_QISTWFP2 = QISTWFP2 - Old_QISTWFP2
              Dif_QISTI2OF = QISTI2OF - Old_QISTI2OF

      if  Dif_QXSELECT <0 then
      do
              Dif_QISTRLLM = QISTRLLM
              Dif_QISECTG  = QISECTG
              Dif_QISECTL  = QISECTL
              Dif_QISEDBDG = QISEDBDG
              Dif_QISEDBDL = QISEDBDL
              Dif_QISEKTG  = QISEKTG
              Dif_QISEKTL  = QISEKTL
              Dif_QISEDSG  = QISEDSG
              Dif_QISEDSI  = QISEDSI
              Dif_QWSDCKPT = QWSDCKPT
              Dif_QTXADEA  = QTXADEA
              Dif_QTXATIM  = QTXATIM
              Dif_QXSELECT = QXSELECT
              Dif_QXINSRT  = QXINSRT
              Dif_QXUPDTE  = QXUPDTE
              Dif_QXDELET  = QXDELET
              Dif_QXFETCH  = QXFETCH
              Dif_QXSTFND  = QXSTFND
              Dif_QXSTNFND = QXSTNFND
              Dif_QXSTIPRP = QXSTIPRP
              Dif_QXSTNPRP = QXSTNPRP
              Dif_QXSTDEXP = QXSTDEXP
              Dif_QXNSMIAP = QXNSMIAP
              Dif_QXMRMIAP = QXMRMIAP
              Dif_QXWFRIDS = QXWFRIDS
              Dif_QXWFRIDT = QXWFRIDT
              Dif_QXHJINCS = QXHJINCS
              Dif_QXHJINCT = QXHJINCT
              Dif_QISTRPLM = QISTRPLM
              Dif_QISTCOLS = QISTCOLS
              Dif_QISTWFP1 = QISTWFP1
              Dif_QISTWFP2 = QISTWFP2
              Dif_QISTI2OF = QISTI2OF
      end

              Old_QISTRLLM = QISTRLLM
              Old_QISECTG  = QISECTG
              Old_QISECTL  = QISECTL
              Old_QISEDBDG = QISEDBDG
              Old_QISEDBDL = QISEDBDL
              Old_QISEKTG  = QISEKTG
              Old_QISEKTL  = QISEKTL
              Old_QISEDSG  = QISEDSG
              Old_QISEDSI  = QISEDSI
              Old_QWSDCKPT = QWSDCKPT
              Old_QTXADEA  = QTXADEA
              Old_QTXATIM  = QTXATIM
              Old_QXSELECT = QXSELECT
              Old_QXINSRT  = QXINSRT
              Old_QXUPDTE  = QXUPDTE
              Old_QXDELET  = QXDELET
              Old_QXFETCH  = QXFETCH
              Old_QXSTFND  = QXSTFND
              Old_QXSTNFND = QXSTNFND
              Old_QXSTIPRP = QXSTIPRP
              Old_QXSTNPRP = QXSTNPRP
              Old_QXSTDEXP = QXSTDEXP
              Old_QXNSMIAP = QXNSMIAP
              Old_QXMRMIAP = QXMRMIAP
              Old_QXWFRIDS = QXWFRIDS
              Old_QXWFRIDT = QXWFRIDT
              Old_QXHJINCS = QXHJINCS
              Old_QXHJINCT = QXHJINCT
              Old_QISTRPLM = QISTRPLM
              Old_QISTCOLS = QISTCOLS
              Old_QISTWFP1 = QISTWFP1
              Old_QISTWFP2 = QISTWFP2
              Old_QISTI2OF = QISTI2OF

      return
DisplayVStor:
  if vsm='Y' & reco > 0 then
  do
    Say ' '; say ' '
    Say 'Threads observed Max : ' MaxThdSee 'at' MaxThdSeeDate,
                                                 MaxThdSeeTime
    Say '                 Min : ' MinThdSee 'at' MinThdSeeDate,
                                                 MinThdSeeTime
    Say ' '; say ' '
    Say 'Max Threads allowed projected with this period is : '
    Say '    ' floor(MinThdComp) 'at' MinThdCompDate MinThdCompTime,
        '/' floor(MaxThdComp) 'at' MaxThdCompDate MaxThdCompTime
    Say '    Formula without Min/Max applied : '
    Say '    ' floor(MinThdComp2) 'at' MinThdComp2Date MinThdComp2Time,
        '/' floor(MaxThdComp2) 'at' MaxThdComp2Date MaxThdComp2Time
    Say ' '
    Say 'DBM1, Max Real Storage is : ' format(MaxReal4K_dbm1,5,2),
        'MB at ' Date_MaxReal4K_dbm1 time_MaxReal4K_dbm1
    Say '                   Min is : ' ,
                             format(MinReal4K_dbm1,5,2) 'MB at ',
           Date_MinReal4K_dbm1 time_MinReal4K_dbm1
    Say 'DIST, Max Real Storage is : ' format(MaxReal4K_dist,5,2),
        'MB at ' Date_MaxReal4K_dist time_MaxReal4K_dist
    Say '                   Min is : ' ,
                          format(MinReal4K_dist,5,2) 'MB at ',
         Date_MinReal4K_dist time_MinReal4K_dist
    Say ' '
 /* Say 'Max Real Storage used by LPAR :' MaxRealLPAR ' Frames --', */
 /*            f2mb(MaxRealLPAR)  ' in MB'                          */
 /* Say '       at ' time_MaxRealLPAR                               */
    temp=MinQW0225_REALAVAIL*4096 / 1048576      /* in MB*/
    Say 'Min Real Storage available for LPAR : ' MinQW0225_REALAVAIL,
                'Frames --' f2mb(MinQW0225_REALAVAIL) ' MB'
    Say '       at ' Date_MinQW0225_REALAVAIL time_MinQW0225_REALAVAIL
    Say ' '
    Say 'Max Aux Storage used by DB2  :' MaxDB2AuxUse ' Slots  --',
           f2mb(MaxDB2AuxUse)        ' MB'
    Say '       at ' DateMaxDB2AuxUse timeMaxDB2AuxUse
  end
return
init_var:
  GBPCount   =0
  HistCKPT.0 =0
  HistRWRO.0 =0
  tsayLocal=0

  /* nb of buffers recorded*/
  nbbp_entry.0=0
  nbgbp_entry.0=0
  /* nb of simulated buffers recorded*/
  SimBp_Entry.0=0
  if vsm='Y' then
      do
           MaxND=0
           MinAS=999999999999999
           MinTS=999999999999999
           MaxTF=0
           MaxThdSee =0
           MaxThdComp=0
           MaxThdComp2=0
           MinThdSee =999999999999999
           MinThdComp=999999999999999
           MinThdComp2=999999999999999
           MaxReal4K_dbm1=0
           MinReal4K_dbm1=999999999999999
           MaxReal4K_dist=0
           MinReal4K_dist=999999999999999
           MinQW0225_REALAVAIL=999999999999999
        /* MaxRealLPAR = 0 */
           MaxDB2AuxUse = -1
      end
  /* init counters */
  Old_QTDSDRN = 0
  Old_QTPCCT  = 0
  Old_QBSTGET = 0
  Old_QBSTRIO = 0
  Old_QBSTPWS = 0
  Old_QBSTDSO = 0
  Old_QBSTIMW = 0
  Old_QBSTWIO = 0
  Old_QBSTRPI = 0
  Old_QBSTWPI = 0
  Old_QBSTPIO = 0
  Old_QBSTCIO = 0
  Old_QBSTDIO = 0
  Old_QBSTLIO = 0
  Old_QBSTSIO = 0
  Old_QBSTSGT = 0
  Old_QBSTHST = 0
  Old_QBSTRHS = 0

  Old_QJSTBFFL  = 0
  Old_QJSTCIOF  = 0

  Old_QISTRLLM  = 0
  Old_QISECTG   = 0
  Old_QISECTL   = 0
  Old_QISEDBDG  = 0
  Old_QISEDBDL  = 0
  Old_QISEKTG   = 0
  Old_QISEKTL   = 0
  Old_QISEDSG   = 0
  Old_QISEDSI   = 0
  Old_QWSDCKPT  = 0
  Old_QTXADEA   = 0
  Old_QTXATIM   = 0
  Old_QXSELECT  = 0
  Old_QXINSRT   = 0
  Old_QXUPDTE   = 0
  Old_QXDELET   = 0
  Old_QXFETCH   = 0
  Old_QXNSMIAP  = 0
  Old_QXSTFND   = 0
  Old_QXSTNFND  = 0
  Old_QXSTIPRP  = 0
  Old_QXSTNPRP  = 0
  Old_QXSTDEXP  = 0
  Old_QXMRMIAP  = 0
  Old_QXWFRIDS  = 0
  Old_QXWFRIDT  = 0
  Old_QXHJINCS  = 0
  Old_QXHJINCT  = 0
  Old_QISTRPLM  = 0
  Old_QISTCOLS  = 0
  Old_QISTWFP1  = 0
  Old_QISTWFP2  = 0
  Old_QISTI2OF  = 0

  Old_Q3STSIGN = 0
  Old_Q3STTERM = 0
  Old_Q3STCTHD = 0
  Old_Q3STPREP = 0
  Old_Q3STCOMM = 0
  Old_Q3STABRT = 0


  Old_MstrTcb =       0
  Old_MstrSrb =       0
  Old_MstrpSRB=       0
  Old_MstrpSRB_ziip = 0
  Old_dbm1Tcb =       0
  Old_dbm1srb =       0
  Old_dbm1pSRB=       0
  Old_dbm1pSRB_ziip = 0
  Old_irlmTcb =       0
  Old_irlmsrb =       0
  Old_irlmpSRB=       0
  Old_irlmpSRB_ziip = 0
  Old_distTcb =       0
  Old_distsrb =       0
  Old_distpSRB=       0
  Old_distpSRB_ziip = 0


  /* compteurs input/output */
  reco= 0
  reci= 0
  recs= 0

  min_time ='26:00:00'
  max_time ='ZZ:00:00'
  min_date ='2100.000'
  max_date ='1900.000'
  /* reinit IFCID 2 data */
  call DSNDQXST0
  return

FLOOR: procedure
parse arg F
return TRUNC(F) - (F < 0) * (F <> TRUNC(F))

CEIL: procedure
parse arg C
return TRUNC(C) + (C > 0) * (C <> TRUNC(C))
/* convert 4K frames to MB */
f2mb:
 arg num
 num = format(num*4/1024,,2)
 return num
/* convert bytes to MB */
b2mb:
 arg num
 num = format(num/1048576,,0)
 return num
comp_sum_bpstats:
        /* we have all the stats for each bpid */
        /* now compare with old value to get the Dif and then*/
        /* have the sum */
         do i = 1 to nbbp_entry.0
            j = nbbp_entry.i
            /*--*/
            /* if value is given by DB2 */
            if  BufGET.j > 0  then
            do
                 Diff= BufGet.j- OBufGet.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufGet.j
                      Sum_QBSTGET = 0
                 end
                 Det_GET.j =  Diff
                 Sum_QBSTGET = Sum_QBSTGET + Diff
                 /*--*/
                 Diff= BufRIO.j- OBufRIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufRIO.j
                      Sum_QBSTRIO = 0
                 end
                 Det_RIO.j =  Diff
                 Sum_QBSTRIO = Sum_QBSTRIO + Diff
                 /*--*/
                 Diff= BufPWS.j- OBufPWS.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPWS.j
                      Sum_QBSTPWS = 0
                 end
                 Det_PWS.j =  Diff
                 Sum_QBSTPWS = Sum_QBSTPWS + Diff
                 /*--*/
                 Diff= BufIMW.j- OBufIMW.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufIMW.j
                      Sum_QBSTIMW = 0
                 end
                 Det_IMW.j =  Diff
                 Sum_QBSTIMW = Sum_QBSTIMW + Diff
                 /*--*/
                 Diff= BufDSO.j- OBufDSO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufDSO.j
                      Sum_QBSTDSO = 0
                 end
                 Det_DSO.j =  Diff
                 Sum_QBSTDSO = Sum_QBSTDSO + Diff
                 /*--*/
                 Diff= BufWIO.j- OBufWIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufWIO.j
                      Sum_QBSTWIO = 0
                 end
                 Det_WIO.j =  Diff
                 Sum_QBSTWIO = Sum_QBSTWIO + Diff
                 /*--*/
                 Diff= BufRPI.j- OBufRPI.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufRPI.j
                      Sum_QBSTRPI = 0
                 end
                 Det_RPI.j =  Diff
                 Sum_QBSTRPI = Sum_QBSTRPI + Diff
                 /*--*/
                 Diff= BufWPI.j- OBufWPI.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufWPI.j
                      Sum_QBSTWPI = 0
                 end
                 Det_WPI.j =  Diff
                 Sum_QBSTWPI = Sum_QBSTWPI + Diff
                 /*--*/
                 Diff= BufPIO.j- OBufPIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPIO.j
                      Sum_QBSTPIO = 0
                 end
                 Det_PIO.j =  Diff
                 Sum_QBSTPIO = Sum_QBSTPIO + Diff
                 /*--*/
                 Diff= BufCIO.j- OBufCIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufCIO.j
                      Sum_QBSTCIO = 0
                 end
                 Det_CIO.j =  Diff
                 Sum_QBSTCIO = Sum_QBSTCIO + Diff
                 /*--*/
                 Diff= BufDIO.j- OBufDIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufDIO.j
                      Sum_QBSTDIO = 0
                 end
                 Det_DIO.j =  Diff
                 Sum_QBSTDIO = Sum_QBSTDIO + Diff
                 /*--*/
                 Diff= BufLIO.j- OBufLIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufLIO.j
                      Sum_QBSTLIO = 0
                 end
                 Det_LIO.j =  Diff
                 Sum_QBSTLIO = Sum_QBSTLIO + Diff
                 /*--*/
                 Diff= BufSGT.j- OBufSGT.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufSGT.j
                      Sum_QBSTSGT = 0
                 end
                 Det_SGT.j =  Diff
                 Sum_QBSTSGT = Sum_QBSTSGT + Diff
                 /*--*/
                 Diff= BufSIO.j- OBufSIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufSIO.j
                      Sum_QBSTSIO = 0
                 end
                 Det_SIO.j =  Diff
                 Sum_QBSTSIO = Sum_QBSTSIO + Diff
                 /*--*/
                 Diff= BufHST.j- OBufHST.j
                 /* db2 recycle */
                 if Diff < 0 then
                      Diff= BufHST.j
                 Det_HST.j =  Diff
                 /*--*/
                 Diff= BufRHS.j- OBufRHS.j
                 /* db2 recycle */
                 if Diff < 0 then
                      Diff= BufRHS.j
                 Det_RHS.j =  Diff
                 /*--*/
            end
            else
            do
                 Det_GET.j = 0
                 Det_RIO.j = 0
                 Det_PWS.j = 0
                 Det_IMW.j = 0
                 Det_DSO.j = 0
                 Det_WIO.j = 0
                 Det_RPI.j = 0
                 Det_WPI.j = 0
                 Det_PIO.j = 0
                 Det_CIO.j = 0
                 Det_DIO.j = 0
                 Det_LIO.j = 0
                 Det_SIO.j = 0
                 Det_SGT.j = 0
                 Det_HST.j = 0
                 Det_RHS.j = 0
            end
         end
   return
comp_diff_gbpstats:
        /* We have all the stats for each bpid */
        /* now compare with old value to get the Dif */
         GBPCount = GBPCount+1
         do i = 1 to nbgbp_entry.0
            j = nbgbp_entry.i
            /*--*/
            /* if value is given in the SMF record */
            if  GBPGetpage.j > 0  then
            do
                 Dif_GBPGetpage.j= GBPGetpage.j - oGBPGetpage.j
                 if Dif_GBPGetpage.j < 0 then
                 do
                      Dif_GBPGetpage.j= GBPGetpage.j
                 end
                 /*--*/
                 Dif_GBPXIReadRet.j= GBPXIReadRet.j -,
                                      oGBPXIReadRet.j
                 if Dif_GBPXIReadRet.j < 0 then
                 do
                      Dif_GBPXIReadRet.j= GBPXIReadRet.j
                 end
                 /*--*/
                 Dif_GBPXIReadNoRet.j= GBPXIReadNoRet.j -,
                                      oGBPXIReadNoRet.j
                 if Dif_GBPXIReadNoRet.j < 0 then
                 do
                 end
                 /*--*/
                 Dif_QBGLAW.j= QBGLAW.j - oQBGLAW.j
                 if Dif_QBGLAW.j < 0 then
                 do
                      Dif_QBGLAW.j= QBGLAW.j
                 end
                 /*--*/
                 Dif_QBGLSW.j= QBGLSW.j - oQBGLSW.j
                 if Dif_QBGLSW.j < 0 then
                 do
                      Dif_QBGLSW.j= QBGLSW.j
                 end
            end
            else
            do
                 Dif_GBPGetPage.j =  0
                 Dif_GBPXIReadRet.j =  0
                 Dif_GBPXIReadNoRet.j =  0
                 Dif_QBGLAW.j =  0
                 Dif_QBGLSW.j =  0
            end
            /* compute sum for last 15 values */
            Sum_GBPXIReadRet.j   =  Sum_GBPXIReadRet.j +,
                          Dif_GBPXIReadRet.j
            Sum_GBPXIReadNoRet.j =  Sum_GBPXIReadNoRet.j +,
                          Dif_GBPXIReadNoRet.j
            if GBPCount = 15 then
            do
               say 'GBPCount'  Run_fmt_time
               GBPXIMissRatio.j = Sum_GBPXIReadNoRet.j /,
                      (1+Sum_GBPXIReadNoRet.j + Sum_GBPXIReadRet.j)
               Say 'MissRatio' j GBPXIMissRatio.j,
                        Sum_GBPXIReadNoRet.j Sum_GBPXIReadRet.j,
                        format(GBPXIMissRatio.j,4,2)
               /* reinit value for a new cycle of 15 minutes */
               Sum_GBPXIReadRet.j   =  Dif_GBPXIReadRet.j
               Sum_GBPXIReadNoRet.j =  Dif_GBPXIReadNoRet.j
            end
            else GBPXIMissRatio.j=0
         end /* loop */
         if GBPCount=15 then GBPCount=0
   return
init_sum_bpstats:
          Sum_QBSTGET = 0
          Sum_QBSTRIO = 0
          Sum_QBSTPWS = 0
          Sum_QBSTIMW = 0
          Sum_QBSTDSO = 0
          Sum_QBSTWIO = 0
          Sum_QBSTRPI = 0
          Sum_QBSTWPI = 0
          Sum_QBSTPIO = 0
          Sum_QBSTCIO = 0
          Sum_QBSTDIO = 0
          Sum_QBSTLIO = 0
          Sum_QBSTSGT = 0
          Sum_QBSTSIO = 0

         /* raz all figures for all bufferpool */
         do i = 1 to nbbp_entry.0
            j = nbbp_entry.i
            BufGet.j = 0
            BufRIO.j = 0
            BufPWs.j = 0
            BufIMW.j = 0
            BufDSO.j = 0
            BufWIO.j = 0
            BufRPI.j = 0
            BufWPI.j = 0
            BufPIO.j = 0
            BufCIO.j = 0
            BufVPL.j = 0
            BufDIO.j = 0
            BufLIO.j = 0
            BufSGT.j = 0
            BufSIO.j = 0
            BufHST.j = 0
            BufRHS.j = 0
         end
     return
init_gbpstats:
         /* raz all figures for all bufferpool */
         do i = 1 to nbgbp_entry.0
            j = nbgbp_entry.i
            GBPGetpage.j=0
            GBPXIReadRet.j=0
            GBPXIReadNoRet.j=0
            QBGLAW.j=0
            QBGLSW.j=0
         end
     return
switch_bpstats:
         /* new to Old only if new value exists */
      if BufGet.j > 0  then do
         do i = 1 to nbbp_entry.0
            j = nbbp_entry.i
            oBufGet.j = BufGet.j
            oBufRIO.j = BufRIO.j
            oBufPWS.j = BufPWS.j
            oBufIMW.j = BufIMW.j
            oBufDSO.j = BufDSO.j
            oBufWIO.j = BufWIO.j
            oBufRPI.j = BufRPI.j
            oBufWPI.j = BufWPI.j
            oBufPIO.j = BufPIO.j
            oBufCIO.j = BufCIO.j
            oBufDIO.j = BufDIO.j
            oBufLIO.j = BufLIO.j
            oBufSGT.j = BufSGT.j
            oBufSIO.j = BufSIO.j
            oBufHST.j = BufHST.j
            oBufRHS.j = BufRHS.j
         end   /* end do */
      end /* end if ...*/
     return
switch_bpstatx:
         /* new to Old only if new value exists */
         do i = 1 to nbbp_entry.0
            j = nbbp_entry.i
            if BufGet.j > 0  then do
              oBufGet.j = BufGet.j
              oBufRIO.j = BufRIO.j
              oBufPWS.j = BufPWS.j
              oBufIMW.j = BufIMW.j
              oBufDSO.j = BufDSO.j
              oBufWIO.j = BufWIO.j
              oBufRPI.j = BufRPI.j
              oBufWPI.j = BufWPI.j
              oBufPIO.j = BufPIO.j
              oBufCIO.j = BufCIO.j
              oBufDIO.j = BufDIO.j
              oBufLIO.j = BufLIO.j
              oBufSGT.j = BufSGT.j
              oBufSIO.j = BufSIO.j
              oBufHST.j = BufHST.j
              oBufRHS.j = BufRHS.j
            end   /* end if */
         end /* end do ...*/
     return
switch_gbpstats:
         /* new to Old only if new value exists */
         do i = 1 to nbgbp_entry.0
            j = nbgbp_entry.i
            if GBPGetPage.j > 0 then do
               oGBPGetPage.j  =GBPGetPage.j
               oGBPXIReadRet.j  =GBPXIReadRet.j
               oGBPXIReadNoRet.j=GBPXIReadNoRet.j
               oQBGLAW.j=QBGLAW.j
               oQBGLSW.j=QBGLSW.j
            end
         end   /* end do */
     return
record_bp:
     /* add a new bufferpool id in the list */
           do i = 1 to nbbp_entry.0
              if QBSTPID = nbbp_entry.i then leave
           end
           /* not found => new entry */
           if i > nbbp_entry.0 then
           do
               nbbp_entry.0 = nbbp_entry.0 + 1
               j            = nbbp_entry.0
               nbbp_entry.j = QBSTPID

               oBufGet.QBSTPID = 0
               oBufRIO.QBSTPID = 0
               oBufPWS.QBSTPID = 0
               oBufIMW.QBSTPID = 0
               oBufDSO.QBSTPID = 0
               oBufWIO.QBSTPID = 0
               oBufRPI.QBSTPID = 0
               oBufWPI.QBSTPID = 0
               oBufPIO.QBSTPID = 0
               oBufCIO.QBSTPID = 0
               oBufDIO.QBSTPID = 0
               oBufLIO.QBSTPID = 0
               oBufSIO.QBSTPID = 0
               oBufSGT.QBSTPID = 0
               oBufHST.QBSTPID = 0
               oBufRHS.QBSTPID = 0
           end
   return
record_gbp:
     /* add a new bufferpool id in the list */
           do i = 1 to nbgbp_entry.0
              if QBGLGN  = nbgbp_entry.i then leave
           end
           /* not found => new entry */
           if i > nbgbp_entry.0 then
           do
               nbgbp_entry.0 = nbgbp_entry.0 + 1
               j            = nbgbp_entry.0
               nbgbp_entry.j = QBGLGN
               say 'record_gbp' QBGLGN

               oGBPGetPage.QBGLGN  = 0
               oGBPXIReadRet.QBGLGN  = 0
               oGBPXIReadNoRet.QBGLGN  = 0
               oQBGLAW.QBGLGN  = 0
               oQBGLSW.QBGLGN  = 0
               Sum_GBPXIReadRet.QBGLGN  = 0
               Sum_GBPXIReadNoRet.QBGLGN  = 0
           end
   return
/********************************************************/
/* Check individual parameters for best practices alert */
/********************************************************/
CheckForAlert:
    /* Global Dynamic Stmt cache hit ratio > 90% */
    Hit = Dif_QXSTFND / (Dif_QXSTFND+Dif_QXSTNFND + 0.01)
    if Hit < 0.90 then
             do
               say 'Warning : Global Dyn. Cache Hit < 90%',
                  format(Hit,3,2) ' Ã ' run_fmt_time
               retcode=4
             end
    /* Local  Dynamic Stmt cache hit ratio > 70% */
    /* Source Optimizing DB2 System Performance using db2 statistics*/
    Hit = Dif_QXSTNPRP/ (Dif_QXSTNPRP + Dif_QXSTIPRP + 0.01)
    if Hit = 0   then do
           if tsaylocal=0 then do
             say 'Warning : Local Dyn. Cache probably not used'
             tsayLocal = 1
           end
    end
    else if Hit < 0.70 then
             do
               say 'Warning : Local Dyn. Cache Hit < 70%',
                  format(Hit,3,2) ' Ã ' run_fmt_time
               retcode=4
             end
    /* SLRU full   */
          if Det_HST.j    > 0 then
             do
               say 'Warning : SLRU chain = VPSEQT',
                   ' Ã ' run_fmt_time
               retcode=4
             end
    /* Checkpoints */
       period= 15
       if HistCKPT.0 < period then
       do
          /* store the value for sliding */
          HistCKPT.0 = HistCKPT.0 + 1
          j=HistCKPT.0
          HistCKPT.j = Dif_QWSDCKPT
       end
       else do /* decaler pour prendre que les 15 dernieres */
          i=1
          sum=0
          do until i= period
              j=i+1
              HistCKPT.i = HistCKPT.j
              sum = sum+HistCKPT.j
              i=i+1
          end
          HistCKPT.i = Dif_QWSDCKPT  /*i= period */
          sum = sum+HistCKPT.i
          if sum  > 3 then /* 1 checkpoint each 5/10 mn is OK */
             do
               say 'Warning : Checkpoint frequency too high' sum,
                   'for' period 'minutes Ã ' run_fmt_time
               retcode=4
             end
       end
    /* Close DSMAX */
          if Dif_QTDSDRN  > 0 then
             do
               say 'Warning : Close Dataset due to DSMAX reached',
                   ' Ã ' run_fmt_time
               retcode=4
             end

    /* RWRO Switch */
       period= 5
       if HistRWRO.0 < period then
       do
          HistRWRO.0 = HistRWRO.0 + 1
          j=HistRWRO.0
          HistRWRO.j = Dif_QTPCCT
       end
       else do /* push stack */
          i=1
          sum=0
          do until i= period
              j=i+1
              HistRWRO.i = HistRWRO.j
              sum = sum+HistRWRO.j
              i=i+1
          end
          HistRWRO.i = Dif_QTPCCT    /*i= period */
          sum = sum+HistRWRO.i
          /* 15 switch per minute is acceptable */
          if sum  > (15* period) then
             do
               say 'Warning : RWRO switch too high' sum,
                   'for' period 'minutes Ã ' run_fmt_time
               retcode=4
             end
       end
    /* Page Ins    */
          if Sum_QBSTRPI  > 0 |  Sum_QBSTWPI > 0 then
             do
               say 'Warning : Page in for Read/Write happened',
                   ' Ã ' run_fmt_time Sum_QBSTRPI Sum_QBSTWPI
               retcode=4
             end
 return
