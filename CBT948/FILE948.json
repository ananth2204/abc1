{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013548000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 764218, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE948.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE948.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\r\\x05'", "DS1TRBAL": "b'\\x83|'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xde\\x00\\x0b\\t\\xdf\\x00\\t\\x00\\x0e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00\\x15\\x01\\x19\\x11/\\x01\\x19\\x11/\\x108\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-22T00:00:00", "modifydate": "2019-04-22T10:38:15", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  948\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE948\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 6,932 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/22/19    10:38:15    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00B\\x01\\x16\\x18\\x7f\\x01\\x17\\x12_\\x18\\x02\\x00,\\x00'\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-07-05T00:00:00", "modifydate": "2017-05-05T18:02:42", "lines": 44, "newlines": 39, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Question\nFrom:     dt n <ndt2004@gmail.com>\nDate:     7/4/2016 1:21 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nNote added later:  Programs have been updated, dated\n                   May 5, 2017\n\n\n\nHi Sam ,\n\nPlease find attached a modified version of file948.xmi :\n\nI renamed the IFCID program to IFCREADS because this program\nprovides a good example of using the READS (Read synchrone) from\nDB2 IFC  (instrumentation facility component).  IFCID is too\nmuch large because there is hundred of IFCID in DB2 (a sort of\nsubcomponent of SMF100 and 101 data)\n\nI checked S110CSV.\n\nI added S100CSV and S101CSV which are essential programs for a\nDB2 sysprog :\n\nS100CSV decodes the DB2 Statistics records.  It is a must use for\nall DB2 system admins, as the name says, you have anything that\nhappened on your DB2 system in counters.\n\nS101CSV decodes the DB2 Accounting records.  It is a must use for\nall DB2 DBAs, it is  application oriented, you have anything that\nhappened to your program accessing DB2 in counters.\n\nAs far as i know, no one shares these two programs on the\nInternet, so until now, if you want to access to these\ninformations, you have to pay to vendors (BMC, IBM, CA ...) or\nyou write it yourself and keep it secret.  I wrote these 2\nprograms to be vendor free, and also because vendors are always\nbehind IBM, so you know that you have this information in SMF,\nbut your vendor doesn't give it to you yet ....\n\nSee you soon,\nDuc\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE948": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00\\t\\x01\\x19\\x11/\\x01\\x19\\x11/\\x108\\x00T\\x00T\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-22T00:00:00", "modifydate": "2019-04-22T10:38:09", "lines": 84, "newlines": 84, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 948 is from Duc Tuan Nguyen (dt n) and contains REXX      *   FILE 948\n//*           programs of considerable complexity, which he has     *   FILE 948\n//*           found useful in his z/OS, DB2, and CICS work.         *   FILE 948\n//*                                                                 *   FILE 948\n//*           email:  dt n <ndt2004@gmail.com>                      *   FILE 948\n//*                                                                 *   FILE 948\n//*     Description of Programs -                                   *   FILE 948\n//*                                                                 *   FILE 948\n//*     IFCREADS - REXX WHICH READS AN IFCID401 SAMPLE AND          *   FILE 948\n//*             PROVIDES A CSV DATASET FOR ANALYSIS                 *   FILE 948\n//*             (Comma Separated Variables)                         *   FILE 948\n//*                                                                 *   FILE 948\n//*     This Rexx is inspired from Rexx program MEMU provided       *   FILE 948\n//*     by IBM. It starts a Monitor trace and reads the buffer      *   FILE 948\n//*     returned. In this Rexx I read IFCID401 which is called      *   FILE 948\n//*     \"Static Statement Cache\".  The data returned can be         *   FILE 948\n//*     used in different ways.                                     *   FILE 948\n//*                                                                 *   FILE 948\n//*     IFCID 401 is mapped using a \"varying length repeating       *   FILE 948\n//*     group\", so the processing is different than IFCID 225       *   FILE 948\n//*     (easier) which is read by MEMU for example.                 *   FILE 948\n//*                                                                 *   FILE 948\n//*     The data returned is really huge so you should filter       *   FILE 948\n//*     directly from the REXX or by qualifying your READS          *   FILE 948\n//*     request. Time is GMT (I think) so don't be surprised.       *   FILE 948\n//*                                                                 *   FILE 948\n//*     PDS2SEQ - A REXX program to put a PDS into sequential       *   FILE 948\n//*               format                                            *   FILE 948\n//*                                                                 *   FILE 948\n//*     I use my PC as a \"data store\", where I have anything        *   FILE 948\n//*     on it (Manuals, Redbooks, documents, presentations          *   FILE 948\n//*     ...). And with the help of a search software                *   FILE 948\n//*     (Archivarius seems to be the best search software that      *   FILE 948\n//*     I've found after many tests), I am able to find             *   FILE 948\n//*     anything on my PC (A sort of Google search on my PC).       *   FILE 948\n//*                                                                 *   FILE 948\n//*     So, it is interesting for me to be able to retrieve         *   FILE 948\n//*     data that are on PDS from my search software.  This         *   FILE 948\n//*     Rexx reads a PDS, puts it in a sequential format , so       *   FILE 948\n//*     I can ftp it on my PC. It provides also jcl that you        *   FILE 948\n//*     can use to reload the sequential into a PDS format.         *   FILE 948\n//*                                                                 *   FILE 948\n//*     It is adapted from a Rexx that I've found on the web        *   FILE 948\n//*     (unfortunately I am not able to find the first author.)     *   FILE 948\n//*                                                                 *   FILE 948\n//*     (Revised by dt n, Mar 26, 2019).                            *   FILE 948\n//*                                                                 *   FILE 948\n//*     S110CSV - REXX TO CREATE A CSV DATASET FROM SMF110          *   FILE 948\n//*                      (CICS PERFORMANCE RECORDS)                 *   FILE 948\n//*                                                                 *   FILE 948\n//*     This REXX reads the unloaded dataset written from the       *   FILE 948\n//*     standard program DFH$MOLS which prints SMF110 CICS          *   FILE 948\n//*     performance records.                                        *   FILE 948\n//*                                                                 *   FILE 948\n//*     The output of DFH$MOLS unfortunately is not easy for        *   FILE 948\n//*     analysis.                                                   *   FILE 948\n//*                                                                 *   FILE 948\n//*     This REXX provide a CSV dataset (I like Excel), with        *   FILE 948\n//*     Transaction ID, elapsed and CPU time associated with        *   FILE 948\n//*     the number of DB2 requests. This is useful to have          *   FILE 948\n//*     quickly a performance indicator of your information         *   FILE 948\n//*     system to compare (which is mainly CICS and DB2 ...).       *   FILE 948\n//*     As SMF110 includes DB2 time, all your consumption is        *   FILE 948\n//*     here.                                                       *   FILE 948\n//*                                                                 *   FILE 948\n//*     More detailed than SMF30                                    *   FILE 948\n//*                                                                 *   FILE 948\n//*     More convenient than SMF101 (in my shop SMF101 is not       *   FILE 948\n//*     collected for CICS transactions because it is really        *   FILE 948\n//*     huge)                                                       *   FILE 948\n//*                                                                 *   FILE 948\n//*     Prereq:  Execute DFHMNDUP then DFH$MOLS with the            *   FILE 948\n//*              UNLOAD option                                      *   FILE 948\n//*                                                                 *   FILE 948\n//*     S100CSV - REXX TO CREATE A CSV DATASET FROM SMF100          *   FILE 948\n//*                      (DB2 STATISTICS RECORDS)                   *   FILE 948\n//*     This REXX provides a sample of DB2 statistics fields,you    *   FILE 948\n//*     can use it as a basis to expand its capability              *   FILE 948\n//*                                                                 *   FILE 948\n//*     S101CSV - REXX TO CREATE A CSV DATASET FROM SMF101          *   FILE 948\n//*                      (DB2 ACCOUNTING RECORDS)                   *   FILE 948\n//*     This REXX providesa sample of DB2 accountings fields,you    *   FILE 948\n//*     can use it as a basis to expand its capability              *   FILE 948\n//*                                                                 *   FILE 948\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFCREADS": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00G\\x01\\x16\\x18_\\x01\\x18\\x06_\\x18&\\x02 \\x01\\xd7\\x00\\x00\\xe6\\xe2\\xe8\\xd5\\xc7\\xe4\\xc4@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2016-07-03T00:00:00", "modifydate": "2018-03-06T18:26:47", "lines": 544, "newlines": 471, "modlines": 0, "user": "WSYNGUD"}, "text": "/* REXX ***************************************************************/\n/*                                                                    */\n/*                                                                    */\n/* <ssid>       DB2 subsystem name                                    */\n/* <numtimes>   Number of intervals (default 60)                      */\n/* <sleeptime>  Time in seconds between two intervals (default 60)    */\n/* <GPMin>      Filter only records with Getpage > GPMin              */\n/* By default EXCLUDE records with Cputime=0  QW0401CP                */\n/*                                                                    */\n/* For information on programming \"Managing Performance V11\"          */\n/* chapter : \"Programming for the Instrumentation Facility Interface\" */\n/*                                                                    */\n/* REXX****************************************************************/\narg suf ssid numtimes sleeptime GPMin\nnumeric digits 25\n\nhlq='SYSTMP.WSYNGUD'\nif suf = 'AUTO' then\ndo\n   suf=MVSVAR(SYSNAME)\nend\nif ssid = '' then do\n say 'YOU MUST ENTER THE NAME OF THE DB2 SUBSYSTEM'\n exit 20\nend\nif numtimes = '' then numtimes = 60\nif datatype(numtimes) <> 'NUM' then do\n logds = numtimes\n numtimes = 60\nend\n/* if sleeptime = '' then sleeptime = 60\nif datatype(sleeptime) <> 'NUM' then do\n logds = sleeptime\n sleeptime = 60\nend */\n\nif GPMin     = '' then GPMin     = 1\n\nsay ' '\nsay 'Processing for Subsys' ssid\nsay '    Number of iteration : ' numtimes\nsay '    Sleep time (seconds): ' sleeptime\nsay '    Getpage minimum     : ' GPMin\nsay ' '\n\n/* init compteurs divers */\ncall init_var\n/* WRITE report header */\nCALL write_header\n/* Connect to DB2 */\nCALL Init_DB2\n/* Start Trace IFCID 400 (switch on) */\nCMD = '-STA TRACE(MON) CLASS(30) IFCID(400)'\ntno2=StartTrace(CMD)\nif tno2 < 0 then exit(8)\n/* Prepare START TRACE command */\nCMD = '-STA TRACE(MON) CLASS(32) IFCID(401)'\ntno=StartTrace(CMD)\nif tno < 0 then do\n        call Stoptrace tno2\n        exit(8)\n    end\n\niterno = 1\n\n/* Loop of  READS command using IFI interface */\ndo numtimes\n    a=date()\n    b=time()\n    call Alloc_File\n    /* WRITE report header */\n    if iterno =  1  then CALL write_header\n    Say '**** READS ****'\n    call IFIReads\n    if  bytes_moved > 0 then\n    do\n        call ProcessData\n    end\n    /* Close & Deallocate files */\n    \"EXECIO \"QUEUED()\" DISKW OUFS(FINIS\"\n    \"FREE F(OUFS)\"\n    if numtimes > 1 then call Wait\n    say time()\n    iterno = iterno+1\nend /* end do numtimes */\n\n/* End of program */\ncall StopTrace tno\ncall StopTrace tno2\n\n/* Disconnect from DB2 */\nADDRESS DSNREXX \"DISCONNECT\"\n\nsay 'End of Program'\nsay '   Nbr records skipped GP Minimum encountered :' NbrSkipGP\nsay '   Nbr records written : ' reco\nsay '   Nbr records read    : ' reci\nexit 0\n\nStopTrace:\n arg tno\n if datatype(tno) = 'NUM' & tno > 0 then do\n    say 'Try to stop trace ...'\n    CMD = '-STO TRACE(MON) TNO('tno')'\n    COMMAND = substr('COMMAND',1,10)\n    IFCA = '00B40000'X||'IFCA'||copies('00'X,172)\n    RtrSz = 512\n    RtrArea = d2c(RtrSz+4,4)left(' ',RtrSz,' ')\n    DumZon = d2c(length(CMD)+4,2)||'0000'X||CMD\n    Buff = '00000000'X||'WBUF'||'0000000000000000'X\n    ADDRESS LINKPGM \"DSNWLI2 COMMAND IFCA RtrArea DumZon Buff\"\n    RetC = c2d(substr(IFCA,13,4))\n    Reas = d2x(c2d(substr(IFCA,17,4)))\n    if RetC <> 0 & Reas <> 'E60820' then do\n     say 'PROBLEM WITH STOP TRACE COMMAND'\n     say 'COMMAND RETCODE = ' RetC\n     say 'COMMAND REASON = ' Reas\n    end\n    else say 'Trace Stopped'\n end    /* if datatype(tno */\n else say '** Warning - MONITOR trace was started but not stopped **'\n return\n/*--------------------------------------------------------------------*/\nProcessVarLenRepGroup:\n      k=i   /* number of data section to process */\n  /*  Say 'ProcessVarLenRepGroup: number of data sect to process' i*/\n      offset_data2= offset_data\n      do while k <= rep_data\n          len_data2= c2d(substr(rec,offset_data2,2))\n          k=k+1\n       /* Subsequent members can be found by advancing the pointers*/\n       /* (length of current member + 2 bytes) forward.            */\n          Call QW0401 offset_data2+2\n          if write   > 0 then Call Write_RepSQL\n          offset_data2=  offset_data2+len_data2+2 /*cf doc sdsnmacs*/\n      end\n   RETURN\n\nQW0401:\n       arg offset_ifc\n    /* say 'QW0401 Process offset' offset_ifc */\n     /*say 'Process data section QW0401'*/\n       write = 1\n       /* save start of Ifcid Data */\n       Offs=Offset_ifc\n       /* Getpage     */\n       QW0401GP =c2d(SUBSTR(rec,offs+24,8))\n       if QW0401GP < GPMin then\n           do\n               /* exclude Getpage < GPMin */\n               write = 0\n               NbrSkipGP = NbrSkipGP+1\n               return\n           end\n       /* db2 cpu (including ziip) */\n       QW0401CP = c2x(SUBSTR(rec,offs+96,8))\n       QW0401CP = x2d(substr(QW0401CP,1,13))\n       QW0401CP = QW0401CP /1000000\n       /* if QW0401CP = 0 then\n           do\n               /* exclude QW0401CP = 0 */\n               write = 0\n               return\n           end */\n       /* offset_QW0401 will be used later */\n       /*offset_d points to the IFCID 401 data to process */\n       QW0401ID =C2D(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr execs */\n       QW0401EX =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr sync buffer reads */\n       QW0401SR =c2d(SUBSTR(rec,offs,8))\n       offs = offs +16\n       /* nbr examined rows */\n       QW0401ER =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr rows processed */\n       QW0401PR =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr sorts */\n       QW0401ST =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr ix scans */\n       QW0401IX =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr TS scans*/\n       QW0401TB =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr Buff writes*/\n       QW0401WT =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* nbr Parallel groups created*/\n       QW0401PG =c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* db2 elapse time */\n       QW0401ET = c2x(SUBSTR(rec,offs,8))\n       QW0401ET = x2d(substr(QW0401ET,1,13))\n       QW0401ET = QW0401ET /1000000\n       offs = offs +16\n       /* wait time for sync IO    */\n       QW0401SI = c2x(SUBSTR(rec,offs,8))\n       QW0401SI = x2d(substr(QW0401SI,1,13))\n       QW0401SI = QW0401SI/1000000\n       offs = offs +32\n       /* wait time for other Reads  */\n       QW0401OR = c2x(SUBSTR(rec,offs,8))\n       QW0401OR = x2d(substr(QW0401OR,1,13))\n       QW0401OR = QW0401OR/1000000\n       offs = offs +8\n       /* wait time for other Write  */\n       QW0401OW = c2x(SUBSTR(rec,offs,8))\n       QW0401OW = x2d(substr(QW0401OW,1,13))\n       QW0401OW = QW0401OW/1000000\n       offs = offs +8\n       /* RID list failed Limit    */\n       QW0401RL= c2d(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* RID list failed Storage  */\n       QW0401RS = c2d(SUBSTR(rec,offs,8))\n       offs = offs +48\n       /* Package token   */\n       QW0401CT= c2x(SUBSTR(rec,offs,8))\n       offs = offs +8\n       /* Process Pkg Collection */\n       Tmp_Off=C2D(SUBSTR(rec,offs,2))\n       Tmp_Off=Tmp_Off + offset_ifc\n       len=C2D(SUBSTR(rec,Tmp_Off,2))\n       QW0401CL =SUBSTR(rec,Tmp_Off+2,len)\n       /* Process Pkg Name */\n       offs = offs +2\n       Tmp_Off=C2D(SUBSTR(rec,offs,2))\n       Tmp_Off=Tmp_Off + offset_ifc\n       len=C2D(SUBSTR(rec,Tmp_Off,2))\n       QW0401PK    =SUBSTR(rec,Tmp_Off+2,len)\n       offs = offs +2\n       /* QW0401TM2 */\n       clock =c2x(SUBSTR(rec,offs,8))\n       Parse Value Stck2Local(clock) With datei timei\n       offs = offs +18\n       /* QW0401UT1 */\n       clock =c2x(SUBSTR(rec,offs,8))\n       Parse Value Stck2Local(clock) With dateS timeS\n       return\n\nAlloc_File:\n   /* Report dataset  */\n   oufs = \"'\" || hlq || '.REPORT.SQL.' || suf || \"'\"\n   /* \"DELETE\" oufS \"PURGE\" */\n\n   Say OUFS ' will be allocated in DISP=MOD'\n   \"ALLOC FI(OUFs) DA(\"oufs\") MOD CATALOG REUSE\" ,\n   \"LRECL(350) RECFM(V B) TRACKS SPACE(300,200)\"\n   rcalloc = rc\n   if rcalloc <> 0 then Do\n        say \"**********************************************\"\n        say \"   Error allocating repSQL file\" rcalloc\n        say \"   Abnormal end  \"\n        say \"**********************************************\"\n        Exit 8\n   end\n  RETURN\n\ninit_var:\n  /* compteurs input/DumZon */\n  NbrSkipGP = 0\n  nbr_ifcid = 0\n  reco= 0\n  reci= 0\n  recs= 0\n  min_time='23:59:59'\n    QW0401ID =-1\n    Use_Cnt=-1\n    tran_name='NA'\n    end_user='NA'\n    wrkstation='NA'\n    table_name='NA'\n    sql_text='NA'\n    QW0401CT='NA'\n    QW0401CL='NA'\n  return\n\nwrite_header:\n    say 'CSV file ' oufS     ' will be produced'\n    queue \"Date,Time, SSID,DatInEDM,TimeIn,DateStats,TimeS,\",\n       \"Elap,Cpu,Execs,SyncRead,BufWr,GP,WtSyncIO,WOthRd,WOthWr,\",\n       \"ExRows,ProcRows,\",\n       \"Sort,IxScan,TsScan,ParaGrp,\",\n       \"RIDLim,RIDStor,PgmN,ColId,PkgTok,StmID,\"\n\n    \"EXECIO\" queued() \"DISKW OUFS\"\n  return\n\nWrite_RepSQL:\n    reco= reco+ 1\n    /*rows in excel format */\n    queue a || ',' || b || ',' || ssid      || ',' ,\n    || DateI        || ','   ,\n    || substr(TimeI,1,13)        || ','   ,\n    || DateS        || ','   ,\n    || substr(TimeS,1,13)        || ','   ,\n    || QW0401ET     || ','   ,\n    || QW0401CP     || ','   ,\n    || QW0401EX     || ','   ,\n    || QW0401SR     || ','   ,\n    || QW0401WT     || ','   ,\n    || QW0401GP     || ','   ,\n    || QW0401SI     || ','   ,\n    || QW0401OR     || ','   ,\n    || QW0401OW     || ','   ,\n    || QW0401ER     || ','   ,\n    || QW0401PR     || ','   ,\n    || QW0401ST     || ','   ,\n    || QW0401IX     || ','   ,\n    || QW0401TB     || ','   ,\n    || QW0401PG     || ','   ,\n    || QW0401RL     || ','   ,\n    || QW0401RS     || ','   ,\n    || QW0401PK     || ','   ,\n    || QW0401CL     || ','   ,\n    || QW0401CT     || ','   ,\n    || QW0401ID     || ','\n\n   \"EXECIO \"QUEUED()\" DISKW OUFS\"\nreturn\n\nIFIReads:\n   READS = substr('READS',1,8)\n   IFCA = '00B40000'X||'IFCA'||copies('00'X,172) /* 180*/\n   RtrSz = 250000\nRead_Again:\n   RtrArea = d2c(RtrSz+4,4)left(' ',RtrSz,' ')\n   IFCIDAREA = '000600000191'X  /*IFCID 401*/\n   /* Qualify Area is described by DSNDWQAL */\n   /* Length of Qual. Area must have some defined  */\n   /* values. Cf. SDSNMACS*/\n   /* Otherwise Error - LEN choosen 920 WQALLN9 */\n   /*\n   QUAL     = '03980000'X || 'WQAL'  ,\n       || copies('00'x,162)  ,\n       || '02'x         , /*QWALFTR Activate filter */\n       || 'G'           , /*QWALFFLD  Qualify on Getpage */\n       || '000003E8'x   , /*QWALFVAL At least 1000 GETPAGE */\n       || copies('00'x,744)\n   */\n   QUAL     = '03980000'X || 'WQAL' || copies('00'x,912)\n   say 'Call IFI Reads'\n   ADDRESS LINKPGM \"DSNWLI2 READS IFCA RtrArea IFCIDAREA QUAL\"\n   RetC = c2d(substr(IFCA,13,4))\n   Reas = d2x(c2d(substr(IFCA,17,4)))\n   if RetC > 4 then do\n        say 'Error READS ...'\n        say '  READS RETCODE = ' RetC\n        say '  READS REASON = ' Reas\n        call StopTrace tno\n        exit 8\n   end\n   bytes_moved = c2d(substr(IFCA,21,4)) /*IFCABM*/\n      say 'bytes_moved =' bytes_moved\n   bytes_left = c2d(substr(IFCA,25,4))   /*IFCABNM*/\n   if bytes_moved = 0 then\n      do\n        say '** Warning - Nothing to read  **'\n        return\n      end\n   if bytes_left > 0 then\n   do\n      say '** Warning - Truncated IFCID401 record **'\n      say bytes_left ' bytes not reported'\n      RtrSz =bytes_left + bytes_moved\n      say 'Retry READS with value' RtrSz\n      signal Read_Again\n   end\n   RETURN\n\nIfiHeaderCheck:\n /* Processing RTRAREA */\n /* 4 bytes (RTRAREA Len.)  */\n /* 2 bytes (IFCID Data Len) + 2 reserved  */\n /* Self defining Section (Pointers to Prod section and data sect. */\n /*      4 bytes offset to Prod, 2 bytes Len of Prod Section,  */\n /*                              2 bytes Repeat Prod Section,  */\n /*      4 bytes offset to Data, 2 bytes Len of Data Section,  */\n /*                              2 bytes Repeat Data Section,  */\n /* Header described by DSNDQWIW */\n if  c2d(substr(RtrArea,5,1)) = 128   /* first byte = x'80' */\n    then    len  = c2d(substr(RtrArea,6,3)) /* Len QWIWLEN */\n    else    len  = c2d(substr(RtrArea,5,2))\n Rec  = substr(RtrArea,5,LEN)     /* recup data */\n /* go to Product section - mapped by DSNDQWHS */\n offset_prod = c2d(substr(rec,5,4))+1\n /* len_prod = c2d(substr(rec,9,2))\n rep_prod = c2d(substr(rec,11,2)) */\n Ifcid = c2d(substr(rec,offset_prod+4,2))\n DataN  = c2d(substr(rec,offset_prod+6,1))\n /*\n DB2Rel = c2x(substr(rec,offset_prod+7,1))\n\n if Db2Rel<>'A1' & Db2Rel<>'B1' then do\n    say 'Not a DB2 10 or DB2 11 subsys.'\n    call StopTrace tno\n    exit 24\n   end */\n RETURN\n\nSTCK2Local:\n    /* Store Clock Value Time to Local Time */\n    arg clock\n    clock = SPACE(clock,0)\n    cvt     = C2X(STORAGE(10,4))\n    cvttz_p = D2X(X2D(cvt) + X2D(130))\n    tzo     = STORAGE(cvttz_p,4)\n    tzo     = C2D(tzo,4)*1.048576\n    tzo     = (tzo+.5)%1\n    ndigits = MAX(6,1.2*LENGTH(clock)+1)%1\n    Numeric Digits ndigits\n    clock   = x2d(clock)*1.048576 / 16**(LENGTH(clock)-8)\n    clock   = clock + tzo\n    If clock < 0  Then Parse Value 0      0     ,\n                             With  clock  tzo\n    seconds = clock // (24*60*60)\n    days    = clock %  (24*60*60)\n    days    = days + 2415021\n    Parse Value DATECONV(days) With y m d dow\n    hours   = RIGHT( seconds %3600    ,2,'0')\n    minutes = RIGHT((seconds//3600)%60,2,'0')\n    seconds = seconds//60\n    /* t1      = y'/'m'/'d hours':'minutes':'seconds   */\n    /*TsTime  =  hours':'minutes':'seconds\n    TsDate  =  y'/'m'/'d */\n    return  y'/'m'/'d hours':'minutes':'seconds\n\nDATECONV:\n    Parse Upper Arg julday\n    j =julday-1721119\n    d =((4*j-1)//146097+146097)//146097\n    d =d%4\n    y =(4*j-1)%146097*100+(4*d+3)%1461\n    d =(((4*d+3)//1461+1461)//1461+4)%4\n    m =(5*d-3)%153\n    d =(((5*d-3)//153+153)//153+5)%5\n    If m<10 ,\n      Then  Parse Value m+3     With m\n      Else  Parse Value m-9 y+1 With m y\n    dow = (julday+1)//7\n    Return RIGHT(y,4,'0') RIGHT(m,2,'0') RIGHT(d,2,'0')   ,\n       WORD('Sun Mon Tue Wed Thu Fri Sat',1+dow) || 'day'\n\nWait:\n     /*  say 'Wait for ' sleeptime 'seconds'\n      call syscalls 'ON'\n      address syscall 'sleep ' sleeptime\n      call syscalls 'OFF' */\n     /* Build sleep time in format of rexxwait */\n     /*  say 'Wait for 5 minutes' */\n    if pos('MN',sleeptime) > 0 then\n    do\n       duree='00'substr(sleeptime,1,2)'0000'\n    end\n    else if pos('HR',sleeptime) > 0 then\n    do\n       duree=substr(sleeptime,1,2)'000000'\n    end\n    say 'Wait for ' duree '(HHMMSSCC)'\n    rc=rexxwait(duree)\nreturn\n\nInit_DB2:\n  /* Connect to DB2 subsystem */\n  ADDRESS TSO \"SUBCOM DSNREXX\"\n   if RC then\n   S_RC = RXSUBCOM('ADD','DSNREXX','DSNREXX')\n  ADDRESS DSNREXX \"CONNECT \"SSID\n  if SQLCODE <> 0 then do\n   say 'PROBLEM CONNECTING TO DB2'\n   say 'SQLCODE = ' SQLCODE\n   say 'SQLSTATE = ' SQLSTATE\n   say 'SQLERRP = ' SQLERRP\n   say 'SQLERRMC = ' SQLERRMC\n   exit 12\n  end\n  return\n\nStartTrace: Procedure\n  arg CMD\n  say CMD\n  COMMAND = substr('COMMAND',1,10)\n  /*init zones */\n  IFCA = '00B40000'X||'IFCA'||copies('00'X,172) /*180*/\n  RtrSz = 512\n  RtrArea = d2c(RtrSz+4,4)left(' ',RtrSz,' ')\n  DumZon = d2c(length(CMD)+4,2)||'0000'X||CMD\n  Buff = '00000000'X||'WBUF'||'0000000000000000'X\n  /* Submit START command using IFI interface */\n  ADDRESS LINKPGM \"DSNWLI2 COMMAND IFCA RtrArea DumZon Buff\"\n  RetC = c2d(substr(IFCA,13,4))\n  Reas = d2x(c2d(substr(IFCA,17,4)))\n  if RetC <> 0 & Reas <> 'E60820' then do\n     say 'PROBLEM WITH START TRACE COMMAND'\n     say 'COMMAND RETCODE = ' RetC\n     say 'COMMAND REASON = ' Reas\n     return(-1)\n  end\n  /*\n    Check if message DSNW130I was issued indicating a\n    new trace has been\n    started, and if so remember the tno so trace can be stopped later.\n  */\n  LEN = c2d(substr(RtrArea,5,2))\n  MSG = substr(RtrArea,9,LEN-5)\n  parse var MSG msgno . 'TRACE NUMBER 'tno\n  if pos('400',cmd) > 0 & msgno = 'DSNW135I' then return(99)\n  if msgno <> 'DSNW130I' then do\n                         say MSG\n                         return(-1)\n                      end\n  say  'Trace started TNO' tno\n  return(tno)\n\nProcessData:\n    call IfiHeaderCheck\n    /* process each data section*/\n    i = 1\n    do while i <  datan\n     /* say 'Processing Self Defined Data' i */\n        j=5+8*i /* ptr to next self de. data section */\n        offset_data= c2d(substr(rec,j,4))+1\n        len_data= c2d(substr(rec,j+4,2))\n        /* len can be zero , read sdsnmacs DSNDQWT0 */\n        /* (it is called \"varying length repeating group\")  */\n        rep_data= c2d(substr(rec,j+6,2))\n    /*  say 'off data/len/rep' offset_data len_data rep_data */\n        if len_data = 0 then\n        do\n            reci=reci+1\n            call ProcessVarLenRepGroup\n            leave\n        end\n     /* This can't happen to IFCID401 */\n     /* call QW0401 offset_data\n        if write   > 0    then\n                      call Write_RepSQL */\n    end\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDS2SEQ": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00R\\x01\\x19\\x11/\\x01\\x19\\x11/\\x104\\x00\\xa3\\x00\\xa3\\x00\\x00\\xe6\\xe2\\xe8\\xd5\\xc7\\xe4\\xc4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-04-22T00:00:00", "modifydate": "2019-04-22T10:34:52", "lines": 163, "newlines": 163, "modlines": 0, "user": "WSYNGUD"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "S100CSV": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00Q\\x01\\x16\\x18o\\x01\\x18\\x06_\\x18!\\x0c\\xa1\\x04\\xd9\\x00\\x00\\xe6\\xe2\\xe8\\xd5\\xc7\\xe4\\xc4@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2016-07-04T00:00:00", "modifydate": "2018-03-06T18:21:51", "lines": 3233, "newlines": 1241, "modlines": 0, "user": "WSYNGUD"}, "text": "/*REXX*/\nnumeric digits 15\n/*-------------------------------------------------------------*/\n/* Extract smf 100 records - written by Nguyen Duc Tuan        */\n/*                                      ndt.db2\u00e0gmail.com      */\n/*   4 jan 2016     Release 1.1                                */\n/*  14 jan 2016     Release 1.2 add dsnqdst ddf stats          */\n/*  11 fev 2016     Release 1.2.1 correct imprecision          */\n/*                  on bp figures (numeric digits)             */\n/*  25 fev 2016     Release 2.0   Ifcid225 cur. threads        */\n/*                  vsm=Y   option to calculate max thread     */\n/*                  possible + central storage usage           */\n/*  15 Apr 2016     Release 2.1   More displays for threads    */\n/*                  calculation - Verification OK with values  */\n/*                  from IBM Rexx MEMU                         */\n/*  20 Apr 2016     Release 2.2   More columns for storage     */\n/*                  monitoring                                 */\n/*  03 Jul 2016     Release 2.3   Process Data Manager Section */\n/*                  (DSNDQIST macro with difference)           */\n/*  06 Jul 2016     Release 2.4   Correction abend in TF=...   */\n/*                  when number of tasks = 0                   */\n/*                  Able to process  records from several days */\n/*  29 Jul 2016     Release 2.5   Minor fixes +Logs created    */\n/*  13 Oct 2016     Release 2.6   Add Q3ST stats               */\n/*                  (Signon, Terminate, Create Threads ..)     */\n/*                  and Datasets Stats                         */\n/*  16 Dec 2016     Release 2.7   PageIns buffer Stats         */\n/*  02 Mar 2017     Release 3.0   Improve Bufferpool stats     */\n/*  21 Mar 2017     Release 3.1   More Bufferpools stats and   */\n/*                  warning messages                           */\n/*  25 Apr 2017     Release 3.2   BP memory usage in Real and  */\n/*                  Auxiliary                                  */\n/*  11 May 2017     DSC stats (Full Prepare, Short, ...) Locks */\n/*  24 May 2017     Z/OS Stats (must activate zparm) R3.4      */\n/*  16 Aug 2017     Add BP simulated stats R3.5                */\n/*  11 Oct 2017     Release 3.6 Add Workfile usage stats       */\n/*  02 Feb 2018     Release 3.7 Add more QISE stats (DBDsteal  */\n/*  02 Mar 2018     Group Buffer Pool stats + check            */\n/*-------------------------------------------------------------*/\n/*Comment : Change datasets high level identifier              */\n/*-------------------------------------------------------------*/\nARG SSID hlq smforig Alert BpSim\nretcode=0\n/* Display Warning messages (best practices)*/\nif Alert ='' then Alert='Y'\n/* Bufferpool simulation */\nif BpSim <> 'Y' then BpSim='N'\nsay 'BPsim ' BpSim\n/* Virtual storage monitoring Yes/No */\nVSM='Y'\n\nsay ' '\nsay 'Processing for Subsys' ssid\n\nifcid1_seen=0\nif smforig='' then smforig='A'\nif smforig='A' then\ndo\n     /* Input file : SMF extract sorted */\n     oufl = hlq || '.SMFEXTS.OUT'\n     \"ALLOC DD(INP) DS('\"oufl\"') ,\n                            SHR REU bufno(20)\"\nend\n\n/* Report dataset on output (general stats) */\noufl = \"'\" || hlq || '.reports.' || ssid ||  \"'\"\n\"DELETE\" oufl \"PURGE\"\n\n/* Report dataset on output (BP stats) */\noufl2= \"'\" || hlq || '.reportsb.' || ssid ||  \"'\"\n\"DELETE\" oufl2 \"PURGE\"\n\n/* Report dataset on output (GBP stats) */\noufl5= \"'\" || hlq || '.reportsg.' || ssid ||  \"'\"\n\"DELETE\" oufl5 \"PURGE\"\n\n/* Report dataset on output (STOR stats) */\noufl3= \"'\" || hlq || '.reportst.' || ssid ||  \"'\"\n\"DELETE\" oufl3 \"PURGE\"\n\n/* Report dataset on output (BP Simulation stats) */\noufl4= \"'\" || hlq || '.repSimBP.' || ssid ||  \"'\"\n\"DELETE\" oufl4 \"PURGE\"\n\n\"ALLOC FI(OUFL) DA(\"oufl\") NEW CATALOG REUSE\" ,\n\"LRECL(1400) RECFM(V B) TRACKS SPACE(50,50)\"\nrcalloc = rc\nif rcalloc <> 0 then Do\n     say \"**********************************************\"\n     say \"   Error allocating report file\" oufl  rcalloc\n     say \"   Abnormal end  \"\n     say \"**********************************************\"\n     Exit 8\nend\n\n\"ALLOC FI(OUFL2) DA(\"oufl2\") NEW CATALOG REUSE\" ,\n\"LRECL(500) RECFM(V B) TRACKS SPACE(50,50)\"\nrcalloc = rc\nif rcalloc <> 0 then Do\n     say \"**********************************************\"\n     say \"   Error allocating report file\" oufl2 rcalloc\n     say \"   Abnormal end  \"\n     say \"**********************************************\"\n     Exit 8\nend\n\n\"ALLOC FI(OUFL5) DA(\"oufl5\") NEW CATALOG REUSE\" ,\n\"LRECL(100) RECFM(V B) TRACKS SPACE(50,50)\"\nrcalloc = rc\nif rcalloc <> 0 then Do\n     say \"**********************************************\"\n     say \"   Error allocating report file\" oufl5 rcalloc\n     say \"   Abnormal end  \"\n     say \"**********************************************\"\n     Exit 8\nend\n\n\"ALLOC FI(OUFL3) DA(\"oufl3\") NEW CATALOG REUSE\" ,\n\"LRECL(200) RECFM(V B) TRACKS SPACE(10,10)\"\nrcalloc = rc\nif rcalloc <> 0 then Do\n     say \"**********************************************\"\n     say \"   Error allocating report file\" oufl3 rcalloc\n     say \"   Abnormal end  \"\n     say \"**********************************************\"\n     Exit 8\nend\n\nif BPSim = 'Y' then\ndo\n    \"ALLOC FI(OUFL4) DA(\"oufl4\") NEW CATALOG REUSE\" ,\n    \"LRECL(200) RECFM(V B) TRACKS SPACE(90,15)\"\n    rcalloc = rc\n    if rcalloc <> 0 then Do\n         say \"**********************************************\"\n         say \"   Error allocating report file\" oufl3 rcalloc\n         say \"   Abnormal end  \"\n         say \"**********************************************\"\n         Exit 8\n    end\nend\n/* init compteurs divers */\ncall init_var\n/* WRITE report header */\nCALL write_header\n\n/* START PROCESSING */\nDO FOREVER\n  /* read SMF record one by one   */\n  \"EXECIO 1 DISKR INP\"\n  IF RC > 0 THEN DO\n            if rc =  2 then\n             do\n              SAY 'End of input SMF file rc=' RC\n              rcalloc = rc\n             end\n             else do\n              SAY 'Error while reading SMF file rc=' RC\n              rcalloc = 8\n             end\n              leave\n            END\n  PARSE PULL INPUT_REC\n  reci=reci+1\n  OFFSET = 1\n  /* Decode SMF header */\n  CALL DSNDQWST\n  /* process only smf100 */\n  IF (SM100RTY = 100  & SM100SSI = SSID  ) THEN\n  DO\n    /* record SMF records period   */\n    if min_time > run_fmt_time then min_time=run_fmt_time\n    if max_time < run_fmt_time then max_time=run_fmt_time\n    if min_date > sm100dte     then min_date=sm100dte\n    if max_date < sm100dte     then max_date=sm100dte\n\n    /*sauvegarde offset_self car on le reutilise */\n    offset_selfdef= offset\n    /* on va sur le self def. section pour aller vers prod section*/\n    offset = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset - 4 + 1\n    /* traitement product section*/\n    CALL DSNDQWHS\n    offset=offset_selfdef\n    /* ifcid 1 must start the stats group */\n    if   ifcid =  1 then\n    do\n          ifcid1_seen = 1\n    end\n    else if   ifcid <> 1 & ifcid1_seen = 0 then\n                     do\n                        iterate\n                        say 'Bypass' ifcid\n                        say 'Ifcid 1 must start the group'\n                     end\n    recs=recs+1\n\n    Select\n         When ifcid     = 1  Then do\n                                      CALL DSNDQWS0\n                                      OFFSET = QWS00PSO - 4 + 1\n                                  end\n         When ifcid     = 2  Then do\n                                      CALL DSNDQWS1\n                                      OFFSET = QWS10PSO - 4 + 1\n                                  end\n     /*  When ifcid     = 199 Then do\n                                      CALL QW0199\n                                      OFFSET = QWS10PSO - 4 + 1\n                                  end  */\n         When ifcid     = 225 Then do\n                                      CALL QW0225\n                                      OFFSET = QWS10PSO - 4 + 1\n                                  end\n         Otherwise      do\n                  /* add line here to avoid excessive displays */\n                          if  ifcid = 202 then nop\n                          else\n                              if  ifcid = 230 then nop\n                          else\n                              say 'ifcid ' ifcid ' not processed'\n                        end\n    end   /* select */\n\n    /*write report quand on a fait le tour des ifcids */\n    if ifcid = 1 & recs > 1 then\n       do\n          call ifcid_diff\n          Call write_report\n       end\n    else\n    do\n         if ifcid = 1 & recs = 1 then\n         do\n              Old_Mstrtcb =       Mstrtcb\n              Old_MstrSrb =       MstrSrb\n              Old_MstrpSRB=       MstrpSRB\n              Old_MstrpSRB_ziip = MstrpSRB_ziip\n              Old_dbm1Tcb =       dbm1Tcb\n              Old_dbm1srb =       dbm1srb\n              Old_dbm1pSRB=       dbm1pSRB\n              Old_dbm1pSRB_ziip = dbm1pSRB_ziip\n              Old_irlmTcb =       irlmTcb\n              Old_irlmsrb =       irlmsrb\n              Old_irlmpSRB=       irlmpSRB\n              Old_irlmpSRB_ziip = irlmpSRB_ziip\n              Old_distTcb =       distTcb\n              Old_distsrb =       distsrb\n              Old_distpSRB=       distpSRB\n              Old_distpSRB_ziip = distpSRB_ziip\n         end\n    end\n  END /*    IF SM101RTY = 101  */\nEND\n\n/* close file */\naddress TSO \"EXECIO 0 DISKW OUFL (FINIS\"\nrcwrite = rc\nif rcwrite<> 0 then Do\n   say \"**********************************************\"\n   say \"   Error writting OUFL file: \" rcwrite\n   say \"   Abnormal end   \"\n   say \"**********************************************\"\n   Exit 8\nend\n\"EXECIO 0 DISKR INP (FINIS\"\n\"FREE DD(INP)\"\n\"FREE DD(OUFL)\"\n\nsay \"Input records =\" reci\nsay \"Output records=\" reco\nsay 'SMF period : ' min_date \"/\" max_date min_time \"/\" max_time\n\n/*-------------------------------------------------*/\n/* F20 End of program display counters and figures */\n/*-------------------------------------------------*/\ncall DisplayVStor\n\nEXIT retcode\n\n/*---------------------------------------*/\n/* End of program body- Routines section */\n/*---------------------------------------*/\n\n/* MAP SELF-DEFINING SECT IFCID 001 LG = 112 */\nDSNDQWS0:\n  /*  OFFSET TO THE PRODUCT SECTION */\n  QWS00PSO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 4\n  QWS00PSL = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  QWS00PSN = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  /*  Following sections are provided by DSNDQWST (Stats header) */\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSA CPU TIME */\n  QWS00R1O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 4\n  QWS00R1L =  C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  QWS00R1N =  C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  save_offset = offset\n  /* controle de coherence */\n  if  QWS00R1N  > 4 then\n      do\n           say 'QWS00R1N is not equal to 4, abnormal end ' QWS00R1N\n           exit 8\n      end\n  /* Load offset to DSNDQWSA section - decode db2 stc cpu section */\n  OFFSET= QWS00R1O - 4 + 1\n  i=0\n  /* init DIST pas toujours pr!sent */\n  DISTTcb      = 0\n  DISTSrb      = 0\n  DISTpSRB     = 0\n  DISTpSRB_Ziip= 0\n  do until i= QWS00R1N\n         i = i+ 1\n         call DSNDQWSA\n  end\n\n  /*restore offset */\n  offset = save_offset\n\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSB STATS COUNTERS*/\n  /*  INSTRUMENTATION STATISTICS DATA ABOUT OUTPUT DESTINATION */\n  QWS00R2O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSC */\n  /*  IFCIDS RECORDED TO STATISTICS */\n  QWS00R3O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ3ST */\n  /*  Subsytem services fields */\n  /*  SIGNON, IDEN, COMMITS, ABORTS ...*/\n  QWS00R4O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  save_offset = offset\n  offset = QWS00R4O - 4 + 1\n  call DSNDQ3ST\n  offset = save_offset\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ9ST */\n  QWS00R5O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSD */\n  /*  CHECKPOINT INFO, IFI COUNT    ...*/\n  QWS00R6O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  save_offset = offset\n  offset = QWS00R6O - 4 + 1\n  call DSNDQWSD\n  offset = save_offset\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVLS */\n  /*  LATCH COUNTS                  ...*/\n  QWS00R7O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVAS */\n  /*  ASMC STATS NBRE DE SUSPENSIONS ..*/\n  QWS00R8O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQSST */\n  /*  STORAGE MANAGER */\n  QWS00R9O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  save_offset = offset\n  offset = QWS00R9O - 4 + 1\n  call DSNDQSST\n  offset = save_offset\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLST */\n  /*  DDF STATS BY LOCATION */\n  QWS00RAO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQJST */\n  /*  LOG MANAGER           */\n  QWS00RBO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  save_offset = offset\n  offset = QWS00RBO - 4 + 1\n  call DSNDQJST\n  offset = save_offset\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQDST */\n  /*  DBAT STATS            */\n  QWS00RCO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  save_offset = offset\n  offset = QWS00RCO - 4 + 1\n  call DSNDQDST\n  offset = save_offset\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWOS */\n  /*  ZOS STATS             */\n  QWS00RDO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  if  QWS00RDO > 0 then\n  do\n    offset = QWS00RDO - 4 + 1\n    call DSNDQWOS\n    offset = save_offset\n  end\n  else do\n           QWOSLPRU=0\n           QWOSDB2U=0\n           QWOSLPIR=0\n           QWOSDPIR=0\n           QWOSLRST=0\n           QWOSLRSF=0\n           QWOSDRSU=0\n           QWOSLUIC=0\n\n  end\n  /* LG = 112 = 14 SECTIONS * 8 */\n\n  Return\n\n/* This IFCID 199 seems not to be available with SMF\nQW0199:\n   numeric digits 15\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* offset_d = offset de la 1ere data section */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       /* offset_d pointe sur la data section QW0199HE */\n       if offset_d > 0 then say 'qw0199 offset1 present'\n       /*dans tous les cas on va en data section 2 */\n       offset=offset+8\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       /* -------------- */\n       /* data section 2 */\n       /* -------------- */\n       /* dbid */\n       QW0199DB= C2D(SUBSTR(INPUT_REC,offset_d,2))\n       say 'dbid ' QW0199DB\n       offset_d=offset_d+2\n       /* obid */\n       QW0199OB= C2D(SUBSTR(INPUT_REC,offset_d,2))\n       say 'obid' QW0199OB\n       offset_d=offset_d+2\n       /* dsnum*/\n       QW0199DN= C2D(SUBSTR(INPUT_REC,offset_d,2))\n       say 'dsn' QW0199DN\n       offset_d=offset_d+2\n       /* bpid */\n       QW0199BP= X2D(SUBSTR(INPUT_REC,offset_d,1))\n       say 'bpid' QW0199BP\n       offset_d=offset_d+1\n       /* Flags */\n       QW0199DS= x2c(SUBSTR(INPUT_REC,offset_d,1))\n       offset_d=offset_d+1\n       say 'QW0199DS' QW0199DS\n     /*QW0199SV\n       QW0199SX  */\n       offset_d=offset_d+8\n       /* Total I/O Synchronous*/\n       QW0199SP = C2D(SUBSTR(INPUT_REC,offset_d,4))\n       say 'nb IO sync' QW0199SP\n       offset_d=offset_d+4\n     /*QW0199AD\n       QW0199AX  */\n       offset_d=offset_d+8\n       /* Total I/O Pages ASynchronous*/\n       QW0199AP = C2D(SUBSTR(INPUT_REC,offset_d,4))\n       say 'total io pages' QW0199AP\n       offset_d=offset_d+4\n       /* Total I/O Count*/\n       QW0199AC = C2D(SUBSTR(INPUT_REC,offset_d,4))\n       say 'total io count' QW0199AC\n       offset_d=offset_d+4\n       /* Current pages count in this BP*/\n       QW0199VP = C2D(SUBSTR(INPUT_REC,offset_d,4))\n       say 'current pages ' QW0199VP\n       offset_d=offset_d+4\n       /* Current changed pages count in this BP*/\n       QW0199VD = C2D(SUBSTR(INPUT_REC,offset_d,4))\n       say 'current changed pages ' QW0199VD\n       offset_d=offset_d+8\n       /* Current number of getpages */\n       QW0199GP = C2D(SUBSTR(INPUT_REC,offset_d,4))\n       say 'current get pages ' QW0199GP\n       offset_d=offset_d+4\n\n   return\n*/\nQW0225:\nnumeric digits 15\n       offset_save=offset /* sauvergarde offset debut data section*/\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* offset_d = offset de la data section */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n\n       /* -------------- */\n       /* data section 1 */\n       /* -------------- */\n       /* Data section 1 = 2 parts, DBM1 and DIST */\n\n       /* offset to dbm1 */\n       offset_d=offset_d -4+1\n       offset=offset+4\n\n    /* say 'offs sect1'  offset_d */\n       /* len of data section 1 : it will be repeated :*/\n       /* One for DBM1 and one for DIST */\n       len=      C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset=offset+2\n       rep=      C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset=offset+2\n    /* say 'len' len\n       say 'rep' rep */\n\n       /* offset to DIST */\n       offset_d2=offset_d+len\n\n    /* say 'offs sect2'  offset_d2 */\n\n       QW0225AN =(SUBSTR(INPUT_REC,OFFSET_d,4))\n       if  QW0225AN <> 'DBM1' then\n       do\n           say 'W0225 - Mapping error'\n           exit 8\n       end\n    /***********************************/\n    /* Processing DBM1 storage section */\n    /***********************************/\n       if  QW0225AN =  'DBM1' & vsm ='Y'  then\n       do\n           offset_d=offset_d+4\n           /* extended region size */\n           QW0225RG = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4+4+4\n           QW0225EL = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4\n           QW0225EH = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4 +4+4\n           /* storage reserved fo must complete */\n           /* before V10 depends on CTHREAD and MAXDBAT zparm*/\n           QW0225CR = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4\n           /* storage reserved for open/close datasets */\n           /* depends on DSMAX value */\n           QW0225MV = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4\n           QW0225SO = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4\n           QW0225GS = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4+4\n           QW0225VR = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4\n           QW0225FX = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4\n           QW0225GM = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4\n           /* 31 bit storage available */\n           QW0225AV = C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n           offset_d=offset_d+4+4+8+8+8+8\n           QW0225RL_dbm1 = C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           /* 225RL = Real stor. frame used by the Address Space*/\n           /*    this includes bufferpools storage qw0225bb */\n           offset_d=offset_d+8\n           QW0225AX_dbm1 = C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           offset_d=offset_d+8\n           /* QW0225HVPagesInReal 64 bits private Real */\n           QW0225HVPagesInReal =  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           offset_d=offset_d+8\n           /* QW0225HVAuxSlots    64 bits private Aux */\n           QW0225HVAuxSlots =  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           offset_d=offset_d+24\n      /*   /* QW0225HWM           64 bits private Real*/\n           QW0225HVGPagesInReal =  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           offset_d=offset_d+8\n           /* QW0225HWM           64 bits private Aux */\n           QW0225HVGAuxSlots=  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           offset_d=offset_d+8 */\n           /* QW0225PagesInReal 64 bits private Real without BP */\n           QW0225PriStg_Real=  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           offset_d=offset_d+8\n           /* QW0225PagesInAux  64 bits private Aux  without BP */\n           QW0225PriStg_Aux=  C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n           offset_d=offset_d+8\n           TotalRealUsedBP = QW0225HVPagesInReal - QW0225PriStg_Real\n           TotalAuxUsedBP = QW0225HVAuxSlots    - QW0225PriStg_Aux\n       end  /* if  QW0225AN =  'DBM1' & vsm = 'Y' then */\n\n       /* rep = 2 : there is 2 parts , DBM1 and DDF */\n       if rep = 2 then\n       do\n          /* partie DIST */\n          QW0225AN =(SUBSTR(INPUT_REC,OFFSET_d2,4))\n          if  QW0225AN <> 'DIST'  then\n          do\n              say 'W0225 - Mapping error DIST not found'\n              say 'input_rec' input_rec\n              say 'offset'   offset_d2\n              exit 8\n          end\n          if  QW0225AN =  'DIST' & vsm='Y' then\n          do\n              offset_d2=offset_d2+4\n              offset_d2=offset_d2+4+4+4\n              offset_d2=offset_d2+4\n              offset_d2=offset_d2+4 +4+4\n              offset_d2=offset_d2+4\n              offset_d2=offset_d2+4\n              offset_d2=offset_d2+4\n              offset_d2=offset_d2+4+4\n              offset_d2=offset_d2+4\n              offset_d2=offset_d2+4\n              offset_d2=offset_d2+4+4+4+8+8+8+8\n              QW0225RL_dist = C2D(SUBSTR(INPUT_REC,offset_d2,8))\n              offset_d2=offset_d2+8\n              QW0225AX_dist = C2D(SUBSTR(INPUT_REC,offset_d2,8))\n          end  /* if  QW0225AN =  'DIST' & vsm = 'Y' then */\n       end\n       else /*if rep = 2 then*/\n       do\n              QW0225RL_dist = 0\n              QW0225AX_dist = 0\n       end\n\n       /*pointer to data section 2*/\n\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n\n\n       QW0225AT =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n       offset_d=offset_d+4 /*pointer on data section 2*/\n       QW0225DB =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n\n       if (QW0225AT + qw0225DB) < MinThdSee then\n          do\n              MinThdSee = QW0225AT + qw0225DB\n              MinThdSeeTime= run_fmt_time\n              MinThdSeeDate= sm100dte\n          end\n       if (QW0225AT + qw0225DB) > MaxThdSee then\n          do\n              MaxThdSee = QW0225AT + qw0225DB\n              MaxThdSeeTime= run_fmt_time\n              MaxThdSeeDate= sm100dte\n          end\n       /* say 'threads allied=' QW0225AT\n          say 'threads dbat=' QW0225DB      */\n\n       /*pointer to data section 3 : Shared and Common Storage */\n       offset=offset+8 /* go to next pointer*/\n       if vsm = 'Y' then\n       do\n          /* load address of section 3*/\n          offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n          offset_d=offset_d -4+1\n\n          offset_d=offset_d +136\n          QW0225SHRINREAL  =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n          offset_d=offset_d + 32\n          QW0225ShrStg_Real=C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n          offset_d=offset_d + 8\n          QW0225ShrStg_Aux =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n          offset_d=offset_d + 8\n          QW0225ShrStkStg_Real=C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n          offset_d=offset_d + 8\n          QW0225ShrStkStg_Aux =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n          offset_d=offset_d + 8\n          QW0225ComStg_Real=C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n          offset_d=offset_d + 8\n          QW0225ComStg_Aux =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n\n         /* formula from    Redbook V11 Monitoring */\n         /* table 13-1 13-2                        */\n         /* Calculation to be updated when V11 + Log Mgr control */\n         /* in Real, Log. write buffers  */\n          TotalRealUsedByDB2 = qw0225rl_dbm1+ qw0225rl_dist +,\n                 QW0225ShrStg_Real + QW0225ShrStkStg_Real +,\n                 QW0225ComStg_Real\n\n      /*  TotalRealUsedByLPAR meaning not clear - value does not  */\n      /*     corresponds with others z/OS monitoring tool         */\n      /*  TotalRealUsedByLPAR= qw0225rl_dbm1+ qw0225rl_dist +,    */\n      /*       QW0225ComStg_Real + -- in redbook but no where else*/\n      /*                           QW0225SHRINREAL                */\n          /* QW0225ComStg_Real Real in use 64 bit shared */\n          /* QW0225SHRINREAL   Real in use 64 bit common */\n\n      /*  if MaxRealLPAR  <  TotalRealUsedByLPAR then */\n      /*       do                                     */\n      /*           MaxRealLPAR = TotalRealUsedByLPAR  */\n      /*           time_MaxRealLPAR = run_fmt_time    */\n      /*       end                                    */\n\n          offset_d=offset_d + 32\n      /*  QW0225_WARN      =C2D(SUBSTR(INPUT_REC,OFFSET_d,4)) */\n          offset_d=offset_d + 8\n          QW0225_REALAVAIL =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n\n          if MinQW0225_REALAVAIL > QW0225_REALAVAIL then\n               do\n                   MinQW0225_REALAVAIL = QW0225_REALAVAIL\n                   time_MinQW0225_REALAVAIL = run_fmt_time\n                   date_MinQW0225_REALAVAIL = sm100dte\n               end\n       end\n\n       /*-------------------------*/\n       /*pointer to data section 4*/\n       /*-------------------------*/\n       offset=offset+8\n\n       /*-------------------------------------------------*/\n       /*pointer to data section 5 : Pool storage details */\n       /*-------------------------------------------------*/\n       offset=offset+8\n       if  vsm = 'Y' then\n       do\n         offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n         offset_d= offset_d+4\n       /* QW0225AS Total system agent storage 31 bits*/\n         QW0225AS =C2D(SUBSTR(INPUT_REC,OFFSET_d,4))\n       /* QW0225BB Total buffer manager storage blocks */\n\n       /*-------------------------------*/\n       /* Calculate max threads allowed */\n       /*-------------------------------*/\n\n         /*Ici on a eu tous les infos on peut donc calculer le */\n         /* nombre de threads max theoriques*/\n         /* Source : IBM formula  */\n         /* (Redbook V11 subsystem monitoring Chap. Virtual Stor*/\n         /* Min and Max is used in a very defensive way */\n         /* The excel proposed with MEMU deoesn't use min max */\n         /* I also caculate this value (thdcomp2) */\n\n         /*    Thread footprint calculation : */\n\n         /* Basic Storage Cushion */\n         BC = QW0225CR + QW0225MV + QW0225SO\n         /* Non DB2 storage, retains max value for final calculation*/\n         ND = QW0225EH-QW0225GM-QW0225GS-QW0225FX-QW0225VR\n         if ND > MaxND then MaxND=ND\n         /* Max Allowable storage */\n         AS = QW0225RG-BC-MaxND\n         AS2= QW0225RG-BC-ND\n         if AS < MinAS then MinAS=AS\n         /* Max Allowable storage for thread use*/\n         TS = MinAS-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)\n         TS2= AS2-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)\n         if TS < MinTS then MinTS=TS\n         /* Average thread footprint */\n         if (QW0225AT + qdstcnat) = 0 then\n            /* if threads in system = 0 then 1 */\n            TF =  QW0225VR- QW0225AS + QW0225GS\n         else\n            TF = (QW0225VR-QW0225AS+QW0225GS)/(QW0225AT+qdstcnat)\n\n         if TF > MaxTF then MaxTF=TF\n         /* Max threads supported    */\n         ThdComp=MinTS/MaxTF\n         ThdComp2=TS2/TF\n         StorBefContract=qw0225AV-(qw0225cr+qw0225SO+qw0225MV)\n         /* Storage contraction ?*/\n         if qw0225AV <  qw0225cr then\n                do\n                    say ' Storage critical condition',\n                        '\u00e0 ' run_fmt_time\n                end\n         else do\n              if qw0225AV <  (qw0225cr+ qw0225SO+qw0225MV) then\n                do\n                    say ' Full system contraction should happen',\n                        '\u00e0 ' run_fmt_time\n                end\n         end /* else */\n\n         if ThdComp < MinThdComp then do\n                                     MinThdComp =ThdComp\n                                     MinThdCompTime=run_fmt_time\n                                     MinThdCompDate=sm100dte\n                                   end\n         if ThdComp2 < MinThdComp2 then do\n                                     MinThdComp2 =ThdComp2\n                                     MinThdComp2Time=run_fmt_time\n                                     MinThdComp2Date=sm100dte\n                                   end\n         if ThdComp > MaxThdComp then do\n                                     MaxThdComp =ThdComp\n                                     MaxThdCompTime =run_fmt_time\n                                     MaxThdCompDate =sm100dte\n                                   end\n         if ThdComp2 > MaxThdComp2 then do\n                                     MaxThdComp2 =ThdComp2\n                                     MaxThdComp2Time =run_fmt_time\n                                     MaxThdComp2Date =sm100dte\n                                   end\n\n         Real4K_dbm1=(QW0225RL_dbm1 *4096)/ 1048576    /*1MB*/\n         Real4K_dist=(QW0225RL_dist *4096)/ 1048576    /*1MB*/\n\n         If MinReal4K_dbm1 > Real4K_dbm1 then\n                          do\n                             MinReal4K_dbm1=Real4K_dbm1\n                             time_MinReal4K_dbm1=run_fmt_time\n                             Date_MinReal4K_dbm1=sm100dte\n                          end\n         If MaxReal4K_dbm1 < Real4K_dbm1 then\n                          do\n                             MaxReal4K_dbm1=Real4K_dbm1\n                             time_MaxReal4K_dbm1=run_fmt_time\n                             Date_MaxReal4K_dbm1=sm100dte\n                          end\n         If MinReal4K_dist > Real4K_dist then\n                          do\n                             MinReal4K_dist=Real4K_dist\n                             time_MinReal4K_dist=run_fmt_time\n                             Date_MinReal4K_dist=sm100dte\n                          end\n         If MaxReal4K_dist < Real4K_dist then\n                          do\n                             MaxReal4K_dist=Real4K_dist\n                             time_MaxReal4K_dist=run_fmt_time\n                             Date_MaxReal4K_dist=sm100dte\n                          end\n         /* calculation to be updated when V11 + Log Mgr control */\n         /* in aux - check IBM excel provided with memu */\n         TotalAuxlUsedByDB2 = qw0225ax_dbm1+ qw0225ax_dist +,\n               QW0225ComStg_Aux  + QW0225ShrStg_Aux  +  ,\n                                   QW0225ShrStkStg_Aux\n         If MaxDB2AuxUse < TotalAuxlUsedByDB2 then\n                          do\n                             MaxDB2AuxUse=TotalAuxlUsedByDB2\n                             timeMaxDB2AuxUse=run_fmt_time\n                             DateMaxDB2AuxUse=sm100dte\n                          end\n       end /* if vsm ... */\nreturn\n/* MAP SELF-DEFINING SECT IFCID 002 LG = 12X8 = 96 */\nDSNDQWS1:\n  /*  OFFSET TO THE PRODUCT SECTION */\n  QWS10PSO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  offset= offset + 8\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQXST */\n  /*  RDS stats block  */\n  QWS10R1O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  if  QWS10R1O > 0 then\n  do\n    save_offset = offset\n    offset = QWS10R1O - 4 + 1\n    call DSNDQXST\n    offset = save_offset\n  end\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTST */\n  /*  Binds counts, Plans allocated succ ... */\n  QWS10R2O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  offset = OFFSET + 8\n  if QWS10R2O > 0 then\n  do\n     save_offset = OFFSET\n     offset = QWS10R2O - 4 + 1\n     call DSNDQTST\n     offset = save_offset\n  end\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBST */\n  /*  Buffer manager stats                          */\n  QWS10R3O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 4\n  QWS10r3L = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  QWS10r3N = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  /* decode dsndqbst to have  buffer stats */\n  if  QWS10R3O > 0 then\n  do\n      save_offset= offset\n      offset=QWS10R3O - 4 + 1\n      call init_sum_bpstats\n      /*add code here if need figures by bufferpool ID */\n      m=0\n      do until m= QWS10r3N\n             m = m+ 1\n             call dsndqbst\n      end\n      call comp_sum_bpstats\n      /* Just read => Old bpstats */\n      call switch_bpstats\n      offset=save_offset\n  end\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQIST */\n  /*  Data   manager stats                          */\n  QWS10R4O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  offset = OFFSET + 8\n  if QWS10R4O > 0 then\n  do\n     save_offset = OFFSET\n     offset = QWS10R4O - 4 + 1\n     call DSNDQIST\n     offset = save_offset\n  end\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTXA */\n  /*  Lock   manager stats                          */\n  QWS10R5O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  offset = OFFSET + 8\n  if QWS10R5O > 0 then\n  do\n     save_offset = OFFSET\n     offset = QWS10R5O - 4 + 1\n     call DSNDQTXA\n     offset = save_offset\n  end\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISE */\n  /*  EDM Pool stats                                */\n  QWS10R6O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 4\n  QWS10R6L = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  QWS10R6N = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  if QWS10R6O > 0 then\n  do\n     save_offset = OFFSET\n     offset = QWS10R6O - 4 + 1\n     call DSNDQISE\n     offset = save_offset\n  end\n  /*  Stop here if not BP Simul. */\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBGL */\n  /*  Group BufferPool stats                        */\n  QWS10R7O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 6\n  QWS10R7N = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  if  QWS10R7O > 0 then\n  do\n       save_offset = offset\n       offset = QWS10R7O - 4 + 1\n       call init_gbpstats\n       m=0\n       do until m= QWS10r7N\n           m = m+ 1\n           call DSNDQBGL\n       end /* do until */\n       call comp_diff_gbpstats\n       call switch_gbpstats\n       offset = save_offset\n  end  /* QWS10R7O > 0  */\n  /*  Others sections ...                           */\n  /*  Jump to BP Simulated data */\n  offset = offset + 32\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTGS */\n  /*  Global Locking                                */\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLES */\n  /*  Language Envt Stats                           */\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISJ */\n  /*  Start Join    Stats                           */\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ8ST */\n  /*  Accelerator Services Stats                    */\n  /*  */\n  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBSP */\n  /*  Simulated Buffer Pool Stats                   */\n  if BPSim = 'N' then return /* haha */\n  QWS10RCO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  offset = offset + 4\n  QWS10RCL = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  offset = offset + 2\n  QWS10RCN = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  offset = offset + 2\n  /* continuation flag from DSNDQBSP data */\n  if  QWS10RCO > 0 then\n  do\n      save_offset= offset\n      offset=QWS10RCO - 4 + 1\n /*  say SUBSTR(INPUT_REC,OFFSET,104)\n  say SUBSTR(INPUT_REC,OFFSET+104,104) */\n      m=0\n      do until m= QWS10RCN\n             m = m+ 1\n             call DSNDQBSP\n      end\n      offset=save_offset\n  end\n  else\n  do\n      Simbp_entry.0=0\n  end\n  /*************************************/\n  /* End of IFCID002 (for this moment) */\n  /*************************************/\n  return\n\n\n/* MAP STANDARD HEADER PRODUCT SECTION */\nDSNDQWHS:\n  OFFSET = OFFSET + 2\n  QWHSTYP = C2D(SUBSTR(INPUT_REC,OFFSET,1))\n  OFFSET = OFFSET + 2\n  /* QWHSIID DS XL2 IFCID */\n  QWHSIID = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  IFCID=QWHSIID\n  OFFSET = OFFSET + 3\n  /* release number */\n  QWHSRN = C2X(SUBSTR(INPUT_REC,OFFSET,1))\n  OFFSET = OFFSET + 5\n  /* QWHSSSID DS CL4 SUBSYSTEM NAME */\n  QWHSSSID = SUBSTR(INPUT_REC,OFFSET,4)\n  OFFSET = OFFSET + 64\n  /* TOTAL LENGTH = 76 */\n  RETURN\n\n/* STATISTICS CPU TIME MAPPING MACRO LG = 52*4*/\nDSNDQWSA:\n    numeric digits 15\n    QWSAPROC =(SUBSTR(INPUT_REC,OFFSET,4))\n    OFFSET = OFFSET + 4\n    /*CONVERT INTO HEX VALUE*/\n    QWSAEJST = C2X(SUBSTR(INPUT_REC,OFFSET,8))\n    /*ELIMINATE 1.5 BYTES */\n    QWSAEJST = X2D(SUBSTR(QWSAEJST,1,13))\n    QWSAEJST = QWSAEJST/1000000\n    OFFSET = OFFSET + 8\n\n    QWSASRBT = C2X(SUBSTR(INPUT_REC,OFFSET,8))\n    QWSASRBT = X2D(SUBSTR(QWSASRBT,1,13))\n    QWSASRBT = QWSASRBT/1000000\n    OFFSET = OFFSET + 8\n    OFFSET = OFFSET + 8    /* saut zones */\n\n    QWSAPSRB = C2X(SUBSTR(INPUT_REC,OFFSET,8))\n    QWSAPSRB = X2D(SUBSTR(QWSAPSRB,1,13))\n    QWSAPSRB = QWSAPSRB/1000000\n    OFFSET = OFFSET + 8\n\n    QWSAPSRB_zIIP = C2X(SUBSTR(INPUT_REC,OFFSET,8))\n    QWSAPSRB_ziip = X2D(SUBSTR(QWSAPSRB_zIIP,1,13))\n    QWSAPSRB_ziip = QWSAPSRB_ziip/1000000\n    OFFSET = OFFSET + 8\n    OFFSET = OFFSET + 8  /*saut */\n\n    Select\n         When qwsaproc  = 'MSTR' Then do\n                    MstrTcb      =QWSAEJST\n                    MstrSrb      =QWSAsrbt\n                    MstrpSRB     =QWSApsrb\n                    MstrpSRB_Ziip=QWSApsrb_ziip\n                 end\n         When qwsaproc  = 'DBM1' Then do\n                    DBM1Tcb      =QWSAEJST\n                    DBM1Srb      =QWSAsrbt\n                    DBM1pSRB     =QWSApsrb\n                    DBM1pSRB_Ziip=QWSApsrb_ziip\n                 end\n         When qwsaproc  = 'DIST' Then do\n                    DISTTcb      =QWSAEJST\n                    DISTSrb      =QWSAsrbt\n                    DISTpSRB     =QWSApsrb\n                    DISTpSRB_Ziip=QWSApsrb_ziip\n                 end\n         When qwsaproc  = 'IRLM' Then do\n                    IRLMTcb      =QWSAEJST\n                    IRLMSrb      =QWSAsrbt\n                    IRLMpSRB     =QWSApsrb\n                    IRLMpSRB_Ziip=QWSApsrb_ziip\n                 end\n         Otherwise      do\n                          say 'qwsaproc NOT correct' qwsaproc\n                          exit 8\n                        end\n    end   /* select */\nRETURN\n\nDSNDQISE:\n    /* EDMPOOL STATS */\n    numeric digits 15\n    /* Fields from IFCID002  : all cumulative */\n    /* calculate difference between interval */\n\n    /*\u00a3 OF REQ FOR CT SECTIONS*/\n    offset = offset + 8\n    QISECTG = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF LOAD CT SECT FROM DASD*/\n    offset = offset + 4\n    QISECTL = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF REQUESTS FOR DBD*/\n    offset = offset + 20\n    QISEDBDG = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF LOAD DBD FROM DASD*/\n    offset = offset + 4\n    QISEDBDL = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF REQ FOR PT SECTIONS*/\n    offset = offset + 4\n    QISEKTG  = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF LOAD PT SECT FROM DASD*/\n    offset = offset + 4\n    QISEKTL = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 12\n    /*\u00a3 OF Inserts  FOR DYN CACHE*/\n    QISEDSI  = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF REQUESTS FOR DYN CACHE*/\n    offset = offset +  4\n    QISEDSG  = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*NUMBER OF PAGES IN DBD POOL*/\n    offset = offset + 12\n    QISEDPGE = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF FREE PG IN DBD FREE CHAIN*/\n    offset = offset + 4\n    QISEDFRE = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF FAIL DUE TO DBD POOL FULL*/\n    offset = offset - 8\n    QISEDFAL = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF PGS IN DYN STMT POOL*/\n    offset = offset + 20\n    QISECPGE = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF FREE PG IN STMT FREE CHAIN*/\n    offset = offset + 4\n    QISECFRE = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF FAIL DUE TO STMT POOL FULL*/\n    offset = offset - 8\n    QISECFAL = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF PAGES IN SKEL EDM POOL*/\n    offset = offset + 24\n    QISEKPGE = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF FREE PG IN SKEL EDM POOL FREE CHAIN */\n    offset = offset + 4\n    QISEKFRE = C2D(SUBSTR(INPUT_REC,offset,4))\n    /*\u00a3 OF FAIL DUE TO STMT SKEL POOL FULL*/\n    offset = offset - 8\n    QISEKFAL = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 52\n    /* Total stealable SKEL pages*/\n    QISEKLRU = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* Total stealable DBD  pages*/\n    QISEDLRU = C2D(SUBSTR(INPUT_REC,offset,4))\n\nreturn\nDSNDQWSD:\n    /* Nbr of checkpoints cumulative value */\n    QWSDCKPT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n return\nDSNDQSST:\n    offset= offset+4\n    /* eye catcher */\n    eyec     = SUBSTR(INPUT_REC,OFFSET,4)\n    if ( eyec     <> 'QSST' ) then\n                  do\n                      say 'DSNDQSST eye catcher not met, error'\n                      exit(8)\n                  end\n    offset= offset+4*14\n    /* full storage contraction*/\n    QSSTCONT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    QSSTCRIT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    QSSTABND = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n return\nDSNDQTXA:\n    /* Deadlocks */\n    QTXADEA  = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 8\n    /* TimeOuts  */\n    QTXATIM  = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n return\n\nDSNDQTST:\n    /* Service Controler Stats */\n    offset= offset+4\n    /* eye catcher */\n    eyec     = SUBSTR(INPUT_REC,OFFSET,4)\n    if ( eyec     <> 'QTST' ) then\n                  do\n                      say 'DSNDQTST eye catcher not met, error'\n                      exit(8)\n                  end\n    offset= offset+72\n    /* Datasets opened (snapshot)*/\n    QTDSOPN  =  C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 48\n    /* DS closed by drain DSMAX reached */\n    QTDSDRN  =  C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* RWRO Convert */\n    QTPCCT   =  C2D(SUBSTR(INPUT_REC,OFFSET,4))\n\n return\nDSNDQ3ST:\n    /* DB2 Subsystem services fields */\n    offset= offset+4\n    /* Signon, meaningful only with CICS or IMS */\n    /* Nbr of signon for new user of an EXISTING thread*/\n    /* If Signon > CrtThread then there is Thread reuse */\n    Q3STSIGN = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* Create thread (does not include DBAT) */\n    Q3STCTHD = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* Terminate     */\n    Q3STTERM = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 8\n    /* Commit1 */\n    Q3STPREP = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* Commit2 */\n    Q3STCOMM = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* Aborts */\n    Q3STABRT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4*9\n    /* HWM   IDBACK*/\n    Q3STHWIB = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* HWM   IDFORE*/\n    Q3STHWIF = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* HWM   CTHREAD*/\n    Q3STHWCT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n return\n\nDSNDQJST:\n    offset=offset+4\n    /* eye catcher */\n    eyec     = SUBSTR(INPUT_REC,OFFSET,4)\n    if ( eyec     <> 'QJST' ) then\n                  do\n                      say 'DSNDQJST eye catcher not met, error'\n                      exit(8)\n                  end\n    offset=offset+40\n    /* active log output CI created */\n    QJSTBFFL = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 16\n    /* CI offloaded */\n    QJSTCIOF = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    return\nDSNDQDST:\n    if QWS00RCO = 0 then\n    /* No DDF information */\n      do\n          say 'There is no DDF information in this trace'\n          say ' '\n          QDSTQDBT =0\n          QDSTQCRT =0\n          QDSTQCIT =0\n          QDSTQMIT =0\n          QDSTCNAT =0\n          QDSTHWAT =0\n          QDSTHWDT =0\n          QDSTCIN2 =0\n          QDSTMIN2 =0\n          return\n      end\n    /* dbat queued */\n    QDSTQDBT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 20 /* 4x 5 */\n    /* dbat rejected condbat reached */\n    QDSTQCRT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* current inact 1 */\n    QDSTQCIT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* max     inact 1 */\n    QDSTQMIT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* curr pooled dbat : active and disconnect */\n    QDSTCNAT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* max  pooled dbat : active and disconnect */\n    QDSTHWAT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* max  dbat        : max active + inact    */\n    QDSTHWDT = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 8\n    /* cur inact 2        */\n    QDSTCIN2 = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* max inact 2        */\n    QDSTMIN2 = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    return\n\nDSNDQXST:\n    /*************************************************/\n    /*  RDS STATISTICS BLOCK  DSNDQXST               */\n    /*************************************************/\n    /* Fields from IFCID002 : cumulative */\n    /* calculate difference between interval */\n    offset=offset+4\n    /* eye catcher */\n    eyec     = SUBSTR(INPUT_REC,OFFSET,4)\n    if ( eyec     <> 'QXST' ) then\n                  do\n                      say 'offset=' offset\n                      eyec = SUBSTR(INPUT_REC,1,100)\n                      say 'eyec' eyec\n                      say 'DSNDQXST eye catcher not met, error'\n                      exit(8)\n                  end\n    offset  =  offset + 4\n    /* Selects     */\n    QXSELECT = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /* Inserts     */\n    QXINSRT  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /* Update      */\n    QXUPDTE  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /* Delete      */\n    QXDELET  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8 * 20\n    /* Fetch       */\n    QXFETCH  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8 * 14\n    /*---*/\n    /*\u00a3RID List failed No storage */\n    QXNSMIAP = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 Failed Limit exceeded */\n    QXMRMIAP = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8*31\n    /*\u00a3 Short Prepare */\n    QXSTFND  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 Full Prepare */\n    QXSTNFND  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 Implicit Prepare = FULL prepare */\n    QXSTIPRP  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 Avoided  Prepare */\n    QXSTNPRP  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 Stmt discarded - MAXKEEPD */\n    QXSTDEXP  = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8*62\n    /* (...) */\n    /*\u00a3 RID list Overflowed to Workfile No Storage */\n    QXWFRIDS = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 RID list overflowed to wKk Limit Exceeded   */\n    QXWFRIDT = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 RID list append for a hybrid join was interrupt No Storage*/\n    QXHJINCS = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\n    /*\u00a3 RID list append for a hybrid join Limit exceeded*/\n    QXHJINCT = C2D(SUBSTR(INPUT_REC,offset,8))\n    offset  =  offset + 8\nreturn\nDSNDQXST0:\n    QXSELECT = 0\n    QXINSRT  = 0\n    QXUPDTE  = 0\n    QXDELET  = 0\n    QXFETCH  = 0\n    QXNSMIAP = 0\n    QXSTFND  = 0\n    QXSTNFND = 0\n    QXSTIPRP = 0\n    QXSTNPRP = 0\n    QXSTDEXP = 0\n    QXWFRIDS = 0\n    QXWFRIDT = 0\n    QXHJINCS = 0\n    QXHJINCT = 0\n    QXMRMIAP = 0\nreturn\n\nGET_FMT_TIME:\n  RUN_HH = SM100TME % 360000\n  RUN_HH = RIGHT(RUN_HH,2,'0')\n  RUN_MIN = SM100TME % 6000 - RUN_HH*60\n  RUN_MIN = RIGHT(RUN_MIN,2,'0')\n  RUN_SEC = SM100TME % 100 - RUN_HH *3600 - RUN_MIN*60\n  RUN_SEC = RIGHT(RUN_SEC,2,'0')\n  RUN_FMT_TIME = RUN_HH||':'||RUN_MIN||':'||RUN_SEC\n  RETURN\n\n\nwrite_header:\n  say 'CSV file ' oufl     ' will be produced'\n  outrec.0= 1\n  outrec.1= ,\n        \"Lpar,ssid,date,time,Hour,MstrTCB,MstrSRB,MstrPSRB,\"||,\n         \"MstrPSRB_Ziip,Dbm1TCB,DBm1SRB,DBm1PSRB,Dbm1PSRB_Ziip,\"||,\n                       \"IrlmTCB,IrlmSRB,IrlmPSRB,IrlmPSRB_Ziip,\"||,\n                       \"DistTCB,DistSRB,DistPSRB,DistPSRB_Ziip,\"||,\n         \"Chkpt,\"||,\n         \"CrtThd,Sign,Term,Comm1,Comm2,Abort,MaxIDBACK,\"||,\n         \"MaxIDFOR,MaxCTHREAD,\"||,\n         \"DSCur,DSClose,RWROSwitch,DSOpen,\"||,\n                  \"Getpage,GpSeq,Syncio,Pgwritten,SyncWr,AsyncWr,\"||,\n                       \"PageInR,PageInW,\"||,\n                       \"SPrefIO,CastIO,DynPrfIO,LstPrfIO,BpSio,\"||,\n         \"CurInac1,MaxInac1,CurActDbat,MaxActDbat,MaxAllDbat,\"||,\n         \"CurInac2,MaxInac2,\"||,\n         \"CurAldThds,CurActDbat,ThdMaxComp,ThdMaxComp2,\"||,\n         \"TotRealUsedDB2,TotAuxUsedDB2,\"||,/* Storage data*/\n         \"TotRealUsedBP,TotAuxUsedBP,RealAvail,\"||,\n         \"ExtRegionSz,31bAvail,StorBefContrac,\"||,\n         \"FullContractions,StorCrit,NbAbndsStor,\"||,\n         \"NotOptColProc,\"||,\n      /* Workfiles block */ ,\n         \"32KbUsed4Prf,4KbUsed32Prf,MaxWfKB,\"||,\n         \"CurWfKB,Cur4KWfKB,Cur32KWfKB,\"||,\n         \"CurDMInMemWfNb,CurDMInMemWfKB,\"||,\n         \"CurSRInMemWfNb,CurSRInMemWfKB,\"||,\n         \"CurRIDsOvfWf,CurNonSRTWfNb,\"||,\n         \"NbPhysWfCrt,MaxWfUsedThdKB,\"||,\n         \"AllWfConfKB,DGTTWfConfKB,\"||,\n         \"OthWfConfKB,\"||,\n         \"CurDGTTUseKB,MaxDGTTUseKB,\"||,\n         \"CurOthUseKB,MaxOthUseKB,\"||,\n     ,/* EDM Pool block  */\n        \"MaxRIDBlocks,\"||,\n        \"ReqCT,LoadCT,ReqDBD,LoadDBD,ReqPT,LoadPT,ReqDynCach,\"||,\n         \"InsDynC,\"||,\n         \"DBDPg,DBDFree,DBDStealable,FailDBDFul,STMPoolPg,\"||,\n         \"StmtFree,\"||,\n         \"FailStmFul,SKelPg,SKelFree,SkelStealable,FailSkFul,\"||,\n    ,/* Locks           */\n         \"DdLok,TimO,\"||,\n    ,/* RID Pool block  */\n         \"Sel,Ins,Upd,Del,Fetch,\"||,\n         \"Prepare,ShortP,ImplP,AvoidP,PrepMAXKD,\"||,\n         \"RIDFailStor,RIDFailLim,RIDOvflStor,RIDOvflLim,\"||,\n         \"RIDHybFailStor,RIDHybFailLim,\"||,\n         \"RIDTrmRDS,RIDTrmDM,\"||,\n    ,/* Logging */\n         \"ActLogCI,CIOff,\"||,\n    ,/*ZOS Stats*/\n         \"CpuLpar,CpuDB2,PageInLpar,PageInDB2,RealLpar,RealFree,\"||,\n         \"RealDB2,UIC\"\n     /*  Zones below correspond to the ibm provided excel columns */\n     /*  \"Z,BE,CV,CX,CZ,CU,CW,CY,CQ,Y,BD\"  */\n\n  \"EXECIO 1 DISKW OUFL (STEM OUTREC. \"\n\n  /*------------------------------*/\n  /* Header for Buffer pool stats */\n  /*------------------------------*/\n  outrec.1= ,\n        \"Lpar,ssid,date,time,Hour,Bp,BpSize,\"||,\n                  \"Getpage,GpSeq,Syncio,PgWritten,SyncWr,AsyncWr,\"||,\n                  \"PageInR,PageInW,\"||,\n          \"SPrefIO,CastIO,DynPrfIO,LstPrfIO,BpSio,\"||,\n                  \"MinSRLU,MaxSLRU,NbSLRUFull,NbRandSLRU\"\n\n  \"EXECIO 1 DISKW OUFL2 (STEM OUTREC. \"\n\n  /*------------------------------*/\n  /* Header for GBP         stats */\n  /*------------------------------*/\n  outrec.1= ,\n        \"Lpar,ssid,date,time,Hour,GBP,\"||,\n          \"GBPGetp,XIReadRet,XIReadNoRet,XIMiss,AsyncW,SyncW\"\n\n  \"EXECIO 1 DISKW OUFL5 (STEM OUTREC. \"\n\n  /*------------------------------*/\n  /* Header for Storage     stats */\n  /*------------------------------*/\n  outrec.1= ,\n        \"Lpar,ssid,date,time,Hour,TotalRealDB2,\"||,\n           \"RealDBM1,RealDist,ShrReal,StkReal,ComReal,\" ||,\n           \"AuxDBM1,AuxDist,ShrAux,StkAux,ComAux,\" ||,\n           \"ShrRealLPAR,\" ||,\n           \"TotAuxDB2,TotRealBP,TotAuxBP,RealAvLPAR,\" ||,\n           \"ExtRegSz,StoAvDB2\"\n\n  \"EXECIO 1 DISKW OUFL3 (STEM OUTREC. \"\n\n  if BPSim = 'N' then return\n  /*--------------------------------*/\n  /* Header for BP Simulation Stats */\n  /*--------------------------------*/\n  outrec.1= ,\n        \"Lpar,ssid,date,time,Hour,BPId,\"||,\n           \"SimSize,SeqPage,SyncIOAvoided,SeqSyncIO,AsyncPgRd,\" ||,\n           \"GSyncIO,GSeqSyncIO,GAsyncPgRd,\" ||,\n           \"PgMov,TotSyncIOWaitAvoided\"\n\n  \"EXECIO 1 DISKW OUFL4 (STEM OUTREC. \"\n\n  return\n\n\nwrite_report:\n    reco= reco+ 1\n    /* bypass first record because off difference calculation */\n    if reco = 1 then return\n    /* Warning messages or not ? */\n    if Alert='Y' then call CheckForAlert\n    /*---*/\n    outrec.0= 1\n    outrec.1= sm100sid  || ',' || sm100ssi || ','  ,\n    || '\"'sm100dte'\"'   || ','   ,\n    || run_fmt_time     || ','   ,\n    || run_hh           || ','   ,\n    || dif_MstrTcb      || ','   ,\n    || dif_MstrSrb      || ','   ,\n    || dif_MstrpSRB     || ','   ,\n    || dif_MstrpSRB_ziip || ','   ,\n    || dif_dbm1Tcb      || ','   ,\n    || dif_dbm1Srb      || ','   ,\n    || dif_dbm1pSRB     || ','   ,\n    || dif_dbm1pSRB_ziip || ','   ,\n    || dif_IrlmTcb      || ','   ,\n    || dif_IrlmSrb      || ','   ,\n    || dif_IrlmpSRB     || ','   ,\n    || dif_IrlmpSRB_ziip || ','  ,\n    || dif_DistTcb      || ','   ,\n    || dif_DistSrb      || ','   ,\n    || dif_DistpSRB     || ','    ,\n    || dif_DistpSRB_ziip || ','   ,\n    || Dif_QWSDCKPT      || ','   ,     /* Checkpoints */\n    || Dif_Q3STCTHD  || ','        ,     /* Create Thd */\n    || Dif_Q3STSIGN  || ','        ,     /* Signon  */\n    || Dif_Q3STTERM  || ','        ,     /* Terminate*/\n    || Dif_Q3STPREP  || ','        ,     /* Commit phase 1 */\n    || Dif_Q3STCOMM  || ','        ,     /* Commit Ph 2*/\n    || Dif_Q3STABRT  || ','        ,     /* Aborts */\n    ||     Q3STHWIB  || ','        ,     /* Max IDBACK */\n    ||     Q3STHWIF  || ','        ,     /* Max IDFORE */\n    ||     Q3STHWCT  || ','        ,     /* Max CTHREAD */\n    || QTDSOPN       || ','        ,     /* DS Current  */\n    || Dif_QTDSDRN   || ','        ,     /* Close Drain */\n    || Dif_QTPCCT    || ','        ,     /* RWRO switch */\n    || Sum_QBSTDSO   || ','        ,     /* OPEN DS     */\n    || Sum_QBSTGET   || ','        ,\n    || Sum_QBSTSGT   || ','        ,     /* Sequential Getp */\n    || Sum_QBSTRIO   || ','        ,\n    || Sum_QBSTPWS   || ','        ,\n    || Sum_QBSTIMW   || ','        ,\n    || Sum_QBSTWIO   || ','        ,\n    || Sum_QBSTRPI   || ','        ,\n    || Sum_QBSTWPI   || ','        ,\n    || Sum_QBSTPIO   || ','        ,\n    || Sum_QBSTCIO   || ','        ,\n    || Sum_QBSTDIO   || ','        ,\n    || Sum_QBSTLIO   || ','        ,\n    || Sum_QBSTSIO   || ','        ,\n    || QDSTQCIT      || ','        ,     /* curr. inact type 1*/\n    || QDSTQMIT      || ','        ,     /* max . inact type 1*/\n    || QDSTCNAT      || ','        ,     /* curr. active dbat */\n    || QDSTHWAT      || ','        ,     /* max active dbat */\n    || QDSTHWDT      || ','        ,     /* max act & inact dbat */\n    || QDSTCIN2      || ','        ,     /* current inactive */\n    || QDSTMIN2      || ','        ,     /* hwm inactive */\n    || QW0225AT      || ','        ,     /* curr. allied threads*/\n    || QW0225DB      || ','        ,     /* curr . active dbat */\n    || format(ThdComp ,4,0)   || ',' ,\n    || format(ThdComp2,4,0)   || ',' ,\n    || f2mb(TotalRealUsedByDB2)     || ',' ,\n    || f2mb(TotalAuxlUsedByDB2)     || ',' ,\n    || f2mb(TotalRealUsedBP)        || ',' ,\n    || f2mb(TotalAuxUsedBP)         || ',' ,\n    || f2mb(QW0225_REALAVAIL)       || ',' ,\n    || b2mb(QW0225RG)               || ',' ,\n    || b2mb(QW0225AV)               || ',' ,\n    || b2mb(StorBefContract)        || ',' ,\n    ||             QSSTCONT         || ',' ,\n    ||             QSSTCRIT         || ',' ,\n    ||             QSSTABND         || ',' ,\n    ||         Dif_QISTCOLS         || ',' ,\n  /* Workfiles block */ ,\n    ||         Dif_QISTWFP1         || ',' ,\n    ||         Dif_QISTWFP2         || ',' ,\n    ||             QISTWMXU         || ',' ,\n    /* Current all workfile usage in KB : DGTT and Sort */,\n    || QISTWCTO     || ',' ,\n    /* Current 4K wrkfile storage usage in KB*/ ,\n    || QISTW4K      || ',' ,\n    /* Current 32K wrkfile storage usage in KB*/,\n    || QISTW32K     || ',' ,\n    /* Nb DM in memory   wrkfiles active currently */ ,\n    || QISTIMAC     || ',' ,\n    /* Space DM in memory active currently in KB*/ ,\n    || QISTIMSC     || ',' ,\n    /* Nb SRT in memory   wrkfiles active currently */ ,\n    || QISTSIAC     || ',' ,\n    /* Space SRT in memory active currently in KB */ ,\n    || QISTSISC     || ',' ,\n    /* Current RID blocks overflowed (stored) in wrkfiles*/ ,\n    || QISTWFRCUR   || ',' ,\n    /* Current NON Sort related workfiles active */,\n    || QISTI2AC     || ',' ,\n    /* Physical  workfiles created */,\n    || Dif_QISTI2OF || ',' ,\n    /* HWM wkfile storage used by an agent */ ,\n    || QISTAMXU     || ','  ,\n    /* Current storage configured for wkfiles*/ ,\n    || QISTWSTG     || ','  ,\n    /* Current DGTT  configured for wkfile KB*/ ,\n    || QISTDGTTSTG  || ',' ,\n    /* Current others  configured for wkfile KB*/,\n    || QISTWFSTG    || ',' ,\n    /* Current DGTT  used  KB*/,\n    || QISTDGTTCTO  || ',' ,\n    /* HWM     DGTT  used  KB*/ ,\n    || QISTDGTTMXU  || ',' ,\n    /* Current others used  KB*/ ,\n    || QISTWFCTO    || ',' ,\n    /* HWM    others used KB*/ ,\n    || QISTWFMXU    || ',' ,\n  /* EDMPOOL block */ ,\n    || QISTRHIG                     || ',' ,    /* Max RID blocks*/\n    || Dif_QISECTG                  || ',' ,    /* requests CT*/\n    || Dif_QISECTL                  || ',' ,    /* Load CT    */\n    || Dif_QISEDBDG                 || ',' ,    /* Req DBD    */\n    || Dif_QISEDBDL                 || ',' ,    /* Load DBD   */\n    || Dif_QISEKTG                  || ',' ,    /* Req PT     */\n    || Dif_QISEKTL                  || ',' ,    /* Load PT    */\n    || Dif_QISEDSG                  || ',' ,    /* Req Dyn Cache */\n    || Dif_QISEDSI                  || ',' ,    /* Ins Dyn Cache */\n    ||     QISEDPGE                 || ',' ,    /* DBDPool used pages */\n    ||     QISEDFRE                 || ',' ,    /* DBDPOOL free pages */\n    ||     QISEDLRU                 || ',' ,    /* DBDPOOL stealable  */\n    ||     QISEDFAL                 || ',' ,    /* Failed DBDPool Full*/\n    ||     QISECPGE                 || ',' ,    /* Pages STMTPool */\n    ||     QISECFRE                 || ',' , /* Pages STMTPool free */\n    ||     QISECFAL                 || ',' , /* Failed STMTool Full*/\n    ||     QISEKPGE                 || ',' , /* Pages in SkelPool */\n    ||     QISEKFRE                 || ',' , /* Free pages SKELPool*/\n    ||     QISEKLRU                 || ',' ,  /* Skel pages stealable*/\n    ||     QISEKFAL                 || ',' ,  /* Failed SkelPoolFull*/\n  /* Locks                              */,\n    ||  Dif_QTXADEA                 || ',' ,\n    ||  Dif_QTXATIM                 || ',' ,\n  /* RID LIST BLOCK RID List processing */,\n    ||  Dif_QXSELECT                || ',' ,\n    ||  Dif_QXINSRT                 || ',' ,\n    ||  Dif_QXUPDTE                 || ',' ,\n    ||  Dif_QXDELET                 || ',' ,\n    ||  Dif_QXFETCH                 || ',' ,\n    ||  Dif_QXSTNFND                || ',' , /* Full  Prepare */\n    ||  Dif_QXSTFND                 || ',' , /* Short Prepare */\n    ||  Dif_QXSTIPRP                || ',' , /* Impl  Prepare */\n    ||  Dif_QXSTNPRP                || ',' , /* Avoided Prepare */\n    ||  Dif_QXSTDEXP                || ',' , /* Prepare MAXKEEPD reach*/\n    ||  Dif_QXNSMIAP                || ',' ,  /*Failed Limit no Stor */\n    ||  Dif_QXMRMIAP                || ',' ,  /*Failed Limit exc*/\n    ||  Dif_QXWFRIDS                || ',' ,  /*Overflow no Stor. */\n    ||  Dif_QXWFRIDT                || ',' ,  /*Overflow Limit    */\n    ||  Dif_QXHJINCS                || ',' ,  /*Failed Hybrid Stor*/\n    ||  Dif_QXHJINCT                || ',' ,  /*Failed Hybrid Limit*/\n    ||         Dif_QISTRLLM         || ',' ,  /*RID end RDS limit */\n                        ,   /* = MAX(25% table size, rid storage) */\n    ||         Dif_QISTRPLM         || ',' ,  /*RID end DM limit  */\n  /* Logging */ ,\n    ||     Dif_QJSTBFFL             || ',' ,  /*Log created*/\n    ||     Dif_QJSTCIOF             || ',' ,\n    ||     QWOSLPRU                 || ',' ,  /* CPU util. LPAR */\n    ||     QWOSDB2U                 || ',' ,  /* CPU util. DB2 */\n    ||     QWOSLPIR                 || ',' ,  /* Page in rate LPAR */\n    ||     QWOSDPIR                 || ',' ,  /* Page in DB2 */\n    ||     QWOSLRST                 || ',' ,  /* Storage LPAR */\n    ||     QWOSLRSF                 || ',' ,  /* Storage Free */\n    ||     QWOSDRSU                 || ',' ,  /* Storage Used by this DB2*/\n    ||     QWOSLUIC                 || ','    /* UIC */\n  /*|| f2mb(qw0225ax_dbm1)          || ',' ,\n    || f2mb(qw0225ax_dist)          || ',' ,\n    || f2mb(QW0225ShrStg_Aux)       || ',' ,\n    || f2mb(QW0225ShrStkStg_Aux)    || ',' ,\n    || f2mb(QW0225ComStg_Aux)       || ',' ,\n    || f2mb(QW0225ShrStg_Real)      || ',' ,\n    || f2mb(QW0225ShrStkStg_Real)   || ',' ,\n    || f2mb(QW0225ComStg_Real)      || ',' ,\n    || f2mb(QW0225SHRINREAL)        || ',' ,\n    || f2mb(qw0225rl_dbm1)          || ',' ,\n    || f2mb(qw0225rl_dist)          || ','    */\n    /* active thread =  QDSTCNAT +  QW0225AT */\n  \"EXECIO 1 DISKW OUFL (STEM OUTREC. \"\n\n\n  /*************************************/\n  /* Second record for Detail Bufstats */\n  /* Loop  for each bufferpool ID      */\n  /*************************************/\n  do i = 1 to nbbp_entry.0\n        j = nbbp_entry.i\n        /* decode BPID to BP name */\n        Select\n             When j >='0'   & j <= '50'    Then bpnm = 'BP'j\n             When j >='100' & j <= '109'   Then do\n                                                  k    = j-100\n                                                  bpnm = 'BP8K'k\n                                                end\n             When j >='120' & j <= '129'   Then do\n                                                  k    = j-120\n                                                  bpnm = 'BP16K'k\n                                                end\n             When j >='80'  & j <= '89'    Then do\n                                                  k    = j-80\n                                                  bpnm = 'BP32K'k\n                                                end\n             Otherwise do\n                         say 'Buffer pool ID ??? 'j\n                         bpnm = '?'j\n                       end\n        end\n        if bpnm = 'BP32K0' then bpnm = 'BP32K'\n        outrec.1= sm100sid || ',' || sm100ssi || ','  ,\n        || '\"'sm100dte'\"'  || ','   ,\n        || run_fmt_time    || ','   ,\n        || run_hh          || ','   ,\n        || bpnm            || ','   ,\n        || BufVPL.j      || ','  ,\n        || Det_GET.j     || ','  ,\n        || Det_SGT.j     || ','  ,\n        || Det_RIO.j     || ','  ,\n        || Det_PWS.j     || ','  ,\n        || Det_IMW.j     || ','  ,\n        || Det_WIO.j     || ','  ,\n        || Det_RPI.j     || ','  ,\n        || Det_WPI.j     || ','  ,\n        || Det_PIO.j     || ','  ,\n        || Det_CIO.j     || ','  ,\n        || Det_DIO.j     || ','  ,\n        || Det_LIO.j     || ','  ,\n        || Det_SIO.j     || ','  ,\n        || BufMIN.j      || ','  ,\n        || BufMAX.j      || ','  ,\n        || Det_HST.j     || ','  ,\n        || Det_RHS.j\n        \"EXECIO 1 DISKW OUFL2 (STEM OUTREC. \"\n  end\n  /***************************************************/\n  /* Another record for Detail Group Bufferpool stats*/\n  /* Loop  for each bufferpool ID                    */\n  /***************************************************/\n  do i = 1 to nbgbp_entry.0\n        j = nbgbp_entry.i\n        /* decode BPID to BP name */\n        Select\n             When j >='0'   & j <= '50'    Then bpnm = 'GBP'j\n             When j >='100' & j <= '109'   Then do\n                                                  k    = j-100\n                                                  bpnm = 'GBP8K'k\n                                                end\n             When j >='120' & j <= '129'   Then do\n                                                  k    = j-120\n                                                  bpnm = 'GBP16K'k\n                                                end\n             When j >='80'  & j <= '89'    Then do\n                                                  k    = j-80\n                                                  bpnm = 'GBP32K'k\n                                                end\n             Otherwise do\n                         say 'Group Buffer pool ID ??? 'j\n                         bpnm = '?'j\n                       end\n        end\n        if bpnm = 'GBP32K0' then bpnm = 'GBP32K'\n        outrec.1= sm100sid || ',' || sm100ssi || ','  ,\n        || '\"'sm100dte'\"'  || ','   ,\n        || run_fmt_time    || ','   ,\n        || run_hh          || ','   ,\n        || bpnm            || ','   ,\n        || Dif_GBPGetPage.j     || ','  ,\n        || Dif_GBPXIReadRet.j     || ','  ,\n        || Dif_GBPXIReadNoRet.j   || ','  ,\n        || format(GBPXIMissRatio.j,4,2) || ','  ,\n        || Dif_QBGLAW.j   || ','  ,\n        || Dif_QBGLSW.j\n        \"EXECIO 1 DISKW OUFL5 (STEM OUTREC. \"\n  end\n\n  /**************************************/\n  /* Another record for Storage stats   */\n  /*************************************/\n        /* Buid output record */\n        outrec.1= sm100sid || ',' || sm100ssi || ','  ,\n        || '\"'sm100dte'\"'  || ','   ,\n        || run_fmt_time    || ','   ,\n        || run_hh          || ','   ,\n        || f2mb(TotalRealUsedByDB2) || ','   ,\n        || f2mb(qw0225rl_dbm1)   || ','   ,\n        || f2mb(qw0225rl_dist)   || ','   ,\n        || f2mb(qw0225ShrStg_Real)    || ','   ,\n        || f2mb(qw0225ShrStkStg_Real) || ','   ,\n        || f2mb(QW0225ComStg_Real) || ','   ,\n    || f2mb(qw0225ax_dbm1)          || ',' ,\n    || f2mb(qw0225ax_dist)          || ',' ,\n    || f2mb(QW0225ShrStg_Aux)       || ',' , /* ShAux slots used SSID */\n    || f2mb(QW0225ShrStkStg_Aux)    || ',' , /* ShStak slots SSID */\n    || f2mb(QW0225ComStg_Aux)       || ',' , /* Common Aux SSID*/\n    || f2mb(QW0225SHRINREAL)   || ',',       /* Share backed by Real*/\n    || f2mb(TotalAuxlUsedByDB2)     || ',' ,        /*for LPAR*/\n    || f2mb(TotalRealUsedBP)        || ',' ,\n    || f2mb(TotalAuxUsedBP)         || ',' ,\n    || f2mb(QW0225_REALAVAIL)       || ',' ,  /* Real Available LPAR */\n    || b2mb(QW0225RG)               || ',' ,\n    || b2mb(QW0225AV) /* How much DB2 thinks it is avail*/\n\n        \"EXECIO 1 DISKW OUFL3 (STEM OUTREC. \"\n  if BPSim  = 'Y' then\n  do\n  /*************************************/\n  /* Simulation  Bufstats              */\n  /* Loop  for each bufferpool ID      */\n  /*************************************/\n      do i = 1 to Simbp_entry.0\n            j = Simbp_entry.i\n            /* decode BPID to BP name */\n            Select\n                 When j >='0'   & j <= '50'    Then bpnm = 'BP'j\n                 When j >='100' & j <= '109'   Then do\n                                                      k    = j-100\n                                                      bpnm = 'BP8K'k\n                                                    end\n                 When j >='120' & j <= '129'   Then do\n                                                      k    = j-120\n                                                      bpnm = 'BP16K'k\n                                                    end\n                 When j >='80'  & j <= '89'    Then do\n                                                      k    = j-80\n                                                      bpnm = 'BP32K'k\n                                                    end\n                 Otherwise do\n                             say 'Buffer pool ID ??? 'j\n                             bpnm = '?'j\n                           end\n            end\n            if bpnm = 'BP32K0' then bpnm = 'BP32K'\n            /* Buid output record */\n            outrec.1= sm100sid || ',' || sm100ssi || ','  ,\n            || '\"'sm100dte'\"'  || ','   ,\n            || run_fmt_time    || ','   ,\n            || run_hh          || ','   ,\n            || bpnm            || ','   ,\n            || DifSimPage.i         || ','   ,\n            || DifSimSeqPage.i      || ','   ,\n            || DifSimSyncIO.i       || ','   ,\n            || DifSimSeqSyncIO.i    || ','   ,\n            || DifSimAsyncPage.i    || ','   ,\n            || DifSimGBPSyncIO.i    || ','   ,\n            || DifSimGBPSeqSyncIO.i || ','   ,\n            || DifSimGBPAsyncPage.i || ','   ,\n            || DifSimPageMov.i      || ','   ,\n            || DifSimWaitSyncIO.i\n            \"EXECIO 1 DISKW OUFL4 (STEM OUTREC. \"\n      end\n  end  /* If BPSim='Y' */\n\nreturn\n\n\n/* SMF HEADER */\nDSNDQWST:\n   OFFSET = OFFSET + 1\n   /* SM100RTY DS XL1 RECORD TYPE X'64' OR 100 */\n   SM100RTY = C2D(SUBSTR(INPUT_REC,OFFSET,1))\n   /* stop processing if not 100 */\n   if sm100rty <> 100 then return\n   OFFSET = OFFSET + 1\n   /* SM100TME DS XL4 TIME SMF MOVED RECORD */\n   SM100TME = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n   CALL GET_FMT_TIME\n   OFFSET = OFFSET + 4\n   field    = C2X(SUBSTR(INPUT_REC,OFFSET,4))\n     parse value field with 1 . 2 c 3 yy 5 ddd 8 .\n     if (c = 0) then\n       yyyy = '19'||yy\n     else\n       yyyy = '20'||yy\n   sm100dte    = yyyy||'.'||ddd\n   /* save date of smf records processed */\n   if reco = 0 then save_date=sm100dte\n   else do\n     if save_date <> sm100dte & displ = 0 then do\n        displ=1\n        say 'There is 2 different dates in this SMF extract'\n        say '             '  save_date sm100dte\n        say ' '\n     end\n   end\n   OFFSET = OFFSET + 4\n   sm100sid = SUBSTR(INPUT_REC,OFFSET,4)\n   OFFSET = OFFSET + 4\n   /* SM100SSI DS CL4 SUBSYSTEM ID */\n   sm100ssi = SUBSTR(INPUT_REC,OFFSET,4)\n   OFFSET = OFFSET + 10\n   /* TOTAL LENGTH = 28 */\nRETURN\nDSNDQWOS:\n    /* Nb CPU */\n    QWOSLNCP =  C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* CPU use. LPAR      */\n    QWOSLPRU = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* CPU use. DB2       */\n    QWOSDB2U = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 12\n    /* Page in rate LPAR       */\n    QWOSLPIR = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* Page in rate DB2        */\n    QWOSDPIR = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* Real Stor. LPAR         */\n    QWOSLRST = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* Real Stor. Free LPAR    */\n    QWOSLRSF = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* Real Stor. used by this DB2 */\n    QWOSDRSU = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 16\n    /* Real Stor. used by this DB2 */\n    QWOSLUIC = C2D(SUBSTR(INPUT_REC,offset,4))\n    return\n\ndsndqist:\n    numeric digits 15\n    offset  =  offset +4\n    /* Fields of these macro seems to be all cumulative */\n    /* calculate difference between interval */\n    /* check QIEYE */\n      if  SUBSTR(INPUT_REC,OFFSET,4) <> 'QIST' then\n        do\n              say 'Mapping error QIST eye catcher not found'\n              exit(8)\n        end\n\n    offset = offset + 4\n    /* RID Term RDS Limit */\n    QISTRLLM = C2D(SUBSTR(INPUT_REC,offset,4))\n    offset = offset + 4\n    /* RID Term DM  Limit */\n    QISTRPLM = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* Highest RID blocks */\n    QISTRHIG = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 16\n    /* not optimal column proc */\n    QISTCOLS = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    offset = offset + 36\n    /* 32KB Wrkfile used instead of 4KB */\n    QISTWFP1 = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    /* 4 KB Wrkfile used instead of 32 KB */\n    QISTWFP2 = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  if QWHSRN= 'A1' then /* zones not available V10 */\n  do\n     QISTWMXU=0\n     QISTWCTO=0\n     QISTW4K=0\n     QISTW32K=0\n     QISTIMAC=0\n     QISTIMSC=0\n     QISTSIAC=0\n     QISTSISC=0\n     QISTWFRCUR=0\n     QISTI2AC=0\n     QISTI2OF=0\n     QISTAMXU=0\n     QISTWSTG=0\n     QISTDGTTSTG=0\n     QISTWFSTG=0\n     QISTDGTTCTO=0\n     QISTDGTTMXU=0\n     QISTWFCTO=0\n     QISTWFMXU=0\n    return\n  end\n    offset = offset + 28\n    /* hwm storage used by workfiles in KB */\n    QISTWMXU = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current all workfile usage in KB : DGTT and Sort */\n    QISTWCTO = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current 4K wrkfile storage usage in KB*/\n    QISTW4K  = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current 32K wrkfile storage usage in KB*/\n    QISTW32K = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Nb DM in memory   wrkfiles active currently */\n    QISTIMAC = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Space DM in memory active currently in KB*/\n    QISTIMSC = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 24\n    /* Nb SRT in memory   wrkfiles active currently */\n    QISTSIAC = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Space SRT in memory active currently in bytes */\n    QISTSISC = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    QISTSISC = trunc(QISTSISC/1024) /* in KB */\n    offset = offset + 32\n    /* Current RID blocks overflowed (stored) in wrkfiles*/\n    QISTWFRCUR=  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current NON Sort related workfiles active */\n    QISTI2AC =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 16\n    /* Physical  workfiles created */\n    QISTI2OF =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 24\n    /* HWM wkfile storage used by an agent */\n    QISTAMXU =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current storage configured for wkfiles*/\n    QISTWSTG =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current DGTT  configured for wkfile KB*/\n    QISTDGTTSTG = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current DGTT  used  KB*/\n    QISTDGTTCTO = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* HWM     DGTT  used  KB*/\n    QISTDGTTMXU = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current others  configured for wkfile KB*/\n    QISTWFSTG = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Current others used  KB*/\n    QISTWFCTO = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* HWM    others used KB*/\n    QISTWFMXU = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    return\n\n/***************************/\n/* Group buffer pool stats */\n/***************************/\ndsndqbgl:\n    numeric digits 15\n    /* Group BPID */\n    QBGLGN  =  C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    QBGLFLG  =  SUBSTR(INPUT_REC,OFFSET,1)\n    offset = offset + 1 + 3\n    /* GBP Dependent Getpage */\n    QBGLGG  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Syn.Read(XI)-Data returned (A in the formula ) */\n    QBGLXD  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Syn.Read(XI)-No Data Return (B in the formula) */\n    QBGLXR  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 24\n    /* Sync Write  (from local BP to GBP) called User Write */\n    QBGLSW  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 56\n    /* ASync Write  (from local BP to GBP) called Syst Write */\n    QBGLAW  =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 40\n    /* Write requests failed no storage */\n    /* QBGLWF  =  C2D(SUBSTR(INPUT_REC,OFFSET,8)) */\n    offset = offset + 104\n    /* Write requests failed no storage secondary GBP */\n    /* QBGL2F  =  C2D(SUBSTR(INPUT_REC,OFFSET,8)) */\n    /* Write Around */\n    offset = offset + 136\n    /* Page in write around  */\n    /* QBGLWA  =  C2D(SUBSTR(INPUT_REC,OFFSET,8)) */\n    /* go to end of macro QBGL */\n    offset = offset + 32\n\n    /*****************************/\n    /* Processing the data read  */\n    /*****************************/\n\n    /* if there is a new bufferpool in the list */\n    if qws10r7n > nbgbp_entry.0 then call record_gbp\n    GBPGetPage.QBGLGN    = QBGLGG\n    GBPXIReadRet.QBGLGN    = QBGLXD\n    GBPXIReadNoRet.QBGLGN  = QBGLXR\n    QBGLAW.QBGLGN  = QBGLAW\n    QBGLSW.QBGLGN  = QBGLSW\n    say 'GBPGetpage'    QBGLGN QBGLGG\n    say 'GBPXIReadRet' QBGLGN QBGLXD\n    say 'GBPXIReadNoRet' QBGLGN QBGLXR\n    say 'QBGLAW ' QBGLGN QBGLAW\n    say 'QBGLSW ' QBGLGN QBGLSW\n\n    return\n\ndsndqbst:\n    numeric digits 15\n    QBSTPID =  C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 8\n    QBSTGET =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTRIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 40\n    QBSTPWS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTWIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 16\n    QBSTRPI =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTWPI =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Open Dataset */\n    QBSTDSO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTIMW =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 16\n    /* Pages read seq Prefetch */\n    QBSTSPP =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 56\n    /* OF SEQ PREFETCH (ASYNCHRONOUS) READ*/\n    QBSTPIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 16\n    /* nb wkfile not created due to buffers resource */\n    QBSTMAX =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 48\n    /* nb of workfiles denied during sort/merge */\n    QBSTWFD =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* nb of time sort not optimized due to BP shortage*/\n    QBSTWFF =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 40\n    /* nb of cast out IO */\n    QBSTCIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTVPL =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 24\n    QBSTDIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTLIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTSGT =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    QBSTSIO =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 112 /* 8*14*/\n    /* Min SRLU */\n    QBSTSMIN=  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Max SRLU */\n    QBSTSMAX=  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Nb times SLRU = VPSEQT */\n    QBSTHST =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Nb times Random getpage found in SRLU chain */\n    QBSTRHS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n\n    /******************************/\n    /* End of macro QBST DSNDQBST */\n    /******************************/\n\n         /* if there is a new bufferpool in the list */\n         if qws10r3n > nbbp_entry.0 then call record_bp\n         BufGet.QBSTPID = QBSTGET\n         BufRIO.QBSTPID=  QBSTRIO\n         BufPWS.QBSTPID=  QBSTPWS\n         BufWIO.QBSTPID=  QBSTWIO\n         BufRPI.QBSTPID=  QBSTRPI\n         BufWPI.QBSTPID=  QBSTWPI\n         BufIMW.QBSTPID=  QBSTIMW\n         BufDSO.QBSTPID=  QBSTDSO\n         BufPIO.QBSTPID=  QBSTPIO\n         BufCIO.QBSTPID=  QBSTCIO\n         BufVPL.QBSTPID=  QBSTVPL\n         BufDIO.QBSTPID=  QBSTDIO\n         BufLIO.QBSTPID=  QBSTLIO\n         BufSIO.QBSTPID=  QBSTSIO\n         BufSGT.QBSTPID=  QBSTSGT\n         BufMIN.QBSTPID=  QBSTSMIN\n         BufMAX.QBSTPID=  QBSTSMAX\n         BufHST.QBSTPID=  QBSTHST\n         BufRHS.QBSTPID=  QBSTRHS\n    /*        'QBSTRIO=' QBSTRIO,     */\n    /*        'QBSTWIO=' QBSTWIO,     */\n    /*        'QBSTIMW=' QBSTIMW,     */\n    /*    say 'QBSTPIO=' QBSTPIO,     */\n    /*        'QBSTCIO=' QBSTCIO,     */\n    /*        'QBSTDIO=' QBSTDIO,     */\n    /*        'QBSTLIO=' QBSTLIO,     */\n    /*        'QBSTSIO=' QBSTSIO      */\n    return\n/*--------------------*/\n/* Simulated BP stats */\n/*--------------------*/\nDSNDQBSP:\n    numeric digits 20\n    /* Bpool ID */\n    QBSPPID =  C2D(SUBSTR(INPUT_REC,OFFSET,4))\n    offset = offset + 4\n    QBSPCON = C2X(SUBSTR(INPUT_REC,OFFSET,1))\n    offset = offset + 4\n    /* Current Number of pages simulated */\n    QBSPIUS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 16\n    /* Current number of seq pages simulated */\n    QBSPSUS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 16\n    /* Random Sync read  */\n    QBSPDRR =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Seq    Sync read  */\n    QBSPDRS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Pages Async Reads */\n    QBSPDRA =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* GBP Random Sync read  */\n    QBSPGRR =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* GBP Seq Sync read  */\n    QBSPGRS =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* GBP Pages Async Reads */\n    QBSPGRA =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Pages moved into Simulated pool */\n    QBSPMVI =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 8\n    /* Total wait for sync/IO  */\n    QBSPDTM =  C2D(SUBSTR(INPUT_REC,OFFSET,8))\n    offset = offset + 16 /* Yes, there is a bug */\n\n    /* Check in simulated BP list */\n    do i = 1 to Simbp_entry.0\n              if QBSPPID = Simbp_entry.i then leave\n    end\n    /* not found => new entry */\n    if i > Simbp_entry.0 then\n           do\n               Simbp_entry.0 = Simbp_entry.0 + 1\n               j            = Simbp_entry.0\n               Simbp_entry.j = QBSPPID\n\n               SimPage.j = 0\n               SimSeqPage.j = 0\n               SimSyncIO.j = 0\n               SimSeqSyncIO.j = 0\n               SimAsyncPage.j = 0\n               SimGBPSyncIO.j = 0\n               SimGBPSeqSyncIO.j = 0\n               SimGBPAsyncPage.j = 0\n               SimPageMov.j = 0\n               SimWaitSyncIO.j = 0\n           end\n\n    /* Check in simulated BP list */\n    do i = 1 to Simbp_entry.0\n              if QBSPPID = Simbp_entry.i then leave\n    end\n    /* not found => error  */\n    if i > Simbp_entry.0 then\n           do\n               say 'Abnormal error '\n               exit 8\n           end\n    /*-----------------------------------------------*/\n    /* Difference between current and previous value */\n    /*-----------------------------------------------*/\n\n    /* Current Number of pages simulated */\n    DifSimPage.i = QBSPIUS\n    /* Current Number of seq pages simulated */\n    DifSimSeqPage.i = QBSPSUS\n    /* Random Sync read  */\n    DifSimSyncIO.i = QBSPDRR - SimSyncIO.i\n    /* Seq    Sync read  */\n    DifSimSeqSyncIO.i = QBSPDRS - SimSeqSyncIO.i\n    /* Pages Async Reads */\n    DifSimAsyncPage.i = QBSPDRA - SimAsyncPage.i\n    /* GBP Random Sync read  */\n    DifSimGBPSyncIO.i = QBSPGRR - SimGBPSyncIO.i\n    /* GBP Seq Sync read  */\n    DifSimGBPSeqSyncIO.i = QBSPGRS - SimGBPSeqSyncIO.i\n    /* GBP Pages Async Reads */\n    DifSimGBPAsyncPage.i = QBSPGRA - SimGBPAsyncPage.i\n    /* Pages moved into Simulated pool */\n    DifSimPageMov.i = QBSPMVI - SimPageMov.i\n    /* Total wait for sync/IO in ms  */\n    DifSimWaitSyncIO.i = QBSPDTM - SimWaitSyncIO.i\n\n    /*------------------------------------*/\n    /* Save the values for next iteration */\n    /* New => Previous                    */\n    /*------------------------------------*/\n    SimPage.i = QBSPIUS\n    SimSeqPage.i = QBSPSUS\n    SimSyncIO.i = QBSPDRR\n    SimSeqSyncIO.i = QBSPDRS\n    SimAsyncPage.i = QBSPDRA\n    SimGBPSyncIO.i = QBSPGRR\n    SimGBPSeqSyncIO.i = QBSPGRS\n    SimGBPAsyncPage.i = QBSPGRA\n    SimPageMov.i = QBSPMVI\n    SimWaitSyncIO.i = QBSPDTM\n\n    /******************************/\n    /* End of macro QBST DSNDQBST */\n    /******************************/\n\n    return\nifcid_diff:\n       /* Cumulative values, report only the difference */\n       /* When diff is negative, this means that the value have been*/\n       /* reset (Seen at DB2 restart , but probably also if they    */\n       /* reach their max)                                          */\n              Dif_MstrTcb =       MstrTcb       - Old_MstrTcb\n              Dif_MstrSrb =       MstrSrb       - Old_MstrSrb\n              Dif_MstrpSRB=       MstrpSRB      - Old_MstrpSRB\n              Dif_MstrpSRB_ziip = MstrpSRB_ziip - Old_MstrpSRB_ziip\n              Dif_dbm1Tcb =       dbm1Tcb       - Old_dbm1Tcb\n              Dif_dbm1srb =       dbm1srb       - Old_dbm1srb\n              Dif_dbm1pSRB=       dbm1pSRB      - Old_dbm1pSRB\n              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip - Old_dbm1pSRB_ziip\n              Dif_irlmTcb =       irlmTcb       - Old_irlmTcb\n              Dif_irlmsrb =       irlmsrb       - Old_irlmsrb\n              Dif_irlmpSRB=       irlmpSRB      - Old_irlmpSRB\n              Dif_irlmpSRB_ziip = irlmpSRB_ziip - Old_irlmpSRB_ziip\n              Dif_distTcb =       distTcb       - Old_distTcb\n              Dif_distsrb =       distsrb       - Old_distsrb\n              Dif_distpSRB=       distpSRB      - Old_distpSRB\n              Dif_distpSRB_ziip = distpSRB_ziip - Old_distpSRB_ziip\n\n        if    Dif_MstrTcb < 0 then\n        do\n              say '|||||||||||||||||||||||||||||||||||||||||||||||'\n              say 'Cumulative fields reset, possible DB2 RECYCLE'\n              say '      at' sm100dte run_fmt_time\n              say '|||||||||||||||||||||||||||||||||||||||||||||||'\n              say ''\n\n\n              Dif_MstrTcb =       MstrTcb\n              Dif_MstrSrb =       MstrSrb\n              Dif_MstrpSRB=       MstrpSRB\n              Dif_MstrpSRB_ziip = MstrpSRB_ziip\n              Dif_dbm1Tcb =       dbm1Tcb\n              Dif_dbm1srb =       dbm1srb\n              Dif_dbm1pSRB=       dbm1pSRB\n              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip\n              Dif_irlmTcb =       irlmTcb\n              Dif_irlmsrb =       irlmsrb\n              Dif_irlmpSRB=       irlmpSRB\n              Dif_irlmpSRB_ziip = irlmpSRB_ziip\n              Dif_distTcb =       distTcb\n              Dif_distsrb =       distsrb\n              Dif_distpSRB=       distpSRB\n              Dif_distpSRB_ziip = distpSRB_ziip\n\n        end\n              Old_Mstrtcb =       Mstrtcb\n              Old_MstrSrb =       MstrSrb\n              Old_MstrpSRB=       MstrpSRB\n              Old_MstrpSRB_ziip = MstrpSRB_ziip\n              Old_dbm1Tcb =       dbm1Tcb\n              Old_dbm1srb =       dbm1srb\n              Old_dbm1pSRB=       dbm1pSRB\n              Old_dbm1pSRB_ziip = dbm1pSRB_ziip\n              Old_irlmTcb =       irlmTcb\n              Old_irlmsrb =       irlmsrb\n              Old_irlmpSRB=       irlmpSRB\n              Old_irlmpSRB_ziip = irlmpSRB_ziip\n              Old_distTcb =       distTcb\n              Old_distsrb =       distsrb\n              Old_distpSRB=       distpSRB\n              Old_distpSRB_ziip = distpSRB_ziip\n\n       /*********************************/\n       /* Subsystem services stats QTDS */\n       /*********************************/\n          Dif_QTDSDRN =     QTDSDRN-Old_QTDSDRN\n          Dif_QTPCCT  =     QTPCCT -Old_QTPCCT\n          if  Dif_QTDSDRN < 0 then\n          do\n              Dif_QTDSDRN = QTDSDRN\n              Dif_QTPCCT  = QTPCCT\n          end\n          Old_QTDSDRN =   QTDSDRN\n          Old_QTPCCT  =   QTPCCT\n       /*********************************/\n       /* Subsystem services stats Q3ST */\n       /*********************************/\n              Dif_Q3STSIGN =     Q3STSIGN-Old_Q3STSIGN\n              Dif_Q3STTERM =     Q3STTERM-Old_Q3STTERM\n              Dif_Q3STCTHD =     Q3STCTHD-Old_Q3STCTHD\n              Dif_Q3STPREP =     Q3STPREP-Old_Q3STPREP\n              Dif_Q3STCOMM =     Q3STCOMM-Old_Q3STCOMM\n              Dif_Q3STABRT =     Q3STABRT-Old_Q3STABRT\n\n          if  Dif_Q3STCTHD < 0 then\n          do\n              Dif_Q3STSIGN = Q3STSIGN\n              Dif_Q3STTERM = Q3STTERM\n              Dif_Q3STCTHD = Q3STCTHD\n              Dif_Q3STPREP = Q3STPREP\n              Dif_Q3STCOMM = Q3STCOMM\n              Dif_Q3STABRT = Q3STABRT\n          end\n\n          Old_Q3STSIGN = Q3STSIGN\n          Old_Q3STTERM = Q3STTERM\n          Old_Q3STCTHD = Q3STCTHD\n          Old_Q3STPREP = Q3STPREP\n          Old_Q3STCOMM = Q3STCOMM\n          Old_Q3STABRT = Q3STABRT\n\n       /***************************/\n       /* buffer pool stats       */\n       /***************************/\n\n\n      /****************************************/\n      /* dsndqjst Log  Manager stats IFCID 001*/\n      /****************************************/\n      Dif_QJSTBFFL = QJSTBFFL - Old_QJSTBFFL\n      Dif_QJSTCIOF = QJSTCIOF - Old_QJSTCIOF\n      if  Dif_QJSTBFFL < 0 then  do\n              Dif_QJSTBFFL = QJSTBFFL\n              Dif_QJSTCIOF = QJSTCIOF\n      end\n      Old_QJSTBFFL = QJSTBFFL\n      Old_QJSTCIOF = QJSTCIOF\n\n      /****************************************/\n      /* dsndqist Data Manager stats IFCID 002 */\n      /****************************************/\n              Dif_QWSDCKPT = QWSDCKPT - Old_QWSDCKPT /*checkpoints*/\n              Dif_QTXADEA  = QTXADEA  - Old_QTXADEA\n              Dif_QTXATIM  = QTXATIM  - Old_QTXATIM\n              Dif_QXSELECT = QXSELECT - Old_QXSELECT\n              Dif_QXINSRT  = QXINSRT  - Old_QXINSRT\n              Dif_QXUPDTE  = QXUPDTE  - Old_QXUPDTE\n              Dif_QXDELET  = QXDELET  - Old_QXDELET\n              Dif_QXFETCH  = QXFETCH  - Old_QXFETCH\n              Dif_QXSTFND  = QXSTFND  - Old_QXSTFND\n              Dif_QXSTNFND = QXSTNFND - Old_QXSTNFND\n              Dif_QXSTIPRP = QXSTIPRP - Old_QXSTIPRP\n              Dif_QXSTNPRP = QXSTNPRP - Old_QXSTNPRP\n              Dif_QXSTDEXP = QXSTDEXP - Old_QXSTDEXP\n              Dif_QXNSMIAP = QXNSMIAP - Old_QXNSMIAP\n              Dif_QXMRMIAP = QXMRMIAP - Old_QXMRMIAP\n              Dif_QXWFRIDS = QXWFRIDS - Old_QXWFRIDS\n              Dif_QXWFRIDT = QXWFRIDT - Old_QXWFRIDT\n              Dif_QXHJINCS = QXHJINCS - Old_QXHJINCS\n              Dif_QXHJINCT = QXHJINCT - Old_QXHJINCT\n              Dif_QISECTG  = QISECTG  - Old_QISECTG\n              Dif_QISECTL  = QISECTL  - Old_QISECTL\n              Dif_QISEDBDG = QISEDBDG - Old_QISEDBDG\n              Dif_QISEDBDL = QISEDBDL - Old_QISEDBDL\n              Dif_QISEKTG  = QISEKTG  - Old_QISEKTG\n              Dif_QISEKTL  = QISEKTL  - Old_QISEKTL\n              Dif_QISEDSG  = QISEDSG  - Old_QISEDSG\n              Dif_QISEDSI  = QISEDSI  - Old_QISEDSI\n              Dif_QISTRLLM = QISTRLLM - Old_QISTRLLM\n              Dif_QISTRPLM = QISTRPLM - Old_QISTRPLM\n              Dif_QISTCOLS = QISTCOLS - Old_QISTCOLS\n              Dif_QISTWFP1 = QISTWFP1 - Old_QISTWFP1\n              Dif_QISTWFP2 = QISTWFP2 - Old_QISTWFP2\n              Dif_QISTI2OF = QISTI2OF - Old_QISTI2OF\n\n      if  Dif_QXSELECT <0 then\n      do\n              Dif_QISTRLLM = QISTRLLM\n              Dif_QISECTG  = QISECTG\n              Dif_QISECTL  = QISECTL\n              Dif_QISEDBDG = QISEDBDG\n              Dif_QISEDBDL = QISEDBDL\n              Dif_QISEKTG  = QISEKTG\n              Dif_QISEKTL  = QISEKTL\n              Dif_QISEDSG  = QISEDSG\n              Dif_QISEDSI  = QISEDSI\n              Dif_QWSDCKPT = QWSDCKPT\n              Dif_QTXADEA  = QTXADEA\n              Dif_QTXATIM  = QTXATIM\n              Dif_QXSELECT = QXSELECT\n              Dif_QXINSRT  = QXINSRT\n              Dif_QXUPDTE  = QXUPDTE\n              Dif_QXDELET  = QXDELET\n              Dif_QXFETCH  = QXFETCH\n              Dif_QXSTFND  = QXSTFND\n              Dif_QXSTNFND = QXSTNFND\n              Dif_QXSTIPRP = QXSTIPRP\n              Dif_QXSTNPRP = QXSTNPRP\n              Dif_QXSTDEXP = QXSTDEXP\n              Dif_QXNSMIAP = QXNSMIAP\n              Dif_QXMRMIAP = QXMRMIAP\n              Dif_QXWFRIDS = QXWFRIDS\n              Dif_QXWFRIDT = QXWFRIDT\n              Dif_QXHJINCS = QXHJINCS\n              Dif_QXHJINCT = QXHJINCT\n              Dif_QISTRPLM = QISTRPLM\n              Dif_QISTCOLS = QISTCOLS\n              Dif_QISTWFP1 = QISTWFP1\n              Dif_QISTWFP2 = QISTWFP2\n              Dif_QISTI2OF = QISTI2OF\n      end\n\n              Old_QISTRLLM = QISTRLLM\n              Old_QISECTG  = QISECTG\n              Old_QISECTL  = QISECTL\n              Old_QISEDBDG = QISEDBDG\n              Old_QISEDBDL = QISEDBDL\n              Old_QISEKTG  = QISEKTG\n              Old_QISEKTL  = QISEKTL\n              Old_QISEDSG  = QISEDSG\n              Old_QISEDSI  = QISEDSI\n              Old_QWSDCKPT = QWSDCKPT\n              Old_QTXADEA  = QTXADEA\n              Old_QTXATIM  = QTXATIM\n              Old_QXSELECT = QXSELECT\n              Old_QXINSRT  = QXINSRT\n              Old_QXUPDTE  = QXUPDTE\n              Old_QXDELET  = QXDELET\n              Old_QXFETCH  = QXFETCH\n              Old_QXSTFND  = QXSTFND\n              Old_QXSTNFND = QXSTNFND\n              Old_QXSTIPRP = QXSTIPRP\n              Old_QXSTNPRP = QXSTNPRP\n              Old_QXSTDEXP = QXSTDEXP\n              Old_QXNSMIAP = QXNSMIAP\n              Old_QXMRMIAP = QXMRMIAP\n              Old_QXWFRIDS = QXWFRIDS\n              Old_QXWFRIDT = QXWFRIDT\n              Old_QXHJINCS = QXHJINCS\n              Old_QXHJINCT = QXHJINCT\n              Old_QISTRPLM = QISTRPLM\n              Old_QISTCOLS = QISTCOLS\n              Old_QISTWFP1 = QISTWFP1\n              Old_QISTWFP2 = QISTWFP2\n              Old_QISTI2OF = QISTI2OF\n\n      return\nDisplayVStor:\n  if vsm='Y' & reco > 0 then\n  do\n    Say ' '; say ' '\n    Say 'Threads observed Max : ' MaxThdSee 'at' MaxThdSeeDate,\n                                                 MaxThdSeeTime\n    Say '                 Min : ' MinThdSee 'at' MinThdSeeDate,\n                                                 MinThdSeeTime\n    Say ' '; say ' '\n    Say 'Max Threads allowed projected with this period is : '\n    Say '    ' floor(MinThdComp) 'at' MinThdCompDate MinThdCompTime,\n        '/' floor(MaxThdComp) 'at' MaxThdCompDate MaxThdCompTime\n    Say '    Formula without Min/Max applied : '\n    Say '    ' floor(MinThdComp2) 'at' MinThdComp2Date MinThdComp2Time,\n        '/' floor(MaxThdComp2) 'at' MaxThdComp2Date MaxThdComp2Time\n    Say ' '\n    Say 'DBM1, Max Real Storage is : ' format(MaxReal4K_dbm1,5,2),\n        'MB at ' Date_MaxReal4K_dbm1 time_MaxReal4K_dbm1\n    Say '                   Min is : ' ,\n                             format(MinReal4K_dbm1,5,2) 'MB at ',\n           Date_MinReal4K_dbm1 time_MinReal4K_dbm1\n    Say 'DIST, Max Real Storage is : ' format(MaxReal4K_dist,5,2),\n        'MB at ' Date_MaxReal4K_dist time_MaxReal4K_dist\n    Say '                   Min is : ' ,\n                          format(MinReal4K_dist,5,2) 'MB at ',\n         Date_MinReal4K_dist time_MinReal4K_dist\n    Say ' '\n /* Say 'Max Real Storage used by LPAR :' MaxRealLPAR ' Frames --', */\n /*            f2mb(MaxRealLPAR)  ' in MB'                          */\n /* Say '       at ' time_MaxRealLPAR                               */\n    temp=MinQW0225_REALAVAIL*4096 / 1048576      /* in MB*/\n    Say 'Min Real Storage available for LPAR : ' MinQW0225_REALAVAIL,\n                'Frames --' f2mb(MinQW0225_REALAVAIL) ' MB'\n    Say '       at ' Date_MinQW0225_REALAVAIL time_MinQW0225_REALAVAIL\n    Say ' '\n    Say 'Max Aux Storage used by DB2  :' MaxDB2AuxUse ' Slots  --',\n           f2mb(MaxDB2AuxUse)        ' MB'\n    Say '       at ' DateMaxDB2AuxUse timeMaxDB2AuxUse\n  end\nreturn\ninit_var:\n  GBPCount   =0\n  HistCKPT.0 =0\n  HistRWRO.0 =0\n  tsayLocal=0\n\n  /* nb of buffers recorded*/\n  nbbp_entry.0=0\n  nbgbp_entry.0=0\n  /* nb of simulated buffers recorded*/\n  SimBp_Entry.0=0\n  if vsm='Y' then\n      do\n           MaxND=0\n           MinAS=999999999999999\n           MinTS=999999999999999\n           MaxTF=0\n           MaxThdSee =0\n           MaxThdComp=0\n           MaxThdComp2=0\n           MinThdSee =999999999999999\n           MinThdComp=999999999999999\n           MinThdComp2=999999999999999\n           MaxReal4K_dbm1=0\n           MinReal4K_dbm1=999999999999999\n           MaxReal4K_dist=0\n           MinReal4K_dist=999999999999999\n           MinQW0225_REALAVAIL=999999999999999\n        /* MaxRealLPAR = 0 */\n           MaxDB2AuxUse = -1\n      end\n  /* init counters */\n  Old_QTDSDRN = 0\n  Old_QTPCCT  = 0\n  Old_QBSTGET = 0\n  Old_QBSTRIO = 0\n  Old_QBSTPWS = 0\n  Old_QBSTDSO = 0\n  Old_QBSTIMW = 0\n  Old_QBSTWIO = 0\n  Old_QBSTRPI = 0\n  Old_QBSTWPI = 0\n  Old_QBSTPIO = 0\n  Old_QBSTCIO = 0\n  Old_QBSTDIO = 0\n  Old_QBSTLIO = 0\n  Old_QBSTSIO = 0\n  Old_QBSTSGT = 0\n  Old_QBSTHST = 0\n  Old_QBSTRHS = 0\n\n  Old_QJSTBFFL  = 0\n  Old_QJSTCIOF  = 0\n\n  Old_QISTRLLM  = 0\n  Old_QISECTG   = 0\n  Old_QISECTL   = 0\n  Old_QISEDBDG  = 0\n  Old_QISEDBDL  = 0\n  Old_QISEKTG   = 0\n  Old_QISEKTL   = 0\n  Old_QISEDSG   = 0\n  Old_QISEDSI   = 0\n  Old_QWSDCKPT  = 0\n  Old_QTXADEA   = 0\n  Old_QTXATIM   = 0\n  Old_QXSELECT  = 0\n  Old_QXINSRT   = 0\n  Old_QXUPDTE   = 0\n  Old_QXDELET   = 0\n  Old_QXFETCH   = 0\n  Old_QXNSMIAP  = 0\n  Old_QXSTFND   = 0\n  Old_QXSTNFND  = 0\n  Old_QXSTIPRP  = 0\n  Old_QXSTNPRP  = 0\n  Old_QXSTDEXP  = 0\n  Old_QXMRMIAP  = 0\n  Old_QXWFRIDS  = 0\n  Old_QXWFRIDT  = 0\n  Old_QXHJINCS  = 0\n  Old_QXHJINCT  = 0\n  Old_QISTRPLM  = 0\n  Old_QISTCOLS  = 0\n  Old_QISTWFP1  = 0\n  Old_QISTWFP2  = 0\n  Old_QISTI2OF  = 0\n\n  Old_Q3STSIGN = 0\n  Old_Q3STTERM = 0\n  Old_Q3STCTHD = 0\n  Old_Q3STPREP = 0\n  Old_Q3STCOMM = 0\n  Old_Q3STABRT = 0\n\n\n  Old_MstrTcb =       0\n  Old_MstrSrb =       0\n  Old_MstrpSRB=       0\n  Old_MstrpSRB_ziip = 0\n  Old_dbm1Tcb =       0\n  Old_dbm1srb =       0\n  Old_dbm1pSRB=       0\n  Old_dbm1pSRB_ziip = 0\n  Old_irlmTcb =       0\n  Old_irlmsrb =       0\n  Old_irlmpSRB=       0\n  Old_irlmpSRB_ziip = 0\n  Old_distTcb =       0\n  Old_distsrb =       0\n  Old_distpSRB=       0\n  Old_distpSRB_ziip = 0\n\n\n  /* compteurs input/output */\n  reco= 0\n  reci= 0\n  recs= 0\n\n  min_time ='26:00:00'\n  max_time ='ZZ:00:00'\n  min_date ='2100.000'\n  max_date ='1900.000'\n  /* reinit IFCID 2 data */\n  call DSNDQXST0\n  return\n\nFLOOR: procedure\nparse arg F\nreturn TRUNC(F) - (F < 0) * (F <> TRUNC(F))\n\nCEIL: procedure\nparse arg C\nreturn TRUNC(C) + (C > 0) * (C <> TRUNC(C))\n/* convert 4K frames to MB */\nf2mb:\n arg num\n num = format(num*4/1024,,2)\n return num\n/* convert bytes to MB */\nb2mb:\n arg num\n num = format(num/1048576,,0)\n return num\ncomp_sum_bpstats:\n        /* we have all the stats for each bpid */\n        /* now compare with old value to get the Dif and then*/\n        /* have the sum */\n         do i = 1 to nbbp_entry.0\n            j = nbbp_entry.i\n            /*--*/\n            /* if value is given by DB2 */\n            if  BufGET.j > 0  then\n            do\n                 Diff= BufGet.j- OBufGet.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufGet.j\n                      Sum_QBSTGET = 0\n                 end\n                 Det_GET.j =  Diff\n                 Sum_QBSTGET = Sum_QBSTGET + Diff\n                 /*--*/\n                 Diff= BufRIO.j- OBufRIO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufRIO.j\n                      Sum_QBSTRIO = 0\n                 end\n                 Det_RIO.j =  Diff\n                 Sum_QBSTRIO = Sum_QBSTRIO + Diff\n                 /*--*/\n                 Diff= BufPWS.j- OBufPWS.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufPWS.j\n                      Sum_QBSTPWS = 0\n                 end\n                 Det_PWS.j =  Diff\n                 Sum_QBSTPWS = Sum_QBSTPWS + Diff\n                 /*--*/\n                 Diff= BufIMW.j- OBufIMW.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufIMW.j\n                      Sum_QBSTIMW = 0\n                 end\n                 Det_IMW.j =  Diff\n                 Sum_QBSTIMW = Sum_QBSTIMW + Diff\n                 /*--*/\n                 Diff= BufDSO.j- OBufDSO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufDSO.j\n                      Sum_QBSTDSO = 0\n                 end\n                 Det_DSO.j =  Diff\n                 Sum_QBSTDSO = Sum_QBSTDSO + Diff\n                 /*--*/\n                 Diff= BufWIO.j- OBufWIO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufWIO.j\n                      Sum_QBSTWIO = 0\n                 end\n                 Det_WIO.j =  Diff\n                 Sum_QBSTWIO = Sum_QBSTWIO + Diff\n                 /*--*/\n                 Diff= BufRPI.j- OBufRPI.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufRPI.j\n                      Sum_QBSTRPI = 0\n                 end\n                 Det_RPI.j =  Diff\n                 Sum_QBSTRPI = Sum_QBSTRPI + Diff\n                 /*--*/\n                 Diff= BufWPI.j- OBufWPI.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufWPI.j\n                      Sum_QBSTWPI = 0\n                 end\n                 Det_WPI.j =  Diff\n                 Sum_QBSTWPI = Sum_QBSTWPI + Diff\n                 /*--*/\n                 Diff= BufPIO.j- OBufPIO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufPIO.j\n                      Sum_QBSTPIO = 0\n                 end\n                 Det_PIO.j =  Diff\n                 Sum_QBSTPIO = Sum_QBSTPIO + Diff\n                 /*--*/\n                 Diff= BufCIO.j- OBufCIO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufCIO.j\n                      Sum_QBSTCIO = 0\n                 end\n                 Det_CIO.j =  Diff\n                 Sum_QBSTCIO = Sum_QBSTCIO + Diff\n                 /*--*/\n                 Diff= BufDIO.j- OBufDIO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufDIO.j\n                      Sum_QBSTDIO = 0\n                 end\n                 Det_DIO.j =  Diff\n                 Sum_QBSTDIO = Sum_QBSTDIO + Diff\n                 /*--*/\n                 Diff= BufLIO.j- OBufLIO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufLIO.j\n                      Sum_QBSTLIO = 0\n                 end\n                 Det_LIO.j =  Diff\n                 Sum_QBSTLIO = Sum_QBSTLIO + Diff\n                 /*--*/\n                 Diff= BufSGT.j- OBufSGT.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufSGT.j\n                      Sum_QBSTSGT = 0\n                 end\n                 Det_SGT.j =  Diff\n                 Sum_QBSTSGT = Sum_QBSTSGT + Diff\n                 /*--*/\n                 Diff= BufSIO.j- OBufSIO.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                 do\n                      Diff= BufSIO.j\n                      Sum_QBSTSIO = 0\n                 end\n                 Det_SIO.j =  Diff\n                 Sum_QBSTSIO = Sum_QBSTSIO + Diff\n                 /*--*/\n                 Diff= BufHST.j- OBufHST.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                      Diff= BufHST.j\n                 Det_HST.j =  Diff\n                 /*--*/\n                 Diff= BufRHS.j- OBufRHS.j\n                 /* db2 recycle */\n                 if Diff < 0 then\n                      Diff= BufRHS.j\n                 Det_RHS.j =  Diff\n                 /*--*/\n            end\n            else\n            do\n                 Det_GET.j = 0\n                 Det_RIO.j = 0\n                 Det_PWS.j = 0\n                 Det_IMW.j = 0\n                 Det_DSO.j = 0\n                 Det_WIO.j = 0\n                 Det_RPI.j = 0\n                 Det_WPI.j = 0\n                 Det_PIO.j = 0\n                 Det_CIO.j = 0\n                 Det_DIO.j = 0\n                 Det_LIO.j = 0\n                 Det_SIO.j = 0\n                 Det_SGT.j = 0\n                 Det_HST.j = 0\n                 Det_RHS.j = 0\n            end\n         end\n   return\ncomp_diff_gbpstats:\n        /* We have all the stats for each bpid */\n        /* now compare with old value to get the Dif */\n         GBPCount = GBPCount+1\n         do i = 1 to nbgbp_entry.0\n            j = nbgbp_entry.i\n            /*--*/\n            /* if value is given in the SMF record */\n            if  GBPGetpage.j > 0  then\n            do\n                 Dif_GBPGetpage.j= GBPGetpage.j - oGBPGetpage.j\n                 if Dif_GBPGetpage.j < 0 then\n                 do\n                      Dif_GBPGetpage.j= GBPGetpage.j\n                 end\n                 /*--*/\n                 Dif_GBPXIReadRet.j= GBPXIReadRet.j -,\n                                      oGBPXIReadRet.j\n                 if Dif_GBPXIReadRet.j < 0 then\n                 do\n                      Dif_GBPXIReadRet.j= GBPXIReadRet.j\n                 end\n                 /*--*/\n                 Dif_GBPXIReadNoRet.j= GBPXIReadNoRet.j -,\n                                      oGBPXIReadNoRet.j\n                 if Dif_GBPXIReadNoRet.j < 0 then\n                 do\n                 end\n                 /*--*/\n                 Dif_QBGLAW.j= QBGLAW.j - oQBGLAW.j\n                 if Dif_QBGLAW.j < 0 then\n                 do\n                      Dif_QBGLAW.j= QBGLAW.j\n                 end\n                 /*--*/\n                 Dif_QBGLSW.j= QBGLSW.j - oQBGLSW.j\n                 if Dif_QBGLSW.j < 0 then\n                 do\n                      Dif_QBGLSW.j= QBGLSW.j\n                 end\n            end\n            else\n            do\n                 Dif_GBPGetPage.j =  0\n                 Dif_GBPXIReadRet.j =  0\n                 Dif_GBPXIReadNoRet.j =  0\n                 Dif_QBGLAW.j =  0\n                 Dif_QBGLSW.j =  0\n            end\n            /* compute sum for last 15 values */\n            Sum_GBPXIReadRet.j   =  Sum_GBPXIReadRet.j +,\n                          Dif_GBPXIReadRet.j\n            Sum_GBPXIReadNoRet.j =  Sum_GBPXIReadNoRet.j +,\n                          Dif_GBPXIReadNoRet.j\n            if GBPCount = 15 then\n            do\n               say 'GBPCount'  Run_fmt_time\n               GBPXIMissRatio.j = Sum_GBPXIReadNoRet.j /,\n                      (1+Sum_GBPXIReadNoRet.j + Sum_GBPXIReadRet.j)\n               Say 'MissRatio' j GBPXIMissRatio.j,\n                        Sum_GBPXIReadNoRet.j Sum_GBPXIReadRet.j,\n                        format(GBPXIMissRatio.j,4,2)\n               /* reinit value for a new cycle of 15 minutes */\n               Sum_GBPXIReadRet.j   =  Dif_GBPXIReadRet.j\n               Sum_GBPXIReadNoRet.j =  Dif_GBPXIReadNoRet.j\n            end\n            else GBPXIMissRatio.j=0\n         end /* loop */\n         if GBPCount=15 then GBPCount=0\n   return\ninit_sum_bpstats:\n          Sum_QBSTGET = 0\n          Sum_QBSTRIO = 0\n          Sum_QBSTPWS = 0\n          Sum_QBSTIMW = 0\n          Sum_QBSTDSO = 0\n          Sum_QBSTWIO = 0\n          Sum_QBSTRPI = 0\n          Sum_QBSTWPI = 0\n          Sum_QBSTPIO = 0\n          Sum_QBSTCIO = 0\n          Sum_QBSTDIO = 0\n          Sum_QBSTLIO = 0\n          Sum_QBSTSGT = 0\n          Sum_QBSTSIO = 0\n\n         /* raz all figures for all bufferpool */\n         do i = 1 to nbbp_entry.0\n            j = nbbp_entry.i\n            BufGet.j = 0\n            BufRIO.j = 0\n            BufPWs.j = 0\n            BufIMW.j = 0\n            BufDSO.j = 0\n            BufWIO.j = 0\n            BufRPI.j = 0\n            BufWPI.j = 0\n            BufPIO.j = 0\n            BufCIO.j = 0\n            BufVPL.j = 0\n            BufDIO.j = 0\n            BufLIO.j = 0\n            BufSGT.j = 0\n            BufSIO.j = 0\n            BufHST.j = 0\n            BufRHS.j = 0\n         end\n     return\ninit_gbpstats:\n         /* raz all figures for all bufferpool */\n         do i = 1 to nbgbp_entry.0\n            j = nbgbp_entry.i\n            GBPGetpage.j=0\n            GBPXIReadRet.j=0\n            GBPXIReadNoRet.j=0\n            QBGLAW.j=0\n            QBGLSW.j=0\n         end\n     return\nswitch_bpstats:\n         /* new to Old only if new value exists */\n      if BufGet.j > 0  then do\n         do i = 1 to nbbp_entry.0\n            j = nbbp_entry.i\n            oBufGet.j = BufGet.j\n            oBufRIO.j = BufRIO.j\n            oBufPWS.j = BufPWS.j\n            oBufIMW.j = BufIMW.j\n            oBufDSO.j = BufDSO.j\n            oBufWIO.j = BufWIO.j\n            oBufRPI.j = BufRPI.j\n            oBufWPI.j = BufWPI.j\n            oBufPIO.j = BufPIO.j\n            oBufCIO.j = BufCIO.j\n            oBufDIO.j = BufDIO.j\n            oBufLIO.j = BufLIO.j\n            oBufSGT.j = BufSGT.j\n            oBufSIO.j = BufSIO.j\n            oBufHST.j = BufHST.j\n            oBufRHS.j = BufRHS.j\n         end   /* end do */\n      end /* end if ...*/\n     return\nswitch_bpstatx:\n         /* new to Old only if new value exists */\n         do i = 1 to nbbp_entry.0\n            j = nbbp_entry.i\n            if BufGet.j > 0  then do\n              oBufGet.j = BufGet.j\n              oBufRIO.j = BufRIO.j\n              oBufPWS.j = BufPWS.j\n              oBufIMW.j = BufIMW.j\n              oBufDSO.j = BufDSO.j\n              oBufWIO.j = BufWIO.j\n              oBufRPI.j = BufRPI.j\n              oBufWPI.j = BufWPI.j\n              oBufPIO.j = BufPIO.j\n              oBufCIO.j = BufCIO.j\n              oBufDIO.j = BufDIO.j\n              oBufLIO.j = BufLIO.j\n              oBufSGT.j = BufSGT.j\n              oBufSIO.j = BufSIO.j\n              oBufHST.j = BufHST.j\n              oBufRHS.j = BufRHS.j\n            end   /* end if */\n         end /* end do ...*/\n     return\nswitch_gbpstats:\n         /* new to Old only if new value exists */\n         do i = 1 to nbgbp_entry.0\n            j = nbgbp_entry.i\n            if GBPGetPage.j > 0 then do\n               oGBPGetPage.j  =GBPGetPage.j\n               oGBPXIReadRet.j  =GBPXIReadRet.j\n               oGBPXIReadNoRet.j=GBPXIReadNoRet.j\n               oQBGLAW.j=QBGLAW.j\n               oQBGLSW.j=QBGLSW.j\n            end\n         end   /* end do */\n     return\nrecord_bp:\n     /* add a new bufferpool id in the list */\n           do i = 1 to nbbp_entry.0\n              if QBSTPID = nbbp_entry.i then leave\n           end\n           /* not found => new entry */\n           if i > nbbp_entry.0 then\n           do\n               nbbp_entry.0 = nbbp_entry.0 + 1\n               j            = nbbp_entry.0\n               nbbp_entry.j = QBSTPID\n\n               oBufGet.QBSTPID = 0\n               oBufRIO.QBSTPID = 0\n               oBufPWS.QBSTPID = 0\n               oBufIMW.QBSTPID = 0\n               oBufDSO.QBSTPID = 0\n               oBufWIO.QBSTPID = 0\n               oBufRPI.QBSTPID = 0\n               oBufWPI.QBSTPID = 0\n               oBufPIO.QBSTPID = 0\n               oBufCIO.QBSTPID = 0\n               oBufDIO.QBSTPID = 0\n               oBufLIO.QBSTPID = 0\n               oBufSIO.QBSTPID = 0\n               oBufSGT.QBSTPID = 0\n               oBufHST.QBSTPID = 0\n               oBufRHS.QBSTPID = 0\n           end\n   return\nrecord_gbp:\n     /* add a new bufferpool id in the list */\n           do i = 1 to nbgbp_entry.0\n              if QBGLGN  = nbgbp_entry.i then leave\n           end\n           /* not found => new entry */\n           if i > nbgbp_entry.0 then\n           do\n               nbgbp_entry.0 = nbgbp_entry.0 + 1\n               j            = nbgbp_entry.0\n               nbgbp_entry.j = QBGLGN\n               say 'record_gbp' QBGLGN\n\n               oGBPGetPage.QBGLGN  = 0\n               oGBPXIReadRet.QBGLGN  = 0\n               oGBPXIReadNoRet.QBGLGN  = 0\n               oQBGLAW.QBGLGN  = 0\n               oQBGLSW.QBGLGN  = 0\n               Sum_GBPXIReadRet.QBGLGN  = 0\n               Sum_GBPXIReadNoRet.QBGLGN  = 0\n           end\n   return\n/********************************************************/\n/* Check individual parameters for best practices alert */\n/********************************************************/\nCheckForAlert:\n    /* Global Dynamic Stmt cache hit ratio > 90% */\n    Hit = Dif_QXSTFND / (Dif_QXSTFND+Dif_QXSTNFND + 0.01)\n    if Hit < 0.90 then\n             do\n               say 'Warning : Global Dyn. Cache Hit < 90%',\n                  format(Hit,3,2) ' \u00e0' run_fmt_time\n               retcode=4\n             end\n    /* Local  Dynamic Stmt cache hit ratio > 70% */\n    /* Source Optimizing DB2 System Performance using db2 statistics*/\n    Hit = Dif_QXSTNPRP/ (Dif_QXSTNPRP + Dif_QXSTIPRP + 0.01)\n    if Hit = 0   then do\n           if tsaylocal=0 then do\n             say 'Warning : Local Dyn. Cache probably not used'\n             tsayLocal = 1\n           end\n    end\n    else if Hit < 0.70 then\n             do\n               say 'Warning : Local Dyn. Cache Hit < 70%',\n                  format(Hit,3,2) ' \u00e0' run_fmt_time\n               retcode=4\n             end\n    /* SLRU full   */\n          if Det_HST.j    > 0 then\n             do\n               say 'Warning : SLRU chain = VPSEQT',\n                   ' \u00e0' run_fmt_time\n               retcode=4\n             end\n    /* Checkpoints */\n       period= 15\n       if HistCKPT.0 < period then\n       do\n          /* store the value for sliding */\n          HistCKPT.0 = HistCKPT.0 + 1\n          j=HistCKPT.0\n          HistCKPT.j = Dif_QWSDCKPT\n       end\n       else do /* decaler pour prendre que les 15 dernieres */\n          i=1\n          sum=0\n          do until i= period\n              j=i+1\n              HistCKPT.i = HistCKPT.j\n              sum = sum+HistCKPT.j\n              i=i+1\n          end\n          HistCKPT.i = Dif_QWSDCKPT  /*i= period */\n          sum = sum+HistCKPT.i\n          if sum  > 3 then /* 1 checkpoint each 5/10 mn is OK */\n             do\n               say 'Warning : Checkpoint frequency too high' sum,\n                   'for' period 'minutes \u00e0' run_fmt_time\n               retcode=4\n             end\n       end\n    /* Close DSMAX */\n          if Dif_QTDSDRN  > 0 then\n             do\n               say 'Warning : Close Dataset due to DSMAX reached',\n                   ' \u00e0' run_fmt_time\n               retcode=4\n             end\n\n    /* RWRO Switch */\n       period= 5\n       if HistRWRO.0 < period then\n       do\n          HistRWRO.0 = HistRWRO.0 + 1\n          j=HistRWRO.0\n          HistRWRO.j = Dif_QTPCCT\n       end\n       else do /* push stack */\n          i=1\n          sum=0\n          do until i= period\n              j=i+1\n              HistRWRO.i = HistRWRO.j\n              sum = sum+HistRWRO.j\n              i=i+1\n          end\n          HistRWRO.i = Dif_QTPCCT    /*i= period */\n          sum = sum+HistRWRO.i\n          /* 15 switch per minute is acceptable */\n          if sum  > (15* period) then\n             do\n               say 'Warning : RWRO switch too high' sum,\n                   'for' period 'minutes \u00e0' run_fmt_time\n               retcode=4\n             end\n       end\n    /* Page Ins    */\n          if Sum_QBSTRPI  > 0 |  Sum_QBSTWPI > 0 then\n             do\n               say 'Warning : Page in for Read/Write happened',\n                   ' \u00e0' run_fmt_time Sum_QBSTRPI Sum_QBSTWPI\n               retcode=4\n             end\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "S101CSV": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00W\\x01\\x16\\x18o\\x01\\x18\\x06o\\x15$\\x03\\xa3\\x02\\xb7\\x03\\xa3\\xe6\\xe2\\xe8\\xd5\\xc7\\xe4\\xc4@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2016-07-04T00:00:00", "modifydate": "2018-03-07T15:24:57", "lines": 931, "newlines": 695, "modlines": 931, "user": "WSYNGUD"}, "text": "/*REXX*/\n/* Input file : SMF extract sorted */\n/* This programs processes one Date/Lpar/SSID a time            */\n/* (at least in mode summary to calculate the accumulation)     */\n/* Decode  smf 101 records - written by Nguyen Duc Tuan */\n/*            Release 1.1  4 Jan 2016                   */\n/*            Release 1.2  11 Feb 16 add numeric digits */\n/*            Release 1.3  15 Jul 16 Possible to report a specific */\n/*                         ConnType (CICS, BATCH ..)               */\n/*                         z/OS 2.1 Read directly SMF records      */\n/*            Release 1.4  27 Jul 16 Commits, ABort, Start time    */\n/*            Release 1.5  07 Sep 16 Bug : Distributed Header not  */\n/*                         displayed in some cases                 */\n/*            Release 2.0  07 Sep 18 Bugs correction - DRDA records*/\n/*                         not selected                            */\n/*-----------------------------------------------------------------*/\n/* summary='Y'  produce report aggregated by plan,jobname, conntype*/\n/*              in dataset &HLQ.REPORTAS (short report)            */\n/* ConnSel='ALL' or CICS, BATCH, DRDA, ... any supported value     */\n/*              set by this program in function DSNDQWHC           */\n/* SmfOrig='B' Raw SMF dataset in input (from z/OS 2.1), allows    */\n/*             to read several SMF concatenated datasets in input  */\n/*             Otherwise the program expects a sorted SMF dataset  */\n/*             as seen with JCL101                                 */\n/*-----------------------------------------------------------------*/\nsummary='N'\narg ssid hlq SmfOrig ConnSel CorridSel\nif ConnSel='' then ConnSel='ALL'\nif CorridSel='' then CorridSel='ALL'\nsay 'Processing for Subsys' ssid\n\n\nif SmfOrig <> 'B' then\ndo\n    /* Input file : SMF extract sorted */\n    oufl = hlq || '.SMFEXTA.OUT'\n    address TSO\n    \"ALLOC DD(INP) DS('\"oufl\"')    SHR REU bufno(20)\"\nend\n\n/* Report dataset on output */\noufl = \"'\" || hlq || '.reportA.' || ssid || \"'\"\nsay oufl\n  \"DELETE\" oufl \"PURGE\"\n\n\"ALLOC FI(OUFL) DA(\"oufl\") NEW CATALOG REUSE\" ,\n\"LRECL(360) RECFM(V B) TRACKS SPACE(1000,900)\"\nrcalloc = rc\nif rcalloc <> 0 then Do\n     say \"**********************************************\"\n     say \"   Error allocating report file\" rcalloc\n     say \"   Abnormal end  \"\n     say \"**********************************************\"\n     Exit 8\nend\n\nif summary='Y' then do\n  oufl = \"'\" || hlq || '.reportAS' || \"'\"\n  \"DELETE\" oufl \"PURGE\"\n  \"ALLOC FI(OUFS) DA(\"oufl\") NEW CATALOG REUSE\" ,\n  \"LRECL(400) RECFM(V B) TRACKS SPACE(250,250)\"\n  rcalloc = rc\n  if rcalloc <> 0 then Do\n       say \"**********************************************\"\n       say \"   Error allocating report summary file\" rcalloc\n       say \"   Abnormal end  \"\n       say \"**********************************************\"\n       Exit 8\n  end\nend /* if summary */\n\n/* compteurs input/output */\nnbr_ifcid=0\nold_hnt=0    /* old header next type */\nreco= 0\nreci= 0\nrecs= 0\nrupture = 0\n/* init valeurs rupture */\nif summary = 'Y' then call init_sum                                    d\n\nCall Write_Header\n\n/* START PROCESSING */\nDo Forever\n  /* LECTURE record SMF UN PAR UN */\n  \"EXECIO 1 DISKR INP\"\n  IF RC > 0 THEN DO\n            rcalloc=rc\n            if rc = 2 then\n              do\n                  SAY 'End of SMF dataset - input records' reci\n                  if summary='Y' then call write_summary\n              end\n            else\n              say 'Erreur de lecture fichier SMF' rc\n            LEAVE /* sortir de la boucle Do Forever */\n  END\n  PARSE PULL INPUT_REC\n  reci = reci+1\n  OFFSET = 1\n  CALL DSNDQWAS /* MAP SMF HEADER */\n  IF SM101RTY = 101 & SM101SSI = ssid   then\n  DO\n    recs=recs+1  /* compteurs records smf101*/\n    /*DSNDQWA0 MAP SELF-DEFINING SECT */\n    CALL DSNDQWA0 /* MAP SELF-DEFINING SECT */\n    OFFSET = QWA01PSO - 4 + 1\n    /* These headers are always present */\n    CALL DSNDQWHS /* MAP product section STANDARD HEADER */\n    CALL DSNDQWHC /* MAP CORRELATED HEADER, just after the standard*/\n                  /* header Product Section */\n\n    /* result is set in subroutine DSNDQWHC */\n    /* select to report only some type of records */\n    if result = 4 then iterate\n    /* Check all hearder type and process if possible */\n    /* Header type : QWHSTYP */\n    /*     1                  ..STANDARD HEADER         */\n    /*     2                  ..CORRELATION HEADER      */\n    /*     4                  ..TRACE HEADER            */\n    /*     8                  ..CPU HEADER              */\n    /*     16                 ..DISTRIBUTED HEADER      */\n    /*     32                 ..DATA SHARING HEADER     */\n    offset_header_next= offset_corr+QWHCLEN\n    /*init requester location */\n    QWHDRQNM=''\n    QWHDSVNM=''\n    QWHDPRID =''\n    /* ---------------------------------------*/\n    Do while offset_header_next  > 0\n        temp=offset_header_next+2 /*skip len*/\n        header_next_type= C2D(SUBSTR(INPUT_REC,temp,1))\n        offset_header = offset_header_next\n        offset_header_next=offset_header_next+ ,\n           C2D(SUBSTR(INPUT_REC,OFFSET_header_next,2))\n        Select\n             When header_next_type=16 then\n                  do\n                     /* distributed header */\n                     CALL DSNDQWHD\n                  end\n             When header_next_type=64 then\n                  do\n                    /*  no more headers behind*/\n                     offset_header_next=0\n                  end\n             Otherwise\n                  do\n                     /* try to avoid excessive displays */\n                     if   header_next_type <> old_hnt then\n                     do\n                       say 'header_next_type' header_next_type,\n                       'not processed yet by the current REX101'\n                       old_hnt= header_next_type\n                     end\n                  end\n        end   /* select */\n    end /* Do until */\n    /* pointeur vers accounting section DSNDQWAC */\n    OFFSET = QWA01R1O - 4 + 1\n    /* record  ifcid in this smf data */\n    call record_ifcid\n    Select\n         When ifcid = 3  Then\n              do\n                 /* general accounting data */\n                 CALL DSNDQWAC\n                 if rollup='1' then iterate\n                 /* sql stats */\n                 if QWA01R2O > 0 then do\n                            OFFSET = QWA01R2O - 4 + 1\n                            CALL DSNDQXST\n                           end\n                        else do\n                        /* pas de donn{es sql*/\n                           selects   =0\n                           inserts   =0\n                           updates   =0\n                           deletes   =0\n                           opens     =0\n                           fetchs    =0\n                        end\n                 /* s'il existe des donnees buffer, les chercher*/\n                 if QWA01R3O > 0 then do\n                            OFFSET = QWA01R3O - 4 + 1\n                            CALL DSNDQBAC\n                           end\n                        else do\n                        /* pas de donn{es buffer manager */\n                           getp      =0\n                           bufupd    =0\n                           syncio    =0\n                           syncwr    =0\n                           sprfreq   =0\n                           lprfreq   =0\n                           dprfreq   =0\n                           sio       =0\n                        end\n              end /* end when ifcid=3*/\n         When ifcid = 239 then /* package accounting data*/\n              do\n                 nop\n              end\n         Otherwise\n              do\n                 nop\n              end\n    end   /* select */\n    /* on part du principe que ifcid03 est le record accounting */\n    /* maitre , a voir si on commence a traiter les autres      */\n    if ifcid=3 then\n    do\n         CALL WRITE_REPORT\n    end\n  END /*    IF SM101RTY = 101  */\nEND /* Do forever */\n\"EXECIO 0 DISKW OUFS (STEM INL. FINIS\"\n\"EXECIO 0 DISKW OUFL (STEM INL. FINIS\"\n\"EXECIO 0 DISKR INP (STEM INL. FINIS\"\n\"EXECIO 0 DISKR INP (STEM INL. FINIS\"\n\"FREE DD(INP)\"\n\"FREE DD(OUFL)\"\n\"FREE DD(OUFS)\"\n/* report ifcid read */\ncall report_ifcid\nSay 'Output records : ' reco\nEXIT rcalloc\n\n\n/* decode smf header */\nDSNDQWAS:\n   OFFSET = OFFSET + 1\n   /* SM100RTY DS XL1 RECORD TYPE X'64' OR 101 */\n   SM101RTY = C2D(SUBSTR(INPUT_REC,OFFSET,1))\n   if sm101rty <> 101 then return;\n   OFFSET = OFFSET + 1\n\n   /* SM101TME DS XL4 TIME SMF MOVED RECORD */\n   SM101TME = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n   OFFSET = OFFSET + 4\n   CALL GET_FMT_TIME\n   field    = C2X(SUBSTR(INPUT_REC,OFFSET,4))\n     parse value field with 1 . 2 c 3 yy 5 ddd 8 .\n     if (c = 0) then\n       yyyy = '19'||yy\n     else\n       yyyy = '20'||yy\n   sm101dte    = yyyy||'.'||ddd\n   OFFSET = OFFSET + 4\n   /* smf id */\n   sm101sid = SUBSTR(INPUT_REC,OFFSET,4)\n   OFFSET = OFFSET + 4\n   /* SM100SSI DS CL4 SSID         */\n   sm101ssi = SUBSTR(INPUT_REC,OFFSET,4)\n   OFFSET = OFFSET + 10\n   /* TOTAL LENGTH = 28 */\n   RETURN\n\nDSNDQWA0: /* MAP SELF-DEFINING SECT */\n  /* QWA01PSO DS AL4 OFFSET TO THE PRODUCT SECTION */\n  QWA01PSO = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8\n  /* QWA01R1O DS AL4 OFFSET TO THE ACCOUNTING SECTION */\n  /* DSNDQWAC ACCOUNTING SECTION */\n  QWA01R1O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8 /* 4+2+2 */\n  /* DSNDQXST RDS DATA : NB selects ... */\n  QWA01R2O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 8 /* 4+2+2 */\n  /* DSNDQBAC Buffer manager  */\n  QWA01R3O = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  offset = offset +6\n  nb_pools = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  /* DSNDQTXA Lock manager  */\n  /* DSNDQTXA Lock manager  */\n  /* DSNDQLAC DDF */\n  /* DSNDQMDA DDF DRDA > V2R3 */\n  /* DSNDQIFA IFI */\n  /* DSNDQWAR Rollup acct info */\n  /* DSNDQBGA GroupBuffer */\n  /* DSNDQTGA Global Locking */\n  /* DSNDQWDA DataSharing (pas encore utilise) */\n  /* DSNDQWAX Acctg overflow */\n  /* DSNDQ8AC Accelerator acctg */\n  /*OFFSET = OFFSET + 96  */\n  RETURN\n\n/* product section std header  */\nDSNDQWHS:\n  QWHSLEN = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 4\n  /*  QWHSIID DS XL2 IFCID */\n  QWHSIID = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  IFCID=QWHSIID\n  OFFSET = OFFSET + 3\n  /* release number */\n  QWHSRN = C2X(SUBSTR(INPUT_REC,OFFSET,1))\n  OFFSET = OFFSET + 5\n  /*if QWHSRN= 'B1' then say 'DB2 V11' */\n  /* QWHSSSID DS CL4 SUBSYSTEM NAME */\n  QWHSSSID = SUBSTR(INPUT_REC,OFFSET,4)\n  if QWHSRN= 'B1' then\n      OFFSET = OFFSET +  74\n  else offset = OFFSET +  104\n  RETURN\n\n/* correlation header */\nDSNDQWHC:\n  offset_corr=offset\n  QWHCLEN = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  OFFSET = OFFSET + 2\n  QWHCTYP = C2D(SUBSTR(INPUT_REC,OFFSET,1))\n  OFFSET = OFFSET + 2\n  /* authid */\n  QWHCAID      = SUBSTR(INPUT_REC,OFFSET,8)\n  OFFSET = OFFSET + 8\n  QWHCCV  = SUBSTR(INPUT_REC,OFFSET,12)\n  OFFSET = OFFSET + 12\n  /* Correlation ID selection */\n  if CorridSel <> 'ALL' & CorridSel <> qwhccv then return 4\n  /* QWHCCN DS CL8 CONNECTION NAME */\n  QWHCCN = SUBSTR(INPUT_REC,OFFSET,8)\n  OFFSET = OFFSET + 8\n  /* QWHCPLAN DS CL8 PLAN NAME */\n  QWHCPLAN = SUBSTR(INPUT_REC,OFFSET,8)\n  OFFSET = OFFSET + 8\n  /* QWHCOPID  initial  authid */\n  QWHCOPID  = SUBSTR(INPUT_REC,OFFSET,8)\n  OFFSET = OFFSET + 8\n  /* QWHCATYP  Type de connection*/\n  QWHCATYP  = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n      Select\n           When QWHCATYP  = 4  Then do\n                                        conntype='CICS'\n                                    end\n           When QWHCATYP  = 2  Then do\n                                        conntype='DB2CALL'\n                /* direct call inside program (used by sofware ..)*/\n                /* example BMC utilities */\n                                    end\n           When QWHCATYP  = 1  Then do\n                                        conntype='BATCH'\n                                    end\n           When QWHCATYP  = 3  Then do\n                                        conntype='DL1'\n                /* PGM=DFSRRC00,PARM='DLI,...' */\n                                    end\n           When QWHCATYP  = 5  Then do\n                                        conntype='IMSBMP'\n                                    end\n           When QWHCATYP  = 6  Then do\n                                        conntype='IMSMPP'\n                                    end\n           When QWHCATYP  = 8  Then do\n                                        conntype='DRDA'\n                                    end\n           When QWHCATYP  = 9  Then do\n                                        conntype='IMSCTR'\n                    /* not seen */\n                                    end\n           When QWHCATYP  = 10 Then do\n                                        conntype='IMSTRANBMP'\n                    /* not seen */\n                                    end\n           When QWHCATYP  = 11 Then do\n                                        conntype='DB2UTIL'\n                                    end\n           When QWHCATYP  = 12 Then do\n                                        conntype='RRSAF'\n                    /* not seen */\n                                    end\n           Otherwise      say 'QWHCATYP' QWHCATYP 'not processed'\n      end   /* select */\n\n  /* Connection Type selection */\n  if ConnSel <> 'ALL' & ConnSel <> Conntype then\n       return 4\n\n  if conntype = 'CICS' | conntype = 'DRDA' | conntype = 'IMSMPP'\n    then jobn= QWHCCN\n    else jobn = QWHCCV\n\n  OFFSET = OFFSET + 28\n  if conntype =  'DRDA' then\n  do\n    /* QWHCEUID  end userid */\n    QWHCEUID  = SUBSTR(INPUT_REC,OFFSET,16)\n    OFFSET = OFFSET + 48\n    /* QWHCEUWN  user workstation name */\n    QWHCEUWN  = SUBSTR(INPUT_REC,OFFSET,18)\n  end\n  else do\n    QWHCEUID  = ''\n    QWHCEUWN  = ''\n  end\n  RETURN 0\n\n\nDSNDQWHD: /* MAP distributed header */\n    offset= offset_header      + 4 /* skip len + type */\n    /* requester location */\n    QWHDRQNM = SUBSTR(INPUT_REC,OFFSET,16)\n    offset= offset + 24\n    QWHDSVNM = SUBSTR(INPUT_REC,OFFSET,16)\n    offset= offset + 16\n    QWHDPRID = SUBSTR(INPUT_REC,OFFSET,8)\n  return\n\nDSNDQWAC: /* MAP ACCOUNTING DATA SECTION */\n  /* QWACBSC DS XL8 CLASS 1 BEGINNING STORE CLOCK VALUE*/\n  NUMERIC DIGITS 30\n  QWACPCNT=c2d(SUBSTR(INPUT_REC,OFFSET+280,4))\n  QWACPACE=c2x(SUBSTR(INPUT_REC,OFFSET+288,4))\n  rollup='0'\n  /* conntype = DRDA the records are often marked as rollup */\n  if QWACPACE >'00000000' & conntype <> 'DRDA' then do\n                               rollup='1'\n                               return\n                             end\n  /* transform to local time value */\n  Clock = c2x(SUBSTR(INPUT_REC,offset,8))\n  call STCK2Local Clock\n  ThdStart= LocalTime\n  QWACBSC = C2X(SUBSTR(INPUT_REC,OFFSET,8)) /*CONVERT INTO HEX VALUE*/\n  QWACBSC = x2d(SUBSTR(QWACBSC,1,13)) /*ELIMINATE 1.5 BYTES */\n  OFFSET = OFFSET + 8\n  /* QWACESC DS XL8 CLASS 1 ENDING STORE CLOCK VALU */\n  QWACESC = C2X(SUBSTR(INPUT_REC,OFFSET,8)) /*CONVERT INTO HEX VALUE */\n  QWACESC = X2D(SUBSTR(QWACESC,1,13)) /*ELIMINATE 1.5 BYTES */\n  OFFSET = OFFSET + 8\n  ELAPSED_TIME = ( QWACESC - QWACBSC ) /1000000\n  if elapsed_time < 0 then\n      do\n         elapsed_time = QWACESC / 1000000\n      end\n  /* QWACBJST DS XL8 BEGINNING TCB CPU TIME FROM MVS (CLASS 1)*/\n  QWACBJST = C2X(SUBSTR(INPUT_REC,OFFSET,8)) /*CONVERT INTO HEX VALUE*/\n  QWACBJST = X2D(SUBSTR(QWACBJST,1,13)) /*ELIMINATE 1.5 BYTES */\n  OFFSET = OFFSET + 8\n  /* QWACEJST DS XL8 ENDING TCB CPU TIME IN ALL ENVIRONMENTS */\n  QWACEJST = C2X(SUBSTR(INPUT_REC,OFFSET,8)) /*CONVERT INTO HEX VALUE*/\n  QWACEJST = X2D(SUBSTR(QWACEJST,1,13)) /*ELIMINATE 1.5 BYTES */\n  TCB_TIME = (QWACEJST - QWACBJST)/1000000\n  OFFSET = OFFSET + 24\n  /* QWACRINV=X2D(SUBSTR(INPUT_REC,OFFSET,4) */\n  OFFSET = OFFSET + 20\n  QWACCOMM=C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 4\n  QWACABRT=C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  OFFSET = OFFSET + 12\n  /* QWACAJST DB2 CPU en stck value */\n  /* attention : this is stck time , not local time | */\n  QWACAJST = C2X(SUBSTR(INPUT_REC,OFFSET,8))\n  offset=offset + 8\n  QWACAJST = X2D(SUBSTR(QWACAJST,1,13))\n  QWACAJST  = QWACAJST/1000000\n  /* Skip next 8   bytes */\n  offset=offset + 8\n  /* Wait I/O */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  offset=offset + 8\n  QWACAWTI=x_time(time8)\n  /* Wait local locks */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  offset=offset + 8 + 8\n  QWACAWTL=x_time(time8)\n  /* Wait other Read */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  offset=offset + 8\n  QWACAWTR=x_time(time8)\n  /* Wait other write*/\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  offset=offset + 8\n  QWACAWTW=x_time(time8)\n  /* Wait synch exec unit switch */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  offset=offset + 8\n  QWACAWTE=x_time(time8)\n  /* Wait latch */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  offset=offset + 32\n  QWACAWLH=x_time(time8)\n  /* Wait write log  */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  QWACAWLG=x_time(time8)\n  offset=offset + 12\n  /* Wait LOB materialization */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  QWACALBW=x_time(time8)\n  offset=offset + 12\n  /* Wait Accel      */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  QWACAACW=x_time(time8)\n  offset=offset + 8\n  /* Wait page latch      */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  QWACAWTP=x_time(time8)\n  offset=offset + 16\n  /*QWACFLGS=c2d(SUBSTR(INPUT_REC,OFFSET,2))\n  say QWACFLGS\n  offset=offset + 4 */\n  /* Wait messages to others members */\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  QWACAWTG=x_time(time8)\n  /* Wait global locks  */\n  offset=offset + 8\n  time8=c2x(SUBSTR(INPUT_REC,OFFSET,8))\n  QWACAWTJ=x_time(time8)\n  /* skip xx bytes */\n  offset=offset + 68\n  /* log records */\n  QWACLRN  = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n  offset=offset + 4\n  /* log bytes written */\n  QWACLRAB = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n  RETURN\n\n/* buffer manager data */\nDSNDQBAC:\nnumeric digits 15\n  i = 0\n  getp=0\n  bufupd=0\n  syncio=0\n  syncwr=0\n  sprfreq=0\n  lprfreq=0\n  dprfreq=0\n  sio    =0\n  /* say 'buffer manager for plan' QWHCPLAN */\n  do until i= nb_pools\n     i = i+1\n     QBACPID   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     offset=offset + 4\n     QBACGET   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     offset=offset + 4\n     getp = getp+QBACGET\n     QBACSWS   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     BufUpd = BufUpd +QBACSWS\n     offset = offset + 8\n     QBACRIO   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     syncio = syncio+QBACRIO\n     offset = offset + 4\n     QBACSEQ   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     sprfreq = sprfreq+QBACSEQ\n     offset = offset + 4\n     QBACIMW   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     syncwr  = syncwr + QBACIMW\n     offset = offset + 4\n     QBACLPF   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     lprfreq = lprfreq+QBACLPF\n     offset = offset + 4\n     QBACDPF   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     dprfreq = dprfreq+QBACDPF\n     offset = offset + 24\n     QBACSIO   = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n     sio     = sio    +QBACSIO\n     offset = offset + 8\n  /* say '      ',                                          */\n  /*     'buffer id' QBACPID 'gp:' QBACGET 'syncio' QBACRIO,*/\n  /*     'syncwr' QBACIMW  'SIO' QBACSIO                    */\n  end\n\n  return\n/* sql statements  */\nDSNDQXST:\n   selects   =0\n   inserts   =0\n   updates   =0\n   deletes   =0\n   opens     =0\n   fetchs    =0\n   offset=offset + 4\n   eye_catch = SUBSTR(INPUT_REC,OFFSET,4)\n   if eye_catch <> 'QXST' then\n           do\n              say 'QXST eye catcher not found at record' reci,\n                  ' offset' offset\n              exit 8\n           end\n   offset=offset + 4\n   selects   = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n   offset=offset + 8\n   inserts   = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n   offset=offset + 8\n   updates   = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n   offset=offset + 8\n   deletes   = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n   offset=offset + 24\n   opens     = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n   offset=offset + 136 /* 17*8*/\n   fetchs    = C2D(SUBSTR(INPUT_REC,OFFSET,8))\n  return\n\nGET_FMT_TIME:\n  RUN_HH = SM101TME % 360000\n  RUN_HH = RIGHT(RUN_HH,2,'0')\n  RUN_MIN = SM101TME % 6000 - RUN_HH*60\n  RUN_MIN = RIGHT(RUN_MIN,2,'0')\n  RUN_SEC = SM101TME % 100 - RUN_HH *3600 - RUN_MIN*60\n  RUN_SEC = RIGHT(RUN_SEC,2,'0')\n  RUN_FMT_TIME = RUN_HH||':'||RUN_MIN||':'||RUN_SEC\nRETURN\n\nwrite_header:\n  say 'file ' oufl     ' will be produced'\n  queue \"Lpar,Ssid,Date,Time,ThdStart,Authid,Corrid,Connid,Plan,\",\n        \"OrigPrimAuth,Conntype,Elapsed,Cl1Cpu,Cl2Cpu,\",\n        \"Commit,Abort,LogRec,LogBytes,\",\n        \"WaitIO,WtLock,WtOthRd,WtOthWr,\",\n        \"WtSync,WtLatch,\",\n        \"WtWrLog,WtLob,WtAcc,WtPgLatch,WtMsg,WtGlLock,\",\n        \"Getp,SyncIo,BufUpd,SyncWr,SPrfReq,LPrfReq,DPrfReq,Sio,\",\n        \"Sels,Ins,Upd,Del,Open,Fetch,\",\n        \"ReqLoc,SrvName,SrvProdId,WrkSUser,WrkSNam\"\n\n  \"EXECIO\" queued() \"DISKW OUFL\"\n\n  if summary='Y' then\n  do\n    say 'file ' oufs     ' will be produced'\n    queue \"Lpar,Ssid,Date,Hour,Plan,Jobn,\",\n           \"Conntype,Occ,Cl1Cpu,Cl2Cpu,\",\n           \"Getp,SyncIo,BufUpd,SyncWr,SPrfReq,LPrfReq,DPrfReq,Sio,\",\n           \"Selects,Inserts,Updates,Deletes,Opens,Fetchs\",\n\n    \"EXECIO\" queued() \"DISKW OUFs\"\n  end\n  return\n\nWRITE_REPORT:\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm101sid || ',' || sm101ssi || ','  ,\n    || sm101dte || ','   ,\n    || run_fmt_time || ','   ,\n    || ThdStart     || ','   ,\n    || strip(QWHCAID,'T')           || ','   ,\n    || strip(qwhccv,'T')            || ','   ,  /* CORRID*/\n    || strip(qwhccn,'T')            || ','   ,\n    || strip(qwhcplan,'T')          || ','   ,\n    || strip(qwhcopid,'T')          || ','   ,\n    || conntype          || ','   ,\n    || elapsed_time     || ','   ,\n    || tcb_time  || ','   ,\n    || QWACAJST  || ','   ,    /*cl2cpu*/\n    || QWACCOMM  || ','   ,    /*commits*/\n    || QWACABRT  || ','   ,    /*abort*/\n    || QWACLRN   || ','   ,    /*log records*/\n    || QWACLRAB  || ','   ,    /*log bytes  */\n    || format(QWACAWTI,6,0)|| ',' , /*wait io*/\n    || format(QWACAWTL,6,0)|| ',' , /*wait locks */\n    || format(QWACAWTR,6,0)|| ',' , /*wait oth. read */\n    || format(QWACAWTW,6,0)|| ',' , /*wait oth write */\n    || format(QWACAWTE,6,0)|| ',' , /*wait sync*/\n    || format(QWACAWLH,6,0)|| ',' , /*wait latch */\n    || format(QWACAWLG,6,0)|| ',' , /*wait log */\n    || format(QWACALBW,6,0)|| ',' , /*wait lob */\n    || format(QWACAACW,6,0)|| ',' , /*wait accelerator*/\n    || format(QWACAWTP,6,0)|| ',' , /*wait page latch */\n    || format(QWACAWTG,6,0)|| ',' , /*wait messages other members */\n    || format(QWACAWTJ,6,0)|| ',' , /*wait global locks */\n    || getp      || ','   ,\n    || syncio    || ','   ,\n    || BufUpd    || ','   ,\n    || syncwr    || ','   ,\n    || sprfreq   || ','   ,\n    || lprfreq   || ','   ,\n    || dprfreq   || ','   ,\n    || sio       || ','   ,\n    || selects   || ','   ,\n    || inserts   || ','   ,\n    || updates   || ','   ,\n    || deletes   || ','   ,\n    || opens     || ','   ,\n    || fetchs    || ','   ,\n    || strip(QWHDRQNM,'T')  || ','   ,\n    || strip(QWHDSVNM,'T')   || ','   ,\n    || strip(QWHDPRID,'T')   || ','   ,\n    || strip(QWHCEUID,'T')   || ','   ,\n    || strip(QWHCEUWN,'T')\n\n   \"EXECIO\" queued() \"DISKW OUFL\"\n\n   if QWHDRQNM > '' then do\n    /*  say 'ddf:' QWHDRQNM QWHDPRID qwhccv */\n   end\n   if summary='Y' then call process_summary\nreturn\n\nprocess_summary:\n   hour = left(run_fmt_time,2)\n   /* pas de rupture pour le 1er record lu */\n   if rupture = 0\n   then do\n       rupture=1\n       occ=0\n       s_hour=hour\n       s_qwhcplan=qwhcplan\n       s_jobn=jobn\n       s_conntype=conntype\n   end\n/* say 'test rupture'  reci */\n/* say s_hour hour          */\n/* say s_qwhcplan qwhcplan  */\n/* say s_jobn jobn          */\n/* say s_conntype conntype  */\n   /* detection rupture,declenche ecriture*/\n   if   hour <>  s_hour   | ,\n        conntype <> s_conntype | ,\n   strip(qwhcplan)||strip(jobn) <> strip(s_qwhcplan)||strip(s_jobn)\n   then do\n       call write_summary\n       sm_tcb_time  =  tcb_time\n       sm_QWACAJST  =  QWACAJST\n       sm_getp      =  getp\n       sm_BufUpd    =  BufUpd\n       sm_syncio    =  syncio\n       sm_syncwr    =  syncwr\n       sm_sprfreq   =  sprfreq\n       sm_lprfreq   =  lprfreq\n       sm_dprfreq   =  dprfreq\n       sm_sio       =  sio\n       sm_selects   =  selects\n       sm_inserts   =  inserts\n       sm_updates   =  updates\n       sm_deletes   =  deletes\n       sm_opens     =  opens\n       sm_fetchs    =  fetchs\n       occ=1\n\n   end\n   /*pas de rupture , on accumule les valeurs */\n   else do\n          sm_tcb_time  =  tcb_time + sm_tcb_time\n          sm_QWACAJST  =  QWACAJST + sm_QWACAJST\n          sm_getp      =  getp     + sm_getp\n          sm_BufUpd    =  BufUpd   + sm_BufUpd\n          sm_syncio    =  syncio   + sm_syncio\n          sm_syncwr    =  syncwr   + sm_syncwr\n          sm_sprfreq   =  sprfreq  + sm_sprfreq\n          sm_lprfreq   =  lprfreq  + sm_lprfreq\n          sm_dprfreq   =  dprfreq  + sm_dprfreq\n          sm_sio       =  sio      + sm_sio\n          sm_selects   =  selects  + sm_selects\n          sm_inserts   =  inserts  + sm_inserts\n          sm_updates   =  updates  + sm_updates\n          sm_deletes   =  deletes  + sm_deletes\n          sm_opens     =  opens    + sm_opens\n          sm_fetchs    =  fetchs   + sm_fetchs\n          occ = occ + 1\n   end/*pas de rupture , on accumule les valeurs */\n\n   /* dans tous les cas , on sauvegarde les valeurs */\n   /*s_sm101sid = sm101sid  */\n   /*s_sm101ssi = sm101ssi  */\n   /*s_sm101dte = sm101dte  */\n   hour = left(run_fmt_time,2)\n   s_hour = hour\n   s_run_fmt_time = run_fmt_time\n   s_qwhccv = qwhccv\n   s_qwhccn = qwhccn\n   s_qwhcplan =  qwhcplan\n   s_conntype = conntype\n   s_jobn  =jobn\n\n   return\n\nwrite_summary:\n     queue sm101sid || ',' || sm101ssi || ','  ,\n     || sm101dte || ','   ,\n     || s_hour || ','   ,\n     || s_qwhcplan               || ','   ,\n     || s_jobn                || ','   ,\n     || s_conntype          || ','   ,\n     || occ                 || ','   ,\n     || sm_tcb_time  || ','   ,\n     || sm_QWACAJST  || ','   ,    /*cl2cpu*/\n     || sm_getp      || ','   ,\n     || sm_syncio    || ','   ,\n     || sm_BufUpd    || ','   ,\n     || sm_syncwr    || ','   ,\n     || sm_sprfreq   || ','   ,\n     || sm_lprfreq   || ','   ,\n     || sm_dprfreq   || ','   ,\n     || sm_sio       || ','   ,\n     || sm_selects   || ','   ,\n     || sm_inserts   || ','   ,\n     || sm_updates   || ','   ,\n     || sm_deletes   || ','   ,\n     || sm_opens     || ','   ,\n     || sm_fetchs\n\n    \"EXECIO\" queued() \"DISKW OUFS\"\n   return\n\ninit_sum:\n   sm_tcb_time = 0\n   sm_QWACAJST = 0\n   sm_getp     = 0\n   sm_BufUpd   = 0\n   sm_syncio   = 0\n   sm_syncwr   = 0\n   sm_sprfreq  = 0\n   sm_lprfreq  = 0\n   sm_dprfreq  = 0\n   sm_sio      = 0\n   sm_selects   =0\n   sm_inserts   =0\n   sm_updates   =0\n   sm_deletes   =0\n   sm_opens     =0\n   sm_fetchs    =0\n   return\n\nSTCK2Local:\n    /* Store Clock Value Time to Local Time */\n    arg clock\n    clock = SPACE(clock,0)\n    cvt     = C2X(STORAGE(10,4))\n    cvttz_p = D2X(X2D(cvt) + X2D(130))\n    tzo     = STORAGE(cvttz_p,4)\n    tzo     = C2D(tzo,4)*1.048576\n    tzo     = (tzo+.5)%1\n    ndigits = MAX(6,1.2*LENGTH(clock)+1)%1\n    Numeric Digits ndigits\n    clock   = x2d(clock)*1.048576 / 16**(LENGTH(clock)-8)\n    clock   = clock + tzo\n    If clock < 0  Then Parse Value 0      0     ,\n                             With  clock  tzo\n    seconds = clock // (24*60*60)\n    hours   = RIGHT( seconds %3600    ,2,'0')\n    minutes = RIGHT((seconds//3600)%60,2,'0')\n    seconds = substr(TRANSLATE(FORMAT(seconds//60,2),'0',' '),1,2)\n    /* t1      = y'/'m'/'d hours':'minutes':'seconds   */\n    LocalTime=  hours':'minutes':'seconds\n    return\nrecord_ifcid:\n   found=0\n   do i = 1 to nbr_ifcid\n      if ifcid_st.i = ifcid then\n         do\n            found=1\n            ifcid_count.i=ifcid_count.i+1\n            leave\n         end\n   end\n   /* not found : add new ifcid to list*/\n   if found=0 then\n      do\n         nbr_ifcid = nbr_ifcid + 1\n         ifcid_st.nbr_ifcid = ifcid\n         ifcid_count.nbr_ifcid = 1\n      end\n   return\nreport_ifcid:\n  say ' '\n  say 'List of IFCIDS read in this SMF file :' nbr_ifcid\n  say 'IFCID/Description/Count'\n  do i=1 to nbr_ifcid\n      Select\n           When ifcid_st.i = 03 then\n                      ifcid_desc='Gen. Accounting data - processed'\n           When ifcid_st.i = 04 then\n                      ifcid_desc='Trace stop'\n           When ifcid_st.i = 05 then\n                      ifcid_desc='Trace stop'\n           When ifcid_st.i = 22 then\n                      ifcid_desc='Mini Bind'\n           When ifcid_st.i = 53 then\n                      ifcid_desc='SQL Desc/Comm/Rollb/Remote Stmt'\n           When ifcid_st.i = 58 then\n                      ifcid_desc='End SQL'\n           When ifcid_st.i = 59 then\n                      ifcid_desc='Start Fetch'\n           When ifcid_st.i = 63 then\n                      ifcid_desc='SQL text'\n           When ifcid_st.i = 64 then\n                      ifcid_desc='Prepare Start'\n           When ifcid_st.i = 65 then\n                      ifcid_desc='Open cursor'\n           When ifcid_st.i = 66 then\n                      ifcid_desc='Close cursor'\n           When ifcid_st.i = 90 then\n                      ifcid_desc='Start Command'\n           When ifcid_st.i = 95 then\n                      ifcid_desc='Sort start'\n           When ifcid_st.i = 96 then\n                      ifcid_desc='Sort stop'\n           When ifcid_st.i = 105 then\n                      ifcid_desc='DBDID OBID translat'\n           When ifcid_st.i = 106 then\n                      ifcid_desc='System init parms'\n           When ifcid_st.i = 112 then\n                      ifcid_desc='Thread alloc'\n           When ifcid_st.i = 172 then\n                      ifcid_desc='DeadLock, timeout'\n           When ifcid_st.i = 173 then\n                      ifcid_desc='CL2 time'\n           When ifcid_st.i = 177 then\n                      ifcid_desc='Pkg alloc'\n           When ifcid_st.i = 196 then\n                      ifcid_desc='Timeout data'\n           When ifcid_st.i = 239 then\n                      ifcid_desc='Package Accounting data'\n           When ifcid_st.i = 254 then\n                      ifcid_desc='CF structure cache stats'\n           When ifcid_st.i = 258 then\n                      ifcid_desc='Dataset extend activity'\n           When ifcid_st.i = 313 then\n                      ifcid_desc='Uncomm. UR'\n           When ifcid_st.i = 337 then\n                      ifcid_desc='Lock Escalation'\n           When ifcid_st.i = 350 then\n                      ifcid_desc='SQL text'\n           When ifcid_st.i = 401 then\n                      ifcid_desc='Static SQL stats'\n           otherwise\n                      ifcid_desc='Unknow'\n\n      end   /* select */\n     say ifcid_st.i  ifcid_desc ifcid_count.i\n   end /* end do */\n   say ' '\n   return\nx_time:\n  arg time8\n  time8    = X2D(SUBSTR(time8,1,13))\n  time8     = time8/1000000\n  return time8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "S102CSV": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x007\\x01\\x16%o\\x01\\x18\\x06_\\x18%\\x062\\x041\\x00\\x00\\xe6\\xe2\\xe8\\xd5\\xc7\\xe4\\xc4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-09-12T00:00:00", "modifydate": "2018-03-06T18:25:37", "lines": 1586, "newlines": 1073, "modlines": 0, "user": "WSYNGUD"}, "text": "/* this REXX can be used to trap DB2 commands submitted on a DB2  */\n/* or trace all the SQL statement with Host variable Input values.*/\n/* It is very useful if you can't get SQL statement text trace    */\n/* from your monitor (site limitations ...)                       */\n/* Of course, you have to start the appropriate trace, see below  */\n/*                                                                */\n/*Rexx*/\nnumeric digits 15\n/*-------------------------------------------------------------*/\n/* Extract smf 102 records - written by Nguyen Duc Tuan        */\n/*                                      ndt.db2\u00e0gmail.com      */\n/* These IFCIDs are available only in Performance trace        */\n/*   4 may 2016     Release 1.0                                */\n/*  12 Aug 2016     Release 2.0 Process SQL Stmt               */\n/*  29 Nov 2016     Release 2.1 Process IFCID 366              */\n/*  13 Apr 2017     Release 2.2 Process IFCID 376 & update 366 */\n/*                  IFCID376 is just an aggregated version of  */\n/*                  IFCID366 , the mapping is identical        */\n/*-------------------------------------------------------------*/\n/*-------------------------------------------------------------*/\n/*Comment : Change datasets high level identifier              */\n/*Notes : Ifcid 63 (sql text) is available only for dynamic sql*/\n/*        (Spufi or Rexx for example)                          */\n/*        For static SQL, there is no ifcid 350 or 63 produced */\n/*        it seems that for static SQL, stmtno is provided and */\n/*        we have to go to syspackstmt to get the SQL text     */\n/*        Ifcid 53 is the ifcid to get sqlcode                 */\n/*        Ifcid 58 is produced only for dynamic SQL (DESCRIBE) */\n/*-------------------------------------------------------------*/\nARG hlq modex   /*PROCESS THIS DB2 SUBSYS ONLY */\n\ndb2_cmd='N'       /* process ifcid 090 DB2 cmd ? */\n/* -STA TRACE(PERFM) DEST(SMF) CLASS(30) IFCID(90) */\n/* -STA TRACE(PERFM) DEST(SMF) CLASS(30) IFCID(108,109) */\nBind      ='N'    /* process ifcid 108/109 : Bind operations ? */\n/* -STA TRACE(PERFM) DEST(SMF) CLASS(30) IFCID(108,109) */\nStmt_cache='N'  /* process stmt_cache ? IFCID 316,317,318,400,401 */\nsql_text  ='N'    /* process Sql statement IFCID 63,64,247  */\n/* Ifcid 53 and 58 is for sqlca (in particular sqlcode) */\n/* -STA TRACE(PERFM) DEST(SMF) AUTHID(WSYNGUD) CLASS(30) IFCID(63,64,2\n   47,53,58)*/\nIFC366='N'        /* process ifcid 366 Built in Function report */\nIFC376='N'        /* process ifcid 376 Unsupported fonctions    */\nIFC224='N'        /* process ifcid 224 invalids xproc */\nIFC342='N'        /* process ifcid 342 workfile usage */\nselect\n    when modex = 'CMD'    then db2_cmd='Y'\n    when modex = 'BIND'   then Bind='Y'\n    when modex = 'STMTC'  then Stmt_cache='Y'\n    when modex = 'SQLTXT' then sql_text='Y'\n    when modex = 'IFC366' then IFC366='Y'\n    when modex = 'IFC376' then IFC376='Y'\n    when modex = 'IFC224' then IFC224='Y'\n    when modex = 'IFC342' then IFC342='Y'\n    otherwise  do\n         say 'Missing or wrong argument :' modex\n         exit 8\n       end\nend /* end select */\nsay ' '\nsay 'Processing for SMF102 - All subsystems'\n\nrepSQL = 'N'\nif stmt_cache = 'Y' | sql_text = 'Y' then repSQL = 'Y'\nrepIncompat = 'N'\nif IFC376     = 'Y' | IFC366   = 'Y' then repIncompat = 'Y'\n\ncall alloc_file\n/* init compteurs divers */\ncall init_var\n/* WRITE report header */\nCALL write_header\n\n/* START PROCESSING */\nDO FOREVER\n  /* read SMF record one by one   */\n  \"EXECIO 1 DISKR INP\"\n  IF RC > 0 THEN DO\n            if rc =  2 then\n             do\n              SAY ''\n              SAY 'End of input SMF file rc=' RC\n              rcalloc = rc\n             end\n             else do\n              SAY ''\n              SAY 'Error while reading SMF file rc=' RC\n              rcalloc = 8\n             end\n              leave\n            END\n  PARSE PULL INPUT_REC\n  reci=reci+1\n  OFFSET = 1\n  /* Decode SMF header */\n  CALL DSNDQWST\n  /* record SMF records period   */\n  if min_time > run_fmt_time then min_time=run_fmt_time\n  if max_time < run_fmt_time then max_time=run_fmt_time\n\n  /* process only smf102 */\n  IF (sm102RTY = 102    ) THEN\n  DO\n    recs=recs+1\n    /*sauvegarde offset_self car on le reutilise */\n    offset_selfdef= offset\n    /* Get   pointer to product section */\n    offset = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n      temp   = offset_selfdef+4\n      prod_len = C2D(SUBSTR(INPUT_REC,temp,2))\n      temp=temp+2\n      prod_rep = C2D(SUBSTR(INPUT_REC,temp,2))\n    offset = offset - 4 + 1\n    /* Process product section*/\n    Call DSNDQWHS\n    offset=offset_selfdef\n    /* record all ifcid in smf for analysis : unexploited data ? */\n    call record_ifcid\n\n    Select\n         When ifcid     = 53 & sql_text = 'Y' then\n                            Do\n                                say 'process IFCID 53'\n                                /* SQLCA most used */\n                                CALL QW0058\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 58 & sql_text = 'Y' then\n                            Do\n                                say 'process IFCID 58'\n                                /* SQLCA     */\n                                CALL QW0058\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 63 & sql_text = 'Y' then\n                            Do\n                                say 'process IFCID 63'\n                                /* SQL stmt - dynamic SQL */\n                                CALL QW0063\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 247 & sql_text = 'Y' then\n                            Do\n                                say 'process IFCID 247'\n                                /* Host Var  */\n                                CALL QW0247\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 350 & sql_text = 'Y' then\n                            Do\n                                /* Long sql text - dynamic */\n                                CALL QW0350\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 366 & IFC366   = 'Y' then\n                            Do\n                                /* Incompatible functions usage */\n                                CALL QW0366\n                                call Write_IFC366\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 376 & IFC376   = 'Y' then\n                            Do\n                                /* Incompatible functions usage */\n                                CALL QW0366\n                                call Write_IFC366\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 224 & IFC224   = 'Y' then\n                            Do\n                                /* Invalid XProc  */\n                                CALL QW0224\n                                call Write_IFC224\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 90 & db2_cmd = 'Y' then\n                            Do\n                                /* get command text */\n                                CALL QW0090\n                                /* get authid and the rest */\n                                call DSNDQWHC\n                                /*write report */\n                                call Write_REPCMD\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 108 & Bind = 'Y' then\n                            Do\n                                /* get Bind details */\n                                CALL QW0108\n                                /* get authid and the rest */\n                                call DSNDQWHC\n                                /*write report */\n                                call Write_REPBnd\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 109 & Bind = 'Y' then\n                            Do\n                                /* get Bind Return code */\n                                CALL QW0109\n                                /* get authid and the rest */\n                                call DSNDQWHC\n                                /*write report */\n                                call Write_REPBNDRC\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 401 & stmt_cache = 'Y' then\n                            Do\n                                /* get static SQL stats*/\n                                CALL init_sql\n                                CALL QW0401\n                                /*write report */\n                                call write_RepSql\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 316 & stmt_cache = 'Y' then\n                            Do\n                                /* get dynamic SQL stats*/\n                                CALL init_sql\n                                CALL QW0316\n                                /*write report */\n                                call write_RepSql\n                                OFFSET = offset_save\n                            end\n         When ifcid     = 342 & IFC342   = 'Y' then\n                            Do\n                                /* get workfile usage  stats*/\n                                CALL QW0342\n                                /*write report */\n                                call write_IFC342\n                                OFFSET = offset_save\n                            end\n         otherwise\n                do\n                     nop\n                  /* say 'ifcid' ifcid 'not processed' */\n                end\n    end   /* select */\n\n  END /*    IF SM102RTY = 102  */\nEND\ncall close_all\n\nsay \"Input records =\" reci\nsay \"Output records=\" reco\nsay 'SMF period : ' min_time \"/\" max_time\n\ncall report_ifcid\n/*-------------------------------------------------*/\n/* F20 End of program display counters and figures */\n/*-------------------------------------------------*/\n\nEXIT rcalloc\n\n/*---------------------------------------*/\n/* End of program body- Routines section */\n/*---------------------------------------*/\n\n\nQW0090:\nnumeric digits 15\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 090 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       QW0090LN =c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d +2\n       QW0090CT = SUBSTR(INPUT_REC,OFFSET_d,qw0090ln-2)\n  return\nQW0108:\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 108 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* plan name if applicable */\n       QW0108PN =SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +8 +2\n       /* Bind type */\n       QW0108T  = SUBSTR(INPUT_REC,OFFSET_d,1)\n       offset_d = offset_d +10\n       /* Owner */\n       QW0108OW = SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +8\n       /* Type  */\n       QW0108TY = SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +8  + 8 + 2 + 16\n       /* Pack. name */\n       QW0108PK = SUBSTR(INPUT_REC,OFFSET_d,36)\n       say 'packname =' QW0108PK\n       offset_d = offset_d + 126 /* real len of pack name*/\n  return\nQW0109:\nnumeric digits 15\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 108 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* Return code  */\n       QW0109RC =c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n  return\n\nQW0350:\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 0350 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       offset_d=offset_d+4 /* skip data */\n       say ' '\n       say '---- Begin Long SQL Text ----'\n       /* Total len */\n       QW0350TL =c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n       say '350/Total Len             :' QW0350TL\n       offset_d = offset_d +4\n       QW0350TY = SUBSTR(INPUT_REC,OFFSET_d,2)\n       select\n           when qw0350ty='8000'x then sqltype='Dynamic'\n           when qw0350ty='4000'x then sqltype='Static'\n           otherwise\n           do\n                say 'qw0350ty contents error unexpected value',\n                          qw0350ty\n                exit(8)\n           end\n       end\n       say '350/Sql type              :' sqltype\n       offset_d = offset_d +2\n       /* statement identifier QW0350SI\n       stmtid   =  c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       say '350/stmtid=' stmtid */\n       offset_d = offset_d +8\n       /*Source CCSID */\n       ccsid    = c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       say '350/Original parser CCSID :' ccsid\n       offset_d = offset_d +2\n       /* len of the following */\n       QW0350SPL=  c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       len = QW0350SPL -2\n       offset_d = offset_d +2\n       QW0350SP =      SUBSTR(INPUT_REC,OFFSET_d,len)\n       xx= '350/Sql len/Text          :' len '/' || ,\n                        space(QW0350SP) ||'/'\n       say xx\n  /*   say 'offset_d 350 after stmtid =' offset_d\n       say  'Display Input_Rec below'\n       say  SUBSTR(INPUT_REC,1,100)\n       say  SUBSTR(INPUT_REC,101,100)\n       say  SUBSTR(INPUT_REC,201,100)\n       say  SUBSTR(INPUT_REC,301,100)\n       say  SUBSTR(INPUT_REC,401,100)\n       say  SUBSTR(INPUT_REC,501,100)\n       say  SUBSTR(INPUT_REC,601,100)\n       say  SUBSTR(INPUT_REC,701,100) */\n  return\nQW0366:\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /* offset_d of the ifcid data for use later*/\n       offset_ifc = offset_d\n       /*offset_d points to the IFCID 0366 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* Function code */\n       QW0366FN =c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n       select\n           when QW0366FN=1 then\n               FnTxt='V9 CHAR(decimal-expr)'\n           when QW0366FN=2 then\n               FnTxt='V9 VARCHAR(decimal-expr)-CAST decimal as CHAR',\n                     '/VARCHAR'\n           when QW0366FN=3 then\n               FnTxt='Unsupported char. string representation ',\n                     'of a timestamp'\n           when QW0366FN=7 then\n               FnTxt='Unsupported Cast because DDF_COMPARTIBILITY ',\n                     'zparm value'\n           when QW0366FN=8 then\n               FnTxt='DDF_COMPARTIBILITY=SP_PARMS_xJV and match ',\n                     'output data is returned'\n           when QW0366FN=9 then\n               FnTxt='TIMEZONE ignored because of',\n                     ' DDF_COMPARTIBILITY zparm value'\n           when QW0366FN=10 then\n               FnTxt='Pre v10 version of  ',\n                     'LTRIM, RTRIM or STRIP has been executed'\n           when QW0366FN=11 then\n               FnTxt='SELECT INTO with UNION UNION ALL EXCEPT ALL ',\n                     'INTERSECT INTERSECT ALL OPERATOR'\n           when QW0366FN=1104 then\n               FnTxt='CLIENT_ACCTNG SPECIAL REGISTER WAS SET FOR ',\n                     'A VALUE NOT SUPPORTED IN V11'\n           when QW0366FN=1105 then\n               FnTxt='CLIENT_APPLNAME SPECIAL REGISTER WAS SET FOR ',\n                     'A VALUE NOT SUPPORTED IN V11'\n           when QW0366FN=1106 then\n               FnTxt='CLIENT_USERID SPECIAL REGISTER WAS SET FOR ',\n                     'A VALUE NOT SUPPORTED IN V11'\n           when QW0366FN=1107 then\n               FnTxt='CLIENT_WRKSTNNAME SPECIAL REGISTER WAS SET FOR ',\n                     'A VALUE NOT SUPPORTED IN V11'\n           when QW0366FN=1109 then\n               FnTxt='CAST string as Timestamp'\n           otherwise\n           do\n               FnTxt =QW0366FN\n           end\n       end\n       offset_d = offset_d +4\n       /* Statement number in the query */\n       QW0366SN =c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n       offset_d = offset_d +4\n       /* Planname */\n       QW0366PL =SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +8\n       /* ConToken */\n       QW0366TS =c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* Statement Id */\n       QW0366SI =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n         /* statement identifier QW0350SI\n         stmtid   =  c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n         say '366/stmtid=' stmtid */\n       /* Statement type */\n       QW0366TY =SUBSTR(INPUT_REC,OFFSET_d,2)\n       offset_d = offset_d +2\n       select\n           when qw0366ty='8000'x then sqltype='Dynamic'\n           when qw0366ty='4000'x then sqltype='Static'\n           otherwise\n           do\n                say 'qw0366ty contents error unexpected value',\n                          qw0366ty\n                exit(8)\n           end\n       end\n       /* Section Number */\n       QW0366SE =c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d +2\n       /* Offset to Collid */\n       QW0366PC_Off =c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       QW0366PC_Off = QW0366PC_Off + offset_ifc\n       offset_d = offset_d +2\n       /* Offset to Package */\n       QW0366PN_Off =c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       QW0366PN_Off = QW0366PN_Off + offset_ifc\n       offset_d = offset_d +2\n       /*Version Len */\n       QW0366VL = c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d +2\n       /*Version  */\n       QW0366VN = SUBSTR(INPUT_REC,OFFSET_d,qw0366VL)\n       /* len of the following */\n       QW0366PC_Len= c2d(SUBSTR(INPUT_REC,QW0366PC_Off,2))\n       offset_d = QW0366PC_Off + 2\n       QW0366PC = SUBSTR(INPUT_REC,OFFSET_d,QW0366PC_Len)\n       /* len of the following */\n       QW0366PN_Len= c2d(SUBSTR(INPUT_REC,QW0366PN_Off,2))\n       offset_d = QW0366PN_Off + 2\n       QW0366PN = SUBSTR(INPUT_REC,OFFSET_d,QW0366PN_Len)\n  return\nQW0342:\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /* offset_d of the ifcid data for use later*/\n       offset_ifc = offset_d\n       /*offset_d points to the IFCID 0342 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* WF type  */\n       QW0342TY = SUBSTR(INPUT_REC,OFFSET_d,4)\n       offset_d = offset_d +4\n       /* DBID */\n       QW0342DB = c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d +2\n       /* PSID */\n       QW0342PS = c2d(subSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d +2\n       /* Current space usage in KB */\n       QW0342CT =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* Max     space usage in KB */\n       QW0342MT =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8+16\n       /* Agent token */\n       QW0342AT = c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n  return\nQW0224:\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 0224 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* Nb cols       */\n       QW0224CL =c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n       offset_d = offset_d +4\n       /* Pgm  */\n       QW0224PN =SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +8\n       /* Collid   */\n       QW0224CI =SUBSTR(INPUT_REC,OFFSET_d,18)\n  return\nQW0063:\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 0063 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       offset_d=offset_d+2 /* skip data */\n       QW0063LL =c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d +2\n       QW0063ST = SUBSTR(INPUT_REC,OFFSET_d,QW0063LL-2)\n       say ' '\n       say '---- Begin Dynamic SQL ----'\n       xx= '63/SQL Text             >' ||  space(QW0063ST) || '<'\n       say xx\n       offset_d = offset_d + QW0063LL /* skip statement type*/\n       /* statement identifier QW0063SI\n       stmtid   =  c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       say '63/stmtid=' stmtid */\n       offset_d = offset_d +8\n       /*Source CCSID */\n       ccsid    = c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       say '63/Original parser CCSID :' ccsid\n  /*   say 'offset_d 063 after stmtid =' offset_d\n       say  'Display Input_Rec below'\n       say  SUBSTR(INPUT_REC,1,100)\n       say  SUBSTR(INPUT_REC,101,100)\n       say  SUBSTR(INPUT_REC,201,100)\n       say  SUBSTR(INPUT_REC,301,100)\n       say  SUBSTR(INPUT_REC,401,100)\n       say  SUBSTR(INPUT_REC,501,100)\n       say  SUBSTR(INPUT_REC,601,100)\n       say  SUBSTR(INPUT_REC,701,100) */\n  return\nQW0247:\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 0247 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* location */\n       QW0247LN =SUBSTR(INPUT_REC,OFFSET_d,16)\n       offset_d = offset_d +16\n       /* Collid   */\n       QW0247PC =SUBSTR(INPUT_REC,OFFSET_d,18)\n       say ' '\n       say '---- begin host variable ----'\n       offset_d = offset_d +18\n       /* Package name */\n       QW0247PN =SUBSTR(INPUT_REC,OFFSET_d,18)\n       xx= '247/Collid/Program       :' ,\n                  strip(QW0247PC)|| '/' || strip(qw0247pn)\n       say xx\n       /* Consitency token (Contoken in sysibm.syspackstmt) */\n       offset_d = offset_d +18\n       /* Divers */\n       offset_d = offset_d +8+2\n       /* Number of entries in SQLDA */\n       QW0247NE =c2d(SUBSTR(INPUT_REC,OFFSET_D,2))\n       offset_d = offset_d +2\n       /* Len of each SQLDA entry */\n       QW0247LE =c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d +2+1+1\n       /* Statement number = STMNO in SYSPACKSTMT */\n       QW0247SN = c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n       say '247/STMTNO               :'  qw0247sn\n       offset_d = offset_d + 4\n       offset_d = offset_d + 8 /* H + H + H then 0000x ?? */\n       /* jump Qw0247LN_D Dsect */\n       /* Begin SQLDA entry */\n       /* Data type (defined in SQLTYPE Manual SQL Reference */\n       QW0247TY = c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       select\n           when QW0247TY = 388 then VTYPE='TIME'\n           when QW0247TY = 389 then VTYPE='TIME'\n           when QW0247TY = 392 then VTYPE='TS'\n           when QW0247TY = 393 then VTYPE='TS'\n           when QW0247TY > 403 & QW0247TY < 414 then VTYPE='xLOB'\n           when QW0247TY =448 then VTYPE='VARCHAR'\n           when QW0247TY =449 then VTYPE='VARCHAR'\n           when QW0247TY =452 then VTYPE='CHAR'\n           when QW0247TY =453 then VTYPE='CHAR'\n           when QW0247TY =484 then VTYPE='DEC'\n           when QW0247TY =485 then VTYPE='DEC'\n           when QW0247TY =492 then VTYPE='BINT'\n           when QW0247TY =493 then VTYPE='BINT'\n           when QW0247TY =496 then VTYPE='INT'\n           when QW0247TY =497 then VTYPE='INT'\n           otherwise do\n               say '247/Data type QW0247 not Processed yet' QW0247TY\n               VTYPE='UNKNOWN'\n             end\n       end /* end select */\n       offset_d = offset_d + 2\n       say '247/Datatype/vtype       :',\n                                 qw0247TY '/' vtype\n       if VTYPE = 'DEC' then\n       do\n          /* Precision if Decimal */\n          QW0247LP = c2d(SUBSTR(INPUT_REC,OFFSET_d,1))\n          say '    247/Decimal Precision    :'  qw0247LP\n          offset_d = offset_d + 1\n          /* Scale     if Decimal */\n          QW0247LS = c2d(SUBSTR(INPUT_REC,OFFSET_d,1))\n          say '    247/DEC Scale            :'   qw0247LS\n          offset_d = offset_d + 1\n       end\n       else\n       do\n          offset_d = offset_d + 2\n       end\n       /* skip */\n       offset_d = offset_d + 20\n       /* SQLDA Entry No */\n       QW0247NO = c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n       xx= '247/Entry No/Total       :' qw0247no ||  '/' || qw0247NE\n       say xx\n       offset_d = offset_d + 40\n\n       /* QW0247B DSECT */\n       QW0247LL = c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       offset_d = offset_d + 2\n       xx= '247/Host Var below Text is in Unicode ||'\n       say xx\n       select\n          when  VTYPE = 'VARCHAR' then\n             do\n               len      = c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n               offset_d = offset_d + 2\n               hv       = SUBSTR(INPUT_REC,OFFSET_d,len)\n               xx= '247/Host Var. value/len  >' ,\n                             ||  hv || '<' || len || '/'\n             end\n          when  VTYPE = 'CHAR' then\n            do\n              Null_ind = SUBSTR(INPUT_REC,OFFSET_d,1)\n              if Null_ind = '00'x then  Null_ind = 'N'\n                                  else  Null_ind = 'Y'\n              len   = qw0247ll-2\n              hv    = SUBSTR(INPUT_REC,OFFSET_d+1,len)\n              xx= '247/Null/Host Var. value/Len   :',\n                          ||  null_ind || '>' || hv ||'<'|| len|| '/'\n            end\n          when  VTYPE = 'DEC' then\n            do\n              len   = qw0247ll-2\n              hv       = c2x(SUBSTR(INPUT_REC,OFFSET_d,len))\n              xx= '     247/Host Var. value Hexa/len   >',\n                        ||             hv ||'<'|| len|| '/'\n            end\n          otherwise\n            do\n              len   = qw0247ll-2\n              hv       = SUBSTR(INPUT_REC,OFFSET_d,len)\n              xx= '247/Host Var. value/len        >',\n                        ||             hv ||'<'|| len|| '/'\n            end\n       end /* end select */\n       say  xx\n   /*  say  'INPUT_REC display below'\n       say  SUBSTR(INPUT_REC,1,99 )\n       say  SUBSTR(INPUT_REC,100,099)\n       say  SUBSTR(INPUT_REC,200,099)\n       say  SUBSTR(INPUT_REC,300,099)\n       say  SUBSTR(INPUT_REC,400,099)\n       say  SUBSTR(INPUT_REC,500,099)\n       say  SUBSTR(INPUT_REC,600,099)\n       say  SUBSTR(INPUT_REC,700,099) */\n\n  return\n\nQW0058:\n       /* lot of things in common with IFCID 0247 */\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /*offset_d points to the IFCID 0058 data to process */\n       offset = offset +4\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* location */\n       QW0058LN =SUBSTR(INPUT_REC,OFFSET_d,16)\n       offset_d = offset_d +16\n       /* Collid   */\n       QW0058PC =SUBSTR(INPUT_REC,OFFSET_d,18)\n       say ' '\n       say '---- End SQL ---- ifcid :' ifcid\n       offset_d = offset_d +18\n       /* Package name */\n       QW0058PN =SUBSTR(INPUT_REC,OFFSET_d,18)\n       xx= ifcid || '/Collid/Program       :',\n               strip(QW0058PC) || '/' || strip(qw0058pn)\n       say xx\n       /* Consitency token (Contoken in sysibm.syspackstmt) */\n       offset_d = offset_d +18\n       /* Divers */\n       offset_d = offset_d +8+2\n       /* SQLCA\n       QW0058SQ =    SUBSTR(INPUT_REC,OFFSET_D,136)\n       say '058/SQLCA 1-50           >'|| substr(qw0058sq,1,50)||'<'\n       say '058/SQLCA 51-100         >'|| substr(qw0058sq,51,50)||'<'\n       say '058/SQLCA 101-136        >'|| substr(qw0058sq,101,36)||'<'\n       say '058/SQLCA 101-136        >'|| substr(qw0058sq,101,36)||'<'\n       offset_d = offset_d +136+2 */\n       /* jump to SQLCODE */\n       offset_d = offset_d +8+4\n       sqlcode  =x2d(c2x(SUBSTR(INPUT_REC,OFFSET_d,4)),8)\n       xx= ifcid ||'/Sqlcode              :' sqlcode\n       say xx\n       offset_d = offset_d +4+120\n       /* Statement number  */\n       QW0058SN = c2d(SUBSTR(INPUT_REC,OFFSET_d,4))\n       offset_d = offset_d + 4\n       offset_d = offset_d + 22 + 2\n       /* SQL Type */\n       QW0058TOS= SUBSTR(INPUT_REC,OFFSET_d,1)\n       select\n           when QW0058TOS = '01'x then sqltype='FETCH'\n           when QW0058TOS = '10'x then sqltype='Insert'\n           when QW0058TOS = '11'x then sqltype='SELECT INTO'\n           when QW0058TOS = '20'x then sqltype='UPDATE NONCURSOR'\n           when QW0058TOS = '21'x then sqltype='UPDATE CURSOR'\n           when QW0058TOS = '30'x then sqltype='MERGE'\n           when QW0058TOS = '40'x then sqltype='DELETE NONCURSOR'\n           when QW0058TOS = '41'x then sqltype='DELETE CURSOR'\n           when QW0058TOS = '50'x then sqltype='TRUNCATE'\n           when QW0058TOS = '80'x then sqltype='PREPARE NONCURSOR'\n           when QW0058TOS = '81'x then sqltype='PREPARE CURSOR'\n           when QW0058TOS = '91'x then sqltype='OPEN'\n           when QW0058TOS = 'A1'x then sqltype='CLOSE'\n           otherwise do\n               xx= ifcid||'/SQL type QW0058 not Processed yet',\n                                QW0058TOS\n               sqltype='UNKNOWN'\n             end\n       end /* end select */\n       xx= ifcid||'/Statement number/type:'  qw0058sn || '/' sqltype\n       say xx\n       offset_d = offset_d + 1\n    /* say  'INPUT_REC display below'\n       say  SUBSTR(INPUT_REC,1,99 )\n       say  SUBSTR(INPUT_REC,100,099)\n       say  SUBSTR(INPUT_REC,200,099)\n       say  SUBSTR(INPUT_REC,300,099)\n       say  SUBSTR(INPUT_REC,400,099)\n       say  SUBSTR(INPUT_REC,500,099)\n       say  SUBSTR(INPUT_REC,600,099)\n       say  SUBSTR(INPUT_REC,700,099) */\n\n  return\n\nQW0316:\n       SQLType='DY'\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /* offset_d of the ifcid data for use later*/\n       offset_ifc=offset_d\n       /*offset_d points to the IFCID 316 data to process */\n       offset = offset +4\n       /* length of data section*/\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* How many  data section ?*/\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n\n       /* skip the first 24 bytes*/\n       offset_d = offset_d +24\n       /* nbr users */\n       say 'CurrUsers' suBSTR(INPUT_REC,OFFSET_d,8)\n       CurrUsers = C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n       say 'CurrUsers' CurrUsers\n       offset_d = offset_d +24\n       /* nbr execs */\n       nbr_execs =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr reads */\n       nbr_reads=c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr gp    */\n       nbr_gp =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr examined rows */\n       nbr_ER =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr rows Processed */\n       nbr_pr =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr sorts */\n       nbr_sort =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr ix scans */\n       nbr_ixscan =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr TS scans*/\n       nbr_tsscan =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr Parallel groups created*/\n       nbr_PG =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr buffer sync writes*/\n       nbr_syncwr =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* db2 elapsed   */\n       elapse = c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       elapse   = x2d(substr(elapse,1,13))\n       elapse   = elapse  /1000000\n       /* skip ... */\n       /* pgm name      */\n       offset_d = offset_d +70\n       len=c2d(SUBSTR(INPUT_REC,OFFSET_d,2))\n       pgm_name = SUBSTR(INPUT_REC,OFFSET_d+2,len)\n       offset_d = offset_d +46\n       tran_name = SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +32\n       end_user  = SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +16\n       wrkstation= SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +68\n       table_name= strip(SUBSTR(INPUT_REC,OFFSET_d,8)) || '.' ||,\n                   strip(SUBSTR(INPUT_REC,OFFSET_d+10,8))\n       offset_d = offset_d +32\n       /* db2 cpu (including ziip) */\n       cputime  = c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       cputime  = x2d(substr(cputime,1,13))\n       cputime  = cputime     /1000000\n       offset_d = offset_d +8*7\n       /* RID list failed Limit    */\n       rid_limit= c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* RID list failed Storage  */\n       rid_stor = c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       ssid_sql = SUBSTR(INPUT_REC,OFFSET_d,8)\n       offset_d = offset_d +80+4+8\n       sql_stmt = '\"' || SUBSTR(INPUT_REC,OFFSET_d,64) || '\"'\n       return\nQW0401:\n       SQLType='ST'\n       offset_save=offset\n       /* offset= offset of self definition section*/\n       /* offset= offset + 8 : bypass pointer to Product  Section*/\n       /* Pointer 4 bytes + Len 2 bytes + Repeat factor 2 bytes  */\n       offset=offset+4+2+2 /*pointer to data section 1*/\n       /*take the contents pointed by the offset */\n       offset_d= C2D(SUBSTR(INPUT_REC,OFFSET,4))\n       offset_d=offset_d -4+1\n       /* offset_QW0401 will be used later */\n       /* offset_d of the ifcid data for use later*/\n       offset_ifc=offset_d\n       /*offset_d points to the IFCID 401 data to process */\n       offset = offset +4\n       /* length of data section*/\n       len     = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       offset = offset +2\n       /* How many  data section ?*/\n       repeat  = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n       say 'repeat data section401=' repeat\n       offset = offset +2\n    /*   say 'offset 401/len/rep' offset_d len repeat\n         say 'ifc401='\n         say SUBSTR(INPUT_REC,OFFSET_d,100)\n         say SUBSTR(INPUT_REC,OFFSET_d+101,100)\n         say SUBSTR(INPUT_REC,OFFSET_d+201,100)\n         say SUBSTR(INPUT_REC,OFFSET_d+301,100) */\n       StmtId =C2D(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr execs */\n       nbr_execs =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr reads */\n       nbr_reads =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr gp    */\n       nbr_gp =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr examined rows */\n       nbr_ER =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr rows Processed */\n       nbr_pr =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr sorts */\n       nbr_sort =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr ix scans */\n       nbr_ixscan =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr TS scans*/\n       nbr_tsscan =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr buffer writes*/\n       nbr_syncwr =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* nbr Parallel groups created*/\n       nbr_PG =c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* db2 elapsed   */\n       elapse   = c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       elapse   = x2d(substr(elapse,1,13))\n       elapse   = elapse  /1000000\n       offset_d = offset_d +8\n       /* db2 cpu (including ziip) */\n       cputime  = c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       cputime  = x2d(substr(cputime,1,13))\n       cputime  = cputime /1000000\n       offset_d = offset_d +8\n       /* wait time for sync IO    */\n       wait_sio = c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       wait_sio = x2d(substr(wait_sio,1,13))\n       wait_sio = wait_sio/1000000\n       offset_d = offset_d +8 * 6\n       /* RID list failed Limit    */\n       rid_limit= c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       /* RID list failed Storage  */\n       rid_stor = c2d(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8*6\n       pkg_token= c2x(SUBSTR(INPUT_REC,OFFSET_d,8))\n       offset_d = offset_d +8\n       QW0401CL_Off=C2D(SUBSTR(INPUT_REC,offset_d,2))\n       QW0401CL_Off=QW0401CL_Off + offset_ifc\n       len=C2D(SUBSTR(INPUT_REC,QW0401CL_Off,2))\n       Collid      =SUBSTR(INPUT_REC,QW0401CL_Off+2,len)\n       offset_d = offset_d +2\n       QW0401PK_Off=C2D(SUBSTR(INPUT_REC,offset_d,2))\n       QW0401PK_Off=QW0401PK_Off + offset_ifc\n       len=C2D(SUBSTR(INPUT_REC,QW0401PK_Off,2))\n       /* package name */\n       Pgm_name    =SUBSTR(INPUT_REC,QW0401PK_Off+2,len)\n       offset_d = offset_d +2\n       tunits=SUBSTR(INPUT_REC,offset_d,8)\n       call stck tunits\n       say timestamp  Tsdate tstime\n       offset_d = offset_d +8\n       offset_d = offset_d +10\n       tunits=SUBSTR(INPUT_REC,offset_d,8)\n       call stck tunits\n       say timestamp  Tsdate tstime\n       offset_d = offset_d +8\nreturn\n\n/* MAP  PRODUCT SECTION */\nDSNDQWHS:\n  QWHSLEN = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  /* go to the next prod section header  */\n  if qwhslen < prod_len  then\n              offset_corr = offset + qwhslen\n        else\n              offset_corr = 0\n\n  OFFSET = OFFSET + 2\n  QWHSTYP = C2D(SUBSTR(INPUT_REC,OFFSET,1))\n   /* say 'header len' QWHSLEN, */\n   /*     'header type' QWHSTYP */\n  OFFSET = OFFSET + 2\n  /* QWHSIID DS XL2 IFCID */\n  QWHSIID = C2D(SUBSTR(INPUT_REC,OFFSET,2))\n  IFCID=QWHSIID\n  OFFSET = OFFSET + 2\n  QWHSNSDA =C2D(SUBSTR(INPUT_REC,OFFSET,1))\n  OFFSET = OFFSET + 6\n  /* QWHSSSID DS CL4 SUBSYSTEM NAME */\n  QWHSSSID = SUBSTR(INPUT_REC,OFFSET,4)\n  OFFSET = OFFSET + 47\n  /* QWHSSID MVS NAME */\n  QWHSSID = SUBSTR(INPUT_REC,OFFSET,4)\n  /* TOTAL LENGTH = 86 */\n\n  RETURN\n\n/* correlation header QWHCTYP = 2 */\nDSNDQWHC:\n  QWHCLEN = C2D(SUBSTR(INPUT_REC,offset_corr,2))\n  offset_corr = offset_corr + 2\n  QWHCTYP = C2D(SUBSTR(INPUT_REC,offset_corr,1))\n  /* process type 2 only */\n  if QWHCTYP >< 2 then return\n  /* process type 2 product header */\n  offset_corr = offset_corr + 2\n  /* authid */\n  QWHCAID      = SUBSTR(INPUT_REC,offset_corr,8)\n  offset_corr = offset_corr + 8\n  /* corrid */\n  QWHCCV  = SUBSTR(INPUT_REC,offset_corr,12)\n  offset_corr = offset_corr + 12\n  /* Connid */\n  QWHCCN = SUBSTR(INPUT_REC,offset_corr,8)\n  offset_corr = offset_corr + 8\n  /* Check rex100 which decode more fields from the correlation */\n  /* header */\n  say 'Corr :' SUBSTR(INPUT_REC,offset_corr,100)\n  return\n\nGET_FMT_TIME:\n  RUN_HH = sm102TME % 360000\n  RUN_HH = RIGHT(RUN_HH,2,'0')\n  RUN_MIN = sm102TME % 6000 - RUN_HH*60\n  RUN_MIN = RIGHT(RUN_MIN,2,'0')\n  RUN_SEC = sm102TME % 100 - RUN_HH *3600 - RUN_MIN*60\n  RUN_SEC = RIGHT(RUN_SEC,2,'0')\n  RUN_FMT_TIME = RUN_HH||':'||RUN_MIN||':'||RUN_SEC\n  RETURN\n\nwrite_header:\n  if repIncompat   = 'Y' then\n  do\n    say 'CSV file ' oufC     ' will be produced'\n    queue \"Lpar,ssid,date,time,Hour,\",\n           \"Fntype,StmNo,Plan,StmId,StmType,SectNo,Collid,Pack,\",\n           \"Version,ConToken\"\n\n    \"EXECIO\" queued() \"DISKW OUFC\"\n  end\n  if IFC224  = 'Y' then\n  do\n    say 'CSV file ' oufC     ' will be produced'\n    queue \"Lpar,ssid,date,time,Hour,\",\n           \"NbCols,Collid,Pgm\"\n\n    \"EXECIO\" queued() \"DISKW OUFC\"\n  end\n  if IFC342  = 'Y' then\n  do\n    say 'CSV file ' oufC     ' will be produced'\n    queue \"Lpar,ssid,date,time,Hour,\",\n           \"Type,DBID,PSID,CurKB,MaxKB,AgentTok\"\n\n    \"EXECIO\" queued() \"DISKW OUFC\"\n  end\n  if db2_cmd = 'Y' then\n  do\n    say 'CSV file ' oufC     ' will be produced'\n    queue \"Lpar,ssid,date,time,Hour,\",\n           \"CmdTxt,Authid,Corrid,Connid,\"\n\n    \"EXECIO\" queued() \"DISKW OUFC\"\n  end\n  if Bind    = 'Y' then\n  do\n    say 'CSV file ' oufC     ' will be produced'\n    queue \"Lpar,ssid,date,time,Hour,\",\n           \"PLan,BindType,Owner,Type,Pack,rc,Authid,Corrid,Connid,\"\n\n    \"EXECIO\" queued() \"DISKW OUFC\"\n  end\n  if stmt_cache = 'Y' | sql_text = 'Y' then\n  do\n    say 'CSV file ' oufS     ' will be produced'\n    queue \"Lpar,ssid,date,time,Hour,\",\n       \"Type,Elapse,Cpu,Execs,SyncRead,SyncWwr,GP,ExRows,ProcRows,\",\n       \"Sort,IxScan,TsScan,ParaGrp,\",\n       \"RIDLim,RIDStor,PgmName,Collid,PkgToken,StmtID,\",\n       \"CurrUsrs,TranName,EndUser,WkStation,TbName,SQLTxt,\"\n\n    \"EXECIO\" queued() \"DISKW OUFS\"\n  end\n  return\n\n\nWrite_REPBND:\n if Bind = 'Y' then do\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm102sid  || ',' || sm102ssi || ','  ,\n    || sm102dte     || ','   ,\n    || run_fmt_time || ','   ,\n    || run_hh       || ','   ,\n    || '\"' || strip(QW0108PN) || '\"'     || ','   ,\n    || QW0108T      || ','   ,  /*bind type */\n    || QW0108OW     || ','   ,  /*Owner     */\n    || QW0108TY     || ','   ,  /*Type      */\n    || '\"' || strip(QW0108PK) || '\"'     || ','   ,\n    || ' '          || ','   , /* return code */\n    || QWHCAID      || ','   ,\n    || QWHCCV       || ','   ,\n    || QWHCCN       || ','\n\n   \"EXECIO\" queued() \"DISKW OUFC\"\n end\nreturn\nWrite_REPBNDRC:\n if Bind = 'Y' then do\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm102sid  || ',' || sm102ssi || ','  ,\n    || sm102dte     || ','   ,\n    || run_fmt_time || ','   ,\n    || run_hh       || ','   ,\n    || ' '          || ','   ,\n    || ' '          || ','   ,\n    || ' '          || ','   ,\n    || ' '          || ','   ,\n    || ' '          || ','   ,\n    || QW0109RC    || ','   , /* return code */\n    || QWHCAID      || ','   ,\n    || QWHCCV       || ','   ,\n    || QWHCCN       || ','\n\n   \"EXECIO\" queued() \"DISKW OUFC\"\n end\nreturn\nWrite_IFC366:\n if repIncompat  = 'Y' then do\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm102sid  || ',' || sm102ssi || ','  ,\n    || sm102dte     || ','   ,\n    || run_fmt_time || ','   ,\n    || run_hh       || ','   ,\n    || '\"' || FnTxt || '\"' || ','   ,\n    || QW0366SN     || ','   ,\n    || QW0366PL     || ','   ,\n    || QW0366SI     || ','   ,\n    || sqltype      || ','   ,\n    || QW0366SE     || ','   ,\n    || QW0366PC     || ','   ,\n    || QW0366PN     || ','   ,\n    || QW0366VN     || ','   ,\n    || QW0366TS\n\n   \"EXECIO\" queued() \"DISKW OUFC\"\n end\nreturn\nWrite_IFC224:\n if IFC224  = 'Y' then do\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm102sid  || ',' || sm102ssi || ','  ,\n    || sm102dte     || ','   ,\n    || run_fmt_time || ','   ,\n    || run_hh       || ','   ,\n    || QW0224CL     || ','   ,\n    || strip(QW0224CI)     || ','   ,\n    || strip(QW0224PN) || ','\n\n   \"EXECIO\" queued() \"DISKW OUFC\"\n end\nreturn\nWrite_IFC342:\n if IFC342  = 'Y' then do\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm102sid  || ',' || sm102ssi || ','  ,\n    || sm102dte     || ','   ,\n    || run_fmt_time || ','   ,\n    || run_hh       || ','   ,\n    || QW0342TY     || ','   ,\n    || QW0342DB     || ','   ,\n    || QW0342PS     || ','   ,\n    || QW0342CT     || ','   ,\n    || QW0342MT     || ','   ,\n    || QW0342AT\n\n   \"EXECIO\" queued() \"DISKW OUFC\"\n end\nreturn\nWrite_REPCMD:\n if db2_cmd = 'Y' then do\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm102sid  || ',' || sm102ssi || ','  ,\n    || sm102dte     || ','   ,\n    || run_fmt_time || ','   ,\n    || run_hh       || ','   ,\n    || '\"' || strip(QW0090CT) || '\"'     || ','   ,\n    || QWHCAID      || ','   ,\n    || QWHCCV       || ','   ,\n    || QWHCCN       || ','\n\n   \"EXECIO\" queued() \"DISKW OUFC\"\n end\nreturn\nWrite_RepSQL:\n if repSQL =    'Y'  then do\n    reco= reco+ 1\n    /*rows in excel format */\n    queue sm102sid  || ',' || sm102ssi || ','  ,\n    || sm102dte     || ','   ,\n    || run_fmt_time || ','   ,\n    || run_hh       || ','   ,\n    || SQLType      || ','   ,\n    || Elapse       || ','   ,\n    || Cputime      || ','   ,\n    || nbr_execs    || ','   ,\n    || nbr_reads    || ','   ,\n    || nbr_syncwr   || ','   ,\n    || nbr_gp       || ','   ,\n    || nbr_er       || ','   ,\n    || nbr_pr       || ','   ,\n    || nbr_sort     || ','   ,\n    || nbr_ixscan   || ','   ,\n    || nbr_tsscan   || ','   ,\n    || nbr_pg       || ','   ,\n    || rid_limit    || ','   ,\n    || rid_stor     || ','   ,\n    || pgm_name     || ','   ,\n    || Collid       || ','   ,\n    || pkg_token    || ','   ,\n    || stmtid       || ','   ,\n    || CurrUsers    || ','   ,\n    || tran_name    || ','   ,\n    || end_user     || ','   ,\n    || wrkstation   || ','   ,\n    || table_name   || ','   ,\n    || sql_stmt     || ','\n\n   \"EXECIO\" queued() \"DISKW OUFS\"\n end\nreturn\n\n\n/* SMF HEADER */\nDSNDQWST:\n   OFFSET = OFFSET + 1\n   /* sm102RTY DS XL1 RECORD TYPE X'66' OR 102 */\n   sm102RTY = C2D(SUBSTR(INPUT_REC,OFFSET,1))\n   OFFSET = OFFSET + 1\n   /* sm102TME DS XL4 TIME SMF MOVED RECORD */\n   sm102TME = C2D(SUBSTR(INPUT_REC,OFFSET,4))\n   CALL GET_FMT_TIME\n   OFFSET = OFFSET + 4\n   field    = C2X(SUBSTR(INPUT_REC,OFFSET,4))\n     parse value field with 1 . 2 c 3 yy 5 ddd 8 .\n     if (c = 0) then\n       yyyy = '19'||yy\n     else\n       yyyy = '20'||yy\n   sm102dte    = yyyy||'.'||ddd\n   /* sauvegarde de la date traitee */\n   OFFSET = OFFSET + 4\n   sm102sid = SUBSTR(INPUT_REC,OFFSET,4)\n   OFFSET = OFFSET + 4\n   /* sm102SSI DS CL4 SUBSYSTEM ID */\n   sm102ssi = SUBSTR(INPUT_REC,OFFSET,4)\n   OFFSET = OFFSET + 10\n   /* TOTAL LENGTH = 28 */\n   return\n\nrecord_ifcid:\n   found=0\n   do i = 1 to nbr_ifcid\n      if ifcid_st.i = ifcid then\n         do\n            found=1\n            ifcid_count.i=ifcid_count.i+1\n            leave\n         end\n   end\n   /* not found : add new ifcid to list*/\n   if found=0 then\n      do\n         nbr_ifcid = nbr_ifcid + 1\n         ifcid_st.nbr_ifcid = ifcid\n         ifcid_count.nbr_ifcid = 1\n      end\n   return\nreport_ifcid:\n  say ' '\n  say ' '\n  say 'List of ifcids read in this SMF file :' nbr_ifcid\n  say '   Ifcid/Description/Count'\n  do i=1 to nbr_ifcid\n      Select\n           When ifcid_st.i = 04 then\n                      ifcid_desc='Trace stop'\n           When ifcid_st.i = 05 then\n                      ifcid_desc='Trace stop'\n           When ifcid_st.i = 22 then\n                      ifcid_desc='Mini Bind'\n           When ifcid_st.i = 53 then\n                      ifcid_desc='End SQL-SQLCA - Processed'\n           When ifcid_st.i = 58 then\n                      ifcid_desc='End SQL-SQLCA - Processed'\n           When ifcid_st.i = 59 then\n                      ifcid_desc='Start Fetch'\n           When ifcid_st.i = 63 then\n                      ifcid_desc='SQL text - Processed'\n           When ifcid_st.i = 64 then\n                      ifcid_desc='Prepare Start'\n           When ifcid_st.i = 65 then\n                      ifcid_desc='Open cursor'\n           When ifcid_st.i = 66 then\n                      ifcid_desc='Close cursor'\n           When ifcid_st.i = 90 then\n                      ifcid_desc='Start Command'\n           When ifcid_st.i = 95 then\n                      ifcid_desc='Sort start'\n           When ifcid_st.i = 96 then\n                      ifcid_desc='Sort stop'\n           When ifcid_st.i = 105 then\n                      ifcid_desc='DBDID OBID translat'\n           When ifcid_st.i = 106 then\n                      ifcid_desc='System init parms'\n           When ifcid_st.i = 108 then\n                      ifcid_desc='Start Bind - Processed'\n           When ifcid_st.i = 109 then\n                      ifcid_desc='End Bind - Processed '\n           When ifcid_st.i = 112 then\n                      ifcid_desc='Thread alloc'\n           When ifcid_st.i = 172 then\n                      ifcid_desc='DeadLock, timeout'\n           When ifcid_st.i = 173 then\n                      ifcid_desc='CL2 time'\n           When ifcid_st.i = 177 then\n                      ifcid_desc='Pkg alloc'\n           When ifcid_st.i = 196 then\n                      ifcid_desc='Timeout data'\n           When ifcid_st.i = 224 then\n                      ifcid_desc='Invalid SPROC - Processed'\n           When ifcid_st.i = 247 then\n                      ifcid_desc='Host variables - Processed'\n           When ifcid_st.i = 254 then\n                      ifcid_desc='CF structure cache stats'\n           When ifcid_st.i = 258 then\n                      ifcid_desc='Dataset extend activity'\n           When ifcid_st.i = 313 then\n                      ifcid_desc='Uncomm. UR'\n           When ifcid_st.i = 316 then\n                      ifcid_desc='DSC stats -Processed'\n           When ifcid_st.i = 337 then\n                      ifcid_desc='Lock Escalation'\n           When ifcid_st.i = 342 then\n                      ifcid_desc='Workfile Usage'\n           When ifcid_st.i = 350 then\n                      ifcid_desc='SQL text (log) - Processed'\n           When ifcid_st.i = 366 then\n                      ifcid_desc='Incompat.funct.exec. - Processed'\n           When ifcid_st.i = 376 then\n                      ifcid_desc='Incompat.funct.exec. - Processed'\n           When ifcid_st.i = 401 then\n                      ifcid_desc='Static SQL stats - Processed'\n           otherwise\n                      ifcid_desc='Unknow'\n\n      end   /* select */\n     xx= '   ' || ifcid_st.i ||'/'||ifcid_desc||'/' ||ifcid_count.i\n     say xx\n   end /* end do */\n   return\ninit_var:\n  /* compteurs input/output */\n  nbr_ifcid = 0\n  reco= 0\n  reci= 0\n  recs= 0\n  min_time='23:59:59'\n  if repSQL =    'Y'  then call init_sql\n  return\ninit_sql:\n    StmtId =-1\n    CurrUsers=-1\n    tran_name='NA'\n    end_user='NA'\n    wrkstation='NA'\n    table_name='NA'\n    sql_stmt='NA'\n    pkg_token='NA'\n    collid='NA'\n  return\n\nalloc_file:\n  /* Input file : SMF extract sorted\n  oufl = hlq || '.SMFEXTP'\n     Input file\n   \"ALLOC DD(INP) SHR  bufno(20)\" */\n  if db2_cmd = 'Y' then\n  do\n       oufl = \"'\" || hlq || '.REPORT' || \"'\"\n       \"DELETE\" oufl \"PURGE\"\n\n       \"ALLOC DD(OUFC) DS(\"OUFl\") NEW CATALOG REUSE\" ,\n       \"LRECL(300) RECFM(V B) TRACKS SPACE(50,50)\"\n       rcalloc = rc\n       if rcalloc <> 0 then Do\n            say \"**********************************************\"\n            say \"   Error allocating REPCMD file\" rcalloc\n            say \"   Abnormal end  \"\n            say \"**********************************************\"\n            Exit 8\n       end\n  end /* db2_cmd = 'Y' */\n  if IFC224  = 'Y' then\n  do\n       oufl = \"'\" || hlq || '.IFC224' || \"'\"\n       \"DELETE\" oufl \"PURGE\"\n\n       \"ALLOC DD(OUFC) DS(\"OUFl\") NEW CATALOG REUSE\" ,\n       \"LRECL(300) RECFM(V B) TRACKS SPACE(50,50)\"\n       rcalloc = rc\n       if rcalloc <> 0 then Do\n            say \"**********************************************\"\n            say \"   Error allocating IFC224 file\" rcalloc\n            say \"   Abnormal end  \"\n            say \"**********************************************\"\n            Exit 8\n       end\n  end /* IFC224  = 'Y' */\n  if IFC342  = 'Y' then\n  do\n       oufl = \"'\" || hlq || '.IFC342' || \"'\"\n       \"DELETE\" oufl \"PURGE\"\n\n       \"ALLOC DD(OUFC) DS(\"OUFl\") NEW CATALOG REUSE\" ,\n       \"LRECL(200) RECFM(V B) TRACKS SPACE(50,50)\"\n       rcalloc = rc\n       if rcalloc <> 0 then Do\n            say \"**********************************************\"\n            say \"   Error allocating IFC342 file\" rcalloc\n            say \"   Abnormal end  \"\n            say \"**********************************************\"\n            Exit 8\n       end\n  end /* IFC342  = 'Y' */\n  if repIncompat  = 'Y' then\n  do\n       oufl = \"'\" || hlq || '.IFC3X6'  || \"'\"\n       \"DELETE\" oufl \"PURGE\"\n\n       \"ALLOC DD(OUFC) DS(\"OUFl\") NEW CATALOG REUSE\" ,\n       \"LRECL(300) RECFM(V B) TRACKS SPACE(50,50)\"\n       rcalloc = rc\n       if rcalloc <> 0 then Do\n            say \"**********************************************\"\n            say \"   Error allocating IFC3X6 file\" rcalloc\n            say \"   Abnormal end  \"\n            say \"**********************************************\"\n            Exit 8\n       end\n  end /* IFC3X6  = 'Y' */\n  if Bind    = 'Y' then\n  do\n       oufl = \"'\" || hlq || '.REPORT.BND' || \"'\"\n       \"DELETE\" oufl \"PURGE\"\n\n       \"ALLOC DD(OUFC) DS(\"OUFl\") NEW CATALOG REUSE\" ,\n       \"LRECL(300) RECFM(V B) TRACKS SPACE(50,50)\"\n       rcalloc = rc\n       if rcalloc <> 0 then Do\n            say \"**********************************************\"\n            say \"   Error allocating REPCMD file\" rcalloc\n            say \"   Abnormal end  \"\n            say \"**********************************************\"\n            Exit 8\n       end\n  end /* Bind    = 'Y' */\n\n  if repSQL =    'Y'  then\n  do\n       /* Report dataset on output */\n       oufs = \"'\" || hlq || '.REPORT.SQL' || \"'\"\n       \"DELETE\" oufS \"PURGE\"\n\n       \"ALLOC FI(OUFs) DA(\"oufs\") NEW CATALOG REUSE\" ,\n       \"LRECL(300) RECFM(V B) TRACKS SPACE(50,50)\"\n       rcalloc = rc\n       if rcalloc <> 0 then Do\n            say \"**********************************************\"\n            say \"   Error allocating repSQL file\" rcalloc\n            say \"   Abnormal end  \"\n            say \"**********************************************\"\n            Exit 8\n       end\n  end /* stmt_cache    */\n\n  RETURN\nclose_all:\n  if repSQL =    'Y'  then\n  do\n    \"EXECIO\" queued() \"DISKW OUFs ( FINIS\"\n    \"FREE DD(OUFs)\"\n  end\n  if db2_cmd='Y' then\n  do\n    \"EXECIO\" queued() \"DISKW OUFC ( FINIS\"\n    \"FREE DD(OUFC)\"\n  end\n  \"EXECIO 0 DISKR oufi (STEM INL. FINIS\"\n  \"FREE DD(oufi)\"\n  return\nstck:\nArg TUNITS\n  TIMESTAMP = Copies(0,26)  /* force result length=26 */\n  Address linkpgm \"BLSUXTOD TUNITS TIMESTAMP\"\n  /* variable Timestamp has the value of timestamp */\n  TSDate=substr(timestamp,1,10)\n  TSTime=substr(timestamp,12,08)\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "S110CSV": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00&\\x01\\x16\\x18_\\x01\\x17\\x12O\\x18\\x16\\x01O\\x00\\xbb\\x00\\x00\\xe6\\xe2\\xe8\\xd5\\xc7\\xe4\\xc4@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2016-07-03T00:00:00", "modifydate": "2017-05-04T18:16:26", "lines": 335, "newlines": 187, "modlines": 0, "user": "WSYNGUD"}, "text": "/* REXX ***************************************************************/\n/*                                                                    */\n/*  Author:  Duc Tuan Nguyen                                          */\n/*  Email :  dt n <ndt2004@gmail.com>                                 */\n/*                                                                    */\n/*              REXX TO CREATE A CSV DATASET FROM SMF110              */\n/*                     (CICS PERFORMANCE RECORDS)                     */\n/*                                                                    */\n/*  This rexx reads the unloaded dataset written from the standard    */\n/*  program DFH$MOLS WHICH PRINTS SMF110 CICS PERFORMANCE RECORD.     */\n/*                                                                    */\n/*  The output of DFH$MOLS unfortunately is not easy for analysis.    */\n/*                                                                    */\n/*  This Rexx provide a CSV dataset (I like Excel), with Transaction  */\n/*  ID, ELAPSED AND CPU TIME ASSOCIATED WITH THE NUMBER OF DB2        */\n/*  requests. This is useful to have quickly a performance indicator  */\n/*  of your information system to compare (which is mainly CICS and   */\n/*  DB2 ...). As SMF110 includes DB2 time, all your consumption is    */\n/*  here.                                                             */\n/*                                                                    */\n/*  More detailed than SMF30                                          */\n/*  More convenient than SMF101 (in my shop SMF101 is not collected   */\n/*  for CICS transactions because it is really huge)                  */\n/*                                                                    */\n/*  Prereq : Execute DFHMNDUP then DFH$MOLS with the UNLOAD option    */\n/*                                                                    */\n/*Rexx*/\nnumeric digits 15\n/*-------------------------------------------------------------*/\n/* Report Transaction performance Data                         */\n/* Validated for CICS TS 5.3                                   */\n/* Extract smf 110 records output from dfh$mols unload file    */\n/*                                      ndt.db2\u00e0gmail.com      */\n/*  10 Jun 2016     Release 1.0  for CICS 5.2                  */\n/*  23 Nov 2016     Release 1.1  for CICS 5.3                  */\n/*-------------------------------------------------------------*/\n/*Comment : Change datasets high level identifier              */\n/*-------------------------------------------------------------*/\nARG  hlq\nreci=0\nreco=0\nmintime='24:60:00'\nmaxtime='00:00:00'\ntotcpu=0\ntotelap=0\ntotdb2r=0\n\n/* Input file : SMF extract sorted */\noufl = hlq || '.report.cicmol'\n\"ALLOC DD(INP) DS('\"oufl\"') ,\n                       SHR REU bufno(20)\"\n\n/* Report dataset on output */\noufl = \"'\" || hlq || '.report.tran' || \"'\"\n\"DELETE\" oufl \"PURGE\"\n\n\"ALLOC FI(OUFL) DA(\"oufl\") NEW CATALOG REUSE\" ,\n\"LRECL(600) RECFM(V B) TRACKS SPACE(600,600)\"\nrcalloc = rc\nif rcalloc <> 0 then Do\n     say \"**********************************************\"\n     say \"   Error allocating Tran Report file\" rcalloc\n     say \"   Abnormal end  \"\n     say \"**********************************************\"\n     Exit 8\nend\n/* WRITE report header */\nCALL write_header\n\n/* START PROCESSING */\nDO FOREVER\n  /* read input */\n  \"EXECIO 1 DISKR INP\"\n  IF RC > 0 THEN DO\n            if rc =  2 then\n             do\n              SAY 'End of Input file rc=' RC\n              rcalloc = rc\n             end\n             else do\n              SAY 'Error while reading Input file rc=' RC\n              rcalloc = 8\n             end\n              leave\n            END\n  PARSE PULL INPUT_REC\n  reci=reci+1\n  Call DECODE\n  Call write_report\nEND\n/* End of processing - close file */\n\"EXECIO\" queued() \"DISKW OUFL ( FINIS\"\nrcwrite = rc\nif rcwrite<> 0 then Do\n   say \"**********************************************\"\n   say \"   Error writting OUFL file: \" rcwrite\n   say \"   Abnormal end   \"\n   say \"**********************************************\"\n   Exit 8\nend\n\"EXECIO 0 DISKR INP (STEM INL. FINIS\"\n\"FREE DD(INP)\"\n\"FREE DD(OUFL)\"\n\nsay \"Input records =\" reci\nsay \"Output records=\" reco\nsay 'Periode processed' tsdate ' betweeen ' mintime maxtime\nsay '    Total Transactions   ' reci\nsay '    Total cpu =          ' totcpu\nsay '    Total Elapsed        ' totelap\nsay '    Total db2requests =  ' totdb2r\n\nEXIT rcalloc\n\n\n/* MAP from dfhsamp(DFHMNPDA) */\ndecode:\n  jobname  = SUBSTR(INPUT_REC,1,8)\n  applid   = SUBSTR(INPUT_REC,9,8)\n  SysId    = SUBSTR(INPUT_REC,25,4)\n  /* ...*/\n\n  TranId   = SUBSTR(INPUT_REC,93,4)\n  UserId   = SUBSTR(INPUT_REC,101,8)\n  /* task start PDRATTT*/\n  tunits   = SUBSTR(INPUT_REC,113,8)\n  call stck tunits\n  startt=tstime\n  startts=tots\n  /* task stop  PDRDETT*/\n  tunits   = SUBSTR(INPUT_REC,121,8)\n  call stck tunits\n  stopt=tstime\n  stopts=tots\n  /* pdrdist/ transaction dispatch time  */\n  offs   = 2329 /* check with the manual corresponding to */\n                /* the CICS version */\n  usrdisp  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrdisp  = x2d(SUBSTR(usrdisp,1,13)) * 0.000001\n  /* pdrcput/ usrcput tcb cpu transaction */\n  offs = offs+12\n  usrcput  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrcput  = x2d(SUBSTR(usrcput,1,13)) * 0.000001\n  /* PDRSUST  User suspend time           */\n  offs = offs+36\n  usrsusp  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrsusp  = x2d(SUBSTR(usrsusp,1,13)) * 0.000001\n  /* PDRDWT   User Dispatch Wait time     */\n  offs = offs+12\n  usrwt    = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrwt    = x2d(SUBSTR(usrwt  ,1,13)) * 0.000001\n  /* PDRQRDSP QR   Dispatch      time     */\n  offs = offs+12\n  usrqrdp  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrqrdp  = x2d(SUBSTR(usrqrdp,1,13)) * 0.000001\n  /* PDRQRCPU QR   CPU           time     */\n  offs = offs+12\n  usrqrcpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrqrcpu = x2d(SUBSTR(usrqrcpu,1,13)) * 0.000001\n  /* PDRMSDSP Other mode Disp    time     */\n  offs = offs+12\n  usrotdp  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrotdp  = x2d(SUBSTR(usrotdp ,1,13)) * 0.000001\n  /* PDRMSCPU Other mode Cpu     time     */\n  offs = offs+12\n  usrotcpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrotcpu = x2d(SUBSTR(usrotcpu,1,13)) * 0.000001\n  /* PDRRODSP RO    mode Disp    time     */\n  offs = offs+12\n  usrROdp  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrROdp  = x2d(SUBSTR(usrrodp ,1,13)) * 0.000001\n  /* PDRROCPU RO    mode Cpu     time     */\n  offs = offs+12\n  usrrocpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrrocpu = x2d(SUBSTR(usrrocpu,1,13)) * 0.000001\n  /* PDRKY8DS Key8  mode Disp    time     */\n  offs = offs+12\n  usrk8dp  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrk8dp  = x2d(SUBSTR(usrk8dp ,1,13)) * 0.000001\n  /* PDRKY8CP Key8  mode Cpu     time     */\n  offs = offs+12\n  usrk8cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrk8cpu = x2d(SUBSTR(usrk8cpu,1,13)) * 0.000001\n  /* PDRKY9DS Key9  mode Disp    time     */\n  offs = offs+12\n  usrk9dp  = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrk9dp  = x2d(SUBSTR(usrk9dp ,1,13)) * 0.000001\n  /* PDRKY9CP Key9  mode Cpu     time     */\n  offs = offs+12\n  usrk9cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrk9cpu = x2d(SUBSTR(usrk9cpu,1,13)) * 0.000001\n  /* PDRL8CPU L8    mode Cpu     time     */\n  offs = offs+12\n  usrl8cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrl8cpu = x2d(SUBSTR(usrl8cpu,1,13)) * 0.000001\n  /* PDRL9CPU L9    mode Cpu     time     */\n  offs = offs+12\n  usrl9cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrl9cpu = x2d(SUBSTR(usrl9cpu,1,13)) * 0.000001\n  /* PDRS8CPU S8    mode Cpu     time     */\n  offs = offs+12\n  usrs8cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrs8cpu = x2d(SUBSTR(usrs8cpu,1,13)) * 0.000001\n  /* PDRX8CPU X8    mode Cpu     time     */\n  offs = offs+12\n  usrx8cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrx8cpu = x2d(SUBSTR(usrx8cpu,1,13)) * 0.000001\n  /* PDRX9CPU X9    mode Cpu     time     */\n  offs = offs+12\n  usrx9cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrx9cpu = x2d(SUBSTR(usrx9cpu,1,13)) * 0.000001\n  /* PDRT9CPU T9    mode Cpu     time     */\n  offs = offs+12\n  usrt9cpu = c2x(SUBSTR(INPUT_REC,offs,8))\n  usrt9cpu = x2d(SUBSTR(usrt9cpu,1,13)) * 0.000001\n\n  /* response time */\n  resp=stopts-startts\n  if resp < 0 then\n  do\n      resp=resp* (-1)\n  end\n  /* sometimes start time is greater than stop time , swap values */\n  if startt > stopt then\n  do\n      m=startt\n      startt=stopt\n      stopt =m\n  end\n  /*          PDRDB2RC db2 requests */\n  offs   = 2133\n  db2reqt  = c2d(SUBSTR(INPUT_REC,offs,4))\n  offs   = offs   + 4\n  mqreqt   = c2d(SUBSTR(INPUT_REC,offs,4))\n  Return\n\nwrite_header:\n  say 'CSV file ' oufl     ' will be produced'\n  queue \"Date,Sysid,Applid,Tran,userid,startt,stopt,Resp,CPU,\",\n        \"DB2req,MQreq,\",\n        \"UsrDisp,\",\n        \"UsrSusp, \" ,\n        \"UsrWait,\" ,\n        \"usrQRdp, \" ,\n        \"usrQRcpu,\" ,\n        \"usrOTdp ,\" ,\n        \"usrOTcpu,\" ,\n        \"usrROdp ,\" ,\n        \"usrROcpu,\" ,\n        \"usrK8dp ,\" ,\n        \"usrK8cpu,\" ,\n        \"usrK9dp ,\" ,\n        \"usrK9cpu,\" ,\n        \"usrL8cpu,\" ,\n        \"usrL9cpu,\" ,\n        \"usrS8cpu,\" ,\n        \"usrX8cpu,\" ,\n        \"usrX9cpu,\" ,\n        \"usrT9cpu\"\n\n  \"EXECIO\" queued() \"DISKW OUFL\"\n  return\n\nwrite_report:\n    if startt < mintime then mintime=startt\n    if stopt  > maxtime then maxtime=stopt\n    totcpu=totcpu + usrcput\n    totdb2r = totdb2r + db2reqt\n    totelap=totelap+resp\n    reco= reco+ 1\n    /*rows in excel format */\n    queue tsdate   || ',' || sysid    || ','  ,\n    || applid   || ','   ,\n    || Tranid       || ','   ,\n    || userid       || ','   ,\n    || '\"' || startt || '\"'           || ','   ,\n    || '\"' || stopt  || '\"'           || ','   ,\n    || resp             || ','   ,\n    || usrcput           || ','   ,\n    || db2reqt        || ','   ,\n    || mqreqt         || ','   ,\n    ||  usrdisp     || ','   ,\n    ||  usrsusp     || ','   ,\n    ||  usrwt       || ','   ,\n    ||  usrqrdp     || ','   ,\n    ||  usrqrcpu    || ','   ,\n    ||  usrotdp     || ','   ,\n    ||  usrotcpu    || ','   ,\n    ||  usrROdp || ','   ,\n    ||  usrROcpu || ','   ,\n    ||  usrk8dp || ','   ,\n    ||  usrk8cpu || ','   ,\n    ||  usrk9dp || ','   ,\n    ||  usrk9cpu || ','   ,\n    ||  usrl8cpu || ','   ,\n    ||  usrl9cpu || ','   ,\n    ||  usrs8cpu || ','   ,\n    ||  usrx8cpu || ','   ,\n    ||  usrx9cpu || ','   ,\n    ||  usrt9cpu\n\n   \"EXECIO\" queued() \"DISKW OUFL\"\nreturn\nstck:\nArg TUNITS\n  TIMESTAMP = Copies(0,26)  /* force result length=26 */\n  Address linkpgm \"BLSUXTOD TUNITS TIMESTAMP\"\n  /* variable Timestamp has the value of timestamp */\n  TSDate=substr(timestamp,1,10)\n  TSTime=substr(timestamp,12,15)\n  hh=substr(tstime,1,2)\n  mm=substr(tstime,4,2)\n  ss=substr(tstime,7,2)\n  cc=substr(tstime,10,6)*0.000001\n  tots=hh*3600+60*60+ss+cc\n  return\n//xxxxxxxx JOB ACCT,MSGCLASS=2,REGION=0M,CLASS=1,NOTIFY=&SYSUID\n/*JOBPARM SYSAFF=*\n//*\n//* INPUT : &HLQ..SMFEXTS (EXTRACT SMF STATS ONLY)\n//*                          VOIR JOB EXTSMF\n//* X'64' = 100\n//*\n// SET HLQ=xxxxxx.yyyyyyy\n//*\n//* INPUT : &HLQ..REPORT.CICMOL\n//* OUTPUT1: &HLQ..REPORT.TRAN\n//* ARGUMENT 1 : PREFIX FOR DATASET NAME (HLQ VALUE)\n//REX110    EXEC PGM=IKJEFT01,DYNAMNBR=5,REGION=0M,COND=(4,LT),\n//    PARM='S110CSV &HLQ'\n//SYSEXEC  DD DISP=SHR,DSN=xxxxx\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT948/FILE948.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT948", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}