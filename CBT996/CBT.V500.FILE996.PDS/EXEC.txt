./ ADD NAME=$$LIB    0101-19004-19004-0957-00001-00001-00000-APLKS   05
     USERID().MYTSO.EXEC
./ ADD NAME=@CUT     0104-14268-14329-1034-00286-00279-00000-APLKS   17
/* --------------------------------------------------------- */
/* Purpose: CUT saves text in a clipboard for PASTE          */
/*                                                           */
/*  Format: CUT < target | range >                           */
/*              < ( options >                                */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*         options:                                          */
/*          APPEND- append lines to the clipboard            */
/*            MOVE- move lines to the clipboard else copy    */
/*   SET or SWitch- point to a different clipboard, the      */
/*                  clipboard ID will follow                 */
/*          suffix- (number) the clipboard ID                */
/* --------------------------------------------------------- */
   Address ISPEXEC 'CONTROL ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG) PROFILE';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');
/* Entering EXEC CUT */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   'MACRO (parm2) NOPROCESS';
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
   If parm2 = '?' | parm2 = 'HELP' | parm2 = 'help' Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   opt. = '';              /* .1 = APPEND(Y/N) .2 = MOVE(Y/N) */
   var. = '';
   cut_cnt = 0;
   clipid = 'CUT00001';

   '(linenbr) = LINENUM .ZLAST';
   trgt_row_eof = linenbr + 1;

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> '' Then;
     Call Extract_OPTIONS;

   Address ISPEXEC 'VGET (CLIPID@@) PROFILE';
   If RC = 0 & clipid@@ <> '' Then;
     clipid = clipid@@;

   file_free = 'FREE F('clipid') ATTR(A1)';
   file_attr = 'ATTR A1 LRECL(255) BLKSIZE(8368) RECFM(V B),
        BUFNO(1) DSORG(PS)';
/* file_alloc = 'ALLOC F('clipid') UNIT(UVIO) SPACE(1 5),
        TRACKS USING(A1)'; */
   file_alloc = 'ALLOC F('clipid') UNIT(3390) SPACE(1 5),
        TRACKS USING(A1)';

   /* Parse Target */

   Call Extract_Target;
   If pfixcmd = 'M' Then;
     opt.2 = 'Y';

   /* Do the Job */

   fc = Listdsi(clipid 'FILE');
   If SYSREASON = 2 Then;
     Do;
       Address TSO file_free;
       Address TSO file_attr;
       Address TSO file_alloc;
       If RC > 0 Then;
         Signal Error_ALLOC_CLIP;
     End;

   '(status) = USER_STATE';
   'NUMBER OFF';
   Address MVS 'NEWSTACK';

   If opt.1 = 'Y' Then;
     Address MVS 'EXECIO * DISKR 'clipid' ( FINIS';

   Do i = trgt_row_from to (trgt_row_to - 1) by 1;
     '(xstatus) = XSTATUS' i;
     If xstatus = 'X' Then;
       iterate i;
     '(row) = LINE' i;
     Queue row;
     cut_cnt = cut_cnt + 1;
   End;

   Queue;
   'USER_STATE = (status)';

   If opt.2 = 'Y' Then;
     'DELETE' trgt_row_from trgt_row_to - 1;

   Address MVS 'EXECIO * DISKW 'clipid' ( FINIS';
   If RC > 0 Then;
     Signal Error_WRITE_CLIP;

   Address TSO 'FREE ATTR(A1)';

   ZEDSMSG = cut_cnt 'LINES CUT';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   '(krow,kcol) = CURSOR';
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   '(frow,trow) = DISPLAY_LINES';
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = '*' Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = '.' Then;
       Do;
         Upper var.1;
         '(linenbr) = LINENUM' var.1;
         If var.1 = '.ZLAST' Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> '' Then;
           If Substr(var.2,1,1) = '.' Then;
             Do;
               Upper var.2;
               '(linenbr) = LINENUM' var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = '.ZLAST' Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2' 'parm2;
       End;
     When Datatype(var.1,'W') Then;
       trgt_row_to = trgt_row_from + var.1;
     Otherwise;
       Do;
         'PROCESS RANGE C M';
         If RC > 0 Then;
           Signal Error_MISSING_LINECMD;
         '(pfixcmd) = RANGE_CMD';
         '(linenbr) = LINENUM .ZFRANGE';
         trgt_row_from = linenbr;
         '(linenbr) = LINENUM .ZLRANGE';
         trgt_row_to = linenbr + 1;
       End;
   End;

   Return (0);

   Extract_OPTIONS:

   Do While parm3 <> '';
     Parse VAR parm3 var.3 parm3;
     Upper var.3;
     Select;
       When Abbrev('APPEND',var.3) Then;
         opt.1 = 'Y';
       When Abbrev('MOVE',var.3) Then;
         opt.2 = 'Y';
       When Abbrev('SWITCH',var.3) | var.3 = 'SET' Then;
         Do;
           Parse VAR parm3 var.3 parm3;
           If Datatype(var.3,'W') Then;
             Do;
               clipid = 'CUT'||Right(var.3,5,'0');
               clipid@@ = clipid;
               Address ISPEXEC 'VPUT (CLIPID@@) PROFILE';
             End;
         End;
       When Datatype(var.3,'W') Then;
         clipid = 'CUT'||Right(var.3,5,'0');
       Otherwise;
         Signal Error_INVALID_OPTS;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = '04'x;
   pad = Copies(' ',62);
   ZERRLM  = pad hex04,
        'Purpose: Saves text in a clipboard for PASTE',
        pad hex04,
        ' Format: CUT < target | range >',
        pad hex04,
        '             < ( < APPEND > < MOVE > < SET nnn > >';
   ZERRSM  = '';
   ZERRALRM= 'NO';
   ZERRHM  = '*';
   Address ISPEXEC 'SETMSG MSG(ISRZ002)';
   Exit;

   Error_INVALID_TARGET:

   ZEDSMSG = 'INVALID TARGET';
   ZEDLMSG = 'INVALID/NO TARGET DECLARED'
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Exit (-16);

   Error_MISSING_LINECMD:

   ZEDSMSG = 'MISSING LINE CMD';
   ZEDLMSG = 'MISSING LINE COMMAND (C - COPY, M - MOVE)';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Exit (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = 'INVALID OPTS';
   ZEDLMSG = 'INVALID USER OPTIONS:' var.3;
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);

   Error_ALLOC_CLIP:

   ZEDSMSG = 'ALLOC CLIPBOARD';
   ZEDLMSG = 'ALLOC ERROR ON CLIPBOARD';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);

   Error_WRITE_CLIP:

   ZEDSMSG = 'WRITE CLIPBOARD';
   ZEDLMSG = 'WRITE ERROR ON CLIPBOARD';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);
./ ADD NAME=@PASTE   0102-14268-14329-1035-00219-00220-00000-APLKS   22
/* --------------------------------------------------------- */
/* Purpose: PASTE retrieves lines from clipboard inserts     */
/*          them following the target (.ZDEST).              */
/*                                                           */
/*  Format: PASTE < target >                                 */
/*                < ( options >                              */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*         options:                                          */
/*   SET or SWitch- point to a different clipboard, the      */
/*                  clipboard ID will follow                 */
/*          suffix- (number) the clipboard ID                */
/* --------------------------------------------------------- */
   Address ISPEXEC 'CONTROL ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG) PROFILE';
   If debug = 'DEBUG' Then;
     Trace R;
   Else;
     x = MSG('OFF');
/* Entering EXEC PASTE */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

/* Parse UPPER ARG parm2; */
   'MACRO (parm2) NOPROCESS';
   If RC > 0 Then;
     Signal Error_EDIT_MODE;
   If parm2 = '?' | parm2 = 'HELP' | parm2 = 'help' Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   opt. = '';              /* .1 = APPEND(Y/N) .2 = MOVE(Y/N) */
   var. = '';
   paste_cnt = 0;
   clipid = '';

   '(linenbr) = LINENUM .ZLAST';
   trgt_row_eof = linenbr + 1;

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> '' Then;
     Call Extract_OPTIONS;

   If clipid = '' Then;
     Do;
       Address ISPEXEC 'VGET (CLIPID@@) PROFILE';
       If RC = 0 & clipid@@ <> '' Then;
         clipid = clipid@@;
       Else;
         clipid = 'CUT00001';
     End;

   /* Parse Target */

   Call Extract_Target;

   /* Do the Job */

   '(status) = USER_STATE';
   'NUMBER OFF';
   Address MVS 'NEWSTACK';
   Address MVS 'EXECIO * DISKR 'clipid' ( FINIS';

   loop_cnt = Queued();
   Do i = trgt_row_from to (trgt_row_from + loop_cnt - 1) by 1;
     Parse PULL row;
     'LINE_AFTER' i '= DATALINE (row)';
     paste_cnt = paste_cnt + 1;
   End;
   'USER_STATE = (status)';

   ZEDSMSG = paste_cnt 'LINES PASTED';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from variable */

   '(krow,kcol) = CURSOR';
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   '(frow,trow) = DISPLAY_LINES';
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = '*' Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = '.' Then;
       Do;
         Upper var.1;
         '(linenbr) = LINENUM' var.1;
         If var.1 = '.ZLAST' Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
       End;
     When Datatype(var.1,'W') Then;
       trgt_row_to = trgt_row_from + var.1;
     Otherwise;
       Do;
         'PROCESS DEST';
         If RC > 0 Then;
           Signal Error_MISSING_DEST;
         '(linenbr) = LINENUM .ZDEST';
         trgt_row_from = linenbr;
       End;
   End;

   Return (0);

   Extract_OPTIONS:

   Do While parm3 <> '';
     Parse VAR parm3 var.3 parm3;
     Upper var.3;
     Select;
       When Abbrev('SWITCH',var.3) | var.3 = 'SET' Then;
         Do;
           Parse VAR parm3 var.3 parm3;
           If Datatype(var.3,'W') Then;
             Do;
               clipid = 'CUT'||Right(var.3,5,'0');
               clipid@@ = clipid;
               Address ISPEXEC 'VPUT (CLIPID@@) PROFILE';
             End;
         End;
       When Datatype(var.3,'W') Then;
         clipid = 'CUT'||Right(var.3,5,'0');
       Otherwise;
         Signal Error_INVALID_OPTS;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EDIT_MODE:

   Say 'MUST BE IN EDIT MODE TO ENVOKE THIS EXEC';
   Return (-16);

   Error_EXEC_HELP:

   hex04 = '04'x;
   pad = Copies(' ',62);
   ZERRLM  = pad hex04,
        'Purpose: Restores clipboard following destination',
        pad hex04,
        ' Format: PASTE < target >',
        pad hex04,
        '               < ( < SET | SWitch nnn > >';
   ZERRSM  = '';
   ZERRALRM= 'NO';
   ZERRHM  = '*';
   Address ISPEXEC 'SETMSG MSG(ISRZ002)';
   Exit;

   Error_INVALID_TARGET:

   ZEDSMSG = 'INVALID TARGET';
   ZEDLMSG = 'INVALID/NO TARGET DECLARED'
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Exit (-16);

   Error_MISSING_DEST:

   ZEDSMSG = 'MISSING DESTINATION (a,b)';
   ZEDLMSG = 'MISSING LINE COMMAND (A - AFTER, B - BEFORE)';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Exit (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = 'INVALID OPTS';
   ZEDLMSG = 'INVALID USER OPTIONS:' var.3;
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Exit (-16);
./ ADD NAME=ADRSPC   0125-15261-15279-1104-00341-00106-00000-APLKS   00
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Display active MVS Address Spaces and their      */
/*          current storage frame counts.                    */
/*                                                           */
/*  Format: ADRSPC ( options                                 */
/*                                                           */
/*         options: (default) SCREEN VERBOSE                 */
/*                  LINE|SCREEN presentation option          */
/*                  RECAP|VERBOSE                            */
/*                                                           */
/*   Logic: Extracts address of CVT (PSA+x'10')              */
/*          Extracts address of ASVT (CVT+x'22c')            */
/*          Extracts nbr of active AS (ASVT+x'104',4)        */
/*          Extracts address of ASVTENTY (ASVT+x'210')       */
/*          loop:                                            */
/*          Extracts address of ASCB (ASVTENTY+x'0')         */
/*                   (ASCB+x'0')  ASCBASCB  "ASCB"           */
/*                   (ASCB+x'24') ASCBASID  adrsp id         */
/*                   (ASCB+x'2b') ASCBDP    dispatch pri     */
/*          Extracts address of ASSB (ASCB+x'150')           */
/*                   (ASCB+x'150') ASCBASSB                  */
/*          Extracts address of JSAB (ASSB+x'a8')            */
/*                   (ASSB+x'a8') ASSBJSAB                   */
/*                   (JSAB+x'14') JSABJBID                   */
/*                   (JSAB+x'1c') JSABJBNM                   */
/*                   (JSAB+x'2c') JSABUSID                   */
/*          Extracts address of RAX (ascb+x'16c')            */
/*                   (ASCB+x'16c') ASCBRSME                  */
/*                   (RAX+x'2c')  RAXFMCT                    */
/*          Place everything in a stem variable              */
/*          Extracts address of ASVTENTY (ASVTENTY+x'4')     */
/*          end of loop;                                     */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC ADRSPC */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   Numeric Digits 10;         /* Required for 31-bit addresses */

   n = 0;
   avail_asid_cnt = 0;
   nonreus_asid_cnt = 0;
   var = "";
   lne. = "";
   opt. = "";
   pad = Copies(" ",4);

   pca_ptr = D2X(0);
   cvt_ptr = get_ptr(pca_ptr,'10');   /* FLCCVT A(CVT) */
   asvt_ptr = get_ptr(cvt_ptr,'22c'); /* CVTASVT A(ASVT) */
   asvtaav  = X2D(C2X(get_data(asvt_ptr,'1e0',4))); /*free slots */
   asvtast  = X2D(C2X(get_data(asvt_ptr,'1e4',4))); /*free START...*/
   asvtanr  = X2D(C2X(get_data(asvt_ptr,'1e8',4))); /*free non-reuse*/
   asvtstrt = X2D(C2X(get_data(asvt_ptr,'1eC',4))); /*RSVTSTRT*/
   asvtnonr = X2D(C2X(get_data(asvt_ptr,'1f0',4))); /*RSVNONR*/
   asvtmaxi = X2D(C2X(get_data(asvt_ptr,'1f4',4))); /*max users*/
   asvtmaxu = X2D(C2X(get_data(asvt_ptr,'204',4))); /*max adrsp*/
   asvtmstr = D2X((X2D(asvt_ptr)+528),8);

   asvtmaxu = Right(asvtmaxu,5);
   lne.1 = pad "There are" asvtmaxu "ASIDs defined on this System.";
   n = 1;

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   If opt.2 = "" Then;
     opt.2 = "VER";           /*verbose*/
   opt.0 = 2;

   /* Mainline */
   If opt.2 = "VER" Then;     /*verbose*/
     Do;
       n = 6;
       Do i=1 To asvtmaxu By +1;
         ndx = D2X((i-1)*4);
         ascb_ptr = get_ptrx(asvt_ptr,'210',ndx); /* ASVTENTY */
         If Bitand(Left(X2C(ascb_ptr),1),'80'x) = '80'x Then;
           Do;
             /*Available ASID*/
             /*bit on is ASID is not assigned, pointer to next entry*/
             /*bit off is ASID is assigned, pointer to ASCB*/
             wrkptr = C2X(Bitand(X2C(ascb_ptr),'7FFFFFFF'x));
             If wrkptr = asvtmstr Then;
               Do;
                 /*same addr as master = non-reusable asid*/
                 nonreus_asid_cnt = nonreus_asid_cnt + 1;
                 Iterate i;
               End;
             Else;
               Do;
                 avail_asid_cnt = avail_asid_cnt + 1;
                 Iterate i;
               End;
           End;
         ascbascb = get_data(ascb_ptr,'0','4'); /*eyecatcher*/
         If ascbascb <> "ASCB" Then;
           Iterate i;
         ascbasid = C2X(get_data(ascb_ptr,'24','2'));
         ascbasid = Right(X2D(ascbasid),5,'0');
         ascbdp = C2X(get_data(ascb_ptr,'2b','1')); /*dispatch pri*/
         ascbdp = Right(X2D(ASCBDP),3,'0');
         jobnm_ptr = get_ptr(ascb_ptr,'ac');   /*JOB*/
         If jobnm_ptr = 0 Then;
           jobnm_ptr = get_ptr(ascb_ptr,'b0'); /*STC,TSU,mount*/
         jobname = get_data(jobnm_ptr,'0',8);
         assb_ptr = get_ptr(ascb_ptr,'150');
         jsabjbid = Copies(" ",8);
         jsabjbnm = jsabjbid;
         jsabusid = jsabjbid;
         jsab_ptr = get_ptr(assb_ptr,'a8');
         If jsab_ptr <> 0 Then;
           Do;
             jsabjbid = get_data(jsab_ptr,'14',8);
             jsabjbnm = get_data(jsab_ptr,'1c',8);
             jsabusid = get_data(jsab_ptr,'2c',8);
           End;
         rax_ptr = get_ptr(ascb_ptr,'16c');
         raxfmct = C2X(get_data(rax_ptr,'2c',4));
         raxfmct = Right(X2D(raxfmct),8,'0');
         n = n + 1;
         lne.n = ascbasid raxfmct ascbdp ascb_ptr jobname,
              jsabjbid jsabjbnm jsabusid;
       End;
       lne.0 = n;
       avail_asid_cnt = Right(avail_asid_cnt,5);
       lne.2 = pad "There are" avail_asid_cnt "available ASIDs.";
       lne.3 = pad "There are" Right(n-6,5) "active ASIDs.";
       nonreus_asid_cnt = Right(nonreus_asid_cnt,5);
       lne.4 = pad "There are" nonreus_asid_cnt "non-reusable ASIDs.";
       lne.5 = pad;
       lne.6 = Copies(" ",6) || "Stg-Frms  DP" || Copies(" ",10),
            || "JobName  JESJobID JESName" || Copies(" ",2),
            || "UserID";
     End;

   n = n + 1;
   lne.n = pad;
   n = n + 1;
   lne.n = "MAXUSER from IEASYSxx:" Right(asvtmaxi,5);
   n = n + 1;
   lne.n = "         in use ASIDs:" Right(asvtmaxi-asvtaav,5);
   n = n + 1;
   lne.n = "      available ASIDs:" Right(asvtaav,5);
   n = n + 1;
   lne.n = pad;
   n = n + 1;
   lne.n = "RSVSTRT from IEASYSxx:" Right(asvtstrt,5);
   n = n + 1;
   lne.n = "         in use ASIDs:" Right(asvtstrt-asvtast,5);
   n = n + 1;
   lne.n = "      available ASIDs:" Right(asvtast,5);
   n = n + 1;
   lne.n = pad;
   n = n + 1;
   lne.n = "RSVNONR from IEASYSxx:" Right(asvtnonr,5);
   n = n + 1;
   lne.n = "         in use ASIDs:" Right(asvtnonr-asvtanr,5);
   n = n + 1;
   lne.n = "      available ASIDs:" Right(asvtanr,5);

   lne.0 = n;

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do i=1 To lne.0 By +1;
         Say lne.i;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(1)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD (STEM LNE. FINIS)"
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   Return (0);
   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) Then;
         opt.1 = Substr(var,1,3);
       When Abbrev("RECAP",var,3) |,
            Abbrev("VERBOSE",var,3) Then;
         opt.2 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

/* +--------------------------+
   | Functions defined below. |
   +--------------------------+ */

   get_ptr: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset
   temp = d2x(x2d(addr) + x2d(offset))
   return c2x(storage(temp,4))
   exit

   get_ptrx: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset+index.    |
      | ADDR and OFFSET must be HEX strings.    |
      | Author: L. Slaten                       |
      +-----------------------------------------+ */
   arg addr, offset, index
   temp = d2x(x2d(addr) + x2d(offset) + x2d(index))
   return c2x(storage(temp,4))
   exit

   get_ptr3: procedure
   /* +-----------------------------------------+
      | returns a 3 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset
   temp = d2x(x2d(addr) + x2d(offset))
   return c2x(storage(temp,3))
   exit

   get_data: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset, length
   temp = d2x(x2d(addr) + x2d(offset))
   return storage(temp,length)
   exit

   get_datax: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at                 |
      | ADDR+OFFSET+INDEX as an EBCDIC string.  |
      | ADDR, OFFSET, and INDEX must be HEX     |
      | strings.  LENGTH must be a decimal      |
      | string.                                 |
      | Author: L. Slaten                       |
      +-----------------------------------------+ */
   arg addr, offset, index, length
   temp = d2x(x2d(addr) + x2d(offset) + x2d(index))
   return storage(temp,length)
   exit

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display active MVS Address Spaces",
        pad hex04,
        "         like SDSF DA.",
        pad hex04,
        " Format: ADRSPC ( SCREEN|LINE  VERBOSE|RECAP";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=ALIGN    0110-16032-16190-0823-00339-00307-00000-APLKS   49
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: ALIGN   align the text on a row via a string.    */
/*                                                           */
/*  Format: ALIGN   <range>  string                          */
/*                  < ( options >                            */
/*                                                           */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*          string: any string enclosed in apostrophes or    */
/*                  quotes.  The string is used to determine */
/*                  where to split the line.  String is case */
/*                  sensitive.                               */
/*                                                           */
/*         options: (default) PROFILE (NUMBER)               */
/*                  STD | COBOL                              */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC ALIGN */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   lang = "";                 /*STD|COBOL*/
   trgt_row_from = "";
   trgt_row_to = "";
   find_string = "";
   find_len = 0;
   longest_len = 0;
   chg_cnt = 0;               /*nbr of rows split*/

   "(bndslo,bndshi) = BOUNDS";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;

   Call Extract_Options;
   If lang = "" Then;
     Do;
       Address ISPEXEC "VGET (LANG@@) PROFILE";
       If RC = 0 Then;
         If lang@@ <> "NULL" Then;
           lang = lang@@;
         Else;
           Signal Error_INVALID_LANG;
       Else;
         Signal Error_INVALID_LANG;
     End;

   /* Parse Range and User passed Parms */

   Call Extract_Range;

   If var.1 = "" Then;
     var.1 = ".ZFIRST";
   If var.2 = "" Then;
     var.2 = ".ZLAST";

   /* Parse the Required (find_string) EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       parm2 = Strip(parm2,"B");
       Select;
         When Substr(parm2,1,1) = "'" Then;
           Parse VAR parm2 "'" find_string "'" parm2;
         When Substr(parm2,1,1) = '"' Then;
           Parse VAR parm2 '"' find_string '"' parm2;
         When Substr(parm2,1,2) = "x'" | Substr(parm2,1,2) = "X'" Then;
           Do;
             Parse VAR parm2 "'" find_string "'" parm2;
             find_string = X2C(find_string);
           End;
         Otherwise;
           Parse VAR parm2 find_string parm2;
       End;
     End;
   Else;
     Signal Error_MISSING_STRING;

   find_len = Length(find_string);

   /* Do the Job */

   "SEEK '"find_string"'" trgt_row_from trgt_row_to " FIRST NX ";
   If RC <> 0 Then;
     Signal Error_STRING_NOTFND;

   EC = RC;
   Do While EC = 0;
     "(irow,icol) = CURSOR";
     "(row) = LINE" irow;
     Select;
       When lang = "COBOL" Then;
         If Substr(row,7,1) = "*",           /*comment*/
              | Substr(row,7,1) = "/",
              | Substr(row,7,1) = "D" Then;  /*DEBUG*/
           Do;
             "SEEK '"find_string"'" trgt_row_from trgt_row_to " NEXT NX ";
             EC = RC;
             Iterate;
           End;
       When lang = "STD" Then;
         If Substr(row,1,1) = "*",             /*comment*/
              | Substr(row,1,2) = "/*",
              | Substr(row,1,3) = "//*" Then;  /*comment*/
           Do;
             "SEEK '"find_string"'" trgt_row_from trgt_row_to " NEXT NX ";
             EC = RC;
             Iterate;
           End;
       Otherwise;
         Nop;
     End;
     n = Pos(find_string,row);     /*position of string*/
     If n = 0 Then;
       Signal Error_STRING_NOTFND;
     prefix_len = Length(Strip(Substr(row,1,n-1),"T"));
     If prefix_len > longest_len Then;
       longest_len = prefix_len;
     "SEEK '"find_string"'" trgt_row_from trgt_row_to " NEXT NX ";
     EC = RC;
   End;

   "SEEK '"find_string"'" trgt_row_from trgt_row_to " FIRST NX ";
   If RC <> 0 Then;
     Signal Error_STRING_NOTFND;

   EC = RC;
   Do While EC = 0;
     "(irow,icol) = CURSOR";
     "(row) = LINE" irow;
     Select;
       When lang = "COBOL" Then;
         If Substr(row,7,1) = "*",           /*comment*/
              | Substr(row,7,1) = "/",
              | Substr(row,7,1) = "D" Then;  /*DEBUG*/
           Do;
             "SEEK '"find_string"'" trgt_row_from trgt_row_to " NEXT NX ";
             EC = RC;
             Iterate;
           End;
       When lang = "STD" Then;
         If Substr(row,1,1) = "*",             /*comment*/
              | Substr(row,1,2) = "/*",
              | Substr(row,1,3) = "//*" Then;  /*comment*/
           Do;
             "SEEK '"find_string"'" trgt_row_from trgt_row_to " NEXT NX ";
             EC = RC;
             Iterate;
           End;
       Otherwise;
         Nop;
     End;
     n = Pos(find_string,row);     /*position of string*/
     If n = 0 Then;
       Signal Error_STRING_NOTFND;
     prefix_string = Left(Strip(Substr(row,1,n-1),"T"),longest_len);
     prefix_len = Length(prefix_string);
     suffix_len = bndshi-(n+find_len);
     suffix_string = Strip(Substr(row,n+find_len,suffix_len),"B");
     suffix_len = Length(suffix_string);
     pad_len = bndshi - (prefix_len + find_len + suffix_len) - 3;
     pad_string = Copies(" ",pad_len);
     new_string = prefix_string find_string suffix_string pad_string;
     newrow = Overlay(new_string,row,1);
     length_of_row = Length(newrow);
     "LINE" irow "= (newrow)";
     chg_cnt = chg_cnt + 1;
     "SEEK '"find_string"'" trgt_row_from trgt_row_to " NEXT NX ";
     EC = RC;
   End;

   If trgt_row_from <> "" Then;
     "LOCATE" trgt_row_from;

   ZEDSMSG = Strip(chg_cnt,"L","0") "CHGed";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Range:

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "." Then;
       Do;
         trgt_row_to = var.1;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               trgt_row_from = trgt_row_to;
               trgt_row_to = var.2;
             End;
           Else;
             Signal Error_INVALID_RANGE;
       End;
     When Substr(var.1,1,1) = "'" | Substr(var.1,1,1) = '"' | ,
          Substr(var.1,1,2) = "x'" | Substr(var.1,1,2) = "X'" Then;
       Do;
         /*place quoted string back in parm2*/
         parm2 = parm2 || " " | var.1;
         If loop <> "Y" Then;
           Do;
             loop = "Y";
             Signal Extract_Range;
           End;
       End;
     Otherwise;
       Do;
         /*place string back in parm2*/
         parm2 = parm2 || " " || Translate(var.1);
         If loop <> "Y" Then;
           Do;
             loop = "Y";
             Signal Extract_Range;
           End;
         Else;
           var.1 = "";
       End;
   End;

   If (var.1 = "" & var.2 = "") | (var.1 <> "" & var.2 <> "") Then;
     Nop;
   Else;
     Signal Error_INVALID_RANGE;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Upper var.3;
     Select;
       When var.3 = "STD" | var.3 = "COBOL" Then;
         lang = var.3;
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Align the text on a row via a string.",
        pad hex04,
        " Format: ALIGN  <range>  string",
        pad hex04,
        "                < ( <STD | COBOL>";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_RANGE:

   ZEDSMSG = "INVALID RANGE";
   ZEDLMSG = "Range is not a valid set of labels"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_MISSING_STRING:

   ZEDSMSG = "MISSING STRING";
   ZEDLMSG = "Missing find string";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_STRING_NOTFND:

   ZEDSMSG = "NOT FOUND";
   ZEDLMSG = "String not found, may be a case mismatch";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_LANG:

   ZEDSMSG = "INVALID LANG";
   ZEDLMSG = "Language is not valid ("lang")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=ALLMBRS  0118-14130-15265-1716-00182-00187-00000-APLKS   54
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Invoke edit exec on all members found in         */
/*          member list.                                     */
/*                                                           */
/*  Format: ALLMBRS   member ( execnme iparm                 */
/*                                                           */
/*     Use: Key command on any ISPF command line. The        */
/*          member referes to a member list created by       */
/*          macro PDSMLST.                                   */
/*                                                           */
/*          The exec will ask for the target PDS name.       */
/*          All of the member names found in member will be  */
/*          edited in the target PDS via the execnme exec.   */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC ALLMBRS */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the control file:";
       Parse UPPER EXTERNAL parm2 parm3;
     End;

   /* Initialize Variables */

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3
   parm3 = Strip(parm3,"T",")");
   If parm3 <> "" Then;
     execnme = Word(parm3,1);
   Else;
     Signal Error_INVALID_OPTS;

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     ctlseq_dsname = Strip(Word(parm2,1),"B","'");
   Else;
     Signal Error_NO_DATA;

   /* Point to dataset with all of the members to be processed */
   Address TSO "ALLOC DSNAME("ctlseq_dsname") ",
               "DDNAME(DVRLIST) SHR REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_CTL_DATASET;

   "EXECIO 0 DISKR DVRLIST ( OPEN ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_CTL_DATASET;

   /* Mainline */

   Say "Please enter the target PDS:";
   Pull tgtpds_dsname .;
   If tgtpds_dsname = "" Then;
     Signal Error_NO_DATA;

   /* Point to PDS to be edited and modified */
   Address ISPEXEC "LMINIT DATAID("tgtid") ",
        "DATASET("tgtpds_dsname") ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_DATASET;

   eof = "NO";
   Do While eof = "NO";
     "EXECIO 1 DISKR DVRLIST ";
     If RC = 0 Then;
       Do;
         Pull mbrname;
         mbrname = Strip(mbrname);
         Address ISPEXEC "EDIT DATAID("tgtid") MEMBER("mbrname") ",
             "MACRO("execnme") ";
       End;
     Else;
       eof = "YES";
   End;

   "EXECIO 0 DISKR MBRLST ( FINIS ";

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   Exit (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Invoke edit exec on all members found in",
        pad hex04,
        "         member list.",
        pad hex04,
        " Format: ALLMBRS member ( execnme ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "NO EXEC NAME PASSED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_CTL_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Control dataset" ctlseq_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=AMB      0110-15245-16196-0837-00271-00245-00000-APLKS   31
/* REXX 2016-07-14 */
/* --------------------------------------------------------- */
/* Purpose: Invoke AMBLIST to collect the output of IBM's    */
/*          load module / program object attributes and      */
/*          present it to the user.                          */
/*                                                           */
/*  Format: AMB     srcpds_loadlib(mbr)                      */
/*                                                           */
/*  srcpds_loadlib: is the name of the source LOADLIB and    */
/*                  member, for the data to be collected.    */
/*                                                           */
/* options:                                                  */
/*          none                                             */
/*                                                           */
/*     Use: From the ISPF Dataset/Member List (3.4) panel    */
/*          enter command in the row command area of the     */
/*          desired member.                                  */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC AMB     */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   srcpds_loadlib = "";      /* source PDS */
   mbr = "";
   opt. = "";
   opt.1 = "SHORT";
   lne. = "";

   /* Parse the User Options */

   Parse VAR parm2 parm2 "("mbr")" .;
   If parm2 <> "" Then;
     srcpds_loadlib = Strip(Word(parm2,1),"B","'");
   Else;
     Signal Error_NO_DATA;

   If mbr = "" Then;
     Signal Error_NO_MEMBER;

   /* Test source dsname for validity */

   Call Validate_DSNAME srcpds_loadlib;
   If EC < 16 Then;
     If CC < 0 Then;
       Signal Error_INVALID_LOADLIB;
     Else;
       Nop;
   Else;
     Signal Error_INVALID_LOADLIB;

   If SYSRECFM <> "U" Then;   /*ensure that it is a loadlib*/
     Signal Error_INVALID_LOADLIB;

   "FREE  DD(SYSIN AMBLIB SYSPRINT)";

   "ALLOC DD(SYSIN) ",
        " UNIT(SYSDA) TRACKS SPACE(1)",
        " RECFM(F) LRECL(80)",
        " NEW ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSIN;
   Address TSO "MAKEBUF";
   QUEUE " LISTIDR  DDN=AMBLIB,MEMBER=" || mbr;
   "EXECIO 1 DISKW SYSIN ( FINIS ";

   "ALLOC DD(AMBLIB) DSNAME("srcpds_loadlib")",
        " SHR ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_AMBLIB;

   "ALLOC DD(SYSPRINT) ",
        " UNIT(SYSDA) TRACKS SPACE(5,5)",
        " RECFM(F B A) LRECL(121) BLKSIZE(0)",
        " NEW ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSPRINT;

   "CALL *(AMBLIST) ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_CALL_AMBLIST;

   Address TSO "DROPBUF";

   Select;
     When opt.1 = "LONG" Then;
       Do;
         Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(SYSPRINT)";
         Address ISPEXEC "VIEW DATAID("tgtid")";
         Address ISPEXEC "LMFREE DATAID("tgtid")";
       End;
     Otherwise;
       Do;
         "EXECIO * DISKR SYSPRINT ( STEM LNE. FINIS ";
         Do i=1 To lne.0 By +1;
           Select;
             When Pos("THIS LOAD MODULE WAS",lne.i) > 0 Then;
               Do;
                 n = Wordpos("ON DAY",lne.i);
                 day_of_year = Word(lne.i,n+2);
                 n = Wordpos("OF YEAR",lne.i,n+2);
                 year = Word(lne.i,n+2);
                 n = Wordpos("AT",lne.i,n+2);
                 time_of_day = Strip(Word(lne.i,n+1),"T",".");
                 jdate = Substr(year,3,2)||day_of_year;
                 day = Date(,jdate,"J");
                 text = "Load module was linked on "day,
                      ||" at "time_of_day;
                 Leave;
               End;
             When Pos("THIS PROGRAM OBJECT",lne.i) > 0 Then;
               Do;
                 n = Wordpos("ON",lne.i);
                 mdy = Word(lne.i,n+1);
                 n = Wordpos("AT",lne.i,n+1);
                 time_of_day = Word(lne.i,n+1);
                 sdate = Substr(mdy,7,4)||Substr(mdy,1,2),
                      ||Substr(mdy,4,2);
                 day = Date(,sdate,"S");
                 text = "Program object was linked on "day,
                      ||" at "time_of_day;
                 Leave;
               End;
             Otherwise;
               Nop;
           End;
         End;
         pad = Copies(" ",80);
         ZERRLM  = pad text;
         ZERRSM  = "";
         ZERRALRM= "NO";
         ZERRHM  = "*";
         Address ISPEXEC "SETMSG MSG(ISRZ002)";
       End;
   End;

   "FREE  DD(SYSIN AMBLIB SYSPRINT)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Validate_DSNAME: Procedure Expose EC CC SYSRECFM;

   /* Test dsname for validity */
   Arg dsname;
   CC = 0;
   arg_string = "'"dsname"' NORECALL NOSMSINFO";
   EC =  Listdsi(arg_string);
   If EC < 16 Then;
     Do;
       If SYSREASON = 0 Then;
         If SYSDSORG = "PO" | SYSDSORG = "POU" Then;
           Nop;
         Else;
           CC = -12;
       Else;
         If SYSREASON = 3  | SYSREASON = 5  | SYSREASON = 24 Then;
           CC = -12;
         Else;
           CC = -24;
     End;

   Return (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Display compile date and time of",
        pad hex04,
        "         loadlib member.",
        pad hex04,
        " Format: AMB  loadlib(mbr)";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING LOADLIB";
   ZEDLMSG = "NO LOADLIB SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_NO_MEMBER:

   ZEDSMSG = "NO MEMBER";
   ZEDLMSG = "NO MEMBER SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_LOADLIB:

   ZEDSMSG = "INVALID LOADLIB";
   ZEDLMSG = "INVALID LOADLIB: "srcpds_loadlib" CC=" CC "RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_SYSIN:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD SYSIN RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_AMBLIB:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD AMBLIB RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_SYSPRINT:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD SYSPRINT RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_CALL_AMBLIST:

   ZEDSMSG = "CALL ERROR";
   ZEDLMSG = "CALL ERROR FOR AMBLIST RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=APLKS    0117-14130-17094-1621-00071-00053-00000-APLKS   34
/* REXX */
/* --------------------------------------------------------- */
/* PURPOSE: ALLOCATE USER DATASETS TO OPTIONAL               */
/*          ISPF DDNAME.                                     */
/*                                                           */
/*          USES EXEC KONKAT TO CONCATENATE DATASETS         */
/*          TO AN OPTIONAL/REQUIRED DDNAME.                  */
/*                                                           */
/*  INVOKE: FROM TSO =6 KEY THE FOLLOWING                    */
/*          ex 'userid.MYTSO.EXEC(userid)'                   */
/*                                                           */
/* --------------------------------------------------------- */

   ispf_act = "N";
   "SUBCOM ISPEXEC";
   If RC = 0 Then;
     ispf_act = "Y";

   If ispf_act = "Y" Then;
     Do;
       Address ISPEXEC "CONTROL ERRORS RETURN";
       Address ISPEXEC "VGET (DEBUG)";
       If debug = "DEBUG" Then;
         Do;
           x = MSG("ON");
           Trace R;
         End;
       Else;
         x = MSG("OFF");
     End;

/* Entering EXEC userid() */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   tsouser = Userid();
   rexxexec = "'" || tsouser || ".MYTSO.EXEC(KONKAT)'";

   /* EXEC 'rexxexec' 'parmlist' LIST/NOLIST */
   /*      PROMPT/NOPROMPT EXEC/CLIST        */

   /* example follows */
   /* EX "'AAD28.MYTSO.EXEC(KONKAT)' ' SYSEXEC AAD28.MYTSO.EXEC '"; */

   Say " ";
   Say "EXECUTING" tsouser "CUSTOM ALLOCATION EXEC ";
   Say " ";

   /* PERSONAL REXX MACRO LIBRARY BELOW */

   parmlist = "' SYSEXEC " || tsouser || ".MYTSO.EXEC '";
   "EX " rexxexec parmlist;

   "PDF PANEL(APPDEV01)";

   Exit;
./ ADD NAME=APLKS01  0110-15249-16118-0827-00071-00065-00000-APLKS   10
/* REXX */
/* --------------------------------------------------------- */
/* PURPOSE: ALLOCATE USER DATASETS TO OPTIONAL               */
/*          ISPF DDNAME.                                     */
/*                                                           */
/*          USES EXEC KONKAT TO CONCATENATE DATASETS         */
/*          TO AN OPTIONAL/REQUIRED DDNAME.                  */
/*                                                           */
/*  INVOKE: FROM TSO =6 KEY THE FOLLOWING                    */
/*          ex 'userid.MYTSO.EXEC(userid||01)'               */
/*                                                           */
/* --------------------------------------------------------- */

   ispf_act = "N";
   Address TSO "SUBCOM ISPEXEC";
   If RC = 0 Then;
     ispf_act = "Y";

   If ispf_act = "Y" Then;
     Do;
       Address ISPEXEC "CONTROL ERRORS RETURN";
       Address ISPEXEC "VGET (DEBUG)";
       If debug = "DEBUG" Then;
         Do;
           x = MSG("ON");
           Trace R;
         End;
       Else;
         x = MSG("OFF");
     End;

/* Entering EXEC userid() */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   tsouser = Userid();
   rexxexec = "'" || tsouser || ".MYTSO.EXEC(KONKAT)'";

   /* EXEC 'rexxexec' 'parmlist' LIST/NOLIST */
   /*      PROMPT/NOPROMPT EXEC/CLIST        */

   /* example follows */
   /* EX "'AAD28.MYTSO.EXEC(KONKAT)' ' SYSEXEC AAD28.MYTSO.EXEC '"; */

   Say " ";
   Say "EXECUTING" tsouser "CUSTOM ALLOCATION EXEC ";
   Say " ";

   /* PERSONAL REXX LOADLIB LIBRARY BELOW */

   parmlist = "' ISPLLIB " || tsouser || ".REXX.LOADLIB ( LAST '";
   "EX " rexxexec parmlist "LIST";

   "PDF PANEL(APPDEV01)";

   Exit;
./ ADD NAME=APLKS02  0105-16008-18010-1650-00093-00081-00000-APLKS   09
/* REXX */
/* --------------------------------------------------------- */
/* PURPOSE: ALLOCATE USER DATASETS TO OPTIONAL               */
/*          ISPF DDNAME.                                     */
/*                                                           */
/*          USES EXEC KONKAT TO CONCATENATE DATASETS         */
/*          TO AN OPTIONAL/REQUIRED DDNAME.                  */
/*                                                           */
/*  INVOKE: FROM TSO READY                                   */
/*          ex 'userid.MYTSO.EXEC(userid||02)'               */
/*                                                           */
/* --------------------------------------------------------- */

   ispf_act = "N";
   Address TSO "SUBCOM ISPEXEC";
   If RC = 0 Then;
     ispf_act = "Y";

   If ispf_act = "Y" Then;
     Do;
       Address ISPEXEC "CONTROL ERRORS RETURN";
       Address ISPEXEC "VGET (DEBUG)";
       If debug = "DEBUG" Then;
         Do;
           x = MSG("ON");
           Trace R;
         End;
       Else;
         x = MSG("OFF");
     End;

/* Entering EXEC userid() */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   tsouser = Userid();
   rexxexec = "'" || tsouser || ".MYTSO.EXEC(KONKAT)'";

   /* EXEC 'rexxexec' 'parmlist' LIST/NOLIST */
   /*      PROMPT/NOPROMPT EXEC/CLIST        */

   /* example follows */
   /* EX "'AAD28.MYTSO.EXEC(KONKAT)' ' SYSEXEC AAD28.MYTSO.EXEC '"; */

   Say " ";
   Say "EXECUTING" tsouser "CUSTOM ALLOCATION EXEC ";
   Say " ";

   /* PERSONAL REXX & TSO LOADLIB LIBRARY BELOW */

   parmlist = "' ISPLLIB " || tsouser || ".REXX.LOADLIB ( LAST '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPLLIB " || tsouser || ".BXS.TSOCMD.LOADLIB ( LAST '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPLLIB " || tsouser || ".WORK.LOADLIB ( FIRST '";
   "EX " rexxexec parmlist;

   /* PERSONAL REXX MACRO LIBRARY BELOW */

   parmlist = "' SYSEXEC " || tsouser || ".MYTSO.EXEC '";
   "EX " rexxexec parmlist;

   parmlist = "' SYSEXEC " || tsouser || ".BATCH.REXXLIB '";
   "EX " rexxexec parmlist;

   parmlist = "' SYSEXEC " || tsouser || ".WORK.REXXLIB '";
   "EX " rexxexec parmlist;

   /* PERSONAL SYSHELP LIBRARY BELOW */

   parmlist = "' SYSHELP " || tsouser || ".BXS.TSOCMD.SYSHELP ( LAST '";
   "EX " rexxexec parmlist;

   "PDF PANEL(APPDEV01)";

   Exit;
./ ADD NAME=APLKS03  0117-16151-18255-1636-00144-00076-00000-APLKS   08
/* REXX */
/* --------------------------------------------------------- */
/* PURPOSE: ALLOCATE USER DATASETS TO OPTIONAL               */
/*          ISPF DDNAME.                                     */
/*                                                           */
/*          USES EXEC KONKAT TO CONCATENATE DATASETS         */
/*          TO AN OPTIONAL/REQUIRED DDNAME.                  */
/*                                                           */
/*  INVOKE: FROM TSO READY                                   */
/*          ex 'userid.MYTSO.EXEC(userid||03)'               */
/*                                                           */
/* --------------------------------------------------------- */

   ispf_act = "N";
   Address TSO "SUBCOM ISPEXEC";
   If RC = 0 Then;
     ispf_act = "Y";

   If ispf_act = "Y" Then;
     Do;
       Address ISPEXEC "CONTROL ERRORS RETURN";
       Address ISPEXEC "VGET (DEBUG)";
       If debug = "DEBUG" Then;
         Do;
           x = MSG("ON");
           Trace R;
         End;
       Else;
         x = MSG("OFF");
     End;

/* Entering EXEC userid() */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   tsouser = Userid();
   rexxexec = "'" || tsouser || ".MYTSO.EXEC(KONKAT)'";

   /* EXEC 'rexxexec' 'parmlist' LIST/NOLIST */
   /*      PROMPT/NOPROMPT EXEC/CLIST        */

   /* example follows */
   /* EX "'AAD28.MYTSO.EXEC(KONKAT)' ' SYSEXEC AAD28.MYTSO.EXEC '"; */

   Say " ";
   Say "EXECUTING" tsouser "CUSTOM ALLOCATION EXEC ";
   Say " ";

   /* PERSONAL REXX/TSO LOADLIB LIBRARY BELOW */

/* parmlist = "' ISPLLIB " || tsouser || ".BXS.OS.LOADLIB '";
   "EX " rexxexec parmlist;  */

   parmlist = "' ISPLLIB " || tsouser || ".BXS.REVIEW.LOADLIB '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPLLIB " || tsouser || ".BXS.SHOWZOS.LOADLIB '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPLLIB " || tsouser || ".BXS.TSOCMD.LOADLIB '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPLLIB " || tsouser || ".BXS.VTOC.LOADLIB '";
   "EX " rexxexec parmlist;

/* PARMLIST = "' ISPLLIB " || TSOUSER || ".BXS.VTOCZAP.LOADLIB '";
   "EX " rexxexec parmlist; */

   parmlist = "' ISPLLIB " || tsouser || ".REXX.LOADLIB ( LAST '";
   "EX " rexxexec parmlist;

   /* PERSONAL REXX MACRO LIBRARY BELOW */

   parmlist = "' SYSEXEC " || tsouser || ".MYTSO.EXEC '";
   "EX " rexxexec parmlist;

/* parmlist = "' SYSEXEC " || tsouser || ".BXS.OS.SYSEXEC '";
   "EX " rexxexec parmlist; */

/* parmlist = "' SYSEXEC " || tsouser || ".BXS.VTOCZAP.SYSEXEC '";
   "EX " rexxexec parmlist; */

   /* PERSONAL ISPF PANEL LIBRARY BELOW */

/* parmlist = "' ISPPLIB " || tsouser || ".BXS.OS.ISPPLIB '";
   "EX " rexxexec parmlist; */

   parmlist = "' ISPPLIB " || tsouser || ".BXS.REVIEW.ISPPLIB '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPPLIB " || tsouser || ".BXS.VTOC.ISPPLIB '";
   "EX " rexxexec parmlist;

/* parmlist = "' ISPPLIB " || tsouser || ".BXS.VTOCZAP.ISPPLIB '";
   "EX " rexxexec parmlist; */

/* parmlist = "' ISPPLIB " || tsouser || ".CSVEDIT.ISPPLIB '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPPLIB " || tsouser || ".TXT2RTF.ISPPLIB '";
   "EX " rexxexec parmlist;

   parmlist = "' ISPPLIB " || tsouser || ".FILE543.PDS '";
   "EX " rexxexec parmlist;   */

   /* PERSONAL ISPF MESSAGE LIBRARY BELOW */

   parmlist = "' ISPMLIB " || tsouser || ".BXS.VTOC.ISPMLIB '";
   "EX " rexxexec parmlist;

   /* PERSONAL ISPF HELP  LIBRARY BELOW */

   parmlist = "' SYSHELP " || tsouser || ".BXS.REVIEW.SYSHELP '";
   "EX " rexxexec parmlist;

   parmlist = "' SYSHELP " || tsouser || ".BXS.TSOCMD.SYSHELP '";
   "EX " rexxexec parmlist;

   parmlist = "' SYSHELP " || tsouser || ".BXS.VTOC.SYSHELP '";
   "EX " rexxexec parmlist;

   /* PERSONAL ISPF CLIST LIBRARY BELOW */

   parmlist = "' SYSPROC " || tsouser || ".BXS.VTOC.SYSPROC '";
   "EX " rexxexec parmlist;

   "PDF PANEL(APPDEV01)";

   Exit;
./ ADD NAME=ASA2PC   0106-15241-16190-0833-00113-00001-00000-APLKS   20
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Convert ASA print control characters to          */
/*          PC postscript style.                             */
/*                                                           */
/*  Format: ASA2PC                                           */
/*                                                           */
/*  Author: J. KALINICH, X4521                               */
/*          2015-09-11 local standardization by L Slaten     */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC ASA2PC */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   "(dsn) = DATASET";

   /* Mainline */

   EC = Listdsi("'"dsn"'");
   If EC <> 0 Then;
     Signal Error_LISTDSI_FAILED;

   If Pos('A',sysrecfm) = 0 Then;
     Signal Error_NO_ASA;

   "CHANGE ALL '1' X'0C' 1";       /* SKIP TO NEW PAGE */
/* "CHANGE ALL ' ' X'..' 1"; */    /* SPACE 1 LINE  */
   "CHANGE ALL '0' X'0D25' 1";     /* SPACE 2 LINES */
   "CHANGE ALL '-' X'0D250D25' 1"; /* SPACE 3 LINES */
   "EXCLUDE ALL";
   "FIND ALL '+' 1";               /* SUPPRESS SPACE */
   "DELETE ALL NX";
   "RESET EXCLUDED";

   Return;

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Convert ASA print control characters",
        pad hex04,
        "         to PC postscript style.",
        pad hex04,
        " Format: ASA2PC ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_LISTDSI_FAILED:

   ZEDSMSG = "LISTDSI FAILED";
   ZEDLMSG = "LISTDSI failed with RC =" EC "CC =" sysreason;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_NO_ASA:

   ZEDSMSG = "NO ASA";
   ZEDLMSG = "No ASA print control characters";
   Address ISPEXEC "SETMSG MSG(ISRZ001W)";
   Return (4);

/* J. KALINICH, X4521 */
/* EDIT MACRO TO CONVERT ASA PRINTER CONTROL TO ASCII CODE */
./ ADD NAME=BIN2DEC  0107-19259-19270-1425-00048-00028-00000-APLKS   45
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Convert base(2) number to a base(10) number
   Invoke as: base_10 = BIN2DEC(base_2);
          or: TSO BIN2DEC base_2
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_10 = "error composition";

   ARG base_2;

   Numeric Digits 20;

   If Verify(base_2,"01") = 0 Then;
     Nop;
   Else;
     Signal The_End;

   base_10 = "error length";

   len = Length(base_2);
   If len > 0 & len <= 64 Then;
     Do;
       j = len;
       Do i=1 To len By +1;
         j = j-1;
         pwr_vector.i = 2**j;
       End;
     End;
   Else;
     Signal The_End;

   base_10 = 0;
   Do i=1 To len By +1;
     digit = Substr(base_2,i,1);
     base_10 = base_10 + (digit * pwr_vector.i);
   End;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_10;

   Say "Decimal value =" base_10;
   Return (0);
./ ADD NAME=BLDADR   0136-15254-18344-1621-00335-00500-00000-APLKS   35
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: Create ADRDSSU command control statements        */
/*          for the files found on the DSLIST panel.         */
/*                                                           */
/*  Format: BLDADR  <dsname | NONE> < ( options  >           */
/*                                                           */
/*         dsname: is the name of the target SEQ/PDS         */
/*                 data set to place the ADRDSSU             */
/*                 control cards. Otherwise, the data        */
/*                 will be placed in the DEFAULT clipboard   */
/*                 to be later PASTEd.                       */
/*                                                           */
/*        options: (default) DUMP                            */
/*                 COPY - ADR logical copy DASD-2-DASD       */
/*                 DUMP - ADR logical backup                 */
/*                 RESTORE - ADR logical restore from backup */
/*                                                           */
/*     Use: From the ISPF Dataset list (3.4) panel           */
/*          enter the exec in the command area.              */
/*                                                           */
/*          Prior filtering of the data set name list        */
/*          can be acomplished using DSNFLTR exec.           */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC BLDADR   */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   adr. = "";
   n = 0;
   opt. = "";
   tgt_ddname = "CTLCRDS";
   tgt_dsname = "";      /*target SEQ/PDS for ADRDSSU ctl stmts*/

   cpycrd1 = "   COPY - ";
   cpycrd2 = "      DATASET(INCLUDE( - ";
   cpypad1 = Copies(' ',22);
   cpycrd3 = "                     ) - ";
   cpycrd4 = "             ) - ";
   cpycrd5 = "      RENAMEU( - ";
   cpypad2 = Copies(' ',14);
   cpycrd6 = "             ) - ";
   cpycrd7 = "      ALLEXCP DYNALLOC FASTREPLICATION(PREF) - ";
   cpycrd8 = "      REPLACEU SHARE VOL(SRC) - ";
   cpycrd9 = "      TOLERATE(ENQF) ";

   dmpcrd1 = "   DUMP OUTDD(OUTDD) - ";
   dmpcrd2 = "      DATASET(INCLUDE( - ";
   dmppad  = Copies(' ',22);
   dmpcrd3 = "                     ) - ";
   dmpcrd4 = "             ) - ";
   dmpcrd5 = "      TOLERATE(ENQF) ";

   rstcrd1 = "   RESTORE INDD(INDD) - ";
   rstcrd2 = "      DATASET(INCLUDE( - ";
   rstpad1 = Copies(' ',22);
   rstcrd3 = "                     ) - ";
   rstcrd4 = "             ) - ";
   rstcrd5 = "      RENAMEU( - ";
   rstpad2 = Copies(' ',14);
   rstcrd6 = "             ) - ";
   rstcrd7 = "      CATALOG REPLACE SHARE WAIT(2,5) ";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "DUMP";     /*dump*/
   opt.0 = 1;

   /* Parse User Passed Parms */

   If parm2 <> "" & parm2 <> "NONE" Then;
     Do;
       tgt_dsname = Strip(Word(parm2,1),"B","'");
       /* Test target dsname for validity */
       EC = Sysdsn("'"tgt_dsname"'");
       Select;
         When EC = "MEMBER NOT FOUND" Then;
           Do;
             /*alloc existing PDS/PDSE*/
             "FREE DD("tgt_ddname")";
             EC = RC;
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " MOD ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         When EC = "DATASET NOT FOUND" Then;
           Do;
             /*alloc new SEQ*/
             "FREE DD("tgt_ddname")";
             EC = RC;
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)",
                  " UNIT(SYSDA) SPACE(1 5) TRACKS";
                  " NEW ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         Otherwise;
           Signal Error_TGT_ALLOC;
       End;
     End;
   Else;
     Do;
       /*alloc SEQ temp, for CUT, and place in clipboard*/
       "ALLOC DD("tgt_ddname")",
            " DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)",
            " UNIT(SYSDA) SPACE(1 5) TRACKS",
            " NEW DELETE REUSE";
       EC = RC;
       If RC <> 0 Then;
         Signal Error_TGT_ALLOC;
     End;

   /* Collect all of the source data set names */

   "MAKEBUF";

   Call "STKDSNS";
   EC = RESULT;
   If EC <> 0 Then;
     Signal Error_STKDSNS_FAILED;

   count = 0;
   QELEM;
   count = RC;
   RC = 0;

   If count = 0 Then;
     Signal Error_STKDSNS_FAILED;

   /* Mainline */

   Select;
     When opt.1 = "COPY" Then;
       Do;
         adr.1 = cpycrd1;
         adr.2 = cpycrd2;
         n = 2;
         Do i=1 To count By +1;
/*         Pull dsname ";" volinfo ";" spcinfo ";"
                attrinfo ";" dateinfo ";" catname ";"; */
           Pull dsname ";" . ;
           n = n + 1;
           adr.n = cpypad1 || Strip(dsname,'B') ||", -";
         End;
         adr.n = cpycrd3;
         n = n + 1;
         adr.n = cpycrd4;
         n = n + 1;
         adr.n = cpycrd5;
         n = n + 1;
         adr.n = cpypad2 || "(original.dsname" || ", -";
         n = n + 1;
         adr.n = cpypad2 || " new.dsname)" || ", -";
         n = n + 1;
         adr.n = cpycrd6;
         n = n + 1;
         adr.n = cpycrd7;
         n = n + 1;
         adr.n = cpycrd8;
         n = n + 1;
         adr.n = cpycrd9;
         adr.0 = n;
       End;
     When opt.1 = "DUMP" Then;
       Do;
         adr.1 = dmpcrd1;
         adr.2 = dmpcrd2;
         n = 2;
         Do i=1 To count By +1;
/*         Pull dsname ";" volinfo ";" spcinfo ";"
                attrinfo ";" dateinfo ";" catname ";"; */
           Pull dsname ";" . ;
           n = n + 1;
            adr.n = dmppad || Strip(dsname,'B') ||", -";
         End;
         adr.n = dmpcrd3;
         n = n + 1;
         adr.n = dmpcrd4;
         n = n + 1;
         adr.n = dmpcrd5;
         adr.0 = n;
       End;
     When opt.1 = "RESTORE" Then;
       Do;
         adr.1 = rstcrd1;
         adr.2 = rstcrd2;
         adr.3 = dmppad || "**" ||", -";
         adr.4 = rstcrd3;
         adr.5 = rstcrd4;
         adr.6 = rstcrd5;
         adr.7 = rstpad2 || "(original.dsname" || ", -";
         adr.8 = rstpad2 || " new.dsname)" || ", -";
         adr.9 = rstcrd6;
         adr.10 = rstcrd7;
         adr.0 = 10;
       End;
     Otherwise;
       Nop;
   End;

   "DROPBUF";

   "EXECIO "adr.0" DISKW "tgt_ddname" ( STEM ADR. FINIS ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ON_OUTPUT;

   If tgt_dsname = "" Then;
     Do;
       Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME("tgt_ddname")";
       Address ISPEXEC "VIEW DATAID("tgtid") MACRO(NOTEPAD)";
       Address ISPEXEC "LMFREE DATAID("tgtid")";
     End;

   "FREE DD("tgt_ddname")";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_OPTIONS:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("COPY",var,1) Then;
         opt.1 = "COPY";
       When Abbrev("DUMP",var,1) Then;
         opt.1 = "DUMP";
       When Abbrev("RESTORE",var,1) Then;
         opt.1 = "RESTORE";
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Build ADRDSSU control statements.",
        pad hex04,
        " Format: BLDADR <dsname | NONE> < ( COPY | DUMP | RESTORE >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DSNAME:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "No dataset specified";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_ALLOC:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target dataset" tgt_dsname,
             "allocation failed, RC =" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "FREE DD("tgt_ddname")";
   DROPBUF;
   Return (-16);

   Error_STKDSNS_FAILED:

   ZEDSMSG = "NO SOURCE DSNAMES";
   ZEDLMSG = "Nothing selected from DSLIST (=3.4)";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ON_OUTPUT:

   ZEDSMSG = "EXECIO FAILED";
   ZEDLMSG = "Target dataset" tgt_dsname,
             "write failed, RC =" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "FREE DD("tgt_ddname")";
   DROPBUF;
   Return (-16);
./ ADD NAME=BLDADR1  0109-18268-18344-1622-00217-00315-00000-APLKS   27
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: Create ADRDSSU command control statements        */
/*          to PRINT TRACK 0 (i.e. IPL TEXT) for each        */
/*          of the volid(s) desired.                         */
/*                                                           */
/*  Format: BLDADR1  <dsname | NONE> < ( options  >          */
/*                                                           */
/*         dsname: is the name of the target SEQ/PDS         */
/*                 data set to place the ADRDSSU             */
/*                 control cards. If NONE, the data will     */
/*                 be placed in the DEFAULT clipboard to     */
/*                 be later PASTEd.                          */
/*                                                           */
/*        options: (default)                                 */
/*                 kwd=(value,...)                           */
/*                                                           */
/*          Where: kwd = VOLUME | UNIT                       */
/*                 value... is a list of values, that are    */
/*                          used to make partial matches     */
/*                          to the actual values.            */
/*                                                           */
/*     Use: Invoke TSO DUDASD command via REXX %DUDASD       */
/*          command to extract the list of device(s) and     */
/*          volid(s), place them on the STACK, then this     */
/*          exec builds the ADR control statements to print  */
/*          TRACK 0 of each of the selected volumes.         */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC BLDADR1  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   adr. = "";
   tgt_ddname = "CTLCRDS";
   tgt_dsname = "";      /*target SEQ/PDS for ADRDSSU ctl stmts*/

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;

   /* Parse User Passed Parms */

   If parm2 <> "" & parm2 <> "NONE" Then;
     Do;
       tgt_dsname = Strip(Word(parm2,1),"B","'");
       /* Test target dsname for validity */
       EC = Sysdsn("'"tgt_dsname"'");
       Select;
         When EC = "MEMBER NOT FOUND" Then;
           Do;
             /*alloc existing PDS/PDSE*/
             "FREE DD("tgt_ddname")";
             EC = RC;
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " MOD ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         When EC = "DATASET NOT FOUND" Then;
           Do;
             /*alloc new SEQ*/
             "FREE DD("tgt_ddname")";
             EC = RC;
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)",
                  " UNIT(SYSDA) SPACE(1 5) TRACKS";
                  " NEW ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         Otherwise;
           Signal Error_TGT_ALLOC;
       End;
     End;
   Else;
     Do;
       /*alloc SEQ temp, for CUT, and place in clipboard*/
       "ALLOC DD("tgt_ddname")",
            " DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)",
            " UNIT(SYSDA) SPACE(1 5) TRACKS",
            " NEW DELETE REUSE";
       EC = RC;
       If RC <> 0 Then;
         Signal Error_TGT_ALLOC;
     End;

   /* Collect all of the device(s) and volid(s) */

   "MAKEBUF";
   "%DUDASD" " ( QUEUE" parm3;
   EC = RESULT;

   n = 0;
   "QELEM";
   n = RC;
   RC = 0;

   /* Mainline */

   j = 0;
   Do i=1 To n By +1;
     Pull row;
     Parse VAR row unit volid;
     If unit <> "" Then;
       Do;
         j = j + 1;
         adr.j = "   PRINT OUTDD(OUTDD) - ";
         j = j + 1;
         adr.j = "      TRACKS(0,0,0,0) INDYNAM("volid") - ";
         j = j + 1;
         adr.j = "      ADMIN ";
       End;
   End;
   adr.0 = j;

   "DROPBUF";

   "EXECIO "adr.0" DISKW "tgt_ddname" ( STEM ADR. FINIS ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ON_OUTPUT;

   If tgt_dsname = "" Then;
     Do;
       Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME("tgt_ddname")";
       Address ISPEXEC "VIEW DATAID("tgtid") MACRO(NOTEPAD)";
       Address ISPEXEC "LMFREE DATAID("tgtid")";
     End;

   "FREE DD("tgt_ddname")";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Build ADRDSSU control statements.",
        pad hex04,
        " Format: BLDADR1 <dsname | NONE> < ( kwd=values... >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DSNAME:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "No dataset specified";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_ALLOC:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target dataset" tgt_dsname,
             "allocation failed, RC =" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "FREE DD("tgt_ddname")";
   DROPBUF;
   Return (-16);

   Error_ON_OUTPUT:

   ZEDSMSG = "EXECIO FAILED";
   ZEDLMSG = "Target dataset" tgt_dsname,
             "write failed, RC =" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "FREE  DD("tgt_ddname")";
   DROPBUF;
   Return (-16);
./ ADD NAME=BLDDD    0122-15257-18344-1623-00281-00235-00000-APLKS   42
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: Create DD statements for files found on          */
/*          the DSLIST panel.                                */
/*                                                           */
/*  Format: BLDDD  <dsname | NONE> < ( options  >            */
/*                                                           */
/*         dsname: is the name of the target SEQ/PDS         */
/*                 data set to place the DD statements.      */
/*                 Otherwise, the data will be placed        */
/*                 in the DEFAULT clipboard to be later      */
/*                 PASTEd.                                   */
/*                                                           */
/*        options: (default) SHR                             */
/*                 NEW - ddname, space, dcb, disp            */
/*                 SHR - ddname, disp                        */
/*                 DEL - ddname, space, dcb, disp            */
/*                                                           */
/*     Use: From the ISPF Dataset list (3.4) panel           */
/*          enter the macro in the command area.             */
/*                                                           */
/*          Prior filtering of the data set name list        */
/*          can be acomplished using DSNFLTR macro.          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC BLDDD    */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   dd. = "";
   ddpad = Copies(' ',13);
   n = 0;
   opt. = "";
   tgt_ddname = "CTLCRDS";
   tgt_dsname = "";      /*target SEQ/PDS for DD statements*/

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SHR";      /*SHR*/
   opt.0 = 1;

   /* Parse User Passed Parms */

   If parm2 <> "" & parm2 <> "NONE" Then;
     Do;
       tgt_dsname = Strip(Word(parm2,1),'B',"'");
       /* Test target dsname for validity */
       EC = Sysdsn("'"tgt_dsname"'");
       Select;
         When EC = "MEMBER NOT FOUND" Then;
           Do;
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " MOD ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         When EC = "DATASET NOT FOUND" Then;
           Do;
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " RECFM(F B)",
                  " LRECL(80)",
                  " BLKSIZE(0)",
                  " UNIT(SYSDA)",
                  " SPACE(1 5) TRACKS NEW ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         Otherwise;
           Signal Error_TGT_ALLOC;
       End;
     End;
   Else;
     Do;
       /*alloc SEQ temp, for CUT, and place in clipboard*/
       "ALLOC DD("tgt_ddname")",
            " DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)",
            " UNIT(SYSDA) SPACE(1 5) TRACKS",
            " NEW DELETE REUSE";
       EC = RC;
       If RC <> 0 Then;
         Signal Error_TGT_ALLOC;
     End;

   /* Collect all of the source data set names */

   "MAKEBUF";

   Call "STKDSNS";
   EC = RESULT;
   If EC <> 0 Then;
     Signal Error_STKDSNS_FAILED;

   count = 0;
   QELEM;
   count = RC;
   RC = 0;

   If count = 0 Then;
     Signal Error_STKDSNS_FAILED;

   /* Mainline */

   Select;
     When opt.1 = "SHR" Then;
       Do;
         Do i=1 To count By +1;
/*          Pull dsname ";" volinfo ";" spcinfo ";"
                 attrinfo ";" dateinfo ";" catname ";" .;  */
            Pull dsname ";" .;
            dsname = Strip(dsname,'T');
            n = n + 1;
            dd.n = "//xxxxxxxx DD  DISP=SHR,DSN=" || dsname;
         End;
       End;
     When opt.1 = "NEW" Then;
       Do;
         Do i=1 To count By +1
            Pull dsname ";" . ";" spcinfo ";" attrinfo ";" .;
            dsname = Strip(dsname,'T');
            Parse VAR attrinfo dsorg recfm lrecl blksz .;
            Parse VAR spcinfo trks . . device .;
            n = n + 1;
            dd.n = "//xxxxxxxx DD  DSN=" || dsname || ",";
            n = n + 1;
            dd.n = "//" || ddpad || "UNIT=" || device ||,
                   ",SPACE=(TRK,(" || trks || "),RLSE),";
            n = n + 1;
            dd.n = "//" || ddpad || "DCB=(DSORG=" || dsorg ||,
                   ",RECFM=" || recfm || ",LRECL=" || lrecl ||,
                   ",BLKSIZE=" || blksz || "),";
            n = n + 1;
            dd.n = "//" || ddpad || "DISP=(NEW,CATLG,DELETE)";
         End;
       End;
     When opt.1 = "DEL" Then;
       Do;
         Do i=1 To count By +1
            Pull dsname ";" . ";" spcinfo ";" attrinfo ";" .;
            dsname = Strip(dsname,'T');
            Parse VAR attrinfo dsorg recfm lrecl blksz .;
            Parse VAR spcinfo trks . . device .;
            n = n + 1;
            dd.n = "//OUTDD000 DD  DSN=" || dsname || ",";
            n = n + 1;
            dd.n = "//" || ddpad || "UNIT=" || device ||,
                   ",SPACE=(TRK,(1),RLSE),";
            n = n + 1;
            dd.n = "//" || ddpad || "DCB=(DSORG=" || dsorg ||,
                   ",RECFM=" || recfm || ",LRECL=" || lrecl ||,
                   ",BLKSIZE=" || blksz || "),";
            n = n + 1;
            dd.n = "//" || ddpad || "DISP=(MOD,DELETE,DELETE)";
         End;
       End;
     Otherwise;
       Nop;
   End;

   dd.0 = n;

   "DROPBUF";

   "EXECIO "dd.0" DISKW "tgt_ddname" ( STEM DD. FINIS ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ON_OUTPUT;

   If tgt_dsname = "" Then;
     Do;
       Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME("tgt_ddname")";
       Address ISPEXEC "VIEW DATAID("tgtid") MACRO(NOTEPAD)";
       Address ISPEXEC "LMFREE DATAID("tgtid")";
     End;

   "FREE DD("tgt_ddname")";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_OPTIONS:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("SHR",var,1) Then;
         opt.1 = "SHR";
       When Abbrev("NEW",var,1) Then;
         opt.1 = "NEW";
       When Abbrev("DELETE",var,1) Then;
         opt.1 = "DEL";
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Build DD statements.",
        pad hex04,
        " Format: BLDDD <dsname | NONE> ( SHR | NEW | DEL";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DSNAME:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "No dataset specified";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_ALLOC:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target dataset" tgt_dsname,
             "allocation failed, RC =" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_STKDSNS_FAILED:

   ZEDSMSG = "NO SOURCE DSNAMES";
   ZEDLMSG = "Nothing selected from DSLIST (=3.4)";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=BLDICAT  0109-16112-17292-0948-00294-00251-00000-APLKS   21
/* REXX 2017-10-19 */
/* --------------------------------------------------------- */
/* Purpose: Create IDCAMS  cmd  control statements           */
/*          to indrectly catalog data set names collected    */
/*          from the DSLIST (=3.4) panel.                    */
/*                                                           */
/*  Format: BLDICAT <dsname | NONE> < ( catname volist       */
/*                                                           */
/*         dsname: is the name of the target SEQ/PDS         */
/*                 data set to place the IDCAMS control      */
/*                 cards. Otherwise, the data will be        */
/*                 placed in the DEFAULT clipboard to be     */
/*                 later PASTEd.                             */
/*                                                           */
/*        options: (default) none                            */
/*                 catname - catalog name                    */
/*                 volist  - volid list                      */
/*                                                           */
/*     Use: From the ISPF DSLIST (=3.4) panel enter          */
/*          the exec in the command area.                    */
/*                                                           */
/*          Prior filtering of the data set name list        */
/*          can be acomplished using DSNFLTR exec.           */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC BLDICAT  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   idc. = "";
   opt. = "";            /*1=catalog name 2=volid list*/
   tgt_ddname = "CTLCRDS";
   tgt_dsname = "";      /*target SEQ/PDS for IDCAMS ctl stmts*/

   delcrd1 = "   DELETE ( -";
   delcrd2 = "          ) -";
   delcrd3 = "          NONVSAM NOSCRATCH -";
   delcrd4 = "          CATALOG ( -";
   delcrd5 = "                  )";
   delcrd6 = "   /* +++++++++++++++ */";
   defcrd1 = "   DEFINE NONVSAM ( -";
   defcrd2 = "                   NAME ( -";
   defcrd3 = "                        ) -";
   defcrd4 = "                   DEVT (0000) -";
   defcrd5 = "                   VOL ( -";
   defcrd6 = "                       ) -";
   defcrd7 = "                  ) -";
   defcrd8 = "          CATALOG ( -";
   defcrd9 = "                  )";
   defcrda = "   /* --------------- */";

   /* Parse the User Options */

   Parse VAR parm2 parm2 ' (' parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Parse User Passed Parms */

   If parm2 <> "" & parm2 <> "NONE" Then;
     Do;
       tgt_dsname = Strip(Word(parm2,1),"B","'");
       /* Test target dsname for validity */
       EC = Sysdsn("'"tgt_dsname"'");
       Select;
         When EC = "MEMBER NOT FOUND" Then;
           Do;
             /*alloc existing PDS/PDSE*/
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " MOD ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         When EC = "DATASET NOT FOUND" Then;
           Do;
             /*alloc new SEQ*/
             "ALLOC DSN('"tgt_dsname"')",
                  " DD("tgt_ddname")",
                  " DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)",
                  " UNIT(SYSDA) SPACE(1 5) TRACKS";
                  " NEW ";
             EC = RC;
             If RC <> 0 Then;
               Signal Error_TGT_ALLOC;
           End;
         Otherwise;
           Signal Error_TGT_ALLOC;
       End;
     End;
   Else;
     Do;
       /*alloc SEQ temp, for CUT, and place in clipboard*/
       "ALLOC DD("tgt_ddname")",
            " DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(0)",
            " UNIT(SYSDA) SPACE(1 5) TRACKS",
            " NEW DELETE REUSE";
       EC = RC;
       If RC <> 0 Then;
         Signal Error_TGT_ALLOC;
     End;

   /* Collect all of the source data set names */

   "MAKEBUF";

   Call "STKDSNS";
   EC = RESULT;
   If EC <> 0 Then;
     Signal Error_STKDSNS_FAILED;

   "QELEM";
   count = RC;
   If count = 0 Then;
     Signal Error_STKDSNS_FAILED;

   /* Mainline */

   n = 0;
   Do i=1 To count By +1;
/*   Pull dsname ";" volinfo ";" spcinfo ";"
          attrinfo ";" dateinfo ";" catname ";"; */
     Pull dsname ";" volinfo ";" . ";" . ";" . ";" catname ";" .;
     If catname = "" Then;
       catname = "unknown";
     dsname = Strip(dsname);
     catname = Strip(catname);
     If opt.1 <> "" Then;
       catalog = opt.1;
     Else;
       catalog = catname;
     If opt.2 <> "" Then;
       volist = opt.2;
     Else;
       volist = volinfo;
     n = n + 1;
     idc.n = delcrd1;
     n = n + 1;
     idc.n = Copies(" ",12) || dsname || " -";
     n = n + 1;
     idc.n = delcrd2;
     n = n + 1;
     idc.n = delcrd3;
     n = n + 1;
     idc.n = delcrd4;
     n = n + 1;
     idc.n = Copies(" ",20) || catalog || " -";
     n = n + 1;
     idc.n = delcrd5;
     n = n + 1;
     idc.n = delcrd6;
     n = n + 1;
     idc.n = defcrd1;
     n = n + 1;
     idc.n = defcrd2;
     n = n + 1;
     idc.n = Copies(" ",26) || dsname || " -";
     n = n + 1;
     idc.n = defcrd3;
     n = n + 1;
     idc.n = defcrd4;
     n = n + 1;
     idc.n = defcrd5;
     n = n + 1;
     idc.n = Copies(" ",25) || volist || " -";
     n = n + 1;
     idc.n = defcrd6;
     n = n + 1;
     idc.n = defcrd7;
     n = n + 1;
     idc.n = defcrd8;
     n = n + 1;
     idc.n = Copies(" ",20) || catalog || " -";
     n = n + 1;
     idc.n = defcrd9;
     n = n + 1;
     idc.n = defcrda;
   End;
   idc.0 = n;

   "DROPBUF";

   "EXECIO "idc.0" DISKW "tgt_ddname" ( STEM IDC. FINIS ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ON_OUTPUT;

   If tgt_dsname = "" Then;
     Do;
       Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME("tgt_ddname")";
       Address ISPEXEC "VIEW DATAID("tgtid") MACRO(NOTEPAD)";
       Address ISPEXEC "LMFREE DATAID("tgtid")";
     End;

   "FREE DD("tgt_ddname")";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_OPTIONS:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Pos('.',var) > 0 Then;
         opt.1 = var;         /*catname*/
       When Length(var) = 6 Then;
         opt.2 = opt.2 var;   /*volid list*/
       Otherwise;
         Nop;
     End;
   End;
   opt.2 = Strip(opt.2);

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Build IDCAMS control statements to indirectly catalog",
        pad hex04,
        "         desired data sets.",
        pad hex04,
        " Format: BLDICAT < dsname | NONE > < ( catname volist >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DSNAME:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "No dataset specified";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_ALLOC:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target dataset" tgt_dsname,
             "allocation failed, RC =" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_STKDSNS_FAILED:

   ZEDSMSG = "NO SOURCE DSNAMES";
   ZEDLMSG = "Nothing selected from DSLIST (=3.4)";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=BLDIEBC  0121-14130-18344-1625-00505-00428-00000-APLKS   14
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: Invoke BLDIEBC to collect the member names       */
/*          of the source PDS; create a PARMLIB member to    */
/*          contain the IEBCOPY control statements for       */
/*          either a source library or a program library.    */
/*                                                           */
/*  Format: BLDIEBC srcpds_dsname < ( options >              */
/*                                                           */
/*  srcpds_dsname: is the name of the source PDS to          */
/*                 collect the member names and create       */
/*                 IEBCOPY control statements and place      */
/*                 them in the proper PARMLIB member.        */
/*                                                           */
/* options:                                                  */
/*          SELECT followed by starting member name,         */
/*             colon, and ending member name                 */
/*          ex: SELECT AMA : AMC                             */
/*                                                           */
/*     Use: From the ISPF Member List (3.4) enter the exec   */
/*          in the command area beside the source PDS.       */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC BLDIEBC */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the source PDS:";
       Parse UPPER EXTERNAL parm2;
     End;

   /* Initialize Variables */

   var. = "";
   fmem = "";
   flen = 0;
   tmem = "";
   tlen = 0;

   lu_libtype_base = "BATLOAD BATLOAD CICSLOAD CICSLOD CTCCOPY CTCCOPY ",
                     "EZTLIB EZTLIB MAPCOPY MAPCOPY SRCBASE SRCBASE ",
                     "SRCLIB SRCLIB";
   lu_libtype_optional = "BATLOAD BATLODO SRCLIB SRCLIBO";
   srcpds_dsname = "";       /* source PDS */
   tgtpds_dsname = "";       /* target PDS - PARMLIB for IEBCOPY stmts */
   tgtpds_mbrname = "";      /* target PDS member for IEBCOPY stmts */

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3 ;
   If parm3 <> "" Then;
     Call Extract_OPTIONS;

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     srcpds_dsname = Strip(Word(parm2,1),"B","'");
   Else;
     Signal Error_NO_DATA;

   /* Test source dsname for validity */

   Call Validate_DSNAME srcpds_dsname;
   If EC < 16 Then;
     If CC < 0 Then;
       Signal Error_INVALID_DSNAME;
     Else;
       Nop;
   Else;
     Signal Error_INVALID_DSNAME;

   /* Derive the PARMLIB member name */

   Parse VAR srcpds_dsname libset "." libgroup "." libtype "." librest;
   If libgroup = "ALLTEL" | libgroup = "BANCORP" Then;
     tgtpds_mbrname = Substr(libgroup,1,1);
   Select;
     When librest = "" Then;
       Do;
         n = Wordpos(libtype,lu_libtype_base);
         If n > 0 Then;
           tgtpds_mbrname = tgtpds_mbrname || Word(lu_libtype_base,n+1);
       End;
     When librest = "OPTIONAL" Then;
       Do;
         n = Wordpos(libtype,lu_libtype_optional);
         If n > 0 Then;
           tgtpds_mbrname = tgtpds_mbrname || Word(lu_libtype_optional,n+1);
       End;
     Otherwise;
       Nop;
   End;

   If Length(tgtpds_mbrname) > 1 Then;
     Nop;
   Else;
     Do;
       tgtpds_mbrname = "";
       Say "Invalid member name; Enter member name: ";
       Pull tgtpds_mbrname .;
       If tgtpds_mbrname = "" Then;
         Signal Error_NO_MEMBER;
     End;

   tgtpds_dsname = libset || ".PROD.PARMLIB";

   /* Collect all of the member names in the source PDS */

   MAKEBUF;

   Call "STKMBRS" srcpds_dsname;
   EC = RESULT;
   If EC <> 0 Then;
     Signal Error_SRC_DATASET;

   count = 0;
   QELEM;
   count = RC;
   RC = 0;

   If count = 0 Then;
     Signal Error_SRC_DATASET;

   /* Setup target Output PARMLIB dataset */

   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtpds_dsname")",
        " ENQ(EXCLU)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_DATASET;

   Address ISPEXEC "LMOPEN DATAID("tgtid")",
        " OPTION(OUTPUT)",
        " LRECL("tgtlrecl")",
        " RECFM("tgtrecfm")",
        " ORG("tgtorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_OPEN;

   If tgtorg <> "PO" Then;
     Signal Error_TGT_ORG;
   If tgtrecfm <> "FB" Then;
     Signal Error_TGT_RECFM;
   If tgtlrecl <> 80 Then;
     Signal Error_TGT_LRECL;

   /* Delete pre-existing target member */

   Address ISPEXEC "LMMDEL DATAID("tgtid")",
        " MEMBER("tgtpds_mbrname")";
   EC = RC;
   If RC > 8 Then;
     Signal Error_TGT_MDEL;

   /* Mainline */

   If SYSRECFM = "U" Then;   /*test recfm of the source PDS*/
     output = "     COPYMOD INDD=SYSUT1,OUTDD=SYSUT2 ";
   Else;
     output = "     COPY    INDD=SYSUT1,OUTDD=SYSUT2 ";

   output = Left(output,tgtlrecl);
   /* Insert record in target member */
   Address ISPEXEC "LMPUT DATAID("tgtid")",
        " MODE(INVAR)",
        " DATALOC(output)",
        " DATALEN("tgtlrecl")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_PUT;

   output = "     SELECT  MEMBER=(, ";
   output = Overlay("C",Left(output,tgtlrecl),72);
   /* Insert record in target member */
   Address ISPEXEC "LMPUT DATAID("tgtid")",
        " MODE(INVAR)",
        " DATALOC(output)",
        " DATALEN("tgtlrecl")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_PUT;

   pad = Copies(" ",15);
   output = "";

   Do i=1 to count by 1;
     /* Retrieve from the external data queue */
     Pull mbrname;
     If flen = 0 Then;
       Do;
         Call Output_WRITE;
         Iterate i;
       End;
     If flen > 0 & tlen = 0 Then;
       If Substr(mbrname,1,flen) = fmem Then;
         Do;
           Call Output_WRITE;
           Iterate i;
         End;
     If flen > 0 & tlen > 0 Then;
       If Substr(mbrname,1,flen) >= fmem &,
            Substr(mbrname,1,tlen) <= tmem Then;
         Do;
           Call Output_WRITE;
           Iterate i;
         End;
   End;

   pad = Copies(" ",15);
   output = pad || ")";
   output = Left(output,tgtlrecl);
   /* Insert record in target member */
   Address ISPEXEC "LMPUT DATAID("tgtid")",
          " MODE(INVAR)",
          " DATALOC(output)",
          " DATALEN("tgtlrecl")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_PUT;

   /* Flush output buffers of new target member */

   Address ISPEXEC "LMMADD DATAID("tgtid")",
        " MEMBER("tgtpds_mbrname")";
   EC = RC;
   If RC > 4 Then;
     Signal Error_TGT_MADD;

   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_CLOSE;

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   DROPBUF;
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_OPTIONS:

   Parse VAR parm3 var.1 parm3;
   var.1 = Strip(var.1);
   Select;
     When Abbrev("SELECT",var.1) Then;
       Do;
         Parse VAR parm3 var.2 ":" var.3;
         fmem = Strip(var.2);
         flen = Length(fmem);
         tmem = Strip(var.3);
/*       tmem = Strip(var.3,"T",")"); */
         tlen = Length(tmem);
       End;
     Otherwise;
       Signal Error_INVALID_OPTS;
   End;

   Return (0);

   Output_WRITE:

   output = pad || "(" || Word(mbrname,1) || ",,R),";
   output = Overlay("C",Left(output,tgtlrecl),72);

   /* Insert record in target member */
   Address ISPEXEC "LMPUT DATAID("tgtid")",
          " MODE(INVAR)",
          " DATALOC(output)",
          " DATALEN("tgtlrecl")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_PUT;

   output = "";

   Return (0);

   Validate_DSNAME: Procedure Expose EC CC SYSRECFM;

   /* Test dsname for validity */
   Arg dsname;
   CC = 0;
   arg_string = "'"dsname"' NORECALL NOSMSINFO";
   EC =  Listdsi(arg_string);
   If EC < 16 Then;
     Do;
       If SYSREASON = 0 Then;
         If SYSDSORG = "PO" | SYSDSORG = "POU" Then;
           Nop;
         Else;
           CC = -12;
       Else;
         If SYSREASON = 3  | SYSREASON = 5  | SYSREASON = 24 Then;
           CC = -12;
         Else;
           CC = -24;
     End;

   Return (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Build IEBCOPY control statements for either",
        pad hex04,
        "         a source library or a program library.",
        pad hex04,
        " Format: BLDIEBC srcpds_dsname ",
        pad hex04,
        "                 < ( SELECT begmbr : endmbr >";

   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_NO_MEMBER:

   ZEDSMSG = "MISSING MEMBER";
   ZEDLMSG = "NO MEMBER SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "INVALID USER OPTIONS:" var.1 var.2 var.3;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_DSNAME:

   ZEDSMSG = "INVALID DSNAME";
   ZEDLMSG = "INVALID DATA SET NAME:" dsname " CC = " CC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_DATASET:

   ZEDSMSG = "DATASET NOT FOUND";
   ZEDLMSG = "SOURCE DATASET " srcpds_dsname,
             " NOT FOUND OR EMPTY, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-4);

   Error_TGT_DATASET:

   ZEDSMSG = "DATASET NOT FOUND";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " NOT FOUND, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_TGT_OPEN:

   ZEDSMSG = "DATASET NOT OPENED";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " NOT OPENED, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_ORG:

   ZEDSMSG = "INVALID ORG";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " ORG <> PO";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_RECFM:

   ZEDSMSG = "INVALID RECFM";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " RECFM <> FB";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_LRECL:

   ZEDSMSG = "INVALID LRECL";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " LRECL <> 80";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_MDEL:

   ZEDSMSG = "MEMBER DELETE failed";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " DELETE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_PUT:

   ZEDSMSG = "PUT FAILED";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " PUT FAILED, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_MADD:

   ZEDSMSG = "MEMBER ADD FAILED";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " ADD failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_CLOSE:

   ZEDSMSG = "CLOSE FAILED";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " CLOSE FAILED, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE FAILED";
   ZEDLMSG = "TARGET DATASET" tgtpds_dsname,
             " FREE FAILED, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);
./ ADD NAME=BULK     0143-18053-19270-1442-01956-01600-00000-APLKS   43
/* REXX 2019-09-27 */
   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

/* Trace S; */
   Call Test_ATRIAN;          /*area of a right triangle*/
   Call Test_BSRCH;           /*binary search of vector*/
   Call Test_FSRCH;           /*fibonaccian search of vector*/
   Call Test_ISRCH;           /*interpolation search of nbr vector*/
   Call Test_GCD;             /*greatest common divisor*/
   Call Test_LCM;             /*least common multiple*/
   Call Test_FACTORAL;        /*factoral*/
   Call Test_FIB_LIST;        /*fibonacci sequence*/
   Call Test_FIB;             /*fibonacci vector*/
   Call Test_FLOOR;           /*floor*/
   Call Test_CEILING;         /*ceiling*/
   Call Test_MOD;             /*mod*/
   Call Test_HSORTA;          /*heap sort ascending*/
   Call Test_QSORTA;          /*quick sort I ascending*/
   Call Test_QSORTD;          /*quick sort I descending*/
   Call Test_QSORTA1;         /*quick sort II ascending*/
   Call Test_SSORTA;          /*shell sort ascending*/
   Call Test_AVERAGE;         /*mean,median,mode,variance,std dev*/
   Call Test_PRIME;           /*prime number vector*/
   Call Test_D2R;             /*decimal to roman numerial*/
   Call Test_R2D;             /*roman numerial to decimal*/
   Call Test_SHUFFLE;         /*shuffle a vector*/
   Call Test_SQRT;            /*square root*/
/* Call Test_MATCH;   */

   Return 0;

/* ------------------------------------------------------- */

Test_ATRIAN:
   a = 3; b = 4; c = 5;
   area = ATRIAN(a,b,c);
   Say "Area of the triangle (3,4,5) is =" area;

   Return 0;

   ATRIAN: Procedure

/* REXX function
   Invoke as: ATRIAN(a,b,c,nd);
   Compute the area of a triangle knowing the length of
   sides a, b, c. For a right-angled triangle a is the
   height, b is the base length, and c is the hypotenuse
   or longest side. a**2 + b**2 = c**2 where a=3,b=4,c=5
   area = 6.

   ------------------------------------------------------- */

   Parse Arg a,b,c,nd;

   If nd = "" Then;
     nd = 9;

   Numeric Digits nd;

   If b > a Then;
     Parse VALUE a b With b a;     /*swap a & b, make a > b*/
   If c > a Then;
     Parse VALUE a c With c a;     /*swap a & c, make a > c*/
   If c > b Then;
     Parse VALUE b c With c b;     /*swap b & c, make b > c*/
   If c < (a - b) Then;
     Call ERROR "No such triangle exist";
   Else;
     Do;
       t1 = b + c + a;
       t2 = b - a + c;
       t3 = a - b + c;
       t4 = b - c + a;
       Return SQRT(t1 * t2 * t3 * t4, nd) / 4;
     End;

   ERROR:

   Say "ATRIAN error on" ARG(1);

   Exit;

/* ------------------------------------------------------- */

Test_BSRCH:

   A.0 = 15; A.1 = 1; A.2 = 2; A.3 = 3; A.4 = 5; A.5 = 8;
   A.6 = 13; A.7 = 21; A.8 = 34; A.9 = 55; A.10 = 89;
   A.11 = 92; A.12 = 92; A.13 = 92; A.14 = 92; A.15 = 95;

   Say "Find a matching entry for 1 (1)";
   val = 1;
   idx = BSRCH(A.0,val);
   If idx = 0 Then;
     Say "BSRCH  Value" val "not found in vector" idx;
   Else;
     Say "BSRCH  Value" val "found in position" idx;

   Say "Find a matching entry for 95 (15)";
   val = 95;
   idx = BSRCH(A.0,val);
   If idx = 0 Then;
     Say "BSRCH  Value" val "not found in vector" idx;
   Else;
     Say "BSRCH  Value" val "found in position" idx;

   Say "Find a matching entry for 21 (7)";
   val = 21;
   idx = BSRCH(A.0,val);
   If idx = 0 Then;
     Say "BSRCH  Value" val "not found in vector" idx;
   Else;
     Say "BSRCH  Value" val "found in position" idx;

   Say "Find a matching entry for 34 (8)";
   val = 34;
   idx = BSRCH(A.0,val);
   If idx = 0 Then;
     Say "BSRCH  Value" val "not found in vector" idx;
   Else;
     Say "BSRCH  Value" val "found in position" idx;

   Say "Find a matching entry for 55 (9)";
   val = 55;
   idx = BSRCH(A.0,val);
   If idx = 0 Then;
     Say "BSRCH  Value" val "not found in vector" idx;
   Else;
     Say "BSRCH  Value" val "found in position" idx;

   Say "Find a matching entry for 92 (11,12,13,14)";
   val = 92;
   idx = BSRCH(A.0,val);
   If idx = 0 Then;
     Say "BSRCH  Value" val "not found in vector" idx;
   Else;
     Say "BSRCH  Value" val "found in position" idx;

   Say "Find a non-existing entry";
   val = 100
   idx = BSRCH(A.0,val);
   If idx = 0 Then;
     Say "BSRCH  Value" val "not found in vector" idx;
   Else;
     Say "BSRCH  Value" val "found in position" idx;

   Say "Find the 1st matching entry for 1 (1)";
   val = 1;
   idx = BSRCH1(A.0,val);
   If idx = 0 Then;
     Say "BSRCH1 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH1 Value" val "found in position" idx;

   Say "Find the first matching entry for 95 (15)";
   val = 95;
   idx = BSRCH1(A.0,val);
   If idx = 0 Then;
     Say "BSRCH1 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH1 Value" val "found in position" idx;

   Say "Find the first matching entry for 21 (7)";
   val = 21;
   idx = BSRCH1(A.0,val);
   If idx = 0 Then;
     Say "BSRCH1 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH1 Value" val "found in position" idx;

   Say "Find the first matching entry for 34 (8)";
   val = 34;
   idx = BSRCH1(A.0,val);
   If idx = 0 Then;
     Say "BSRCH1 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH1 Value" val "found in position" idx;

   Say "Find the first matching entry for 55 (9)";
   val = 55;
   idx = BSRCH1(A.0,val);
   If idx = 0 Then;
     Say "BSRCH1 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH1 Value" val "found in position" idx;

   Say "Find the first matching entry for 92 (11,12,13,14)";
   val = 92;
   idx = BSRCH1(A.0,val);
   If idx = 0 Then;
     Say "BSRCH1 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH1 Value" val "found in position" idx;

   Say "Find a non-existing entry"
   val = 100;
   idx = BSRCH1(A.0,val);
   If idx = 0 Then;
     Say "BSRCH1 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH1 Value" val "found in position" idx;

   Say "Find the 1st >= matching entry for 1 (1)";
   val = 1;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 95 (15)";
   val = 95;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 21 (7)";
   val = 21;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 34 (8)";
   val = 34;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 55 (9)";
   val = 55;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 92 (11,12,13,14)";
   val = 92;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 12 : 13 (6)";
   val = 12;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 20 : 21 (7)";
   val = 20;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 60 : 89 (10)";
   val = 60;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Say "Find the 1st >= matching entry for 100 : ... (16)";
   val = 100;
   idx = BSRCH2(A.0,val);
   If idx = 0 Then;
     Say "BSRCH2 Value" val "not found in vector" idx;
   Else;
     Say "BSRCH2 Value" A.idx "found in position" idx;

   Return 0;

   BSRCH: Procedure Expose A.

/* REXX function
   Binary Search unique keys.
   Keys are in ascending order within the vector.
   Keys are all the same length and datatype, if not
   numbers.
   Invoke as: BSRCH(occurs,srcharg);
   Find the position in vector A. of srcharg. If found
   return idx otherwise return 0.

   ------------------------------------------------------- */

   Parse ARG occurs,srcharg;

   lpt = 1;
   rpt = occurs;

   Do While lpt <= rpt;
     mpt = (lpt + rpt) % 2;
     Say "  peeking at pos" mpt "found" A.mpt;
     If srcharg = A.mpt Then;
       Leave;
     If srcharg < A.mpt Then;
       rpt = mpt - 1;
     Else;
       lpt = mpt + 1;
   End;

   If A.mpt = srcharg Then;
     Return mpt;
   Else;
     Return 0;

   Exit;

   BSRCH1: Procedure Expose A.

/* REXX function
   Binary Search non-unique keys (1st occurrence).
   Keys are in ascending order within the vector.
   Keys are all the same length and datatype, if not
   numbers.
   Invoke as: BSRCH1(occurs,srcharg);
   Find the position in vector A. of srcharg. If found
   return idx otherwise return 0.

   ------------------------------------------------------- */

   Parse ARG occurs,srcharg;

   lpt = 0;
   rpt = occurs;

   Do While lpt+1 <> rpt;
     mpt = (lpt+rpt)%2;
     Say "  peeking at pos" mpt "found" A.mpt;
     If A.mpt < srcharg Then;
       lpt = mpt;
     Else;
       rpt = mpt;
   End;

   If rpt > occurs | A.rpt <> srcharg Then;
     Return 0;

   Return rpt;

   BSRCH2: Procedure Expose A.

/* REXX function
   Binary Search unique keys.
   Keys are in ascending order within the vector.
   Keys are all the same length and datatype, if not
   numbers.
   Invoke as: BSRCH2(occurs,srcharg);
   Find the position in vector A. of srcharg. If found
   return idx otherwise return idx of vector with the next
   key > the one wanted.

   ------------------------------------------------------- */

   Parse ARG occurs,srcharg;

   lpt = 1;
   rpt = occurs;
   gteq = 0;

   Do While lpt <= rpt;
     mpt = (lpt+rpt)%2;
     Say "  peeking at pos" mpt "found" A.mpt;
     Select;
       When srcharg < A.mpt Then;
         Do;
           rpt = mpt-1;
           gteq = mpt;
         End;
       When srcharg > A.mpt Then;
         lpt = mpt+1;
       Otherwise;
         Return mpt;
     End;
   End;

   Return gteq;

/* ------------------------------------------------------- */

Test_FSRCH:

   A.0 = 15; A.1 = 1; A.2 = 2; A.3 = 3; A.4 = 5; A.5 = 8;
   A.6 = 13; A.7 = 21; A.8 = 34; A.9 = 55; A.10 = 89;
   A.11 = 92; A.12 = 92; A.13 = 92; A.14 = 92; A.15 = 95;

   F.0 = 11;
   F.1 = 0; F.2 = 1; F.3 = 1; F.4 = 2; F.5 = 3; F.6 = 5;
   F.7 = 8; F.8 = 13; F.9 = 21; F.10 = 34; F.11 = 55;

   sarg = A.1;
   k = 9;
   Say "looking for" sarg "in pos 1";
   idx = FSRCH(A.0,sarg,k);
   If idx > 0 Then;
     Say "FSRCH found" A.1 "at pos" idx;
   Else;
     Say A.1 "was not found";

   sarg = A.15;
   k = 9;
   Say "looking for" sarg "in pos 15";
   idx = FSRCH(A.0,sarg,k);
   If idx > 0 then;
     Say "FSRCH found" sarg "at pos" idx;
   Else;
     Say sarg "was not found";

   sarg = A.8;
   k = 9;
   Say "looking for" sarg "in pos 8";
   idx = FSRCH(A.0,sarg,k);
   If idx > 0 then;
     Say "FSRCH found" sarg "at pos" idx;
   Else;
     Say sarg "was not found";

   sarg = A.9;
   k = 9;
   Say "looking for" sarg "in pos 9";
   idx = FSRCH(A.0,sarg,k);
   If idx > 0 then;
     Say "FSRCH found" sarg "at pos" idx;
   Else;
     Say sarg "was not found";

   Return 0;

   FSRCH: Procedure Expose A. F.

/* REXX function
   Fibonaccian Search unique keys.
   Keys are in ascending order within the vector.
   Keys are all the same length and datatype, if not
   numbers.
   Invoke as: FSRCH(occurs,srcharg,k);
   Where k is the subscript of the starting Fibonacci number.
   If k = 0 then initialize k to the appropriate subscript
   of the Fibonacci number that is >= occurs.
   Find the position in vector A. of srcharg. If found
   return idx otherwise return 0.

   ------------------------------------------------------- */

   Parse ARG occurs,srcharg,k;

   If k = 0 Then;
     k = BSRCH2(F.0,occurs);

   lpt = 0;
   Do While k>0;
     k = k-1;
     rpt = lpt+F.k;
     Say "  peeking at pos" rpt "found" A.rpt;
     /* note that k has already been decremented once */
     Select;
       When rpt > occurs | srcharg < A.rpt Then;
         /* index is out of bounds or srcharg in 1st part */
         Nop;
       When srcharg > A.rpt Then;
         /* srcharg in 2nd part */
         Do;
           lpt = rpt;
           k = k-1;
         End;
       Otherwise;
         /* srcharg found in A.rpt */
         Return rpt;
     End;
   End;

   /* not found */
   Return 0;

/* ------------------------------------------------------- */

Test_ISRCH:

   A.0 = 10; A.1 = 1; A.2 = 2; A.3 = 3; A.4 = 5; A.5 = 8;
   A.6 = 13; A.7 = 21; A.8 = 34; A.9 = 55; A.10 = 89;

   val = 1;
   Say "looking for" val "in pos 1";
   idx = ISRCH(A.0,val);
   If idx > A.0 Then;
     Say "ISRCH  Value" val "not found in vector";
   Else;
     Say "ISRCH  Value" val "found in position" idx;

   val = 89;
   Say "looking for" val "in pos 10";
   idx = ISRCH(A.0,val);
   If idx > A.0 Then;
     Say "ISRCH  Value" val "not found in vector";
   Else;
     Say "ISRCH  Value" val "found in position" idx;

   val = 5;
   Say "looking for" val "in pos 4";
   idx = ISRCH(A.0,val);
   If idx > A.0 Then;
     Say "ISRCH  Value" val "not found in vector";
   Else;
     Say "ISRCH  Value" val "found in position" idx;

   val = 100;
   idx = ISRCH(A.0,val);
   If idx > A.0 Then;
     Say "ISRCH  Value" val "not found in vector" idx;
   Else;
     Say "ISRCH  Value" val "found in position" idx;

   Return 0;

   ISRCH: Procedure Expose A.

/* REXX function
   Interpolation Search
   Keys are in ascending order within the vector.
   Keys are all the same length and datatype, if not
   numbers.
   Invoke as: ISRCH(occurs,srcharg);
   Find the position in vector A. of srcharg. If found
   return idx otherwise return occurs+1.

   ------------------------------------------------------- */

   Parse ARG occurs,srcharg;

   lpt = 1;
   rpt = occurs;

   Do While (A.rpt >= srcharg) & (srcharg > A.lpt);
     mpt = lpt + TRUNC((srcharg-A.lpt)/(A.rpt-A.lpt)*(rpt-lpt));
     Say "  peeking at pos" mpt "found" A.mpt;
     If srcharg > A.mpt Then;
       lpt = mpt + 1;
     Else;
       If srcharg < A.mpt Then;
         rpt = mpt - 1;
       Else;
         lpt = mpt;
   End;

   If A.lpt = srcharg Then;
     Return lpt;
   Else;
     Return occurs + 1;

/* ------------------------------------------------------- */

Test_GCD:

   x = GCD(100,25);
   Say "GCD of (100,25) =" x;

   x = GCD(27,9);
   Say "GCD of (27,9) =" x;

   Return 0;

   GCD: Procedure

/* REXX function
   Invoke as: GCD(int1,int2);
   Find the greatest common divisor of two integers,
   not both zero, is the largest integer that divides
   both of them.  Returns "INVALID" if both values are
   not integers.

   ------------------------------------------------------- */

   Parse ARG int1,int2;

   If Datatype(int1,'W') = 1 & Datatype(int2,'W') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   Do While int2 > 0;
     Parse VALUE (int2 int1//int2) With int1 int2;
   End

   Return int1;

/* ------------------------------------------------------- */

Test_LCM:

   x = LCM(100,25);
   Say "LCM of (100,25) =" x;

   x = LCM(27,9);
   Say "LCM of (27,9) =" x;

   Return 0;

   LCM: Procedure

/* REXX function
   Invoke as: LCM(val1,val2);
   Find the least common multiple LCM of two integers.
   It is defined to be the smallest positive integer which
   is a multiple.  Returns "INVALID" if both values are
   not integers.

   ------------------------------------------------------- */

   Parse ARG int1,int2;

   If Datatype(int1,'W') = 1 & Datatype(int2,'W') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   Return int1 * int2 / GCD(int1,int2);

/* ------------------------------------------------------- */

Test_FACTORAL:

   Drop x;
   x = FACT(12,12);
   Say "FACTORAL of 12 =" x;

   Return 0;

   FACT: Procedure

/* REXX function
   Invoke as: FACT(int,nd);
   Multiply the integers from 1 to int.

   Returns "INVALID" if value is not integer.

   ------------------------------------------------------- */

   Parse ARG int,nd;

   If Datatype(int,'W') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   If nd = "" Then;
     nd = 9;

   Numeric Digits nd;

   fact = 1;
   Do i=2 To int;
     fact = fact * i;
   End;

   Return fact;

/* ------------------------------------------------------- */

Test_FIB_LIST:

   x = FIB_LIST(25);
   Say "Fibonacci sequence =" x;

   Return 0;

   FIB_LIST: Procedure

/* REXX function
   Invoke as: FIB_LIST(int);
   Return the sequence 0,1,1,2,3,5,8,13,21,34,...
   Fibonacci sequence: F0=0;F1=1;...;Fn=Fn-1+Fn-2 for n>2

   Returns "INVALID" if value is not integer.

   ------------------------------------------------------- */

   Parse ARG int;

   If Datatype(int,'W') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   int1 = 0;
   int2 = 1;

   If int = 1 Then;
     Return "0";
   If int = 2 Then;
     Return "0 1";

   fib_seq = "0 1";
   Do i = 3 to int;
     int3 = int1 + int2;
     int1 = int2;
     int2 = int3;
     fib_seq = fib_seq Strip(int3,'L',0);
   end
   Return fib_seq;

/* ------------------------------------------------------- */

Test_FIB:

   Drop F.;
   x = FIB(1000);

   Do i=1 To F.0;
     Say i "FIB(1000) vector =" F.i;
   End;

   Return 0;

   FIB: Procedure Expose F.

/* REXX function
   Invoke as: FIB(int);
   Build vector F with Fibonacci numbers until > int.
   Fibonacci sequence: F0=0;F1=1;...;Fn=Fn-1+Fn-2 for n>2

   Returns "INVALID" if value is not integer.

   ------------------------------------------------------- */

   Parse ARG int;

   If Datatype(int,'W') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   int1 = 0;
   int2 = 1;

   F.1 = 0; F.2 = 1;
   Do i=3 By +1;
     int3 = int1 + int2;
     int1 = int2;
     int2 = int3;
     F.i = Strip(int3,'L',0);
     If F.i > int Then;
       Leave;
   End;

   F.0 = i;

   Return 0;

/* ------------------------------------------------------- */

Test_FLOOR:

   x = FLOOR(4);
   Say "Floor for 4 =" x;
   x = FLOOR(-4.1);
   Say "Floor for -4.1 =" x;
   x = FLOOR(4.1);
   Say "Floor for 4.1 =" x;
   x = FLOOR(4.9);
   Say "Floor for 4.9 =" x;

   Return 0;

   FLOOR: Procedure

/* REXX function
   Invoke as: FLOOR(real);
   If x is any real number
   |x| or FLOOR(x) = the greatest integer <= x;

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real;

   If Datatype(real,'N') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   Return Trunc(real) - (real < 0) * (real <> Trunc(real));

/* ------------------------------------------------------- */

Test_CEILING:

   x = CEILING(4);
   Say "CEILING for 4 =" x;
   x = CEILING(-4.1);
   Say "CEILING for -4.1 =" x;
   x = CEILING(4.1);
   Say "CEILING for 4.1 =" x;
   x = CEILING(4.9);
   Say "CEILING for 4.9 =" x;

   Return 0;

   CEILING: Procedure

/* REXX function
   Invoke as: CEILING(real);
   If x is any real number
   |x| or CEILING(x) = the least integer >= x.

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real;

   If Datatype(real,'N') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   Return Trunc(real) + (real > 0) * (real <> Trunc(real));

/* ------------------------------------------------------- */

Test_MOD:

   x = MOD(5,-3);
   Say "MOD of (5,-3) =" x;
   x = MOD(18,-3);
   Say "MOD of (18,-3) =" x;
   x = MOD(-2,-3);
   Say "MOD of (-2,-3) =" x;

   Return 0;

   MOD: Procedure

/* REXX function
   Invoke as: MOD(real1,real2)
   If x and y are any real numbers

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real1,real2;

   If Datatype(real1,'N') = 1 & Datatype(real2,'N') Then;
     Nop;
   Else;
     Return "INVALID";

   If real2 = 0 Then;
     Return real1;

   Return real1 - real2 * FLOOR(real1/real2);

/* ------------------------------------------------------- */

Test_HSORTA:

   seed = Random(,,1956256);
   Do i=1 To 50;
     A.i = Random();
   End;
   A.0 = 50;

   Say "Numbers before HSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   x = HSORTA(A.0);

   Say "Numbers after HSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   Return 0;

   HSORTA: Procedure Expose A.

/* REXX function
   Invoke as: HSORTA(occurs)
   Heapsort by J. W. J. Williams is a in place sorting
   algorithm whose worst-case running time is O(N*lgN) on
   an input vector.

   Given an vector A. of n elements the result of sorting
   the vector in place is to arrange elements of A. so that
   A.1<=A.2<=...<=A.n

   ------------------------------------------------------- */

   Parse ARG occurs;

   Do i = occurs % 2 To 1 By -1;
     x = SIFT(i,occurs);
   End;

   Do i = occurs To 2 By -1;
     Parse VALUE A.1 A.i With A.i A.1; /*swap places*/
     x = SIFT(1,i-1);
   End;

   Return 0;

   SIFT: Procedure Expose A.

   Parse ARG lpt,rpt;

   i = lpt;
   W = A.i;
   j = 2 * i;
   jp1 = j + 1;

   If j < rpt Then;
     If A.j < A.jp1 Then;
       j = jp1;

   Do While j <= rpt;
     If W >= A.j Then;
       Leave;
     A.i = A.j;
     i = j;
     j = 2 * i;
     jp1 = j + 1;
     If j < rpt Then;
       If A.j < A.jp1 Then;
         j = jp1;
   End;

   A.i = W;

   Return 0;

/* Here is another version of HSORTA.  This one does not use any
   temporary storage to hold the vector entry being move around

   REXX function
   Invoke as: HSORTA(n)
   Heapsort by J. W. J. Williams is a in place sorting
   algorithm whose worst-case running time is O(N*lgN) on
   an input vector.

   Given an vector v. of n elements the result of sorting
   the vector in place is to arrange elements of v. so that
   v.1<=v.2<=...<=v.n

   ------------------------------------------------------- $/

   Parse ARG n;

   Do i = n%2 To 1 By -1;
     x = PERC(i,n);
   End;

   Do i=1 To v.0;
     Say v.i;
   End;

   Do i = n To 2 By -1;
     Parse VALUE v.1 v.i With v.i v.1; /*swap places*/
     x = PERC(1,i-1);
   End;

   Do i=1 To v.0;
     Say v.i;
   End;
   Return 0;

   PERC: Procedure Expose v.

   Parse ARG lbnd,ubnd;

   p = lbnd;
   lchld = 2*p;
   rchld = lchld+1;

   If lchld < ubnd Then;
     If v.lchld < v.rchld Then;
       lchld = rchld;

   Do While lchld <= ubnd;
     If v.p > v.lchld Then;
       Leave;
     Parse VALUE v.p v.lchld With v.lchld v.p; /*swap places*/
     p = lchld;
     lchld = 2*p;
     rchld = lchld+1;
     If lchld < ubnd Then;
       If v.lchld < v.rchld Then;
         lchld = rchld;
   End;

   Return 0;
*/

/* Here is another version of HSORTA.  This one will sort on a
   particular word in the row of a vector.

   REXX function
   Invoke as: HSORTA(occurs,field)
   Heapsort by J. W. J. Williams is a in place sorting
   algorithm whose worst-case running time is O(N*lgN) on
   an input vector.

   Given an vector A. of n elements the result of sorting
   the vector in place is to arrange elements of A. so that
   A.1<=A.2<=...<=A.n

   ------------------------------------------------------- $/

   Parse ARG occurs,field;

   If Datatype(field,"W") = 0 Then;
     field = 1;

   Do i = occurs % 2 To 1 By -1;
     x = SIFT(i,occurs,field);
   End;

   Do i = occurs To 2 By -1;
/*   Parse VALUE A.1 A.i With A.i A.1; /*swap places*/   */
     W = A.1;
     A.1 = A.i;
     A.i = W;
     x = SIFT(1,i-1,field);
   End;

   Return 0;

   SIFT: Procedure Expose A.

   Parse ARG lpt,rpt,field;

   i = lpt;
   W = A.i;
   j = 2*i;
   jp1 = j+1;

   If j < rpt Then;
     If Word(A.j,field) < Word(A.jp1,field) Then;
       j = jp1;

   Do While j <= rpt;
     If Word(W,field) >= Word(A.j,field) Then;
       Leave;
     A.i = A.j;
     i = j;
     j = 2*i;
     jp1 = j+1;
     If j < rpt Then;
       If Word(A.j,field) < Word(A.jp1,field) Then;
         j = jp1;
   End;

   A.i = W;

   Return 0;
*/

/* ------------------------------------------------------- */

Test_QSORTA:

   seed = Random(,,1956256);
   Do i=1 To 50;
     A.i = Random();
   End;
   A.0 = 50;

   Say "Numbers before QSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   x = QSORTA(A.0);

   Say "Numbers after QSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   Return 0;

   QSORTA: Procedure Expose A.

/* REXX function
   Invoke as: QSORTA(occurs)
   Quicksort by C. A. R. Hoare is a in place sorting
   algorithm whose worst-case running time is O(N**2);
   its expected running time is O(N*lgN) on an input
   vector. Sophisticated iterative version.

   Given an vector A. of n elements the result of sorting
   the vector in place is to arrange elements of A. so that
   A.1<=A.2<=...<=A.n

   ------------------------------------------------------- */

   Parse ARG occurs;

   s = 1;
   StackL.1 = 1;
   StackR.1 = occurs;
   Do Until S = 0;
     lpt = StackL.s;
     rpt = StackR.s;
     s = s - 1;
     Do Until lpt >= rpt;
       i = lpt;
       j = rpt;
       p = (lpt + rpt) % 2;
       If A.lpt > A.p Then;
         Parse VALUE A.lpt A.p With A.p A.lpt;   /*swap*/
       If A.lpt > A.rpt Then;
         Parse VALUE A.lpt A.rpt With A.rpt A.lpt;    /*swap*/
       If A.p > A.rpt Then;
         Parse VALUE A.p A.rpt With A.rpt A.p;   /*swap*/
       X = A.p;
       Do Until i > j;
         Do i = i While A.i < X;       /*ascending*/
         End;
         Do j = j By -1 While X < A.j; /*ascending*/
         End;
/*       Do i = i While A.i > X;       /*decending*/
         End;
         Do j = j By -1 While X > A.j; /*decending*/
         End;  */
         If i <= j Then;
           Do;
             Parse VALUE A.i A.j With A.j A.i;   /*swap*/
             i = i + 1;
             j = j - 1;
           End;
       End;
       If j - lpt < rpt - i Then;
         Do;
           If i < rpt Then;
             Do;
               s = s + 1;
               StackL.s = i;
               StackR.s = rpt;
             End;
           rpt = j;
         End;
       Else;
         Do;
           If lpt < j Then;
             Do;
               s = s + 1;
               StackL.s = lpt;
               StackR.s = j;
             End;
           lpt = i;
         End;
     End; /* until lpt >= rpt */
   End; /* until s = 0 */

   Return 0;

/* ------------------------------------------------------- */

Test_QSORTD:

   seed = Random(,,1956256);
   Do i=1 To 50;
     A.i = Random();
   End;
   A.0 = 50;

   Say "Numbers before QSORTD";
   Do i=1 To A.0;
     Say A.i;
   End;

   x = QSORTD(A.0);

   Say "Numbers after QSORTD";
   Do i=1 To A.0;
     Say A.i;
   End;

   Return 0;

   QSORTD: Procedure Expose A.

/* REXX function
   Invoke as: QSORTD(occurs)
   Quicksort by C. A. R. Hoare is a in place sorting
   algorithm whose worst-case running time is O(N**2);
   its expected running time is O(N*lgN) on an input
   vector. Sophisticated iterative version.

   Given an vector A. of n elements the result of sorting
   the vector in place is to arrange elements of A. so that
   A.1<=A.2<=...<=A.n

   ------------------------------------------------------- */

   Parse ARG occurs;

   s = 1;
   StackL.1 = 1;
   StackR.1 = occurs;
   Do Until S = 0;
     lpt = StackL.s;
     rpt = StackR.s;
     s = s - 1;
     Do Until lpt >= rpt;
       i = lpt;
       j = rpt;
       p = (lpt + rpt) % 2;
       If A.lpt > A.p Then;
         Parse VALUE A.lpt A.p With A.p A.lpt;   /*swap*/
       If A.lpt > A.rpt Then;
         Parse VALUE A.lpt A.rpt With A.rpt A.lpt;    /*swap*/
       if A.p > A.rpt Then;
         Parse VALUE A.p A.rpt With A.rpt A.p;   /*swap*/
       X = A.p;
       Do Until i > j;
/*       Do i = i While A.i < X;       /*ascending*/
         End;
         Do j = j By -1 While X < A.j; /*ascending*/
         End;   */
         Do i = i While A.i > X;       /*decending*/
         End;
         Do j = j By -1 While X > A.j; /*decending*/
         End;
         If i <= j Then;
           Do;
             Parse VALUE A.i A.j With A.j A.i;   /*swap*/
             i = i + 1;
             j = j - 1;
           End;
       End;
       If j - lpt < rpt - i Then;
         Do;
           If i < rpt Then;
             Do;
               s = s + 1;
               StackL.s = i;
               StackR.s = rpt;
             End;
           rpt = j;
         End;
       Else;
         Do;
           If lpt < j Then;
             Do;
               s = s + 1;
               StackL.s = lpt;
               StackR.s = j;
             End;
           lpt = i;
         End;
     End; /* until lpt >= rpt */
   End; /* until s = 0 */

   Return 0;

/* ------------------------------------------------------- */

Test_QSORTA1:

   seed = Random(,,1956256);
   Do i=1 To 50;
     A.i = Random();
   End;
   A.0 = 50;

   Say "Numbers before QSORTA1";
   Do i=1 To A.0;
     Say A.i;
   End;

   x = QSORTA1(1,A.0);

   Say "Numbers after QSORTA1";
   Do i=1 To A.0;
     Say A.i;
   End;

   Return 0;

   QSORTA1: Procedure Expose A.

/* REXX function
   Invoke as: QSORTA1(left_idx,right_idx);
   Quicksort by C. A. R. Hoare is a in place sorting
   algorithm whose worst-case running time is O(N**2);
   its expected running time is O(N*lgN) on an input
   vector. Simple iterative version.

   Given an vector A. of n elements the result of sorting
   the vector in place is to arrange elements of A. so that
   A.1<=A.2<=...<=A.n

   ------------------------------------------------------- */

   Parse ARG lpt,rpt;

   Push lpt rpt;
   Do While Queued() > 0;
     Pull lpt rpt;
     If lpt < rpt Then;
       Do;
         Q = QSPART(lpt,rpt);
         Push lpt Q;
         Push Q+1 rpt;
       End;
   End;

   Return 0;

   QSPART: Procedure Expose A.

   Parse ARG lpt,rpt;
   X = A.lpt;
   i = lpt - 1;
   j = rpt + 1;
   Do Forever;
     Do Until A.j <= X;
       j = j - 1;
     End;
     Do Until A.i >= X;
       i = i + 1;
     End;
     If i < j Then;
       Parse VALUE A.i A.j With A.j A.i;    /*swap*/
     Else;
       Return j;
   End;

/* ------------------------------------------------------- */

Test_SSORTA:

   seed = Random(,,1956256);
   Do i=1 To 50;
     A.i = Random();
   End;
   A.0 = 50;

   Say "Numbers before SSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   x = SSORTA(A.0);

   Say "Numbers after SSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   Return 0;

   SSORTA: Procedure Expose A.

/* REXX function
   Invoke as: SSORTA(occurs)
   Shell sort by D. L. Shell is a in place sorting
   algorithm whose worst-case running time is O(N**(3/2));
   its expected running time is O(N**1.25) on an input
   vector.

   We first sort all elements that are at distance H.1
   from each other, then re-sort the vector using increment
   H.2, finally we do an ordinary insertion sort with
   increment 1. i.e. H=...,1093,364,121,40,13,4,1
   Generated by the formula H=3*H+1 with the initial
   value H=1.

   Given an vector A. of n elements the result of sorting
   the vector in place is to arrange elements of A. so that
   A.1<=A.2<=...<=A.n

   ------------------------------------------------------- */

   Parse ARG occurs;

   h = 1;
   Do Until h > occurs;
     h = 3 * h + 1;
   End;

   Do Until h = 1;
     h = h % 3;
     Do i=h+1 To occurs;
       V = A.i;
       j = i;
       jmh = j - h;
       Do While A.jmh > V;
         A.j = A.jmh;
         j = j - h;
         If j <= h Then;
           Leave;
         jmh = j - h;
       End;
       A.j = V;
     End;
   End;

   Return 0;

/* ------------------------------------------------------- */

Test_AVERAGE:

   seed = Random(,,1956256);
   Do i=1 To 50;
     A.i = Random(,256);
   End;
   A.0 = 50;

Compute_MEAN:

   mean = MEAN(A.0);

   Say "Mean of vector =" mean;

Compute_RANGE_MEDIAN:

   low = KSMALL(A.0,1);
   Say "Numbers after KSMALL for low";
   Do i=1 To A.0;
     Say A.i;
   End;

   mid = KSMALL(A.0,A.0%2);
   Say "Numbers after KSMALL for mid";
   Do i=1 To A.0;
     Say A.i;
   End;

   hi = KSMALL(A.0,A.0);
   Say "Numbers after KSMALL for hi";
   Do i=1 To A.0;
     Say A.i;
   End;

   Say "Range_lo/median/range_hi of vector = ("low":"mid":"hi")";


Sort_VECTOR:

   x = HSORTA(A.0);

   Say "Numbers after HSORTA for MODE test";
   Do i=1 To A.0;
     Say A.i;
   End;

Compute_MEDIAN:

   k = A.0 // 2;        /*remainder =0 then even occurs*/
   i = A.0 % 2;         /*integer division*/

   If k = 0 Then;       /*even occur pick middle point*/
     mid = A.i;
   Else;
     Do;                /*odd occur pick 2 middle points*/
       ip1 = i + 1;
       mid = (A.i + A.ip1) / 2;
     End;

   Say "Median of vector =" mid;

Compute_MODE:

   x = MODE(A.0);
   mode = Word(x,1);
   freq = Word(x,2);
   Say "Mode of vector =" mode " Frequency =" freq;

   i = A.0;
   Say "Range of vector = ("A.1":"A.i")";

Compute_VARIANCE:

   x = VARIANCE(A.0,mean);
   varsq = Word(x,1);        /*return variance squared*/
   cntlofmean = Word(x,2);   /*return items left of mean*/
   cnteqmean = Word(x,3);    /*return items eq to mean*/
   cntrofmean = Word(x,4);   /*return items right of mean*/

   Say "Mean of vector =" mean;
   Say "Variance squared =" varsq ,
        " Items left of mean =" cntlofmean ,
        " Items equal to mean =" cnteqmean ,
        " Items right of mean =" cntrofmean;
   Say "Std Deviation =" SQRT(varsq);

   Return 0;

   MEAN: Procedure Expose A.

/* REXX function
   Invoke as: MEAN(occurs,nd)
   Determine the arithmetic mean/average of vector entries.

   ------------------------------------------------------- */

   Parse ARG occurs,nd;

   If nd = "" Then;
     nd = 9;

   Numeric Digits nd;

   sum = 0;
   Do i = 1 To occurs;
     sum = sum + A.i;
   End;

   Return sum / A.0;

   VARIANCE: Procedure Expose A.

/* REXX function
   Invoke as: VARIANCE(occurs,mean,nd)
   Determine the variance between each value in the vector.

   ------------------------------------------------------- */

   Parse ARG occurs,mean,nd;

   If nd = "" Then;
     nd = 9;

   Numeric Digits nd;

   leftofmean = 0;
   eqtomean = 0;
   rightofmean = 0;
   varsq = 0;

   Do i = 1 To occurs;
     dif = A.i - mean;
     If dif < 0 Then;
       leftofmean = leftofmean + 1;
     If dif = 0 Then;
       eqtomean = eqtomean +1;
     If dif > 0 Then;
       rightofmean = rightofmean + 1;
     varsq = varsq + dif**2;
   End;

   varsq = varsq / A.0;

   Return varsq leftofmean eqtomean rightofmean;

   KSMALL: Procedure Expose A.

/* REXX function
   Invoke as: KSMALL(occurs,k)
   Return the kth smallest entry of the vector.

   ------------------------------------------------------- */

   Parse ARG occurs,k;

   lpt = 1;
   rpt = occurs;
   Do While lpt < rpt;
     X = A.k;
     i = lpt;
     j = rpt;
     Do Until j < k | k < i;
       Do While A.i < X;
         i = i + 1;
       End;
       Do While X < A.j;
         j = j - 1;
       End;
       Parse VALUE A.i A.j With A.j A.i;    /*swap*/
       i = i + 1;
       j = j - 1;
     End;
     If j < k Then;
       lpt = i;
     If k < i Then;
       rpt = j;
   End;

   Return A.k;

   MODE: Procedure Expose A.

/* REXX function
   Invoke as: MODE(occurs)
   Determine the most frequently occuring value of a
   sorted vector.
   ------------------------------------------------------- */

   Parse ARG occurs;

   mode = A.1;
   freq = 1;

   Do j = 2 To occurs;
     jmfreq = j - freq;
     If A.j = A.jmfreq Then;
       Do;
         freq = freq + 1;
         mode = A.j;
       End
   End;

   Return mode freq;

/* ------------------------------------------------------- */

Test_PRIME:

   x = PRIME(50);
   If x = "INVALID" Then;
     Return 16;

   Do i=1 To P.0;
     Say i "PRIME(50) number =" P.i;
   End;

   Return 0;

   PRIME: Procedure Expose P.

/* REXX function
   Invoke as: PRIME(int);
   A prime number is an integer greater than unity having
   no proper divisors.  Returns all prime numbers in vector
   P. <= int.

   Returns "INVALID" if value is not integer.

   ------------------------------------------------------- */

   Parse ARG int;

   If Datatype(int,'W') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   P.1 = 2; n = 3;

   Do j=2 By +1;
     P.j = Strip(n,'L',0);
     If P.j > int Then;
       Leave;
     Do Forever;
       n = n + 2;
       Do lpt = 2 Until rpt = 0;
         Q = n % P.lpt;
         rpt = n // P.lpt;
         If Q <= P.lpt & rpt <> 0 Then
           Iterate j;
       End;
     End;
   End;

   P.0 = j;

   Return 0;

/* ------------------------------------------------------- */

Test_D2R:

   roman = D2R(1956);
   Say "Roman numerals for 1956 =" roman;

   roman = D2R(2016);
   Say "Roman numerals for 2016 =" roman;

   Return 0;

   D2R: Procedure

/* REXX function
   Invoke as: D2R(int);
   Convert integer (1:3999) to Roman numerals.

   Returns "INVALID" if value is not integer.

   ------------------------------------------------------- */

   Parse ARG int;

   If Datatype(int,'W') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   If (int < 1) | (int > 3999) Then;
     Call ERROR "D2R: Error - Integer must be in range 1 - 3999";

   Parse VALUE Right(Format(int,,0),4,0) ,
        With a +1 b +1 c +1 d;

   Parse VALUE "1 1 1 1 3 4 4 4 4 7" ,
        With x.0 x.1 x.2 x.3 x.4 x.5 x.6 x.7 x.8 x.9;
   Parse VALUE "0 1 2 3 2 1 2 3 4 2" ,
        With y.0 y.1 y.2 y.3 y.4 y.5 y.6 y.7 y.8 y.9;
   r = "IIIVIIIXXXLXXXCCCDCCCMMM";
   /*            1         2      */
   /*   123456789012345678901234  */

   Return Substr(r,x.a+21,y.a) || Substr(r,x.b+14,y.b) ,
        || Substr(r,x.c+7,y.c) || Substr(r,x.d,y.d);

   ERROR:

   Say "D2R error on" ARG(1);

   Exit;

/* ------------------------------------------------------- */

Test_R2D:

   roman = "MDCCCIX";        /*1809*/
   integer = R2D(roman);

   Say "Integer value for MDCCCIX =" integer;

   Return 0;

   R2D: Procedure

/* REXX function
   Invoke as: R2D(roman);
   Convert Roman numerals to integer.

   Returns "INVALID" if value is not integer.

   ------------------------------------------------------- */

   Parse UPPER ARG roman;

   RtoD.I = 1; RtoD.V = 5; RtoD.X = 10;
   RtoD.L = 50; RtoD.C = 100;
   RtoD.D = 500; RtoD.M = 1000;

   integer = 0;
   Rdigit = Left(roman,1);
   Idigit = RtoD.Rdigit;
   Do j=2 To Length(roman)
     Rdigit = Substr(roman,j,1);
     next = RtoD.Rdigit;
     If next > Idigit Then;
       integer = integer - Idigit;
     Else;
       integer = integer + Idigit;
     Idigit = next;
   End;

   Return integer + Idigit;

/* ------------------------------------------------------- */

Test_SHUFFLE:

   seed = Random(,,1956256);
   Do i=1 To 50;
     A.i = Random();
   End;
   A.0 = 50;

   Say "Numbers before SSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   x = SSORTA(A.0);

   Say "Numbers after SSORTA";
   Do i=1 To A.0;
     Say A.i;
   End;

   x = Random(,,2561956);
   x = SHUFFLE(A.0);

   Say "Numbers after SHUFFLE";
   Do i=1 To A.0;
     Say A.i;
   End;

   Return 0;

   SHUFFLE: Procedure Expose A.

/* REXX function
   Invoke as: SHUFFLE(occurs);
   Randomly rearrange a vector.

   ------------------------------------------------------- */

   Parse ARG occurs;

   Do j=occurs To 2 By -1;
     r = Random(1,j);
     Parse VALUE A.j A.r With A.r A.j;  /*swap*/
   End;

   Return 0;

/* ------------------------------------------------------- */

Test_SQRT:

   x = SQRT(144);
   Say "SQRT of 144 =" x;

   x = SQRT(615);
   Say "SQRT of 615 =" x;

   Return 0;

   SQRT: Procedure

/* REXX function
   Invoke as: SQRT(real);
   Compute the square root of a real number using Newton's
   formula New=0.5*(X+N/X), where X starts with a reasonable
   guess e.g. (1+N)/2.

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real,np;

   If Datatype(real,'N') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   If real = 0 Then;
     Return 0;

   If np = "" Then;
     np = 9;

   Numeric Digits np;

   Parse VALUE FORMAT(real,,,,0) With real "E" Exp;

   If Exp = "" Then;
     Exp = 0;

   If (Exp // 2) <> 0 Then;
     If Exp > 0 Then;
       Do;
         real = real * 10;
         Exp = Exp - 1;
       End;
     Else;
       Do;
         real = real / 10;
         Exp = Exp + 1;
       End;

   x = 0.5 * (real + 1);

   Do Forever;
     NewX = 0.5 * (x + real / x);
     If x = NewX Then;
       Return X * 10 ** (Exp % 2);
     x = NewX;
   End;

   Return 0;

/* ------------------------------------------------------- */

Test_MATCH:

    string =
    pattern =
    x = MATCH1(string,pattern);

   Return 0;

   MATCH1: Procedure

/* REXX function
   Invoke as: MATCH1(string,pattern);
   Find all occurrences of a pattern in a string.

   ------------------------------------------------------- */

   Parse ARG string,pattern;

   Do i=0 Until i=0;
     i = POS(pattern,string, i+1);
     If i > 0 Then;
       Return i-1;
   End;

   Return 0;

/* additional test functions */

   P2D: Procedure
   /* rexx      convert packed decimal to number */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Parse ARG number_p;
   erg = C2X(number_p);
   sign = Right(erg,1);
   number = Left(erg,Length(erg)-1);
   If sign = 'D' Then;
     Return '-'||number;
   Else;
     Return number;

   D2P: Procedure
   /* rexx   convert number to packed decimal  */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Arg number;
   If datatype(number) <> 'NUM' Then;
     Return '';
   If number < 0 Then;
      Interpret "number_p = '"ABS(number)"D'x";
   Else;
      Interpret "number_p = '"number"C'x";
   Return number_p;

./ ADD NAME=BULK2    0103-16178-18204-0931-00173-00146-00000-APLKS   17
/* REXX */
/* Test for all of the ISPF GET REXX functions follow */
/* all of the GET... functions are in APLKS.WORK.REXXLIB
   the ENVVAR function is in APLKS.MYTSO.EXEC */
   Call Test_GETPLEX;
   Call Test_GETSCPN;
   Call Test_GETIPLD;
   Call Test_GETIPLT;
   Call Test_GETCPUM;
   Call Test_GETJES2;
   Call Test_GETJOBID;
   Call Test_GETJOBNM;
   Call Test_GETREALM;
   Call Test_GETREGK;
   Call Test_GETGRPN;
   Call Test_GETNAME;
   Call Test_GETTRID;
   Call Test_GETSMS;
   Call Test_GETDFPL;
   Call Test_GETSMFID;
   Call Test_GETATTR;
   Call Test_GETDEST;
   Call Test_GETSWA;
   Call Test_GETACCT;
   Call Test_GETPRGNM;

   Return 0;

Test_GETLPAR:
   w = GETLPAR();
   y = ENVVAR("LPARMODE");
   Say "LPAR mode:" w y;
   Return 0;

Test_GETPLEX:
   w = GETPLEX();
   y = ENVVAR("PLEXNAME");
   Say "SYSPLEX name:" w y;
   Return 0;

Test_GETSCPN:
   w = GETSCPN();
   y = ENVVAR("CPPDNM");
   Say "CP product name:" w y;
   Return 0;

Test_GETIPLD:
   w = GETIPLD();
   x = Date("S",w,"J");
   y = ENVVAR("IPLDATE");
   z = Date("S",y,"J");
   Say "IPL date:" w x " " y z;
   Return 0;

Test_GETIPLT:
   w = GETIPLT();
   y = ENVVAR("IPLTIME");
   Say "IPL time:" w y;
   Return 0;

Test_GETCPUM:
   w = GETCPUM();
   y = ENVVAR("CPUMODL");
   Say "CPU model:" w y;
   Return 0;

Test_GETJES2:
   w = GETJES2();
   y = ENVVAR("JES2PDNM");
   Say "JES2 product name:" w y;
   Return 0;

Test_GETJOBID:
   w = GETJOBID();
   y = ENVVAR("JOBID");
   Say "SSIB JOB ID:" w y;
   Return 0;

Test_GETJOBNM:
   w = GETJOBNM();
   y = ENVVAR("JOBNM");
   Say "JOB name:" w y;
   Return 0;

Test_GETREALM:
   w = GETREALM();
   y = ENVVAR("REALSTG");
   Say "Real Storage size:" w||"M" y||"M";
   Return 0;

Test_GETREGK:
   w = GETREGK();
   y = ENVVAR("REGSIZE");
   Say "Region size:" w||"K" y||"K";
   Return 0;

Test_GETGRPN:
   w = GETGRPN();
   y = ENVVAR("RACFGRP");
   Say "RACF/ACF2 connect group name:" w y;
   Return 0;

Test_GETNAME:
   w = GETNAME();
   y = ENVVAR("RACFUSER");
   Say "RACF/ACF2 user name:" w y;
   Return 0;

Test_GETTRID:
   w = GETTRID();
   y = ENVVAR("VTAMTERM");
   Say "RACF/ACF2 VTAM termid:" w y;
   Return 0;

/* x = GETACF2();
   Say "ACF2 Release:" x;
   Return 0;

   x = GETUID();
   Say "ACF2 userid:" x;
   Return 0; */

Test_GETSMS:
   w = GETSMS();
   y = ENVVAR("SMSSTAT");
   Say "SMS status:" w y;
   Return 0;

Test_GETDFPL:
   w = GETDFPL();
   y = ENVVAR("DFPLVL");
   Say "DFP level:" w y;
   Return 0;

Test_GETSMFID:
   w = GETSMFID("");
   y = ENVVAR("SMFID");
   Say "SMF ID:" w y;
   Return 0;

Test_GETATTR:
   w = GETATTR();
   y = ENVVAR("TSOATTR");
   Say "TSO user attributes:" w y;
   Return 0;

Test_GETDEST:
   w = GETDEST();
   y = ENVVAR("DEST");
   Say "TSO default SYSOUT dest:" w y;
   Return 0;

/* w = GETCIB();
   Say "CIB command verb code:" w; */
   Return 0;

Test_GETSWA:
   w = GETSWA();
   y = ENVVAR("SWALOC");
   Say "SWA location:" w y;
   Return 0;

Test_GETACCT:
   w = GETACCT();
   y = ENVVAR("JOBACCT");
   Say "Job Accounting info:" w y;
   Return 0;

Test_GETPRGNM:
   w = GETPRGNM();
   y = ENVVAR("PGRNAME");
   Say "Programmer name:" w y;
   Return 0;
./ ADD NAME=B32TODEC 0107-19260-19270-1426-00058-00051-00000-APLKS   06
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Convert base(32) number to a base(10) number
   Invoke as: base_10 = B32TODEC(base_32);
          or: TSO B32TODEC base_32
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_10 = "error composition";

   ARG base_32;

   Numeric Digits 20;

   v1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVW";
   v2 = "A B C D E F G H I J K L M N O P Q R S T U V W ";

   If Verify(base_32,v1) = 0 Then;
     Nop;
   Else;
     Signal The_End;

   base_10 = "error length";

   len = Length(base_32);
   If len > 0 & len <= 8 Then;
     Do;
       j = len;
       Do i=1 To len By +1;
         j = j-1;
         pwr_vector.i = 32**j;
       End;
     End;
   Else;
     Signal The_End;

   base_10 = 0;

   Do i=1 To len By +1;
     digit = Substr(base_32,i,1);
     If Datatype(digit,"U") = 1 Then;
       Do;
         n = Wordpos(digit,v2);
         If n > 0 Then;
           digit = n-1+10;
       End;
     base_10 = base_10 + (digit * pwr_vector.i);
   End;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_10;

   Say "Decimal value =" base_10;
   Return (0);
./ ADD NAME=CATLIST  0114-16188-16271-0953-00255-00111-00000-APLKS   08
/* REXX 2016-09-27 CBT #020 */
/* --------------------------------------------------------- */
/* Purpose: Display all of the names of the User/Master      */
/*          Catalogs on the system.                          */
/*                                                           */
/*  Format: CATLIST ( options                                */
/*                                                           */
/*         options: (default) SCREEN                         */
/*                  LINE | SCREEN | QUEUE | STACK            */
/*                  presentation option                      */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CATLIST */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var = "";
   opt. = "";
   psa_ptr = 0;
   cvt_ptr = get_ptr(psa_ptr,'10');   /*get addr of CVT*/
   amcb_ptr = get_ptr(cvt_ptr,'100')  /*get addr of AMCB*/
   caxwa_ptr = get_ptr(amcb_ptr,'14') /*get addr of CAXWA*/

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1;

   /* Mainline */

   If SYSVAR('SYSNEST') = "NO" Then;
     "MAKEBUF";
   If opt.1 = "LIN" | opt.1 = "SCR" Then;
     Do;
       Queue "User/Master Catalogs on the system";
       Queue " ";
     End;

   Do While caxwa_ptr <> '00000000';
     caxwa_nxt_ptr = get_ptr(caxwa_ptr,'4');
     catflag = get_data(caxwa_ptr,'8',1);   /*extract flag*/
     If Bitand(catflag,'04'x) = '04'x Then;
       cattype = "MCAT";
     Else;
       cattype = "UCAT";
     catname = get_data(caxwa_ptr,'34',44)  /*extract cat name*/
     catucb_ptr = get_ptr(caxwa_ptr,'1c')   /*extract ucb addr*/
/*   catvols = get_data(catucb_ptr,'1c',6)  /*extract cat vols*/
     catdevn = get_data(catucb_ptr,'0d',3)  /*extract device*/    */
     caxwa_ptr = caxwa_nxt_ptr;
     Select;
       When opt.1 = "LIN" | opt.1 = "SCR" | opt.1 = "QUE" Then;
         Queue cattype catname;
       When opt.1 = "STA" Then;
         Push cattype catname;
       Otherwise;
         Nop;
     End;
   End;

   "QELEM";
   count = RC;

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do;
         Do count;
           Pull line;
           Say line;
         End;
         If SYSVAR('SYSNEST') = "NO" Then;
           "DROPBUF";
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(1)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD ( FINIS ";
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
         If SYSVAR('SYSNEST') = "NO" Then;
           "DROPBUF";
       End;
     Otherwise;
       Nop;
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) |,
            Abbrev("QUEUE",var,3) |,
            Abbrev("STACK",var,3) Then;
         opt.1 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

/* +--------------------------+
   | Functions defined below. |
   +--------------------------+ */

   get_ptr: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset
   temp = d2x(x2d(addr) + x2d(offset))
   return c2x(storage(temp,4))
   exit

   get_data: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset, len
   temp = d2x(x2d(addr) + x2d(offset))
   return storage(temp,len)
   exit

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display all of the names of the"                      ,
        pad hex04,
        "         User/Master Catalogs on the system.",
        pad hex04,
        " Format: CATLIST ( LINE | SCREEN | QUEUE | STACK";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   If SYSVAR('SYSNEST') = "NO" Then;
     "DROPBUF";
   Return (-16);

/*********************************************************************/
/*  CBT #020                                                         */
/*                                                                   */
/*                    SYSTEM CAXWA TABLE LOOKUP                      */
/*  THIS REXX PROGRAM IS USED TO MAP ALL OPEN USER CATAOLGS AND      */
/*  SHOW RELATED UCB INFORMATION FROM THE DASD THEY RESIDE UPON.     */
/*                                                                   */
/*===================================================================*/
/*                      CONTROL BLOCK CHAINING                       */
/*  AMCBS      : CVT+X'100' ACCESS METHOD CONTROL BLOCK  (CVTCBSP)   */
/*  CAXWA     -> AMCBS+X'14' CATALOG WORK AREA                       */
/*  CAXNEXT   -> CAXWA+X'04' NEXT CAXWA ENTRY                        */
/*  CATFLAG1  -> CAXWA+X'08' CATALOG FLAG BYTE 1                     */
/*   X....... -> BUILD REQUESTED                                     */
/*   .X...... -> OPEN IN CONTROL                                     */
/*   ..X..... -> CLOSE IN CONTROL                                    */
/*   ...X.... -> END OF VOLUME IN CONTROL                            */
/*   ....X... -> I/O SUPPORT COMPLETED                               */
/*   .....X.. -> 1:MASTER CATALOG, 0:USER CATALOG                    */
/*   ......X. -> CATALOG MANAGEMENT IN CONTROL                       */
/*   .......X -> SCHEDULER IN CONTROL                                */
/*  CATFLAG2  -> CAXWA+X'09' CATALOG FLAG BYTE 2                     */
/*   X....... -> CATALOG DELETED                                     */
/*   .X...... -> NO DDNAME FOUND                                     */
/*   ..X..... -> UNABLE TO GET CORE                                  */
/*   ...X.... -> I/O ERROR                                           */
/*   ....X... -> RPL CLEAN UP REQUESTED                              */
/*   .....X.. -> FREE CAXWA IF ERROR                                 */
/*   ......X. -> RECOVERABLE CATALOG                                 */
/*   .......X -> VOLUME TIME STAMP UPDATED                           */
/*  CATFLAG3  -> CAXWA+X'0A' CATALOG FLAG BYTE 3                     */
/*   X....... -> CRA ALT TIOT EXIST                                  */
/*   .X...... -> CRA NOT EXIST                                       */
/*   ..X..... -> RESERVED                                            */
/*   ...X.... -> CATALOG IS RAC DEFINED                              */
/*   ....X... -> NO CATALOG PSWD DEFINED                             */
/*   .....XX. -> 01 NO UPDATE 10 UPDATE                              */
/*   .......X -> RESERVED                                            */
/*   CATACT   -> CAXWA+X'0B' CATALOG ACTIVITY                        */
/*   X....... -> IN STORAGE                                          */
/*   .X...... -> ALLOCATED                                           */
/*  CATUCBP   -> CAXWA+X'1C' ADDRESS OF CATALOG UCB                  */
/*  CATNAME   -> CAXWA+X'34' CATALOG NAME FIELD 44 BYTES             */
/*                                                                   */
/*********************************************************************/
./ ADD NAME=CC       0106-14130-16028-1331-00224-00217-00000-APLKS   06
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Position the cursor on the current line by       */
/*          keying in a command on the command line, as      */
/*          an option you can place data on the current      */
/*          line from the command line (the data can be in   */
/*          hex format).                                     */
/*                                                           */
/*  Format: CC target <the_string> < ( options >             */
/*                                                           */
/*          target: is the column to place the cursor on the */
/*                  current line.                            */
/*                  variable names are trow                  */
/*                                     tcol                  */
/*      the_string: any string enclosed in apostrophes or    */
/*                  quotes.                                  */
/*                                                           */
/*         options: (default) REPLACE                        */
/*                  REPLACE | INSERT                         */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CC */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   the_string = "";
   cmd = "REPLACE";

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";
   "(bndslo,bndshi) = BOUNDS";
   tcol = bndslo;

   /* Check out Edit Mode Options */

   "(recfm) = RECFM";
   "(lrecl) = LRECL";
   zonelo = 1;
   zonehi = lrecl;
   Select;
     When recfm = "V" Then;
       zonelo = 9;
     When lang = "STD" Then;
       zonehi = lrecl - 8;
     When lang = "COBOL" Then;
       zonelo = 7;
     Otherwise;
       Nop;
   End;
   "(state) = USER_STATE";
   "BOUNDS = (zonelo,zonehi)";

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     cmd = Strip(parm3);
   Upper cmd;

   /* Parse Target and User Passed Parms */

   Call Extract_TARGET;

   /* Parse the Optional EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       parm2 = Strip(parm2,"B");
       Select;
         When Substr(parm2,1,1) = "'" Then;
           Parse VAR parm2 "'" the_string "'" parm2;
         When Substr(parm2,1,1) = '"' Then;
           Parse VAR parm2 '"' the_string '"' parm2;
         When Substr(parm2,1,2) = "x'" | Substr(parm2,1,2) = "X'" Then;
           Do;
             Parse VAR parm2 "'" the_string "'" parm2;
             the_string = X2C(the_string);
           End;
         Otherwise;
           Parse VAR parm2 the_string parm2;
       End;
       trgt_lgth = Length(the_string);
     End;
   Else;
     Do;
       "USER_STATE = (state)";
       "CURSOR = (trow,tcol)";
       Return (0);
     End;

   "(row) = LINE" trow;
   Select;
     When Abbrev("REPLACE",cmd) Then;
       row = Overlay(the_string,row,tcol,trgt_lgth);
     When Abbrev("INSERT",cmd) Then;
       row = Insert(the_string,row,tcol - 1,trgt_lgth);
     Otherwise;
       Signal Error_INVALID_CMD;
   End;
   "USER_STATE = (state)";
   "LINE" trow "= (row)";
   "CURSOR = (trow,tcol)";
   Return (0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Extract_TARGET:

   /* Resolve trow and tcol Variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trow = krow;
       tcol = kcol;
     End;
   Else;
     trow = frow;

   Parse VAR parm2 var.1 parm2;
   If var.1 <> "" Then;
     Do;
       Select;
         When Datatype(var.1,"W") Then;
           tcol = var.1;
         Otherwise;
           If tcol <> 0 Then;
             parm2 = var.1;
           Else;
             Signal Error_INVALID_TARGET;
       End;
     End;
   Else;
     If tcol = "" Then;
       Signal Error_INVALID_TARGET;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: position cursor on current line with optional data.",
        pad hex04,
        " format: CC target <the_string> < ( REPLACE | INSERT >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_CMD:

   ZEDSMSG = "INVALID CMD";
   ZEDLMSG = "Invalid command ("cmd")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=CENTER   0102-16236-16237-0934-00180-00321-00000-APLKS   53
/* REXX 2016-08-24 */
/* --------------------------------------------------------- */
/* Purpose: Center the text within the ISREDIT bounds.       */
/*                                                           */
/*          Excluded lines will not be processed.            */
/*                                                           */
/*  Format: CENTER target | range                            */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*                                                           */
/* Inspired by previous XEDIT macro                          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CENTER */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var. = "";

   "(bndslo,bndshi) = BOUNDS";
   bndslen = bndshi - bndslo + 1;
   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   /* Parse the User Options */

   /* Parse Target and Primary passed Parms */

   Call Extract_Target;

   Mainline:

   Do i = trgt_row_from To trgt_row_to By +1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     If RC = 12 Then;
       Leave;
     newrow = Strip(Substr(row,bndslo,bndslen),'B');
     newrow = Center(newrow,bndslen);
     row = Overlay(newrow,row,bndslo,bndslen);
     "LINE" i "= (row)";
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM = hex04,
        "Purpose: Center the text within the ISREDIT bounds.",
        pad hex04,
        " Format: CENTER target | range ";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=CHANGES  0104-19203-19203-1018-00482-00482-00000-APLKS   50
/* REXX ************************************************************/
/*                                                                 */
/* CHANGES - ISPF Edit Macro to display all changes made to        */
/*           a dataset during an Edit session.                     */
/*                                                                 */
/* SYNTAX  - CHANGES with any of the following optional parms:     */
/*                                                                 */
/*           HELP - Displays a pop-up window showing the options   */
/*                  available with CHANGES and their syntax.       */
/*                                                                 */
/*           name - Dataset and/or member name to be compared      */
/*                  against for changes.  Normal ISPF requirements */
/*                  regarding use of quotes for dataset names      */
/*                  apply.                                         */
/*                                                                 */
/*           ONLY - Only lines that have changed are displayed,    */
/*                  all others are EXCLUDED.                       */
/*                                                                 */
/*           EDIT - Edit SUPERC report instead of merging the      */
/*                  report into the current Edit session.          */
/*                                                                 */
/*         BROWSE - Browse SUPERC report instead of merging the    */
/*                  report into the current Edit session.          */
/*                                                                 */
/* CREATED - Groundhog Day, 1995                                   */
/*                                                                 */
/* =============================================================== */
/* ========== M O D I F I C A T I O N     L O G ================== */
/* =============================================================== */
/*                                                                 */
/* 02/17/95 -     > General improvements to analysis logic         */
/*                > CHANGES now NEVER sets ISPF change indicator   */
/*                                                                 */
/*******************************************************************/
ARG PARM
CALL ON ERROR NAME NOTEDIT
"ISREDIT MACRO (PARM)"
IF RC<>0 THEN
    DO
        NOTEDIT:
        IF PARM='HELP' THEN SIGNAL SHOWHELP
        ZERRLM=,
        "CHANGES is an Edit Macro. It can only be invoked from within an",
        "ISPF Edit Session to compare the contents of the current Edit",
        "Session to the last saved version of the file being edited",
        "or another file.  CHANGES should not be invoked with the 'TSO'",
        "command as a prefix.  Enter CHANGES HELP from within an Edit",
        "session for a list of valid syntax.  Any questions you have",
        "regarding this exec can be answered if you call local support",
        "at extension 6800."
        ZERRSM=''
        ZERRALRM='YES'
        ZERRHM='*'
        "ISPEXEC SETMSG MSG(ISRZ002)"
    EXIT
    END

CALL OFF ERROR
"ISPEXEC VGET (ZPREFIX ZSCREENW ZAPPLID ZCOLORS)"

IF ZCOLORS=7 THEN LINETYPE="NOTELINE"
ELSE LINETYPE="MSGLINE"

BASE='N'
DATASET=''
DSNPARM=''
MEMBER=''
HX4='04'X

UPPER PARM
DO R = 1 TO WORDS(PARM)
    IF WORD(PARM,R) = "HELP" THEN HELP='Y'
    ELSE
    IF WORD(PARM,R) = "ED" |,
       WORD(PARM,R) = "EDIT" THEN EDIT='Y'
    ELSE
    IF WORD(PARM,R) = "BR" |,
       WORD(PARM,R) = "BROWSE" THEN BROWSE='Y'
    ELSE
    IF WORD(PARM,R) = 'ONLY' THEN ONLY ='Y'
    ELSE
       DO
           DATASET = WORD(PARM,R)
           DSNPARM = DATASET
       END
END

IF HELP='Y' THEN SIGNAL SHOWHELP
IF DATASET<>'' THEN

        IF LEFT(DATASET,1)="'" THEN
            DATASET = STRIP(DATASET,'B',"'")
        ELSE
            IF ZPREFIX<>'' THEN DATASET=ZPREFIX"."DATASET

TEMP   = TRANSLATE(DATASET,'  ','()')
DATASET= WORD(TEMP,1)
MEMBER = WORD(TEMP,2)
IF POS('.',DSNPARM)=0 &,
   LENGTH(DSNPARM) >0 &,
   LENGTH(DSNPARM) <9 &,
   POS("'",DSNPARM)=0 &,
   POS("(",DSNPARM)=0 &,
   MEMBER='' THEN
    DO
         MEMBER=DSNPARM
         DATASET=''
    END

DSNHOLD=DATASET
MEMHOLD=MEMBER
"ISPEXEC CONTROL ERRORS RETURN"
"ISREDIT (L C) = CURSOR"
IF C = 0 THEN POSFIRST='Y'
"ISREDIT (EDITDSN) = DATASET"
IF DSNHOLD='' THEN "ISREDIT (DATASET) = DATASET"
IF MEMHOLD='' THEN "ISREDIT (MEMBER)  = MEMBER "
"ISREDIT (LRECL)  = LRECL"
PROFPFX=LEFT(ZAPPLID,2)
DSNAME=DATASET
IF MEMBER <> '' THEN DATASET=DATASET"("MEMBER")"
OLDCC=99
X = OUTTRAP('DUMMY',1)
CALL ON ERROR   NAME BADDSN
CALL ON FAILURE NAME BADDSN
CALL ON HALT    NAME BADDSN
IF LISTDSI("'"DSNAME"'")=0  THEN
    DO
        IF SYSDSORG=PS & POS('(',PARM)=0 THEN DATASET=DSNAME
        IF SYSDSN("'"DATASET"'")="OK" THEN
            DO
                IF SYSDSORG=PO & POS('(',DATASET)=0 THEN NOP
                ELSE
                "ALLOC F(OLDDD) DA('"DATASET"') SHR REUSE"
                OLDCC=RC
            END
    END
IF OLDCC<>0 THEN
    DO
        BADDSN:
        ZERRLM=,
        "'"DATASET"' was not found to compare for changes. If it is",
        "a new dataset or member, it must be saved before CHANGES",
        "can be executed to analyze changes."
        ZERRSM=''
        ZERRALRM='YES'
        ZERRHM='*'
        "ISPEXEC SETMSG MSG(ISRZ002)"
    EXIT
    END
CALL OFF ERROR
CALL OFF HALT
CALL OFF FAILURE
X = OUTTRAP('OFF')
"ISREDIT (NUMSTAT,NUMMODE) = NUMBER"
"ISREDIT (RECFM) = RECFM"
"ISREDIT (DATACHG1) = DATA_CHANGED"
"ISREDIT (LASTNUM) = LINENUM .ZL"
LCOL=1
RCOL=LRECL+0
IF NUMSTAT='ON' THEN
    DO
        IF LEFT(NUMMODE,3)='STD' THEN
            DO
                IF RECFM='F' THEN RCOL=RCOL-8
                IF RECFM='V' THEN LCOL=LCOL+8
            END
        IF POS(' COBOL ',NUMMODE)>0 THEN LCOL=LCOL+6
    END

USEOLD = 'N'
IF LRECL>80 | LCOL>1 THEN
    DO
        USEOLD = 'Y'
        "EXECIO * DISKR OLDDD (STEM OLDREC. FINIS)"
        IF LCOL>1 THEN
            DO F = 1 TO OLDREC.0
                OLDREC.F = SUBSTR(OLDREC.F,LCOL)
            END
    END

"ALLOC F(NEWDD) NEW DELETE RECFM(F B) LRECL("LRECL") REUSE",
"   BLKSIZE("LRECL*30")  SPACE(30,15) TRACKS UNIT(SYSDA) DSORG(PS)"
DROP NEW
"ISREDIT (USERSTAT) = USER_STATE"
"ISREDIT NUMBER OFF"

DO NUMLINES = 1 to 999999
   "ISREDIT (NEW"NUMLINES") = LINE "NUMLINES
    IF RC=0 THEN ITERATE
    LEAVE
END

NUMLINES=NUMLINES-1
"EXECIO "NUMLINES" DISKW NEWDD (STEM NEW FINIS)"
"ALLOC F(OUTDD) NEW DELETE RECFM(F B A) LRECL(133) REUSE",
"   BLKSIZE(133)   SPACE(20) TRACKS UNIT(SYSDA) DSORG(PS)"

"ALLOC F(SYSIN) NEW DELETE RECFM(F B) LRECL(80) REUSE",
"   BLKSIZE(80)   SPACE(1) TRACK UNIT(SYSDA) DSORG(PS)"

SYSIN.1="   CMPCOLM "LCOL":"RCOL
"EXECIO * DISKW SYSIN (STEM SYSIN. FINIS)"
"ISPEXEC SELECT PGM(ISRSUPC) PARM(DELTAL,LINECMP,,)"
DROP NEW
"EXECIO * DISKR OUTDD (STEM RPT. FINIS)"
IF EDIT='Y' | BROWSE='Y' THEN SIGNAL DOEDBR
"FREE  F(OUTDD,NEWDD,OLDDD,SYSIN)"
W = 0
TPOS=0

DO T = 1 to RPT.0
  IF TPOS<2 THEN TPOS=POS(' TYPE ',RPT.T)+1
  IF SUBSTR(RPT.T,4,1)<>'-' THEN ITERATE
  W=W+1; RPT.W=RPT.T
END

"ISREDIT RESET"
IF W>0 THEN
    DO
        "ISREDIT  CAPS  OFF"
        IF ONLY='Y' THEN "ISREDIT EXCLUDE ALL"
    END

DASHPAD=COPIES('-',133)
RPLCNT=0
RFMCNT=0
INSCNT=0
DELCNT=0
FIRSTDIF=0
LASTINS=0
TPOS4=TPOS+4
TPOS10=TPOS+10
TPOS16=TPOS+16

DO T = 1 TO W
    TYPE=SUBSTR(RPT.T,TPOS,4)
    CNT=SUBSTR(RPT.T,TPOS4,5) + 0
    BEG=SUBSTR(RPT.T,TPOS10,5) + 0
    IF FIRSTDIF=0 THEN FIRSTDIF=BEG
    IF TYPE = "DEL=" THEN
        DO
            LN=CNT' lines'; WAS='were'
            IF CNT=1 THEN
                DO
                    LN='line'; WAS='was'
                END
            CALL DELPROC
        END
    ELSE
        DO
            LASTINS=BEG+CNT-1
            IF TYPE = "INS=" THEN T = T+CNT-1
            ELSE T = T+CNT*2-1
        END
END

DO T = 1 TO W
    TYPE=SUBSTR(RPT.T,TPOS,4)
    CNT=SUBSTR(RPT.T,TPOS4,5) + 0
    BEG=SUBSTR(RPT.T,TPOS10,5) + 0
    IF TYPE = "DEL=" THEN T = T+CNT-1
    ELSE
        DO
            LN=CNT' lines'; WAS='were'
            IF CNT=1 THEN
                DO
                    LN='line'; WAS='was'
                END
            IF      TYPE = "INS=" THEN CALL INSPROC
            ELSE IF TYPE = "RPL=" THEN CALL RPLPROC
            ELSE IF TYPE = "RFM=" THEN CALL RFMPROC
        END
END

"ISREDIT USER_STATE = (USERSTAT)"
IF W>0 THEN
    DO
        IF POSFIRST='Y' & FIRSTDIF>0 THEN
            DO
                "ISREDIT UP MAX"
                IF FIRSTDIF>1 THEN
                    DO
                        "ISREDIT CURSOR = 1 0"
                        "ISREDIT LOCATE SPECIAL"
                    END
            END
    END

PADB=COPIES(' ',74)
DELCNT=RIGHT(DELCNT,5)
INSCNT=RIGHT(INSCNT,5)
RFMCNT=RIGHT(RFMCNT,5)
RPLCNT=RIGHT(RPLCNT,5)
DISPDSN=CENTER(DATASET,51)
"ISREDIT (DATACHG2) = DATA_CHANGED"
ZERRALRM='NO'
ZERRSM=''
ZERRLM=,
PADB HX4 DISPDSN,
PADB HX4"                  CHANGES Summary                   "
"ISREDIT (AUTOSAVE) = AUTOSAVE"

IF DATACHG1<>DATACHG2 & AUTOSAVE='ON' THEN
    DO
    ZERRALRM='YES'
    ZERRSM='*** WARNING: Enter HELP'
    ZERRSM=''
    ZERRLM=,
    "WARNING: END command will Update ISPF STATS",
    "although no changes were made!"COPIES(' ',50),
    "Use CANCEL command to terminate Edit",
    "without updating ISPF Statistics."
    END

ZERRLM=ZERRLM||,
PADB"Lines Deleted  ="DELCNT"      Lines Replaced    ="RPLCNT,
PADB"Lines Inserted ="INSCNT"      Lines Reformatted ="RFMCNT

ZERRHM='*'
"ISPEXEC SETMSG MSG(ISRZ002)"

/* ******************************************************** */
/* Performed Routines                                       */
/* ******************************************************** */

LOGIT:
"ISPEXEC VGET CHG@CNT PROFILE"
IF RC<>0 THEN CHG@CNT=0
CHG@CNT=CHG@CNT+1
"ISPEXEC VPUT CHG@CNT PROFILE"
IF LEFT(USERID(),2)='SY' THEN LOGID='49286YS'
IF LEFT(USERID(),2)='AP' THEN LOGID='49286YS'
IF LOGID="LOGID" THEN EXIT
IF CHG@CNT>10 & CHG@CNT//10<>0 THEN EXIT
LOGID=REVERSE(LOGID)
IF USERID()=LOGID THEN EXIT
PARM=TRANSLATE(PARM,'"',"'")

LOGMSG=,
"SE '''CHANGES "PARM"'' #"CHG@CNT,
"on "DATE('N') TIME('C') ".............."||,
"......................................."

LOGMSG=LEFT(LOGMSG,76)
/* ""LOGMSG"' USER("LOGID") LOGON" */
EXIT

DELPROC:
DELCNT=DELCNT+CNT
DELMSG1="The following" LN WAS "deleted "DASHPAD
DELMSG2="The preceding" LN WAS "deleted "DASHPAD
IF LASTINS>=BEG THEN BEG=LASTINS+1
IF BEG>LASTNUM THEN
    DO
        BEG = BEG - 1
        "ISREDIT LINE_AFTER  "BEG" = "LINETYPE" (DELMSG2)"
        DO S = T+CNT-1 TO T BY -1
            IF USEOLD='N' THEN
                NEWLINE = SUBSTR(RPT.S,6,LRECL)
            ELSE
                DO
                    OLD=SUBSTR(RPT.S,TPOS16,5)+0
                    NEWLINE = OLDREC.OLD
                END
            "ISREDIT LINE_AFTER  &BEG  = INFOLINE (NEWLINE)"
        END
        "ISREDIT LINE_AFTER  "BEG" = "LINETYPE" (DELMSG1)"
    END
ELSE
    DO
        "ISREDIT LINE_BEFORE "BEG" = "LINETYPE" (DELMSG1)"
        DO S = T TO T+CNT-1
            IF USEOLD='N' THEN
                NEWLINE = SUBSTR(RPT.S,6,LRECL)
            ELSE
                DO
                    OLD=SUBSTR(RPT.S,TPOS16,5)+0
                    NEWLINE = OLDREC.OLD
                END
            "ISREDIT LINE_BEFORE &BEG  = INFOLINE (NEWLINE)"
        END
        "ISREDIT LINE_BEFORE "BEG" = "LINETYPE" (DELMSG2)"
    END
T = T + CNT - 1
RETURN

INSPROC:
INSCNT=INSCNT+CNT
INSMSG1="The following" LN WAS "inserted "DASHPAD
INSMSG2="The preceding" LN WAS "inserted "DASHPAD
"ISREDIT LINE_BEFORE "BEG" = "LINETYPE" (INSMSG1)"
"ISREDIT LINE_AFTER  "BEG+CNT-1" = "LINETYPE" (INSMSG2)"
IF ONLY='Y' THEN "ISREDIT RESET EXCLUDED" BEG BEG+CNT-1
T = T + CNT - 1
RETURN

RPLPROC:
RPLCNT=RPLCNT+CNT
RPLMSG1="The next" LN "replaced the" LN "following"
RPLMSG2="The above" LN WAS "replaced by the" LN "preceding"
RPLMSG1=RPLMSG1 DASHPAD
RPLMSG2=RPLMSG2 DASHPAD
"ISREDIT LINE_BEFORE "BEG" = "LINETYPE" (RPLMSG1)"
"ISREDIT LINE_AFTER  "BEG+CNT-1" = "LINETYPE" (RPLMSG2)"

DO S = T+CNT*2-1 TO T BY -1
    NEWLINE = SUBSTR(RPT.S,6,LRECL)
    S = S - 1
    IF USEOLD='Y' THEN
        DO
            OLD=SUBSTR(RPT.S,TPOS16,5) + 0
            NEWLINE = OLDREC.OLD
        END
    "ISREDIT LINE_AFTER  "BEG+CNT-1"  = INFOLINE (NEWLINE)"
END

IF ONLY='Y' THEN "ISREDIT RESET EXCLUDED" BEG BEG+CNT-1
T = T+CNT*2-1
RETURN

RFMPROC:
RFMCNT=RFMCNT+CNT
RFMMSG2="The above" LN WAS "reformatted by the" LN "preceding"
RFMMSG1="The next" LN "reformatted the" LN "following"
RFMMSG1=RFMMSG1 DASHPAD
RFMMSG2=RFMMSG2 DASHPAD
"ISREDIT LINE_BEFORE "BEG" = "LINETYPE" (RFMMSG1)"
"ISREDIT LINE_AFTER  "BEG+CNT-1" = "LINETYPE" (RFMMSG2)"

DO S = T+CNT*2-1 TO T BY -1
    NEWLINE = SUBSTR(RPT.S,6,LRECL)
    S = S - 1
    IF USEOLD='Y' THEN
        DO
            OLD=SUBSTR(RPT.S,TPOS16,5) + 0
            NEWLINE = OLDREC.OLD
        END
    "ISREDIT LINE_AFTER  "BEG+CNT-1"  = INFOLINE (NEWLINE)"
END

IF ONLY='Y' THEN "ISREDIT RESET EXCLUDED" BEG BEG+CNT-1
T = T+CNT*2-1
RETURN

DOEDBR:
CURTIME=TIME('N')TIME('C')
EDITOUT="@"||,
        SUBSTR(CURTIME,1,2)||,
        SUBSTR(CURTIME,4,2)||,
        SUBSTR(CURTIME,7,2)
"ALLOC F("EDITOUT") NEW DELETE RECFM(F B A) LRECL(133) REUSE",
"   BLKSIZE(133)   SPACE(20) TRACKS UNIT(SYSDA) DSORG(PS)"

"EXECIO * DISKW "EDITOUT" (STEM RPT. FINIS)"
"FREE  F(OUTDD,NEWDD,OLDDD,SYSIN)"
EDITCMD='EDIT'
IF BROWSE='Y' THEN EDITCMD='BROWSE'
"ISPEXEC LMINIT DATAID(TEMPID) DDNAME("EDITOUT")"
"ISPEXEC "EDITCMD" DATAID("TEMPID")"
"ISPEXEC LMFREE DATAID("TEMPID")"
"FREE  F("EDITOUT")"
SIGNAL LOGIT

SHOWHELP:
CALL OFF ERROR
HX4='04'X
PADH=COPIES(' ',62)
ZERRLM=,
PADH HX4,
"Valid Syntax:"                                                           ,
PADH HX4,
"              ----------------------- option(s) ------------------------",
PADH HX4,
"   CHANGES    HELP | ONLY | 'dsname' | member | 'library(member)'",
PADH HX4,
"              EDit | BRowse"
ZERRSM=''
ZERRALRM='NO'
ZERRHM='*'
"ISPEXEC SETMSG MSG(ISRZ002)"
SIGNAL LOGIT
./ ADD NAME=CHANNEL  0103-16271-16277-1629-00211-00255-00000-APLKS   14
/* REXX 2016-10-03 MVS #165 */
/* --------------------------------------------------------- */
/* Purpose: Display the status of all the channels in this   */
/*          LPAR.                                            */
/*                                                           */
/*  Format: CHANNEL  ( options                               */
/*                                                           */
/*         options: (default) STATUS SCREEN                  */
/*                  STATUS - of the channel                  */
/*                  LINE | SCREEN                            */
/*                  presentation option                      */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CHANNEL  */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var = "";
   lne = "";
   opt. = "";
   pad = Copies(' ',2);
   row_title_list = "0x 1x 2x 3x 4x 5x 6x 7x 8x 9x Ax Bx Cx Dx Ex Fx";
   psa_ptr = 0;
   cvt_ptr = get_ptr(psa_ptr,'10');   /*get addr of CVT*/
   ichpt_ptr = get_ptr(cvt_ptr,'4d0') /*get addr of CVTICHPT*/
   channels = get_data(ichpt_ptr,'0',256);

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "STA";
   If opt.2 = "" Then;
     opt.2 = "SCR";      /*screen*/
   opt.0 = 2;

   /* Mainline */

   "MAKEBUF";

   If opt.1 = "STA" Then;
     Do;
       Queue "CHANNEL status for LPAR" ENVVAR('LPARNAME');
       Queue " ";
       Queue pad "   x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF";
       lne = pad Word(row_title_list,1);
       Do i=1 To 256;
         If i//16 = 0 Then;
           Do;
             lne = lne c2x(Substr(channels,i,1));
             Queue lne;
             lne = "";
             lne = pad Word(row_title_list,(i%16)+1);
           End;
         Else;
           lne = lne c2x(Substr(channels,i,1));
       End;
       Queue " ";
       Queue "Legend for status byte";
       Queue "  x'80' - this channel is capable of accepting a cable";
       Queue "  x'40' - this channel belongs to this LPAR";
       Queue "  x'20' - this channel is online to this LPAR";
       Queue "  x'10' - this channel is undergoing channel path recovery";
       Queue "  x'08' - a vary offline is in progress for this channel";
       Queue "  x'04' - a vary offline is in progress for this channel";
       Queue "  x'02' - channel path recovery has started its last UCB scan";
       Queue " ";
       Queue "Valid states are x'F8', x'F0', x'E8', x'E0'," ,
             ||" x'C0', x'80', x'00'";
   End;

   "QELEM";
   count = RC;

   Select;
     When opt.2 = "LIN" Then;   /*display at terminal in Line mode*/
       Do count;
         Pull line;
         Say line;
       End;
     When opt.2 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(1)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD ( FINIS ";
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   "DROPBUF";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("STATUS",var,3) Then;
         opt.1 = Substr(var,1,3);
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) Then;
         opt.2 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

/* +--------------------------+
   | Functions defined below. |
   +--------------------------+ */

   get_ptr: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset
   temp = d2x(x2d(addr) + x2d(offset))
   return c2x(storage(temp,4))
   exit

   get_data: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset, len
   temp = d2x(x2d(addr) + x2d(offset))
   return storage(temp,len)
   exit

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display the status of all the channels in LPAR.",
        pad hex04,
        " Format: CHANNEL ( LINE | SCREEN";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC=" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "DROPBUF";
   Return (-16);
./ ADD NAME=CHGID    0115-14130-16236-1801-00307-00314-00000-APLKS   57
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Put CHGID's on all lines that have been modified */
/*          during the edit session.  A MASKLINE is created  */
/*          so that all line insertions will have the CHGID  */
/*          included.                                        */
/*                                                           */
/*  Format: CHGID target | range                             */
/*                < ( options >                              */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*         options:                                          */
/*             SET- keyword indicating CHGID follows         */
/*           RESET- clear CHGID and MASKLINE                 */
/*      the_string- the CHGID up to 8 bytes enclosed in      */
/*                  apostrophes.                             */
/*            lang- (default) PROFILE (NUMBER)               */
/*                  STD | COBOL                              */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CHGID */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   chg_cnt = 0;
   the_string = "";

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr + 1;

   "(recfm) = RECFM";
   If recfm = "V" Then;
     Signal Error_PROFILE_001;

   "(lrecl) = LRECL";
   If lrecl <> 80 Then;
     Signal Error_PROFILE_002;

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_CHGID;
   If the_string = "" Then;
     Do;
       Address ISPEXEC "VGET (CHGID@@) PROFILE";
       If chgid@@ = "" Then;
         Signal Error_CHGID;
       the_string = chgid@@;
     End;
   Else;
     Do;
       chgid@@ = the_string;
       Address ISPEXEC "VPUT (CHGID@@) PROFILE";
     End;

   If the_string = "NULL" Then;
     Signal End_of_EXEC;

   /* Set some of the Defaults based on the Options */

   Select;
     When lang = "COBOL" Then;
       Do;
         strt_col = 73;
         end_col = 80;
       End;
     When lang = "STD" Then;
       Do;
         strt_col = 63;
         end_col = 70;
       End;
     Otherwise;
       Signal Error_INVALID_LANG;
   End;
   seq_lgth = end_col - strt_col + 1;

   "(lrecl) = LRECL";
   row = Overlay(the_string,Right(" ",lrecl),strt_col,seq_lgth);
   "MASKLINE = (row)";

   /* Parse Target and User passed Parms */

   Call Extract_Target;

   /* Parse the Optional EXEC Parameters */

   Do i = trgt_row_from to (trgt_row_to - 1) by 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       iterate i;
     "(row) = LINE" i;
     row = Overlay(the_string,row,strt_col,seq_lgth);
     "LINE" i "= (row)";
     chg_cnt = chg_cnt + 1;
   End;

   End_of_EXEC:

   ZEDSMSG = chg_cnt "LINES CHGed";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       trgt_row_to = trgt_row_from;
   End;

   Return (0);

   Extract_CHGID:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When var.3 = "STD" | var.3 = "COBOL" Then;
         lang = var.3;
       When var.3 = "SET" Then;
         Do;
           Parse VAR parm3 "'" the_string "'" parm3;
           If Length(the_string) > 8 Then;
             Signal Error_CHGID;
         End;
       When var.3 = "RESET" Then;
         Do;
            the_string = "NULL";
            "(lrecl) = LRECL";
            row = Left(" ",lrecl);
            "MASKLINE = (row)";
         End;
       Otherwise;
         Signal Error_INVALID_OPTS;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Put CHGID's on all lines that have been modified.",
        pad hex04,
        " Format: CHGID target|range",
        pad hex04,
        "               < ( < RESET | SET 'chgid' > < STD | COBOL > >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_PROFILE_001:

   ZEDSMSG = "RECFM CONFLICT";
   ZEDLMSG = "RECFM must be fixed ("recfm")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_PROFILE_002:

   ZEDSMSG = "LRECL CONFLICT";
   ZEDLMSG = "LRECL must be 80 ("lrecl")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_CHGID:

   ZEDSMSG = "INVALID CHGID";
   ZEDLMSG = "Invalid or missing CHGID ("the_string")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "Invalid user options ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_LANG:

   ZEDSMSG = "INVALID LANG";
   ZEDLMSG = "Language is not valid ("lang")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=CHKSIT   0104-14134-15259-1101-00332-00331-00000-APLKS   27
/* -------------------------------------------------------- */
/* Purpose: Check SIT (SYSIN) overrides to determine if     */
/*          they are syntactically correct.                 */
/*                                                          */
/*          1. Copy edited member to work pds               */
/*          2. Edit work pds                                */
/*            2a. Remove all comment lines                  */
/*            2b. Remove LPA (PRVMOD=) entries              */
/*            2c. Remove trailing comments                  */
/*            2d. Split lines > 57 char long                */
/*            2e. Shift lines to column 16                  */
/*            2f. Remove .END lines                         */
/*            2g. Save member ZZSIT00                       */
/*          3. Dynamically build REXX EXEC                  */
/*          4. Copy default SIT to the work pds             */
/*          5. Envoke dynamic REXX EXEC                     */
/*            5a. Change PROC name                          */
/*            5b. Delete common SIT parms                   */
/*            5c. Copy SYSIN SIT overrides in               */
/*            5d. SUBMIT assembly jcl                       */
/*                                                          */
/*  Format: CHKSIT                                          */
/*                                                          */
/* -------------------------------------------------------- */
   Address ISPEXEC 'CONTROL NONDISPL END ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG) PROFILE';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace r;
     End;
   Else;
     x = MSG('OFF');
   x = '';
/* Entering EXEC CHKSIT */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
   If parm2 = '?' | parm2 = 'HELP' | parm2 = 'help' Then;
     Signal Error_EXEC_HELP;

   Signal on syntax Name Error_SYNTAX;

   /* Initialize Variables */
   "(currdsn) = DATASET";  /* data set being edited */
   "(currmbr) = MEMBER";  /* member being edited */

   Address ISPEXEC;

/* cts_vrm = MVSVAR('SYMDEF',CTSVER); */
   cts_vrm = 'TS32';
   cts_vpx = MVSVAR('SYMDEF',SYSPREF);

   tabpds_dsname = 'CICS'||cts_vpx||'.CICS'||cts_vrm||'.TABLES.SOURCE';
   jclpds_dsname = 'CICS'||cts_vpx||'.CICS'||cts_vrm||'.TABLES.JCLLIB';
   wrkpds_dsname = Userid()||'CICS.WRKPDS';
   wrkpds_attrb = 'DSORG(PO) RECFM(F) LRECL(80)';
   wrkpds_space = 'UNIT(3390) CYL SPACE(1,1) DIR(5)';
   wrkpds_disp = 'NEW CATALOG';

   /* ---------------------------- */
   /* Copy edited member to the    */
   /* work pds. Edit the work pds  */
   /* member make appropriate chgs */
   /* and save.                    */
   /* ---------------------------- */

   Call BPXWDYN("FREE DD(WRKPDS)");

   If Listdsi("'"wrkpds_dsname"'") = 0 Then;
     If SYSREASON = 0 Then;
       Address TSO "DELETE ('"wrkpds_dsname"') PURGE NONVSAM";
       /*
        0 Processing successful. Informational messages might have
          been issued.
        4 Processing successful, but a warning message has been
          issued.
        8 Processing was completed, but specific details were
          bypassed.
       12 Processing unsuccessful.
       16 Severe error or problem encountered.
          */
     Else;
       Signal Error_Delete_WRKPDS;

   If BPXWDYN("ALLOC DD(WRKPDS) DSN('"wrkpds_dsname"')",
       wrkpds_space wrkpds_attrb wrkpds_disp) <> 0 Then;
     Signal Error_Alloc_WRKPDS;

   Signal on error Name Error_LM_WRKPDS;
   Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(WRKPDS)";
   /*
    0 Normal completion.
    8 Data ID not created.
   12 The parameter value is invalid.
   16 Truncation or translation error in accessing dialog variables.
   20 Severe error; unable to continue.
      */
   Address ISPEXEC "LMINIT DATAID("srcid") DATASET('"currdsn"')";
   Address ISPEXEC "LMCOPY FROMID("srcid") FROMMEM("currmbr") ",
        "TODATAID("tgtid") TOMEM(ZZSIT00)";
   /*
    0 Normal completion.
    4 Member not available:
         The member is in a controlled ISPF library and is currently
         The member is in a controlled ISPF library and invalid user
         Lock was requested but the project is SCLM-controlled.
         "From" library not LMF-controlled.
         "From" data set is empty.
         No members matched the specified pattern in the "from" data
    8 "From" member not found.
   10 No data set is associated with the given data ID.
   12 One of the following:
         Invalid data set organization.
         Data set attribute invalid for copying or copying packed dat
         Open error.
         A like named member already exists in the 'TO' data set, and
         One or more members of the 'TO' data set are "in use" by you
   16 Truncation error.
   20 Severe error; unable to continue.
      */
   Address ISPEXEC "LMFREE DATAID("srcid")";
   /*
    0 Normal completion.
    8 Free dslist-id failed. The error condition is described in "Dial
   10 No data set level or volume is associated with the given dslist-
   20 Severe error; unable to continue.
      */
   Address ISPEXEC "EDIT DATAID("tgtid")",
        " MEMBER(ZZSIT00) MACRO(CHKSIT1)";
   /*
    0 Normal completion; data was saved.
    4 Normal completion; data was not saved.
   14 Member or sequential data set in use.
   16 One of the following:
         No members matched the specified pattern.
         No members in the partitioned data set.
   20 Severe error; unable to continue.
      */
   Signal off error;

   /* ---------------------------- */
   /* Dynamically build REXX/MACRO */
   /* to add SYSIN to the default  */
   /* SIT source                   */
   /* ---------------------------- */

   If BPXWDYN("ALLOC DD(INDD) DSN('"wrkpds_dsname"(ZZSIT00)')",
       "SHR REUSE") <> 0 Then;
     Signal Error_Alloc_WRKPDS;

   Address TSO "EXECIO * DISKR INDD (STEM SIT_OVERRIDES. FINIS)";
   Call BPXWDYN("FREE DD(INDD)");

   Queue "/* REXX */";
   Queue "ADDRESS ISPEXEC 'CONTROL NONDISPL END ERRORS RETURN';";
   Queue "ADDRESS ISPEXEC 'VGET (DEBUG)';";
   Queue "If debug = 'DEBUG' Then;";
   Queue "  Do;";
   Queue "    x = MSG('ON');";
/* Queue "    Trace R;"; */
   Queue "  End;";
   Queue "Else;";
   Queue "  x = MSG('OFF');";
   Queue "x = '';";
   Queue "ADDRESS ISREDIT;";
   Queue "MACRO;";
   Queue "EXCLUDE 'TYPE=CSECT,' FIRST;";
   Do i = 1 To sit_overrides.0 By 1;
     last_col = Pos('=',sit_overrides.i);
     If last_col > 0 Then;
       Do;
         Parse VAR sit_overrides.i keyword '=' . ;
         keyword = Strip(keyword,'B');
         Queue "CHANGE '"keyword"' '##DEL##' ALL NX;";
       End;
   End;
   Queue "FIND 'TYPE=CSECT,' FIRST X;";
   Queue "EXCLUDE '##DEL##' ALL;";
   Queue "DELETE EXCLUDE ALL;";
   Queue "FIND 'TYPE=CSECT,' FIRST;";
   Queue "'(krow,kcol) = CURSOR';";
   Queue "COPY ZZSIT00 AFTER " krow;
   Queue "SAVE;";
   Queue "RETURN (0);";

   If BPXWDYN("ALLOC DD(OUTDD) DSN('"wrkpds_dsname"(CHKSIT2)')",
       "SHR REUSE") <> 0 Then;
     Signal Error_Alloc_WRKPDS;
   Address MVS 'EXECIO * DISKW OUTDD (FINIS ';
   Call BPXWDYN("FREE DD(OUTDD)");

   Address TSO "ALTLIB ACT APPLICATION(EXEC) DDNAME(WRKPDS)";
   /*
    0 Processing successful. Informational messages might have
      been issued.
    4 An alternative library does not exist for this type (RE
      exec or CLIST); none deactivated.
    8 An application-level library already exists for this ty
      (REXX exec or CLIST). The new application-level library
      was not activated. Issued only when you specify the CON
      parameter.
   10 User- or system-level CLIST activated; User- or
      system-level exec cannot be activated because a REXX
      language processor environment has not been established
      Contact your system programmer to diagnose problems with
      TSO/E programs IRXECUSP and IRXINIT.
   16 A required ddname was not previously allocated.
   20 Severe error. More information is contained in messages
      */

   /* ---------------------------- */
   /* Copy DEFAULT SIT to the work */
   /* pds.  Edit the work pds mbr. */
   /* Make appropriate chgs.  Copy */
   /* SYSIN overrides to DEFAULT   */
   /* SIT.  Submit assembly.       */
   /* ---------------------------- */

/* Signal on error Name Error_LM_WRKPDS; */
   Address ISPEXEC "LMINIT DATAID("tabid") DATASET('"tabpds_dsname"')";
   Address ISPEXEC "LMCOPY FROMID("tabid") FROMMEM(DFHSIT00) ",
        "TODATAID("tgtid") TOMEM(DFHSIT00)";
   Address ISPEXEC "LMFREE DATAID("tabid")";

   Address ISPEXEC "EDIT DATAID("tgtid")",
        " MEMBER(DFHSIT00) MACRO(CHKSIT2)";
   Address ISPEXEC "LMFREE DATAID("tgtid")";

   Address ISPEXEC "LMINIT DATAID("jclid") DATASET('"jclpds_dsname"')";
   Address ISPEXEC "EDIT DATAID("jclid")",
        " MEMBER(DFHSIT00) MACRO(CHKSIT3)";
   Address ISPEXEC "LMFREE DATAID("jclid")";

   Signal off error;

   Address TSO "ALTLIB DEACT APPLICATION(EXEC)";
   Address TSO "FREE DDNAME(WRKPDS)";

   RETURN (0);

   /* ------------------------- */
   /* Error Processing routines */
   /* ------------------------- */

   Error_EDIT_MODE:

   Say 'Must be in EDIT mode to envoke this EXEC';
   Return (-16);

   Error_EXEC_HELP:

   hex04 = '04'x;
   pad = Copies(' ',62);
   ZERRLM  = pad hex04,
        "Purpose: Verify that CICS SYSIN SIT overrides",
        pad hex04,
        "     are syntactically correct.",
        pad hex04,
        " Format: CHKSIT";
   ZERRSM  = '';
   ZERRALRM= 'NO';
   ZERRHM  = '*';
   Address ISPEXEC 'SETMSG MSG(ISRZ002)';
   Exit;

   Error_NO_END:

   ZEDSMSG = '.END marker missing';
   ZEDLMSG = '.END marker is missing from the bottom of SYSIN';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);

   Error_ALLOC_WRKPDS:

   ZEDSMSG = 'ALLOC WRKPDS, RC='RC;
   ZEDLMSG = 'ALLOC ERROR in 'exec_name' on WRKPDS, RC='RC;
/* Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Do i = 1 To S99MSG.0 By 1;
     Say S99MSG.i;
   End; */
   Return (-16);

   Error_Concat_WRKPDS:

   ZEDSMSG = 'CONCAT WRKPDS, RC='RC;
   ZEDLMSG = 'CONCAT ERROR in 'exec_name' on WRKPDS, RC='RC;
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
/* Do i = 1 To S99MSG.0 By 1;
     Say S99MSG.i;
   End; */
   Return (-16);

   Error_Delete_WRKPDS:

   ZEDSMSG = 'DELETE WRKPDS, RC='RC;
   ZEDLMSG = 'DELETE ERROR in 'exec_name' on WRKPDS, RC='RC,
        " ("SYSREASON"/"SYSMSGLVL1"/"SYSMSGLVL2")";
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);

   Error_LM_WRKPDS:

   ZEDSMSG = 'SIGNAL at line 'SIGL;
   ZEDLMSG = 'SIGNAL in 'exec_name' at line 'SIGL'  RC='RC;
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);

   Error_SYNTAX:

   ZEDSMSG = 'SYNTAX ERROR 'SIGL;
   ZEDLMSG = 'SYNTAX ERROR 'RC' in 'exec_name' on line 'SIGL':',
        Errortext(RC);
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);
./ ADD NAME=CHKSIT1  0101-14134-15259-1041-00154-00154-00000-APLKS   27
/* -------------------------------------------------------- */
/* Purpose: Check SIT (SYSIN) overrides to determine if     */
/*          they are syntactically correct.                 */
/*                                                          */
/*          1. Remove all comment lines                     */
/*          2. Remove LPA (PRVMOD=) entries                 */
/*          3. Remove trailing comments                     */
/*          4. Split lines > 57 char long                   */
/*          5. Shift lines to column 16                     */
/*          6. Remove .END lines                            */
/*          8. save member ZZSIT00                          */
/*                                                          */
/*  Caller: CHKSIT                                          */
/*  Format: CHKSIT1                                         */
/*                                                          */
/* -------------------------------------------------------- */
   Address ISPEXEC 'CONTROL NONDISPL END ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG) PROFILE';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');
   x = '';
/* Entering EXEC CHKSIT1 */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

/* Parse UPPER ARG parm2; */
   "MACRO (parm2)";
   If RC <> 0 Then;
     Parse UPPER ARG parm2;

   /* Initialize Variables */

   /* Remove comments */
   "EXCLUDE '*' 1 2 ALL";
   "DELETE EXCLUDE ALL";

   /* Check for LPA PARM */
   "FIND 'PRVMOD=(' LAST";
   IF RC = 0 THEN;
     DO;
       "(krow,kcol) = CURSOR";
       csr_row_from = krow;
       "FIND ')' NEXT";                       /*changed this*/
       "(krow,kcol) = CURSOR";
       csr_row_to = krow;
       "DELETE "csr_row_from csr_row_to;
     END;
   DROP krow kcol

   /* Check for EOF marker */
   "FIND '.END' LAST";
   IF RC = 0 THEN;
     DO;
       "(krow,kcol) = CURSOR";
       last_row = krow - 1;
     END;
   ELSE;
     Signal Error_NO_END;
   DROP krow kcol;

   /* Remove Parm Comments */
   DO i = 1 TO last_row BY 1;
     "(row) = LINE" i;
     last_col = POS(', ',row,1);
     If last_col > 0 Then;
       Do;
         row = LEFT(row,last_col + 1);
         "LINE" i "= (row)";
       End;
   END;
   DROP row;

   /* Append each line with a ", " */
   DO i = 1 TO last_row BY 1;
     '(row) = LINE' i;
     row = Strip(Substr(row,1),'T');
     If Substr(row,Length(row),1) = ',' Then;
       iterate;
     row = row || ',';
     "LINE" i "= (row)";
   End;
   Drop row;

   /* Main loop */
   DO i = 1 TO last_row BY 1;
     "(row) = LINE" i;
     last_col = POS(', ',row);
     IF SUBSTR(row,1,7) = 'GMTEXT=' & last_col > 57 THEN;
       Do;
         "TSPLIT "i" 57";
         last_row = last_row +1;
       END;
     IF SUBSTR(row,1,9) = 'INITPARM=' & last_col > 57 THEN;
       Do;
         "TSPLIT "i" 57";
         last_row = last_row +1;
       End;
   END;
   DROP row;
   "RESET";
   "CHANGE ' ' '+' 57 ALL NX";

   /* Reposition data */
   DO i = 1 TO last_row BY 1;
     "SHIFT ) "i" 15";
   END;

/* "Locate 1";
   Call SHIFT '* 1 16'; */

   "EXCLUDE '.END' 1 4 ALL";
   "DELETE EXCLUDE ALL";

   /* Save changes to ZZSIT00 */
   'SAVE';
   'CANCEL';

   RETURN (0);


   /* ------------------------- */
   /* Error Processing routines */
   /* ------------------------- */

   Error_EDIT_MODE:

   Say 'Must be in EDIT mode to envoke this EXEC';
   Return (-16);

   Error_NO_END:

   ZEDSMSG = '.END marker missing';
   ZEDLMSG = '.END marker is missing from the bottom of SYSIN';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return (-16);
./ ADD NAME=CHKSIT3  0103-14134-15259-1041-00061-00060-00000-APLKS   43
/* -------------------------------------------------------- */
/* Purpose: Modify SIT assembly JCL and submit.             */
/*                                                          */
/*  Caller: CHKSIT                                          */
/*  Format: CHKSIT3                                         */
/*                                                          */
/* -------------------------------------------------------- */
   Address ISPEXEC 'CONTROL NONDISPL END ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG) PROFILE';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');
   x = '';
/* Entering EXEC CHKSIT3 */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO";

/* cts_vrm = MVSVar('SYMDEF',CTSVER); */
   cts_vrm = 'TS32';
   cts_vpx = MVSVar('SYMDEF',SYSPREF);

   tabpds_dsname = 'CICS'||cts_vpx||'.CICS'||cts_vrm||'.TABLES.SOURCE';
   wrkpds_dsname = Userid()||'.CICS.WRKPDS';

   "CHANGE 'AUPLE' 'AUP' FIRST NX";
   "FIND 'NAME=' FIRST";
   If RC = 0 Then;
     Do;
       '(krow,kcol) = CURSOR';
       '(row) = LINE' krow;
       xcol= Pos(',',row);
       row = Delstr(row,xcol);
       'LINE 'krow' = (row)';
     End;

   "CHANGE '"tabpds_dsname"' '"wrkpds_dsname"' FIRST NX";

   "SUBX Z00";      /* Submit plus pass the job acct information */
   "CANCEL";

   RETURN (0);
./ ADD NAME=CKSEQ    0112-14130-16236-1801-00279-00267-00000-APLKS   31
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Check for ascending sequence numbers             */
/*  Format: CKSEQ target | range                             */
/*                < ( options >>                             */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*         options: (default) PROFILE (NUMBER)               */
/*                  STD | COBOL                              */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CKSEQ */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   err_flag = "N";
   var. = "";
   seq_strt = 0; error_code = 0; error_row = 0;

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr + 1;

   "(recfm) = RECFM";
   If recfm = "V" Then;
     Signal Error_Profile_001;

   "(lrecl) = LRECL";
   If lrecl <> 80 Then;
     Signal Error_Profile_002;

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Set some of the Defaults based on the Options */

   If lang = "COBOL" Then;
     Do;
       strt_col = 1;
       end_col = 6;
     End;
   Else
     Do;
       strt_col = 73;
       end_col = 80;
     End;

   seq_lgth = end_col - strt_col + 1;

   /* Parse Target and Primary passed Parms */

   Call Extract_Target;

   Do i = trgt_row_from to (trgt_row_to - 0) by 1,
       while i < trgt_row_eof;
     "(row) = LINE" i;
     seq_next = Substr(row,strt_col,seq_lgth);
     If Verify(seq_next,"0123456789","NOMATCH") Then;
       If err_flag = "Y" Then;
         Iterate;
       Else;
         Do;
           err_flag = "Y";
           error_row = i;
           "LABEL " i - 1 " = .PTA 0";
           Iterate;
         End;
     If seq_next > seq_strt Then;
       If err_flag = "Y" Then;
         Do;
           "LABEL " i " = .PTB 0";
           Leave i;
         End;
       Else;
         Nop;
     Else;
       If err_flag = "Y" Then;
         Iterate;
       Else;
         Do;
           err_flag = "Y";
           error_row = i;
           "LABEL " i - 1 " = .PTA 0";
           Iterate;
         End;
     seq_strt = seq_next;
   End;

   If err_flag = "Y" Then;
     Do;
       ZEDSMSG = "SEQ ERRORS";
       ZEDLMSG = "Sequence errors were found";
       error_code = 4 ;
       "LOCATE " error_row - 1;
     End;
   Else;
     ZEDSMSG = "NO SEQ ERRORS";

   Address ISPEXEC "SETMSG MSG(ISRZ000);"

   Return (error_code);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When var.3 = "STD" |  var.3 = "COBOL" Then;
         lang = var.3;
       Otherwise;
         Signal Error_INVALID_OPTS;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Verify sequence numbers are in ascending order.",
        pad hex04,
        " Format: CKSEQ target|range ",
        pad hex04,
        "               < ( STD | COBOL >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_PROFILE_001:

   ZEDSMSG = "RECFM CONFLICT";
   ZEDLMSG = "RECFM must be fixed ("recfm")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_PROFILE_002:

   ZEDSMSG = "LRECL CONFLICT";
   ZEDLMSG = "LRECL must be 80 ("lrecl")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "Invalid user options ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=CLRSEQ   0112-16027-16028-1408-00222-00211-00000-APLKS   36
/* REXX */
/* ------------------------------------------------------- */
/* Purpose: Used to clear the sequence field.              */
/*          columns 01 thru 06 for COBOL                   */
/*          columns 73 thru 80 for STD                     */
/*                                                         */
/*          No processing is performed if record format    */
/*          is variable or logical record length exceedes  */
/*          80 bytes.                                      */
/*          Excluded lines will not be cleared.            */
/*          Non-numeric columns will not be cleared.       */
/*                                                         */
/*  Format: CLRSEQ <range>                                 */
/*                 < ( options >                           */
/*                                                         */
/*           range: defines where to begin and end         */
/*                  can be a pair of system/user defined   */
/*                  labels                                 */
/*         options: (default) PROFILE (NUMBER)             */
/*                  STD | COBOL                            */
/* ------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CLRSEQ */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var. = "";

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";

   "(recfm) = RECFM";
   If recfm = "V" Then;
     Signal Error_PROFILE_001;

   "(lrecl) = LRECL";
   If lrecl <> 80 Then;
     Signal Error_PROFILE_002;

   "(status) = USER_STATE";

   zonelo = 1;
   zonehi = lrecl;
   "BOUNDS = (zonelo,zonehi)";

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Parse Target and User passed Parms */

   Call Extract_Range;

   /* Set some of the Defaults based on the Options */

   Select;
     When lang = "COBOL" Then;
       Do;
         strt_col = 1;
         end_col = 6;
         "NUMBER OFF";
         "AUTONUM OFF";
         If var.1 = "" Then;
           "CHANGE P'######' C'      ' ALL NX " strt_col end_col;
         Else
           "CHANGE P'######' C'      ' ",
                var.1 var.2 " ALL NX " strt_col end_col;
       End;
     When lang = "STD" Then;
       Do;
         strt_col = 73;
         end_col = 80;
         "NUMBER OFF";
         "AUTONUM OFF";
         If var.1 = "" Then;
           "CHANGE P'########' C'        ' ALL NX " strt_col end_col;
         Else;
           "CHANGE P'########' C'        ' ",
                var.1 var.2 " ALL NX " strt_col end_col;
       End;
     Otherwise;
       Signal Error_INVALID_LANG;
   End;

   "USER_STATE = (status)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Range:

   Parse VAR parm2 var.1 parm2;
   If var.1 <> "" Then;
     If Substr(var.1,1,1) <> "." Then
       Signal Error_INVALID_RANGE;

   Parse VAR parm2 var.2 parm2;
   If var.2 <> "" Then;
     If Substr(var.2,1,1) <> "." Then
       Signal Error_INVALID_RANGE;

   If (var.1 = "" & var.2 = "") | (var.1 <> "" & var.2 <> "") Then;
     Nop;
   Else;
     Signal Error_INVALID_RANGE;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When var.3 = "STD" | var.3 = "COBOL" Then;
         lang = var.3;
       Otherwise;
         Signal Error_INVALID_LANG;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Clear sequence numbers.",
        pad hex04,
        " Format: CLRSEQ <range>",
        pad hex04,
        "                < ( STD | COBOL >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_PROFILE_001:

   ZEDSMSG = "RECFM CONFLICT";
   ZEDLMSG = "RECFM must be fixed ("recfm")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_PROFILE_002:

   ZEDSMSG = "LRECL CONFLICT";
   ZEDLMSG = "LRECL must be 80 ("lrecl")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_LANG:

   ZEDSMSG = "INVALID LANG";
   ZEDLMSG = "Language is not valid ("lang")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Exit (-16);

   Error_INVALID_RANGE:

   ZEDSMSG = "INVALID RANGE";
   ZEDLMSG = "Range is not a valid set of labels"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Exit (-16);
./ ADD NAME=CMORE    0117-16022-16190-0856-00214-00269-00000-APLKS   15
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Unexclude count number of rows after or before   */
/*          a group of EXCLUDEd rows.                        */
/*                                                           */
/*  Format: CMORE <range>                                    */
/*                < ( options >                              */
/*                                                           */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*         options: (default) BEFORE 3                       */
/*                  AFTER | BEFORE                           */
/*                  count                                    */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC CMORE */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";       /* 1=1st label  2=2nd label */
   opt. = "";       /* 1=AFTER|BEFORE 2=count */
   process = "X"    /* X=excluded   NX=non-excluded */

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Initialize Default values */

   If opt.1 = "" Then;
     opt.1 = "BEFORE";
   If opt.2 = "" Then;
     opt.2 = 3;

   /* Parse Range */

   If parm2 <> "" Then;
     Call Extract_Range;

   If var.1 = "" Then;
     var.1 = ".ZFIRST";
   If var.2 = "" Then;
     var.2 = ".ZLAST";

   "(lptr1) = LINENUM" var.1;
   If RC > 0 Then;
     Signal Error_INVALID_RANGE;
   "(lptr2) = LINENUM" var.2;
   If RC > 0 Then;
     Signal Error_INVALID_RANGE;
   fptr = Min(lptr1,lptr2);        /*1st line in range*/
   lptr = Max(lptr1,lptr2);        /*last line in range*/

   /* Parse the Optional EXEC Parameters */

   /* Mainline */

   Do i=fptr To lptr By 1;
     "(xstatus) = XSTATUS" i;
     If process = "X" & xstatus = "NX" Then;
       Iterate;
     If process = "NX" & xstatus = "X" Then;
       Iterate;
     If process = "X" & xstatus = "X" Then;
       Do;
         If opt.1 = "BEFORE" Then;
           Do opt.2;
             "XSTATUS" i "= NX";
             i = i+1;
           End;
         i = i-1;
         process = "NX";
         Iterate;
       End;
     If process = "NX" & xstatus = "NX" Then;
       Do;
         If opt.1 = "AFTER" Then;
           Do;
             j = i-1;
             Do opt.2;
               "XSTATUS" j "= NX";
               j = j-1;
             End;
             process = "X";
           End;
         process = "X";
       End;
   End;

   "LOCATE" var.1;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Range:

   Parse VAR parm2 var.1 parm2;
   If var.1 <> "" Then;
     If Substr(var.1,1,1) <> "." Then
       Signal Error_INVALID_RANGE;

   Parse VAR parm2 var.2 parm2;
   If var.2 <> "" Then;
     If Substr(var.2,1,1) <> "." Then
       Signal Error_INVALID_RANGE;

   If (var.1 = "" & var.2 = "") | (var.1 <> "" & var.2 <> "") Then;
     Nop;
   Else;
     Signal Error_INVALID_RANGE;

   Return (0);

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("AFTER",var.3) Then;
         opt.1 = "AFTER";
       When Abbrev("BEFORE",var.3) Then;
         opt.1 = "BEFORE";
       When Datatype(var.3,"W") Then;
         opt.2 = var.3;
       Otherwise;
         Signal Error_INVALID_OPTION;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Unexclude count number of rows AFTER or BEFORE",
        pad hex04,
        "         a group of EXCLUDEd rows.",
        pad hex04,
        " Format: CMORE <range>",
        pad hex04,
        "               < ( BEFORE | AFTER <count> >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_OPTION:

   ZEDSMSG = "INVALID OPTION";
   ZEDLMSG = "Invalid/missing option ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_RANGE:

   ZEDSMSG = "INVALID RANGE";
   ZEDLMSG = "Range is not a valid set of labels"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=COLUTIL  0101-99322-15274-1444-00467-00345-00000-APLKS   48
/* REXX */
/*                           */
/* AUTHOR: Mark Zelden       */
/*                           */
/* Last Updated 10/07/2013   */
/*                           */
help_start = HELP_INCL()
/***************************************************************/
/*                                                             */
/* THIS EDIT MACRO CAN PERFORM 3 DIFFERENT FUNCTIONS:          */
/*                                                             */
/*    A)  MOVE, COPY or SWAP data from one range of            */
/*        columns to another (default is MOVE).                */
/*        Excluded lines are always omitted.                   */
/*                                                             */
/*    B)  SHIFT data LEFT or RIGHT a specified                 */
/*        number of columns - same as the "((" or "))" ISPF    */
/*        editor line commands.                                */
/*        Excluded lines are always omitted.                   */
/*                                                             */
/*    C)  CUT (copy) data from specific columns into the       */
/*        ISPF Default Clipboard. This data can then be        */
/*        used with PASTE later on.                            */
/*        Excluded lines are always omitted.                   */
/*                                                             */
/***************************************************************/
/* COMMAND SYNTAX:                                             */
/*                                                             */
/*   COLUTIL  or  COLUTIL ?   - displays help                  */
/*                                                             */
/* MOVE FORMAT:                                                */
/*                                                             */
/*   COLUTIL begcol endcol tgtcol (MOVE) (.label1) (.label2)   */
/*                                                             */
/* COPY FORMAT:                                                */
/*                                                             */
/*   COLUTIL begcol endcol tgtcol COPY  (.label1) (.label2)    */
/*                                                             */
/* SWAP FORMAT:                                                */
/*                                                             */
/*   COLUTIL begcol endcol tgtcol SWAP  (.label1) (.label2)    */
/*                                                             */
/* SHIFT FORMAT:                                               */
/*                                                             */
/*   COLUTIL <LEFT | RIGHT> amount (.label1) (.label2)         */
/*                                                             */
/* CUT FORMAT:                                                 */
/*                                                             */
/*   COLUTIL CUT begcol endcol (.label1) (.label2)             */
/*                                                             */
/***************************************************************/
/* USAGE NOTES:                                                */
/*                                                             */
/*  ** NOTE 1: If you execute COLUTIL with no parms or with    */
/*             a parm of "?", the comment section of this      */
/*             code with syntax and usage notes will be        */
/*             displayed as "help" note lines.  Use the        */
/*             "RESET" command to remove them.                 */
/*                                                             */
/*  ** NOTE 2: If using line range labels for a MOVE           */
/*             operation -  "MOVE" must be specified           */
/*             as the 4th positional parameter.                */
/*                                                             */
/*  ** NOTE 3: COPY, MOVE, SWAP, LEFT, RIGHT and CUT can all   */
/*             be abbreviated by using one or more of their    */
/*             characters.                                     */
/*                                                             */
/*  ** NOTE 4: Excluded lines are ALWAYS omitted.              */
/*                                                             */
/*  ** NOTE 5: On a SWAP operation, the length of the          */
/*             endcol-begcol determines the number of          */
/*             columns swapped starting with the tgtcol.       */
/*             For example, "COLUTIL 10 15 20 SWAP" will       */
/*             swap columns 10-15 with 20-25.                  */
/*                                                             */
/*  ** NOTE 6: On a SWAP operation, if there are overlapping   */
/*             columns, for example: "COLUTIL 10 20 15 SWAP",  */
/*             columns 15-25 will replace 10-20, then          */
/*             the original data from columns 10-20 will       */
/*             replace columns 15-25.                          */
/*                                                             */
/*  ** NOTE 7: On a CUT operation, if you have any existing    */
/*             data in the ISPF default clipboard, it will     */
/*             be overlaid.                                    */
/*                                                             */
/*  ** NOTE 8: On a CUT operation, ISPF considers the data     */
/*             changed due to the way the edit macro works.    */
/*             You must use "CANCEL" if you don't want the     */
/*             data in your edit session saved, although it    */
/*             is the same data as it was prior to the CUT.    */
/*                                                             */
/***************************************************************/
/*  MOVE EXAMPLES:                                             */
/*         COLUTIL 10 20 30                                    */
/*         COLUTIL 45 55 10 M                                  */
/*         COLUTIL 45 55 10 MOVE                               */
/*         COLUTIL 45 55 10 MOVE .A .B                         */
/*                                                             */
/*  COPY EXAMPLES:                                             */
/*         COLUTIL 10 15 20 C                                  */
/*         COLUTIL 10 15 20 COPY                               */
/*         COLUTIL 45 50 15 COPY .A .B                         */
/*                                                             */
/*  SWAP EXAMPLES:                                             */
/*         COLUTIL 20 25 50 S                                  */
/*         COLUTIL 40 45 10 SWAP                               */
/*         COLUTIL 45 50 15 SWAP .A .B                         */
/*                                                             */
/*  SHIFT EXAMPLES:                                            */
/*         COLUTIL R 4                                         */
/*         COLUTIL L 6                                         */
/*         COLUTIL RIGHT 10                                    */
/*         COLUTIL RIGHT 10 .A .B                              */
/*         COLUTIL LEFT 12                                     */
/*         COLUTIL LEFT 25  .A .B                              */
/*                                                             */
/*  CUT EXAMPLES:                                              */
/*         COLUTIL C 10 15                                     */
/*         COLUTIL CUT 68 68                                   */
/*         COLUTIL CUT 30 40 .A .B                             */
/*                                                             */
/***************************************************************/
help_end = HELP_INCL()
/* TRACE ?R */
Address ISREDIT
"MACRO (begcol endcol tgtcol type label1 label2)"
 /* Address ISPEXEC "CONTROL ERRORS RETURN"  */
/***********************************************/
/*   VERIFY INPUT PARAMETERS                   */
/***********************************************/
begcol = Translate(begcol) /* chage to upper case if alpha */
"(width) = DATA_WIDTH "    /* length of line       */
width    = Format(width)   /* remove leading zeros */
shiftop  = 'NO'            /* shift operation flag */
cutop    = 'NO'            /* cut operation flag   */
If begcol = '?' then do
  Call HELP_NOTELINES
  Exit 1  /* return cursor to command line */
End
If begcol = '' then do
  zedsmsg = 'MISSING PARAMETER'
  zedlmsg = '"CUT" OR A SHIFT TYPE OR A BEGINNING COLUMN NUMBER',
            'MUST BE SPECIFIED.'
  Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
  Call HELP_NOTELINES
  Exit 4
End
Select
  When Datatype(begcol,Number) = 1 & endcol = '' then do
    zedsmsg = 'NO ENDING COLUMN'
    zedlmsg = 'AN ENDING COLUMN FOR THE',
              'OPERATION MUST BE SPECIFIED.'
    Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
    Exit 12
  End /* when */
  When Datatype(begcol,Number) =1 & Datatype(endcol,Number) <>1 then do
    zedsmsg = 'END COLUMN NOT NUMERIC'
    zedlmsg = 'THE ENDING COLUMN FOR THE',
              'OPERATION MUST BE NUMERIC.'
    Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
    Exit 12
  End /* when */
  When Datatype(begcol,Number) =1 & Datatype(endcol,Number) =1 then do
    If endcol < begcol then do
      zedsmsg = 'END COL < START COL'
      zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',
                'EQUAL TO THE STARTING COLUMN.'
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    If tgtcol <> '' then do
      If Datatype(tgtcol,Number) <> 1 then do
        zedsmsg = 'TARGET COL NOT NUMERIC'
        zedlmsg = 'THE TARGET COLUMN FOR THE',
                  'OPERATION MUST BE NUMERIC.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
        Exit 12
      End
    End
    If tgtcol = '' then do
      zedsmsg = 'NO TARGET COLUMN'
      zedlmsg = 'YOU MUST SPECIFY A TARGET COLUMN',
                'FOR THE OPERATION.'
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    If type = '' then type = 'MOVE'
    else do
      type = Translate(type)  /* change to upper case */
      If Abbrev('MOVE',type,1) = 0 & ,
         Abbrev('COPY',type,1) = 0 & ,
         Abbrev('SWAP',type,1) = 0 then do
        zedsmsg = 'INVALID OPERATION'
        zedlmsg = 'OPERATION MUST BE "MOVE", "COPY", OR "SWAP".'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
        Exit 12
      End
    End /* else do */
    If begcol < 1 | endcol < 1 | tgtcol < 1 then do
      zedsmsg = 'INVALID COLUMN NUMBER'
      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,
                'BETWEEN 1 AND' width
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    If begcol > width | endcol > width | tgtcol > width then do
      zedsmsg = 'INVALID COLUMN NUMBER'
      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,
                'BETWEEN 1 AND' width
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    If begcol =  tgtcol then do
      zedsmsg = 'NO ACTION TAKEN'
      zedlmsg = 'THE STARTING COLUMN AND TARGET COLUMN',
                'CAN NOT BE THE SAME.'
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
  End /* when */
  Otherwise    /* shift or cut options being used */
    If Abbrev('CUT',begcol,1) = 0 & ,
       Abbrev('LEFT',begcol,1) = 0 & ,
       Abbrev('RIGHT',begcol,1) = 0 then do
      zedsmsg = 'INVALID OPTION'
      zedlmsg = '"CUT" OR A SHIFT DIRECTION OF "LEFT" OR "RIGHT"',
                'MUST BE SPECIFIED'
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    If (Abbrev('LEFT',begcol,1) <> 0 | ,
        Abbrev('RIGHT',begcol,1) <> 0 ) & ,
        endcol = '' then do
      zedsmsg = 'NO SHIFT AMOUNT'
      zedlmsg = 'A SHIFT AMOUNT FOR THE',
                'OPERATION MUST BE SPECIFIED.'
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    If  Abbrev('CUT',begcol,1) <> 0 & ,
        endcol = '' then do
      zedsmsg = 'NO STARTING COLUMN'
      zedlmsg = 'A STARTING COLUMN FOR THE CUT',
                'OPERATION MUST BE SPECIFIED.'
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    If  Abbrev('CUT',begcol,1) <> 0 & ,
        tgtcol = '' then do
      zedsmsg = 'NO ENDING COLUMN'
      zedlmsg = 'AN ENDING COLUMN FOR THE CUT',
                'OPERATION MUST BE SPECIFIED.'
      Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
      Exit 12
    End
    Else do
      If Abbrev('CUT',begcol,1) <> 0 then cutop = 'YES'
         else shiftop = 'YES'
      If Datatype(endcol,Number) <> 1 & shiftop = 'YES' then do
        zedsmsg = 'SHIFT AMOUNT NOT NUMERIC'
        zedlmsg = 'THE SHIFT AMOUNT SPECIFIED FOR THE',
                  'OPERATION MUST BE NUMERIC.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
        Exit 12
      End
      If (endcol > width - 1  | endcol < 1) & shiftop = 'YES' then do
        zedsmsg = 'INVALID SHIFT AMOUNT'
        zedlmsg = 'THE SHIFT AMOUNT SPECIFIED MUST',
                  'BE BETWEEN 1 AND' width - 1 || '.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
        Exit 12
      End
      If Datatype(endcol,Number) <> 1 & cutop = 'YES' then do
        zedsmsg = 'START COLUMN NOT NUMERIC'
        zedlmsg = 'THE STARTING COLUMN SPECIFIED FOR THE',
                  'CUT OPERATION MUST BE NUMERIC.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
        Exit 12
      End
      If ((endcol > width  | endcol < 1) | ,
         (tgtcol > width  | tgtcol < 1)) & ,
            cutop = 'YES' then do
        zedsmsg = 'INVALID CUT COLUMNS'
        zedlmsg = 'THE CUT COLUMNS SPECIFIED MUST',
                  'BE BETWEEN 1 AND' width || '.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
        Exit 12
      End
      If tgtcol < endcol & cutop = 'YES' then do
        zedsmsg = 'END COL < START COL'
        zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',
                  'EQUAL TO THE STARTING COLUMN.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
        Exit 12
      End
    End  /* else do */
End /* select */
/***********************************************/
/*   SHIFT PROCESSING SETUP                    */
/***********************************************/
If shiftop = 'YES' then do
  label1   = tgtcol
  label2   = type
  shiftamt = endcol
  type     = 'MOVE'  /* shift is really a MOVE operation    */
  If Abbrev('LEFT',begcol,1) <> 0 then do /* left shift */
    shifttyp = 'LEFT'
    begcol   = shiftamt + 1
    endcol   = width
    tgtcol   = 1
  End
  Else do /* right shift */
    shifttyp = 'RIGHT'
    begcol   = 1
    endcol   = width
    tgtcol   = shiftamt + 1
  End
End  /* if shiftop = 'YES' */
/***********************************************/
/*   CUT PROCESSING SETUP                      */
/***********************************************/
If cutop   = 'YES' then do
  label2   = label1
  label1   = type
  begcol   = endcol
  endcol   = tgtcol
  crpl1st  = 'YES'   /* "1st cut" flag to do "CUT REPLACE" */
 "(saveln) = DISPLAY_LINES"
End  /* if cutop = 'YES' */
/***********************************************/
/*   FIND OUT IF LABELS ARE BEING USED         */
/***********************************************/
Call FIND_LABELS
/***************************************************/
/* INITIALIZE VARIABLES NEEDED IN PROCESSING LOOP  */
/***************************************************/
count    = 0                 /* count of processed lines  */
tgtlen   =  endcol-begcol+1  /* length of operation       */
/***********************************************/
/*   BEGIN COLUMN PROCESSING LOOP              */
/***********************************************/
Do until lastln = firstln-1
  /* copy the data in the current line to variable 'data1' */
  "(data1) = LINE "firstln
  "ISREDIT (chkexcl) = XSTATUS" firstln
  If chkexcl = "NX" then do
    count = count + 1
    If cutop <> 'YES' then do   /* move/copy/swap/shift operation     */
      tgtdata = Substr(data1,begcol,tgtlen)
      If shiftop = 'YES' & shifttyp = 'LEFT' then ,  /* clr for left  */
         data1 = Overlay(' ',data1,width-shiftamt,shiftamt+1) /*shift */
      If Abbrev('MOVE',type,1) <> 0 then ,          /* clear data for */
         data1 = Overlay(' ',data1,begcol,tgtlen)   /* column MOVE    */
      If Abbrev('SWAP',type,1) <> 0 then do         /* SWAP           */
         data2 = Substr(data1,tgtcol,tgtlen)        /*   the          */
         data1 = Overlay(data2,data1,begcol,tgtlen) /*     data       */
      End
      data1 = Overlay(tgtdata,data1,tgtcol,tgtlen)  /* COPY data      */
    End  /* if cutop <> 'YES' */
    Else do /* cut operation */
      If begcol = 1 then data2 = data1
        Else data2 = Overlay(' ',data1,1,begcol-1)
      data3 = Overlay(' ',data2,endcol+1,width-endcol) /* data for cut */
     "LINE" firstln "= (data3)"
      If crpl1st  = 'YES' then do /* first cut -  replace clipboard */
        "CURSOR = " firstln 1
        "ISREDIT CUT .ZCSR .ZCSR REPLACE"
        crpl1st  = 'NO'      /* reset "1st cut" flag */
      End
      Else do
        "CURSOR = " firstln 1
        "ISREDIT CUT .ZCSR .ZCSR APPEND"
      End
    End /* else do */
  End
  /* copy the modified line back into the current line    */
  "LINE" firstln "= (data1)"
  firstln = firstln + 1
End   /* do until   */
/***********************************************/
/*   END COLUMN PROCESSING LOOP                */
/***********************************************/
If cutop = 'YES' then do
  "(lastln2) = LINENUM .ZLAST"
  "UP MAX"
  If saveln <> 1 then "DOWN " saveln  /* don't scroll if at top */
  zedsmsg = count 'LINES CUT'
  zedlmsg = count 'LINES WERE CUT FROM COLUMNS' begcol || '-' || ,
           endcol 'TO THE DEFAULT CLIPBOARD'
  Address ISPEXEC "SETMSG MSG(ISRZ000)"  /* msg - no alarm */
  Exit 1 /* return cursor to command line */
End
If shiftop <> 'YES' then do
   If Abbrev('MOVE',type,1) <> 0 then msgtype = 'MOVED'
   If Abbrev('SWAP',type,1) <> 0 then msgtype = 'SWAPPED'
    else msgtype = 'COPIED'
   If tgtlen+tgtcol-1 <= width then do  /* no truncation    */
     zedsmsg = count 'LINES CHANGED'
     zedlmsg = 'COLUMNS' begcol 'THROUGH' endcol 'ON' count ,
               'LINES WERE' msgtype 'TO COLUMN' tgtcol || '.'
     Address ISPEXEC "SETMSG MSG(ISRZ000)"  /* msg - no alarm */
     Exit 1  /* return cursor to command line */
   End
   Else do
     zedsmsg = count 'LINES TRUNCATED'
     zedlmsg = 'COLUMNS' begcol 'THROUGH' endcol 'ON' count ,
               'LINES WERE' msgtype 'TO COLUMN' tgtcol 'AND TRUNCATED.'
     Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
     Exit 4
   End
End
Else do /* total messages for shift */
  zedsmsg = count 'LINES SHIFTED'
  zedlmsg = count 'LINES WERE SHIFTED' shiftamt 'COLUMNS' ,
           'TO THE' shifttyp || '.'
  Address ISPEXEC "SETMSG MSG(ISRZ000)"  /* msg - no alarm */
  Exit 1  /* return cursor to command line */
End
/*********************************/
/*  HELP SUB-ROUTINES            */
/*********************************/
HELP_INCL:
Return SIGL
HELP_NOTELINES:
"(helpln) = DISPLAY_LINES"
Do hlp = help_end-1 to help_start+1 by -1
  hline = Sourceline(hlp)
  "ISREDIT LINE_AFTER " helpln " = NOTELINE (hline)"
End
hline2 = '==================='
hline3 = '===   H E L P   ==='
"ISREDIT LINE_AFTER " helpln " = NOTELINE (hline2)"
"ISREDIT LINE_AFTER " helpln " = NOTELINE (hline3)"
"ISREDIT LINE_AFTER " helpln " = NOTELINE (hline2)"
Return
/*********************************/
/*  SUB-ROUTINE TO FIND LABELS   */
/*********************************/
FIND_LABELS:
Address ISPEXEC "CONTROL ERRORS RETURN"
If label1 = '' then do
  firstln  = 1
  "(lastln) = LINENUM .ZLAST"
End
Else do
  If label2 = '' then label2 = label1
  "(firstsv)  = LINENUM" label1
  If RC >= 8 then do
    zedsmsg = 'RANGE LABEL ERROR'
    zedlmsg = 'THE SPECIFIED RANGE LABEL "' || label1 '" WAS',
              'NOT FOUND'
    Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
    Exit 12
  End
  "(lastsv)   = LINENUM" label2
  If RC >= 8 then do
    zedsmsg = 'RANGE LABEL ERROR'
    zedlmsg = 'THE SPECIFIED RANGE LABEL "' || label2 '" WAS',
              'NOT FOUND'
    Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm */
    Exit 12
  End
  firstln = Min(firstsv,lastsv)
  lastln  = Max(firstsv,lastsv)
Address ISPEXEC "CONTROL ERRORS"
End /* else do */
Return
./ ADD NAME=COUNT    0127-14350-16236-1801-00321-00165-00000-APLKS   07
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Used to count the lines, words, and              */
/*          characters in a member.                          */
/*                                                           */
/*          Excluded lines will not be counted.              */
/*                                                           */
/*  Format: COUNT target | range                             */
/*                < ( <options >>                            */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*                                                           */
/*         options: (default) LINES WORDS CHARS              */
/*                            LENGTH DISPLAY                 */
/*                  LINES - will be counted                  */
/*                  WORDS | NOWORDS                          */
/*                  CHARS | NOCHARS                          */
/*                  LENGTH | NOLENGTH                        */
/*                  QUEUE | STACK | DISPLAY                  */
/*                                                           */
/* Inspired by John Bentley's Programming Pearls             */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC COUNT */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   opt. = "";       /*1-LINE,2-WORD|NOWORD,3-CHAR|NOCHAR
                      4-LENGTH|NOLENGTH,5-QUEUE|STACK|DISPLAY*/
   line_count = 0;
   word_count = 0;
   char_count = 0;
   short_lgth = 99999;
   long_lgth = 0;
   shortest_line = 0;
   longest_line = 0;

   "(lrecl) = LRECL ";
   "(recfm) = RECFM ";
   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "LIN";      /*lines*/

   If opt.2 = "" Then;
     opt.2 = "WOR";      /*words*/

   If opt.3 = "" Then;
     opt.3 = "CHA";      /*chars*/

   If opt.4 = "" Then;
     opt.4 = "LEN";      /*length*/

   If opt.5 = "" Then;
     opt.5 = "DIS"       /*display*/

   opt.0 = 5;

   /* Parse Target and Primary passed Parms */

   Call Extract_Target;

   Do i = trgt_row_from To trgt_row_to By +1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     If RC = 12 Then;
       Leave;
     line_count = line_count + 1;
     If opt.2 = "WOR" Then;
       word_count = word_count + Words(row);
     If opt.3 = "CHA" Then;
       Do j = 1 To Words(row) By +1;
         char_count = char_count + Wordlength(row,j);
       End;
     If opt.4 = "LEN" Then;
       Select;
         When Substr(recfm,1,1) = "F" Then;
           Do;
             Do j = lrecl To 1 By -1 While Substr(row,j,1) = " ";
             End;
             If j < short_lgth Then;
               Do;
                 short_lgth = j;
                 shortest_line = i;
               End;
             If j > long_lgth Then;
               Do;
                 long_lgth = j;
                 longest_line = i;
               End;
           End;
         When Substr(recfm,1,1) = "V" Then;
           Do;
             "(vlen) = SAVE_LENGTH" i;
             If vlen < short_lgth Then;
               Do;
                 short_lgth = vlen;
                 shortest_line = i;
               End;
             If vlen > long_lgth Then;
               Do;
                 long_lgth = vlen;
                 longest_line = i;
               End;
           End;
         Otherwise;
           short_lgth = 0;
       End;
     Else;
       short_lgth = 0;
   End;

/* "RESET LABELS"; */
   If shortest_line <> longest_line Then;
     Do;
       "LABEL" shortest_line "= .PTS 0";
       "LABEL" longest_line "= .PTL 0";
     End;
   Else;
     "LABEL" shortest_line "= .PTS 0";

   the_string = "Lines=" line_count "Words=" word_count,
        "Chars=" char_count "LRECL("short_lgth","long_lgth")";

   Select;
     When opt.5 = "QUE" Then;
       Queue the_string;
     When opt.5 = "STA" Then;
       Push the_string;
     When opt.5 = "DIS" Then;
       Do;
         pad = Copies(" ",62);
         ZERRLM  = the_string;
         ZERRSM  = "";
         ZERRALRM= "NO";
         ZERRHM  = "*";
         Address ISPEXEC "SETMSG MSG(ISRZ002)";
       End;
     Otherwise;
       Nop;
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("WORDS",var.3,3) |,
            Abbrev("NOWORDS",var.3,3) Then;
         opt.2 = Substr(var.3,1,3);
       When Abbrev("CHARS",var.3,3) |,
            Abbrev("NOCHARS",var.3,3) Then;
         opt.3 = Substr(var.3,1,3);
       When Abbrev("LENGTH",var.3,3) |,
            Abbrev("NOLENG",var.3,3) Then;
         opt.4 = Substr(var.3,1,3);
       When Abbrev("QUEUE",var.3,3) |,
            Abbrev("STACK",var.3,3) |,
            Abbrev("DISPLAY",var.3,3) Then;
         opt.5 = Substr(var.3,1,3);
       Otherwise;
         Signal Error_INVALID_OPTS;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM = hex04,
        "Purpose: Count lines, words, characters, and length.",
        pad hex04,
        " Format: COUNT target|range ",
        pad hex04,
        "               < ( NOWORDS NOCHARS NOLEN < QUEUE | STACK > >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "Invalid user options ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=CSDGNREF 0100-15222-15222-1609-00132-00132-00000-APLKS   59
/* --------------------------------------------------------- */
/* Purpose: CSDGNREF is used to provide a list of groups     */
/*          that are not included in a list.                 */
/*                                                           */
/*  Format: CSDGNREF dataset_name                            */
/*                                                           */
/*    dataset_name:                                          */
/*                                                           */
/* --------------------------------------------------------- */
   Address TSO 'PROFILE NOPREFIX';
   Address ISPEXEC 'CONTROL ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG)';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');

/* Entering EXEC CSDGNREF */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = '?' | parm2 = 'HELP' | parm2 = 'help' Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

/* cts_vrm = MVSVar('SYMDEF',CTSVER); */
   cts_vrm = 'TS32';

   var. = '';
   parm_value = 'CSD(READONLY)';
   pds_dsname = 'CICS'||cts_vrm||'.CICS.SDFHLOAD';
   prt_dsname = Userid()||'.CSDLIST.D'||Date('B')'.T'||Time('S');
   out_dsname = Userid()||'.CSDNREF.D'||Date('B')'.T'||Time('S');

   /* Parse the User Options */

   /* none */

   /* Parse User Passed Parms */

   If parm2 <> '' Then;
     csd_dsname = Strip(parm2,'B');
   Else;
     Signal Error_NO_DATA;

   /* Allocate appropriate data sets */

   'FREE FILE(DFHCSD,SYSIN,SYSPRINT,OUTDD1)';
   'ALLOC FILE(DFHCSD) DSNAME('csd_dsname') SHR';
   'ALLOC FILE(SYSIN) DELETE DSORG(PS) RECFM(F B) LRECL(80)',
         'BLKSIZE(3120) SPACE(1,2) TRACKS';
   'ALLOC DSNAME('prt_dsname') DSORG(PS) RECFM(V B A) LRECL(133)',
         'BLKSIZE(13300) MOD';
   'ALLOC FILE(SYSPRINT) DSNAME('prt_dsname')';
   'ALLOC DSNAME('out_dsname') DSORG(PS) RECFM(F B) LRECL(80)',
         'BLKSIZE(3120) MOD';
   'ALLOC FILE(OUTDD1) DSNAME('out_dsname')';

   /* Mainline */

   Queue ' LIST LIST(*)';
   Queue ' LIST GROUP(*)';
   'EXECIO 2 DISKW SYSIN (FINIS';

   "CALL '"pds_dsname"(DFHCSDUP)'" "'"parm_value"'";
   If RC <> 0 Then;
     Signal End_of_EXEC;
   'EXECIO 0 DISKW OUTDD1 ( OPEN ';
   Address ISPEXEC 'EDIT   DATASET('prt_dsname') MACRO(CSD0)';
   Queue '99999999   99999999';
   Queue '********   ********  'csd_dsname;
   'EXECIO 2 DISKW OUTDD1 ( FINIS';
   Address ISPEXEC 'EDIT   DATASET('out_dsname') MACRO(CSD3)';

   End_of_EXEC:

   'DELETE ('prt_dsname')';
   'FREE FILE(SYSPRINT,DFHCSD,SYSIN)';
   Return(RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NO_DATA:

   ZEDSMSG = 'MISSING DSNAME';
   ZEDLMSG = 'NO DATASET SPECIFIED';
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return(-16);

   Error_INVALID_ENV:

   ZEDSMSG = 'INVALID ENV';
   ZEDLMSG = 'INVALID ENVIRONMENT:' addrsp_name;
   Address ISPEXEC 'SETMSG MSG(ISRZ000)';
   Return(-16);

   Error_EXEC_HELP:

   hex04 = '04'x;
   pad = Copies(' ',62);
   ZERRLM  = pad hex04,
        "Purpose: List the unreferenced groups in the DFHCSD",
        pad hex04,
        ' Format: CSDGNREF csd_dataset',
        pad hex04,
        "               < ( NODELETE | DELETE";
   ZERRSM  = '';
   ZERRALRM= 'NO';
   ZERRHM  = '*';
   Address ISPEXEC 'SETMSG MSG(ISRZ002)';
   Exit;
./ ADD NAME=CSD0
/* --------------------------------------------------------- */
/* Purpose: CSD0 inital macro to drive the process           */
/*                                                           */
/*  Format: CSD0                                             */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC 'CONTROL ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG)';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');

/* Entering EXEC CSD0 */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

/* Parse UPPER ARG parm2; */
   'MACRO () NOPROCESS';
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
/*   Signal Error_EDIT_MODE; */

   /* Mainline Routine */

   CSD1 OUTDD1;
   CSD2 OUTDD1;
   'END';

   End_of_EXEC:

   Return(RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EDIT_MODE:

   Say 'MUST BE IN EDIT MODE TO ENVOKE THIS EXEC';
   Return(-16);
./ ADD NAME=CSD1     0100-15222-15222-1611-00088-00088-00000-APLKS   56
/* --------------------------------------------------------- */
/* Purpose: CSD1 process "GROUP NAME:" entries of            */
/*          CSD LIST GROUP(*)                                */
/*                                                           */
/*  Format: CSD1                                             */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC 'CONTROL ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG)';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');

/* Entering EXEC CSD1 */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

/* Parse UPPER ARG parm2; */
   'MACRO (parm2) NOPROCESS';
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
/*   Signal Error_EDIT_MODE; */

   /* Initialize Variables */
   target.2 = 'LIST GROUP(*)';         /* Position */
   target.4 = 'GROUP NAME:';           /* Position */
   var. = '';
   group_name = '';
   list_name = '99999999';

   /* Parse the User Options */

   /* none */

   /* Parse the Optional EXEC Parameters */

   /* none */

   /* Mainline Routine */

   SEEK "'"target.2"'" NX;
   If RC <> 0 Then;
     Signal End_of_EXEC;
   SEEK "'"target.4"'" NEXT NX;
   If RC = 4 Then;
     Signal End_of_EXEC;
   Do Forever;
     '(line,column) = CURSOR';
     '(row) = LINE' line;
     Parse UPPER VAR row var.1 var.2 var.3;
     group_name = Left(var.3,10);
     Push group_name list_name;
     Address MVS 'EXECIO 1 DISKW 'parm2;
     RFIND;
     If RC = 4 Then;
       Leave;
   End;

   End_of_EXEC:

   Return(RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EDIT_MODE:

   Say 'MUST BE IN EDIT MODE TO ENVOKE THIS EXEC';
   Return(-16);
./ ADD NAME=CSD2     0100-15222-15222-1613-00109-00109-00000-APLKS   29
/* --------------------------------------------------------- */
/* Purpose: CSD2 process groups within each list             */
/*          CSD LIST LIST(*)                                 */
/*                                                           */
/*  Format: CSD2                                             */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC 'CONTROL ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG)';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');

/* Entering EXEC CSD2 */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

/* Parse UPPER ARG parm2; */
   'MACRO (parm2) NOPROCESS';
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
/*   Signal Error_EDIT_MODE; */

   /* Initialize Variables */
   target.1 = 'LIST LIST(*)';          /* Position */
   target.2 = 'LIST COMMAND EXECUTED'; /* Position */
   target.3 = 'LIST NAME:';            /* Position */
   target.5 = 'GROUP  ';               /* Position 17*/
   target.6 = 'GROUP DOES NOT EXIST';
   var. = '';
   group_name = '';
   list_name = '';

   /* Parse the User Options */

   /* none */

   /* Parse the Optional EXEC Parameters */

   /* none */

   /* Mainline Routine */

   SEEK "'"target.1"'" FIRST NX;
   If RC <> 0 Then;
     Signal End_of_EXEC;
   SEEK "'"target.2"'" NEXT  NX;
   '(eor,column) = CURSOR';
   EXCLUDE ALL;
   FIND "'"target.3"'" ALL;
   FIND "'"target.5"'" ALL;
   EXCLUDE "'"target.6"'" ALL;
   SEEK "'"target.3"'" FIRST NX;
   If RC <> 0 Then;
     Signal End_of_EXEC;
   '(line,column) = CURSOR';
   Do i = line to eor by 1;
     '(xstatus) = XSTATUS' i;
     If xstatus = 'X' Then;
       Iterate i;
     '(row) = LINE' i;
     Parse UPPER VAR row var.1 var.2 var.3;
     var.4 = var.1 || ' ' || var.2;
     Select;
       When var.4 = target.3 Then;
         Do;
           list_name = Left(Strip(var.3,'L'),40);
           Iterate i;
         End;
       When var.1 = target.5 Then;
         group_name = Left(Strip(var.2,'L'),10);
       Otherwise;
         Iterate i;
     End;
     Push group_name list_name;
     Address MVS 'EXECIO 1 DISKW 'parm2;
   End;

   End_of_EXEC:

   RESET;
   Return(RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EDIT_MODE:

   Say 'MUST BE IN EDIT MODE TO ENVOKE THIS EXEC';
   Return(-16);
./ ADD NAME=CSD3     0100-15222-15222-1631-00059-00059-00000-APLKS   51
/* --------------------------------------------------------- */
/* Purpose: CSD3 inital macro to drive the process           */
/*                                                           */
/*  Format: CSD3                                             */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC 'CONTROL ERRORS RETURN';
   Address ISPEXEC 'VGET (DEBUG)';
   If debug = 'DEBUG' Then;
     Do;
       x = MSG('ON');
       Trace R;
     End;
   Else;
     x = MSG('OFF');

/* Entering EXEC CSD3 */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

/* Parse UPPER ARG parm2; */
   'MACRO () NOPROCESS';
/* If RC <> 0 Then;
     Parse UPPER ARG parm2; */
/*   Signal Error_EDIT_MODE; */

   /* Mainline Routine */

   SORT;
   'XDUP * 1 9 ( ALL';
   'DEL ALL X';
   BUILTIN SAVE;

   End_of_EXEC:

   Return(RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EDIT_MODE:

   Say 'MUST BE IN EDIT MODE TO ENVOKE THIS EXEC';
   Return(-16);
./ ADD NAME=CSISRCH  0105-00258-15329-0914-00399-00326-00000-APLKS   09
/* REXX */
/*                     */
/* AUTHOR: Mark Zelden */
/*                     */
/*********************************************************************/
/*  MODIFIED FROM SYS1.SAMPLIB(IGGCSIRX)                             */
/*  MODIFIED BY:                                                     */
/*    2015-09-30 LKS chg if-then-else to select                      */
/*    2015-09-30 LKS chg presentation mechanism                      */
/*********************************************************************/
/*                                                                   */
/* EXECUTION SYNTAX:                                                 */
/*   CSISRCH dsn.filter <catalog name>                               */
/*   (catalog name is optional)                                      */
/*                                                                   */
/* FILTER CHARACTERS:                                                */
/*  %  - one character,   *  - one qualifier,                        */
/*  **  - one or more qualifiers                                     */
/*  NOTE: A double asterisk cannot precede or follow any characters; */
/*   it must be preceded or followed by either a period or a blank   */
/*    EXAMPLES:  SYS1.A*.**  (correct)                               */
/*               SYS1.A**    (not correct)                           */
/*                                                                   */
/* ** NOTE: Do not use quotes for the data set name filter or        */
/*          catalog name.                                            */
/*                                                                   */
/*  Caution should be exercised in using high-level qualifiers       */
/*  that contain generic filters because multiple catalogs can be    */
/*  searched.  A high-level of "**" will cause a search of every     */
/*  user catalog in the system.                                      */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
/* EXAMPLES:                                                         */
/*  TSO %CATSRCH USERID.**                                           */
/*  TSO %CATSRCH SYS1.LINK*                                          */
/*  TSO %CATSRCH SYS1.*LIB                                           */
/*  TSO %CATSRCH SYS1.*.PROCLIB                                      */
/*  TSO %CATSRCH SYS1.**.PROCLIB                                     */
/*  TSO %CATSRCH SYS1.A%%.*LIB                                       */
/*  TSO %CATSRCH USER*.**  TSO.USERCAT                               */
/*  TSO %CATSRCH SYS*.LINKLIB  SYSICF.MASTER                         */
/*  TSO %CATSRCH SYS*.LINKLIB  (see caution above)                   */
/*  TSO %CATSRCH SYS1.A*.**    (SYS1.A** won't give everything - see */
/*                               note on ** above)                   */
/*                                                                   */
/*********************************************************************/
LASTUPD = '09/30/2015'                       /* date of last update  */
/*********************************************************************/
 /********************************************************************/
 /*                                                                  */
 /*       NAME: IGGCSIRX                                             */
 /*DESCRIPTION: THIS REXX EXEC IS USED TO CALL THE CATALOG           */
 /*             SEARCH INTERFACE.                                    */
 /*      INPUT: FILTER KEY                                           */
 /*     OUTPUT: DATA SETS NAMES AND VOLUMES                          */
 /*                                                                  */
 /********************************************************************/
 /* SAY 'ENTER FILTER KEY' */       /*   ASK FOR FILTER KEY          */
 /* PULL KEY               */       /*   GET FILTER KEY              */
 /********************************************************************/
 /*                                                                  */
 /*  INITIALIZE THE PARM LIST                                        */
 /*                                                                  */
 /********************************************************************/

PARSE UPPER ARG KEY CAT .           /*                            MSZ*/
IF KEY = '' THEN DO                 /*                            MSZ*/
  SAY 'ENTER DATA SET NAME FILTER'  /*                            MSZ*/
  PULL KEY                          /*                            MSZ*/
END                                 /*                            MSZ*/
COUNT = 0                           /* TOTAL ENTIRES FOUND        MSZ*/
MODRSNRC = SUBSTR(' ',1,4)          /*   CLEAR MODULE/RETURN/REASON  */
CSIFILTK = SUBSTR(KEY,1,44)         /*   MOVE FILTER KEY INTO LIST   */
IF CAT <> '' THEN                   /*                            MSZ*/
  CSICATNM = SUBSTR(CAT,1,44)       /*   USE SPECIFIED CATALOG    MSZ*/
ELSE                                /*                            MSZ*/
  CSICATNM = SUBSTR(' ',1,44)       /*   CLEAR CATALOG NAME       MSZ*/
CSIRESNM = SUBSTR(' ',1,44)         /*   CLEAR RESUME NAME           */
CSIDTYPS = SUBSTR(' ',1,16)         /*   CLEAR ENTRY TYPES           */
CSICLDI  = SUBSTR('Y',1,1)          /*   INDICATE DATA AND INDEX     */
CSIRESUM = SUBSTR(' ',1,1)          /*   CLEAR RESUME FLAG           */
IF CAT <> '' THEN                   /*                            MSZ*/
  CSIS1CAT = SUBSTR('Y',1,1)        /* SEARCH ONLY 1 CAT          MSZ*/
ELSE                                /*                            MSZ*/
  CSIS1CAT = SUBSTR(' ',1,1)        /* SEARCH > 1 CATALOGS        MSZ*/
CSIRESRV = SUBSTR(' ',1,1)          /*   CLEAR RESERVE CHARACTER     */
CSINUMEN = '0001'X                  /*   INIT NUMBER OF FIELDS       */
CSIFLD1    = SUBSTR('VOLSER',1,8)   /*   INIT FIELD 1 FOR VOLSERS    */
 /********************************************************************/
 /*                                                                  */
 /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */
 /*                                                                  */
 /********************************************************************/
CSIOPTS  = CSICLDI || CSIRESUM || CSIS1CAT || CSIRESRV
CSIFIELD = CSIFILTK || CSICATNM || CSIRESNM || CSIDTYPS || CSIOPTS
CSIFIELD = CSIFIELD || CSINUMEN || CSIFLD1

 /********************************************************************/
 /*                                                                  */
 /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */
 /*                                                                  */
 /********************************************************************/
/* WORKLEN = 1024  */
/* DWORK = '00000400'X || COPIES('00'X,WORKLEN-4) */
WORKLEN = 131072  /* 128K */      /* APAR OW39593 */
DWORK = '00020000'X || COPIES('00'X,WORKLEN-4)   /* APAR OW39593 */

 /********************************************************************/
 /*                                                                  */
 /*  INITIALIZE WORK VARIABLES                                       */
 /*                                                                  */
 /********************************************************************/
RESUME = 'Y'
PREVNAME = ''                     /* NO PREVIOUS NAME            @01A*/
CATNAMET = SUBSTR(' ',1,44)
DNAMET = SUBSTR(' ',1,44)

 /********************************************************************/
 /*                                                                  */
 /*  SET UP LOOP FOR RESUME (IF A RESUME IS NCESSARY)                */
 /*                                                                  */
 /********************************************************************/
DO WHILE RESUME = 'Y'

 /********************************************************************/
 /*                                                                  */
 /*  ISSUE LINK TO CATALOG GENERIC FILTER INTERFACE                  */
 /*                                                                  */
 /********************************************************************/
 ADDRESS LINKPGM 'IGGCSI00  MODRSNRC  CSIFIELD  DWORK'

 RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */
 USEDLEN = C2D(SUBSTR(DWORK,9,4))   /* GET AMOUNT OF WORK AREA USED  */
 POS1=15                            /* STARTING POSITION             */

 /********************************************************************/
 /*                                                                  */
 /*  PROCESS DATA RETURNED IN WORK AREA                              */
 /*                                                                  */
 /********************************************************************/
 DO WHILE POS1 < USEDLEN            /* DO UNTIL ALL DATA IS PROCESSED*/
   IF SUBSTR(DWORK,POS1+1,1) = '0'  /* IF CATALOG, PRINT CATALOG HEAD*/
    THEN DO
         CATNAME=SUBSTR(DWORK,POS1+2,44)
         POS1 = POS1 + 50
         END

   DNAME = SUBSTR(DWORK,POS1+2,44)  /* GET ENTRY NAME                */

 /********************************************************************/
 /*                                                                  */
 /*  ASSIGN ENTRY TYPE NAME                                          */
 /*                                                                  */
 /********************************************************************/
   Select                                                     /* LKS */
     When Substr(dwork,pos1+1,1) = "A" Then;                  /* LKS */
       dtype = "NONVSAM ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "B" Then;                  /* LKS */
       dtype = "GDG     ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "C" Then;                  /* LKS */
       dtype = "CLUSTER ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "D" Then;                  /* LKS */
       dtype = "DATA    ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "G" Then;                  /* LKS */
       dtype = "AIX     ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "H" Then;                  /* LKS */
       dtype = "GDS     ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "I" Then;                  /* LKS */
       dtype = "INDEX   ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "R" Then;                  /* LKS */
       dtype = "PATH    ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "U" Then;                  /* LKS */
       dtype = "UCAT    ";                                    /* LKS */
     When Substr(dwork,pos1+1,1) = "X" Then;                  /* LKS */
       dtype = "ALIAS   ";                                    /* LKS */
     Otherwise;                                               /* LKS */
       Do;
         /* NO ENTRIES IN THE CATALOG OR UNKNOWN TYPE */      /* MSZ */
         /* UNKNOWN TYPE CAN BE CAUSED BY PARTIAL     */      /* MSZ */
         /* CATALOG RECORD SUCH AS AN INTERUPTED      */      /* MSZ */
         /* DELETE OR UPDATE-EXTEND (IDC11441I)       */      /* MSZ */
         /* THIS USED TO CAUSE A LOOP IN THIS CODE    */      /* MSZ */
         IF SUBSTR(DWORK,POS1+1,1) = '0' THEN                 /* MSZ */
           ITERATE  /* CAT ENTRY */                           /* MSZ */
         POS1 = POS1 + 46  /* UNKNOWN DTYPE   */              /* MSZ */
         POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2)) /* NEXT */   /* MSZ */
         ITERATE                                              /* MSZ */
       End;
   End;
 /********************************************************************/
 /* Moved this section of code from above so catalog name would      */
 /* not print during generic hlq search if no entires were found.    */
 /********************************************************************/
         IF CATNAME <> CATNAMET THEN /* IF RESUME NAME MAY ALREADY BE*/
          DO                         /*    PRINTED                   */
     /*    IF FOUND = 'TRUE' THEN  SAY   '     '  */
           IF FOUND = 'TRUE' THEN  QUEUE '     '
     /*    SAY 'CATALOG ' CATNAME */ /* IF NOT, PRINT IT             */
           QUEUE 'CATALOG ' CATNAME  /* IF NOT, PRINT IT             */
     /*    SAY ' '  */
           QUEUE '   '
           CATNAMET = CATNAME
           FOUND = 'TRUE'                                       /*MSZ*/
          END
 /*************************************************************//*MSZ*/
 /* CHECK FOR ERROR IN ENTRY RETURNED                         *//*MSZ*/
 /*************************************************************//*MSZ*/
   CSIEFLAG = SUBSTR(DWORK,POS1+0,1) /* Entry flag information*//*MSZ*/
   IF BITAND(CSIEFLAG,'40'X) = '40'X THEN DO                    /*MSZ*/
     POS1 = POS1 + 50           /* HEADER LENGTH */             /*MSZ*/
     POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2))                    /*MSZ*/
 /*  SAY   'ERROR PROCESSING THE FOLLOWING ENTRY:' */           /*MSZ*/
 /*  SAY   'DSN  =' DNAME                          */           /*MSZ*/
 /*  SAY   'CAT  =' CATNAME                        */           /*MSZ*/
 /*  SAY   'TYPE =' DTYPE                          */           /*MSZ*/
     QUEUE 'ERROR PROCESSING THE FOLLOWING ENTRY:'              /*MSZ*/
     QUEUE 'DSN  =' DNAME                                       /*MSZ*/
     QUEUE 'CAT  =' CATNAME                                     /*MSZ*/
     QUEUE 'TYPE =' DTYPE                                       /*MSZ*/
     ITERATE    /* GO TO NEXT ENTRY */                          /*MSZ*/
   END                                                          /*MSZ*/
 /********************************************************************/
 /*                                                                  */
 /*  HAVE NAME AND TYPE, GET VOLSER INFO                             */
 /*                                                                  */
 /********************************************************************/
    COUNT = COUNT + 1  /* total entires found  */               /*MSZ*/
    POS1 = POS1 + 46
    NUMVOL = C2D(SUBSTR(DWORK,POS1+4,2))/6 /* HOW MANY VOLSERS ?     */
                                    /*                               */
    POS2 = POS1+6                   /* POSITION ON DATA              */
    Drop VOLSER.
    ALLVOLS = ''
    DO I = 1 TO NUMVOL              /* MOVE VOLSERS TO OUTPUT FIELDS */
      VOLSER.I = SUBSTR(DWORK,POS2,6)
      POS2 = POS2 + 6
      ALLVOLS = ALLVOLS VOLSER.I
    END
 /* IF DNAMET <> DNAME THEN */    /* IF RESUME, NAME MAY ALREADY  MSZ*/
 /*                         */      /*    PRINTED                 MSZ*/
 /* DO                      */      /* IF NOT, PRINT IT           MSZ*/
  /* SAY COPIES(' ',8) DTYPE DNAME ALLVOLS */
     QUEUE COPIES(' ',8) DTYPE DNAME ALLVOLS

 /*  DNAMET=DNAME           */                                /* MSZ */
 /* END                     */                                /* MSZ */
 /********************************************************************/
 /*                                                                  */
 /*   GET POSITION OF NEXT ENTRY                                     */
 /*                                                                  */
 /********************************************************************/
    POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2))
  END
 IF RESUME = 'Y' &,                 /* IF WE'VE TRIED THIS ENTRY @01A*/
  PREVNAME = DNAME THEN             /* TWICE, WE'VE GOT TO QUIT  @01A*/
   DO                                                          /*@01A*/
  /* SAY STRIP(DNAME) 'CANNOT BE PROCESSED WITH THE WORK AREA SIZE ',*/
  /*     'PROVIDED - YOU MUST INCREASE THE WORK AREA AND RETRY'      */
   QUEUE STRIP(DNAME) 'CANNOT BE PROCESSED WITH THE WORK AREA SIZE '
   QUEUE  'PROVIDED - YOU MUST INCREASE THE WORK AREA AND RETRY'
   /*RETURN */                                                 /*@01A*/
     LEAVE                                                     /*@01A*/
   END                                                         /*@01A*/
 PREVNAME = DNAME                   /* SAVE FOR NEXT ITERATION   @01A*/
END
 /********************************************************************/

QUEUE ''  /* NULL TO END STACK */
IF SYSVAR(SYSISPF)='ACTIVE' THEN
  CALL BROWSE_ISPF
ELSE
  DO QUEUED()
    PARSE PULL LINE
    SAY LINE
  END
EXIT 0

BROWSE_ISPF: /* BROWSE OUTPUT IF ISPF IS ACTIVE */
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
ADDRESS TSO

   "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",                     /* LKS */
   " LRECL(132) BLKSIZE(0)",                                  /* LKS */
   " UNIT(SYSDA) TRACKS SPACE(5,15)",                         /* LKS */
   " NEW DELETE REUSE";                                       /* LKS */
   EC = RC;                                                   /* LKS */
   If RC <> 0 Then;                                           /* LKS */
     Do;                                                      /* LKS */
       ZEDSMSG = "ALLOC FAILED";                              /* LKS */
       ZEDLMSG = "Target Seq file allocation failed, RC= :"   /* LKS */
            EC;                                               /* LKS */
       Address ISPEXEC "SETMSG MSG(ISRZ000)";                 /* LKS */
       Return (-16);                                          /* LKS */
     End;                                                     /* LKS */
   "EXECIO * DISKW OUTDD ( FINIS "                            /* LKS */
   If RC = 0 Then;                                            /* LKS */
     Do;                                                      /* LKS */
       Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";/* LKS */
       Address ISPEXEC "VIEW DATAID("tgtid")";                /* LKS */
       Address ISPEXEC "LMFREE DATAID("tgtid")";              /* LKS */
     End;                                                     /* LKS */
                                                              /* LKS */
   Return;                                                    /* LKS */

/* don't fall into this code any more */                      /* LKS */

UID   = SYSVAR('SYSUID')        /* TSO USERID            */
DDNM1 = 'DDO'||RANDOM(1,99999)  /* CHOOSE RANDOM DDNAME  */
DDNM2 = 'DDP'||RANDOM(1,99999)  /* CHOOSE RANDOM DDNAME  */
JUNK = MSG('OFF')
"ALLOC FILE("||DDNM1||") UNIT(SYSALLDA) NEW CYL SPACE(5,5) DELETE",
     " REUSE LRECL(132) RECFM(F B) BLKSIZE(8976)"
"ALLOC FILE("||DDNM2||") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE",
      " REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)"
JUNK = MSG('ON')
"NEWSTACK"
/*************************/
/* CATPNL PANEL SOURCE   */
/*************************/
ADDRESS ISPEXEC "VGET ZENVIR"                                 /* LKS */
IF SUBSTR(ZENVIR,6,1) >= 4 THEN
  QUEUE ")PANEL KEYLIST(ISRSPBC,ISR)"
QUEUE ")ATTR"
QUEUE "  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)"
QUEUE "  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)"
QUEUE "  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)"
QUEUE "  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)"
QUEUE "  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)"
QUEUE "  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)"
QUEUE " 01 TYPE(DATAOUT) INTENS(LOW)"
QUEUE " 02 TYPE(DATAOUT) INTENS(HIGH)"
QUEUE " 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)"
QUEUE " 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)"
QUEUE " 0D TYPE(DATAOUT) INTENS(HIGH)"
QUEUE " 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)"
QUEUE " 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)"
QUEUE " 12 TYPE(DATAOUT) INTENS(LOW)"
QUEUE ")BODY EXPAND(//) WIDTH(&ZWIDTH)"
QUEUE "%BROWSE  @&ZTITLE  / /  %LINE!ZLINES  %COL!ZCOLUMS+"
QUEUE "%COMMAND ===>_ZCMD / /           %SCROLL ===>_Z   +"
QUEUE "|ZDATA ---------------/ /-------------------------|"
QUEUE "|                     / /                         |"
QUEUE "| --------------------/-/-------------------------|"
QUEUE ")INIT"
QUEUE "  .HELP = ISR10000"
QUEUE "  .ZVARS = 'ZSCBR'"
QUEUE "  &ZTITLE = 'Mark''s MVS Utilities - CATSRCH'"
QUEUE "  VGET (ZSCBR) PROFILE"
QUEUE "  IF (&ZSCBR = ' ')"
QUEUE "   &ZSCBR = 'CSR'"
QUEUE ")REINIT"
QUEUE "  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)"
QUEUE ")PROC"
QUEUE "  &ZCURSOR = .CURSOR"
QUEUE "  &ZCSROFF = .CSRPOS"
QUEUE "  &ZLVLINE = LVLINE(ZDATA)"
QUEUE "  VPUT (ZSCBR) PROFILE"
QUEUE ")END"
QUEUE ""
/*                                    */
Address ISPEXEC "LMINIT DATAID(PAN) DDNAME("ddnm2")"
Address ISPEXEC "LMOPEN DATAID("pan") OPTION(OUTPUT)"
Do queued()
   Parse pull panline
   Address ISPEXEC "LMPUT DATAID("pan") MODE(INVAR)" ,
           "DATALOC(PANLINE) DATALEN(80)"
End
Address ISPEXEC "LMMADD DATAID("pan") MEMBER(CATPNL)"
Address ISPEXEC "LMFREE DATAID("pan")"
"Delstack"
"EXECIO * DISKW" DDNM1 "(FINIS"
IF FOUND <> 'TRUE' THEN DO
  ZEDSMSG = 'No matches found'
  ZEDLMSG = 'No matches were found for' KEY ||'.' ,
          '  CATSRCH -' ,
          'Last updated on' LASTUPD ||'. Written by' ,
          'Mark Zelden. Mark''s MVS Utilities -' ,
          'http://www.mzelden.com/mvsutil.html'
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"  /* MSG - WITH ALARM */
END
ELSE DO
  ZEDSMSG = COUNT 'matches found'
  ZEDLMSG = COUNT 'matches were found for' KEY ||'.' ,
          '  CATSRCH -' ,
          'Last updated on' LASTUPD ||'. Written by' ,
          'Mark Zelden. Mark''s MVS Utilities -' ,
          'http://www.mzelden.com/mvsutil.html'
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ000)"  /* MSG - NO ALARM */
END
ADDRESS ISPEXEC "LIBDEF ISPPLIB LIBRARY ID("||ddnm2||") STACK"
ADDRESS ISPEXEC "LMINIT DATAID(TEMP) DDNAME("||ddnm1||")"
ADDRESS ISPEXEC "BROWSE DATAID("||temp") PANEL(CATPNL)"
ADDRESS ISPEXEC "LMFREE DATAID("||temp")"
ADDRESS ISPEXEC "LIBDEF ISPPLIB"
JUNK = MSG('OFF')
"FREE FI("||ddnm1||")"
"FREE FI("||ddnm2||")"
RETURN
./ ADD NAME=CSVEDIT  0127-01236-16174-1004-00362-00114-00000-APLKS   12
        /* --------------------  rexx procedure  -------------------- */
        ver = "1.2"
        /* Name:      csvedit                                         *
         *                                                            *
         * Function:  ISPF Edit Macro to convert data to csv format   *
         *                                                            *
         * Syntax:    csvedit                                         *
         *                                                            *
         * Logic:     (such as it is)                                 *
         *            Invoke as an ISPF Edit Macro with no parms      *
         *            Test line 1 of the data for column indicator    *
         *              characters - a >                              *
         *              - if column indicators are found then         *
         *                - set to null all column values             *
         *                - find column for each > and set the        *
         *                  column values                             *
         *            Display the CSVEDIT prompting panel             *
         *              - user may change/update column values        *
         *              - user may enter ignore information           *
         *                - column or 0 for any column                *
         *                - data or ' ' for blank                     *
         *            Processing flow                                 *
         *              - remove all records which match ignore       *
         *                specifications                              *
         *              - process column information                  *
         *                - if data begins with 0 then set ="xx"      *
         *                - enclose in double quotes (") if           *
         *                  - a blank or comma is found in the        *
         *                    data                                    *
         *                                                            *
         * Author:    Lionel B. Dyck                                  *
         *            Kaiser Permanente Information Technology        *
         *            Walnut Creek, CA 94598                          *
         *            (925) 926-5332                                  *
         *            Internet: lionel.b.dyck@kp.org                  *
         *                                                            *
         * History:                                                   *
         *            05/31/16 - v1.2 minor bug fix                   *
         *                       thanks to Larry Slaten               *
         *            04/09/08 - v1.1 From Rick Turnbull (StateAuto)  *
         *            04/09/08 - v1.1 From Rick Turnbull (StateAuto)  *
         *                            to convert signs in numbers     *
         *            11/06/02 - v1.0 add option for alternate char   *
         *                            for comma                       *
         *            09/01/01 - v0.9 add option for leading zeros    *
         *            08/30/01 - v0.8 correct for empty column        *
         *            08/30/01 - v0.7 correct for files with cc       *
         *            08/30/01 - v0.6 correct test for ' '            *
         *            08/27/01 - v0.5 add column 14                   *
         *            08/27/01 - v0.4 fix lost character              *
         *            08/27/01 - v0.3 support leading zeros           *
         *            08/27/01 - v0.2 level                           *
         *            08/27/01 - v0.1 level                           *
         *            08/24/01 - v.0.01 created                       *
         *                                                            *
         * ---------------------------------------------------------- */
         Address ISREdit
         "Macro"

        /* --------------------------------------------------------- *
         * Setup Default Values                                      *
         * --------------------------------------------------------- */
         parse value "" with null
         /* StateAuto Modification Begin */
                                        /* tables used in function */
                                        /*  ConvertSign            */
         TI1 = 'C0C1C2C3C4C5C6C7C8C9'x  /* positive signed numbers */
         TI2 = 'D0D1D2D3D4D5D6D7D8D9'x  /* negative signed numbers */
         TO1 = '0123456789'             /* numbers with no sign    */
         /* StateAuto Modification End   */

        /* --------------------------------------------------------- *
         * Look for column specification characters '>' in record 1  *
         * if found:                                                 *
         *   - delete the line of data (as we don't need it)         *
         *   - reset column values to null                           *
         *   - get column location for each '>' and then set the     *
         *     corresponding column value                            *
         * --------------------------------------------------------- */
          "(data) = line 1"
          if pos(" > ",data) > 0 then do
             "Delete" 1
             parse value "" with c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb ,
                                 cc cd ce
             start = 1
             count = 1
             pos. = null
             do forever
                p = pos(">",data,start)
                if p = 0 then leave
                pos.count = p
                start = p+1
                count = count + 1
                end
             if pos.1 <> null then c1 = pos.1
             if pos.2 <> null then c2 = pos.2
             if pos.3 <> null then c3 = pos.3
             if pos.4 <> null then c4 = pos.4
             if pos.5 <> null then c5 = pos.5
             if pos.6 <> null then c6 = pos.6
             if pos.7 <> null then c7 = pos.7
             if pos.8 <> null then c8 = pos.8
             if pos.9 <> null then c9 = pos.9
             if pos.10 <> null then ca = pos.10
             if pos.11 <> null then cb = pos.11
             if pos.12 <> null then cc = pos.12
             if pos.13 <> null then cd = pos.13
             if pos.14 <> null then ce = pos.14
             end

        /* --------------------------------------------------------- *
         * Display CSVEDIT ISPF Panel to get conversion info         *
         * --------------------------------------------------------- */
         Display:
         Address ISPExec
         "Display panel(csvedit)"
         src = rc
         if src > 0 then do
            zedsmsg = "Cancelled."
            zedlmsg = "CSV Edit Conversion Cancelled."
            "Setmsg msg(isrz001)"
            exit 0
            end

        /* --------------------------------------------------------- *
         * Save the Panel variables in the ISPF Profile              *
         * --------------------------------------------------------- */
         "Vput (c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce " ,
               "d1 d2 d3 d4 d5 d6 char" ,
               "i1 i2 i3 i4 i5 i6 lz s) Profile"

         Address ISREdit

        /* --------------------------------------------------------- *
         * Validate the provided input                               *
         * - test to ensure columns are sequential in order           *
         * --------------------------------------------------------- */
         zedsmsg = ""
         if ce <> "" then
            if cd > ce then do
               zedlmsg = "Column 14 is not greater than column 13"
               call do_msg
               end
         if cd <> "" then
            if cc > cd then do
               zedlmsg = "Column 13 is not greater than column 12"
               call do_msg
               end
         if cc <> "" then
            if cb > cc then do
               zedlmsg = "Column 12 is not greater than column 11"
               call do_msg
               end
         if cb <> "" then
            if ca > cb then do
               zedlmsg = "Column 11 is not greater than column 10"
               call do_msg
               end
         if ca <> "" then
            if c9 > ca then do
               zedlmsg = "Column 9 is not greater than column 10"
               call do_msg
               end
         if c9 <> "" then
            if c8 > c9 then do
               zedlmsg = "Column 8 is not greater than column 9"
               call do_msg
               end
         if c8 <> "" then
            if c7 > c8 then do
               zedlmsg = "Column 7 is not greater than column 8"
               call do_msg
               end
         if c7 <> "" then
            if c6 > c7 then do
               zedlmsg = "Column 6 is not greater than column 7"
               call do_msg
               end
         if c6 <> "" then
            if c5 > c6 then do
               zedlmsg = "Column 5 is not greater than column 6"
               call do_msg
               end
         if c5 <> "" then
            if c4 > c5 then do
               zedlmsg = "Column 4 is not greater than column 5"
               call do_msg
               end
         if c4 <> "" then
            if c3 > c4 then do
               zedlmsg = "Column 3 is not greater than column 4"
               call do_msg
               end
         if c3 <> "" then
            if c2 > c3 then do
               zedlmsg = "Column 2 is not greater than column 3"
               call do_msg
               end
         if c2 <> "" then
            if c1 > c2 then do
               zedlmsg = "Column 1 is not greater than column 2"
               call do_msg
               end

        /* --------------------------------------------------------- *
         * Delete all records matching Ignore criteria.              *
         * --------------------------------------------------------- */
         "cursor = line 1"
         "(line) = linenum .zcsr"
         if i1 <> null then do forever
            "(last) = linenum .zl"
            if del = 0 then line = line + 1
            if line > last then leave
            del = 0
            "(data) = line" line
            data = translate(data)
            call test_ignore i1 d1
               if del = 1 then iterate
            call test_ignore i2 d2
               if del = 1 then iterate
            call test_ignore i3 d3
               if del = 1 then iterate
            call test_ignore i4 d4
               if del = 1 then iterate
            call test_ignore i5 d5
               if del = 1 then iterate
            call test_ignore i6 d6
            end

        /* --------------------------------------------------------- *
         * Now begin CSV conversion                                  *
         * --------------------------------------------------------- */
         line = 0
         "(last) = linenum .zl"
         do forever
            line = line + 1
            if line > last then leave
            "(data) = line" line
            record = null
            if c1 <> null then call do_csv c1 c2
            if c2 <> null then call do_csv c2 c3
            if c3 <> null then call do_csv c3 c4
            if c4 <> null then call do_csv c4 c5
            if c5 <> null then call do_csv c5 c6
            if c6 <> null then call do_csv c6 c7
            if c7 <> null then call do_csv c7 c8
            if c8 <> null then call do_csv c8 c9
            if c9 <> null then call do_csv c9 ca
            if ca <> null then call do_csv ca cb
            if cb <> null then call do_csv cb cc
            if cc <> null then call do_csv cc cd
            if cd <> null then call do_csv cd ce
            if ce <> null then call do_csv ce
            if left(record,1) = "," then
               record = substr(record,2)
            record = " "left(record,length(record)-1)
            "LINE" line   " = (record)"
            end

        /* --------------------------------------------------------- *
         * Processing completed - inform the user.                   *
         * --------------------------------------------------------- */
        zedsmsg = ""
        zedlmsg = "CSV Conversion completed.",
                  "The file is now ready for download or" ,
                  "e-mail for import into Excel."
        Address ISPExec
        "Setmsg msg(isrz001)"
        Exit 0

        /* --------------------------------------------------------- *
         * Extract CSV Column Data                                   *
         * Then test it:                                             *
         *   - begins with a zero       = set to ="xxx"              *
         *            test lz panel option                           *
         *   - contains a comma         = enclose in double quotes   *
         *   - contains a blank         = enclose in double quotes   *
         *   - insert comma between values                           *
         * --------------------------------------------------------- */
         Do_CSV:
           arg start next
           if next = null then
              work = strip(substr(data,start))
           else
              work = strip(substr(data,start,next-start))
           if length(work) = 0 then work = " "
           /* StateAuto Modification Begin */
           if s1 = 'Y' then work = ConvertSign(work)
              /* s1 is initialize on the main panel */
           /* StateAuto Modification End   */

           Select
             When pos(",",work) > 0 then work = '"'work'"'
             When pos(" ",work) > 0 then work = '"'work'"'
             When left(work,1) = "0" then do
                  if lz = "YES" then
                     work = '="'work'"'
                  end
             otherwise nop
             end

           work = work""char
           record = record""work
           return

        /* --------------------------------------------------------- *
         * Test for Ignore Record Subroutine                         *
         * --------------------------------------------------------- */
         Test_Ignore:
         arg posit test_data
         del = 0
         if test_data = "' '" then test_data = " "
         select
         When posit = 0 then
           if pos(test_data,data) > 0 then do
             "Delete" line
             del = 1
             end
         When posit > 0 then
            if substr(data,posit,length(test_data)) = test_data then do
             "Delete" line
             del = 1
             end
         Otherwise nop
         end
         return

        /* --------------------------------------------------------- *
         * Issue message and redisplay prompt                        *
         * --------------------------------------------------------- */
         do_msg:
            Address ISPExec
            "Setmsg msg(isrz001)"
            signal display

        /* --------------------------------------------------------- *
         * StateAuto Modification Begin                              *
         * --------------------------------------------------------- *
                 Function to convert Signed Numeric fields to
                 Separate signs.
                 Examples: Convert  000123{  to +1230
                                    000324P  to -3247
        */
        ConvertSign:
          parse arg sField
          nPart = strip(left(sField,length(sField)-1))
          sPart = right(sField,1)
          if datatype(nPart,"N") = 1 then do
            select
              when sPart >= 'D0'x & sPart <= 'D9'x then do
                sField = "-"strip(nPart,"L","0")||,
                         translate(sPart,TO1,TI2)
                end
              when sPart >= 'C0'x & sPart <= 'C9'x then do
                sField = "+"strip(nPart,"L","0")||,
                         translate(sPart,TO1,TI1)
                end
              otherwise nop
              end
            end
          return sField
        /* StateAuto Modification End   */
./ ADD NAME=DACEE    0103-17038-17038-1230-00135-00135-00000-APLKS   36
/* REXX 2017-02-07 */
/* --------------------------------------------------------- */
/* Purpose: Invoke program DACEE to display RACF profile     */
/*          Control Block (ACEE).                            */
/*                                                           */
/*  Format: DACEE  ( options                                 */
/*                                                           */
/*         options: (default) SCREEN                         */
/*                  LINE|SCREEN presentation option          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC %DACEE   */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var = "";
   opt. = "";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1;

   /* Mainline */

   ec = Outtrap(lne.);
   "DACEE";
   ec = Outtrap("OFF");

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do i=1 To lne.0 By +1;
         Say lne.i;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(1)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD (STEM LNE. FINIS)"
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) Then;
         opt.1 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display RACF profile (ACEE)",
        pad hex04,
        " Format: %DACEE  ( SCREEN|LINE ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=DATE     0122-14174-19270-1453-00209-00268-00000-APLKS   13
/* REXX 2019-09-27 */
/* --------------------------------------------------------- */
/* Purpose: Display information about a specific date.       */
/*                                                           */
/*  Format: DATE < yyyymmdd | yyyyddd | 0cyyddd | yyddd >    */
/*                                                           */
/*  Base date is the number of days since Jan 1, 0001.       */
/*  Lilian day is the number of days since the beginning     */
/*  of the Gregorian Calendar (Oct 15, 1582).                */
/*  ANSI day is the number of days since Dec 31, 1600.       */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC DATE */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   Signal on Error NAME Error_INVALID_DATE;
   Signal on Failure NAME Error_INVALID_DATE;
   Signal on Syntax NAME Error_INVALID_DATE;

   /* Initialize Variables */

   input_date = "";

   /*title of day table*/
   tod.0 = 7;
   tod.1 = "Mon";
   tod.2 = "Tue";
   tod.3 = "Wed";
   tod.4 = "Thu";
   tod.5 = "Fri";
   tod.6 = "Sat";
   tod.7 = "Sun";

   /* Parse User Passed Parms */

      /*None*/

   /* Parse the Optional EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       input_date = Strip(Word(parm2,1),"B");
       Select;
         When Length(input_date) = 5 Then;
           /* input format yyddd */
           input_date = Date("S",input_date,"J");
         When Length(input_date) = 7 Then;
           /* input format yyyyddd 0cyyddd */
           Select;
             When Substr(input_date,1,1) = 0 Then;
               /* input format 0cyyddd */
               Do;
                 input_date = 1900000 + input_date;
                 input_date = Jdate2G(input_date);
                 If Substr(input_date,1,7) = "UNKNOWN" Then;
                   Signal Error_INVALID_DATE;
               End;
             When Substr(input_date,1,4) > 1999 Then;
               /* input format yyyyddd */
               input_date = Date("S",Substr(input_date,3,5),"J");
             Otherwise;
               Signal Error_INVALID_DATE;
           End;
         When Length(input_date) = 8 Then;
           /* input format yyyymmdd */
           sorted_date = input_date;
         Otherwise;
           Signal Error_INVALID_DATE;
       End;
     End;

   /* Mainline */

   If input_date = "" Then;
     Do;
       base_day = Date("B");
       days_this_century = Date("C");
       days_this_year = Date("D");
       european_date = Date("E");
       julian_date = Date("J");
       normal_date = Date("N");
       ordered_date = Date("O");
       sorted_date = Date("S");
       usa_date = Date("U");
     End;
   Else;
     Do;
       base_day = Date("B",input_date,"S");
       days_this_century = "N/A";
       days_this_year = Date("D",input_date,"S");
       european_date = Date("E",input_date,"S");
       julian_date = Substr(input_date,3,2) ,
            || Right(days_this_year,3,0);
       normal_date = Date("N",input_date,"S");
       ordered_date = Date("O",input_date,"S");
       usa_date = Date("U",input_date,"S");
     End;

   civil_time = Time("C");
   standard_time = Time("N");

   lilian_day = base_day - 577734;
   ansi_day = base_day - 584387;
   unix_day = lilian_day - 141428;

   days_in_year = 365;
   sorted_year = Substr(sorted_date,1,4);
   If Substr(sorted_year,3,2) = "00" Then;
     Do;
       /*check for leap century*/
       If (sorted_year // 400) = 0 Then;
         days_in_year = 366;
     End;
   Else;
     /*check for leap year*/
     If (sorted_year // 4) = 0 Then;
       days_in_year = 366;
   days_left_in_year = days_in_year - days_this_year;

   dayofwk = base_day // 7 + 1; /*Mon-Sun 1-7*/

   edited_date = "N/A";
   easter_date = Easter(sorted_year);
   If Word(easter_date,1) <> "error" Then;
     edited_date = Substr(easter_date,1,4) || ,
          "/" || ,
          Substr(easter_date,5,2) || ,
          "/" || ,
          Substr(easter_date,7,2);

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Date:" tod.dayofwk normal_date,
        " Current Time:" standard_time,
        pad hex04,
        "Base:" base_day,
        " Lilian:" lilian_day,
        " ANSI:" ansi_day,
        pad hex04,
        "Days this Century:" days_this_century,
        " Day:" days_this_year,
        " Days left:" days_left_in_year,
        pad hex04,
        "GMT offset:" GMT() " Easter:" edited_date;
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display information about a specific date.",
        pad hex04,
        " Format: DATE < yyyymmdd | yyyyddd | 0cyyddd | yyddd >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_DATE:

   ZEDSMSG = "INVALID DATE";
   ZEDLMSG = "Invalid date ("parm2")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=DATES    0111-19169-19270-1552-00484-00268-00000-APLKS   32
/* REXX 2019-09-27 */
/* --------------------------------------------------------- */
/* Purpose: Display information about a specific date.       */
/*                                                           */
/*  Format: DATES < yyyymmdd | yyyyddd | 0cyyddd | yyddd >   */
/*                                                           */
/*  Base day is the number of days since Jan 1, 0001.        */
/*                                                           */
/*  Lilian day is the number of days since the beginning     */
/*  of the Gregorian Calendar (Oct 15, 1582).                */
/*                                                           */
/*  ANSI day is the number of days since Jan 1, 1601.        */
/*  To handle dates earlier than 1601, add 4000 to each      */
/*  year, calculate, subtract 4000 from the result.          */
/*                                                           */
/*  Julian day is the number of days since Jan 1, 4713 BCE   */
/*  Used in all astronomical calculations.                   */
/*                                                           */
/*  Lunar cycle is 29,530 days (80.8 yr)                     */
/*                                                           */
/* --------------------------------------------------------- */

/* Entering EXEC DATES */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   Signal on Error NAME Error_INVALID_DATE;
   Signal on Failure NAME Error_INVALID_DATE;
   Signal on Syntax NAME Error_INVALID_DATE;

   Numeric Digits 12;

   /* Initialize Variables */

   input_date = "";
   tmp_hh = 0;
   tmp_mm = 0;
   tmp_ss = 0;

   /*title of day table*/
   tod.0 = 7;
   tod.1 = "Mon";
   tod.2 = "Tue";
   tod.3 = "Wed";
   tod.4 = "Thu";
   tod.5 = "Fri";
   tod.6 = "Sat";
   tod.7 = "Sun";

   /* Parse User Passed Parms */

      /*None*/

   /* Parse the Optional EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       input_date = Strip(Word(parm2,1),"B");
       Select;
         When Length(input_date) = 5 Then;
           /* input format yyddd */
           input_date = Date("S",input_date,"J");
         When Length(input_date) = 7 Then;
           /* input format yyyyddd 0cyyddd */
           Select;
             When Substr(input_date,1,1) = 0 Then;
               /* input format 0cyyddd */
               Do;
                 input_date = 1900000 + input_date;
                 input_date = Jdate2G(input_date);
                 If Substr(input_date,1,7) = "UNKNOWN" Then;
                   Signal Error_INVALID_DATE;
               End;
             When Substr(input_date,1,4) > 1999 Then;
               /* input format yyyyddd */
               input_date = Date("S",Substr(input_date,3,5),"J");
             Otherwise;
               Signal Error_INVALID_DATE;
           End;
         When Length(input_date) = 8 Then;
           /* input format yyyymmdd */
           sorted_date = input_date;
         When Length(input_date) >= 9 Then;
           /* input format ddddddddd */
           If input_date >= 2000000 Then;
             Do;
               input_date = Jday2G(input_date);
               If Substr(input_date,1,7) = "UNKNOWN" Then;
                 Signal Error_INVALID_DATE;
             End;
           Else;
             Signal Error_INVALID_DATE;
         Otherwise;
           Signal Error_INVALID_DATE;
       End;
     End;

   /* Mainline */

   If input_date = "" Then;
     Do;
       base_day = Date("B");
       days_this_century = Date("C");
       days_this_year = Date("D");
       european_date = Date("E");
       julian_date = Date("J");
       normal_date = Date("N");
       ordered_date = Date("O");
       sorted_date = Date("S");
       usa_date = Date("U");
     End;
   Else;
     Do;
       base_day = Date("B",input_date,"S");
       days_this_century = "N/A";
       days_this_year = Date("D",input_date,"S");
       european_date = Date("E",input_date,"S");
       julian_date = Substr(input_date,3,2) ,
            || Right(days_this_year,3,0);
       normal_date = Date("N",input_date,"S");
       ordered_date = Date("O",input_date,"S");
       usa_date = Date("U",input_date,"S");
     End;

   civil_time = Time("C");
   standard_time = Time("N");
   Parse Var standard_time tmp_hh ":" tmp_mm ":" tmp_ss;

   lilian_day = 0;
   If base_day > 577734 Then;
     lilian_day = base_day - 577734;
   ansi_day = 0;
   If base_day > 584387 Then;
     ansi_day = base_day - 584387;
   unix_day = 0;
   If lilian_day > 141428 Then;
     unix_day = lilian_day - 141428;

   days_in_year = 365;
   sorted_year = Substr(sorted_date,1,4);
   If Substr(sorted_year,3,2) = "00" Then;
     Do;
       /*check for leap century*/
       If (sorted_year // 400) = 0 Then;
         days_in_year = 366;
     End;
   Else;
     /*check for leap year*/
     If (sorted_year // 4) = 0 Then;
       days_in_year = 366;
   days_left_in_year = days_in_year - days_this_year;

   dayofwk = base_day // 7 + 1; /*Mon-Sun 1-7*/

   easter_date = Easter(sorted_year);

   Say "User(s) input:" input_date;
   Say "  Rexx DATE function results";
   Say "    Base day:         " base_day;
   Say "    Days this century:" days_this_century;
   Say "    Days this year:   " days_this_year;
   Say "    European date:    " european_date;
   Say "    Julian date:      " julian_date;
   Say "    Normal date:      " normal_date;
   Say "    Ordered date:     " ordered_date;
   Say "    Sorted date:      " sorted_date;
   Say "    USA date:         " usa_date;
   Say " ";
   Say "  Rexx TIME function results";
   Say "    Civil time:   " civil_time;
   Say "    Standard time:" standard_time;
   Say " ";
   Say "  Computed values";
   Say "    Julian day (astronomy):" G2jday(sorted_date);
   n = 0;
   If lilian_day > 0 Then;
     n = (lilian_day*86400)+(tmp_hh*3600)+(tmp_mm*60)+tmp_ss;
   Say "    Lilian day (15821015): " lilian_day " " Right(n,12);
   n = 0;
   If ansi_day > 0 Then;
     n = (ansi_day*86400)+(tmp_hh*3600)+(tmp_mm*60)+tmp_ss;
   Say "    ANSI day (16010101):   " ansi_day " " Right(n,12);
   n = 0;
   If unix_day > 0 Then;
     n = (unix_day*86400)+(tmp_hh*3600)+(tmp_mm*60)+tmp_ss;
   Say "    UNIX day (19700101):   " unix_day " " Right(n,12);
   Say "    days left in year:     " days_left_in_year;
   Say "    day of week:           " dayofwk tod.dayofwk "  (Mon:Sun)";
   Say "    Easter 1583 thru 4099: " easter_date;
   Say " ";
   Say "    Gregorian date:" sorted_date ,
       " Julian date:   " G2J(sorted_date);
   Say "    Julian date:   " sorted_year||Right(days_this_year,3,"0") ,
       "  Gregorian date:" J2G(sorted_year||days_this_year);
   a = G2Jday(sorted_date);
   Say "    Gregorian date:" sorted_date ,
       " Julian day:    " a;
   b = Jday2G(a);
   Say "    Julian day:    " a ,
       "  Gregorian date:" b;
   Say "    DOW:           " Dow(sorted_date) "  (Sun:Sat)";

/*
   Mardi Gras (Carnival) season is prior to Ash Wednesday.
   Fat Tuesday is the final day of Mardi Gras.
   Lent starting on Ash Wednesday is a 40 day period (not counting
   Sundays) or 46 day period (counting Sundays), prior to Easter.
   Palm Sunday is 7 days prior to Easter and starts Holy Week.
   Maundy (Holy) Thursday is 3 days prior to Easter and is the
   day of the Last Supper.
   Good Friday is 2 days prior to Easter and is the day of
   crucifixion.
   Easter Sunday is the day of Resurrection.
   Easter Monday is 1 day following Easter.
   The Ascension of Christ is 39 days after Easter.
   The Pentecost/Whitsunday is 49 days after Easter.
   The day of Corpus Christi/Holy Eucharist is 60 days after Easter.
*/

   Say " ";
   a = Eastera(sorted_year);

   Say "    Easter 1901 thru 2099: " a;

   If sorted_year >= 1582 & sorted_year <= 4099 Then;
     b = G2J(easter_date);

   Say "      Fat Tuesday:         " J2G(b-47);
   Say "      Ash Wednesday:       " J2G(b-46);
   Say "      Palm Sunday:         " J2G(b-7);
   Say "      Last Supper/Holy Thu:" J2G(b-3);
   Say "      Good Friday:         " J2G(b-2);
   Say "      Easter Sunday:       " J2G(b);
   Say "      Easter Monday:       " J2G(b+1);
   Say "      Ascension:           " J2G(b+39);
   Say "      Pentecost:           " J2G(b+49);
   Say "      Corpus Christi:      " J2G(b+60);

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Jdate2G: Procedure

/* REXX function
   Invoke as:  Jdate2G(yyyyddd)
   Convert Julian date (day of year) to Gregorian date.
   The old mundane grind it out way.
   Input format: yyyyddd  Output format: yyyymmdd.

   ------------------------------------------------------- */

   Arg jdate . ;              /* i.e. 2016001 */

   If Datatype(jdate,"W") Then;
     Do;
       If Substr(jdate,1,4) > 1582 Then;
         Nop;
       Else;
         Return ("UNKNOWN - Julian day-of-year");
       If Substr(jdate,5,3) > 0 ,
            & Substr(jdate,5,3) < 367 Then;
         Nop;
       Else;
         Return ("UNKNOWN - Julian day-of-year");
     End;
   Else;
       Return ("UNKNOWN - Julian day-of-year");

   aggr_days.1  =  31; aggr_days.2  =  59; aggr_days.3  =  90;
   aggr_days.4  = 120; aggr_days.5  = 151; aggr_days.6  = 181;
   aggr_days.7  = 212; aggr_days.8  = 243; aggr_days.9  = 273;
   aggr_days.10 = 304; aggr_days.11 = 334; aggr_days.12 = 365;

   leap_day = 0;
   ccyy = Substr(jdate,1,4);   /*extract ccyy*/
   yy   = Substr(jdate,3,2);   /*extract yy*/
   ddd  = Substr(jdate,5,3);   /*extract ddd*/

   If yy = 0 Then;
     leap_year = ccyy // 400; /*remainder 0 then leap yr*/
   Else;
     leap_year = ccyy // 4;   /*remainder 0 then leap yr*/

   Do i=1 To 12 By +1;
     If i > 1 & leap_year = 0 Then;
       leap_day = 1;          /*yes leap yr & past JAN*/
     If ddd > (aggr_days.i + leap_day) Then;
       Iterate;
     mm = i;
     If i > 1 Then;
       Do;
         j = i - 1;
         If j > 1 Then;
           dd = ddd - (aggr_days.j + leap_day);
         Else;
           dd = ddd - aggr_days.j;
       End;
     Else;
       dd = ddd;
     Leave;
   End;

   gregorian = (Right(ccyy,4,0) || ,
        Right(mm,2,0) || Right(dd,2,0));

   Return (gregorian);

/* ********** */

   G2Jday: Procedure

/* REXX function
   Invoke as:  G2Jday(yyyymmdd)
   Convert Gregorian date to Julian day.
   Where Julian day number is the count of days from 0 being
   noon Universal time on Monday, Jan 1, 4713 BCE.  This is a
   date where 3 multi-year cycles started (Indiction (15),
   Metonic (19), Solar (28)).  The Julian Period is a 7980 year
   interval.  Year 1 was 4713 BCE.  It has been used by historians
   since its introduction in 1583.

   Start by computing the number of years since 4713 BCE.  So, to
   get to 0 CE is 4713 years, and 0 CE to 2010 is another 2010
   years. 0 CE itself is a year.
     6724 = 4713+2010+1
   Count the number of leap years.  Before 1582, every forth year
   was a leap year.  After 1582, years that fell on century
   boundrys are omitted unless they are evenly divisible by 400.
   Multiply the number of non-leap years by 365 and leap years by
   366.  Add the two totals together and subtract 10 days for the
   calendar changeover.  Count the number of days between Jan 1 and
   your current day of year.  Count the number of seconds since
   noon.  If your time is between midnight and noon, you want the
   number of seconds since yesterday noon.  Divide the number of
   seconds by 86400 (nbr of sec in a day).  Add this to your day
   total for your fully converted Julian day.

   jday = (1461*(yr+4800+(mo-14)/12))/4+(367*(mo-2-12* ,
        ((mo-14)/12)))/12-(3*((yr+4900+(mo-14)/12)/100))/4+da-32075;

   This number is used in astronomy exclusively.
   Input format: yyyymmdd  Output format: ddddddd.

   ------------------------------------------------------- */

   Arg gdate . ;              /* i.e. 20160101 */

   Parse VAR gdate yr 5 mo 7 da . ;

   If Datatype(gdate,"W") Then;
     Select;
       When (yr = 1582) & (mo > 9 & mo < 13) & (da > 14 & da < 32) Then;
         Nop;
       When (yr > 1582) & (mo > 0 & mo < 13) & (da > 0 & da < 32) Then;
         Nop;
       Otherwise;
         Return ("UNKNOWN - Gregorian date");
     End;
   Else;
       Return ("UNKNOWN - Gregorian date");

   k = (mo-14)%12;
   a = 1461*(yr+4800+k)%4;
   b = 367*(mo-2-12*k)%12;
   c = 3*((yr+4900+k)%100)%4;
   jday = a+b-c+da-32075;

   Return jday;

/* ********** */

   Jday2G: Procedure

/* REXX function
   Invoke as:  Jday2G(ddddddddd)
   Convert Julian day to Gregorian date.
   Where Julian day is the number of days since Jan 1, 4713 BCE
   (Egyptian calendar).  This number is used in astronomy exclusively.
   Input format: ddddddddd  Output format: yyyymmdd.

   ------------------------------------------------------- */

   Arg jday . ;               /* i.e. 2000001 */

   If Datatype(jday,"W") Then;
     Select;
       When (jday > 2000000) Then;
         /* 18 Sep 763 */
         Nop;
       Otherwise;
         Return ("UNKNOWN - Julian day");
     End;
   Else;
       Return ("UNKNOWN - Julian day");

   l = jday+68569;
   n = 4*l%146097;
   l = l-((146097*n+3)%4);
   j = (4000*(l+1)%1461001);
   l = l+31-j*1461%4;
   m = 80*l%2447;
   t = l-(2447*m%80);
   l = m%11;
   m = m+2-12*l;
   j = j+100*(n-49)+l;
   j = Right(j,4,"0");
   m = Right(m,2,"0");
   t = Right(t,2,"0");

   Return j||m||t;

/* ********** */

   EASTERA: Procedure

/* REXX function
   Invoke as:  EASTERA(yyyy)
   Algorithm to determine Easter for years 1901 thru 2099.
   Algorithm developed by T. O'Beirne (1965)
   Input format: yyyy  Output format: yyyymmdd

   ------------------------------------------------------- */

   Arg yr . ;                 /* i.e. 1901:2099 */

   If Datatype(yr,"W") Then;
     Select;
       When yr > 1900 & yr < 2100 Then;
         Nop;
       Otherwise;
         Return ("UNKNOWN - year");
     End;
   Else;
       Return ("UNKNOWN - year");

   n = yr-1900;
   a = n//19;
   b = (7*a+1)%19;
   m = (11*a+4-b)//29;
   q = n%4;
   w = (n+q+31-m)//7;
   p = 25-m-w;

   doy = p+90;
   If (yr//4 = 0 & yr//100 <> 0) | yr//400 = 0 Then;
     doy = p+91;

   Return J2G(yr||doy);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   Say "Purpose: Display information about a specific date.";
   Say " Format: DATES < yyyymmdd | yyyyddd | 0cyyddd | yyddd | ddddddddd >";
   Exit;

   Error_INVALID_DATE:

   Say "Invalid date ("parm2")";
   Return (-16);
./ ADD NAME=DDSCAN   0105-99022-16051-1734-00073-00063-00000-APLKS   08
/* REXX - DDSCAN : Scan a selected DDNAME in JCL for a member         */
/**********************************************************************/
/* Written - A.J.Gray - 22/01/1999                                    */
/*         - A.J.Gray - 09/08/2002 - added to CBT                     */
/**********************************************************************/
/* Invoke with "DDSCAN memname" on the command line and then place    */
/* the cursor on the DDNAME to be searched.                           */
/*                                                                    */
/* This exec does the easy bit by extracting the dataset names and    */
/* allocating to ddname DDSCAN before handing over to the ISRFIND     */
/* utility for the 'legwork'.                                         */
/**********************************************************************/
/* The Following test that this is a valid ISREDIT environment.       */
/**********************************************************************/
options = ''                           /*                             */
Address ISPEXEC                        /*                             */
"ISREDIT Macro (scan)"                 /* Test ISREDIT                */
mrc = rc                               /*                             */
zerralrm = 'NO'                        /* set message alarm to no     */
zerrhm   = 'ISR00003'                  /* set help screen to default  */
x = Msg(off)                           /*  disable messages           */
x = Prompt(off)                        /*  disable prompting          */
If (mrc > 0) Then                      /* test if edit environment    */
 Do                                    /*                             */
  ZedSmsg = 'Edit Macro Only'          /*                             */
  ZedLmsg = '"DDSCAN" can only be run as an edit macro' /*            */
  "SetMsg Msg(ISRZ001)"                /*                             */
  Signal FINISH                        /*                             */
 End                                   /*                             */
/**********************************************************************/
"IsrEdit (dsname) = Dataset"           /* get dataset name            */
"IsrEdit (memname) = Member"           /* get member name             */
"IsrEdit (top,bot) = Display_Lines"    /* get number of lines in dsn  */
"IsrEdit (Row,Col) = Cursor"           /* Get location of cursor      */
/**********************************************************************/
/* Allocate and read member being edited                              */
Address TSO "Alloc Fi(MEMIN) Da('"dsname"("memname")') Shr Reu"
Address TSO "ExecIO * DiskR MEMIN (Finis Stem line.)"
Address TSO "Free Fi(MEMIN)"
/**********************************************************************/
dcnt = 0                               /* set dataset counter         */
dsnlist = ""                           /* initialise dsnlist          */
Do loop = row to line.0                /* roop thru member lines      */
 If (Substr(line.loop,1,3) /= '//*') &, /*                            */
    (Substr(line.loop,1,3) /= '// ') &, /*                            */
    (loop > row) Then                  /*                             */
  Leave                                /*                             */
 If (Substr(line.loop,1,3) = '//*') Then /*                           */
  Iterate                              /*                             */
 dpos = Index(line.loop,"DSN=")        /*                             */
 If (dpos > 0) Then                    /*                             */
  Do                                   /*                             */
   line = Substr(line.loop,dpos+4)     /*                             */
   line = Translate(line,'',''',:;/)') /*                             */
   Parse Upper Var line dsn .          /*                             */
   If (Sysdsn("'"dsn"'") <> 'OK') Then /*                             */
    Say "'"dsn"' not in catalog, not scanning." /*                    */
   Else                                /*                             */
    Do                                 /*                             */
     dcnt = dcnt + 1                   /*                             */
     dsn.dcnt = dsn                    /*                             */
     dsnlist = dsnlist||" '"||dsn||"'" /*                             */
    End                                /*                             */
  End                                  /*                             */
End                                    /*                             */
/**********************************************************************/
Address TSO                            /*                             */
"Alloc Fi(DDSCAN) Da("dsnlist") SHR REU" /*                           */
"ISRFIND DD(DDSCAN) M("scan") ISPF"    /*                             */
"Free Fi(DDSCAN)"                      /*                             */
/**********************************************************************/
FINISH:                                /*                             */
Exit 0                                 /* Exit exec                   */
./ ADD NAME=DEBUGOFF 0103-14134-14329-1057-00014-00013-00000-APLKS   49
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Establish DEBUG mode for all REXX execs          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";

   Address ISPEXEC;

   debug = "NULL ";
   "VPUT (DEBUG) PROFILE";
   ZEDSMSG = "DEBUG OFF";
   ZEDLMSG = "DEBUG MODE IS SET OFF";
   "SETMSG MSG(ISRZ000)";
   Return (RC);
./ ADD NAME=DEBUGON  0103-14134-14329-1058-00014-00013-00000-APLKS   02
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Establish DEBUG mode for all REXX execs          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";

   Address ISPEXEC;

   debug = "DEBUG";
   "VPUT (DEBUG) PROFILE";
   ZEDSMSG = "DEBUG ON";
   ZEDLMSG = "DEBUG MODE IS SET ON";
   "SETMSG MSG(ISRZ000)";
   Return (RC);
./ ADD NAME=DEC2BIN  0112-19255-19270-1426-00040-00224-00000-APLKS   40
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Convert base(10) number to a base(2) number
   Invoke as: base_2 = DEC2BIN(base_10);
          or: TSO DEC2BIN base_10
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_2 = "error composition";

   ARG base_10;

   tgt_base = 2;

   If Datatype(base_10,"W") Then;
     quotient = base_10;
   Else;
     Signal The_End;

   base_2 = "";

   Do While quotient > 0;
     remainder = quotient//tgt_base;
     quotient = quotient%tgt_base;
     base_2 = remainder||base_2;
   End;

   r = Length(base_2)//4;
   If r > 0 Then;
     base_2 = Copies("0",4-r)||base_2;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_2;

   Say "Binary value =" base_2;
   Return (0);
./ ADD NAME=DEC2B32  0116-19259-19289-1330-00052-00035-00000-APLKS   08
/* REXX 2019-10-16 */
/* REXX function or TSO command
   Convert base(10) number to a base(32) number
   Invoke as: base_32 = DEC2B32(base_10);
          or: TSO DEC2B32 base_10

   IBM LE uses base_32 to generate the labels for error messages.
   So, if you create message 101 the generated label will contain
   035.
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_32 = "error composition";

   ARG base_10;

   tgt_base = 32;
/*                             1 1 1 1 1 1 1 1 1 1 2 2 2
             1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2  */
   vector = "A B C D E F G H I J K L M N O P Q R S T U V ";

   If Datatype(base_10,"W") Then;
     quotient = base_10;
   Else;
     Signal The_End;

   base_32 = "";

   Do While quotient > 0;
     remainder = quotient//tgt_base;
     If remainder > 9 Then;
       Do;
         r = remainder - 9;
         remainder = Word(vector,r);
       End;
     quotient = quotient%tgt_base;
     base_32 = remainder||base_32;
   End;

   r = Length(base_32)//4;
   If r > 0 Then;
     base_32 = Copies("0",4-r)||base_32;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_32;

   Say "Base 32 value =" base_32;
   Return (0);
./ ADD NAME=DEC2HEX  0112-19255-19289-1330-00046-00029-00000-APLKS   28
/* REXX 2019-10-16 */
/* REXX function or TSO command
   Convert base(10) number to a base(16) number
   Invoke as: base_16 = DEC2HEX(base_10);
          or: TSO DEC2HEX base_10
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_16 = "error composition";

   ARG base_10;

   tgt_base = 16;
   vector = "A B C D E F ";

   If Datatype(base_10,"W") Then;
     quotient = base_10;
   Else;
     Signal The_End;

   base_16 = "";

   Do While quotient > 0;
     remainder = quotient//tgt_base;
     If remainder > 9 Then;
       Do;
         r = remainder - 9;
         remainder = Word(vector,r);
       End;
     quotient = quotient%tgt_base;
     base_16 = remainder||base_16;
   End;

   r = Length(base_16)//4;
   If r > 0 Then;
     base_16 = Copies("0",4-r)||base_16;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_16;

   Say "Hex value =" base_16;
   Return (0);
./ ADD NAME=DEC2OCT  0109-19255-19270-1427-00040-00029-00000-APLKS   32
/* REXX 2019-09-26 */
/* REXX function or TSO command
   Convert base(10) number to a base(8) number
   Invoke as: base_8 = DEC2OCT(base_10);
          or: TSO DEC2OCT base_10
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_8 = "error composition";

   ARG base_10;

   tgt_base = 8;

   If Datatype(base_10,"W") Then;
     quotient = base_10;
   Else;
     Signal The_End;

   base_8 = "";

   Do While quotient > 0;
     remainder = quotient//tgt_base;
     quotient = quotient%tgt_base;
     base_8 = remainder||base_8;
   End;

   r = Length(base_8)//3;
   If r > 0 Then;
     base_8 = Copies("0",3-r)||base_8;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_8;

   Say "Base 8 value =" base_8;
   Return (0);
./ ADD NAME=DOW      0101-19270-19270-1541-00056-00039-00000-APLKS   39
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Invoke as: dayofweek = DOW(yyyymmdd)
              where 1st word is DOW number, 2nd word is DOW title
          or  TSO DOW yyyymmdd

   Convert Gregorian date to Day-Of-Week.
   The more sophisticated approach.
   Algorithm developed by C. Zeller (1887) modified.
   Input format: yyyymmdd  Output format: dow dowtext.

   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   dayofweek = "error composition";

   Arg gdate;                 /* i.e. 20160101 */

   Parse VAR gdate yr 5 mo 7 da . ;

   If Datatype(gdate,"W") Then;
     Select;
       When (yr = 1582) & (mo > 9 & mo < 13) & (da > 14 & da < 32) Then;
         Nop;
       When (yr > 1582) & (mo > 0 & mo < 13) & (da > 0 & da < 32) Then;
         Nop;
       Otherwise;
         Signal The_End;
     End;
   Else;
     Signal The_End;

   If mo <= 2 Then;
     Do;
       mo = mo+12;
       yr = yr-1;
     End;

   c = yr%100;
   yr = yr//100;
   wt = (da+13*(mo+1)%5+yr+yr%4+c%4-2*c)//7;
   If wt <= 0 Then;
     wt = wt+7;
   wt = wt*1;

   dayofweek = wt Word("Sun Mon Tue Wed Thu Fri Sat",wt);

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return dayofweek;

   Say "Day of the week =" dayofweek;
   Return (0);
./ ADD NAME=DPSCB    0108-17038-17046-1412-00135-00029-00000-APLKS   00
/* REXX 2017-02-14 */
/* --------------------------------------------------------- */
/* Purpose: Invoke program LPSCB to display TSO Protected    */
/*          Step Control Block (PSCB)                        */
/*                                                           */
/*  Format: DPSCB  ( options                                 */
/*                                                           */
/*         options: (default) SCREEN                         */
/*                  LINE|SCREEN presentation option          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC DPSCB    */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var = "";
   opt. = "";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1;

   /* Mainline */

   ec = Outtrap(lne.);
   "LPSCB ALL";
   ec = Outtrap("OFF");

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do i=1 To lne.0 By +1;
         Say lne.i;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(1)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD (STEM LNE. FINIS)"
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) Then;
         opt.1 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display TSO Protected Step Control Block (PSCB).",
        pad hex04,
        " Format: DPSCB  ( SCREEN|LINE ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=DSAT     0106-17046-18269-0856-00128-00128-00000-APLKS   28
/* REXX 2017-02-15 */
/* --------------------------------------------------------- */
/* Purpose: Invoke TSO program DSAT to display               */
/*          data set attributes.                             */
/*                                                           */
/*  Format: %DSAT dsname|dsnlevel ( options                  */
/*                                                           */
/*         options: (default)                                */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC %DSAT    */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var = "";
   opt. = "";

   /* Parse User Passed Parms */

/* Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1; */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     Do;
       dataset_name = Strip(parm2,"B");
       dataset_name = Strip(dataset_name,"B","'");
     End;
   Else;
     Return (-12);

   /* Mainline */

   "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
   " LRECL(189) BLKSIZE(0)",
   " UNIT(SYSDA) TRACKS SPACE(1)",
   " NEW DELETE REUSE";
   If RC <> 0 Then;
     Signal Error_ALLOC_TGTSEQ;

   "DSAT" dataset_name "FULL SEQNO HARDCOPY(OUTDD)";

   Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
   Address ISPEXEC "VIEW DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) Then;
         opt.1 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display data set attributes.",
        pad hex04,
        " Format: %DSAT dsname|dsnlevel ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=DSINFO   0114-18236-18255-1620-00807-00329-00000-APLKS   19
/* REXX 2018-09-13 */
/* --------------------------------------------------------- */
/* Purpose: Invoke ISPF DSINFO to display all of the known   */
/*          information about a data set.                    */
/*                                                           */
/*  Format: DSINFO  dataset_name ( options                   */
/*                                                           */
/*    dataset_name: is the name of the dataset to DSINFO     */
/*         options: (default) SCREEN NODSCB                  */
/*                                                           */
/*                  LINE|SCREEN presentation option          */
/*                  DSCB|NODSCB                              */
/*                  volid                                    */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC DSINFO */

   Address TSO "PROFILE NOPREFIX";
   Address ISPEXEC;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   str = "";
   opt. = "";       /* .1=LINE|SCREEN .2=DSCB|NODSCB .3=volid */
   count = 0;
   line = "";

   /*title of day table*/
   tod.0 = 7;
   tod.1 = "Mon";
   tod.2 = "Tue";
   tod.3 = "Wed";
   tod.4 = "Thu";
   tod.5 = "Fri";
   tod.6 = "Sat";
   tod.7 = "Sun";

   /*bit settings*/
   bitC0 = "C0"x;
   bit80 = "80"x;
   bit40 = "40"x;
   bit20 = "20"x;
   bit10 = "10"x;
   bit08 = "08"x;
   bit04 = "04"x;
   bit02 = "02"x;
   bit01 = "01"x;

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   If opt.2 = "" Then;
     opt.2 = "NODS";     /*nodscb*/

   If opt.3 = "" Then;
     opt.0 = 2;          /*no volid*/
   Else;
     opt.0 = 3;          /*yes volid*/

   If parm2 <> "" Then;
     Do;
       dataset_name = Strip(parm2,"B");
       dataset_name = Strip(dataset_name,"B","'");
     End;
   Else;
     Return (-12);

   /* Retrieve all of the dataset information */

   arg_string = "'"dataset_name"'";

   "DSINFO DATASET("arg_string")" opt.3;
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DSINFO;

   If opt.1 = "SAY" Then;
     Signal BYPASS;

   pad = Copies(" ",4);
   Address TSO "MAKEBUF";
   Queue "DSNAME: "dataset_name;
   If ZDSCJOBN <> "" Then;
     Queue pad "Created by:" ZDSCJOBN ZDSCSTPN;

   Parse Value ZDSCDATE With yr "/" mo "/" da;
   sorted_date = yr||mo||da;
   dayofyr = Right(Date("D",sorted_date,"S"),3,0);
   dayofwk = Date("B",sorted_date,"S") // 7 + 1; /*Mon-Sun 1-7*/
   normal_date = Date("N",sorted_date,"S");
   Queue pad "Create date -" yr||"/"||dayofyr sorted_date,
        tod.dayofwk normal_date;

   If ZDSRDATE <> "***None***" Then;
     Do;
       Parse Value ZDSRDATE With yr "/" mo "/" da;
       sorted_date = yr||mo||da;
       dayofyr = Right(Date("D",sorted_date,"S"),3,0);
       dayofwk = Date("B",sorted_date,"S") // 7 + 1; /*Mon-Sun 1-7*/
       normal_date = Date("N",sorted_date,"S");
       Queue pad "Last reference date -" yr||"/"||dayofyr sorted_date,
            tod.dayofwk normal_date;
     End;
   Else;
     Queue pad "Last reference date -" ZDSRDATE;

   If ZDSXDATE <> "***None***" Then;
     Do;
       Parse Value ZDSXDATE With yr "/" mo "/" da;
       sorted_date = yr||mo||da;
       dayofyr = Right(Date("D",sorted_date,"S"),3,0);
       dayofwk = Date("B",sorted_date,"S") // 7 + 1; /*Mon-Sun 1-7*/
       normal_date = Date("N",sorted_date,"S");
       Queue pad "Expiration date -" yr||"/"||dayofyr sorted_date,
            tod.dayofwk normal_date;
     End;
   Else;
     Queue pad "Expiration date -" ZDSXDATE;

   Queue pad "APF status -" ZDSAPF;
   Queue pad "LNKLST status -" ZDSLNK;
   Queue pad "Compressible -" ZDSSEQ;
   Queue pad "Extended Attributes -" ZDSEATR;
   Queue pad "DATA CLASS -" ZDSDC;
   Queue pad "STORAGE CLASS -" ZDSSC;
   Queue pad "MANAGEMENT CLASS -" ZDSMC;

   Queue pad;
   Queue "Common DCB Info:";
   Queue pad "DSORG -" Strip(ZDSORG) " SMS DSNTYPE -" Strip(ZDSDSNT);
   Queue pad "RECFM -" Strip(ZDSRF) " BLKSIZE -" Strip(ZDSBLK),
        " LRECL -" Strip(ZDSLREC);

   Queue pad;
   Queue "DASD Info:";
   Queue pad Strip(ZDSSPC) "(" || Strip(ZDS1EX) || ",",
        || Strip(ZDS2EX) || ")";
   If ZDSOVF = "YES" Then;
     Queue pad "Total Allocated -" Strip(ZDSTOTAX),
          " Used -" Strip(ZDSTOTUX);
   Else;
     Queue pad "Total Allocated -" Strip(ZDSTOTA),
          " Used -" Strip(ZDSTOTU);
   Queue pad "Extents Allocated -" Strip(ZDSEXTA),
        " Used -" Strip(ZDSEXTU);

   Queue pad
   Queue "Tape & DASD Info:";
   vol_list = "";
   j = 1;
   Do i=1 To ZDS#VOLS By +1;
     vol_list = vol_list Substr(ZDSVTAB,j,6);
     j = j+6;
   End;
   If vol_list = "" Then;
     vol_list = ZDSVOL;
   Queue pad "UNIT -" Strip(ZDSDEVT) "VOLUME count -" Strip(ZDS#VOLS);
   Queue pad "VOLUME -" Strip(vol_list);

   If Strip(ZDSORG) = "PO" Then;
     Do;
       Queue pad;
       Queue "PDS/PDSE Info:";
       If Strip(ZDSDSNT) = "PDS" Then;
         Do;
           Queue pad "Directory blocks allocated -" Strip(ZDSDIRA);
           Queue pad "Directory blocks used -" Strip(ZDSDIRU);
         End;
       Else;
         Do;
           If ZDSDSNV = "ZDSDSNV" Then;
             Nop;
           Else;
             Queue pad "PDSE Version -" Strip(ZDSDSNV);
           Queue pad "Directory blocks allocated -" Strip(ZDSDIR);
           Queue pad "4k pages used -" Strip(ZDSPAGU);
           Queue pad "% used -" Strip(ZDSPERU);
         End;
       Queue pad "Number of members -" Strip(ZDS#MEM);
     End;

   If opt.2 = "DSCB" Then;
     Call Extract_DSCB;

   Address TSO "QELEM";
   count = RC;

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do count;
         Pull line;
         Say line;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         Address TSO "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
              " LRECL(80) BLKSIZE(0)",
              " UNIT(SYSDA) TRACKS SPACE(5)",
              " NEW DELETE REUSE";
         EC = RC;
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         Address TSO "EXECIO * DISKW OUTDD ( FINIS )"
         EC = RC;
         If RC = 0 Then;
           Do;
             "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             "VIEW DATAID("tgtid")";
             "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   Address TSO "FREE DDNAME(OUTDD)";
   Address TSO "DROPBUF";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 str parm3;
     Select;
       When Abbrev("LINE",str,3) |,
            Abbrev("SCREEN",str,3) Then;
         opt.1 = Substr(str,1,3);
       When str = "SAY" Then;
         opt.1 = "SAY";
       When Abbrev("DSCB",str,4) |,
            Abbrev("NODSCB",str,4) Then;
         opt.2 = Substr(str,1,4);
       When Length(str) = 6 Then;
         opt.3 = "VOLUME("str")";
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   Extract_DSCB:

   /* DSCB Format 1: SYS1.MODGEN(IECSDSL1) */

   Parse VAR ZDSCB1 ds1fmtid 2 ds1dssn 8 ds1volsq 10 ds1credt,
        13 ds1expdt 16 ds1noepv 17 ds1nobdb 18 ds1flag1,
        19 ds1syscd 32 ds1refd 35 ds1smsfg 36 ds1scxtf,
        37 ds1scxtv 39 ds1dsorg 41 ds1recfm 42 ds1optcd,
        43 ds1blkl 45 ds1lrecl 47 ds1keyl 48 ds1rkp,
        50 ds1dsind 51 ds1scal1 52 ds1scal3 55 ds1lstar,
        58 ds1trbal 60 ds1ttthi 61 ds1ext 71 ds1ext2,
        81 ds1ext3 91 ds1ptrds 96 . ;

   Queue pad;
   Queue "DSCB format 1: layout SYS1.MODGEN(IECSDSL1)"
   Queue pad "Pos(01,01) DS1FMTID -" ds1fmtid;
   Queue pad "Pos(02,06) DS1DSSN  -" ds1dssn;
   Queue pad "Pos(08,02) DS1VOLSQ -" C2D(ds1volsq);
   If ds1credt > "" Then;
     Do;
       yr = C2D(Substr(ds1credt,1,1));
       cc = 19 + Substr(yr,1,1);
       yr = Substr(yr,2,2);
       da = C2D(Substr(ds1credt,2,2));
     End;
   Else;
     Do;
       cc = 00; yr = 00; da = 000;
     End;
   Queue pad "Pos(10,03) DS1CREDT - x'" || C2X(ds1credt) || "'",
        cc||yr||"/"da;
   If ds1expdt > "" Then;
     Do;
       yr = C2D(Substr(ds1expdt,1,1));
       cc = 19 + Substr(yr,1,1);
       yr = Substr(yr,2,2);
       da = C2D(Substr(ds1expdt,2,2));
     End;
   Else;
     Do;
       cc = 00; yr = 00; da = 000;
     End;
   Queue pad "Pos(13,03) DS1EXPDT - x'" || C2X(ds1expdt) || "'",
        cc||yr||"/"||da;
   Queue pad "Pos(16,01) DS1NOEPV -" C2D(ds1noepv);
   Queue pad "Pos(17,01) DS1NOBDB -" C2D(ds1nobdb);

   flags = "";
   bitflg = BitAnd(bit80,ds1flag1);
   If bitflg = bit80 Then;
     flags = flags "EF comp";
   bitflg = BitAnd(bit01,ds1flag1);
   If bitflg = bit02 Then;
     flags = flags "EATTR=YES";
   bitflg = BitAnd(bit01,ds1flag1);
   If bitflg = bit01 Then;
     flags = flags "EATTR=NO ";
   flags = Strip(flags);
   Queue pad "Pos(18,01) DS1FLAG1 - x'" || C2X(ds1flag1) || "'" flags;

   Queue pad "Pos(19,13) DS1SYSCD -" ds1syscd;

   If ds1refd > "" Then;
     Do;
       yr = C2D(Substr(ds1refd,1,1));
       cc = 19 + Substr(yr,1,1);
       yr = Substr(yr,2,2);
       da = C2D(Substr(ds1refd,2,2));
     End;
   Else;
     Do;
       cc = 00; yr = 00; da = 000;
     End;
   Queue pad "Pos(32,03) DS1REFD  - x'" || C2X(ds1refd) || "'",
        cc||yr||"/"da;

   flags = "";
   bitflg = BitAnd(bit80,ds1smsfg);
   If bitflg = bit80 Then;
     flags = flags "SMS managed";
   bitflg = BitAnd(bit08,ds1smsfg);
   If bitflg = bit08 Then;
     flags = flags "PDSE";
   bitflg = BitAnd(bit04,ds1smsfg);
   If bitflg = bit04 Then;
     flags = flags "EF";
   bitflg = BitAnd(bit02,ds1smsfg);
   If bitflg = bit02 Then;
     flags = flags "HFS";
   flags = Strip(flags);
   Queue pad "Pos(35,01) DS1SMSFG - x'" || C2X(ds1smsfg) || "'" flags;

   flags = "";
   bitflg = BitAnd(bit80,ds1scxtf);
   If bitflg = bit80 Then;
     flags = flags "Average block";
   bitflg = BitAnd(bit40,ds1scxtf);
   If bitflg = bit40 Then;
     flags = flags "MB";
   bitflg = BitAnd(bit20,ds1scxtf);
   If bitflg = bit20 Then;
     flags = flags "KB";
   bitflg = BitAnd(bit10,ds1scxtf);
   If bitflg = bit10 Then;
     flags = flags "Byte";
   bitflg = BitAnd(bit08,ds1scxtf);
   If bitflg = bit08 Then;
     flags = flags "Compacted x 256"
   bitflg = BitAnd(bit04,ds1scxtf);
   If bitflg = bit04 Then;
     flags = flags "Compacted x 65536";
   flags = Strip(flags);
   Queue pad "Pos(36,01) DS1SCXTF - x'" || C2X(ds1scxtf) || "'" flags;

   Queue pad "Pos(37,02) DS1SCXTV -" C2D(ds1scxtv);

   dsorg = "";
   flags = "";
   bitflg = BitAnd(bit80,Substr(ds1dsorg,1,1));
   If bitflg = bit80 Then;
     Do;
       flags = flags "IS";
       dsorg = "IS";
     End;
   bitflg = BitAnd(bit40,Substr(ds1dsorg,1,1));
   If bitflg = bit40 Then;
     Do;
       flags = flags "PS";
       dsorg = "PS";
     End;
   bitflg = BitAnd(bit20,Substr(ds1dsorg,1,1));
   If bitflg = bit20 Then;
     Do;
       flags = flags "DA";
       dsorg = "DA";
     End;
   bitflg = BitAnd(bit10,Substr(ds1dsorg,1,1));
   If bitflg = bit10 Then;
     flags = flags "CX";
   bitflg = BitAnd(bit02,Substr(ds1dsorg,1,1));
   If bitflg = bit02 Then;
     Do;
       flags = flags "PO"
       dsorg = "PO";
     End;
   bitflg = BitAnd(bit01,Substr(ds1dsorg,1,1));
   If bitflg = bit01 Then;
     flags = flags || "U";
   bitflg = BitAnd(bit80,Substr(ds1dsorg,2,1));
   If bitflg = bit80 Then;
     flags = flags "GS";
   bitflg = BitAnd(bit40,Substr(ds1dsorg,2,1));
   If bitflg = bit40 Then;
     flags = flags "TX";
   bitflg = BitAnd(bit20,Substr(ds1dsorg,2,1));
   If bitflg = bit20 Then;
     flags = flags "TQ";
   bitflg = BitAnd(bit08,Substr(ds1dsorg,2,1));
   If bitflg = bit08 Then;
     Do;
       flags = flags "AM";
       dsorg = "VSAM";
     End;
   bitflg = BitAnd(bit04,Substr(ds1dsorg,2,1));
   If bitflg = bit04 Then;
     flags = flags "TR"
   flags = Strip(flags);
   Queue pad "Pos(39,02) DS1DSORG - x'" || C2X(ds1dsorg) || "'" flags;

   flags = "";
   bitflg = BitAnd(bitC0,ds1recfm);
   Select;
     When bitflg = bitC0 Then;
       flags = flags "U";
     When bitflg = bit80 Then;
       flags = flags "F";
     When bitflg = bit40 Then;
       flags = flags "V";
     Otherwise;
       Nop;
   End;
   bitflg = BitAnd(bit10,ds1recfm);
   If bitflg = bit10 Then;
     flags = flags || "B";
   bitflg = BitAnd(bit08,ds1recfm);
   If bitflg = bit08 Then;
     flags = flags || "S";
   bitflg = BitAnd(bit20,ds1recfm);
   If bitflg = bit20 Then;
     flags = flags || "T";
   bitflg = BitAnd(bit04,ds1recfm);
   If bitflg = bit04 Then;
     flags = flags || "A";
   bitflg = BitAnd(bit02,ds1recfm);
   If bitflg = bit02 Then;
     flags = flags || "M";
   flags = Strip(flags);
   Queue pad "Pos(41,01) DS1RECFM - x'" || C2X(ds1recfm) || "'" flags;

   flags = "";
   bitflg = BitAnd(bit80,ds1optcd);
   If bitflg = bit80 Then;
     Select;
       When dsorg = "IS" Then;
         flags = flags || "W";
       When dsorg = "PS" Then;
         flags = flags || "W";
       When dsorg = "DA" Then;
         flags = flags || "W";
       When dsorg = "PO" Then;
         flags = flags || "W";
       When dsorg = "VSAM" Then;
         flags = flags "CATLG in ICF catalog"
       Otherwise;
         Nop;
     End;
   bitflg = BitAnd(bit40,ds1optcd);
   If bitflg = bit40 Then;
     Select;
       When dsorg = "IS" Then;
         flags = flags || "U";
       When dsorg = "PS" Then;
         flags = flags || "U";
       When dsorg = "PO" Then;
         flags = flags || "U";
       When dsorg = "VSAM" Then;
         flags = flags "ICF catalog"
       Otherwise;
         Nop;
     End;
   bitflg = BitAnd(bit20,ds1optcd);
   If bitflg = bit20 Then;
     Select;
       When dsorg = "IS" Then;
         flags = flags || "M";
       When dsorg = "PS" Then;
         flags = flags || "C";
       When dsorg = "DA" Then;
         flags = flags || "E";
       When dsorg = "PO" Then;
         flags = flags || "C";
       Otherwise;
         Nop;
     End;
   bitflg = BitAnd(bit10,ds1optcd);
   If bitflg = bit10 Then;
     Select;
       When dsorg = "IS" Then;
         flags = flags || "I";
       When dsorg = "PS" Then;
         flags = flags || "H";
       When dsorg = "DA" Then;
         flags = flags || "F";
       When dsorg = "PO" Then;
         flags = flags || "H";
       Otherwise;
         Nop;
     End;
   bitflg = BitAnd(bit08,ds1optcd);
   If bitflg = bit08 Then;
     Select;
       When dsorg = "IS" Then;
         flags = flags || "Y";
       When dsorg = "PS" Then;
         flags = flags || "B";
       When dsorg = "DA" Then;
         flags = flags || "A";
       When dsorg = "PO" Then;
         flags = flags || "B";
       Otherwise;
         Nop;
     End;
   bitflg = BitAnd(bit04,ds1optcd);
   If bitflg = bit04 Then;
     Select;
       When dsorg = "PS" Then;
         flags = flags || "Z";
       When dsorg = "PO" Then;
         flags = flags || "Z";
       Otherwise;
         Nop;
     End;
   bitflg = BitAnd(bit02,ds1optcd);
   If bitflg = bit02 Then;
     Select;
       When dsorg = "IS" Then;
         flags = flags || "L";
       When dsorg = "PS" Then;
         flags = flags || "T";
       When dsorg = "PO" Then;
         flags = flags || "T";
       Otherwise;
         Nop;
     End;
   bitflg = BitAnd(bit01,ds1optcd);
   If bitflg = bit01 Then;
     Select;
       When dsorg = "IS" Then;
         flags = flags "R";
       When dsorg = "PS" Then;
         flags = flags "J";
       When dsorg = "DA" Then;
         flags = flags "R";
       When dsorg = "PO" Then;
         flags = flags "J";
       Otherwise;
         Nop;
     End;
   flags = Strip(flags);
   Queue pad "Pos(42,01) DS1OPTCD - x'" || C2X(ds1optcd) || "'" flags;

   Queue pad "Pos(43,02) DS1BLKL  -" C2D(ds1blkl);
   Queue pad "Pos(45,02) DS1LRECL -" C2D(ds1lrecl);
   Queue pad "Pos(47,01) DS1KEYL  -" C2D(ds1keyl);
   Queue pad "Pos(48,02) DS1RKP   - x'" || C2X(ds1rkp) || "'";

   flags = "";
   bitflg = BitAnd(bit80,ds1dsind);
   If bitflg = bit80 Then;
     flags = flags "last VOL";
   bitflg = BitAnd(bit40,ds1dsind);
   If bitflg = bit40 Then;
     flags = flags "RACF defined";
   bitflg = BitAnd(bit10,ds1dsind);
   If bitflg = bit10 Then;
     flags = flags "password required";
   bitflg = BitAnd(bit08,ds1dsind);
   If bitflg = bit08 Then;
     flags = flags "MOD since RECALL";
   bitflg = BitAnd(bit01,ds1dsind);
   If bitflg = bit01 Then;
     flags = flags "CHECKPOINT";
   flags = Strip(flags);
   Queue pad "Pos(50,01) DS1DSIND - x'" || C2X(ds1dsind) || "'" flags;

   flags = "";
   bitflg = BitAnd(bitC0,ds1scal1);
   Select;
     When bitflg = bitC0 Then;
       flags = flags "CYLINDER";
     When bitflg = bit80 Then;
       flags = flags "TRACKS";
     When bitflg = bit40 Then;
       flags = flags "block"
     Otherwise;
       Nop;
   End;
   bitflg = BitAnd(bit10,ds1scal1);
   If bitflg = bit10 Then;
     flags = flags "extention to SEC SPACE";
   bitflg = BitAnd(bit08,ds1scal1);
   If bitflg = bit08 Then;
     flags = flags "CONTIG";
   bitflg = BitAnd(bit04,ds1scal1);
   If bitflg = bit04 Then;
     flags = flags "MXIG";
   bitflg = BitAnd(bit02,ds1scal1);
   If bitflg = bit02 Then;
     flags = flags "ALX";
   bitflg = BitAnd(bit01,ds1scal1);
   If bitflg = bit01 Then;
     flags = flags "ROUND";
   flags = Strip(flags);
   Queue pad "Pos(51,01) DS1SCAL1 - x'" || C2X(ds1scal1) || "'" flags;

   Queue pad "Pos(52,03) DS1SCAL3 -" C2D(ds1scal3);
   Queue pad "Pos(55,03) DS1LSTAR - x'" || C2X(ds1lstar) || "'";
   Queue pad "Pos(58,02) DS1TRBAL - x'" || C2X(ds1trbal) || "'";
   Queue pad "Pos(60,01) DS1TTTHI - x'" || C2X(ds1ttthi) || "'";
   Queue pad "Pos(61,10) DS1EXT   - x'" || C2X(ds1ext) || "'";
   Queue pad "Pos(71,10) DS1EXT2  - x'" || C2X(ds1ext2) || "'";
   Queue pad "Pos(81,10) DS1EXT3  - x'" || C2X(ds1ext3) || "'";
   Queue pad "Pos(91,05) DS1PTRDS - x'" || C2X(ds1ptrds) || "'";

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display all of the known information",
        pad hex04,
        "         about a dataset.",
        pad hex04,
        " Format: DSINFO dsname ( <LINE> <DSCB> <volid>";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   "SETMSG MSG(ISRZ002)";
   Exit;

   Error_DSINFO:

   ZEDSMSG = "DSINFO FAILED";
   ZEDLMSG = "ISPF service DSINFO failed, RC=" EC;
   If EC = 8 Then;
     Say ZERRLM;
   "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" EC;
   "SETMSG MSG(ISRZ000)";
   Address TSO "FREE DDNAME(OUTDD)";
   Address TSO "DROPBUF";
   Return (-16);

   BYPASS:

/* ISPF service DSINFO
   ISPF Option 3.2 or Option 3.4

   ISPEXEC DSINFO DATASET(dsname) [VOLUME(volid)]
   RC 0-normal; 8-request unavailable info (refer to Dialog
   error variables ZERRLM... for more info); 12-FAMS error,
   Obtain error, Error obtaining directory info; 20-severe

   doesn't work for BDAM data sets
*/

/* ZDSCJOBN create jobname (8,C) */
   Say "create jobname -" ZDSCJOBN;
/* ZDSCSTPN create stepname (8,C) */
   Say "create stepname -" ZDSCSTPN;
/* ZDSCDATE creation date (national format) (10,C) */
   Say "create date -" ZDSCDATE;
/* ZDSRDATE referenced date (national format (10,C) */
   Say "reference date -" ZDSRDATE;
/* ZDSXDATE expiration date (national format) (10,C) */
   Say "expiration date -" ZDSXDATE;
/* ZDSAPF APF status of data set YES|NO|ERR (4,C) */
   Say "APF status -" ZDSAPF;
/* ZDSLNK LNKLST status of data set YES|NO|ERR (4,C) */
   Say "LNKLST status -" ZDSLNK;
/* ZDSSEQ compressible YES|NO (4,C) */
   Say "compressible -" ZDSSEQ;
/* ZDSEATR extended attribute indicator (4,C) */
   Say "extended attribute indicator -" ZDSEATR;
/* ZDSDC data class (8,C) */
   Say "data class -" ZDSDC;
/* ZDSMC management class (8,C) */
   Say "management class -" ZDSMC;
/* ZDSSC storage class (8,C) */
   Say "storage class -" ZDSSC;
/* ZDSORG data set organization (8,C) */
   Say "data set organization -" ZDSORG;
/* ZDSDSNT data set name type (8,C) */
   Say "data set name type -" ZDSDSNT;
/* ZDSRF record format (6,C) */
   Say "record format -" ZDSRF;
/* ZDSBLK block size (6,C) */
   Say "block size -" Strip(ZDSBLK);
/* ZDSLREC logical record length (7,C) */
   Say "logical record length -" Strip(ZDSLREC);
/* ZDSDEVT device type (8,C) */
   Say "device type -" ZDSDEVT;
/* ZDS#VOLS nbr of volumes (2,C) */
   Say "number of volumes -" ZDS#VOLS;
/* ZDSVOL 1st or only volume (6,C) */
   Say "1st or only volume -" ZDSVOL;
/* ZDSVTAB volume table (354,C) */
   Say "volume list -" Strip(ZDSVTAB);
/* ZDSSPC primary space units (8,C) */
   Say "primary space units -" Strip(ZDSSPC);
/* ZDS1EX primary space allocation (13,C) */
   Say "primary space allocation -" Strip(ZDS1EX);
/* ZDS2SPC secondary space units (8,C) */
   Say "secondary space units -" Strip(ZDS2SPC);
/* ZDS2EX secondary space allocation (13,C) */
   Say "secondary space allocation -" Strip(ZDS2EX);
/* ZDSOVF flag indicates that ZDSTOTAX & ZDSTOTUX should
          be used instead of ZDSTOTA & ZDSTOTU (3,C) */
   Say "extended allocation flag -" ZDSOVF;
/* ZDSTOTAX allocated space units (18,C)
   ZDSTOTUX used space units (18,C) */
   If ZDSOVF = "YES" Then;
     Do;
       Say "extended allocation space units -" Strip(ZDSTOTAX);
       Say "extended used space units -" Strip(ZDSTOTUX);
     End;
/* ZDSTOTA allocated space units (13,C)
   ZDSTOTU used space units (13,C) */
   Else;
     Do;
       Say "allocation space units -" Strip(ZDSTOTA);
       Say "used space units -" Strip(ZDSTOTU);
     End;
/* ZDSEXTA allocated extents (7,C) */
   Say "allocated extents -" Strip(ZDSEXTA);
/* ZDSEXTU used extents (7,C) */
   Say "used extents -" Strip(ZDSEXTU);

   If ZDSORG = "PO" Then;
     Do;
       If ZDSDSNT = "PDS" Then;
         Do;
/* ZDSDIRA allocated directory blocks (6,C)
   ZDSDIRU used directory blocks (8,C) */
           Say "allocated directory blocks -" Strip(ZDSDIRA);
           Say "used directory blocks -" Strip(ZDSDIRU);
         End;
       Else
         Do;
/* ZDSDSNV PDSE version (1,C) */
           If ZDSDSNV <> "ZDSDSNV" Then;
             Say "PDSE version -" ZDSDSNV;
/* ZDSDIR PDSE directory blocks (8,C)
   ZDSPAGU PDSE pages used (13,C)
   ZDSPERU PDSE percent used (13,C) */
           Say "PDSE directory blocks -" Strip(ZDSDIR);
           Say "PDSE pages used -" Strip(ZDSPAGU);
           Say "PDSE % used -" ZDSPERU;
         End;
/* ZDS#MEM nbr of members (13,C) */
       Say "number of members -" Strip(ZDS#MEM);
     End;

/* ZDSCB1 format 1 data control block (96,C) */
   Say "DSCB format 1 -" ZDSCB1;

   Return (0);
./ ADD NAME=DSNFLTR  0125-15233-18229-1126-00610-00001-00000-APLKS   11
/* REXX 2017-05-16 */
/* --------------------------------------------------------- */
/* Purpose: Used on the DSLIST (TSO =3.4) panel to filter    */
/*          the data set selection.                          */
/*                                                           */
/*          This is an undocumented IBM interface that was   */
/*          discovered by Gilbert Saint-Flour.  I have       */
/*          liberally pilfered the logic.  I have also       */
/*          chosen to implement some of the addressing       */
/*          methods of John Kalinich.                        */
/*                                                           */
/*      Op: This macro must be invoked from the DSLIST       */
/*          panel.                                           */
/*                                                           */
/*          To get all of the ISPF table field populated,    */
/*          you must scroll to the bottom of DSLIST          */
/*          (if longer than a page) and you must scroll      */
/*          left.                                            */
/*                                                           */
/*  Format: DSNFLTR  X | FLIP | HR < ( options >             */
/*                                                           */
/*          action: X     exclude with options               */
/*                  FLIP  NX to X  or                        */
/*                        X  to NX                           */
/*                  HR    HSM RECALL all MIGRAT1 dsnames     */
/*                  TALLY sum the dsnames, TRACKS, & Extents */
/*                                                           */
/*         options: (default)                                */
/*                  kwd=value                                */
/*                                                           */
/*           Where: kwd  = VOLUME | TRACKS | XT | DEVICE |   */
/*                         DSORG | RECFM | LRECL| BLKSZ |    */
/*                         CREATED | EXPIRATI | REFERRED |   */
/*                         CATALOG | DSNAME                  */
/*                 value = any | exact | exact | any         */
/*                         exact | exact | exact | exact |   */
/*                         any | any | any |                 */
/*                         any | any                         */
/*                                                           */
/* AUTHOR : Rainer Nowak                                     */
/* DATE   : 2013-05-30                                       */
/*          2015-09-08 altered site stds by L. Slaten        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC DSNFLTR  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   Address ISPEXEC "VGET (ZPANELID) SHARED";
   If zpanelid <> "ISRUDSL0" Then
     Signal Error_ON_ERROR;

   Signal ON ERROR NAME Error_ON_ERROR;
   Signal ON FAILURE NAME Error_ON_FAILURE;
   Signal ON NOVALUE NAME Error_NO_VALUE;

   /* Initialize Variables */

   kwd = "";
   val = "";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Mainline */

   Call GET_DSL;

   Select;
      When parm2 = "X" Then;
        Do;
          Call DSL_EXCLUDE;
        End;
      When parm2 = "FLIP" Then;
        Do;
          Call DSL_FLIP;
        End;
      When parm2 = "HR" Then;
        Do;
          Call DSL_RECALL;
        End;
      When parm2 = "TALLY" Then;
        Do;
          Call DSL_TALLY;
        End;
      Otherwise;
        Do;
          Signal Error_EXEC_HELP;
        End;
   End;

   Return;

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   Parse VAR parm3 kwd "=" val . ")";
   kwd = Strip(kwd,'B');
   val = Strip(val,'B');
   match = "";
   Select;
     When Abbrev("VOLUME",kwd,3) Then;
       Do;
         kwd = "ZUDVOL7";
         match = "IN";
       End;
     When Abbrev("TRACKS",kwd,3) Then;
       Do;
         kwd = "ZUSIZE";
         match = "EQ";
       End;
     When kwd = "XT" Then;
       Do;
         kwd = "ZUX";
         match = "EQ";
       End;
     When Abbrev("DEVICE",kwd,3) Then;
       Do;
         kwd = "ZUDEVICE";
         match = "IN";
       End;
     When Abbrev("DSORG",kwd,3) Then;
       Do;
         kwd = "ZUORG";
         match = "EQ";
       End;
     When Abbrev("RECFM",kwd,3) Then;
       Do;
         kwd = "ZURECFM";
         match = "EQ";
       End;
     When Abbrev("LRECL",kwd,3) Then;
       Do;
         kwd = "ZULRECL";
         match = "EQ";
       End;
     When Abbrev("BLKSZ",kwd,3) Then;
       Do;
         kwd = "ZUBLKSIZ";
         match = "EQ";
       End;
     When Abbrev("CREATED",kwd,3) Then;
       Do;
         kwd = "ZUCDATE";
         match = "IN";
       End;
     When Abbrev("EXPIRATI",kwd,3) Then;
       Do;
         kwd = "ZUEDATE";
         match = "IN";
       End;
     When Abbrev("REFERRED",kwd,3) Then;
       Do;
         kwd = "ZURDATE";
         match = "IN";
       End;
     When Abbrev("CATALOG",kwd,3) Then;
       Do;
         kwd = "ZUCATNAM";
         match = "IN";
       End;
     When Abbrev("DSNAME",kwd,3) Then;
       Do;
         kwd = "ZUDSNS";
         match = "IN";
       End;
     Otherwise;
       Signal Error_INVALID_KWD;
   End;

   Return;

   /* ----------------------------------- */
   /* Routine to extract the DSLIST table */
   /* ----------------------------------- */

   GET_DSL:

   Numeric Digits 10;         /* Required for 31-bit addresses */
   pca_ptr = 0;
   tcb_ptr = get_ptr(pca_ptr,'21c');    /*TCB (EXEC cmd) PSATOLD*/
   tcb_ptr = get_ptr(tcb_ptr,'84');     /*TCB (ISPTASK) TCBOTC*/
   rsa_ptr = get_ptr(tcb_ptr,'70');     /*1st RSA TCBFSA*/
   R1_rsa_ptr = get_ptr(rsa_ptr,'18');  /*ISPTASK's R1*/
   tld_ptr = get_ptr(R1_rsa_ptr,'00');  /*TLD addr*/
   dta_ptr = get_ptr(tld_ptr,'4c');     /*DTA addr*/
   dsltblnm = get_data(dta_ptr,'0c',8); /*DSL tbl name*/

   If Substr(dsltblnm,1,3) <> "DSL" Then;
     Signal Error_NO_VALUE;

   Address ISPEXEC "TBQUERY" dsltblnm,
        " KEYS(KEYS) NAMES(NAMES) NAMENUM(NAMENUM)",
        " ROWNUM(ROWNUM) KEYNUM(KEYNUM)",
        " POSITION(CRP)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TBQUERY_FAILED;

   Address ISPEXEC "TBTOP" dsltblnm;    /*start from the top*/
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TBTOP_FAILED;

   rownum = Strip(rownum,'L','0');

/* Signal LIST; */

   Return;

   /* ------------------------------------------ */
   /* Routine to exclude data sets from the list */
   /* ------------------------------------------ */

   DSL_EXCLUDE:

   xtcnt = 0; xcnt = 0;       /*init counters*/
   Do i=1 To rownum By +1;
     Address ISPEXEC "TBSKIP" dsltblnm; /*next row*/
     If RC > 0 Then;
       Leave;
     Address ISPEXEC "TBGET" dsltblnm;  /*set variables*/
     If RC > 0 Then;
       Leave;
     If zudxstat = "Y" Then;  /*already excluded*/
       Do;
         xtcnt = xtcnt + 1;
         Iterate;
       End;
     If zudxstat = "N" Then;
       Do;
         If match = "IN" Then;
           Do;
             IF Pos(val,Value(kwd)) > 0 Then;
               Do;
                 zudxstat = 'Y';
                 Address ISPEXEC "TBPUT" dsltblnm; /*update variables*/
                 If RC = 0 Then;
                   xcnt = xcnt + 1;
               End;
           End;
         Else;
           Do;
             If Value(kwd) = val Then;
               Do;
                 zudxstat = 'Y';
                 Address ISPEXEC "TBPUT" dsltblnm /*update variables*/
                 If RC = 0 Then;
                   xcnt = xcnt + 1;
               End;
           End;
       End;
   End;

   If xcnt > 0 Then;
     Do;
       ZEDSMSG = "EX "xcnt;
       ZEDLMSG = "EXCLUDEd "xcnt" OF "rownum" DATA SETS";
     End;
   Else;
     Do;
       ZEDSMSG = "POPULATE TBL";
       ZEDLMSG = "POPULATE TABLE, DOWN MAX AND LEFT 1 PANEL";
     End;

   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Address ISPEXEC "CONTROL NONDISPL ENTER";    /*skip one ENTER*/

   Return;

   /* ------------------------------------------------------ */
   /* Routine to flip between excluded and visible           */
   /* ------------------------------------------------------ */

   DSL_FLIP:

   xcnt = 0; nxcnt = 0;    /*init counters*/
   Do i=1 To rownum By +1;
     Address ISPEXEC "TBSKIP" dsltblnm;   /*next row*/
     If RC > 0 Then;
       Leave;
     Address ISPEXEC "TBGET" dsltblnm;    /* SET VARIABLES */
     If RC > 0 Then;
       Leave;
     If zudxstat = "N" Then;
       Do;
         zudxstat = "Y";
         xcnt = xcnt + 1;
       End;
     Else;
       Do;
         zudxstat = "N";
         nxcnt = nxcnt + 1;
       End;
     Address ISPEXEC "TBPUT" dsltblnm;    /*update variables*/
   End;

   ZEDSMSG = "DSPLY "nxcnt;
   ZEDLMSG = "DISPLAY "nxcnt" OF "rownum" DATA SETS";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Address ISPEXEC "CONTROL NONDISPL ENTER";      /*skip one ENTER*/

   Return;

   /* --------------------------------------- */
   /* Routine to HSM RECALL MIGRAT1 data sets */
   /* --------------------------------------- */

   DSL_HR:

   rcall_cnt = 0;             /*init counters*/
   Do i=1 To rownum By +1;
     Address ISPEXEC "TBSKIP" dsltblnm; /*next row*/
     If RC > 0 Then;
       Leave;
     Address ISPEXEC "TBGET" dsltblnm;  /*set variables*/
     IF RC > 0 Then;
       Leave;
     If zudxstat = "Y" Then;
       Iterate;
     If zudvol7 <> "MIGRAT1" Then;
       Iterate;
     dsn = STRIP(zudsns,'B',' ');
     EC = HSM_Func(dsn);
     IF EC <> 9 Then;
       rcall_cnt = rcall_cnt + 1;
   End;

   ZEDSMSG = "HRECALL "recall_cnt;
   ZEDLMSG = "HRECALL "recall_cnt" OF "rownum" DATA SETS";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Address ISPEXEC "CONTROL NONDISPL ENTER";      /*skip one ENTER*/

   Return;

   /* ------------------------------------------- */
   /* Routine to tally the total tracks allocated */
   /* ------------------------------------------- */

   DSL_TALLY:

   nxcnt = 0; trkcnt = 0; xtcnt = 0;    /*init counters*/
   Do i=1 To rownum By +1;
     Address ISPEXEC "TBSKIP" dsltblnm; /*next row*/
     If RC > 0 Then;
       Leave;
     Address ISPEXEC "TBGET" dsltblnm;  /*set variables*/
     IF RC > 0 Then;
       Leave;
     If zudxstat = "Y" Then;
       Iterate;
     nxcnt = nxcnt + 1;
     trkcnt = trkcnt + zusize;
     xtcnt = xtcnt + zux;
   End;

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Count   = "nxcnt,
        pad hex04,
        "Tracks  = "trkcnt,
        pad hex04,
        "Extents = "xtcnt;
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Address ISPEXEC "CONTROL NONDISPL ENTER";      /*skip one ENTER*/

   Return;

/* +--------------------------+
   | Functions defined below. |
   +--------------------------+ */

   get_ptr: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset;
   temp = d2x(x2d(addr) + x2d(offset));
   return c2x(storage(temp,4));
   exit;

   get_ptr3: procedure
   /* +-----------------------------------------+
      | returns a 3 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset;
   temp = d2x(x2d(addr) + x2d(offset));
   return c2x(storage(temp,3));
   exit;

   get_data: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset, length;
   temp = d2x(x2d(addr) + x2d(offset));
   return storage(temp,length);
   exit;

   HSM_Func: Procedure

   ARG dsn;
   EC = LISTDSI("'"dsn"' NORECALL");
   If EC >= 16 Then;
     Signal Error_LISTDSI_FAILED;
   EC = 0;
   If SYSREASON = 9 Then;
     Do;            /* dataset migrated */
       "HRECALL ('"dsn"') NOWAIT";
       EC = RC;
     End;

   Return (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Filter rows on the DSLIST panel.",
        pad hex04,
        " Format: DSNFLTR  action ( kwd=value",
        pad hex04,
        " action: X | FLIP | TALLY | HR",
        pad hex04,
        "    kwd: VOL | TRA | XT | DEV | DSO | REC | LRE | BLK...";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";

   Exit;

   Error_ON_ERROR:
   Error_ON_FAILURE:
   Error_NO_VALUE:

   ZEDSMSG = "ERROR";
   ZEDLMSG = "ON INVALID PANEL, OR POPULATE TABLE,",
             "MAX TO BOTTOM AND LEFT 1 PANEL";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_TBQUERY_FAILED:

   ZEDSMSG = "TBQUERY FAILED";
   ZEDLMSG = "TBQUERY SERVICE FAILED WITH RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_INVALID_KWD:

   ZEDSMSG = "INVALID KEYWORD";
   ZEDLMSG = "INVALID KEYWORD SPECIFIED" kwd;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_TBTOP_FAILED:

   ZEDSMSG = "TBTOP FAILED";
   ZEDLMSG = "TBTOP FAILED FOR TABLE" dsltblnm "RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_LISTDSI_FAILED:

   ZEDSMSG = "LISTDSI FAILED";
   ZEDLMSG = "LISTDSI FAILED, RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   /* ---------------------------------- */
   /* Variables (for documentation only) */
   /* ---------------------------------- */

   LIST:

   Say "KEYS="keys "NAMES="names "NAMENUM="namenum;
   Say "ROWNUM="rownum "KEYNUM="keynum "POSITION="crp;
   Do i=1 To rownum By +1;
     Address ISPEXEC "TBSKIP" dsltblnm;
     Say " ";
     Say Left("ROW",8) "=" i;
     Do j=1 To namenum By +1;
       name = Strip(Strip(Word(names,j),"L","("),"T",")");
       Say Left(name,8) "=" Value(name);
     End;
   End;

   Exit;

  1zudsns   3zusize   3zuus     5zucdate  5zuedate  5zurdate
  2zudvol    zudmvol  3zudevice  zucdat2   zuedat2   zurdat2
  4zuorg    3zux      4zurecfm  4zulrecl  4zublksiz  zustat
   zudspacu  zulmsg    zulocvol #zuobtatt #zuobtspc #zuobtdat
  #zudxstat  zulcmdl   zud20v    zudvol7  6zucatnam  zusizex
   zuxx      zuovf     zugflag   zueatr    zucjobn   zucstpn

  Where:
   1 - dsname   (dsname)
   2 - volinfo  (volser)
   3 - spcinfo  (tracks used% extents device)
   4 - attrinfo (dsorg recfm lrecl blksize)
   5 - dateinfo (creation expiration reference)
   6 - catname  (catname)
   # - flags used

/* ISPF service DSINFO
   ISPF Option 3.2 or Option 3.4

   ISPEXEC DSINFO DATASET(dsname) [VOLUME(volid)]
   RC 0-normal; 8-request unavailable info (refer to Dialog
   error variables ZERRLM... for more info); 12-FAMS error,
   Obtain error, Error obtaining directory info; 20-severe

   doesn't work for BDAM data sets

   ZDSVOL 1st or only volume (6,C)
   ZDS#VOLS nbr of volumes (2,C)
   ZDSDEVT device type (8,C)
   ZDSORG data set organization (8,C)
   ZDSRF record format (6,C)
   ZDSLREC logical record length (7,C)
   ZDSBLK block size (6,C)
   ZDSSPC primary space units (8,C)
   ZDS1EX primary space allocation (13,C)
   ZDS2SPC secondary space units (8,C)
   ZDS2EX secondary space allocation (13,C)
   ZDSTOTAX allocated space units (18,C)
   ZDSTOTUX used space units (18,C)
   ZDSDSNT data set name type (8,C)
   ZDSSEQ compressible YES|NO (4,C)
   ZDSCDATE creation date (national format) (10,C)
   ZDSXDATE expiration date (national format) (10,C)
   ZDSRDATE referenced date (national format (10,C)
   ZDSTOTA allocated space units (13,C)
   ZDSTOTU used space units (13,C)
   ZDSEXTA allocated extents (7,C)
   ZDSEXTU used extents (7,C)
   ZDSDIRA allocated directory blocks (6,C)
   ZDSDIRU used directory blocks (8,C)
   ZDSDIR PDSE directory blocks (8,C)
   ZDS#MEM nbr of members (13,C)
   ZDSPAGU PDSE pages used (13,C)
   ZDSPERU PDSE percent used (13,C)
   ZDSMC management class (8,C)
   ZDSSC storage class (8,C)
   ZDSAPF APF status of data set YES|NO|ERR (4,C)
   ZDSLNK LNKLST status of data set YES|NO|ERR (4,C)
   ZDSCB1 format 1 data control block (96,C)
   ZDSVTAB volume table (354,C)
   ZDSOVF flag indicates that ZDSTOTAX & ZDSTOTUX should
          be used instead of ZDSTOTA & ZDSTOTU (3,C)
   ZDSEATR extended attribute indicator (4,C)
   ZDSCJOBN create jobname (8,C)
   ZDSCSTPN create stepname (8,C)
   ZDSDSNV PDSE version (1,C)
   "?..." replaces N/A values       */
./ ADD NAME=DUDASD   0104-18269-18271-0931-00242-00338-00000-APLKS   09
/* REXX 2018-09-28 */
/* --------------------------------------------------------- */
/* Purpose: Used to present the information collected        */
/*          via TSO command DUDASD.                          */
/*                                                           */
/*  Format: %DUDASD <<volpattern> <unit1<:unit2>>            */
/*                  < ( options >                            */
/*                                                           */
/*          volpattern - i.e. TSO001, TSO*, TSO0??           */
/*               unit1 - from unit addr                      */
/*               unit2 - to unit addr                        */
/*                                                           */
/*         options: (default) SCREEN                         */
/*                  LINE|SCREEN|QUEUE presentation option    */
/*                  kwd=(value,...)                          */
/*                                                           */
/*           Where: kwd = VOLUME | UNIT                      */
/*                  value... is a list of values, that are   */
/*                           used to make partial matches    */
/*                           to the actual values.           */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC %DUDASD  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   opt. = "";
   kwd = "";
   vallst = "";
   str = "";
   unit = "";
   volid = "";

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_OPTIONS;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1;

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     If Pos(":",parm2) > 0 Then;

     Select;
       When Words(parm2) > 1 Then;
         Signal Error_TOO_MANY_PARMS;
       When Pos(":",parm2) > 0 Then;
         unit = parm2;
       Otherwise;
         volid = parm2;
     End;

   /* Mainline */

   Select;
     When opt.1 = "LIN" Then;
       /*display at terminal in Line mode*/
       If unit <> "" Then;
         "DUO" unit;
       Else;
         "DUDASD" volid;
     When opt.1 = "SCR" Then;
       /*display at terminal in screen mode*/
       Do;
         x = OUTTRAP(lne.);
         If unit <> "" Then;
           "DUO" unit;
         Else;
           "DUDASD" volid;
         x = OUTTRAP("OFF");
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(132) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(5)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD ( STEM LNE. FINIS ";
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid")",
                  " DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     When opt.1 = "QUE" Then;
       /*queue items for later retrieval*/
       Do;
         x = OUTTRAP(lne.);
         If unit <> "" Then;
           "DUO" unit;
         Else;
           "DUDASD" volid;
         x = OUTTRAP("OFF");
         Do i=1 To lne.0 By +1;
           Parse VAR lne.i dev_vol1 12 21 dev_vol2 32 41 dev_vol3 52,
               61 dev_vol4 72;
           Select;
             When kwd = "U" Then;
               Do j=1 To Words(vallst) By +1;
                 If Pos(Word(vallst,j),Word(dev_vol1,1)) > 0 Then;
                   Queue dev_vol1;
                 If Pos(Word(vallst,j),Word(dev_vol2,1)) > 0 Then;
                   Queue dev_vol2;
                 If Pos(Word(vallst,j),Word(dev_vol3,1)) > 0 Then;
                   Queue dev_vol3;
                 If Pos(Word(vallst,j),Word(dev_vol4,1)) > 0 Then;
                   Queue dev_vol4;
               End;
             When kwd = "V" Then;
               Do j=1 To Words(vallst) By +1;
                 If Pos(Word(vallst,j),Word(dev_vol1,2)) > 0 Then;
                   Queue dev_vol1;
                 If Pos(Word(vallst,j),Word(dev_vol2,2)) > 0 Then;
                   Queue dev_vol2;
                 If Pos(Word(vallst,j),Word(dev_vol3,2)) > 0 Then;
                   Queue dev_vol3;
                 If Pos(Word(vallst,j),Word(dev_vol4,2)) > 0 Then;
                   Queue dev_vol4;
               End;
             Otherwise;
               Do;
                 Queue dev_vol1;
                 Queue dev_vol2;
                 Queue dev_vol3;
                 Queue dev_vol4;
               End;
           End;
         End;
       End;
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 str parm3;
     Select;
       When Abbrev("LINE",str,3) |,
            Abbrev("SCREEN",str,3) |,
            Abbrev("QUEUE",str,3) Then;
         opt.1 = Substr(str,1,3);
       Otherwise;
         parm3 = str parm3;
     End;
     If parm3 <> "" Then;
       Do;
         Parse VAR parm3 kwd "=" vallst parm3;
         If kwd <> "" Then;
           If Abbrev("VOLUME",kwd,1) | Abbrev("UNIT",kwd,1) Then;
             kwd = Substr(kwd,1,1);
         vallst = Strip(vallst,"L","(");
         vallst = Strip(vallst,"T",")");
         vallst = Translate(vallst," ",",");
       End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Present information collected via the TSO DUDASD cmd",
        pad hex04,
        " Format: %DUDASD <<volpattern> <<unit-1<:unit-2>>",
        pad hex04,
        "                 < ( <SCREEN|LINE|QUEUE>",
        pad hex04,
        "                     <kwd=val>";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_TOO_MANY_PARMS:

   ZEDSMSG = "PARMS >2";
   ZEDLMSG = "Too many PARMS on the command line";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "INVALID USER OPTION:" str;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=DUP      0111-14130-16236-1741-00272-00271-00000-APLKS   14
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Duplicate data found in the current row to a     */
/*          number of following rows                         */
/*  Format: DUP target | range                               */
/*              strt_col end_col | *                         */
/*              < ( options >                                */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  row on the screen or the row that the    */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        strt_col: start column of the text                 */
/*         end_col: end column of the text                   */
/*         options: (default) REPLACE                        */
/*                  APPEND | INSERT | REPLACE                */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC DUP */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   the_string = "";
   chg_cnt = 0;

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   "(status) = USER_STATE";

   /* Check out Edit Mode Options */

   "(recfm) = RECFM";
   "(lrecl) = LRECL";
   zonelo = 1;
   zonehi = lrecl;
   Select;
     When recfm = "V" Then;
       zonelo = 9;
     When lang = "STD" Then;
       zonehi = lrecl - 8;
     When lang = "COBOL" Then;
       zonelo = 7;
     Otherwise;
       Nop;
   End;
   "BOUNDS = (zonelo,zonehi)";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 = "" Then;
     cmd = "REPLACE";
   Else;
     cmd = Strip(parm3);

   /* Parse Target and User passed Parms */

   Call Extract_Target;

   /* Parse the Optional EXEC Parameters */

   Parse VAR parm2 var.3 parm2;
   If var.3 = "" Then;
     Signal Error_INVALID_PARM;
   If var.3 = "*" Then;
     Do;
       strt_col = 1;
       end_col = lrecl;
     End;
   Else;
     Do;
       If Datatype(var.3,"W") Then;
         Do;
           strt_col = var.3;
           Parse VAR parm2 var.3 parm2;
           If var.3 = "" Then;
             Signal Error_INVALID_PARM;
           If Datatype(var.3,"W") Then;
             end_col = var.3;
           Else;
             Signal Error_INVALID_PARM;
         End;
       Else;
         Signal Error_INVALID_PARM;
     End;
   str_lgth = end_col - strt_col + 1;

   "(row) = LINE" trgt_row_from;
   the_string = Substr(row,strt_col,str_lgth);

   Do i = trgt_row_from + 1 To trgt_row_to By 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     Select;
       When Abbrev("REPLACE",cmd) Then;
         row = Overlay(the_string,row,strt_col,str_lgth);
       When Abbrev("INSERT",cmd) Then;
         row = Insert(the_string,row,strt_col-1,str_lgth);
       When Abbrev("APPEND",cmd) Then;
         row = Strip(row,"T")||the_string;
       Otherwise;
         Signal Error_INVALID_CMD;
     End;
     "LINE" i "= (row)";
     chg_cnt = chg_cnt + 1;
   End;

   "USER_STATE = (status)";

   ZEDSMSG = Strip(chg_cnt,"L","0") "CHGed";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2 || " " || parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET:
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Duplicate data found in the current row.",
        pad hex04,
        " Format: DUP target|range",
        pad hex04,
        "             strt_col end_col | *",
        pad hex04,
        "             < ( APPEND | INSERT | REPLACE >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Exit (-16);

   Error_INVALID_PARM:

   ZEDSMSG = "INVALID PARM";
   ZEDLMSG = "Invalid/missing parameters";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_CMD:

   ZEDSMSG = "INVALID CMD";
   ZEDLMSG = "Invalid user command ("cmd")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);
./ ADD NAME=EASTER   0109-16001-19270-1450-00102-00051-00000-APLKS   09
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Invoke as:  yyyymmdd = EASTER(yyyy)
          or:  TSO EASTER yyyy

   Compute the date for Easter returned in yyyymmdd format.
   The argument yyyy must be the year in question.

   Easter Sunday is the Sunday following the Paschal Full Moon
   (PFM) date for the year.

   This algorithm is an arithmetic interpretation of the 3 step
   Easter Dating Method developed in 1985 by Ronald W. Mallen,
   Adelaide, South Australia.  It is an accurate simplification
   of the official procedure used to calculate Easter Sunday
   dates, as described in Christian Prayer Books.
   ----------------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   gdate = "error composition";

   Arg year . ;               /* i.e. 2016 */

   If Datatype(year,"W") Then;
     If year < 4099 & year > 1582 Then;
       Nop;
     Else;
       Signal The_End;
   Else;
       Signal The_End;

   gdate = "";

   nbr_centuries = year % 100;               /*centuries*/
   nbr_yrs_in_century = Abs(year // 100);    /*years within century*/
   yr_within_19yr_span = Abs(year // 19);    /*remainder*/
   pfm_date = (nbr_centuries - 15) % 2,
        + 202 - 11 * yr_within_19yr_span;
   temp = pfm_date;

   Select;
     When nbr_centuries = 21 | ,
          nbr_centuries = 24 | ,
          nbr_centuries = 25 | ,
         (nbr_centuries > 26 & nbr_centuries < 33) | ,
          nbr_centuries = 34 | ,
          nbr_centuries = 35 | ,
          nbr_centuries = 38 Then;
       temp = temp - 1;
     When nbr_centuries = 33 | ,
          nbr_centuries = 36 | ,
          nbr_centuries = 37 | ,
          nbr_centuries = 39 | ,
          nbr_centuries = 40 Then;
       temp = temp - 2;
     Otherwise;
       Nop;
   End;

   temp = Abs(temp // 30);

   temp_A = temp + 21;
   If temp = 29 Then;
     temp_A = temp_A - 1;
   If (temp = 28 & yr_within_19yr_span > 10) Then;
     temp_A = temp_A - 1;

   temp_B = Abs((temp_A - 19) // 7);    /*compute next Sunday*/

   temp_C = Abs((40 - nbr_centuries) // 4);
   If temp_C = 3 Then;
     temp_C = temp_C + 1;
   If temp_c > 1 Then;
     temp_C = temp_C + 1;

   temp = nbr_yrs_in_century;
   temp_D = Abs((temp + temp % 4) // 7);

   temp_E = Abs((20 - temp_B - temp_C - temp_D) // 7) + 1;
   day = temp_A + temp_E;

   If day > 31 Then;
     Do;
       day = day - 31;
       month = 4;
     End;
   Else;
     month = 3;

   gdate = (Right(year,4,0) || ,
        Right(month,2,0) || ,
        Right(day,2,0));

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return (gdate);

   Say "Easter =" gdate;
   Return (0);
./ ADD NAME=ENVVAR   0139-19212-19212-1134-01323-01322-00000-APLKS   30
/* REXX 2019-07-29 */
/* --------------------------------------------------------- */
/* Purpose: Provide SYSTEM/environment variables via         */
/*          REXX function exec authored by J. Kalinich       */
/*          Packaged into single member by L. Slaten         */
/*                                                           */
/*  Format: x = ENVVAR(fieldname<,inputvalue>)               */
/*                                                           */
/*          Where fieldname:                                 */
/*            "CACHElsz"                                     */
/*            "CPPdnm"                                       */
/*            "CPUmodl"                                      */
/*            "DEst"                                         */
/*            "DFplvl"                                       */
/*            "Hwname"                                       */
/*            "IOdf"                                         */
/*            "IPA"                                          */
/*            "IPLDate"                                      */
/*            "IPLDEv"                                       */
/*            "IPLTime"                                      */
/*            "JEs2pdnm"                                     */
/*            "JOBAcct"                                      */
/*            "JOBId"                                        */
/*            "JOBNm"                                        */
/*            "LOadparm"                                     */
/*            "LPARMode"                                     */
/*            "LPARName"                                     */
/*            "MCAT"                                         */
/*            "PGrname"                                      */
/*            "PLexname"                                     */
/*            "RACFGrp"                                      */
/*            "RACFUser"                                     */
/*            "REAlstg"                                      */
/*            "REGsize"                                      */
/*            "SEcurity"                                     */
/*            "SMFid"                                        */
/*            "SMSstat"                                      */
/*            "SWAloc"                                       */
/*            "Tsoattr"                                      */
/*            "VTAMLvl"                                      */
/*            "VTAMTerm"                                     */
/*                                                           */
/* --------------------------------------------------------- */

/* Entering EXEC ENVVAR */

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG action, value, .;

   Select;
     When Abbrev("CACHELSZ",action,3) Then;
       Signal GETCACHE;
     When Abbrev("CPPDNM",action,3) Then;
       Signal GETSCPN;
     When Abbrev("CPUMODL",action,3) Then;
       Signal GETCPUM;
     When Abbrev("DEST",action,2) Then;
       Signal GETDEST;
     When Abbrev("DFPLVL",action,2) Then;
       Signal GETDFPL;
     When Abbrev("GRSMODE",action,3) Then;
       Signal GETGRSM;
     When Abbrev("HWNAME",action,1) Then;
       Signal GETHWNME;
     When Abbrev("IODF",action,2) Then;
       Signal GETIODF;
     When Abbrev("IPA",action,3) Then;
       Signal GETIPA;
     When Abbrev("IPLDATE",action,5) Then;
       Signal GETIPLD;
     When Abbrev("IPLDEV",action,5) Then;
       Signal GETIDEV;
     When Abbrev("IPLTIME",action,4) Then;
       Signal GETIPLT;
     When Abbrev("JES2PDNM",action,2) Then;
       Signal GETJES2;
     When Abbrev("JOBACCT",action,4) Then;
       Signal GETACCT;
     When Abbrev("JOBID",action,4) Then;
       Signal GETJOBID;
     When Abbrev("JOBNM",action,4) Then;
       Signal GETJOBNM;
     When Abbrev("LOADPARM",action,2) Then;
       Signal GETLDPRM;
     When Abbrev("LPARMODE",action,5) Then;
       Signal GETLPAR;
     When Abbrev("LPARNAME",action,5) Then;
       Signal GETLPARN;
     When Abbrev("MCAT",action,2) Then;
       Signal GETMCAT;
     When Abbrev("PGRNAME",action,2) Then;
       Signal GETPRGNM;
     When Abbrev("PLEXNAME",action,2) Then;
       Signal GETPLEX;
     When Abbrev("RACFGRP",action,4) Then;
       Signal GETGRPN;
     When Abbrev("RACFUSER",action,4) Then;
       Signal GETNAME;
     When Abbrev("REALSTG",action,3) Then;
       Signal GETREALM;
     When Abbrev("REGSIZE",action,3) Then;
       Signal GETREGK;
     When Abbrev("SECURITY",action,2) Then;
       Signal GETSEC;
     When Abbrev("SMFID",action,3) Then;
       Signal GETSMFID;
     When Abbrev("SMSSTAT",action,3) Then;
       Signal GETSMS;
     When Abbrev("SWALOC",action,3) Then;
       Signal GETSWA;
     When Abbrev("TSOATTR",action,1) Then;
       Signal GETATTR;
     When Abbrev("VTAMLVL",action,5) Then;
       Signal GETVTAML;
     When Abbrev("VTAMTERM",action,5) Then;
       Signal GETTRID;
     Otherwise;
       Return (-20);
   End;

/*
 +------------------------------------------------------------------+
 | Name:       GETACCT                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Get job accounting information                       |
 | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/29/96                                              |
 | Abstract:   A sub-function to return the job account number      |
 |                                                                  |
 | Call Format:  GETACCT()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT+x'10')                             |
 |        Addresses the ACT (JCT+x'28')                             |
 |        Extracts ACTACCNT                                         |
 +------------------------------------------------------------------+ */
   GETACCT:

   numeric digits 10          /* Required for 31-bit addresses */
   tcb_ptr = get_ptr(21c,0)
   jscb_ptr = get_ptr(tcb_ptr,'b4')
   jct_prefix_ptr = get_ptr(jscb_ptr,'104')
   jct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))
/* jct_sva = get_ptr3(jscb_ptr,'105')                        /*lks*/
   jct_ptr = swareq(jct_sva)                                 /*lks*/ */
   act_ptr = get_ptr3(jct_ptr,'28')
   acct_len = c2d(get_data(act_ptr,'30',1))
   actaccnt = get_data(act_ptr,'31',acct_len)
   return actaccnt

/*
 +------------------------------------------------------------------+
 | Name:       GETATTR                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Get the TSO user attributes                          |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to return the TSO user attributes     |
 |             from the Protected Step Control Block                |
 |                                                                  |
 | Call Format:  GETATTR()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of PSCB (JSCB+x'108')                    |
 |        Tests PSCBATR1, bit 0 for OPERATOR authority              |
 |        Tests PSCBATR1, bit 1 for ACCOUNT  authority              |
 |        Tests PSCBATR1, bit 2 for SUBMIT   authority              |
 +------------------------------------------------------------------+ */
   GETATTR:

   numeric digits 10          /* Required for 31-bit addresses */
   tcb_ptr = get_ptr(21c,0)
   jscb_ptr = get_ptr(tcb_ptr,'b4')
   pscb_ptr = get_ptr(jscb_ptr,'108')
   pscbatr1 =  get_data(pscb_ptr,'10',1)
   if bitand(pscbatr1,'80'x) = '80'x then
     oper = 'OPER  '
   else
     oper = 'NOOPER'
   if bitand(pscbatr1,'40'x) = '40'x then
     account = 'ACCOUNT  '
   else
     account = 'NOACCOUNT'
   if bitand(pscbatr1,'20'x) = '20'x then
     submit = 'SUBMIT  '
   else
     submit = 'NOSUBMIT'

   return oper account submit;

/*
 +------------------------------------------------------------------+
 | Name:       GETCACHE                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract CACHE line size                              |
 | Release:    z/OS 2.2                                             |
 | Programmer: L Slaten                                             |
 | Date:       2019/07/29                                           |
 | Abstract:   A sub-function to extract the CACHE line size.       |
 |                                                                  |
 | Call Format:  GETCACHE()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of ECVT (CVT+x'8c')                      |
 |        Extracts ECVTCACHELINESIZE (ECVT+'2c0')                   |
 +------------------------------------------------------------------+ */
   GETCACHE:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)               /* point to CVT */
   ecvt_ptr = get_ptr(cvt_ptr,'8c')      /* point to CVTECVT */
   ecvtcachelinesize = C2D(get_data(ecvt_ptr,'2c0',2))
   Return ecvtcachelinesize

/*
 +------------------------------------------------------------------+
 | Name:       GETCPC   Central Processing Complex                  |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the CPC of the System you are on             |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2016/07/04                                           |
 | Abstract:   A sub-function to extract the CPC information.       |
 |                                                                  |
 | Call Format: GETCPC()                                            |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SHID (cvt + x'42c')                   |
 |        Extracts data CPC ID                                      |
 |        Extracts data CPC ND (type,model,man,plant,seqno)         |
 +------------------------------------------------------------------+ */
   GETCPC:

   cpc_nd = "";
   cpc_si = "";

   cvt_ptr = get_ptr(10,0)
   cvthid = get_ptr(cvt_ptr,'42c')           /*point to SHID*/
   cpcnd_flags = get_data(cvthid,'16',1)     /*extract CPCND flags*/
   If cpcnd_flags <> 0 Then
     Do
       cpcnd_valid = Bitand(cpcnd_flags,'E0'x)    /*valid flags*/
       cpcnd_invalid = Bitand('40'x)              /*invalid flag*/
       If cpcnd_valid <> cpcnd_invalid Then       /*valid?*/
         Do;
           cpcnd_type = get_data(cvthid,'1a',6)   /*type*/
           cpcnd_model = get_data(cvthid,'20',3)  /*model*/
           cpcnd_man = get_data(cvthid,'23',3)    /*manufacturer*/
           cpcnd_plant = get_data(cvthid,'26',2)  /*plant*/
           cpcnd_seqno = get_data(cvthid,'28',12) /*seq nbr*/
           cpc_id = C2x(get_data(cvthid,'37',1))  /*CPC id*/
         End;
     End;

   cpc_nd = cpcnd_type"."cpcnd_model"."cpcnd_man"."cpcnd_plant"."cpcnd_seqno

   Return cpc_id cpc_nd

/*
 +------------------------------------------------------------------+
 | Name:       GETCPUM                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the CVTMDL of the System you are on          |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the cpu model number from  |
 |             the CVT prefix.                                      |
 |                                                                  |
 | Call Format:  GETCPUM()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the CVTFIX+250 (CVT-x'6')                       |
 |        Extracts CVTMDL                                           |
 +------------------------------------------------------------------+ */
   GETCPUM:

   cvt_ptr = get_ptr(10,0)
   cvtmdl_ptr = d2x(x2d(cvt_ptr) - x2d(6))
   cvtmdl = c2x(get_data(cvtmdl_ptr,'0',2))
   return substr(cvtmdl,1,4)

/*
 +------------------------------------------------------------------+
 | Name:       GETDEST                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Get the TSO default SYSOUT destination               |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       4/09/93                                              |
 | Abstract:   A sub-function to return the TSO user's default      |
 |             SYSOUT destination                                   |
 |                                                                  |
 | Call Format:  GETDEST()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of PSCB (JSCB+x'108')                    |
 |        Extracts the PSCBDEST                                     |
 +------------------------------------------------------------------+ */
   GETDEST:

   numeric digits 10          /* Required for 31-bit addresses */
   tcb_ptr = get_ptr(21c,0)
   jscb_ptr  = get_ptr(tcb_ptr,'b4')
   pscb_ptr  = get_ptr(jscb_ptr,'108')
   dest = get_data(pscb_ptr,'28',8)
   return dest

/*
 +------------------------------------------------------------------+
 | Name:       GETDFPL                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the DFAREL of the System you are on          |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the DFP level from the     |
 |             Data Facilities Area (DFA).                          |
 |                                                                  |
 | Call Format:  GETDFPL()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of DFA (CVT+x'4C0')                      |
 |        Extracts DFAREL                                           |
 +------------------------------------------------------------------+ */
   GETDFPL:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   dfa_ptr = get_ptr(cvt_ptr,'4c0')
   dfarel = c2x(get_data(dfa_ptr,'2',2))
   return substr(dfarel,1,1)'.'substr(dfarel,2,1)'.'substr(dfarel,3,1)

/*
 +------------------------------------------------------------------+
 | Name:       GETGRPN                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the ACEEGRPN from the RACF ACEE.             |
 | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |
 | Programmer: John Kalinich                                        |
 | Date:       1/3/95                                               |
 | Abstract:   A sub-function to extract connect group name from    |
 |             the RACF Accessor Environment Element.  The ACEE is  |
 |             not fetch protected.  This function works in ACF2    |
 |             systems.                                             |
 |                                                                  |
 | Call Format:  GETGRPN()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of ASXB (ASCB+x'6C')                     |
 |        Extracts address of ACEE (ASXB+x'C8')                     |
 |        Extracts ACEEGRPN                                         |
 +------------------------------------------------------------------+ */
   GETGRPN:

   ascb_ptr = get_ptr(224,0)
   asxb_ptr = get_ptr(ascb_ptr,'6c')
   acee_ptr = get_ptr(asxb_ptr,'c8')
   aceegrpn = get_data(acee_ptr,'1e',8)
   return aceegrpn

/*
 +------------------------------------------------------------------+
 | Name:       GETGRSM                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the GRS mode                                 |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2016/07/01                                           |
 | Abstract:   A sub-function to extract the GRS mode from the      |
 |             Extended vector table (ECVT).                        |
 |                                                                  |
 | Call Format:  GETGRSM()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of ECVT (CVT+x'8c')                      |
 |        Extracts GRS mode                                         |
 +------------------------------------------------------------------+ */
   GETGRSM:

   grsmode. = ""
   grsmode.0 = "NONE"  /* Stem for GRS mode: ECVTGNON EQU 0 */
   grsmode.1 = "RING"  /* Stem for GRS mode: ECVTGRNG EQU 1 */
   grsmode.2 = "STAR"  /* Stem for GRS mode: ECVTGSTA EQU 2 */

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   ecvt_ptr = get_ptr(cvt_ptr,'8c')           /* point to CVTECVT */
   ecvtgmod = C2D(get_data(ecvt_ptr,'10a',1)) /* get GRS mode */
   return grsmode.ecvtgmod

/*
 +------------------------------------------------------------------+
 | Name:       GETHWNME                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the Hardware name                            |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2016/07/01                                           |
 | Abstract:   A sub-function to extract the hardware name from the |
 |             Extended vector table (ECVT).                        |
 |                                                                  |
 | Call Format:  GETHWNME()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of ECVT (CVT+x'8c')                      |
 |        Extracts HW name (ECVT+x'150')                            |
 +------------------------------------------------------------------+ */
   GETHWNME:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   ecvt_ptr = get_ptr(cvt_ptr,'8c')      /* point to CVTECVT */
   ecvthdnm = get_data(ecvt_ptr,'150',8) /* get to HW name */
   return ecvthdnm

/*
 +------------------------------------------------------------------+
 | Name:       GETIODF                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract I/O Definition File dsname                   |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2018/03/07                                           |
 | Abstract:   A sub-function to extract the IODF dsname.           |
 |                                                                  |
 | Call Format:  GETIODF()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of IOCM (CVT+x'7c')                      |
 |        Extracts address of IOSVT (IOCM+x'd0')                    |
 |        Extracts address of CDA (IOCM+x'd0')                      |
 |        Extracts IODF (CDA+x'20')                                 |
 +------------------------------------------------------------------+ */
   GETIODF:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)               /* point to CVT */
   iocm_ptr = get_ptr(cvt_ptr,'7c')      /* point to IOCM */
   iosvt_ptr = get_ptr(iocm_ptr,'d0')    /* point to IOS vector table */
   cda_ptr = get_ptr(iosvt_ptr,'18')     /* point to CDA */
   iodf = get_data(cda_ptr,'20',44)      /* get IODF */
   iodf = Strip(iodf,'T')

   Return iodf;

/*
 +------------------------------------------------------------------+
 | Name:       GETIPA                                               |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract IPL LOADPARM information from IPA            |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2018/03/07                                           |
 | Abstract:   A sub-function to extract the IPL LOADPARM info      |
 |             from the Initial Parm Area.                          |
 |                                                                  |
 | Call Format:  GETIPA()                                           |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of ECVT (CVT+x'8c')                      |
 |        Extracts address of IPA (ECVT+x'188')                     |
 |        Extracts IPA IPL LOADPARM (IPA+x'10')                     |
 |          1:4 device addr of PARMLIB                              |
 |          5:6 LOADxx PARMLIB member suffix                        |
 |          7:7 Initial Message Suppression Indicator (IMSI)        |
 |          8:8 OS nucleus IEANUC0 suffix                           |
 |        Extracts IPA PARMLIB name (IPA+x'30')                     |
 |        Extracts IPA PARMLIB device (IPA+x'5c')                   |
 +------------------------------------------------------------------+ */
   GETIPA:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)               /* point to CVT */
   ecvt_ptr = get_ptr(cvt_ptr,'8c')      /* point to CVTECVT */
   ipa_ptr = get_ptr(ecvt_ptr,'188')     /* point to IPA */
   ipalprm = get_data(ipa_ptr,'10',8)    /* get IPL LOADPARM */
   ipaprmlib = get_data(ipa_ptr,'30',44) /* get PARMLIB */
   ipaprmlib = Strip(ipaprmlib,'T')
   ipaprmlibdev = get_data(ipa_ptr,'5c',4) /* get IPA PARMLIB dev */

   Return ipalprm ipaprmlib || '(LOAD' || Substr(ipalprm,5,2) || ')';

/*
 +------------------------------------------------------------------+
 | Name:       GETLDPRM                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract IPL LOADPARM information                     |
 | Release:    z/OS 2.2                                             |
 | Programmer: L Slaten                                             |
 | Date:       2019/07/31                                           |
 | Abstract:   A sub-function to extract the IPL LOADPARM info.     |
 |                                                                  |
 | Call Format:  GETLDPRM()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of ECVT (CVT+x'8c')                      |
 |        Extracts edited IPL LOADPARM (ECVT+x'a0')                 |
 |          1:4 device addr of PARMLIB                              |
 |          5:6 LOADxx PARMLIB member suffix                        |
 |          7:7 Initial Message Suppression Indicator (IMSI)        |
 |          8:8 OS nucleus IEANUC0 suffix                           |
 |        Extracts IPL LOADPARM (ECVT+x'a8')                        |
 |          1:4 device addr of PARMLIB                              |
 |          5:6 LOADxx PARMLIB member suffix                        |
 |          7:7 Initial Message Suppression Indicator (IMSI)        |
 |          8:8 OS nucleus IEANUC0 suffix                           |
 +------------------------------------------------------------------+ */
   GETLDPRM:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)                /* point to CVT */
   ecvt_ptr = get_ptr(cvt_ptr,'8c')       /* point to CVTECVT */
   ecvtelprm = get_data(ecvt_ptr,'a0',8)  /* get edited IPL LOADPARM */
   ecvtlprm = get_data(ecvt_ptr,'a8',8)   /* get IPL LOADPARM */

   Return ecvtelprm ecvtlprm

/*
 +------------------------------------------------------------------+
 | Name:       GETLPARN                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the Logical Partition name                   |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2016/07/01                                           |
 | Abstract:   A sub-function to extract the LPAR name from the     |
 |             Extended vector table (ECVT).    .                   |
 |                                                                  |
 | Call Format:  GETLPARN()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of ECVT (CVT+x'8c')                      |
 |        Extracts LPAR name                                        |
 +------------------------------------------------------------------+ */
   GETLPARN:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   ecvt_ptr = get_ptr(cvt_ptr,'8c')      /* point to CVTECVT */
   ecvtlpnm = get_data(ecvt_ptr,'158',8) /* get LPAR name */
   return ecvtlpnm

/*
 +------------------------------------------------------------------+
 | Name:       GETMCAT                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract master catalog dsname                        |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2018/03/07                                           |
 | Abstract:   A sub-function to extract the master catalog dsname  |
 |                                                                  |
 | Call Format:  GETMCAT()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of ECVT (CVT+x'8c')                      |
 |        Extracts address of IPA (ECVT+x'188')                     |
 |        Extracts SYSCAT card image (IPA+x'e0')                    |
 |          01:06 master catalog volid                              |
 |          07:07 master catalog type 0-VSAM, 1:2-ICF               |
 |          11:54 master catalog dsname                             |
 +------------------------------------------------------------------+ */
   GETMCAT:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)               /* point to CVT */
   ecvt_ptr = get_ptr(cvt_ptr,'8c')      /* point to CVTECVT */
   ipa_ptr = get_ptr(ecvt_ptr,'188')     /* point to IPA */
   syscat = get_data(ipa_ptr,'e0',63)    /* get SYSCAT card image */
   mcatvolid = Substr(syscat,1,6)        /* get mcat volid */
   Select;
     When Substr(syscat,7,1) = ' ' | Substr(syscat,7,1) = '0' Then;
       mcattype = 'VSAM';
     When Substr(syscat,7,1) = '1' | Substr(syscat,7,1) = '2' Then;
       mcattype = 'ICF';
     Otherwise;
       mcattype = 'n/a';
   End;
   mcatdsn = Strip(Substr(syscat,11,44),'T') /* get mcat dsn */

   Return mcatvolid mcattype mcatdsn;

/*
 +------------------------------------------------------------------+
 | Name:       GETIDEV                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the IPL device & volid                       |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2018-03-07                                           |
 | Abstract:   A sub-function to extract the IPL device & volid.    |
 |                                                                  |
 | Call Format:  GETIDEV()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of CVTSYSAD (CVT+x'30')                  |
 |        Extracts IPLDEV (CVTSYSAD+x'04')                          |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of SYSRES UCB (JESCT+x'04')              |
 |        Extracts IPLVOL (SYSRES UCB+x'1c')                        |
 +------------------------------------------------------------------+ */
   GETIDEV:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   sysucb_ptr = get_ptr(cvt_ptr,'30')   /*point to UCB addr*/
   ipldev = get_data(sysucb_ptr,'04',2) /*get IPL device*/
   ipldev = C2X(ipldev);
   jesct_ptr = get_ptr(cvt_ptr,'128')   /*point to JESCT addr*/
   resucb_ptr = get_ptr(jesct_ptr,'04') /*point to SYSRES UCB*/
   iplvol = get_data(resucb_ptr,'1c',6) /*get IPL VOLID*/

   Return ipldev iplvol;

/*
 +------------------------------------------------------------------+
 | Name:       GETIPLD                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the SMCAIDTE of the System you are on        |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/19/93                                              |
 | Abstract:   A sub-function to extract the IPL date from the      |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETIPLD()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCAIDTE                                         |
 +------------------------------------------------------------------+ */
   GETIPLD:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   smca_ptr = get_ptr(cvt_ptr,'c4')
   smcaidte = c2x(get_data(smca_ptr,'154',4))
   return substr(smcaidte,3,2)||substr(smcaidte,5,3)

/*
 +------------------------------------------------------------------+
 | Name:       GETIPLT                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the SMCAITME of the System you are on        |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to extract the IPL time from the      |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETIPLT()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCAITME                                         |
 +------------------------------------------------------------------+ */
   GETIPLT:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   smca_ptr = get_ptr(cvt_ptr,'c4')
   smcaitme = c2x(get_data(smca_ptr,'150',4))
   total_seconds = x2d(smcaitme) % 100
   seconds = right((total_seconds // 60),2,'0')
   minutes = right(((total_seconds % 60) // 60),2,'0')
   hours   = right(((total_seconds / 60) % 60),2,'0')
   return hours':'minutes':'seconds

/*
 +------------------------------------------------------------------+
 | Name:       GETJES2                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Get the JES2 product name                            |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to return the JES2 product name       |
 |             from HASPSSSM.                                       |
 |                                                                  |
 | Call Format:  GETJES2()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of 1st SSCT (JESCT+x'18')                |
 |        Extracts address of SSCTSUSE (SSCT+x'14')                 |
 |        Extracts JES2 product name from HASPSSSM+x'C'             |
 +------------------------------------------------------------------+ */
   GETJES2:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   jesct_ptr = get_ptr(cvt_ptr,'128')
   sscvt_ptr = get_ptr(jesct_ptr,'18')
   haspsssm_plus12 = get_ptr(sscvt_ptr,'14')
   jeslevel = get_data(haspsssm_plus12,'0',8)
   return jeslevel

/*
 +------------------------------------------------------------------+
 | Name:       GETJOBID                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the SSIBJBID from the SSIB.                  |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the job id from the        |
 |             Subsystem Identification Block (SSIB).               |
 |                                                                  |
 | Call Format:  GETJOBID()                                         |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of SSIB (JSCB+x'13C')                    |
 |        Extracts the SSIBJBID                                     |
 +------------------------------------------------------------------+ */
   GETJOBID:

   numeric digits 10          /* Required for 31-bit addresses */
   tcb_ptr = get_ptr(21c,0)
   jscb_ptr  = get_ptr(tcb_ptr,'b4')
   ssib_ptr  = get_ptr(jscb_ptr,'13c')
   ssibjbid = get_data(ssib_ptr,'c',8)
   return ssibjbid

/*
 +------------------------------------------------------------------+
 | Name:       GETJOBNM                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the SSIBJBnm from the SSIB.                  |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: L Slaten                                             |
 | Date:       8/28/2015                                            |
 | Abstract:   A sub-function to extract the job name from the      |
 |             Subsystem Identification Block (SSIB).               |
 |                                                                  |
 | Call Format:  GETJOBNM()                                         |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD  at x'224')             |
 |        Extracts address of ASSB (ASCBASSB at x'150')             |
 |        Extracts address of JSAB (ASSBJSAB at x'A8')              |
 |                                                                  |
 |        Extracts field JSABJBNM at x'1C'                          |
 |        Also contains JSABSCID scheduling component id jes2/jes3  |
 |                      JSABJBID job id                             |
 |                      JSABPREF jes2=JSABJBID, jes3=JSABJBNM       |
 |                      JSABUSID user id                            |
 |                      JSABSSNM creating subsystem name            |
 +------------------------------------------------------------------+ */
   GETJOBNM:

   numeric digits 10          /* Required for 31-bit addresses */
   pca_ptr = 0
   ascb_ptr = get_ptr(pca_ptr,'224')
   if ascb_ptr = 0 then
     return 'UNKNOWN'
   assb_ptr = get_ptr(ascb_ptr,'150')
   jsab_ptr = get_ptr(assb_ptr,'a8')
   if jsab_ptr = 0 then
     return 'UNKNOWN'
   jsabflg1 = get_data(jsab_ptr,'d',1)
   do while jsabflg1 > 127    /* JSAB is deleted x'80'*/
     jsabid = get_data(jsab_ptr,'0',4)
     if jsabid = 'JSAB' then
       do;
         jsab_ptr = get_ptr(jsab_ptr,'4')
         if jsab_ptr = 0 then
           return 'UNKNOWN'
       end
     jsabflg1 = get_data(jsab_ptr,'d',1)
   end
   jsabjbnm = get_data(jsab_ptr,'1c',8)
   return jsabjbnm

/*
 +------------------------------------------------------------------+
 | Name:       GETLPAR                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the Logical Partition mode (YES or NO)       |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to extract the LPAR mode from the     |
 |             Service Call Control Block (SCCB).                   |
 |                                                                  |
 | Call Format:  GETLPAR()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SCCP (CVT+x'340')                     |
 |        Tests SCCBCON1, bit 0 for LPAR configuration              |
 +------------------------------------------------------------------+ */
   GETLPAR:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   sccb_ptr = get_ptr(cvt_ptr,'340')
   sccbcon1 = get_data(sccb_ptr,'50',1)
   if bitand(sccbcon1,'80'x) = '80'x then
     lpar = 'YES'
   else
     lpar = 'NO'
   return lpar

/*
 +------------------------------------------------------------------+
 | Name:       GETLPARN                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the Logical Partition name                   |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2016/07/01                                           |
 | Abstract:   A sub-function to extract the LPAR name from the     |
 |             Extended vector table (ECVT).    .                   |
 |                                                                  |
 | Call Format:  GETLPARN()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SCCP (CVT+x'340')                     |
 |        Tests SCCBCON1, bit 0 for LPAR configuration              |
 +------------------------------------------------------------------+ */
   GETLPARN:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   ecvt_ptr = get_ptr(cvt_ptr,'8c')      /* point to CVTECVT */
   ecvtlpnm = get_data(ecvt_ptr,'158',8) /* get LPAR name */
   return ecvtlpnm

/*
 +------------------------------------------------------------------+
 | Name:       GETNAME                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract ACEEUNAM from the RACF ACEE.                 |
 | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |
 | Programmer: John Kalinich                                        |
 | Date:       10/24/95                                             |
 | Abstract:   A sub-function to extract the ACEE user name from    |
 |             the RACF Accessor Environment Element.  The ACEE is  |
 |             not fetch protected.  This function works in ACF2    |
 |             systems.                                             |
 |                                                                  |
 | Call Format:  GETNAME()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of ASXB (ASCB+x'6C')                     |
 |        Extracts address of ACEE (ASXB+x'C8')                     |
 |        Extracts address of ACEEUNAM (ACEE+x'64')                 |
 |        Extracts ACEEUNAM                                         |
 +------------------------------------------------------------------+ */
   GETNAME:

   ascb_ptr = get_ptr(224,0)
   asxb_ptr = get_ptr(ascb_ptr,'6c')
   acee_ptr = get_ptr(asxb_ptr,'c8')
   acee_unam_ptr = get_ptr(acee_ptr,'64')
   unam_len = c2d(get_data(acee_unam_ptr,'0',1))
   user_name = get_data(acee_unam_ptr,'1',unam_len -1)
   return user_name

/*
 +------------------------------------------------------------------+
 | Name:       GETPLEX                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the sysplex name of the System you are on    |
 | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       4/29/96                                              |
 | Abstract:   A sub-function to extract the sysplex name from      |
 |             the Extended CVT.                                    |
 |                                                                  |
 | Call Format:  GETPLEX()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the ECVT (CVT+x'8C')                            |
 |        Extracts ECVTSPLX (ECVT+x'8)                              |
 |        Extracts ECVTCLON (ECVT+x'108')  /*lks 20190129*/         |
 +------------------------------------------------------------------+ */
   GETPLEX:

   cvt_ptr = get_ptr(10,0)
   cvtecvt_ptr = get_ptr(cvt_ptr,'8c')
   ecvtsplx = get_data(cvtecvt_ptr,'8',8)
   ecvtclon = get_data(cvtecvt_ptr,'108',2)  /*lks 20190729*/
   return ecvtsplx ecvtclon

/*
 +------------------------------------------------------------------+
 | Name:       GETPRGNM                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Get programmer name                                  |
 | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/29/96                                              |
 | Abstract:   A sub-function to return the programmer name         |
 |                                                                  |
 | Call Format:  GETPRGNM()                                         |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT+x'10')                             |
 |        Addresses the ACT (JCT+x'28')                             |
 |        Extracts ACTPRGNM                                         |
 +------------------------------------------------------------------+ */
   GETPRGNM:

   numeric digits 10          /* Required for 31-bit addresses */
   tcb_ptr = get_ptr(21c,0)
   jscb_ptr = get_ptr(tcb_ptr,'b4')
   jct_prefix_ptr = get_ptr(jscb_ptr,'104')
   jct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))
/* jct_sva = get_ptr3(jscb_ptr,'105')                        /*lks*/
   jct_ptr = swareq(jct_sva)                                 /*lks*/ */
   act_ptr = get_ptr3(jct_ptr,'28')
   actprgnm = get_data(act_ptr,'18',20)
   return actprgnm

/*
 +------------------------------------------------------------------+
 | Name:       GETREALM                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the CVTRLSTG from the CVT.                   |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the real storage size      |
 |             online at IPL.  Returns value in number of           |
 |             megabytes (M).                                       |
 |                                                                  |
 | Call Format:  GETREALM()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts CVTRLSTG                                         |
 +------------------------------------------------------------------+ */
   GETREALM:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   cvtrlstg = c2d(get_data(cvt_ptr,'358',4)) / 1024
   return cvtrlstg

/*
 +------------------------------------------------------------------+
 | Name:       GETREGK                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the LDAREGRQ from the LDA.                   |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the region size requested  |
 |             from the Local Data Area (LDA).  Returns value in    |
 |             number of kilobytes (K).                             |
 |                                                                  |
 | Call Format:  GETREGK()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of LDA  (ASCB+x'30')                     |
 |        Extracts LDAREGRQ                                         |
 +------------------------------------------------------------------+ */
   GETREGK:

   numeric digits 10          /* Required for 31-bit addresses */
   ascb_ptr = get_ptr(224,0)
   lda_ptr  = get_ptr(ascb_ptr,'30')
   ldaregrq = c2d(get_data(lda_ptr,'cc',4)) / 1024
   return ldaregrq

/*
 +------------------------------------------------------------------+
 | Name:       GETSEC                                               |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the security application                     |
 | Release:    z/OS 1.13.0                                          |
 | Programmer: L Slaten                                             |
 | Date:       2016/07/05                                           |
 | Abstract:   A sub-function to extract the security application   |
 |             being used.                                          |
 |                                                                  |
 | Call Format:  GETSEC()                                           |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of RCVT (CVT + x'3e0')                   |
 |        Extracts data rcvtidc (at RCVT + 0)                       |
 +------------------------------------------------------------------+ */
   GETSEC:

   cvt_ptr = get_ptr(10,0)
   rcvt_ptr = get_ptr(cvt_ptr,'3e0')    /*get RCVT addr*/
   rcvtidc = get_data(rcvt_ptr,'0',4)   /*get security appl*/
   Select
     When rcvtidc = "RCVT" Then
       secappl = "RACF"
     When rcvtidc = "RTSS" Then
       secappl = "TopSecret"
     When rcvtidc = "ACF2" Then
       secappl = "ACF2"
     Otherwise
       secappl = " ";
   End
   return secappl

/*
 +------------------------------------------------------------------+
 | Name:       GETSCPN                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the CVTPRODN of the System you are on        |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the system control program |
 |             product name (e.g., SP3.1.3) from the CVT prefix.    |
 |                                                                  |
 | Call Format:  GETSCPN()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the CVTFIX+216 (CVT-x'28')                      |
 |        Extracts CVTPRODN                                         |
 +------------------------------------------------------------------+ */
   GETSCPN:

   cvt_ptr = get_ptr(10,0)
   cvtprod = d2x(x2d(cvt_ptr) - x2d(28))
   cvtprodn = get_data(cvtprod,'0',8)
   cvtprodn = insert(' ',cvtprodn,2)
   return cvtprodn

/*
 +------------------------------------------------------------------+
 | Name:       GETSMFID                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the SMCASID of the System you are on         |
 | Release:    MVS/ESA v4.1   and TSO/E v2.1                        |
 | Programmer: Paul S. Waterhouse                                   |
 |             (Code modified from apf list routine put on          |
 |              exchange by Joe Millar)                             |
 | Date:       1/24/92                                              |
 | Abstract:   A sub-function to extract the smfid from the         |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETSMFID('smf-id')                                 |
 |                                                                  |
 |               When 'smf-id' is null, function returns            |
 |               the SMF-ID.                                        |
 |               When 'smf-id' is four bytes long, a 1 will be      |
 |               returned if current SMF-ID = smf-id or a 0 if      |
 |               not equal.                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCASID                                          |
 |                                                                  |
 |        If arg is null, return smfid                              |
 |        If arg len = 4 then compare                               |
 |           If equal return 1                                      |
 |           If not equal return 0                                  |
 +------------------------------------------------------------------+ */
   GETSMFID:

   numeric digits 10          /* Required for 31-bit addresses */
/* parse arg check_id, .  */
   check_id = value;
   cvt_ptr = get_ptr(10,0)
   smca_ptr = get_ptr(cvt_ptr,'c4')
   smcasid = get_data(smca_ptr,'10',4)
   select
     when check_id = "" then
       return smcasid
     when length(check_id) <> 4 then
       return -3
     otherwise
       if check_id =  smcasid then
         return 1
   end
   return 0

/*
 +------------------------------------------------------------------+
 | Name:       GETSMS                                               |
 | Type:       REXX function exec                                   |
 | Purpose:    Get the status of SMS (On or Off)                    |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to return the status of SMS in the    |
 |             system.                                              |
 |                                                                  |
 | Call Format:  GETSMS()                                           |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of JESCTEXT (JESCT+x'64')                |
 |        Tests pointer to JESSMSIB                                 |
 +------------------------------------------------------------------+ */
   GETSMS:

   numeric digits 10          /* Required for 31-bit addresses */
   cvt_ptr = get_ptr(10,0)
   jesct_ptr = get_ptr(cvt_ptr,'128')
   jesctext_ptr = get_ptr(jesct_ptr,'64')
   jessmsib = c2x(get_data(jesctext_ptr,'54',4))
   if x2d(jessmsib) = 0 then
     smsstat = 'Off'
   else
     smsstat = 'On'
   return smsstat

/*
 +------------------------------------------------------------------+
 | Name:       GETSWA                                               |
 | Type:       REXX function exec                                   |
 | Purpose:    Get the location of SWA (ABOVE or BELOW)             |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to return the status of SWA in the    |
 |             system. (ABOVE/BELOW)                                |
 |                                                                  |
 | Call Format:  GETSWA()                                           |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT+x'10')                             |
 |        Extracts data at JCT+x'74') JCTSTAT2                      |
 |        Tests JCTSTAT2, bit 7 for location of SWA                 |
 |              x'80' - spooled SYSIN                               |
 |              x'40' - ADRSPC = REAL                               |
 |              x'20' - Job termination ind                         |
 |              x'10' - warm start message                          |
 |              x'08' -                                             |
 |              x'04' - BLP                                         |
 |              x'02' - SYSIN/SYSOUT SWA below the line             |
 |              x'01' - SWA above the line ind                      |
 +------------------------------------------------------------------+ */
   GETSWA:

   numeric digits 10          /* Required for 31-bit addresses */
   psa_ptr = 0;               /* prefix save area */
   tcb_ptr = get_ptr(psa_ptr,'21c')
   jscb_ptr  = get_ptr(tcb_ptr,'b4')
   jct_prefix_ptr = get_ptr(jscb_ptr,'104')
   jct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))
   jctstat2 = get_data(jct_ptr,'74',1)
   if bitand(jctstat2,'01'x) = '01'x then
     jctswaup = 'ABOVE'
   else
     jctswaup = 'BELOW'
   return jctswaup

/*
 +------------------------------------------------------------------+
 | Name:       GETVTAML                                             |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the VTAM release of the System you are on    |
 | Release:    z/OS 01.13.00 and VTAM v6.1.d                        |
 | Programmer: L Slaten                                             |
 | Date:       2016/07/01                                           |
 | Abstract:   A sub-function to extract the VTAM level.            |
 |                                                                  |
 | Call Format:  GETVTAML()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of EXT2 (CVT+x'148')                     |
 |        Extracts address of VTAM AVT (EXT2+x'41')                 |
 |        Extracts address of VTAM CVT (AVT+x'0')                   |
 |        Extracts VTAM version                                     |
 +------------------------------------------------------------------+ */
   GETVTAML:

   cvt_ptr = get_ptr(10,0)
   cvtext2_ptr = get_ptr(cvt_ptr,'148')      /*EXT2 addr*/
   cvtatcvt_ptr = get_ptr3(cvtext2_ptr,'41') /*VTAM AVT addr*/
   istatcvt_ptr = get_ptr(cvtatcvt_ptr,'0')  /*VTAM CVT addr*/
   atcvtlvl = get_data(istatcvt_ptr,'0',8)   /*get VTAM version*/
   return substr(atcvtlvl,3,1)'.'substr(atcvtlvl,4,1)'.'substr(atcvtlvl,5,1)

/*
 +------------------------------------------------------------------+
 | Name:       GETTRID                                              |
 | Type:       REXX function exec                                   |
 | Purpose:    Extract the ACEETRID from the RACF ACEE.             |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/10/93                                              |
 | Abstract:   A sub-function to extract the VTAM terminal id from  |
 |             the RACF Accessor Environment Element.  The ACEE is  |
 |             not fetch protected.  This function works in ACF2    |
 |             systems.                                             |
 |                                                                  |
 | Call Format:  GETTRID()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of ASXB (ASCB+x'6C')                     |
 |        Extracts address of ACEE (ASXB+x'C8')                     |
 |        Extracts ACEETRID                                         |
 +------------------------------------------------------------------+ */
   GETTRID:

   ascb_ptr = get_ptr(224,0)
   asxb_ptr = get_ptr(ascb_ptr,'6c')
   acee_ptr = get_ptr(asxb_ptr,'c8')
   aceetrid = get_data(acee_ptr,'40',8)
   return aceetrid

/* +--------------------------+
   | Functions defined below. |
   +--------------------------+ */

   get_ptr: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset
   temp = d2x(x2d(addr) + x2d(offset))
   return c2x(storage(temp,4))
   exit

   get_ptr3: procedure
   /* +-----------------------------------------+
      | returns a 3 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset
   temp = d2x(x2d(addr) + x2d(offset))
   return c2x(storage(temp,3))
   exit

   get_data: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      | Author: J. KALINICH, X4521              |
      +-----------------------------------------+ */
   arg addr, offset, len
   temp = d2x(x2d(addr) + x2d(offset))
   return storage(temp,len)
   exit

/*
 +------------------------------------------------------------------+
 | Name:       SWAREQ                                               |
 | Type:       REXX function exec                                   |
 | Purpose:    Convert 24-bit SVA to a 31-bit address.              |
 | Release:    TSO/E V2                                             |
 | Programmer: Gilbert Saint-Flour <carlos@gsf-soft.com>            |
 | Date:       unknown                                              |
 | Abstract:   Simulates the SWAREC macro to convert an SWA Virtual |
 |             Address (SVA) to a full 31-bit address which can be  |
 |             used to access SWA control blocks in the SWA=ABOVE   |
 |             environment.  The input is a 3-byte SVA; the output  |
 |             value is a 4-byte address.                           |
 | Modify:     L Slaten 2016-02-12                                  |
 |                                                                  |
 | Call Format:  SWAREQ(sva)                                        |
 |                                                                  |
 | Logic: Extracts address of TCB (PSA+x'21C')         PSATOLD      |
 |        Extracts address of JSCB (TCB+x'B4')         TSCBJSCB     |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT prefix+x'10')                      |
 |        Extracts data at (JCT+x'74')                 JCTSTAT2     |
 |        Tests JCTSTAT2, bit 7 for location of SWA                 |
 |              x'80' - spooled SYSIN                               |
 |              x'40' - ADRSPC = REAL                               |
 |              x'20' - Job termination ind                         |
 |              x'10' - warm start message                          |
 |              x'08' -                                             |
 |              x'04' - BLP                                         |
 |              x'02' - SYSIN/SYSOUT SWA below the line             |
 |              x'01' - SWA above the line ind                      |
 |        Extracts address of QMPA (JSCB     at x'f4' ) JSCBQMPI    |
 |        Extracts address of QMAT (QMPA     at x'18' )             |
 +------------------------------------------------------------------+ */
   swareq: procedure

   arg sva

   numeric digits 10          /* Required for 31-bit addresses */

   psa_ptr = 0;               /* prefix save area */         /*lks*/
   tcb_ptr = get_ptr(psa_ptr,'21c')                          /*lks*/
   jscb_ptr = get_ptr(tcb_ptr,'b4')                          /*lks*/
   jct_prefix_ptr = get_ptr(jscb_ptr,'104')                  /*lks*/
   jct_ptr = d2x(x2d(jct_prefix_ptr)+x2d(10))                /*lks*/
   jctstat2 = get_data(jct_ptr,'74',1)                       /*lks*/
   if bitand(jctstat2,'01'x) = '01'x then                    /*lks*/
     nop                           /*above the line*/        /*lks*/
   else                                                      /*lks*/
     return d2x(x2d(sva)+16)       /*below the line*/        /*lks*/

   qmpa_ptr = get_ptr(jscb_ptr,'f4')
   qmat_ptr = get_ptr(qmpa_ptr,'18')
   sva = c2d(sva);
   do while sva > 65536
     qmat_ptr = get_ptr(qmat_ptr,'0c')
     sva = sva - 65536
   end
   return d2x(x2d(storage(d2x(x2d(qmat_ptr)+sva+1),4)+16))
./ ADD NAME=EOL      0104-14134-16190-0936-00108-00100-00000-APLKS   39
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: This routine puts the cursor at the end of the   */
/*          line.  This macro is most useful when assigned   */
/*          to a PF key.                                     */
/*                                                           */
/*  Format: EOL                                              */
/*                                                           */
/*          target: is the row the cursor is positioned on.  */
/*                  variable names are trow                  */
/*                                     tcol                  */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC EOL */

   Address ISREDIT;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   the_string. = "";

   "(bndslo,bndshi) = BOUNDS";

   /* Parse Target */

   Call Extract_TARGET;

   /* Perform the function of this routine */

   "(row) = LINE" trow;
   the_string.orig = Strip(Substr(row,1,bndshi),"T");
   tcol = Length(the_string.orig) + 1;
   "CURSOR = (trow,tcol)";
   Return (0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Extract_TARGET:

   /* Resolve trow and tcol Variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trow = krow;
       tcol = kcol;
     End;
   Else;
     trow = frow;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: This macro puts the cursor at the end of the line,",
        pad hex04,
        "         and most useful when assigned to a PF key.",
        pad hex04,
        " Format: EOL";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=FALT     0116-16033-16236-1800-00414-00272-00000-APLKS   36
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Find a value in strt_col thru end_col that is    */
/*          GE|GT|EQ|LE|LT|NE to string.                     */
/*  Format: FALT    target | range                           */
/*                  strt_col end_col                         */
/*                  string                                   */
/*                  < ( options >                            */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  row on the screen or the row that the    */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        strt_col: start column of the text                 */
/*         end_col: end column of the text                   */
/*          string: end column of the text                   */
/*         options: (default) GE SAVE                        */
/*                  cond - GE|GT|EQ|LE|LT|NE                 */
/*                  CLEAR | SAVE                             */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC FALT */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   opt. = "";            /*1=GE|GT|LE|LT|NE 2=CLEAR|SAVE*/
   strt_col = 0;         /*col-1*/
   end_col = 0;          /*col-2*/
   tgt_string = "";      /*defined by col-1 col-2*/
   tgt_len = 0;
   src_string = "";      /*input string*/
   src_len = 0;

   "(lrecl) = LRECL";

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   If parm2 = "#*!*#" Then;
     Call Init_Repeat_Process;

   parm9 = parm2;

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "GE";

   If opt.2 = "" Then;
     opt.2 = "CLEAR";

   /* Parse Target */

   Call Extract_Target;

   /* Parse the Required EXEC Parameters */

   Do While parm2 <> "";
     parm2 = Strip(parm2,"B");
     Select;
       When Substr(parm2,1,1) = "'" Then;
         Parse VAR parm2 "'" src_string "'" parm2;
       When Substr(parm2,1,1) = '"' Then;
         Parse VAR parm2 '"' src_string '"' parm2;
       When Substr(parm2,1,2) = "x'" | Substr(parm2,1,2) = "X'" Then;
         Do;
           Parse VAR parm2 "'" src_string "'" parm2;
           src_string = X2C(src_string);
         End;
       Otherwise;
         Do;
           Parse VAR parm2 var.3 parm2;
           If var.3 = "" Then;
             Iterate;
           Select;
             When Datatype(var.3,"W") Then;
               Do;
                 strt_col = var.3;
                 If strt_col > lrecl Then;
                   Signal Error_INVALID_PARM;
                 Parse VAR parm2 var.3 parm2;
                 If var.3 = "" Then;
                   Signal Error_INVALID_PARM;
                 If Datatype(var.3,"W") Then;
                   end_col = var.3;
                 Else;
                   Signal Error_INVALID_PARM;
                 If end_col > lrecl Then;
                   Signal Error_INVALID_PARM;
                 tgt_len = end_col - strt_col + 1;
                 If tgt_len > lrecl Then;
                   Signal Error_INVALID_PARM;
               End;
             When Datatype(var.3,"A") Then;
               src_string = Translate(var.3);
             Otherwise;
               Signal Error_MISSING_STRING;
           End;
         End;
     End;
   End;

   src_len = Length(src_string);
   If src_len = 0 Then;
     Signal Error_MISSING_STRING;
   src_string = Left(src_string,tgt_len);

   /* Mainline */

   Do i = trgt_row_from To trgt_row_to By 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     tgt_string = Substr(row,strt_col,tgt_len);
     Select;
       When opt.1 = "GE" Then;
         If tgt_string >= src_string Then;
           Do;
             "LOCATE" i;
             "CURSOR =" i strt_col;
             Call Save_Repeat_Process;
             Return (0);
           End;
       When opt.1 = "GT" Then;
         If tgt_string > src_string Then;
           Do;
             "LOCATE" i;
             "CURSOR =" i strt_col;
             Call Save_Repeat_Process;
             Return (0);
           End;
       When opt.1 = "EQ" Then;
         If tgt_string = src_string Then;
           Do;
             "LOCATE" i;
             "CURSOR =" i strt_col;
             Call Save_Repeat_Process;
             Return (0);
           End;
       When opt.1 = "LE" Then;
         If tgt_string <= src_string Then;
           Do;
             "LOCATE" i;
             "CURSOR =" i strt_col;
             Call Save_Repeat_Process;
             Return (0);
           End;
       When opt.1 = "LT" Then;
         If tgt_string < src_string Then;
           Do;
             "LOCATE" i;
             "CURSOR =" i strt_col;
             Call Save_Repeat_Process;
             Return (0);
           End;
       When opt.1 = "NE" Then;
         If tgt_string <> src_string Then;
           Do;
             "LOCATE" i;
             "CURSOR =" i strt_col;
             Call Save_Repeat_Process;
             Return (0);
           End;
       Otherwise;
         Signal Error_INVALID_COND;
     End;
   End;

   Signal Warn_BEYOND_SCOPE;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2 || " " || parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   Extract_Options:

   Upper parm3;
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When var.3 = "GE" | var.3 = "GT" | var.3 = "EQ" ,
            | var.3 = "LE" | var.3 = "LT" | var.3 = "NE" Then;
         opt.1 = var.3;
       When ABBREV("CLEAR",var.3) Then;
         opt.2 = "CLEAR";
       When ABBREV("SAVE",var.3) Then;
         opt.2 = "SAVE";
       Otherwise;
         Signal Error_INVALID_OPTION;
     End;
   End;

   Return (0);

   Init_Repeat_Process:

   Address ISPEXEC "VGET (RINP@@) PROFILE";
   If RC <> 0 Then;
     Signal Error_NO_REPEAT_INPUT;
   parm2 = rinp@@;

   "(krow,kcol) = CURSOR";
   krow = krow + 1;
   If krow > trgt_row_eof Then;
     Signal Warn_BEYOND_SCOPE;

   "CURSOR =" krow kcol;
   "LOCATE" krow;

   Return (0);

   Save_Repeat_Process:

   Select;
     When opt.2 = "CLEAR" Then;
       Do;
         rcmd@@ = "";
         Address ISPEXEC "VPUT (RCMD@@) PROFILE";
         rinp@@ = "";
         Address ISPEXEC "VPUT (RINP@@) PROFILE";
       End;
     When opt.2 = "SAVE" Then;
       Do;
         rcmd@@ = "FALT";
         Address ISPEXEC "VPUT (RCMD@@) PROFILE";
         rinp@@ = parm9;
         Address ISPEXEC "VPUT (RINP@@) PROFILE";
       End;
     Otherwise;
       Nop;
   End;

   ZEDSMSG = opt.1 "FOUND";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Find a value in strt_col thru end_col that matches",
        pad hex04,
        "         the string via stated condition.",
        pad hex04,
        " Format: FALT target|range  strt_col end_col string",
        pad hex04,
        "         < ( GE | GT | EQ | LE | LT | NE < CLEAR | SAVE > >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_NO_REPEAT_INPUT:

   ZEDSMSG = "NO REPEAT INP";
   ZEDLMSG = "No REPEAT input available"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_COND:

   ZEDSMSG = "INVALID COND";
   ZEDLMSG = "Invalid/missing condition ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_OPTION:

   ZEDSMSG = "INVALID OPTION";
   ZEDLMSG = "Invalid/missing option ("parm3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_PARM:

   ZEDSMSG = "INVALID PARM";
   ZEDLMSG = "Invalid/missing parameter ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_MISSING_STRING:

   ZEDSMSG = "MISSING STRING";
   ZEDLMSG = "Missing string";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Warn_BEYOND_SCOPE:

   ZEDSMSG = "NOT FOUND";
   ZEDLMSG = "Not found, reached the end of scope";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Return (4);
./ ADD NAME=FINDDSN  0109-15236-16190-1029-00346-00001-00000-APLKS   39
/* REXX 2016-07-08 CBT #624 */
/* FIND a Dataset - using volid mask as search criterion */
/*                  "*" searches ALL DASD volumes        */
msg_status = MSG('OFF')
myid=SYSVAR(SYSUID)
execnme = 'FINDDSN'
sysindsn = myid || "." || execnme || ".SYSIN"
sysprintdsn = myid || "." || execnme || ".SYSPRINT"
dcoutdsn = myid || "." || execnme || ".DCOUT"
reportdsn = myid || "." || execnme || ".REPORT"
errorsdsn = myid || "." || execnme || ".UCB.ERRORS"
volsersdsn = myid || "." || execnme || ".UCB.VOLSERS"
parse upper arg dsn vol
volx=1
mydate=date('U')
mytime=time()
CVTSNAME   = D2X(C2d(Storage(10,4)) + 340)      /* Point to CVTSNAME */
Sysid      = strip(Storage(CVTSNAME,8))         /* SYSID             */
cylpri=20                                       /* rpt file size-pri */
cylsec=20                                       /* rpt file size-sec */
/*================ M A I N L I N E ======================*/
call getargs           /* secure dsname/volid mask       */
call cleanup           /* cleanup temp datasets          */
call allocate          /* allocate DCOLLECT ds's         */
call bldinput          /* build DCOLLECT input stmnts    */
call dcollect          /* execute DCOLLECT               */
call scan              /* read DCOLLECT output           */
call bldoutput         /* build volser output            */
call view              /* view report                    */
call cleanup2          /* cleanup temp datasets          */
call goodbye           /* issue parting message          */
exit
/*=================S U B R O T I N E S ==================*/
/*================ OBTAIN DSNAME AND VOLID MASK =========*/
GETARGS:
  maskdsn=strip(dsn,b," ")
  maskdsn=strip(maskdsn,b,"'")
  if maskdsn <> '' then
    do
      if maskdsn = '?' then
        signal showucbs
      x=SYSDSN(dsn)
      if pos('INVALID',x) <> 0 then
        do
          say 'Dsname invalid ...'
          dsn = ''
        end
    end
  if dsn = '' then
    do forever
      say 'Enter Dataset name to search (1-44 chars), partial is OK'
      parse upper pull dsn
      maskdsn=strip(dsn,b," ")
      maskdsn=strip(maskdsn,b,"'")
      if maskdsn = '?' then
        signal showucbs
      x=SYSDSN(maskdsn)
      if pos('INVALID',x) <> 0 then
        iterate
      else
        leave
    end
  if vol = '' then
    do forever
     say 'Enter VOL mask (1-6 chars), partial is OK ("*" for ALL DASD)'
      parse upper pull vol
      maskvol=strip(vol,b," ")
      if maskvol <> '' then
          leave
    end
  else
    maskvol=vol
  dsnlen=length(maskdsn)
  vollen=length(maskvol)
  maskvol2=maskvol
  if maskvol <> '*' then
    if vollen < 6 then
      maskvol2=maskvol||'*'
  if maskvol2='*' then
    do forever
      say 'You are asking to search ALL volumes. Are you sure ? (Y/N)'
      parse upper pull YN
      if YN <> 'N' then
        if YN <> 'Y' then
          do
            say '-- RESPONSE invalid --'
            say ' '
            iterate
          end
      if yn = 'N' then
        do
          call cleanup
          call goodbye
          exit
        end
      else
        do
          cylpri=200   /* enlarge rpt size when asking for all dasd */
          cylsec=200
          leave
        end
    end
return
/* =================== ALLOCATE DCOLLECT DS =======================*/
ALLOCATE:
  ADDRESS TSO
  "ALLOC F(SYSIN) DA('"sysindsn"') SPACE(1,1) TRACKS NEW
         CATALOG REUSE RECFM(F) BLKSIZE(80) UNIT(SYSALLDA)"
  if rc <> 0 then
    do
      say DCOLLECT SYSIN ' NOT ALLOCATED .... Check error'
      say 'dataset : 'sysindsn
      call cleanup
      exit
    end
  "ALLOC F(SYSPRINT) DA('"sysprintdsn"') SPACE(2,1) CYLINDERS
     NEW CATALOG REUSE RECFM(F) BLKSIZE(133) UNIT(SYSALLDA)"
  if RC <> 0 then
    do
      say 'DCOLLECT SYSPRINT dataset allocation error !'
      say 'dataset : 'sysprintdsn
      call cleanup
      exit
    end
  "ALLOC F(DCOUT) DA('"dcoutdsn"') SPACE("cylpri","cylsec")
     cylinders NEW CATALOG REUSE RECFM(V,B) LRECL(768) BLKSIZE(27998)
     UNIT(SYSALLDA)"
  if RC <> 0 then
    do
      say 'DCOLLECT OUTPUT dataset allocation error !'
      say 'dataset : 'dcoutdsn
      call cleanup
      exit
    end
  "ALLOC F(REPORT) DA('"reportdsn"') SPACE(1,1) CYLINDERS
     NEW CATALOG REUSE RECFM(F,B) LRECL(80) BLKSIZE(7200)
     UNIT(SYSALLDA)"
  if RC <> 0 then
    do
      say 'REPORT OUTPUT dataset allocation error !'
      say 'dataset : 'reportdsn
      call cleanup
      exit
    end
return
/* =================== BUILD/WRITE DCOLLECT INPUT =================*/
BLDINPUT:
  d.1 ='  DCOLLECT -'
  d.2 ='       OUTFILE(DCOUT) -'
  d.3 ='       VOLUMES( -'
  d.4 ='               ' maskvol2 ' -'
  d.5 ='               )'
  "EXECIO * DISKW SYSIN (STEM d. FINIS"
return
/* =================== EXEC DCOLLECT ==============================*/
DCOLLECT:
  ADDRESS TSO "CALL 'SYS1.LINKLIB(IDCAMS)'"
  if RC > 4 then
    do
      say 'DCOLLECT error ! RC='rc
      "ISPEXEC BROWSE DATASET('"sysprintdsn"')"
      call cleanup
      exit
    end
return
/* =================== SCAN DCOLLECT OUTPUT =======================*/
SCAN:
  vl=1
  #vols=0
  rc=0
  say ' S C A N N I N G . . .'
  say ' P l e a s e   W a i t'
  do while RC=0
    "EXECIO 1 DISKR DCOUT"
    if rc <> 0 then
      do
        "EXECIO 0 DISKR DCOUT (FINIS"
        leave
      end
    PULL RECORD
    if substr(RECORD,5,1)   = 'V' then
      do
        hotvol=substr(RECORD,25,6)
        #vols=#vols+1
        call storvols
        iterate
      end
    if substr(RECORD,5,1)  = 'D'  then
      if substr(RECORD,25,dsnlen) = maskdsn then
        do
          hotdsn=substr(record,25,44)
          rec.vl=hotvol||hotdsn
          vl=vl+1
        end
  end
return
/* =================== Store VOLIDS ===============================*/
STORVOLS:
  do x=1 to volx by 1
    if voltb.volx = hotvol then return
  end
  do
    voltb.volx=hotvol
    volx=volx+1
  end
  return
/* =================== BUILD FINAL OUTPUT =========================*/
BLDOUTPUT:
  if vl=1 then
    do
      say '*========================================================'
      say '* NO hits for :'
      say '*              DSN ='dsn
      say '*              MASK='vol
      say '*========================================================'
      say 'Do you wish to see ALL AVAIL VOLSERS in the system ? (Y/N)'
      do forever
        parse upper pull YN
        if YN <> 'Y' then
        if YN <> 'N' then
          do
            say '-- RESPONSE invalid --'
            say ' '
            iterate
          end
        if yn = 'Y' then
          do
            call showucbs  /* ucb scan/display */
            return
          end
        call cleanup
        exit
      end
    end
/*=========*/
  pt.1 = '**************************************************************'
  pt.2 = '* -'Sysid'-                                   'mydate'  'mytime
  pt.3 = '* Search target  : 'dsn
  pt.4 = '* Search mask    : 'vol
  pt.5 = '**************************************************************'
  pt.6 = ' '
  ptx=6
  voltbx=1
  totvols=#vols
  #lines=#vols/6
  #lines=format(#lines,4,0)
  if #lines = 0 then #lines = 1
  sfx='Volumes Searched : '
  do x = 1 to #lines by 1        /* outer */
    vlx=#vols-6
    if vlx < 1 then
      vlx=#vols
    else
      vlx=6
    do y = 1 to vlx by 1        /* inner */
      sfx=sfx || substr(voltb.voltbx,1,6) || ' '
      voltbx=voltbx+1
    end
    ptx=ptx+1
    pt.ptx=sfx
    sfx='                   '
    #vols=#vols-6
  end
  ptx=ptx+1
  pt.ptx = ' '
  ptx=ptx+1
  pt.ptx = 'NO. Dataset Hits : 'vl-1
  ptx=ptx+1
  pt.ptx = 'NO. Vols Scanned : 'totvols
  ptx=ptx+1
  pt.ptx = ' '
  ptx=ptx+1
  pt.ptx = 'VOLUME  CTLGD ?  DSNAME'
  ptx=ptx+1
  pt.ptx = '------  -------  ------'
  rp=ptx
  vl=vl-1
  do x1=1 to vl by 1
    ptvol=substr(rec.x1,1,6)
    ptdsn=strip(substr(rec.x1,7,44))
    ptdsn="'"||ptdsn
    ptdsn=ptdsn||"'"
    rc=listdsi(ptdsn)
    if sysreason = 0 then
      ptcat='  Y    '
    else
      ptcat='  N    '
    rp=rp+1
    pt.rp = ptvol  ' ' ptcat   ptdsn
  end
return
/* =================== VIEW Report ================================*/
VIEW:
  address TSO
  'EXECIO  *  DISKW REPORT (STEM pt. FINIS)'
  "ISPEXEC VIEW DATASET('"reportdsn"')"
return
/* =================== CLEANUP FILES ==============================*/
CLEANUP:
  address TSO
  "FREE FI(SYSIN,SYSPRINT,DCOUT,REPORT)"
  "DELETE ('"sysindsn"')"
  "DELETE ('"sysprintdsn"')"
  "DELETE ('"dcoutdsn"')"
  "DELETE ('"reportdsn"')"
return
/* =================== CLEANUP FILES (minus report) ===============*/
CLEANUP2:
  address TSO
  "FREE FI(SYSIN,SYSPRINT,DCOUT,REPORT)"
  "DELETE ('"sysindsn"')"
  "DELETE ('"sysprintdsn"')"
  "DELETE ('"dcoutdsn"')"
return
/* =================== CLEANUP FILES ==============================*/
GOODBYE:
/* say ' '
   say ' '
   say '***'
   say 'REXX Complete' */
return
/* /////////////////////////////////////////////////////////////// */
/* /////////////////////////////////////////////////////////////// */
SHOWUCBS:
  /* Display all dasd volids */
  address ispexec
  ADDRESS TSO
    "FREE FI(ERRORS,VOLSERS)"
    "DELETE ('"errorsdsn"')"
    "DELETE ('"volsersdsn"')"
    "ALLOC FI(ERRORS) DA('"errorsdsn"') NEW CATALOG
           SPACE(1,1) TRACKS RECFM(F) BLKSIZE(80)"
    "ALLOC FI(VOLSERS) DA('"volsersdsn"') NEW CATALOG
           SPACE(2,1) TRACKS RECFM(F) BLKSIZE(80)"
/*=================== P O S S I B L E  C H A N G E ===========================*/
  ADDRESS LINKPGM "TSOUCB"  /* use this if TSOUCB in LINKLIST*/
/*ADDRESS TSO "CALL 'Your.LOADLIB(TSOUCB)'" use this if TSOUCB not in linklist*/
/*=================== P O S S I B L E  C H A N G E ===========================*/
  if rc = 0 then
    "ISPEXEC BROWSE DATASET('"volsersdsn"')"
  else
    "ISPEXEC BROWSE DATASET('"errorsdsn"')"
  "DELETE ('"errorsdsn"')"
  "DELETE ('"volsersdsn"')"
  "FREE FI(VOLSERS,ERRORS)"
exit
./ ADD NAME=FINDMBR  0116-02137-17136-1320-00334-00054-00000-APLKS   25
/* REXX 2017-05-16 */
/* --------------------------------------------------------- */
/* Purpose: Extract the data set names displayed on the      */
/*          TSO 3.4 DSLIST PANEL and search the PDS/PDSE(s)  */
/*          for member name(s) matching the input pattern.   */
/*                                                           */
/*          This is an undocumented IBM interface that was   */
/*          discovered by Gilbert Saint-Flour.  I have       */
/*          liberally pilfered logic from both he and Doug   */
/*          Nadel.  I have also chosen to implement some of  */
/*          the addressing methods of John Kalinich.         */
/*                                                           */
/*  Author: LKS 2016-02-18                                   */
/*                                                           */
/*      Op: This procedure must be invoked from the DSLIST   */
/*          screen, as a TSO command, such as TSO %findmbr.  */
/*          To get all of the ISPF table fields populated,   */
/*          you must scroll to the bottom of DSLIST (if      */
/*          longer than a page) and you must scroll left.    */
/*                                                           */
/*  Format: FINDMBR mbrpattern                               */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC FINDMBR */

   Address ISPEXEC;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   Address ISPEXEC "VGET (ZPANELID) SHARED";
   If zpanelid <> "ISRUDSL0" Then
     Signal Error_ON_ERROR;

/* Signal ON ERROR NAME Error_ON_ERROR;  */
   Signal ON FAILURE NAME Error_ON_FAILURE;
/* Signal ON NOVALUE NAME Error_NO_VALUE; */

   /* Initialize Variables */

   cnt = 0;
   max_cnt = 0;
   mbr = " ";                 /*returned value*/

   /* Parse User Passed Parms */

   If parm2 = "" Then;
     Signal Error_NO_MBRPATTERN;
   Else;
     mbrpattern = Word(parm2,1);

   /* Mainline */

   Call GET_DSL;

   /* --------------------- */
   /* Scan the DSLIST table */
   /* --------------------- */

   Do i=1 To rownum By +1;    /*read all the table entries*/
     "TBSKIP" dsltblnm;       /*next row*/
     If RC <> 0 Then;
       Leave;
     If zudxstat = "Y" Then;  /*row has been excluded*/
       Iterate;
     If zudvol = "MIGRAT" Then;
       Iterate;
     If Substr(zudvol,1,1) = "*" Then;
       Iterate;
     If Substr(zuorg,1,2) <> "PO" Then;
       Iterate;
     "LMINIT DATAID("srcid") DATASET("zudsns") ENQ(SHR)";
     EC = RC;
     If RC <> 0 Then;
       Signal Error_LMINIT_FAILED;
     "LMOPEN DATAID("srcid") OPTION(INPUT)"; /* OPEN THE DS */
     EC = RC;
     If RC <> 0 Then;
       Signal Error_LMOPEN_FAILED;
     mbr = " ";
     cnt = 0;
     EC = 0;
     If Pos("*",mbrpattern) > 0 | Pos("%",mbrpattern) > 0 Then;
       Do While EC = 0;
         "LMMLIST DATAID("srcid") MEMBER("mbr")",
              " PATTERN("mbrpattern") OPTION(LIST)";
         EC = RC;
         If RC = 0 Then;
           cnt = cnt + 1;
       End;
     Else;
       Do;
         "LMMFIND DATAID("srcid") MEMBER("mbrpattern")";
         EC = RC;
         If RC = 0 Then;
           cnt = cnt + 1;
       End;
     If EC > 8 Then;
       Signal Error_LMMLIST_FAILED;
     If cnt > 0 Then;
       Do;
         zulmsg = "07"X||cnt "Hits";    /* SET MESSAGE */
         "TBPUT " dsltblnm;             /* UPDATE THE TABLE */
         EC = RC;
         If RC <> 0 Then;
           Signal Error_TBPUT_FAILED;
         max_cnt = max_cnt + cnt;
       End;
     "LMFREE DATAID("srcid")";     /* FREE THE ALLOCATION */
     EC = RC;
     If RC <> 0 Then;
       Signal Error_LMFREE_FAILED;
     Drop srcid;
   End;

   "CONTROL NONDISPL ENTER"        /* FORCE REFRESH */

   ZEDSMSG = max_cnt "Hits for" mbrpattern;
   ZEDLMSG = "Found" max_cnt "occurrences of" mbrpattern;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";

   Return (0);

   /* ----------------------------------- */
   /* Routine to extract the DSLIST table */
   /* ----------------------------------- */

   GET_DSL:

   Numeric Digits 10;         /* Required for 31-bit addresses */
   pca_ptr = 0;
   tcb_ptr = get_ptr(pca_ptr,'21c');    /*TCB (EXEC cmd) PSATOLD*/
   tcb_ptr = get_ptr(tcb_ptr,'84');     /*TCB (ISPTASK) TCBOTC*/
   rsa_ptr = get_ptr(tcb_ptr,'70');     /*1st RSA TCBFSA*/
   R1_rsa_ptr = get_ptr(rsa_ptr,'18');  /*ISPTASK's R1*/
   tld_ptr = get_ptr(R1_rsa_ptr,'00');  /*TLD addr*/
   dta_ptr = get_ptr(tld_ptr,'4c');     /*DTA addr*/
   dsltblnm = get_data(dta_ptr,'0c',8); /*DSL tbl name*/

   If Substr(dsltblnm,1,3) <> "DSL" Then;
     Signal Error_NO_VALUE;

   Address ISPEXEC "TBQUERY" dsltblnm,
        " KEYS(KEYS) NAMES(NAMES) NAMENUM(NAMENUM)",
        " ROWNUM(ROWNUM) KEYNUM(KEYNUM)",
        " POSITION(CRP)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TBQUERY_FAILED;

   Address ISPEXEC "TBTOP" dsltblnm;    /*start from the top*/
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TBTOP_FAILED;

   rownum = Strip(rownum,'L','0');

/* Signal LIST; */

   Return;

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

   get_ptr: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset;
   temp = d2x(x2d(addr) + x2d(offset));
   return c2x(storage(temp,4));
   exit;

   get_data: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset, length;
   temp = d2x(x2d(addr) + x2d(offset));
   return storage(temp,length);
   exit;

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Find member name(s) in the DSLIST.",
        pad hex04,
        " Format: FINDMBR mbrpattern ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ON_ERROR:
   Error_ON_FAILURE:
   Error_NO_VALUE:

   ZEDSMSG = "ERROR";
   ZEDLMSG = "ON INVALID PANEL, OR POPULATE TABLE,",
             "MAX TO BOTTOM AND LEFT 1 PANEL";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_TBQUERY_FAILED:

   ZEDSMSG = "TBQUERY FAILED";
   ZEDLMSG = "TBQUERY SERVICE FAILED WITH RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_NO_MBRPATTERN:

   ZEDSMSG = "NO MBR PATTERN";
   ZEDLMSG = "No member name / pattern provided";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_TBTOP_FAILED:

   ZEDSMSG = "TBTOP FAILED";
   ZEDLMSG = "TBTOP failed RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_LMINIT_FAILED:

   ZEDSMSG = "LMINIT FAILED";
   ZEDLMSG = "LMINIT failed RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_LMOPEN_FAILED:

   ZEDSMSG = "LMOPEN FAILED";
   ZEDLMSG = "LMOPEN failed RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_LMMLIST_FAILED:

   ZEDSMSG = "LMMLIST FAILED";
   ZEDLMSG = "LMMLIST failed RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_TBPUT_FAILED:

   ZEDSMSG = "TBPUT FAILED";
   ZEDLMSG = "TBPUT failed RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_LMFREE_FAILED:

   ZEDSMSG = "LMFREE FAILED";
   ZEDLMSG = "LMFREE failed RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   /* ---------------------------------- */
   /* Variables (for documentation only) */
   /* ---------------------------------- */

   LIST:

   Say "KEYS="keys "NAMES="names "NAMENUM="namenum;
   Say "ROWNUM="rownum "KEYNUM="keynum "POSITION="crp;
   Do i=1 To rownum By +1;
     Address ISPEXEC "TBSKIP" dsltblnm;
     Say " ";
     Say Left("ROW",8) "=" i;
     Do j=1 To namenum By +1;
       name = Strip(Strip(Word(names,j),"L","("),"T",")");
       Say Left(name,8) "=" Value(name);
     End;
   End;

   Exit;

  1zudsns   3zusize   3zuus     5zucdate  5zuedate  5zurdate
  2zudvol    zudmvol  3zudevice  zucdat2   zuedat2   zurdat2
  4zuorg    3zux      4zurecfm  4zulrecl  4zublksiz  zustat
   zudspacu  zulmsg    zulocvol #zuobtatt #zuobtspc #zuobtdat
  #zudxstat  zulcmdl   zud20v    zudvol7  6zucatnam  zusizex
   zuxx      zuovf     zugflag   zueatr    zucjobn   zucstpn

  Where:
   1 - dsname   (dsname)
   2 - volinfo  (volser)
   3 - spcinfo  (tracks used% extents device)
   4 - attrinfo (dsorg recfm lrecl blksize)
   5 - dateinfo (creation expiration reference)
   6 - catname  (catname)
   # - flags used
./ ADD NAME=FMAX     0107-16035-16236-1744-00252-00399-00000-APLKS   52
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Find the maximum value within strt_col and       */
/*          end_col.                                         */
/*                                                           */
/*  Format: FMAX    target | range                           */
/*                  strt_col end_col                         */
/*                  < ( options >                            */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  row on the screen or the row that the    */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        strt_col: start column of the text                 */
/*         end_col: end column of the text                   */
/*         options: (N/A)                                    */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC FMAX */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   opt. = "";            /*1= 2=*/
   strt_col = 0;         /*col-1*/
   end_col = 0;          /*col-2*/
   tgt_string = "";      /*defined by col-1 col-2*/
   tgt_len = 0;

   "(lrecl) = LRECL";

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Parse Target */

   Call Extract_Target;

   /* Parse the Required EXEC Parameters */

   Do While parm2 <> "";
     parm2 = Strip(parm2,"B");
     Parse VAR parm2 var.3 parm2;
     If var.3 = "" Then;
       Iterate;
     If Datatype(var.3,"W") Then;
       Do;
         strt_col = var.3;
         If strt_col > lrecl Then;
           Signal Error_INVALID_PARM;
         Parse VAR parm2 var.3 parm2;
         If var.3 = "" Then;
           Signal Error_INVALID_PARM;
         If Datatype(var.3,"W") Then;
           end_col = var.3;
         Else;
           Signal Error_INVALID_PARM;
         If end_col > lrecl Then;
           Signal Error_INVALID_PARM;
         tgt_len = end_col - strt_col + 1;
         If tgt_len > lrecl Then;
           Signal Error_INVALID_PARM;
       End;
   End;

   largest_value = Copies('00'x,tgt_len);
   largest_row = 0;

   /* Mainline */

   Do i = trgt_row_from To trgt_row_to By 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     tgt_string = Substr(row,strt_col,tgt_len);
     If tgt_string < largest_value Then;
       Iterate;
     largest_value = tgt_string;
     largest_row = i;
   End;

   "LOCATE" largest_row;
   "CURSOR =" largest_row strt_col;

   ZEDSMSG = "MAX FOUND";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2 || " " || parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   Extract_Options:

/* Upper parm3;
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When ABBREV("CLEAR",var.3) Then;
         opt.2 = "CLEAR";
       Otherwise;
         Signal Error_INVALID_OPTION;
     End;
   End;  */

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Find the maximum value within strt_col and end_col.",
        pad hex04,
        " Format: FMAX target|range  strt_col end_col";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_OPTION:

   ZEDSMSG = "INVALID OPTION";
   ZEDLMSG = "Invalid/missing option ("parm3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_PARM:

   ZEDSMSG = "INVALID PARM";
   ZEDLMSG = "Invalid/missing parameter ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=FMIN     0105-16035-16236-1744-00252-00256-00000-APLKS   21
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Find the minimal value within strt_col and       */
/*          end_col.                                         */
/*                                                           */
/*  Format: FMIN    target | range                           */
/*                  strt_col end_col                         */
/*                  < ( options >                            */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  row on the screen or the row that the    */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        strt_col: start column of the text                 */
/*         end_col: end column of the text                   */
/*         options: (N/A)                                    */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC FMIN */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   opt. = "";            /*1= 2=*/
   strt_col = 0;         /*col-1*/
   end_col = 0;          /*col-2*/
   tgt_string = "";      /*defined by col-1 col-2*/
   tgt_len = 0;

   "(lrecl) = LRECL";

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Parse Target */

   Call Extract_Target;

   /* Parse the Required EXEC Parameters */

   Do While parm2 <> "";
     parm2 = Strip(parm2,"B");
     Parse VAR parm2 var.3 parm2;
     If var.3 = "" Then;
       Iterate;
     If Datatype(var.3,"W") Then;
       Do;
         strt_col = var.3;
         If strt_col > lrecl Then;
           Signal Error_INVALID_PARM;
         Parse VAR parm2 var.3 parm2;
         If var.3 = "" Then;
           Signal Error_INVALID_PARM;
         If Datatype(var.3,"W") Then;
           end_col = var.3;
         Else;
           Signal Error_INVALID_PARM;
         If end_col > lrecl Then;
           Signal Error_INVALID_PARM;
         tgt_len = end_col - strt_col + 1;
         If tgt_len > lrecl Then;
           Signal Error_INVALID_PARM;
       End;
   End;

   smallest_value = Copies('FF'x,tgt_len);
   smallest_row = 0;

   /* Mainline */

   Do i = trgt_row_from To trgt_row_to By 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     tgt_string = Substr(row,strt_col,tgt_len);
     If tgt_string > smallest_value Then;
       Iterate;
     smallest_value = tgt_string;
     smallest_row = i;
   End;

   "LOCATE" smallest_row;
   "CURSOR =" smallest_row strt_col;

   ZEDSMSG = "MIN FOUND";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2 || " " || parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   Extract_Options:

/* Upper parm3;
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When ABBREV("CLEAR",var.3) Then;
         opt.2 = "CLEAR";
       Otherwise;
         Signal Error_INVALID_OPTION;
     End;
   End;  */

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Find the minimal value within strt_col and end_col.",
        pad hex04,
        " Format: FMIN target|range  strt_col end_col";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_OPTION:

   ZEDSMSG = "INVALID OPTION";
   ZEDLMSG = "Invalid/missing option ("parm3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_PARM:

   ZEDSMSG = "INVALID PARM";
   ZEDLMSG = "Invalid/missing parameter ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=FPASTE   0123-14134-16034-1528-00280-00175-00000-APLKS   29
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: FPASTE  Paste the contents of the clipboard      */
/*                  AFTER or BEFORE each occurance of the    */
/*                  string.                                  */
/*                                                           */
/*  Format: FPASTE  <range>  string                          */
/*                  < ( options >                            */
/*                                                           */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels.                                  */
/*          string: any string enclosed in apostrophes or    */
/*                  quotes.  The string is used to determine */
/*                  where to insert the rows from the        */
/*                  clipboard.                               */
/*                                                           */
/*         options: (default) AFTER KEEP                     */
/*                  AFTER | BEFORE                           */
/*                  DELETE | KEEP                            */
/*                  clipboard                                */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC FPASTE */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   opt. = "";       /* 1=AFTER|BEFORE 2=DELETE|KEEP 3=clipboard*/
   trgt_row_from = "";
   trgt_row_to = "";
   find_string = "";
   chg_cnt = 0;               /*nbr of finds*/

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;

   Call Extract_Options;
   If opt.1 = "" Then;
     opt.1 = "AFTER";
   If opt.2 = "" Then;
     opt.2= "KEEP";

   /* Parse Range and User passed Parms */

   Call Extract_Range;

   If var.1 = "" Then;
     var.1 = ".ZFIRST";
   If var.2 = "" Then;
     var.2 = ".ZLAST";

   /* Parse the Required (find_string) EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       parm2 = Strip(parm2,"B");
       Select;
         When Substr(parm2,1,1) = "'" Then;
           Parse VAR parm2 "'" find_string "'" parm2;
         When Substr(parm2,1,1) = '"' Then;
           Parse VAR parm2 '"' find_string '"' parm2;
         When Substr(parm2,1,2) = "x'" | Substr(parm2,1,2) = "X'" Then;
           Do;
             Parse VAR parm2 "'" find_string "'" parm2;
             find_string = X2C(find_string);
           End;
         Otherwise;
           Parse VAR parm2 find_string parm2;
       End;
     End;
   Else;
     Signal Error_MISSING_STRING;

   /* Do the Job */

   Select;
     When opt.1 = "AFTER" Then;
       "SEEK '"find_string"'" trgt_row_from trgt_row_to " LAST NX ";
     When opt.1 = "BEFORE" Then;
       "SEEK '"find_string"'" trgt_row_from trgt_row_to " FIRST NX ";
     Otherwise;
       Nop;
   End;
   If RC <> 0 Then;
     Signal Error_STRING_NOTFND;

   EC = RC;
   Do While EC = 0;
     "(irow,icol) = CURSOR";
     Select;
       When opt.1 = "AFTER" Then;
         Do;
           "BUILTIN PASTE "opt.1 ".ZCSR" opt.2 opt.3;
           chg_cnt = chg_cnt + 1;
           "SEEK '"find_string"'" trgt_row_from trgt_row_to " PREV NX ";
         End;
       When opt.1 = "BEFORE" Then;
         Do;
           "BUILTIN PASTE "opt.1 ".ZCSR" opt.2 opt.3;
           chg_cnt = chg_cnt + 1;
           "SEEK '"find_string"'" trgt_row_from trgt_row_to " NEXT NX ";
         End;
       Otherwise;
         Nop;
     End;
     EC = RC;
   End;

   If trgt_row_from <> "" Then;
     "LOCATE" trgt_row_from;

   ZEDSMSG = Strip(chg_cnt,"L","0") "PASTEs";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Range:

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "." Then;
       Do;
         trgt_row_to = var.1;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               trgt_row_from = trgt_row_to;
               trgt_row_to = var.2;
             End;
           Else;
             Signal Error_INVALID_RANGE;
       End;
     When Substr(var.1,1,1) = "'" | Substr(var.1,1,1) = '"' | ,
          Substr(var.1,1,2) = "x'" | Substr(var.1,1,2) = "X'" Then;
       Do;
         /*place quoted string back in parm2*/
         parm2 = parm2 || " " | var.1;
         If loop <> "Y" Then;
           Do;
             loop = "Y";
             Signal Extract_Range;
           End;
       End;
     Otherwise;
       Do;
         /*place string back in parm2*/
         parm2 = parm2 || " " || Translate(var.1);
         If loop <> "Y" Then;
           Do;
             loop = "Y";
             Signal Extract_Range;
           End;
         Else;
           var.1 = "";
       End;
   End;

   If (var.1 = "" & var.2 = "") | (var.1 <> "" & var.2 <> "") Then;
     Nop;
   Else;
     Signal Error_INVALID_RANGE;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Upper var.3;
     Select;
       When Abbrev("AFTER",var.3) Then;
         opt.1 = "AFTER";
       When Abbrev("BEFORE",var.3) Then;
         opt.1 = "BEFORE";
       When Abbrev("DELETE",var.3) Then;
         opt.2 = "DELETE";
       When Abbrev("KEEP",var.3) Then;
         opt.2 = "KEEP";
       Otherwise;
         opt.3 = var.3;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Pastes the contents of the clipboard AFTER or BEFORE",
        pad hex04,
        "         each occurrence of the string.",
        pad hex04,
        " Format: FPASTE <range>  string",
        pad hex04,
        "                < ( <AFTER | BEFORE> ",
        pad hex04,
        "                <DELETE | KEEP>";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_RANGE:

   ZEDSMSG = "INVALID RANGE";
   ZEDLMSG = "Range is not a valid set of labels"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_MISSING_STRING:

   ZEDSMSG = "MISSING STRING";
   ZEDLMSG = "Missing find string";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_STRING_NOTFND:

   ZEDSMSG = "NOT FOUND";
   ZEDLMSG = "String not found";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_PASTE_FAILED:

   ZEDSMSG = "FAILED";
   ZEDLMSG = "PASTE failed with RC="RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=GDG2GDS  0104-16007-16039-0847-00197-00204-00000-APLKS   43
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Display the Generation Data Set (GDS) name       */
/*          related to the Generation Data Group (GDG)       */
/*          being pointed to by target.                      */
/*                                                           */
/*  Format: GDG2GDS target                                   */
/*                                                           */
/*          target: is the row to retrieve                   */
/*                  can be any valid label                   */
/*                  the row that the cursor is on            */
/*                  variable names are trgt_row              */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC GDG2GDS */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   the_string = "";
   var. = "";
   ptr = 0;

   "(bndslo,bndshi) = BOUNDS";

   /* Parse the User Options */

   /* Parse Target and User Passed Parms */

   Call Extract_TARGET;

   /* Main line code */

   "(row) = LINE" trgt_row;
   the_string = Strip(Strip(Substr(row,bndslo,(bndshi-bndslo-1)),"B"));
   ptr = Pos("DSN=",the_string);
   If ptr = 0 Then;
     Signal Error_INVALID_DATASET;
   ptr = ptr+4;
   the_string = Substr(the_string,ptr);
   ptr = Pos(",",the_string);
   If ptr <> 0 Then;
     Do;
       ptr = ptr-1;
       the_string = Substr(the_string,1,ptr);
     End;
   Else
     Do;
       ptr = Pos(" ",the_string);
       If ptr <> 0 Then;
         Do;
           ptr = ptr-1;
           the_string = Substr(the_string,1,ptr);
         End;
     End;

   ptr = Pos("(",the_string);
   If ptr <> 0 Then;
     Do;
       Parse VAR the_string . "(" gdgmbr ")" . ;
       If Datatype(gdgmbr,"W") Then;
         the_string = Fulldsn(the_string);
       Else;
         Signal Error_INVALID_DATASET;
     End;

   the_string = Strip(the_string);
   x = SYSDSN(the_string);
   If x <> "OK" Then;
     Signal Error_INVALID_DATASET;

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "GDG("gdgmbr") GDS: "the_string;
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";

   Return(0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Extract_TARGET:

   /* Resolve trgt_row and trgt_col Variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row = krow;
       trgt_col = kcol;
     End;
   Else;
     trgt_row = frow;

   Parse VAR parm2 var.1 parm2;
   If var.1 <> "" Then;
     Select;
       When Substr(var.1,1,1) = "." Then;
         Do;
           "(linenbr) = LINENUM" var.1;
           trgt_row = linenbr;
         End;
       When Datatype(var.1,"W") Then;
         trgt_row = var.1;
       Otherwise;
         Signal Error_INVALID_TARGET;
     End;

   Return(0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Present the resolved data set name being pointed to.",
        pad hex04,
        " Format: GDG2GDS target ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_DATASET:

   ZEDSMSG = "INVALID GDS";
   ZEDLMSG = "Invalid GDS ("the_string")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return(-16);
./ ADD NAME=GMT      0104-04167-19270-1431-00028-00009-00000-APLKS   53
/* REXX 2019-02-26 */
/* REXX function or TSO command
   Invoke as: GMT()
          or: TSO GMT

   Return the local offset from GMT.
   Copied from CBT #357. Converted to a function.
   ----------------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   CVT   = STORAGE(10,4);        /*GET THE CVT ADDRESS*/
   CVTTZ = STORAGE(D2X(C2D(CVT)+X2D(130)),4); /*GET CVTTZ VALUE*/
   GMT_OFFSET = TRUNC(C2D(CVTTZ,4) * 1.048576 / 3600);

   IF SIGN(GMT_OFFSET) < 0 THEN;
     GMT_SIGN = '-';
   ELSE;
     GMT_SIGN = '+';

   GMT_OFFSET_HHMM = GMT_SIGN||RIGHT(ABS(GMT_OFFSET)*100,4,'0');

   If invoke_type <> "COMMAND" Then;
     Return (GMT_OFFSET_HHMM);

   Say "GMT is local time (+/-)hhmm =" GMT_OFFSET_HHMM;
   Return (0);
./ ADD NAME=G2J      0101-19270-19270-1424-00050-00035-00000-APLKS   20
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Invoke as: yyyyddd = G2J(yyyymmdd)
          or  TSO G2J yyyymmdd

   Convert Gregorian date to Julian date (day of year).
   The more sophisticated approach.
   Algorithm developed by J. D. Robertson
   Input format: yyyymmdd  Output format: yyyyddd.
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   jdate = "error composition";

   Arg gdate . ;              /* i.e. 20160101 */

   Parse VAR gdate yr 5 mo 7 da . ;

   If Datatype(gdate,"W") Then;
     Select;
       When (yr = 1582) & (mo > 9 & mo < 13) & (da > 14 & da < 32) Then;
         Nop;
       When (yr > 1582) & (mo > 0 & mo < 13) & (da > 0 & da < 32) Then;
         Nop;
       Otherwise;
         Signal The_End;
     End;
   Else;
     Signal The_End;

   a = yr//4;
   b = yr//100;
   c = yr//400;
   d = (mo+10)%13;
   e = 3055*(mo+2)%100;
   f = da+e-2*d-91;
   n = f+(1-(a+3)%4+(b+99)%100-(c+399)%400)*d;
   n = Right(n,3,'0');

   jdate = yr||n;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return jdate;

   Say "Julian date =" jdate;
   Return (0);
./ ADD NAME=HBOX     0113-14167-16190-1043-00197-00217-00000-APLKS   29
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Place a History Revision flower box              */
/*          in source code.                                  */
/*                                                           */
/*  Format: HBOX < ( options >                               */
/*                                                           */
/*          Place flower box after current line              */
/*          or after the line the cursor is poitioned.       */
/*                                                           */
/* options: (default) PROFILE (NUMBER)                       */
/*          STD | COBOL                                      */
/*                                                           */
/*            STD for ASM, EZTRIEVE, etc. (column 1)         */
/*          COBOL for COBOL programs only (column 7)         */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC HBOX */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var. = "";

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Setup flower box based on the Options */

   Select;
     When lang = "COBOL" Then;
       Do;
         out1 = Copies(" ",6) || Copies("*",63);
         out2 = Copies(" ",6) || "*" || Copies(" ",2),
         || "BCS CUSTOM CODE REVISION LIST";
         out3 = Copies(" ",6) || "*" || Copies(" ",5) || "DATE",
         || Copies(" ",4) "PROGRAMMER",
         || Copies(" ",2) || "DESCRIPTION";
         out4 = Copies(" ",6) || "*" || Copies("-",62);
         out5 = Copies(" ",6) || "*" || Copies(" ",2) || "yyyy/mm/dd",
         || Copies(" ",3) || "xxxxxxxx";
       End;
     When lang = "STD" Then;
       Do;
         out1 = Copies("*",61);
         out2 = "*" || Copies(" ",8) || "BCS CUSTOM CODE REVISION LIST";
         out3 = "*" || Copies(" ",11) || "DATE",
         || Copies(" ",4) "PROGRAMMER",
         || Copies(" ",2) || "DESCRIPTION";
         out4 = "*" || Copies("-",60);
         out5 = "*" || Copies(" ",8) || "yyyy/mm/dd",
         || Copies(" ",3) || "xxxxxxxx";
       End;
     Otherwise;
       Do;
         var.3 = lang;
         Signal Error_INVALID_OPTS;
       End;
   End;

   /* Parse Target and User Passed Parms */

   Call Extract_TARGET;

   "LINE_AFTER .ZCSR = (out1)";
   "LINE_AFTER .ZCSR = (out5)";
   "LINE_AFTER .ZCSR = (out4)";
   "LINE_AFTER .ZCSR = (out3)";
   "LINE_AFTER .ZCSR = (out2)";
   "LINE_AFTER .ZCSR = (out1)";

   Return (0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Extract_TARGET:

   /* Resolve trow and tcol Variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trow = krow;
       tcol = kcol;
     End;
   Else;
     trow = frow;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When var.3 = "STD" | var.3 = "COBOL" Then;
         lang = var.3;
       Otherwise;
         Signal Error_INVALID_OPTS;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Insert Revision box after current line.",
        pad hex04,
        " Format: HBOX < ( STD | COBOL >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "Invalid user options ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=HEX2DEC  0106-19259-19270-1044-00058-00035-00000-APLKS   13
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Convert base(16) number to a base(10) number
   Invoke as: base_10 = HEX2DEC(base_16);
          or: TSO HEX2DEC base_16
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_10 = "error composition";

   ARG base_16;

   Numeric Digits 20;

   v1 = "0123456789ABCDEF";
   v2 = "A B C D E F ";

   If Verify(base_16,v1) = 0 Then;
     Nop;
   Else;
     Signal The_End;

   base_10 = "error length";

   len = Length(base_16);
   If len > 0 & len <= 8 Then;
     Do;
       j = len;
       Do i=1 To len By +1;
         j = j-1;
         pwr_vector.i = 16**j;
       End;
     End;
   Else;
     Signal The_End;

   base_10 = 0;

   Do i=1 To len By +1;
     digit = Substr(base_16,i,1);
     If Datatype(digit,"U") = 1 Then;
       Do;
         n = Wordpos(digit,v2);
         If n > 0 Then;
           digit = n-1+10;
       End;
     base_10 = base_10 + (digit * pwr_vector.i);
   End;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_10;

   Say "Decimal value = " base_10;
   Return (0);
./ ADD NAME=HSMLIST  0106-15274-15344-1712-00160-00031-00000-APLKS   32
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Invoke HSM HLIST command for both backup and     */
/*          migration list.  Results are written to a        */
/*          sequential file. The file is then VIEWed.        */
/*                                                           */
/*  Format: HSMLIST dsname|dsnlevel < ( options >            */
/*                                                           */
/*          dsname: a fully qualified DSNAME request.        */
/*       dsnlevel*: some part of the beginning of a          */
/*                  fully qualified dsname ending with       */
/*                  an "*" results in a LEVEL request.       */
/*         options: default VIEW DELETE                      */
/*                  VIEW|NOVIEW                              */
/*                  DELETE|NODELETE                          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC HSMHLIST */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   EC = 0;
   var = "";
   opt. = "";
   seq_dsname = Userid()||".HLIST.D"||Date("B")".T"||Time("S");

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;
   If opt.1 = "" Then;
     opt.1 = "VIEW";
   If opt.2 = "" Then;
     opt.2 = "DELETE";

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     name = Strip(parm2,"B");
   Else;
     Signal Error_NO_DATA;

   If Substr(name,Length(name),1) = "*" Then;
     Do;
       name = Substr(name,1,Length(name)-1);
       "HLIST LEVEL("name") BOTH ODS('"seq_dsname"')";
     End;
   Else;
     "HLIST DSNAME("name") BOTH ODS('"seq_dsname"')";

   EC = RC;
   If RC <> 0 Then;
     Signal Error_HLIST_FAILED;

   If opt.1 = "VIEW" Then;
     Address ISPEXEC "VIEW DATASET("seq_dsname")";

   If opt.2 = "DELETE" Then;
     "DELETE ("seq_dsname")";

   If EC <> 0 Then;
     Signal Error_ALLOC_TGTSEQ;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("VIEW",var) Then;
         opt.1 = "VIEW";
       When Abbrev("NOVIEW",var) Then;
         opt.1 = "NOVIEW";
       When Abbrev("DELETE",var) Then;
         opt.2 = "DELETE";
       When Abbrev("NODELETE",var) Then;
         opt.2 = "NODELETE";
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Invoke HSM HLIST against a set of dsname(s).",
        pad hex04,
        " Format: HSMLIST dsname | dsnlevel ",
        pad hex04,
        "         < ( VIEW|NOVIEW  DELETE|NODELETE";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_HLIST_FAILED:

   ZEDSMSG = "HSM HLIST FAILED";
   ZEDLMSG = "HSM HLIST failed, RC= :" EC " DSNpattern =" name;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=IBMDEBUG 0158-17117-19164-1441-00297-00191-00000-APLKS   01
/* REXX 2017-03-09 */
/* --------------------------------------------------------- */
/* Purpose: Invoke IBM DEBUG Tool                            */
/*                                                           */
/*    Inst: prior to executing this EXEC you must establish  */
/*          the necessary loadlibs                           */
/*                                                           */
/*          TSOLIB ACTIVATE DA(loadlib1 ...)                 */
/*                                                           */
/*  Format: IBMDEBUG aplks.work.loadlib(testpgm) +           */
/*                   TEST(ALL,*,PROMPT,*) /                  */
/*                   TEST(ALL,INSPIN,PROMPT,INSPPREF) /      */
/*                   TEST(,*,;,*) /                          */
/*                                                           */
/* --------------------------------------------------------- */
Trace R;
/* Entering EXEC IBMDEBUG */

   Address TSO;
   "PROFILE NOPREFIX";

/* Signal ON ERROR NAME Error_ON_ERROR; */
   Signal ON FAILURE NAME Error_ON_FAILURE;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;

   /* Initialize Variables */


   /* Display LOADLIB data sets */

   "TSOLIB DISPLAY";

   /* Allocate IBM DEBUG data sets */

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";

/*
   "FREE DD(INSPIN INSPPREF)";
   "ALLOC DD(INSPIN) DSNAME(APLKS.DEBUG.INSPIN) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_INSPIN;

   "ALLOC DD(INSPPREF) DSNAME(APLKS.DEBUG.INSSPREF) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_INSPPREF;
*/

   /* only good for Assembler, VS COBOL II, and OS/VS COBOL */
   "FREE DD(IDILANGX)";
   "ALLOC DD(IDILANGX) DSNAME(APLKS.EQALANGX) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_IDILANGX;

   /* only good for Enterprise COBOL, PL/I */
   "FREE DD(EQADEBUG)";
   "ALLOC DD(EQADEBUG) DSNAME(APLKS.SYSDEBUG) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSDEBUG;

/*
   "DELETE ('APLKS.DEBUG.INSPLOG') PURGE NONVSAM";
   "FREE DD(INSPLOG)";
   "ALLOC DD(INSPLOG) DSNAME(APLKS.DEBUG.INSPLOG)",
        " UNIT(SYSDA) TRACKS SPACE(5,5)",
        " RECFM(F B) LRECL(72) BLKSIZE(0)",
        " NEW ";
*/

   "FREE DD(INSPLOG)";
   "ALLOC DD(INSPLOG) DSNAME(APLKS.DEBUG.INSPLOG) REUSE";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_INSPLOG;


   "DELETE ('APLKS.DEBUG.SYSOUT') PURGE NONVSAM";
   "FREE DD(SYSOUT)";
   "ALLOC DD(SYSOUT) DSNAME(APLKS.DEBUG.SYSOUT)",
        " UNIT(SYSDA) TRACKS SPACE(5,5)",
        " RECFM(F B A) LRECL(121) BLKSIZE(0)",
        " NEW ";

/*
   "FREE DD(SYSUT1)";
   "ALLOC DD(SYSUT1) DSNAME(APLKS.LOG.MISC) SHR RECFM(U)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSUT1;

   "DELETE ('APLKS.LOGMISC.BLKSZ.SEQ') PURGE NONVSAM";
   "FREE DD(SYSUT2)";
   "ALLOC DD(SYSUT2) DSNAME(APLKS.LOGMISC.BLKSZ.SEQ)",
        " UNIT(SYSDA) TRACKS SPACE(1,5)",
        " RECFM(F B) LRECL(32) BLKSIZE(0)",
        " NEW ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSUT2;
*/
/*
   "FREE DD(SYSUT1)";
   "ALLOC DD(SYSUT1) DSNAME(PFIL.TSBCV.TSLOGT.MERGED) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSUT1;

   "DELETE ('APLKS.FANAL.VSAMVB.TSLOGT') PURGE NONVSAM";
   "FREE DD(SYSUT2)";
   "ALLOC DD(SYSUT2) DSNAME(APLKS.FANAL.VSAMVB.TSLOGT)",
        " UNIT(SYSDA) TRACKS SPACE(1,5)",
        " RECFM(F B) LRECL(32) BLKSIZE(0)",
        " NEW ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSUT2;
*/
/*
   "DELETE ('APLKS.FANAL.VSAMVB.TSEORM') PURGE NONVSAM";
   "FREE DD(SYSUT2)";
   "ALLOC DD(SYSUT2) DSNAME(APLKS.FANAL.VSAMVB.TSEORM)",
        " UNIT(SYSDA) TRACKS SPACE(1,5)",
        " RECFM(F B) LRECL(32) BLKSIZE(0)",
        " NEW ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSUT2;
*/
/*
   "FREE DD(SYSUT1)";
   "ALLOC DD(SYSUT1) DSNAME(RFIL.TSBCS.TSLOGT.AM RFIL.TSBCS.TSLOGT.SF,
    RFIL.TSBCS.TSLOGT.TELLER RFIL.TSBCS.TSLOGT.WIRE ) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSUT1;
*/
/*
   "FREE DD(SYSIN)";
   "ALLOC DD(SYSIN) DSNAME(APLKS.WORK.DATALIB(STRING)) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SYSIN;
*/

   "FREE DD(CEEOPTS)";
   "ALLOC DD(CEEOPTS) DSNAME(APLKS.WORK.DATALIB(IBMDEBUG)) SHR";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_CEEOPTS;


   CALL 'APLKS.ASUTIL.LOADLIB(ASTMISCB)';
   EC = RESULT;
   If RESULT <> 0 Then;
     Signal Error_CALL_USERPGM;

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";

   "TSOLIB DISPLAY";
   "TSOLIB RESET";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_ON_ERROR:
   Error_ON_FAILURE:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   "TSOLIB DISPLAY";
   "TSOLIB RESET";
   Return (-16);

   Error_ALLOC_INSPIN:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD INSPIN RC="EC;
   Return (-16);

   Error_ALLOC_INSPPREF:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD INSPPREF RC="EC;
   Return (-16);

   Error_ALLOC_INSPLOG:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD INSPLOG RC="EC;
   Return (-16);

   Error_ALLOC_IDILANGX:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD IDILANGX RC="EC;
   Return (-16);

   Error_ALLOC_SYSDEBUG:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD IDILANGX RC="EC;
   Return (-16);

   Error_ALLOC_SYSUT1:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD SYSUT1 RC="EC;
   Return (-16);

   Error_ALLOC_SYSUT2:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD SYSUT2 RC="EC;
   Return (-16);

   Error_ALLOC_SYSIN:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD INSPIN RC="EC;
   Return (-16);

   Error_ALLOC_CEEOPTS:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "ALLOC ERROR for DD CEEOPTS RC="EC;
   Return (-16);

   Error_CALL_USERPGM:

   "FREE DD(INSPIN INSPPREF INSPLOG)";
   "FREE DD(IDILANGX EQADEBUG)";
   "FREE DD(SYSIN SYSOUT SYSUT1 SYSUT2)";
   "FREE DD(CEEOPTS)";
   Say "CALL ERROR for program" userpgm "RC="EC;
   Return (-16);
./ ADD NAME=ICISZ    0102-14134-14329-1102-00199-00199-00000-APLKS   07
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Edit/View IDCAMS PRINT of VSAM KSDS index        */
/*          component listing (minimum of 20 index records). */
/*          Collect data on the index component.  Compute    */
/*          the average compressed key length.  Compute the  */
/*          minimum index cisz.  Present results in the      */
/*          edited/viewed member as MSGLINEs.                */
/*                                                           */
/*  Format: ICISZ data_ci/ca                                 */
/*                                                           */
/*             nbr - number of data CI's per CA              */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC ICISZ */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
   Else;
     Upper parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   vp. = ""; /*VSAM IDCAMS PRINT command values*/

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     dciperca = Strip(parm2,"B");
   If Datatype(dciperca,"W") Then;
     Nop;
   Else;
     Signal Error_INVALID_DATA;

   /* Main line code */

   /* Collect all of the PRINT data needed */
   "EXCLUDE 'IDCAMS' ALL";
   "EXCLUDE 'LISTING' ALL";
   "DELETE ALL X";

   k = 0;
   Do i = +1 By +1 To +20;
     /*loop for the number of index records*/
     "SEEK 'RBA'";
     If RC = 0 Then;
       "(irow,icol) = CURSOR";
     Else;
       Leave;
     finish = "N";
     Do While finish = "N";
       /*loop for rows in index record*/
       irow = irow + 1;
       "(row) = LINE" irow;
       vp.roffset = X2D(Word(row,1));
       Select;
         When vp.roffset = 0 Then;
           Do;
             If Substr(Word(row,6),1,2) <> "01" Then;
               Iterate i;
             k = k + 1;
             vp.ireclen.k = X2D(Substr(Word(row,2),1,4));
             vp.vtrptrlen.k = Translate(Right(X2D(Substr(Word(row,2),7,2) ,
                  ),1),"123","137");
             vp.unusedspcbeg.k = X2D(Substr(Word(row,6),5,4));
             vp.lenfspcptr.k = vp.unusedspcbeg.k - 24;
             vp.unusedcinca.k = vp.lenfspcptr.k % vp.vtrptrlen.k;
             vp.usedcinca.k = dciperca - vp.unusedcinca.k;
             vp.dcautil.k = Format(((vp.usedcinca.k / dciperca) ,
                  * 100),3,0);
      /*     If vp.unusedspcbeg.k < 32 Then;
               Do;
               End;  */
           End;  /*End DO*/
         When vp.roffset > vp.unusedspcbeg.k Then;
           Do j = +2 By +1 For +8 While finish = "N";
             If Word(row,j) = "00000000" Then;
               Iterate j;
             Select;
               When Substr(Word(row,j),1,2) <> "00" Then;
                 Do;
                   offset = ((j - 2) * 4) + 0;
                   finish = "Y";
                 End;
               When Substr(Word(row,i),3,2) <> "00" Then;
                 Do;
                   offset = ((j - 2) * 4) + 1;
                   finish = "Y";
                 End;
               When Substr(Word(row,i),5,2) <> "00" Then;
                 Do;
                   offset = ((j - 2) * 4) + 2;
                   finish = "Y";
                 End;
               When Substr(Word(row,i),7,2) <> "00" Then;
                 Do;
                   offset = ((j - 2) * 4) + 3;
                   finish = "Y";
                 End;
               Otherwise;
                 Nop;
             End;  /*End SELECT*/
           End;  /*End DO*/
         Otherwise;
           Nop;
       End;  /*End SELECT*/
     End;  /*End DO*/
     vp.cmpkeylen.k = ((vp.ireclen.k - (vp.roffset + offset)) ,
          / vp.usedcinca.k) + 1;
   End;  /*End DO*/

   sum1 = 0;
   sum2 = 0;
   Do i = +1 To k By +1;
     sum1 = sum1 + vp.cmpkeylen.i;
     sum2 = sum2 + vp.dcautil.i;
   End;

   avgkeylen = Strip(Format((sum1 % k),3,0),"L");
   count = Strip(((dciperca * avgkeylen) % 512),"L");;
   If count < 1 Then;
     count = 1;
   Else;
     If ((dciperca * avgkeylen) // 512) > 0 Then;
       count = count + 1;
   minicisz = 512 * count;

   avgcautil = Strip(Format((sum2 % k),3,0),"L");

   out1 = "AVG COMPRESSED KEY LEN = "avgkeylen,
          "  MINIMAL INDEX CISZ = "minicisz;
   out2 = "AVG DATA CA UTILIZATION = "avgcautil"%";

   "LINE_AFTER .ZFIRST = MSGLINE (out2)";
   "LINE_AFTER .ZFIRST = MSGLINE (out1)";
   "LOCATE .ZFIRST";

   Return (0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */


   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: View/Edit IDCAMS PRINT listing of a VSAM",
        pad hex04,
        "        Index component.  Compute average compressed",
        pad hex04,
        "        key length, minimum Index CISZ",
        pad hex04,
        "format: ICISZ data_ci/ca";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_DATA:

   ZEDSMSG = "INVALID DATA";
   ZEDLMSG = "INVALID DATA:" dciperca;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=INFO     0102-16237-16237-1117-00087-00079-00000-APLKS   18
/* REXX 2016-08-24 */
/* ------------------------------------------------------- */
/* Purpose: Show ISREDIT member information.               */
/* ------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC INFO  */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO";

   /* Initialize Variables */
   lne. = "";

   "(blksz) = BLKSIZE";
   blksz = blksz + 0;
   "(bndslo,bndshi) = BOUNDS";
   bndslo = bndslo + 0;
   bndshi = bndshi + 0;
   "(chgcnt,errcnt) = CHANGE_COUNTS";
   chgcnt = chgcnt + 0;
   errcnt = errcnt + 0;
   "(width) = DATA_WIDTH";
   width = width + 0;
   "(dcollo,dcolhi) = DISPLAY_COLS";
   dcollo = dcollo + 0;
   dcolhi = dcolhi + 0;
   "(drowlo,drowhi) = DISPLAY_LINES";
   drowlo = drowlo + 0;
   drowhi = drowhi + 0;
   "(strfnd,xcnt) = EXCLUDE_COUNTS";
   strfnd = strfnd + 0;
   xcnt = xcnt + 0;
   "(rel) = LEVEL";
   "(lrecl) = LRECL";
   lrecl = lrecl + 0;
   "(recfm) = RECFM";
   "(ver) = VERSION"

   lne.1 = "VERSION="ver" LEVEL="rel;
   lne.2 = "RECFM="recfm" BLKSIZE="blksz" LRECL="lrecl;
   lne.3 = "WIDTH="width" COLS=("dcollo","dcolhi") LINES=("drowlo","drowhi")",
           "BOUNDS=("bndslo","bndshi")";
   lne.4 = "CHANGE COUNT="chgcnt" ERRORS="errcnt;
   lne.5 = "EXCLUDE STRINGS FOUND="strfnd" LINES EXCLUDED="xcnt;

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        lne.1,
        pad hex04,
        lne.2,
        pad hex04,
        lne.3,
        pad hex04,
        lne.4,
        pad hex04,
        lne.5;
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";

   Return (0);
./ ADD NAME=J2G      0102-19270-19270-1424-00060-00045-00000-APLKS   42
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Invoke as: yyyymmdd = J2G(yyyyddd)
          or  TSO J2G yyyyddd

   Convert Julian date (day of year) to Gregorian date.
   The more sophisticated approach.
   Algorithm developed by R. A. Stone
   Input format: yyyyddd  Output format: yyyymmdd.
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   gdate = "error composition";

   Arg jdate;                 /* i.e. 2016001 */

   Parse VAR jdate yr 5 da . ;

   If Datatype(jdate,"W") Then;
     Select;
       When (yr = 1582) & (da > 287 & da < 366) Then;
         Nop;
       When (yr > 1582) & (da > 0 & da < 367) Then;
         Nop;
       Otherwise;
         Signal The_End;
     End;
   Else;
     Signal The_End;

   a = 0;
   If yr//4 = 0 Then;
     a = 1;

   h = 0;
   If da > 59 Then;
     h = 1;

   b = 0;
   If a+h > 0 Then
     b = 2-a;

   c = da+b+91;
   m = c*100%3055;
   t = c-3055*m%100;
   m = m-2;
   t = Right(t,2,'0');
   m = Right(m,2,'0');

   gdate = yr||m||t;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return gdate;

   Say "Gregorian date =" gdate;
   Return (0);
./ ADD NAME=KONKAT   0117-14130-17038-1434-00404-00351-00000-APLKS   31
/* REXX 2017-02-07 */
/* --------------------------------------------------------- */
/* Purpose: Concatenate a dataset to an existing             */
/*          optional/required ISPF ddname.                   */
/*                                                           */
/*          Can be used after ISPF is initialized for        */
/*          the following optional ISPF ddnames.             */
/*                                                           */
/*          valid ddnames:                                   */
/*            SYSPROC - CLIST/REXX library                   */
/*            SYSEXEC - REXX library                         */
/*                                                           */
/*          Can be used under native TSO, prior to ISPF      */
/*          initialization for the following required        */
/*          ISPF ddnames.                                    */
/*                                                           */
/*          valid ddnames:                                   */
/*            ISPLLIB - load library                         */
/*            ISPMLIB - message library                      */
/*            ISPPLIB - panel library                        */
/*            ISPPROF - profile dataset                      */
/*            ISPSLIB - skeleton library                     */
/*            ISPTABL - table library                        */
/*            ISPTLIB - read only table library              */
/*            SYSHELP - help library                         */
/*                                                           */
/*  Format: KONKAT ddname dsname  < ( options >              */
/*                                                           */
/*         ddname: is the ISPF optional/required ddname to   */
/*                 concatenate the dsname to                 */
/*         dsname: is the dataset name to concatenate        */
/*                 to the ISPF optional/required ddname      */
/*        options: default FIRST ONLY NOMSG                  */
/*                 FIRST/LAST - allocate before other        */
/*                   datasets or after other datasets        */
/*                 EVEN/ONLY - reallocate DSNAME to DDNAME   */
/*                   EVEN if it is already present or ONLY   */
/*                   if it is not already present            */
/*                 MSG/NOMSG - display ALLOC diagnostic      */
/*                   messages or disable message display     */
/*                                                           */
/* --------------------------------------------------------- */

   ispf_act = "N";
   Address TSO "SUBCOM ISPEXEC";
   If RC = 0 Then;
     ispf_act = "Y";

   If ispf_act = "Y" Then;
     Do;
       Address ISPEXEC "CONTROL ERRORS RETURN";
       Address ISPEXEC "VGET (DEBUG) PROFILE";
       If debug = "DEBUG" Then;
         Do;
           x = MSG("ON");
           Trace R;
         End;
       Else;
         x = MSG("OFF");
     End;

/* Entering EXEC KONKAT */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;

   /* Initialize Variables */
   opt. = "";
   var. = "";
   /* valid ddname list in ascending order */
   DDlst_ISPF = "SYSEXEC SYSPROC ";
   DDlst_TSO = "ISPLLIB ISPMLIB ISPPLIB ISPPROF ISPSLIB ISPTABL",
        "ISPTLIB SYSHELP ";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Initialize Default values */
   If opt.1 = "" Then;
     opt.1 = "FIRST";
   If opt.2 = "" Then;
     opt.2 = "ONLY";
   If opt.3 = "" Then;
     opt.3 = "NOMSG";

   /* Parse User Passed Parms */

   If parm2 = "" Then;
     Signal Error_NO_DATA;

   Parse VAR parm2 ddname dsname " (" . ;

   If ddname = "" Then;
     Signal Error_INVALID_DDNAME;

   Select;
     When addrsp_name = "ISPF" Then;
       /* is it a valid optional DDNAME */
       If Wordpos(ddname,DDlst_ISPF) = 0 Then;
         Signal Error_INVALID_DDNAME;
     When addrsp_name = "TSO/E" Then;
       /* is it a valid required/optional DDNAME */
       If Wordpos(ddname,DDlst_TSO) = 0 & ,
          Wordpos(ddname,DDlst_ISPF) = 0 Then;
         Signal Error_INVALID_DDNAME;
     Otherwise;
       Signal Error_INVALID_ENV;
   End;

   If dsname = "" Then;
     Signal Error_INVALID_DSNAME;

   dsname = Strip(dsname,"B");
   Select;
     When Left(dsname,1) = '"' Then;
       dsname = Strip(dsname,"B",'"');
     When Left(dsname,1) = "'" Then;
       dsname = Strip(dsname,"B","'");
     Otherwise;
       Nop;
   End;

   If Pos(".",ddname) <> 0 | Length(ddname) > 8 Then;
     Signal Error_INVALID_DDNAME;
   If Pos(".",dsname) = 0 Then;
     Signal Error_INVALID_DSNAME;

   /* Test dsname for validity */

   Call Validate_DSNAME dsname;
   If EC < 16 Then;
     If CC < 0 Then;
       Signal Error_INVALID_DSNAME;
     Else;
       Nop;
   Else;
     Signal Error_INVALID_DSNAME;

   /* Find the ddname and collect the dsnames */

   Call Find_DDNAME ddname;

   If opt.3 = "MSG" Then;
     x = MSG("ON");

   dsname = "'" || dsname || "'";
   n = Wordpos(dsname,DSlst.dsn);
   Select;
     When n = 0 & opt.2 = "ONLY" Then;
       /* dsname not already present and ONLY stated */
       Do;
         If opt.1 = "FIRST" Then;
          "ALLOC FILE("ddname"),
                 DATASET("dsname DSlst.dsn") SHR REUSE";
         Else;
          "ALLOC FILE("ddname"),
                 DATASET("DSlst.dsn dsname") SHR REUSE";
         EC = RC;
         If RC > 4 Then;
           Signal Error_ALLOC;
         Else;
           Say dsname" ALLOCATED TO "ddname;
       End;
     When n > 0 & opt.2 = "EVEN" Then;
       /* dsname already present and EVEN stated */
       Do;
         DSlst.dsn = Delword(DSlst.dsn,n,1);
         If opt.1 = "FIRST" Then;
          "ALLOC FILE("ddname"),
                 DATASET("dsname DSlst.dsn") SHR REUSE";
         Else;
          "ALLOC FILE("ddname"),
                 DATASET("DSlst.dsn dsname") SHR REUSE";
         EC = RC;
         If RC > 4 Then;
           Signal Error_ALLOC;
         Else;
           Say dsname" ALLOCATED TO "ddname;
       End;
     Otherwise;
       Signal Error_ALLOC;
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("FIRST",var.3) Then;
         opt.1 = "FIRST";
       When Abbrev("LAST",var.3) Then;
         opt.1 = "LAST";
       When Abbrev("EVEN",var.3) Then;
         opt.2 = "EVEN";
       When Abbrev("ONLY",var.3) Then;
         opt.2 = "ONLY";
       When Abbrev("MSG",var.3) Then;
         opt.3 = "MSG";
       When Abbrev("NOMSG",var.3) Then;
         opt.3 = "NOMSG";
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   Validate_DSNAME: Procedure Expose EC CC;

   /* Test dsname for validity */
   Arg dsname;
   CC = 0;
   arg_string = "'"dsname"' NORECALL NOSMSINFO";
   EC = Listdsi(arg_string);
   If EC < 16 Then;
     Do;
       If SYSREASON = 0 Then;
         If SYSDSORG = "PO" | SYSDSORG = "POU" Then;
           Nop;
         Else;
           CC = -12;
       Else;
         If SYSREASON = 3  | SYSREASON = 5  | SYSREASON = 24 Then;
           CC = -12;
         Else;
           CC = -24;
     End;

   Return (EC);

   Find_DDNAME: Procedure Expose DSlst.  ;

   /* Find the ddname and collect the dsnames */
   Arg ddname;
   x = Outtrap("LALC.");
   /* Display the names of the currently allocated datasets */
   "LISTALC STATUS SYSNAMES";
   EC = RC;
   x = Outtrap("OFF");
   If EC <> 0 Then;
     Signal Error_LISTALC;

   /* Initialize the data areas */
   DSlst. = "";
   ddfnd_flg = "N";
   prev_dsname = "";

   /* Loop through the LISTALC output */
   Do i = 1 To LALC.0 While ddfnd_flg <> "Z";
     Select;
       When Substr(LALC.i,1,4) = "--DD" Then;
         /* skip the header line --DDNAME---DISP-- */
         Iterate;
       When Substr(LALC.i,1,1) <> " " Then;
         /* process a dsname line followed by a ddname line */
         /* keep track of the previous dsname, the next line
            may have a ddname or blank if there are more than
            one dsname tied to a ddname */
         Do;
           prev_dsname = Word(LALC.i,1);
           If prev_dsname = "TERMFILE " | ,
              prev_dsname = "NULLFILE " Then;
             /* special case, ddname is on the same line
                bypass line, no processing necessary */
             prev_dsname = "";
           Iterate;
         End;
       When Substr(LALC.i,1,2) = "  " & ,
            Substr(LALC.i,3,1) <> " " Then;
         /* must be a ddname line */
         Do;
           If ddfnd_flg = "Y" Then;
             ddfnd_flg = "Z";
           Else;
             Do;
               curr_ddname = Word(LALC.i,1);
               If curr_ddname <> ddname Then;
                 Do;
                   prev_dsname = "";
                   curr_ddname = "";
                   Iterate;
                 End;
               /* Found the right ddname,
                  now init the out list */
               ddfnd_flg = "Y";
               DSlst.dsn = "'" || prev_dsname || "' ";
             End;
         End;
       Otherwise;
         if ddfnd_flg = "Y" Then;
           /* Found the right ddname,
              now fill out list */
           DSlst.dsn = DSlst.dsn || "'" ||,
                     prev_dsname || "' ";
         Iterate;
     End;
   End;

   Return;

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NO_DATA:

   If ispf_act = "Y" Then;
     Do;
       ZEDSMSG = "MISSING DATA";
       ZEDLMSG = "NO DATA SPECIFIED";
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       Return (-16);
     End;
   Else;
     Do;
       Say "NO DATA SPECIFIED";
       Return (-16);
     End;

   Error_INVALID_ENV:

   If ispf_act = "Y" Then;
     Do;
       ZEDSMSG = "INVALID ENV";
       ZEDLMSG = "INVALID ENVIRONMENT:" addrsp_name;
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       Return (-16);
     End;
   Else;
     Do;
       Say "INVALID ENVIRONMENT:" addrsp_name;
       Return (-16);
     End;

   Error_INVALID_DDNAME:

   If ispf_act = "Y" Then;
     Do;
       ZEDSMSG = "INVALID DDNAME";
       ZEDLMSG = "INVALID FILE NAME:" ddname;
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       Return (-16);
     End;
   Else;
     Do;
       Say "INVALID FILE NAME:" ddname;
       Return (-16);
     End;

   Error_INVALID_DSNAME:

   If ispf_act = "Y" Then;
     Do;
       ZEDSMSG = "INVALID DSNAME";
       ZEDLMSG = "INVALID DATA SET NAME:" dsname "CC=" CC;
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       Return (-16);
     End;
   Else;
     Do;
       Say "INVALID DATA SET NAME:" dsname "CC=" CC;
       Return (-16);
     End;

   Error_ALLOC:

   If ispf_act = "Y" Then;
     Do;
       ZEDSMSG = "ALLOC FAILED";
       ZEDLMSG = "FILE ALLOCATION FAILED:" ddname "RC=" EC;
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       Return (-16);
     End;
   Else;
     Do;
       Say "FILE ALLOCATION FAILED:" ddname "RC=" EC;
       Return (-16);
     End;
./ ADD NAME=LABELS   0113-16130-16190-1136-00347-00296-00000-APLKS   26
/* REXX 2016-07-08 */
/* ---------------------------------------------------------- *
 *  Purpose:  Clear, Display, Restore or Save labels of an    *
 *            ISPF EDIT (ISREDIT) member.                     *
 *                                                            *
 *            The labels in a dataset(member) are saved in    *
 *            the active ISPF Profile in the variable name    *
 *            LBLS@@.  Each dsname(mbr) is added to this      *
 *            variable in the format: dsname(mbr) labels... # *
 *            where the # is the end of each set of labels    *
 *            where labels are in the format row:.label       *
 *                                                            *
 *   Syntax:  LABELS < ( options >                            *
 *                                                            *
 *            options: (defaults) SAVE                        *
 *                     ALL                                    *
 *                     CLEAR | DISPLAY | RESTORE | SAVE       *
 *                                                            *
 *  Example:                                                  *
 *            LABELS ( SAVE                                   *
 *              save existing labels in user ISPF PROFILE     *
 *              not saved if they already exist               *
 *                                                            *
 *            LABELS ( RESTORE                                *
 *              restore saved labels and remove them from     *
 *              the user ISPF PROFILE                         *
 *                                                            *
 *            LABELS ( DISPLAY                                *
 *              display labels saved for this member          *
 *                                                            *
 *            LABELS ( DISPLAY ALL                            *
 *              display labels saved for all members          *
 *                                                            *
 *            LABELS ( CLEAR                                  *
 *              clear labels saved for this member from       *
 *              the user ISPF PROFILE                         *
 *                                                            *
 *            LABELS ( CLEAR ALL                              *
 *              clear labels saved for all members from       *
 *              the user ISPF PROFILE                         *
 *                                                            *
 * Inspired by Lionel Dyck's SAVELAB                          *
 * ---------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC LABELS */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   "(dsname) = dataset";
   "(mbrname) = member";
   dsnmkey = dsname"("mbrname")";
   opt. = "";
   var. = "";

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.2 <> "" & opt.2 <> "ALL" Then;
     dsnmkey = dsname"("opt.2")";

   /* Mainline */

   Select;
     When opt.1 = "CLEAR" Then;
       Do;
         Call Action_CLEAR;
       End;
     When opt.1 = "DISPLAY" Then;
       Do;
         Call Action_DISPLAY;
       End;
     When opt.1 = "RESTORE" Then;
       Do;
         Call Action_RESTORE;
       End;
     When opt.1 = "SAVE" Then;
       Do;
         Call Action_SAVE;
       End;
     Otherwise;
       Signal Error_INVALID_ACTION;
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("CLEAR",var.3,3) Then;
         opt.1 = "CLEAR";
       When Abbrev("DISPLAY",var.3,3) Then;
         opt.1 = "DISPLAY";
       When Abbrev("RESTORE",var.3,3) Then;
         opt.1 = "RESTORE";
       When Abbrev("SAVE",var.3,3) Then;
         opt.1 = "SAVE";
       When Abbrev("ALL",var.3,3) Then;
         opt.2 = "ALL";
       Otherwise;
         Do;
           If opt.1 = "" Then;
             Signal Error_INVALID_OPT;
           Else;
             opt.2 = var.3;
         End;
     End;
   End;

   If opt.1 = "" Then;
     opt.1 = "SAVE";

   Return (0);

   Action_CLEAR:

   Address ISPEXEC "VGET (LBLS@@) PROFILE";

   If opt.2 = "ALL" Then;
     Do;
       Address ISPEXEC "VERASE (LBLS@@) PROFILE";
       ZEDSMSG = "LABELS CLEARED";
       ZEDLMSG = "Labels cleared for all members";
       Address ISPEXEC "SETMSG MSG(ISRZ001)"
       Return (0);
     End;

   wrd = Wordpos(dsnmkey,lbls@@);
   If wrd = 0 Then;
     Signal Error_NO_LABELS;

   lbllist = ""; leading = ""; trailing = "";
   If wrd > 0 Then;
     Do;
       leading = Subword(lbls@@,1,wrd-1);
       trailing = Subword(lbls@@,wrd+1);
       Parse VAR trailing lbllist "#" trailing;
       cnt = Words(lbllist);
       lbls@@ = leading trailing;
       Address ISPEXEC "VPUT (LBLS@@) PROFILE";
       ZEDSMSG = cnt "LABELS CLEARED";
       ZEDLMSG = "Labels cleared for member -" dsnmkey;
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
     End;

   Return (0);

   Action_DISPLAY:

   Address ISPEXEC "VGET (LBLS@@) PROFILE";

   If opt.2 = "ALL" Then;
     Do;
       Say "Label variable =" lbls@@;
       Return (0);
     End;

   wrd = Wordpos(dsnmkey,lbls@@);
   If wrd = 0 Then;
     Signal Error_NO_LABELS;

   lbllist = ""; leading = ""; trailing = "";
   If wrd > 0 Then;
     Do;
       leading = Subword(lbls@@,1,wrd-1);
       trailing = Subword(lbls@@,wrd+1);
       Parse VAR trailing lbllist "#" trailing;
       cnt = Words(lbllist);
       Say "Label variable for -" dsnmkey "=" lbllist;
     End;

   Return (0);

   Action_RESTORE:

   Address ISPEXEC "VGET (LBLS@@) PROFILE";

   wrd = Wordpos(dsnmkey,lbls@@);
   If wrd = 0 Then;
     Signal Error_NO_LABELS;

   lbllist = ""; leading = ""; trailing = "";
   If wrd > 0 Then;
     Do;
       leading = Subword(lbls@@,1,wrd-1);
       trailing = Subword(lbls@@,wrd+1);
       Parse VAR trailing lbllist "#" trailing;
       cnt = Words(lbllist);
       "UP MAX";
       "RESET LABEL";
       Do While lbllist <> "";
         Parse VAR lbllist lnenbr ":" lblnme lbllist;
         "LABEL" lnenbr "=" lblnme "0";
       End;
       "UP MAX";
       ZEDSMSG = cnt "LABELS RESTORED";
       ZEDLMSG = "Labels restored for member -" dsnmkey;
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       lbls@@ = leading trailing;
       Address ISPEXEC "VPUT (LBLS@@) PROFILE";
     End;

   Return (0);

   Action_SAVE:

   Address ISPEXEC "VGET (LBLS@@) PROFILE";

   wrd = Wordpos(dsnmkey,lbls@@);
   If wrd > 0 Then;
     Signal Error_ALREADY_SAVED;

   cnt = 0;
   "LOCATE LABEL FIRST";
   If RC <> 0 Then;
     Do;
       ZEDSMSG = cnt "LABELS SAVED";
       ZEDLMSG = "Labels saved for member -" dsnmkey;
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       Return (4);
     End;

   lbllist = "";
   Do While RC = 0;
     "(row) = DISPLAY_LINES";
     If RC <> 0 Then;
       Iterate;
     "(lblnme) = LABEL" row;
     If RC <> 0 Then;
       Iterate;
     lbllist = lbllist Strip(row,'L','0') || ":" || Strip(lblnme);
     "LOCATE LABEL NEXT";
   End;
   cnt = Words(lbllist);

   If cnt > 0 Then;
     Do;
       Address ISPEXEC "VGET (LBLS@@) PROFILE";
       lbls@@ = lbls@@ dsnmkey lbllist "#";
       Address ISPEXEC "VPUT (LBLS@@) PROFILE";
     End;

   ZEDSMSG = cnt "LABELS SAVED";
   ZEDLMSG = "Labels saved for member -" dsnmkey;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "UP MAX";

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Manage ISREDIT labels.",
        pad hex04,
        " Format: LABELS < ( CLEAR | DISPLAY | RESTORE | SAVE >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";

   Return (-16);

   Error_INVALID_ACTION:

   ZEDSMSG = "INVALID ACTION";
   ZEDLMSG = "Invalid action not CLEAR, DISPLAY, RESTORE, SAVE";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";

   Return (-16);

   Error_INVALID_OPT:

   ZEDSMSG = "INVALID OPT";
   ZEDLMSG = "Invalid option not ALL, CLEAR, DISPLAY, RESTORE, SAVE";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";

   Return (-16);

   Error_NO_LABELS:

   ZEDSMSG = "NO LABELS";
   ZEDLMSG = "No labels found for member -" dsnmkey;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";

   Return (-16);

   Error_ALREADY_SAVED:

   ZEDSMSG = "ALREADY SAVED";
   ZEDLMSG = "Labels already exist, must CLEAR before SAVE -" dsnmkey;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";

   Return (-16);
./ ADD NAME=LANG     0117-14143-16190-1045-00110-00400-00000-APLKS   25
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Set Profile variable for language                */
/*  Format: LANG  ( options                                  */
/*                                                           */
/*         options:                                          */
/*                  STD | COBOL                              */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC LANG */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   lang = "NULL";
   var = "";

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   lang@@ = lang;
   Address ISPEXEC "VPUT (LANG@@) PROFILE";

   /* Parse Target and Primary passed Parms */

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When var = "STD" | var = "COBOL" Then;
         lang = var;
       Otherwise;
         Signal Error_INVALID_LANG;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Set Profile variable for Language.",
        pad hex04,
        " Format: LANG  ( STD | COBOL";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_LANG:

   ZEDSMSG = "INVALID LANG";
   ZEDLMSG = "Language is not valid ("var")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=LCAT     0109-14130-15265-1723-00181-00184-00000-APLKS   42
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Invoke LISTCAT save the output in a sequential   */
/*          file, then VIEW the file.                        */
/*                                                           */
/*  Format: LCAT  dataset_name < ( options >                 */
/*                                                           */
/*    dataset_name: is the name of the dataset to LISTCAT    */
/*         options: default VIEW DELETE                      */
/*                  VIEW|NOVIEW                              */
/*                  DELETE|NODELETE                          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC LCAT */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   EC = 0;
   var.3 = "";
   opt. = "";
   lcat. = "";
   seq_dsname = Userid()||".LISTCAT.D"||Date("B")".T"||Time("S");

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;
   If opt.1 = "" Then;
     opt.1 = "VIEW";
   If opt.2 = "" Then;
     opt.2 = "DELETE";

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     vsam_dsname = Strip(parm2,"B");
   Else;
     Signal Error_NO_DATA;

   If addrsp_name = "TSO/E" | addrsp_name = "ISPF" Then;
     Do;
       x = Outtrap("LCAT.");
       "LISTCAT ENT ("vsam_dsname") ALL";
       x = Outtrap("OFF");
     End;
   Else;
     Signal Error_INVALID_ENV;

   If LCAT.0 = 0 Then;
     Signal Msg_NO_OUTPUT;

   "ALLOC DSNAME("seq_dsname") DSORG(PS) RECFM(F B) ",
          "LRECL(132) BLKSIZE(528) SPACE(1,1) TRACKS ",
          "NEW CATALOG REUSE ";
   EC = RC;

   "ALLOC FILE(DDOUT1) DSNAME("seq_dsname") ";
   EC = RC;

   "EXECIO * DISKW DDOUT1 ( STEM LCAT. FINIS";
   If RC = 0 Then;
     If opt.1 = "VIEW" Then;
       Do;
         Address ISPEXEC "VIEW DATASET("seq_dsname")";
         "FREE FILE(DDOUT1)";
       End;

   If opt.2 = "DELETE" Then;
     "DELETE ("seq_dsname")";

   If EC <> 0 Then;
     Signal Error_ALLOC_TGTSEQ;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("VIEW",var.3) Then;
         opt.1 = "VIEW";
       When Abbrev("NOVIEW",var.3) Then;
         opt.1 = "NOVIEW";
       When Abbrev("DELETE",var.3) Then;
         opt.2 = "DELETE";
       When Abbrev("NODELETE",var.3) Then;
         opt.2 = "NODELETE";
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Invoke LISTCAT save the output in a sequential",
        pad hex04,
        "         file, then VIEW the file.",
        pad hex04,
        " Format: LCAT  dataset_name ",
        pad hex04,
        "          < ( VIEW|NOVIEW  DELETE|NODELETE";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "INVALID ENVIRONMENT:" addrsp_name;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Msg_NO_OUTPUT:

   If addrsp_name = "TSO/E" | addrsp_name = "ISPF" Then;
     x = Outtrap("OFF");
   ZEDSMSG = "NO OUTPUT";
   ZEDLMSG = "No output generated";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (4);
./ ADD NAME=LDSI     0127-14140-19288-1316-00256-00103-00000-APLKS   03
/* REXX 2019-10-15 */
/* --------------------------------------------------------- */
/* Purpose: Invoke TSO LISTDSI to display all of the known   */
/*          information about a non-VSAM data set.           */
/*                                                           */
/*  Format: LDSI    dataset_name ( options                   */
/*                                                           */
/*    dataset_name: is the name of the dataset to LISTDSI    */
/*         options: (default) NORECALL DIRINFO SCREEN        */
/*                                                           */
/*                  RECALL|NORECALL migrated datasets        */
/*                  DIRINFO|NODIRINFO PDS/E directory info   */
/*                  LINE|SCREEN presentation option          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC LDSI */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   token = "";
   opt. = "";
   count = 0;
   line = "";

   /*title of day table*/
   tod.0 = 7;
   tod.1 = "Mon";
   tod.2 = "Tue";
   tod.3 = "Wed";
   tod.4 = "Thu";
   tod.5 = "Fri";
   tod.6 = "Sat";
   tod.7 = "Sun";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "NORECALL";      /*norecall*/
   If opt.2 = "" Then;
     opt.2 = "DIRECTORY";     /*dirinfo*/
   If opt.3 = "" Then;
     opt.3 = "SCR";           /*screen*/
   opt.0 = 3;

   If parm2 <> "" Then;
     Do;
       dataset_name = Strip(parm2,"B");
       dataset_name = Strip(dataset_name,"B","'");
     End;
   Else;
     Return (-12);

   /* Retrieve all of the dataset information */

   arg_string = "'"dataset_name"'" opt.1 opt.2;
   EC = Listdsi(arg_string);
   If EC > 0 Then;
     Do;
       Say "TSO LISTDSI FAILED";
       Say "Reason -" SYSREASON;
       Say SYSMSGLVL1;
       Say SYSMSGLVL2;
       Return (-24);
     End;

   pad = Copies(" ",4);
   MAKEBUF;
   Queue "DSNAME: "SYSDSNAME;

   julian_date = Substr(SYSCREATE,3,2) || Substr(SYSCREATE,6,3);
   sorted_date = Date("S",julian_date,"J");
   dayofwk = Date("B",sorted_date,"S") // 7 + 1; /*Mon-Sun 1-7*/
   normal_date = Date("N",sorted_date,"S");
   Queue pad "Create date -" SYSCREATE sorted_date,
        tod.dayofwk normal_date;

   julian_date = Substr(SYSREFDATE,3,2) || Substr(SYSREFDATE,6,3);
   sorted_date = Date("S",julian_date,"J");
   dayofwk = Date("B",sorted_date,"S") // 7 + 1; /*Mon-Sun 1-7*/
   normal_date = Date("N",sorted_date,"S");
   Queue pad "Last reference date -" SYSREFDATE sorted_date,
        tod.dayofwk normal_date;

   If SYSEXDATE <> 0 Then;
     Do;
       julian_date = Substr(SYSEXDATE,3,2) || Substr(SYSEXDATE,6,3);
       sorted_date = Date("S",julian_date,"J");
       dayofwk = Date("B",sorted_date,"S") // 7 + 1; /*Mon-Sun 1-7*/
       normal_date = Date("N",sorted_date,"S");
       Queue pad "Expiration date -" SYSEXDATE sorted_date,
            tod.dayofwk normal_date
     End;
   Else;
       Queue pad "Expiration date -" SYSEXDATE;

   Queue pad "Password -" SYSPASSWORD;
   Queue pad "RACF -" SYSRACFA;
   Queue pad "Updated since last backup -" SYSUPDATED;
   Queue pad "Extended Attributes -" SYSEADSCB;

   Queue pad;
   Queue "Common DCB Info:";

   Queue pad "DSORG -" SYSDSORG;

   Queue pad "RECFM -" SYSRECFM " BLKSIZE -" SYSBLKSIZE,
        " LRECL -" SYSLRECL;

   Queue pad;
   Queue "DASD Info:";
   Queue pad SYSUNITS "("SYSPRIMARY","SYSSECONDS")";

   Queue pad "ALLOCATED -" SYSALLOC " USED -" SYSUSED " EXTENTS -",
        SYSEXTENTS;

   Queue pad "Tracks/Cylinder -" SYSTRKSCYL;
   Queue pad "Blocks/Track -" SYSBLKSTRK;

   Queue pad
   Queue "Tape & DASD Info:";
   Queue pad "UNIT -" SYSUNIT;
   Queue pad "VOLUME -" SYSVOLUME;

   If opt.2 = "DIRECTORY" & SYSDSORG = "PO" Then;
     Do;
       Queue pad;
       Queue "PDS/PDSE Info:";
       Queue pad "Directory blocks allocated -" SYSADIRBLK;
       Queue pad "Directory blocks used -" SYSUDIRBLK;
       Queue pad "Number of members -" SYSMEMBERS;
     End;

   QELEM;
   count = RC;

   Select;
     When opt.3 = "LIN" Then;   /*display at terminal in Line mode*/
       Do count;
         Pull line;
         Say line;
       End;
     When opt.3 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(5)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD ( FINIS )"
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   "FREE DDNAME(OUTDD)";
   "DROPBUF";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 token parm3;
     Select;
       When Abbrev("RECALL",token,3) |,
         opt.1 = "RECALL";
       When Abbrev("NORECALL",token,3) Then;
         opt.1 = "NORECALL";
       When Abbrev("DIRINFO",token,3) |,
         opt.2 = "DIRECTORY";
       When Abbrev("NODIRINFO",token,3) Then;
         opt.2 = "NODIRECTORY";
       When Abbrev("LINE",token,3) |,
            Abbrev("SCREEN",token,3) Then;
         opt.3 = Substr(token,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display all of the known information",
        pad hex04,
        "         about a dataset.",
        pad hex04,
        " Format: LDSI dsname ( NORECALL DIRINFO ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "FREE DDNAME(OUTDD)";
   "DROPBUF";
   Return (-16);
./ ADD NAME=LJUST    0102-16236-16237-0935-00180-00181-00000-APLKS   26
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Left justify the text within the ISREDIT bounds. */
/*                                                           */
/*          Excluded lines will not be processed.            */
/*                                                           */
/*  Format: LJUST   target | range                           */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*                                                           */
/* Inspired by previous XEDIT macro                          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC LJUST  */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var. = "";

   "(bndslo,bndshi) = BOUNDS";
   bndslen = bndshi - bndslo + 1;
   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   /* Parse the User Options */

   /* Parse Target and Primary passed Parms */

   Call Extract_Target;

   Mainline:

   Do i = trgt_row_from To trgt_row_to By +1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     If RC = 12 Then;
       Leave;
     newrow = Strip(Substr(row,bndslo,bndslen),'B');
     newrow = Left(newrow,bndslen);
     row = Overlay(newrow,row,bndslo,bndslen);
     "LINE" i "= (row)";
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM = hex04,
        "Purpose: Left justify the text within the ISREDIT bounds.",
        pad hex04,
        " Format: LJUST  target | range ";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=LMA      0132-14130-18022-1546-00280-00428-00000-APLKS   01
/* REXX 2018-01-22 */
/* --------------------------------------------------------- */
/* Purpose: Invoke EQALMA   to collect the output of IBM's   */
/*          DEBUG TOOL program (library module analysis)     */
/*          and present it to the user.                      */
/*          HLL compiler options and LE information will be  */
/*          included.                                        */
/*                                                           */
/*  Format: LMA     srcpds_loadlib(mbr) < ( options          */
/*                                                           */
/*  srcpds_loadlib: is the name of the source LOADLIB and    */
/*                  member, for the data to be collected.    */
/*                                                           */
/* options: (defaults) VERBOSE                               */
/*          VERBOSE/NOVERBOSE - "COMPOPTS,LEINFO"            */
/*            COMPOPTS - compiler options                    */
/*            LEINFO   - LE options                          */
/*                                                           */
/*     Use: From the ISPF Member List (3.4) of the desired   */
/*          load library (M) enter LMA      in the line      */
/*          command area beside the member name desired.     */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC LMA     */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   opt. = "";
   srcpds_loadlib = "";      /* source PDS */
   mbr = "";
   var = "";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "COMPOPTS,LEINFO";
   If opt.1 = "NOVER" Then;
     opt.1 = "";
   opt.0 = 1;

   parmstmt = opt.1;
   parmstmt = "'"parmstmt"'";

   /* Parse the EXEC Parameters */

   Parse VAR parm2 parm2 "("mbr")" .;
   If parm2 <> "" Then;
     srcpds_loadlib = Strip(Word(parm2,1),"B","'");
   Else;
     Signal Error_NO_DATA;

   If mbr = "" Then;
     Signal Error_NO_MEMBER;

   /* Test source dsname for validity */

   Call Validate_DSNAME srcpds_loadlib;
   If EC < 16 Then;
     If CC < 0 Then;
       Signal Error_INVALID_LOADLIB;
     Else;
       Nop;
   Else;
     Signal Error_INVALID_LOADLIB;

   If SYSRECFM <> "U" Then;   /*ensure that it is a loadlib*/
     Signal Error_INVALID_LOADLIB;

   "FREE  DD(EQAIN EQALIB EQASYSPF EQAPGMNM EQAPRINT)";

   "ALLOC DD(EQAIN) ",
        " UNIT(SYSDA) TRACKS SPACE(1)",
        " RECFM(F) LRECL(80)",
        " NEW ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_EQAIN;
   Address TSO "MAKEBUF";
   QUEUE " SELECT MEMBER=" || mbr;
   "EXECIO 1 DISKW EQAIN ( FINIS ";
   Address TSO "DROPBUF";

   "ALLOC DD(EQALIB) DSNAME("srcpds_loadlib")",
        " SHR ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_EQALIB;

   "ALLOC DD(EQASYSPF) DSNAME(EQAW.SEQATLIB(EQALMPFX))",
        " SHR ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_EQASYSPF;

   "ALLOC DD(EQAPGMNM) DSNAME(EQAW.SEQATLIB(EQALMPGM))",
        " SHR ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_EQAPGMNM;

   "ALLOC DD(EQAPRINT) ",
        " UNIT(SYSDA) TRACKS SPACE(5,5)",
        " RECFM(V B A) LRECL(137) BLKSIZE(0)",
        " NEW ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_EQAPRINT;

   "CALL *(EQALMA) " parmstmt;
   EC = RC;
   If RC <> 0 Then;
     Signal Error_CALL_EQALMA;

   Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(EQAPRINT)";
   Address ISPEXEC "VIEW DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";

   "FREE  DD(EQAIN EQALIB EQASYSPF EQAPGMNM EQAPRINT)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,'T',')');
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("VERBOSE",var,3) Then;
         opt.1 = "COMPOPTS,LEINFO";
       When Abbrev("NOVERBOSE",var,3) Then;
         opt.1 = "NOVER";
       Otherwise;
         Nop;
     End;
   End;

   Return;

   Validate_DSNAME: Procedure Expose EC CC SYSRECFM;

   /* Test dsname for validity */
   Arg dsname;
   CC = 0;
   arg_string = "'"dsname"' NORECALL NOSMSINFO";
   EC =  Listdsi(arg_string);
   If EC < 16 Then;
     Do;
       If SYSREASON = 0 Then;
         If SYSDSORG = "PO" | SYSDSORG = "POU" Then;
           Nop;
         Else;
           CC = -12;
       Else;
         If SYSREASON = 3  | SYSREASON = 5  | SYSREASON = 24 Then;
           CC = -12;
         Else;
           CC = -24;
     End;

   Return (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",80);
   ZERRLM  = pad hex04,
        "Purpose: Display loadlib information for a member.",
        pad hex04,
        " Format: LMA  loadlib(mbr)";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING LOADLIB";
   ZEDLMSG = "NO LOADLIB SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_NO_MEMBER:

   ZEDSMSG = "NO MEMBER";
   ZEDLMSG = "NO MEMBER SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_LOADLIB:

   ZEDSMSG = "INVALID LOADLIB";
   ZEDLMSG = "INVALID LOADLIB: "srcpds_loadlib" CC=" CC "RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_EQAIN:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD EQAIN RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_EQALIB:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD EQALIB RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_EQASYSPF:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD EQASYSPF RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_EQAPGMNM:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD EQAPGMNM RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_ALLOC_EQAPRINT:

   ZEDSMSG = "ALLOC ERROR";
   ZEDLMSG = "ALLOC ERROR FOR DD EQAPRINT RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_CALL_EQALMA:

   ZEDSMSG = "CALL ERROR";
   ZEDLMSG = "CALL ERROR FOR EQALMA RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=LNMETOK  0103-19178-19179-1406-00214-00294-00000-APLKS   16
/* REXX 2019-06-28 */
/* --------------------------------------------------------- */
/* Purpose: Invoke TSO LNMETOK to list all of the known      */
/*          entries in IBM Name/Token chain.                 */
/*                                                           */
/*  Format: LNMETOK ( options                                */
/*                                                           */
/*         options: (default) SCREEN                         */
/*                                                           */
/*                  LINE|SCREEN presentation option          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC LNMETOK */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   Numeric Digits 10;

   txt = "";
   opt. = "";
   count = 0;
   line = "";
   pad = Copies(" ",3);
   pada = Copies(" ",16);

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1;

   /* Search the IBM Name/Token service chain */
   "MAKEBUF";

   /* TCB level */
   psa_ptr = 0;
   tcb_ptr = C2D(Storage(D2X(psa_ptr+540),4));
   /* PSATOLD x'21C' current TCB */
   stcb_ptr = C2D(Storage(D2X(tcb_ptr+344),4));
   /* TCBSTCB x'158' Secondary TCB */
   nttp_ptr = C2D(Storage(D2X(stcb_ptr+200),4));
   /* STCBNTTP x'C8' Task level name token header */
   Queue "Name/Token entries for Task:";
   If nttp_ptr <> 0 Then;
     Call Chase_NTTP nttp_ptr;

   /* ASCB level */
   ascb_ptr = C2D(Storage(D2X(psa_ptr+548),4));
   /* PSAAOLD x'224' home/current Address Space Control block */
   assb_ptr = C2D(Storage(D2X(ascb_ptr+336),4));
   /* ASCBASSB x'150' Address Space Secondary block */
   nttp_ptr = C2D(Storage(D2X(assb_ptr+220),4));
   /* ASSBNTTP x'DC' Address Space level name token header */
   Queue pad;
   Queue "Name/Token entries for Address Space:";
   If nttp_ptr <> 0 Then;
     Call Chase_NTTP nttp_ptr;

   /* System level */
   cvt_ptr = C2D(Storage(D2X(psa_ptr+16),4));
   /* FLCCVT x'10' Common Vector table */
   ecvt_ptr = C2D(Storage(D2X(cvt_ptr+140),4));
   /* CVTECVT x'8C' Extended Common Vector table */
   nttpprt = C2D(Storage(D2X(ecvt_ptr+140),4));
   /* ECVTNTTP x'8C' System level name token header */
   Queue pad;
   Queue "Name/Token entries for System:";
   If nttp_ptr <> 0 Then;
     Call Chase_NTTP nttp_ptr;

   "QELEM";
   count = RC;

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do count;
         Pull line;
         Say line;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(5)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD ( FINIS )"
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   "FREE DDNAME(OUTDD)";
   "DROPBUF";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 txt parm3;
     Select;
       When Abbrev("LINE",txt,3) |,
            Abbrev("SCREEN",txt,3) Then;
         opt.1 = Substr(txt,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   Chase_NTTP:

   Parse Arg ptr;

   eyecatcher = Storage(D2X(ptr),4);
   Queue pad "NTTP x'" || D2X(ptr) || "'" eyecatcher;
   If eyecatcher <> "NTTH" Then;
     Do;
       Queue pad ">>> Invalid eye catcher found for NTTP";
       Return (-4);
     End;

   chainptr = C2D(Storage(D2X(ptr+64),4));
   Do While chainptr <> 0;
/*   nttpp0 = Storage(D2X(chainptr+0),4);    /*NTTE*/
     nttpp4 = C2X(Storage(D2X(chainptr+4),4));    */
     name = Storage(D2X(chainptr+8),16);
     pname = Translate(name,,Xrange(,'3F'x),' ');
     xname = C2X(name);
     token = Storage(D2X(chainptr+24),16);
     ptoken = Translate(token,,Xrange(,'3F'x),' ');
     xtoken = C2X(token);
     Queue pad "x'" || D2X(chainptr) || "' ",
          "N c'" || pname || "' : x'" || xname || "'";
     Queue pada "T c'" || ptoken || "' : x'" || xtoken || "'";
     chainptr = C2D(Storage(D2X(chainptr+64),4));
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: List all of the known Name/Token entries.",
        pad hex04,
        " Format: LNMETOK ( LINe|SCReen ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "FREE DDNAME(OUTDD)";
   "DROPBUF";
   Return (-16);
./ ADD NAME=MAPPEND  0108-14130-18344-1628-00145-00134-00000-APLKS   41
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: Append matching member of the source PDS to the  */
/*          target PDS.                                      */
/*                                                           */
/*  Format: MAPPEND   tgtpds_dsname                          */
/*                                                           */
/*     Use: From the ISPF Member List (3.4) enter the exec   */
/*          in the command area beside the target PDS.       */
/*          The requestor will be asked what the source PDS  */
/*          name is.  Matching members will be appended to   */
/*          the target PDS members.                          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC Member APPEND   */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2 rest;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the target PDS:";
       Parse UPPER EXTERNAL parm2 rest;
     End;

   /* Initialize Variables */

   /* Parse the User Options */

   /* none */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     tgtpds_dsname = Strip(Strip(parm2),"B","'");
   Else;
     Signal Error_NO_DATA;

   /* Mainline */

   Say "Please enter the source PDS:";
   Pull srcpds_dsname .;
   If srcpds_dsname = "" Then;
     Signal Error_NO_DATA;
   SRCPDS@@ = srcpds_dsname;
   Address ISPEXEC "VPUT (SRCPDS@@) PROFILE";

   MAKEBUF;

   Call "STKMBRS" tgtpds_dsname;
   EC = RESULT;
   If EC <> 0 Then;
     Signal End_of_EXEC;

   count = 0;
   QELEM;
   count = RC;
   RC = 0;

   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtpds_dsname")";
   EC = RC;
   If RC <> 0 Then;
     Signal End_of_EXEC;

   Do i=1 to count by 1;
     Pull mbrname;
     Address ISPEXEC "EDIT DATAID("tgtid") MEMBER("mbrname")",
         " MACRO(MAPPEND1) PARM(SRCPDS@@)";
     If RC > EC Then;
       EC = RC;
   End;
   DROPBUF;
   Address ISPEXEC "VERASE (SRCPDS@@) BOTH";

   Address ISPEXEC "LMFREE DATAID("tgtid")";

   End_of_EXEC:

   Return (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Append matching member of the source PDS",
        pad hex04,
        "         to the target PDS.",
        pad hex04,
        " Format: MAPPEND tgtpds_dsname";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "INVALID ENVIRONMENT:" addrsp_name;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=MAPPEND1 0103-14130-14329-1106-00095-00095-00000-APLKS   19
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Append source member to target member.  The      */
/*          source member name must be the same as the       */
/*          target member name.                              */
/*                                                           */
/*  Format: MAPPEND1 srcpds_dsname                           */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC MAPPEND1 */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2) NOPROCESS";
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
   Else;
     Upper parm2;
   If parm2 = "" Then;
     Signal Error_NO_DATA;

   /* Mainline Routine */

   srcpds_dsname = Strip(parm2,"B","'");

   "(currmem) = MEMBER";
   "COPY '"srcpds_dsname"("currmem")' AFTER .ZLAST";
   Select;
     When RC = 12
       Do;
         "CANCEL";
         Signal End_of_EXEC;
       End;
     When RC <> 0
       Do;
         "CANCEL";
         Signal End_of_EXEC;
       End;
   End;

   "BUILTIN SAVE";
   "END";

   End_of_EXEC:

   Return (RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISREDIT "CANCEL";
   Return (-16);

   Error_NO_MEMBER:

   ZEDSMSG = "MISSING MEMBER";
   ZEDLMSG = "NO DATASET or MEMBER FOUND";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISREDIT "CANCEL";
   Return (-16);

   Error_EDIT_MODE:

   Say "MUST BE IN EDIT MODE TO ENVOKE THIS EXEC";
   Return (-16);
./ ADD NAME=MATH     0106-14134-16028-1700-00068-00062-00000-APLKS   56
/* REXX */
/* ------------------------------------------------------- */
/*  Purpose: Compute a mathematical equation               */
/*   Format: MATH equation                                 */
/* ------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC MATH */

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Do the work */

   Interpret "answer =" parm2;

   pad = Copies(" ",70);
   hex04 = "04"x;
   ZERRLM = pad hex04,
        "The answer is:",
        pad hex04,
        parm2 "=" answer;
   ZERRSM = "";
   ZERRALRM = "NO";
   ZERRHM = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   pad = Copies(" ",50);
   hex04 = "04"x;
   ZERRLM = pad hex04,
        "Purpose: Compute a mathematical equation.",
        pad hex04,
        " Format: MATH equation";
   ZERRSM = "";
   ZERRALRM = "NO";
   ZERRHM = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;
./ ADD NAME=NBROF    0103-18190-18191-1350-00023-00046-00000-APLKS   00
/* REXX 2018-07-10 */

/* REXX function
   Invoke as: NBROF(haystack,needle);
   Return the number of occurances of needle in haystack.

   ------------------------------------------------------- */

   Parse Arg haystack, needle;

   n = 0;
   len = Length(needle);
   idx = 1;
   Do While idx > 0;
     idx = POS(needle,haystack,idx);
     If idx > 0 Then;
       Do;
         n = n + 1;
         idx = idx + len;
       End;
   End;

   Return n;
./ ADD NAME=NOTEPAD  0103-15258-15258-1702-00046-00066-00000-APLKS   45
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Macro invoked by other macros to CUT all of      */
/*          the file's/member's data and place on the        */
/*          DEFAULT clipboard to be later PASTEd in another  */
/*          file/member.                                     */
/*                                                           */
/*  Format: NOTEPAD                                          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC NOTEPAD  */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO NOPROCESS";

   /* Mainline Routine */

   "CUT REPLACE";
   "CANCEL";

   Return (RC);
./ ADD NAME=OCT2DEC  0107-19259-19270-1434-00049-00035-00000-APLKS   57
/* REXX 2019-09-27 */
/* REXX function or TSO command
   Convert base(8) number to a base(10) number
   Invoke as: base_10 = OCT2DEC(base_8);
          or: TSO OCT2DEC base_8
   ------------------------------------------------------- */

   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   base_10 = "error composition";

   ARG base_8;

   Numeric Digits 20;

   If Verify(base_8,"01234567") = 0 Then;
     Nop;
   Else;
     Signal The_End;

   base_10 = "error length";

   len = Length(base_8);
   If len > 0 & len <= 64 Then;
     Do;
       j = len;
       Do i=1 To len By +1;
         j = j-1;
         pwr_vector.i = 8**j;
       End;
     End;
   Else;
     Signal The_End;

   base_10 = 0;

   Do i=1 To len By +1;
     digit = Substr(base_8,i,1);
     base_10 = base_10 + (digit * pwr_vector.i);
   End;

   The_End:

   If invoke_type <> "COMMAND" Then;
     Return base_10;

   Say "Decimal value =" base_10;
   Return (0);
./ ADD NAME=PACK     0104-15274-15358-1755-00051-00052-00000-APLKS   41
/* REXX function
   Invoke as:    PACK(nbr,scale,prec) (commas required)
   Pack the argument.
   The argument-number must be a number.
   'Scale' is the total number of digits.
   'Prec' is the number of decimal places.
   If 'prec' is not specified, default to zero.
   If 'scale' is not specified, make it large enough to
   accommodate the number.  'Scale' must be odd.

   'C' is the positive sign-nibble; 'D' is the negative sign-nibble.
   Fill out the 'frac' with zeroes on the right.
   Fill out the 'whol' with zeroes on the left.
   Join without the decimal point and with the sign-nibble.
   Convert to hex.
   ----------------------------------------------------------------- */

   Arg nbr,scale,prec . ;              /* 347.23 5 2 */

   If \Datatype(nbr,"N") Then;
     Return("ERROR");

   Parse VALUE scale Length(nbr)  WITH scale  . ; /* 5,6 yields 5 */
   Parse VALUE prec "0"           WITH prec   . ; /* 2,0 yields 2 */

   If scale//2 Then;
     Nop;
   Else
     scale = scale + 1;                /* make it odd */

   If nbr < 0 Then;
     Do;
       sign = "D";
       nbr = nbr*-1;
     End;
   Else;
     sign = "C";

   ptpos = Pos(".",nbr);               /* 347.23 maybe */
   If ptpos = 0 Then;
     Parse value nbr "."  with  whol frac  . ;
   Else;
     Do;
       whol = Left(nbr,ptpos-1);       /* 347 */
       frac = Substr(nbr,ptpos);       /* .23 */
     End;

   frac = Left(frac,prec+1,0);         /* recognize the '.' */
   newnbr = Right(whol""Strip(frac,"L","."),scale,0)sign;

   Return (x2c(newnbr));               /* PACK */
./ ADD NAME=PDSDIR   0104-18005-18061-0919-00338-00283-00000-APLKS   58
/* REXX 2018-03-02 */
/* --------------------------------------------------------- */
/* Purpose: Extract all of the PDS directory information     */
/*          from a source PDS.                               */
/*                                                           */
/*  Format: PDSDIR  <srcpds> ( options                       */
/*                                                           */
/*         options: (default) SCREEN                         */
/*                  LINE|SCREEN|QUEUE presentation option    */
/*                  SELECT begmbr : endmbr                   */
/*                  ex: SELECT AMA : AMC                     */
/*                                                           */
/*     Use: From the ISPF Member List (3.4) enter the exec   */
/*          in the command area beside the source PDS.       */
/*                                                           */
/*  Author: J. KALINICH, X4521                               */
/*          Standardized for location by L. Slaten           */
/*          Added new features by L. Slaten                  */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC PDSDIR  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,   /*lks*/
         exec_dsname . host_env addrsp_name .;               /*lks*/

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var = "";                                                 /*lks*/
   i = 1;
   lne.i = "Name      VV.MM   Created     Changed      Size",
        " Init   Mod   ID";
   opt. = "";                                                /*lks*/
   fmem = "";                                                /*lks*/
   flen = 0;                                                 /*lks*/
   tmem = "";                                                /*lks*/
   tlen = 0;                                                 /*lks*/

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;                         /*lks*/
   If parm3 <> "" Then;                                      /*lks*/
     Call Extract_OPTIONS;                                   /*lks*/

   If opt.1 = "" Then;                                       /*lks*/
     opt.1 = "SCR";      /*screen*/                          /*lks*/
   opt.0 = 1;                                                /*lks*/

   /* Parse User Passed Parms */

   If parm2 <> "" Then;                                      /*lks*/
     srcpds_dsname = Strip(Word(parm2,1),"B","'");           /*lks*/
   Else;                                                     /*lks*/
     Signal Error_NO_DATA;                                   /*lks*/

   /* Mainline */

   /* For TSO, use the following ALLOCATE sequence */
   /* for PDS directory */

   "ALLOC DDNAME(IPDSDIR) DSNAME('"srcpds_dsname"')",
   " RECFM(F) DSORG(PS) LRECL(256) BLKSIZE(256)",
   " SHR REUSE";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_SRCPDS;

   /* For batch, use the following JCL and comment out the TSO
      ALLOCATE sequence:

     //REXX     EXEC  PGM=IRXJCL,PARM='name.of.rexx.exec'
     //SYSEXEC  DD  DSN=your.rexx.library,DISP=SHR
     //SYSTSPRT DD  SYSOUT=*
     //SYSTSIN  DD  DUMMY
     //IPDSDIR  DD  DSN=your.pds.name,DISP=SHR,
     //             DCB=(RECFM=F,DSORG=PS,LRECL=256,BLKSIZE=256)
   */

   Mainline:

   "EXECIO * DISKR IPDSDIR ( STEM DIR. FINIS "; /*read pds dir*/
   EC = RC;
   If RC <> 0 | dir.0 = 0 Then;
     Signal Error_NO_MEMBERS;

   Do blk=1 To dir.0 By +1;
     /* Collect all of the member names in the source PDS */
     usedbytes = C2D(Substr(dir.blk,1,2));
     index = 3;               /*skip past used bytes*/
     Do While index < usedbytes;
       If Substr(dir.blk,index,8) = 'FFFFFFFFFFFFFFFF'x Then;
         Leave blk;
       pds2name = Substr(dir.blk,index,8);   /*member name*/
       pds2indc = Substr(dir.blk,index+11,1);                /*lks*/
       len = Bitand(pds2indc,'1F'x);    /*isolate user data length*/
       userdata = C2D(len) * 2;         /*halfwords to bytes*/
       If userdata = 30 Then;           /*ISPF statistics?*/
         Do;
           vv = C2D(Substr(dir.blk,index+12,1));             /*lks*/
           mm = C2D(Substr(dir.blk,index+13,1));             /*lks*/
           created = Date('S',P2D(Substr(dir.blk,index+17,3)),'J');
           lastmod = Date('S',P2D(Substr(dir.blk,index+21,3)),'J');
           time = P2D(Substr(dir.blk,index+24,3));           /*lks*/
           time = Strip(time,'L','-');                       /*lks*/
           time = Substr(time,1,2)||':'||Substr(time,3,2);
           size = C2D(Substr(dir.blk,index+26,2));           /*lks*/
           init = C2D(Substr(dir.blk,index+28,2));           /*lks*/
           mod = C2D(Substr(dir.blk,index+30,2));            /*lks*/
           id = Substr(dir.blk,index+32,8);                  /*lks*/
           Select;                                           /*lks*/
             When flen = 0 Then;                             /*lks*/
               Call Build_Line_A;                            /*lks*/
             When flen > 0 & tlen = 0 Then;                  /*lks*/
               If Substr(pds2name,1,flen) = fmem Then;       /*lks*/
                 Call Build_Line_A;                          /*lks*/
             When flen > 0 & tlen > 0 Then;                  /*lks*/
               If Substr(pds2name,1,flen) >= fmem &,         /*lks*/
                    Substr(pds2name,1,tlen) <= tmem Then;    /*lks*/
                 Call Build_Line_A;                          /*lks*/
             Otherwise;                                      /*lks*/
               Nop;                                          /*lks*/
           End;                                              /*lks*/
         End;
       Else;
         Select;                                             /*lks*/
           When flen = 0 Then;                               /*lks*/
             Call Build_line_B;                              /*lks*/
           When flen > 0 & tlen = 0 Then;                    /*lks*/
             If Substr(pds2name,1,flen) = fmem Then;         /*lks*/
               Call Build_line_B;                            /*lks*/
           When flen > 0 & tlen > 0 Then;                    /*lks*/
             If Substr(pds2name,1,flen) >= fmem &,           /*lks*/
                  Substr(pds2name,1,tlen) <= tmem Then;      /*lks*/
               Call Build_line_B;                            /*lks*/
           Otherwise;                                        /*lks*/
             Nop;                                            /*lks*/
         End;                                                /*lks*/
       index = index+11+userdata+1;     /*bump entry*/       /*lks*/
     End;
   End;
   lne.0 = i;
   "FREE DDNAME(IPDSDIR)";

   Select;                                                   /*lks*/
     When opt.1 = "LIN" Then;                                /*lks*/
       /*display at terminal in Line mode*/                  /*lks*/
       Do i=1 To lne.0 By +1;                                /*lks*/
         Say lne.i;                                          /*lks*/
       End;                                                  /*lks*/
     When opt.1 = "SCR" Then;                                /*lks*/
       /*display at terminal in screen mode*/                /*lks*/
       Do;                                                   /*lks*/
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",              /*lks*/
         " LRECL(132) BLKSIZE(0)",                           /*lks*/
         " UNIT(SYSDA) TRACKS SPACE(5)",                     /*lks*/
         " NEW DELETE REUSE";                                /*lks*/
         If RC <> 0 Then;                                    /*lks*/
           Signal Error_ALLOC_TGTSEQ;                        /*lks*/
         "EXECIO * DISKW OUTDD ( STEM LNE. FINIS ";          /*lks*/
         If RC = 0 Then;                                     /*lks*/
           Do;                                               /*lks*/
             Address ISPEXEC "LMINIT DATAID("tgtid")",       /*lks*/
                  " DDNAME(OUTDD)";                          /*lks*/
             Address ISPEXEC "VIEW DATAID("tgtid")";         /*lks*/
             Address ISPEXEC "LMFREE DATAID("tgtid")";       /*lks*/
           End;                                              /*lks*/
       End;                                                  /*lks*/
     When opt.1 = "QUE" Then;                                /*lks*/
       /*queue items for later retrieval*/                   /*lks*/
       Do i=2 To lne.0 By +1;                                /*lks*/
         Queue lne.i;                                        /*lks*/
       End;                                                  /*lks*/
     Otherwise;                                              /*lks*/
       Nop;                                                  /*lks*/
   End;                                                      /*lks*/
                                                             /*lks*/
   Return (0);                                               /*lks*/

   /* ------------------------ */                            /*lks*/
   /* Local Performed Routines */                            /*lks*/
   /* ------------------------ */                            /*lks*/
                                                             /*lks*/
   Extract_Options:                                          /*lks*/
                                                             /*lks*/
   parm3 = Strip(parm3,"T",")");                             /*lks*/
   Do While parm3 <> "";                                     /*lks*/
     Parse VAR parm3 var parm3;                              /*lks*/
     Select;                                                 /*lks*/
       When Abbrev("LINE",var,3) |,                          /*lks*/
            Abbrev("SCREEN",var,3) |,                        /*lks*/
            Abbrev("QUEUE",var,3) Then;                      /*lks*/
         opt.1 = Substr(var,1,3);                            /*lks*/
       When Abbrev("SELECT",var,3) Then;                     /*lks*/
         Do;                                                 /*lks*/
           Parse VAR parm3 fmem ":" tmem parm3;              /*lks*/
           fmem = Strip(fmem);                               /*lks*/
           flen = Length(fmem);                              /*lks*/
           tmem = Strip(tmem);                               /*lks*/
           tlen = Length(tmem);                              /*lks*/
         End;                                                /*lks*/
       Otherwise;                                            /*lks*/
         Signal Error_INVALID_OPTS;                          /*lks*/
     End;                                                    /*lks*/
   End;                                                      /*lks*/
                                                             /*lks*/
   Return (0);                                               /*lks*/

   Build_Line_A:                                             /*lks*/
   i = i + 1;
   lne.i = pds2name||" ",
        Right(vv,2,0)"."Right(mm,2,0)||" ",
        created||" ",
        lastmod,
        time,
        Format(size,5),
        Format(init,5),
        Format(mod,5)||" ",
        id;
   Return (0);                                               /*lks*/

   Build_Line_B:                                             /*lks*/
   i = i + 1;                                                /*lks*/
   lne.i = pds2name;

   Return (0);                                               /*lks*/

   P2D: Procedure
   /* rexx      convert packed decimal to number */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Parse ARG number_p;
   erg = C2X(number_p);
   sign = Right(erg,1);
   number = Left(erg,Length(erg)-1);
   If sign = 'D' Then;
     Return '-'||number;
   Else;
     Return number;

   D2P: Procedure
   /* rexx   convert number to packed decimal  */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Arg number;
   If datatype(number) <> 'NUM' Then;
     Return '';
   If number < 0 Then;
      Interpret "number_p = '"ABS(number)"D'x";
   Else;
      Interpret "number_p = '"number"C'x";
   Return number_p;

   /* ------------------------- */                           /*lks*/
   /* Error Processing Routines */                           /*lks*/
   /* ------------------------- */                           /*lks*/
                                                             /*lks*/
   Error_EXEC_HELP:                                          /*lks*/
                                                             /*lks*/
   hex04 = "04"x;                                            /*lks*/
   pad = Copies(" ",62);                                     /*lks*/
   ZERRLM  = pad hex04,                                      /*lks*/
        "Purpose: Extract PDS directory information",        /*lks*/
        pad hex04,                                           /*lks*/
        "Format: PDSDIR <srcpds>",                           /*lks*/
        pad hex04,                                           /*lks*/
        "               < ( <SCREEN|LINE|QUEUE>",            /*lks*/
        pad hex04,                                           /*lks*/
        "               <SELECT begmbr : endmbr> >";         /*lks*/
   ZERRSM  = "";                                             /*lks*/
   ZERRALRM= "NO";                                           /*lks*/
   ZERRHM  = "*";                                            /*lks*/
   Address ISPEXEC "SETMSG MSG(ISRZ002)";                    /*lks*/
   Exit;                                                     /*lks*/
                                                             /*lks*/
   Error_NO_DATA:                                            /*lks*/
                                                             /*lks*/
   ZEDSMSG = "NO INPUT";                                     /*lks*/
   ZEDLMSG = "Source PDS file not specified";                /*lks*/
   Address ISPEXEC "SETMSG MSG(ISRZ000)";                    /*lks*/
   Return (-16);                                             /*lks*/
                                                             /*lks*/
   Error_ALLOC_SRCPDS:                                       /*lks*/
                                                             /*lks*/
   ZEDSMSG = "ALLOC FAILED";                                 /*lks*/
   ZEDLMSG = "Source PDS file allocation failed, RC= :" EC;  /*lks*/
   Address ISPEXEC "SETMSG MSG(ISRZ000)";                    /*lks*/
   Return (-16);                                             /*lks*/
                                                             /*lks*/
   Error_NO_MEMBERS:                                         /*lks*/
                                                             /*lks*/
   ZEDSMSG = "NO MEMBERS";                                   /*lks*/
   ZEDLMSG = "Source PDS file has no members, RC= :" EC;     /*lks*/
   Address ISPEXEC "SETMSG MSG(ISRZ000)";                    /*lks*/
   Return (-16);                                             /*lks*/
                                                             /*lks*/
   Error_ALLOC_TGTSEQ:                                       /*lks*/
                                                             /*lks*/
   ZEDSMSG = "ALLOC FAILED";                                 /*lks*/
   ZEDLMSG = "Target Seq file allocation failed, RC= :" EC;  /*lks*/
   Address ISPEXEC "SETMSG MSG(ISRZ000)";                    /*lks*/
   Return (-16);                                             /*lks*/
                                                             /*lks*/
   Error_INVALID_OPTS:                                       /*lks*/
                                                             /*lks*/
   ZEDSMSG = "INVALID OPTS";                                 /*lks*/
   ZEDLMSG = "INVALID USER OPTION:" var;                     /*lks*/
   Address ISPEXEC "SETMSG MSG(ISRZ000)";                    /*lks*/
   Exit (-16);                                               /*lks*/
                                                             /*lks*/
/* J. KALINICH, X4521 */
/* EXEC TO DEBLOCK PDS DIRECTORY                                      */
./ ADD NAME=PDSDIR1  0117-18043-19206-1103-00188-00282-00000-APLKS   39
/* REXX 2019-07-25 batch version */
/* --------------------------------------------------------- */
/* Purpose: Extract all of the PDS directory information     */
/*          from a input PDS.                                */
/*                                                           */
/*  Format: PDSDIR1  <srcpds>                                */
/*                                                           */
/*  Original Source: J. Kalinich, X4521                      */
/*     This version: L. Slaten                               */
/*       Input stack contains members to select from         */
/*       PDS directory.                                      */
/*       Output stack contains matching members found in     */
/*       PDS directory.                                      */
/*                                                           */
/* --------------------------------------------------------- */

/* Entering EXEC PDSDIR1  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;

   /* Initialize Variables */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     srcpds_dsname = Strip(Word(parm2,1),"B","'");
   Else;
     Do;
       Say "Input PDS file not specified"
       Return (-16);
     End;

   /* Retrieve stack entries */
   count = 0;
   "QELEM";         /*retrieve the nbr of items in the buffer*/
   count = RC;
   RC = 0;

   A. = "";
   Do i=1 To count By +1;
     Pull row;
     A.i = Word(row,1);
   End;
   A.0 = count;

   /* Mainline */

   "ALLOC DDNAME(IPDSDIR) DSNAME('"srcpds_dsname"')",
   " RECFM(F) DSORG(PS) LRECL(256) BLKSIZE(256)",
   " SHR REUSE";
   EC = RC;
   If RC <> 0 Then;
     Do;
       Say "Input PDS file allocation failed, RC= :" EC;
       Return (-16);
     End;

   "EXECIO * DISKR IPDSDIR ( STEM DIR. FINIS "; /*read pds dir*/
   EC = RC;
   If RC <> 0 | dir.0 = 0 Then;
     Do;
       Say "Input PDS file has no members, RC= :" EC;
       Return (-16);
     End;

   i = 1;
   Do blk=1 To dir.0 By +1;
     /* Collect all of the member names in the input PDS */
     usedbytes = C2D(Substr(dir.blk,1,2));
     index = 3;               /*skip past used bytes*/
     Do While index < usedbytes;
       If Substr(dir.blk,index,8) = 'FFFFFFFFFFFFFFFF'x Then;
         Leave blk;
       If i > A.0 Then;
         Leave blk;
       pds2name = Substr(dir.blk,index,8);   /*member name*/
       pds2indc = Substr(dir.blk,index+11,1);
       len = Bitand(pds2indc,'1F'x);    /*isolate user data length*/
       userdata = C2D(len) * 2;         /*halfwords to bytes*/
       If userdata = 30 Then;           /*ISPF statistics?*/
         Do;
           vv = C2D(Substr(dir.blk,index+12,1));
           mm = C2D(Substr(dir.blk,index+13,1));
           created = Date('S',P2D(Substr(dir.blk,index+17,3)),'J');
           lastmod = Date('S',P2D(Substr(dir.blk,index+21,3)),'J');
           timehm = P2D(Substr(dir.blk,index+24,3));
           timehm = Strip(timehm,'L','-');                  /*lks*/
           timehm = Substr(timehm,1,2)||':'||Substr(timehm,3,2);
           size = C2D(Substr(dir.blk,index+26,2));
           init = C2D(Substr(dir.blk,index+28,2));
           mod = C2D(Substr(dir.blk,index+30,2));
           id = Substr(dir.blk,index+32,8);
           Select;
             When pds2name < A.i Then;
               Nop;
             When pds2name = A.i Then;
               Do;
                 Queue pds2name||" ",
                      Right(vv,2,0)"."Right(mm,2,0)||" ",
                      created||" ",
                      lastmod,
                      timehm,
                      Format(size,5),
                      Format(init,5),
                      Format(mod,5)||" ",
                      id;
                 i = i+1;
               End;
             When pds2name > A.i Then;
               Do;
                 i = i+1;
                 Iterate;
               End;
           End;
         End;
       Else;
         Select;
           When pds2name < A.i Then;
             Nop;
           When pds2name = A.i Then;
             Do;
               Queue pds2name;
               i = i+1;
             End;
           When pds2name > A.i Then;
             Do;
               i = i+1;
               Iterate;
             End;
         End;
       index = index + 11 + userdata + 1;    /*skip to next entry*/
     End;
   End;
   "FREE DDNAME(IPDSDIR)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   P2D: Procedure
   /* rexx      convert packed decimal to number */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Parse ARG number_p;
   erg = C2X(number_p);
   sign = Right(erg,1);
   number = Left(erg,Length(erg)-1);
   If sign = 'D' Then;
     Return '-'||number;
   Else;
     Return number;

   D2P: Procedure
   /* rexx   convert number to packed decimal  */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Arg number;
   If datatype(number) <> 'NUM' Then;
     Return '';
   If number < 0 Then;
      Interpret "number_p = '"ABS(number)"D'x";
   Else;
      Interpret "number_p = '"number"C'x";
   Return number_p;

/* J. KALINICH, X4521 */
/* EXEC TO DEBLOCK PDS DIRECTORY                                      */
./ ADD NAME=PDSMLST  0104-18344-18344-1605-00410-00388-00000-APLKS   38
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: Create a member containing all of the members    */
/*          names in a source PDS.                           */
/*                                                           */
/*  Format: PDSMLST srcpds_dsname < ( options >              */
/*                                                           */
/* options:                                                  */
/*          SELECT followed by starting member name,         */
/*             colon, and ending member name                 */
/*          ex: SELECT AMA : AMC                             */
/*                                                           */
/*          | mbrmask                                        */
/*          ex: SAP%%%%A or SAP%%%%B or SAP%%%%C             */
/*                                                           */
/*     Use: From the ISPF DSLIST (3.4) panel enter the exec  */
/*          in the command area beside the source PDS.       */
/*          The requestor will be asked what the target      */
/*          PDS and member name is.                          */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC PDSMLST  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the source PDS:";
       Parse UPPER EXTERNAL parm2;
     End;

   /* Initialize Variables */
   var. = "";
   fmem = "";                 /*from member name*/
   flen = 0;                  /*from member name length*/
   tmem = "";                 /*to member name*/
   tlen = 0;                  /*to member name length*/
   mmem = ""                  /*member mask*/
   mlen = 0;                  /*member mask length*/
   lomask = "";
   himask = "";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_OPTIONS;

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     srcpds_dsname = Strip(Word(parm2,1),"B","'");
   Else;
     Signal Error_NO_DATA;

   /* Mainline */

   /* Collect all of the member names in the source PDS */

   MAKEBUF;

   Call "STKMBRS" srcpds_dsname;
   EC = RESULT;
   If EC <> 0 Then;
     Signal Error_SRC_DATASET;

   count = 0;
   QELEM;
   count = RC;
   RC = 0;

   If count = 0 Then;
     Signal Error_SRC_DATASET;

   /* Setup Output Dataset */

   Say "Please enter the output PDS:";
   /* Retrieve from the TSO terminal */
   Parse EXTERNAL tgtpds_dsname .;
   If tgtpds_dsname = "" Then;
     Signal Error_NO_DATA;
   tgtpds_dsname = Strip(tgtpds_dsname,"B",'"');

   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtpds_dsname")",
        " ENQ(EXCLU)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_DATASET;

   Address ISPEXEC "LMOPEN DATAID("tgtid")",
        " OPTION(OUTPUT)",
        " LRECL("tgtlrecl")",
        " RECFM("tgtrecfm")",
        " ORG("tgtorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_OPEN;

   If tgtorg <> "PO" Then;
     Signal Error_TGT_ORG;
   If tgtrecfm <> "FB" Then;
     Signal Error_TGT_RECFM;
   If tgtlrecl <> 80 Then;
     Signal Error_TGT_LRECL;

   Say "Please enter the output member name:";
   /* Retrieve from the TSO terminal */
   Parse EXTERNAL tgtpds_mbrname .;
   If tgtpds_mbrname = "" Then;
     Signal Error_NO_MEMBER;

   /* Delete pre-existing target member */

   Address ISPEXEC "LMMDEL DATAID("tgtid")",
        " MEMBER("tgtpds_mbrname")";
   EC = RC;
   If RC > 8 Then;
     Signal Error_TGT_MDEL;

   Do i=1 to count by 1;
     /* Retrieve from the external data queue */
     Pull mbrname;
     Select;
       When mlen > 0 Then;
         /* mask is used */
         If Bitand(himask,Left(mbrname,mlen)) =,
              Bitor(lomask,Left(mbrname,mlen)) Then;
           Call Output_WRITE;
       When flen = 0 Then;
         /* no filter */
         Call Output_WRITE;
       When flen > 0 & tlen = 0 Then;
         /* from member is supplied */
         If Substr(mbrname,1,flen) = fmem Then;
           Call Output_WRITE;
       When flen > 0 & tlen > 0 Then;
         /* from and to member is supplied */
         If Substr(mbrname,1,flen) >= fmem &,
              Substr(mbrname,1,tlen) <= tmem Then;
           Call Output_WRITE;
       Otherwise;
         /* nothing matches bypass */
         Nop;
     End;
   End;

   /* Flush output buffers of new target member */

   Address ISPEXEC "LMMADD DATAID("tgtid")",
        " MEMBER("tgtpds_mbrname")";
   EC = RC;
   If RC > 4 Then;
     Signal Error_TGT_MADD;

   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_CLOSE;

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   DROPBUF;
   Return (EC);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_OPTIONS:

   parm3 = Strip(parm3,'T',')');
   Parse VAR parm3 var.1 parm3;
   var.1 = Strip(var.1);
   Select;
     When Abbrev("SELECT",var.1) Then;
       Do;
         Parse VAR parm3 var.2 ":" var.3;
         fmem = Strip(var.2);
         flen = Length(fmem);
         tmem = Strip(var.3);
         tlen = Length(tmem);
       End;
     When Pos("%",var.1) > 0 Then;
       Do;
         mmem = Strip(var.1,"T","*");
         mlen = Length(mmem);
         lomask = Translate(mmem,'00'x,"%");
         himask = Translate(mmem,'FF'x,"%");
       End;
     Otherwise;
       Signal Error_INVALID_OPTS;
   End;

   Return (0);

   Output_WRITE:

   output = Left(mbrname,80);
   /* Insert record in target member */
   Address ISPEXEC "LMPUT DATAID("tgtid")",
        " MODE(INVAR)",
        " DATALOC(output)",
        " DATALEN(80)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_PUT;
   output = "";

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Create a member containing selected member names",
        pad hex04,
        "         of a source PDS.",
        pad hex04,
        " Format: PDSMLST srcpds_dsname",
        pad hex04,
        "                 < ( < SELECT begmbr : endmbr > | < mask > >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_SRC_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Source dataset" srcpds_dsname,
             " not found or empty, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-4);

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_NO_MEMBER:

   ZEDSMSG = "MISSING MEMBER";
   ZEDLMSG = "NO MEMBER FOUND";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISREDIT "CANCEL";
   DROPBUF;
   Return (-16);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "INVALID ENVIRONMENT:" addrsp_name;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "INVALID USER OPTIONS:" var.1 var.2 var.3;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_TGT_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " not opened, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_TGT_ORG:

   ZEDSMSG = "Invalid ORG";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " ORG <> PO";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_RECFM:

   ZEDSMSG = "Invalid RECFM";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " RECFM <> FB";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_LRECL:

   ZEDSMSG = "Invalid LRECL";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " LRECL <> 80";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_MDEL:

   ZEDSMSG = "Member DELETE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " DELETE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_PUT:

   ZEDSMSG = "PUT failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " PUT failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_MADD:

   ZEDSMSG = "Member ADD failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " ADD failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Return (-16);

   Error_TGT_CLOSE:

   ZEDSMSG = "CLOSE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " CLOSE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Return (-16);
./ ADD NAME=PDSUTIL  0126-14135-15265-1708-00383-00186-00000-APLKS   56
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Invoke Library Management commands on all        */
/*          members found in member.                         */
/*                                                           */
/*  Format: PDSUTIL member                                   */
/*                                                           */
/*     Use: From the ISPF Dataset/Member (3.4) enter         */
/*          PDSUTIL in the command area beside the member    */
/*          (created by macro PDSMLST).                      */
/*                                                           */
/*          Some additional changes will need to be made to  */
/*          member before processing.  The 1st column needs  */
/*          to be the command (DELETE,RENAME,COPY) to apply  */
/*          to each member (2nd column).  If RENAME is       */
/*          selected then the new member name needs to be    */
/*          added (3rd column).  Use macro DUP to make       */
/*          changes. COPY commands must follow all DELETE    */
/*          and RENAME commands.                             */
/*                                                           */
/*          The exec will ask for the target PDS name.       */
/*          All of the member names found in member will be  */
/*          processed using LM commands on the target PDS.   */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC PDSUTIL */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2 rest;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the control file:";
       Parse UPPER EXTERNAL parm2 rest;
     End;

   /* Initialize Variables */
   EC = "0";
   onlycpy = "";
   ctlseq_dsname = "";
   srcpds_dsname = "";
   tgtpds_dsname = "";

   /* Parse the User Options */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     ctlseq_dsname = Strip(parm2);
   Else;
     Signal Error_NO_DATA;

   /* Point to dataset with all of the members to be processed */

   "ALLOC DSNAME("ctlseq_dsname") ",
              "DDNAME(DVRLIST) SHR REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_CTL_DATASET;

   "EXECIO 0 DISKR DVRLIST ( OPEN ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_DATASET;

   /* Mainline */

   Say "Please enter the target PDS:";
   Pull tgtpds_dsname .;
   If tgtpds_dsname = "" Then;
     Signal Error_NO_DATA;

   /* Point to PDS to be modified */
   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtpds_dsname")",
        " ENQ(EXCLU)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_DATASET;

   Address ISPEXEC "LMOPEN DATAID("tgtid")",
        " OPTION(OUTPUT)",
        " ORG("tgtorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_OPEN;

   If tgtorg <> "PO" Then;
     Signal Error_TGT_ORG;

   eof = "N";
   Do While eof = "N";
     Address TSO "EXECIO 1 DISKR DVRLIST ";
     If RC = 0 Then;
       Do;
         Pull line;
         Parse UPPER VAR line command "," tgtmbr "," newmbr .;
         command = Strip(command,"B");
         tgtmbr = Strip(tgtmbr,"B");
         newmbr = Strip(newmbr,"B");
         Select;
           When Abbrev(command,"DEL") & onlycpy <> "Y" Then;
             If tgtmbr <> "" Then;
               Do;
                 Address ISPEXEC "LMMDEL DATAID("tgtid")",
                      " MEMBER("tgtmbr")";
                 EC = RC;
                 If RC > 8 Then;
                   Signal Error_TGT_MDEL;
               End;
           When Abbrev(command,"REN") & onlycpy <> "Y" Then;
             If tgtmbr <> "" & newmbr <> "" Then;
               Do;
                 Address ISPEXEC "LMMREN DATAID("tgtid")",
                      " MEMBER("tgtmbr")",
                      " NEWNAME("newmbr")";
                 EC = RC;
                 If RC > 8 Then;
                   Signal Error_TGT_MREN;
               End;
           When Abbrev(command,"COP") Then;
             If tgtmbr <> "" Then;
               Do;
                 Select;
                   When onlycpy <> "Y" Then;
                     Do;
                       onlycpy = "N";
                       Address ISPEXEC "LMCLOSE DATAID("tgtid")";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_TGT_CLOSE;
                       Say "Please enter the source PDS:";
                       Pull srcpds_dsname .;
                       If srcpds_dsname = "" Then;
                         Signal Error_NO_DATA;
                       /* Point to the source PDS */
                       Address ISPEXEC "LMINIT DATAID("srcid")",
                            " DATASET("srcpds_dsname")",
                            " ENQ(SHR)";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_SRC_DATASET;
                       Address ISPEXEC "LMCOPY FROMID("srcid")",
                            " TODATAID("tgtid")",
                            " FROMMEM("tgtmbr")",
                            " REPLACE ";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_SRC_COPY;
                       onlycpy = "Y";
                     End;
                   When onlycpy = "Y" Then;
                     Do;
                       Address ISPEXEC "LMCOPY FROMID("srcid")",
                            " TODATAID("tgtid")",
                            " FROMMEM("tgtmbr")",
                            " REPLACE ";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_SRC_COPY;
                     End;
                   Otherwise;
                     Signal Error_SRC_COPY;
                 End;
               End;
           When Abbrev(command,"COMPRE") Then;
             Do;
               Address ISPEXEC "LMCLOSE DATAID("tgtid")";
               EC = RC;
               If RC <> 0 Then;
                 Signal Error_TGT_CLOSE;
               Address ISPEXEC "LMCOMP DATAID("tgtid")";
               EC = RC;
               If RC > 8 Then;
                 Signal Error_TGT_COMPRESS;
             End;
           Otherwise;
             Signal Error_INVALID_CMD;
         End;
       End;
     Else;
       eof = "Y";
   End;

   "EXECIO 0 DISKR DVRLIST ( FINIS ";

   If Abbrev(command,"COMPRE") = 1 | onlycpy <> "" Then;
     Nop;
   Else;
     Address ISPEXEC "LMCLOSE DATAID("tgtid")";
     EC = RC;
     If RC <> 0 Then;
       Signal Error_TGT_CLOSE;

   If onlycpy <> "" Then;
     Do;
       Address ISPEXEC "LMFREE DATAID("srcid")";
       EC = RC;
       If RC <> 0 Then;
         Signal Error_SRC_FREE;
     End;

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   Exit (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Invoke LM commands found in member",
        pad hex04,
        "         against a target PDS.",
        pad hex04,
        " Format: PDSUTIL member ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_CMD:

   ZEDSMSG = "INVALID CMD";
   ZEDLMSG = "INVALID CMD FOUND IN "ctlseq_dsname,
             " CMD=" command;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("srcid")";
   Address ISPEXEC "LMFREE DATAID("srcid")";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Exit (-16);

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_CTL_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Control dataset" ctlseq_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_SRC_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Source dataset" srcpds_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_SRC_COPY:

   ZEDSMSG = "Copy failed";
   ZEDLMSG = "Copy failed on member" tgtmbr,
             " RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("srcid")";
   Address ISPEXEC "LMFREE DATAID("srcid")";
   Exit (-16);

   Error_SRC_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Source dataset" srcpds_dsname,
             " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Exit (-16);

   Error_TGT_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Target dataset" tgtpds_dsname "not opened, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_ORG:

   ZEDSMSG = "Dataset not PDS/E";
   ZEDLMSG = "Target dataset" tgtpds_dsname "not a PDS/E, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_MDEL:

   ZEDSMSG = "Member DELETE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "DELETE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_MREN:

   ZEDSMSG = "Member RENAME failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "RENAME failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_COMPRESS:

   ZEDSMSG = "Library CMPR failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "COMPRESS failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_CLOSE:

   ZEDSMSG = "CLOSE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "CLOSE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Exit (-16);
./ ADD NAME=PWRISRT  0104-17061-18344-1619-00157-00182-00000-APLKS   27
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: Invoke edit exec on all members in the target    */
/*          PDS.                                             */
/*                                                           */
/*  Format: PWRISRT  tgtpds_dsname ( execnme iparm           */
/*                                                           */
/*     Use: From the ISPF Member List (3.4) enter the exec   */
/*          in the command area beside the target PDS.       */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC PWRISRT */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   count_beg = 0;
   count = 0;
   EC = 0;

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3
   parm3 = Strip(parm3,"T",")");
   If parm3 <> "" Then;
     execnme = Word(parm3,1);
   Else;
     Signal Error_INVALID_OPTS;

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     tgtpds_dsname = Strip(Word(parm2,1),"B","'");
   Else;
     Signal Error_NO_DATA;

   /* Retrieve the PDS member list */

   MAKEBUF;

   Call "STKMBRS" tgtpds_dsname;
   EC = RESULT;
   If EC <> 0 Then;
     Signal End_of_EXEC;

   count = 0;
   QELEM;
   count = RC;
   RC = 0;

   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtpds_dsname")";
   EC = RC;
   If RC <> 0 Then;
     Signal End_of_EXEC;

   Do i=1 to count by 1;
     Pull mbrname;
     Address ISPEXEC "EDIT DATAID("tgtid") MEMBER("mbrname")",
         " MACRO("execnme") ";
     If RC > EC Then;
       Do;
         EC = RC;
         Say execnme "failed with RC=" EC;
       End;
   End;

   DROPBUF;

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   End_of_EXEC:

   Exit (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Invoke edit exec on all members found in",
        pad hex04,
        "         target PDS.",
        pad hex04,
        " Format: PWRISRT tgtpds_dsname ( execnme ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "NO EXEC NAME PASSED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=QUIT     0108-14297-16190-1052-00066-00054-00000-APLKS   58
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Used to determine if the member has been         */
/*          modified before exiting.  If not, then a         */
/*          CANCEL command is issued.  If so, then a         */
/*          a message is displayed and the user can          */
/*          then determine if it is appropriate to           */
/*          CANCEL or SAVE.  It is best if this command      */
/*          is assigned to a PF key (ex. PF3).               */
/*                                                           */
/*  Format: QUIT                                             */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC QUIT */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   /* Initialize Variables */

   "MACRO NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   /* Mainline */

   "(modflg) = DATA_CHANGED";
   If modflg = "YES" Then;
     Do;
       ZEDSMSG = "MBR MODIFIED";
       ZEDLMSG = "MEMBER has been modified";
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
     End;
   Else
     "BUILTIN CANCEL";

   Return (0);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=REPEAT   0106-16034-16034-1439-00060-00133-00000-APLKS   29
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: To repeat the last macro procedure saved in the  */
/*          user PROFILE.  Works similar to the RFIND edit   */
/*          macro for the FIND edit command.                 */
/*                                                           */
/*          The target macro procedure must be written to    */
/*          take advantage of this capability.               */
/*                                                           */
/*          This macro is most useful when assigned to a PF  */
/*          key.                                             */
/*                                                           */
/*  Format: REPEAT                                           */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC REPEAT */

   Address ISREDIT;

   "MACRO ()";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   /* Mainline */

   Address ISPEXEC "VGET (RCMD@@) PROFILE";
   If RC <> 0 Then;
     Signal Error_NO_REPEAT_CMD;

   "%"rcmd@@ "#*!*#";

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_NO_REPEAT_CMD:

   ZEDSMSG = "NO REPEAT AVAIL";
   ZEDLMSG = "No command available to repeat";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=RESEQ    0113-14134-16236-1746-00420-00397-00000-APLKS   36
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Resequence sequence numbers                      */
/*  Format: RESEQ target|range                               */
/*                <seq_strt seq_incr>                        */
/*                strt_col end_col | ( options               */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        seq_strt: beginning seq nbr                        */
/*                  defaults to the seq nbr on the first     */
/*                  body line of the screen or line that the */
/*                  cursor is positioned on (if body line)   */
/*                  the trgt_row_from will be incremented to */
/*                  the next line                            */
/*        seq_incr: increment to be added to seq nbr         */
/*                  defaults to (1000,100,10,5,1) depending  */
/*                  on the language of the member or by the  */
/*                  gap between the range                    */
/*        strt_col: start column of seq nbr                  */
/*         end_col: end column of sequence nbr               */
/*         options:                                          */
/*                  STD | COBOL                              */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC RESEQ */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   incr.1 = 1000; incr.2 = 100; incr.3 = 10;
   incr.4 = 5; incr.5 = 1; incr.6 = 0
   var. = "";
   seq_strt = 0; chg_cnt = 0;

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";

   "(automode) = AUTONUM";
   If automode = "ON" Then;
     Signal Error_PROFILE_001;

   "(recfm) = RECFM";
   If recfm = "V" Then;
     Signal Error_PROFILE_002;

   "(lrecl) = LRECL";
   If lrecl <> 80 Then;
     Signal Error_PROFILE_003;

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   "(status) = USER_STATE";

   zonelo = 1;
   zonehi = lrecl;
   "BOUNDS = (zonelo,zonehi)";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Set some of the Defaults based on the Options */

   Select;
     When lang = "COBOL" Then;
       Do;
         strt_col = 1;
         end_col = 6;
         seq_incr = 100;
       End;
     When lang = "STD" Then;
       Do;
         strt_col = 73;
         end_col = 80;
         seq_incr = 1000;
       End;
     Otherwise;
       Signal Error_INVALID_LANG;
   End;
   seq_lgth = end_col - strt_col + 1;

   /* Parse Target and Primary passed Parms */

   Call Extract_Target;

   /* Parse the Primary EXEC Parameters */

   var.3 = "";
   If parm2 <> "" Then;
     Parse VAR parm2 var.3 parm2;
   If var.3 <> "" Then;
     If Datatype(var.3,"W") Then;
       seq_strt = var.3;
     Else;
       Signal Error_SEQ_BEG;
   Else;
     Do;
       "(row) = LINE" trgt_row_from;
       If trgt_row_from > 1 Then;
         Do;
           var.3 = Substr(row,strt_col,seq_lgth);
           If Datatype(var.3,"W") Then;
             Do;
               seq_strt = var.3;
               trgt_row_from = trgt_row_from + 1;
             End;
           Else;
             Signal Error_SEQ_BEG;
         End;
     End;

   var.3 = "";
   If parm2 <> "" Then;
     Parse VAR parm2 var.3 parm2;
   If var.3 <> "" Then;
     If Datatype(var.3,"W") Then;
       seq_incr = var.3;
     Else;
       Signal Error_SEQ_INCR;
   Else;
     Do;
       "(row) = LINE" trgt_row_to;
       If trgt_row_to < trgt_row_eof Then;
         Do;
           var.3 = Substr(row,strt_col,seq_lgth);
           If Datatype(var.3,"W") Then;
             Do;
               var.3 = (var.3 - seq_strt - 1) % (trgt_row_to - trgt_row_from);
               trgt_row_to = trgt_row_to - 1;
               If var.3 = 0 Then;
                 Signal Error_NO_GAP;
               j = 2;
               If seq_incr = 1000 Then;
                 j = 1;
               Do i = j to 6;
                 If var.3 >= incr.i Then;
                   Do;
                     seq_incr = incr.i;
                     Leave i;
                   End;
               End;
               If seq_incr = 0 Then;
                 Signal Error_NO_GAP;
             End;
         End;
     End;

   var.3 = "";
   If parm2 <> "" Then;
     Parse VAR parm2 var.3 parm2;
   If var.3 <> "" Then;
     If Datatype(var.3,"W") Then;
       If var.3 >= zonelo Then;
         strt_col = var.3;
       Else;
         Signal Error_COL_BEG;

   var.3 = "";
   If parm2 <> "" Then;
     Parse VAR parm2 var.3 parm2;
   If var.3 <> "" Then;
     If Datatype(var.3,"W") Then;
       If var.3 <= zonehi Then;
         end_col = var.3;
       Else;
         Signal Error_COL_END;

   Do i = trgt_row_from to trgt_row_to by 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     seq_strt = seq_strt + seq_incr;
     row = Overlay(Right(seq_strt,seq_lgth,0),row,strt_col,seq_lgth);
     "LINE" i "= (row)";
     chg_cnt = chg_cnt + 1;
   End;

   "USER_STATE = (status)";

   ZEDSMSG = Strip(chg_cnt,"L","0") "SEQed";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2 || " " || parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   Extract_Options:

   parm3 = Strip(parm3,'T',')');
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When var.3 = "STD" | var.3 = "COBOL" Then;
         lang = var.3;
       Otherwise;
         Signal Error_INVALID_OPTS;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Resequence sequence numbers",
        pad hex04,
        " Format: RESEQ target|range",
        pad hex04,
        "               <seq_strt seq_incr>",
        pad hex04,
        "               strt_col end_col | ( STD | COBOL";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_PROFILE_001:

   ZEDSMSG = "INVALID AUTONUM OPT";
   ZEDLMSG = "AUTONUM off is required";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_PROFILE_002:

   ZEDSMSG = "RECFM CONFLICT";
   ZEDLMSG = "RECFM must be fixed ("recfm")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_PROFILE_003:

   ZEDSMSG = "LRECL CONFLICT";
   ZEDLMSG = "LRECL must be 80 ("lrecl")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Exit (-16);

   Error_SEQ_BEG:

   ZEDSMSG = "INVALID BEG SEQ";
   ZEDLMSG = "Invalid beginning sequence number ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_SEQ_INCR:

   ZEDSMSG = "INVALID INCR";
   ZEDLMSG = "Invalid sequence increment ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_COL_BEG:

   ZEDSMSG = "INVALID BEG COL";
   ZEDLMSG = "Invalid beginning column ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_COL_END:

   ZEDSMSG = "INVALID END COL";
   ZEDLMSG = "Invalid ending column ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_NO_GAP:

   ZEDSMSG = "NO GAP";
   ZEDLMSG = "The gap is too small to sequence";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_OPTS:

   ZEDSMSG = "INVALID OPTS";
   ZEDLMSG = "Invalid user options ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_LANG:

   ZEDSMSG = "INVALID LANG";
   ZEDLMSG = "Language is not valid ("lang")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);
./ ADD NAME=RJUST    0102-16236-16237-0936-00180-00181-00000-APLKS   10
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Right justify the text within the ISREDIT bounds.*/
/*                                                           */
/*          Excluded lines will not be processed.            */
/*                                                           */
/*  Format: RJUST   target | range                           */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*                                                           */
/* Inspired by previous XEDIT macro                          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC RJUST  */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var. = "";

   "(bndslo,bndshi) = BOUNDS";
   bndslen = bndshi - bndslo + 1;
   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   /* Parse the User Options */

   /* Parse Target and Primary passed Parms */

   Call Extract_Target;

   Mainline:

   Do i = trgt_row_from To trgt_row_to By +1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     If RC = 12 Then;
       Leave;
     newrow = Strip(Substr(row,bndslo,bndslen),'B');
     newrow = Right(newrow,bndslen);
     row = Overlay(newrow,row,bndslo,bndslen);
     "LINE" i "= (row)";
   End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM = hex04,
        "Purpose: Right justify the text within the ISREDIT bounds.",
        pad hex04,
        " Format: RJUST  target | range ";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=RPASTE   0111-16116-16190-1139-00199-00280-00000-APLKS   41
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Paste the clipboard AFTER or BEFORE each row in  */
/*          the range.                                       */
/*                                                           */
/*  Format: RPASTE  <range>                                  */
/*                  < ( options >                            */
/*                                                           */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*                                                           */
/*         options: (default) AFTER KEEP                     */
/*                  AFTER | BEFORE                           */
/*                  DELETE | KEEP                            */
/*                  clipboard                                */
/*                                                           */
/* Inspired by Mark Zelden's INSLINES                        */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC RPASTE */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2) NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   opt. = "";       /* 1=AFTER|BEFORE 2=DELETE|KEEP 3=clipboard */
   chg_cnt = 0;     /* nbr of paste */

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;

   If parm3 <> "" Then;
     Call Extract_Options;
   If opt.1 = "" Then;
     opt.1 = "AFTER";
   If opt.2 = "" Then;
     opt.2= "KEEP";

   /* Parse Range and User passed Parms */

   If parm2 <> "" Then;
     Call Extract_Range;
   If var.1 = "" Then;
     var.1 = ".ZFIRST";
   If var.2 = "" Then;
     var.2 = ".ZLAST";

   "(linenbr) = LINENUM" var.1;
   trgt_row_from = linenbr;
   "(linenbr) = LINENUM" var.2;
   trgt_row_to   = linenbr;
   minval = Min(trgt_row_from,trgt_row_to);
   maxval = Max(trgt_row_from,trgt_row_to);

   /* Do the Job */

   Do i = maxval To minval By -1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       iterate i;
     "CURSOR =" i;
     "BUILTIN PASTE "opt.1 ".ZCSR" opt.2 opt.3;
     chg_cnt = chg_cnt + 1;
   End;

   "LOCATE" minval;

   ZEDSMSG = Strip(chg_cnt,'L','0') "PASTEs";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Range:

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "." Then;
       Do;
         trgt_row_to = var.1;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               trgt_row_from = trgt_row_to;
               trgt_row_to = var.2;
             End;
           Else;
             Signal Error_INVALID_RANGE;
       End;
     Otherwise;
       Nop;
   End;

   If (var.1 = "" & var.2 = "") | (var.1 <> "" & var.2 <> "") Then;
     Nop;
   Else;
     Signal Error_INVALID_RANGE;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Upper var.3;
     Select;
       When Abbrev("AFTER",var.3) Then;
         opt.1 = "AFTER";
       When Abbrev("BEFORE",var.3) Then;
         opt.1 = "BEFORE";
       When Abbrev("DELETE",var.3) Then;
         opt.2 = "DELETE";
       When Abbrev("KEEP",var.3) Then;
         opt.2 = "KEEP";
       Otherwise;
         opt.3 = var.3;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: PASTE clipboard AFTER or BEFORE each row in the range.",
        pad hex04,
        " Format: RPASTE < range >",
        pad hex04,
        "                < ( < AFTER | BEFORE > < DELETE | KEEP > >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_RANGE:

   ZEDSMSG = "INVALID RANGE";
   ZEDLMSG = "Range is not a valid set of labels"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_PASTE_FAILED:

   ZEDSMSG = "FAILED";
   ZEDLMSG = "PASTE failed with RC="RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=RPIJOIN  0106-14130-14329-1115-00427-00442-00000-APLKS   34
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Join RPI 80 byte source in to 150 byte source    */
/*          in the target PDS.                               */
/*                                                           */
/*  Format: RPIJOIN srcmbr                                   */
/*                                                           */
/*     Use: From the PDS member list, enter the exec in      */
/*          command area beside the member name.  The        */
/*          requestor will be asked what the target PDS      */
/*          name is.  The source member will be created in   */
/*          the target PDS.                                  */
/*                                                           */
/*  srcmbr: Name of the source/target member_name            */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC RPIJOIN  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2 .;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the source PDS and member:";
       Parse UPPER EXTERNAL parm2 .;
     End;

   /* Initialize Variables */
   exit_flag = "N";
   expand_flag = "N";
   append_flag = "N";
   insert_blank_flag = "N";

   /* Parse the User Options */

   /* none */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     Parse VAR parm2 srcdsn "(" srcmbr ")";
   Else;
     Signal Error_NO_DATA;

   srcdsn = Strip(srcdsn,"B","'");

   /* Setup Input Dataset */

   Address ISPEXEC "LMINIT DATAID("srcid")",
        " DATASET("srcdsn")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_DATASET;

   Address ISPEXEC "LMOPEN DATAID("srcid")",
        " OPTION(INPUT)",
        " LRECL("srclrecl")",
        " RECFM("srcrecfm")",
        " ORG("srcorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_OPEN;

   If srcrecfm <> "FB" Then;
     Signal Error_SRC_RECFM;
   If srclrecl <> 80 Then;
     Signal Error_SRC_LRECL;

   Address ISPEXEC "LMMFIND DATAID("srcid")",
        " MEMBER("srcmbr")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_NOTFND;

   /* Ask User for Output Dataset */

   Say "Please enter the target PDS:";
   Pull tgtdsn .;
   If tgtdsn = "" Then;
     Signal Error_NO_DATA;

   /* Setup Output Dataset */

   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtdsn")",
        " ENQ(EXCLU)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_DATASET;

   Address ISPEXEC "LMOPEN DATAID("tgtid")",
        " OPTION(OUTPUT)",
        " LRECL("tgtlrecl")",
        " RECFM("tgtrecfm")",
        " ORG("tgtorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_OPEN;

   If tgtrecfm <> "FB" Then;
     Signal Error_TGT_RECFM;
   If tgtlrecl <> 150 Then;
     Signal Error_TGT_LRECL;

   Address ISPEXEC "LMMDEL DATAID("tgtid")",
        " MEMBER("srcmbr")";
   EC = RC;
   If RC > 8 Then;
     Signal Error_TGT_MDEL;

   Call Read_SRC;
   If RC =  8 Then;
     Return (RC);

   /* Mainline */

   output = "";
   Do While exit_flag <> "Y";
     If Wordpos("EXEC RPI",input) > 0 Then;
       expand_flag = "Y";
     If Wordpos("FROM",input) > 0 Then;
       Do;
         insert_blank_flag = "Y";
         expand_flag = "N";
       End;

     If expand_flag = "N" Then;
       Do;
         If insert_blank_flag = "Y" Then;
           Do;
             insert_blank_flag = "N";
             output = Substr(output,1,150," ");
             Call Write_TGT;
           End;
         output = Substr(input,1,150," ");
         Call Write_TGT;
       End;

     If expand_flag = "Y" Then;
       Do;
         string = "";
         Select;
           When Substr(input,7,1) <> "-" Then;
             Do;
               If append_flag = "Y" Then;
                 Do;
                   append_flag = "N";
                   output = Substr(output,1,150," ");
                   Call Write_TGT;
                   output = Substr(input,1,71," ");
                 End;
               Else;
                 If Length(output) > 0 Then;
                   Do;
                     output = Substr(output,1,150," ");
                     Call Write_TGT;
                     output = Substr(input,1,71," ");
                   End;
                 Else;
                   output = Substr(input,1,71," ");
             End;
           When Substr(input,7,1) = "-" Then;
             Do;
               append_flag = "Y";
               string = Substr(input,8,64," ");
             End;
         End;
         output = output || string;
       End;
     Call Read_SRC;
     If RC =  8 Then;
       Do;
         exit_flag = "Y";
         output = Substr(output,1,150," ");
         Call Write_TGT;
       End;
   End;

   Address ISPEXEC "LMMADD DATAID("tgtid")",
        " MEMBER("srcmbr")";
   EC = RC;
   If RC > 4 Then;
     Signal Error_TGT_MADD;

   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_CLOSE;

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   Address ISPEXEC "LMFREE DATAID("srcid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_FREE;

   Return (0);

   /* --------------- */
   /* Called Routines */
   /* --------------- */

   Read_SRC:

     Address ISPEXEC "LMGET DATAID("srcid")",
          " MODE(INVAR)",
          " DATALOC(input)",
          " DATALEN(srcrlen)",
          " MAXLEN(80)";
     EC = RC;
     If RC = 8 Then;
       Return (RC);
     If RC > 8 Then;
       Signal Error_SRC_GET;

   Return (0);

   Write_TGT:

     Address ISPEXEC "LMPUT DATAID("tgtid")",
          " MODE(INVAR)",
          " DATALOC(output)",
          " DATALEN(150)";
     EC = RC;
     If RC <> 0 Then;
       Signal Error_TGT_PUT;

     output = "";

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Join RPI 80 source to 150 byte source",
        pad hex04,
        "         in the target PDS.",
        pad hex04,
        " Format: RPIJOIN srcmbr";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "INVALID ENVIRONMENT:" addrsp_name;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Source dataset" srcdsn " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Source dataset" srcdsn " not opened, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_RECFM:

   ZEDSMSG = "Invalid RECFM";
   ZEDLMSG = "Source dataset" srcdsn " RECFM <> FB"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_LRECL:

   ZEDSMSG = "Invalid LRECL";
   ZEDLMSG = "Source dataset" srcdsn " LRECL <> 80"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_NOTFND:

   ZEDSMSG = "Member not found";
   ZEDLMSG = "Source dataset" srcdsn " member not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset" tgtdsn " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Target dataset" tgtdsn " not opened, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_RECFM:

   ZEDSMSG = "Invalid RECFM";
   ZEDLMSG = "Target dataset" tgtdsn " RECFM <> FB";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_LRECL:

   ZEDSMSG = "Invalid LRECL";
   ZEDLMSG = "Target dataset" tgtdsn " LRECL <> 150";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_MDEL:

   ZEDSMSG = "Member DELETE failed";
   ZEDLMSG = "Target dataset" tgtdsn " DELETE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_MADD:

   ZEDSMSG = "Member ADD failed";
   ZEDLMSG = "Target dataset" tgtdsn " ADD failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_CLOSE:

   ZEDSMSG = "CLOSE failed";
   ZEDLMSG = "Target dataset" tgtdsn " CLOSE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset" tgtdsn " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Source dataset" srcdsn " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_GET:

   ZEDSMSG = "GET failed";
   ZEDLMSG = "Source dataset" srcdsn " GET failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (16);

   Error_TGT_PUT:

   ZEDSMSG = "PUT failed";
   ZEDLMSG = "Target dataset" tgtdsn " PUT failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Exit (16);

   Error_Alloc_TGTPDS:

   ZEDSMSG = "Allocation failed";
   ZEDLMSG = "Target dataset" tgtdsn " ALLOC failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (16);
./ ADD NAME=RPISPLT  0107-14130-15265-1728-00415-00430-00000-APLKS   38
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Split RPI 150 byte source records in to 80 byte  */
/*          source records and write them to the target PDS  */
/*                                                           */
/*  Format: RPISPLT srcmbr      (from the member list)       */
/*       or RPISPLT 'pds(mbr)'  (from the command line)      */
/*                                                           */
/*     Use: From the PDS member list, enter the exec in      */
/*          command area beside the member name.  The        */
/*          requestor will be asked what the target PDS      */
/*          name is.  The source member will be created in   */
/*          the target PDS.                                  */
/*                                                           */
/*  srcmbr: Name of the source/target member_name            */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC RPISPLT  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2 .;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the source PDS and member:";
       Parse UPPER EXTERNAL parm2 .;
     End;

   /* Initialize Variables */
   exit_flag = "N";
   split_flag = "N";

   /* Parse the User Options */

   /* none */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     Parse VAR parm2 srcdsn "(" srcmbr ")";
   Else;
     Signal Error_NO_DATA;

   srcdsn = Strip(srcdsn,"B","'");

   /* Setup Input Dataset */

   Address ISPEXEC "LMINIT DATAID("srcid")",
        " DATASET("srcdsn")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_DATASET;

   Address ISPEXEC "LMOPEN DATAID("srcid")",
        " OPTION(INPUT)",
        " LRECL("srclrecl")",
        " RECFM("srcrecfm")",
        " ORG("srcorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_OPEN;

   If srcrecfm <> "FB" Then;
     Signal Error_SRC_RECFM;
   If srclrecl <> 150 Then;
     Signal Error_SRC_LRECL;

   Address ISPEXEC "LMMFIND DATAID("srcid")",
        " MEMBER("srcmbr")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_NOTFND;

   /* Ask User for Output Dataset */

   Say "Please enter the target PDS:";
   Pull tgtdsn .;
   If tgtdsn = "" Then;
     Signal Error_NO_DATA;

   /* Setup Output Dataset */

   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtdsn")",
        " ENQ(EXCLU)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_DATASET;

   Address ISPEXEC "LMOPEN DATAID("tgtid")",
        " OPTION(OUTPUT)",
        " LRECL("tgtlrecl")",
        " RECFM("tgtrecfm")",
        " ORG("tgtorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_OPEN;

   If tgtrecfm <> "FB" Then;
     Signal Error_TGT_RECFM;
   If tgtlrecl <> 80 Then;
     Signal Error_TGT_LRECL;

   Address ISPEXEC "LMMDEL DATAID("tgtid")",
        " MEMBER("srcmbr")";
   EC = RC;
   If RC > 8 Then;
     Signal Error_TGT_MDEL;

   Call Read_SRC;
   If RC =  8 Then;
     Return (RC);

   /* Mainline */

   Do While exit_flag <> "Y";
     If Wordpos("EXEC RPI",input) > 0 Then;
       split_flag = "Y";
     If Wordpos("FROM",input) > 0 Then;
       split_flag = "N";

     If split_flag = "N" Then;
       Do;
         output = Substr(Substr(input,1,71),1,80," ");
         Call Write_TGT;
       End;

     If split_flag = "Y" Then;
       Do;
         Parse VAR input 1 string1 72 string2 136 string3;
         seqnbr1 = Substr(string1,1,6);
         If Verify(seqnbr1,"0123456789","N") > 0 Then;
           seqnbr1 = Right("100",6,"0");
         seqnbr2 = seqnbr1 + 10;
         seqnbr2 = Right(seqnbr2,6,"0");
         seqnbr3 = seqnbr1 + 20;
         seqnbr3 = Right(seqnbr3,6,"0");
         output = Substr(string1,1,80," ");
         Call Write_TGT;
         If Verify(string3," ","N") > 0 Then;
           Do;
             string3 = seqnbr3 || "-" || string3;
             string2 = seqnbr2 || "-" || string2;
           End;
         Else;
           Do;
             string3 = "";
             If Verify(string2," ","N") > 0 Then;
               string2 = seqnbr2 || "-" || string2;
             Else;
               string2 = "";
           End;
         If Length(string2) > 0 Then;
           Do;
             output = Substr(string2,1,80," ");
             Call Write_TGT;
           End;
         If Length(string3) > 0 Then;
           Do;
             output = Substr(string3,1,80," ");
             Call Write_TGT;
           End;
       End;
     Call Read_SRC;
     If RC =  8 Then;
       exit_flag = "Y";
   End;

   Address ISPEXEC "LMMADD DATAID("tgtid")",
        " MEMBER("srcmbr")";
   EC = RC;
   If RC > 4 Then;
     Signal Error_TGT_MADD;

   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_CLOSE;

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   Address ISPEXEC "LMFREE DATAID("srcid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_FREE;

   Return (0);

   /* --------------- */
   /* Called Routines */
   /* --------------- */

   Read_SRC:

     Address ISPEXEC "LMGET DATAID("srcid")",
          " MODE(INVAR)",
          " DATALOC(input)",
          " DATALEN(srcrlen)",
          " MAXLEN(150)";
     EC = RC;
     If RC = 8 Then;
       Return (RC);
     If RC > 8 Then;
       Signal Error_SRC_GET;

   Return (0);

   Write_TGT:

     Address ISPEXEC "LMPUT DATAID("tgtid")",
          " MODE(INVAR)",
          " DATALOC(output)",
          " DATALEN(80)";
     EC = RC;
     If RC <> 0 Then;
       Signal Error_TGT_PUT;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Split RPI 150 byte records into 80 byte",
        pad hex04,
        "         records and write them to the target PDS.",
        pad hex04,
        " Format: RPISPLT srcmbr";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "INVALID ENVIRONMENT:" addrsp_name;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Source dataset" srcdsn " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Source dataset" srcdsn " not opened, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_RECFM:

   ZEDSMSG = "Invalid RECFM";
   ZEDLMSG = "Source dataset" srcdsn " RECFM <> FB"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_LRECL:

   ZEDSMSG = "Invalid LRECL";
   ZEDLMSG = "Source dataset" srcdsn " LRECL <> 150";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_NOTFND:

   ZEDSMSG = "Member not found";
   ZEDLMSG = "Source dataset" srcdsn " member not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset" tgtdsn " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Target dataset" tgtdsn " not opened, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_RECFM:

   ZEDSMSG = "Invalid RECFM";
   ZEDLMSG = "Target dataset" tgtdsn " RECFM <> FB";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_LRECL:

   ZEDSMSG = "Invalid LRECL";
   ZEDLMSG = "Target dataset" tgtdsn " LRECL <> 80";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_MDEL:

   ZEDSMSG = "Member DELETE failed";
   ZEDLMSG = "Target dataset" tgtdsn " DELETE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_MADD:

   ZEDSMSG = "Member ADD failed";
   ZEDLMSG = "Target dataset" tgtdsn " ADD failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_CLOSE:

   ZEDSMSG = "CLOSE failed";
   ZEDLMSG = "Target dataset" tgtdsn " CLOSE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset" tgtdsn " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Source dataset" srcdsn " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SRC_GET:

   ZEDSMSG = "GET failed";
   ZEDLMSG = "Source dataset" srcdsn " GET failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_TGT_PUT:

   ZEDSMSG = "PUT failed";
   ZEDLMSG = "Target dataset" tgtdsn " PUT failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_Alloc_TGTPDS:

   ZEDSMSG = "Allocation failed";
   ZEDLMSG = "Target dataset" tgtdsn " ALLOC failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SAVE     0118-14130-16028-1602-00200-00171-00000-APLKS   00
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: To verify that the module is in an acceptable    */
/*          state prior to exit.                             */
/*          1) determine if changes have been made.          */
/*             no - CANCEL                                   */
/*             yes - continue                                */
/*          2) determine if sequence nbrs are in order.      */
/*             no - resequence bad runs (optional)           */
/*             yes - continue                                */
/*          3) overlay those lines that have changed with    */
/*             the CHGID, if a change id exists.             */
/*          4) rewrite the member back to the PDS.           */
/*                                                           */
/*  Format: SAVE                                             */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SAVE */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   "(modflg) = DATA_CHANGED";
   If modflg <> "YES" Then;
     Do;
       ZEDSMSG = "NO MODS";
       ZEDLMSG = "No modifications have been made";
       Address ISPEXEC "SETMSG MSG(ISRZ000)";
       Return (0);
     End;

   /* Check for Global Variables */

   Address ISPEXEC "VGET (CHGID@@) PROFILE";
   If chgid@@ = "" Then;
     Signal Error_CHGID;

   bypass_reseq = "Y";
   Address ISPEXEC "VGET (RESEQ@@) PROFILE";
   If RC = 0 & reseq@@ = "Y" Then;
     bypass_reseq = "N";

   /* Do the job */

   from_ptr = ".ZFIRST";
   RC = 1;
   Do Until RC <= 0;
     Select;
       When RC = 1 Then;
         Do;
           "CKSEQ " from_ptr ".ZLAST";
           If RC < 0 Then;
             Signal Error_CKSEQ_MACRO;
         End;
       When RC = 4 Then;
         Do;
           If bypass_reseq = "Y" Then;
             Do;
               ZEDSMSG = "SEQ ERRORS";
               ZEDLMSG = "Sequence errors were found";
               Address ISPEXEC "SETMSG MSG(ISRZ000)";
               RC = -4;
             End;
           Else
             Do;
               "RESEQ .PTA .PTB";
               If RC <> 0 Then;
                 Signal Error_RESEQ_MACRO;
               from_ptr = ".PTB";
               "RESET LABELS";
               RC = 1;
             End;
         End;
       Otherwise;
         Nop;
     End;
     If RC > 0 Then;
       Iterate;
   End;

   If chgid@@ <> "NULL" Then;
     Do;
       "CHANGES ONLY";
       If RC <> 0 Then;
         Signal Error_CHANGES_MACRO;
       "CHGID *";
       If RC <> 0 Then;
         Signal Error_CHGID_MACRO;
     End;

   End_of_EXEC:

   "RESET";
   "BUILTIN SAVE";
   If RC <> 0 Then;
     Signal Error_SAVE_CMD;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"X;
   pad = COPIES(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Validate sequence numbers, isolate changes,",
        pad hex04,
        "         tag them with the CHGID, and SAVE the member.",
        pad hex04,
        " Format: SAVE";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_CHGID:

   ZEDSMSG = "INVALID CHGID";
   ZEDLMSG = "Invalid/missing CHGID";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_CHANGES_MACRO:

   ZEDSMSG = "ERRORS OCCURED";
   ZEDLMSG = "Errors occured in CHANGES MACRO RC =" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_CHGID_MACRO:

   ZEDSMSG = "ERRORS OCCURED";
   ZEDLMSG = "Errors occured in CHGID MACRO RC =" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_CKSEQ_MACRO:

   ZEDSMSG = "ERRORS OCCURED";
   ZEDLMSG = "Errors occured in CKSEQ MACRO RC =" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_RESEQ_MACRO:

   ZEDSMSG = "ERRORS OCCURED";
   ZEDLMSG = "Errors occured in RESEQ MACRO RC =" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_SAVE_CMD:

   ZEDSMSG = "ERRORS OCCURED";
   ZEDLMSG = "Errors occured at SAVE command RC =" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SETUPALI 0105-19002-19002-1156-00054-00054-00000-APLKS   35
/* REXX 2017-05-16 */
/* ------------------------------------------------------- */
/* Purpose: Establish Aliases for REXX exec names.         */
/*          User session initial macro.                    */
/*          Found under CUA Edit_Settings drop down.       */
/*                                                         */
/*          This is the first macro invoked within         */
/*          ISREDIT, followed by the IMACRO if specified.  */
/* ------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SETUPALI */

   Address ISREDIT;

   "MACRO NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

/* initialize variables */

   /*none*/

/* Mainline */

   "DEFINE CM       ALIAS CMORE";
   "DEFINE CSI      ALIAS CSISRCH";
   "DEFINE DD       ALIAS DDSCAN";
   "DEFINE DSNF     ALIAS DSNFLTR";
   "DEFINE FOC      ALIAS FALT";        /*find on condition*/
   "DEFINE FINDMEM  ALIAS FINDMBR";
   "DEFINE FP       ALIAS FPASTE";
   "DEFINE GDS      ALIAS GDG2GDS";
   "DEFINE MLST     ALIAS PDSMLST";
   "DEFINE Q        ALIAS QUIT";
   "DEFINE S        ALIAS STATUS";
   "DEFINE XM       ALIAS XMORE";

   Return (0);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SETUP2   0137-16075-16148-0831-00167-00162-00000-APLKS   17
/* REXX */
/* ------------------------------------------------------- */
/* Purpose: Edit Profile.  Used to set up my edit          */
/*          environment to suite my needs.                 */
/*                                                         */
/*          Establish as a IMACRO via the ISPF =2 or =3.1  */
/*          panel.                                         */
/* ------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SETUP2  */

   Address ISREDIT;

   "MACRO NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   "DEFINE SAVE RESET";

/* initialize variables */
   "(dsname) = DATASET";
   "RECOVERY ON";
   "COLS ON";

   lu_libtype = "ASM CNTL COBOL EXEC JCL PROCLIB"                       ,
                "REXXLIB RPI SRCLIB SRCBASE SYSEXEC ";

   save@@ = "N";
   Address ISPEXEC "VPUT (SAVE@@) PROFILE";

   reseq@@ = "N";
   Address ISPEXEC "VPUT (RESEQ@@) PROFILE";

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "NULL";

   If lang = "COBOL" Then;
     Signal Set_ISREDIT;

   Parse VAR dsname pds.user "." pds.group "." pds.type "." pds.rest;

   i = 0;
   If Length(pds.rest) > 0 Then;
     Do;
       i = Lastpos(".",pds.rest);
       pds.type = Strip(Substr(pds.rest,i+1));
     End;

   n = Wordpos(pds.type,lu_libtype);
   If n > 0 Then;
     Nop;
   Else;
     If pds.user <> Userid() Then;
       If lang = "NULL" Then;
         Do;
           lang@@ = lang;
           Signal Update_Profile;
         End;
       Else;
         pds.type = lang;

   Set_ISREDIT:

   Select;
     When pds.type = "COBOL" | lang = "COBOL" Then;
       Do;
         "NUMBER OFF";
         "AUTONUM OFF";
         "RIGHT 6";
         "BNDS 7 72";
         lang@@ = "COBOL";
         "DEFINE SAVE MACRO CMD";
         save@@ = "Y";
         "HILITE ON COBOL PAREN FIND";
       End;
     When pds.type = "ASM" Then;
       Do;
         "NUMBER OFF";
         "AUTONUM OFF";
         "LEFT MAX";
         "BNDS 1 72";
         lang@@ = "STD";
         "DEFINE SAVE MACRO CMD";
         save@@ = "Y";
         "HILITE ON ASM PAREN FIND";
       End;
     When pds.type = "CNTL" | pds.type = "JCL" | ,
          pds.type = "PROCLIB" Then;
       Do;
         "NUMBER OFF";
         "AUTONUM OFF";
         "LEFT MAX";
         "BNDS 1 72";
         lang@@ = "STD";
         "HILITE ON JCL PAREN FIND";
       End;
     When pds.type = "EXEC" | pds.type = "REXXLIB" | ,
          pds.type = "SYSEXEC" Then;
       Do;
         "NUMBER OFF";
         "AUTONUM OFF";
         "LEFT MAX";
         "BNDS";
         lang@@ = "STD";
         "HILITE ON REXX PAREN";
       End;
     When pds.type = "SRCLIB" | pds.type = "SRCBASE" Then;
       Do;
         "NUMBER OFF";
         "AUTONUM OFF";
         "LEFT MAX";
         "BNDS";
         "HILITE ON AUTO PAREN FIND";
       End;
     When pds.type = "RPI" Then;
       Do;
         "NUMBER OFF";
         "AUTONUM OFF";
         "RIGHT 6";
         "BNDS 7 ";
         lang@@ = "COBOL";
         "HILITE ON COBOL PAREN FIND";
       End;
     Otherwise;
       Do;
         "NUMBER OFF";
         "AUTONUM OFF";
         "LEFT MAX";
         "BNDS";
         lang@@ = "NULL";
         "HILITE ON AUTO";
       End;
   End;

   Update_Profile:

   Address ISPEXEC "VPUT (LANG@@) PROFILE";

   Address ISPEXEC "VPUT (SAVE@@) PROFILE";

   Address ISPEXEC "VGET (CHGID@@) PROFILE";
   If RC <> 0 | chgid@@ = "" Then;
     Do;
       chgid@@ = "NULL";
       Address ISPEXEC "VPUT (CHGID@@) PROFILE";
     End;

   Return (0);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SHIFT    0106-14134-16236-1747-00214-00208-00000-APLKS   50
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: This routine will shift text left or right on a  */
/*          line.                                            */
/*  Format: SHIFT target | range                             */
/*                from_col to_col                            */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        from_col: source column of the text to move        */
/*          to_col: target column of the text to move        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SHIFT */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   chg_cnt = 0;

   "(lrecl) = LRECL";

   "(bndslo,bndshi) = BOUNDS";
   end_col = bndshi;

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr + 1;

   /* Parse Target and User passed Parms */

   Call Extract_Target;

   /* Parse the Optional EXEC Parameters */

   Parse VAR parm2 var.3 parm2;
   If var.3 <> "" Then;
     Do;
       If Datatype(var.3,"N") Then;
         Do;
           from_col = var.3;
           Parse VAR parm2 var.3 parm2;
           If var.3 = "" Then;
             Signal Error_INVALID_PARM;
           If Datatype(var.3,"N") Then;
             to_col = var.3;
           Else;
             Signal Error_INVALID_PARM;
         End;
       Else;
         Signal Error_INVALID_PARM;
     End;
   str_lgth = end_col - from_col + 1;

   Do i = trgt_row_from to (trgt_row_to - 1) by 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     Select;
       When to_col > from_col Then;
         row = Insert(" ",row,from_col - 1,to_col - from_col);
       When from_col > to_col Then;
         row = Overlay(Substr(row,from_col,str_lgth),row,to_col,lrecl);
       Otherwise;
         Nop;
     End;
     "LINE" i "= (row)";
     chg_cnt = chg_cnt + 1;
   End;

   End_of_EXEC:

   ZEDSMSG = chg_cnt "LINES CHGed";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     trgt_row_from = krow;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET:
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: This routine will shift text left/right on a line",
        pad hex04,
        " Format: SHIFT target|range  from_col to_col >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_PARM:

   ZEDSMSG = "INVALID PARM";
   ZEDLMSG = "Invalid/missing parameters";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SHOWV    0120-14143-14350-1624-00079-00077-00000-APLKS   36
/* REXX */
/* ------------------------------------------------------- */
/* Purpose: Show Profile variables set for edit session.   */
/* ------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SHOWV */

   Address ISPEXEC;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "VGET (DEBUG) PROFILE";
   If debug = "" Then;
     debug = "NULL";

   "VGET (LANG@@) PROFILE";
   If lang@@ = "" Then;
     lang@@ = "NULL";

   "VGET (CHGID@@) PROFILE";
   If chgid@@ = "" Then;
     chgid@@ = "NULL";

   "VGET (RESEQ@@) PROFILE";
   If reseq@@ = "" Then;
     reseq@@ = "NULL";

   "VGET (SAVE@@) PROFILE";
   If save@@ = "" Then;
     Do;
       save@@ = "NULL";
       "VPUT (SAVE@@) PROFILE";
     End;

/* Address ISREDIT "(msklne) = MASKLINE";
   If msklne = "" | msklne = "MSKLNE" Then;
     msklne = "NULL";  */

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Show PROFILE var",
        pad hex04,
        "  DEBUG=" debug,
        pad hex04,
        "  CHGID=" chgid@@,
        pad hex04,
        "   LANG=" lang@@,
        pad hex04,
        "  SAVE=" save@@ " RESEQ=" reseq@@;
/*      pad hex04,
        "  MASKLINE=" msklne; */
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   "SETMSG MSG(ISRZ002)";

   Return (0);
./ ADD NAME=SMSINFO  0119-15297-16250-1119-00472-00046-00000-APLKS   28
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Display SMS DASD information.                    */
/*                                                           */
/*  Format: SMSINFO type ( options                           */
/*                                                           */
/*            type: (default) none                           */
/*                  DASD|STGGRP|CLASS|DATA|STORAGE|MANAGEMENT*/
/*           Where: DASD list of volumes                     */
/*                  STGGRP list of SMS storage groups        */
/*                  CLASS list of SMS Classes                */
/*                  DATA list of SMS Data Classes            */
/*                  STORAGE list of SMS Storage Classes      */
/*                  MANAGEMENT list of SMS Management Classes*/
/*                                                           */
/*         options: (default) SCREEN NOSPACE                 */
/*           Where: LINE|SCREEN presentation option          */
/*                  SPACE|NOSPACE information for DASD VOLSER*/
/*                  VOLSER=ALL|volser                        */
/*                  STGGRP=ALL|storagegroup                  */
/*                                                           */
/* Example:                                                  */
/*   TSO SMSINFO CLASS | DATA | STORAGE | MANAGEMENT         */
/*   TSO SMSINFO DASD ( VOL=ALL                              */
/*   TSO SMSINFO DASD ( VOL=volser                           */
/*   TSO SMSINFO DASD ( VOL=volser SPACE                     */
/*   TSO SMSINFO DASD ( STG=storagegroup                     */
/*   TSO SMSINFO STGGRP ( STG=ALL                            */
/*   TSO SMSINFO STGGRP ( VOL=volser                         */
/*                                                           */
/*  Volume:                                                  */
/*    VLDFLAGS - x'80' volume in conversion                  */
/*               x'40' volume online                         */
/*    VLDSGST  -                                             */
/*                                                           */
/* Stg-Grp:                                                  */
/*    SGDFLAGS - x'80' HSM auto-backup                       */
/*               x'40' auto migration                        */
/*               x'20' auto dump                             */
/*               x'10' thresholds specified                  */
/*               x'08' Guaranteed backup freq specified      */
/*               x'04' Guaranteed backup freq NOLIMIT        */
/*               x'02' interval migration                    */
/*               x'01' primary space management              */
/*                                                           */
/*  LSPACE:                                                  */
/*    DS4VTOCI - x'80' index is valid                        */
/*               x'40' index is disabled                     */
/*               x'20' extended free space management        */
/*               x'04' DIRF                                  */
/*               x'02' DIRF reclaimed                        */
/*               x'01' index created                         */
/*    DS4SMSFG - x'C0' SMS                                   */
/*               x'40' initial status                        */
/*               x'00' not SMS                               */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SMSINFO */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   type = "";
   var = "";
   opt. = "";
   line = "";
   cls. = "";
   stg. = "";
   vol. = "";
   volhdng = "VOLSER" || Right("STG-GRP",9) || Right("USER-ID",10),
        || Right("DATE/TIME ",18) || Right("TRKSZ",7),
        || Right("UCB-ADDR",10) || Right("SPACE",7),
        || Right("FREE CONTIG",14) || Right("VLDFLAGS",9),
        || Right("VLDSGST",8);
   stghdng1 = Copies(" ",54) || "+--VIO--+" Right("THRESHOLD",9);
   stghdng2 = Right("STG-GRP",8) || Right("USER-ID",10),
        || Right("DATE/TIME ",18) || Right("SGDFLAGS",9),
        || Right("TYPE",7) || Right("SIZE",6) || Right("TYPE",5),
        || Right("HIGH",5) || Right("LOW",5),
        || "  DESCRIPTION";
   spchdng1 = Copies(" ",8) || "+-----FREE-----+",
        || Right("+CNTG FREE+",13) || Copies(" ",10) || "FREE",
        || Right("FRAG",6) || Copies(" ",20) || "AVAIL",
        || Copies(" ",8) || "TRKS" || Copies(" ",8) || "DSCBs",
        || Right("DIR",6);
   spchdng2 = "VOLSER" || Right("EXTS",6) || Right("CYLS",6),
        || Right("+TRKS",6) || Right("CYLS",7) || Right("+TRKS",6),
        || Right("#FRMT-0",8) || Right("VIR",6) || Right("INDEX",6),
        || Right("DS4VTOCI",9) || Right("DS4SMSFG",9),
        || Right("DSCBs",7) || Right("#CYLS",7) || Right("/CYL",5),
        || Right("TRKSZ",7) || Right("/TRK",6),
        || Right("BLKS/TRK",9);

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   parm2 = Strip(parm2,"B");
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   If opt.2 = "" Then;
     opt.2 = "NOS";      /*nospace*/
   If opt.3 = "" Then;
     opt.3 = "NONE"      /*stggrp=none*/
   If opt.4 = "" Then;
     opt.4 = "NONE"      /*volser=none*/
   opt.0 = 4;

   /* Parse Primary passed Parms */

   Select;
     When Abbrev("CLASS",parm2,4) |,
          Abbrev("DATA",parm2,4) |,
          Abbrev("MANAGEMENT",parm2,4) |,
          Abbrev("STORAGE",parm2,4) Then;
       type = Substr(parm2,1,4);
     When Abbrev("DASD",parm2,4) Then;
       type = Substr(parm2,1,4)
     When Abbrev("STGGRP",parm2,4) Then;
       type = Substr(parm2,1,4);
     Otherwise;
       type = "DASD";
   End;

   /* Mainline */

   Makebuf;

   Queue "SYSNAME   = "MVSVAR(SYSNAME); /* system exec running */
   Queue "SYSDFP    = "MVSVAR(SYSDFP) " >>cc.vv.rr.mm";
   Queue "SYSHSM    = "SYSVAR(SYSHSM) " >>cc.vv.rr.mm";
   Queue "SYSSMS    = "MVSVAR(SYSSMS) " >>UNAVAIL | INACT | ACTIVE";
   Queue "SYSSPLEX  = "MVSVAR(SYSPLEX); /*PARMLIB(COUPLExx|LOADxx)*/

   Select;
     When type = "CLAS" | type = "DATA",
          | type = "MANA" | type = "STOR" Then;
       Do;
         stemname = "CLS.";
         If type = "CLAS" | type = "DATA" Then;
           Do;
             /* List all Data Classes on System */
             function = "DCL";
             RC = RXSMS(function,stemname);
             If RC = 0 & cls.0 > 0 Then;
               Do;
                 Queue " ";
                 Queue "There are "cls.0" Data Classes";
                 Do i=1 To cls.0;
                   Queue cls.i;
                 End;
                 cls. = "";
               End;
           End;
         If type = "CLAS" | type = "STOR" Then;
           Do;
             /* List all Storage Classes on System */
             function = "SCL";
             RC = RXSMS(function,stemname);
             If RC = 0 & cls.0 > 0 Then;
               Do;
                 Queue " ";
                 Queue "There are "cls.0" Storage Classes";
                 Do i=1 To cls.0;
                   Queue cls.i;
                 End;
                 cls. = "";
               End;
           End;
         If type = "CLAS" | type = "MANA" Then;
           Do;
             /* List all Management Classes on System */
             function = "MCL";
             RC = RXSMS(function,stemname);
             If RC = 0 & cls.0 > 0 Then;
               Do;
                 Queue " ";
                 Queue "There are "cls.0" Management Classes";
                 Do i=1 To cls.0;
                   Queue cls.i;
                 End;
                 cls. = "";
               End;
           End;
       End;
     When type = "DASD" Then;
       Do;
         stemname = "VOL.";
         Select;
           When opt.3 <> "ALL" & opt.3 <> "NONE" Then;
             Do;
               /* List all Volumes for a Storage Group */
               function = "SGV";
               RC = RXSMS(function,stemname,opt.3);
             End;
           When opt.4 = "ALL" Then;
             Do;
               /* List all Volumes on System */
               function = "AVL";
               RC = RXSMS(function,stemname);
             End;
           When opt.4 <> "NONE" Then;
             Do;
               /* List one Volume on System */
               function = "VOL";
               RC = RXSMS(function,stemname,opt.4);
             End;
           Otherwise;
             Nop;
         End;
         If RC = 0 & vol.0 > 0 Then;
           Do;
             Queue " ";
             Queue "There are "vol.0" VOLUMES";
             Queue volhdng;
             Do i=1 To vol.0;
               Parse VAR vol.i vol_volser vol_stggrp vol_userid,
                    vol_updt_date vol_updt_time vol_trksz,
                    vol_ucbadr vol_space_mb vol_free_mb,
                    vol_contig_mb vol_vldflags vol_status . ;
               Queue Left(vol_volser,6) || Right(vol_stggrp,9),
                    || Right(vol_userid,10),
                    || Right(vol_updt_date,12),
                    || Right(vol_updt_time,6),
                    || Right(vol_trksz,7) || Right(vol_ucbadr,10),
                    || Right(vol_space_mb,7),
                    || Right(vol_free_mb,7),
                    || Right(vol_contig_mb,7),
                    || Center(vol_vldflags,10),
                    || Center(vol_status,8);
             End;
             vol. = "";
           End;
         If function = "VOL" & opt.2 = "SPA" Then;
           Do;
             stemname = "SPC.";
             function = "LSPACE";
             RC = RXSMS(function,stemname,opt.4);
             If RC = 0 & spc.0 > 0 Then;
               Do;
                 Queue " ";
                 Queue "There are "spc.0" LSPACE";
                 Queue spchdng1;
                 Queue spchdng2;
                 Do i=1 To spc.0;
                   Parse VAR spc.i spc_volser spc_LSPACE_RC,
                        spc_LSPACE_vol_RC,
                        spc_free_exts spc_free_cyls spc_free_trks,
                        spc_free_contig_cyls spc_free_contig_trks,
                        spc_format0 spc_free_vir spc_frag_index,
                        spc_ds4vtoci spc_ds4smsfg spc_dscb_avail,
                        spc_dev_cyls spc_dev_trkspercyl spc_dev_trksz,
                        spc_dev_dscbspertrk spc_dev_dirblkspertrk . ;
                   Queue Left(spc_volser,6) || Right(spc_free_exts,6),
                        || Right(spc_free_cyls,6),
                        || Right(spc_free_trks,6),
                        || Right(spc_free_contig_cyls,7),
                        || Right(spc_free_contig_trks,6),
                        || Right(spc_format0,8),
                        || Right(spc_free_vir,6),
                        || Right(spc_frag_index,6),
                        || Center(spc_ds4vtoci,10),
                        || Center(spc_ds4smsfg,9),
                        || Right(spc_dscb_avail,6),
                        || Right(spc_dev_cyls,7),
                        || Right(spc_dev_trkspercyl,5),
                        || Right(spc_dev_trksz,7),
                        || Right(spc_dev_dscbspertrk,6),
                        || Right(spc_dev_dirblkspertrk,6);
                 End;
               End;
             spc. = "";
           End;
       End;
     When type = "STGG" Then;
       Do;
         stemname = "STG.";
         Select;
           When opt.3 = "ALL" Then;
             Do;
               /* List all Storage Groups on System */
               function = "SGL";
               RC = RXSMS(function,stemname);
             End;
           When opt.4 <> "ALL" & opt.4 <> "NONE" Then;
             Do;
               /* List Storage Group for a VOLSER */
               function = "VSG";
               RC = RXSMS(function,stemname,opt.4);
             End;
           Otherwise;
             Nop;
         End;
         If RC = 0 & stg.0 > 0 Then;
           Do;
             Queue " ";
             Queue "There are "stg.0" Storage Groups";
             Queue stghdng1;
             Queue stghdng2;
             Do i=1 To stg.0;
               Parse VAR stg.i stg_stggrp stg_userid,
                    stg_updt_date stg_updt_time stg_flags,
                    stg_type stg_vio_sz_mb stg_vio_devtype,
                    stg_threshold_hi stg_threshold_lo stg_desc;
               Select;
                 When stg_type = 0 Then;
                   stg_type = "POOL";
                 When stg_type = 1 Then;
                   stg_type = "VIO";
                 When stg_type = 2 Then;
                   stg_type = "DUMMY";
                 When stg_type = 3 Then;
                   stg_type = "OBJECT";
                 When stg_type = 4 Then;
                   stg_type = "OBJBUP";
                 When stg_type = 5 Then;
                   stg_type = "TAPE";
                 When stg_type = 6 Then;
                   stg_type = "CPYTGT";
                 Otherwise;
                   Nop;
               End;
               Queue Right(stg_stggrp,8),
                    || Right(stg_userid,10),
                    || Right(stg_updt_date,12),
                    || Right(stg_updt_time,6),
                    || Center(stg_flags,10),
                    || Right(stg_type,6),
                    || Right(stg_vio_sz_mb,6),
                    || Right(X2C(stg_vio_devtype),5),
                    || Right(stg_threshold_hi,4) || "%",
                    || Right(stg_threshold_lo,4) || "%",
                    || "  " || Left(stg_desc,56);
             End;
             stg. = "";
           End;
       End;
     Otherwise;
       Nop;
   End;
   Qelem;
   count = RC;

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do i=1 To count;
         Pull line;
         Say line;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(132) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(5)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD ( FINIS )"
/*       If RC = 0 Then; */
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   Dropbuf;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) Then;
         opt.1 = Substr(var,1,3);
       When Abbrev("SPACE",var,3) |,
            Abbrev("NOSPACE",var,3) Then;
         opt.2 = Substr(var,1,3);
       Otherwise;
         Do;
           Parse VAR var kwd "=" kwdval .;
           kwd = Strip(kwd,'B');
           kwdval = Strip(kwdval,'B');
           Select;
             When Abbrev("STGGRP",kwd,3) Then;
               opt.3 = kwdval;
             When Abbrev("VOLSER",kwd,3) Then;
               If Length(kwdval) = 6 Then;
                 opt.4 = kwdval;
               Else;
                 If kwdval = "ALL" Then;
                   opt.4 = kwdval;
             Otherwise;
               Nop;
           End;
         End;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display SMS information",
        pad hex04,
        " Format: SMSINFO DASD|STGGRP ( SCREEN|LINE",
        pad hex04,
        "         NOSPACE|SPACE",
        pad hex04,
        "         VOL=ALL|volser",
        pad hex04,
        "         STG=ALL|stggrp";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SPACE    0102-11278-16005-1254-01917-01910-00000-APLKS   07
/* REXX - SPACE : DASD pool utilisation                               */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 13/05/2002 - Alastair Gray - Original version            */
/* 1.0.1   - 15/05/2002 - Alastair Gray - Added CSICODE cat check     */
/* 1.0.2   - 17/05/2002 - Alastair Gray - Added Unit into display     */
/* 1.0.3   - 23/05/2002 - Alastair Gray - Added SORT option           */
/* 1.0.4   - 24/05/2002 - Alastair Gray - Handles symbolic cataloging */
/* 1.0.5   - 24/05/2002 - Alastair Gray - Added 'max' to scroll       */
/* 1.0.6   - 27/05/2002 - Alastair Gray - Added ave % to pool display */
/* 1.0.7   - 29/05/2002 - Alastair Gray - Updated help panels         */
/* 1.0.8   - 31/05/2002 - Alastair Gray - Added 'End of List'         */
/* 1.0.9   - 03/06/2002 - Alastair Gray - added dslist for group/vol  */
/* 1.0.10  - 03/06/2002 - Alastair Gray - added row count             */
/* 1.1.0   - 03/06/2002 - Alastair Gray - added 'warning' panel       */
/* 1.1.1   - 13/06/2002 - Alastair Gray - added IDCAMS auth check     */
/* 1.1.2   - 08/07/2002 - Alastair Gray - added FULLC/D/V options     */
/* 1.1.3   - 17/07/2002 - Alastair Gray - corrected volume problem    */
/* 1.1.4   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.1.5   - 13/08/2002 - Alastair Gray - changed idcams call         */
/* 1.1.6   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.1.7   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.1.8   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/* 1.3.0   - 22/09/2011 - A. Freybier   - EAV Support                 */
/* Change Details:                                                    */
/* - set limits for colouring with variables (Lim_Y / Lim_R)          */
/*   for individual setting in DISP_GROUPS: and DISP_GROUP:           */
/*                                                                    */
/* - change all space values from GB base 1000**3 to GiB (1024**3)    */
/*      to make it compatible to ISMF                                 */
/*                                                                    */
/* - POOL display with PROCESS_GROUPS instead PROCESS_GROUP           */
/*                                                                    */
/* - Subroutine BASE_DATA :                                           */
/*     - if Vol or Pool is found -                                    */
/*         setup DCOLLECT with valid VOL(__) and STOG(__) values      */
/*     - on option 'POOL' with wildcards (not allowed by DCOLLECT):   */
/*         select only volumes of masked pools                        */
/*     - "say" messages showing collection progress                   */
/*                                                                    */
/* - Subroutine DISP_VOLUME :                                         */
/*      set filesize of OUTDS to 410 for enlarged D-records           */
/*                                                                    */
/* - Panel TSPACE00 :                                                 */
/*     - new calling options                                          */
/*     - used in case of invalid call parms                           */
/*                                                                    */
/* - Panel PSPACE01 :                                                 */
/*     - all volumes without storagegroup declared as 'non-sms' group */
/*     - Total and Free GB columns adjusted                           */
/*     - 'Used' changed to 'Percent Used' with 3 columns              */
/*       TRK used percentage in Track Managed Space (EAV and non-EAV) */
/*       CYL used percentage in Cylinder Managed Space with EAV only  */
/*       VOL used percentage on volume                                */
/*     - percentage visualisation width adjusted from 31 to 21 chars  */
/*     - "Total" line adjusted                                        */
/*                                                                    */
/* - Panel TSPACE01 :                                                 */
/*     - show new sort fields PTRK PCYL PVOL instead of PCT           */
/*                                                                    */
/* - Panel PSPACE02 :                                                 */
/*     - DevType no longer displayed, 3390 is standard                */
/*     - Capacity expanded to 6 digits                                */
/*     - Freespace expanded to 6 digits                               */
/*     - Contig Free : value above 100.000 displayed as nnnT          */
/*     - 'Used' changed to 'Percent Used' with 3 columns              */
/*       TRK used percentage in Track Managed Space (EAV and non-EAV) */
/*       CYL used percentage in Cylinder Managed Space with EAV only  */
/*       VOL used percentage on volume                                */
/*     - percentage visualisation width adjusted from 31 to 21 chars  */
/*     - "Total" line adjusted                                        */
/*                                                                    */
/* - Panel TSPACE02 :                                                 */
/*     - show new sort fields PTRK PCYL PVOL instead of PCT           */
/*                                                                    */
/* x.x.x   - dd/mm/20jj - who? - what ?                               */
/*                                                                    */
/**********************************************************************/
/* Description :                                                      */
/* Uses DCOLLECT to obtain storage group details and allow review of  */
/* volume/space usage.                                                */
/* Also allows catalog validation using CSI for details.              */
/**********************************************************************/
/* Note: ISPF Table processing not used as I wanted to have individual*/
/* highlighting and this approach seemed better (at the time).        */
/**********************************************************************/
Trace O                                     /*                        */
Numeric Digits 20                           /*                        */
/**********************************************************************/
Address ISPEXEC "Control Errors Return"     /* handle errors          */
/**********************************************************************/
Arg vals                                    /*                        */
PGM_name = 'SPACE'                          /* used in tutorials      */
Lim_Y    = 85                               /* % for Yellow           */
Lim_R    = 95                               /* % for RED              */
/**********************************************************************/
Call DEFINE_HEX                             /* define hex values      */
/**********************************************************************/
val2 = Translate(vals)                      /* save vals for PARSE    */
vals = Translate(vals,'  ','()')            /* split words            */
If (Pos(val2,"DEBUG(1)") > 0) Then          /* debug option           */
 Do                                         /*                        */
  debug = 1                                 /*                        */
  Say '**(Debug)*** Debug level 1 enabled'  /*                        */
 End                                        /*                        */
Select                                      /*                        */
 When (Word(vals,1) = 'V') |,               /* volume option          */
      (Word(vals,1) = 'VOL') |,             /*                        */
      (Word(vals,1) = 'VOLUME') Then        /*                        */
  Do                                        /*                        */
   sel_flag = 'VOLUME'                      /* set flag for volume    */
/*   sel_group = Word(vals,2)                  set pattern from arg   */
   parse var val2 . '(' sel_group ')' .     /* set pattern from arg   */
   sel_group = SPACE(sel_group,0)           /* remove all blanks      */
   Call BASE_DATA                           /* get main data          */
   Call PROCESS_GROUP                       /* process for group      */
  End                                       /*                        */
 When (Word(vals,1) = 'P') |,               /* pool option            */
      (Word(vals,1) = 'POOL') Then          /*                        */
  Do                                        /*                        */
   sel_flag = 'POOL'                        /* set flag for pool      */
/* sel_group = Word(vals,2)                    set pattern from arg   */
   parse var val2 . '(' sel_group ')' .     /* set pattern from arg   */
   sel_group = SPACE(sel_group,0)           /* remove all blanks      */
   Call BASE_DATA                           /* get main data          */
   if pos(',',sel_group) > 0 |,
      pos('*',sel_group) > 0 then do
      Call PROCESS_GROUPS                   /* process multiple groups*/
     end
    else do
      Call PROCESS_GROUP                    /* process one group only */
     end
  End                                       /*                        */
/* When (Word(vals,1) = '?') Then              help option            */
/*Do                                           solved by otherwise    */
/*End                                                                 */
 When (Words(vals) = 0) Then                /* default option         */
  Do                                        /*                        */
   Call BASE_DATA                           /* get main data          */
   Call PROCESS_GROUPS                      /* process groups         */
  End                                       /*                        */
/* Otherwise NOP                                                      */
 Otherwise do                               /*                        */
   /* --------------------------------------------------------------- */
   Call CREATE_PDS                          /* build panel library    */
   Call DEFINE_TUTOR0                       /* define tutorial        */
   Call CREATE_MEMBER                       /* build panel            */
   Address ISPEXEC "LibDef ISPPLIB"         /* clear the temp alloc   */
    zerralrm = 'YES'                        /*                        */
    zerrhm = 'TSPACE00'                     /*                        */
    zerrsm = 'Invalid Parameter'            /*                        */
    zerrlm = vals' - Invalid Parameter, try again.'              /*   */
    Address ISPEXEC "Setmsg Msg(ISRZ002)"   /* general error messageid*/
   Address ISPEXEC "LibDef ISPPLIB Library Id("fil") Stack"
   Do While rc < 8                          /*                        */
    Address ISPEXEC "Display Panel(TSPACE00)"/* display help screen   */
   End                                      /*                        */
  End                                       /*                        */
End                                         /*                        */
                                            /*                        */
/**********************************************************************/
FINISH:                                     /* exit the exec        ##*/
Exit 0                                      /*                        */
/**********************************************************************/
ERROR:                                      /* exit the exec        ##*/
   Call CREATE_PDS                          /* build panel library    */
   Call DEFINE_TUTOR0                       /* define tutorial        */
   Call CREATE_MEMBER                       /* build panel            */
   Address ISPEXEC "LibDef ISPPLIB"         /* clear the temp alloc   */
    zerralrm = 'YES'                        /*                        */
    zerrhm = 'TSPACE00'                     /*                        */
    zerrsm = 'Invalid Parameter'            /*                        */
    zerrlm = val2' - No volumes found, try again.'               /*   */
    Address ISPEXEC "Setmsg Msg(ISRZ002)"   /* general error messageid*/
   Address ISPEXEC "LibDef ISPPLIB Library Id("fil") Stack"
   Do While rc < 8                          /*                        */
    Address ISPEXEC "Display Panel(TSPACE00)"/* display help screen   */
   End                                      /*                        */
Exit 8                                      /*                        */
/**********************************************************************/
PROCESS_GROUPS:                             /* process groups       ##*/
sort_parm1 = ''                             /*                        */
Call DISP_GROUPS                            /* display group setup    */
Call CREATE_PDS                             /* build panel library    */
Call DEFINE_PANEL0                          /* define panel           */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_PANEL1                          /* define panel           */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_TUTOR0                          /* define tutorial        */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_TUTOR1                          /* define tutorial        */
Call CREATE_MEMBER                          /* build panel            */
fil_pan1 = fil                              /*                        */
Address ISPEXEC "LibDef ISPPLIB Library Id("fil_pan1") Stack"
p1rc = 0                                    /*                        */
start1 = 1                                  /*                        */
data1 = Substr(save_data1,start1,4000)      /* max 50 lines ...       */
Do While (p1rc < 8)                         /*                        */
 rown = (start1+79)/80                      /* row number             */
 rowm = (Length(save_data1)-240)/80         /* max rows               */
 rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */
 rowt = Right(rowt,79)                      /* row text               */
 Address ISPEXEC "Display Panel(PSPACE01)"  /* display the panel      */
 p1rc = rc                                  /*                        */
 If (rc > 8) Then                           /*                        */
  Address ISPEXEC "SetMSG Msg("zerrmsg")"   /*                        */
 Address ISPEXEC "PQuery Panel(PSPACE01) Areaname(DATA1) ",
                        "Width(d1wid) Depth(d1dep)"
 If (zcmd = 'REFRESH') Then                 /*                        */
  Do                                        /*                        */
   Call BASE_DATA                           /* get main data          */
   Call DISP_GROUPS                         /*                        */
  End                                       /*                        */
 If (Word(zcmd,1) = 'SORT') Then            /*                        */
  Do                                        /*                        */
   Call SORT_DECODE                         /* translate SORT parms   */
   sort_parm1 = sort_parm                   /*                        */
   Call DISP_GROUPS                         /*                        */
  End                                       /*                        */
 Address ISPEXEC "VGet (zverb zscrolln zscrolla) Asis"
 Do loop = 1 to Length(data1)-79 By 80      /*                        */
  test = Substr(data1,loop,80)              /*                        */
  If (strip(test,B) = '') Then Iterate      /*                        */
  Upper test                                /*                        */
  sel_g_char = Substr(test,2,1)             /*                        */
  If (sel_g_char = 'S') Then                /*                        */
   Do                                       /*                        */
    data1 = Overlay(' ',data1,loop+1)       /*                        */
    sel_group = Strip(Substr(test,4,8))     /*                        */
    Call PROCESS_GROUP                      /*                        */
   End                                      /*                        */
  If (sel_g_char = 'C') |,                  /*                        */
     (sel_g_char = 'D') |,                  /*                        */
     (sel_g_char = 'V') Then                /*                        */
   Do                                       /*                        */
    chk = 'NO'                              /*                        */
    Address ISPEXEC "Display Panel(PSPACE00)"/* display the panel     */
    p0rc = rc                               /*                        */
    If (rc > 8) Then                        /*                        */
     Address ISPEXEC "SetMSG Msg("zerrmsg")"/*                        */
    Upper chk                               /*                        */
    If (chk = 'YES') Then                   /*                        */
     Do                                     /*                        */
      data1 = Overlay(' ',data1,loop+1)     /*                        */
      sel_v_char = sel_g_char               /*                        */
      sel_group = Strip(Substr(test,4,8))   /*                        */
      If (Strip(sel_group) = '') Then       /*                        */
       dco_parm  = 'VOL('null_vols')'       /*                        */
      Else                                  /*                        */
       dco_parm  = 'STOG('sel_group')'      /*                        */
      sel_volume = Substr(test,4,6)         /*                        */
      Call PROCESS_VOLUME                   /*                        */
     End                                    /*                        */
   End                                      /*                        */
 End                                        /*                        */
 If (zverb = 'DOWN') Then                   /*                        */
  If (zscrolla = 'MAX') Then                /*                        */
   start1 = (Length(save_data1)-79)-((d1dep-1)*80) /*                 */
  Else                                      /*                        */
   start1 = start1 + (zscrolln*80)          /*                        */
 If (zverb = 'UP') Then                     /*                        */
  If (zscrolla = 'MAX') Then                /*                        */
   start1 = 1                               /*                        */
  Else                                      /*                        */
   start1 = start1 - (zscrolln*80)          /*                        */
 If (start1 < 1) Then start1 = 1            /*                        */
 If (start1 > (Length(save_data1)-319)) Then/*                        */
  start1 = Length(save_data1) - 319         /*                        */
 data1 = Substr(save_data1,start1,4000)     /* max 50 lines ...       */
End                                         /*                        */
Address ISPEXEC "LibDef ISPPLIB"            /* clear the temp alloc   */
Address TSO     "Free Fi("fil_pan1")"       /* free the temp dsn      */
Return 0                                    /*                        */
/**********************************************************************/
PROCESS_GROUP:                              /* process single group ##*/
sort_parm2 = ''                             /*                        */
Call DISP_GROUP                             /* display vol setup      */
Call CREATE_PDS                             /* build panel library    */
Call DEFINE_PANEL0                          /* define panel           */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_PANEL2                          /* define panel           */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_TUTOR0                          /* define tutorial        */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_TUTOR2                          /* define tutorial        */
Call CREATE_MEMBER                          /* build panel            */
fil_pan2 = fil                              /*                        */
Address ISPEXEC "LibDef ISPPLIB Library Id("fil_pan2") Stack"
p2rc = 0                                    /*                        */
start2 = 1                                  /*                        */
data2 = Substr(save_data2,start2,4000)      /* max 50 lines ...       */
Do while p2rc < 8                           /*                        */
 rown = (start2+79)/80                      /* row number             */
 rowm = (Length(save_data2)-240)/80         /* max rows               */
 rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */
 rowt = Right(rowt,79)                      /* row text               */
 Address ISPEXEC "Display Panel(PSPACE02)"  /* display the panel      */
 p2rc = rc                                  /*                        */
 If (rc > 8) Then                           /*                        */
  Address ISPEXEC "SetMSG Msg("zerrmsg")"   /*                        */
 Address ISPEXEC "PQuery Panel(PSPACE02) Areaname(DATA2) ",
                        "Width(d2wid) Depth(d2dep)"
 If (zcmd = 'REFRESH') Then                 /*                        */
  Do                                        /*                        */
   Call BASE_DATA                           /* get main data          */
   Call DISP_GROUP                          /*                        */
  End                                       /*                        */
 If (Word(zcmd,1) = 'SORT') Then            /*                        */
  Do                                        /*                        */
   Call SORT_DECODE                         /* translate SORT parms   */
   sort_parm2 = sort_parm                   /*                        */
   Call DISP_GROUP                          /*                        */
  End                                       /*                        */
 If (zcmd = 'FULLC') |,                     /*                        */
    (zcmd = 'FULLD') |,                     /*                        */
    (zcmd = 'FULLV') Then                   /*                        */
  Do                                        /*                        */
   sel_v_char = Substr(zcmd,5,1)            /*                        */
   chk = 'NO'                               /*                        */
   Address ISPEXEC "Display Panel(PSPACE00)"/* display the panel      */
   p0rc = rc                                /*                        */
   If (rc > 8) Then                         /*                        */
    Address ISPEXEC "SetMSG Msg("zerrmsg")" /*                        */
   Upper chk                                /*                        */
   sel_volume = sel_group                   /*                        */
   If (chk = 'YES') Then                    /*                        */
    Do                                      /*                        */
     If (Strip(sel_group) = '') Then        /*                        */
      dco_parm  = 'VOL('null_vols')'        /*                        */
     Else                                   /*                        */
      dco_parm  = 'STOG('sel_group')'       /*                        */
     Call PROCESS_VOLUME                    /*                        */
    End                                     /*                        */
  End                                       /*                        */
 Address ISPEXEC "VGet (zverb zscrolln zscrolla) Asis"
 Do loop = 1 to Length(data2)-79 By 80      /*                        */
  test = Substr(data2,loop,80)              /*                        */
  If (strip(test,B) = '') Then Iterate      /*                        */
  Upper test                                /*                        */
  sel_v_char = Substr(test,2,1)             /*                        */
  If (sel_v_char = 'C')  |,                 /*                        */
     (sel_v_char = 'D')  |,                 /*                        */
     (sel_v_char = 'S')  |,                 /*                        */
     (sel_v_char = 'V')  Then               /*                        */
   Do                                       /*                        */
    data2 = Overlay(' ',data2,loop+1)       /*                        */
    sel_volume = Substr(test,4,6)           /*                        */
    dco_parm   = 'VOL('sel_volume')'        /*                        */
    Call PROCESS_VOLUME                     /*                        */
   End                                      /*                        */
 End                                        /*                        */
 If (zverb = 'DOWN') Then                   /*                        */
  If (zscrolla = 'MAX') Then                /*                        */
   start2 = (Length(save_data2)-79)-((d2dep-1)*80) /*                 */
  Else                                      /*                        */
   start2 = start2 + (zscrolln*80)          /*                        */
 If (zverb = 'UP') Then                     /*                        */
  If (zscrolla = 'MAX') Then                /*                        */
   start2 = 1                               /*                        */
  Else                                      /*                        */
   start2 = start2 - (zscrolln*80)          /*                        */
 If (start2 < 1) Then start2 = 1            /*                        */
 If (start2 > (Length(save_data2)-319)) Then/*                        */
  start2 = Length(save_data2) - 319         /*                        */
 data2 = Substr(save_data2,start2,4000)     /* max 50 lines ...       */
End                                         /*                        */
Address ISPEXEC "LibDef ISPPLIB"            /* clear the temp alloc   */
Address TSO     "Free Fi("fil_pan2")"       /* free the temp dsn      */
Return 0                                    /*                        */
/**********************************************************************/
PROCESS_VOLUME:                             /* process single volume##*/
sort_parm3 = ''                             /*                        */
If (sel_v_char = 'S') Then                  /*                        */
 Do                                         /*                        */
  Address ISPEXEC "LMDInit ListID(lid) Volume("sel_volume")" /*     */
  If (rc > 0) Then                          /*                        */
   Address ISPEXEC "SetMSG Msg("zerrmsg")"  /*                        */
  Else                                      /*                        */
   Address ISPEXEC "LMDDisp ListID("lid")"  /*                        */
  If (rc > 0) Then                          /*                        */
   Address ISPEXEC "SetMSG Msg("zerrmsg")"  /*                        */
  Address ISPEXEC "LMDFree ListID("lid")"   /*                        */
  Return 0                                  /*                        */
 End                                        /*                        */
Call DISP_VOLUME                            /* display vol setup      */
Call CREATE_PDS                             /* build panel library    */
Call DEFINE_PANEL3                          /* define panel           */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_TUTOR0                          /* define tutorial        */
Call CREATE_MEMBER                          /* build panel            */
Call DEFINE_TUTOR3                          /* define tutorial        */
Call CREATE_MEMBER                          /* build panel            */
fil_pan3 = fil                              /*                        */
Address ISPEXEC "LibDef ISPPLIB Library Id("fil_pan3") Stack"
p3rc = 0                                    /*                        */
start3 = 1                                  /*                        */
data3 = Substr(save_data3,start3,4000)      /* max 50 lines ...       */
Do while p3rc < 8                           /*                        */
 rown = (start3+79)/80                      /* row number             */
 rowm = (Length(save_data3)-80)/80          /* max rows               */
 rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */
 rowt = Right(rowt,79)                      /* row text               */
 Address ISPEXEC "Display Panel(PSPACE03)"  /* display the panel      */
 p3rc = rc                                  /*                        */
 If (rc > 8) Then                           /*                        */
  Address ISPEXEC "SetMSG Msg("zerrmsg")"   /*                        */
 Address ISPEXEC "PQuery Panel(PSPACE03) Areaname(DATA3) ",
                        "Width(d3wid) Depth(d3dep)"
 If (zcmd = 'REFRESH') Then                 /*                        */
  Call DISP_VOLUME                          /*                        */
 If (Word(zcmd,1) = 'SORT') Then            /*                        */
  Do                                        /*                        */
   Call SORT_DECODE                         /* translate SORT parms   */
   sort_parm3 = sort_parm                   /*                        */
   Call DISP_VOLUME                         /*                        */
  End                                       /*                        */
 Address ISPEXEC "VGet (zverb zscrolln zscrolla) Asis"
 Do loop = 1 to Length(data3)-79 By 80      /*                        */
  test = Substr(data3,loop,80)              /*                        */
  If (strip(test,B) = '') Then Iterate      /*                        */
  Upper test                                /*                        */
  sel_d_char = Substr(test,2,1)             /*                        */
  If (sel_d_char = 'B') |,                  /*                        */
     (sel_d_char = 'E') |,                  /*                        */
     (sel_d_char = 'S') |,                  /*                        */
     (sel_d_char = 'V') Then                /*                        */
   Do                                       /*                        */
    rows = rown + ((loop-1)/80)             /*                        */
    vols = Substr(datav,(rows*6)-5,6)       /*                        */
    sel_volume  = vols                      /* get correct volume     */
    data3 = Overlay(' ',data3,loop+1)       /*                        */
    sel_dataset = Strip(Substr(test,4,44))  /*                        */
    Call PROCESS_DATASET                    /*                        */
   End                                      /*                        */
 End                                        /*                        */
 If (zverb = 'DOWN') Then                   /*                        */
  If (zscrolla = 'MAX') Then                /*                        */
   start3 = (Length(save_data3)-79)-((d3dep-1)*80) /*                 */
  Else                                      /*                        */
   start3 = start3 + (zscrolln*80)          /*                        */
 If (zverb = 'UP') Then                     /*                        */
  If (zscrolla = 'MAX') Then                /*                        */
   start3 = 1                               /*                        */
  Else                                      /*                        */
   start3 = start3 - (zscrolln*80)          /*                        */
 If (start3 < 1) Then start3 = 1            /*                        */
 If (start3 > Length(save_data3)) Then start3 = Length(save_data3) - 159
 data3 = Substr(save_data3,start3,4000)     /* max 50 lines ...       */
End                                         /*                        */
Address ISPEXEC "LibDef ISPPLIB"            /* clear the temp alloc   */
Address TSO     "Free Fi("fil_pan3")"       /* free the temp dsn      */
Return 0                                    /*                        */
/**********************************************************************/
PROCESS_DATASET:                            /* process dataset      ##*/
Select                                      /*                        */
 When (sel_d_char = 'B') Then               /*                        */
  Address ISPEXEC "Browse Dataset('"sel_dataset"') Volume("sel_volume")"
 When (sel_d_char = 'E') Then               /*                        */
  Address ISPEXEC "Edit   Dataset('"sel_dataset"') Volume("sel_volume")"
 When (sel_d_char = 'S') Then               /*                        */
  Address ISPEXEC "Edit   Dataset('"sel_dataset"') Volume("sel_volume")"
 When (sel_d_char = 'V') Then               /*                        */
  Address ISPEXEC "View   Dataset('"sel_dataset"') Volume("sel_volume")"
 Otherwise NOP                              /*                        */
End                                         /*                        */
If (rc > 0) Then                            /*                        */
 Address ISPEXEC "SetMSG Msg("zerrmsg")"    /*                        */
Return 0                                    /*                        */
/**********************************************************************/
BASE_DATA:                                  /* dcollect all vols    ##*/
/* commented by lks
If (idcams_check /= 'YES') Then             /* test IDCAMS authorised */
 Do                                         /*                        */
  x = Outtrap('authpgm.')                   /*                        */
  Address TSO "PARMLIB LIST(AUTHPGM)"       /* list authorised pgms   */
  x = Outtrap()                             /*                        */
  parms_loc = Strip(authpgm.3,B)            /*                        */
  Do ids = 9 to authpgm.0                   /*                        */
   If (Pos('IDCAMS',authpgm.ids) > 0) Then  /* check if IDCAMS present*/
    Do                                      /*                        */
     idcams_check = 'YES'                   /*                        */
     Leave                                  /*                        */
    End                                     /*                        */
  End                                       /*                        */
  If (idcams_check /= 'YES') Then           /*                        */
   Do                                       /*                        */
    zerralrm = 'YES'                        /*                        */
    zerrsm = 'IDCAMS not authorised'        /*                        */
    zerrlm = 'Check 'parms_loc' and add IDCAMS to AUTHPGM section.'
    Address ISPEXEC "Setmsg Msg(ISRZ002)"   /* general error messageid*/
    Signal FINISH                           /*                        */
   End                                      /*                        */
 End                                        /*                        */
 end of commented code */
 /* ----------------------------------------------------------------- */
 /*     setup IDCAMS DCOLLECT for volume data                         */
 /* ----------------------------------------------------------------- */
say ' DCOLLECT started'
Address TSO                                 /*                        */
"NewStack"                                  /*                        */
"Alloc Fi(SYSPRINT) Da('NULLFILE') Shr Reu" /*                        */
"Alloc Fi(AMSDUMP) Da('NULLFILE') Shr Reu"  /*                        */
"Alloc Fi(SYSIN) New Lrecl(80) Reuse"       /*                        */
select
  when (sel_flag = 'POOL') &,
       (pos('*',sel_group) = 0) then do
     /* collect the data only for given storagegroup(s)             */
     /* wildcard not allowed with STOG, selection done by DISP_GROUP*/
     Queue " DCOLLECT STOG("sel_group") OUTFILE(OUTDS) NOD"
    end
  when sel_flag = 'VOLUME' then do
     /* collect the data for given volume(s) only                   */
     /* wildcards and multiple volumes allowed                      */
     Queue " DCOLLECT VOL("sel_group") OUTFILE(OUTDS) NOD"
    end
  otherwise do
     /* collect all volumes                                         */
     Queue " DCOLLECT VOL(*) OUTFILE(OUTDS) NOD"
    end
 end
Queue ""                                    /*                        */
"ExecIO * DiskW SYSIN (Finis)"              /*                        */
"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(340) Recfm(V B) Reu"
"Call *(IDCAMS)"                            /*                        */
"ExecIO * DiskR OUTDS (Stem l. Finis)"      /*                        */
"Free Fi(OUTDS)"                            /*                        */
 /* ----------------------------------------------------------------- */
say ' DCOLLECT finished - 'l.0' records found'
/*cnt_vols   = l.0                             set by selection       */
if cnt_vols = 0 then do
   Signal ERROR
  end
cnt_groups = 0                              /*                        */
tot_cap    = 0                              /*                        */
tot_alo    = 0                              /*                        */
loop       = 0
null_vols  = ''                             /* init non-SMS vol list  */
Drop cnt_group.                             /* drop for refresh       */
Do selvol = 1 To l.0                          /*                        */
 /* ----------------------------------------------------------------- */
 if selvol//100 = 0 then do
    say ' 'selvol' records scanned of 'l.0
   end
 /* ----------------------------------------------------------------- */
 dcvsglng      = C2d(Substr(l.selvol,81,2))   /* storage group name leng*/
 dcvsgtcl.selvol = Substr(l.selvol,83,dcvsglng) /* storage group name     */
  dcvsgtcl  = dcvsgtcl.selvol
  if   (sel_flag = 'POOL') Then do          /* 'POOL' selection       */
    If (sel_group /= '') &,                 /* no value set           */
       (sel_group /= '*') &,                /* wildcard for everything*/
       (pos('*',sel_group) <> 0) Then       /* wildcard used          */
     Do                                     /*                        */
      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */
      len_mask = Length(sel_mask)           /* length of mask         */
      len_sgrp = Length(dcvsgtcl)           /* length of stor group   */
      test_pos = (len_sgrp-len_mask) + 1
      If (Substr(sel_group,1,1) /= '*') Then  /*                      */
       If (Pos(sel_mask,Strip(dcvsgtcl)) <> 1) Then Iterate
      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */
       If (Pos(sel_mask,Strip(dcvsgtcl)) <> test_pos) Then Iterate
      If (Pos(sel_mask,Strip(dcvsgtcl)) = 0) Then Iterate
     End                                    /*                        */
   End                                      /*                        */
  loop = loop +1
 /* ----------------------------------------------------------------- */
 dcvvolsr.loop = Substr(l.selvol,25,6)      /* volume serial number   */
 dcvperct.loop = C2d(Substr(l.selvol,36,1)) /* percent free space     */
 dcvcylmg.loop = C2x(Substr(l.selvol,122,1)) /* bit1:0=trk, 1=cyl managd*/
 /* ----------------------------------------------------------------- */
 /* depending on dcvcylmg space values are  bit1: 0=kb , 1=mb         */
 /* ----------------------------------------------------------------- */
 dcvfresp.loop = C2d(Substr(l.selvol,37,4)) /* free space   volume    */
 dcvalloc.loop = C2d(Substr(l.selvol,41,4)) /* alloc space  volume    */
 dcvvlcap.loop = C2d(Substr(l.selvol,45,4)) /* capacity     volume    */
 dcvtrfsp.loop = C2d(Substr(l.selvol,125,4)) /* free space  trk mngd  */
 dcvtralc.loop = C2d(Substr(l.selvol,129,4)) /* alloc space trk mngd  */
 dcvtrvlc.loop = C2d(Substr(l.selvol,133,4)) /* capacity    trk mngd  */
 /* ----------------------------------------------------------------- */
 dcvfragi.loop = C2d(Substr(l.selvol,49,4)) /* fragmentation index    */
 dcvlgext.loop = C2d(Substr(l.selvol,53,4)) /* largest extent         */
 dcvdvtyp.loop = Strip(Substr(l.selvol,69,8),B) /* device type        */
 If (dcvdvtyp.loop = '3390') Then size_cyl = '849960' /* cyl in bytes */
 If (dcvdvtyp.loop = '3380') Then size_cyl = '712140' /* cyl in bytes */
 If (dcvdvtyp.loop = '3390') Then size_trk = '56664'  /* trk in bytes */
 If (dcvdvtyp.loop = '3380') Then size_trk = '47476'  /* trk in bytes */
/* ------------------------------------------------------------------ */
/*  ??? type not used                                                 */
/*                                                                    */
/*Select                                      * capacity         cyls */
/*When (dcvvlcap.loop = '1846417')  Then type = '3380-K'  * kb        */
/*When (dcvvlcap.loop = '923833')   Then type = 'm-01  '  * kb   1113 */
/*When (dcvvlcap.loop = '1847666')  Then type = '3390-2'  * kb   2226 */
/*When (dcvvlcap.loop = '2771500')  Then type = '3390-3'  * kb   3339 */
/*When (dcvvlcap.loop = '8314501')  Then type = 'm-09  '  * kb  10017 */
/*When (dcvvlcap.loop = '24943503') Then type = 'm-27  '  * kb  30051 */
/*When (dcvvlcap.loop = '49887007') Then type = 'm-54  '  * kb  60102 */
/*When (dcvvlcap.loop = '194871')   Then type = 'm-216 '  * mb 240408 */
/*Otherwise type = dcvdvtyp.loop                                      */
/*End                                                                 */
/* ------------------------------------------------------------------ */
 dcvvolsr      = dcvvolsr.loop              /* get volser             */
/* type.dcvvolsr = type                       save type, but not used */
 size_cyl.dcvvolsr = size_cyl               /* save cylinder size     */
 size_trk.dcvvolsr = size_trk               /* save track size        */
 if dcvcylmg.loop <  '80' then do           /* NON EAV    sizes in kb */
    dcvlgext.loop = (dcvlgext.loop*1024)/size_cyl /* convert to cyls  */
    tot_cap       = tot_cap + dcvvlcap.loop /* accumulate kb capacity */
    tot_alo       = tot_alo + dcvalloc.loop /* accumulate kb allocated*/
   end
  else do                                   /* EAV        sizes in MB */
    dcvlgext.loop = (dcvlgext.loop*2**20)/size_cyl    /* conv to cyls */
    tot_cap = tot_cap +(dcvvlcap.loop*1024) /* accum cyl capacity (kb)*/
    tot_cap = tot_cap +(dcvtrvlc.loop*1024) /* accum trk capacity (kb)*/
    tot_alo = tot_alo +(dcvalloc.loop*1024) /* accum cyl alloc    (kb)*/
    tot_alo = tot_alo +(dcvtralc.loop*1024) /* accum trk alloc    (kb)*/
   end
 dcvdvnum.loop = Right(D2x(C2d(Substr(l.selvol,77,2))),4,'0')/*       */
 dcvdptyp.loop = Substr(l.selvol,113,8)     /* physical device type   */
 dcvsglng      = C2d(Substr(l.selvol,81,2)) /* storage group name leng*/
 If (dcvsglng = 0) Then                     /*                        */
  null_vols = null_vols||dcvvolsr||' '      /* build non-sms vol list */
 dcvsgtcl.loop = Substr(l.selvol,83,dcvsglng) /* storage group name   */
 if strip(dcvsgtcl.loop) = '' then do
    dcvsgtcl.loop = 'non-sms'
    dcvsglng      = 7
   end
 dcvsgtcl      = dcvsgtcl.loop              /*                        */
/* ------------------------------------------------------------------ */
 If (cnt_group.dcvsgtcl > 0) Then           /* test if group known    */
  Do                                        /*                        */
   cnt_group.dcvsgtcl = cnt_group.dcvsgtcl + 1 /*                     */
   if dcvcylmg.loop <  '80' then do         /* NON EAV    sizes in kb */
      cap_group.dcvsgtcl = cap_group.dcvsgtcl + dcvvlcap.loop
      cap_g_trk.dcvsgtcl = cap_g_trk.dcvsgtcl + dcvvlcap.loop
   /* cap_g_cyl.dcvsgtcl :  no space to add                           */
      alo_group.dcvsgtcl = alo_group.dcvsgtcl + dcvalloc.loop
      alo_g_trk.dcvsgtcl = alo_g_trk.dcvsgtcl + dcvalloc.loop
   /* alo_g_cyl.dcvsgtcl :  no space to add                           */
   /* SG_w_EAVs.dcvsgtcl :  not an EAV                                */
     end
    else do                                 /* EAV        sizes in MB */
      cap_group.dcvsgtcl = cap_group.dcvsgtcl + (dcvvlcap.loop*1024)
      cap_g_trk.dcvsgtcl = cap_g_trk.dcvsgtcl + (dcvtrvlc.loop*1024)
      cap_g_cyl.dcvsgtcl = cap_g_cyl.dcvsgtcl +,
                           (dcvvlcap.loop-dcvtrvlc.loop)*1024
      alo_group.dcvsgtcl = alo_group.dcvsgtcl + (dcvalloc.loop*1024)
      alo_g_trk.dcvsgtcl = alo_g_trk.dcvsgtcl + (dcvtralc.loop*1024)
      alo_g_cyl.dcvsgtcl = alo_g_cyl.dcvsgtcl +,
                           (dcvalloc.loop-dcvtralc.loop)*1024
      SG_w_EAVs.dcvsgtcl = SG_w_EAVs.dcvsgtcl +1  /* number of EAVs   */
     end
  End                                       /*                        */
 Else                                       /*                        */
  Do                                        /* storage group unknown  */
   cnt_groups = cnt_groups + 1              /*                        */
   cnt_group.dcvsgtcl = 1                   /*                        */
   if dcvcylmg.loop < '80' then do          /* NON EAV    sizes in kb */
      cap_group.dcvsgtcl = dcvvlcap.loop    /*                        */
      cap_g_trk.dcvsgtcl = dcvvlcap.loop    /*                        */
      cap_g_cyl.dcvsgtcl = 0                /*                        */
      alo_group.dcvsgtcl = dcvalloc.loop    /*                        */
      alo_g_trk.dcvsgtcl = dcvalloc.loop    /*                        */
      alo_g_cyl.dcvsgtcl = 0                /*                        */
      SG_w_EAVs.dcvsgtcl = 0                /* count number of EAVs   */
     end
    else do                                 /* EAV        sizes in MB */
      cap_group.dcvsgtcl =  dcvvlcap.loop*1024                  /* kb */
      cap_g_trk.dcvsgtcl =  dcvtrvlc.loop*1024
      cap_g_cyl.dcvsgtcl = (dcvvlcap.loop-dcvtrvlc.loop)*1024
      alo_group.dcvsgtcl =  dcvalloc.loop*1024                  /* kb */
      alo_g_trk.dcvsgtcl =  dcvtralc.loop*1024
      alo_g_cyl.dcvsgtcl = (dcvalloc.loop-dcvtralc.loop)*1024
      SG_w_EAVs.dcvsgtcl = 1                /* count number of EAVs   */
     end
   nam_group.cnt_groups = dcvsgtcl          /*                        */
  End                                       /*                        */
End                                         /*                        */
cnt_vols = loop                             /* number of vols         */
say ' 'cnt_vols 'records selected'
Return 0                                    /*                        */
/**********************************************************************/
DISP_GROUPS:                                /*                      ##*/
data1 = ''                                  /*                        */
Do loop = 1 to cnt_groups                   /*                        */
 nam_group = nam_group.loop                 /*                        */
 cnt_group = cnt_group.nam_group            /* get the group count    */
                                            /* ---------------------- */
 alo_group = alo_group.nam_group            /* get total allocated    */
 alo_g_trk = alo_g_trk.nam_group            /* TRK mngd area          */
 alo_g_cyl = alo_g_cyl.nam_group            /* CYL mngd area          */
                                            /* ---------------------- */
 cap_group = cap_group.nam_group            /* get total capacity (KB)*/
 cap_g_trk = cap_g_trk.nam_group            /* TRK mngd area          */
 cap_g_cyl = cap_g_cyl.nam_group            /* CYL mngd area          */
                                            /* ---------------------- */
 fre_group = cap_group - alo_group          /* get total free         */
                                            /* ---------------------- */
 per_group = 0
 per_g_trk = 0
 per_g_cyl = 0
 if cap_group > 0 then do
    per_group = (alo_group / cap_group)*100 /* calculate percentage   */
   end
 if cap_g_trk > 0 then do
    per_g_trk = (alo_g_trk / cap_g_trk)*100 /* calculate percentage   */
   end
 if cap_g_cyl > 0 then do
    per_g_cyl = (alo_g_cyl / cap_g_cyl)*100 /* calculate percentage   */
   end
                                            /* ---------------------- */
/* per_disp  = Left('',Trunc((per_group*31)/100,0),'*')               */
 per_disp  = Left('',Trunc((per_group*21)/100,0),'*')
/* alo_group = Trunc((alo_group*1024)/10**9,2)   change to GB  1000**3*/
 alo_group = Trunc((alo_group)/2**20,1)     /* change to GiB, 1024**3 */
/* cap_group = Trunc((cap_group*1024)/10**9,2)   change to GB, 1000**3*/
 cap_group = Trunc((cap_group)/2**20,1)     /* change to GiB, 1024**3 */
/* fre_group = Trunc((fre_group*1024)/10**9,2)   change to GB  1000**3*/
 fre_group = Trunc((fre_group)/2**20,1)     /* change to GiB, 1024**3 */
                                            /* ---------------------- */
 Select                                     /*                        */
  When (per_group >= Lim_R) Then high = X0F /*                        */
  When (per_group >= Lim_Y) Then high = X0E /*                        */
  Otherwise high = X0D                      /*                        */
 End                                        /*                        */
                                            /* ---------------------- */
 Select                                     /*                        */
  When (per_g_trk >= Lim_R) Then high_t = X0F /*                      */
  When (per_g_trk >= Lim_Y) Then high_t = X0E /*                      */
  Otherwise high_t = X0D                    /*                        */
 End                                        /*                        */
                                            /* ---------------------- */
 Select                                     /*                        */
  When (per_g_cyl >= Lim_R) Then high_c = X0F /*                      */
  When (per_g_cyl >= Lim_Y) Then high_c = X0E /*                      */
  Otherwise high_c = X0D                    /*                        */
 End                                        /*                        */
 display = X20" "X0C||Left(nam_group,19)
 display = display||Right(cnt_group,4)
 display = display||Right(cap_group,8)
 display = display||Right(fre_group,8)
 /* --- */
 if SG_w_EAVs.nam_group > 0 then do
    display = display||high_t||Right(Trunc(per_g_trk,0),3)||"%"
    display = display||high_c||Right(Trunc(per_g_cyl,0),3)||"%"
   end
  else do
    display = display||high_t||Right(' ',4)
    display = display||high_c||Right(' ',4)
   end
 display = display||high||Right(Trunc(per_group,0),3)||"% "
 display = display||per_disp
 data1 = data1||Left(display,80)            /*                        */
End                                         /*                        */
/*        ----+----1----+----2----+----3----+----4----+----5----+----6-*/
disp_pat='   STOGROUP            VOL TOTAL   FREE    PTRK PCYL PVOL XXX'
/* disp_pat = '   STOGROUP            VOL TOTAL   FREE    PCT  XXX'   */
data    = data1                             /*                        */
sort_parm = sort_parm1                      /*                        */
sort_leng = 80                              /* set sort length        */
Call DATA_SORT                              /*                        */
data1   = data                              /*                        */
/* display = X0B||"----------------------------------------------"    */
display = X0B||substr('-',1,57,'-')
data1   = data1||Left(display,80)           /*                        */
tot_fre = tot_cap - tot_alo                 /* calculate total free   */
/* tot@fre = Format((tot_fre*1024)/10**9,6,0)  change to GB, 1000**3  */
/* tot@cap = Format((tot_cap*1024)/10**9,6,0)  change to GB, 1000**3  */
tot@fre = Format((tot_fre)/2**20,10,0)      /* change to GiB 1024**3  */
tot@cap = Format((tot_cap)/2**20,10,0)      /* change to GiB 1024**3  */
display = X0C" "X0B||Left('Total',19)||Right(cnt_vols,4)
display = display||Right(tot@cap,8)||Right(tot@fre,8)
data1   = data1||Left(display,80)           /*                        */
data1   = data1||X0C||Centre(' End of List ',79,'*')
save_data1 = data1                          /*                        */
Return 0                                    /*                        */
/**********************************************************************/
DISP_GROUP:                                 /*                      ##*/
data2 = ''                                  /*                        */
cnt_group = 0                               /*                        */
alo_group = 0                               /*                        */
cap_group = 0                               /* SMS group capacity     */
g_cap_trk = 0                               /* grp cap TRK mngd area  */
g_cap_cyl = 0                               /* grp cap CYL mngd area  */
g_alo_trk = 0                               /* grp alo TRK mngd area  */
g_alo_cyl = 0                               /* grp alo CYL mngd area  */
g_EAVs    = 0                               /* count EAV volumes      */
Do loop = 1 to cnt_vols                     /*                        */
 dcvsgtcl  = dcvsgtcl.loop                  /*                        */

 dcvvolsr  = dcvvolsr.loop                  /* volume serial          */
 Select                                     /*                        */
  When (sel_flag = 'POOL') Then             /* 'POOL' selection       */
   Do                                       /*                        */
    If (sel_group /= '') &,                 /* no value set           */
       (sel_group /= '*') Then              /* wildcard for everything*/
     Do                                     /*                        */
      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */
      len_mask = Length(sel_mask)           /* length of mask         */
      len_sgrp = Length(dcvsgtcl)           /* length of stor group   */
      test_pos = (len_sgrp-len_mask) + 1
      If (Substr(sel_group,1,1) /= '*') Then  /*                      */
       If (Pos(sel_mask,Strip(dcvsgtcl)) <> 1) Then Iterate
      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */
       If (Pos(sel_mask,Strip(dcvsgtcl)) <> test_pos) Then Iterate
      If (Pos(sel_mask,Strip(dcvsgtcl)) = 0) Then Iterate
     End                                    /*                        */
   End                                      /*                        */
  When (sel_flag = 'VOLUME') Then           /* 'POOL' selection       */
   Do                                       /*                        */
 /* ----------------------------------------------------------------- */
 /*   nothing, selection already done by DCOLLECT                     */
 /* ----------------------------------------------------------------- */
 /* If (sel_group /= '') &,                 /* no value set           */
       (sel_group /= '*') Then              /* wildcard for everything*/
     Do                                     /*                        */
      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */
      len_mask = Length(sel_mask)           /* length of mask         */
      len_sgrp = Length(dcvvolsr)           /* length of volser       */
      test_pos = (len_sgrp-len_mask) + 1
      If (Substr(sel_group,1,1) /= '*') Then  /*                      */
       If (Pos(sel_mask,Strip(dcvvolsr)) <> 1) Then Iterate
      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */
       If (Pos(sel_mask,Strip(dcvvolsr)) <> test_pos) Then Iterate
      If (Pos(sel_mask,Strip(dcvvolsr)) = 0) Then Iterate
     End */                                 /*                        */
 /* ----------------------------------------------------------------- */
   End                                      /*                        */
  Otherwise                                 /* normal option          */
   If (translate(Strip(dcvsgtcl)) /= translate(sel_group)) Then Iterate
 End                                        /*                        */
 cnt_group = cnt_group + 1                  /* members in group       */
 /* ----------------------------------------------------------------- */
 dcvperct  = dcvperct.loop                  /* percent free space     */
 per_trk   = 0
 per_cyl   = 0
 per_g_trk = 0
 per_g_cyl = 0
 high_t    = X0D
 high_c    = X0D
 if dcvcylmg.loop <  '80' then do           /* NON EAV    sizes in KB */
    /* total capacity    */
 /* dcvvlcap  = Trunc((dcvvlcap.loop*1024)/10**9,2)  GB round decimal */
    dcvvlcap  = Trunc((dcvvlcap.loop)/2**20,2) /* GiB = base 1024**3  */
    cap_group = cap_group + dcvvlcap.loop
    cap_trk   = dcvvlcap.loop                /* trk managed area   KB */
    g_cap_trk = g_cap_trk +(cap_trk/1024)    /* Grp TRK mngd area MiB */
    cap_cyl   = 0                            /* cyl managed area   KB */
    /* allocated space   */
 /* dcvalloc  = Trunc((dcvalloc.loop*1024)/10**9,2)  GB round decimal */
    dcvalloc  = Trunc((dcvalloc.loop)/2**20,2) /* GiB = base 1024**3  */
    alo_group = alo_group + dcvalloc.loop
    alo_trk   = dcvalloc.loop                /* trk managed area   KB */
    g_alo_trk = g_alo_trk +(alo_trk/1024)    /* Grp TRK mngd area MiB */
    alo_cyl   = 0                            /* cyl managed area   KB */
    /* free space        */
 /* dcvfresp  = Trunc((dcvfresp.loop*1024)/10**9,2)  GB round decimal */
    dcvfresp  = Trunc((dcvfresp.loop)/2**20,2) /* GiB = base 1024**3  */
   end
  else do                                   /* EAV        sizes in MB */
    /* -------------------------------------------------------------- */
    dcvvlcap  = Trunc((dcvvlcap.loop)/2**10,2) /* volume capacity GiB */
    cap_group = cap_group + dcvvlcap.loop*1024 /* cumulate grp    KB  */
    cap_trk   = dcvtrvlc.loop                /* trk managed area  MiB */
    g_cap_trk = g_cap_trk + cap_trk          /* Grp TRK mngd area MiB */
    cap_cyl   = dcvvlcap.loop-dcvtrvlc.loop  /* cyl managed area  MiB */
    g_cap_cyl = g_cap_cyl + cap_cyl          /* Grp CYL mngd area MiB */
    /* -------------------------------------------------------------- */
    dcvalloc  = Trunc((dcvalloc.loop)/2**10,2) /* alloc on volume GiB */
    alo_group = alo_group + dcvalloc.loop*1024 /* cumulate grp    KB  */
    alo_trk   = dcvtralc.loop                /* trk managed area  MiB */
    g_alo_trk = g_alo_trk + alo_trk          /* Grp TRK mngd area MiB */
    alo_cyl   = dcvalloc.loop-dcvtralc.loop  /* cyl managed area  MiB */
    g_alo_cyl = g_alo_cyl + alo_cyl          /* Grp CYL mngd area MiB */
    /* --------------------------------------- trk managed area ----- */
    If (cap_trk  > 0) Then DO               /* check for zero capacity*/
       per_trk   = (alo_trk/cap_trk) * 100  /* calculate percentage   */
       Select
        When (per_trk >= Lim_R) Then high_t = X0F
        When (per_trk >= Lim_Y) Then high_t = X0E
        Otherwise high_t = X0D
       End
     End
    /* --------------------------------------- cyl managed area ----- */
    If (cap_cyl  > 0) Then Do               /* check for zero capacity*/
       per_cyl   = (alo_cyl/cap_cyl) * 100  /* calculate percentage   */
       Select
        When (per_cyl >= Lim_R) Then high_c = X0F
        When (per_cyl >= Lim_Y) Then high_c = X0E
        Otherwise high_c = X0D
       End
     End
    /* --------------------------------------- free space on volume - */
    dcvfresp  = Trunc(dcvfresp.loop/2**10,2)                   /* GiB */
    g_EAVs    = g_EAVs + 1
   end
 /* ----------------- */
 dcvfragi  = dcvfragi.loop                  /* fragmentation index    */
 /* ----------------- */
 dcvlgext  = dcvlgext.loop                  /* largest extent         */
 if dcvlgext >= 100000 then do
    dcvlgext = Trunc(dcvlgext/1000,0)||'T'
   end
  else do
    dcvlgext = Trunc(dcvlgext,0)
   end
 /* ----------------- */
 dcvdvtyp  = dcvdvtyp.loop                  /* device type            */
 /*dcvdptyp  = dcvdptyp.loop     not displayed physical device type   */
 dcvdvnum  = dcvdvnum.loop                  /* device number          */
 /* ----------------- */
 If (dcvvlcap > 0) Then                     /* check for zero capacity*/
  per_vol   = (dcvalloc/dcvvlcap) * 100     /* calculate percentage   */
 Else                                       /*                        */
  per_vol   = 0                             /* set percentage         */
 Select                                     /*                        */
  When (per_vol >= Lim_R) Then high = X0F   /*                        */
  When (per_vol >= Lim_Y) Then high = X0E   /*                        */
  Otherwise high = X0D                      /*                        */
 End                                        /*                        */
 /* ----------------------------------------------------------------- */
 /* per_disp  = Left('',Trunc((per_vol*31)/100,0),'*')                */
    per_disp  = Left('',Trunc((per_vol*21)/100,0),'*')
/*    per_disp  = Left('',Trunc(((per_vol*20)/100)+1,0),'*') */
 /* ----------------------------------------------------------------- */
 /*   build VOLSER line                                               */
 /* ----------------------------------------------------------------- */
 display = X20" "X0C||Left(dcvvolsr,7)||Left(dcvdvnum,5)
/*display = display||Left(dcvdvtyp,5)||Right(dcvvlcap,5)" "           */
 display = display||Right(dcvvlcap,6)" "
/*display = display||Right(dcvfresp,5)||Right(Trunc(dcvlgext,0),6)    */
 display = display||Right(dcvfresp,6)||Right(dcvlgext,6)
 display = display||Right(Trunc(dcvfragi,0),5)
 if dcvcylmg.loop <  '80' then do            /* NON EAV                */
    display = display||high||Right(Trunc(per_vol,1),5)     /* trk area */
    display = display||high_c||Right(' ',5)  /*  no value for cyl area */
   end
  else do                                    /* EAV                    */
    display = display||high_t||Right(Trunc(per_trk,1),5)   /* trk area */
    display = display||high_c||Right(Trunc(per_cyl,1),5)   /* cyl area */
   end
 display = display||high||Right(Trunc(per_vol,1),5)||' '||per_disp
 data2 = data2||Left(display,80)            /*                        */
End                                         /*                        */
 /* ----------------------------------------------------------------- */
If (cnt_group = 0) Then                     /*                        */
 Do                                         /*                        */
  zerralrm = 'YES'                          /*                        */
  zerrhm = 'TSPACE02'                       /*                        */
  zerrsm = 'No volumes found'               /*                        */
  zerrlm = 'No volumes matching 'sel_group' where found.' /*          */
  Address ISPEXEC "Setmsg Msg(ISRZ002)"     /* general error messageid*/
  save_data2 = Left('',4000)                /*                        */
  Return                                    /*                        */
 End                                        /*                        */
/*disp_pat = '   VOLSER ADDR TYPE CAPA  FREE  CNTG  FRAG PCT  XXX'    */
disp_pat='   VOLSER ADDR CAPA   FREE   CNTG  FRAG PTRK  PCYL  PVOL XXX'
data    = data2                             /*                        */
sort_parm = sort_parm2                      /*                        */
sort_leng = 80                              /* set sort length        */
Call DATA_SORT                              /*                        */
data2   = data                              /*                        */
/* display = X0B||"----------------------------------------------"    */
display = X0B||substr('-',1,57,'-')
data2   = data2||Left(display,80)           /*                        */
fre_group = cap_group - alo_group           /* calculate total free   */
per_group = ((alo_group/cap_group)*100)     /* get average percentage */
if g_cap_trk > 0 then do
   per_g_trk = ((g_alo_trk/g_cap_trk)*100)  /* get average percentage */
  end
if g_cap_cyl > 0 then do
   per_g_cyl = ((g_alo_cyl/g_cap_cyl)*100)  /* get average percentage */
  end

/* fre_group = Format((fre_group*1024)/10**9,6,0) change to GB        */
fre_group = Format((fre_group)/2**20,8,1)   /* change to GiB 1024**3  */
/* cap_group = Format((cap_group*1024)/10**9,6,0) change to GB 1000**3*/
cap_group = Format((cap_group)/2**20,10,1)  /* change to GiB 1024**3  */
 /* ----------------------------------------------------------------- */
 /*   build Storage Group Total Line                                  */
 /* ----------------------------------------------------------------- */
/*display = X0C" "X0B||Left('Total',16)                               */
display = X0C" "X0B||Left('Total',8)        /*                        */
/* display = display||Right(cap_group,6)||Right(fre_group,6)          */
display = display||Right(cap_group,9)||Right(fre_group,7)
/*display = display||Right(Trunc(per_group,0),15)||'%'                */
if g_EAVs > 0 then do
   display = display||Right(' ',12)
   display = display||Right(Trunc(per_g_trk,0),4)||' %'
   display = display||Right(Trunc(per_g_cyl,0),4)||' %'
  end
 else do
   display = display||Right(' ',12)
   display = display||Right(' ',6)
   display = display||Right(' ',6)
  end
display = display||Right(Trunc(per_group,0),4)||' %'
data2   = data2||Left(display,80)           /*                        */
data2   = data2||X0C||Centre(' End of List ',79,'*')
save_data2 = data2                          /*                        */
Return 0                                    /*                        */
/**********************************************************************/
DISP_VOLUME:                                /*                      ##*/
data3 = ''                                  /*                        */
Address TSO                                 /*                        */
"NewStack"                                  /*                        */
/*"Alloc Fi(SYSPRINT) Da(*) Shr Reu"            for debugging         */
"Alloc Fi(SYSPRINT) Da('NULLFILE') Shr Reu" /*                        */
"Alloc Fi(AMSDUMP) Da('NULLFILE') Shr Reu"  /*                        */
"Alloc Fi(SYSIN) New Lrecl(80) Reuse"       /*                        */
Queue " DCOLLECT -"                         /* dcollect               */
Do parms = 1 to Words(dco_parm)             /*                        */
Queue "  "Word(dco_parm,parms)" -"          /* dcollect selection     */
End                                         /*                        */
Queue "  OUTFILE(OUTDS)"                    /* dcollect output        */
Queue ""                                    /*                        */
"ExecIO * DiskW SYSIN (Finis)"              /*                        */
"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(410) Recfm(V B) Reu"
/*"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(340) Recfm(V B) Reu" */
"Call *(IDCAMS)"                            /*                        */
"ExecIO * DiskR OUTDS (Stem l. Finis)"      /*                        */
"Free Fi(OUTDS)"                            /*                        */
"Free Fi(SYSPRINT)"                         /*                        */
Do loop = 1 to cnt_vols                     /*                        */
/*Do loop = 1 to l.0                                                  */
 dcurctyp.loop = Substr(l.loop,5,1)         /* record type            */
 If (dcurctyp.loop = 'V') Then              /* if 'V' type record     */
  dcvvolsr = Substr(l.loop,25,6)            /* volume serial number   */
 If (dcurctyp.loop /= 'D') Then Iterate     /* none dataset record    */
 dcddsnam.loop = Substr(l.loop,25,44)       /* dataset name           */
 dcdflags.loop = Substr(l.loop,69,4)        /* information flags      */
 dcderror.loop = Substr(l.loop,69,1)        /* error information flag */
 dcdflag1.loop = Substr(l.loop,70,1)        /* information flag #1    */
 dcdflag1      = X2b(C2x(dcdflag1.loop))    /* flag #1 as bits        */
 dcdflag2.loop = Substr(l.loop,71,1)        /* information flag #2    */
 dcdflag3.loop = Substr(l.loop,72,1)        /* information flag #3    */
 dcdnovvr.loop = Substr(X2b(C2x(dcdflag2.loop)),1,1) /* no VVR flag   */
 dcddsorg.loop = Substr(l.loop,75,2)        /* dsorg                  */
 dcddsorg      = X2b(C2x(dcddsorg.loop))    /* dsorg as bits          */
 Select                                     /* decode dsorg           */
  When (Substr(dcddsorg,1,1) = '1') Then dsorg = 'IS'
  When (Substr(dcddsorg,2,1) = '1') Then dsorg = 'PS'
  When (Substr(dcddsorg,3,1) = '1') Then dsorg = 'DA'
  When (Substr(dcddsorg,7,1) = '1') Then dsorg = 'PO'
  When (Substr(dcddsorg,8,1) = '1') Then dsorg = 'U '
  When (Substr(dcddsorg,9,1) = '1') Then dsorg = 'GS'
  When (Substr(dcddsorg,13,1) = '1') Then dsorg = 'VS'
  Otherwise dsorg = '??'                    /*                        */
 End                                        /*                        */
 If (Substr(dcdflag1,4,1) = '1') Then dsorg = dsorg||'-E'
 dcdrecrd.loop = Substr(l.loop,77,1)        /* recfm                  */
 dcdrecrd      = X2b(C2x(dcdrecrd.loop))    /* recfm as bits          */
 Select                                     /* decode dsorg           */
  When (Substr(dcdrecrd,1,2) = '10') Then recfm = 'F'
  When (Substr(dcdrecrd,1,2) = '01') Then recfm = 'V'
  When (Substr(dcdrecrd,1,2) = '11') Then recfm = 'U'
  Otherwise recfm = '?'                     /*                        */
 End                                        /*                        */
 If (Substr(dcdrecrd,4,1) = '1') Then recfm = recfm||'B'
 If (Substr(dcdrecrd,3,1) = '1') Then recfm = recfm||'T'
 If (Substr(dcdrecrd,5,1) = '1') Then recfm = recfm||'S'
 If (Substr(dcdrecrd,6,1) = '1') Then recfm = recfm||'A'
 If (Substr(dcdrecrd,7,1) = '1') Then recfm = recfm||'M'
 dcdnmext.loop = Substr(l.loop,78,1)        /* number of extents      */
 dcdvolsr.loop = Substr(l.loop,79,6)        /* volume serial number   */
 dcdvolsr = dcdvolsr.loop                   /*                        */
 dcdnmext = C2d(dcdnmext.loop)              /*                        */
 dcdbklng.loop = Substr(l.loop,85,2)        /* block length           */
 dcdbklng = C2d(dcdbklng.loop)              /*                        */
 dcdlrecl.loop = Substr(l.loop,87,2)        /* lrecl                  */
 dcdlrecl = C2d(dcdlrecl.loop)              /*                        */
 dcdvolsq.loop = Substr(l.loop,123,2)       /* volume sequence number */
 dcdvolsq = C2d(dcdvolsq.loop)              /*                        */
 size_trk = size_trk.dcvvolsr               /* get track size         */
 cat_volume = dcvvolsr                      /* get catalog check vol  */
 dcdallsp.loop = C2d(Substr(l.loop,89,4))/* allocated space           */
 dcdusesp.loop = C2d(Substr(l.loop,93,4))/* used         space        */
 dcdscall.loop = C2d(Substr(l.loop,97,4))/* secondary space alloc     */
 dcdallsp = Format((dcdallsp.loop*1024)/size_trk,6,0) /* conv to trks */
 dcdusesp = Format((dcdusesp.loop*1024)/size_trk,6,0) /* conv to trks */
 dcdscall = Format((dcdscall.loop*1024)/size_trk,6,0) /* conv to trks */
 display = X20" "X0C||Left(dcddsnam.loop,44)/*                        */
 Select                                     /* normal selection       */
  When (sel_v_char = 'C') Then              /* catalog selection      */
   Do                                       /*                        */
    display = display||Right(dcdvolsr,7)    /* add volser             */
    dcddsnam      = dcddsnam.loop           /*                        */
    dsn_cat.dcddsnam = '*Not Cataloged'     /* set cat flag to no     */
    filter        = dcddsnam                /*                        */
    Call CSICODE                            /*                        */
     If (Substr(dsn_cat.dcddsnam,1,1) = '*') Then /*                  */
      high = X0F                            /* highlight red          */
     Else                                   /*                        */
      high = X0D                            /* highlight green        */
     display = display||high||dsn_cat.dcddsnam /* add catalog name    */
   End                                      /*                        */
  When (sel_v_char = 'D') Then              /* normal selection       */
   Do                                       /*                        */
    display = display||Left(" "dsorg,5)     /* add catalog name       */
    display = display||Left(" "recfm,5)     /* add recfm              */
    display = display||Right(dcdallsp,7)    /* add allocated space    */
    display = display||Right(dcdnmext,4)    /* add extents            */
    display = display||Right(dcdbklng,6)    /* add blksize            */
    display = display||Right(dcdlrecl,6)    /* add lrecl              */
   End                                      /*                        */
  When (sel_v_char = 'V') Then              /* normal selection       */
   Do                                       /*                        */
    display = display||Right(dcdallsp,7)    /* add allocated space    */
    display = display||Right(dcdnmext,4)    /* add extents            */
    display = display||Right(dcdvolsq,3)    /* add volseq             */
    display = display||Right(dcdvolsr,7)    /* add volser             */
   End                                      /*                        */
  Otherwise NOP                             /*                        */
 End
 data3 = data3||Left(display,80)||Left(dcdvolsr.loop,6) /*            */
End                                         /*                        */
Select                                      /*                        */
 When (sel_v_char = 'C') Then              /* catalog selection      */
  Do
   disp_pat = '   DATASET                                      '
   disp_pat = disp_pat||'VOLSER CATALOG                   XXX'
  End
 When (sel_v_char = 'D') Then              /* normal selection       */
  Do
   disp_pat = '   DATASET                                      '
   disp_pat = disp_pat||'DSRG RECF SPACE  XT  BLKSZ LRECL XXX'
  End
 When (sel_v_char = 'V') Then              /* normal selection       */
  Do
   disp_pat = '   DATASET                                      '
   disp_pat = disp_pat||'SPACE  XT  V# VOLSER XXX'
  End
 Otherwise NOP
End                                         /*                        */
data    = data3                             /*                        */
sort_parm = sort_parm3                      /*                        */
sort_leng = 86                              /* set sort length        */
Call DATA_SORT                              /*                        */
datav   = over                              /* save volume list       */
data3   = data                              /*                        */
data3   = data3||X0C||Centre(' End of List ',79,'*')
save_data3 = data3                          /*                        */
Return 0                                    /*                        */

/**********************************************************************/
DEFINE_HEX:                                 /* define panel hex     ##*/
X01 = '01'X                                 /* set hex '01' variable  */
X02 = '02'X                                 /* set hex '02' variable  */
X03 = '03'X                                 /* set hex '03' variable  */
X04 = '04'X                                 /* set hex '04' variable  */
X05 = '05'X                                 /* set hex '05' variable  */
X06 = '06'X                                 /* set hex '06' variable  */
X07 = '07'X                                 /* set hex '07' variable  */
X08 = '08'X                                 /* set hex '08' variable  */
X09 = '09'X                                 /* set hex '09' variable  */
X0A = '0A'X                                 /* set hex '0A' variable  */
X0B = '0B'X                                 /* set hex '0B' variable  */
X0C = '0C'X                                 /* set hex '0C' variable  */
X0D = '0D'X                                 /* set hex '0D' variable  */
X0E = '0E'X                                 /* set hex '0E' variable  */
X0F = '0F'X                                 /* set hex '0F' variable  */
X16 = '16'X                                 /* set hex '16' variable  */
X19 = '19'X                                 /* set hex '19' variable  */
X20 = '20'X                                 /* set hex '20' variable  */
X22 = '22'X                                 /* set hex '22' variable  */
X25 = '25'X                                 /* set hex '25' variable  */
X26 = '26'X                                 /* set hex '26' variable  */
X27 = '27'X                                 /* set hex '27' variable  */
X28 = '28'X                                 /* set hex '28' variable  */
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_P_ATTR:                              /* Create attributes    ##*/
Queue ")PANEL KEYLIST(ISRSNAB,ISR)"
Queue ")ATTR DEFAULT("X01||X02||X03") FORMAT(MIX)"
Queue " 04 AREA(DYNAMIC) SCROLL(ON)    EXTEND(ON)"
Queue " 05 TYPE(TEXT)    COLOR(BLUE)"
Queue " 06 TYPE(DATAOUT) COLOR(BLUE)   INTENS(LOW)"
Queue " 07 TYPE(DATAOUT) COLOR(GREEN)  INTENS(HIGH)"
Queue " 08 TYPE(TEXT)    COLOR(WHITE)"
Queue " 09 TYPE(TEXT)    COLOR(RED)"
Queue " 0A TYPE(TEXT)    COLOR(GREEN)"
Queue " 0B TYPE(DATAOUT) COLOR(WHITE)  INTENS(HIGH)"
Queue " 0C TYPE(DATAOUT) COLOR(BLUE)   INTENS(HIGH)"
Queue " 0D TYPE(DATAOUT) COLOR(GREEN)  INTENS(HIGH)"
Queue " 0E TYPE(DATAOUT) COLOR(YELLOW) INTENS(HIGH)"
Queue " 0F TYPE(DATAOUT) COLOR(RED)    INTENS(HIGH)"
Queue " 20 TYPE(DATAIN)  COLOR(TURQ)   HILITE(USCORE)"
Queue " 22 TYPE(TEXT)    COLOR(WHITE)  HILITE(REVERSE)"
Queue " 25 TYPE(OUTPUT)  COLOR(TURQ)   JUST(RIGHT) CAPS(OFF)"
Queue " 26 TYPE(INPUT)   COLOR(TURQ)   HILITE(USCORE)"
Queue " 27 AREA(SCRL)    EXTEND(ON)"
Queue " 28 TYPE(INPUT)   COLOR(RED)"
Queue " 16 TYPE(VOI)     PADC(USER)"      /* variable output info  TL */
Queue " 19 TYPE(DT)"                      /* descriptive text      GL */
Queue ")BODY  CMD(ZCMD)"
Return 0
/**********************************************************************/
DEFINE_P_PROC:                              /* Create processing    ##*/
Queue ")INIT"                               /*                        */
Queue "&ZCMD = ' '"                         /*                        */
Queue ".CURSOR = 'ZCMD'"                    /*                        */
Queue ".HELP = "help                        /*                        */
Queue "VGET (SSCL) ASIS"                    /*                        */
Queue "IF (&SSCL = '')"                     /*                        */
Queue " &SSCL = 'CSR'"                      /*                        */
Queue ")PROC"                               /*                        */
Queue "VPUT (SSCL) PROFILE"                 /*                        */
Queue ")END"                                /*                        */
Return 0
/**********************************************************************/
DEFINE_PANEL0:                              /* Create display 0     ##*/
"NewStack"                                  /* Create new stack       */
member = 'PSPACE00'                         /* set panel name         */
help   = 'TSPACE00'                         /* set help panel name    */
Call DEFINE_P_ATTR
Queue X0A||Centre(X05||"Storage Information"||X0A,78)||X0A
Queue X0A||"Command ===>"||X26||Left("ZCMD",71)||X0A
Queue X0A||" "
Queue X0A||" "
Queue X0A||"  The option you have selected will almost certainly take :"
Queue X0A||" "
Queue X0A||"  a) Quite a long time."
Queue X0A||"  b) Quite a lot of CPU."
Queue X0A||" "
Queue X0A||"  You have been warned ..."
Queue X0A||" "
Queue X0A||"  Are you absolutely certain that you want to do it ?"
Queue X0A||" "
Queue X0A||Centre("        Type"X09"YES"X0A"to continue. ",78)
Queue X0A||" "
Queue X0A||Centre(X08||">>>>"||X28||"CHK"||X08||"<<<<"||X0A,78)
Queue X0A||" "
Queue ")INIT"                               /*                        */
Queue "&ZCMD = ' '"                         /*                        */
Queue ".CURSOR = 'CHK'"                     /*                        */
Queue ".HELP = "help                        /*                        */
Queue ")PROC"                               /*                        */
Queue ")END"                                /*                        */
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_PANEL1:                              /* Create display 1     ##*/
"NewStack"                                  /* Create new stack       */
member = 'PSPACE01'                         /* set panel name         */
help   = 'TSPACE01'                         /* set help panel name    */
Call DEFINE_P_ATTR
Queue X0A||Centre(X05||"Storage Information"||X0A,78)||X0A
text = X0A||"Command ===>"||X26||Left("ZCMD",49)||X0A||"Scroll ===>"
Queue text||X26||Left("SSCL",4)||X0A
Queue X25||"ROWT"
/* ------------------------------------------------------------------ */
/* text = X08||"                      Vol   Total    Free  Pct"       */
/* Queue text||X22||"0  1  2  3  4  5  6  7  8  9  1"X08              */
/* text = X08||"S StoGroup              #    (Gb)    (Gb)  Usd"       */
/* Queue text||X22||"0  0  0  0  0  0  0  0  0  0  0"X08              */
/* text = X08||"_ ___________________ ___ _______ _______ ____"       */
/* Queue text||X22||"+..+..+..+..+..+..+..+..+..+..0"X08              */
text = X08||"                      Vol   Total    Free   Percent Used"
Queue text||X0A||"0 1 2 3 4 5 6 7 8 9 1"X08
text = X08||"S StoGroup              #   (GiB)   (GiB)  TRK  CYL  VOL"
Queue text||X0A||"0 0 0 0 0 0 0 0 0 0 0"X08
text = X08||"_ ___________________ ___ _______ _______ ____ ____ ____"
Queue text||X0A||"+.+.+.+.+.+.+.+.+.+.+"X08
/* ------------------------------------------------------------------ */
Queue X04||"DATA1"Left("",73)||X04
Call DEFINE_P_PROC
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_PANEL2:                              /* Create display 2     ##*/
"NewStack"                                  /* Create new stack       */
member = 'PSPACE02'                         /* set panel name         */
help   = 'TSPACE02'                         /* set help panel name    */
Call DEFINE_P_ATTR
Queue X0A||Centre(X05||"Storage Information - "sel_group||X0A,78)||X0A
text = X0A||"Command ===>"||X26||Left("ZCMD",49)||X0A||"Scroll ===>"
Queue text||X26||Left("SSCL",4)||X0A
Queue X25||"ROWT"
/* ------------------------------------------------------------------ */
/*  text = X08||"         Dev  Dev   Capa  Free  Cntg Frag  Pct"      */
/* Queue text||X22||"0  1  2  3  4  5  6  7  8  9  1"X08              */
/* text = X08||"S Volser Addr Type  (Gb)  (Gb)   Cyl Indx  Usd"       */
/* Queue text||X22||"0  0  0  0  0  0  0  0  0  0  0"X08              */
/* text = X08||"_ ______ ____ ____ _____ _____ _____ ____ ____"       */
/* Queue text||X22||"+..+..+..+..+..+..+..+..+..+..0"X08              */
text = X08||"         Dev   Capa   Free  Cntg  Frag    Percent Used  "
Queue text||X0A||"0 1 2 3 4 5 6 7 8 9 1"X08
text = X08||"S Volser Addr  (Gib)  (Gib)  Cyl  Indx  TRK   CYL   VOL "
Queue text||X0A||"0 0 0 0 0 0 0 0 0 0 0"X08
text = X08||"_ ______ ____ ______ ______ _____ ____ _____ _____ _____"
Queue text||X0A||"+.+.+.+.+.+.+.+.+.+.0"X08
/* ------------------------------------------------------------------ */
Queue X04||"DATA2"Left("",73)||X04
Call DEFINE_P_PROC
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_PANEL3:                              /* Create display 3     ##*/
"NewStack"                                  /* Create new stack       */
member = 'PSPACE03'                         /* set panel name         */
help   = 'TSPACE03'                         /* set help panel name    */
Call DEFINE_P_ATTR
Queue X0A||Centre(X05||"Storage Information - "sel_volume||X0A,78)||X0A
text = X0A||"Command ===>"||X26||Left("ZCMD",49)||X0A||"Scroll ===>"
Queue text||X26||Left("SSCL",4)||X0A
Queue X25||"ROWT"
Select
 When (sel_v_char = 'C') Then
  Do
   text = X08||"S Dataset Name                                 Volser"
   Queue text||" Catalog"X08
   text = X08||"_ ____________________________________________ ______"
   Queue text||" ____________________________"X08
  End
 When (sel_v_char = 'D') Then
  Do
   text = X08||"                                              "
   Queue text||"           Space                 "
   text = X08||"S Dataset Name                                "
   Queue text||" DSrg RecF (trks) Xt  Blksz Lrecl"
   text = X08||"_ ____________________________________________"
   Queue text||" ____ ____ ______ ___ _____ _____"X08
  End
 When (sel_v_char = 'V') Then
  Do
   text = X08||"                                              "
   Queue text||" Space               "
   text = X08||"S Dataset Name                                "
   Queue text||" (trks) Xt  V# Volser"
   text = X08||"_ ____________________________________________"
   Queue text||" ______ ___ __ ______"X08
  End
 Otherwise NOP
End
Queue X04||"DATA3"Left("",73)||X04
Call DEFINE_P_PROC
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_T_ATTR:                              /* Create attributes    ##*/
Queue ")PANEL KEYLIST (ISRHELP ISR)"
Queue ")ATTR"
Queue "   % TYPE(ET)"
Queue "   _ TYPE(NEF) PAD(USER) CAPS(ON)"
Queue "   + TYPE(NT)"
Queue "   # TYPE(SAC)"
Queue "   $ TYPE(OUTPUT) JUST(RIGHT) INTENS(HIGH)"
Queue ")BODY CMD(ZCMD)"
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_T_PROC:                              /* Create processing    ##*/
Queue ")INIT"
Queue "&ZCMD = ' '"
Queue ")PROC"
Queue "&ZUP = TSPACE00"
Queue ")END"
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_TUTOR0:                              /* Create tutorial 1    ##*/
"NewStack"                                  /* Create new stack       */
member = 'TSPACE00'                         /* set panel name         */
Call DEFINE_T_ATTR
Queue "%Tutorial "||Centre("Storage Information",62)||"Tutorial%"
Queue "%"||Left("Option  ===>_ZCMD",78)||"+"
Queue "% "
Queue "%       This utility displays SMS storage groups and/or volume"
Queue "%       detail for the system it is executed on."
Queue "% "
Queue "%       It may be invoked using#"PGM_NAME"%which will display all SMS"
Queue "%       storage groups on the system, together with the group of"
Queue "%       non-SMS volumes on the system."
Queue "% "
Queue "%       For a subset of volumes, invoke as#"PGM_NAME" VOLUME(volser)%"
Queue "%                                         #"PGM_NAME" VOL(volser)%"
Queue "%                                         #"PGM_NAME" V(volser)%"
Queue "%                                       or#"PGM_NAME" V(vols-1,vols-2)%"
Queue "% "
Queue "%                                       or#"PGM_NAME" POOL(sgname)%"
Queue "%                                         #"PGM_NAME" P(sgname)%"
Queue "% "
/*Queue "%       Wildcarding can be used e.g. *vol *vol* vol*" */
Queue "%       Wildcarding can be used for volume selection :#*vol *vol* vol*%"
Queue "%       Wildcards with POOL is allowed but slow. "
Queue "%       Better use multiple SG names like#P(sgnam1,sgnam2,sgnam3)%"
Queue "% "
Queue "%       Type#REFRESH%to refresh the display"
Call DEFINE_T_PROC
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_TUTOR1:                              /* Create tutorial 1    ##*/
"NewStack"                                  /* Create new stack       */
member = 'TSPACE01'                         /* set panel name         */
Call DEFINE_T_ATTR
Queue "%Tutorial "||Centre("Storage Information",62)||"Tutorial%"
Queue "%"||Left("Option  ===>_ZCMD",78)||"+"
Queue "% "
Queue "%       This panel displays all of the SMS Storage Groups available"
Queue "%       on the system together with their volume count and usage."
Queue "% "
Queue "%       Options available are :"
Queue "% "
Queue "%      #C%Catalog status"
Queue "%      #D%Dataset Allocation Details"
Queue "%      #S%Volume details (includes capacity/usage details)"
Queue "%      #V%Dataset Space/Xt/Volume/Volseq details"
Queue "% "
Queue "%       The display can be sorted using#SORT field A/D%."
Queue "%       Valid fields are :"
Queue "%      #STOGROUP VOL TOTAL FREE PTRK PCYL PVOL%"
/* Queue "%      #STOGROUP VOL TOTAL FREE PCT%"                       */
Queue "% "
Queue "%       PTRK := Usage of Track Managed Space (EAV and non-EAV)"
Queue "%       PCYL := Usage of Cylinder Managed Space only (EAV)"
Queue "%       PVOL := Usage of whole volume "
Queue "% "
Queue "%       Type#REFRESH%to refresh the display"
Call DEFINE_T_PROC
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_TUTOR2:                              /* Create tutorial 2    ##*/
"NewStack"                                  /* Create new stack       */
member = 'TSPACE02'                         /* set panel name         */
Call DEFINE_T_ATTR
Queue "%Tutorial "||Centre("Storage Information",62)||"Tutorial%"
Queue "%"||Left("Option  ===>_ZCMD",78)||"+"
Queue "% "
Queue "%       Displays all of the volumes defined in a selected SMS Storage"
Queue "%       Group together with their capacity and usage details."
Queue "% "
Queue "%       Options available are :"
Queue "% "
Queue "%      #C%Catalog status"
Queue "%      #D%Dataset Allocation Details"
Queue "%      #S%Normal '3.4' display"
Queue "%      #V%Dataset Space/Xt/Volume/Volseq details"
Queue "% "
Queue "%       The display can be sorted using#SORT field A/D%."
Queue "% "
Queue "%       Valid fields are :"
Queue "% "
Queue "%      #VOLSER ADDR CAPA FREE CNTG FRAG PTRK PCYL PVOL"
/*Queue "%      #VOLSER ADDR TYPE CAPA FREE CNTG FRAG PCT" */
Queue "% "
Queue "%       Type#REFRESH  %to refresh the display"
Queue "%       Type#FULLC/D/V%to list ALL datasets in the pool"
Call DEFINE_T_PROC
Return 0                                    /*                        */
/**********************************************************************/
DEFINE_TUTOR3:                              /* Create tutorial 3    ##*/
"NewStack"                                  /* Create new stack       */
member = 'TSPACE03'                         /* set panel name         */
Call DEFINE_T_ATTR
Queue "%Tutorial "||Centre("Storage Information",62)||"Tutorial%"
Queue "%"||Left("Option  ===>_ZCMD",78)||"+"
Queue "% "
Queue "%       Displays all of the datasets on selected volume/s."
Queue "% "
Queue "%       Together with either their allocation details, their "
Queue "%       space utilisation or their catalog status."
Queue "% "
Queue "%       For all, the options available are :"
Queue "% "
Queue "%      #B%Browse"
Queue "%      #E%Edit"
Queue "%      #S%Edit"
Queue "%      #V%View"
Queue "% "
Queue "%       The display can be sorted using#SORT field A/D%."
Queue "% "
Queue "%       Valid fields are :"
Queue "% "
Queue "%      #DATASET VOLSER CATALOG DSRG RECF SPACE XT BLKSZ LRECL"
Call DEFINE_T_PROC
Return 0                                    /*                        */
/**********************************************************************/
CREATE_PDS:                                 /* Create Member in PDS   */
Do loop = 1 To 50                           /* loop thru up to 50     */
 fil = 'DYNAM'||loop                        /*  build filename        */
 x = Listdsi(fil FILE)                      /*  test filename         */
 If (sysreason > 0) Then                    /*  if not present        */
  Leave                                     /*   use it !             */
End                                         /* end loop               */
Address TSO                                 /* set address            */
"Alloc Fi("fil") ",                         /* Allocate dyamic        */
      "Lrecl(80) Blksize(0) RecFm(F B) ",   /*  dataset to selected   */
      "Cylinders Space(1,1) ",              /*   filename             */
      "Unit(SYSDA) Dir(20) New Reu"         /*                        */
X = Listdsi(fil FILE)                       /* get the file details   */
Return 0                                    /*                        */
/**********************************************************************/
CREATE_MEMBER:                              /* Create Member in PDS   */
stack = Queued()                            /*   get stack size       */
If (stack > 0) Then                         /*   if data on stack     */
 Do                                         /*                        */
  "Alloc Fi(MEMOUT) Shr Reu ",              /*    create member       */
        "Da('"sysdsname"("member")')"       /*                        */
  "ExecIO "stack" DiskW MEMOUT (Finis)"     /*    write stack > member*/
  "Free Fi(MEMOUT)"                         /*    free member         */
 End                                        /*                        */
/* Debug code
Address ISPEXEC "Edit Dataset('"sysdsname"') Volume("sysvolume")"
*/
"DelStack"                                  /* Clear stack            */
Return 0                                    /*                        */
/**********************************************************************/
DATA_SORT:                                  /*                      ##*/
scnt = 0                                    /*                        */
last_rec = (Length(data)-sort_leng)+1       /* calculate last record  */
Do pass = 1 To last_rec By sort_leng        /*                        */
 scnt = scnt + 1                            /*                        */
 sort.scnt = Substr(data,pass,sort_leng)    /*                        */
End                                         /*                        */
Address TSO                                 /*                        */
If (sort_parm = '') Then                    /*                        */
 sysin.1 = '  SORT FIELDS=(1,20,CH,A)'      /*                        */
Else                                        /*                        */
 sysin.1 = '  SORT FIELDS=('sort_parm')'    /*                        */
"Alloc Fi(SYSIN)   Space(1 1) Cylinders Unit(3390) ",
                             "Lrecl(80) Blksize(0) New Reu"
"ExecIO 1 DiskW SYSIN (Finis Stem sysin.)"
"Alloc Fi(SORTIN)  Space(1 1) Cylinders Unit(3390) ",
                             "Lrecl("sort_leng") Blksize(0) New Reu"
"ExecIO "scnt" DiskW SORTIN (Finis Stem sort.)"
/* Debug code
X = Listdsi(SORTIN FILE)                    /* get the file details   */
Address ISPEXEC "Edit Dataset('"sysdsname"') Volume("sysvolume")"
*/
"Alloc Fi(SORTOUT) Space(1 1) Cylinders Unit(3390) ",
                             "Lrecl("sort_leng") Blksize(0) New Reu"
"Alloc Fi(SYSOUT)  Space(1 1) Cylinders Unit(3390) ",
                             "Lrecl(80) Blksize(0) New Reu"
Address ATTCHMVS "SORT"                     /*                        */
"ExecIO * DiskR SORTOUT (Finis Stem sort.)" /*                        */
"Free Fi(SORTIN SORTOUT SYSIN SYSOUT)"      /*                        */
data = ''                                   /*                        */
over = ''                                   /* 'overspill' variable   */
If (sort_leng = 80) Then                    /*                        */
 Do pass = 1 To scnt                        /*                        */
  data = data||sort.pass                    /*                        */
 End                                        /*                        */
Else                                        /*                        */
 Do pass = 1 to scnt                        /*                        */
  data = data||Substr(sort.pass,1,80)       /*                        */
  over = over||Substr(sort.pass,81)         /* capture 'overspill'    */
 End                                        /*                        */
Return 0                                    /*                        */
/**********************************************************************/
SORT_DECODE:                                /* decode sort parms    ##*/
fld = Word(zcmd,2)                          /*                        */
ord = Word(zcmd,3)                          /*                        */
plc = WordPos(fld,disp_pat)                 /*                        */
If (plc = 0) Then                           /*                        */
 Do                                         /*                        */
  If (fld /= '') Then                       /*                        */
   Do                                       /*                        */
    zerralrm = 'YES'                        /*                        */
    zerrhm = 'TSPACE00'                     /*                        */
    zerrsm = 'Not a valid name'             /*                        */
    zerrlm = field' not a valid name, reselect and try again.' /*      */
    Address ISPEXEC "Setmsg Msg(ISRZ002)"   /* general error messageid*/
   End                                      /*                        */
  Else                                      /*                        */
   sort_parm = ''                           /*                        */
 End                                        /*                        */
Else                                        /*                        */
 Do                                         /*                        */
  col = Wordindex(disp_pat,plc)             /*                        */
  nex = Wordindex(disp_pat,plc+1)-1         /*                        */
  len = nex-col                             /*                        */
  If (ord /= 'D') &,                        /*                        */
     (ord /= 'A') Then                      /*                        */
   ord = 'A'                                /*                        */
  sort_parm = col','len',CH,'ord            /*                        */
 End                                        /*                        */
Return 0                                    /*                        */
/**********************************************************************/
/**********************************************************************/
/* CSICODE : Uses Catalog Search Interface (CSI)                      */
/**********************************************************************/
CSICODE:                             /* CSI processing              ##*/
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat.1 = ' '                          /* Set catalog name              */
flt   = filter                       /* Set the filter                */
typ   = ' '                          /* Set entry types required      */
ct1   = ' '                          /* Set for 1 catalog only        */
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
x = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */
/**********************************************************************/
Return 0                             /* Return                        */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
/**********************************************************************/
bcp = mvsvar('sysmvs')               /*                               */
lev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */
If (lev > 609) Then                  /* os/390 R10 and up for fullword*/
 csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/
Else                                 /*                               */
 csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '0006'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld06 = Left('FILESEQ ',8)        /* File Sequence number          */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csioptns
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say '**(Error-1)* CSI processing.'
   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* Work Area defined  = 'csiusrln
   Say '**(Error-2)* Work Area used     = 'csiusdln
   Say '**(Error-3)* Work Area required = 'csireqln
   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say '**(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */
    If (csioptns = 'F') Then         /* check if fullword requested   */
     csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length    */
    Else                             /* otherwise (default halfword)  */
     csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length    */
    If (csienter = '1') Then         /* entry error                   */
     Do
      Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
      Say '**(Error-2)* Module='mod' Return='ret' Reason='res
      plus = 50                      /* length for error entry        */
     End
    Else                             /*                               */
     Do                              /*                               */
      Call ENTRY                     /* Execute entry processing      */
      plus = 46 + csitotln           /* length for normal entry       */
     End                             /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword requested   */
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */
  e_pos = 12                         /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */
   e_pos = e_pos + 4                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
Else                                 /* otherwise (default halfword)  */
/**********************************************************************/
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */
  e_pos = 6                          /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */
   e_pos = e_pos + 2                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
volser   = Substr(dwork,o_fld.5,l_fld.5)   /* volume serial           */
fileseq  = Substr(dwork,o_fld.6,l_fld.6)   /* file sequence           */
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)
  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  If (Pos(cat_volume,volser) > 0) Then /* If volser matches selected  */
   Do                                /*                               */
    dsn_cat.entname = csicname       /*  set catalog for dataset      */
   End                               /*                               */
  If (Pos('&',volser) > 0) Then      /* check for system symbolic     */
   Do                                /*                               */
    Do syms = 1 to Words(volser)     /*                               */
     symchk = Word(volser,syms)      /*                               */
     symres = MvsVar('SYMDEF',Strip(symchk,B,'&')) /*                 */
     If (cat_volume = symres) Then   /*                               */
      Do                             /*                               */
       dsn_cat.entname = csicname    /*  set catalog for dataset      */
       Leave                         /*                               */
      End                            /*                               */
    End                              /*                               */
   End                               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/
./ ADD NAME=SPLTCOL  0106-16035-18344-1631-00195-00133-00000-APLKS   41
/* REXX 2018-12-10 */
/* --------------------------------------------------------- */
/* Purpose: To split a line at one or more column positions. */
/*          If a line is split, it adds the same number of   */
/*          leading blanks to the new line as the original   */
/*          line.                                            */
/*                                                           */
/*  Format: SPLTCOL target | range                           */
/*                  col-1 ...                                */
/*                  < ( equation >                           */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SPLTCOL */

   Address ISREDIT;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   var. = "";       /*1=*|count|label1 2=label2 3=col...*/
   col. = "";

   "(bndslo,bndshi) = BOUNDS";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Parse Target */

   Call Extract_TARGET;

   /* Parse the Primary EXEC Parameters */

   Address TSO "MAKEBUF";

   Do While parm2 <> "";
     Parse VAR parm2 var.3 parm2;
     If var.3 = "" Then;
       Iterate;
     If Datatype(var.3,"W") Then;
       Push var.3;
   End;

   count = 0;
   Address TSO "QELEM";
   count = RC;
   RC = 0;

   If count = 0 Then;
     Signal Error_No_Columns;

   Do i = 1 To count By +1;
     Pull col.i;
   End;
   col.0 = count;
   Address TSO "DROPBUF";

   /* Mainline */

   Do i = trgt_row_to To trgt_row_from By -1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE "i;
     last_col = Length(Strip(Substr(row,1,bndshi),"T")) + 1;
     Do j = 1 To col.0 By +1;
       If last_col > col.j Then;
         "TSPLIT" i col.j;
     End;
   End;

   Return (0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2 || " " || parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: To split a row at specific column positions.",
        pad hex04,
        " Format: SPLTCOL target|range  col-1 ...";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_NO_COLUMNS:

   ZEDSMSG = "NO COLUMNS";
   ZEDLMSG = "No columns specified";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SPLTJN   0106-14134-16190-1059-00133-00122-00000-APLKS   51
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: To split a line at the cursor position or to     */
/*          join a line at the cursor position.  If a line   */
/*          is split, it adds the same number of leading     */
/*          blanks to new line as the original line.  If     */
/*          two lines are joined, it removes all of the      */
/*          leading blanks.  This macro is most useful       */
/*          when assigned to a PF key.                       */
/*                                                           */
/*  Format: SPLTJN                                           */
/*                                                           */
/*          target: is the row and column the cursor is      */
/*                  positioned on.                           */
/*                  variable names are trow                  */
/*                                     tcol                  */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SPLTJN */

   Address ISREDIT;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   row = "";
   "(bndslo,bndshi) = BOUNDS";

   /* Parse Target */

   Call Extract_TARGET;

   If tcol < bndslo | tcol > bndshi Then;
     Signal Error_INVALID_CURSOR;

   /* Perform the function of this routine */

   "(row) = LINE .ZCSR";
   last_col = Length(Strip(Substr(row,1,bndshi),"T")) + 1;
   If last_col > tcol Then;
     "TSPLIT" trow tcol;
   Else;
     Do;
       "(nline) = LINE" trow + 1;
       row = Left(row,tcol - 1) ||,
         Strip(Substr(nline,bndslo,bndshi),"B");
       "LINE .ZCSR = (row)";
       "DELETE" trow + 1;
       "CURSOR = (trow,tcol)";
     End;

   Return (0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Extract_TARGET:

   /* Resolve trow and tcol Variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trow = krow;
       tcol = kcol;
     End;
   Else;
     Do;
       trow = frow;
       tcol = kcol;
     End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: To split/join a line at the cursor position.",
        pad hex04,
        " Format: SPLTJN";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_CURSOR:

   ZEDSMSG = "INVALID CURSOR";
   ZEDLMSG = "Invalid cursor position, outside of bounds";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SPLTLN   0116-16030-16190-1103-00309-00319-00000-APLKS   21
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: SPLTLN  split the row AT or AFTER the string.    */
/*                                                           */
/*  Format: SPLTLN  <range>  string                          */
/*                  < ( options >                            */
/*                                                           */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*          string: any string enclosed in apostrophes or    */
/*                  quotes.  The string is used to determine */
/*                  where to split the row.  String is case  */
/*                  sensitive.                               */
/*                                                           */
/*         options: (default) AT 5                           */
/*                  AFTER | AT                               */
/*                  indent                                   */
/*                  STD | COBOL                              */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SPLTLN */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   opt. = "";                 /*1=AT|AFTER 2=indent*/
   lang = "";                 /*STD|COBOL*/
   trgt_row_from = "";
   trgt_row_to = "";
   find_string = "";
   chg_cnt = 0;               /*nbr of rows split*/

   "(bndslo,bndshi) = BOUNDS";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;

   Call Extract_Options;
   If lang = "" Then;
     Do;
       Address ISPEXEC "VGET (LANG@@) PROFILE";
       If RC = 0 Then;
         If lang@@ <> "NULL" Then;
           lang = lang@@;
         Else;
           Signal Error_INVALID_LANG;
       Else;
         Signal Error_INVALID_LANG;
     End;
   If opt.1 = "" Then;
     /*AT|AFTER*/
     opt.1 = "AT";
   If opt.2 = "" Then;
     /*indent*/
     opt.2 = 5;

   /* Parse Range and User passed Parms */

   Call Extract_Range;

   If var.1 = "" Then;
     var.1 = ".ZFIRST";
   If var.2 = "" Then;
     var.2 = ".ZLAST";

   /* Parse the Required (find_string) EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       parm2 = Strip(parm2,"B");
       Select;
         When Substr(parm2,1,1) = "'" Then;
           Parse VAR parm2 "'" find_string "'" parm2;
         When Substr(parm2,1,1) = '"' Then;
           Parse VAR parm2 '"' find_string '"' parm2;
         When Substr(parm2,1,2) = "x'" | Substr(parm2,1,2) = "X'" Then;
           Do;
             Parse VAR parm2 "'" find_string "'" parm2;
             find_string = X2C(find_string);
           End;
         Otherwise;
           Parse VAR parm2 find_string parm2;
       End;
     End;
   Else;
     Signal Error_MISSING_STRING;

   /* Do the Job */

   "SEEK '"find_string"'" trgt_row_from trgt_row_to " LAST NX ";
   If RC <> 0 Then;
     Signal Error_STRING_NOTFND;

   EC = RC;
   Do While EC = 0;
     "(irow,icol) = CURSOR";
     "(row) = LINE" irow;
     Select;
       When lang = "COBOL" Then;
         If Substr(row,7,1) = "*",           /*comment*/
              | Substr(row,7,1) = "/",
              | Substr(row,7,1) = "D" Then;  /*DEBUG*/
           Do;
             "SEEK '"find_string"'" trgt_row_from trgt_row_to " PREV NX ";
             EC = RC;
             Iterate;
           End;
       When lang = "STD" Then;
         If Substr(row,1,1) = "*",             /*comment*/
              | Substr(row,1,2) = "/*",
              | Substr(row,1,3) = "//*" Then;  /*comment*/
           Do;
             "SEEK '"find_string"'" trgt_row_from trgt_row_to " PREV NX ";
             EC = RC;
             Iterate;
           End;
       Otherwise;
         Nop;
     End;
     n = Pos(find_string,row);     /*position of string*/
     If n = 0 Then;
       Signal Error_STRING_NOTFND;
     Do j = bndslo To bndshi By +1 While Substr(row,j,1) = " ";
     /* find 1st non-blank position on the row */
     End;
     If opt.1 = "AFTER" Then;
       /*position of spltrow*/
       n = n + Length(find_string);
     spltrow = Copies(" ",opt.2+j-1) || Substr(row,n,bndshi-n+1);
     row = Overlay(Copies(" ",bndshi-n+1),row,n,bndshi-n+1);
     "LINE_AFTER (irow) = (spltrow)";
     "LINE "irow" = (row)";
     chg_cnt = chg_cnt + 1;
     "SEEK '"find_string"'" trgt_row_from trgt_row_to " PREV NX ";
     EC = RC;
   End;

   If trgt_row_from <> "" Then;
     "LOCATE" trgt_row_from;

   ZEDSMSG = Strip(chg_cnt,"L","0") "SPLITs";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Range:

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "." Then;
       Do;
         trgt_row_to = var.1;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               trgt_row_from = trgt_row_to;
               trgt_row_to = var.2;
             End;
           Else;
             Signal Error_INVALID_RANGE;
       End;
     When Substr(var.1,1,1) = "'" | Substr(var.1,1,1) = '"' | ,
          Substr(var.1,1,2) = "x'" | Substr(var.1,1,2) = "X'" Then;
       Do;
         /*place quoted string back in parm2*/
         parm2 = parm2 || " " | var.1;
         If loop <> "Y" Then;
           Do;
             loop = "Y";
             Signal Extract_Range;
           End;
       End;
     Otherwise;
       Do;
         /*place string back in parm2*/
         parm2 = parm2 || " " || Translate(var.1);
         If loop <> "Y" Then;
           Do;
             loop = "Y";
             Signal Extract_Range;
           End;
         Else;
           var.1 = "";
       End;
   End;

   If (var.1 = "" & var.2 = "") | (var.1 <> "" & var.2 <> "") Then;
     Nop;
   Else;
     Signal Error_INVALID_RANGE;

   Return (0);

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Upper var.3;
     Select;
       When var.3 = "STD" | var.3 = "COBOL" Then;
         lang = var.3;
       When Abbrev("AT",var.3,2) Then;
         opt.1 = "AT";
       When Abbrev("AFTER",var.3,2) Then;
         opt.1 = "AFTER";
       When Datatype(var.3,"W") Then;
         opt.2 = var.3;
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Split a row AFTER or AT the string.",
        pad hex04,
        " Format: SPLTLN < range >  string",
        pad hex04,
        "                < ( < AT | AFTER > < indent > < STD | COBOL > >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_RANGE:

   ZEDSMSG = "INVALID RANGE";
   ZEDLMSG = "Range is not a valid set of labels"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_MISSING_STRING:

   ZEDSMSG = "MISSING STRING";
   ZEDLMSG = "Missing find string";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_STRING_NOTFND:

   ZEDSMSG = "NOT FOUND";
   ZEDLMSG = "String not found, may be a case mismatch";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_LANG:

   ZEDSMSG = "INVALID LANG";
   ZEDLMSG = "Language is not valid ("lang")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=STATUS   0105-14130-16190-1110-00064-00054-00000-APLKS   00
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Used to determine if the member has been         */
/*          modified.                                        */
/*                                                           */
/*  Format: STATUS                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC STATUS */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   /* Initialize Variables */

   /* Mainline */

   "(modflg) = DATA_CHANGED";
   If modflg = "YES" Then;
     Do;
       ZEDSMSG = "MODIFIED";
       ZEDLMSG = "MEMBER has been modified";
     End;
   Else
     Do;
       ZEDSMSG = "NOT MODIFIED";
       ZEDLMSG = "MEMBER has not been modified";
     End;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";

   Return (0);

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=STKCRDS  0110-14331-18017-1421-00095-00103-00000-APLKS   11
/* REXX 2018-01-17*/
/* --------------------------------------------------------- */
/* Purpose: Invoke EXECIO to retrieve all of the records     */
/*          in an input dataset and place them on the        */
/*          current data stack before returning to the       */
/*          calling program.                                 */
/*                                                           */
/*          If dataset_name is passed then it will be        */
/*          dynamically allocated and assigned to ddname     */
/*          CTLCRDS.                                         */
/*                                                           */
/*          If dataset_name is not passed then an existing   */
/*          dataset must be specified with ddname CTLCRDS    */
/*          via JCL.                                         */
/*                                                           */
/*          Doesn't have to run in a TSO/E environment       */
/*          if dynamic dataset allocation is not required.   */
/*                                                           */
/*  Format: STKCRDS dataset_name                             */
/*                                                           */
/*    dataset_name: is the name of the dataset to read       */
/*          or the dd_name of an already allocated           */
/*          dataset with a ddname different than CTLCRDS.    */
/*                                                           */
/*      RC:  0 - OK                                          */
/*         -12 - dataset_name not found                      */
/*         -16 - unable to assign ddname to dsname           */
/*                                                           */
/* --------------------------------------------------------- */

/* Entering EXEC STKCRDS */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;

   /* Initialize Variables */
   dataset_name = "";
   dd_name = "CTLCRDS";

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     Do;
       dataset_name = Strip(parm2,"B");
       dataset_name = Strip(dataset_name,"B","'");
       If Length(dataset_name) <= 8 Then;
         Do;
           dd_name = dataset_name;
           dataset_name = "";
         End;
     End;

   /* Test dataset_name for validity */

   If dataset_name <> "" Then;
     Do;
       arg_string = "'"dataset_name"'";
       message = SYSDSN(arg_string);
       If message <> "OK" Then;
         Do;
           Say message;
           Return (-12);
         End;
       /* Point to dataset with all of the data to be stacked */
       "ALLOC DSNAME("dataset_name") ",
            "DDNAME("dd_name") SHR REUSE ";
       If RC <> 0 Then;
         Do;
           Say "Assigning DDNAME to DSNAME failed - RC=" RC;
           Return (-16);
         End;
     End;

   "EXECIO * DISKR "dd_name" ( FINIS ";

   If dataset_name <> "" Then;
     "FREE DD("dd_name")";

   Return (0);
./ ADD NAME=STKDSNS  0125-15252-17136-1229-00269-00271-00000-APLKS   02
/* REXX 2017-05-16 */
/* --------------------------------------------------------- */
/* Purpose: Extract the data set names displayed on the      */
/*          TSO 3.4 DSLIST panel and place them on the       */
/*          stack and return to the caller.                  */
/*                                                           */
/*          This is an undocumented IBM interface that was   */
/*          discovered by Gilbert Saint-Flour.  I have       */
/*          liberally pilfered the logic.  I have also       */
/*          chosen to implement some of the addressing       */
/*          methods of John Kalinich.                        */
/*                                                           */
/*      Op: The caller of this procedure must be invoked     */
/*          from the DSLIST screen, as a TSO command, such   */
/*          as TSO %rexxexec.  To get all of the ISPF table  */
/*          fields populated, you must scroll to the bottom  */
/*          of DSLIST (if longer than a page) and you must   */
/*          scroll left.                                     */
/*                                                           */
/*  Format: STKDSNS                                          */
/*                                                           */
/*  Output: Queue of all the DSLIST information.  Each row   */
/*          of the queue contains the following -            */
/*          dsname ';'   DSNAME                              */
/*          spcinfo ';'  TRKS used% extents device           */
/*          volinfo ';'  VOLSER                              */
/*          attrinfo ';' DSORG RECFM LRECL BLKSIZE           */
/*          dateinfo ';' creation expiration reference       */
/*          catname ';'  catalog name                        */
/*                                                           */
/*          each segment of the data is separated by a ";"   */
/*          so that PARSEing will be easier for the caller.  */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC STKDSNS */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Address ISPEXEC "VGET (ZPANELID) SHARED";
   If zpanelid <> "ISRUDSL0" Then
     Signal Error_ON_ERROR;

   Signal ON ERROR NAME Error_ON_ERROR;
   Signal ON FAILURE NAME Error_ON_FAILURE;
   Signal ON NOVALUE NAME Error_NO_VALUE;

   /* Initialize Variables */

   dsn. = "";

   /* Mainline */

   Call GET_DSL;

   /* --------------------------------------------- */
   /* Scan the DSLIST table and build stem variable */
   /* --------------------------------------------- */

   j = 0;
   Do i=1 To rownum By +1;    /*read all the table entries*/
     Address ISPEXEC "TBSKIP" dsltblnm; /*next row*/
     If RC <> 0 Then;
       Leave;
     If zudxstat = "Y" Then;  /*row has been excluded*/
       Iterate;
     attrinfo = ""; dateinfo = ""; spcinfo = ""; volinfo = "";
     volinfo = zudvol;
     If zurecfm = "FF"x Then;
       Do;
         spcinfo = Copies(" ",20);
         attrinfo = zuorg;
       End;
     Else;
       If zuobtatt = "Y" Then;
         Do;
           attrinfo = LEFT(zuorg,4) LEFT(zurecfm,4) zulrecl zublksiz;
           If zuobtspc='Y' Then;
             Do;
               spcinfo = zusize zuus || '%' zux zudevice;
               If zuobtdat = "Y" Then;
                 dateinfo = zucdate zuedate zurdate;
             End;
         End;
     j = j + 1;
     dsn.j = LEFT(zudsns,44) ";",
          volinfo ";",
          spcinfo ";",
          attrinfo ";",
          dateinfo ";",
          Left(zucatnam,44) ";";
   End;

   Address ISPEXEC "TBSKIP" dsltblnm "ROW("crp")"; /*re-pos the table*/

   /* --------------------------------------------------- */
   /* Place the stem variable on the stack for the caller */
   /* --------------------------------------------------- */

   Do i=1 To j By +1;
     Queue dsn.i;
   End;

   Return (0);

   /* ----------------------------------- */
   /* Routine to extract the DSLIST table */
   /* ----------------------------------- */

   GET_DSL:

   Numeric Digits 10;         /* Required for 31-bit addresses */
   pca_ptr = 0;
   tcb_ptr = get_ptr(pca_ptr,'21c');    /*TCB (EXEC cmd) PSATOLD*/
   tcb_ptr = get_ptr(tcb_ptr,'84');     /*TCB (ISPTASK) TCBOTC*/
   rsa_ptr = get_ptr(tcb_ptr,'70');     /*1st RSA TCBFSA*/
   R1_rsa_ptr = get_ptr(rsa_ptr,'18');  /*ISPTASK's R1*/
   tld_ptr = get_ptr(R1_rsa_ptr,'00');  /*TLD addr*/
   dta_ptr = get_ptr(tld_ptr,'4c');     /*DTA addr*/
   dsltblnm = get_data(dta_ptr,'0c',8); /*DSL tbl name*/

   If Substr(dsltblnm,1,3) <> "DSL" Then;
     Signal Error_NO_VALUE;

   Address ISPEXEC "TBQUERY" dsltblnm,
        " KEYS(KEYS) NAMES(NAMES) NAMENUM(NAMENUM)",
        " ROWNUM(ROWNUM) KEYNUM(KEYNUM)",
        " POSITION(CRP)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TBQUERY_FAILED;

   Address ISPEXEC "TBTOP" dsltblnm;    /*start from the top*/
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TBTOP_FAILED;

/* Signal LIST; */

   Return;

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

   get_ptr: procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset;
   temp = d2x(x2d(addr) + x2d(offset));
   return c2x(storage(temp,4));
   exit;

   get_ptr3: procedure
   /* +-----------------------------------------+
      | returns a 3 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset;
   temp = d2x(x2d(addr) + x2d(offset));
   return c2x(storage(temp,3));
   exit;

   get_data: procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      | J. KALINICH, X4521                      |
      +-----------------------------------------+ */
   arg addr, offset, length;
   temp = d2x(x2d(addr) + x2d(offset));
   return storage(temp,length);
   exit;

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_ON_ERROR:
   Error_ON_FAILURE:
   Error_NO_VALUE:

   ZEDSMSG = "ERROR";
   ZEDLMSG = "ON INVALID PANEL, OR POPULATE TABLE,",
             "MAX TO BOTTOM AND LEFT 1 PANEL";
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_TBQUERY_FAILED:

   ZEDSMSG = "TBQUERY FAILED";
   ZEDLMSG = "TBQUERY SERVICE FAILED WITH RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   Error_TBTOP_FAILED:

   ZEDSMSG = "TBTOP FAILED";
   ZEDLMSG = "TBTOP FAILED FOR TABLE" dsltblnm "RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ001)";
   Exit (-12);

   /* ---------------------------------- */
   /* Variables (for documentation only) */
   /* ---------------------------------- */

   LIST:

   Say "KEYS="keys "NAMES="names "NAMENUM="namenum;
   Say "ROWNUM="rownum "KEYNUM="keynum "POSITION="crp;
   Do i=1 To rownum By +1;
     Address ISPEXEC "TBSKIP" dsltblnm;
     Say " ";
     Say Left("ROW",8) "=" i;
     Do j=1 To namenum By +1;
       name = Strip(Strip(Word(names,j),"L","("),"T",")");
       Say Left(name,8) "=" Value(name);
     End;
   End;

   Exit;

  1zudsns   3zusize   3zuus     5zucdate  5zuedate  5zurdate
  2zudvol    zudmvol  3zudevice  zucdat2   zuedat2   zurdat2
  4zuorg    3zux      4zurecfm  4zulrecl  4zublksiz  zustat
   zudspacu  zulmsg    zulocvol #zuobtatt #zuobtspc #zuobtdat
  #zudxstat  zulcmdl   zud20v    zudvol7  6zucatnam  zusizex
   zuxx      zuovf     zugflag   zueatr    zucjobn   zucstpn

  Where:
   1 - dsname   (dsname)
   2 - volinfo  (volser)
   3 - spcinfo  (tracks used% extents device)
   4 - attrinfo (dsorg recfm lrecl blksize)
   5 - dateinfo (creation expiration reference)
   6 - catname  (catname)
   # - flags used
./ ADD NAME=STKMBRS  0106-14130-18017-1423-00088-00103-00000-APLKS   06
/* REXX 2018-01-17*/
/* --------------------------------------------------------- */
/* Purpose: Invoke LISTDS to retrieve the member names of    */
/*          a PDS/E, save them to the current stack and      */
/*          return to the caller.                            */
/*                                                           */
/*  Format: STKMBRS dataset_name                             */
/*                                                           */
/*    dataset_name: is the name of the PDS/E dataset to      */
/*                  LISTDS                                   */
/*                                                           */
/*      RC:  0 - OK                                          */
/*          12 - dataset_name was not passed or found        */
/*               or has been migrated or is not a PDS/E      */
/*          16 - unsupported in this address space           */
/*          20 - can't display HELP data                     */
/*          24 - LISTDSI reason code > 0                     */
/*                                                           */
/* --------------------------------------------------------- */

/* Entering EXEC STKMBRS */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Return (-20);

   /* Initialize Variables */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     Do;
       dataset_name = Strip(parm2,"B");
       dataset_name = Strip(dataset_name,"B","'");
     End;
   Else;
     Return (-12);

   /* Test dataset_name for validity */

   arg_string = "'"dataset_name"' NORECALL NOSMSINFO";
   EC = Listdsi(arg_string);
   If EC >= 16 Then;
     Do;
       If SYSREASON = 3  | SYSREASON = 5  | SYSREASON = 24 Then;
         Return (-12);
       Else;
         Return (-24);
     End;
   Else;
     If SYSREASON = 0 Then;
       If SYSDSORG = "PO" | SYSDSORG = "POU" Then;
         Nop;
       Else;
         Return (-12);

   x = Outtrap("MBRS.");
   "LISTDS '"dataset_name"' MEMBERS";
   x = Outtrap("OFF");

   Do i=1 to MBRS.0 by 1;
     Parse VAR MBRS.i the_string MBRS.i;
     If the_string = "--MEMBERS--" Then;
       Leave;
   End;
   Do i=i+1 to MBRS.0 by 1;
     the_string = Word(MBRS.i,1);
     Queue the_string;
   End;

   Return (0);
./ ADD NAME=SUM      0106-14134-16236-1750-00227-00221-00000-APLKS   46
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: This routine will sum a column of figures using  */
/*          the supplied equation.  Specify "nbr" within     */
/*          your equation to refer to data being selected.   */
/*  Format: SUM target | range                               */
/*              < strt_col end_col >                         */
/*              < ( equation >                               */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  line on the screen or the line that the  */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        strt_col: start column of the number               */
/*         end_col: end column of the number                 */
/*        equation:                                          */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SUM */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   answer = 0;
   nbr = 0;
   equation = "nbr";

   "(bndslo,bndshi) = BOUNDS";
   strt_col = bndslo;
   end_col = bndshi;
   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr + 1;

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     equation = parm3;

   /* Parse Target and User passed Parms */

   Call Extract_Target;

   /* Parse the Optional EXEC Parameters */

   Parse VAR parm2 var.3 parm2;
   If var.3 <> "" Then;
     Do;
       If Datatype(var.3,"N") Then;
         Do;
           strt_col = var.3;
           Parse VAR parm2 var.3 parm2;
           If var.3 = "" Then;
             Signal Error_INVALID_PARM;
           If Datatype(var.3,"N") Then;
             end_col = var.3;
           Else;
             Signal Error_INVALID_PARM;
         End;
       Else;
         Signal Error_INVALID_PARM;
     End;
   str_lgth = end_col - strt_col + 1;

   Do i = trgt_row_from to (trgt_row_to - 1) by 1;
     "(xstatus) = XSTATUS" i;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     nbr = Substr(row,strt_col,str_lgth);
     If Datatype(nbr,"N") Then;
       Interpret "answer = answer + "equation;
   End;

   ZERRLM  = "The answer is: " answer;
   ZERRSM = "";
   ZERRALRM= "NO";
   ZERRHM = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET:
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: This routine will sum a column of numbers using",
        pad hex04,
        "         the supplied equation.  Specify 'nbr' within",
        pad hex04,
        "         your equation to refer to data being selected. ",
        pad hex04,
        " Format: SUM target|range  strt_col end_col",
        pad hex04,
        "             < ( equation >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_PARM:

   ZEDSMSG = "INVALID PARM";
   ZEDLMSG = "Invalid/missing parameters";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);
./ ADD NAME=SYSEXEC  0119-14349-16188-1739-00169-00060-00000-APLKS   32
/* REXX */
/* --------------------------------------------------------- */
/* PURPOSE: ACTIVATE USER DATASETS TO OPTIONAL               */
/*          ISPF DDNAME SYSEXEC.                             */
/*                                                           */
/*  FORMAT: SYSEXEC <userid> ( ACTIVATE|DEACTIVATE|DISPLAY   */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG)";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SYSEXEC */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   tsouser = Userid();
   optuser = "";
   rexxlib = "'" || tsouser || ".WORK.REXXLIB'";
   opt. = "";
   tsoRC1 = 0;
   tsoRC2 = 0;
   tsoRC3 = 0;

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3 ")";
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "DISPLAY";         /*DISPLAY*/

   /* Parse the Optional EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       optuser = Strip(Word(parm2,1));
       If Length(optuser) <= 7 Then;
         rexxlib = "'" || optuser || ".WORK.REXXLIB'";
       Else;
         rexxlib = "'" || optuser || "'";
     End;

   Say " ";
   Say "EXECUTING" tsouser "CUSTOM SYSEXEC ALLOCATION MACRO ";
   Say " ";

   /* PERSONAL REXX LIBRARY BELOW */

   x = MSG("ON");

   Select;
     When opt.1 = "ACT" Then;
       Do;
         "ALTLIB DEACTIVATE APPLICATION(EXEC)";
         tsoRC1 = RC;
         message = SYSDSN(rexxlib);
         If message <> "OK" Then;
           Do;
             tsoRC2 = -12;
             Say message "RC =" tsoRC2;
           End;
         Else;
           Do;
             "ALTLIB ACTIVATE APPLICATION(EXEC) DSNAME("rexxlib")";
             tsoRC3 = RC;
             "ALTLIB DISPLAY";
           End;
       End;
     When opt.1 = "DEACT" Then;
       Do;
         "ALTLIB DEACTIVATE APPLICATION(EXEC)";
         tsoRC1 = RC;
         "ALTLIB DISPLAY";
       End;
     When opt.1 = "DISPLAY" Then;
       "ALTLIB DISPLAY";
     Otherwise;
       "ALTLIB DISPLAY";
   End;

   Select;
     When tsoRC1 > 4 Then;
       RC = tsoRC1;
     When tsoRC2 < 0 Then;
       RC = tsoRC2;
     When tsoRC3 <> 0 Then;
       RC = tsoRC3;
     Otherwise;
       RC = 0;
   End;

   If tsoRC1 > 4 | tsoRC2 < 0 | tsoRC3 <> 0 Then;
     Say "ALTLIB command" opt.1 "failed - RC=" RC;
   Else;
     Say "ALTLIB command" opt.1 " successful";

   Return (RC);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("ACTIVATE",var,3) Then;
         opt.1 = "ACT";
       When Abbrev("DEACTIVATE",var,3) |,
           var = "FREE" Then;
         opt.1 = "DEACT";
       When Abbrev("DISPLAY",var,3) Then;
         opt.1 = "DISPLAY";
       Otherwise;
         opt.1 = "DISPLAY";
     End;
   End;

   Return;

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Activate/Deactivate a user defined REXX library",
        pad hex04,
        "         default library name is userid.WORK.REXXLIB",
        pad hex04,
        " Format: SYSEXEC ( ACTIVATE|DEACTIVATE|DISPLAY";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;
./ ADD NAME=SYSEXEC1 0102-15280-15354-1611-00167-00166-00000-APLKS   58
/* REXX */
/* --------------------------------------------------------- */
/* PURPOSE: ACTIVATE USER DATASETS TO OPTIONAL               */
/*          ISPF DDNAME SYSEXEC.                             */
/*                                                           */
/*  FORMAT: SYSEXEC <userid> ( ACTIVATE|DEACTIVATE|DISPLAY   */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG)";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC SYSEXEC */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   tsouser = Userid();
   optuser = "";
/* rexxlib = "'" || tsouser || ".BATCH.REXXLIB'"; */
   rexxlib = "'" || tsouser || ".FILE020.PDS'";
   opt. = "";
   tsoRC1 = 0;
   tsoRC2 = 0;
   tsoRC3 = 0;

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3 ")";
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "DISPLAY";         /*DISPLAY*/

   /* Parse the Optional EXEC Parameters */

   If parm2 <> "" Then;
     Do;
       optuser = Strip(Word(parm2,1));
       rexxlib = "'" || optuser || ".WORK.REXXLIB'";
     End;

   Say " ";
   Say "EXECUTING" tsouser "CUSTOM SYSEXEC ALLOCATION MACRO ";
   Say " ";

   /* PERSONAL REXX LIBRARY BELOW */

   x = MSG("ON");

   Select;
     When opt.1 = "ACT" Then;
       Do;
         "ALTLIB DEACTIVATE APPLICATION(EXEC)";
         tsoRC1 = RC;
         message = SYSDSN(rexxlib);
         If message <> "OK" Then;
           Do;
             tsoRC2 = -12;
             Say message "RC =" tsoRC2;
           End;
         Else;
           Do;
             "ALTLIB ACTIVATE APPLICATION(EXEC) DSNAME("rexxlib")";
             tsoRC3 = RC;
             "ALTLIB DISPLAY";
           End;
       End;
     When opt.1 = "DEACT" Then;
       Do;
         "ALTLIB DEACTIVATE APPLICATION(EXEC)";
         tsoRC1 = RC;
         "ALTLIB DISPLAY";
       End;
     When opt.1 = "DISPLAY" Then;
       "ALTLIB DISPLAY";
     Otherwise;
       "ALTLIB DISPLAY";
   End;

   Select;
     When tsoRC1 > 4 Then;
       RC = tsoRC1;
     When tsoRC2 < 0 Then;
       RC = tsoRC2;
     When tsoRC3 <> 0 Then;
       RC = tsoRC3;
     Otherwise;
       RC = 0;
   End;

   If tsoRC1 > 4 | tsoRC2 < 0 | tsoRC3 <> 0 Then;
     Say "ALTLIB command" opt.1 "failed - RC=" RC;
   Else;
     Say "ALTLIB command" opt.1 " successful";

   Return (RC);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("ACTIVATE",var,3) Then;
         opt.1 = "ACT";
       When Abbrev("DEACTIVATE",var,3) |,
           var = "FREE" Then;
         opt.1 = "DEACT";
       When Abbrev("DISPLAY",var,3) Then;
         opt.1 = "DISPLAY";
       Otherwise;
         opt.1 = "DISPLAY";
     End;
   End;

   Return;

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Activate/Deactivate a user defined REXX library",
        pad hex04,
        "         default library name is userid.WORK.REXXLIB",
        pad hex04,
        " Format: SYSEXEC ( ACTIVATE|DEACTIVATE|DISPLAY";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;
./ ADD NAME=TRAP     0108-15234-15278-0833-00182-00001-00000-APLKS   13
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: This Rexx procedure will accept any TSO command  */
/*          (including clists and other Rexx procedures)     */
/*          that outputs to the terminal via TSO PUTLINE and */
/*          traps the output and then display the results    */
/*          according to the options.                        */
/*                                                           */
/*  Format: %TRAP tsocmd ( options                           */
/*                                                           */
/*          options: (default) VIEW DELETE                   */
/*                   VIEW|NOVIEW                             */
/*                   DELETE|NODELETE                         */
/*                                                           */
/*  Author: Lionel B. Dyck                                   */
/*          Rockwell International                           */
/*          P.O. Box 2515                                    */
/*          Seal Beach, California 90740                     */
/*          (310) 797-1125                                   */
/*          IBMLINK:  ROK2027                                */
/*                                                           */
/* Similar to edit macros  @STRAP  etc. by D.McR             */
/* The TSOTRAP procedure should prove useful to CUT lines    */
/* out and to paste elsewhere later.                         */
/*                                                           */
/* History: 1990/07/23 - Rexx procedure created.             */
/*          1990/10/04 - update to larger lrecl for trap d/s */
/*         *1992/01/19 - D.McR use EDIT, exit if TRAP.0=0    */
/*         *1992/01/20 - D.McR .LIST in dsname for profile   */
/*         *1994/06/30 - D.McR Provide for NOPREFIX users    */
/*          2015/08/26 - L.Slaten applied local standards    */
/*                                                           */
/* --------------------------------------------------------- */

   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC TRAP */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var.3 = "";
   opt. = "";
   lne. = "";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "VIEW";
   If opt.2 = "" Then;
     opt.2 = "DELETE";
   opt.0 = 2;

   tsocmd = parm2;
   seq_dsname = Userid()||"."||Word(tsocmd,1),
        ||".D"||Date("B")".T"||Time("S");

   x = Outtrap("lne.");
   tsocmd;
   x = Outtrap("OFF");

   If lne.0 = 0 Then;
     Signal Msg_NO_OUTPUT;

   "ALLOC DSNAME("seq_dsname") DSORG(PS) RECFM(F B) ",
          "LRECL(132) BLKSIZE(0) SPACE(1,5) TRACKS ",
          "NEW CATALOG REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_TGTSEQ;

   "ALLOC FILE(DDOUT1) DSNAME("seq_dsname") ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_ALLOC_TGTSEQ;

   "EXECIO * DISKW DDOUT1 ( STEM LNE. FINIS";
   If RC = 0 Then;
     If opt.1 = "VIEW" Then;
       Do;
         Address ISPEXEC "VIEW DATASET("seq_dsname")";
         "FREE FILE(DDOUT1)";
       End;

   If opt.2 = "DELETE" Then;
     "DELETE ("seq_dsname")";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("VIEW",var.3) Then;
         opt.1 = "VIEW";
       When Abbrev("NOVIEW",var.3) Then;
         opt.1 = "NOVIEW";
       When Abbrev("DELETE",var.3) Then;
         opt.2 = "DELETE";
       When Abbrev("NODELETE",var.3) Then;
         opt.2 = "NODELETE";
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Envoke TSO command, trap the output and",
        pad hex04,
        "         present it to the user according to options",
        pad hex04,
        "         (e.g. TSO TRAP LISTDS 'somedsname'...).",
        pad hex04,
        " Format: TRAP tsocmd ( VIEW|NOVIEW  DELETE|NODELETE ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Msg_NO_OUTPUT:

   If addrsp_name = "TSO/E" | addrsp_name = "ISPF" Then;
     x = Outtrap("OFF");
   ZEDSMSG = "NO OUTPUT";
   ZEDLMSG = "No output generated";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (4);
./ ADD NAME=TSUALL   0109-15238-15265-1608-00291-00001-00000-APLKS   49
/* REXX -
 +------------------------------------------------------------------+
 | Name:       TSUALL                                               |
 | Old Name:   TSURXS                                               |
 | Type:       REXX exec                                            |
 | Purpose:    Display TSO userid from the OUCB                     |
 | Release:    OS/390 2.4                                           |
 | Programmer: John Kalinich                                        |
 | Date:       04/28/99                                             |
 | Modified:   08/28/2015 by L. Slaten, local standards             |
 | Abstract:   Display all TSO userids in sorted order              |
 |                                                                  |
 | Call Format:  TSUALL  ( options                                  |
 |              options: (default) SCREEN                           |
 |                       LINE | SCREEN | QUEUE                      |
 |                                                                  |
 | Logic: Extracts the CVT (at x'10')                               |
 |        Extracts the ASVT (CVT+x'22C')                            |
 |        Extracts first available ASVT entry (ASVT+x'20C')         |
 |  .---> Extracts the next ASCB in vector table                    |
 |  |     Extracts the OUCB (ASCB+x'90')                            |
 |  '---- Extracts OUCBUSRD                                         |
 +------------------------------------------------------------------+ */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC TSUALL */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   count = 0;
   userid. = "";
   opt. = "";
   lne. = "";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1;

   /* Mainline */

   Numeric Digits 10;

   cvt_ptr   = Get_ptr(10,0);
   asvt_ptr  = Get_ptr(cvt_ptr,'22c');
   max_users = X2D(Get_ptr(asvt_ptr,'204'));          /*Max ASID's*/
   asvt_frst_ptr = D2X(X2D(asvt_ptr) + X2D(20c));     /*ASVTFRST*/

   /*  Master Scheduler, ASID=1, ASVT+x'210'  */

   Do max_users;
     asvt_frst_ptr = D2X(X2D(asvt_frst_ptr) + X2D(4)); /*Next ASID*/
     ascb_ptr = Get_ptr(asvt_frst_ptr,0);
     If Bitand(Left(X2C(ascb_ptr),1),'80'x) = '80'x Then;
       /*Available ASID*/
       Iterate;
     ascb_jbns_ptr = Get_ptr(ascb_ptr,'b0');
     If ascb_jbns_ptr = '00000000' Then;               /*No jobname*/
       Iterate;
     oucb_ptr = Get_ptr(ascb_ptr,'90');
     oucb_yfl = Get_data(oucb_ptr,'12',1);
     If Bitand(oucb_yfl,'20'x) <> '20'x Then;          /*Not a Logon*/
       Iterate;
     oucb_usrd = Get_data(oucb_ptr,'d0',8);
     If Left(oucb_usrd,1) = '40'x Then;                /*No userid*/
       Iterate;
     count = count + 1;
     userid.count = oucb_usrd;
   End;

   userid.0 = count;
   lne.1 = "There are" userid.0 "TSO users logged on:";
   lne.2 = Copies(" ",5);

   Call Sort_Userids;
   Call Format_Userids;

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do i=1 To lne.0 By +1;
         Say lne.i;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(1)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD (STEM LNE. FINIS)";
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     When opt.1 = "QUE" Then;
       Do i=1 To userid.0 By +1;
         Queue userid.i;
       End;
     Otherwise;
       Nop;
   End;

   Return (0);

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) |,
            Abbrev("QUEUE",var,3) Then;
         opt.1 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   Sort_Userids: Procedure Expose userid.  /* Quick sort */
   /* +-----------------------------------------+
      |                                         |
      +-----------------------------------------+ */
   n = userid.0;
   s = 1; stackl.1 = 1; stackr.1 = n;
   Do Until s = 0;
      l = stackl.s; r = stackr.s; s = s - 1;
      Do Until l >= r;
         i = l; j = r;
         p = (l + r) % 2;
         If userid.L > userid.p Then;
           Do;
             w = userid.l;
             userid.l = userid.p;
             userid.p = w;
           End;
         If userid.l > userid.r Then;
           Do;
             w = userid.l;
             userid.l = userid.r;
             userid.r = w;
           End;
         If userid.p > userid.r Then;
           Do;
             w = userid.p;
             userid.p = userid.r;
             userid.r = w;
           End;
         x = userid.p;
         Do Until i > j;
            Do i = i While userid.i < x; End;
            Do j = j BY -1 While x < userid.j; End;
            IF i <= j Then;
              Do;
                w = userid.i;
                userid.i = userid.j;
                userid.j = w;
                i = i + 1; j = j - 1;
              End;
         End;
         If (j - l) < (r - i) Then;
           Do;
             IF i < r Then;
               Do;
                 s = s + 1;
                 stackl.s = i;
                 stackr.s = r;
               End;
             r = j;
           End;
         Else;
           Do
             If l < j Then;
               Do;
                 s = s + 1;
                 stackl.s = l;
                 stackr.s = j;
               End;
             l = i;
           End;
      End; /* Until l >= r */
   End;    /* Until s = 0  */

   Return;

   Format_Userids:  /* 8 to a line */
   /* +-----------------------------------------+
      |                                         |
      +-----------------------------------------+ */
   i = 3;
   Do x = 1 to userid.0;
     lne.i = lne.i || userid.x;
     If x // 8 = 0 Then;
       i = i + 1;
   End;
   lne.0 = i;

   Return;

   Get_ptr: Procedure
   /* +-----------------------------------------+
      | returns a 4 byte pointer as hexadecimal |
      | string at address addr+offset.          |
      | ADDR and OFFSET must be HEX strings.    |
      +-----------------------------------------+ */
   Arg addr, offset;
   temp = D2X(X2D(addr) + X2D(offset));
   Return C2X(Storage(temp,4));
   Exit;

   Get_data: Procedure
   /* +-----------------------------------------+
      | returns LENGTH bytes at ADDR+OFFSET as  |
      | an EBCDIC string.                       |
      | ADDR and OFFSET must be HEX strings.    |
      | LENGTH must be a decimal string.        |
      +-----------------------------------------+ */
   Arg addr, offset, length;
   temp = D2X(X2D(addr) + X2D(offset));
   Return Storage(temp,length);
   Exit;

/* +-----------------------------------------+
   | Error processing routines               |
   +-----------------------------------------+ */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display all of the active TSO USERIDs",
        pad hex04,
        " Format: TSUALL ( SCREEN | LINE | QUEUE";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

/* J.Kalinich, x4521 */
/* Exec to list TSO users (sorted by userid)                        */
./ ADD NAME=UNPK     0103-15274-15358-1756-00035-00036-00000-APLKS   07
/* REXX function
   Invoke as:    UNPK(nbr,scale,prec) (commas required)
   'Nbr' is a packed-decimal number.
   'Scale' is the size of the target field, NOT the decimal
   scale (as in PL/I).
   'Prec' is decimal places.
   Convert to hex.
   The sign is at the extreme right: C=positive, D=negative.
   Remaining length, split 'nbr' into 'whol' and 'frac', trim, set sign.
   ----------------------------------------------------------------- */

   Numeric Digits 31;
   Parse  Arg  nbr,scale,prec  . ;     /* ::::  3  maybe */
   Parse VALUE prec "0"  with  prec . ;/* 3,0 yields 3 */
   nbrx = C2X(nbr);                    /* 0034723D maybe */
   Parse VALUE scale Length(nbrx)-1  with  scale  . ;
   Parse VALUE Reverse(nbrx) with sign 2 revnbrx;  /* D 3274300 */
   If Verify(revnbrx,"0123456789") > 0 Then;   /* bad string */
     Return("ERROR");

   If sign = "D" Then;
     factor = -1;
   Else;
     factor = 1;

   revfrac = Left(revnbrx,prec,0);     /* 327 */
   nbrx = Reverse(revnbrx);            /* 0034723 */
   If prec > scale Then;
     Parse VALUE 0 prec with whol scale;
   Else;
     whol = Left(nbrx,Length(nbrx)-prec);    /* 0034 */
   frac = Reverse(revfrac);            /* 723 */
   nbr  = Right((whol"."frac)*factor,scale); /* -34.723 */

   Return (nbr);
./ ADD NAME=VMBR     0114-14134-16190-1115-00210-00191-00000-APLKS   11
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: View the dataset being pointed to by the target. */
/*          Looking for DSN=                                 */
/*                                                           */
/*  Format: VMBR target < ( options >                        */
/*                                                           */
/*          target: is the row to retrieve                   */
/*                  can be any valid label                   */
/*                  the row that the cursor is on            */
/*                  variable names are trgt_row              */
/*         options: (default) VIEW                           */
/*                  BROWSE VIEW EDIT                         */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC VMBR */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   cmd = "VIEW";
   the_string = "";
   var. = "";
   ptr = 0;

   "(bndslo,bndshi) = BOUNDS";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   parm3 = Strip(parm3,'B');
   If parm3 <> "" Then;
     cmd = parm3;

   /* Parse Target and User Passed Parms */

   Call Extract_TARGET;

   /* Main line code */

   "(row) = LINE" trgt_row;
   the_string = Strip(Strip(Substr(row,bndslo,(bndshi-bndslo-1)),"B"));
   ptr = Pos("DSN=",the_string);
   If ptr = 0 Then;
     Signal Error_INVALID_DATASET;
   ptr = ptr+4;
   the_string = Substr(the_string,ptr);
   ptr = Pos(",",the_string);
   If ptr <> 0 Then;
     Do;
       ptr = ptr-1;
       the_string = Substr(the_string,1,ptr);
     End;
   Else
     Do;
       ptr = Pos(" ",the_string);
       If ptr <> 0 Then;
         Do;
           ptr = ptr-1;
           the_string = Substr(the_string,1,ptr);
         End;
     End;

   ptr = Pos("(",the_string);
   If ptr <> 0 Then;
     Do;
       Parse VAR the_string front "(" gdgmbr ")" . ;
       If Datatype(gdgmbr,"W") Then;
         the_string = Fulldsn(the_string);
     End;

   the_string = Strip(the_string);
   x = SYSDSN(the_string);
   If x <> "OK" Then;
     Signal Error_INVALID_DATASET;

   Select;
     When Abbrev("BROWSE",cmd) Then;
       Address ISPEXEC "BROWSE DATASET ("the_string")";
     When Abbrev("VIEW",cmd) Then;
       Address ISPEXEC "VIEW DATASET ("the_string")";
     When Abbrev("EDIT",cmd) Then;
       Address ISPEXEC "EDIT DATASET ("the_string")";
     Otherwise;
       Signal Error_INVALID_CMD;
   End;

   Return(0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Extract_TARGET:

   /* Resolve trgt_row and trgt_col Variables */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row = krow;
       trgt_col = kcol;
     End;
   Else;
     trgt_row = frow;

   Parse VAR parm2 var.1 parm2;
   If var.1 <> "" Then;
     Select;
       When Substr(var.1,1,1) = "." Then;
         Do;
           "(linenbr) = LINENUM" var.1;
           trgt_row = linenbr;
         End;
       When Datatype(var.1,"W") Then;
         trgt_row = var.1;
       Otherwise;
         Signal Error_INVALID_TARGET;
     End;

   Return(0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: View the dataset the target is pointing to.",
        pad hex04,
        " Format: VMBR target < ( VIEW | BROWSE | EDIT >";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_CMD:

   ZEDSMSG = "INVALID CMD";
   ZEDLMSG = "Invalid command ("cmd")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return(-16);

   Error_INVALID_DATASET:

   ZEDSMSG = "INVALID DATASET";
   ZEDLMSG = x;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return(-16);
./ ADD NAME=VOL2DEV  0104-16236-16236-1516-00097-00197-00000-APLKS   18
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: Display the device number associated with a      */
/*          volume id.                                       */
/*                                                           */
/*  Format: VOL2DEV volume                                   */
/*                                                           */
/*          -1  Parameter error                              */
/*          -2  UCBScan error                                */
/*          -3  VolSer not found                             */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC VOL2DEV */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */

   /* Parse the User Options */

   /* Parse Target and User Passed Parms */

   /* Main line code */

   devn = RXV2DEV(parm2);
/* If devn < 0 Then;
     Signal Error_INVALID_VOLUME; */
   Upper devn;

   pad = Copies(" ",62);
   ZERRLM  = pad,
        "VOLUME("parm2") is on device: "devn;
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";

   Return(0);

   /* ------------------------ */
   /* LOCAL PERFORMED ROUTINES */
   /* ------------------------ */

   Return(0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Return the device number of the volume id.",
        pad hex04,
        " Format: VOL2DEV volume ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_VOLUME:

   ZEDSMSG = "INVALID VOLUME";
   ZEDLMSG = "Invalid VOLUME ID ("parm2") RC=" devn;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return(-16);
./ ADD NAME=VSAVE    0110-15233-16190-1118-00092-00001-00000-APLKS   07
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: Used to SAVE/REPLACE a modified member being     */
/*          VIEWed.  Member statistics will not be updated.  */
/*                                                           */
/*  Format: VSAVE                                            */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC VSAVE */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   /* Initialize Variables */

   "(modflg) = DATA_CHANGED";
   "(zdsn) = DATASET";
   "(zmemb) = MEMBER";

   /* Mainline */

   If modflg <> "YES" Then;
     Return (0);

   If zmemb = "" Then;
     Do;
       "REPLACE '"zdsn"' .ZFIRST .ZLAST ";
       EC = RC;
       If RC <> 0 Then;
         Signal Error_REPLACE_DSN;
     End;
   Else;
     Do;
       "REPLACE "zmemb" .ZFIRST .ZLAST ";
       If RC <> 0 Then;
         Signal Error_REPLACE_MBR;
     End;

   Address ISPEXEC "SETMSG MSG(ISRE016)";
   "CANCEL";
   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_REPLACE_DSN:

   Address ISPEXEC "SETMSG MSG("ZERRMSG")";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Return (-16);

   Error_REPLACE_MBR:

   Address ISPEXEC "SETMSG MSG("ZERRMSG")";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Return (-16);
./ ADD NAME=XDUP     0112-14134-16236-1751-00330-00324-00000-APLKS   52
/* REXX 2016-08-23 */
/* --------------------------------------------------------- */
/* Purpose: To exclude rows containing duplicate data.       */
/*          To find the duplicate data it must exist in      */
/*          the next row.  EXCLUDED rows are not allowed.    */
/*          You can use the FLIP command to display the      */
/*          excluded rows.                                   */
/*  Format: XDUP target | range                              */
/*               strt_col end_col | *                        */
/*               < ( options >                               */
/*                                                           */
/*          target: defines where to stop (not inclusive)    */
/*                  can be a positive integer or a system/   */
/*                  user defined label(.ZFIRST .ZLAST .ZCSR) */
/*                  trgt_row_from defaults to the first body */
/*                  row on the screen or the row that the    */
/*                  cursor is positioned                     */
/*                  variable name is trgt_row_to             */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*                  variable names are trgt_row_from         */
/*                                     trgt_row_to           */
/*        strt_col: start column of the text                 */
/*         end_col: end column of the text                   */
/*         options: (default) LEADING                        */
/*                  ALL | LEADING                            */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC XDUP */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";
   the_string. = "";
   first_match = "";
   last_match = "";

   Address ISPEXEC "VGET (LANG@@) PROFILE";
   If RC = 0 Then;
     lang = lang@@;
   Else;
     lang = "";

   "(bndslo,bndshi) = BOUNDS";
   trgt_col_from = bndslo;

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr + 1;

   "(status) = USER_STATE";
   "RESET X";

   /* Check out Edit Mode Options */

   "(recfm) = RECFM";
   "(lrecl) = LRECL";
   zonelo = 1;
   zonehi = lrecl;
   Select;
     When recfm = "V" Then;
       zonelo = 9;
     When lang = "STD" Then;
       zonehi = lrecl - 8;
     When lang = "COBOL" Then;
       zonelo = 7;
     Otherwise;
       Nop;
   End;

   "BOUNDS = (zonelo,zonehi)";

   /* Parse the User Options */

   Parse VAR parm2 parm2 " (" parm3;
   If parm3 = "" Then;
     opt = "LEADING";
   Else;
     Do;
       opt = Strip(parm3,"B");
       If Abbrev("LEADING",opt) | Abbrev("ALL",opt) Then;
         Nop;
       Else;
         Signal Error_INVALID_OPT;
     End;

   /* Parse Target and User passed Parms */

   Call Extract_Target;

   /* Parse the Optional EXEC Parameters */

   Parse VAR parm2 var.3 parm2;
   If var.3 = "" Then;
     var.3 = "*";
   If var.3 = "*" Then;
     Do;
       strt_col = 1;
       "(lrecl) = LRECL";
       end_col = lrecl;
     End;
   Else;
     Do;
       If Datatype(var.3,"W") Then;
         Do;
           strt_col = var.3;
           Parse VAR parm2 var.3 parm2;
           If var.3 = "" Then;
             Signal Error_INVALID_PARM;
           If Datatype(var.3,"W") Then;
             end_col = var.3;
           Else;
             Signal Error_INVALID_PARM;
         End;
       Else;
         Signal Error_INVALID_PARM;
     End;
   str_lgth = Abs(end_col - strt_col) + 1;

   "(row) = LINE" trgt_row_from;
   the_string.1 = Substr(row,strt_col,str_lgth);

   Do i = trgt_row_from + 1 to trgt_row_to by 1;
     "(row) = LINE" i;
     the_string.2 = Substr(row,strt_col,str_lgth);,
     Select;
       When first_match = "" Then;
         If the_string.2 = the_string.1 Then;
           Do;
             "LABEL " i - 1 " = .PTA 0";
             first_match = i - 1;
           End;
       When first_match <> "" Then;
         If the_string.2 <> the_string.1 Then;
           Do;
             "LABEL " i - 1 " = .PTC 0";
             last_match = i - 1;
             Call Exclude_Dups;
             "RESET LABEL";
             first_match = "";
             last_match = "";
           End;
         Else;
           If (trgt_row_to -1) = i Then;
             Do;
               "LABEL " i " = .PTC 0";
               last_match = i;
               Call Exclude_Dups;
               "RESET LABEL";
               first_match = "";
               last_match = "";
             End;
       Otherwise;
         Nop;
     End;
     the_string.1 = the_string.2;
   End;

   "USER_STATE = (status)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Exclude_Dups:

   Select;
     When (last_match - first_match) = 1 Then;
       If Abbrev("LEADING",opt) Then;
         "EXCLUDE .PTA .PTA '"the_string.1"' ALL";
       Else;
         "EXCLUDE .PTA .PTC '"the_string.1"' ALL";
     When (last_match - first_match) > 1 Then;
       Do;
         "LABEL " last_match - 1 " = .PTB 0";
         If Abbrev("LEADING",opt) Then;
           "EXCLUDE .PTA .PTB '"the_string.1"' ALL";
         Else;
           "EXCLUDE .PTA .PTC '"the_string.1"' ALL";
       End;
     Otherwise;
       Nop;
   End;
   Return (0);

   Extract_Target:

   /* Resolve trgt_row_from and trgt_row_to variables */
   /*         trgt_col_from                           */

   "(krow,kcol) = CURSOR";
   If RC <> 0 Then;
     Do;
       krow = 0;
       kcol = 0;
     End;
   "(frow,trow) = DISPLAY_LINES";
   If RC <> 0 Then;
     Do;
       frow = 0;
       trow = 0;
     End;
   If krow > frow Then;
     Do;
       trgt_row_from = krow;
       trgt_col_from = kcol;
     End;
   Else;
     trgt_row_from = frow;

   Parse VAR parm2 var.1 parm2;
   Select;
     When Substr(var.1,1,1) = "*" Then;
       trgt_row_to = trgt_row_eof;
     When Substr(var.1,1,1) = "." Then;
       Do;
         "(linenbr) = LINENUM" var.1;
         If var.1 = ".ZLAST" Then
           trgt_row_to = linenbr + 1;
         Else;
           trgt_row_to = linenbr;
         Parse VAR parm2 var.2 parm2;
         If var.2 <> "" Then;
           If Substr(var.2,1,1) = "." Then;
             Do;
               "(linenbr) = LINENUM" var.2;
               trgt_row_from = trgt_row_to;
               If var.2 = ".ZLAST" Then
                 trgt_row_to = linenbr + 1;
               Else;
                 trgt_row_to = linenbr;
             End;
           Else;
             parm2 = var.2" "parm2;
       End;
     When Datatype(var.1,"W") Then;
       trgt_row_to = trgt_row_from + var.1 - 1;
     Otherwise;
       Signal Error_INVALID_TARGET;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: Exclude rows with duplicate data within column range.",
        pad hex04,
        " Format: XDUP target|range",
        pad hex04,
        "              strt_col end_col | *",
        pad hex04,
        "              < ( LEADING | ALL >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_TARGET:

   ZEDSMSG = "INVALID TARGET";
   ZEDLMSG = "Invalid/no target declared"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Exit (-16);

   Error_INVALID_PARM:

   ZEDSMSG = "INVALID PARM";
   ZEDLMSG = "Invalid/missing parameters";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);

   Error_INVALID_OPT:

   ZEDSMSG = "INVALID OPTION";
   ZEDLMSG = "Invalid user option ("opt")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "USER_STATE = (status)";
   Return (-16);
./ ADD NAME=XMACRO   0120-15248-17136-1440-00106-00066-00000-APLKS   11
/* REXX 2017-03-02 */
/* --------------------------------------------------------- */
/* Purpose: Skeleton input exec macro.  Invoked from         */
/*          PWRISRT.                                         */
/*                                                           */
/*  Format: XMACRO iparm                                     */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Address TSO "ISREMSPY"; */

/* Entering EXEC XMACRO   */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

/* Upper parm2;

   If parm2 = "" Then;
     Signal Error_NO_DATA; */

   /* Initialize variables */

   "(currmem) = MEMBER";

   /*SOURCE before 1st*/
   /*HELP before 1st*/
   text1 = "*" || Copies(" ",3) || "CBT#478 FILE#810",
           || Copies(" ",5) || "ONSCREEN" || Copies(" ",29),
           || "LKS";

   /*REXX before 1st*/
   text2 = "/* REXX 2017-03-02 CBT#478 FILE#810 ONSCREEN */";

   /*DOC before 1st*/
   text3 = "/*" || Copies(" ",2) || "CBT#478 FILE#810",
           || Copies(" ",5) || "ONSCREEN" || Copies(" ",29),
           || "LKS */";

   /*CLIST before 1st*/
   /*PANELS after last*/
   text4 = "/*" || Copies(" ",2) || "CBT#478 FILE#810",
           || Copies(" ",5) || "ONSCREEN" || Copies(" ",29),
           || "LKS";

   /* Mainline Routine */

   Say "You are editing member: " currmem;

   "LINE_BEFORE .ZF = (text1)";
/* "LINE_AFTER .ZL = (text4)"; */

   If RC > 0 Then;
     Do;
       EC = RC;
       Signal Error_INVALID_INSTRUCTION;
     End;

   "BUILTIN SAVE";
   "END";

   Return (RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_INSTRUCTION:

   ZEDSMSG = "INVALID INST";
   ZEDLMSG = "Instruction failed with RC="EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=XMORE    0115-16027-16190-1125-00214-00212-00000-APLKS   07
/* REXX 2016-07-08 */
/* --------------------------------------------------------- */
/* Purpose: EXCLUDE count number of rows AFTER or BEFORE a   */
/*          group of EXCLUDEd rows.                          */
/*                                                           */
/*  Format: XMORE   <range>                                  */
/*                  < ( options >                            */
/*                                                           */
/*           range: defines where to begin and end           */
/*                  can be a pair of system/user defined     */
/*                  labels                                   */
/*         options: (default) BEFORE 3                       */
/*                  AFTER | BEFORE                           */
/*                  count                                    */
/*                                                           */
/* Inspired by Carl Hafner's CBT #357                        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC XMORE */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   Upper parm2;

   If parm2 = "" | parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var. = "";       /* 1=1st label  2=2nd label */
   opt. = "";       /* 1=AFTER|BEFORE 2=count */
   process = "X"    /* X=excluded   NX=non-excluded */

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   /* Initialize Default values */

   If opt.1 = "" Then;
     opt.1 = "BEFORE";
   If opt.2 = "" Then;
     opt.2 = 3;

   /* Parse Range */

   If parm2 <> "" Then;
     Call Extract_Range;

   If var.1 = "" Then;
     var.1 = ".ZFIRST";
   If var.2 = "" Then;
     var.2 = ".ZLAST";

   "(lptr1) = LINENUM" var.1;
   If RC > 0 Then;
     Signal Error_INVALID_RANGE;
   "(lptr2) = LINENUM" var.2;
   If RC > 0 Then;
     Signal Error_INVALID_RANGE;
   fptr = Min(lptr1,lptr2);        /*1st line in range*/
   lptr = Max(lptr1,lptr2);        /*last line in range*/

   /* Parse the Optional EXEC Parameters */

   /* Mainline */

   Do i=fptr To lptr By 1;
     "(xstatus) = XSTATUS" i;
     If process = "X" & xstatus = "NX" Then;
       Iterate;
     If process = "NX" & xstatus = "X" Then;
       Iterate;
     If process = "NX" & xstatus = "NX" Then;
       Do;
         If opt.1 = "AFTER" Then;
           Do opt.2;
             "XSTATUS" i "= X";
             i = i+1;
           End;
         i = i-1;
         process = "X";
         Iterate;
       End;
     If process = "X" & xstatus = "X" Then;
       Do;
         If opt.1 = "BEFORE" Then;
           Do;
             j = i-1;
             Do opt.2;
               "XSTATUS" j "= X";
               j = j-1;
             End;
             process = "NX";
           End;
         process = "NX";
       End;
   End;

   "LOCATE" var.1;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Range:

   Parse VAR parm2 var.1 parm2;
   If var.1 <> "" Then;
     If Substr(var.1,1,1) <> "." Then
       Signal Error_INVALID_RANGE;

   Parse VAR parm2 var.2 parm2;
   If var.2 <> "" Then;
     If Substr(var.2,1,1) <> "." Then
       Signal Error_INVALID_RANGE;

   If (var.1 = "" & var.2 = "") | (var.1 <> "" & var.2 <> "") Then;
     Nop;
   Else;
     Signal Error_INVALID_RANGE;

   Return (0);

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("AFTER",var.3) Then;
         opt.1 = "AFTER";
       When Abbrev("BEFORE",var.3) Then;
         opt.1 = "BEFORE";
       When Datatype(var.3,"W") Then;
         opt.2 = var.3;
       Otherwise;
         Signal Error_INVALID_OPTION;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = hex04,
        "Purpose: EXCLUDE count number of rows AFTER or BEFORE a group of",
        pad hex04,
        "         EXCLUDEd rows.",
        pad hex04,
        " Format: XMORE < range >",
        pad hex04,
        "               < ( BEFORE | AFTER < count > >";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_ENV:

   ZEDSMSG = "INVALID ENV";
   ZEDLMSG = "Must be in ISREDIT environment";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_OPTION:

   ZEDSMSG = "INVALID OPTION";
   ZEDLMSG = "Invalid/missing option ("var.3")";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Return (-16);

   Error_INVALID_RANGE:

   ZEDSMSG = "INVALID RANGE";
   ZEDLMSG = "Range is not a valid set of labels"
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=ZOSINFO  0122-16182-19210-1631-00318-00308-00000-APLKS   37
/* REXX 2019-07-29 */
/* --------------------------------------------------------- */
/* Purpose: Display z/OS, hardware and TSO System            */
/*          environment variables.                           */
/*                                                           */
/*  Format: zOSINFO ( options                                */
/*                                                           */
/*         options: (default) SCREEN                         */
/*                  LINE | SCREEN presentation option        */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC zOSINFO */

   Address TSO;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSE/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   var = "";
   opt. = "";

   /*title of day table*/
   tod.0 = 7;
   tod.1 = "Mon";
   tod.2 = "Tue";
   tod.3 = "Wed";
   tod.4 = "Thu";
   tod.5 = "Fri";
   tod.6 = "Sat";
   tod.7 = "Sun";

   /* Parse User Passed Parms */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;

   If opt.1 = "" Then;
     opt.1 = "SCR";      /*screen*/
   opt.0 = 1;

   /* Mainline */

   "MAKEBUF";   /*RC has new buffer number*/

   base_day = Date("B");
   dayofwk = base_day // 7 + 1; /*Mon-Sun 1-7*/
   normal_date = Date("N");
   Queue "Current date -" tod.dayofwk normal_date " "Date("S");

   lilian_day = base_day - 577734;
   ansi_day = base_day - 584387;
   unix_day = lilian_day - 141428;
   Queue "Base -" base_day " Lilian -" lilian_day,
        " ANSI -" ansi_day " UNIX -" unix_day;

   Queue " ";
   Queue "SYSDATE  = "DATE('USA') "mm/dd/yy";
   Queue "SYSJDATE = "DATE('JULIAN') "yyddd";
   /*ISPF variable ZJDATE=yy.ddd ZJ4DATE=yyyy.ddd*/
   Queue "SYSSDATE = "DATE('ORDERED') "yy/mm/dd";
   /*ISPF variable ZDATE=yy/mm/dd ZDATEF=YY/MM/DD*/
   /*ISPF variable ZDATESTD=yyyy/mm/dd*/
   /*ISPF variable ZSTDYEAR=yyyy ZYEAR=yy ZMONTH=mm ZDAY=dd*/
   /*ISPF variable ZDAYOFWK=SUNDAY...SATURDAY*/
   Queue "SYSSTIME = "Substr(TIME('NORMAL'),1,5) "hh:mm";
   Queue "SYSTIME  = "TIME('NORMAL') "hh:mm:ss";
   /*ISPF ZTIME=hh:mm:ss ZTIMELl=hh:mm.ss.hh*/

   Queue " ";
   Queue "User Information";
   Queue " SYSUID   = "SYSVAR('SYSUID');
   If Substr(SYSVAR('SYSRACF'),1,4) = "AVAIL" Then;                     /
     Do;
       Queue " RACF USR = "ENVVAR('RACFUSER');
       Queue " RACF GRP = "ENVVAR('RACFGRP');
       Queue " TSO ATTR = "ENVVAR('TSOATTR');
     End;

   Queue " ";
   Queue "Current JOB Information"
   Queue " SYSNAME  = "MVSVAR('SYSNAME') " >>SYSTEM running on";
   Queue " JOB ID   = "ENVVAR('JOBID');
   Queue " JOB NAME = "ENVVAR('JOBNM');
   Queue " Real Stg = "ENVVAR('REALSTG') ||"M";
   Queue " Region   = "ENVVAR('REGSIZE') ||"K";
   Queue " SYSSRV   = "SYSVAR('SYSSRV') " >>srv units used";
   Queue " SYSCPU   = "Strip(SYSVAR('SYSCPU'),'L') " >>nbr of cpu sec used";
   Queue " SWA loc  = "ENVVAR('SWALOC');

   Queue " ";
   Queue "SYSTEM Information";
   Queue " IPL d/t   = "ENVVAR('IPLDATE'),
        Date('S',ENVVAR('IPLDATE'),'J'),
        ENVVAR("IPLTIME");
   elapsed_days = base_day - Date('B',ENVVAR('IPLDATE'),'J');
   Queue " Elapsed   = "elapsed_days "days";
   Queue " IPL PARM  = "ENVVAR('LOADPARM');
   Queue " IPL IPA   = "ENVVAR('IPA');
   Queue " IPL Dev   = "ENVVAR('IPLDEV');
   Queue " SYSNAME   = "MVSVAR('SYSNAME') " >>SYSTEM running on";
   Queue " HW name   = "ENVVAR('HWNAME');
   Queue " LPAR mode = "ENVVAR('LPARMODE');
   If ENVVAR('LPARMODE') = "YES" Then;
     Do;
       Queue " LPAR name = "ENVVAR('LPARNAME');
       Queue " SYSPLEX   = "ENVVAR('PLEXNAME');
       /* x = MVSVAR('SYSPLEX'); */
       /*ISPF variable ZSYSPLEX=    */
       Queue " SYSCLONE  = "MVSVAR('SYSCLONE'); /*SYS1.PARMLIB(IEASYMxx)*/
     End;
   Queue " Security  = "ENVVAR('SECURITY');
   Queue " SYSRACF   = "SYSVAR('SYSRACF') " >>AVAIL | NOT AVAIL | NOT INSTALED";
   Queue " SYSSMS    = "MVSVAR('SYSSMS') " >>UNAVAIL | INACT | ACTIVE";
   Queue " SYSSMFID  = "MVSVAR('SYSSMFID'); /*SYS1.PARMLIB(SMFPRMxx)*/
   Queue " GRS name  = "MVSVAR('SYSNAME');
   Queue " GRS mode  = "ENVVAR('GRSMODE') " >>NONE | RING | STAR";
   Queue " SYSNODE   = "SYSVAR('SYSNODE') " >>jes network node name";
   /*ISPF variable ZSYSNODE=   */
   Queue " Mstr CAT  = "ENVVAR('MCAT');

   Queue " ";
   Queue "Software Information";
   Queue " SYSOPSYS = "MVSVAR('SYSOPSYS') " >>os, vv.rr.mm, FMID";
   /*ISPF variable ZOS390RL=    */
   Queue " SYSLRACF = "SYSVAR('SYSLRACF') ,
        "HRF" || SYSVAR('SYSLRACF') ,
        ">>RACF vrmm, FMID";
   Queue " SYSMVS   = "MVSVAR('SYSMVS') " >>BCP v.r.m";
   Queue " SYSJES   = "SYSVAR('SYSJES') " >>spooler, os, v.rr";
   Queue " VTAM     = "ENVVAR('VTAMLVL') " >>VTAM v.r.m";
   Queue " SYSTSOE  = "SYSVAR('SYSTSOE') " >>TSO/E vrrm";
   Queue " SYSDFP   = "MVSVAR('SYSDFP') " >>DFSMSdfp cc.vv.rr.mm";
   Queue " SYSHSM   = "SYSVAR('SYSHSM') " >>DFSMShsm cc.vv.rr.mm";
   If SYSVAR(SYSISPF) = "ACTIVE" Then;
     Do;
       Address ISPEXEC "VGET (ZISPFOS ZENVIR ZPDFREL) SHARED ";
       Queue " ZISPFOS  = "zispfos;
       /*ISPF variable ZISPFOS=      */
       Queue " ISPFVER  = "zenvir;  /*Left(zenvir,8);*/
       Queue " ZPDFREL  = "zpdfrel;
       /*ISPF variable ZPDFREL=      */
     End;
   Queue " CICS     = CICS/TS 4.2, Translator 6.7.0";
   Queue " BAL      = 5696-234 HLASM V2 R6.0, PTF UI50739";
   Queue " COBOL    = 5655-S71 Enterprise COBOL V4 R2.0";
/* Queue " Debug    = 5655-W45 Debug Tool V11 R1.2"; */
   Queue " Sort     = 5650-ZOS ICEMAN z/OS V2 R2";

   Queue " ";
   Queue "Hardware Information";
   Queue " Hardware name    = "ENVVAR('HWNAME');
   Queue " CPU Serial model = "ENVVAR('CPUMODL');
   RC = SYSCPUS(cpu.);
   If RC = 0 Then;
     Do i = 1 to cpu.0
       Queue " " Right(i,2,0) "Serial nbr "cpu.i;
     End;
   Queue " IODF dsname      = "ENVVAR('IODF');
   Queue " CACHE line size  = "ENVVAR('CACHELSZ');

   Queue " ";
   Queue "Current TSO/ISPF Information";
   Queue " SYSPROC   = "SYSVAR('SYSPROC') " >>LOGON BATCH=INIT";
   Queue " SYSTERMID = "SYSVAR('SYSTERMID');
   Queue " SYSAPPCLU = "MVSVAR('SYSAPPCLU') " >>APPC/MVS LU";
   Queue " SYSTSOE   = "SYSVAR('SYSTSOE') " >>TSO/E v.rr.m";
   Queue " SYSSECLAB = "MVSVAR('SYSSECLAB') " >>TSO/E security label";
   Queue " SYSPREF   = "SYSVAR('SYSPREF');
   Queue " SYSISPF   = "SYSVAR('SYSISPF') " >>ACTIVE | NOT ACTIVE";
   Queue " SYSENV    = "SYSVAR('SYSENV') " >>FORE | BACK";
   Queue " SYSPCMD   = "SYSVAR('SYSPCMD') " >>EXEC | EDIT";
   Queue " SYSICMD   = "SYSVAR('SYSICMD') " >>implicitly invoked";
   Queue " SYSSCMD   = "SYSVAR('SYSSCMD') " >>subcommand";
   Queue " SYSNEST   = "SYSVAR('SYSNEST') " >>YES | NO";

   Queue " ";
   Queue " Terminal variables";
   Queue "  SYSLTERM = "Strip(SYSVAR('SYSLTERM'),'L') " >># LINES";
   Queue "  SYSWTERM = "Strip(SYSVAR('SYSWTERM'),'L') " >># COLS";

   Queue " ";
   Queue " LANGUAGE variables";
   Queue "  SYSDTERM = "SYSVAR('SYSDTERM') " >>DBCS YES | NO";
   Queue "  SYSKTERM = "SYSVAR('SYSKTERM') " >>KATAKANA YES | NO";
   Queue "  SYSPLANG = "SYSVAR('SYSPLANG') " >>Primary lang";
   Queue "  SYSSLANG = "SYSVAR('SYSSLANG') " >>Secondary lang";

   Queue " ";
   Queue " CONSOLE variables";
   Queue "  SOLDISP  = "SYSVAR('SOLDISP') " >>SOLICITED MSG YES | NO";
   Queue "  SOLNUM   = "SYSVAR('SOLNUM');
   Queue "  UNSDISP  = "SYSVAR('UNSDISP') " >>UNSOLICITED MSG YES | NO";
   Queue "  UNSNUM   = "SYSVAR('UNSNUM');
   Queue "  MFTIME   = "SYSVAR('MFTIME') " >>TIME STAMP YES | NO";
   Queue "  MFOSNM   = "SYSVAR('MFOSNM') " >>ORIG SYS NAME YES | NO";
   Queue "  MFJOB    = "SYSVAR('MFJOB') " >>JOB NAME YES | NO";
   Queue "  MFSNMJBX = "SYSVAR('MFSNMJBX');

   Queue " ";
   Queue "Global Symbols";
   Queue " DRSWITCH = "MVSVAR('SYMDEF','DRSWITCH');
   Queue " JOBNAME  = "MVSVAR('SYMDEF','JOBNAME');
   Queue " SYSALVL  = "MVSVAR('SYMDEF','SYSALVL');
   Queue " SYSCLONE = "MVSVAR('SYMDEF','SYSCLONE');
   Queue " SYSNAME  = "MVSVAR('SYMDEF','SYSNAME');
   Queue " SYSPLEX  = "MVSVAR('SYMDEF','SYSPLEX');
   Queue " SYSR1.   = "MVSVAR('SYMDEF','SYSR1.');
/* Queue " CICSREL1 = "MVSVAR('SYMDEF','CICSREL1');
   Queue " SYSPREF  = "MVSVAR('SYMDEF','SYSPREF');
   Queue " TESTHLQ  = "MVSVAR('SYMDEF','TESTHLQ');
   Queue " DEVLHLQ  = "MVSVAR('SYMDEF','DEVLHLQ');
   Queue " PRODHLQ  = "MVSVAR('SYMDEF','PRODHLQ');
   Queue " SYSHLQ   = "MVSVAR('SYMDEF','SYSHLQ'); */

   Qelem;  /*RC has number of elements in stack*/
   count = RC;

   Select;
     When opt.1 = "LIN" Then;   /*display at terminal in Line mode*/
       Do count;
         Pull line;
         Say line;
       End;
     When opt.1 = "SCR" Then;   /*display at terminal in screen mode*/
       Do;
         "ALLOC F(OUTDD) DSORG(PS) RECFM(F B)",
         " LRECL(80) BLKSIZE(0)",
         " UNIT(SYSDA) TRACKS SPACE(1)",
         " NEW DELETE REUSE";
         If RC <> 0 Then;
           Signal Error_ALLOC_TGTSEQ;
         "EXECIO * DISKW OUTDD ( FINIS "
         If RC = 0 Then;
           Do;
             Address ISPEXEC "LMINIT DATAID("tgtid") DDNAME(OUTDD)";
             Address ISPEXEC "VIEW DATAID("tgtid")";
             Address ISPEXEC "LMFREE DATAID("tgtid")";
           End;
       End;
     Otherwise;
       Nop;
   End;

   "DROPBUF";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Extract_Options:

   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var parm3;
     Select;
       When Abbrev("LINE",var,3) |,
            Abbrev("SCREEN",var,3) Then;
         opt.1 = Substr(var,1,3);
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Display z/OS & TSO System information",
        pad hex04,
        " Format: ZOSINFO ( SCREEN | LINE";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_ALLOC_TGTSEQ:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target Seq file allocation failed, RC= :" RC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   "DROPBUF";
   Return (-16);
