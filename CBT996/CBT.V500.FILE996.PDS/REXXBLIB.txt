./ ADD NAME=$$LIB    0101-19004-19004-0949-00001-00001-00000-APLKS   57
     USERID().BATCH.REXXLIB
./ ADD NAME=ASA2PC   0110-15241-16026-1521-00077-00001-00000-APLKS   57
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Convert ASA print control characters to          */
/*          PC compatable print control characters.          */
/*                                                           */
/*  Format: ASA2PC                                           */
/*                                                           */
/*  Author: J. KALINICH, X4521                               */
/*          2015-09-11 local standardization by L Slaten     */
/* --------------------------------------------------------- */

/* Entering EXEC ASA2PC */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2) NOPROCESS";
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
   Else;
     Upper parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   "(dsn) = DATASET";

   /* Mainline */

   EC = Listdsi("'"dsn"'");
   If EC <> 0 Then;
     Signal Error_LISTDSI_FAILED;

   If Pos('A',sysrecfm) = 0 Then;
     Signal Error_NO_ASA;

   "CHANGE ALL '1' X'0C' 1";       /* SKIP TO NEW PAGE */
/* "CHANGE ALL ' ' X'..' 1"; */    /* SPACE 1 LINE  */
   "CHANGE ALL '0' X'0D25' 1";     /* SPACE 2 LINES */
   "CHANGE ALL '-' X'0D250D25' 1"; /* SPACE 3 LINES */
   "EXCLUDE ALL";
   "FIND ALL '+' 1";               /* SUPPRESS SPACE */
   "DELETE ALL NX";
   "RESET EXCLUDED";
   "BUILTIN SAVE";

   Return;

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_LISTDSI_FAILED:

   Say "LISTDSI failed with RC =" EC "CC =" sysreason;
   Return (-16);

   Error_NO_ASA:

   Say "No ASA print control characters";
   Return (4);

/* J. KALINICH, X4521 */
/* EDIT MACRO TO CONVERT ASA PRINTER CONTROL TO ASCII CODE */
./ ADD NAME=AVGLRECL 0122-16193-17149-1838-00330-00015-00000-APLKS   05
/* REXX 2017-05-29 */
/* Trace R; */
/* Entering EXEC AVGLRECL */
   Address TSO;
   'PROFILE NOPREFIX';

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Parse UPPER ARG parm2;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the LRECL statistics dsname:";
       Parse UPPER EXTERNAL parm2 .;
     End;

   /* variable definition */
   F.0 = 0; L.0 = 0; M.0 = 0;

   /* Parse User passed Parms */

   /* get the dsname that we want to analyze the data in */
   If parm2 <> "" Then;
     Parse VAR parm2 dsname .;
   Else;
     Signal Error_NODATA;

   dsname = Strip(dsname);
   x = Sysdsn(dsname);
   If x <> "OK" Then;
     Signal Error_INVALID_DSNAME;

   /* Point to LRECL statistics dsname to be processed */

   "ALLOC DSNAME("dsname") ",
              "DDNAME(LRECLDD) SHR REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_ALLOC;

   "EXECIO 0 DISKR LRECLDD ( OPEN ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_OPEN;

   i = 0;
   eof = "N";
   Do While eof = "N";
     "EXECIO 1 DISKR LRECLDD ";
     If RC = 0 Then;
       Do;
         Pull line;
         /* binary(1:2 lrecl);
            binary(2:4 0);
            binary(5:8 freq);
            binary(9:12 seqnbr)
            binary(13:20 0) */
         Parse UPPER VAR line lrecl 3 5 freq 9 seqnbr 13 .;
         i = i + 1;
         L.i = c2d(lrecl);
         F.i = c2d(freq);
       End;
     Else;
       Do;
         L.0 = i;
         F.0 = i;
         eof = "Y";
         "EXECIO 0 DISKR LRECLDD ( FINIS ";
       End;
   End;

   "CLEAR";
   Say "There are" i "unique record lengths";

Compute_MEAN:

   cnt = 0; sum = 0; mean = 0;
   If L.0 > 0 Then;
     Do;
       x = MEAN(L.0);
       cnt = Word(x,1);
       sum = Word(x,2);
     End;

   Say "Total bytes          =" sum;
   Say "Total records        =" cnt;
   If cnt > 0 Then;
     mean = Format((sum/cnt),,0);
   Say "Mean of LRECL vector =" mean;

Compute_MODE:

   freq = 0;
   If L.0 > 0 Then;
     freq = MODE(L.0);
   Say "Highest frequency of occurrences =" freq;

   If M.0 > 0 Then;
     Do i = 1 To M.0;
       Say "  Mode of LRECL vector =" M.i;
     End;

   i = L.0;
   If L.0 > 0 Then;
     Say "Range of values in LRECL vector = ("L.1":"L.i")";

Compute_VARIANCE:

   varsq = 0;
   cntlofmean = 0; cnteqmean = 0; cntrofmean = 0;
   If L.0 > 0 Then;
     Do;
       x = VARIANCE(L.0,mean,cnt);
       varsq = Word(x,1);        /*return variance squared*/
       cntlofmean = Word(x,2);   /*return items left of mean*/
       cnteqmean = Word(x,3);    /*return items eq to mean*/
       cntrofmean = Word(x,4);   /*return items right of mean*/
     End;

   Say "Variance squared =" varsq;
   Say "  Items < mean   =" cntlofmean;
   Say "  Items = mean   =" cnteqmean;
   Say "  Items > mean   =" cntrofmean;
   stddev = SQRT(varsq);
   Say "Std Deviation    =" Format(stddev,,0);
   Say "Range of average LRECL vector = (" ,
        || Format((mean-stddev),,0) || ":" ,
        || mean || ":" ,
        || Format((mean+stddev),,0) || ")";

   Return 0;

/* --------------------------- */
   MEAN: Procedure Expose L. F.

/* REXX function
   Invoke as: MEAN(occurs,nd)
   Determine the arithmetic mean/average of vector entries.

   where L.i = LRECL vector
         F.i = FREQuence of LRECL entry vector

   ------------------------------------------------------- */

   Parse ARG occurs,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   cnt = 0;
   sum = 0;
   Do i = 1 To occurs;
     cnt = cnt + F.i;
     sum = sum + (L.i * F.i);
   End;

   Return (cnt  sum);

/* --------------------------- */
   VARIANCE: Procedure Expose L. F.

/* REXX function
   Invoke as: VARIANCE(occurs,mean,nd)
   Determine the variance between each value in the vector.
   Sum of (((L.i-mean)**2)*F.i)

   where L.i = LRECL vector
         F.i = FREQuency of LRECL entry vector
   ------------------------------------------------------- */

   Parse ARG occurs,mean,cnt,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   leftofmean = 0;
   eqtomean = 0;
   rightofmean = 0;
   varsq = 0;

   Do i = 1 To occurs;
     dif = L.i - mean;
     If dif < 0 Then;
       leftofmean = leftofmean + F.i;
     If dif = 0 Then;
       eqtomean = eqtomean + F.i;
     If dif > 0 Then;
       rightofmean = rightofmean + F.i;
     varsq = varsq + (dif**2) * F.i;
   End;

   If cnt > 0 Then;
     varsq = varsq / cnt;

   Return (varsq leftofmean eqtomean rightofmean);

/* --------------------------- */
   MODE: Procedure Expose L. F. M.

/* REXX function
   Invoke as: MODE(occurs)
   Determine the most frequently occuring value(s) of a
   sorted vector.

   where L. = LRECL vector
         F. = FREQuency of LRECL entry vector
         M. = MODE vector (LRECL with the most occurrences)
   ------------------------------------------------------- */

   Parse ARG occurs;

   j = 1;           /*index of largest entry in FREQuency vector*/
   freq = F.j;      /*init freq with 1st entry in FREQuency vector*/

   Do i = 2 To occurs;
     If freq < F.i Then;
       Do;          /*tag 1st occurrence of largest frequency*/
         j = i;
         freq = F.i;
       End;
   End;

   k = 0;
   Do i = j To occurs;
     If F.i = freq Then;
       Do;          /*save LRECL in Mode vector*/
         k = k + 1;
         M.k = L.i;
       End;
   End;
   M.0 = k;

   Return (freq);

/* --------------------------- */
   SQRT: Procedure

/* REXX function
   Invoke as: SQRT(real);
   Compute the square root of a real number using Newton's
   formula New=0.5*(X+N/X), where X starts with a reasonable
   guess e.g. (1+N)/2.

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real,np;

   If Datatype(real,'N') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   If real = 0 Then;
     Return 0;

   If np = "" Then;
     np = 9;

   Numeric Digits np;

   Parse VALUE FORMAT(real,,,,0) With real "E" exp;

   If exp = "" Then;
     exp = 0;

   If (exp // 2) <> 0 Then;
     If exp > 0 Then;
       Do;
         real = real * 10;
         exp = exp - 1;
       End;
     Else;
       Do;
         real = real / 10;
         exp = exp + 1;
       End;

   x = 0.5 * (real + 1);

   Do Forever;
     NewX = 0.5 * (x + real / x);
     If x = NewX Then;
       Return X * 10 ** (exp % 2);
     x = NewX;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NODATA:

   Say "Missing dsname";
   Exit (-16);

   Error_INVALID_DSNAME:

   Say "INVALID DSNAME" dsname;
   Exit (-16);

   Error_DATASET_ALLOC:

   Say "TSO ALLOCation failed" dsname EC;
   Exit (-16);

   Error_DATASET_OPEN:

   Say "OPEN failed" dsname EC;
   Exit (-16);
./ ADD NAME=BKSZANAL 0107-17146-17150-1620-00347-00334-00000-APLKS   59
/* REXX 2017-05-29 */
   Address TSO;
   'PROFILE NOPREFIX';

/* Entering EXEC BKSZANAL */

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Parse UPPER ARG parm2;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the BKSZANAL statistics dsname:";
       Parse UPPER EXTERNAL parm2 .;
     End;

   /* variable definition */
   F.0 = 0; L.0 = 0; M.0 = 0;

   /* Parse User passed Parms */

   /* get the dsname that we want to analyze the data in */
   If parm2 <> "" Then;
     Parse VAR parm2 dsname .;
   Else;
     Signal Error_NODATA;

   dsname = Strip(dsname);
   x = Sysdsn(dsname);
   If x <> "OK" Then;
     Signal Error_INVALID_DSNAME;

   /* Point to BKSZANAL statistics dsname to be processed */

   "ALLOC DSNAME("dsname") ",
         "DDNAME(FANALDD) SHR REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_ALLOC;

   "EXECIO 0 DISKR FANALDD ( OPEN ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_OPEN;

   i = 0;
   eof = "N";
   Do While eof = "N";
     "EXECIO 1 DISKR FANALDD ";
     If RC = 0 Then;
       Do;
         Pull line;
         /* char(1:1 sr_type);     1=lrecl,2=block|CI
            char(2:1 sr_am);       Q=QSAM,V=VSAM
            char(3:1 sr_org);      K=KSDS
            char(4:1 sr_flag);     E=error
            binary(5:4 null);
            binary(9:4 sr_seq)     sequence nbr
            binary(13:4 sr_lgth)   length of record|block|CI
            binary(17:4 sr_cnt)    count of record(s)|block(s)|CI(s)
            binary(21:4 sr_rci)    relative CI nbr
            binary(25:8 sr_xrba)   xrba
         */
         Parse UPPER VAR line sr_type 2 sr_am 3 sr_org 4 sr_flag 5 ,
            9 sr_seq 13 sr_lgth 17 sr_cnt 21 sr_rci 25 .;
         If sr_flag = "E" Then;
           Iterate;
         Select;
           When sr_type = "2" Then;
             Do;
               i = i + 1;
               L.i = c2d(sr_lgth);
               F.i = c2d(sr_cnt);
             End;
           Otherwise;
             Iterate;
         End;
       End;
     Else;
       Do;
         L.0 = i;
         F.0 = i;
         eof = "Y";
         "EXECIO 0 DISKR FANALDD ( FINIS ";
       End;
   End;

/* "CLEAR"; */
   Say "There are" i "unique block|CI lengths";

Compute_MEAN:

   cnt = 0; sum = 0; mean = 0;
   If L.0 > 0 Then;
     Do;
       x = MEAN(L.0);
       cnt = Word(x,1);
       sum = Word(x,2);
     End;

   Say "Total bytes          =" sum;
   Say "Total block(s)|CI(s) =" cnt;
   If cnt > 0 Then;
     mean = Format((sum/cnt),,0);
   Say "Mean of BLKSZ|CISZ vector =" mean;

Compute_MODE:

   freq = 0;
   If L.0 > 0 Then;
     freq = MODE(L.0);
   Say "Highest frequency of occurrences =" freq;

   If M.0 > 0 Then;
     Do i = 1 To M.0;
       Say "  Mode of BLKSZ|CISZ vector =" M.i;
     End;

   i = L.0;
   If L.0 > 0 Then;
     Say "Range of values in BLKSZ|CISZ vector = ("L.1":"L.i")";

Compute_VARIANCE:

   varsq = 0;
   cntlofmean = 0; cnteqmean = 0; cntrofmean = 0;
   If L.0 > 0 Then;
     Do;
       x = VARIANCE(L.0,mean,cnt);
       varsq = Word(x,1);        /*return variance squared*/
       cntlofmean = Word(x,2);   /*return items left of mean*/
       cnteqmean = Word(x,3);    /*return items eq to mean*/
       cntrofmean = Word(x,4);   /*return items right of mean*/
     End;

   Say "Variance squared =" varsq;
   Say "  Items < mean   =" cntlofmean;
   Say "  Items = mean   =" cnteqmean;
   Say "  Items > mean   =" cntrofmean;

   stddev = SQRT(varsq);
   Say "Std Deviation    =" Format(stddev,,0);
   Say "Range of average BLKSZ|CISZ vector = (" ,
        || Format((mean-stddev),,0) || ":" ,
        || mean || ":" ,
        || Format((mean+stddev),,0) || ")";

   Return 0;

/* --------------------------- */
   MEAN: Procedure Expose L. F.

/* REXX function
   Invoke as: MEAN(occurs,nd)
   Determine the arithmetic mean/average of vector entries.

   where L.i = LRECL vector
         F.i = FREQuence of LRECL entry vector

   ------------------------------------------------------- */

   Parse ARG occurs,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   cnt = 0;
   sum = 0;
   Do i = 1 To occurs;
     cnt = cnt + F.i;
     sum = sum + (L.i * F.i);
   End;

   Return (cnt  sum);

/* --------------------------- */
   VARIANCE: Procedure Expose L. F.

/* REXX function
   Invoke as: VARIANCE(occurs,mean,nd)
   Determine the variance between each value in the vector.
   Sum of (((L.i-mean)**2)*F.i)

   where L.i = LRECL vector
         F.i = FREQuency of LRECL entry vector
   ------------------------------------------------------- */

   Parse ARG occurs,mean,cnt,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   leftofmean = 0;
   eqtomean = 0;
   rightofmean = 0;
   varsq = 0;

   Do i = 1 To occurs;
     dif = L.i - mean;
     If dif < 0 Then;
       leftofmean = leftofmean + F.i;
     If dif = 0 Then;
       eqtomean = eqtomean + F.i;
     If dif > 0 Then;
       rightofmean = rightofmean + F.i;
     varsq = varsq + (dif**2) * F.i;
   End;

   If cnt > 0 Then;
     varsq = varsq / cnt;

   Return (varsq leftofmean eqtomean rightofmean);

/* --------------------------- */
   MODE: Procedure Expose L. F. M.

/* REXX function
   Invoke as: MODE(occurs)
   Determine the most frequently occuring value(s) of a
   sorted vector.

   where L. = LRECL vector
         F. = FREQuency of LRECL entry vector
         M. = MODE vector (LRECL with the most occurrences)
   ------------------------------------------------------- */

   Parse ARG occurs;

   j = 1;           /*index of largest entry in FREQuency vector*/
   freq = F.j;      /*init freq with 1st entry in FREQuency vector*/

   Do i = 2 To occurs;
     If freq < F.i Then;
       Do;          /*tag 1st occurrence of largest frequency*/
         j = i;
         freq = F.i;
       End;
   End;

   k = 0;
   Do i = j To occurs;
     If F.i = freq Then;
       Do;          /*save LRECL in Mode vector*/
         k = k + 1;
         M.k = L.i;
       End;
   End;
   M.0 = k;

   Return (freq);

/* --------------------------- */
   SQRT: Procedure

/* REXX function
   Invoke as: SQRT(real);
   Compute the square root of a real number using Newton's
   formula New=0.5*(X+N/X), where X starts with a reasonable
   guess e.g. (1+N)/2.

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real,np;

   If Datatype(real,'N') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   If real = 0 Then;
     Return 0;

   If np = "" Then;
     np = 9;

   Numeric Digits np;

   Parse VALUE FORMAT(real,,,,0) With real "E" exp;

   If exp = "" Then;
     exp = 0;

   If (exp // 2) <> 0 Then;
     If exp > 0 Then;
       Do;
         real = real * 10;
         exp = exp - 1;
       End;
     Else;
       Do;
         real = real / 10;
         exp = exp + 1;
       End;

   x = 0.5 * (real + 1);

   Do Forever;
     NewX = 0.5 * (x + real / x);
     If x = NewX Then;
       Return X * 10 ** (exp % 2);
     x = NewX;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NODATA:

   Say "Missing dsname";
   Exit (-16);

   Error_INVALID_DSNAME:

   Say "INVALID DSNAME" dsname;
   Exit (-16);

   Error_DATASET_ALLOC:

   Say "TSO ALLOCation failed" dsname EC;
   Exit (-16);

   Error_DATASET_OPEN:

   Say "OPEN failed" dsname EC;
   Exit (-16);
./ ADD NAME=BLDIDC   0110-14130-15264-1349-01182-01176-00000-APLKS   19
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: VIEW/EDIT a LISTCAT and collect all of the       */
/*          appropriate data.  Build the IDCAMS control      */
/*          card deck (i.e. DELETE, DEFINE, etc.) using      */
/*          the model members found in userid.WORK.MODEL     */
/*          PDS.  Save the modified models in                */
/*          userid.WORK.IDCAMS(member) PDS.                  */
/*                                                           */
/*                                                           */
/*  Format: BLDIDC  member ( CANCEL &| DEFINE &| DEFPTH &|   */
/*                           DELETE &| IF &|                 */
/*                           LISTCAT &| PRINT &|             */
/*                           REPRO &| SET &|                 */
/*                           VERIFY                          */
/*                                                           */
/* --------------------------------------------------------- */
/* Address ISPEXEC "CONTROL NONDISPL END ERRORS RETURN"; */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC BLDIDC */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO (parm2)";
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
   Else;
     Upper parm2;
   If parm2 = "?" | parm2 = "HELP" Then;
     Signal Error_EXEC_HELP;

   /* Initialize Variables */
   opt. = "";
   vlc. = "";                      /*VSAM LISTCAT variables*/
   section = "";                   /*VSAM LISTCAT section name*/
   subsection = "";                /*VSAM LISTCAT sub-section name*/
   dvolcnt = 0;
   ivolcnt = 0;
   fshlq = Userid();
   lshlq = Userid();

   tgtpds_dsname = lshlq|| ".WORK.IDCAMS";   /*IDCAMS ctl cards*/
   srcpds_dsname = lshlq|| ".WORK.MODEL";    /*model ctl stmts*/
   xeqpds_dsname = lshlq|| ".WORK.REXXLIB";  /*REXX library*/
   xeqpds_member = "##IDC01"; /*REXX EDIT MACRO for IDCAMS*/

   EC = 0;

   "(linenbr) = LINENUM .ZLAST";
   trgt_row_eof = linenbr;

   /* Parse the User Options */

   Parse VAR parm2 parm2 "(" parm3;
   If parm3 <> "" Then;
     Call Extract_Options;
   Else;
     Do;
       opt.0 = 1;
       opt.1 = "MVDEFINE";
     End;

   /* Parse User Passed Parms */

   Parse VAR parm2 tgtpds_member "(" . ;
   tgtpds_member = Strip(tgtpds_member,"T");
   If tgtpds_member = "" Then;
     Signal Error_NO_MEMBER;

   /* Mainline */

   /* Collect all of the LISTCAT data needed */
   Do i=1 to trgt_row_eof by 1;
     "(xstatus) = XSTATUS" i;
     If RC >= +12 Then;
       Leave;
     If xstatus = "X" Then;
       Iterate i;
     "(row) = LINE" i;
     string = Word(row,1);
     Select;
       When string = "AIX" Then;
         Do;
           vlc.defcmd = string;    /*save IDCAMS DEFINE command*/
           section = string;       /*save LISTCAT section name*/
           subsection = "";
           vlc.xentryname = Word(row,3);
         End;
       When string = "CLUSTER" Then;
         Do;
           vlc.defcmd = string;    /*save IDCAMS DEFINE command*/
           section = string;       /*save LISTCAT section name*/
           subsection = "";
           vlc.centryname = Word(row,3);
         End;
       When string = "GDG" Then;
         Do;
           vlc.defcmd = string;    /*save IDCAMS DEFINE command*/
           section = string;       /*save LISTCAT section name*/
           subsection = "";
           vlc.gentryname = Word(row,4);
         End;
       When string = "PATH" Then;
         Do;
           section = string;       /*save LISTCAT section name*/
           subsection = "";
           vlc.pentryname = Word(row,3);
         End;
       When string = "DATA" Then;
         Do;
           section = string;       /*save LISTCAT section name*/
           subsection = "";
           vlc.dentryname = Word(row,3);
         End;
       When string = "INDEX" Then;
         Do;
           section = string;       /*save LISTCAT section name*/
           subsection = "";
           vlc.ientryname = Word(row,3);
         End;
       When string = "IN-CAT" Then;
         If section = "AIX" | section = "CLUSTER" ,
              | section = "PATH" | section = "GDG" Then;
           vlc.catnamelist = Word(row,3);
       When string = "STORAGECLASS" Then;
         If section = "CLUSTER" Then;
           /*will be (NULL) or a valid class*/
           Do;
             vlc.stgcls = Strip(Word(row,2),"L","-");
             vlc.mgtcls = Strip(Right(Word(row,3),8),"L","-");
           End;
       When string = "DATACLASS" Then;
         If section = "CLUSTER" Then;
           /*will be (NULL) or a valid class*/
           vlc.dtacls = Strip(Word(row,2),"L","-");
       When string = "VSAM" Then;
         If section = "CLUSTER" Then;
           /*RLS/NONRLS*/
           Do;
             vlc.kwattr15 =  Strip(Strip(Strip(Word(row,7), ,
                  "L","-"),"L","("),"T",")");
             If vlc.kwattr15 = "YES" Then;
               vlc.kwattr15 = "RLS";
             Else;
               vlc.kwattr15 = "NONRLS";
           End;
       When Strip(Left(string,8),"T","-") = "CLUSTER" Then;
         If section = "AIX" Then;
           vlc.centryname = Substr(string,10);
       When string = "ATTRIBUTES" | string = "STATISTICS" |,
            string = "ALLOCATION" | string = "VOLUME" Then;
         Do;
           subsection = string;    /*save LISTCAT sub-section*/
           linecnt = i;
           j = 0;
         End;
       When subsection = "ATTRIBUTES" Then;
         Select;
           When section = "AIX" Then;
             If (i - linecnt) = +1 Then;
               vlc.kwattr11 = Word(row,1);  /*UPGRADE/NOUPGRADE*/
           When section = "PATH" Then;
             If (i - linecnt) = +1 Then;
               vlc.kwattr13 = Word(row,1);  /*UPDATE/NOUPDATE*/
           When section = "GDG" Then;
             If (i - linecnt) = +1 Then;
               Do;
                 vlc.glimit = Strip(Right(Word(row,1),3),"L","-");
                 vlc.kwattrA = Word(row,2); /*SCRATCH/NOSCRATCH*/
                 vlc.kwattrB = Word(row,3); /*EMPTY/NOEMPTY)*/
               End;
           When section = "DATA" Then;
             Select;
               When (i - linecnt ) = +1 Then;
                 Do;
                   vlc.drecszavg = Strip(Right(Word(row,2),6),"L","-");
                   vlc.cbufsp = Strip(Right(Word(row,3),7),"L","-");
                   vlc.dcisz = Strip(Right(Word(row,4),6),"L","-");
                 End;
               When (i - linecnt) = +2 Then;
                 Do;
                   vlc.drecszmax = Strip(Right(Word(row,2),6),"L","-");
                   vlc.dciperca = Strip(Right(Word(row,4),4),"L","-");
                 End;
               When (i - linecnt) = (j + 3) Then;
                 Select;
                   When Substr(Word(row,1),1,6) = "STRIPE" Then;
                     /*when SMS Extended Format*/
                     j = 1;
                   When Substr(Word(row,1),1,13) = "ACT-DIC-TOKEN" Then;
                     /*when SMS Extended Format, Compressed*/
                     j = j + 1;
                   When Substr(Word(row,1),1,5) = "AXRKP" Then;
                     /*when AIX*/
                     Do;
                       vlc.xkeyoff = Strip(Right(Word(row,1),4),"L","-");
                       j = 1;
                     End;
                   Otherwise;
                     Do k = 1 To 8 By 1;
                       text = Substr(Word(row,k),1,5);
                       If text = "" Then;
                         Leave k;
                       Select;
                         When text = "SHROP" Then;
                           Do;
                             vlc.cshroptreg = Substr(Word(row,k),10,1);
                             vlc.cshroptsys = Substr(Word(row,k),12,1);
                           End;
                         When text = "SPEED" | ,
                              text = "RECOV" Then;
                           vlc.kwattr1 = Word(row,k);  /*SPEED/RECOVERY*/
                         When text = "UNIQU" | ,
                              text = "SUBAL" Then;
                           vlc.kwattr2 = Word(row,k);  /*UNIQUE/SUBALLOCATION
                                                         ICF CATLG = UNIQUE*/
                         When text = "ERASE" | ,
                              text = "NOERA" Then;
                           vlc.kwattr3 = Word(row,k);  /*ERASE/NOERASE*/
                         When text = "INDEX" | ,
                              text = "LINEA" | ,
                              text = "NONIN" | ,
                              text = "NUMBE" Then;
                           vlc.kwattr4 = Word(row,k);  /*INDEXED/LINEAR/
                                                         NONINDEXED/NUMBERED*/
                         When text = "WRITE" | ,
                              text = "NOWRI" Then;
                           vlc.kwattr5 = Word(row,k);  /*WRITECHECK/NOWRITECHK*/
                         When text = "ORDER" | ,
                              text = "UNORD" Then;
                           vlc.kwattr6 = Word(row,k);  /*ORDERED/UNORDERED*/
                         When text = "REUSE" | ,
                              text = "NOREU" Then;
                           vlc.kwattr7 = Word(row,k);  /*REUSE/NOREUSE*/
                         Otherwise;
                           Nop;
                       End;
                     End;
                 End;
               When (i - linecnt) = (j + 4) Then;
                 /*LISTCAT keyword ATTRIBUTES continued*/
                 Do k = 1 To 8 By 1;
                   text = Substr(Word(row,k),1,5);
                   If text = "" Then;
                     Leave k;
                   Select;
                     When text = "ORDER" | ,
                          text = "UNORD" Then;
                       vlc.kwattr6 = Word(row,k);  /*ORDERED/UNORDERED*/
                     When text = "REUSE" | ,
                          text = "NOREU" Then;
                       vlc.kwattr7 = Word(row,k);  /*REUSE/NOREUSE*/
                     When text = "SPANN" | ,
                          text = "NONSP" Then;
                       vlc.kwattr8 = Word(row,k);  /*SPANNED/NONSPANNED*/
                     When text = "EXTEN" Then;
                       vlc.kwattr9 = Word(row,k);  /*EXTENDED*/
                     When text = "EXT-A" Then;
                       vlc.kwattr10 = Word(row,k); /*EXT-ADDR*/
                     When text = "UNIQU" | ,
                          text = "NONUN" Then;
                       vlc.kwattr12 = Word(row,k); /*UNIQUEKEY/NONUNIQUEKEY*/
                     When text = "COMP-" Then;
                       vlc.kwattr14 = Word(row,k); /*COMP-FORMT*/
                     Otherwise;
                       Nop;
                   End;
                 End;
               Otherwise;
                 Nop;
             End;
           When section = "INDEX" Then;
             Select;
               When (i - linecnt) = +1 Then;
                 Do;
                   vlc.ikeylen = Strip(Right(Word(row,1),3),"L","-");
                   vlc.icisz = Strip(Right(Word(row,4),6),"L","-");
                 End;
               When (i - linecnt) = +2 Then;
                 Do;
                   vlc.ikeyoff = Strip(Right(Word(row,1),4),"L","-");
                   vlc.irecszmax = Strip(Right(Word(row,2),6),"L","-");
                   vlc.iciperca = Strip(Right(Word(row,4),4),"L","-");
                 End;
               Otherwise;
                 Nop;
             End;
           Otherwise;
             Nop;
         End;
       When subsection = "STATISTICS" Then;
         Select;
           When section = "DATA" Then;
             Select;
               When (i - linecnt) = +3 Then;
                 vlc.dcifspc = Strip(Right(Word(row,2),3),"L","-");
               When (i - linecnt) = +4 Then;
                 vlc.dcafspc = Strip(Right(Word(row,2),3),"L","-");
               Otherwise;
                 Nop;
             End;
           When section = "INDEX" Then;
             Select;
               When (i - linecnt) = +2 Then;
                 vlc.ilvls = Strip(Right(Word(row,4),1),"L","-");
               When (i - linecnt) = +3 Then;
                 vlc.intrypersect = Strip(Right(Word(row,4),3),"L","-");
               Otherwise;
                 Nop;
             End;
           Otherwise;
             Nop;
         End;
       When subsection = "ALLOCATION" Then;
         Select;
           When section = "DATA" Then;
             Select;
               When (i - linecnt) = +1 Then;
                 vlc.dspace = Strip(Right(Word(row,1),8),"L","-");
               When (i - linecnt) = +2 Then;
                 Do;
                   vlc.dspcpri = Strip(Right(Word(row,1),9),"L","-");
                   vlc.dhurba = Strip(Right(Word(row,2),12),"L","-");
                 End;
               When (i - linecnt) = +3 Then;
                 vlc.dspcsec = Strip(Right(Word(row,1),9),"L","-");
               Otherwise;
                 Nop;
             End;
           When section = "INDEX" Then;
             Select;
               When (i - linecnt) = +1 Then;
                 vlc.ispace = Strip(Right(Word(row,1),8),"L","-");
               When (i - linecnt) = +2 Then;
                 Do;
                   vlc.ispcpri = Strip(Right(Word(row,1),9),"L","-");
                   vlc.ihurba = Strip(Right(Word(row,2),12),"L","-");
                 End;
               When (i - linecnt) = +3 Then;
                 vlc.ispcsec = Strip(Right(Word(row,1),9),"L","-");
               Otherwise;
                 Nop;
             End;
           Otherwise;
             Nop;
         End;
       When subsection = "VOLUME" Then;
         Select;
           When section = "DATA" Then;
             Select;
               When (i - linecnt) = +1 Then;
                 Do;
                   dvolcnt = dvolcnt + 1;
                   vlc.dvol.dvolcnt = ,
                        Strip(Right(Word(row,1),6),"L","-");
                   vlc.dvollist = vlc.dvollist ||,
                        vlc.dvol.dvolcnt,
                        || " ";
                   vlc.dphyrecsz.dvolcnt = ,
                        Strip(Right(Word(row,2),6),"L","-");
                 End;
               When (i - linecnt) = +2 Then;
                 vlc.dphyrecpertrk.dvolcnt = ,
                      Strip(Right(Word(row,2),6),"L","-");
               When (i - linecnt) = +3 Then;
                 vlc.dtrkperca.dvolcnt = ,
                      Strip(Right(Word(row,2),3),"L","-");
               When (i - linecnt) > +3 Then;
                 subsection = "";
               Otherwise;
                 Nop;
             End;
           When section = "INDEX" Then;
             Select;
               When (i - linecnt) = +1 Then;
                 Do;
                   ivolcnt = ivolcnt + 1;
                   vlc.ivol.ivolcnt = ,
                        Strip(Right(Word(row,1),6),"L","-");
                   vlc.ivollist = vlc.ivollist ||,
                        vlc.ivol.ivolcnt,
                        || " ";
                   vlc.iphyrecsz.ivolcnt = ,
                        Strip(Right(Word(row,2),6),"L","-");
                 End;
               When (i - linecnt) = +2 Then;
                 Do;
                   vlc.iphyrecpertrk.ivolcnt = ,
                        Strip(Right(Word(row,2),6),"L","-");
                   If Substr(Strip(Right(Word(row,4),6),"L","-"),3,2),
                        = "00" Then;
                     /*extent type = index set*/
                     vlc.ishurba.ivolcnt = ,
                          Strip(Right(Word(row,3),12),"L","-");
                 End;
               When (i - linecnt) = +3 Then;
                 vlc.itrkperca.ivolcnt = ,
                      Strip(Right(Word(row,2),3),"L","-");
               When (i - linecnt) > +3 Then;
                 subsection = "";
               Otherwise;
                 Nop;
             End;
           Otherwise;
             Nop;
         End;
       Otherwise;
         Nop;
     End;
   End;

   /* combine fields into a list */

   vlc.cshrlist = vlc.cshroptreg || " " || vlc.cshroptsys;
   vlc.dspclist = vlc.dspcpri || " " || vlc.dspcsec;
   vlc.dfspclist = vlc.dcifspc || " " || vlc.dcafspc;
   vlc.drecszlist = vlc.drecszavg || " " || vlc.drecszmax;
   If vlc.kwattr4 = "INDEXED" Then;
     /*when VSAM KSDS*/
     Do;
       vlc.ispclist = vlc.ispcpri || " " || vlc.ispcsec;
       vlc.ikeylist = vlc.ikeylen || " " || vlc.ikeyoff;
       vlc.cmdcont = "-";
       If vlc.ishurba.1 = "" Then;
         vlc.ishurba.1 = 0;
     End;
   Else;
     vlc.cmdcont = " ";

   /* clean up some fields */

   vlc.dvollist = Strip(vlc.dvollist,"T"," ");
   vlc.ivollist = Strip(vlc.ivollist,"T"," ");

   /* compute some values */

   Signal on NOVALUE Name No_More_Computations;
   Signal on SYNTAX Name No_More_Computations;

   bufsp = vlc.dcisz * 2;
   If vlc.kwattr4 = "INDEXED" Then;
     bufsp = bufsp + vlc.icisz;
   If bufsp >= vlc.cbufsp Then;
     /*comment out BUFFERSPACE in define*/
     vlc.cbufsp_flag = "Y";

   If vlc.kwattr14 = "COMP-FORMT" Then;
     ci_ovrhead = 10;
   Else;
     ci_ovrhead = 7;

   rec_ovrhead = 0;
   If vlc.drecszavg < vlc.drecszmax Then;
     rec_ovrhead = 3;
   Else;
     ci_ovrhead = ci_ovrhead + 3;

   recperci = (vlc.dcisz - ci_ovrhead) ,
        % (vlc.drecszavg + rec_ovrhead);

   /*compute DASD space utilization using LISTCAT FREESPACE*/
   vlc.spcutil = ((100 - vlc.dcifspc) ,
        * (100 - vlc.dcafspc)) % 100;

   /*compute FREESPACE recs/CI & CI/CA*/
   vlc.fspcrecperci = ,
        Strip(Format(((vlc.dcifspc * recperci) % 100),2,0),"L");
   vlc.fspcciperca = ,
        Strip(Format(((vlc.dcafspc * vlc.dciperca) % 100),2,0),"L");

   /*reserve nbr rec per ci / 10*/
   dta_reserveperci = recperci % 10;

   /*reserve nbr of ci per ca / nbr of trks per ca*/
   dta_reserveperca = vlc.dciperca % vlc.dtrkperca.1;

   /*compute optional FREESPACE*/
   dta_cifspc = (dta_reserveperci * 100) ,
        % ((vlc.dcisz - ci_ovrhead) ,
        % (vlc.drecszavg + rec_ovrhead));
   dta_cafspc = (dta_reserveperca * 100) ,
        % vlc.dciperca;
   dta_fspclist = dta_cifspc || " " || dta_cafspc;

   /*compute DASD space utilization using optional FREESPACE*/
   dta_spcutil = ((100 - dta_cifspc) ,
        * (100 - dta_cafspc)) % 100;

   If vlc.kwattr4 = "INDEXED" Then;
     /*when VSAM KSDS*/
     Do;
       /*compute nbr of index records in the index set*/
       idx_isetcnt = (vlc.ishurba.1 / vlc.icisz) ,
            - (vlc.dhurba / (vlc.dcisz * vlc.dciperca));
       If idx_isetcnt < 0 Then;
         idx_isetcnt = 0;
       /*compute nbr of index records in the seq set (SSI)*/
       idx_issicnt = (vlc.ihurba / vlc.icisz) - idx_isetcnt;
       /*compute minimal cisz*/
       idx_mincisz = (((vlc.ikeylen % 3) + 3) * vlc.dciperca) ,
            + (vlc.ilvls * 2) + 7;
       count = Strip((idx_mincisz % 512),"L");
       If count < 1 Then;
         count = 1;
       Else;
         If (idx_mincisz // 512) > 0 Then;
           count = count + 1;
       idx_mincisz = 512 * count;
     End;

   No_More_Computations:

   /* Ensure Target PDS exists - userid.WORK.IDCAMS() */

   Call Validate_DSNAME tgtpds_dsname;
   If EC >= 16 Then;
     If CC < 0 Then;
       If SYSREASON = 5 Then;
         /*dataset not found*/
         Do;
           If BPXWDYN("ALLOC DSNAME("tgtpds_dsname") ",
                "UNIT(3390) DSORG(PO) RECFM(F B) ",
                "DSNTYPE(LIBRARY) LRECL(80) BLKSIZE(6320) ",
                "SPACE(5,1) CYLINDERS ",
                "NEW CATALOG ") <> 0 Then;
             Signal Error_TGT_ALLOC;
         End;
       Else;
         Signal Error_INVALID_DSNAME;
     Else;
       Signal Error_INVALID_DSNAME;

   /* Determine if Source/Model PDS exists - userid.WORK.DATA() */

   Call Validate_DSNAME srcpds_dsname;
   If EC >= 16 Then;
     Signal Error_INVALID_DSNAME;

   /* Setup Target/Output Dataset */

   tgtdsn = tgtpds_dsname;
   Address ISPEXEC "LMINIT DATAID("tgtid") ",
        "DATASET("tgtdsn") ",
        "ENQ(EXCLU) ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_TGT_DATASET;
     End;

   Address ISPEXEC "LMOPEN DATAID("tgtid") ",
        "OPTION(OUTPUT) ",
        "LRECL("tgtlrecl") ",
        "RECFM("tgtrecfm") ",
        "ORG("tgtorg") ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_TGT_OPEN;
     End;

   If tgtrecfm <> "FB" Then;
     Signal Error_TGT_RECFM;
   If tgtlrecl <> 80 Then;
     Signal Error_TGT_LRECL;

   /* Delete existing Target PDS member */

   tgtmbr = tgtpds_member;
   Address ISPEXEC "LMMDEL DATAID("tgtid") ",
        "MEMBER("tgtmbr") ";
   If RC > 8 Then;
     Do;
       EC = RC;
       Signal Error_TGT_MDEL;
     End;

   Address ISPEXEC "LMCLOSE DATAID("tgtid") ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_TGT_CLOSE;
     End;

   /* Build the REXX ISREDIT MACRO */

   Call Build_Edit_MACRO;

   /* Apply all of the changes to the Target PDS */

   tgtmbr = tgtpds_member;
   xeqmbr = xeqpds_member;
   Address ISPEXEC "EDIT DATAID("tgtid") ",
        "MEMBER("tgtmbr") MACRO("xeqmbr") ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_TGT_EDIT;
     End;

   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_TGT_FREE;
     End;

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   Validate_DSNAME: Procedure Expose EC CC SYSREASON;

   /* Test dsname for validity */
   Arg dsname;
   CC = 0;
   arg_string = "'"dsname"' NORECALL NOSMSINFO";
   EC = Listdsi(arg_string);
   If EC >= 16 Then;
     Do;
       If SYSREASON = 3  | SYSREASON = 5  | SYSREASON = 24 Then;
         CC = -12;
       Else;
         CC = -24;
     End;
   Else;
     If SYSREASON = 0 Then;
       If SYSDSORG = "PO" | SYSDSORG = "POU" Then;
         Nop;
       Else;
         Do;
           EC = 16;
           CC = -12;
         End;

   Return (0);

   Extract_Options:

   n = 0;
   opt.0 = n;
   parm3 = Strip(parm3,"T",")");
   Do While parm3 <> "";
     Parse VAR parm3 var.3 parm3;
     Select;
       When Abbrev("CANCEL",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVCANCEL";
         End;
       When Abbrev("DEFINE",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVDEFINE";
         End;
       When Abbrev("DEFPTH",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVDEFPTH";
         End;
       When Abbrev("DELETE",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVDELETE";
         End;
       When Abbrev("IF",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVIF";
         End;
       When Abbrev("LISTCAT",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVLISTCA";
         End;
       When Abbrev("PRINT",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVPRINT";
         End;
       When Abbrev("REPRO",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVREPRO";
         End;
       When Abbrev("SET",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVSET";
         End;
       When Abbrev("VERIFY",var.3) Then;
         Do;
           n = n + 1;
           opt.0 = n;
           opt.n = "MVVERIFY";
         End;
       Otherwise;
         Nop;
     End;
   End;

   Return (0);

   Build_Edit_MACRO:

   /* Setup REXX Dataset */

   xeqdsn = xeqpds_dsname;
   Address ISPEXEC "LMINIT DATAID("xeqid") ",
        "DATASET("xeqdsn") ",
        "ENQ(EXCLU) ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_XEQ_DATASET;
     End;

   Address ISPEXEC "LMOPEN DATAID("xeqid") ",
        "OPTION(OUTPUT) ",
        "LRECL("xeqlrecl") ",
        "RECFM("xeqrecfm") ",
        "ORG("xeqorg") ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_XEQ_OPEN;
     End;

   If xeqrecfm <> "FB" Then;
     Signal Error_XEQ_RECFM;
   If xeqlrecl <> 80 Then;
     Signal Error_XEQ_LRECL;
   If xeqorg <> "PO" Then;
     Signal Error_XEQ_DSORG;

   /* Delete existing REXX PDS member */

   xeqmbr = xeqpds_member;
   Address ISPEXEC "LMMDEL DATAID("xeqid") ",
        "MEMBER("xeqmbr") ";
   If RC > 8 Then;
     Do;
       EC = RC;
       Signal Error_XEQ_MDEL;
     End;

   Address ISPEXEC "LMCLOSE DATAID("xeqid") ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_XEQ_CLOSE;
     End;

   Address ISPEXEC "LMFREE DATAID("xeqid") ";
   If RC <> 0 Then;
     Do;
       EC = RC;
       Signal Error_XEQ_FREE;
     End;

   /* Build the REXX ISREDIT MACRO */

   Queue "/* REXX */ ";
   Queue "     Address ISPEXEC 'CONTROL NONDISPL END ERRORS RETURN'; ";
   Queue "     Address ISREDIT; ";
   Queue "     'MACRO NOPROCESS';";
   Queue "     /*Copy all of the Source PDS members selected ";
   Queue "       (IDCAMS model stmts) to the Target PDS */ ";
   Do i=1 To opt.0 By +1;
     If opt.i = "MVDEFINE" Then;
       Select;
         When vlc.defcmd = "AIX" Then;
           opt.i = "MVDEFAIX";
         When vlc.defcmd = "CLUSTER" Then;
           opt.i = "MVDEFCLU";
         When vlc.defcmd = "PATH" Then;
           opt.i = "MVDEFPTH";
         When vlc.defcmd = "GDG" Then;
           opt.i = "MVDEFGDG";
       End;
     Queue "     COPY '"srcpds_dsname"("opt.i")' AFTER .ZLAST; ";
   End;
   /*Change AIX/CLUSTER/PATH/GDG variables*/
   Queue "     C '$xentryname' '"vlc.xentryname"' ALL; ";
   Queue "     C '$centryname' '"vlc.centryname"' ALL; ";
   Queue "     C '$pentryname' '"vlc.pentryname"' ALL; ";
   Queue "     C '$gentryname' '"vlc.gentryname"' ALL; ";
   If vlc.cbufsp_flag = "Y" Then;
     /*delete BUFFERSPACE()*/
     Queue "     EXCLUDE 'BUFFERSPACE' ALL; ";
   Else;
     Queue "     C '#cbufsp' '"vlc.cbufsp"' ALL; ";
   Queue "     C '$kwattr1' '"vlc.kwattr1"' WORD ALL; ";
   Queue "     C '$kwattr4' '"vlc.kwattr4"' WORD ALL; ";
   Queue "     C '$kwattr7' '"vlc.kwattr7"' WORD ALL; ";
   str = "    C '#cshrlist' '"vlc.cshrlist"' ALL ";
   Queue '"'str'";';
   Queue "     C '#cshrreg' '"vlc.cshroptreg"' ALL; ";
   Queue "     C '#cshrsys' '"vlc.cshroptsys"' ALL; ";
   Queue "     C '$kwattr11' '"vlc.kwattr11"' WORD ALL; ";
   Queue "     C '$kwattr13' '"vlc.kwattr13"' WORD ALL; ";
   Queue "     C '$kwattrA' '"vlc.kwattrA"' WORD ALL; ";
   Queue "     C '$kwattrB' '"vlc.kwattrB"' WORD ALL; ";
   Queue "     C '#glimit' '"vlc.glimit"' ALL; ";
   If vlc.stgcls = "(NULL)" Then;
     /*delete STORAGECLASS()*/
     Queue "     EXCLUDE 'STORAGECLASS' ALL; ";
   Else;
     Queue "     C '$stgcls' '"vlc.stgcls"' ALL; ";
   If vlc.mgtcls = "(NULL)" Then;
     /*delete MANAGEMENTCLASS()*/
     Queue "     EXCLUDE 'MANAGEMENTCLASS' ALL; ";
   Else;
     Queue "     C '$mgtcls' '"vlc.mgtcls"' ALL; ";
   If vlc.dtacls = "(NULL)" Then;
     Do;
       /*delete DATACLASS()*/
       Queue "     EXCLUDE 'DATACLASS' ALL; ";
       Queue "     EXCLUDE '$smscomp' ALL; ";
     End;
   Else;
     Do;
       Queue "     C '$dtacls' '"vlc.dtacls"' ALL; ";
       str = "    C '$smsrls' '"vlc.kwattr15"' WORD ALL ";
       Queue '"'str'";';
       str = "    C '$smsxattr' '"vlc.kwattr9"' WORD ALL ";
       Queue '"'str'";';
       str = "    C '$smsxaddr' '"vlc.kwattr10"' WORD ALL ";
       Queue '"'str'";';
       str = "    C '$smscomp' '"vlc.kwattr14"' WORD ALL ";
       Queue '"'str'";';
     End;

   /*Change DATA variables*/
   Queue "     C '$dentryname' '"vlc.dentryname"' ALL; ";
   Queue "     C '#dcisz' '"vlc.dcisz"' ALL; ";
   Queue "     C '$dspace' '"vlc.dspace"' ALL; ";
   str = "    C '#dspclist' '"vlc.dspclist"' ALL ";
   Queue '"'str'";';
   Queue "     C '#dspcpri' '"vlc.dspcpri"' ALL; ";
   Queue "     C '#dspcsec' '"vlc.dspcsec"' ALL; ";
   If vlc.kwattr4 = "INDEXED" Then;
     Do;
       str = "    C '#dfspclist' '"vlc.dfspclist"' ALL ";
       Queue '"'str'";';
       Queue "     C '#dcifspc' '"vlc.dcifspc"' ALL; ";
       Queue "     C '#dcafspc' '"vlc.dcafspc"' ALL; ";
       Queue "     C '#fspcrecperci' '"vlc.fspcrecperci"' ALL; ";
       Queue "     C '#fspcciperca' '"vlc.fspcciperca"' ALL; ";
       Queue "     C '#spcutil' '"vlc.spcutil"' ALL; ";
       str = "    C '#optdfspclist' '"dta_fspclist"' ALL ";
       Queue '"'str'";';
       Queue "     C '#optdcifspc' '"dta_cifspc"' ALL; ";
       Queue "     C '#optdcafspc' '"dta_cafspc"' ALL; ";
       Queue "     C '#optresperci' '"dta_reserveperci"' ALL; ";
       Queue "     C '#optresperca' '"dta_reserveperca"' ALL; ";
       Queue "     C '#optdspcutil' '"dta_spcutil"' ALL; ";
     End;
   Else;
     Do;
       Queue "     EXCLUDE 'FREESPACE' ALL; ";
       Queue "     EXCLUDE '#fspc' ALL; ";
       Queue "     EXCLUDE '#spcutil' ALL; ";
       Queue "     EXCLUDE '#opt' ALL; ";
     End;
   str = "    C '#drecszlist' '"vlc.drecszlist"' ALL ";
   Queue '"'str'";';
   Queue "     C '#drecszavg' '"vlc.drecszavg"' ALL; ";
   Queue "     C '#drecszmax' '"vlc.drecszmax"' ALL; ";
   Queue "     C '$kwattr8' '"vlc.kwattr8"' WORD ALL; ";
   Queue "     C '$kwattr12' '"vlc.kwattr12"' WORD ALL; ";
   str = "    C '$dvollist' '"vlc.dvollist"' ALL ";
   Queue '"'str'";';
   str = "    C '$cmdcont' '"vlc.cmdcont"' WORD ALL ";
   Queue '"'str'";';

   /*Change INDEX variables*/
   If vlc.kwattr4 = "INDEXED" Then;
     Do;
       Queue "     C '$ientryname' '"vlc.ientryname"' ALL; ";
       Queue "     C '#isetcnt' '"idx_isetcnt"' ALL; ";
       Queue "     C '#issicnt' '"idx_issicnt"' ALL; ";
       Queue "     C '#icisz' '"vlc.icisz"' ALL; ";
       Queue "     C '#imincisz' '"idx_mincisz"' ALL; ";
       Queue "     C '$ispace' '"vlc.ispace"' ALL; ";
       str = "    C '#ispclist' '"vlc.ispclist"' ALL ";
       Queue '"'str'";';
       Queue "     C '#ispcpri' '"vlc.ispcpri"' ALL; ";
       Queue "     C '#ispcsec' '"vlc.ispcsec"' ALL; ";
       str = "    C '#ikeylist' '"vlc.ikeylist"' ALL ";
       Queue '"'str'";';
       Queue "     C '#ikeylen' '"vlc.ikeylen"' ALL; ";
       Queue "     C '#ikeyoff' '"vlc.ikeyoff"' ALL; ";
       Queue "     C '#xkeyoff' '"vlc.xkeyoff"' ALL; ";
       str = "    C '$ivollist' '"vlc.ivollist"' ALL ";
       Queue '"'str'";';
     End;
   Else;
     Do;
       /*delete whole INDEX section*/
       Queue "     SEEK 'INDEX' FIRST WORD NX; ";
       Queue "     If RC = 0 Then; ";
       Queue "       Do; ";
       Queue "         '(irow,icol) = CURSOR'; ";
       Queue "         'LABEL '"irow"' = .PTA 0'; ";
       Queue "       End; ";
       Queue "     SEEK 'VOLUMES' NEXT NX; ";
       Queue "     If RC = 0 Then; ";
       Queue "       Do; ";
       Queue "         '(irow,icol) = CURSOR'; ";
       Queue "         'LABEL '"irow"+1' = .PTB 0'; ";
       Queue "         EXCLUDE .PTA .PTB ALL; ";
       Queue "       End; ";
     End;

   Queue "     C '$catnamelist' '"vlc.catnamelist"' ALL; ";
   Queue "     DELETE ALL X; ";
   Queue "     RESET LABEL; ";
   Queue "     BUILTIN SAVE; ";
   Queue "     CANCEL; ";
   Queue "     Return (0); ";

   Address TSO "ALLOC DD(OUTDD) ",
               "DSN('"xeqpds_dsname"("xeqpds_member")') ",
               "SHR REUSE";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_XEQ_DATASET;

   Address MVS 'EXECIO * DISKW OUTDD ( FINIS ';
   If RC <> 0 Then;
     Signal Error_XEQ_MADD;

   Address TSO "FREE DD(OUTDD)";

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: VIEW/EDIT a LISTCAT and build an IDCAMS",
        pad hex04,
        "        control card deck",
        pad hex04,
        "Format: BLDIDC member ( DEFCLU ...";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_SYNTAX:

   Say "REXX error " RC " in line " SIGL ":" Errortext(rc);
   Say Sourceline(SIGL);
   Exit (RC);

   Error_INVALID_DSNAME:

   ZEDSMSG = "Invalid DSNAME";
   ZEDLMSG = "Invalid dataset name: " dsname " CC = " CC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_NO_MEMBER:

   ZEDSMSG = "Missing MEMBER";
   ZEDLMSG = "Missing member name: " tgtpds_member;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_ALLOC:

   ZEDSMSG = "ALLOC FAILED";
   ZEDLMSG = "Target dataset " tgtpds_dsname " ALLOC failed, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_DATASET:

/* Address ISPEXEC " SETMSG  MSG(ISRZ002)"; */
   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset " tgtdsn " not found, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Target dataset " tgtdsn " not opened, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_RECFM:

   ZEDSMSG = "Invalid RECFM";
   ZEDLMSG = "Target dataset " tgtdsn " RECFM <> FB";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid") ";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_LRECL:

   ZEDSMSG = "Invalid LRECL";
   ZEDLMSG = "Target dataset " tgtdsn " LRECL <> 80";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid") ";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_MDEL:

   ZEDSMSG = "Member DELETE failed";
   ZEDLMSG = "Target dataset " tgtdsn " DELETE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid") ";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_EDIT:

   ZEDSMSG = "EDIT failed";
   ZEDLMSG = "Target dataset " tgtdsn " EDIT failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid") ";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_CLOSE:

   ZEDSMSG = "CLOSE failed";
   ZEDLMSG = "Target dataset " tgtdsn " CLOSE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset " tgtdsn " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_COPY:

   ZEDSMSG = "COPY failed";
   ZEDLMSG = "Target dataset " tgtdsn " COPY failed, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Address ISPEXEC "LMFREE DATAID("srcid") ";
   Exit (-16);

   Error_SRC_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Source dataset " srcdsn " not found, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_SRC_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Source dataset " srcdsn " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_XEQ_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "EXEC dataset " xeqdsn " not found, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_XEQ_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "EXEC dataset " xeqdsn " not opened, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_XEQ_RECFM:

   ZEDSMSG = "Invalid RECFM";
   ZEDLMSG = "EXEC dataset " xeqdsn " RECFM <> FB";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("xeqid") ";
   Address ISPEXEC "LMFREE DATAID("xeqid") ";
   Exit (-16);

   Error_XEQ_LRECL:

   ZEDSMSG = "Invalid LRECL";
   ZEDLMSG = "EXEC dataset " xeqdsn " LRECL <> 80";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("xeqid") ";
   Address ISPEXEC "LMFREE DATAID("xeqid") ";
   Exit (-16);

   Error_XEQ_DSORG:

   ZEDSMSG = "Invalid DSORG";
   ZEDLMSG = "EXEC dataset " xeqdsn " DSORG <> PO";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("xeqid") ";
   Address ISPEXEC "LMFREE DATAID("xeqid") ";
   Exit (-16);

   Error_XEQ_PUT:

   ZEDSMSG = "Write error";
   ZEDLMSG = "EXEC dataset " xeqdsn " WRITE error RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("xeqid") ";
   Address ISPEXEC "LMFREE DATAID("xeqid") ";
   Exit (-16);

   Error_XEQ_MADD:

   ZEDSMSG = "Member ADD failed";
   ZEDLMSG = "EXEC dataset " xeqdsn " Member ADD failed RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("xeqid") ";
   Address ISPEXEC "LMFREE DATAID("xeqid") ";
   Exit (-16);

   Error_XEQ_CLOSE:

   ZEDSMSG = "CLOSE failed";
   ZEDLMSG = "EXEC dataset " xeqdsn " CLOSE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("xeqid") ";
   Exit (-16);

   Error_XEQ_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "EXEC dataset " xeqdsn " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=BVIEW    0107-14252-15343-1517-00101-00053-00000-APLKS   27
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: This REXX macro is for batch processing.         */
/*                                                           */
/*          Invoke this REXX macro to View a dsname          */
/*          with an Initial macro.                           */
/*                                                           */
/*  Format: BVIEW imacro dsname                              */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC BVIEW  */

   Address TSO;
   'PROFILE NOPREFIX';

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;

/* "MACRO (parm2)";
   If RC <> 0 Then;
     Parse UPPER ARG parm2;
   Else;
     Upper parm2; */

   /* Parse User passed Parms */

   /* get the imacro and dsname that we want to view */
   If parm2 <> "" Then;
     Parse VAR parm2 imacro dsname .;
   Else;
     Signal Error_NODATA;

   If Length(imacro) > 8 Then;
     Signal Error_INVALID_IMACRO;

   dsname = Strip(dsname);
   x = Sysdsn(dsname);
   If x <> "OK" Then;
     Signal Error_INVALID_DSNAME;

   Address ISPEXEC "VIEW DATASET("dsname") ",
                   "MACRO("imacro") ";
   EC = RC;
   If RC > 4 Then;
     Signal Error_TGTSEQ_VIEW;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NODATA:

   ZEDSMSG = "NODATA";
   ZEDLMSG = "Missing imacro and dsname";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_IMACRO:

   ZEDSMSG = "INVALID IMACRO";
   ZEDLMSG = "Invalid IMACRO name " imacro;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_INVALID_DSNAME:

   ZEDSMSG = "INVALID DSNAME";
   ZEDLMSG = x;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGTSEQ_VIEW:

   ZEDSMSG = "VIEW FAILED";
   ZEDLMSG = "Target dataset" dsname " VIEW failed, RC= " EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);
./ ADD NAME=CBTCOMNT 0120-15248-19119-1730-00100-00066-00000-APLKS   30
/* REXX 2019-04-29 */
/* --------------------------------------------------------- */
/* Purpose: Insert comment line containing the CBT file      */
/*          release number and File number to each member    */
/*          of a PDS.                                        */
/*                                                           */
/*          Modify text... variables to contain the          */
/*          correct CBT#nnn, FILE#nnn, application name,     */
/*          and whatever else you want in the comment.       */
/*                                                           */
/*          Modify the LINE_BEFORE and LINE_AFTER            */
/*          command(s) to match the PDS library you want     */
/*          to modify.  Comment the one not needed.          */
/*                                                           */
/*          You can use the PWRISRT Rexx macro to invoke     */
/*          this Rexx macro for each and every member in     */
/*          the PDS.                                         */
/*                                                           */
/*  Format: CBTCOMNT                                         */
/*                                                           */
/* --------------------------------------------------------- */

/* Entering EXEC CBTCOMNT */

   Address ISREDIT;

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   "MACRO NOPROCESS";
   If RC <> 0 Then;
     Signal Error_INVALID_ENV;

   /* Initialize variables */

   "(currmem) = MEMBER";

   /*SOURCE before 1st*/
   /*HELP before 1st*/
   text1 = "*" || Copies(" ",3) || "CBT#478 FILE#810",
           || Copies(" ",5) || "ONSCREEN" || Copies(" ",29),
           || "LKS";

   /*REXX before 1st*/
   text2 = "/* REXX 2017-03-02 CBT#478 FILE#810 ONSCREEN */";

   /*DOC before 1st*/
   text3 = "/*" || Copies(" ",2) || "CBT#478 FILE#810",
           || Copies(" ",5) || "ONSCREEN" || Copies(" ",29),
           || "LKS */";

   /*CLIST before 1st*/
   /*PANELS after last*/
   text4 = "/*" || Copies(" ",2) || "CBT#478 FILE#810",
           || Copies(" ",5) || "ONSCREEN" || Copies(" ",29),
           || "LKS";

   /* Mainline Routine */

   Say "You are editing member: " currmem;

   "LINE_BEFORE .ZF = (text1)";
/* "LINE_AFTER .ZL = (text4)"; */

   If RC > 0 Then;
     Do;
       EC = RC;
       Signal Error_INVALID_INSTRUCTION;
     End;

   "BUILTIN SAVE";
   "END";

   Return (RC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_INVALID_ENV:

   Say "Must be in ISREDIT environment";
   Return (-16);

   Error_INVALID_INSTRUCTION:

   ZEDSMSG = "INVALID INST";
   Say "Instruction failed with RC=" EC;
   Exit (-16);
./ ADD NAME=CCB2EZT  0112-19200-19245-1722-00136-00351-00000-APLKS   51
/* REXX 2019-08-19 */
/* --------------------------------------------------------- */
/* Purpose: Convert one or more COBOL copybooks to a         */
/*          CA-EazyTrieve record layout.                     */
/*                                                           */
/*          1) use File Manager - Copybook View and Print    */
/*          to generate the data, File Manager uses          */
/*          to map a data area.  This file may contain the   */
/*          converted data of one or more COBOL copybooks.   */
/*                                                           */
/*          2) use the output file of File Manager as the    */
/*          input to this REXX exec.  This REXX exec will    */
/*          convert the output of File Manager to the format */
/*          desired by CA-EasyTrieve.                        */
/*                                                           */
/*          Must run in a TSO/E environment.                 */
/*                                                           */
/*  Format: CCB2EZT                                          */
/*                                                           */
/*  Changed:                                                 */
/*                                                           */
/* --------------------------------------------------------- */

/* Trace R; */

/* Entering EXEC CCB2EZT  */

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   /* Initialize Variables */

   input_ddname = "INPUT";
   output_ddname = "OUTPUT";

   "EXECIO 0 DISKR" input_ddname " ( OPEN ";
   If RC <> 0 Then;
     Signal Error_OPEN_FAILED;

   EC = 0;
   Do While EC = 0;
     "EXECIO 1 DISKR" input_ddname;
     If RC <> 0 Then;
       Do;
         EC = RC;
         Iterate;
       End;
     Pull line;
     line = Substr(line,2);        /*drop carriage control*/
     Parse VAR line token line;
     If Datatype(token,"W") <> 1 Then;
       Iterate;
     ref = token;
     If ref = 1 Then;
       Do;
         Push " ";
         "EXECIO 1 DISKW" output_ddname;
       End;
     pic = " ";
     occurs = " ";
     Parse VAR line level field_name token line;
     If token = "OCCURS" Then;
       Do;
         occurs = token;                /*initialize OCCURS*/
         Parse VAR line token line;     /*extract nbr of occurs*/
         occurs = occurs token;
         Parse VAR line token line;     /*extract TIMES*/
         occurs = occurs token;
         Parse VAR line token line;     /*get next token*/
       End;
     If token = "REDEFINES" Then;
       Do;
         Parse VAR line . line;         /*drop REDEFINES clause*/
         Parse VAR line token line;     /*get next token*/
       End;
     If Substr(token,1,1) = "X" | Substr(token,1,1) = "S" | ,
          Substr(token,1,1) = "V" | Substr(token,1,1) = "9" Then;
       Do;
         pic = token;
         Parse VAR line token line;     /*get next token*/
       End;
     n = Wordpos(token,"AN BI FP PD ZD");
     If n > 0 Then;
       Select;
         When token = "AN" Then;
           attr = "A";
         When token = "BI" Then;
           attr = "B";
         When token = "PD" Then;
           attr = "P";
         When token = "ZD" Then;
           attr = "N";
         Otherwise;
           attr = "U";
       End;
     Parse VAR line strt_pos end_pos len . ;
     Push Left(field_name,34) Right(strt_pos,5) Right(len,5),
          "  " attr "  " occurs;
     "EXECIO 1 DISKW" output_ddname;
     If pic <> " " Then;
       Do;
         Push Copies(" ",52) "* PIC" pic;
         "EXECIO 1 DISKW" output_ddname;
       End;
   End;

   "EXECIO 0 DISKR" input_ddname " ( FINIS ";
   "EXECIO 0 DISKW" output_ddname " ( FINIS ";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */


   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_OPEN_FAILED:

   Say "Open for input data set failed - RC="RC;
   "EXECIO 0 DISKR "input_ddname" ( FINIS ";
   Exit (12);
./ ADD NAME=CSIALI#  0156-02022-16007-1104-00552-00325-00000-APLKS   08
/* REXX - CSIALI# : Count datasets for each alias in the system       */
/**********************************************************************/
/* ALICOUNT : Uses Catalog Search Interface (CSI)                     */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version            */
/* 1.1.0   - 11/01/2002 - Alastair Gray - Rewrite using CLICODE base  */
/* 1.1.1   - 14/01/2002 - Alastair Gray - Add TOT_INIT                */
/* 1.1.2   - 22/01/2002 - Alastair Gray - In line with CSICODE        */
/* 1.1.3   - 29/04/2002 - Alastair Gray - Added '?' option            */
/* 1.1.4   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.1.5   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.1.6   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.1.7   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.1.8   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.2.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.2.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.2.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.2.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.2.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This processes the master catalog to get a list of aliases and  */
/*    then processes each ALIAS/UCAT to get a dataset count.          */
/*                                                                    */
/* 2. The output is written to members of a PDS allocated to REPORT.  */
/*    or in batch JES sequential output is allowed.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say ' **(Error-1)* No TSO environment and no OMVS environment.'
  Say ' **(Error-2)* CSIALI# cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
Arg test                             /* allow for '?' option          */
If (test = '?') Then                 /*                               */
 Do                                  /*                               */
  Say " CSIALI# has no other parms"
  Say "  To use simply specify 'CSIALI#' it will identify and use the "
  Say "  master catalog."
  Signal FINISH                      /*                               */
 End                                 /*                               */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat = ' '                            /* Set catalog name              */
flt = '**'                           /* Set the filter                */
typ = 'X'                            /* Set entry types required      */
ct1 = ' '                            /* Set for 1 catalog only        */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
x = CSI(cat,flt,typ,ct1)             /* initial CSI call              */
/**********************************************************************/
nvsam_cnt = 0                        /* initialise non-vsam count     */
ucat_cnt  = 0                        /* initialise usercat count      */
/**********************************************************************/
l_cnt = l_cnt + 2                    /* increment for loop            */
head1 = l_cnt - 1                    /* calculate header line 1       */
head2 = l_cnt                        /* calculate headre line 2       */
Do zzzz = 1 to alias_tot             /* loop through alias list       */
 ind_tot = 0                         /*  initialise counter           */
 If (altyp.zzzz = 'A') Then          /*  if alternate is NONVSAM      */
  Do                                 /*                               */
   nvsam_cnt = nvsam_cnt + 1         /*   increment non-VSAM counter  */
   l_cnt = l_cnt + 1                 /*   increment report line       */
   l.l_cnt = Left(1,6)' 'alias.zzzz' for 'Strip(alcat.zzzz,T)
  End                                /*                               */
End                                  /*                               */
l.head1 = ' Number of Non-VSAM aliases found = 'nvsam_cnt
l.head2 = ' 'Left('-',Length(l.head1),'-')
/**********************************************************************/
l_cnt = l_cnt + 1                    /* add a blank line to report    */
l.l_cnt = ' '                        /*                               */
/**********************************************************************/
l_cnt = l_cnt + 2                    /* increment for next loop       */
head1 = l_cnt - 1                    /* calculate header line 1       */
head2 = l_cnt                        /* calculate header line 2       */
Do zzzz = 1 to alias_tot             /* loop through alias list       */
 ind_tot = 0                         /*  initialise counter           */
 If (altyp.zzzz = 'U') Then          /*  if alternate is UCAT         */
  Do                                 /*                               */
   ucat_cnt = ucat_cnt + 1           /*   increment UCAT counter      */
   l_cnt = l_cnt + 1                 /*   increment report line       */
   x = CSI(Strip(alcat.zzzz,T),Strip(alias.zzzz)'.**','ABCGHR','Y')
   l.l_cnt = ' 'Left(ind_tot,6)' 'alias.zzzz' in  'Strip(alcat.zzzz,T)
  End                                /*                               */
End                                  /*                               */
l.head1 = ' Number of UCAT aliases found = 'ucat_cnt
l.head2 = ' 'Left('-',Length(l.head1),'-')
/**********************************************************************/
/* Produce the ALIAS Report                                           */
/**********************************************************************/
member = 'ALIASCNT'                  /* processing ALIASCNT report    */
Call WRITE_MEMBER                    /* write-out member              */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"sysdsname"') VOLUME("sysvolume")"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
csiresrv = Substr(' ',1,1)           /* clear reserve character       */
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '0004'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csiresrv
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say ' **(Error-1)* CSI processing.'
   Say ' **(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* Work Area defined  = 'csiusrln
   Say ' **(Error-2)* Work Area used     = 'csiusdln
   Say ' **(Error-3)* Work Area required = 'csireqln
   Say ' **(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say ' **(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length     */
    If (csienter = '1') Then         /* entry error                   */
     Do
      Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
      Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
      plus = 50                      /* length for error entry        */
     End
    Else                             /*                               */
     Do                              /*                               */
      Call ENTRY                     /* Execute entry processing      */
      plus = 46 + csitotln           /* length for normal entry       */
     End                             /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
e_off = off + 46                     /* get offset to entries         */
o_fld.1 = e_off+4+(C2d(csinumen)*2)  /* get first field offset        */
l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length      */
e_pos = 6                            /* set offset of second field    */
Do flds = 2 to C2d(csinumen)         /* loop through other fields     */
 prv = flds - 1                      /* set 'previous' value          */
 o_fld.flds = o_fld.prv + l_fld.prv  /* get next offset               */
 l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length     */
 e_pos = e_pos + 2                   /*                               */
End                                  /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
  Say ' **(Error-2)* Entry type ='entype
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* For execution in batch, please ensure that a PDS'
   Say ' **(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say ' **(Error-1)* For execution in foreground TSO, please ensure'
    Say ' **(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                "Blksize(1330) Recfm(F,B) New Reuse"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    x = Listdd(REPORT)               /*                               */
    dsn = sysdsname                  /*                               */
   End                               /*                               */
Else                                 /*                               */
 dsn = sysdsname                     /* get dataset name from DD      */
If (sysvolume = '*JES**') Then       /*                               */
 Do                                  /*                               */
  Say ' **(Warning-1)* For execution in batch, it is recommended that'
  Say ' **(Warning-2)* a PDS is pre-allocated to DD name REPORT.'
  Say ' **(Warning-3)* Processing will continue with sequential output.'
  outflag = 'JES'                    /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
alias_tot = 0                        /* initialise alias counter      */
ind_tot   = 0                        /* initialise individual counter */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDD:                                     /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
If (csi_type /= '0') Then            /* processing non-catalog        */
 Do                                  /*                               */
  If (entype = 'ALIAS') Then         /* If entry is an ALIAS          */
   Do                                /*                               */
    alias_tot = alias_tot + 1        /*  increment total              */
    alias.alias_tot = entname        /*  save alias name              */
    alcat.alias_tot = name           /*  save alias catalog           */
    altyp.alias_tot = type           /*  save alias type              */
   End                               /*                               */
  Else                               /* otherwise                     */
   Do                                /*                               */
    ind_tot = ind_tot + 1            /*  increment individual counter */
   End                               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

./ ADD NAME=CSIALIGN 0167-02022-16007-1106-00844-00510-00000-APLKS   46
/* REXX - CSIALIGN : Generate ALIAS DEFs based on catalog contents    */
/**********************************************************************/
/* CSICODE : Uses Catalog Search Interface (CSI)                      */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 22/01/2002 - Alastair Gray - Original version            */
/* 1.0.1   - 29/04/2002 - Alastair Gray - Added '?' option            */
/* 1.0.2   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.0.3   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.0.4   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.0.5   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.0.6   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.0.7   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This processes a catalog and produces a PDS member with         */
/*    DEF ALIAS statements for all 'suitable' HLQs in the cat.        */
/*                                                                    */
/* 2. The output is written to members of a PDS allocated to REPORT   */
/*    or in batch JES sequential output is allowed.                   */
/*                                                                    */
/* 3. Handy when you have accidentally disconnected a usercat ...     */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say ' **(Error-1)* No TSO environment and no OMVS environment.'
  Say ' **(Error-2)* CSIALIGN cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
/* Initialize the relevant CSI variables                              */
/**********************************************************************/
cat = ' '                            /* Set catalog name              */
flt = '**'                           /* Set the filter                */
typ = ' '                            /* Set entry types required      */
ct1 = ' '                            /* Set for 1 catalog only        */
/**********************************************************************/
/* Handle passed parameters                                           */
/**********************************************************************/

Arg cat .                            /* Get passed arguments */

cat = Strip(cat,B,"'")               /* clean up passed catalog       */
If (cat = '?') Then                  /*                               */
 Do                                  /*                               */
  Say " CSIALIGN has only one paramemter"
  Say "  To use simply specify : CSIALIGN catname "
  Signal FINISH                      /*                               */
 End                                 /*                               */
If (cat = '') Then                   /* no catalog passed             */
 Do                                  /*                               */
  Say ' **(cat)** No entry provided for catalog name.'
  Signal FINISH                      /* exit exec                     */
 End                                 /*                               */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialize the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialize totals             */
/**********************************************************************/
/* Get the Master Catalog name                                        */
/**********************************************************************/
Call GET_MCAT                        /* get master catalog name       */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
member = 'ALIASGEN'                  /* processing ALIAS gen report   */
x = CSI(cat,'**',typ,'Y')            /* Call CSI procedure            */
Call WRITE_MEMBER                    /* write-out member              */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"sysdsname"') VOLUME("sysvolume")"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialize the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
csiresrv = Substr(' ',1,1)           /* clear reserve character       */
/**********************************************************************/
/* Initialize requested fields                                        */
/**********************************************************************/
csinumen = '000D'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */
csifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */
csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */
csifld08 = Left('CATTR   ',8)        /* Attributes page and swap      */
csifld09 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld10 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld11 = Left('FILESEQ ',8)        /* File Sequence number          */
csifld12 = Left('VSAMREUS',8)        /* VSAM dataset information      */
csifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information      */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csiresrv
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
csifield = csifield||csifld11||csifld12||csifld13
/**********************************************************************/
/* Initialize and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialize work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say ' **(Error-1)* CSI processing.'
   Say ' **(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* Work Area defined  = 'csiusrln
   Say ' **(Error-2)* Work Area used     = 'csiusdln
   Say ' **(Error-3)* Work Area required = 'csireqln
   Say ' **(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say ' **(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length     */
    If (csienter = '1') Then         /* entry error                   */
     Do
      Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
      Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
      plus = 50                      /* length for error entry        */
     End
    Else                             /*                               */
     Do                              /*                               */
      Call ENTRY                     /* Execute entry processing      */
      plus = 46 + csitotln           /* length for normal entry       */
     End                             /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
e_off = off + 46                     /* get offset to entries         */
o_fld.1 = e_off+4+(C2d(csinumen)*2)  /* get first field offset        */
l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length      */
e_pos = 6                            /* set offset of second field    */
Do flds = 2 to C2d(csinumen)         /* loop through other fields     */
 prv = flds - 1                      /* set 'previous' value          */
 o_fld.flds = o_fld.prv + l_fld.prv  /* get next offset               */
 l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length     */
 e_pos = e_pos + 2                   /*                               */
End                                  /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
gdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */
gdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */
dscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */
cattr    = Substr(dwork,o_fld.8,l_fld.8)   /* attribs page and swap   */
devtyp   = Substr(dwork,o_fld.9,l_fld.9)   /* device type             */
volser   = Substr(dwork,o_fld.10,l_fld.10) /* volume serial           */
fileseq  = Substr(dwork,o_fld.11,l_fld.11) /* file sequence           */
vsamreus = Substr(dwork,o_fld.12,l_fld.12) /* VSAM dataset information*/
vsamtype = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
vsam_attr = ''                           /* Initialize vsam attributes*/
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'CATTR') > 0) Then    /*                           */
 Call FLD_CATTR                          /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'GDGATTR') > 0) Then  /*                           */
 Call FLD_GDGATTR                        /*                           */
If (Index(csifield,'GDGLIMIT') > 0) Then /*                           */
 Call FLD_GDGLIMIT                       /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'VSAMTYPE') > 0) Then /*                           */
 Call FLD_VSAMTYPE                       /*                           */
If (Index(csifield,'VSAMREUS') > 0) Then /*                           */
 Call FLD_VSAMREUS                       /*                           */
If (Index(csifield,'DSCRDT2') > 0) Then  /*                           */
 Call FLD_DSCRDT2                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
  Say ' **(Error-2)* Entry type ='entype
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_TYPE     - Process TYPE     field                              */
/**********************************************************************/
FLD_TYPE:                            /* TYPE     field processing   ##*/
type_list = ''                       /* loop through type             */
Do z = 1 to Length(type)             /* loop through type             */
 astype = Substr(type,z,1)           /* decode type flag              */
 Select                              /* decode type flag              */
  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */
  When (astype = 'D') Then astype = 'DATA'     /*                     */
  When (astype = 'I') Then astype = 'INDEX'    /*                     */
  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */
  When (astype = 'H') Then astype = 'GDS'      /*                     */
  When (astype = 'B') Then astype = 'GDG'      /*                     */
  When (astype = 'R') Then astype = 'PATH'     /*                     */
  When (astype = 'G') Then astype = 'AIX'      /*                     */
  When (astype = 'X') Then astype = 'ALIAS'    /*                     */
  When (astype = 'U') Then astype = 'UCAT'     /*                     */
  Otherwise                          /*                               */
   Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
   Say ' **(Error-2)* Entry type ='astype
   astype = '@'                      /* unknown type                  */
 End                                 /*                               */
 type_list = type_list' 'astype      /*                               */
End                                  /*                               */
type = Strip(type_list,L)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGLIMIT - Process GDGLIMIT field                              */
/**********************************************************************/
FLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/
gdglimit = X2d(C2x(gdglimit))        /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGATTR  - Process GDGATTR  field                              */
/**********************************************************************/
FLD_GDGATTR:                         /* GDGATTR  field processing   ##*/
gdgattr = X2b(C2x(gdgattr))          /*                               */
If (Substr(gdgattr,1,1) = '1') Then  /*                               */
 gdg_emp = 'EMPTY'                   /*                               */
Else                                 /*                               */
 gdg_emp = 'NOEMPTY'                 /*                               */
If (Substr(gdgattr,2,1) = '1') Then  /*                               */
 gdg_scr = 'SCRATCH'                 /*                               */
Else                                 /*                               */
 gdg_scr = 'NOSCRATCH'               /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DSCRDT2  - Process DSCRDT2  field                              */
/**********************************************************************/
FLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/
If (Substr(dscrdt2,1,2) /= 'FFFF'X) Then
 Do                                  /*                               */
  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */
  yy    = Substr(yyddd,1,2)          /*                               */
  ddd   = Substr(yyddd,3,3)          /*                               */
  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */
  If (cent = '00') Then              /*                               */
   yyyy    = yy + 1900               /*                               */
  Else                               /*                               */
   yyyy    = yy + 2000               /*                               */
  If (yyyy = '1900') Then            /* correct for '00'              */
   yyyy = '2000'                     /*                               */
  savcrdt2 = dscrdt2
  dscrdt2 = yyyy'.'ddd               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_CATTR    - Process CATTR    field                              */
/**********************************************************************/
FLD_CATTR:                           /* CATTR    field processing   ##*/
cattr = X2b(C2x(cattr))              /*                               */
If (entype = 'CLUSTER') Then         /*                               */
 Do                                  /*                               */
  If (Substr(cattr,8,1) = '1') Then  /*                               */
   entype = 'PAGESPACE'              /*                               */
  If (Substr(cattr,7,1) = '1') Then  /*                               */
   pageswap = 'SWAP'                 /*                               */
  Else                               /*                               */
   pageswap = 'NOSWAP'               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP   field processing   ##*/
devices = ''                         /* Initialize devices            */
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_model  = Substr(device,1,1)       /* get model byte                */
 d_option = Substr(device,2,1)       /* get option byte               */
 d_class  = Substr(device,3,1)       /* get class byte                */
 d_device = Substr(device,4,1)       /* get device byte               */
 Select                              /*                               */
  When (d_class = '80'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'TAPE'               /* Tape device                   */
    Select                           /*                               */
     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/
     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */
     When (d_device = '05'x) Then dev_type = '3410' /*                */
     When (d_device = '06'x) Then dev_type = '8809' /*                */
     When (d_device = '07'x) Then dev_type = '3430' /*                */
     When (d_device = '08'x) Then dev_type = '7340' /*                */
     When (d_device = '09'x) Then dev_type = '9374' /*                */
     When (d_device = '80'x) Then dev_type = '3480' /*                */
     When (d_device = '81'x) Then dev_type = '3490' /*                */
     When (d_device = '83'x) Then dev_type = '3590' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End                               /*                               */
  When (d_class = '20'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'DASD'               /* DASD device                   */
    Select                           /*                               */
     When (d_device = '04'x) Then dev_type = '9345' /*                */
     When (d_device = '09'x) Then dev_type = '3330' /*                */
     When (d_device = '0A'x) Then dev_type = '3340' /*                */
     When (d_device = '0B'x) Then dev_type = '3350' /*                */
     When (d_device = '0C'x) Then dev_type = '3375' /*                */
     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */
     When (d_device = '0E'x) Then dev_type = '3380' /*                */
     When (d_device = '0F'x) Then dev_type = '3390' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
  Otherwise                          /*                               */
   Do                                /*                               */
    dev_class = 'UNKN'               /* Unknown device                */
    Select                           /*                               */
     When (device = '00000000'x) Then dev_type = '0000' /*            */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
 End                                 /*                               */
 devices = devices||' '||Left(dev_type,8) /* build device list        */
End                                  /*                               */
devices = Strip(devices,B,' ')       /* clean up device list          */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */
/**********************************************************************/
FLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/
vsamreus = X2b(C2x(vsamreus))        /* show binary flags             */
If (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */
 vsam_attr = vsam_attr' REUSE'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREUSE'     /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMTYPE - Process VSAMTYPE field                              */
/**********************************************************************/
FLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/
vsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */
vsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */
Select                               /*                               */
 When (Substr(vsam_byte1,1,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'KSDS'                /*                               */
   vsam_attr = vsam_attr' INDEXED'   /*                               */
  End                                /*                               */
 When (Substr(vsam_byte1,7,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'RRDS'                /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,6,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'LDS'                 /*                               */
   vsam_attr = vsam_attr' LINEAR'    /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,8,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'VRRDS'               /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 Otherwise                           /*                               */
  Do                                 /*                               */
   vsam_type = 'ESDS'                /*                               */
   If (entype /= 'INDEX') Then       /*                               */
    vsam_attr = vsam_attr' NONINDEXED'/*                              */
  End                                /*                               */
End                                  /*                               */
If (Substr(vsam_byte1,2,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' WRITECHECK'  /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOWRITECHK'  /*                               */
If (Substr(vsam_byte1,3,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' IMBED'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOIMBED'     /*                               */
If (Substr(vsam_byte1,4,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' REPLICATE'   /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREPLICAT'  /*                               */
If (entype /= 'INDEX') Then          /*                               */
 If (Substr(vsam_byte1,8,1) = '1') Then /*                            */
  vsam_attr = vsam_attr' SPANNED'     /*                              */
 Else                                 /*                              */
  vsam_attr = vsam_attr' NONSPANNED'  /*                              */
If (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */
 vsam_vvds = 'Y'                     /* Set VVDS flag                 */
Else                                 /*                               */
 vsam_vvds = 'N'                     /* Set VVDS flag off             */
vsam_attr = Strip(vsam_attr,B)       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* For execution in batch, please ensure that a PDS'
   Say ' **(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say ' **(Error-1)* For execution in foreground TSO, please ensure'
    Say ' **(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                "Blksize(1330) Recfm(F,B) New Reuse"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    x = Listdd(REPORT)               /*                               */
    dsn = sysdsname                  /*                               */
   End                               /*                               */
Else                                 /*                               */
 dsn = sysdsname                     /* get dataset name from DD      */
If (sysvolume = '*JES**') Then       /*                               */
 Do                                  /*                               */
  Say ' **(Warning-1)* For execution in batch, it is recommended that'
  Say ' **(Warning-2)* a PDS is pre-allocated to DD name REPORT.'
  Say ' **(Warning-3)* Processing will continue with sequential output.'
  outflag = 'JES'                    /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialize the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialize totals variables ##*/
l_cnt   = 0                          /* Initialize output line count  */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDD:                                     /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
If (csi_type /= '0') Then            /* processing non-catalog        */
 Do                                  /*                               */
  If (Substr(entname,1,4) = '0000') |, /* not self entry              */
     (entype = 'CLUSTER') |,         /* not a cluster entry           */
     (entype = 'UCAT') Then          /* not a ucat entry              */
   Return                            /*                               */
  If (entype = 'DATA') |,            /* not data entry or             */
     (entype = 'INDEX') Then         /*     index entry               */
   If (vsam_vvds = 'Y') Then         /*  when VVDS                    */
    Return                           /*                               */
  hlq = Word(Translate(entname,' ','.'),1) /* get hlq                 */
  If (flag.hlq /= 'Y') Then          /* if not processed              */
   Do                                /*                               */
    flag.hlq = 'Y'                   /* set flag                      */
    l_cnt = l_cnt + 1                /* build DEF ALIAS with hlq      */
    l.l_cnt = '     DEF ALIAS(REL('cat') -'
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = '          NAME('hlq'))     -'
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = '          CAT('mast_cat')'
   End                               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* GET_MCAT - Get the Master catalog name                             */
/**********************************************************************/
GET_MCAT:                            /* Get the Master catalog name ##*/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtcbsp  = Storage(D2x(C2d(cvt)+256),4)  /* get the AMCBS address     */
acb      = Storage(D2x(C2d(cvtcbsp)+8),4)/* get the acb Address       */
caxwa    = Storage(D2x(C2d(acb)+64),4)   /* get the caxwa Address     */
dsncat   = Storage(D2x(C2d(caxwa)+52),44)/* dsn of master cat         */
mast_cat = Strip(dsncat,T)           /*                               */
Return                               /*                               */
/**********************************************************************/

./ ADD NAME=CSIALL   0193-03062-16007-0920-00905-00811-00000-APLKS   45
/* REXX - CSIALL : Minimum clean CSI utilisation code                 */
/**********************************************************************/
/* CSICODE : Uses Catalog Search Interface (CSI)                      */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 12/01/2002 - Alastair Gray - Original version            */
/* 1.0.1   - 15/01/2002 - Alastair Gray - Added DSCRDT2 field         */
/* 1.0.2   - 22/01/2002 - Alastair Gray - Re-ordered fields           */
/* 1.0.3   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.0.4   - 21/06/2002 - Alastair Gray - Checked work area required  */
/* 1.0.5   - 08/08/2002 - Alastair Gray - Updated device list         */
/* 1.0.6   - 20/09/2002 - Alastair Gray - Updates for CSICODEV        */
/* 1.0.7   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.0.8   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.0.9   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/* 1.1.5   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.1.6   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.1.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */
/* 1.1.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */
/* 1.1.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */
/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This provides a clean base for further CSI development work.    */
/*                                                                    */
/* 2. This processes all catalogs and lists all entries.              */
/*                                                                    */
/* 3. One return codes is 'special' :                                 */
/*    RC=44 , Reason=14                                               */
/*    This relates to entries of greater than 65535 characters.       */
/*    If you get this entry, then you need to enable fullword         */
/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */
/* 3. The output is written to members of a PDS allocated to REPORT   */
/*    or in batch JES sequential output is allowed.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say ' **(Error-1)* No TSO environment and no OMVS environment.'
  Say ' **(Error-2)* CSIALL cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
Arg vals                             /* Get passed arguments          */
argnum = 0                           /*                               */
Do i = 1 to Words(vals)              /* loop thru arguments           */
 testarg = Strip(Word(vals,i),B,"'") /* remove inverted commas        */
 Upper testarg                       /* convert to upper case         */
 Select                              /*                               */
  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */
   Do                                /*                               */
    debug = Substr(testarg,7,1)      /* get debug value               */
    Say ' **(Debug)*** Debug level 'debug' enabled.'
   End                               /*                               */
  When (testarg = '?') Then          /*                               */
   Do                                /*                               */
    Say " CSIALL has no normal external parms" /*                      */
    Say "  To use simply specify 'CSIALL' it will identify and use the "
    Say "  master catalog."           /*                               */
    Signal FINISH                    /*                               */
   End                               /*                               */
  Otherwise NOP                      /*                               */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat.1 = ' '                          /* Set catalog name              */
flt   = '**'                         /* Set the filter                */
typ   = ' '                          /* Set entry types required      */
ct1   = ' '                          /* Set for 1 catalog only        */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
member = 'REPORT'                    /* processing ALL report         */
x = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */
Call WRITE_MEMBER                    /* write-out member              */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"sysdsname"') VOLUME("sysvolume")"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
/**********************************************************************/
bcp = mvsvar('sysmvs')               /*                               */
lev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */
If (lev > 609) Then                  /* os/390 R10 and up for fullword*/
 csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/
Else                                 /*                               */
 csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword used        */
 Say ' **(csi)***** Fullword processing selected'
Else                                 /* check if fullword used        */
 Say ' **(csi)***** Halfword processing - default'
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '000D'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */
csifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */
csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */
csifld08 = Left('CATTR   ',8)        /* Attributes page and swap      */
csifld09 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld10 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld11 = Left('FILESEQ ',8)        /* File Sequence number          */
csifld12 = Left('VSAMREUS',8)        /* VSAM dataset information      */
csifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information      */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csioptns
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
csifield = csifield||csifld11||csifld12||csifld13
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say ' **(Error-1)* CSI processing.'
   Say ' **(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* Work Area defined  = 'csiusrln
   Say ' **(Error-2)* Work Area used     = 'csiusdln
   Say ' **(Error-3)* Work Area required = 'csireqln
   Say ' **(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  If (debug = 2) Then                /*                               */
   Do                                /*                               */
    Say ' off=<'off'>'
    Say ' entry =<'Substr(dwork,off,150)'>'
    Say ' entry X=<'C2x(Substr(dwork,off,150))'>'
   End                               /*                               */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say ' **(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */
    Select                           /*                               */
     When (csienter = '1') Then      /*                               */
      Do                             /*                               */
       Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     When (csiedata = '0') Then      /*                               */
      Do                             /*                               */
       Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say ' **(Error-2)* No data returned'
       Say ' **(Error-3)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     Otherwise                       /*                               */
      Do                             /*                               */
       If (csioptns = 'F') Then      /* check if fullword requested   */
        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */
       Else                          /* otherwise (default halfword)  */
        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */
       Call ENTRY                    /* Execute entry processing      */
       plus = 46 + csitotln          /* length for normal entry       */
      End                            /*                               */
    End                              /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword requested   */
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */
  e_pos = 12                         /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say " e_off="e_off
    Say " C=<"Substr(dwork,e_off,200)">"
    Say " X=<"C2x(Substr(dwork,e_off,200))">"
    Say " o_fld.1="o_fld.1",hex="C2x(o_flds.1)
    Say " l_fld.1="l_fld.1",hex="C2x(l_flds.1)
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */
   e_pos = e_pos + 4                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say " o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds)
     Say " l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds)
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
Else                                 /* otherwise (default halfword)  */
/**********************************************************************/
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */
  e_pos = 6                          /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say " e_off="e_off
    Say " C=<"Substr(dwork,e_off,200)">"
    Say " X=<"C2x(Substr(dwork,e_off,200))">"
    Say " o_fld.1="o_fld.1",hex="C2x(o_flds.1)
    Say " l_fld.1="l_fld.1",hex="C2x(l_flds.1)
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */
   e_pos = e_pos + 2                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say " o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds)
     Say " l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds)
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
gdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */
gdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */
dscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */
cattr    = Substr(dwork,o_fld.8,l_fld.8)   /* attribs page and swap   */
devtyp   = Substr(dwork,o_fld.9,l_fld.9)   /* device type             */
volser   = Substr(dwork,o_fld.10,l_fld.10) /* volume serial           */
fileseq  = Substr(dwork,o_fld.11,l_fld.11) /* file sequence           */
vsamreus = Substr(dwork,o_fld.12,l_fld.12) /* VSAM dataset information*/
vsamtype = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
vsam_attr = ''                           /* initialise vsam attributes*/
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'CATTR') > 0) Then    /*                           */
 Call FLD_CATTR                          /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'GDGATTR') > 0) Then  /*                           */
 Call FLD_GDGATTR                        /*                           */
If (Index(csifield,'GDGLIMIT') > 0) Then /*                           */
 Call FLD_GDGLIMIT                       /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'VSAMTYPE') > 0) Then /*                           */
 Call FLD_VSAMTYPE                       /*                           */
If (Index(csifield,'VSAMREUS') > 0) Then /*                           */
 Call FLD_VSAMREUS                       /*                           */
If (Index(csifield,'DSCRDT2') > 0) Then  /*                           */
 Call FLD_DSCRDT2                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
  Say ' **(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_TYPE     - Process TYPE     field                              */
/**********************************************************************/
FLD_TYPE:                            /* TYPE     field processing   ##*/
type_list = ''                       /* loop through type             */
Do z = 1 to Length(type)             /* loop through type             */
 astype = Substr(type,z,1)           /* decode type flag              */
 Select                              /* decode type flag              */
  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */
  When (astype = 'D') Then astype = 'DATA'     /*                     */
  When (astype = 'I') Then astype = 'INDEX'    /*                     */
  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */
  When (astype = 'H') Then astype = 'GDS'      /*                     */
  When (astype = 'B') Then astype = 'GDG'      /*                     */
  When (astype = 'R') Then astype = 'PATH'     /*                     */
  When (astype = 'G') Then astype = 'AIX'      /*                     */
  When (astype = 'X') Then astype = 'ALIAS'    /*                     */
  When (astype = 'U') Then astype = 'UCAT'     /*                     */
  Otherwise                          /*                               */
   Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
   Say ' **(Error-2)* Entry type ='astype' X=<'C2x(astype)'>'
   astype = '@'                      /* unknown type                  */
 End                                 /*                               */
 type_list = type_list' 'astype      /*                               */
End                                  /*                               */
type = Strip(type_list,L)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGLIMIT - Process GDGLIMIT field                              */
/**********************************************************************/
FLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/
gdglimit = X2d(C2x(gdglimit))        /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGATTR  - Process GDGATTR  field                              */
/**********************************************************************/
FLD_GDGATTR:                         /* GDGATTR  field processing   ##*/
gdgattr = X2b(C2x(gdgattr))          /*                               */
If (Substr(gdgattr,1,1) = '1') Then  /*                               */
 gdg_emp = 'EMPTY'                   /*                               */
Else                                 /*                               */
 gdg_emp = 'NOEMPTY'                 /*                               */
If (Substr(gdgattr,2,1) = '1') Then  /*                               */
 gdg_scr = 'SCRATCH'                 /*                               */
Else                                 /*                               */
 gdg_scr = 'NOSCRATCH'               /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DSCRDT2  - Process DSCRDT2  field                              */
/**********************************************************************/
FLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/
If (Substr(dscrdt2,1,2) /= 'FFFF'X) Then
 Do                                  /*                               */
  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */
  yy    = Substr(yyddd,1,2)          /*                               */
  ddd   = Substr(yyddd,3,3)          /*                               */
  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */
  If (cent = '00') Then              /*                               */
   yyyy    = yy + 1900               /*                               */
  Else                               /*                               */
   yyyy    = yy + 2000               /*                               */
  If (yyyy = '1900') Then            /* correct for '00'              */
   yyyy = '2000'                     /*                               */
  savcrdt2 = dscrdt2
  dscrdt2 = yyyy'.'ddd               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_CATTR    - Process CATTR    field                              */
/**********************************************************************/
FLD_CATTR:                           /* CATTR    field processing   ##*/
cattr = X2b(C2x(cattr))              /*                               */
If (entype = 'CLUSTER') Then         /*                               */
 Do                                  /*                               */
  If (Substr(cattr,8,1) = '1') Then  /*                               */
   entype = 'PAGESPACE'              /*                               */
  If (Substr(cattr,7,1) = '1') Then  /*                               */
   pageswap = 'SWAP'                 /*                               */
  Else                               /*                               */
   pageswap = 'NOSWAP'               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP   field processing   ##*/
devices = ''                         /* initialise devices            */
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_model  = Substr(device,1,1)       /* get model byte                */
 d_option = Substr(device,2,1)       /* get option byte               */
 d_class  = Substr(device,3,1)       /* get class byte                */
 d_device = Substr(device,4,1)       /* get device byte               */
 Select                              /*                               */
  When (d_class = '80'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'TAPE'               /* Tape device                   */
    Select                           /*                               */
     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/
     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */
     When (d_device = '05'x) Then dev_type = '3410' /*                */
     When (d_device = '06'x) Then dev_type = '8809' /*                */
     When (d_device = '07'x) Then dev_type = '3430' /*                */
     When (d_device = '08'x) Then dev_type = '7340' /*                */
     When (d_device = '09'x) Then dev_type = '9374' /*                */
     When (d_device = '80'x) Then dev_type = '3480' /*                */
     When (d_device = '81'x) Then dev_type = '3490' /*                */
     When (d_device = '83'x) Then dev_type = '3590' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End                               /*                               */
  When (d_class = '20'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'DASD'               /* DASD device                   */
    Select                           /*                               */
     When (d_device = '04'x) Then dev_type = '9345' /*                */
     When (d_device = '09'x) Then dev_type = '3330' /*                */
     When (d_device = '0A'x) Then dev_type = '3340' /*                */
     When (d_device = '0B'x) Then dev_type = '3350' /*                */
     When (d_device = '0C'x) Then dev_type = '3375' /*                */
     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */
     When (d_device = '0E'x) Then dev_type = '3380' /*                */
     When (d_device = '0F'x) Then dev_type = '3390' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
  Otherwise                          /*                               */
   Do                                /*                               */
    dev_class = 'UNKN'               /* Unknown device                */
    Select                           /*                               */
     When (device = '00000000'x) Then dev_type = '0000' /*            */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
 End                                 /*                               */
 devices = devices||' '||Left(dev_type,8) /* build device list        */
End                                  /*                               */
devices = Strip(devices,B,' ')       /* clean up device list          */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */
/**********************************************************************/
FLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/
Return                               /* duplicates ATTR1              */
vsamreus = X2b(C2x(vsamreus))        /* show binary flags             */
If (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */
 vsam_attr = vsam_attr' REUSE'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREUSE'     /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMTYPE - Process VSAMTYPE field                              */
/**********************************************************************/
FLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/
vsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */
vsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */
Select                               /*                               */
 When (Substr(vsam_byte1,1,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'KSDS'                /*                               */
   vsam_attr = vsam_attr' INDEXED'   /*                               */
  End                                /*                               */
 When (Substr(vsam_byte1,7,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'RRDS'                /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,6,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'LDS'                 /*                               */
   vsam_attr = vsam_attr' LINEAR'    /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,8,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'VRRDS'               /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 Otherwise                           /*                               */
  Do                                 /*                               */
   vsam_type = 'ESDS'                /*                               */
   If (entype /= 'INDEX') Then       /*                               */
    vsam_attr = vsam_attr' NONINDEXED'/*                              */
  End                                /*                               */
End                                  /*                               */
If (Substr(vsam_byte1,2,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' WRITECHECK'  /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOWRITECHK'  /*                               */
If (Substr(vsam_byte1,3,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' IMBED'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOIMBED'     /*                               */
If (Substr(vsam_byte1,4,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' REPLICATE'   /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREPLICAT'  /*                               */
If (entype /= 'INDEX') Then          /*                               */
 If (Substr(vsam_byte1,8,1) = '1') Then /*                            */
  vsam_attr = vsam_attr' SPANNED'     /*                              */
 Else                                 /*                              */
  vsam_attr = vsam_attr' NONSPANNED'  /*                              */
If (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */
 vsam_vvds = 'Y'                     /* Set VVDS flag                 */
Else                                 /*                               */
 vsam_vvds = 'N'                     /* Set VVDS flag off             */
vsam_attr = Strip(vsam_attr,B)       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* For execution in batch, please ensure that a PDS'
   Say ' **(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say ' **(Error-1)* For execution in foreground TSO, please ensure'
    Say ' **(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                "Blksize(1330) Recfm(F,B) New Reuse"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    x = Listdd(REPORT)               /*                               */
    dsn = sysdsname                  /*                               */
   End                               /*                               */
Else                                 /*                               */
 dsn = sysdsname                     /* get dataset name from DD      */
If (sysvolume = '*JES**') Then       /*                               */
 Do                                  /*                               */
  Say ' **(Warning-1)* For execution in batch, it is recommended that'
  Say ' **(Warning-2)* a PDS is pre-allocated to DD name REPORT.'
  Say ' **(Warning-3)* Processing will continue with sequential output.'
  outflag = 'JES'                    /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDD:                                     /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = Left('CATALOG',10) csicname /*                            */
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = Left(entype,10) entname dscrdt2 volsers /*                */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

./ ADD NAME=CSIGDS   0109-16007-16007-1234-00899-00905-00000-APLKS   17
/* REXX - CSIGDS : Minimum clean CSI utilisation code                 */
/**********************************************************************/
/* CSICODE : Uses Catalog Search Interface (CSI)                      */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 12/01/2002 - Alastair Gray - Original version            */
/* 1.0.1   - 15/01/2002 - Alastair Gray - Added DSCRDT2 field         */
/* 1.0.2   - 22/01/2002 - Alastair Gray - Re-ordered fields           */
/* 1.0.3   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.0.4   - 21/06/2002 - Alastair Gray - Checked work area required  */
/* 1.0.5   - 08/08/2002 - Alastair Gray - Updated device list         */
/* 1.0.6   - 20/09/2002 - Alastair Gray - Updates for CSICODEV        */
/* 1.0.7   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.0.8   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.0.9   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/* 1.1.5   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.1.6   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.1.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */
/* 1.1.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */
/* 1.1.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */
/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/*         - 01/07/2016 - Larry Slaten  - GDS/GDG selection           */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This provides a clean base for further CSI development work.    */
/*                                                                    */
/* 2. This processes all catalogs and lists all entries.              */
/*                                                                    */
/* 3. One return codes is 'special' :                                 */
/*    RC=44 , Reason=14                                               */
/*    This relates to entries of greater than 65535 characters.       */
/*    If you get this entry, then you need to enable fullword         */
/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */
/* 3. The output is written to members of a PDS allocated to REPORT   */
/*    or in batch JES sequential output is allowed.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say ' **(Error-1)* No TSO environment and no OMVS environment.'
  Say ' **(Error-2)* CSIALL cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
Arg vals                             /* Get passed arguments          */
argnum = 0                           /*                               */
Do i = 1 to Words(vals)              /* loop thru arguments           */
 testarg = Strip(Word(vals,i),B,"'") /* remove inverted commas        */
 Upper testarg                       /* convert to upper case         */
 Select                              /*                               */
  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */
   Do                                /*                               */
    debug = Substr(testarg,7,1)      /* get debug value               */
    Say ' **(Debug)*** Debug level 'debug' enabled.'
   End                               /*                               */
  When (testarg = '?') Then          /*                               */
   Do                                /*                               */
    Say " CSIGDS has no normal external parms" /*                      */
    Say "  To use simply specify 'CSIGDS' it will identify and use the "
    Say "  master catalog."           /*                               */
    Signal FINISH                    /*                               */
   End                               /*                               */
  Otherwise NOP                      /*                               */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat.1 = ' '                          /* Set catalog name              */
flt   = '**'                         /* Set the filter                */
typ   = 'H'                          /* Set entry types required      */
ct1   = ' '                          /* Set for 1 catalog only        */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
member = 'GDGGDS'                    /* processing GDG/GDS report     */
x = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */
Call WRITE_MEMBER                    /* write-out member              */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"sysdsname"') VOLUME("sysvolume")"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
/**********************************************************************/
bcp = mvsvar('sysmvs')               /*                               */
lev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */
If (lev > 609) Then                  /* os/390 R10 and up for fullword*/
 csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/
Else                                 /*                               */
 csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword used        */
 Say ' **(csi)***** Fullword processing selected'
Else                                 /* check if fullword used        */
 Say ' **(csi)***** Halfword processing - default'
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '000B'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */
csifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */
csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */
csifld08 = Left('CATTR   ',8)        /* Attributes page and swap      */
csifld09 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld10 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld11 = Left('FILESEQ ',8)        /* File Sequence number          */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csioptns
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
csifield = csifield||csifld11
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say ' **(Error-1)* CSI processing.'
   Say ' **(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* Work Area defined  = 'csiusrln
   Say ' **(Error-2)* Work Area used     = 'csiusdln
   Say ' **(Error-3)* Work Area required = 'csireqln
   Say ' **(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  If (debug = 2) Then                /*                               */
   Do                                /*                               */
    Say ' off=<'off'>'
    Say ' entry =<'Substr(dwork,off,150)'>'
    Say ' entry X=<'C2x(Substr(dwork,off,150))'>'
   End                               /*                               */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say ' **(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */
    Select                           /*                               */
     When (csienter = '1') Then      /*                               */
      Do                             /*                               */
       Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     When (csiedata = '0') Then      /*                               */
      Do                             /*                               */
       Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say ' **(Error-2)* No data returned'
       Say ' **(Error-3)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     Otherwise                       /*                               */
      Do                             /*                               */
       If (csioptns = 'F') Then      /* check if fullword requested   */
        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */
       Else                          /* otherwise (default halfword)  */
        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */
       Call ENTRY                    /* Execute entry processing      */
       plus = 46 + csitotln          /* length for normal entry       */
      End                            /*                               */
    End                              /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword requested   */
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */
  e_pos = 12                         /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say " e_off="e_off
    Say " C=<"Substr(dwork,e_off,200)">"
    Say " X=<"C2x(Substr(dwork,e_off,200))">"
    Say " o_fld.1="o_fld.1",hex="C2x(o_flds.1)
    Say " l_fld.1="l_fld.1",hex="C2x(l_flds.1)
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */
   e_pos = e_pos + 4                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say " o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds)
     Say " l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds)
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
Else                                 /* otherwise (default halfword)  */
/**********************************************************************/
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */
  e_pos = 6                          /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say " e_off="e_off
    Say " C=<"Substr(dwork,e_off,200)">"
    Say " X=<"C2x(Substr(dwork,e_off,200))">"
    Say " o_fld.1="o_fld.1",hex="C2x(o_flds.1)
    Say " l_fld.1="l_fld.1",hex="C2x(l_flds.1)
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */
   e_pos = e_pos + 2                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say " o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds)
     Say " l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds)
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
gdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */
gdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */
dscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */
cattr    = Substr(dwork,o_fld.8,l_fld.8)   /* attribs page and swap   */
devtyp   = Substr(dwork,o_fld.9,l_fld.9)   /* device type             */
volser   = Substr(dwork,o_fld.10,l_fld.10) /* volume serial           */
fileseq  = Substr(dwork,o_fld.11,l_fld.11) /* file sequence           */
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
vsam_attr = ''                           /* initialise vsam attributes*/
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'CATTR') > 0) Then    /*                           */
 Call FLD_CATTR                          /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'GDGATTR') > 0) Then  /*                           */
 Call FLD_GDGATTR                        /*                           */
If (Index(csifield,'GDGLIMIT') > 0) Then /*                           */
 Call FLD_GDGLIMIT                       /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'DSCRDT2') > 0) Then  /*                           */
 Call FLD_DSCRDT2                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
  Say ' **(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_TYPE     - Process TYPE     field                              */
/**********************************************************************/
FLD_TYPE:                            /* TYPE     field processing   ##*/
type_list = ''                       /* loop through type             */
Do z = 1 to Length(type)             /* loop through type             */
 astype = Substr(type,z,1)           /* decode type flag              */
 Select                              /* decode type flag              */
  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */
  When (astype = 'D') Then astype = 'DATA'     /*                     */
  When (astype = 'I') Then astype = 'INDEX'    /*                     */
  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */
  When (astype = 'H') Then astype = 'GDS'      /*                     */
  When (astype = 'B') Then astype = 'GDG'      /*                     */
  When (astype = 'R') Then astype = 'PATH'     /*                     */
  When (astype = 'G') Then astype = 'AIX'      /*                     */
  When (astype = 'X') Then astype = 'ALIAS'    /*                     */
  When (astype = 'U') Then astype = 'UCAT'     /*                     */
  Otherwise                          /*                               */
   Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
   Say ' **(Error-2)* Entry type ='astype' X=<'C2x(astype)'>'
   astype = '@'                      /* unknown type                  */
 End                                 /*                               */
 type_list = type_list' 'astype      /*                               */
End                                  /*                               */
type = Strip(type_list,L)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGLIMIT - Process GDGLIMIT field                              */
/**********************************************************************/
FLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/
gdglimit = X2d(C2x(gdglimit))        /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGATTR  - Process GDGATTR  field                              */
/**********************************************************************/
FLD_GDGATTR:                         /* GDGATTR  field processing   ##*/
gdgattr = X2b(C2x(gdgattr))          /*                               */
If (Substr(gdgattr,1,1) = '1') Then  /*                               */
 gdg_emp = 'EMPTY'                   /*                               */
Else                                 /*                               */
 gdg_emp = 'NOEMPTY'                 /*                               */
If (Substr(gdgattr,2,1) = '1') Then  /*                               */
 gdg_scr = 'SCRATCH'                 /*                               */
Else                                 /*                               */
 gdg_scr = 'NOSCRATCH'               /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DSCRDT2  - Process DSCRDT2  field                              */
/**********************************************************************/
FLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/
If (Substr(dscrdt2,1,2) /= 'FFFF'X) Then
 Do                                  /*                               */
  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */
  yy    = Substr(yyddd,1,2)          /*                               */
  ddd   = Substr(yyddd,3,3)          /*                               */
  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */
  If (cent = '00') Then              /*                               */
   yyyy    = yy + 1900               /*                               */
  Else                               /*                               */
   yyyy    = yy + 2000               /*                               */
  If (yyyy = '1900') Then            /* correct for '00'              */
   yyyy = '2000'                     /*                               */
  savcrdt2 = dscrdt2
  dscrdt2 = yyyy'.'ddd               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_CATTR    - Process CATTR    field                              */
/**********************************************************************/
FLD_CATTR:                           /* CATTR    field processing   ##*/
cattr = X2b(C2x(cattr))              /*                               */
If (entype = 'CLUSTER') Then         /*                               */
 Do                                  /*                               */
  If (Substr(cattr,8,1) = '1') Then  /*                               */
   entype = 'PAGESPACE'              /*                               */
  If (Substr(cattr,7,1) = '1') Then  /*                               */
   pageswap = 'SWAP'                 /*                               */
  Else                               /*                               */
   pageswap = 'NOSWAP'               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP   field processing   ##*/
devices = ''                         /* initialise devices            */
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_model  = Substr(device,1,1)       /* get model byte                */
 d_option = Substr(device,2,1)       /* get option byte               */
 d_class  = Substr(device,3,1)       /* get class byte                */
 d_device = Substr(device,4,1)       /* get device byte               */
 Select                              /*                               */
  When (d_class = '80'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'TAPE'               /* Tape device                   */
    Select                           /*                               */
     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/
     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */
     When (d_device = '05'x) Then dev_type = '3410' /*                */
     When (d_device = '06'x) Then dev_type = '8809' /*                */
     When (d_device = '07'x) Then dev_type = '3430' /*                */
     When (d_device = '08'x) Then dev_type = '7340' /*                */
     When (d_device = '09'x) Then dev_type = '9374' /*                */
     When (d_device = '80'x) Then dev_type = '3480' /*                */
     When (d_device = '81'x) Then dev_type = '3490' /*                */
     When (d_device = '83'x) Then dev_type = '3590' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End                               /*                               */
  When (d_class = '20'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'DASD'               /* DASD device                   */
    Select                           /*                               */
     When (d_device = '04'x) Then dev_type = '9345' /*                */
     When (d_device = '09'x) Then dev_type = '3330' /*                */
     When (d_device = '0A'x) Then dev_type = '3340' /*                */
     When (d_device = '0B'x) Then dev_type = '3350' /*                */
     When (d_device = '0C'x) Then dev_type = '3375' /*                */
     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */
     When (d_device = '0E'x) Then dev_type = '3380' /*                */
     When (d_device = '0F'x) Then dev_type = '3390' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
  Otherwise                          /*                               */
   Do                                /*                               */
    dev_class = 'UNKN'               /* Unknown device                */
    Select                           /*                               */
     When (device = '00000000'x) Then dev_type = '0000' /*            */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say ' **(Error-1)* Device type processing for 'Strip(entname,T)
      Say ' **(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
 End                                 /*                               */
 devices = devices||' '||Left(dev_type,8) /* build device list        */
End                                  /*                               */
devices = Strip(devices,B,' ')       /* clean up device list          */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */
/**********************************************************************/
FLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/
Return                               /* duplicates ATTR1              */
vsamreus = X2b(C2x(vsamreus))        /* show binary flags             */
If (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */
 vsam_attr = vsam_attr' REUSE'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREUSE'     /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMTYPE - Process VSAMTYPE field                              */
/**********************************************************************/
FLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/
vsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */
vsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */
Select                               /*                               */
 When (Substr(vsam_byte1,1,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'KSDS'                /*                               */
   vsam_attr = vsam_attr' INDEXED'   /*                               */
  End                                /*                               */
 When (Substr(vsam_byte1,7,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'RRDS'                /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,6,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'LDS'                 /*                               */
   vsam_attr = vsam_attr' LINEAR'    /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,8,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'VRRDS'               /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 Otherwise                           /*                               */
  Do                                 /*                               */
   vsam_type = 'ESDS'                /*                               */
   If (entype /= 'INDEX') Then       /*                               */
    vsam_attr = vsam_attr' NONINDEXED'/*                              */
  End                                /*                               */
End                                  /*                               */
If (Substr(vsam_byte1,2,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' WRITECHECK'  /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOWRITECHK'  /*                               */
If (Substr(vsam_byte1,3,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' IMBED'       /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOIMBED'     /*                               */
If (Substr(vsam_byte1,4,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' REPLICATE'   /*                               */
Else                                 /*                               */
 vsam_attr = vsam_attr' NOREPLICAT'  /*                               */
If (entype /= 'INDEX') Then          /*                               */
 If (Substr(vsam_byte1,8,1) = '1') Then /*                            */
  vsam_attr = vsam_attr' SPANNED'     /*                              */
 Else                                 /*                              */
  vsam_attr = vsam_attr' NONSPANNED'  /*                              */
If (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */
 vsam_vvds = 'Y'                     /* Set VVDS flag                 */
Else                                 /*                               */
 vsam_vvds = 'N'                     /* Set VVDS flag off             */
vsam_attr = Strip(vsam_attr,B)       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* For execution in batch, please ensure that a PDS'
   Say ' **(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say ' **(Error-1)* For execution in foreground TSO, please ensure'
    Say ' **(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                "Blksize(1330) Recfm(F,B) New Reuse"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    x = Listdd(REPORT)               /*                               */
    dsn = sysdsname                  /*                               */
   End                               /*                               */
Else                                 /*                               */
 dsn = sysdsname                     /* get dataset name from DD      */
If (sysvolume = '*JES**') Then       /*                               */
 Do                                  /*                               */
  Say ' **(Warning-1)* For execution in batch, it is recommended that'
  Say ' **(Warning-2)* a PDS is pre-allocated to DD name REPORT.'
  Say ' **(Warning-3)* Processing will continue with sequential output.'
  outflag = 'JES'                    /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDD:                                     /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = ' 'Left('CATALOG',10) csicname
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = ' 'Left(entype,10) entname dscrdt2 Right(gdglimit,4),
       dev_class volsers
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

./ ADD NAME=CSITAPE  0155-02171-16007-1119-00640-00399-00000-APLKS   14
/* REXX - CSITAPE : Stripped CSICODE just for Tape datasets           */
/**********************************************************************/
/* CSITAPES : Uses Catalog Search Interface (CSI)                     */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 20/06/2002 - Alastair Gray - Original version            */
/* 1.0.1   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.0.2   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.0.3   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.0.4   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/* 1.1.5   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.1.6   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.1.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */
/* 1.1.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */
/* 1.1.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */
/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/*         - 10/07/2015 - LKS - Added more ALLOC error handling       */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This processes all catalogs and lists all tape entries.         */
/*                                                                    */
/* 2. The output is written to members of a PDS allocated to REPORT   */
/*    or in batch JES sequential output is allowed.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say ' **(Error-1)* No TSO environment and no OMVS environment.'
  Say ' **(Error-2)* CSITAPE cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
Arg vals                             /* Get passed arguments          */
argnum = 0                           /*                               */
Do i = 1 to Words(vals)              /* loop thru arguments           */
 testarg = Strip(Word(vals,i),B,"'") /* remove inverted commas        */
 Upper testarg                       /* convert to upper case         */
 Select                              /*                               */
  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */
   Do                                /*                               */
    debug = Substr(testarg,7,1)      /* get debug value               */
    Say ' **(Debug)*** Debug level 'debug' enabled.'
   End                               /*                               */
  When (testarg = '?') Then          /*                               */
   Do                                /*                               */
    Say "CSITAPE has no normal external parms"   /*                   */
    Say " To use simply specify 'CSITAPE' it will identify and use the"
    Say " master catalog."           /*                               */
    Signal FINISH                    /*                               */
   End                               /*                               */
  Otherwise NOP                      /*                               */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat.1 = ' '                          /* Set catalog name              */
flt   = '**'                         /* Set the filter                */
typ   = 'AH'                         /* Set entry types required      */
ct1   = ' '                          /* Set for 1 catalog only        */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
member = 'TAPES'                     /* processing TAPE report        */
x = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */
Call WRITE_MEMBER                    /* write-out member              */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"sysdsname"') VOLUME("sysvolume")"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
/**********************************************************************/
bcp = mvsvar('sysmvs')               /*                               */
lev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */
If (lev > 609) Then                  /* os/390 R10 and up for fullword*/
 csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/
Else                                 /*                               */
 csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword used        */
 Say ' **(csi)***** Fullword processing selected'
Else                                 /* check if fullword used        */
 Say ' **(csi)***** Halfword processing - default'
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '0006'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld06 = Left('VOLSER  ',8)        /* Volume serial number          */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csioptns
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say ' **(Error-1)* CSI processing.'
   Say ' **(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* Work Area defined  = 'csiusrln
   Say ' **(Error-2)* Work Area used     = 'csiusdln
   Say ' **(Error-3)* Work Area required = 'csireqln
   Say ' **(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  If (debug = 2) Then                /*                               */
   Do                                /*                               */
    Say ' off=<'off'>'
    Say ' entry =<'Substr(dwork,off,150)'>'
    Say ' entry X=<'C2x(Substr(dwork,off,150))'>'
   End                               /*                               */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say ' **(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */
    Select                           /*                               */
     When (csienter = '1') Then      /*                               */
      Do                             /*                               */
       Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say ' **(Error-2)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     When (csiedata = '0') Then      /*                               */
      Do                             /*                               */
       Say ' **(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say ' **(Error-2)* No data returned'
       Say ' **(Error-3)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     Otherwise                       /*                               */
      Do                             /*                               */
       If (csioptns = 'F') Then      /* check if fullword requested   */
        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */
       Else                          /* otherwise (default halfword)  */
        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */
       Call ENTRY                    /* Execute entry processing      */
       plus = 46 + csitotln          /* length for normal entry       */
      End                            /*                               */
    End                              /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword requested   */
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */
  e_pos = 12                         /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say " e_off="e_off
    Say " C=<"Substr(dwork,e_off,200)">"
    Say " X=<"C2x(Substr(dwork,e_off,200))">"
    Say " o_fld.1="o_fld.1",hex="C2x(o_flds.1)
    Say " l_fld.1="l_fld.1",hex="C2x(l_flds.1)
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */
   e_pos = e_pos + 4                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say " o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds)
     Say " l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds)
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
Else                                 /* otherwise (default halfword)  */
/**********************************************************************/
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */
  e_pos = 6                          /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say " e_off="e_off
    Say " C=<"Substr(dwork,e_off,200)">"
    Say " X=<"C2x(Substr(dwork,e_off,200))">"
    Say " o_fld.1="o_fld.1",hex="C2x(o_flds.1)
    Say " l_fld.1="l_fld.1",hex="C2x(l_flds.1)
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */
   e_pos = e_pos + 2                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say " o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds)
     Say " l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds)
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
devtyp   = Substr(dwork,o_fld.5,l_fld.5)   /* device type             */
volser   = Substr(dwork,o_fld.6,l_fld.6)   /* volume serial           */
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
If (Substr(volser,1,6) = 'MIGRAT') Then  /* check if HSM migrat tape  */
 Return                                  /*                           */
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (dev_class /= 'TAPE') Then            /* reject non-tapes          */
 Return                                  /* save processing           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP - Process DEVTYP field to translate data                */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP field processing     ##*/
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_class  = Substr(device,3,1)       /* get class byte                */
 Select                              /*                               */
  When (d_class = '80'x) Then dev_class = 'TAPE' /* Tape device       */
  When (d_class = '20'x) Then dev_class = 'DASD' /* DASD device       */
  Otherwise NOP                      /*                               */
 End                                 /*                               */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say ' **(Error-1)* Entry type processing for 'Strip(entname,T)
  Say ' **(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
   If RC <> 0 Then                                            /* LKS */
     Do;                                                      /* LKS */
       Say " **(Error-1)* Allocation failed for MEMOT"        /* LKS */
       Signal FINISH                                          /* LKS */
     End;                                                     /* LKS */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
    If Result <> 0 Then                                       /* LKS */
      Do;                                                     /* LKS */
        Say " **(Error-1)* Allocation failed for MEMOT"       /* LKS */
        Signal FINISH                                         /* LKS */
      End;                                                    /* LKS */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say ' **(Error-1)* For execution in batch, please ensure that a PDS'
   Say ' **(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say ' **(Error-1)* For execution in foreground TSO, please ensure'
    Say ' **(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                "Blksize(1330) Recfm(F,B) New Reuse"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    x = Listdd(REPORT)               /*                               */
    dsn = sysdsname                  /*                               */
   End                               /*                               */
Else                                 /*                               */
 dsn = sysdsname                     /* get dataset name from DD      */
If (sysvolume = '*JES**') Then       /*                               */
 Do                                  /*                               */
  Say ' **(Warning-1)* For execution in batch, it is recommended that'
  Say ' **(Warning-2)* a PDS is pre-allocated to DD name REPORT.'
  Say ' **(Warning-3)* Processing will continue with sequential output.'
  outflag = 'JES'                    /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDD:                                     /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = ' 'Left('CATALOG',10) csicname
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  If (Substr(volser,1,6) = 'MIGRAT') Then/* check if HSM migrat tape  */
   Return                            /*                               */
  If (dev_class /= 'TAPE') Then      /* reject non-tapes              */
   Return                            /* save processing               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = ' 'Left(entype,10) entname volsers
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

./ ADD NAME=DASDVOLS 0106-15230-15232-1336-00434-00425-00000-APLKS   33
/* REXX                                                               */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/* DASDVOLS                                                           */
/*    PURPOSE: READS TYPE V AND C RECORDS FOR VOLUME DETAIL REPORT    */
/*             AND STORAGE GROUP SUMMARY REPORT, READS TYPE T RECORDS */
/*             FOR DFHSM TAPE SUMMARY REPORT                          */
/*                                                                    */
/*             DETAIL REPORT BY VOLSER CONTAINS THE FOLLOWING:        */
/*                DATE DCOLLECT RUN                                   */
/*                DATE DFHSM DATA COLLECT                             */
/*                VOLSER                                              */
/*                VOLUME CAPACITY IN KB                               */
/*                KB ALLOCATED ON VOLUME                              */
/*                FRAGMENTATION INDEX                                 */
/*                TARGET THRESHOLD                                    */
/*                TRIGGER THRESHOLD                                   */
/*                BEFORE OCCUPANCY                                    */
/*                AFTER OCCUPANCY                                     */
/*                PERCENT ELGIBLE TO MIGRATE                          */
/*             SUMMARY TOTALS BY STORAGE GROUP, SMS AND NON-SMS:      */
/*                CAPACITY IN KB                                      */
/*                KB ALLOCATED                                        */
/*                PERCENT ALLOCATED                                   */
/*                TARGET THRESHOLD (IF STORAGE GROUP)                 */
/*                TRIGGER THRESHOLD (IF STORAGE GROUP)                */
/*             SUMMARY TOTALS FOR DFHSM TAPE:                         */
/*                BACKUP: TOTAL, FULL, PARTIAL AND EMPTY              */
/*                DUMP: TOTAL, FULL, PARTIAL AND EMPTY                */
/*                MIGRATE: TOTAL, FULL, PARTIAL AND EMPTY             */
/*    INPUT:   USERID()..DCOLLECT.RECC                                */
/*             TYPE C RECORDS                                         */
/*             USERID()..DCOLLECT.RECV                                */
/*             TYPE V RECORDS                                         */
/*             USERID()..DCOLLECT.RECT                                */
/*             TYPE T RECORDS                                         */
/*    OUTPUT:  USERID()..DCOLLECT.CAPACITY.DCCYYDDD                   */
/*    PRESORT: FOR TYPE C RECORDS                                     */
/*             SORT FIELDS=(29,6,CH,A,35,4,CH,D)                      */
/*             INCLUDE COND=(9,2,CH,EQ,C'C ')                         */
/*             RECORD TYPE=V,LENGTH=(264,,264)                        */
/*                                                                    */
/*             FOR TYPE V RECORDS                                     */
/*             SORT FIELDS=(87,8,CH,A,29,6,CH,A)                      */
/*             INCLUDE COND=(9,2,CH,EQ,C'V ')                         */
/*             RECORD TYPE=V,LENGTH=(264,,264)                        */
/*                                                                    */
/*             FOR TYPE T RECORDS                                     */
/*             SORT FIELDS=(29,6,CH,A)                                */
/*             INCLUDE COND=(9,2,CH,EQ,C'T ')                         */
/*             RECORD TYPE=V,LENGTH=(264,,264)                        */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT V RECORDS)     */
/***********************************************************/
 TRACE N
/* INNAME = "'SMS.UMB.DCOLLECT.RECTYPV'"  */
 INNAME = "'"USERID()".DCOLLECT.RECV'"
 "ALLOC DD(INFILE) DA("INNAME") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT C RECORDS)     */
/***********************************************************/
/* INNAME2 = "'SMS.UMB.DCOLLECT.RECTYPC'" */
 INNAME2 = "'"USERID()".DCOLLECT.RECC'"
 "ALLOC DD(INFILE2) DA("INNAME2") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME2') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT T RECORDS)     */
/***********************************************************/
/* INNAME = "'SMS.UMB.DCOLLECT.RECTYPT'" */
 INNAME3 = "'"USERID()".DCOLLECT.RECT'"
 "ALLOC F(INFILE3) DA("INNAME3") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME3') FAILED'
    EXIT 8
    END

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 OUT_COUNT = 0
 TOT_ALLOC_KB = 0
 SMS_ALLOC_KB = 0
 TOT_AVAIL_KB = 0
 SMS_AVAIL_KB = 0
 STG_ALLOC_KB. = 0
 STG_AVAIL_KB. = 0
 NONSMS_ALLOC_KB = 0
 NONSMS_AVAIL_KB = 0
 VOLSER = '      '
 COL_DATE. = '      '
 TARGET.  = '   '
 TRIGGER. = '   '
 TARGET_STG.  = '   '
 TRIGGER_STG. = '   '
 B4.      = '  '
 AFTER.   = '  '
 MIGELG.  = '  '
 STGRP_NAMES    = ' '

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE C RECORDS                  */
/***********************************************************/
 "EXECIO * DISKR INFILE2 (FINIS STEM RECORD."

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 DO K = 1 TO RECORD.0
    PARSE VAR RECORD.K 1 . 25 UCVOLSR 31 UCCOLDT 35 UCFLAG1,
      36 . 37 UCTOTAL 41 UCTGOCC 42 UCTROCC 43 UCBFOCC,
      44 UCAFOCC 45 UCNOMIG 46 UCNINTV 47 UCINTVM 48
    IF UCVOLSR <> VOLSER THEN DO
       VOLSER = UCVOLSR
       COL_DATE.VOLSER = LEFT(C2X(UCCOLDT),7)
       TARGET.VOLSER  = C2D(UCTGOCC)
       TRIGGER.VOLSER = C2D(UCTROCC)
       B4.VOLSER      = C2D(UCBFOCC)
       AFTER.VOLSER   = C2D(UCAFOCC)
       MIGELG.VOLSER  = C2D(UCNOMIG)
       END
 END

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE V RECORDS                  */
/***********************************************************/
 "EXECIO * DISKR INFILE (FINIS STEM RECORD."

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 DO K = 1 TO RECORD.0
    PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
       13 DCUTIME 17 DCUDATE 21 .
    PARSE VAR RECORD.K 1 . 25 DCVVOLSR 31 DCVFLAG1,
       32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,
       45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,
       65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .
    DATE = LEFT(C2X(DCUDATE),7)
/* ADDING SOME CODE */
    ODATE = DATE('O',SUBSTR(DATE,3,5),'J')
/* FINISHED ADDING */
    IF K=1 THEN DO
       OUT_COUNT = OUT_COUNT + 1
       OUT_LINE.OUT_COUNT = "DCOLLECT RUN ON:" DATE ODATE
       OUT_COUNT = OUT_COUNT + 1
       OUT_LINE.OUT_COUNT = "  "
       CALL OUTHEAD
       END
    VOLSER = DCVVOLSR
    IF BITAND(DCVFLAG1,'03'X) = '03'X  THEN DO  /* IS IT SMS?         */
       SMS_ALLOC_KB = SMS_ALLOC_KB + C2D(DCVALLOC)
       SMS_AVAIL_KB = SMS_AVAIL_KB + C2D(DCVVLCAP)
       IF DCVSGTCL = '        ' THEN DCVSGTCL = 'NO_GROUP'
       END
    SELECT
       WHEN SUBSTR(VOLSER,1,2) = 'ML' THEN
         TARGTRIG = (TARGET.VOLSER||"/"||TRIGGER.VOLSER)
       WHEN DCVSGTCL = '      ' | DCVSGTCL = 'NO_GROUP' THEN
         TARGTRIG = '  '
       OTHERWISE
         TARGTRIG = (TARGET.VOLSER||"/"||TRIGGER.VOLSER)
    END
/***********************************************************/
/* BUILD LIST OF STORAGE GROUP NAMES                       */
/*  AND PROCESS KBYTES INFORMATION BY STORAGE GROUP        */
/***********************************************************/

    IF DCVSGTCL <> '      ' THEN DO
       IF WORDPOS(DCVSGTCL,STGRP_NAMES,1) = 0 THEN DO
          STGRP_NAMES = STGRP_NAMES DCVSGTCL
          L = WORDPOS(DCVSGTCL,STGRP_NAMES,1)
          TARGET_STG.L = TARGET.DCVVOLSR
          TRIGGER_STG.L = TRIGGER.DCVVOLSR
          END
       L = WORDPOS(DCVSGTCL,STGRP_NAMES,1)
       STG_ALLOC_KB.L = STG_ALLOC_KB.L + C2D(DCVALLOC)
       STG_AVAIL_KB.L = STG_AVAIL_KB.L + C2D(DCVVLCAP)
       END
    ELSE DO
       NONSMS_ALLOC_KB = NONSMS_ALLOC_KB + C2D(DCVALLOC)
       NONSMS_AVAIL_KB = NONSMS_AVAIL_KB + C2D(DCVVLCAP)
       END

/***********************************************************/
/* BUILD TOTALS                                            */
/***********************************************************/

    TOT_ALLOC_KB = TOT_ALLOC_KB + C2D(DCVALLOC)
    TOT_AVAIL_KB = TOT_AVAIL_KB + C2D(DCVVLCAP)

/***********************************************************/
/* PUT OUT VOLUME DETAIL RECORD                            */
/***********************************************************/

    OUT_COUNT = OUT_COUNT + 1
    OUT_LINE.OUT_COUNT = CENTER(COL_DATE.VOLSER,7),
        LEFT(DCVSGTCL,8),
        RIGHT(DCVVOLSR,6),
        RIGHT(C2D(DCVVLCAP),10),
        RIGHT(C2D(DCVALLOC),10),
        RIGHT(C2D(DCVFRAGI),6),
        CENTER(TARGTRIG,7),
        RIGHT(B4.VOLSER,6),
        RIGHT(AFTER.VOLSER,6),
        RIGHT(MIGELG.VOLSER,4)
 END

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
/* OUTNAME = "'SMS.PMB.DCOLLECT.CAPACITY.D"||DATE||"'" */
 OUTNAME = "'"USERID()".DCOLLECT.CAPACITY.D"||DATE||"'"
 "ALLOC DSNAME("OUTNAME")",
     "DSORG(PS) LRECL(80) RECFM(F B) ",
     "TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)"
  IF RC <> 0 THEN DO
     SAY  'ALLOC OF ('OUTNAME') FAILED'
     EXIT 12
     END

OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("++++",80,"+")
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER("    ",7),
    LEFT("      ",8),
    RIGHT("     ",6),
    RIGHT("CAPACITY",12),
    RIGHT("ALLOCATED",12),
    CENTER("PERCENT",9),
    CENTER("TARGET/",7)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER("    ",7),
    LEFT("      ",8),
    RIGHT("     ",6),
    RIGHT("IN KBYTES",12),
    RIGHT("IN KBYTES",12),
    CENTER("ALLOCATED",9),
    CENTER("TRIGGER",7)

/***********************************************************/
/* PUT OUT TOTALS BY STORAGE GROUP, SMS AND GRAND TOTAL    */
/***********************************************************/

L = WORDS(STGRP_NAMES)
DO K = 1 TO L
   PRCNT_ALC = FORMAT(((STG_ALLOC_KB.K/STG_AVAIL_KB.K)*100),3,1)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER('  ',7),
       RIGHT(WORD(STGRP_NAMES,K),8),
       LEFT("   ",6),
       RIGHT(STG_AVAIL_KB.K,12),
       RIGHT(STG_ALLOC_KB.K,12),
       RIGHT(PRCNT_ALC,9),
       CENTER(TARGET_STG.K||"/"||TRIGGER_STG.K,7)
END

PRCNT_ALC = FORMAT(((SMS_ALLOC_KB/SMS_AVAIL_KB)*100),3,1)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER('  ',7),
    RIGHT("SMS",8),
    LEFT("    ",6),
    RIGHT(SMS_AVAIL_KB,12),
    RIGHT(SMS_ALLOC_KB,12),
    RIGHT(PRCNT_ALC,9)

PRCNT_ALC = FORMAT(((NONSMS_ALLOC_KB/NONSMS_AVAIL_KB)*100),3,1)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER('  ',7),
    RIGHT("NON-SMS",8),
    LEFT("    ",6),
    RIGHT(NONSMS_AVAIL_KB,12),
    RIGHT(NONSMS_ALLOC_KB,12),
    RIGHT(PRCNT_ALC,9)

PRCNT_ALC = FORMAT(((TOT_ALLOC_KB/TOT_AVAIL_KB)*100),3,1)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER('  ',7),
    RIGHT("TOTAL",8),
    LEFT("     ",6),
    RIGHT(TOT_AVAIL_KB,12),
    RIGHT(TOT_ALLOC_KB,12),
    RIGHT(PRCNT_ALC,9)

/***********************************************************/
/* PROCESS EACH T RECORD UNTIL END-OF-FILE REACHED         */
/***********************************************************/
 UTALL = 0
 UTTOT = 0
 UTTOTFULL = 0
 UTTOTPART = 0
 UTTOTEMP = 0
 EOF = 'NO'
 CALL OUTHEADT
 TRACE N
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE3"
   IF RC <> 0 THEN
      EOF = 'YES'
   ELSE DO
      PARSE PULL RECORD
/***********************************************************/
/* DETERMINE THE RECORD TYPE (M,B,C,T,D,A,V)               */
/***********************************************************/
      DCURCTYP=SUBSTR(RECORD,5,2)
         SELECT
/***********************************************************/
/* PROCESS TAPE     DATA SET INFORMATION RECORD            */
/***********************************************************/
         WHEN(DCURCTYP='T ') THEN DO
                             CALL DCTRECP
                             IF UTSTYPE = B THEN TYPE = "BACKUP "
                             IF UTSTYPE = M THEN TYPE = "MIGRATE"
                             IF UTSTYPE = D THEN TYPE = "DUMP   "
                             UTALL = UTFULL + UTPART + UTEMPTY
                             UTTOT = UTALL + UTTOT
                             UTTOTFULL = UTFULL + UTTOTFULL
                             UTTOTPART = UTPART + UTTOTPART
                             UTTOTEMP= UTEMPTY + UTTOTEMP
                             CALL OUTDET
                             END
         OTHERWISE
         END
      END
 END
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("TOTAL",9),
    RIGHT(UTTOT,7),
    RIGHT(UTTOTFULL,7),
    RIGHT(UTTOTPART,7),
    RIGHT(UTTOTEMP,7)

"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE ALL"
EXIT

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                                    */
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER("    ",7),
       LEFT("      ",8),
       RIGHT("      ",6),
       RIGHT("VOLUME",10),
       RIGHT("VOLUME",10),
       RIGHT("      ",6),
       RIGHT("       ",7),
       CENTER("      ",6),
       CENTER("     ",6),
       CENTER("%",4)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER("COLLECT",7),
       LEFT("STORAGE",8),
       RIGHT("      ",6),
       RIGHT("CAPACITY",10),
       RIGHT("ALLOCATED",10),
       CENTER("FRAG",6),
       CENTER("TARGET/",7),
       CENTER("BEFORE",6),
       CENTER("AFTER",6),
       CENTER("MIGR",4)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER("DATE",7),
       LEFT("GROUP",8),
       RIGHT("VOLSER",6),
       RIGHT("IN KBYTES",10),
       RIGHT("IN KBYTES",10),
       CENTER("INDEX",6),
       CENTER("TRIGGER",7),
       CENTER("OCCUPY",6),
       CENTER("OCCUPY",6),
       CENTER("ELG",4)
   RETURN

/***********************************************************/
/* PARSE   TAPE CAPACITY PLANNING RECORD                   */
/***********************************************************/
 DCTRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
      13 DCUTIME 17 DCUDATE 21 . ,
      25 UTSTYPE 26 . ,
      29 UTFULL 33 UTPART 37 UTEMPTY 41
       UTFULL = C2D(UTFULL)
       UTPART = C2D(UTPART)
       UTEMPTY = C2D(UTEMPTY)
 RETURN

/***********************************************************/
/*   PRINT OUT TAPE HEADINGS                               */
/***********************************************************/
OUTHEADT:
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT("++++",80,"+")
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT("HSM TAPES",9),
      RIGHT("TOTAL",7),
      RIGHT("FULL",7),
      RIGHT("PARTIAL",7),
      RIGHT("EMPTY",7)
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT("---------",9),
      RIGHT("-------",7),
      RIGHT("-------",7),
      RIGHT("-------",7),
      RIGHT("-------",7)
  RETURN

/***********************************************************/
/*   PRINT OUT TAPE TYPES                                  */
/***********************************************************/
OUTDET:
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT(TYPE,9),
      RIGHT(UTALL,7),
      RIGHT(UTFULL,7),
      RIGHT(UTPART,7),
      RIGHT(UTEMPTY,7)
  RETURN

./ ADD NAME=DATERFSM 0110-15230-15232-1105-00461-00443-00000-APLKS   36
/* REXX                                                               */
/*                                                                    */
/* DATERFSM                                                           */
/*    PURPOSE: READS TYPE D AND M RECORDS AND PRODUCES REPORTS OF     */
/*             DAYS FROM LAST REFERENCE FOR THE FOLLOWING:            */
/*                L0, ML1 AND ML2 DATA COMBINED                       */
/*                ALL L0 DATA                                         */
/*                L0 SMS ONLY                                         */
/*                L0 NONSMS ONLY                                      */
/*                                                                    */
/*             A DETAIL REPORT IS PRODUCED THAT LISTS OUT ALL         */
/*             DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,   */
/*             VTOCS, VVDS, PAGE AND TEMPORARY DSNS                   */
/*                                                                    */
/*    INPUT:   USERID()..DCOLLECT.RECDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  USERID()..DCOLLECT.LRFDATE                             */
/*             USERID()..DCOLLECT.LRFDETL                             */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */
/***********************************************************/
TRACE N
/* INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'" */
INNAME = "'"USERID()".DCOLLECT.RECDM'"
 "ALLOC F(INFILE) DA("INNAME") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
/* NEW CODE ADDED */
DATE = DATE('J')
SDATE = DATE('S')
CC = SUBSTR(SDATE,1,2)
CC = CC - 19
DATE = RIGHT(CC,2,'0')||DATE
ODATE = DATE('O')
/* END OF NEW CODE */

/* OUTNAME = "'SMS.UMB.DCOLLECT.DATE.LRF'" */
 OUTNAME = "'"USERID()".DCOLLECT.LRFDATE.D"||DATE||"'"
"ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(50,20) RELEASE DDNAME(OUTFILE)"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE DETAIL BY DSN REPORT       */
/***********************************************************/
/* OUTNAME = "'SMS.UMB.DCOLLECT.DATE.DETAIL.LRF'" */
 OUTNAME2 = "'"USERID()".DCOLLECT.LRFDETL.D"||DATE||"'"
"ALLOC DSNAME("OUTNAME2")",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(7000,3500) RELEASE DDNAME(OUTDET)"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME2') FAILED'
    EXIT 12
    END

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 DAYS.1   = '0-15'
 DAYS.2   = '16-30'
 DAYS.3   = '31-60'
 DAYS.4   = '61-120'
 DAYS.5   = '121-365'
 DAYS.6   = '>365'
 DAYS.7   = 'VS INDX'
 DAYS.8   = 'SYSTEM'
 DAYS.TOT = 'TOTAL'
 DAYS.ERR = 'ERRORS'
 DAYST = 8
 DSN#.    = 0
 MBALLOC. = 0
 MBORG.   = 0
 DSNPER.  = 0
 MBORGPER. = 0
 K        = 0

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 EOF = 'NO'
 FIRST_REC = 'YES'
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE"
   IF RC <> 0 THEN EOF = 'YES'
   ELSE DO
      PARSE PULL RECORD
      PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 17 DCUDATE 21 .,
         25 RECDSN 69 .
      VSINDX = 'NO'
      VS = 'NO'
      SYS = 'NO'

      IF FIRST_REC = 'YES' THEN DO               /* SPECIAL PROCESSING*/
         DATE = LEFT(C2X(DCUDATE),7)             /*FOR FIRST RECORD  */
         COLDATE = RIGHT(DATE,5)
         COLYY = LEFT(COLDATE,2)
         COLDDD = RIGHT(COLDATE,3)
/* ADDING SOME CODE */
         ODATE = DATE('O',SUBSTR(DATE,3,5),'J')
/* FINISHED ADDING */
/*       OUT_LINE = "DATA COLLECTED ON:" COLDATE  */
         OUT_LINE = "DATA COLLECTED ON:" DATE ODATE
         PUSH OUT_LINE
         "EXECIO 1 DISKW OUTFILE"
         OUT_LINE2 = OUT_LINE
         PUSH OUT_LINE2
         "EXECIO 1 DISKW OUTDET"
         CALL OUTHEAD2
         FIRST_REC = 'NO'
         END

      SELECT
         WHEN(DCURCTYP='D ') THEN DO             /* ACTIVE DATA       */
                          CALL DCDRECP
                          DSN = DCDDSNAM
                          REFYY = LEFT(DCDLSTRF,2)
                          REFDDD = RIGHT(DCDLSTRF,3)
                          CREYY = LEFT(DCDCREDT,2)
                          CREDDD = RIGHT(DCDCREDT,3)
                          CREATED = DCDCREDT
                          CURRSIZE = DCDALLSP
                          ORGSIZE = DCDALLSP
                          DSORG = DCDDSORG
                          END
         WHEN(DCURCTYP='M ') THEN DO             /* MIGRATED DATA     */
                          CALL DCMRECP
                          DSN = UMDSNAM
                          REFYY = LEFT(UMLRFDT,2)
                          REFDDD = RIGHT(UMLRFDT,3)
                          CREYY = LEFT(UMCREDT,2)
                          CREDDD = RIGHT(UMCREDT,3)
                          CREATED = UMCREDT
                          CURRSIZE = UMDSIZE
                          ORGSIZE = UMALLSP
                          DSORG = UMDSORG
                          END
         OTHERWISE            /* DO NOT PROCESS OTHER RECORD TYPES */
         END

/***********************************************************/
/* CALULATE NUMBER OF DAYS SINCE LAST REFERENCE            */
/* ALL DATA, BOTH SMS AND NON-SMS                          */
/* BASED ON COLLECTION DATE OF DATA                        */
/***********************************************************/

      IF REFDDD = '00000' THEN DO      /*  IF LASTREF = 0'S THEN      */
         REFYY = CREYY                 /*  SET LAST REFERENCE TO      */
         REFDDD = CREDDD               /*  CREATION DATE              */
         END
      IF COLDDD <= REFDDD THEN DO
         REFYY = REFYY - 1
         REFDDD = REFDDD + 365
         END
      REFDAYS = COLDDD - REFDDD
      REFYRS = COLYY - REFYY
      REFDAYS = REFDAYS + (REFYRS * 365)

      IF SUBSTR(DSN,1,9) = "SYS1.VVDS" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,9) = "SYS1.VTOC" THEN SYS = 'YES'
/*    IF SUBSTR(DSN,1,9) = "BHSM.VTOC" THEN SYS = 'YES' */
/*    IF SUBSTR(DSN,1,6) = "PAGE.V" THEN SYS = 'YES'  */
      IF SUBSTR(DSN,1,9) = "PAGE.BCSP" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,4) = "SYS9" THEN SYS = 'YES'
      IF INDEX(DSN,'DUMYDSCB') > 0 THEN SYS = 'YES'
      IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN DO
         VS = 'YES'
         IF INDEX(DSN,'INDEX') > 0 THEN VSINDX = 'YES'
         END

      SELECT
         WHEN SYS = 'YES' THEN K=8
         WHEN VSINDX = 'YES' THEN K=7
         WHEN REFDAYS <=15 THEN K=1
         WHEN REFDAYS > 15 & REFDAYS <= 30 THEN K=2
         WHEN REFDAYS > 30 & REFDAYS <= 60 THEN K=3
         WHEN REFDAYS > 60 & REFDAYS <= 120 THEN K=4
         WHEN REFDAYS > 120 & REFDAYS <= 365 THEN K=5
         WHEN REFDAYS > 365  THEN K=6
      OTHERWISE K = 'ERR'  /* DO NOT PROCESS OTHER RECORD TYPES */
      END                                        /* END OF SELECT     */

/***********************************************************/
/* TOTAL UP STATS FOR ALL DATA - SMS AND NON-SMS           */
/* ACTIVE AND MIGRATED                                     */
/***********************************************************/

      DSN#.DM.REF.K    = DSN#.DM.REF.K + 1
      MBALLOC.DM.REF.K = MBALLOC.DM.REF.K + CURRSIZE
      MBORG.DM.REF.K   = MBORG.DM.REF.K + ORGSIZE
      DSN#.DM.REF.TOT    = DSN#.DM.REF.TOT + 1
      MBALLOC.DM.REF.TOT = MBALLOC.DM.REF.TOT + CURRSIZE
      MBORG.DM.REF.TOT   = MBORG.DM.REF.TOT + ORGSIZE

/***********************************************************/
/* TOTAL UP STATS FOR ACTIVE (L0) ONLY                     */
/***********************************************************/

      IF DCURCTYP='D ' THEN DO
         DSN#.L0.REF.K    = DSN#.L0.REF.K + 1
         MBALLOC.L0.REF.K = MBALLOC.L0.REF.K + CURRSIZE
         MBORG.L0.REF.K   = MBORG.L0.REF.K + ORGSIZE
         DSN#.L0.REF.TOT    = DSN#.L0.REF.TOT + 1
         MBALLOC.L0.REF.TOT = MBALLOC.L0.REF.TOT + CURRSIZE
         MBORG.L0.REF.TOT   = MBORG.L0.REF.TOT + ORGSIZE
         IF K>2 & K<7 THEN CALL OUTLINE2
         IF BITAND(DCDFLAG1,'40'X) = '40'X THEN DO
            DSN#.SMS.REF.K   = DSN#.SMS.REF.K + 1
            MBALLOC.SMS.REF.K = MBALLOC.SMS.REF.K + CURRSIZE
            MBORG.SMS.REF.K  = MBORG.SMS.REF.K + ORGSIZE
            DSN#.SMS.REF.TOT   = DSN#.SMS.REF.TOT + 1
            MBALLOC.SMS.REF.TOT = MBALLOC.SMS.REF.TOT + CURRSIZE
            MBORG.SMS.REF.TOT  = MBORG.SMS.REF.TOT + ORGSIZE
            END
         ELSE DO
            DSN#.NONSMS.REF.K = DSN#.NONSMS.REF.K + 1
            MBALLOC.NONSMS.REF.K = MBALLOC.NONSMS.REF.K + CURRSIZE
            MBORG.NONSMS.REF.K = MBORG.NONSMS.REF.K + ORGSIZE
            DSN#.NONSMS.REF.TOT = DSN#.NONSMS.REF.TOT + 1
            MBALLOC.NONSMS.REF.TOT = MBALLOC.NONSMS.REF.TOT + CURRSIZE
            MBORG.NONSMS.REF.TOT = MBORG.NONSMS.REF.TOT + ORGSIZE
            END
         END

   END
 END                                             /* END OF DOWHILE EOF*/
"EXECIO 0 DISKR INFILE (FINIS"
"FREE DDNAME(INFILE)"

/***********************************************************/
/* TOTAL IT ALL UP                                         */
/* PUT REPORT OUT TO DATASET                               */
/***********************************************************/

 CALL OUTLEG
 TYP = "DM.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0, ML1, AND ML2 DATA"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */

 TYP = "L0.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */

 TYP = "SMS.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0 SMS ONLY"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */

 TYP = "NONSMS.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0 NONSMS ONLY"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */
"EXECIO 0 DISKW OUTFILE (FINIS"
"EXECIO 0 DISKW OUTDET (FINIS"
"FREE DDNAME(OUTFILE)"
"FREE DDNAME(OUTDET)"

 EXIT


/***********************************************************/
/* ROUTINE TO FIGURE OUT PERCENTAGES OF TOTALS             */
/*  AND                                                    */
/* CHANGE THE ALLOC AND ORG DATA TO MB INSTEAD OF KB       */
/***********************************************************/

 PERCENT:

    DO J = 1 TO DAYST
       DSN1 = DSN#.TYP.J/DSN#.TYP.TOT
       MBORG1 = MBORG.TYP.J/MBORG.TYP.TOT
       DSNPER.TYP.J   = FORMAT(((DSN1)*100),3,1)
       MBORGPER.TYP.J = FORMAT(((MBORG1)*100),3,1)
       MBALLOC.TYP.J = FORMAT((MBALLOC.TYP.J/1024),,0)
       MBORG.TYP.J   = FORMAT((MBORG.TYP.J /1024),,0)
    END
    MBALLOC.TYP.TOT = FORMAT((MBALLOC.TYP.TOT/1024),,0)
    MBORG.TYP.TOT   = FORMAT((MBORG.TYP.TOT /1024),,0)
    DSNPER.TYP.TOT = ' '
    MBORGPER.TYP.TOT = ' '
 RETURN

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                          */
   OUT_LINE = "   "
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = REP
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = CENTER("DAYS",9),
      CENTER("# BY DSN",9),
      CENTER("MB ALLOC",10),
      CENTER("ORG MB",10),
      CENTER("% DSN",8),
      CENTER("% ORG MB",8)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT OUT A LEGEND LINE                                   */
/***********************************************************/
 OUTLEG:
/*                                                          */
   OUT_LINE = "   "
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = "VS INDX = VSAM INDEXES"
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = "SYSTEM = VTOCS, VVDS, PAGE AND TEMPORARY DSNS"
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = "   "
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT SUMMARIZED INFO OUT TO NEW FILE                     */
/***********************************************************/
OUTLINE:
/*                                                          */
   OUT_LINE = LEFT(DAYS.J,9),
      RIGHT(DSN#.TYP.J,9),
      RIGHT(MBALLOC.TYP.J,10),
      RIGHT(MBORG.TYP.J,10),
      RIGHT(DSNPER.TYP.J,8),
      RIGHT(MBORGPER.TYP.J,8)
/* SAY OUT_LINE                                             */
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT OUT A HEADER LINE FOR DETAIL REPORT                 */
/***********************************************************/
 OUTHEAD2:
/*                                                          */
   OUT_LINE2 = "   "
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = "DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,"
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = "VTOCS, VVDS, PAGE AND TEMPORARY DSNS"
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = "   "
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = LEFT("DSN",44),
      CENTER("REF DAYS",9),
      CENTER("MGMTCL",8),
      CENTER("STOGRP",8)
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
 RETURN

/***********************************************************/
/* PUT DETAIL INFO OUT TO NEW FILE                         */
/***********************************************************/
OUTLINE2:
/*                                                          */
   OUT_LINE2 = LEFT(DCDDSNAM,44),
      RIGHT(REFDAYS,9),
      RIGHT(DCDMGTCL,8),
      RIGHT(DCDSTGRP,8)
/* SAY OUT_LINE2                                             */
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .

   DCDALLSP = C2D(DCDALLSP)
   DCDCREDT = RIGHT(LEFT(C2X(DCDCREDT),7),5)
   DCDLSTRF = RIGHT(LEFT(C2X(DCDLSTRF),7),5)
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
   UMALLSP = C2D(UMALLSP)
   UMDSIZE = C2D(UMDSIZE)
   UMCREDT = RIGHT(LEFT(C2X(UMCREDT),7),5)
   UMLRFDT = RIGHT(LEFT(C2X(UMLRFDT),7),5)
   UMLBKDT = C2X(UMLBKDT)
 RETURN

./ ADD NAME=DB2      0104-15230-15231-1340-00139-00136-00000-APLKS   38
/* REXX                                                               */
/*                                                                    */
/* DB2                                                                */
/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT ALL DB2             */
/*             DSNS, INCLUDING VOLSER, CREATION DATE AND              */
/*             ALLOCATED KBYTES. TOTALS ALLOCATED KBYTES.             */
/*                                                                    */
/*    INPUT:   USERID()..DCOLLECT.RECDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  USERID()..DCOLLECT.DB2.DCCYYDDD                        */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/**********************************************************************/

TRACE N

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M RECORDS)   */
/***********************************************************/

/* INDD1 = "'SMS.UMB.DCOLLECT.RECTYPDM'" */
INDD1 = "'"USERID()".DCOLLECT.RECDM'"
"ALLOC DSNAME("INDD1") DDNAME(FILEA) SHR"

/****************************************************************/
/*  INITIALIZE VARIABLES                                        */
/****************************************************************/
DSNCOUNT = 0
STD_DSNCOUNT = 0
OUT_COUNT = 0
HLQ_SMS_DSNCT = 0
HLQ_DSNCT = 0
HLQ_STDDSN = 0
TOT_HLQ = 0
ALLOC = 0
FIRST_REC = "YES"

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/

"EXECIO 10000 DISKR FILEA (STEM IN_REC."
DO WHILE IN_REC.0 > 0
   DO J = 1 TO IN_REC.0
      PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
         13 DCUTIME 17 DCUDATE 21 .
      IF FIRST_REC = 'YES' THEN DO               /* SPECIAL PROCESSING*/
         COLDATE  = LEFT(C2X(DCUDATE),7)         /* FOR FIRST RECORD  */
/* ADDING SOME CODE */
         ODATE = DATE('O',SUBSTR(COLDATE,3,5),'J')
/* FINISHED ADDING */
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = "DATA COLLECTED ON:" COLDATE ODATE
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = "  "
         FIRST_REC = 'NO'
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = LEFT("DSN",44),
             RIGHT("VOLSER",6),
             RIGHT("CREATED",7),
             RIGHT("ALLOC_KB",10)
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = LEFT("-",44,"-"),
            RIGHT("------",6),
            RIGHT("-------",7),
            LEFT("----------",10)
         END
      IF DCURCTYP = "D " THEN DO
         CALL DCDRECP
         CREDT = LEFT(C2X(DCDCREDT),7)
         PARSE VAR IN_REC.J 1 . 25 HLQ.J "." HLQ2.J "." HLQ3.J "." .
         IF LENGTH(HLQ.J) > 8 THEN HLQ.J = LEFT(HLQ.J,8)
         IF LENGTH(HLQ2.J) > 8 THEN HLQ2.J = LEFT(HLQ2.J,8)
         IF LENGTH(HLQ3.J) > 8 THEN HLQ2.J = LEFT(HLQ3.J,8)
         IF LEFT(HLQ2.J,5) = "DSNDB" THEN DO
            ALLOC = ALLOC + C2D(DCDALLSP)
            OUT_COUNT = OUT_COUNT + 1
            OUT_LINE.OUT_COUNT = LEFT(DCDDSNAM,44),
            LEFT(DCDVOLSR,6),
            RIGHT(CREDT,7),
            RIGHT(C2D(DCDALLSP),10)
            END
         END
   END
   "EXECIO 10000 DISKR FILEA (STEM IN_REC."
END

/****************************************************************/
/*  PUT OUT TOTAL COUNTS                                        */
/****************************************************************/
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("  ",44)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("-",44,"-"),
   RIGHT("------",6),
   RIGHT("-------",7),
   LEFT("==========",10)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("  ",44)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("TOTAL ALLOCATED KBYTES",44),
    RIGHT("     ",6),
    RIGHT("     ",7),
    RIGHT(ALLOC,10)

/****************************************************************/
/*  FREE INPUT FILE AND CREATE OUTPUT FILE                      */
/****************************************************************/
"EXECIO 0 DISKR FILEA (FINIS"
"FREE DDNAME(FILEA)"
/* OUTNAME = "'SMS.UMB.DCOLLECT.DB2.D"||COLDATE||"')"  */
 OUTNAME = "'"USERID()".DCOLLECT.DB2.D"||COLDATE||"'"
/* "ALLOC DSNAME('SMS.UMB.DCOLLECT.DB2.D"||COLDATE||"')", */
"ALLOC DSNAME("OUTNAME")",
    "DSORG(PS) LRECL(80) RECFM(F B) ",
    "TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)"
"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE DDNAME(OUTDD)"
EXIT

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
 RETURN

./ ADD NAME=DCBRECP
/***********************************************************/
/* PARSE   BACKUP   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCBRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 UBDSNAM 69 UBFLAG1 70 UBDEVCL,
      71 UBDSORG 73 UBDSIZE 77 UBTIME 81 UBDATE 85 . 87 UBDATCL,
      117 . 119 UBSTGCL 149 . 151 UBMGTCL 181 UBRECRD 182 UBRECOR,
      183 UBBKLNG 185 UBFLAG2 186 . 187 UBNMIG 189 UBALLSP,
      193 UBUSESP 197 UBRECSP 200
 RETURN
./ ADD NAME=DCCRECP
/***********************************************************/
/* PARSE  CAPACITY INFORMATION RECORD -                    */
/***********************************************************/
 DCCRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 UCVOLSR 31 UCCOLDT 35 UCFLAG1,
     36 . 37 UCTOTAL 41 UCTGOCC 42 UCTROCC 43 UCBFOCC,
     44 UCAFOCC 45 UCNOMIG 46 UCNINTV 47 UCINTVM 48

 RETURN
./ ADD NAME=DCDRECP
/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
 RETURN
./ ADD NAME=DCMRECP
/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
 RETURN
./ ADD NAME=DCOLDLY  0105-15231-17080-1308-00013-00011-00000-APLKS   59
/* REXX */

     "%DASDVOLS"
     "%DATERFSM"    /*DATE LAST REFERENCED (SYS)*/
     "%DB2"
     "%DSORG"
     "%ERRORS"
     "%EXPDT"
     "%HLQSUM"
     "%MULTIVOL"
     "%NONSMS"      /*(SYS)*/

    EXIT;
./ ADD NAME=DCTRECP
/***********************************************************/
/* PARSE   TAPE CAPACITY PLANNING RECORD                   */
/***********************************************************/
 DCTRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 UTSTYPE 26 . ,
      29 UTFULL 33 UTPART 37 UTEMPTY 41
 RETURN
./ ADD NAME=DCURECP
/***********************************************************/
/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */
/***********************************************************/
 DCURECP:
/*                                                          */
   PARSE VAR RECORD 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
      13 DCUTIME 17 DCUDATE 21 .
 RETURN
./ ADD NAME=DCVRECP
/***********************************************************/
/* PARSE   VOLUME INFORMATION RECORD -                     */
/***********************************************************/
 DCVRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 DCVVOLSR 31 DCVFLAG1,
      32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,
      45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,
      65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .
 RETURN
./ ADD NAME=DSORG    0104-15230-15231-1341-00235-00228-00000-APLKS   59
/* REXX                                                               */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/* DSORG                                                              */
/*    PURPOSE: BREAKOUT OF DATA SETS BY DSORG. DONE BY DSN COUNT AND  */
/*             BY KBYTES WITH PERCENTAGES                             */
/*    INPUT:   USERID()..DCOLLECT.RECDM                               */
/*             TYPE D AND M RECORDS                                   */
/*    OUTPUT:  USERID()..DCOLLECT.DSORG.DCCYYDDD                      */
/*    PRESORT: SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/*    DCDDSORG XL2 MAPS AS FOLLOWS:                                   */
/*                                                                    */
/*             8000  IS - INDEXED SEQUENTIAL                          */
/*             4000  PS - PHYSICAL SEQUENTIAL                         */
/*             2000  DA - DIRECT                                      */
/*             0200  PO - PARTITIONED                                 */
/*             0100  U  - UNMOVEABLE                                  */
/*             0080  GS - GRAPHICS                                    */
/*             0008  VS - VSAM                                        */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D AND M RECORDS*/
/***********************************************************/
 TRACE N
/* INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'"  */
 INNAME = "'"USERID()".DCOLLECT.RECDM'"
/* "ALLOC DD(INFILE) DA('SMS.UMB.DCOLLECT.RECTYPDM') SHR" */
 "ALLOC DD(INFILE) DA("INNAME") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 OUT_COUNT = 0
 DSORG_TYPES    = ' '
 DSORG_CNT.  = 0
 DSORG_KB.  = 0
 TOT_CNT  = 0
 TOT_KB  = 0

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE D AND M RECORDS            */
/***********************************************************/

 "EXECIO 10000 DISKR INFILE (STEM RECORD."
 K=1
 CALL DCURECP
 DATE = LEFT(C2X(DCUDATE),7)
/* ADDING SOME CODE */
 ODATE = DATE('O',SUBSTR(DATE,3,5),'J')
/* FINISHED ADDING */
 OUT_COUNT = OUT_COUNT + 1
 OUT_LINE.OUT_COUNT = "DCOLLECT RUN ON:" DATE ODATE
 OUT_COUNT = OUT_COUNT + 1
 OUT_LINE.OUT_COUNT = " "
 CALL OUTHEAD

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/

/***********************************************************/
/* NOTE: THE DSORG BIT STRING IS CONVERTED TO CHARACTERS   */
/* TO BE STORED IN A VARIABLE AND THEN CONVERTED BACK TO   */
/* A BIT-STRING FOR FINAL PROCESSING. SEEMS WHEN A         */
/* X'4000' GETS STORED AND TREATED AS A WORD, THE X'40'    */
/* GETS CONVERTED TO A BLANK.                              */
/***********************************************************/

 DO WHILE RECORD.0 > 0
    DO K = 1 TO RECORD.0
       CALL DCURECP
       IF DCURCTYP = "D " THEN DO
          CALL DCDRECP
          DSN = DCDDSNAM
          DSORG = C2X(DCDDSORG)
          IF WORDPOS(DSORG,DSORG_TYPES,1) = 0 THEN DO
             DSORG_TYPES = DSORG_TYPES DSORG
             L = WORDPOS(DCDDSORG,DSORG_TYPES,1)
             END
          ELSE NOP
          L = WORDPOS(DSORG,DSORG_TYPES,1)
          DSORG_CNT.L = DSORG_CNT.L + 1
          DSORG_KB.L = DSORG_KB.L + C2D(DCDALLSP)
          TOT_CNT = TOT_CNT + 1
          TOT_KB = TOT_KB + C2D(DCDALLSP)
          END

       IF DCURCTYP = "M " THEN DO
          CALL DCMRECP
          DSN = UMDSNAM
          DSORG = C2X(UMDSORG)
          IF WORDPOS(DSORG,DSORG_TYPES,1) = 0 THEN DO
             DSORG_TYPES = DSORG_TYPES DSORG
             L = WORDPOS(DCDDSORG,DSORG_TYPES,1)
             END
          ELSE NOP
          L = WORDPOS(DSORG,DSORG_TYPES,1)
          DSORG_CNT.L = DSORG_CNT.L + 1
          DSORG_KB.L = DSORG_KB.L + C2D(UMALLSP)
          TOT_CNT = TOT_CNT + 1
          TOT_KB = TOT_KB + C2D(UMALLSP)
          END

    END
    "EXECIO 10000 DISKR INFILE (STEM RECORD."
 END
 "EXECIO 0 DISKR INFILE (FINIS"

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
/* OUTNAME = "'SMS.PMB.DCOLLECT.DSORG.D"||DATE||"'" */
 OUTNAME = "'"USERID()".DCOLLECT.DSORG.D"||DATE||"'"
 "ALLOC DSNAME("OUTNAME")",
     "DSORG(PS) LRECL(80) RECFM(F B) ",
     "TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)"
  IF RC <> 0 THEN DO
     SAY  'ALLOC OF ('OUTNAME') FAILED'
     EXIT 12
     END


/***********************************************************/
/* PUT OUT TOTALS BY DSORG                                 */
/***********************************************************/

L = WORDS(DSORG_TYPES)
DO K = 1 TO L
   DSORG = 'ERROR'         /* PRESET TO ERROR IF NO MATCHES ARE FOUND */
   DSORG_TYPES_BITS = X2C(WORD(DSORG_TYPES,K))
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'01'X) = '01'X THEN
      UNMOVE = 'U'
      ELSE UNMOVE = ''
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'40'X) = '40'X THEN
      DSORG = 'PS'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'20'X) = '20'X THEN
      DSORG = 'DA'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'02'X) = '02'X THEN
      DSORG = 'PO'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'80'X) = '80'X THEN
      DSORG = 'IS'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,2,1),'08'X) = '08'X THEN
      DSORG = 'VS'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,2,1),'80'X) = '80'X THEN
      DSORG = 'GS'||UNMOVE
   IF DSORG_TYPES_BITS = '0000'X THEN
      DSORG = 'UNKNOWN'
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       RIGHT(DSORG,8),
       RIGHT(DSORG_CNT.K,6),
       RIGHT(DSORG_KB.K,10),
       (WORD(DSORG_TYPES,K))
END

OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = ,
    RIGHT("TOTAL",8),
    RIGHT(TOT_CNT,6),
    RIGHT(TOT_KB,10)
"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE ALL"
EXIT

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                                    */
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       CENTER("DSORG",8),
       CENTER("     ",6),
       CENTER("     ",10),
       CENTER("DSORG",5)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       CENTER("TYPE",8),
       CENTER("COUNT",6),
       CENTER("KBYTES",10),
       CENTER("BITS",5)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       CENTER("-",8,"-"),
       CENTER("-",6,"-"),
       CENTER("-",10,"-"),
       CENTER("-",5,"-")
   RETURN

/***********************************************************/
/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */
/***********************************************************/
 DCURECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
      13 DCUTIME 17 DCUDATE 21 .
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 25 DCDDSNAM 69 DCDERROR,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
 RETURN
./ ADD NAME=ERRORS   0105-15230-15232-1338-00257-00271-00000-APLKS   06
/* REXX                                                               */
/*                                                                    */
/* ERRORS                                                             */
/*    PURPOSE: LISTS EVERY D RECORD THAT HAS ERROR BITS SET           */
/*                                                                    */
/*    INPUT:   USERID()..DCOLLECT.RECDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  USERID()..DCOLLECT.ERRORS                              */
/*                                                                    */
/*    PRESORT: SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/*    DCDERROR XL1 MAPS AS FOLLOWS:                                   */
/*                                                                    */
/*             80  SMS MANAGED INCONSISTENCY                          */
/*             40  DUPLICATE VVR FOUND                                */
/*             20  NO SPACE INFORMATION PROVIDED                      */
/*             10  VSAM INDICATORS INCONSISTENT                       */
/*             08  NO FMT 1 DSCB FOR THIS DATA SET                    */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D AND M RECORDS*/
/***********************************************************/
 TRACE N
/* INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'" */
 INNAME = "'"USERID()".DCOLLECT.RECDM'"
 "ALLOC DD(INFILE) DA("INNAME") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END


/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 OUT_COUNT = 0

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE D AND M RECORDS            */
/***********************************************************/

 "EXECIO 10000 DISKR INFILE (STEM RECORD."

/***********************************************************/
/* OPEN THE OUTPUT FILE (CONTAINING YOUR REPORT)           */
/***********************************************************/
/* NEW CODE ADDED */
DATE = DATE('J')
SDATE = DATE('S')
CC = SUBSTR(SDATE,1,2)
CC = CC - 19
DATE = RIGHT(CC,2,'0')||DATE
/* END OF NEW CODE */

/* OUTNAME = "'SMS.UMB.DCOLLECT.ERRORS'" */
 OUTNAME = "'"USERID()".DCOLLECT.ERRORS.D"||DATE||"'"
/* "ALLOC DSNAME('SMS.UMB.DCOLLECT.ERRORS')",  */
"ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(200,200) RELEASE DDNAME(OUTFILE)"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/* PROCESS FIRST RECORD FOR DATE COLLECTED INFORMATION     */
/***********************************************************/

 K = 1
 CALL DCURECP
 DATE = LEFT(C2X(DCUDATE),7)
/* ADDING SOME CODE */
 ODATE = DATE('O',SUBSTR(DATE,3,5),'J')
/* FINISHED ADDING */
 PUSH "DCOLLECT RUN ON:" DATE ODATE
 "EXECIO 1  DISKW OUTFILE"
 PUSH " "
 "EXECIO 1  DISKW OUTFILE"

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/

 DO WHILE RECORD.0 > 0
    DO K = 1 TO RECORD.0
       CALL DCURECP
       IF DCURCTYP = "D" THEN DO
          CALL DCDRECP
          IF DCDERROR = '00'X THEN ITERATE
          IF BITAND(DCDERROR,'80'X) = '80'X THEN DO
             ERROR = "SMS MANAGED INCONSISTENCY"
             PUSH "ERROR=" ERROR
             END
          IF BITAND(DCDERROR,'40'X) = '40'X THEN DO
             ERROR = "DUPLICATE VVR FOUND"
             PUSH "ERROR=" ERROR
             END
          IF BITAND(DCDERROR,'20'X) = '20'X THEN DO
             ERROR = "NO SPACE INFORMATION PROVIDED"
             PUSH "ERROR=" ERROR
             END
          IF BITAND(DCDERROR,'10'X) = '10'X THEN DO
             ERROR = "VSAM INDICATORS INCONSISTEN"
             PUSH "ERROR=" ERROR
             END
          IF BITAND(DCDERROR,'08'X) = '08'X THEN DO
             ERROR = "NO FMT 1 DSCB FOR THIS DATA SET"
             PUSH "ERROR=" ERROR
             END
          CALL DCRECORD
          CALL DISPLAYDC
          END

       IF DCURCTYP = "M" THEN ITERATE

    END
    "EXECIO 10000 DISKR INFILE (STEM RECORD."
 END


/***********************************************************/
/* PUT OUT TOTALS BY DSORG                                 */
/***********************************************************/

"EXECIO 0 DISKR INFILE (FINIS"
"EXECIO * DISKW OUTFILE (FINIS"
"FREE ALL"
EXIT


/***********************************************************/
/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */
/***********************************************************/
 DCURECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
      13 DCUTIME 17 DCUDATE 21 .
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 25 DCDDSNAM 69 DCDERROR,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      142 . 167 DCDSTGCL 174 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 238 .
 RETURN

/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */
/***********************************************************/
 DCRECORD:
/*                                                          */
       DCDDSNAM = SUBSTR(RECORD.K,25,44)
       DCDERROR = BITSTR(SUBSTR(RECORD.K,69,1))
       DCDFLAG1 = BITSTR(SUBSTR(RECORD.K,70,1))
       DCDFLAG2 = BITSTR(SUBSTR(RECORD.K,71,1))
       DCDDSORG = C2X(SUBSTR(RECORD.K,75,2))
       DCDRECRD = C2X(SUBSTR(RECORD.K,77,1))
       DCDNMEXT = C2X(SUBSTR(RECORD.K,78,1))
       DCDVOLSR = SUBSTR(RECORD.K,79,6)
       DCDBKLNG = C2D(SUBSTR(RECORD.K,85,2))
       DCDLRECL = C2D(SUBSTR(RECORD.K,87,2))
       DCDALLSP = C2D(SUBSTR(RECORD.K,89,4))
       DCDUSESP = C2D(SUBSTR(RECORD.K,93,4))
       DCDSCALL = C2D(SUBSTR(RECORD.K,97,4))
       DCDNMBLK = C2D(SUBSTR(RECORD.K,101,4))
       DCDCREDT = STRIP(C2X(SUBSTR(RECORD.K,105,4)),T,'F')
       DCDEXPDT = STRIP(C2X(SUBSTR(RECORD.K,109,4)),T,'F')
       DCDLSTRF = STRIP(C2X(SUBSTR(RECORD.K,113,4)),T,'F')
       DCDDSSER = SUBSTR(RECORD.K,117,6)
       DCDVOLSQ = C2X(SUBSTR(RECORD.K,123,2))
       DCDLBKDT = C2X(SUBSTR(RECORD.K,125,8))
       DCDDATCL = SUBSTR(RECORD.K,135,8)
       DCDSTGCL = SUBSTR(RECORD.K,167,8)
       DCDMGTCL = SUBSTR(RECORD.K,199,8)
       DCDSTGRP = SUBSTR(RECORD.K,231,8)
 RETURN


/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */
/***********************************************************/
 DISPLAYDC:
 PUSH "DCDDSNAM="   DCDDSNAM
 PUSH "DCDERROR="   DCDERROR
 PUSH "DCDFLAG1="   DCDFLAG1
 PUSH "DCDFLAG2="   DCDFLAG2
 PUSH "DCDDSORG="   DCDDSORG
 PUSH "DCDRECRD="   DCDRECRD
 PUSH "DCDNMEXT="   DCDNMEXT
 PUSH "DCDVOLSR="   DCDVOLSR
 PUSH "DCDBKLNG="   DCDBKLNG
 PUSH "DCDLRECL="   DCDLRECL
 PUSH "DCDALLSP="   DCDALLSP
 PUSH "DCDUSESP="   DCDUSESP
 PUSH "DCDSCALL="   DCDSCALL
 PUSH "DCDNMBLK="   DCDNMBLK
 PUSH "DCDCREDT="   DCDCREDT
 PUSH "DCDEXPDT="   DCDEXPDT
 PUSH "DCDLSTRF="   DCDLSTRF
 PUSH "DCDDSSER="   DCDDSSER
 PUSH "DCDVOLSQ="   DCDVOLSQ
 PUSH "DCDLBKDT="   DCDLBKDT
 PUSH "DCDDATCL="   DCDDATCL
 PUSH "DCDSTGCL="   DCDSTGCL
 PUSH "DCDMGTCL="   DCDMGTCL
 PUSH "DCDSTGRP="   DCDSTGRP
 PUSH "*******************************************************"
 "EXECIO *  DISKW OUTFILE"
 RETURN


/***********************************************************/
/* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */
/* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */
/***********************************************************/
 BITSTR:
       IF BIT.F <> "1111"  THEN DO
          BIT.0="0000"
          BIT.1="0001"
          BIT.2="0010"
          BIT.3="0011"
          BIT.4="0100"
          BIT.5="0101"
          BIT.6="0110"
          BIT.7="0111"
          BIT.8="1000"
          BIT.9="1001"
          BIT.A="1010"
          BIT.B="1011"
          BIT.C="1100"
          BIT.D="1101"
          BIT.E="1110"
          BIT.F="1111"
       END
       CH=C2X(ARG(1))
       BS=''
       DO I=1 TO LENGTH(CH)
          Q=SUBSTR(CH,I,1)
          BS=BS||BIT.Q
       END
RETURN BS
./ ADD NAME=EXPDT    0109-15230-15232-1241-00143-00126-00000-APLKS   59
/* REXX                                                               */
/*                                                                    */
/* EXPDT                                                              */
/*    PURPOSE: READS TYPE D AND M RECORDS FOR ALL DSNS THAT           */
/*             HAVE AN EXPDT > 0. (VSAM IS EXCLUDED SINCE IT          */
/*             ALWAYS HAS AN EXPDT = 1999365)                         */
/*                                                                    */
/*    INPUT:   USERID()..DCOLLECT.RECDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  USERID()..DCOLLECT.EXPDT.DCCYYDDD                      */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/**********************************************************************/


TRACE N

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M RECORDS)   */
/***********************************************************/
/* INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'"  */
 INNAME = "'"USERID()".DCOLLECT.RECDM'"
/* "ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPDM') DDNAME(FILEA) SHR" */
"ALLOC DSNAME("INNAME") DDNAME(FILEA) SHR"

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
OUT_COUNT = 0
HLQ_STDDSN = 0
TOT_HLQ = 0
ALLOC = 0

/***********************************************************/
/* SPECIAL PROCESSING FOR FIRST RECORD                     */
/***********************************************************/
"EXECIO 10000 DISKR FILEA (STEM IN_REC."
J=1
PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
   13 DCUTIME 17 DCUDATE 21 .
DATE = LEFT(C2X(DCUDATE),7)
/* ADDING SOME CODE */
 ODATE = DATE('O',SUBSTR(DATE,3,5),'J')
/* FINISHED ADDING */
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = "DATA COLLECTED ON:" DATE ODATE
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = " "
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("DSN",44),
    LEFT("EXPDT",7)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("-",44,"-"),
    RIGHT("-",7,"-")

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
DO WHILE IN_REC.0 > 0
   DO J = 1 TO IN_REC.0
      PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
         13 DCUTIME 17 DCUDATE 21 .
      SELECT
         WHEN DCURCTYP = 'D ' THEN CALL DCDRECP
         WHEN DCURCTYP = 'M ' THEN CALL DCMRECP
         OTHERWISE ITERATE
         END
      IF EXPDT <> 0 THEN DO
          IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN ITERATE
             /* IGNORE VSAM DATA           */
             /* SINCE EXPDT = 99365        */
          OUT_COUNT = OUT_COUNT + 1
          OUT_LINE.OUT_COUNT = LEFT(DSNAME,44),
          RIGHT(EXPDT,7),
          MIGRATE
          END
      END
      "EXECIO 10000 DISKR FILEA (STEM IN_REC."
   END

/***********************************************************/
/*  FREE INPUT FILE AND CREATE OUTPUT FILE                 */
/***********************************************************/
"EXECIO 0 DISKR FILEA (FINIS"
"FREE DDNAME(FILEA)"
/* OUTNAME = "'SMS.UMB.DCOLLECT.EXPDT'"  */
 OUTNAME = "'"USERID()".DCOLLECT.EXPDT.D"||DATE||"'"
/* "ALLOC DSNAME('SMS.UMB.DCOLLECT.EXPDT')", */
"ALLOC DSNAME("OUTNAME")",
    "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
    "SPACE(100,50) RELEASE DDNAME(OUTDD)"
"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE DDNAME(OUTDD)"
EXIT

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
   EXPDT = LEFT(C2X(DCDEXPDT),7)
/* ADDING SOME CODE
   IF EXPDT > 0 THEN
     OEXPDT = DATE('O',SUBSTR(EXPDT,3,5),'J')
   FINISHED ADDING */
   DSNAME = DCDDSNAM
   DSORG = DCDDSORG
   MIGRATE = " "
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR IN_REC.J 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
   EXPDT = LEFT(C2X(UMEXPDT),7)
/* ADDING SOME CODE
   IF EXPDT > 0 THEN
     OEXPDT = DATE('O',SUBSTR(EXPDT,3,5),'J')
   FINISHED ADDING */
   DSNAME = UMDSNAM
   DSORG = UMDSORG
   MIGRATE = "  MIGRATED"
 RETURN
./ ADD NAME=FRAGANAL 0116-17149-17151-1034-00344-00333-00000-APLKS   38
/* REXX 2017-05-29 */
   Address TSO;
   'PROFILE NOPREFIX';

/* Entering EXEC FRAGANAL */

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Parse UPPER ARG parm2;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the FRAGANAL statistics dsname:";
       Parse UPPER EXTERNAL parm2 .;
     End;

   /* variable definition */
   F.0 = 0; L.0 = 0; M.0 = 0;

   /* Parse User passed Parms */

   /* get the dsname that we want to analyze the data in */
   If parm2 <> "" Then;
     Parse VAR parm2 dsname .;
   Else;
     Signal Error_NODATA;

   dsname = Strip(dsname);
   x = Sysdsn(dsname);
   If x <> "OK" Then;
     Signal Error_INVALID_DSNAME;

   /* Point to FRAGANAL statistics dsname to be processed */

   "ALLOC DSNAME("dsname") ",
         "DDNAME(FANALDD) SHR REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_ALLOC;

   "EXECIO 0 DISKR FANALDD ( OPEN ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_OPEN;

   Numeric Digits 12;
   i = 0;
   eof = "N";
   Do While eof = "N";
     "EXECIO 1 DISKR FANALDD ";
     If RC = 0 Then;
       Do;
         Pull line;
         /* char(1:1 sr_type);     1=lrecl,2=block|CI,3=CI frag
            char(2:1 sr_am);       Q=QSAM,V=VSAM
            char(3:1 sr_org);      K=KSDS
            char(4:1 sr_flag);     E=error
            binary(5:4 null);
            binary(9:4 sr_seq)     sequence nbr
            binary(13:4 sr_frag)   distance of CI from desired location
            binary(17:4 sr_cnt)    count of CI(s)
            binary(21:4 sr_rci)    relative CI nbr
            binary(25:8 sr_xrba)   XRBA
         */
         Parse UPPER VAR line sr_type 2 sr_am 3 sr_org 4 sr_flag 5 ,
            9 sr_seq 13 sr_frag 17 sr_cnt 21 sr_rci 25 .;
         If sr_flag = "E" Then;
           Iterate;
         Select;
           When sr_type = "3" Then;
             Do;
               i = i + 1;
               L.i = c2d(sr_frag,4);
               F.i = c2d(sr_cnt);
      /*       Say c2d(sr_seq) i "FRAG=" L.i " COUNT=" F.i; */
             End;
           Otherwise;
             Iterate;
         End;
       End;
     Else;
       Do;
         L.0 = i;
         F.0 = i;
         eof = "Y";
         "EXECIO 0 DISKR FANALDD ( FINIS ";
       End;
   End;

/* "CLEAR"; */
   Say "There are" i "unique CI fragmentations";

Compute_MEAN:

   cnt = 0; sum = 0; mean = 0;
   If L.0 > 0 Then;
     Do;
       x = MEAN(L.0);
       cnt = Word(x,1);
       sum = Word(x,2);
     End;

   Say "Total CI(s)          =" cnt;

Compute_MODE:

   freq = 0;
   If L.0 > 0 Then;
     freq = MODE(L.0);
   Say "Highest frequency of disorder =" freq;

   If M.0 > 0 Then;
     Do i = 1 To M.0;
       Say "  Mode of disorder vector =" M.i;
     End;

   i = L.0;
   If L.0 > 0 Then;
     Say "Range of values in disorder vector = ("L.1":"L.i")";

Compute_VARIANCE:

   varsq = 0; mean = 0;
   cntlofmean = 0; cnteqmean = 0; cntrofmean = 0;
   If L.0 > 0 Then;
     Do;
       x = VARIANCE(L.0,mean,cnt);
       varsq = Word(x,1);        /*return variance squared*/
       cntlofmean = Word(x,2);   /*return items left of mean*/
       cnteqmean = Word(x,3);    /*return items eq to mean*/
       cntrofmean = Word(x,4);   /*return items right of mean*/
     End;

   Say "Variance squared =" varsq;
   Say "  Items < mean   =" cntlofmean;
   Say "  Items = mean   =" cnteqmean;
   Say "  Items > mean   =" cntrofmean;
   stddev = SQRT(varsq);
   Say "Std Deviation    =" Format(stddev,,0);
   Say "Range of average disorder vector = (" ,
        || Format((mean-stddev),,0) || ":" ,
        || mean || ":" ,
        || Format((mean+stddev),,0) || ")";

   Return 0;

/* --------------------------- */
   MEAN: Procedure Expose L. F.

/* REXX function
   Invoke as: MEAN(occurs,nd)
   Determine the arithmetic mean/average of vector entries.

   where L.i = LRECL vector
         F.i = FREQuence of LRECL entry vector

   ------------------------------------------------------- */

   Parse ARG occurs,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   cnt = 0;
   sum = 0;
   Do i = 1 To occurs;
     cnt = cnt + F.i;
     sum = sum + (L.i * F.i);
   End;

   Return (cnt  sum);

/* --------------------------- */
   VARIANCE: Procedure Expose L. F.

/* REXX function
   Invoke as: VARIANCE(occurs,mean,nd)
   Determine the variance between each value in the vector.
   Sum of (((L.i-mean)**2)*F.i)

   where L.i = LRECL vector
         F.i = FREQuency of LRECL entry vector
   ------------------------------------------------------- */

   Parse ARG occurs,mean,cnt,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   leftofmean = 0;
   eqtomean = 0;
   rightofmean = 0;
   varsq = 0;

   Do i = 1 To occurs;
     dif = L.i - mean;
     If dif < 0 Then;
       leftofmean = leftofmean + F.i;
     If dif = 0 Then;
       eqtomean = eqtomean + F.i;
     If dif > 0 Then;
       rightofmean = rightofmean + F.i;
     varsq = varsq + (dif**2) * F.i;
   End;

   If cnt > 0 Then;
     varsq = varsq / cnt;

   Return (varsq leftofmean eqtomean rightofmean);

/* --------------------------- */
   MODE: Procedure Expose L. F. M.

/* REXX function
   Invoke as: MODE(occurs)
   Determine the most frequently occuring value(s) of a
   sorted vector.

   where L. = LRECL vector
         F. = FREQuency of LRECL entry vector
         M. = MODE vector (LRECL with the most occurrences)
   ------------------------------------------------------- */

   Parse ARG occurs;

   j = 1;           /*index of largest entry in FREQuency vector*/
   freq = F.j;      /*init freq with 1st entry in FREQuency vector*/

   Do i = 2 To occurs;
     If freq < F.i Then;
       Do;          /*tag 1st occurrence of largest frequency*/
         j = i;
         freq = F.i;
       End;
   End;

   k = 0;
   Do i = j To occurs;
     If F.i = freq Then;
       Do;          /*save LRECL in Mode vector*/
         k = k + 1;
         M.k = L.i;
       End;
   End;
   M.0 = k;

   Return (freq);

/* --------------------------- */
   SQRT: Procedure

/* REXX function
   Invoke as: SQRT(real);
   Compute the square root of a real number using Newton's
   formula New=0.5*(X+N/X), where X starts with a reasonable
   guess e.g. (1+N)/2.

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real,nd;

   If Datatype(real,'N') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   If real = 0 Then;
     Return 0;

   If nd = "" Then;
     nd = 9;

   Numeric Digits nd;

   Parse VALUE FORMAT(real,,,,0) With real "E" exp;

   If exp = "" Then;
     exp = 0;

   If (exp // 2) <> 0 Then;
     If exp > 0 Then;
       Do;
         real = real * 10;
         exp = exp - 1;
       End;
     Else;
       Do;
         real = real / 10;
         exp = exp + 1;
       End;

   x = 0.5 * (real + 1);

   Do Forever;
     NewX = 0.5 * (x + real / x);
     If x = NewX Then;
       Return X * 10 ** (exp % 2);
     x = NewX;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NODATA:

   Say "Missing dsname";
   Exit (-16);

   Error_INVALID_DSNAME:

   Say "INVALID DSNAME" dsname;
   Exit (-16);

   Error_DATASET_ALLOC:

   Say "TSO ALLOCation failed" dsname EC;
   Exit (-16);

   Error_DATASET_OPEN:

   Say "OPEN failed" dsname EC;
   Exit (-16);
./ ADD NAME=HLQSUM   0107-15230-15231-1637-00519-00501-00000-APLKS   36
/* REXX                                                               */
/*                                                                    */
/* HLQSUM                                                             */
/*    PURPOSE: READS DCOLLECT "D" "M" AND "B" RECORDS AND PRODUCES    */
/*             A REPORT SUMMARIZED BY HLQ OF BYTES ALLOCATED AT EACH  */
/*             LEVEL (L0, ML1, AND ML2) AS WELL AS BACKUP BYTES       */
/*                                                                    */
/*             PRODUCES A SUMMARY REPORT OF THE FOLLOWING:            */
/*                                                                    */
/*                TOTAL FROM VOLUME (V) RECORDS:                      */
/*                   TOTAL AVAILABLE KBYTES                           */
/*                   TOTAL ALLOCATED KBYTES                           */
/*                   SMS AVAILABLE KBYTES                             */
/*                   SMS ALLOCATED KBYTES                             */
/*                                                                    */
/*                TOTAL FROM D, M AND B RECORDS:                      */
/*                   L0+ML1+ML2 DSN COUNT                             */
/*                   TOTAL L0 + ML1 +ML2 ALLOCATED                    */
/*                   TOTAL BACKUP KBYTES                              */
/*                   L0 DSN COUNT                                     */
/*                   L0 ALLOCATED KBYTES                              */
/*                   L0 USED KBYTES                                   */
/*                   SMS DSN COUNT                                    */
/*                   SMS ALLOCATED KBYTES                             */
/*                   ML1 DSN COUNT                                    */
/*                   ML1 ALLOCATED KBYTES                             */
/*                   ML1 ORIGINAL KBYTES                              */
/*                   ML2 DSN COUNT                                    */
/*                   ML2 ALLOCATED KBYTES                             */
/*                   ML2 ORIGINAL KBYTES                              */
/*                                                                    */
/*    INPUT:   USERID()..DCOLLECT.RECDMB                              */
/*             TYPE D, M AND B RECORDS                                */
/*                                                                    */
/*             USERID()..DCOLLECT.RECV                                */
/*             TYPE V RECORDS                                         */
/*                                                                    */
/*    OUTPUT:  USERID()..DCOLLECT.SUMMARY.DCCYYDDD                    */
/*             USERID()..DCOLLECT.HLQDETL.DCCYYDDD                    */
/*                                                                    */
/*    PRESORT: FOR TYPE D, M AND B RECORDS                            */
/*             SORT FIELDS=(29,44,CH,A),                              */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,                    */
/*                           (9,2,CH,EQ,C'M '),OR,                    */
/*                           (9,2,CH,EQ,C'B '))                       */
/*                                                                    */
/*             FOR TYPE V RECORDS                                     */
/*             SORT FIELDS=(87,8,CH,A,29,6,CH,A)                      */
/*             INCLUDE COND=(9,2,CH,EQ,C'V ')                         */
/*                                                                    */
/*                                                                    */
/**********************************************************************/


/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M,B RECORDS) */
/***********************************************************/
TRACE N
/* INNAME = "'SMS.UMB.DCOLLECT.DMB'" */
 INNAME = "'"USERID()".DCOLLECT.RECDMB'"
 "ALLOC F(INFILE) DA("INNAME") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* SPECIAL PROCESSING FOR FIRST RECORD                     */
/***********************************************************/
 "EXECIO 10000 DISKR INFILE (STEM RECORD."
 CALL INITHLQ
 CALL INITTOT
 J = 1
 PARSE VAR RECORD.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
    13 DCUTIME 17 DCUDATE 21 . 25 DCDDSNAM 69 .
 DATE  = LEFT(C2X(DCUDATE),7)
/* ADDING SOME CODE */
 ODATE = DATE('O',SUBSTR(DATE,3,5),'J')
/* FINISHED ADDING */

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY HLQ REPORT   */
/***********************************************************/
/* OUTNAME = "SMS.PMB.DCOLLECT.HLQ.DETAIL.D"||DATE  */
 OUTNAME = "'"USERID()".DCOLLECT.HLQDETL.D"||DATE||"'"
/* "ALLOC DSNAME('SMS.PMB.DCOLLECT.HLQ.DETAIL.D"||DATE||"')", */
 "ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(172) RECFM(F B) AVGREC(U)",
  "SPACE(2000,1000) RELEASE DDNAME(OUTFILE)"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

 PARSE VAR DCDDSNAM RECHLQ "." .
 IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
 HLQ=RECHLQ
 OUT_LINE = "DATA COLLECTED ON:" DATE ODATE
 PUSH OUT_LINE
 "EXECIO 1 DISKW OUTFILE"
 OUT_LINE = " "
 PUSH OUT_LINE
 "EXECIO 1 DISKW OUTFILE"
 CALL OUTHEAD

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 DO WHILE RECORD.0 > 0
    DO J = 1 TO RECORD.0
      PARSE VAR RECORD.J 1 . 5 DCURCTYP 7 . 25 DCDDSNAM 69 .
      PARSE VAR DCDDSNAM RECHLQ "." .
      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
      IF RECHLQ <> HLQ THEN DO
         CALL OUTHLQ
         HLQ = RECHLQ
         END
      SELECT
         WHEN(DCURCTYP='D ') THEN DO               /* ACTIVE DATA  */
            CALL DCDRECP
            CALL DNEWINFO
            END
         WHEN(DCURCTYP='M ') THEN DO               /* MIGRATED DATA*/
            CALL DCMRECP
            CALL MNEWINFO
            END
         WHEN(DCURCTYP='B ') THEN DO               /* BACKUP DATA  */
            CALL DCBRECP
            CALL BNEWINFO
            END
         OTHERWISE            /* DO NOT PROCESS OTHER RECORD TYPES */
         END
      END
      "EXECIO 10000 DISKR INFILE (STEM RECORD."
 END
 CALL OUTHLQ
 "EXECIO 0 DISKR INFILE (FINIS"
 "EXECIO 0 DISKW OUTFILE (FINIS"
 "FREE DDNAME(INFILE)"
 "FREE DDNAME(OUTFILE)"

/***********************************************************/
/*   ALLOCATE NEW SUMMARY DATA SET                         */
/***********************************************************/

/* SUMNAME = "SMS.PMB.DCOLLECT.SUMMARY.D"||DATE  */
SUMNAME = "'"USERID()".DCOLLECT.SUMMARY.D"||DATE||"'"
/* "ALLOC DSNAME('SMS.PMB.DCOLLECT.SUMMARY.D"||DATE||"')", */
"ALLOC DSNAME("SUMNAME")",
   "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
   "SPACE(10,5) RELEASE DDNAME(OUTSUM)"

 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('SUMNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/*   PROCESS TYPE 'V' VOLUME INFORMATION RECORDS           */
/***********************************************************/

/* INNAMEV = "SMS.UMB.DCOLLECT.RECTYPV"  */
INNAMEV = "'"USERID()".DCOLLECT.RECV'"
/* "ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPV') DDNAME(FILEV) SHR" */
"ALLOC DSNAME("INNAMEV") DDNAME(FILEV) SHR"
"EXECIO * DISKR FILEV (FINIS STEM IN_RECV."
"FREE DDNAME(FILEV)"
TOT_AVAIL_ALLOC_KBYTES = 0
SMS_AVAIL_ALLOC_KBYTES = 0
TOT_AVAIL_KBYTES       = 0
SMS_AVAIL_KBYTES       = 0
L = 0
DO K = 1 TO IN_RECV.0
   PARSE VAR IN_RECV.K 1 . 25 DCVVOLSR 31 DCVFLAG1,
      32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,
      45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,
      65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .
   TOT_AVAIL_ALLOC_KBYTES = TOT_AVAIL_ALLOC_KBYTES + C2D(DCVALLOC)
   TOT_AVAIL_KBYTES = TOT_AVAIL_KBYTES + C2D(DCVVLCAP)
   IF BITAND(DCVFLAG1,'03'X) = '03'X THEN DO           /* IS IT SMS?  */
      SMS_AVAIL_ALLOC_KBYTES = SMS_AVAIL_ALLOC_KBYTES + C2D(DCVALLOC)
      SMS_AVAIL_KBYTES = SMS_AVAIL_KBYTES + C2D(DCVVLCAP)
   END
END
L = L + 1
OUT_LINE2.L = "DATA COLLECTED ON:" DATE ODATE
L = L + 1
OUT_LINE2.L= " "
L = L + 1
OUT_LINE2.L = "TOTAL FROM VOLUME (V) RECORDS:"
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL AVAILABLE KBYTES",30),
    RIGHT(TOT_AVAIL_KBYTES,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL ALLOCATED KBYTES",30),
    RIGHT(TOT_AVAIL_ALLOC_KBYTES,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS AVAILABLE KBYTES",30),
    RIGHT(SMS_AVAIL_KBYTES,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS ALLOCATED KBYTES",30),
    RIGHT(SMS_AVAIL_ALLOC_KBYTES,11)
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = "TOTAL FROM D, M AND B RECORDS:"
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = "  " LEFT("L0+ML1+ML2 DSN COUNT",30),
    RIGHT(TOT_ALL_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL L0 + ML1 +ML2 ALLOCATED KBYTES",30),
    RIGHT(TOT_KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL BACKUP KBYTES",30),
    RIGHT(TOT_BKKB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("L0 DSN COUNT",30),
    RIGHT(TOT_L0_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("L0 ALLOCATED KBYTES",30),
    RIGHT(TOT_L0KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("L0 USED KBYTES",30),
    RIGHT(TOT_L0USEKB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS DSN COUNT",30),
    RIGHT(TOT_SMS_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS ALLOCATED KBYTES",30),
    RIGHT(TOT_SMS_L0KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML1 DSN COUNT",30),
    RIGHT(TOT_ML1_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML1 ALLOCATED KBYTES",30),
    RIGHT(TOT_ML1KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML1 ORIGINAL KBYTES",30),
    RIGHT(TOT_ML1_ORGKB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML2 DSN COUNT",30),
    RIGHT(TOT_ML2_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML2 ALLOCATED KBYTES",30),
    RIGHT(TOT_ML2KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML2 ORIGINAL KBYTES",30),
    RIGHT(TOT_ML2_ORGKB,11)
/*                                                                    */
/**********************************************************************/
/*   WRITE OUT HLQ SUMMARY AND VOLUME SUMMARY RECORDS TO DASD         */
/**********************************************************************/
/*                                                                    */
"EXECIO * DISKW OUTSUM (FINIS STEM OUT_LINE2."
"FREE DDNAME(OUTSUM)"

 EXIT


/***********************************************************/
/*         R O U T I N E S                                 */
/***********************************************************/

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                          */
   OUT_LINE = LEFT("    ",8),
      RIGHT("L0+ML1+ML2",10),
      RIGHT("L0 ",10),
      RIGHT("L0",11),
      RIGHT("L0",11),
      RIGHT("SMS",10),
      RIGHT("SMS L0",11),
      RIGHT("ML1",10),
      RIGHT("ML1",11),
      RIGHT("   ",11),
      RIGHT("ML2",10),
      RIGHT("ML2",11),
      RIGHT("   ",11),
      RIGHT("   ",11),
      RIGHT("   ",11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = LEFT("    ",8),
      RIGHT("DSN",10),
      RIGHT("DSN",10),
      RIGHT("ALLOCATED",11),
      RIGHT("USED",11),
      RIGHT("DSN",10),
      RIGHT("ALLOCATED",11),
      RIGHT("DSN",10),
      RIGHT("ORGINAL",11),
      RIGHT("ML1",11),
      RIGHT("DSN",10),
      RIGHT("ORGINAL",11),
      RIGHT("ML2",11),
      RIGHT("L0+ML1+ML2",11),
      RIGHT("BACKUP",11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = LEFT("HLQ",8),
      RIGHT("COUNT",10),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = LEFT("-",8,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-")
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT SUMMARIZED HLQ INFO OUT TO NEW FILE                 */
/***********************************************************/
OUTHLQ:
/*                                                          */
   OUT_LINE = LEFT(HLQ,8),
      RIGHT(HLQ_ALL_DSN_CTR,10),
      RIGHT(HLQ_L0_DSN_CTR,10),
      RIGHT(HLQ_L0KB,11),
      RIGHT(HLQ_L0USEKB,11),
      RIGHT(HLQ_SMS_DSN_CTR,10),
      RIGHT(HLQ_SMS_L0KB,11),
      RIGHT(HLQ_ML1_DSN_CTR,10),
      RIGHT(HLQ_ML1_ORGKB,11),
      RIGHT(HLQ_ML1KB,11),
      RIGHT(HLQ_ML2_DSN_CTR,10),
      RIGHT(HLQ_ML2_ORGKB,11),
      RIGHT(HLQ_ML2KB,11),
      RIGHT(HLQ_KB,11),
      RIGHT(HLQ_BKKB,11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   CALL INITHLQ
 RETURN

/***********************************************************/
/* PUT IN "D" INFO FOR NEW DATASET                         */
/***********************************************************/
 DNEWINFO:
/*                                                          */
   HLQ_ALL_DSN_CTR = HLQ_ALL_DSN_CTR + 1
   TOT_ALL_DSN_CTR = TOT_ALL_DSN_CTR + 1
   HLQ_L0_DSN_CTR  = HLQ_L0_DSN_CTR + 1
   TOT_L0_DSN_CTR  = TOT_L0_DSN_CTR + 1
   IF DCDUSESP > DCDALLSP THEN DCDUSESP = DCDALLSP   /* BAD DATA      */
   IF SUBSTR(DCDDSORG,2,1) = '08'X THEN DCDUSESP = DCDALLSP
                                                   /*  VSAM DATA      */
   HLQ_L0KB = HLQ_L0KB + DCDALLSP
   HLQ_L0USEKB = HLQ_L0USEKB + DCDUSESP
   HLQ_KB = HLQ_KB + DCDALLSP
   TOT_L0KB = TOT_L0KB + DCDALLSP
   TOT_L0USEKB = TOT_L0USEKB + DCDUSESP
   TOT_KB = TOT_KB + DCDALLSP
   IF BITAND(DCDFLAG1,'40'X) = '40'X THEN DO           /* IS IT SMS?  */
      TOT_SMS_L0KB = TOT_SMS_L0KB + DCDALLSP
      TOT_SMS_DSN_CTR = TOT_SMS_DSN_CTR + 1
      HLQ_SMS_L0KB = HLQ_SMS_L0KB + DCDALLSP
      HLQ_SMS_DSN_CTR = HLQ_SMS_DSN_CTR + 1
      END
 RETURN

/***********************************************************/
/* PUT IN "M" INFO FOR NEW DATASET                         */
/***********************************************************/
 MNEWINFO:
/*                                                          */
   HLQ_ALL_DSN_CTR = HLQ_ALL_DSN_CTR + 1
   TOT_ALL_DSN_CTR = TOT_ALL_DSN_CTR + 1
   IF BITAND(UMFLAG1,'40'X) = '40'X THEN DO
      HLQ_ML1_DSN_CTR = HLQ_ML1_DSN_CTR + 1
      TOT_ML1_DSN_CTR = TOT_ML1_DSN_CTR + 1
      HLQ_ML1_ORGKB = HLQ_ML1_ORGKB + UMALLSP
      HLQ_KB = HLQ_KB + UMALLSP
      HLQ_ML1KB = HLQ_ML1KB + UMDSIZE
      TOT_ML1_ORGKB = TOT_ML1_ORGKB + UMALLSP
      TOT_KB = TOT_KB + UMALLSP
      TOT_ML1KB = TOT_ML1KB + UMDSIZE
      END
     ELSE DO
      HLQ_ML2_DSN_CTR = HLQ_ML2_DSN_CTR + 1
      TOT_ML2_DSN_CTR = TOT_ML2_DSN_CTR + 1
      HLQ_ML2_ORGKB = HLQ_ML2_ORGKB + UMALLSP
      HLQ_KB = HLQ_KB + UMALLSP
      HLQ_ML2KB = HLQ_ML2KB + UMDSIZE
      TOT_ML2_ORGKB = TOT_ML2_ORGKB + UMALLSP
      TOT_KB = TOT_KB + UMALLSP
      TOT_ML2KB = TOT_ML2KB + UMDSIZE
      END
 RETURN

/***********************************************************/
/* PUT IN "B" INFO FOR NEW DATASET                         */
/***********************************************************/
 BNEWINFO:
/*                                                          */
   HLQ_BKKB = HLQ_BKKB+UBDSIZE
   TOT_BKKB = TOT_BKKB+UBDSIZE
 RETURN

/***********************************************************/
/* INIT ALL HLQ SUMMARY FIELDS                             */
/***********************************************************/
 INITHLQ:
/*                                                          */
   HLQ_L0KB = 0
   HLQ_L0USEKB = 0
   HLQ_ML1_DSN_CTR = 0
   HLQ_ML1_ORGKB = 0
   HLQ_ML1KB = 0
   HLQ_ML2_DSN_CTR = 0
   HLQ_ML2_ORGKB = 0
   HLQ_ML2KB = 0
   HLQ_KB = 0
   HLQ_BKKB = 0
   HLQ_L0_DSN_CTR = 0
   HLQ_ALL_DSN_CTR = 0
   HLQ_SMS_L0KB = 0
   HLQ_SMS_DSN_CTR = 0
 RETURN

/***********************************************************/
/* INIT ALL TOT SUMMARY FIELDS                             */
/***********************************************************/
 INITTOT:
/*                                                          */
   TOT_L0KB = 0
   TOT_L0USEKB = 0
   TOT_ML1_DSN_CTR = 0
   TOT_ML1_ORGKB = 0
   TOT_ML1KB = 0
   TOT_ML2_DSN_CTR = 0
   TOT_ML2_ORGKB = 0
   TOT_ML2KB = 0
   TOT_KB = 0
   TOT_BKKB = 0
   TOT_L0_DSN_CTR = 0
   TOT_ALL_DSN_CTR = 0
   TOT_SMS_L0KB = 0
   TOT_SMS_DSN_CTR = 0
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD.J 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
   DCDALLSP = C2D(DCDALLSP)
   DCDUSESP = C2D(DCDUSESP)
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR RECORD.J 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
   UMALLSP = C2D(UMALLSP)
   UMDSIZE = C2D(UMDSIZE)
 RETURN

/***********************************************************/
/* PARSE   BACKUP   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCBRECP:
/*                                                          */
   PARSE VAR RECORD.J 1 . 25 UBDSNAM 69 UBFLAG1 70 UBDEVCL,
      71 UBDSORG 73 UBDSIZE 77 UBTIME 81 UBDATE 85 . 87 UBDATCL,
      117 . 119 UBSTGCL 149 . 151 UBMGTCL 181 UBRECRD 182 UBRECOR,
      183 UBBKLNG 185 UBFLAG2 186 . 187 UBNMIG 189 UBALLSP,
      193 UBUSESP 197 UBRECSP 200
   UBDSIZE = C2D(UBDSIZE)
 RETURN
./ ADD NAME=MULTIVOL 0109-15230-15232-1327-00071-00036-00000-APLKS   36
/* REXX                                                               */
/*                                                                    */
/* MULTIVOL                                                           */
/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */
/*             THE VOLSER AND DSN FOR ALL RECORDS                     */
/*             THAT HAVE A VOLUME SEQUENCE NUMBER > 1                 */
/*                                                                    */
/*    INPUT:   USERID()..DCOLLECT.RECDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  USERID()..DCOLLECT.MULTIVOL.DCCYYDDD                   */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/**********************************************************************/

TRACE N
"FREE DDNAME(FILEA)"
/* INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'"  */
 INNAME = "'"USERID()".DCOLLECT.RECDM'"
/* "ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPDM') DDNAME(FILEA) SHR" */
"ALLOC DSNAME("INNAME") DDNAME(FILEA) SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 12
    END

/* NEW CODE ADDED */
DATE = DATE('J')
SDATE = DATE('S')
CC = SUBSTR(SDATE,1,2)
CC = CC - 19
DATE = RIGHT(CC,2,'0')||DATE
ODATE = DATE('O')

 OUTNAME = "'"USERID()".DCOLLECT.MULTIVOL.D"||DATE||"'"
"ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(200,200) RELEASE DDNAME(OUTFILE)"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

PUSH "DCOLLECT RUN ON:" DATE ODATE
"EXECIO 1 DISKW OUTFILE "
PUSH " "
"EXECIO 1 DISKW OUTFILE "
/* END OF NEW CODE */

"EXECIO 10000 DISKR FILEA (STEM IN_REC."
DO WHILE IN_REC.0 > 0
   DO J = 1 TO IN_REC.0
      PARSE VAR IN_REC.J S1 5 DCURCTYP 7
      IF DCURCTYP <> 'D ' THEN ITERATE J
      PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 .  79 DCDVOLSR,
         85 . 123 DCDVOLSQ 125 .
      IF DCDVOLSQ > '0001'X THEN
         PUSH DCDVOLSR DCDDSNAM
   END
   "EXECIO 10000 DISKR FILEA (STEM IN_REC."
   "EXECIO * DISKW OUTFILE "
END
"EXECIO 0 DISKR FILEA (FINIS"
"FREE DDNAME(FILEA)"
"EXECIO * DISKW OUTFILE (FINIS"
"FREE ALL"
EXIT
./ ADD NAME=NONSMS   0106-15230-15231-1525-00373-00364-00000-APLKS   59
/* REXX                                                               */
/*                                                                    */
/* NONSMS                                                             */
/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */
/*             NON-SMS DSNS AND THE VOLSER THEY ARE ON.               */
/*             FOR EACH HLQ, LISTS OUT NUMBER OF DATASETS,            */
/*             SIZE IN KBYTES, SIZE FOR PRIME POOL (OURS IS           */
/*             DEFINED AS <102400 KBYTES), SIZE FOR LARGE POOL        */
/*             (ANY DSN >1024000 KBYTES), AND KYBTES NOT              */
/*             REFERENCED IN THE LAST 30 DAYS.                        */
/*                                                                    */
/*    INPUT:   USERID()..DCOLLECT.RECDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*             (NOTE: EVEN THOUGH D AND M ARE BOTH INPUT, ONLY        */
/*              D IS USED)                                            */
/*                                                                    */
/*    OUTPUT:  USERID()..DCOLLECT.NONSMS.DCCYYDDD                     */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */
/***********************************************************/
TRACE N
/*  INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'" */
 INNAME = "'"USERID()".DCOLLECT.RECDM'"
 "ALLOC DDNAME(INFILE) DA("INNAME") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

 EXCLUDES = 'HSM BHSM'
 EXCL = 'HSM BHS'

/***********************************************************/
/* SPECIAL PROCESSING FOR FIRST RECORD                     */
/***********************************************************/
 EOF = 'NO'
 FIRST = 'NO'
 DO UNTIL FIRST = 'YES'
    "EXECIO 1 DISKR INFILE"
    IF RC <> 0 THEN
       EOF = 'YES'
    ELSE DO
       PARSE PULL RECORD
       PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 17 DCUDATE 21 .,
          25 RECDSN 69 . 70 DCDFLAG1 71 . 231 DCDSTGRP 239 .
       IF BITAND(DCDFLAG1,'40'X) <> '40'X THEN FIRST = 'YES'
       IF DCURCTYP <> 'D ' THEN FIRST = 'NO'
       END
 END
 CALL INITDSN
 CALL INITHLQ
 CALL INITTOT
 DATE  = LEFT(C2X(DCUDATE),7)
 DSNAME=RECDSN
 PARSE VAR RECDSN RECHLQ "." .
 IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
 HLQ=RECHLQ

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
/* OUTNAME ="SMS.PMB.DCOLLECT.NONSMS.D"||DATE */
OUTNAME = "'"USERID()".DCOLLECT.NONSMS.D"||DATE||"'"
/* "ALLOC DSNAME('SMS.PMB.DCOLLECT.NONSMS.D"||DATE||"')", */
"ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(5000,5000) RELEASE DDNAME(OUTFILE)"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/* ADDING SOME CODE */
 DATE = LEFT(C2X(DCUDATE),7)
 ODATE = DATE('O',SUBSTR(DATE,3,5),'J')
/* FINISHED ADDING */
 COLDATE  = RIGHT(DATE,5)
 COLYY = LEFT(COLDATE,2)
 COLDDD = RIGHT(COLDATE,3)
 OUT_LINE = "DATA COLLECTED ON:" DATE ODATE
 PUSH OUT_LINE
 "EXECIO 1 DISKW OUTFILE"
 CALL OUTHEAD
 HLQ_DSN_CTR=1
 TOT_DSN_CTR=1
 CALL DCDRECP
 CALL DNEWINFO

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 EOF = 'NO'
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE"
   IF RC <> 0 THEN DO
      EOF = 'YES'
      CALL OUTLINE
      CALL OUTHLQ
      CALL OUTTOT
      END
   ELSE DO
      PARSE PULL RECORD
      PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 25 RECDSN 69 .
      PARSE VAR RECDSN RECHLQ "." .
      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
      SELECT
         WHEN(DCURCTYP='D ') THEN DO             /* ACTIVE DATA       */
                         CALL DCDRECP
                         IF BITAND(DCDFLAG1,'40'X) = '40'X THEN ITERATE
                         END
         WHEN(DCURCTYP='M ') THEN ITERATE        /* MIGRATED DATA     */
         OTHERWISE ITERATE    /* DO NOT PROCESS OTHER RECORD TYPES */
         END

/***********************************************************/
/*        OUTPUT OUTLINE TO FILE AND STORE NEW INFO        */
/***********************************************************/
      CALL OUTLINE
      DSNAME=RECDSN
      PARSE VAR RECDSN RECHLQ "." .
      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
         IF RECHLQ <> HLQ THEN CALL OUTHLQ
      IF WORDPOS(RECHLQ,EXCLUDES) = 0 THEN DO
         HLQ_DSN_CTR = HLQ_DSN_CTR + 1
         TOT_DSN_CTR = TOT_DSN_CTR + 1
         END
      HLQ = RECHLQ
      SELECT
         WHEN(DCURCTYP='D ') THEN DO         /* ACTIVE DATA       */
                          CALL DNEWINFO
                          END
         WHEN(DCURCTYP='M ') THEN NOP         /* MIGRATED DATA     */
         WHEN(DCURCTYP='B ') THEN NOP         /* BACKUP DATA       */
         OTHERWISE NOP        /* DO NOT PROCESS OTHER RECORD TYPES */
         END
      END
 END
 "EXECIO 0 DISKW OUTFILE (FINIS"
 "EXECIO * DISKR INFILE (FINIS"
 "FREE DDNAME(INFILE)"
 "FREE DDNAME(OUTFILE)"
 EXIT


/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                          */
    OUT_LINE = "  "
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
    OUT_LINE = LEFT(" ",17),
       RIGHT("DSN",7),
       RIGHT("L0",9),
       RIGHT("PRIME",9),
       RIGHT("LARGE",9),
       RIGHT(">30DAYS",9)
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
    OUT_LINE = LEFT("HLQ/DSN",17),
       RIGHT("COUNT",7),
       RIGHT("KBYTES",9),
       RIGHT("POOL",9),
       RIGHT("POOL",9),
       RIGHT("LASTREF",9)
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
    OUT_LINE = LEFT("-",17,"-"),
       RIGHT("-",7,"-"),
       RIGHT("-",9,"-"),
       RIGHT("-",9,"-"),
       RIGHT("-",9,"-"),
       RIGHT("-",9,"-")
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT OUT A DETAIL LINE                                   */
/***********************************************************/
 OUTDET:
/*                                                          */
   OUT_LINE = LEFT("  ",2),
      LEFT(DCDDSNAM,62),
      LEFT(DCDVOLSR,8)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT SUMMARIZED INFO OUT TO NEW FILE                     */
/***********************************************************/
OUTLINE:
   CALL INITDSN
 RETURN

/***********************************************************/
/* PUT SUMMARIZED HLQ INFO OUT TO NEW FILE                 */
/***********************************************************/
OUTHLQ:
/*                                                          */
   OUT_LINE = '*',
      LEFT(HLQ,8),
      '      ',
      RIGHT(HLQ_DSN_CTR,7),
      RIGHT(HLQ_L0KB,9),
      RIGHT(HLQ_PRKB,9),
      RIGHT(HLQ_LGKB,9),
      RIGHT(HLQ_GT30,9)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   CALL INITHLQ
 RETURN

/***********************************************************/
/* PUT SUMMARIZED TOTAL INFO OUT TO NEW FILE               */
/***********************************************************/
OUTTOT:
/*                                                          */
   OUT_LINE = '* TOTAL  ',
      '       ',
      RIGHT(TOT_DSN_CTR,7),
      RIGHT(TOT_L0KB,9),
      RIGHT(TOT_PRKB,9),
      RIGHT(TOT_LGKB,9),
      RIGHT(TOT_GT30,9)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT IN "D" INFO FOR NEW DATASET                         */
/***********************************************************/
 DNEWINFO:
/*                                                          */
   IF WORDPOS(SUBSTR(DCDDSNAM,1,3),EXCL) = 0 THEN DO
      L0KBYTES = DCDALLSP
      HLQ_L0KB = HLQ_L0KB+DCDALLSP
      TOT_L0KB = TOT_L0KB+DCDALLSP
      CALL REF
      IF L0KBYTES < 102400 THEN DO
            PRKBYTES = PRKBYTES
            HLQ_PRKB = HLQ_PRKB + DCDALLSP
            TOT_PRKB = TOT_PRKB + DCDALLSP
         END
         ELSE DO
            LGKBYTES = LGKBYTES
            HLQ_LGKB = HLQ_LGKB + DCDALLSP
            TOT_LGKB = TOT_LGKB + DCDALLSP
         END
      CALL OUTDET
      END
 RETURN


/***********************************************************/
/* CALULATE NUMBER OF DAYS SINCE LAST REFERENCE            */
/* ALL DATA, BOTH SMS AND NON-SMS                          */
/* BASED ON COLLECTION DATE OF DATA                        */
/***********************************************************/

 REF:
      IF REFDDD = '00000' THEN DO      /*  IF LASTREF = 0'S THEN      */
         REFYY = CREYY                 /*  SET LAST REFERENCE TO      */
         REFDDD = CREDDD               /*  CREATION DATE              */
         END
      IF COLDDD <= REFDDD THEN DO
         REFYY = REFYY - 1
         REFDDD = REFDDD + 365
         END
      REFDAYS = COLDDD - REFDDD
      REFYRS = COLYY - REFYY
      REFDAYS = REFDAYS + (REFYRS * 365)

      SYS = 'NO'
      VS = 'NO'
      VSINDX = 'NO'
      IF SUBSTR(DSN,1,9) = "SYS1.VVDS" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,9) = "SYS1.VTOC" THEN SYS = 'YES'
/*    IF SUBSTR(DSN,1,9) = "BHSM.VTOC" THEN SYS = 'YES' */
/*    IF SUBSTR(DSN,1,6) = "PAGE.V" THEN SYS = 'YES' */
      IF SUBSTR(DSN,1,9) = "PAGE.BCSP" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,4) = "SYS9" THEN SYS = 'YES'
      IF INDEX(DSN,'DUMYDSCB') >0 THEN SYS = 'YES'
      IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN DO
         VS = 'YES'
         IF INDEX(DSN,'INDEX') >0 THEN VSINDX = 'YES'
         END

      SELECT
         WHEN SYS = 'YES' THEN NOP
         WHEN VSINDX = 'YES' THEN NOP
         WHEN REFDAYS > 30 THEN DO
            GT30YTES = DCDALLSP
            HLQ_GT30 = HLQ_GT30 + DCDALLSP
            TOT_GT30 = TOT_GT30 + DCDALLSP
            END
      OTHERWISE
      END                                        /* END OF SELECT     */
 RETURN

/***********************************************************/
/* INIT ALL DSN SUMMARY FIELDS                             */
/***********************************************************/
 INITDSN:
/*                                                          */
   L0KBYTES = 0
   PRKBYTES = 0
   LGKBYTES = 0
   GT30YTES = 0
 RETURN

/***********************************************************/
/* INIT ALL HLQ SUMMARY FIELDS                             */
/***********************************************************/
 INITHLQ:
/*                                                          */
   HLQ_L0KB = 0
   HLQ_PRKB = 0
   HLQ_LGKB = 0
   HLQ_GT30 = 0
   HLQ_DSN_CTR = 0
   HLQ_TOT = 0
 RETURN

/***********************************************************/
/* INIT ALL TOT SUMMARY FIELDS                             */
/***********************************************************/
 INITTOT:
/*                                                          */
   TOT_L0KB = 0
   TOT_PRKB = 0
   TOT_LGKB = 0
   TOT_GT30 = 0
   TOT_DSN_CTR = 0
   TOT_TOT = 0
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
   DSN = DCDDSNAM
   DCDALLSP = C2D(DCDALLSP)
   DCDCREDT = RIGHT(LEFT(C2X(DCDCREDT),7),5)
   DCDLSTRF = RIGHT(LEFT(C2X(DCDLSTRF),7),5)
   REFYY = LEFT(DCDLSTRF,2)
   REFDDD = RIGHT(DCDLSTRF,3)
   CREYY = LEFT(DCDCREDT,2)
   CREDDD = RIGHT(DCDCREDT,3)
   CREATED = DCDCREDT
   DSORG = DCDDSORG
 RETURN

./ ADD NAME=PDSDIR1  0117-18043-19206-1103-00188-00282-00000-APLKS   39
/* REXX 2019-07-25 batch version */
/* --------------------------------------------------------- */
/* Purpose: Extract all of the PDS directory information     */
/*          from a input PDS.                                */
/*                                                           */
/*  Format: PDSDIR1  <srcpds>                                */
/*                                                           */
/*  Original Source: J. Kalinich, X4521                      */
/*     This version: L. Slaten                               */
/*       Input stack contains members to select from         */
/*       PDS directory.                                      */
/*       Output stack contains matching members found in     */
/*       PDS directory.                                      */
/*                                                           */
/* --------------------------------------------------------- */

/* Entering EXEC PDSDIR1  */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   Parse UPPER ARG parm2;

   /* Initialize Variables */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     srcpds_dsname = Strip(Word(parm2,1),"B","'");
   Else;
     Do;
       Say "Input PDS file not specified"
       Return (-16);
     End;

   /* Retrieve stack entries */
   count = 0;
   "QELEM";         /*retrieve the nbr of items in the buffer*/
   count = RC;
   RC = 0;

   A. = "";
   Do i=1 To count By +1;
     Pull row;
     A.i = Word(row,1);
   End;
   A.0 = count;

   /* Mainline */

   "ALLOC DDNAME(IPDSDIR) DSNAME('"srcpds_dsname"')",
   " RECFM(F) DSORG(PS) LRECL(256) BLKSIZE(256)",
   " SHR REUSE";
   EC = RC;
   If RC <> 0 Then;
     Do;
       Say "Input PDS file allocation failed, RC= :" EC;
       Return (-16);
     End;

   "EXECIO * DISKR IPDSDIR ( STEM DIR. FINIS "; /*read pds dir*/
   EC = RC;
   If RC <> 0 | dir.0 = 0 Then;
     Do;
       Say "Input PDS file has no members, RC= :" EC;
       Return (-16);
     End;

   i = 1;
   Do blk=1 To dir.0 By +1;
     /* Collect all of the member names in the input PDS */
     usedbytes = C2D(Substr(dir.blk,1,2));
     index = 3;               /*skip past used bytes*/
     Do While index < usedbytes;
       If Substr(dir.blk,index,8) = 'FFFFFFFFFFFFFFFF'x Then;
         Leave blk;
       If i > A.0 Then;
         Leave blk;
       pds2name = Substr(dir.blk,index,8);   /*member name*/
       pds2indc = Substr(dir.blk,index+11,1);
       len = Bitand(pds2indc,'1F'x);    /*isolate user data length*/
       userdata = C2D(len) * 2;         /*halfwords to bytes*/
       If userdata = 30 Then;           /*ISPF statistics?*/
         Do;
           vv = C2D(Substr(dir.blk,index+12,1));
           mm = C2D(Substr(dir.blk,index+13,1));
           created = Date('S',P2D(Substr(dir.blk,index+17,3)),'J');
           lastmod = Date('S',P2D(Substr(dir.blk,index+21,3)),'J');
           timehm = P2D(Substr(dir.blk,index+24,3));
           timehm = Strip(timehm,'L','-');                  /*lks*/
           timehm = Substr(timehm,1,2)||':'||Substr(timehm,3,2);
           size = C2D(Substr(dir.blk,index+26,2));
           init = C2D(Substr(dir.blk,index+28,2));
           mod = C2D(Substr(dir.blk,index+30,2));
           id = Substr(dir.blk,index+32,8);
           Select;
             When pds2name < A.i Then;
               Nop;
             When pds2name = A.i Then;
               Do;
                 Queue pds2name||" ",
                      Right(vv,2,0)"."Right(mm,2,0)||" ",
                      created||" ",
                      lastmod,
                      timehm,
                      Format(size,5),
                      Format(init,5),
                      Format(mod,5)||" ",
                      id;
                 i = i+1;
               End;
             When pds2name > A.i Then;
               Do;
                 i = i+1;
                 Iterate;
               End;
           End;
         End;
       Else;
         Select;
           When pds2name < A.i Then;
             Nop;
           When pds2name = A.i Then;
             Do;
               Queue pds2name;
               i = i+1;
             End;
           When pds2name > A.i Then;
             Do;
               i = i+1;
               Iterate;
             End;
         End;
       index = index + 11 + userdata + 1;    /*skip to next entry*/
     End;
   End;
   "FREE DDNAME(IPDSDIR)";

   Return (0);

   /* ------------------------ */
   /* Local Performed Routines */
   /* ------------------------ */

   P2D: Procedure
   /* rexx      convert packed decimal to number */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Parse ARG number_p;
   erg = C2X(number_p);
   sign = Right(erg,1);
   number = Left(erg,Length(erg)-1);
   If sign = 'D' Then;
     Return '-'||number;
   Else;
     Return number;

   D2P: Procedure
   /* rexx   convert number to packed decimal  */
   /* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
   /* Tel: +49-711-2012-387                                       */
   /* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
   Arg number;
   If datatype(number) <> 'NUM' Then;
     Return '';
   If number < 0 Then;
      Interpret "number_p = '"ABS(number)"D'x";
   Else;
      Interpret "number_p = '"number"C'x";
   Return number_p;

/* J. KALINICH, X4521 */
/* EXEC TO DEBLOCK PDS DIRECTORY                                      */
./ ADD NAME=PDSUTIL  0128-14135-15279-1502-00383-00186-00000-APLKS   18
/* REXX */
/* --------------------------------------------------------- */
/* Purpose: Invoke Library Management commands on all        */
/*          members found in member.                         */
/*                                                           */
/*  Format: PDSUTIL member                                   */
/*                                                           */
/*     Use: From the ISPF Dataset/Member (3.4) enter         */
/*          PDSUTIL in the command area beside the member    */
/*          (created by macro PDSMLST).                      */
/*                                                           */
/*          Some additional changes will need to be made to  */
/*          member before processing.  The 1st column needs  */
/*          to be the command (DELETE,RENAME,COPY) to apply  */
/*          to each member (2nd column).  If RENAME is       */
/*          selected then the new member name needs to be    */
/*          added (3rd column).  Use macro DUP to make       */
/*          changes. COPY commands must follow all DELETE    */
/*          and RENAME commands.                             */
/*                                                           */
/*          The exec will ask for the target PDS name.       */
/*          All of the member names found in member will be  */
/*          processed using LM commands on the target PDS.   */
/*                                                           */
/* --------------------------------------------------------- */
   Address ISPEXEC "CONTROL ERRORS RETURN";
   Address ISPEXEC "VGET (DEBUG) PROFILE";
   If debug = "DEBUG" Then;
     Do;
       x = MSG("ON");
       Trace R;
     End;
   Else;
     x = MSG("OFF");

/* Entering EXEC PDSUTIL */

   Address TSO;
   "PROFILE NOPREFIX";

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Do;
       Parse UPPER ARG parm2 rest;
       If parm2 = "?" | parm2 = "HELP" Then;
         Signal Error_EXEC_HELP;
     End;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the control file:";
       Parse UPPER EXTERNAL parm2 rest;
     End;

   /* Initialize Variables */
   EC = "0";
   onlycpy = "";
   ctlseq_dsname = "";
   srcpds_dsname = "";
   tgtpds_dsname = "";

   /* Parse the User Options */

   /* Parse User Passed Parms */

   If parm2 <> "" Then;
     ctlseq_dsname = Strip(parm2);
   Else;
     Signal Error_NO_DATA;

   /* Point to dataset with all of the members to be processed */

   "ALLOC DSNAME("ctlseq_dsname") ",
              "DDNAME(DVRLIST) SHR REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_CTL_DATASET;

   "EXECIO 0 DISKR DVRLIST ( OPEN ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_SRC_DATASET;

   /* Mainline */

   Say "Please enter the target PDS:";
   Pull tgtpds_dsname .;
   If tgtpds_dsname = "" Then;
     Signal Error_NO_DATA;

   /* Point to PDS to be modified */
   Address ISPEXEC "LMINIT DATAID("tgtid")",
        " DATASET("tgtpds_dsname")",
        " ENQ(EXCLU)";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_DATASET;

   Address ISPEXEC "LMOPEN DATAID("tgtid")",
        " OPTION(OUTPUT)",
        " ORG("tgtorg")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_OPEN;

   If tgtorg <> "PO" Then;
     Signal Error_TGT_ORG;

   eof = "N";
   Do While eof = "N";
     Address TSO "EXECIO 1 DISKR DVRLIST ";
     If RC = 0 Then;
       Do;
         Pull line;
         Parse UPPER VAR line command "," tgtmbr "," newmbr .;
         command = Strip(command,"B");
         tgtmbr = Strip(tgtmbr,"B");
         newmbr = Strip(newmbr,"B");
         Select;
           When Abbrev(command,"DEL") & onlycpy <> "Y" Then;
             If tgtmbr <> "" Then;
               Do;
                 Address ISPEXEC "LMMDEL DATAID("tgtid")",
                      " MEMBER("tgtmbr")";
                 EC = RC;
                 If RC > 8 Then;
                   Signal Error_TGT_MDEL;
               End;
           When Abbrev(command,"REN") & onlycpy <> "Y" Then;
             If tgtmbr <> "" & newmbr <> "" Then;
               Do;
                 Address ISPEXEC "LMMREN DATAID("tgtid")",
                      " MEMBER("tgtmbr")",
                      " NEWNAME("newmbr")";
                 EC = RC;
                 If RC > 8 Then;
                   Signal Error_TGT_MREN;
               End;
           When Abbrev(command,"COP") Then;
             If tgtmbr <> "" Then;
               Do;
                 Select;
                   When onlycpy <> "Y" Then;
                     Do;
                       onlycpy = "N";
                       Address ISPEXEC "LMCLOSE DATAID("tgtid")";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_TGT_CLOSE;
                       Say "Please enter the source PDS:";
                       Pull srcpds_dsname .;
                       If srcpds_dsname = "" Then;
                         Signal Error_NO_DATA;
                       /* Point to the source PDS */
                       Address ISPEXEC "LMINIT DATAID("srcid")",
                            " DATASET("srcpds_dsname")",
                            " ENQ(SHR)";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_SRC_DATASET;
                       Address ISPEXEC "LMCOPY FROMID("srcid")",
                            " TODATAID("tgtid")",
                            " FROMMEM("tgtmbr")",
                            " REPLACE ";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_SRC_COPY;
                       onlycpy = "Y";
                     End;
                   When onlycpy = "Y" Then;
                     Do;
                       Address ISPEXEC "LMCOPY FROMID("srcid")",
                            " TODATAID("tgtid")",
                            " FROMMEM("tgtmbr")",
                            " REPLACE ";
                       EC = RC;
                       If RC <> 0 Then;
                         Signal Error_SRC_COPY;
                     End;
                   Otherwise;
                     Signal Error_SRC_COPY;
                 End;
               End;
           When Abbrev(command,"COMPRE") Then;
             Do;
               Address ISPEXEC "LMCLOSE DATAID("tgtid")";
               EC = RC;
               If RC <> 0 Then;
                 Signal Error_TGT_CLOSE;
               Address ISPEXEC "LMCOMP DATAID("tgtid")";
               EC = RC;
               If RC > 8 Then;
                 Signal Error_TGT_COMPRESS;
             End;
           Otherwise;
             Signal Error_INVALID_CMD;
         End;
       End;
     Else;
       eof = "Y";
   End;

   "EXECIO 0 DISKR DVRLIST ( FINIS ";

   If Abbrev(command,"COMPRE") = 1 | onlycpy <> "" Then;
     Nop;
   Else;
     Address ISPEXEC "LMCLOSE DATAID("tgtid")";
     EC = RC;
     If RC <> 0 Then;
       Signal Error_TGT_CLOSE;

   If onlycpy <> "" Then;
     Do;
       Address ISPEXEC "LMFREE DATAID("srcid")";
       EC = RC;
       If RC <> 0 Then;
         Signal Error_SRC_FREE;
     End;

   Address ISPEXEC "LMFREE DATAID("tgtid")";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_TGT_FREE;

   Exit (EC);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_EXEC_HELP:

   hex04 = "04"x;
   pad = Copies(" ",62);
   ZERRLM  = pad hex04,
        "Purpose: Invoke LM commands found in member",
        pad hex04,
        "         against a target PDS.",
        pad hex04,
        " Format: PDSUTIL member ";
   ZERRSM  = "";
   ZERRALRM= "NO";
   ZERRHM  = "*";
   Address ISPEXEC "SETMSG MSG(ISRZ002)";
   Exit;

   Error_INVALID_CMD:

   ZEDSMSG = "INVALID CMD";
   ZEDLMSG = "INVALID CMD FOUND IN "ctlseq_dsname,
             " CMD=" command;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("srcid")";
   Address ISPEXEC "LMFREE DATAID("srcid")";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Exit (-16);

   Error_NO_DATA:

   ZEDSMSG = "MISSING DSNAME";
   ZEDLMSG = "NO DATASET SPECIFIED";
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_CTL_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Control dataset" ctlseq_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_SRC_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Source dataset" srcpds_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_SRC_COPY:

   ZEDSMSG = "Copy failed";
   ZEDLMSG = "Copy failed on member" tgtmbr,
             " RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("srcid")";
   Address ISPEXEC "LMFREE DATAID("srcid")";
   Exit (-16);

   Error_SRC_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Source dataset" srcpds_dsname,
             " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   DROPBUF;
   Exit (-16);

   Error_TGT_DATASET:

   ZEDSMSG = "Dataset not found";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " not found, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Exit (-16);

   Error_TGT_OPEN:

   ZEDSMSG = "Dataset not opened";
   ZEDLMSG = "Target dataset" tgtpds_dsname "not opened, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_ORG:

   ZEDSMSG = "Dataset not PDS/E";
   ZEDLMSG = "Target dataset" tgtpds_dsname "not a PDS/E, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid") ";
   Exit (-16);

   Error_TGT_MDEL:

   ZEDSMSG = "Member DELETE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "DELETE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_MREN:

   ZEDSMSG = "Member RENAME failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "RENAME failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_COMPRESS:

   ZEDSMSG = "Library CMPR failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "COMPRESS failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMCLOSE DATAID("tgtid")";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_CLOSE:

   ZEDSMSG = "CLOSE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname "CLOSE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   Address ISPEXEC "LMFREE DATAID("tgtid")";
   Return (-16);

   Error_TGT_FREE:

   ZEDSMSG = "FREE failed";
   ZEDLMSG = "Target dataset" tgtpds_dsname,
             " FREE failed, RC=" EC;
   Address ISPEXEC "SETMSG MSG(ISRZ000)";
   DROPBUF;
   Exit (-16);
./ ADD NAME=RCNVTCAT
/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX                     */
/**********************************************************************/
/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */
/**********************************************************************/
/* Author : Alastair Gray - a_j_gray@hotmail.com                      */
/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */
/*                                                                    */
/* This was an extension of previous work that was initially derived  */
/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */
/*                                                                    */
/**********************************************************************/
/* The report dataset will now always be dynamically allocated        */
/* and will be userid/prefix.rcnvtcat.report.Tnnnn                    */
/**********************************************************************/
/* Changes :                                                          */
/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */
/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */
/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */
/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */
/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */
/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */
/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/
/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */
/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */
/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */
/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */
/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */
/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */
/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */
/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */
/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/
/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */
/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */
/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/
/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */
/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */
/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */
/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */
/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */
/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */
/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &           */
/*                                        make UNIX shell compatible  */
/* 1.7.2   - 08/11/2016 - Lionel Dyck   - Add TARGET keyword          */
/**********************************************************************/
/* Notes :                                                            */
/*                                                                    */
/* 1. This program writes out various error messages, the return and  */
/*    reason codes can be checked using those found listed for the    */
/*    IBM message IDC3009I. The module is the CSI internal reference  */
/*    and probably isn't of much use to anyone outside IBM.           */
/*                                                                    */
/* 2. Two return codes are 'special' :                                */
/*    RC=100, Reason=4                                                */
/*    RC=44 , Reason=14                                               */
/*    These relate to entries of greater than 65535 characters.       */
/*    If you get these entries, then you need to enable fullword      */
/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */
/*                                                                    */
/**********************************************************************/
/* So how does this differ from the original MCNVTCAT ?               */
/*                                                                    */
/* 1. Well it's written in REXX and uses the Catalog Search Interface */
/*                                                                    */
/* 2. It doesn't check the actual devices available on the system     */
/*    (So you may get a catalog entry for a non-present device type)  */
/*                                                                    */
/* 3. It doesn't add bits of LISTCAT messages into the report totals  */
/*    or the generated members.                                       */
/*                                                                    */
/* 4. It DOES handle datasets cataloged on more than five volume !    */
/*    (So doesn't write out an error message for that condition)      */
/*                                                                    */
/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */
/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */
/*    guess this shouldn't be an issue for many out there.            */
/*                                                                    */
/* 6. It writes its report to the REPORT member of the PDS rather     */
/*    than to a SYSOUT.                                               */
/*                                                                    */
/* 7. It generates a RECAT member that contains statements to allow   */
/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */
/*                                                                    */
/*    Currently this only supports VSAM clusters with the following   */
/*    non-default attributes : LINEAR, REUSE                          */
/*                                                                    */
/* 8. It can be used to compare two catalogs and produces reports     */
/*    showing the differences between the catalogs.                   */
/*                                                                    */
/**********************************************************************/
Trace O                              /* Trace Off                     */
If (Address() = 'TSO') Then          /* test if under TSO             */
 Do                                  /*                               */
  x = Msg('Off')                     /* Disable messages              */
  x = Prompt('Off')                  /* Disable prompts               */
 End                                 /*                               */
/**********************************************************************/
/* extract / check and set environment variables                      */
/**********************************************************************/
cvt      = Storage(10,4)             /* get the CVT address           */
cvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */
mvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */
If (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/
 omvs_flag = 'OMVS'                  /* set OMVS flag                 */
If Address() = 'SH' Then             /* test for UNIX shell environ   */
 sh_flag = 'SH'
If (Mvsvar("SYSSMS") = 'ACTIVE') Then/* test for SMS environment      */
 sms_flag = 'SMS'                    /* set SMS flag                  */
If (Address() = 'TSO') Then          /* test for tso environment      */
 tso_flag = 'TSO'                    /* set TSO flag                  */
If (tso_flag = 'TSO') Then           /* if TSO environment            */
 Do                                  /*                               */
  If (Sysvar("SYSENV") = 'FORE') Then/* test for foreground           */
   env_flag = 'FORE'                 /* set ENV flag                  */
  If (Sysvar("SYSISPF") = 'ACTIVE') Then/* test for ISPF              */
   ispf_flag = 'ISPF'                /* set ISPF flag                 */
 End                                 /*                               */
If (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */
   (sh_flag /= 'SH') &,              /* it not UNIX shell             */
   (tso_flag /= 'TSO') Then          /* and no TSO                    */
 Do                                  /*                               */
  Say '**(Error-1)* No TSO environment and no UNIX environment.'
  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'
  Signal FINISH                      /* leave the exec                */
 End                                 /*                               */
/**********************************************************************/
/* Initialise the relevant CSI variables                              */
/**********************************************************************/
cat.1 = ' '                          /* Set catalog name              */
flt = '**'                           /* Set the filter                */
typ = ' '                            /* Set entry types required      */
ct1 = ' '                            /* Set for 1 catalog only        */
rcnvdsn = ''                         /* set dsn to null               */
/**********************************************************************/
/* Handle passed parameters                                           */
/**********************************************************************/
Arg vals                             /* Get passed arguments          */
argnum = 0                           /*                               */
targ_cat = ''                        /* set target catalog to null    */

/* ------------------------------------- *
 | Check for TARGET(newcatalog) keyword: |
 | - not found then done here            |
 | - found then extract                  |
 |   - save target catalog name          |
 |   - remove from parameters            |
 * ------------------------------------- */
if pos("TARGET(",translate(vals)) > 0 then do
   parse value translate(vals) with val_left "TARGET("targ_cat")" val_right
   vals = val_left val_right
   if left(targ_cat,1) = "'" then
      parse value targ_cat with "'"targ_cat"'"
   end

Do i = 1 to Words(vals)              /* loop thru arguments           */
 testarg = Strip(Word(vals,i),B,"'") /* remove inverted commas        */
 Upper testarg                       /* convert to upper case         */
 Select                              /*                               */
  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */
   Do                                /*                               */
    debug = Substr(testarg,7,1)      /* get debug value               */
    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */
   End                               /*                               */
  When (testarg = '?') Then          /*                               */
   Do                                /*                               */
    Say "RCNVTCAT requires either one or two parameters"
    Say " - RCNVTCAT catname       : produces MCNVTCAT type output"
    Say " - RCNVTCAT oldcat newcat : produces catalog comparison output"
    Say " - RCNVTCAT oldcat TARGET(newcat) : produce recatalog output"*/
    Signal FINISH                    /*                               */
   End                               /*                               */
  Otherwise                          /*                               */
   Do                                /*                               */
    argnum = argnum + 1              /*                               */
    cat.argnum = testarg             /*                               */
   End                               /*                               */
 End                                 /*                               */
End                                  /*                               */
Select                               /*                               */
 When (argnum = 0) Then              /*                               */
  Do                                 /*                               */
   Say '**(cat)** No entry provided for catalog name.'
   Signal FINISH                     /* exit exec                     */
  End                                /*                               */
 When (argnum = 1) Then              /* only one catalog              */
  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */
 When (argnum = 2) Then              /* two catalogs                  */
  process = 'CATCOMP'                /* process for Catalog compare   */
 Otherwise                           /* two catalogs                  */
  Do                                 /*                               */
   Say '**(cat)** Too many arguments - retry.'
   Signal FINISH                     /* exit exec                     */
  End                                /*                               */
End                                  /*                               */
/**********************************************************************/
If (DsExist("'"cat.1"'") > 4) Then /*                               */
 Do                                /*                               */
  Say '**(cat)** Bad entry provided for catalog name.'
  Say '**(cat)** 'cat.1
  Say '**(cat)** LISTDSI Return code = 'sysreason
  Say '**(cat)** 'sysmsglvl1
  Say '**(cat)** 'sysmsglvl2
  Signal FINISH                    /* exit exec                     */
 End                               /*                               */
If (process = 'CATCOMP') &,        /* Catalog compare processing    */
   (DsExist("'"cat.2"'") > 4) Then /* bad return                    */
 Do                                /*                               */
  Say '**(cat)** Bad entry provided for second catalog name.'
  Say '**(cat)** 'cat.2
  Say '**(cat)** LISTDSI Return code = 'sysreason
  Say '**(cat)** 'sysmsglvl1
  Say '**(cat)** 'sysmsglvl2
  Signal FINISH                    /* exit exec                     */
 End                               /*                               */
/**********************************************************************/
/* Setup for output of reports                                        */
/**********************************************************************/
Call DSN_HANDLING
/**********************************************************************/
/* Initialise the various totals variables                            */
/**********************************************************************/
Call TOT_INIT                        /* Initialise totals             */
/**********************************************************************/
/* CSI Processing section                                             */
/**********************************************************************/
If (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */
 Do                                  /*                               */
  count.id = 0                       /* initialise count              */
  member = 'ALIAS'                   /* processing ALIAS              */
  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'NONVSAM'                 /* processing NONVSAM            */
  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'SYS1'                    /* processing SYS1               */
  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'IMPORT'                  /* processing IMPORT             */
  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'GDG'                     /* processing GDG                */
  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'MISC'                    /* processing MISC               */
  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'RECAT'                   /* processing RECAT (MISC+)      */
  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'SYSCTLG'                 /* processing SYSCTLG            */
  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */
  Call WRITE_MEMBER                  /* write-out member              */
  member = 'REPORT'                  /* processing REPORT             */
  Call MEM_REPORT                    /* generate report               */
  Call WRITE_MEMBER                  /* write out member              */
 End                                 /*                               */
Else                                 /* Process as Catalog compare    */
 Do                                  /*                               */
  id = 'OLD'                         /* specify for 'old' catalog     */
  count.id = 0                       /* initialise count              */
  cat.old = cat.1                    /* retain catalog name           */
  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */
  id = 'NEW'                         /* specify for 'NEW' catalog     */
  count.id = 0                       /* initialise count              */
  cat.new = cat.2                    /* retain catalog name           */
  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */
  member = 'COMPFULL'                /* processing FULL comparison    */
  Call COMP_REPORT                   /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'COMPSHRT'                /* processing SHORT comparison   */
  Call COMP_REPORT                   /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'EXTRA'                   /* processing EXTRA member       */
  Call NEW_EXT                       /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
  member = 'CHANGED'                 /* processing CHANGED member     */
  Call OLD_BAD                       /* Build the report              */
  Call WRITE_MEMBER                  /* write the report              */
 End                                 /*                               */
/**********************************************************************/
/* Display output if foreground ISPF                                  */
/**********************************************************************/
If (env_flag = 'FORE') &,            /*                               */
   (ispf_flag = 'ISPF') Then         /*                               */
 Do                                  /*                               */
  x = Listdd(REPORT)                 /*                               */
  Address ISPEXEC "EDIT DATASET('"rcnvdsn"')"
  Address TSO "Free Fi(REPORT)"      /* free the report file          */
 End                                 /*                               */
/**********************************************************************/
/* Finish the REXX                                                    */
/**********************************************************************/
FINISH:                              /*                               */
Exit 0                               /* Exit the code                 */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
CSI:                                 /* CSI procedure start         ##*/
Arg cat,flt,typ,ct1                  /* get passed arguments          */
/**********************************************************************/
/* Initialise the parameter list                                      */
/**********************************************************************/
modrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */
csifiltk = Substr(flt,1,44)          /* move filter key into list     */
csicatnm = Substr(cat,1,44)          /* clear catalog name            */
csiresnm = Substr(' ',1,44)          /* clear resume name             */
csidtyps = Substr(typ,1,16)          /* clear entry types             */
csicldi  = Substr('Y',1,1)           /* indicate data and index       */
csiresum = Substr(' ',1,1)           /* clear resume flag             */
csis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */
/**********************************************************************/
bcp = mvsvar('sysmvs')               /*                               */
lev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */
If (lev > 609) Then                  /* os/390 R10 and up for fullword*/
 csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/
Else                                 /*                               */
 csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword used        */
 Say '**(csi)***** Fullword processing selected'
Else                                 /* check if fullword used        */
 Say '**(csi)***** Halfword processing - default'
/**********************************************************************/
/* Initialise requested fields                                        */
/**********************************************************************/
csinumen = '000E'X                   /* init number of fields         */
csifld01 = Left('ENTYPE  ',8)        /* type of entry                 */
csifld02 = Left('ENTNAME ',8)        /* name of entry                 */
csifld03 = Left('TYPE    ',8)        /* type of associated entry      */
csifld04 = Left('NAME    ',8)        /* name of associated entry      */
csifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */
csifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */
csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */
csifld08 = Left('ATTR1   ',8)        /* Attributes                    */
csifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */
csifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */
csifld11 = Left('VOLSER  ',8)        /* Volume serial number          */
csifld12 = Left('FILESEQ ',8)        /* File Sequence number          */
csifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */
csifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */
/**********************************************************************/
/* Build the selection criteria fields part of parameter list         */
/**********************************************************************/
csiopts  = csicldi ||csiresum||csis1cat||csioptns
csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
csifield = csifield||csifld11||csifld12||csifld13||csifld14
/**********************************************************************/
/* Initialise and build work are output part of parameter list        */
/**********************************************************************/
csiusrln = 524288                    /* CSIUSRLN work area length     */
                                     /* range from 1024 to 1048575    */
dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/**********************************************************************/
/* Initialise work variables                                          */
/**********************************************************************/
csiresum = 'Y'
/**********************************************************************/
/* Set up loop for resume (if a resume is necessary)                  */
/**********************************************************************/
Do While csiresum = 'Y'
/**********************************************************************/
/* Issue link to CSI - Catalog Search Interface                       */
/**********************************************************************/
 Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
 r15 = rc                            /* get returned code             */
 mod = Substr(modrsnrc,1,2)          /* get module code               */
 res = C2d(Substr(modrsnrc,3,1))     /* get return code               */
 ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */
 If (r15 > 0) Then                   /* when error occured            */
  Do
   Say '**(Error-1)* CSI processing.'
   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
  End
/**********************************************************************/
 csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */
 csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */
 csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */
 csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */
 csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */
 If (csireqln > csiusrln) Then       /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* Work Area defined  = 'csiusrln
   Say '**(Error-2)* Work Area used     = 'csiusdln
   Say '**(Error-3)* Work Area required = 'csireqln
   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'
  End                                /*                               */
 If (csiusdln < 65) Then Leave       /* No entries returned           */
 off = 15                            /* Starting position             */
/**********************************************************************/
/* Process data returned in work area                                 */
/**********************************************************************/
 Do While off < csiusdln             /* do until all data is processed*/
  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */
  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */
  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */
  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */
  If (debug = 2) Then                /*                               */
   Do                                /*                               */
    Say 'off=<'off'>'                /*                               */
    Say 'entry =<'Substr(dwork,off,150)'>'
    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'
   End                               /*                               */
  mod = Substr(csi_retn,1,2)         /* get CSI module                */
  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */
  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */
  If (csi_type = '0') Then           /* Catalog entry                 */
   Do                                /*                               */
    If (ret > 0) Then                /* test catalog return code      */
     Do
      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'
      Say '**(Error-2)* Module='mod' Return='ret' Reason='res
     End
    csicname = csi_name              /* set the catalog name          */
    plus = 50                        /* length for catalog entry      */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    csiename = csi_name              /* use the entry name            */
    csietype = csi_type              /* use the entry name            */
    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */
    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */
    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */
    Select                           /*                               */
     When (csienter = '1') Then      /*                               */
      Do                             /*                               */
       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say '**(Error-2)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     When (csiedata = '0') Then      /*                               */
      Do                             /*                               */
       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'
       Say '**(Error-2)* No data returned'
       Say '**(Error-3)* Module='mod' Return='ret' Reason='res
       plus = 50                     /* length for error entry        */
      End                            /*                               */
     Otherwise                       /*                               */
      Do                             /*                               */
       If (csioptns = 'F') Then      /* check if fullword requested   */
        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */
       Else                          /* otherwise (default halfword)  */
        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */
       Call ENTRY                    /* Execute entry processing      */
       plus = 46 + csitotln          /* length for normal entry       */
      End                            /*                               */
    End                              /*                               */
   End                               /*                               */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
   Call DATA_HANDLING                /*                               */
/**********************************************************************/
/* increment for next entry                                           */
/**********************************************************************/
  off = off + plus                   /* build new offset              */
 End                                 /*                               */
End                                  /*                               */
/**********************************************************************/
/* Complete CSI Procedure                                             */
/**********************************************************************/
Return 0                             /*                               */
/**********************************************************************/

/**********************************************************************/
/* Process entry fields to extract data                               */
/**********************************************************************/
ENTRY:                               /* Start entry processing      ##*/
/**********************************************************************/
/* entry field size and location extraction                           */
/**********************************************************************/
If (csioptns = 'F') Then             /* check if fullword requested   */
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */
  e_pos = 12                         /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */
   e_pos = e_pos + 4                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
Else                                 /* otherwise (default halfword)  */
/**********************************************************************/
 Do                                  /* field length length of 4      */
  e_off = off + 46                   /* get offset to entries         */
  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */
  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */
  e_pos = 6                          /* set offset of second field    */
  If (debug = 1) Then                /*                               */
   Do                                /*                               */
    Say "e_off="e_off                /*                               */
    Say "C=<"Substr(dwork,e_off,200)">" /*                            */
    Say "X=<"C2x(Substr(dwork,e_off,200))">" /*                       */
    Say "o_fld.1="o_fld.1",hex="C2x(o_flds.1) /*                      */
    Say "l_fld.1="l_fld.1",hex="C2x(l_flds.1) /*                      */
   End                               /*                               */
  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */
   prv = flds - 1                    /* set 'previous' value          */
   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */
   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */
   e_pos = e_pos + 2                 /*                               */
   If (debug = 1) Then               /*                               */
    Do                               /*                               */
     Say "o_fld."flds"="o_fld.flds",hex="C2x(o_flds.flds) /*          */
     Say "l_fld."flds"="l_fld.flds",hex="C2x(l_flds.flds) /*          */
    End                              /*                               */
  End                                /*                               */
 End                                 /*                               */
/**********************************************************************/
/* entry field extraction                                             */
/**********************************************************************/
entype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */
entname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */
type     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */
name     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */
gdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */
gdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */
dscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */
attr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */
cattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */
devtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */
volser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */
fileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */
vsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/
vsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/
/**********************************************************************/
/* entry re-processing section                                        */
/**********************************************************************/
vsam_attr = ''                           /* initialise vsam attributes*/
If (Index(csifield,'DEVTYP') > 0) Then   /*                           */
 Call FLD_DEVTYP                         /*                           */
If (Index(csifield,'ENTYPE') > 0) Then   /*                           */
 Call FLD_ENTYPE                         /*                           */
If (Index(csifield,'ATTR1') > 0) Then    /*                           */
 Call FLD_ATTR1                          /*                           */
If (Index(csifield,'CATTR') > 0) Then    /*                           */
 Call FLD_CATTR                          /*                           */
If (Index(csifield,'ENTNAME') > 0) Then  /*                           */
 Call FLD_ENTNAME                        /*                           */
If (Index(csifield,'FILESEQ') > 0) Then  /*                           */
 Call FLD_FILESEQ                        /*                           */
If (Index(csifield,'GDGATTR') > 0) Then  /*                           */
 Call FLD_GDGATTR                        /*                           */
If (Index(csifield,'GDGLIMIT') > 0) Then /*                           */
 Call FLD_GDGLIMIT                       /*                           */
If (Index(csifield,'VOLSER') > 0) Then   /*                           */
 Call FLD_VOLSER                         /*                           */
If (Index(csifield,'VSAMTYPE') > 0) Then /*                           */
 Call FLD_VSAMTYPE                       /*                           */
If (Index(csifield,'VSAMREUS') > 0) Then /*                           */
 Call FLD_VSAMREUS                       /*                           */
If (Index(csifield,'DSCRDT2') > 0) Then  /*                           */
 Call FLD_DSCRDT2                        /*                           */
/**********************************************************************/
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTYPE   - Process ENTYPE   field                              */
/**********************************************************************/
FLD_ENTYPE:                          /* ENTYPE   field processing   ##*/
Select                               /* decode type flag              */
 When (entype = 'C') Then entype = 'CLUSTER'  /*                      */
 When (entype = 'D') Then entype = 'DATA'     /*                      */
 When (entype = 'I') Then entype = 'INDEX'    /*                      */
 When (entype = 'A') Then entype = 'NONVSAM'  /*                      */
 When (entype = 'H') Then entype = 'GDS'      /*                      */
 When (entype = 'B') Then entype = 'GDG'      /*                      */
 When (entype = 'R') Then entype = 'PATH'     /*                      */
 When (entype = 'G') Then entype = 'AIX'      /*                      */
 When (entype = 'X') Then entype = 'ALIAS'    /*                      */
 When (entype = 'U') Then entype = 'UCAT'     /*                      */
 Otherwise                           /*                               */
  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)
  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
  entype = ' '                       /* unknown type                  */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ENTNAME  - Process ENTNAME  field                              */
/**********************************************************************/
FLD_ENTNAME:                         /* ENTNAME  field processing   ##*/
If (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */
 entname = Left(C2x(entname),44)     /* Return hex value              */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGLIMIT - Process GDGLIMIT field                              */
/**********************************************************************/
FLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/
gdglimit = X2d(C2x(gdglimit))        /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_GDGATTR  - Process GDGATTR  field                              */
/**********************************************************************/
FLD_GDGATTR:                         /* GDGATTR  field processing   ##*/
gdgattr = X2b(C2x(gdgattr))          /*                               */
If (Substr(gdgattr,1,1) = '1') Then  /*                               */
 gdg_emp = 'EMPTY'                   /*                               */
Else                                 /*                               */
 gdg_emp = 'NOEMPTY'                 /*                               */
If (Substr(gdgattr,2,1) = '1') Then  /*                               */
 gdg_scr = 'SCRATCH'                 /*                               */
Else                                 /*                               */
 gdg_scr = 'NOSCRATCH'               /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DSCRDT2  - Process DSCRDT2  field                              */
/**********************************************************************/
FLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/
If (Substr(dscrdt2,1,2) /= 'FFFF'X) Then
 Do                                  /*                               */
  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */
  yy    = Substr(yyddd,1,2)          /*                               */
  ddd   = Substr(yyddd,3,3)          /*                               */
  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */
  If (cent = '00') Then              /*                               */
   yyyy    = yy + 1900               /*                               */
  Else                               /*                               */
   yyyy    = yy + 2000               /*                               */
  If (yyyy = '1900') Then            /* correct for '00'              */
   yyyy = '2000'                     /*                               */
  savcrdt2 = dscrdt2
  dscrdt2 = yyyy'.'ddd               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_ATTR1    - Process ATTR1    field                              */
/**********************************************************************/
FLD_ATTR1:                           /* ATTR1    field processing   ##*/
attr1 = X2b(c2x(attr1))              /*                               */
If (Substr(attr1,1,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' SPEED'       /*                               */
If (Substr(attr1,3,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' REUSE'       /*                               */
If (Substr(attr1,4,1) = '1') Then    /*                               */
 vsam_attr = vsam_attr' ERASE'       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_CATTR    - Process CATTR    field                              */
/**********************************************************************/
FLD_CATTR:                           /* CATTR    field processing   ##*/
cattr = X2b(C2x(cattr))              /*                               */
If (entype = 'CLUSTER') Then         /*                               */
 Do                                  /*                               */
  If (Substr(cattr,8,1) = '1') Then  /*                               */
   entype = 'PAGESPACE'              /*                               */
  If (Substr(cattr,7,1) = '1') Then  /*                               */
   pageswap = 'SWAP'                 /*                               */
  Else                               /*                               */
   pageswap = 'NOSWAP'               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */
/**********************************************************************/
FLD_DEVTYP:                          /* DEVTYP   field processing   ##*/
devices = ''                         /* initialise devices            */
Do d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */
 device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */
 d_model  = Substr(device,1,1)       /* get model byte                */
 d_option = Substr(device,2,1)       /* get option byte               */
 d_class  = Substr(device,3,1)       /* get class byte                */
 d_device = Substr(device,4,1)       /* get device byte               */
 Select                              /*                               */
  When (d_class = '80'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'TAPE'               /* Tape device                   */
    Select                           /*                               */
     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/
     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */
     When (d_device = '05'x) Then dev_type = '3410' /*                */
     When (d_device = '06'x) Then dev_type = '8809' /*                */
     When (d_device = '07'x) Then dev_type = '3430' /*                */
     When (d_device = '08'x) Then dev_type = '7340' /*                */
     When (d_device = '09'x) Then dev_type = '9374' /*                */
     When (d_device = '80'x) Then dev_type = '3480' /*                */
     When (d_device = '81'x) Then dev_type = '3490' /*                */
     When (d_device = '83'x) Then dev_type = '3590' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End                               /*                               */
  When (d_class = '20'x) Then        /*                               */
   Do                                /*                               */
    dev_class = 'DASD'               /* DASD device                   */
    Select                           /*                               */
     When (d_device = '04'x) Then dev_type = '9345' /*                */
     When (d_device = '09'x) Then dev_type = '3330' /*                */
     When (d_device = '0A'x) Then dev_type = '3340' /*                */
     When (d_device = '0B'x) Then dev_type = '3350' /*                */
     When (d_device = '0C'x) Then dev_type = '3375' /*                */
     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */
     When (d_device = '0E'x) Then dev_type = '3380' /*                */
     When (d_device = '0F'x) Then dev_type = '3390' /*                */
     When (device = '00000000'x) Then dev_type = '0000'     /*        */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
  Otherwise                          /*                               */
   Do                                /*                               */
    dev_class = 'UNKN'               /* Unknown device                */
    Select                           /*                               */
     When (device = '00000000'x) Then dev_type = '0000' /*            */
     Otherwise                       /*                               */
      dev_type = C2x(device)         /* show UCB if unknown           */
      Say '**(Error-1)* Device type processing for 'Strip(entname,T)
      Say '**(Error-2)* Device type = 'dev_type
    End                              /*                               */
   End
 End                                 /*                               */
 devices = devices||' '||Left(dev_type,8) /* build device list        */
End                                  /*                               */
devices = Strip(devices,B,' ')       /* clean up device list          */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VOLSER   - Process VOLSER   field                              */
/**********************************************************************/
FLD_VOLSER:                          /* VOLSER   field processing   ##*/
volsers = ''                         /*                               */
Do v_pos = 1 To Length(volser) By 6  /*                               */
 volume = Substr(volser,v_pos,6)     /*                               */
 If (Substr(volume,1,2) = '00'x) Then/*                               */
  volume = '000000'                  /*                               */
 volume = Right(Strip(volume,B),6)' '/*                               */
 volsers = volsers||'  '||volume     /*                               */
End                                  /*                               */
volser = Strip(volsers,B)            /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_FILESEQ  - Process FILESEQ  field                              */
/**********************************************************************/
FLD_FILESEQ:                         /* FILESEQ  field processing   ##*/
build = ''                           /*                               */
Do f_pos = 1 To Length(fileseq) By 2 /*                               */
 build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '
End                                  /*                               */
fileseq = build                      /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */
/**********************************************************************/
FLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/
Return                               /* duplicates ATTR1              */
vsamreus = X2b(C2x(vsamreus))        /* show binary flags             */
If (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */
 vsam_attr = vsam_attr' REUSE'       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* FLD_VSAMTYPE - Process VSAMTYPE field                              */
/**********************************************************************/
FLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/
vsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */
vsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */
Select                               /*                               */
 When (Substr(vsam_byte1,1,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'KSDS'                /*                               */
   vsam_attr = vsam_attr' INDEXED'   /*                               */
  End                                /*                               */
 When (Substr(vsam_byte1,7,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'RRDS'                /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,6,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'LDS'                 /*                               */
   vsam_attr = vsam_attr' LINEAR'    /*                               */
  End                                /*                               */
 When (Substr(vsam_byte2,8,1) = '1') Then /*                          */
  Do                                 /*                               */
   vsam_type = 'VRRDS'               /*                               */
   vsam_attr = vsam_attr' NUMBERED'  /*                               */
  End                                /*                               */
 Otherwise                           /*                               */
  Do                                 /*                               */
   vsam_type = 'ESDS'                /*                               */
   If (entype /= 'INDEX') Then       /*                               */
    vsam_attr = vsam_attr' NONINDEXED'/*                              */
  End                                /*                               */
End                                  /*                               */
If (Substr(vsam_byte1,2,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' WRITECHECK'  /*                               */
If (Substr(vsam_byte1,3,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' IMBED'       /*                               */
If (Substr(vsam_byte1,4,1) = '1') Then /*                             */
 vsam_attr = vsam_attr' REPLICATE'   /*                               */
If (entype /= 'INDEX') Then          /*                               */
 If (Substr(vsam_byte1,8,1) = '1') Then /*                            */
  vsam_attr = vsam_attr' SPANNED'     /*                              */
If (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */
 vsam_vvds = 'Y'                     /* Set VVDS flag                 */
Else                                 /*                               */
 vsam_vvds = 'N'                     /* Set VVDS flag off             */
vsam_attr = Strip(vsam_attr,B)       /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* WRITE_MEMBER - Write out the generated lines to a PDS member       */
/**********************************************************************/
WRITE_MEMBER:                        /* Write out the report member ##*/
If (l_cnt = 0) Then                  /* if no output                  */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /* write a no output line        */
  l.l_cnt = ' /*' no data produced '*/' /*                            */
 End                                 /*                               */
If (member /= 'REPORT') Then         /* if not a REPORT member        */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*  add a line                   */
  l.l_cnt = ' /*'member'*/'          /*  add report name              */
 End                                 /*                               */
If (outflag /= 'JES') Then           /* if not jes queue              */
 Do                                  /*                               */
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Alloc Fi(MEMOT) Da('"dsn"("member")') Shr Reuse"
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
  Address MVS "ExecIO "l_cnt" DiskW MEMOT (Finis Stem l.)"
  If (tso_flag = 'TSO') Then         /*                               */
   Address TSO "Free Fi(MEMOT)"      /*                               */
  Else                               /*                               */
   Do                                /*                               */
    bpxparm = "Free Fi(MEMOT)"       /*                               */
    Call BPXWDYN(bpxparm)            /*                               */
   End                               /*                               */
 End                                 /*                               */
Else                                 /* otherwise                     */
 Address MVS "ExecIO "l_cnt" DiskW REPORT (Finis Stem l.)"
l_cnt = 0                            /* re-init line count for next   */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* DSN_HANDLING - Carry out processing for output dataset             */
/**********************************************************************/
DSN_HANDLING:                        /* 'Handle' the data produced  ##*/
rc = Listdd(REPORT)                  /*                               */
dsn = rcnvdsn
If sh_flag = 'SH' Then
 Do
  Address syscall getlogin sysuid
  random_dsn = 'T'random(9999)
  rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn
  bpxparm = "Alloc ",
            "Da("rcnvdsn")" ,
            "Fi(REPORT) ",
            "Lrecl(133) ",
            "Unit(SYSALLDA)",
            "Space(2,2) ",
            "Dir(10) ",
            "Cyl ",
            "Blksize(1330) ",
            "Recfm(F,B) ",
            "New ",
            "Catalog ",
            "Reuse"
  rc=BPXWDYN(bpxparm)
  If rc <> 0 Then
   Do
    Say '**(Error-1)* Allocation of DD:REPORT Failed.'
    Select
     When rc = 20 Then
      Say '**(Error-2)* BPXWDYN Invalid Parameter List.'
     When rc > 0 | rc <-1610612737 Then
      Do
       hexrc=right(d2x(rc),8,"0")
       Say '**(Error-2)* Dynamic Allocation error code:'hexcode
      End
     When rc <= -21 & rc >= -9999 Then
      Say '**(Error-2)* Error in key number 'abs(rc)-20
     When rc <= -10000 & rc >= -10099 Then
      Say '**(Error-2)* Message processing error. IEFDB476 returned code:',
           abs(rc)-10000
    End
    Signal FINISH
   End
  dsn = rcnvdsn                      /*                               */
  say 'RCNVTCAT Report DSN:' dsn
  Return
 End
If (rc = 16) Then                    /* REPORT not allocated          */
 If (env_flag /= 'FORE') Then        /*                               */
  Do                                 /*                               */
   Say '**(Error-1)* For execution in batch, please ensure that a PDS'
   Say '**(Error-2)* is pre-allocated to DD name REPORT.'
   Signal FINISH                     /*                               */
  End                                /*                               */
 Else                                /*                               */
  If (ispf_flag /= 'ISPF') Then      /*                               */
   Do                                /*                               */
    Say '**(Error-1)* For execution in foreground TSO, please ensure'
    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'
    Signal FINISH                    /*                               */
   End                               /*                               */
  Else                               /*                               */
   Do                                /*                               */
    random_dsn = 'T'random(9999)
    if sysvar('syspref') = ''
       then rcnvdsn = sysvar('sysuid')'.RCNVTCAT.REPORT.'random_dsn
       else rcnvdsn = sysvar('syspref')'.RCNVTCAT.REPORT.'random_dsn
    If (tso_flag = 'TSO') Then       /*                               */
     Address TSO "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                 "Space(2,2) Dir(10) Cyl ",
                 "Dataset('"rcnvdsn"')" ,
                 "Blksize(1330) Recfm(F,B) New Reuse"
    Else                             /*                               */
     Do                              /*                               */
      bpxparm = "Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)",
                "Space(2,2) Dir(10) Cyl ",
                 "Da('"rcnvdsn"')" ,
                "Blksize(1330) Recfm(F,B) New Reuse Catalog"
      Call BPXWDYN(bpxparm)
     End                             /*                               */
    dsn = rcnvdsn                    /*                               */
   End                               /*                               */
say 'RCNVTCAT Report DSN:' dsn
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* TOT_INIT - Initialise the various totals variables                 */
/**********************************************************************/
TOT_INIT:                            /* Initialise totals variables ##*/
l_cnt   = 0                          /* Initialise output line count  */
ali_tot = 0                          /* Total Aliases                 */
asy_tot = 0                          /* Total Aliases SYSCATLG        */
anv_tot = 0                          /* Total Aliases NONVSAM         */
axx_tot = 0                          /* interim alias total           */
avu_tot = 0                          /* Total Aliases VSAM UCAT       */
gdg_tot = 0                          /* Total GDGs                    */
ivd_tot = 0                          /* Total invalid devices         */
msc_tot = 0                          /* Total MISC datasets           */
nvd_tot = 0                          /* Total NONVSAM datasets        */
nvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */
nvv_tot = 0                          /* Total NONVSAM dsn volumes     */
syc_tot = 0                          /* Total SYSCTLG datasets        */
sy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */
uct_tot = 0                          /* Total Usercatalog imports     */
Return                               /*                               */
/**********************************************************************/

DsExist: Procedure Expose sysreason sysmsglvl1 sysmsglvl2
parse arg indsn
sysreason=0
sysmsglvl1=' Not Emulated '
sysmsglvl2=' Not Emulated '
If indsn = '' Then
 Do
   sysreason=29
   return 16
 End
xx=outtrap('junk.','*') /* I don't care */
Address TSO "LISTCAT ENT("indsn")"
lrc=rc
sysreason=rc
hexrc=right(d2x(rc),8,"0")
xx=outtrap("OFF")
If "0438" = left(hexrc,4) Then
 Do
  sysreason=24
  Return 16
 End
drop junk.
return lrc
LISTDD:   /* new routine */
rc=bpxwdyn("INFO ",
           "DD(REPORT) ",
           "INRTDSN(rcnvdsn) ",
           "INRDSNT(dsntype) ",
           "INRTORG(dsorg) ",
           "MSG(message.)")
If rc <> 0 Then
 Do
  rcnvdsn=''
  return 16
 End
if dsntype <> "PDS" then return 8
if 'PO' <> left(dsorg,2) then return 8
return 0
/* Old implementation */
 call outtrap 'x.'
 'lista sta'
 call outtrap 'off'

 do i = 1 to x.0
    if left(x.i,1) /= ' ' then iterate
    if word(x.i,1) = 'REPORT' then do
       id = i - 1
       rcnvdsn = word(x.id,1)
       leave
       end
    end
  if rcnvdsn = '' then return 16
  return 0
*/

/**********************************************************************/
/* LISTDD   - Get the dataset and volume for a selected DD name       */
/**********************************************************************/
LISTDDO:                                    /*                        */
Arg dd                                      /*                        */
Numeric Digits 20                           /*                        */
drc = 16                                    /*                        */
psatold  = Storage(D2x(540),4)              /* pointer to current tcb */
tcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */
offset   = 24                               /* establish tiot offset  */
Do Forever                                  /*                        */
 tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/
 tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */
 tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */
 tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */
 tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */
 tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */
 If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */
  Do                                        /*                        */
   If (tioelngh == '00'x) Then Leave        /* no more allocations    */
   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */
   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */
   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */
   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */
   Select                                   /*                        */
    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */
     jfcbvols = "*TERM*"                    /*                        */
    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */
     jfcbvols = "*JES**"                    /*                        */
    Otherwise                               /*                        */
     Do                                     /*                        */
      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */
      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/
      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */
     End                                    /*                        */
   End                                      /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    conc = conc + 1                         /*  assume concatenation  */
   else                                     /* otherwise              */
    conc = 0                                /*  assume first          */
   ucbname = ""                             /*                        */
   If (tioeddnm = "") Then                  /* no ddname ?            */
    Do                                      /*                        */
     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */
     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */
    End                                     /*                        */
   else                                     /* otherwise              */
    If (flag = dd) Then                     /* if already set         */
     Do                                     /*                        */
      Signal DDDone                         /* exit procedure         */
     End                                    /* otherwise              */
   If (tioeddnm = dd) Then                  /* ddname match           */
    Do                                      /*                        */
     drc = 0                                /*                        */
     flag = dd                              /*  set flag              */
     dsns = jfcbdsnm                        /*  initialiase dsn list  */
     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */
    End                                     /*                        */
  End                                       /*                        */
 offset = offset + C2d(tioelngh)            /*                        */
End                                         /*                        */
/**********************************************************************/
DDDone:                                     /*                        */
sysdsname = Strip(dsns,B)                   /* set LISTDSI values     */
sysvolume = Strip(vols,B)                   /* set LISTDSI values     */
Return drc                                  /*                        */
/**********************************************************************/
/* Common procedures                                                  */
/**********************************************************************/
SWAREQ:                                     /* SWAREQ Procedure     ::*/
If (Right(C2x(Arg(1)),1) \= 'F') Then       /* SWA=BELOW ?            */
 Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */
sva  = C2d(Arg(1))                          /* convert to decimal     */
tcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */
jscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */
qmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */
qmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */
Do While sva > 65536                        /*                        */
 qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */
 sva=sva-65536                              /* 010006F -> 000006F     */
End                                         /*                        */
Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */
/**********************************************************************/

/**********************************************************************/
/* DATA_HANDLING - Carry out whatever processing is required ...      */
/**********************************************************************/
DATA_HANDLING:                       /* 'Handle' the data produced  ##*/
                                     /*                               */
If (csi_type = '0') Then             /* Catalog entries               */
 Do                                  /*                               */
  Say '**(cat)** Processing 'Left('CATALOG',10) csicname
 End                                 /*                               */
Else                                 /* Non-Catalog entries           */
 Do                                  /*                               */
  If (process = 'CATCOMP') Then      /** Catalog compare code        **/
   Do                                /*                               */
    count.id           = count.id+1  /* increment count               */
    val                = count.id    /* save value                    */
    entname.id.val     = entname     /* store entry name              */
    entype.id.val      = entype      /* store entry type              */
    name.id.val        = name        /* store assoc name              */
    type.id.val        = type        /* store assoc type              */
    pageswap.id.val    = pageswap    /* store pageswap                */
    devices.id.val     = devices     /* store devices                 */
    fils.id.val        = fils        /* store fils                    */
    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */
    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */
    gdglimit.id.val    = gdglimit    /* store gdglimit                */
    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */
    vsam_type.id.val   = vsam_type   /* store vsam_attr               */
    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */
    volsers.id.val     = volsers     /* store volsers by value        */
                                     /** Back reference values       **/
    volsers.id.entname = volsers     /* store volsers by entry name   */
    name.id.entname    = name        /* store name by entry name      */
    val.id.entname     = val         /* store value by entry name     */
   End                               /** End Catalog compare code    **/
  Else                               /*                               */
   Do                                /*                               */
    Select                           /*                               */
     When (member = 'MISC') Then     /* MISC member                   */
      Call MEM_MISC                  /*                               */
     When (member = 'RECAT') Then    /* RECAT member                  */
      Call MEM_RECAT                 /*                               */
     When (member = 'ALIAS') Then    /* ALIAS member                  */
      Call MEM_ALIAS                 /*                               */
     When (member = 'GDG') Then      /* GDG member                    */
      Call MEM_GDG                   /*                               */
     When (member = 'IMPORT') Then   /* IMPORT member                 */
      Call MEM_IMPORT                /*                               */
     When (member = 'NONVSAM') Then  /* NONVSAM member                */
      Do                             /*                               */
       axx_tot = anv_tot             /* set intermim alias total      */
       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */
       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */
       If (Substr(entname,1,4) /= 'SYS1') &,
          (Substr(entname,1,7) /= 'SYSCTLG') Then /* not SYS1/SYSCTLG */
        Do                           /*                               */
         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */
         Call MEM_NONVSAM            /*                               */
        End                          /*                               */
       anv_tot = axx_tot             /* set non-vsam aliases total    */
      End                            /*                               */
     When (member = 'SYS1') Then     /* SYS1 member                   */
      Do                             /*                               */
       sy1_tot = sy1_tot + 1         /* increment sys1 total          */
       Call MEM_NONVSAM              /*                               */
      End                            /*                               */
     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */
      Do                             /*                               */
       axx_tot = asy_tot             /* interim = syscatlg aliases    */
       syc_tot = syc_tot + 1         /* increment syscatlg total      */
       Call MEM_NONVSAM              /*                               */
       asy_tot = axx_tot             /* set syscatlg total            */
      End                            /*                               */
     Otherwise NOP                   /*                               */
    End                              /*                               */
   End                               /*                               */
 End                                 /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_MISC - Generate MISC member lines                              */
/**********************************************************************/
MEM_MISC:                            /* Generate MISC member lines  ##*/
If (entype = 'CLUSTER') |,
   (entype = 'PAGESPACE') Then
 Do
  msc_tot = msc_tot + 1
  l_cnt = l_cnt + 1
  text = ' /* 'Left(entype' ',15,'-')
  text = text' 'Left(entname,32)'  NOT PROCESSED */'
  l.l_cnt = text
 End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_RECAT - Generate RECAT member lines                            */
/**********************************************************************/
MEM_RECAT:                           /* Generate RECAT member lines ##*/
If (entype = 'PAGESPACE') Then
 Do
  page_name     = entname
  page_swap     = pageswap
  If (Index(type,'D') /= 0) Then
   data_flag = 'DATA'
  Else
   data_flag = ''
 End
If (entype = 'CLUSTER') Then
 Do
  If (Substr(entname,1,4) /= 'SYS1') Then
   Do
    cluster_name  = entname
    l_cnt = l_cnt + 1
    text = ' /* 'Left(entype' ',15,'-')
    text = text' 'Left(entname,34)' CANNOT RECAT */'
    data_flag = ''
    index_flag = ''
    l.l_cnt = text
   End
  Else
   Do
    cluster_name  = entname
    If (Index(type,'D') /= 0) Then
     data_flag = 'DATA'
    Else
     data_flag = ''
    If (Index(type,'I') /= 0) Then
     index_flag = 'INDEX'
    Else
     index_flag = ''
    cluster_bits  = type
   End
 End
If (entype = 'DATA') &,
   (data_flag = 'DATA') Then
 Select
  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */
   Do
    l_cnt = l_cnt + 1
    text = ' /* 'Left('VVDS ',15,'-')
    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'
    l.l_cnt = text
   End
  When (Index(name,page_name) > 0) Then
   Do
    l_cnt = l_cnt + 1
    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          VOL(  'Left(volser,50)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left(page_swap,57)' -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left('RECATALOG',55)' ) -'
    l_cnt = l_cnt + 1
    if targ_cat /= ''
    then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
    else l.l_cnt = '          CAT('Left(cat,44)'        )'
   End
  When (Index(name,cluster_name) > 0) Then
   Do
    l_cnt = l_cnt + 1
    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          VOL(  'Left(volser,50)') -'
    If (vsam_attr /= '') Then
     Do
      l_cnt = l_cnt + 1
      l.l_cnt = '          'Left(vsam_attr,57)' -'
     End
    l_cnt = l_cnt + 1
    l.l_cnt = '          'Left('RECATALOG',55)' ) -'
    l_cnt = l_cnt + 1
    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'
    If (index_flag = '') Then
     Do
      l_cnt = l_cnt + 1
      if targ_cat /= ''
      then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
      else l.l_cnt = '          CAT('Left(cat,44)'        )'
     End
   End
  Otherwise
   Say '**(Error--1)* Unexpected condition for :'
   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)
   Say '**(Error--3)* page_name    = 'Strip(page_name,T)
   Say '**(Error--4)* entname      = 'Strip(entname,T)
   Say '**(Error--5)* entype       = 'Strip(entype,T)
   Say '**(Error--6)* name         = 'Strip(name,T)
   Say '**(Error--7)* type         = 'Strip(type,T)
   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)
   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)
   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1
   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2
   Say '**(Error-12)* vsamreus     = 'vsamreus
 End
If (entype = 'INDEX') &,
   (index_flag = 'INDEX') Then
 Do
  l_cnt = l_cnt + 1
  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'
  l_cnt = l_cnt + 1
  if targ_cat /= ''
  then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
  else l.l_cnt = '          CAT('Left(cat,44)'        )'
 End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_ALIAS - Generate ALIAS member lines                            */
/**********************************************************************/
MEM_ALIAS:                           /* Generate ALIAS member lines ##*/
ali_tot = ali_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '     DEF ALIAS(NAME('entname')  -'
l_cnt = l_cnt + 1
l.l_cnt = '          REL('name'))          -'
l_cnt = l_cnt + 1
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'         )'
else l.l_cnt = '          CAT('Left(cat,44)'         )'
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_IMPORT - Generate IMPORT member lines                          */
/**********************************************************************/
MEM_IMPORT:                          /* Generate IMPORT member lins ##*/
uct_tot = uct_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '    IMPORT   OBJ( ('entname'  -'
l_cnt = l_cnt + 1
l.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'
l.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'
l_cnt = l_cnt + 1
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
Call ASSOC_ENTRY                     /* process associated entries    */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_GDG - Generate GDG member lines                                */
/**********************************************************************/
MEM_GDG:                             /* Generate GDG member lines   ##*/
gdg_tot = gdg_tot + 1
l_cnt = l_cnt + 1
l.l_cnt = '   DEF  GDG  (NAME('entname') -'
l_cnt = l_cnt + 1
l.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)
l.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'
l_cnt = l_cnt + 1
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_NONVSAM - Generate NONVSAM member lines                        */
/**********************************************************************/
MEM_NONVSAM:                         /* Generate NONVSAM member lins##*/
l_cnt = l_cnt + 1
l.l_cnt = '   DEF  NVSAM(NAME('entname') -'
If (Words(devices) <= 5) Then        /* < 5 devices for dataset       */
 Do                                  /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = '          DEVT( 'Left(devices,47)') -'
  If (dev_class = 'TAPE') &,         /* if devices is tape            */
     (fileseq /= '0') Then           /* if fileseq number exist       */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'
   End                               /*                               */
  l_cnt = l_cnt + 1                  /*                               */
  l.l_cnt = '          VOL(  'Left(volser,47)') )-'
 End                                 /*                               */
Else                                 /* > 5 devices for dataset       */
 Do                                  /*                               */
  item_lead = 'DEVT( '               /* devices header                */
  item_end  = ') -'                  /* devices trailer               */
  item_pad  = ''                     /* no padding                    */
  items = devices                    /* pass data                     */
  Call PLUS5_HANDLE                  /* handle > 5 items              */
  If (dev_class = 'TAPE') &,         /* if devices is tape            */
     (fileseq /= '0') Then           /* if fileseq number exist       */
   Do                                /*                               */
    item_lead = 'FSEQN('             /* fileseq header                */
    item_end  = ') -'                /* fileseq trailer               */
    item_pad  = Left('',7)           /* 7 spaces padding              */
    items = fileseq                  /* pass data                     */
    Call PLUS5_HANDLE                /* handle > 5 items              */
   End                               /*                               */
  item_lead = 'VOL(  '               /* volumes header                */
  item_end  = ') ) -'                /* volumes trailer               */
  item_pad  = ''                     /* no padding                    */
  items = volser                     /* pass data                     */
  Call PLUS5_HANDLE                  /* handle > 5 items              */
 End                                 /*                               */
l_cnt = l_cnt + 1                    /*                               */
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
Call ASSOC_ENTRY                     /* process associated entries    */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ASSOC_ENTRY - Process associated entries                           */
/**********************************************************************/
ASSOC_ENTRY:                         /* Process associated entries  ##*/
Do ali = 1 to Words(name)
 If (Substr(type,ali,1) = 'X') Then
  Do
   axx_tot = axx_tot + 1
   l_cnt = l_cnt + 1
   l.l_cnt = '     DEF ALIAS(NAME('Left(Word(name,ali),44)') -'
   l_cnt = l_cnt + 1
   l.l_cnt = '          REL('entname'))  -'
   l_cnt = l_cnt + 1
   if targ_cat /= ''
   then l.l_cnt = '          CAT('Left(targ_cat,44)'         )'
   else l.l_cnt = '          CAT('Left(cat,44)'         )'
  End
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */
/**********************************************************************/
PLUS5_HANDLE:                        /* Handle > 5 fields           ##*/
l_cnt = l_cnt + 1
w_end = Wordindex(items,6)
data = Left(Substr(items,1,w_end-1),47)
l.l_cnt = '          'item_lead||data' -'
Do mult = 6 to Words(items) by 5
 w_sta = Wordindex(items,mult)
 w_end = Wordindex(items,mult+5)
 If (w_end = 0) Then
  item = Substr(items,w_sta)
 Else
  item = Substr(items,w_sta,w_end-w_sta)
 l_cnt = l_cnt + 1
 item_length = 47 - Length(item_pad)
 l.l_cnt = '                '||item_pad||Left(item,item_length)' -'
End
l.l_cnt = Strip(l.l_cnt,T,'-')||item_end
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* MEM_REPORT - Generate REPORT member                                */
/**********************************************************************/
MEM_REPORT:                          /* Generate REPORT member      ##*/
r.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'
r.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'
r.3  = ' '
r.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '
r.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '
r.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '
r.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '
r.8  = '                                                        '
r.9  = 'NUMBER OF VSAM USER CATALOGS                            '
r.10 = '                                                        '
r.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '
r.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '
r.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '
r.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '
r.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '
r.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'
r.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '
r.18 = 'ALL OTHER NON VSAM DATA SETS                            '
r.19 = '                                                        '
r.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '
r.21 = '                                                        '
r.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '
r.23 = '                                                        '
r.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '
r.25 = 'DEVICE TYPE. SEE NOTE 3                                 '
r.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '
r.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '
r.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '
tot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot
sta_tot = tot_tot + ali_tot
r.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4
r.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5
r.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6
r.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7
r.8  = '                                          '||r.8
r.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9
r.10 = '                                          '||r.10
r.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11
r.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12
r.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13
r.14 = '                                          '||r.14
r.15 = ' SYSCTLG CONVERTED ........        0      '||r.15
r.16 = '                                          '||r.16
r.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17
r.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18
r.19 = '                                          '||r.19
r.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20
r.21 = '                                          '||r.21
r.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22
r.23 = '------------------------------------      '||r.23
r.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24
r.25 = '                                          '||r.25
r.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26
r.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27
r.28 = '                                          '||r.28
r.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'
r.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '
r.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'
r.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'
r.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'
r.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'
r.32 = r.32||'. BETTER CHECK THE CODE !?!'
r.33 = r.33||'HEY ARE PROCESSED TWICE'
l_cnt = 33
Do loop = 1 to 33
 l.loop = r.loop
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* COMP_REPORT - Produce the Catalog comparison report                */
/**********************************************************************/
COMP_REPORT:                         /* Produce the catalog compare ##*/
l_cnt = 0
Do loop = 1 to count.OLD
 entname = entname.OLD.loop
 entype  = entype.OLD.loop
 name    = name.OLD.loop
 volsers = volsers.OLD.loop
 flag.entname = 'Y'
 If (member = 'COMPFULL') Then
  Do
   disp_ent = entname
   disp_entype = Left(entype,8)
  End
 Else
  Do
   disp_ent = Left(entname,36)
   disp_entype = Left(substr(entype,1,3),4)
  End
 disp_vol = Strip(volsers,B)
 If (Symbol('val.NEW.entname') = 'LIT') Then
  Do
   l_cnt = l_cnt + 1
   Select
    When (entype = 'ALIAS  '  ) Then
     detail = Strip(name.OLD.loop,B)
    When (entype = 'DATA'     ) |,
         (entype = 'INDEX'    ) Then
     detail = Strip(volsers.old.loop,B)||' ',
              Strip(devices.old.loop,B)||' ',
              Strip(vsam_type.OLD.loop,B)||' ',
              Strip(vsam_attr.OLD.loop,B)
    When (entype = 'NONVSAM'  ) |,
         (entype = 'GDG'      ) |,
         (entype = 'UCAT'     ) |,
         (entype = 'PAGESPACE') Then
     detail = Strip(volsers.old.loop,B)||' ',
              Strip(devices.old.loop,B)
    Otherwise NOP
   End
   l.l_cnt = disp_entype||disp_ent' --missing - 'detail
   status.OLD.loop = 'MISSING'
  End
 Else
  Do
   namenew = name.NEW.entname
   volsnew = volsers.NEW.entname
   Select
    When (namenew /= name) Then
     Do
      If (entype = 'ALIAS') Then
       Do
        l_cnt = l_cnt + 1
        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)
        l.l_cnt = disp_entype||disp_ent||err_text
        status.OLD.loop = 'BADCAT'
       End
      Else
       Do
        l_cnt = l_cnt + 1
        err_text = ' ##related entries do not match.'
        l.l_cnt = disp_entype||disp_ent||err_text
        status.OLD.loop = 'BADENT'
       End
     End
    When (volsnew /= volsers) Then
     Do
      l_cnt = l_cnt + 1
      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)
      l.l_cnt = disp_entype||disp_ent||err_text
      status.OLD.loop = 'BADVOL'
     End
    Otherwise
     l_cnt = l_cnt + 1
     l.l_cnt = disp_entype||disp_ent' **entry matches.'
     status.OLD.loop = 'OK'
   End
  End
End
Do loop = 1 to count.NEW
 entname = entname.NEW.loop
 entype  = entype.NEW.loop
 volsers = volsers.NEW.loop
 If (flag.entname /= 'Y') Then
  Do
   If (member = 'COMPFULL') Then
    Do
     disp_ent = entname
     disp_entype = Left(entype,8)
    End
   Else
    Do
     disp_ent = Left(entname,36)
     disp_entype = Left(substr(entype,1,3),4)
    End
   disp_vol = Strip(volsers,B)
   l_cnt = l_cnt + 1
   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol
   status.NEW.loop = 'NEW'
  End
End
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* NEW_EXT - Process for new entries                                  */
/**********************************************************************/
NEW_EXT:                             /* Process new entries         ##*/
Do loop = 1 to count.NEW             /*                               */
 If (status.NEW.loop = 'NEW') Then   /*                               */
  Do                                 /*                               */
   entname = entname.NEW.loop        /*                               */
   entype  = entype.NEW.loop         /*                               */
   If (entype = 'DATA') |,           /*                               */
      (entype = 'INDEX') Then        /*                               */
    Iterate                          /*                               */
   l_cnt = l_cnt + 1                 /*                               */
   l.l_cnt = "      /* Entry not present in catalog "cat.old". */"
   l_cnt = l_cnt + 1                 /*                               */
   l.l_cnt = "      /* Entry present in catalog     "cat.new". */"
   Call ENTRY_DEL                    /* process an entry delete       */
  End                                /*                               */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* OLD_BAD - Process for old entries                                  */
/**********************************************************************/
OLD_BAD:                             /* Process old entries         ##*/
Do loop = 1 to count.OLD             /*                               */
 entname   = entname.OLD.loop        /*                               */
 entype    = entype.OLD.loop         /*                               */
 volsers   = volsers.OLD.loop        /*                               */
 volser    = Strip(volsers,B)        /*                               */
 name      = name.OLD.loop           /*                               */
 type      = type.OLD.loop           /*                               */
 pageswap  = pageswap.OLD.loop       /*                               */
 devices   = devices.OLD.loop        /*                               */
 fils      = fils.OLD.loop           /*                               */
 gdg_emp   = gdg_emp.OLD.loop        /*                               */
 gdg_scr   = gdg_scr.OLD.loop        /*                               */
 gdglimit  = gdglimit.OLD.loop       /*                               */
 vsam_attr = vsam_attr.OLD.loop      /*                               */
 vsam_type = vsam_type.OLD.loop      /*                               */
 vsam_vvds = vsam_vvds.OLD.loop      /*                               */
 namenew   = name.NEW.entname        /*                               */
 volsnew   = volsers.NEW.entname     /*                               */
 If (entype = 'DATA') |,             /*                               */
    (entype = 'INDEX') Then          /*                               */
  Iterate                            /*                               */
 Select                              /*                               */
  When (status.OLD.loop = 'MISSING') Then /*                          */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Entry missing in catalog "cat". */"
   End                               /*                               */
  When (status.OLD.loop = 'BADCAT') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Alias incorrectly pointing to "namenew". */"
   End                               /*                               */
  When (status.OLD.loop = 'BADENT') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Related entries do not match */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* entry "Strip(entname,T)" */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* old "Strip(name,T)" */"
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* new "Strip(namenew,T)" */"
   End                               /*                               */
  When (status.OLD.loop = 'BADVOL') Then /*                           */
   Do                                /*                               */
    l_cnt = l_cnt + 1                /*                               */
    l.l_cnt = "      /* Volume incorrect - was "volsnew". */"
   End                               /*                               */
  Otherwise Iterate                  /*                               */
 End                                 /*                               */
 Call ENTRY_DEL                      /* process an entry delete       */
 Call ENTRY_CHG                      /* process an entry change       */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ENTRY_DEL - Create a DELETE statement                              */
/**********************************************************************/
ENTRY_DEL:                           /* Create an entry DELETE      ##*/
If (entype = 'NONVSAM') Then         /*                               */
 tparm = ''                          /*                               */
Else                                 /*                               */
 tparm = entype                      /*                               */
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = "      DELETE "Strip(entname,T)" "tparm" NOSCRATCH -"
l_cnt = l_cnt + 1                    /*                               */
if targ_cat /= ''
then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'
else l.l_cnt = '          CAT('Left(cat,44)'        )'
l.l_cnt = "             CAT("Left(cat,44)"         )"
l_cnt = l_cnt + 1                    /*                               */
l.l_cnt = "      SET MAXCC=0"
Return                               /*                               */
/**********************************************************************/

/**********************************************************************/
/* ENTRY_CHG - Create a changed entry statement                       */
/**********************************************************************/
ENTRY_CHG:                           /* Create a changed entry      ##*/
Select                               /*                               */
 When (entype = 'NONVSAM') Then      /*                               */
  Call MEM_NONVSAM                   /*                               */
 When (entype = 'ALIAS') Then        /*                               */
  Call MEM_ALIAS                     /*                               */
 When (entype = 'GDG') Then          /*                               */
  Call MEM_GDG                       /*                               */
 Otherwise NOP                       /*                               */
End                                  /*                               */
Return                               /*                               */
/**********************************************************************/


./ ADD NAME=RECDDETL 0112-15230-17166-1415-00389-00294-00000-APLKS   06
/* REXX                                                    */
/*                                                         */
/*  FORMAT: RECDDETL <DSNAME>                              */
/*                                                         */
/*  RECDDETL                                               */
/*     PURPOSE: PRINTS OUT DETAIL INFORMATION FOR EVERY    */
/*              "D" AND "M" RECORD INPUT                   */
/*     INPUT:   USERID()..DCOLLECT.RECDM                   */
/*              TYPE D AND M RECORDS                       */
/*     OUTPUT:  USERID()..DCOLLECT.DETAIL                  */
/*     PRESORT: NONE REQUIRED                              */
/*                                                         */
/***********************************************************/

   REQ_DSNAME = "";
   Parse UPPER ARG parm2;
   If parm2 <> "" Then;
     Do;
       REQ_DSNAME = STRIP(PARM2,"B");
       REQ_DSNAME = STRIP(REQ_DSNAME,"B","'");
     End;

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */
/***********************************************************/
/* INNAME = "'LINCHO.DCOLLECT.D'" */
   INNAME = "'"USERID()".DCOLLECT.RECDM'"
/* INNAME = "'"USERID()".DCOLLECT.RECDM.SMALL'" */
/* "ALLOC F(INFILE) DA('LNICHO.DCOLLECT.D') SHR" */
 "ALLOC F(INFILE) DA("INNAME") SHR"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE OUTPUT FILE (CONTAINING YOUR REPORT)           */
/***********************************************************/
/* NEW CODE ADDED */
DATE = DATE('J')
SDATE = DATE('S')
CC = SUBSTR(SDATE,1,2)
CC = CC - 19
DATE = RIGHT(CC,2,'0')||DATE
ODATE = DATE('O')
/* END OF NEW CODE */

/* OUTNAME = "SMS.UMB.DCOLLECT.DMREC.DETAIL"  */
 OUTNAME = "'"USERID()".DCOLLECT.DETAIL.D"||DATE||"'"
/* "ALLOC DSNAME('SMS.UMB.DCOLLECT.DMREC.DETAIL')",  */
"ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(100) RECFM(F B) ",
  "TRACKS SPACE(1,5) RELEASE DDNAME(OUTFILE)"
 IF RC <> 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 QUEUE "DATA COLLECTED ON:" DATE ODATE
 QUEUE " "
 "EXECIO 2  DISKW OUTFILE ";
 EOF = 'NO'
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE"
   IF RC <> 0 THEN DO
      EOF = 'YES'
      "EXECIO *  DISKW OUTFILE ( FINIS "
      "FREE ALL"
      END
   ELSE DO
      PARSE PULL RECORD
/***********************************************************/
/* DETERMINE THE RECORD TYPE (M,B,C,T,D,A,V)               */
/***********************************************************/
      DCURCTYP=SUBSTR(RECORD,5,2)
         SELECT
/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD            */
/***********************************************************/
         WHEN(DCURCTYP='D ') THEN;
           DO;
             CALL DCRECORD
             IF REQ_DSNAME <> "" THEN;
               IF REQ_DSNAME <> STRIP(DCDDSNAM,"B") THEN;
                 ITERATE;
             CALL DISPLAYDC
           END;
/***********************************************************/
/* PROCESS MIGRATED DATA SET INFORMATION RECORD            */
/***********************************************************/
         WHEN(DCURCTYP='M ') THEN;
           DO;
             CALL UMRECORD
             IF REQ_DSNAME <> "" THEN;
               IF REQ_DSNAME <> STRIP(UMDSNAM,"B") THEN;
                 ITERATE;
             CALL DISPLAYUM
           END;
/***********************************************************/
/* DO NOT PROCESS OTHER RECORD TYPES                       */
/***********************************************************/
         OTHERWISE
         END
      END
 END
 EXIT
/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */
/***********************************************************/
 DCRECORD:
/*                                                          */
       DCDDSNAM = SUBSTR(RECORD,25,44)
       DCDERROR = BITSTR(SUBSTR(RECORD,69,1))
       DCDFLAG1 = BITSTR(SUBSTR(RECORD,70,1))
       DCDFLAG2 = BITSTR(SUBSTR(RECORD,71,1))
       DCDDSORG = C2X(SUBSTR(RECORD,75,2))
       DCDRECRD = C2X(SUBSTR(RECORD,77,1))
       DCDNMEXT = X2D(C2X(SUBSTR(RECORD,78,1)));
       DCDVOLSR = SUBSTR(RECORD,79,6)
       DCDBKLNG = C2D(SUBSTR(RECORD,85,2))
       DCDLRECL = C2D(SUBSTR(RECORD,87,2))
       DCDALLSP = C2D(SUBSTR(RECORD,89,4))
       DCDUSESP = C2D(SUBSTR(RECORD,93,4))
       DCDSCALL = C2D(SUBSTR(RECORD,97,4))
       DCDNMBLK = C2D(SUBSTR(RECORD,101,4))
       DCDCREDT = STRIP(C2X(SUBSTR(RECORD,105,4)),T,'F')
       DCDEXPDT = STRIP(C2X(SUBSTR(RECORD,109,4)),T,'F')
       DCDLSTRF = STRIP(C2X(SUBSTR(RECORD,113,4)),T,'F')
       DCDDSSER = SUBSTR(RECORD,117,6)
       DCDVOLSQ = X2D(C2X(SUBSTR(RECORD,123,2)));
       DCDLBKDT = C2X(SUBSTR(RECORD,125,8))
       DCDDATCL = SUBSTR(RECORD,135,8)
       DCDSTGCL = SUBSTR(RECORD,167,8)
       DCDMGTCL = SUBSTR(RECORD,199,8)
       DCDSTGRP = SUBSTR(RECORD,231,8)
 RETURN

 /***********************************************************/
 /* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */
 /*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */
 /***********************************************************/
  UMRECORD:
        UMDSNAM = SUBSTR(RECORD,25,44)
        UMFLAG1 = BITSTR(SUBSTR(RECORD,69,1))
        UMLEVEL = SUBSTR(UMFLAG1,1,2)
        UMCHIND = SUBSTR(UMFLAG1,3,1)
        UMDEVCL = SUBSTR(RECORD,70,1)
        UMDSORG = C2X(SUBSTR(RECORD,71,2))
        UMDSIZE = C2D(SUBSTR(RECORD,73,4))
        UMTIME  = C2X(SUBSTR(RECORD,77,4))
        UMDATE  = STRIP(C2X(SUBSTR(RECORD,81,4)),T,'F')
        UMDATCL = SUBSTR(RECORD,87,30)
        UMSTGCL = SUBSTR(RECORD,119,30)
        UMMGTCL = SUBSTR(RECORD,151,30)
        UMRECRD = C2X(SUBSTR(RECORD,181,1))
        UMRECOR = C2X(SUBSTR(RECORD,182,1))
        UMBKLNG = C2D(SUBSTR(RECORD,183,2))
        UMFLAG2 = BITSTR(SUBSTR(RECORD,185,1))
        UMRACFD = SUBSTR(UMFLAG2,1,1)
        UMGDS   = SUBSTR(UMFLAG2,2,1)
        UMREBLK = SUBSTR(UMFLAG2,3,1)
        UMPDSE  = SUBSTR(UMFLAG2,4,1)
        UMSMSM  = SUBSTR(UMFLAG2,5,1)
        UMNMIG  = C2D(SUBSTR(RECORD,187,2))
        UMALLSP = C2D(SUBSTR(RECORD,189,4))
        UMUSESP = C2D(SUBSTR(RECORD,193,4))
        UMRECSP = C2D(SUBSTR(RECORD,197,4))
        UMCREDT = STRIP(C2X(SUBSTR(RECORD,201,4)),T,'F')
        UMEXPDT = STRIP(C2X(SUBSTR(RECORD,205,4)),T,'F')
        UMLBKDT = C2X(SUBSTR(RECORD,209,8))
        UMLRFDT = STRIP(C2X(SUBSTR(RECORD,217,4)),T,'F')
  RETURN

/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */
/***********************************************************/
 DISPLAYDC:
 QUEUE "DCDDSNAM="  DCDDSNAM
 QUEUE "DCDERROR="  DCDERROR
 QUEUE "DCDFLAG1="  DCDFLAG1
 QUEUE "DCDFLAG2="  DCDFLAG2
 PDSORG = "";
 SELECT;
   WHEN SUBSTR(DCDDSORG,1,1) = "8" THEN;
     PDSORG = "IS";
   WHEN SUBSTR(DCDDSORG,1,1) = "4" THEN;
     PDSORG = "PS";
   WHEN SUBSTR(DCDDSORG,1,1) = "2" THEN;
     PDSORG = "DA";
   WHEN SUBSTR(DCDDSORG,2,1) = "2" | SUBSTR(DCDDSORG,2,1) = "3" THEN;
     PDSORG = "PO";
   WHEN SUBSTR(DCDDSORG,3,2) = "08" THEN;
     PDSORG = "VSAM";
   OTHERWISE;
     NOP;
 END;
 IF SUBSTR(DCDDSORG,2,1) = "1" | SUBSTR(DCDDSORG,2,1) = "3" THEN;
   PDSORG = PDSORG || "U";
 QUEUE "DCDDSORG="  DCDDSORG  PDSORG;
 PRECFM = "";
 SELECT;
   WHEN SUBSTR(DCDRECRD,1,1) = "E" THEN;
     PRECFM = "D";
   WHEN SUBSTR(DCDRECRD,1,1) = "F" THEN;
     PRECFM = "DB";
   WHEN SUBSTR(DCDRECRD,1,1) = "C" THEN;
     PRECFM = "U";
   WHEN SUBSTR(DCDRECRD,1,1) = "8" THEN;
     PRECFM = "F";
   WHEN SUBSTR(DCDRECRD,1,1) = "9" THEN;
     PRECFM = "FB";
   WHEN SUBSTR(DCDRECRD,1,1) = "4" THEN;
     PRECFM = "V";
   WHEN SUBSTR(DCDRECRD,1,1) = "5" THEN;
     PRECFM = "VB";
   OTHERWISE;
     NOP;
 END;
 SELECT;
   WHEN SUBSTR(DCDRECRD,2,1) = "8" THEN;
     PRECFM = PRECFM || "S";
   WHEN SUBSTR(DCDRECRD,2,1) = "4" THEN;
     PRECFM = PRECFM || "A";
   WHEN SUBSTR(DCDRECRD,2,1) = "2" THEN;
     PRECFM = PRECFM || "M";
   OTHERWISE;
     NOP;
 END;
 QUEUE "DCDRECRD="  DCDRECRD  PRECFM;
 QUEUE "DCDNMEXT="  DCDNMEXT
 QUEUE "DCDVOLSR="  DCDVOLSR
 QUEUE "DCDBKLNG="  DCDBKLNG
 QUEUE "DCDLRECL="  DCDLRECL
 QUEUE "DCDALLSP="  DCDALLSP
 QUEUE "DCDUSESP="  DCDUSESP
 QUEUE "DCDSCALL="  DCDSCALL
 QUEUE "DCDNMBLK="  DCDNMBLK
 PDATE = "";
 IF DATATYPE(DCDCREDT,"W") & DCDCREDT > 0 THEN;
   PDATE = DATE("S",SUBSTR(DCDCREDT,3,5),"J");
 QUEUE "DCDCREDT="  DCDCREDT  PDATE;
 PDATE = "";
 IF DATATYPE(DCDEXPDT,"W") & DCDEXPDT > 0 THEN;
   PDATE = DATE("S",SUBSTR(DCDEXPDT,3,5),"J");
 QUEUE "DCDEXPDT="  DCDEXPDT  PDATE;
 PDATE = "";
 IF DATATYPE(DCDLSTRF,"W") & DCDLSTRF > 0 THEN;
   PDATE = DATE("S",SUBSTR(DCDLSTRF,3,5),"J");
 QUEUE "DCDLSTRF="  DCDLSTRF  PDATE;
 QUEUE "DCDDSSER="  DCDDSSER
 QUEUE "DCDVOLSQ="  DCDVOLSQ
 QUEUE "DCDLBKDT="  DCDLBKDT
 QUEUE "DCDDATCL="  DCDDATCL
 QUEUE "DCDSTGCL="  DCDSTGCL
 QUEUE "DCDMGTCL="  DCDMGTCL
 QUEUE "DCDSTGRP="  DCDSTGRP
 QUEUE "*******************************************************"
 "EXECIO *  DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */
/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */
/***********************************************************/
 DISPLAYUM:
 QUEUE "UMDSNAM ="  UMDSNAM
 QUEUE "UMFLAG1 ="  UMFLAG1
 QUEUE "UMLEVEL ="  UMLEVEL
 QUEUE "UMCHIND ="  UMCHIND
 QUEUE "UMDEVCL ="  UMDEVCL
 PDSORG = "";
 SELECT;
   WHEN SUBSTR(UMDSORG,1,1) = "8" THEN;
     PDSORG = "IS";
   WHEN SUBSTR(UMDSORG,1,1) = "4" THEN;
     PDSORG = "PS";
   WHEN SUBSTR(UMDSORG,1,1) = "2" THEN;
     PDSORG = "DA";
   WHEN SUBSTR(UMDSORG,2,1) = "2" | SUBSTR(UMDSORG,2,1) = "3" THEN;
     PDSORG = "PO";
   WHEN SUBSTR(UMDSORG,3,2) = "08" THEN;
     PDSORG = "VSAM";
   OTHERWISE;
     NOP;
 END;
 IF SUBSTR(UMDSORG,2,1) = "1" | SUBSTR(UMDSORG,2,1) = "3" THEN;
   PDSORG = PDSORG || "U";
 QUEUE "UMDSORG ="  UMDSORG  PDSORG;
 QUEUE "UMDSIZE ="  UMDSIZE
 QUEUE "UMTIME  ="  UMTIME
 QUEUE "UMDATE  ="  UMDATE
 QUEUE "UMDATCL ="  UMDATCL
 QUEUE "UMSTGCL ="  UMSTGCL
 QUEUE "UMMGTCL ="  UMMGTCL
 PRECFM = "";
 SELECT;
   WHEN SUBSTR(UMRECRD,1,1) = "E" THEN;
     PRECFM = "D";
   WHEN SUBSTR(UMRECRD,1,1) = "F" THEN;
     PRECFM = "DB";
   WHEN SUBSTR(UMRECRD,1,1) = "C" THEN;
     PRECFM = "U";
   WHEN SUBSTR(UMRECRD,1,1) = "8" THEN;
     PRECFM = "F";
   WHEN SUBSTR(UMRECRD,1,1) = "9" THEN;
     PRECFM = "FB";
   WHEN SUBSTR(UMRECRD,1,1) = "4" THEN;
     PRECFM = "V";
   WHEN SUBSTR(UMRECRD,1,1) = "5" THEN;
     PRECFM = "VB";
   OTHERWISE;
     NOP;
 END;
 SELECT;
   WHEN SUBSTR(UMRECRD,2,1) = "8" THEN;
     PRECFM = "S";
   WHEN SUBSTR(UMRECRD,2,1) = "4" THEN;
     PRECFM = "A";
   WHEN SUBSTR(UMRECRD,2,1) = "2" THEN;
     PRECFM = "M";
   OTHERWISE;
     NOP;
 END;
 QUEUE "UMRECRD ="  UMRECRD  PRECFM;
 QUEUE "UMRECOR ="  UMRECOR
 QUEUE "UMBKLNG ="  UMBKLNG
 QUEUE "UMFLAG2 ="  UMFLAG2
 QUEUE "UMRACFD ="  UMRACFD
 QUEUE "UMGDS   ="  UMGDS
 QUEUE "UMREBLK ="  UMREBLK
 QUEUE "UMPDSE  ="  UMPDSE
 QUEUE "UMSMSM  ="  UMSMSM
 QUEUE "UMNMIG  ="  UMNMIG
 QUEUE "UMALLSP ="  UMALLSP
 QUEUE "UMUSESP ="  UMUSESP
 QUEUE "UMRECSP ="  UMRECSP
 PDATE = "";
 IF DATATYPE(UMCREDT,"W") & UMCREDT > 0 THEN;
   PDATE = DATE("S",SUBSTR(UMCREDT,3,5),"J");
 QUEUE "UMCREDT ="  UMCREDT  PDATE;
 PDATE = "";
 IF DATATYPE(UMEXPDT,"W") & UMEXPDT > 0 THEN;
   PDATE = DATE("S",SUBSTR(UMEXPDT,3,5),"J");
 QUEUE "UMEXPDT ="  UMEXPDT  PDATE;
 QUEUE "UMLBKDT ="  UMLBKDT
 PDATE = "";
 IF DATATYPE(UMLRFDT,"W") & UMLRFDT > 0 THEN;
   PDATE = DATE("S",SUBSTR(UMLRFDT,3,5),"J");
 QUEUE "UMLRFDT ="  UMLRFDT  PDATE;
 QUEUE "*******************************************************"
 "EXECIO *  DISKW OUTFILE"
 RETURN

/***********************************************************/
/* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */
/* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */
/***********************************************************/
 BITSTR:
       IF BIT.F <> "1111"  THEN DO
          BIT.0="0000"
          BIT.1="0001"
          BIT.2="0010"
          BIT.3="0011"
          BIT.4="0100"
          BIT.5="0101"
          BIT.6="0110"
          BIT.7="0111"
          BIT.8="1000"
          BIT.9="1001"
          BIT.A="1010"
          BIT.B="1011"
          BIT.C="1100"
          BIT.D="1101"
          BIT.E="1110"
          BIT.F="1111"
       END
       CH=C2X(ARG(1))
       BS=''
       DO I=1 TO LENGTH(CH)
          Q=SUBSTR(CH,I,1)
          BS=BS||BIT.Q
       END
RETURN BS

./ ADD NAME=RECLANAL 0110-17145-17149-1833-00346-00314-00000-APLKS   38
/* REXX 2017-05-29 */
   Address TSO;
   'PROFILE NOPREFIX';

/* Entering EXEC RECLANAL */

   /* Collect Initial Information about the Environment */

   /* ----------------------------------------------------- */
   /*     os_name = CMS or TSO                              */
   /* invoke_type = COMMAND | FUNCTION | SUBROUTINE         */
   /*   exec_name =                                         */
   /* exec_ddname =                                         */
   /* exec_dsname =                                         */
   /*    host_env = TSO | MVS | ISPEXEC                     */
   /* addrsp_name = MVS | TSO/E | ISPF                      */
   /* ----------------------------------------------------- */
   Parse SOURCE os_name invoke_type exec_name exec_ddname,
         exec_dsname . host_env addrsp_name .;

   If Arg() Then;
     Parse UPPER ARG parm2;
   Else;
     Do;
       /* assume executing in batch mode */
       Say "Please enter the RECLANAL statistics dsname:";
       Parse UPPER EXTERNAL parm2 .;
     End;

   /* variable definition */
   F.0 = 0; L.0 = 0; M.0 = 0;

   /* Parse User passed Parms */

   /* get the dsname that we want to analyze the data in */
   If parm2 <> "" Then;
     Parse VAR parm2 dsname .;
   Else;
     Signal Error_NODATA;

   dsname = Strip(dsname);
   x = Sysdsn(dsname);
   If x <> "OK" Then;
     Signal Error_INVALID_DSNAME;

   /* Point to RECLANAL statistics dsname to be processed */

   "ALLOC DSNAME("dsname") ",
         "DDNAME(FANALDD) SHR REUSE ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_ALLOC;

   "EXECIO 0 DISKR FANALDD ( OPEN ";
   EC = RC;
   If RC <> 0 Then;
     Signal Error_DATASET_OPEN;

   i = 0;
   eof = "N";
   Do While eof = "N";
     "EXECIO 1 DISKR FANALDD ";
     If RC = 0 Then;
       Do;
         Pull line;
         /* char(1:1 sr_type);     1=lrecl,2=block|CI
            char(2:1 sr_am);       Q=QSAM,V=VSAM
            char(3:1 sr_org);      K=KSDS
            char(4:1 sr_flag);     E=error
            binary(5:4 null);
            binary(9:4 sr_seq)     sequence nbr
            binary(13:4 sr_lgth)   length of record|block|CI
            binary(17:4 sr_cnt)    count of record(s)|block(s)|CI(s)
            binary(21:4 sr_rci)    relative CI nbr
            binary(25:8 sr_xrba)   xrba
         */
         Parse UPPER VAR line sr_type 2 sr_am 3 sr_org 4 sr_flag 5 ,
            9 sr_seq 13 sr_lgth 17 sr_cnt 21 sr_rci 25 .;
         If sr_flag = "E" Then;
           Iterate;
         Select;
           When sr_type = "1" Then;
             Do;
               i = i + 1;
               L.i = c2d(sr_lgth);
               F.i = c2d(sr_cnt);
             End;
           Otherwise;
             Iterate;
         End;
       End;
     Else;
       Do;
         L.0 = i;
         F.0 = i;
         eof = "Y";
         "EXECIO 0 DISKR FANALDD ( FINIS ";
       End;
   End;

/* "CLEAR"; */
   Say "There are" i "unique record lengths";

Compute_MEAN:

   cnt = 0; sum = 0; mean = 0;
   If L.0 > 0 Then;
     Do;
       x = MEAN(L.0);
       cnt = Word(x,1);
       sum = Word(x,2);
     End;

   Say "Total bytes          =" sum;
   Say "Total records        =" cnt;
   If cnt > 0 Then;
     mean = Format((sum/cnt),,0);
   Say "Mean of LRECL vector =" mean;

Compute_MODE:

   freq = 0;
   If L.0 > 0 Then;
     freq = MODE(L.0);
   Say "Highest frequency of occurrences =" freq;

   If M.0 > 0 Then;
     Do i = 1 To M.0;
       Say "  Mode of LRECL vector =" M.i;
     End;

   i = L.0;
   If L.0 > 0 Then;
     Say "Range of values in LRECL vector = ("L.1":"L.i")";

Compute_VARIANCE:

   varsq = 0;
   cntlofmean = 0; cnteqmean = 0; cntrofmean = 0;
   If L.0 > 0 Then;
     Do;
       x = VARIANCE(L.0,mean,cnt);
       varsq = Word(x,1);        /*return variance squared*/
       cntlofmean = Word(x,2);   /*return items left of mean*/
       cnteqmean = Word(x,3);    /*return items eq to mean*/
       cntrofmean = Word(x,4);   /*return items right of mean*/
     End;

   Say "Variance squared =" varsq;
   Say "  Items < mean   =" cntlofmean;
   Say "  Items = mean   =" cnteqmean;
   Say "  Items > mean   =" cntrofmean;
   stddev = SQRT(varsq);
   Say "Std Deviation    =" Format(stddev,,0);
   Say "Range of average LRECL vector = (" ,
        || Format((mean-stddev),,0) || ":" ,
        || mean || ":" ,
        || Format((mean+stddev),,0) || ")";

   Return 0;

/* --------------------------- */
   MEAN: Procedure Expose L. F.

/* REXX function
   Invoke as: MEAN(occurs,nd)
   Determine the arithmetic mean/average of vector entries.

   where L.i = LRECL vector
         F.i = FREQuence of LRECL entry vector

   ------------------------------------------------------- */

   Parse ARG occurs,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   cnt = 0;
   sum = 0;
   Do i = 1 To occurs;
     cnt = cnt + F.i;
     sum = sum + (L.i * F.i);
   End;

   Return (cnt  sum);

/* --------------------------- */
   VARIANCE: Procedure Expose L. F.

/* REXX function
   Invoke as: VARIANCE(occurs,mean,nd)
   Determine the variance between each value in the vector.
   Sum of (((L.i-mean)**2)*F.i)

   where L.i = LRECL vector
         F.i = FREQuency of LRECL entry vector
   ------------------------------------------------------- */

   Parse ARG occurs,mean,cnt,nd;

   If nd = "" Then;
     nd = 12;

   Numeric Digits nd;

   leftofmean = 0;
   eqtomean = 0;
   rightofmean = 0;
   varsq = 0;

   Do i = 1 To occurs;
     dif = L.i - mean;
     If dif < 0 Then;
       leftofmean = leftofmean + F.i;
     If dif = 0 Then;
       eqtomean = eqtomean + F.i;
     If dif > 0 Then;
       rightofmean = rightofmean + F.i;
     varsq = varsq + (dif**2) * F.i;
   End;

   If cnt > 0 Then;
     varsq = varsq / cnt;

   Return (varsq leftofmean eqtomean rightofmean);

/* --------------------------- */
   MODE: Procedure Expose L. F. M.

/* REXX function
   Invoke as: MODE(occurs)
   Determine the most frequently occuring value(s) of a
   sorted vector.

   where L. = LRECL vector
         F. = FREQuency of LRECL entry vector
         M. = MODE vector (LRECL with the most occurrences)
   ------------------------------------------------------- */

   Parse ARG occurs;

   j = 1;           /*index of largest entry in FREQuency vector*/
   freq = F.j;      /*init freq with 1st entry in FREQuency vector*/

   Do i = 2 To occurs;
     If freq < F.i Then;
       Do;          /*tag 1st occurrence of largest frequency*/
         j = i;
         freq = F.i;
       End;
   End;

   k = 0;
   Do i = j To occurs;
     If F.i = freq Then;
       Do;          /*save LRECL in Mode vector*/
         k = k + 1;
         M.k = L.i;
       End;
   End;
   M.0 = k;

   Return (freq);

/* --------------------------- */
   SQRT: Procedure

/* REXX function
   Invoke as: SQRT(real);
   Compute the square root of a real number using Newton's
   formula New=0.5*(X+N/X), where X starts with a reasonable
   guess e.g. (1+N)/2.

   Returns "INVALID" if value is not a valid REXX number.

   ------------------------------------------------------- */

   Parse ARG real,np;

   If Datatype(real,'N') = 1 Then;
     Nop;
   Else;
     Return "INVALID";

   If real = 0 Then;
     Return 0;

   If np = "" Then;
     np = 9;

   Numeric Digits np;

   Parse VALUE FORMAT(real,,,,0) With real "E" exp;

   If exp = "" Then;
     exp = 0;

   If (exp // 2) <> 0 Then;
     If exp > 0 Then;
       Do;
         real = real * 10;
         exp = exp - 1;
       End;
     Else;
       Do;
         real = real / 10;
         exp = exp + 1;
       End;

   x = 0.5 * (real + 1);

   Do Forever;
     NewX = 0.5 * (x + real / x);
     If x = NewX Then;
       Return X * 10 ** (exp % 2);
     x = NewX;
   End;

   Return (0);

   /* ------------------------- */
   /* Error Processing Routines */
   /* ------------------------- */

   Error_NODATA:

   Say "Missing dsname";
   Exit (-16);

   Error_INVALID_DSNAME:

   Say "INVALID DSNAME" dsname;
   Exit (-16);

   Error_DATASET_ALLOC:

   Say "TSO ALLOCation failed" dsname EC;
   Exit (-16);

   Error_DATASET_OPEN:

   Say "OPEN failed" dsname EC;
   Exit (-16);
./ ADD NAME=SPDISK   0102-07353-17166-1536-00176-00158-00000-APLKS   13
/* REXX 2017-06-15 */
/********************************************************************/
/*                     DISK STORAGE OCCUPANCY                       */
/*  ------------------------------------------------------------    */
/*  CARE: REXX = HOT CPU                                            */
/*  ------------------------------------------------------------    */
/* AUTHOR: PHILIPPE COCHY                                           */
/* REXX : SPDISK PARM1 PARM2                                        */
/* PARM1 = DCOLLECT TYPE D DATASET, PARM2 = OUTPUT REPORT           */
/* SYSIN: DATASET(S) PATTERNS TO BE ANALYZED, 1 PATTERN BY LINE     */
/* OUTPUT REPORT: "PATTERNS OF DATASETS"  "SPACE IN GIGABYTES"      */
/*                                                                  */
/* Modified by: L Slaten                                            */
/* default PARM1 to &sysuid..DCOLLECT.RECDM                         */
/* default PARM2 to &sysuid..DCOLLECT                               */
/*                                                                  */
/********************************************************************/
numeric digits 18

trace N
parse arg INDSN OUTDSN
/* code changes begin */
If INDSN = '' & OUTDSN = '' Then;
  Do;
    INDSN = USERID() || '.DCOLLECT.RECDM';
    OUTDSN = USERID() || '.DCOLLECT';
  End;
If INDSN = 'NONE' Then;
  INDSN = USERID() || '.DCOLLECT.RECDM';
If OUTDSN = '' Then;
  OUTDSN = USERID() || '.DCOLLECT';
/* code changes ends */

"ALLOC DSNAME('" || INDSN || "') DDNAME(INDD) SHR"
FIRST_REC = 'YES'
"execio * diskr" SYSIN     "(finis stem PAT."
OQP.0 = PAT.0
do M = 1 to PAT.0
  parse var PAT.M PAT.M .
  OQP.M = 0
end
"execio 10000 diskr INDD (stem IN_REC."
do while IN_REC.0 > 0
   do R = 1 TO IN_REC.0
      parse VAR IN_REC.R 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
         13 DCUTIME 17 DCUDATE 21 .
      if FIRST_REC = 'YES' then do
         SMFDATE = left(C2X(DCUDATE),7)
         JULDATE = right(SMFDATE,5)
         STDDATE = date('S',JULDATE,'J')
         COLDATE = right(STDDATE,6)
         FIRST_REC = 'NO'
      end
      if DCURCTYP = "D " then do
         CALL DCDRECP
         do M = 1 TO PAT.0
           if MATCH(DCDDSNAM,PAT.M) then do
             OQP.M = OQP.M + right(C2D(DCDALLSP),10)
           end
         end
      end
   end
   "execio 10000 diskr INDD (stem IN_REC."
end
"execio 0 diskr INDD (finis"
"free ddname(INDD)"
do S = 1 TO OQP.0
  GBYTES = OQP.S/1048576
  PAT.S = left(PAT.S,44,' ') || format(GBYTES,6,3,0)
end
"alloc dsname('" || OUTDSN || ".D2"||COLDATE||"')",
    "dsorg(ps) lrecl(80) recfm(f b) ",
    "cylinders space(300,50) release ddname(OUTDD)"
"execio * diskw OUTDD (finis stem PAT."
"free ddname(OUTDD)"
exit

/**********************************************************************/
/* ROUTINE DE PARSE                                                   */
/**********************************************************************/
DCDRECP:
  parse var IN_REC.R 1 . 25 DCDDSNAM 69 DCDERROR 70,
    70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
    78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
    89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
    105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
    123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
    143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
    207 . 231 DCDSTGRP 239 .
return
/**********************************************************************/
/* ROUTINE DE TEST DU DSNAME                                          */
/**********************************************************************/
MATCH:
parse arg DSN, PAT
PAT = strip(PAT)
if right(PAT,3) = '.**' then do
  PAT = left(PAT,length(PAT)-3)
  DSN = strip(DSN)
end
else do
  PAT = PAT || '&'
  DSN = strip(DSN) || '&'
end
parse var DSN D.1 '.' D.2 '.' D.3 '.' D.4 '.' D.5 '.' D.6 '.' D.7 '.' .
do I = 1 to 7
  if D.I = "" then leave
end
D.0 = I-1
parse var PAT P.1 '.' P.2 '.' P.3 '.' P.4 '.' P.5 '.' .
do J = 1 to 5
  if P.J = "" then leave
end
P.0 = J-1
J = 1
do I = 1 to D.0              /* Niveau qualifieur */
  if J > P.0 then leave      /* plus de qual @ comparer */
  if P.J = '**' then J = J+1 /* qual ** pattern ignore */
  if J > P.0 then leave      /* plus de qual @ comparer */
  Q = P.J
  if D.I = Q then J = J+1    /* qual dsn = qual pattern : +1 I et J */
  else do                    /* qual dsn /= qual pattern */
    LEN = length(D.I)        /* caractere par caractere */
    JC = 1
    do IC = 1 to LEN
      if JC > length(Q) then leave /* plus de car a comparer */
      if substr(Q,JC,1) = '*' then JC = JC+1 /* car * pattern ignore */
      if substr(Q,JC,1) = '%' then do        /* car joker */
        parse var Q P1 '%' P2
        Q = P1 || substr((D.I),IC,1) || P2   /* substitution car qual */
        JC = JC+1            /* +1 IC et JC */
        iterate
      end
      if substr(D.I,IC,1) = substr(Q,JC,1) then do
        JC = JC+1            /* car dsn = car pattern : +1 IC et JC */
        iterate
      end
    end                           /* fin de car par car */
    if D.I /= Q then do
/* transforme du qualifieur par * */
      Q = '.' || Q || '.'
      QD = '.' || D.I || '.'
      parse var Q P1 '*' P2 '*' P3 '*' .
      parse var QD D1 (P1) D2 (P2) D3 (P3) .
      Q = D1 || P1 || D2 || P2 || D3 || P3
/* fin de transforme par * */
      if QD = Q then do
        P.J = strip(Q,,'.')
        J = J+1
      end
    end
    else do
      P.J = Q
      J = J+1
    end
  end                        /* fin de qual dsn /= qual pattern */
end                          /* boucle qual dsn suivant */
PAT = P.1
do J = 2 to 5
  if P.J = '' then leave
  PAT = PAT || '.' || P.J
end
/* transforme du dsname par ** */
parse var PAT P1 '**' P2 '**' P3 '**' .
if P1='' then do
  parse var DSN D1 (P2) D2 (P3) D3
  PAT = D1 || P2 || D2 || P3 || D3
end
else do
  parse var DSN D1 (P1) D2 (P2) D3 (P3) .
  PAT = P1 || D1 || P2 || D2 || P3 || D3
end
/* fin de transforme par ** */
if DSN = PAT then RC = 1
else RC = 0
return RC
./ ADD NAME=TSTRXSMS 0105-15296-16018-1435-00189-00001-00000-APLKS   47
/* REXX */
/*
   RC = RXSMS(function,stemname<,search argument>)
   function:
   AVL    All volumes in current configuration
   SGL    List of all Storage Groups
   SGV    Volser list for a given Storage Group (requires search arg)
   VSG    Storage Group for a given volser      (requires search arg)
   VOL    Volume definition for a given volser  (requires search arg)
   DCL    List all Data Classes
   SCL    List all Storage Classes
   MCL    List all Management Classes
   LSPACE LSPACE
*/

   /* List all Volumes on System */
   function = "AVL";
   stemname = "AVL.";
   RC = RXSMS(function,stemname);
   If RC <> 0 Then;
     Do;
       Say "Function AVL failed RC =" RC;
       avl.0 = 0;
     End;
   Say "***";
   Say "There are "avl.0" volumes";
   Do i=1 To avl.0;
     Say avl.i;
     Say "Device:" RXV2DEV(Word(avl.i,1));
     altfunction = "LSPACE";
     altstemname = "LSP.";
     altsrcharg = Word(avl.i,1);        /*extract volume*/
     Say altfunction altstemname altsrcharg;
     RC = RXSMS(altfunction,altstemname,altsrcharg);
     If RC <> 0 Then;
       Do;
         Say "Function LSPACE failed RC =" RC;
         lsp.0 = 0
       End;
     Say "====";
     Say "There are "lsp.0" LSPACE records";
     Do j=1 To lsp.0;
       Say lsp.j;
     End;
     Say "****";
   End;

   /* List all Storage Groups */
   function = "SGL";
   stemname = "SGL.";
   RC = RXSMS(function,stemname);
   If RC <> 0 Then;
     Do;
       Say "Function SGL failed RC =" RC;
       sgl.0 = 0;
     End;
   Say "***";
   Say "There are "sgl.0" Storage Groups";
   If RC = 0 Then;
     Do i=1 To sgl.0;
       SAY sgl.i;
     End;

   /* List all Volumes for a Storage Group */
   function = "SGV";
   stemname = "SGV.";
   If sgl.0 > 0 Then;
     Do;
       srcharg = "SGTEST"               /*extract storage group*/
       Say function stemname srcharg;
       RC = RXSMS(function,stemname,srcharg);
     End;
   If RC <> 0 Then;
     Do;
       Say "Function SGV failed RC =" RC;
       sgv.0 = 0;
     End;
   Say "***";
   Say "There are "sgv.0" Volumes for the Storage Group" srcharg;
   If RC = 0 Then;
     Do i=1 To sgv.0;
       SAY sgv.i;
     End;

   /* List Storage Group for a Volume */
   function = "VSG";
   stemname = "VSG.";
   If sgv.0 > 0 Then;
     Do;
       srcharg = Word(sgv.1,1);         /*extract volume*/
       Say function stemname srcharg;
       RC = RXSMS(function,stemname,srcharg);
     End;
   If RC <> 0 Then;
     Do;
       Say "Function VSG failed RC =" RC;
       vsg.0 = 0;
     End;
   Say "***";
   Say "There are "vsg.0" Storage Group(s) for the VOLSER" srcharg;
   If RC = 0 Then;
     Do i=1 To vsg.0;
       SAY vsg.i;
     End;

   /* Volume definition for a VOLSER */
   function = "VOL";
   stemname = "VOL.";
   If sgv.0 > 0 Then;
     Do;
       srcharg = Word(sgv.1,1);         /*extract volume*/
       Say function stemname srcharg;
       RC = RXSMS(function,stemname,srcharg);
     End;
   If RC <> 0 Then;
     Do;
       Say "Function VSG failed RC =" RC;
       vol.0 = 0;
     End;
   Say "***";
   Say "There are "vol.0" Volume definition(s) for the VOLSER" srcharg;
   If RC = 0 Then;
     Do i=1 To vol.0;
       SAY vol.i;
     End;

   /* List all Data Classes on System */
   function = "DCL";
   stemname = "DCL.";
   RC = RXSMS(function,stemname);
   If RC <> 0 Then;
     Do;
       Say "Function DCL failed RC =" RC;
       dcl.0 = 0;
     End;
   Say "***";
   Say "There are "dcl.0" Data Classes";
   Do i=1 To dcl.0;
     SAY dcl.i;
   End;

   /* List all Storage Classes on System */
   function = "SCL";
   stemname = "SCL.";
   RC = RXSMS(function,stemname);
   If RC <> 0 Then;
     Do;
       Say "Function SCL failed RC =" RC;
       scl.0 = 0;
     End;
   Say "***";
   Say "There are "scl.0" Storage Classes";
   Do i=1 To scl.0;
     SAY scl.i;
   End;

   /* List all Management Classes on System */
   function = "MCL";
   stemname = "MCL.";
   RC = RXSMS(function,stemname);
   If RC <> 0 Then;
     Do;
       Say "Function MCL failed RC =" RC;
       mcl.0 = 0;
     End;
   Say "***";
   Say "There are "mcl.0" Management Classes";
   Do i=1 To mcl.0;
     SAY mcl.i;
   End;

   Exit;

   /* List LSPACE information on System */
   function = "LSPACE";
   stemname = "LSP.";
   RC = RXSMS(function,stemname);
   If RC <> 0 Then;
     Do;
       Say "Function LSP failed RC =" RC;
       lsp.0 = 0;
     End;
   Say "***";
   Say "There are "lsp.0" LSPACE records";
   Do i=1 To lsp.0;
     SAY lsp.i;
   End;

   Exit;
