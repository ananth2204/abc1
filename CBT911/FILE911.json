{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013416000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 17, "INMDSNAM": "CBT.V500.FILE911.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE911.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x07'", "DS1TRBAL": "b'\\x97$'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\x00\\x00\\x0b\\t\\x01\\x00\\x05\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00\\x00\\x01\\x14\\x14\\x8f\\x01\\x14\\x14\\x8f\\x00\\x02\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2014-05-28T00:00:00", "modifydate": "2014-05-28T00:02:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-488"}, "text": "REGULAR CBT TAPE - VERSION 488    FILE:  911\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT488.FILE911\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    16000   PO\n\n   PDS117I 66 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,634 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/28/14    00:02:00    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HIDEALL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x19\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:19:11", "lines": 28, "newlines": 28, "modlines": 0, "user": "EXEC"}, "text": "/* REXX $hideall\nA macro for the TSO/ISPF editor.\nUsed within a TSO/ISPF edit session.\nIt excludes (hides) all lines of the file which\ncontain a specific character string.\n\nTo use, within a TSO/ISPF edit session,\ntype $HIDEALL character-string on the command line.\nExample:\n$HIDEALL DSN=\n*/\nADDRESS ISREDIT\n\"MACRO (PARM1)\"\n\nIF RC > 0 THEN SIGNAL NOT_AS_A_MACRO\nIF PARM1 = \"\" THEN EXIT\nADDRESS ISREDIT \"EXCLUDE ALL\"\nADDRESS ISREDIT \"FIND ALL '\"PARM1\"'\"\nADDRESS ISREDIT \"FLIP \"\nEXIT /* NORMAL END OF PROGRAM */\n\nNOT_AS_A_MACRO:\nSAY \"THIS IS A TSO/ISPF EDITOR MACRO\"\nSAY \"IT MAY BE EXECUTED ONLY IN THE ISPF EDITOR\"\nSAY \"BY TYPING $HIDEALL char-string ON THE COMMAND LINE\"\nEXIT\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x06\\x01\\x14\\x14?\\x01\\x14\\x14\\x7f#7\\x001\\x00\\x11\\x00\\x00\\xd9\\xc5\\xc1\\xc4\\xd4\\xc5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-27T23:37:06", "lines": 49, "newlines": 17, "modlines": 0, "user": "README"}, "text": "     PROBLEMS FROM GABRIEL GARGIULO'S REXX BOOK\n     -------- ---- ------- ---------- ---- ----\n\nThese are suggested solutions to the practice problems\nreferenced in the book:\n\n\"The REXX Language on TSO\"  by Gabriel F. Gargiulo.\nISBN-10: 1479104779 ISBN-13: 978-1479104772\n\nThe members in this PDS are REXX programs, functions\nor subroutines.\n\nNote that there is not a program for every problem.\nIn other words, the numbers for the programs are not consecutive.\n\nThe descriptions of the problems and their solutions\n(IE, these programs) can be found here:\nhttp://theamericanprogrammer.com/programming/rexx2.prob.shtml\n\n Note:  This is duplicated in member @PROBLMS\n\nMore information about the book can be found here:\nhttp://theamericanprogrammer.com/programming/rexx.programming.book.shtml\n\n Summary of information:\n\n  Learn how to write programs in the REXX language for TSO, MVS,\n  OS/390, Z/OS.\n\n My first book on the REXX programming language, is out of print.\n This is my second book on REXX for TSO.\n\n It improves on REXX in the TSO Environment in every way: it\n clarifies important points, it is better organized, and gives\n better examples.\n\n There are very few other books in print about REXX in the TSO\n Environment.\n\n This book quickly gets you started writing programs in REXX for\n MVS, OS/390, z/OS.  It covers all REXX language elements, all TSO\n built-in functions, and the more important built-in functions.\n\n Several REXX programs, macros, and user-written functions are\n illustrated and explained.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE911": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00U\\x01\\x14\\x14\\x8f\\x01\\x14\\x14\\x8f\\x00\\x01\\x00#\\x00#\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2014-05-28T00:00:00", "modifydate": "2014-05-28T00:01:55", "lines": 35, "newlines": 35, "modlines": 0, "user": "CBT-488"}, "text": "//***FILE 911 is from Gabriel Gargiulo and contains answers for     *   FILE 911\n//*           problems in his textbook on the REXX language:        *   FILE 911\n//*                                                                 *   FILE 911\n//*                  \"The REXX Language on TSO\"                     *   FILE 911\n//*                    by Gabriel F. Gargiulo.                      *   FILE 911\n//*                                                                 *   FILE 911\n//*       ISBN-10: 1479104779 ISBN-13: 978-1479104772               *   FILE 911\n//*                                                                 *   FILE 911\n//*       email:  gabeg@yoursecondlanguage.com                      *   FILE 911\n//*                                                                 *   FILE 911\n//*       - - - - - - - - - - - - - - - - - - - - - - - - - -       *   FILE 911\n//*                                                                 *   FILE 911\n//*       See the following URL for direct information about        *   FILE 911\n//*        the book.                                                *   FILE 911\n//*                                                                 *   FILE 911\n//*       http://theamericanprogrammer.com/programming/  (continue) *   FILE 911\n//*           rexx.programming.book.shtml                           *   FILE 911\n//*                                                                 *   FILE 911\n//*       - - - - - - - - - - - - - - - - - - - - - - - - - -       *   FILE 911\n//*                                                                 *   FILE 911\n//*       Included in this file are:                                *   FILE 911\n//*                                                                 *   FILE 911\n//*       1.  Problems in the book and answers to them.             *   FILE 911\n//*                                                                 *   FILE 911\n//*       2.  Various REXX EXECs that are useful (marked with       *   FILE 911\n//*            a userid of EXEC).                                   *   FILE 911\n//*                                                                 *   FILE 911\n//*       Please see members @PROBLMS, ALL, and ALLEXECS for        *   FILE 911\n//*       further summary information and instruction.              *   FILE 911\n//*                                                                 *   FILE 911\n//*       Of course, it's better to have the book, together with    *   FILE 911\n//*       this file, but even so, this file will be helpful, even   *   FILE 911\n//*       by itself.  The book can (and should) be ordered on       *   FILE 911\n//*       Amazon.                                                   *   FILE 911\n//*                                                                 *   FILE 911\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@PROBLMS": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x14\\x14\\x7f\\x01\\x14\\x14\\x7f#$\\x05\\xc6\\x05\\xc6\\x00\\x00\\xc5\\xe7\\xd7\\xd3\\xc1\\xc9\\xd5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-05-27T00:00:00", "modifydate": "2014-05-27T23:24:54", "lines": 1478, "newlines": 1478, "modlines": 0, "user": "EXPLAIN"}, "text": "         \t*The American Programmer*\n\n\n**Home* <http://TheAmericanProgrammer.com/index.shtml>*\n*Books on Mainframe Programming\n<http://TheAmericanProgrammer.com/books/index.shtml>*\n*Mainframe Manuals and Tutorials\n<http://TheAmericanProgrammer.com/manuals/index.shtml>*\n*System Abend codes, Sqlcodes, VSAM/QSAM codes\n<http://TheAmericanProgrammer.com/error-codes/index.shtml>*\n*Everything about the IBM AS/400 Midrange Computer - iSeries\n<http://TheAmericanProgrammer.com/as400/index.shtml>*\n*Everything about CICS <http://TheAmericanProgrammer.com/cics/index.shtml>*\n*Everything about COBOL\n<http://TheAmericanProgrammer.com/cobol/index.shtml>*\n*Everything about DB2 and SQL\n<http://TheAmericanProgrammer.com/db2-sql/index.shtml>*\n*Everything about IMS <http://TheAmericanProgrammer.com/ims/index.shtml>*\n*Everything about Java and JavaScript\n<http://TheAmericanProgrammer.com/java-javascript/index.shtml>*\n*Everything about JCL and JES\n<http://TheAmericanProgrammer.com/jcl-jes/index.shtml>*\n*Everything about REXX <http://TheAmericanProgrammer.com/rexx/index.shtml>*\n*  Sorting in REXX: The Bubble Sort\n<http://TheAmericanProgrammer.com/programming/rexx.bubble.sort.shtml>*\n*  REXX Password Generator\n<http://TheAmericanProgrammer.com/programming/rexx.password.generator.shtml>*\n\n*  Using REXX to capture displayed output of TSO command\n<http://TheAmericanProgrammer.com/programming/rexx.outtrap.capture.shtml>*\n*  Count records in REXX\n<http://TheAmericanProgrammer.com/programming/rexx.count.shtml>*\n*  REXX program to calculate present value of money\n<http://TheAmericanProgrammer.com/programming/rexx.discount.present.value.shtml>\n\n*  REXX function to format a number in currency format\n<http://TheAmericanProgrammer.com/programming/rexx.format.dollars.shtml>*\n*  REXX function to produce a fixed-length number\n<http://TheAmericanProgrammer.com/programming/rexx.fixed.length.number.shtml>*\n\n*  REXX program to produce lottery numbers\n<http://TheAmericanProgrammer.com/programming/rexx.lottery.numbers.shtml>*\n*  REXX: what does your phone number spell?\n<http://TheAmericanProgrammer.com/programming/rexx.phone.number.spell.shtml>*\n\n*  REXX Practice Problems.\n<http://TheAmericanProgrammer.com/programming/rexx2.prob.shtml>*\n*  Just Enough REXX Tutorial\n<http://TheAmericanProgrammer.com/programming/jerexx.shtml>*\n*  Setting up to Execute REXX Programs on TSO/ISPF\n<http://TheAmericanProgrammer.com/programming/rexxsetp.shtml>*\n*  How to execute a REXX program\n<http://TheAmericanProgrammer.com/programming/rexx.how.to.execute.shtml>*\n*  REXX Boolean operators\n<http://TheAmericanProgrammer.com/programming/rexx.boolean.operators.shtml>*\n\n*  Comparison of CLIST language and REXX\n<http://TheAmericanProgrammer.com/programming/rexx.clist.shtml>*\n*  REXX Comparison operators\n<http://TheAmericanProgrammer.com/programming/rexx.comparison.operators.shtml>*\n\n*  REXX Debugging: the TRACE verb\n<http://TheAmericanProgrammer.com/programming/rexx.debugging.trace.shtml>*\n*  Using REXX OUTTRAP\n<http://TheAmericanProgrammer.com/programming/rexx.outtrap.shtml>*\n*  Reserved REXX Variables\n<http://TheAmericanProgrammer.com/programming/rexx.reserved.variables.shtml>*\n\n*  Executing REXX through JCL.\n<http://TheAmericanProgrammer.com/programming/rexxjcl.shtml>*\n*  Writing ISPF Edit Macros in REXX\n<http://theamericanprogrammer.com/programming/holymac.shtml>*\n*  REXX program to unload a PDS\n<http://TheAmericanProgrammer.com/programming/rexx.pdstosequential.shtml>*\n*  REXX book: The REXX Language on TSO\n<http://TheAmericanProgrammer.com/programming/rexx.programming.book.shtml>*\n*  REXX Functions Book\n<http://TheAmericanProgrammer.com/programming/rexx.function.book.shtml>*\n*  QMF Procedures Written in REXX\n<http://TheAmericanProgrammer.com/programming/qmfrexx.shtml>*\n*  Using REXX Subroutines with the QMF Calc panel\n<http://TheAmericanProgrammer.com/programming/qmfcalc.shtml>*\n*  REXX error codes (RC)\n<http://TheAmericanProgrammer.com/programming/rexx.programming.book.shtml (cont)\n    #errorcodes>*\n\n*  REXX programming language manuals\n<http://TheAmericanProgrammer.com/programming/manuals.rexx.shtml>*\n*  Books on REXX programming\n<http://TheAmericanProgrammer.com/books/books.rexx.shtml>*\n*  The REXX Files\n<http://TheAmericanProgrammer.com/programming/rexxfiles.shtml>*\n*Everything about zOS, VSAM, Tivoli, Assembler\n<http://TheAmericanProgrammer.com/system-vsam-tivoli-asm/index.shtml>*\n*Everything about TSO, ISPF, Spufi\n<http://TheAmericanProgrammer.com/tso-ispf-spufi/index.shtml>*\n*Site Map and Site Search <http://TheAmericanProgrammer.com/sitemap.shtml>*\n\n\t*\n           *Home* <http://theamericanprogrammer.com/>*   > *REXX*\n<http://theamericanprogrammer.com/rexx/index.shtml>*   > REXX Practice\nProblems ******\n\n    *\n\n    REXX Practice Problems. (Answers below)\n\n    *\n\n    This is to be used with the book The REXX Language on TSO\n    <http://theamericanprogrammer.com/programming/rexx.programming.book.shtml>\n    These problems go with the book.\n    The book tells you to do specific problems after it covers the\n    material.\n\n    You'll find the answers <#answers> about halfway through this document.\n    look for\n      ******Suggested answers for workshops.******\n      ******Suggested answers for workshops.******\n\n\n    1. In Chapter 3, after say.\n     Create and run the following REXX program using your name instead of Sue\n     Name it PROB001.\n    \tSay 1 + 1\n     \tSay \"Today is\" Date()\n     \tName = \"Sue\"\n     \tSay \"Hello, \" Name\n\n    2. In Chapter 3, after literal. PROB002\n    Using Say\n     Display the literal \"hello\"\n     display 1 + 1\n     display the length of the literal \"hello\"\tSay length(\u00f4hello\u00f6)\n     set the variable NUM to 5\n     display NUM + 5\n\n    3. In Chapter 3, after literal. PROB003\n    Type in this program without the line numbers.\n     Run this program.\n     Discuss the results.\n\n     1\t/* rexx */\n     2\tSay 1  + 1\n     3\tSay \"1 + 1\"\n     4\tSay \"1\"  + \"1\"\n     5\tSay one + 1\n     6\tone = 1\n     7\tSay one + 1\n     8\tSay \"one\" + 1\n\n    4. In Chapter 3, after literal. PROB004\n     Type in this program without the line numbers.\n     Run this program.\n     Discuss the results.\n     1\t/* rexx */\n     2\tone = 1\n     3\tSay one + 1\n     4\tDrop one\n     5\tSay one + 1\n\n    5. Variables. In Chapter 3, after concatenate data. PROB005\n    Set a variable to \"Good morning\"\n     Set a variable to your name. (Joe in the example)\n     Display Good morning Joe\n     Display Good morningJoe\n     Display Good morning   (10 spaces here)     Joe\n\n    6. In Chapter 3, after Passing Commands to TSO. PROB006\n    Run this program. Discuss the results.\n    say \"enter a message\"\n    pull message\n    say \"enter userid to send to\"\n    pull userid\n    \"send '\"message\"'user(\"userid\")\"\n\n    7. In Chapter 3, after Passing Commands to TSO. PROB007\n    Execute the TSO command LISTDS 'your-userid.REXX.EXEC' MEMBERS\n     in a REXX program.\n\n    8. In Chapter 3, after Passing Commands to TSO. PROB008\n    Variables in TSO Command. Use of quotes.\n     Like the previous, but MEMBERS is now a variable.\n     Set it to nothing, in other words MEMBERS = \"\"\n     Now run the program. It should not display any members.\n\n    9. After Chapter 3. PROB009\n    What does this program do?\n\n     /*REXX SAMPLE PROB009*/\n     X = 10\n     Y = 20\n     Z = Y - X\n     SAY \"THE ANSWER IS \" Z\n\n    10. After Chapter 3. PROB010\n    Write an exec to execute the TSO commands:\n     TIME\n     SEND 'SAMPLE EXEC ' USER(*)\n\n     Include the comment:    This is a sample exec for REXX class\n\n     Expected results will be approximately like this:\n     09:05:02  03/08/42  CPU  4.3  SVC  888.323\n     + SAMPLE EXEC TSOU01\n\n    11. After Chapter 3. PROB011\n    What does this program do?\n     /*REXX TRYME*/\n     SAY GREETING\n\n    12. After Chapter 3. PROB012\n    What does this program do?\n\n     /*REXX TRY ME TOO*/\n     GREETING = \"HELLO\"\n     SAY GREETING\n\n    13. After Chapter 3. PROB013\n    Can you tell what this does?  Try it out if you don't know.\n     /*REXX TRY ME TOO*/\n     GREETING = \"HAPPY HALLOWEEN\"\n     SAY GREETING\n     DROP GREETING\n     SAY GREETING\n\n    14. After Chapter 3. PROB014\n    What does this display on the screen?\n     SAY 'F2F3F4'X\n\n    15. After Chapter 3. PROB015\n    Write an exec that displays these lines exactly as shown:\n     3 + 1 is 4\n    '3 + 1 is 4'\n    O'brien\n\n    16. After Chapter 3. PROB016\n    Write an exec that executes this TSO command:\n       \tLISTCAT ENTRY('SYS1.PROCLIB')\n\n    17. After Chapter 3. PROB017\n    What does this exec print out?\n     /*REXX SHORT EXEC*/\n     MESSAGE = MESSAGE\n     SAY MESSAGE\n     EXIT\n\n    18. After Chapter 3. PROB018\n    In an exec, assign the number 10 to a variable.\n     Assign the number 20 to another variable.\n     In one instruction display the total of the two.\n\n    19. After Chapter 3. PROB019\n    First assign the variable USERID the value of your neighbor's\n    TSO userid.  Then execute the TSO command:\n\n     LISTCAT LEVEL(your neighbor's userid)\n    using the variable USERID in place of your neighbor's userid.\n\n    20. After Chapter 4, IF. PROB020\n    Write a program that will show you what happens when you\n    create a number with more than 9 digits. Type this in. Run\n    it with a trace I.\n\n    NUM1 = 9876543211\n    NUM2 = 9876543212\n    If Num1 = Num2 then say \"they are equal\"\n    else say \"not equal\"\n\n    21. After Chapter 4, IF. PROB021\n    What does this exec display?\n     A = 5\n     B = 4\n     SAY A = B\n\n    22. After Chapter 4, IF. PROB022\n    What does this exec display?  Try it to find out.\n     A = 2 + 2 = 2\n     SAY A\n\n     These are displaying the truth value of the comparison\n     \ttrue is 1\n    \tfalse is 0\n\n    23. After Chapter 5. Looping, DO END PROB023\n    \tType this in a program. Notice the results\n     \t\tDO\n     \t\t\tSay \"hi\"\n     \t\t\tSay \"lo\"\n     \t\tEND\n\n    24. After Chapter 5. Looping, DO END PROB024\n     \tType this in a program. Notice the results\n     \t\tDO 5\n     \t\t\tSay \"hi\"\n     \t\t\tSay \"lo\"\n     \t\tEND\n\n    25. After Chapter 5. Looping, DO END PROB025\n    \tType this in a program.\n     \t\tthe first time, replace XXXXX with EXIT\n     \t\t2nd time replace with ITERATE\n     \t\t3rd time replace with LEAVE\n     \t\t4th time replace with SIGNAL BYE\n     \tNotice the difference\n     \tDO 10\n     \t\tSay \"loop or stop now?\"\n     \t\tSay \"type STOP, or press enter to keep looping\"\n     \t\tPull Reply\n     \t\tIf Reply = \"STOP\" then XXXXX\n     \tEND\n     \tBye:\t\tExit\n\n    26. After Chapter 5. Looping, DO END PROB026\n     Nesting.\tRun this\n     \tDO Outer = 1 to 10\n     \t\tDo Inner = 1 to 5\n     \t\t\tSay Outer Inner\n     \t\tEnd Inner\n     \tEnd Outer\n\n    27. After Chapter 5. Looping, DO END PROB027\n     Nesting\n     \tSame as the previous, but change the last END OUTER to END INNER.\n     \tWhat is the result?\n\n    28. After Chapter 5. Looping, DO END PROB028\n    Write an exec that asks the user to enter a series of\n    numbers, but never the same one twice in a row.  Limit it to\n    10 numbers.\n\n    29. After Chapter 5. Looping. PROB029\n    Set secret number equal to 13.  Write an exec to keep asking\n    the user to enter a number from 1 to 20 until the secret\n    number is guessed.  Limit the loop to 10 guesses.  Expected\n    results:\n\n     ===> %myexec\n          PLEASE ENTER YOUR GUESS, FROM 1 TO 20\n     ===> 2\n          WRONG\n     ===> 7\n          WRONG\n     ===> 13\n          RIGHT\n\n    30. After Chapter 5. Looping, DO END PROB030\n     Loop 10 times.  In the loop ask for a dataset name, then\n     issue the TSO command LISTDS on the dataset.  If the RC\n     (return code) is 0, get out of the loop; otherwise display\n     the message \"not found\" and then automatically repeat the\n     loop.\n\n    31. After Chapter 6. Pull, If, Select PROB031\n     Select.\tWrite a program that asks you for your name.\n     \tIf you reply \"JOHN\" it displays \"PAUL JONES\"\n     \tIf you reply \"GEORGE\" it displays \"Washington\"\n     \tNELSON -> Mandela\n     \tJULIUS -> Caesar\n     \ta blank, or just hitting Enter -> Please try again\n     \tany thing else, Bad reply.-> Please enter a name\n\n    32. After Chapter 7. PROB032\n    Parse Pull.\n     Set this up so that the only valid reply is Yes - Upper case\n     Y, lower case e, s.\n     Ask for a reply. Get the reply.\n     If the reply is Yes display \"correct answer\" otherwise\n     display \"wrong answer\"\n\n    33. After Chapter 7. PROB033\n    Write an exec that breaks up the information contained in a\n    variable into three variables.  Place this information in the\n    first variable VAR1:\n\n     ABCDEFGHIJKLMNOP\n\n     Use the proper PARSE instruction to break up the first\n     variable this way:\n\n     VAR2 gets columns 3 and 4\n     VAR3 gets columns 6 through 9\n     VAR4 gets columns 9 through 14\n     Display VAR2\n     Display VAR3\n     Display VAR4\n\n     Expected results:\n\n     CD\n     FGHI\n     IJKLMN\n\n\n    34. After Chapter 7. PROB034\n    What would this say?\n\n     /*REXX program TESTING */\n     ARG N1 N2 N3\n     SAY N2 N3 N1\n\n     if it is executed this way:\n\n     ==> %TESTING MARYELLEN SUE KAREN\n\n    35. After Chapter 7. PROB035\n    Write an exec that will execute this TSO command:\n\n     LISTCAT ENTRY(dataset-name)\n\n     The dataset name is to be entered through an ARG.  Make sure\n     it works on datasets belonging to you as well as those\n     belonging to someone else.  Try executing it with these two\n     dataset names:\n\n     REXXPRGS.EXEC\n     'SYS1.PROCLIB'\n\n     ==> %myexec REXXPRGS.EXEC\n     ==> %myexec  'SYS1.PROCLIB'\n\n    36. After Chapter 7. PROB036\n    This ARG, and this manner of execution, produces what display?\n     /*REXX  addemup exec   */\n     ARG NUM1 NUM2 NUM3\n     TOTAL = NUM1 + NUM2 + NUM3\n     SAY TOTAL\n\n    ===> %ADDEMUP 10 20 30 40 50 60\n\n    37. After Chapter 7. PROB037\n    Write an exec that accepts three pieces of information and\n    displays them in reverse order.  If more than three are\n    entered, display an error message.  Expected results:\n\n     ==>  %myexec peter paul mary\n     MARY PAUL PETER\n     ==> %myexec peter paul mary ringo\n     I said enter only three items please!\n\n    38. After Chapter 7. PROB038\n    You want the user to type in three and only three items\n    (words) of information, separated by spaces.  What does your\n    PULL look like?\n\n    39. After Chapter 7. PROB039\n    Write an exec that asks for three words (only) and displays\n    them in reverse order.  Expected results:\n\n     ===> %myexec a b c\n          C B A\n     ===> %myexec a b c d\n          C B A\n\n    40. After Chapter 7. PROB040\n    Write a front-end exec for the DELETE command.  Have it ask\n    \"Are you sure?\"  If the dataset name is \"junk.data,\" don't\n    ask.  Expected results:\n\n     ===> %erase abc.data\n          ARE YOU SURE? Y/N\n          ===> n\n          NOT DELETED\n     ===> %erase junk.data\n          DELETED\n\n\n    41. After Chapter 7. PROB041\n    Write an exec that computes the percent of increase of one\n    number over another.  Ask for the two amounts from the\n    terminal.  The formula is:\n\n     % increase =  100 * ((new - old) / old)\n\n     Imagine your old salary was $21,203 and your new is $80,000.\n     You would figure the % increase as:\n\n     % increase =  100 * ((80000 - 21203) / 21203)\n\n     Expected results:\n\n     ===> %myexec 100 120\n         20\n\n    42. After Chapter 9, traps. PROB042\n    Write an exec that asks for a dataset name and then issues\n    the TSO command LISTDS on it.  Set up an ERROR trap to\n    intercept the command that is not working.  In the ERROR\n    trap, display the line of the program in error and the error\n    code from TSO.  Ask for the dataset name again, reexecute the\n    command, and exit.  Expected results:\n\n     ===> %myexec\n          PLEASE ENTER DATASET NAME\n     ===> abc.nonesuch.data\n          CANNOT EXECUTE TSO COMMAND\n          TSO ERROR CODE IS 12\n          LINE IN ERROR IS \"LISTDS dsn\"\n          PLEASE REENTER\n     ===> abc.real.data\n          ABC.REAL.DATA VOLUME SERIAL D12345\n          LRECL 80 BLKSIZE 3120 RECFM FB\n\n    43. After Chapter 11, Math. PROB043\n    Write an exec that will multiply two numbers.  Prompt the\n    user for the two numbers, and set up a trap to intercept any\n    error, such as invalid numbers.\n\n    44. After Chapter 11, Math. PROB044\n    Run this exec to determine the effect of parentheses on\n    arithmetic operations. What is displayed?\n\n     SAY (1 + 2) * 3\n     SAY 1 + (2 * 3)\n     SAY 1 +  2 * 3\n\n    45. After Chapter 11, Math. PROB045\n    Write an exec that asks for a number (record length) and\n    another number (block size).  It determines if block size is\n    an exact multiple of record length, that is, if record length\n    was multiplied by a whole number to obtain block size.\n    Expected results:\n\n     ===> %myexec\n          PLEASE ENTER RECORD LENGTH\n     ===> 80\n          PLEASE ENTER BLOCK SIZE\n     ===> 3121\n          BLOCK SIZE IS NOT A MULTIPLE OF RECORD LENGTH\n\n\n\n    46. After Chapter 11, Math. PROB046\n\n    Create a simple exec to calculate the effect of compound\n    interest.  Ask for the following items from the terminal:\n\n     Principal\n     Percent of interest (yearly)\n     Number of years money kept in account\n     Compounding frequency (how many times per year is interest compounded?\n     1 = yearly; 12 = monthly; 52 = weekly; 365 = daily)\n     Perform the following calculations:\n     Compute the yearly rate of interest as yearly percent of interest / 100.\n     Compute r (the rate) as  yearly rate of interest /\n     compounding frequency.\n     Compute n (number of times compounded) as how many years X\n     compounding frequency.\n     Compute final amount as principal times ((1 + r)n).\n     Display final amount.\n\n    Keep this program, since you will be improving on it later.\n\n    47. In Chapter 12. RC. PROB047\n\n     put these into a REXX program. Notice the results.\n      \"LISTCAT LEVEL(your-userid)      \"\n     Say RC\n     \"LISTCAT LEVEL(JUNK)      \"\n     Say RC\n     \"LISTDOG LEVEL(your-userid )      \"\n     Say RC\n\n\n    48. After Chapter 13. datatype, arg, math, look up the function. PROB048\n    Accept two numbers from the command line, and check to be\n    sure they are valid.  Subtract one from the other.  Drop the\n    sign of the answer and display the answer.  Expected results:\n\n    ===> %myexec 100 20\n         80\n    ===> %myexec 20 100\n         80\n\n    49. After Chapter 13. PROB049\n    Use SYSDSN to see if there exists a dataset named\n    WORKSHOP.TEMP.  If so, delete it.  If not, allocate a new one\n    like your Exec library.  The TSO command is:\n\n    ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\n\n    50. After Chapter 13. PROB050\n     Redo the previous problem, supressing any display message\n     from the DELETE command, using OUTTRAP.\n\n    51. After Chapter 13. PROB051\n    Redo the previous problem, supressing any display message\n    from the DELETE command with the MSG function.\n\n    52. After Chapter 13. PROB052\n    Using the TRANSLATE function, create an exec that will\n    convert one character string to another.  Set it up so that\n    if you type in:\n\n      GREAT\n\n    it will print out:\t  BUENO.\n\n    53. After Chapter 13. arg, hex conversion functions. PROB053\n    Write an exec that will accept a hex number, a plus or minus\n    sign, and another hex number; then add or subtract based on\n    the sign.  Display the answer in hex.  Expected results:\n\n    ===> %hexmath e - 2\n         C\n    ===> %hexmath e + 2\n         10\n\n    54. After Chapter 13. PROB054\n    Here is a working example of a program that will convert all\n    the letters in a string of characters to lower case.  Modify\n    it so that it converts from lower case to upper case.\n\n    /*REXX LOWER EXEC converts upper to lower*/\n    parse arg instring\n    upper_alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lower_alpha = \"abcdefghijklmnopqrstuvwxyz\"\n    outstring = translate(instring,lower_alpha,upper_alpha)\n    say outstring\n\n\n    55. In Chapter 14. writing your own function. PROB055\n\n     put these into a REXX program.\n\n    SAY Mysub(1,2)\n    Exit\n\n     Mysub:\n    ARG A, B\n    C = A + B\n     Return C\n\n    56. After Chapter 15. PROB056\n    Write an internal function that will concatenate two items\n    passed to it (without spaces). Execute the internal function\n    from within the same program. Expected results:\n\n     ===> %myexec cat dog\n     CATDOG\n\n    57. After Chapter 15. PROB057\n    Write an internal subroutine will concatenate two items\n    passed to it (without spaces). Execute the internal\n    subroutine from within the same program. Expected results:\n\n     ===> %myexec cat dog\n     CATDOG\n\n    58. After Chapter 15. PROB058\n    Redo the percent increase problem (problem 33) as an external\n    function, naming it PERCENTI\n\n      Have it accept two parameters (that is, arguments): first,\n      Old salary; second, New salary.\n\n     Have it return the percent increase on the RETURN statement.\n     Check both numbers for numeric.\n     If either is not valid, display a message and return a zero.\n\n     Note that there will be two members in your library: the function\n     and the main program that invokes the function.\n\n\n    59. After Chapter 15. PROB059\n    Using the solution to the CATDOG problem (problem 48), write\n    your concatenate function as an external function\n\n    60. After Chapter 15. user written external functions, math, arg. PROB060\n    Create a metric conversion external function named Metric.\n    It will accept two arguments: UNIT and QUANTITY.\n\n     UNIT has these possible values:  LITER   QUART   MILE   KILOMETER.\n     It returns a number equivalent to QUANTITY in the other\n     measuring system, based on this table:\n\n     \t1 liter     \t= 1.057 quarts\n     \t1 quart     \t= .946  liters\n     \t1 mile      \t= 8/5   kilometers\n     \t1 kilometer \t= .625  miles\n     Also, write a main program that invokes this as a function.\n     Expected results:\n\n     ==> %myexec kilometer 1000\n        625 MILES\n\n    61. After Chapter 5. Looping, DO END PROB061\n    Write an external subroutine to compute the square root of a\n    number passed to it. Name it SQRT.  It will accept one ARG:\n    the number.  Validate the number.  If negative, or not\n    numeric, display a message and return a zero.  Make your\n    guess one-half of the number.\n\n     Repeat this loop 50 times.\n       Make new guess = (guess + (number / guess)) / 2\n       Make guess = new guess\n     End-repeat\n     Return the new guess to the caller\n\n    62. After Chapter 17 Compound variables. PROB062\n    Write an exec with a loop that sets NUMBER.1 through\n    NUMBER.10 to the numbers 101 through 110; then loop through\n    the array, displaying the contents of NUMBER.1 through\n    NUMBER.11 (yes, NUMBER.11 is what I said) to see what\n    happens.\n\n    63. After Chapter 17 Compound variables. Outtrap. Loop. PROB063\n    Write a program that captures the display from TSO commands\n    in an array and then displays the lines of output one at a\n    time.\n\n    Display \"Please enter a command.\"\n    Accept the command into a variable.\n    Turn on OUTTRAP using the array Display_line.\n    Execute the command.  Turn off OUTTRAP.\n    Display the message: \"About to display command's output.\"\n     Loop through the array, displaying each line of the command's output.\n\n    64. Chapter 18. Execio. PROB064\n    Choose a file that you currently have under your userid.\n    Read it into an array.  Display every other record, starting\n    with record 1.\n\n    65. Chapter 18. Execio. PROB065\n    Read in a file you currently have under your userid into an\n    array, and write it out to another file.  Get both file names\n    from the terminal by asking.  To allocate the new file, use\n    an allocate command with LIKE.\n\n    66. Chapter 18. Execio. PROB066\n    Read any file of yours into an array.  Count each record, and\n    keep track of the length of the longest one.  At the end of\n    the program, display the record count and the length of the\n    longest record.\n\n    67. Chapter 18. Execio. PROB067\n    Modify the command output capture exec (Problem 64) to store\n    the lines of the display in the dataset:\n    TEMP.CAPTURE.DATA\n\n    Use SYSDSN to see if that dataset exists.  If it does, delete\n    it.  Then allocate it (create it) with the following TSO\n    command:\n\n    ALLOC DDN(CAPTURE) DSN(TEMP.CAPTURE.DATA) NEW REUSE\n      SPACE(1 1) TRACKS LRECL(80) BLKSIZE(4000) RECFM(F B)\n    (Normally typed in on one line, not two.)\n\n    OUTTRAP loads an array.  Use that array to write out the\n    lines of the command display.  The WRITE command should close\n    the file at the same time.\n\n    68. Chapter 19. PROB069\n    Create a quick calculator exec.  Use INTERPRET to execute an\n    expression that is typed in, then display the result and name\n    it CALC.  It will be used this way:\n\n    ==> %CALC 1 + 1\n\n    It will display \"2\"\n\n\n    Extra practice problem. Loop. Pull. Numeric datatype function. PROB069\n     Improve on your compound interest program written previously\n     (problem 46)   These are the added requirements\n\n     Put the terminal dialogue, calculations, and display into a\n     loop that will repeat until you type in \"NO.\"  After getting\n     the amounts from the terminal, verify the following:\n\n     If principal is blank, end the loop.\n\n     If percent blank, or years blank, or years over 100, or\n     principal not numeric, or percent not numeric, or years not\n     numeric, then start the loop over again.\n\n\n    *****************************Suggested answers for\n    workshops.**********************************************\n\n    *****************************Suggested answers for\n    workshops.**********************************************\n\n    *****************************Suggested answers for\n    workshops.**********************************************\n\n    *****************************Suggested answers for\n    workshops.**********************************************\n\n\n    Suggested answers for workshops:\n\n    1.\n    /* REXX PROB001*/\n    \tSay 1 + 1\n     \tSay \"Today is\" Date()\n     \tName = \"Sue\"\n     \tSay \"Hello, \" Name\n    2.\n    /* REXX PROB002*/\n    Say \"hello\"\n    Say 1 + 1\n    Say length(\"hello\")\n    num = 5\n\n    say num + 5\n\n    3.\n    Quotes around a valid number don\u00c6t stop REXX from doing math.\n    Quotes around a variable prevent REXX from seeing the\n    variable\u00c6s contents.\n\n    4.\n    An undefined variable (or one that was DROPped) can\u00c6t be used\n    in math.\n\n    5.\n    /* REXX PROB005*/\n    greeting = \"Good morning\"\n    name = \"Joe\"\n    say greeting name\n    say greeting || name\n    /*or*/\n    say greeting\"\"name\n    say greeting \"          \"name\n\n    6.\n    It uses the TSO command SEND to send a message to another TSO user.\n    The variables message and userid must be out of quotes.\n\n    7.\n    /* REXX PROB007*/\n    \"LISTDS 'userid.REXX.EXEC' MEMBERS\"\n\n    8.\n    /* REXX PROB008*/\n    members = \"\"\n    \"LISTDS 'userid.REXX.EXEC' \" MEMBERS\n\n    9.\n    This program displays THE ANSWER IS 10\n\n     10.\n    /* REXX PROB010*/\n    /* This is a sample exec for REXX class */\n    \"TIME\"\n    \"SEND 'SAMPLE EXEC ' USER(*)\"\n\n    11.\n    Displays GREETING\n\n    12.\n    Displays HELLO\n\n    13.\n    Displays HAPPY HALLOWEEN\n             GREETING\n\n    14.\n    Displays 234\n\n    15.\n    /* REXX PROB015*/\n    say \"3 + 1 is 4\"\n    say \"'3 + 1 is 4'\"\n    say \"O'brien\"\n\n    16.\n    /* REXX PROB016*/\n    \"LISTCAT ENTRY('SYS1.PROCLIB')\"\n\n    17.\n    Displays MESSAGE\n\n    18.\n    /* REXX PROB018*/\n    v1 = 10\n    v2 = 20\n    say v1 + v2\n\n    19.\n    /* REXX PROB019*/\n    userid = \"TSOU02\" /*for example*/\n    \"LISTCAT LEVEL(\"userid\")\"\n\n\n    20.\n    They will be found equal, because a number with more than 9\n    digits is rounded.\n\n    21.\n    Displays 0\n    0 means the comparison is false.\n\n    22.\n    displays 0\n    the comparison of \"2 + 2\" and \"2\" is false.\n\n    23 \u00fb 27.\n    Just do it.\n\n    28.\n    /* REXX PROB028*/\n    previous = \"\"\n    do 10\n      say \"please enter a number (not same as previous)\"\n      pull number\n      if number = previous then say \"that is same as previous\"\n      previous = number\n    End\n\n    29.\n    /* REXX PROB029*/\n    secret = 13\n    do 10\n      say \"PLEASE ENTER YOUR GUESS, FROM 1 TO 20\"\n      pull number\n      if number = secret then do\n         say \"RIGHT\"\n         leave\n         end\n      else do\n         say \"WRONG\"\n         end\n    end\n\n\n    30.\n    /* REXX PROB030*/\n    do 10\n      say \"PLEASE ENTER A DATASET NAME\"\n      pull dsn\n      /* Standard TSO naming conventions:\n         if name is fully qualified,\n         specify with apostrophes:\n         'MYUSERID.MY.DATA'\n         if userid omitted, and it's yours,\n         do not include apostrophes:\n          MY.DATA\n       */\n      \"LISTDS\" dsn\n      if rc = 0 then do\n         leave\n         end\n      else do\n         say \"not found\"\n         end\n    end\n\n    31.\n    /* REXX PROB031*/\n    Say \"Please enter name\"\n    Pull name\n    select\n    \twhen name = \"JOHN\" then say \"PAUL JONES\"\n    \twhen name = \"GEORGE\" then say \"Washington\"\n    \twhen name = \"NELSON\" then say \"Mandela\"\n    \twhen name = \"JULIUS\" then say \"Caesar\"\n    \twhen name = \"\" then say \"Please try again\"\n    otherwise\n    say \"bad reply .> Please enter a name\"\n    end\n\n    32.\n    /* REXX PROB032*/\n    Say \"Please reply exactly Yes! \"\n    parse pull reply\n    if reply = \"Yes\" then say \"correct answer\"\n    else say \"wrong answer\"\n\n    33.\n    /* REXX PROB033*/\n    VAR1 = \"ABCDEFGHIJKLMNOP\"\n    Parse var VAR1  3 var2  5  6  var3  10  9  var4  15\n    say var2\n    say var3\n    say var4\n\n    34.\n    Displays SUE KAREN MARYELLEN\n\n    35.\n    /* REXX PROB035*/\n    arg dataset\n      /* Standard TSO naming conventions:\n         if name is fully qualified,\n         specify with apostrophes:\n         'MYUSERID.MY.DATA'\n         if userid omitted, and it's yours,\n         do not include apostrophes:\n          MY.DATA\n       */\n    \"LISTCAT ENTRY(\"dataset\")\"\n\n    36.\n    Syntax error.\n\n    37.\n    /* REXX PROB037*/\n    arg v1 v2 v3 v4\n    if v4 <> \"\" then say \"I said enter only three items please!\"\n    say v3 v2 v1\n\n    38.\n    /* REXX PROB038*/\n    Say \"Please type in three words (only)\"\n    Pull word1 word2 word3 .\n    Say  word1 word2 word3\n    /* the period throws away words after the third*/\n\n    39.\n    /* REXX PROB039*/\n    Say \"Please type in three words (only)\"\n    Pull word1 word2 word3 .\n    /* the period throws away words after the third*/\n    Say word3 word2 word1\n\n    40.\n    /* REXX PROB040*/\n    arg dataset\n      /* Standard TSO naming conventions:\n         if name is fully qualified,\n         specify with apostrophes:\n         'MYUSERID.MY.DATA'\n         if userid omitted, and it's yours,\n         do not include apostrophes:\n          MY.DATA\n       */\n    if dataset = \"JUNK.DATA\" then \"DELETE JUNK.DATA\"\n    else do\n       Say \"ARE YOU SURE? Y/N\"\n       pull reply\n       if reply = \"Y\" then do\n          \"DELETE \" dataset\n          say \"DELETED\"\n          end\n        else do\n          say \"NOT DELETED\"\n          end\n        end\n\n    41.\n    /* REXX PROB041*/\n    Say \"Please type in old salary\"\n    Pull old\n    Say \"Please type in new salary\"\n    Pull new\n    increase =  100 * ((new - old) / old)\n    Say \"the % of increase was\" increase\n\n    42.\n    /* REXX PROB042*/\n    say \"PLEASE ENTER DATASET NAME\"\n    pull dsn\n      /* Standard TSO naming conventions:\n         if name is fully qualified,\n         specify with apostrophes:\n         'MYUSERID.MY.DATA'\n         if userid omitted, and it's yours,\n         do not include apostrophes:\n          MY.DATA\n       */\n\n    signal on error\n    \"LISTDS\" dsn\n    Exit\n\n    error:\n    say \"CANNOT EXECUTE TSO COMMAND\"\n    say \"TSO ERROR CODE IS \" rc\n    say \"LINE IN ERROR IS \" sourceline(sigl)\n    say \"PLEASE REENTER\"\n    pull dsn\n    \"LISTDS\" dsn\n    exit\n\n    43.\n    /* REXX PROB043*/\n    say \"Please type in a number\"\n    pull number1\n    say \"Please type in another number\"\n    pull number2\n\n    signal on syntax\n    say number1 * number2\n    exit\n\n    syntax:\n    say \"a syntax error has occured. \"\n    exit\n\n    44.\n    displays\n    9\n    7\n    7\n\n    45.\n    /* REXX PROB044*/\n    Say \"PLEASE ENTER RECORD LENGTH\"\n    pull lrecl\n    say \"PLEASE ENTER BLOCK SIZE\"\n    pull blksize\n\n    if (blksize // lrecl) = 0 then say \"OK\"\n    else say \"BLOCK SIZE IS NOT A MULTIPLE OF RECORD LENGTH\"\n\n    46.\n    /* REXX PROB046*/\n    say \"Please enter principal\"\n    pull principal\n    say \"please enter yearly interest rate in percent\"\n    pull percent\n    say \"how many years is money kept in account?\"\n    pull years\n    say \"please enter how many times per year interest is compounded\"\n    say \"1 = yearly; 12 = monthly; 52 = weekly; 365 = daily\"\n    pull frequency\n\n    yearly_rate = percent / 100\n    r = yearly_rate / frequency\n\n    n = years * frequency\n\n    final = principal * ((1 + r)**n)\n    say final\n\n\n    47.\n    Just do it.\n\n    48.\n    /* REXX PROB048*/\n    arg number1 number2\n    if datatype(number1) = \"CHAR\" then do\n       say number1 \"is not a valid number\"\n       exit\n       end\n\n    if datatype(number2) = \"CHAR\" then do\n       say number2 \"is not a valid number\"\n       exit\n       end\n\n    answer = number1 - number2\n    answer = abs(answer)\n    say answer\n\n    49.\n    /* REXX PROB049*/\n    if sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n       delete \"WORKSHOP.TEMP\"\n       end\n    else do\n       \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n      end\n\n    50.\n    /* REXX PROB050*/\n    if sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n       call outtrap \"line.\", \"*\" /* or x = outtrap(\"line.\",\"*\") */\n       delete \"WORKSHOP.TEMP\"\n       end\n    else do\n       \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n       end\n\n    51.\n    /* REXX PROB051*/\n    if sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n       call msg \"OFF\"\n       delete \"WORKSHOP.TEMP\"\n       end\n    else do\n       \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n       end\n\n    52.\n    /* REXX PROB052*/\n    say \"Please type in GREAT\"\n    pull word\n    say translate(word,\"BUENO\",\"GREAT\")\n       /* or */\n    say translate(word,\"ONEUB\",\"TAERG\")\n\n    53.\n    /* REXX PROB053*/\n    arg hex1 sign hex2\n    dec1 = x2d(hex1)\n    dec2 = x2d(hex2)\n\n    if sign = \"+\" then do\n       dec_answer = dec1 + dec2\n       end\n\n    if sign = \"-\" then do\n       dec_answer = dec1 - dec2\n       end\n\n    say d2x(dec_answer)\n\n    54.\n    /* REXX PROB054*/\n    /*REXX Uppr EXEC converts upper to lower*/\n    parse arg instring\n    upper_alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lower_alpha = \"abcdefghijklmnopqrstuvwxyz\"\n    outstring = translate(instring,upper_alpha,lower_alpha)\n    say outstring\n\n    55.\n    Just do it.\n\n    56.\n    /* REXX PROB056*/\n    Say concat_nate(\"cat\" \"dog\")\n    exit\n\n    concat_nate:\n    arg var1 var2\n    return var1 || var2\n    /* or return var1\"\"var2 */\n\n    57.\n    /* REXX PROB057*/\n    call concat_nate \"cat\" \"dog\"\n    say result\n    exit\n\n    concat_nate:\n    arg var1 var2\n    return var1 || var2\n    /* or return var1\"\"var2 */\n\n    58.\n    /* REXX PROB058*/\n    /*REXX main program to execute PERCENTI*/\n    say percenti(100000, 150000)\n\n\n    /*REXX external function PERCENTI */\n    /* this must be a member, named PERCENTI\n    in your REXX library, or in another\n    library allocated to SYSEXEC\n    */\n    arg old, new\n    if datatype(old) = \"CHAR\" then do\n       say \"invalid number\" old\n       return 0\n       end\n\n    if datatype(new) = \"CHAR\" then do\n       say \"invalid number\" new\n       return 0\n       end\n\n    increase =  100 * ((new - old) / old)\n    return increase\n\n    59.\n    /* REXX PROB059*/\n    /*REXX main program*/\n    call concatn \"cat\" \"dog\"\n    say result\n    exit\n\n\n    /*REXX CONCATN external function*/\n    /* this must be a member, named CONCATN\n    in your REXX library, or in another\n    library allocated to SYSEXEC\n    */\n    arg var1 var2\n    return var1 || var2\n    /* or return var1\"\"var2 */\n\n    60.\n    /* REXX PROB060*/\n    /*REXX main program*/\n    say METRIC(\"KILOMETER\" 1000)\n\n    /*REXX external function METRIC*/\n    /* this must be a member, named METRIC\n    in your REXX library, or in another\n    library allocated to SYSEXEC\n    */\n    arg unit quantity\n\n    if unit = \"LITER\" then do\n       return quantity * 1.057 \"quarts\"\n       end\n\n    if unit = \"QUART\" then do\n       return quantity * .946 \"liters\"\n       end\n\n    if unit = \"MILE\" then do\n       return quantity * (8/5) \"kilometers\"\n       end\n\n    if unit = \"KILOMETER\" then do\n       return quantity * .625 \"miles\"\n       end\n\n     61.\n    /* REXX PROB061*/\n    /*REXX main program*/\n    call SQRT 25\n    say result\n    /* ------------------------------------------*/\n    /*REXX SQRT external function */\n    /* this must be a member, named SQRT\n    in your REXX library, or in another\n    library allocated to SYSEXEC\n    */\n    arg number\n    if number < 0 then do\n       say \"number must be positive\"\n       return 0\n       end\n\n    if datatype(number) = \"CHAR\" then do\n       say \"number must be numeric\"\n       return 0\n       end\n\n    guess = number / 2\n    do 50\n      new_guess = (guess + (number / guess)) / 2\n      guess = new_guess\n    end\n    return new_guess\n\n\n    62.\n    /* REXX PROB062*/\n    do i = 1 to 10\n      number.i = i + 100\n    end i\n\n    do i = 1 to 11\n      say number.i\n    end i\n\n    63.\n    /* REXX PROB063*/\n    say \"please enter a command\"\n    pull command\n\n    call outtrap \"Display_line.\", \"*\"\n    command\n    call outtrap \"OFF\"\n\n    say \"About to display command's output\"\n    do i = 1 to Display_line.0\n      say Display_line.i\n    end i\n\n    64.\n    /* REXX PROB064*/\n    sample_file = \"my.sample.file\"\n    \"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n    \"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n    \"FREE DDN(INFILE)\"\n    Do i = 1 to infile.0 by 2\n      say infile.i\n    end i\n\n    65.\n    /* REXX PROB065*/\n    sample_file   = \"my.sample.file\"\n    sample_output = \"my.sample.output\"\n\n    \"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n    \"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n    \"FREE DDN(INFILE)\"\n\n    \"ALLOC DDN(OUTFILE) NEW REUSE DSN(\"sample_output\")\",\n      \"LIKE(\"sample_file\")\"\n\n    \"EXECIO \" infile.0 \"DISKW OUTFILE (STEM INFILE. FINIS)\"\n    \"FREE DDN(OUTFILE)\"\n\n    66.\n    /* REXX PROB066*/\n    sample_file = \"my.sample.file\"\n    \"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n    \"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n    \"FREE DDN(INFILE)\"\n\n    record_count = 0\n    max_length = 0\n\n    Do i = 1 to infile.0\n      record_count = record_count + 1\n      say infile.i\n\n      if length(infile.i) > max_length\n      then max_length = length(infile.i)\n\n    end i\n\n    Say \"record count was \" record_count\n    /* or infile.0 instead of record_count */\n    Say \"length of longest record was \" max_length\n\n    67.\n    /* REXX PROB067*/\n    say \"please enter a command\"\n    pull command\n\n    call outtrap \"Display_line.\", \"*\"\n    command\n    call outtrap \"OFF\"\n\n    if sysdsn(\"temp.capture.data\") = \"OK\"\n    then \"DELETE TEMP.CAPTURE.DATA\"\n\n    \"ALLOC DDN(CAPTURE) DSN(TEMP.CAPTURE.DATA) NEW REUSE\",\n      \"SPACE(1 1) TRACKS LRECL(80) BLKSIZE(4000) RECFM(F B)\"\n\n    \"EXECIO \" Display_line.0 \"DISKW CAPTURE (STEM Display_line. FINIS)\"\n    \"FREE DDN(CAPTURE)\"\n\n    68.\n    /* REXX PROB068*/\n    arg expression\n    interpret \"say\" expression\n\n    /* REXX PROB069*/\n    /*Extra practice problem.*/\n    do until reply = \"NO\"\n      say \"Please enter principal\"\n      pull principal\n      if principal = \"\" then leave\n      if datatype(principal) = \"CHAR\" then iterate\n\n      say \"please enter yearly interest rate in percent\"\n      pull percent\n      if percent = \"\" then iterate\n      if datatype(principal) = \"CHAR\" then iterate\n\n      say \"how many years is money kept in account?\"\n      pull years\n      if years = \"\" then iterate\n      if years > 100 then iterate\n      if datatype(principal) = \"CHAR\" then iterate\n\n      say \"please enter how many times per year interest is compounded\"\n      say \"1 = yearly; 12 = monthly; 52 = weekly; 365 = daily\"\n      pull frequency\n\n      yearly_rate = percent / 100\n      r = yearly_rate / frequency\n\n      n = years * frequency\n\n      final = principal * ((1 + r)**n)\n      say final\n\n      say \"do another calculation? YES/NO\"\n      pull reply\n    end\n\n*\n\n\u00ddBooks Computer\u00a8\n\n| /Home/ <http://theamericanprogrammer.com/> | /Books for Computer\nProfessionals/ <http://theamericanprogrammer.com/books/index.shtml>\n| /Privacy/ <http://theamericanprogrammer.com/privacy.shtml> | /Terms /\n<http://theamericanprogrammer.com/terms.shtml> |\n| /Site Map and Site Search/\n<http://theamericanprogrammer.com/sitemap.shtml> | /Programming Manuals\nand Tutorials/ <http://theamericanprogrammer.com/manuals/index.shtml>\n| /The REXX Files/\n<http://theamericanprogrammer.com/programming/rexxfiles.shtml>\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALL": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11&\\x02\\x9c\\x02\\x9c\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:26:37", "lines": 668, "newlines": 668, "modlines": 0, "user": "GABRIEL"}, "text": "1.\n/* REXX PROB001*/\n Say 1 + 1\n  Say \"Today is\" Date()\n  Name = \"Sue\"\n  Say \"Hello, \" Name\n2.\n/* REXX PROB002*/\nSay \"hello\"\nSay 1 + 1\nSay length(\"hello\")\nnum = 5\n\nsay num + 5\n\n3.\nQuotes around a valid number don t stop REXX from doing math.\nQuotes around a variable prevent REXX from seeing the variable s contents.\n\n4.\nAn undefined variable (or one that was DROPped) can t be used in math.\n\n5.\n/* REXX PROB005*/\ngreeting = \"Good morning\"\nname = \"Joe\"\nsay greeting name\nsay greeting || name\n/*or*/\nsay greeting\"\"name\nsay greeting \"          \"name\n\n6.\nIt uses the TSO command SEND to send a message to another TSO user.\nThe variables message and userid must be out of quotes.\n\n7.\n/* REXX PROB007*/\n\"LISTDS 'userid.REXX.EXEC' MEMBERS\"\n\n8.\n/* REXX PROB008*/\nmembers = \"\"\n\"LISTDS 'userid.REXX.EXEC' \" MEMBERS\n\n9.\nThis program displays THE ANSWER IS 10\n\n 10.\n/* REXX PROB010*/\n/* This is a sample exec for REXX class */\n\"TIME\"\n\"SEND 'SAMPLE EXEC ' USER(*)\"\n\n11.\nDisplays GREETING\n\n12.\nDisplays HELLO\n\n13.\nDisplays HAPPY HALLOWEEN\n         GREETING\n\n14.\nDisplays 234\n\n15.\n/* REXX PROB015*/\nsay \"3 + 1 is 4\"\nsay \"'3 + 1 is 4'\"\nsay \"O'brien\"\n\n16.\n/* REXX PROB016*/\n\"LISTCAT ENTRY('SYS1.PROCLIB')\"\n\n17.\nDisplays MESSAGE\n\n18.\n/* REXX PROB018*/\nv1 = 10\nv2 = 20\nsay v1 + v2\n\n19.\n/* REXX PROB019*/\nuserid = \"TSOU02\" /*for example*/\n\"LISTCAT LEVEL(\"userid\")\"\n\n\n 20.\nThey will be found equal, because a number with more than 9 digits is rounded.\n\n21.\nDisplays 0\n0 means the comparison is false.\n\n22.\ndisplays 0\nthe comparison of \"2 + 2\" and \"2\" is false.\n\n23 - 27.\nJust do it.\n\n28.\n/* REXX PROB028*/\nprevious = \"\"\ndo 10\n  say \"please enter a number (not same as previous)\"\n  pull number\n  if number = previous then say \"that is same as previous\"\n  previous = number\nEnd\n\n29.\n/* REXX PROB029*/\nsecret = 13\ndo 10\n  say \"PLEASE ENTER YOUR GUESS, FROM 1 TO 20\"\n  pull number\n  if number = secret then do\n     say \"RIGHT\"\n     leave\n     end\n  else do\n     say \"WRONG\"\n     end\nend\n\n\n 30.\n/* REXX PROB030*/\ndo 10\n  say \"PLEASE ENTER A DATASET NAME\"\n  pull dsn\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\n  \"LISTDS\" dsn\n  if rc = 0 then do\n     leave\n     end\n  else do\n     say \"not found\"\n     end\nend\n\n-------------\n31.\n/* REXX PROB031*/\nSay \"Please enter name\"\nPull name\nselect\n when name = \"JOHN\" then say \"PAUL JONES\"\n when name = \"GEORGE\" then say \"Washington\"\n when name = \"NELSON\" then say \"Mandela\"\n when name = \"JULIUS\" then say \"Caesar\"\n when name = \"\" then say \"Please try again\"\notherwise\nsay \"bad reply .> Please enter a name\"\nend\n\n32.\n/* REXX PROB032*/\nSay \"Please reply Yes! \"\nparse pull reply\nif reply = \"Yes\" then say \"correct answer\"\nelse say \"wrong answer\"\n\n33.\n/* REXX PROB033*/\nVAR1 = \"ABCDEFGHIJKLMNOP\"\nParse var VAR1  3 var2  5  6  var3  10  9  var4  15\nsay var2\nsay var3\nsay var4\n\n 34.\nDisplays SUE KAREN MARYELLEN\n\n35.\n/* REXX PROB035*/\narg dataset\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\n\"LISTCAT ENTRY(\"dataset\")\"\n\n36.\nSyntax error.\n\n37.\n/* REXX PROB037*/\narg v1 v2 v3 v4\nif v4 <> \"\" then say \"I said enter only three items please!\"\nsay v3 v2 v1\n\n38.\n/* REXX PROB038*/\nSay \"Please type in three words (only)\"\nPull word1 word2 word3 .\n/* the period throws away words after the third*/\n\n39.\n/* REXX PROB039*/\nSay \"Please type in three words (only)\"\nPull word1 word2 word3 .\n/* the period throws away words after the third*/\nSay word3 word2 word1\n\n40.\n/* REXX PROB040*/\narg dataset\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\nif dataset = \"JUNK.DATA\" then \"DELETE JUNK.DATA\"\nelse do\n   Say \"ARE YOU SURE? Y/N\"\n   pull reply\n   if reply = \"Y\" then do\n      \"DELETE \" dataset\n      say \"DELETED\"\n      end\n    else do\n      say \"NOT DELETED\"\n      end\n    end\n\n41.\n/* REXX PROB041*/\nSay \"Please type in old salary\"\nPull old\nSay \"Please type in new salary\"\nPull new\nincrease =  100 * ((new - old) / old)\nSay \"the % of increase was\" increase\n\n 42.\n/* REXX PROB042*/\nsay \"PLEASE ENTER DATASET NAME\"\npull dsn\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\n\nsignal on error\n\"LISTDS\" dsn\nExit\n\nerror:\nsay \"CANNOT EXECUTE TSO COMMAND\"\nsay \"TSO ERROR CODE IS \" rc\nsay \"LINE IN ERROR IS \" sourceline(sigl)\nsay \"PLEASE REENTER\"\npull dsn\n\"LISTDS\" dsn\nexit\n\n43.\n/* REXX PROB043*/\nsay \"Please type in a number\"\npull number1\nsay \"Please type in another number\"\npull number2\n\nsignal on syntax\nsay number1 * number2\nexit\n\nsyntax:\nsay \"a syntax error has occured. \"\nexit\n\n44.\ndisplays\n9\n7\n7\n\n45.\n/* REXX PROB044*/\nSay \"PLEASE ENTER RECORD LENGTH\"\npull lrecl\nsay \"PLEASE ENTER BLOCK SIZE\"\npull blksize\n\nif (blksize // lrecl) = 0 then say \"OK\"\nelse say \"BLOCK SIZE IS NOT A MULTIPLE OF RECORD LENGTH\"\n\n 46.\n/* REXX PROB046*/\nsay \"Please enter principal\"\npull principal\nsay \"please enter yearly interest rate in percent\"\npull percent\nsay \"how many years is money kept in account?\"\npull years\nsay \"please enter how many times per year interest is compounded\"\nsay \"1 = yearly; 12 = monthly; 52 = weekly; 365 = daily\"\npull frequency\n\nyearly_rate = percent / 100\nr = yearly_rate / frequency\n\nn = years * frequency\n\nfinal = principal * ((1 + r)**n)\nsay final\n\n\n47.\nJust do it.\n\n48.\n/* REXX PROB048*/\narg number1 number2\nif datatype(number1) = \"CHAR\" then do\n   say number1 \"is not a valid number\"\n   exit\n   end\n\nif datatype(number2) = \"CHAR\" then do\n   say number2 \"is not a valid number\"\n   exit\n   end\n\nanswer = number1 - number2\nanswer = abs(answer)\nsay answer\n\n49.\n/* REXX PROB049*/\nif sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n   delete \"WORKSHOP.TEMP\"\n   end\nelse do\n   \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n  end\n\n 50.\n/* REXX PROB050*/\nif sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n   call outtrap \"line.\", \"*\" /* or x = outtrap(\"line.\",\"*\") */\n   delete \"WORKSHOP.TEMP\"\n   end\nelse do\n   \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n   end\n\n51.\n/* REXX PROB051*/\nif sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n   call msg \"OFF\"\n   delete \"WORKSHOP.TEMP\"\n   end\nelse do\n   \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n   end\n\n52.\n/* REXX PROB052*/\nsay \"Please type in GREAT\"\npull word\nsay translate(word,\"BUENO\",\"GREAT\")\n   /* or */\nsay translate(word,\"ONEUB\",\"TAERG\")\n\n53.\n/* REXX PROB053*/\narg hex1 sign hex2\ndec1 = x2d(hex1)\ndec2 = x2d(hex2)\n\nif sign = \"+\" then do\n   dec_answer = dec1 + dec2\n   end\n\nif sign = \"-\" then do\n   dec_answer = dec1 - dec2\n   end\n\nsay d2x(dec_answer)\n\n54.\n/* REXX PROB054*/\n/*REXX Uppr EXEC converts upper to lower*/\nparse arg instring\nupper_alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nlower_alpha = \"abcdefghijklmnopqrstuvwxyz\"\noutstring = translate(instring,upper_alpha,lower_alpha)\nsay outstring\n\n 55.\nJust do it.\n\n56.\n/* REXX PROB056*/\nSay concat_nate(\"cat\" \"dog\")\nexit\n\nconcat_nate:\narg var1 var2\nreturn var1 || var2\n/* or return var1\"\"var2 */\n\n57.\n/* REXX PROB057*/\ncall concat_nate \"cat\" \"dog\"\nsay result\nexit\n\nconcat_nate:\narg var1 var2\nreturn var1 || var2\n/* or return var1\"\"var2 */\n\n58.\n/* REXX PROB058*/\n/*REXX main program to execute PERCENTI*/\nsay percenti(100000, 150000)\n\n\n/*REXX external function PERCENTI */\n/* this must be a member, named PERCENTI\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg old, new\nif datatype(old) = \"CHAR\" then do\n   say \"invalid number\" old\n   return 0\n   end\n\nif datatype(new) = \"CHAR\" then do\n   say \"invalid number\" new\n   return 0\n   end\n\nincrease =  100 * ((new - old) / old)\nreturn increase\n\n 59.\n/* REXX PROB059*/\n/*REXX main program*/\ncall concatn \"cat\" \"dog\"\nsay result\nexit\n\n\n/*REXX CONCATN external function*/\n/* this must be a member, named CONCATN\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg var1 var2\nreturn var1 || var2\n/* or return var1\"\"var2 */\n\n60.\n/* REXX PROB060*/\n/*REXX main program*/\nsay METRIC(\"KILOMETER\" 1000)\n\n/*REXX external function METRIC*/\n/* this must be a member, named METRIC\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg unit quantity\n\nif unit = \"LITER\" then do\n   return quantity * 1.057 \"quarts\"\n   end\n\nif unit = \"QUART\" then do\n   return quantity * .946 \"liters\"\n   end\n\nif unit = \"MILE\" then do\n   return quantity * (8/5) \"kilometers\"\n   end\n\nif unit = \"KILOMETER\" then do\n   return quantity * .625 \"miles\"\n   end\n\n 61.\n/* REXX PROB061*/\n/*REXX main program*/\ncall SQRT 25\nsay result\n\n/*REXX SQRT external function or subroutine*/\n/* this must be a member, named SQRT\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg number\nif number < 0 then do\n   say \"number must be positive\"\n   return 0\n   end\n\nif datatype(number) = \"CHAR\" then do\n   say \"number must be numeric\"\n   return 0\n   end\n\nguess = number / 2\ndo 50\n  new_guess = (guess + (number / guess)) / 2\n  guess = new_guess\nend\nreturn new_guess\n\n\n62.\n/* REXX PROB062*/\ndo i = 1 to 10\n  number.i = i + 100\nend i\n\ndo i = 1 to 11\n  say number.i\nend i\n\n63.\n/* REXX PROB063*/\nsay \"please enter a command\"\npull command\n\ncall outtrap \"Display_line.\", \"*\"\ncommand\ncall outtrap \"OFF\"\n\nsay \"About to display command's output\"\ndo i = 1 to Display_line.0\n  say Display_line.i\nend i\n\n 64.\n/* REXX PROB064*/\nsample_file = \"my.sample.file\"\n\"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n\"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(INFILE)\"\nDo i = 1 to infile.0 by 2\n  say infile.i\nend i\n\n65.\n/* REXX PROB065*/\nsample_file   = \"my.sample.file\"\nsample_output = \"my.sample.output\"\n\n\"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n\"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(INFILE)\"\n\n\"ALLOC DDN(OUTFILE) NEW REUSE DSN(\"sample_output\")\",\n  \"LIKE(\"sample_file\")\"\n\n\"EXECIO \" infile.0 \"DISKW OUTFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(OUTFILE)\"\n\n66.\n/* REXX PROB066*/\nsample_file = \"my.sample.file\"\n\"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n\"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(INFILE)\"\n\nrecord_count = 0\nmax_length = 0\n\nDo i = 1 to infile.0\n  record_count = record_count + 1\n  say infile.i\n\n  if length(infile.i) > max_length\n  then max_length = length(infile.i)\n\nend i\n\nSay \"record count was \" record_count\n/* or infile.0 instead of record_count */\nSay \"length of longest record was \" max_length\n\n 67.\n/* REXX PROB067*/\nsay \"please enter a command\"\npull command\n\ncall outtrap \"Display_line.\", \"*\"\ncommand\ncall outtrap \"OFF\"\n\nif sysdsn(\"temp.capture.data\") = \"OK\"\nthen \"DELETE TEMP.CAPTURE.DATA\"\n\n\"ALLOC DDN(CAPTURE) DSN(TEMP.CAPTURE.DATA) NEW REUSE\",\n  \"SPACE(1 1) TRACKS LRECL(80) BLKSIZE(4000) RECFM(F B)\"\n\n\"EXECIO \" Display_line.0 \"DISKW CAPTURE (STEM Display_line. FINIS)\"\n\"FREE DDN(CAPTURE)\"\n\n68.\n/* REXX PROB068*/\narg expression\ninterpret \"say\" expression\n\n/* REXX PROB069*/\n/*Extra practice problem.*/\ndo until reply = \"NO\"\n  say \"Please enter principal\"\n  pull principal\n  if principal = \"\" then leave\n  if datatype(principal) = \"CHAR\" then iterate\n\n  say \"please enter yearly interest rate in percent\"\n  pull percent\n  if percent = \"\" then iterate\n  if datatype(principal) = \"CHAR\" then iterate\n\n  say \"how many years is money kept in account?\"\n  pull years\n  if years = \"\" then iterate\n  if years > 100 then iterate\n  if datatype(principal) = \"CHAR\" then iterate\n\n  say \"please enter how many times per year interest is compounded\"\n  say \"1 = yearly; 12 = monthly; 52 = weekly; 365 = daily\"\n  pull frequency\n\n  yearly_rate = percent / 100\n  r = yearly_rate / frequency\n\n  n = years * frequency\n\n  final = principal * ((1 + r)**n)\n  say final\n\n  say \"do another calculation? YES/NO\"\n  pull reply\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALLEXECS": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x19\\x01\\xb0\\x01\\xb0\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:19:12", "lines": 432, "newlines": 432, "modlines": 0, "user": "EXEC"}, "text": "**** STQUICK REXX Program. ****\n\n/*REXX STQUICK\n COUNT AND STATUS OF JOBS SUBMITTED BY YOU\n*/\nCALL OUTTRAP \"LINE.\",\"*\"\n\"STATUS\"\nCALL OUTTRAP \"OFF\"\n\nEXECUTING_CTR = 0\nWAIT_CTR      = 0\nOUTPUT_CTR    = 0\n\nDO I = 1 TO LINE.0\n   IF POS(\"NO JOBS FOUND\",LINE.I) > 0\n   THEN\n     DO\n       SAY \"YOU HAVE NO JOBS IN THE SYSTEM NOW\"\n       EXIT\n     END\nEND I\n\nDO I = 1 TO LINE.0\n   IF POS(\"EXECUTING\",LINE.I) > 0\n      THEN EXECUTING_CTR =   EXECUTING_CTR + 1\n   IF POS(\"OUTPUT QUEUE\",LINE.I) > 0\n      THEN OUTPUT_CTR =      OUTPUT_CTR    + 1\n   IF POS(\"WAITING FOR\",LINE.I) > 0\n      THEN WAIT_CTR =        WAIT_CTR      + 1\nEND I\n\nSAY \"EXECUTING\"             EXECUTING_CTR\nSAY \"ON OUTPUT QUEUE\"       OUTPUT_CTR\nSAY \"WAITING FOR EXECUTION\" WAIT_CTR\n\n\n**** CANJOB REXX Program. ****\n\n/* REXX NAME: CANJOB\n\n   PURPOSE: DOES A STATUS, THEN ASKS YOU FOR JOB SUFFIX,\n            AND JES JOB NUMBER\n            THEN CANCELS THE JOB WITH A PURGE\n\n   USE: %CANJOB\n        THEN REPLY WITH JOB SUFFIX,\n        I.E. LETTER/NUMBER APPENDED TO YOUR USERID ON JOB NAME\n        AND JES JOB NUMBER, NUMERIC PART ONLY\n\n        FOR EXAMPLE:\n\n         %CANJOB\n         - MESSAGE APPEARS: TSOU01A(JOB01234) EXECUTING\n         A   1234\n*/\n\"STATUS\"\n SAY \"TO CANCEL ONE OF YOUR JOBS,\"\n SAY \"- TYPE IN:\"\n SAY \"- JOB SUFFIX     JES JOB NUMBER \"\n SAY \"- EXAMPLE:     P  1234 \"\n SAY\n PULL SUFFIX NUMBER\n IF SUFFIX = \"\"\n THEN\n    DO\n      SAY \"NEED JOB SUFFIX AND JOB NUMBER, NO COMMAS\"\n      EXIT\n    END\n IF SUFFIX = \"\" THEN EXIT\n IF SUFFIX = \"STOP\"  THEN EXIT\n\nTRACE C\n\n\n\"CANCEL\" USERID() || SUFFIX || \"(JOB\" || NUMBER\"), PURGE\"\n/* ALTERNATIVELY, YOU COULD HAVE DONE IT THIS WAY:\n\"CANCEL\" USERID()\"\"SUFFIX\"(JOB\"NUMBER\"), PURGE\"\n*/\n\n\n**** SUBJCL1 REXX Program. ****\n\n/* REXX SUBJCL1\n   SUBMITTING JCL FOR BATCH PROCESSING.\n   INSERTING VARIABLE VALUES INTO THE JCL\n   USING THE INTERNAL DATA QUEUE\n\n   QUEUE LINES OF JCL, THEN WRITE TO A FILE\n   FROM THE DATA QUEUE.\n   SUBMIT THE FILE, THEN DELETE IT\n*/\n\nTEMP_FILE_NAME = \"'userid.TEMP.SUBMIT.CNTL'\"\nPROGRAM_TO_EXECUTE = \"MYPROG1\"\n\nCALL MSG \"OFF\"\n\"DELETE\" TEMP_FILE_NAME\nCALL MSG \"ON\"\n\nSIGNAL ON ERROR\n\"ALLOC DDN(TEMPFILE) NEW REUSE DSN(\"TEMP_FILE_NAME\")\",\n   \"SPACE(3,1) TRACKS\"\nSIGNAL OFF ERROR\n\n\"NEWSTACK\"\nQUEUE \"//useridA  JOB (0),'TSO USER',\"\nQUEUE \"//         TYPRUN=SCAN,  \"\nQUEUE \"//         MSGLEVEL=1,CLASS=A,NOTIFY=userid\"\nQUEUE \"//STEP1    EXEC PGM=\"PROGRAM_TO_EXECUTE\nQUEUE \"//INFILE   DD DSN=userid.INPUT.FILE,DISP=SHR \"\nQUEUE \"//OUTFILE  DD SYSOUT=A \"\nQUEUE \"//SYSIN    DD * \"\nQUEUE DATE() TIME()\nQUEUE \"/*\"\n\n\n\"EXECIO\" QUEUED() \"DISKW TEMPFILE (FINIS)\"\n\"DELSTACK\"\n\"FREE DDNAME(TEMPFILE)\"\n\"SUBMIT\" TEMP_FILE_NAME\nCALL MSG \"OFF\"\n\"DELETE\" TEMP_FILE_NAME\nCALL MSG \"ON\"\nEXIT\n\nERROR:\nSAY \"UNABLE TO ALLOCATE TEMPORARY FILE\" TEMP_FILE_NAME\nSAY \"TERMINATING\"\nEXIT\n\n\n**** SUBJCL2 REXX Program. ****\n\n/* rexx subjcl2\n   submitting JCL for batch processing.\n   Inserting variable values into the JCL\n   using a compound, or stem variable\n\n   place lines of jcl into the stem variable\n   write the file,\n   submit the file, then delete it\n*/\n\nTemp_file_name = \"'userid.TEMP.SUBMIT.CNTL'\"\nProgram_to_execute = \"MYPROG1\"\n\ncall msg \"off\"\n\"delete\" Temp_file_name\ncall msg \"on\"\n\nsignal on error\n\"alloc ddn(tempfile) new reuse dsn(\"Temp_file_name\")\",\n   \"space(3,1) tracks\"\nsignal off error\n\nline_counter = 0\ncall add_line_to_array,\n     \"//useridA JOB (0),'TSO USER',\"\ncall add_line_to_array,\n     \"//         TYPRUN=SCAN,  \"\ncall add_line_to_array,\n     \"//         MSGLEVEL=1,CLASS=A,NOTIFY=userid\"\ncall add_line_to_array,\n     \"//STEP1    EXEC PGM=\"PROGRAM_TO_EXECUTE\ncall add_line_to_array,\n     \"//INFILE   DD DSN=userid.INPUT.FILE,DISP=SHR \"\ncall add_line_to_array,\n     \"//OUTFILE  DD SYSOUT=A \"\ncall add_line_to_array,\n     \"//SYSIN    DD * \"\ncall add_line_to_array,\n     DATE() TIME()\ncall add_line_to_array,\n     \"/*\"\n\n/* display contents of stem variable */\ndo i = 1 to line.0\n   say line.i\nend i\n\n\"execio\" line.0   \"diskw tempfile (stem line. finis)\"\n\n\"free ddname(tempfile)\"\n\n\"submit\" Temp_file_name\n\ncall msg \"off\"\n\"delete\" Temp_file_name\ncall msg \"on\"\nexit\n\nerror:\nsay \"Unable to allocate temporary file\" Temp_file_name\nsay \"terminating\"\nexit\n\nadd_line_to_array:\narg line_to_add\nline_counter      = line_counter + 1\nline.0            = line_counter\nline.line_counter = line_to_add\nreturn\n\n\n**** SUBJCL3 REXX Program. ****\n\n/* REXX SUBJCL3\n   SUBMITTING JCL FOR BATCH PROCESSING.\n   INSERTING VARIABLE VALUES INTO THE JCL.\n   USING THE TSO LINE MODE EDITOR TO CREATE\n   A TEMPORARY FILE, SUBMIT IT,\n   AND EXIT WITHOUT SAVING IT\n*/\n/* TRACE C  */\nTEMP_FILE_NAME = \"'userid.TEMP.SUBMIT.CNTL'\"\nPROGRAM_TO_EXECUTE = \"MYPROG1\"\nJCL_DELIMITER = \"/*\"\n\n/* DELETE, IF IT EXISTS. IT'S A TEMP FILE.\n\n   YOU SHOULD HAVE NOTHING GOOD IN A TEMP FILE. GOODBYE.\n*/\nCALL MSG \"OFF\"\n\"DELETE\" TEMP_FILE_NAME\nCALL MSG \"ON\"\n\n\"ALLOCATE DSN(\"TEMP_FILE_NAME\") NEW REUSE TRACKS\",\n   \"SPACE(3,1) LRECL(80) RECFM(F,B) BLKSIZE(8000)\"\n\nQUEUE \"//useridA JOB (0),'TSO USER',\"\nQUEUE \"//         TYPRUN=SCAN,  \"\nQUEUE \"//         MSGLEVEL=1,CLASS=A,NOTIFY=USERID\"\nQUEUE \"//STEP1    EXEC PGM=\"PROGRAM_TO_EXECUTE\nQUEUE \"//INFILE   DD DSN=USERID.INPUT.FILE,DISP=SHR \"\nQUEUE \"//OUTFILE  DD SYSOUT=A \"\nQUEUE \"//SYSIN    DD * \"\nQUEUE DATE() TIME()\nQUEUE JCL_DELIMITER\nQUEUE \"\" /* NULL LINE EXITS INPUT MODE */\nQUEUE \"TOP\"\nQUEUE \"LIST\"\nQUEUE \"SUBMIT\"\nQUEUE \"END NOSAVE\"\n\"EDIT\" TEMP_FILE_NAME \"CNTL OLD NONUM\"\n\"STATUS\"\n\n\n**** UPDTMEMB REXX Program. ****\n\n/* REXX UPDTMEMB\n   OBTAIN MEMBER INFORMATION ABOUT A PDS,\n   UPDATE A MEMBER IN THAT PDS NAMED ##INFO\n   WITH THAT INFORMATION.\n   1 PARAMETER REQUIRED TO BE ENTERED ON THE COMMAND LINE:\n   PDS\n   IF IT IS NOT ENTERED ON THE COMMAND LINE,\n   THE PROGRAM WILL ASK FOR IT.\n*/\n\nARG PDS .\nDEBUG = \"NO\"                    /* YES OR NO */\n\nIF PDS = \"\" THEN CALL GET_INPUT  /* NO ARG, ASK FOR INFO */\n\n/* INITIALIZE VARIABLES */\nMEMBER_NAME = \"##INFO\"\n\n/* VERIFY PDS */\nRET_CODE = LISTDSI(PDS)\nIF RET_CODE <> 0 THEN SIGNAL BAD_DSN\n\nIF SYSDSORG <> \"PO\" THEN SIGNAL NOT_PDS\n\n/* BUILD FULL DSN + MEMBER NAME\n   LISTDSI RETURNS THE FULL NAME OF THE PDS\n   IN THE RESERVED VARIABLE SYSDSNAME\n*/\nPDS_AND_MEMB = \"'\"SYSDSNAME\"(\"##INFO\")'\"\nIF DEBUG = \"YES\" THEN SAY \"FULL NAME IS \" PDS_AND_MEMB\n\n/* CAPTURE OUTPUT OF LISTDS */\nCALL OUTTRAP \"LINE.\",\"*\"\n\n\"LISTDS\" PDS\nCALL OUTTRAP \"OFF\"\nIF DEBUG = \"YES\" THEN CALL DISPLAY_LINE_ARRAY\n\nWRITE_TO_FILE:\nIF DEBUG = \"YES\" THEN TRACE C\n\"ALLOCATE DDNAME(OUT) DSNAME(\"PDS_AND_MEMB\") SHR REUSE\"\nIF DEBUG = \"YES\" THEN SAY \"GOING TO WRITE \" LINE.0 \" RECORDS\"\n\n\"EXECIO \" LINE.0 \"DISKW OUT (STEM LINE. FINIS)\"\nIF RC = 0 | RC = 1 THEN SAY \"MEMBER CREATED SUCCESSFULLY\"\nELSE SAY \"MEMBER CREATION FAILED\"\nIF DEBUG = \"YES\" THEN SAY \"RETURN CODE FROM EXECIO \" RC\n\"FREE     DDNAME(OUT)\"\nRETURN\n\nGET_INPUT:\n   SAY \"ENTER THE NAME OF A PDS, STANDARD TSO NAMING CONVENTIONS\"\n   SAY \"INFORMATION ABOUT THE PDS WILL BE COLLECTED\"\n   SAY \"AND INSERTED INTO THE PDS IN MEMBER NAME ##STATS\"\n   PULL PDS\n   IF PDS  = \"\" THEN DO\n      SAY \"NOTHING ENTERED, ENDING\"\n      EXIT\n      END /* NO PDS  SECOND TIME */\n\nRETURN\n\nDISPLAY_LINE_ARRAY:\nDO I = 1 TO LINE.0\n   SAY \"TRAPPED LISTD\" I LINE.I\nEND I\nRETURN\n\nBAD_DSN:\nSAY \"DATASET NAME ENTERED DOES NOT EXIST\" PDS\nEXIT\n\nNOT_PDS:\nSAY \"DATASET NAME ENTERED IS NOT A PDS\" PDS\nEXIT\n\n\n**** CONTAINS REXX Function. ****\n/* REXX CONTAINS\nA REXX internal function that tells you if the first argument\nis contained in the second.\n\nIf you wish to use it as an external function\n you need to delete the instruction:\nCONTAINS: PROCEDURE\n\nIt is executed this way, as an example: (in another program!)\nHaystack = \"Hello!\"\nNeedle = \"!\"\nIf contains(needle,haystack) = 1 then say \"OK\"\nelse say \"Must contain exclamation (!) character\"\n\nsay contains(\"cat\",\"reallocate\") gives 1\nsay contains(\"cat\",\"kate\")       gives 0\nsay contains(\"cat\")              gives -1\n*/\nCONTAINS: PROCEDURE\n\n\nif arg()              < 2 then return -1   /* 2 args required */\nif pos(arg(1),arg(2)) > 0 then return 1\nreturn 0\n\n\n**** EQWILD function. ****\n\n/* REXX EQWILD\nThis is an internal function that does a comparison,\nwith a wild card character.\nThe wild card character is always equal to\nthe corresponding character in the input strings.\nComparison is done character by character.\nBoth strings must be of the same length.\nThe default wild character is the underscore: (_).\nIt is used like this:\nif eqwild(\"JO_N\", \"JOAN\", \"_\")\n     then say \"equal\"\n     else say \"not equal\"\nThe first input string may contain the wild card character.\n*/\nEQWILD: PROCEDURE\narg string1, string2, char1_wild .\ncall validate\nif char1_wild = \"\" then char1_wild = \"_\"\n\nstring1 = strip(string1,b) /* drop lead + trail blanks */\nstring2 = strip(string2,b)\n\nif length(string1) <> length(string2) then return 0\ndo i = 1 to length(string1)\n   if substr(string1,i,1) = char1_wild then nop\n   else if substr(string1,i,1) <> substr(string2,i,1)\n   then do\n          return 0 /* not equal*/\n        end\nend i\nreturn 1 /* equal */\n\nvalidate:\nparse source . how_called .\nif how_called = \"COMMAND\" then do\n   say 'this is a function'\n   say 'it may not be called from the command line'\n   say 'call it from another REXX program:'\n   say '   if eqwild(\"JO_N\", \"JOAN\", \"_\")'\n   say '      then say \"equal\"'\n   say '      else say \"not equal\"'\n   exit -1 /* give -1 to TSO,\n         since program was called from command line */\n   end\nreturn /* was called properly */\n\n\n**** $HIDEALL macro. ****\n\n/* REXX $hideall\nA macro for the TSO/ISPF editor.\nUsed within a TSO/ISPF edit session.\nIt excludes (hides) all lines of the file which\ncontain a specific character string.\n\nTo use, within a TSO/ISPF edit session,\ntype $HIDEALL character-string on the command line.\nExample:\n$HIDEALL DSN=\n*/\nADDRESS ISREDIT\n\"MACRO (PARM1)\"\n\nIF RC > 0 THEN SIGNAL NOT_AS_A_MACRO\nIF PARM1 = \"\" THEN EXIT\nADDRESS ISREDIT \"EXCLUDE ALL\"\nADDRESS ISREDIT \"FIND ALL '\"PARM1\"'\"\nADDRESS ISREDIT \"FLIP \"\nEXIT /* NORMAL END OF PROGRAM */\n\nNOT_AS_A_MACRO:\nSAY \"THIS IS A TSO/ISPF EDITOR MACRO\"\nSAY \"IT MAY BE EXECUTED ONLY IN THE ISPF EDITOR\"\nSAY \"BY TYPING $HIDEALL char-string ON THE COMMAND LINE\"\nEXIT\n\n\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "CANJOB": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x16\\x00*\\x00*\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:16:48", "lines": 42, "newlines": 42, "modlines": 0, "user": "EXEC"}, "text": "/* REXX NAME: CANJOB\n\n   PURPOSE: DOES A STATUS, THEN ASKS YOU FOR JOB SUFFIX,\n            AND JES JOB NUMBER\n            THEN CANCELS THE JOB WITH A PURGE\n\n   USE: %CANJOB\n        THEN REPLY WITH JOB SUFFIX,\n        I.E. LETTER/NUMBER APPENDED TO YOUR USERID ON JOB NAME\n        AND JES JOB NUMBER, NUMERIC PART ONLY\n\n        FOR EXAMPLE:\n\n         %CANJOB\n         - MESSAGE APPEARS: TSOU01A(JOB01234) EXECUTING\n         A   1234\n*/\n\"STATUS\"\n SAY \"TO CANCEL ONE OF YOUR JOBS,\"\n SAY \"- TYPE IN:\"\n SAY \"- JOB SUFFIX     JES JOB NUMBER \"\n SAY \"- EXAMPLE:     P  1234 \"\n SAY\n PULL SUFFIX NUMBER\n IF SUFFIX = \"\"\n THEN\n    DO\n      SAY \"NEED JOB SUFFIX AND JOB NUMBER, NO COMMAS\"\n      EXIT\n    END\n IF SUFFIX = \"\" THEN EXIT\n IF SUFFIX = \"STOP\"  THEN EXIT\n\nTRACE C\n\n\n\"CANCEL\" USERID() || SUFFIX || \"(JOB\" || NUMBER\"), PURGE\"\n/* ALTERNATIVELY, YOU COULD HAVE DONE IT THIS WAY:\n\"CANCEL\" USERID()\"\"SUFFIX\"(JOB\"NUMBER\"), PURGE\"\n*/\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONCATN": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11#\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:23:17", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/*REXX CONCATN external function*/\n/* this must be a member, named CONCATN\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg var1 var2\nreturn var1 || var2\n/* or return var1\"\"var2 */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONTAINS": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:18:36", "lines": 25, "newlines": 25, "modlines": 0, "user": "EXEC"}, "text": "/* REXX CONTAINS\nA REXX internal function that tells you if the first argument\nis contained in the second.\n\nIf you wish to use it as an external function\n you need to delete the instruction:\nCONTAINS: PROCEDURE\n\nIt is executed this way, as an example: (in another program!)\nHaystack = \"Hello!\"\nNeedle = \"!\"\nIf contains(needle,haystack) = 1 then say \"OK\"\nelse say \"Must contain exclamation (!) character\"\n\nsay contains(\"cat\",\"reallocate\") gives 1\nsay contains(\"cat\",\"kate\")       gives 0\nsay contains(\"cat\")              gives -1\n*/\nCONTAINS: PROCEDURE\n\n\nif arg()              < 2 then return -1   /* 2 args required */\nif pos(arg(1),arg(2)) > 0 then return 1\nreturn 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOEQWILD": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x17\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16'\\x00\\x07\\x00\\x07\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:27:17", "lines": 7, "newlines": 7, "modlines": 0, "user": "EXEC"}, "text": "/* rexx doeqwild\nthis program exists only to test the function EQWILD.\nExecute this, from the command line, not EQWILD\n*/\nif eqwild(\"JO_N\", \"JOAN\", \"_\")\n     then say \"equal\"\n     else say \"not equal\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQWILD": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x18\\x00.\\x00.\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:18:56", "lines": 46, "newlines": 46, "modlines": 0, "user": "EXEC"}, "text": "/* REXX EQWILD\nThis is an internal function that does a comparison,\nwith a wild card character.\nThe wild card character is always equal to\nthe corresponding character in the input strings.\nComparison is done character by character.\nBoth strings must be of the same length.\nThe default wild character is the underscore: (_).\nIt is used like this:\nif eqwild(\"JO_N\", \"JOAN\", \"_\")\n     then say \"equal\"\n     else say \"not equal\"\nThe first input string may contain the wild card character.\n*/\nEQWILD: PROCEDURE\narg string1, string2, char1_wild .\ncall validate\nif char1_wild = \"\" then char1_wild = \"_\"\n\nstring1 = strip(string1,b) /* drop lead + trail blanks */\nstring2 = strip(string2,b)\n\nif length(string1) <> length(string2) then return 0\ndo i = 1 to length(string1)\n   if substr(string1,i,1) = char1_wild then nop\n   else if substr(string1,i,1) <> substr(string2,i,1)\n   then do\n          return 0 /* not equal*/\n        end\nend i\nreturn 1 /* equal */\n\nvalidate:\nparse source . how_called .\nif how_called = \"COMMAND\" then do\n   say 'this is a function'\n   say 'it may not be called from the command line'\n   say 'call it from another REXX program:'\n   say '   if eqwild(\"JO_N\", \"JOAN\", \"_\")'\n   say '      then say \"equal\"'\n   say '      else say \"not equal\"'\n   exit -1 /* give -1 to TSO,\n         since program was called from command line */\n   end\nreturn /* was called properly */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "METRIC": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11#\\x00\\x17\\x00\\x17\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:23:49", "lines": 23, "newlines": 23, "modlines": 0, "user": "GABRIEL"}, "text": "/*REXX external function METRIC*/\n/* this must be a member, named METRIC\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg unit quantity\n\nif unit = \"LITER\" then do\n   return quantity * 1.057 \"quarts\"\n   end\n\nif unit = \"QUART\" then do\n   return quantity * .946 \"liters\"\n   end\n\nif unit = \"MILE\" then do\n   return quantity * (8/5) \"kilometers\"\n   end\n\nif unit = \"KILOMETER\" then do\n   return quantity * .625 \"miles\"\n   end\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PERCENTI": {"ttr": 1556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11\"\\x00\\x14\\x00\\x14\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:22:36", "lines": 20, "newlines": 20, "modlines": 0, "user": "GABRIEL"}, "text": "\n/*REXX external function PERCENTI */\n/* this must be a member, named PERCENTI\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg old, new\nif datatype(old) = \"CHAR\" then do\n   say \"invalid number\" old\n   return 0\n   end\n\nif datatype(new) = \"CHAR\" then do\n   say \"invalid number\" new\n   return 0\n   end\n\nincrease =  100 * ((new - old) / old)\nreturn increase\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB001": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11\\x11\\x00\\x05\\x00\\x05\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:11:32", "lines": 5, "newlines": 5, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB001*/\n Say 1 + 1\n  Say \"Today is\" Date()\n  Name = \"Sue\"\n  Say \"Hello, \" Name\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB002": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11\\x11\\x00\\x08\\x00\\x08\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:11:54", "lines": 8, "newlines": 8, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB002*/\nSay \"hello\"\nSay 1 + 1\nSay length(\"hello\")\nnum = 5\n\nsay num + 5\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB005": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11\\x12\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:12:13", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB005*/\ngreeting = \"Good morning\"\nname = \"Joe\"\nsay greeting name\nsay greeting || name\n/*or*/\nsay greeting\"\"name\nsay greeting \"          \"name\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB007": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x01\\x14\\x14?\\x01\\x14\\x14?\\x110\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:30:52", "lines": 3, "newlines": 3, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB007*/\n\"LISTDS 'userid.REXX.EXEC' MEMBERS\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB008": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x01\\x14\\x14?\\x01\\x14\\x14?\\x111\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:31:38", "lines": 4, "newlines": 4, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB008*/\nmembers = \"\"\n\"LISTDS 'userid.REXX.EXEC' \" MEMBERS\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB010": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x14\\x14?\\x01\\x14\\x14?\\x111\\x00\\x05\\x00\\x05\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:31:47", "lines": 5, "newlines": 5, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB010*/\n/* This is a sample exec for REXX class */\n\"TIME\"\n\"SEND 'SAMPLE EXEC ' USER(*)\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB015": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x14\\x14?\\x01\\x14\\x14?\\x112\\x00\\x05\\x00\\x05\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:32:09", "lines": 5, "newlines": 5, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB015*/\nsay \"3 + 1 is 4\"\nsay \"'3 + 1 is 4'\"\nsay \"O'brien\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB016": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x14\\x14?\\x01\\x14\\x14?\\x112\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:32:19", "lines": 3, "newlines": 3, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB016*/\n\"LISTCAT ENTRY('SYS1.PROCLIB')\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB018": {"ttr": 1809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x14\\x14?\\x01\\x14\\x14?\\x112\\x00\\x05\\x00\\x05\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:32:27", "lines": 5, "newlines": 5, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB018*/\nv1 = 10\nv2 = 20\nsay v1 + v2\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PROB019": {"ttr": 1811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x14\\x14?\\x01\\x14\\x14?\\x112\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:32:34", "lines": 4, "newlines": 4, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB019*/\nuserid = \"TSOU02\" /*for example*/\n\"LISTCAT LEVEL(\"userid\")\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB028": {"ttr": 1813, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x14\\x14?\\x01\\x14\\x14?\\x112\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:32:58", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB028*/\nprevious = \"\"\ndo 10\n  say \"please enter a number (not same as previous)\"\n  pull number\n  if number = previous then say \"that is same as previous\"\n  previous = number\nEnd\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB029": {"ttr": 1815, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x14\\x14?\\x01\\x14\\x14?\\x113\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:33:27", "lines": 14, "newlines": 14, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB029*/\nsecret = 13\ndo 10\n  say \"PLEASE ENTER YOUR GUESS, FROM 1 TO 20\"\n  pull number\n  if number = secret then do\n     say \"RIGHT\"\n     leave\n     end\n  else do\n     say \"WRONG\"\n     end\nend\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB030": {"ttr": 1817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x14\\x14?\\x01\\x14\\x14?\\x113\\x00\\x14\\x00\\x14\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:33:39", "lines": 20, "newlines": 20, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB030*/\ndo 10\n  say \"PLEASE ENTER A DATASET NAME\"\n  pull dsn\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\n  \"LISTDS\" dsn\n  if rc = 0 then do\n     leave\n     end\n  else do\n     say \"not found\"\n     end\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB031": {"ttr": 1819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x14\\x14?\\x01\\x14\\x14?\\x114\\x00\\r\\x00\\r\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:34:10", "lines": 13, "newlines": 13, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB031*/\nSay \"Please enter name\"\nPull name\nselect\n when name = \"JOHN\" then say \"PAUL JONES\"\n when name = \"GEORGE\" then say \"Washington\"\n when name = \"NELSON\" then say \"Mandela\"\n when name = \"JULIUS\" then say \"Caesar\"\n when name = \"\" then say \"Please try again\"\notherwise\nsay \"bad reply .> Please enter a name\"\nend\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB032": {"ttr": 1821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x14\\x14?\\x01\\x14\\x14?\\x157\\x00\\x06\\x00\\x06\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:37:51", "lines": 6, "newlines": 6, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB032*/\nSay \"Please reply exactly Yes! \"\nparse pull reply\nif reply = \"Yes\" then say \"correct answer\"\nelse say \"wrong answer\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB033": {"ttr": 1823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x14\\x14?\\x01\\x14\\x14?\\x158\\x00\\x06\\x00\\x06\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:38:09", "lines": 6, "newlines": 6, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB033*/\nVAR1 = \"ABCDEFGHIJKLMNOP\"\nParse var VAR1  3 var2  5  6  var3  10  9  var4  15\nsay var2\nsay var3\nsay var4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB035": {"ttr": 1825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x14\\x14?\\x01\\x14\\x14?\\x158\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:38:17", "lines": 12, "newlines": 12, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB035*/\narg dataset\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\n\"LISTCAT ENTRY(\"dataset\")\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB037": {"ttr": 1827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x14\\x14?\\x01\\x14\\x14?\\x11\\x18\\x00\\x05\\x00\\x05\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T11:18:26", "lines": 5, "newlines": 5, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB037*/\narg v1 v2 v3 v4\nif v4 <> \"\" then say \"I said enter only three items please!\"\nsay v3 v2 v1\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB038": {"ttr": 1829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15C\\x00\\x06\\x00\\x05\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:43:13", "lines": 6, "newlines": 5, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB038*/\nSay \"Please type in three words (only)\"\nPull word1 word2 word3 .\nSay  word1 word2 word3\n/* the period throws away words after the third*/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB039": {"ttr": 1831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15D\\x00\\x06\\x00\\x06\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:44:09", "lines": 6, "newlines": 6, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB039*/\nSay \"Please type in three words (only)\"\nPull word1 word2 word3 .\n/* the period throws away words after the third*/\nSay word3 word2 word1\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB040": {"ttr": 1833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15D\\x00\\x17\\x00\\x17\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:44:36", "lines": 23, "newlines": 23, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB040*/\narg dataset\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\nif dataset = \"JUNK.DATA\" then \"DELETE JUNK.DATA\"\nelse do\n   Say \"ARE YOU SURE? Y/N\"\n   pull reply\n   if reply = \"Y\" then do\n      \"DELETE \" dataset\n      say \"DELETED\"\n      end\n    else do\n      say \"NOT DELETED\"\n      end\n    end\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB041": {"ttr": 1835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15D\\x00\\x08\\x00\\x08\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:44:54", "lines": 8, "newlines": 8, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB041*/\nSay \"Please type in old salary\"\nPull old\nSay \"Please type in new salary\"\nPull new\nincrease =  100 * ((new - old) / old)\nSay \"the % of increase was\" increase\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB042": {"ttr": 1837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15E\\x00\\x19\\x00\\x19\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:45:34", "lines": 25, "newlines": 25, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB042*/\nsay \"PLEASE ENTER DATASET NAME\"\npull dsn\n  /* Standard TSO naming conventions:\n     if name is fully qualified,\n     specify with apostrophes:\n     'MYUSERID.MY.DATA'\n     if userid omitted, and it's yours,\n     do not include apostrophes:\n      MY.DATA\n   */\n\nsignal on error\n\"LISTDS\" dsn\nExit\n\nerror:\nsay \"CANNOT EXECUTE TSO COMMAND\"\nsay \"TSO ERROR CODE IS \" rc\nsay \"LINE IN ERROR IS \" sourceline(sigl)\nsay \"PLEASE REENTER\"\npull dsn\n\"LISTDS\" dsn\nexit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB043": {"ttr": 1839, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15E\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:45:58", "lines": 14, "newlines": 14, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB043*/\nsay \"Please type in a number\"\npull number1\nsay \"Please type in another number\"\npull number2\n\nsignal on syntax\nsay number1 * number2\nexit\n\nsyntax:\nsay \"a syntax error has occured. \"\nexit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB044": {"ttr": 1841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15F\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:46:50", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB044*/\nSay \"PLEASE ENTER RECORD LENGTH\"\npull lrecl\nsay \"PLEASE ENTER BLOCK SIZE\"\npull blksize\n\nif (blksize // lrecl) = 0 then say \"OK\"\nelse say \"BLOCK SIZE IS NOT A MULTIPLE OF RECORD LENGTH\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB046": {"ttr": 1843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15G\\x00\\x13\\x00\\x13\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:47:04", "lines": 19, "newlines": 19, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB046*/\nsay \"Please enter principal\"\npull principal\nsay \"please enter yearly interest rate in percent\"\npull percent\nsay \"how many years is money kept in account?\"\npull years\nsay \"please enter how many times per year interest is compounded\"\nsay \"1 = yearly; 12 = monthly; 52 = weekly; 365 = daily\"\npull frequency\n\nyearly_rate = percent / 100\nr = yearly_rate / frequency\n\nn = years * frequency\n\nfinal = principal * ((1 + r)**n)\nsay final\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB048": {"ttr": 1845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15G\\x00\\x10\\x00\\x10\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:47:40", "lines": 16, "newlines": 16, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB048*/\narg number1 number2\nif datatype(number1) = \"CHAR\" then do\n   say number1 \"is not a valid number\"\n   exit\n   end\n\nif datatype(number2) = \"CHAR\" then do\n   say number2 \"is not a valid number\"\n   exit\n   end\n\nanswer = number1 - number2\nanswer = abs(answer)\nsay answer\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB049": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15H\\x00\\x08\\x00\\x08\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:48:04", "lines": 8, "newlines": 8, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB049*/\nif sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n   delete \"WORKSHOP.TEMP\"\n   end\nelse do\n   \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n  end\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB050": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15H\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:48:19", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB050*/\nif sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n   call outtrap \"line.\", \"*\" /* or x = outtrap(\"line.\",\"*\") */\n   delete \"WORKSHOP.TEMP\"\n   end\nelse do\n   \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n   end\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB051": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15H\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:48:28", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB051*/\nif sysdsn(WORKSHOP.TEMP) = \"OK\" then do\n   call msg \"OFF\"\n   delete \"WORKSHOP.TEMP\"\n   end\nelse do\n   \"ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)\"\n   end\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB052": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15H\\x00\\x07\\x00\\x07\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:48:40", "lines": 7, "newlines": 7, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB052*/\nsay \"Please type in GREAT\"\npull word\nsay translate(word,\"BUENO\",\"GREAT\")\n   /* or */\nsay translate(word,\"ONEUB\",\"TAERG\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB053": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15I\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:49:06", "lines": 15, "newlines": 15, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB053*/\narg hex1 sign hex2\ndec1 = x2d(hex1)\ndec2 = x2d(hex2)\n\nif sign = \"+\" then do\n   dec_answer = dec1 + dec2\n   end\n\nif sign = \"-\" then do\n   dec_answer = dec1 - dec2\n   end\n\nsay d2x(dec_answer)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB054": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15I\\x00\\x08\\x00\\x08\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:49:31", "lines": 8, "newlines": 8, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB054*/\n/*REXX Uppr EXEC converts upper to lower*/\nparse arg instring\nupper_alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nlower_alpha = \"abcdefghijklmnopqrstuvwxyz\"\noutstring = translate(instring,upper_alpha,lower_alpha)\nsay outstring\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB056": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15P\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:50:05", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB056*/\nSay concat_nate(\"cat\" \"dog\")\nexit\n\nconcat_nate:\narg var1 var2\nreturn var1 || var2\n/* or return var1\"\"var2 */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB058": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15P\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:50:16", "lines": 4, "newlines": 4, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB058*/\n/*REXX main program to execute PERCENTI*/\nsay percenti(100000, 150000)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PROB059": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15P\\x00\\x06\\x00\\x06\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:50:25", "lines": 6, "newlines": 6, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB059*/\n/*REXX main program*/\ncall concatn \"cat\" \"dog\"\nsay result\nexit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB060": {"ttr": 2067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15P\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:50:34", "lines": 4, "newlines": 4, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB060*/\n/*REXX main program*/\nsay METRIC(\"KILOMETER\" 1000)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB061": {"ttr": 2069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15P\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:50:41", "lines": 4, "newlines": 4, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB061*/\n/*REXX main program*/\ncall SQRT 25\nsay result\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PROB062": {"ttr": 2071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15P\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:50:55", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB062*/\ndo i = 1 to 10\n  number.i = i + 100\nend i\n\ndo i = 1 to 11\n  say number.i\nend i\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PROB063": {"ttr": 2073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15Q\\x00\\r\\x00\\r\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:51:13", "lines": 13, "newlines": 13, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB063*/\nsay \"please enter a command\"\npull command\n\ncall outtrap \"Display_line.\", \"*\"\ncommand\ncall outtrap \"OFF\"\n\nsay \"About to display command's output\"\ndo i = 1 to Display_line.0\n  say Display_line.i\nend i\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB064": {"ttr": 2075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15Q\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:51:36", "lines": 9, "newlines": 9, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB064*/\nsample_file = \"my.sample.file\"\n\"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n\"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(INFILE)\"\nDo i = 1 to infile.0 by 2\n  say infile.i\nend i\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB065": {"ttr": 2077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15Q\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:51:47", "lines": 14, "newlines": 14, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB065*/\nsample_file   = \"my.sample.file\"\nsample_output = \"my.sample.output\"\n\n\"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n\"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(INFILE)\"\n\n\"ALLOC DDN(OUTFILE) NEW REUSE DSN(\"sample_output\")\",\n  \"LIKE(\"sample_file\")\"\n\n\"EXECIO \" infile.0 \"DISKW OUTFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(OUTFILE)\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB066": {"ttr": 2079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15Q\\x00\\x16\\x00\\x16\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:51:55", "lines": 22, "newlines": 22, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB066*/\nsample_file = \"my.sample.file\"\n\"ALLOC DDN(INFILE) SHR REUSE DSN(\"sample_file\")\"\n\"EXECIO * DISKR INFILE (STEM INFILE. FINIS)\"\n\"FREE DDN(INFILE)\"\n\nrecord_count = 0\nmax_length = 0\n\nDo i = 1 to infile.0\n  record_count = record_count + 1\n  say infile.i\n\n  if length(infile.i) > max_length\n  then max_length = length(infile.i)\n\nend i\n\nSay \"record count was \" record_count\n/* or infile.0 instead of record_count */\nSay \"length of longest record was \" max_length\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB067": {"ttr": 2081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15R\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:52:09", "lines": 17, "newlines": 17, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB067*/\nsay \"please enter a command\"\npull command\n\ncall outtrap \"Display_line.\", \"*\"\ncommand\ncall outtrap \"OFF\"\n\nif sysdsn(\"temp.capture.data\") = \"OK\"\nthen \"DELETE TEMP.CAPTURE.DATA\"\n\n\"ALLOC DDN(CAPTURE) DSN(TEMP.CAPTURE.DATA) NEW REUSE\",\n  \"SPACE(1 1) TRACKS LRECL(80) BLKSIZE(4000) RECFM(F B)\"\n\n\"EXECIO \" Display_line.0 \"DISKW CAPTURE (STEM Display_line. FINIS)\"\n\"FREE DDN(CAPTURE)\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB068": {"ttr": 2083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15R\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:52:29", "lines": 4, "newlines": 4, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB068*/\narg expression\ninterpret \"say\" expression\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROB069": {"ttr": 2085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15R\\x00\"\\x00\"\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:52:43", "lines": 34, "newlines": 34, "modlines": 0, "user": "GABRIEL"}, "text": "/* REXX PROB069*/\n/*Extra practice problem.*/\ndo until reply = \"NO\"\n  say \"Please enter principal\"\n  pull principal\n  if principal = \"\" then leave\n  if datatype(principal) = \"CHAR\" then iterate\n\n  say \"please enter yearly interest rate in percent\"\n  pull percent\n  if percent = \"\" then iterate\n  if datatype(principal) = \"CHAR\" then iterate\n\n  say \"how many years is money kept in account?\"\n  pull years\n  if years = \"\" then iterate\n  if years > 100 then iterate\n  if datatype(principal) = \"CHAR\" then iterate\n\n  say \"please enter how many times per year interest is compounded\"\n  say \"1 = yearly; 12 = monthly; 52 = weekly; 365 = daily\"\n  pull frequency\n\n  yearly_rate = percent / 100\n  r = yearly_rate / frequency\n\n  n = years * frequency\n\n  final = principal * ((1 + r)**n)\n  say final\n\n  say \"do another calculation? YES/NO\"\n  pull reply\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQRT": {"ttr": 2087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x14\\x14?\\x01\\x14\\x14?\\x15S\\x00\\x17\\x00\\x17\\x00\\x00\\xc7\\xc1\\xc2\\xd9\\xc9\\xc5\\xd3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T15:53:53", "lines": 23, "newlines": 23, "modlines": 0, "user": "GABRIEL"}, "text": "/*REXX SQRT external function */\n/* this must be a member, named SQRT\nin your REXX library, or in another\nlibrary allocated to SYSEXEC\n*/\narg number\nif number < 0 then do\n   say \"number must be positive\"\n   return 0\n   end\n\nif datatype(number) = \"CHAR\" then do\n   say \"number must be numeric\"\n   return 0\n   end\n\nguess = number / 2\ndo 50\n  new_guess = (guess + (number / guess)) / 2\n  guess = new_guess\nend\nreturn new_guess\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STQUICK": {"ttr": 2089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x16\\x00!\\x00!\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:16:20", "lines": 33, "newlines": 33, "modlines": 0, "user": "EXEC"}, "text": "/*REXX STQUICK\n COUNT AND STATUS OF JOBS SUBMITTED BY YOU\n*/\nCALL OUTTRAP \"LINE.\",\"*\"\n\"STATUS\"\nCALL OUTTRAP \"OFF\"\n\nEXECUTING_CTR = 0\nWAIT_CTR      = 0\nOUTPUT_CTR    = 0\n\nDO I = 1 TO LINE.0\n   IF POS(\"NO JOBS FOUND\",LINE.I) > 0\n   THEN\n     DO\n       SAY \"YOU HAVE NO JOBS IN THE SYSTEM NOW\"\n       EXIT\n     END\nEND I\n\nDO I = 1 TO LINE.0\n   IF POS(\"EXECUTING\",LINE.I) > 0\n      THEN EXECUTING_CTR =   EXECUTING_CTR + 1\n   IF POS(\"OUTPUT QUEUE\",LINE.I) > 0\n      THEN OUTPUT_CTR =      OUTPUT_CTR    + 1\n   IF POS(\"WAITING FOR\",LINE.I) > 0\n      THEN WAIT_CTR =        WAIT_CTR      + 1\nEND I\n\nSAY \"EXECUTING\"             EXECUTING_CTR\nSAY \"ON OUTPUT QUEUE\"       OUTPUT_CTR\nSAY \"WAITING FOR EXECUTION\" WAIT_CTR\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBJCL1": {"ttr": 2091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x17\\x002\\x002\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:17:14", "lines": 50, "newlines": 50, "modlines": 0, "user": "EXEC"}, "text": "**** SUBJCL1 REXX Program. ****\n\n/* REXX SUBJCL1\n   SUBMITTING JCL FOR BATCH PROCESSING.\n   INSERTING VARIABLE VALUES INTO THE JCL\n   USING THE INTERNAL DATA QUEUE\n\n   QUEUE LINES OF JCL, THEN WRITE TO A FILE\n   FROM THE DATA QUEUE.\n   SUBMIT THE FILE, THEN DELETE IT\n*/\n\nTEMP_FILE_NAME = \"'userid.TEMP.SUBMIT.CNTL'\"\nPROGRAM_TO_EXECUTE = \"MYPROG1\"\n\nCALL MSG \"OFF\"\n\"DELETE\" TEMP_FILE_NAME\nCALL MSG \"ON\"\n\nSIGNAL ON ERROR\n\"ALLOC DDN(TEMPFILE) NEW REUSE DSN(\"TEMP_FILE_NAME\")\",\n   \"SPACE(3,1) TRACKS\"\nSIGNAL OFF ERROR\n\n\"NEWSTACK\"\nQUEUE \"//useridA  JOB (0),'TSO USER',\"\nQUEUE \"//         TYPRUN=SCAN,  \"\nQUEUE \"//         MSGLEVEL=1,CLASS=A,NOTIFY=userid\"\nQUEUE \"//STEP1    EXEC PGM=\"PROGRAM_TO_EXECUTE\nQUEUE \"//INFILE   DD DSN=userid.INPUT.FILE,DISP=SHR \"\nQUEUE \"//OUTFILE  DD SYSOUT=A \"\nQUEUE \"//SYSIN    DD * \"\nQUEUE DATE() TIME()\nQUEUE \"/*\"\n\n\n\"EXECIO\" QUEUED() \"DISKW TEMPFILE (FINIS)\"\n\"DELSTACK\"\n\"FREE DDNAME(TEMPFILE)\"\n\"SUBMIT\" TEMP_FILE_NAME\nCALL MSG \"OFF\"\n\"DELETE\" TEMP_FILE_NAME\nCALL MSG \"ON\"\nEXIT\n\nERROR:\nSAY \"UNABLE TO ALLOCATE TEMPORARY FILE\" TEMP_FILE_NAME\nSAY \"TERMINATING\"\nEXIT\n\n", "mimetype": "text/x-diff", "datatype": "ebcdic", "extension": ".diff"}, "SUBJCL2": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x17\\x00F\\x00F\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:17:29", "lines": 70, "newlines": 70, "modlines": 0, "user": "EXEC"}, "text": "/* rexx subjcl2\n   submitting JCL for batch processing.\n   Inserting variable values into the JCL\n   using a compound, or stem variable\n\n   place lines of jcl into the stem variable\n   write the file,\n   submit the file, then delete it\n*/\n\nTemp_file_name = \"'userid.TEMP.SUBMIT.CNTL'\"\nProgram_to_execute = \"MYPROG1\"\n\ncall msg \"off\"\n\"delete\" Temp_file_name\ncall msg \"on\"\n\nsignal on error\n\"alloc ddn(tempfile) new reuse dsn(\"Temp_file_name\")\",\n   \"space(3,1) tracks\"\nsignal off error\n\nline_counter = 0\ncall add_line_to_array,\n     \"//useridA JOB (0),'TSO USER',\"\ncall add_line_to_array,\n     \"//         TYPRUN=SCAN,  \"\ncall add_line_to_array,\n     \"//         MSGLEVEL=1,CLASS=A,NOTIFY=userid\"\ncall add_line_to_array,\n     \"//STEP1    EXEC PGM=\"PROGRAM_TO_EXECUTE\ncall add_line_to_array,\n     \"//INFILE   DD DSN=userid.INPUT.FILE,DISP=SHR \"\ncall add_line_to_array,\n     \"//OUTFILE  DD SYSOUT=A \"\ncall add_line_to_array,\n     \"//SYSIN    DD * \"\ncall add_line_to_array,\n     DATE() TIME()\ncall add_line_to_array,\n     \"/*\"\n\n/* display contents of stem variable */\ndo i = 1 to line.0\n   say line.i\nend i\n\n\"execio\" line.0   \"diskw tempfile (stem line. finis)\"\n\n\"free ddname(tempfile)\"\n\n\"submit\" Temp_file_name\n\ncall msg \"off\"\n\"delete\" Temp_file_name\ncall msg \"on\"\nexit\n\nerror:\nsay \"Unable to allocate temporary file\" Temp_file_name\nsay \"terminating\"\nexit\n\nadd_line_to_array:\narg line_to_add\nline_counter      = line_counter + 1\nline.0            = line_counter\nline.line_counter = line_to_add\nreturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBJCL3": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x17\\x00)\\x00)\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:17:43", "lines": 41, "newlines": 41, "modlines": 0, "user": "EXEC"}, "text": "/* REXX SUBJCL3\n   SUBMITTING JCL FOR BATCH PROCESSING.\n   INSERTING VARIABLE VALUES INTO THE JCL.\n   USING THE TSO LINE MODE EDITOR TO CREATE\n   A TEMPORARY FILE, SUBMIT IT,\n   AND EXIT WITHOUT SAVING IT\n*/\n/* TRACE C  */\nTEMP_FILE_NAME = \"'userid.TEMP.SUBMIT.CNTL'\"\nPROGRAM_TO_EXECUTE = \"MYPROG1\"\nJCL_DELIMITER = \"/*\"\n\n/* DELETE, IF IT EXISTS. IT'S A TEMP FILE.\n\n   YOU SHOULD HAVE NOTHING GOOD IN A TEMP FILE. GOODBYE.\n*/\nCALL MSG \"OFF\"\n\"DELETE\" TEMP_FILE_NAME\nCALL MSG \"ON\"\n\n\"ALLOCATE DSN(\"TEMP_FILE_NAME\") NEW REUSE TRACKS\",\n   \"SPACE(3,1) LRECL(80) RECFM(F,B) BLKSIZE(8000)\"\n\nQUEUE \"//useridA JOB (0),'TSO USER',\"\nQUEUE \"//         TYPRUN=SCAN,  \"\nQUEUE \"//         MSGLEVEL=1,CLASS=A,NOTIFY=USERID\"\nQUEUE \"//STEP1    EXEC PGM=\"PROGRAM_TO_EXECUTE\nQUEUE \"//INFILE   DD DSN=USERID.INPUT.FILE,DISP=SHR \"\nQUEUE \"//OUTFILE  DD SYSOUT=A \"\nQUEUE \"//SYSIN    DD * \"\nQUEUE DATE() TIME()\nQUEUE JCL_DELIMITER\nQUEUE \"\" /* NULL LINE EXITS INPUT MODE */\nQUEUE \"TOP\"\nQUEUE \"LIST\"\nQUEUE \"SUBMIT\"\nQUEUE \"END NOSAVE\"\n\"EDIT\" TEMP_FILE_NAME \"CNTL OLD NONUM\"\n\"STATUS\"\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UPDTMEMB": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x14\\x14?\\x01\\x14\\x14?\\x16\\x18\\x00L\\x00L\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-05-23T00:00:00", "modifydate": "2014-05-23T16:18:09", "lines": 76, "newlines": 76, "modlines": 0, "user": "EXEC"}, "text": "/* REXX UPDTMEMB\n   OBTAIN MEMBER INFORMATION ABOUT A PDS,\n   UPDATE A MEMBER IN THAT PDS NAMED ##INFO\n   WITH THAT INFORMATION.\n   1 PARAMETER REQUIRED TO BE ENTERED ON THE COMMAND LINE:\n   PDS\n   IF IT IS NOT ENTERED ON THE COMMAND LINE,\n   THE PROGRAM WILL ASK FOR IT.\n*/\n\nARG PDS .\nDEBUG = \"NO\"                    /* YES OR NO */\n\nIF PDS = \"\" THEN CALL GET_INPUT  /* NO ARG, ASK FOR INFO */\n\n/* INITIALIZE VARIABLES */\nMEMBER_NAME = \"##INFO\"\n\n/* VERIFY PDS */\nRET_CODE = LISTDSI(PDS)\nIF RET_CODE <> 0 THEN SIGNAL BAD_DSN\n\nIF SYSDSORG <> \"PO\" THEN SIGNAL NOT_PDS\n\n/* BUILD FULL DSN + MEMBER NAME\n   LISTDSI RETURNS THE FULL NAME OF THE PDS\n   IN THE RESERVED VARIABLE SYSDSNAME\n*/\nPDS_AND_MEMB = \"'\"SYSDSNAME\"(\"##INFO\")'\"\nIF DEBUG = \"YES\" THEN SAY \"FULL NAME IS \" PDS_AND_MEMB\n\n/* CAPTURE OUTPUT OF LISTDS */\nCALL OUTTRAP \"LINE.\",\"*\"\n\n\"LISTDS\" PDS\nCALL OUTTRAP \"OFF\"\nIF DEBUG = \"YES\" THEN CALL DISPLAY_LINE_ARRAY\n\nWRITE_TO_FILE:\nIF DEBUG = \"YES\" THEN TRACE C\n\"ALLOCATE DDNAME(OUT) DSNAME(\"PDS_AND_MEMB\") SHR REUSE\"\nIF DEBUG = \"YES\" THEN SAY \"GOING TO WRITE \" LINE.0 \" RECORDS\"\n\n\"EXECIO \" LINE.0 \"DISKW OUT (STEM LINE. FINIS)\"\nIF RC = 0 | RC = 1 THEN SAY \"MEMBER CREATED SUCCESSFULLY\"\nELSE SAY \"MEMBER CREATION FAILED\"\nIF DEBUG = \"YES\" THEN SAY \"RETURN CODE FROM EXECIO \" RC\n\"FREE     DDNAME(OUT)\"\nRETURN\n\nGET_INPUT:\n   SAY \"ENTER THE NAME OF A PDS, STANDARD TSO NAMING CONVENTIONS\"\n   SAY \"INFORMATION ABOUT THE PDS WILL BE COLLECTED\"\n   SAY \"AND INSERTED INTO THE PDS IN MEMBER NAME ##STATS\"\n   PULL PDS\n   IF PDS  = \"\" THEN DO\n      SAY \"NOTHING ENTERED, ENDING\"\n      EXIT\n      END /* NO PDS  SECOND TIME */\n\nRETURN\n\nDISPLAY_LINE_ARRAY:\nDO I = 1 TO LINE.0\n   SAY \"TRAPPED LISTD\" I LINE.I\nEND I\nRETURN\n\nBAD_DSN:\nSAY \"DATASET NAME ENTERED DOES NOT EXIST\" PDS\nEXIT\n\nNOT_PDS:\nSAY \"DATASET NAME ENTERED IS NOT A PDS\" PDS\nEXIT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT911/FILE911.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT911", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}