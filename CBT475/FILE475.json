{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012132000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE475.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE475.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\x0b'", "DS1TRBAL": "b'[\\x1c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03t\\x00\\x03\\x03t\\x00\\x05\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@FILE475": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x08?\\x01\\x00\"\\x1f\\x163\\x00\\x08\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2000-08-08T16:33:00", "lines": 8, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 475 is from Wayne Rhoten of IBM, and contains an informal *   FILE 475\n//*           explanation of how to use the Large Block Interface   *   FILE 475\n//*           for Magnetic Tapes, which is being introduced with    *   FILE 475\n//*           OS/390 Release 2.10.                                  *   FILE 475\n//*                                                                 *   FILE 475\n//*           This small paper assumes that you have some prior     *   FILE 475\n//*           knowledge of interfacing with tapes and tape labels.  *   FILE 475\n//*                                                                 *   FILE 475\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LBITAPE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\"\\x1f\\x01\\x00\"\\x1f\\x19\\x02\\x01>\\x01=\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-08-08T00:00:00", "modifydate": "2000-08-08T19:02:00", "lines": 318, "newlines": 317, "modlines": 0, "user": "WSBG"}, "text": "Subject: Large tape block size\nDate: Mon, 7 Aug 2000 11:54:17 -0600\nFrom: \"Wayne Rhoten/IBM\"\nTo: sbgolob@attglobal.net\n\n                   Large Tape Block Size\n                   ----- ---- ----- ----\n\nDFA\n\nYou need to test the DFA only if you need to know of the availability\nof LBI (large block interface) before issuing an OPEN macro.  In\ngeneral that is not necessary.  The DCBE section below describes an\neasier way to adapt to the presence or lack of LBI support.  It will\nrun on any level of the system.\n\nTest the CVT word named CVTDFA for being non-zero.  If it is zero, you\nare running on a system that is prior to MVS/XA DFP 2.1.0, which was\ndelivered around 1985.  In fact on a very ancient system such as MVT,\nthe CVT might not be long enough.  You will have to figure how to know\nwhether the CVT is long enough.  According to the Release 21.7 edition\nof OS/360 System Control Blocks, the CVT was only X'114' bytes.  You\nwould want to test the byte at CVTDCB first.  The PCP bit in CVTDCB\nprobably means you are running on CMS on VM.\n\nCVTDFA is at offset X'4C0' and the older name was CVTCKRAS.  The field\nnever got used for the original purpose and had been zero for a number\nof years.  I think we set that word to point to the DFA before anyone\ngot around to defining the name CVTDFA.\n\nIf the CVT is long enough and CVTDFA is non-zero, then it points to\nthe DFA, data facilities area.\n\nThe DFA has always been at least X'30' bytes long.  In OS/390 2.10 in\nSeptember 2000, it was lengthened.  There is a two-byte length field.\nThe area is mapped by the IHADFA macro, which has been in SYS1.MACLIB\nsince DFP 2.1.0.  The IHADFA macro and its fields are documented in\nthe various incarnations of DFSMSdfp Advanced Services.\n\nIn DFSMS/MVS 1.1.0 the four-byte field DFARELS was added.  Prior to\nthat release it had always been four bytes of binary zeroes.  If\nDFARELS contains the value of X'02020A00' or greater, then you are on\nOS/390 DFSMS 2.10 or later.  The first byte being X'02' signifies that\nyou are running on a DFSMS level that came as an inseparable part of\nOS/390.  That is after the DFSMS/MVS product, which could still run\nwith MVS/ESA SP 5.2.2.  The other three bytes signify Version 2,\nRelease 10, Modification Level 0.\n\nIf you are running on OS/390 2.10 or later, then you know that BSAM,\nBPAM and QSAM support LBI on disk, tape, spooled, subsystem and dummy\ndata sets.\n\nDEVTYPE Macro\n\nAnother way to test before OPEN whether OPEN supports LBI for the data\nset is to issue the DEVTYPE macro.  It is documented in DFSMS Advanced\nServices.  Code the INFOLIST parameter on the DEVTYPE macro and point\nto another instance of the macro with INFO=AMCAP.  This is one form of\nDEVTYPE parameter list pointing to another form of parameter list.\nThe main parameter list has several variable fields, including the\naddress and length of the area to receive the information.  The\nreceiving area must be at least 32 bytes long.  You do not have to\ninitialize that area.  If you are running on any release of DFSMS/MVS,\nthe system is supposed to clear the 32 bytes to binary zeroes even if\nit does not know what to put in it.  In other words you can assemble\nINFO=AMCAP only on OS/390 2.10 or later but it should reliably set the\n32 bytes when running as early as DFSMS/MVS 1.1.0.  Unfortunately if\nyou execute DEVTYPE with the INFO parameter with any value on an\nearlier level of the system, it may fail.\n\nIn OS/390 R10 or later, DEVTYPE will set the 32 bytes as follows:\n\n ______________________________________________________________________\n| INFO=AMCAP 32-byte return data                                       |\n|______________________________________________________________________|\n| Offset     | Bytes     | Description                                 |\n|____________|___________|_____________________________________________|\n| 0(0)       | 1         | Flags.                                      |\n|____________|___________|_____________________________________________|\n| 0(0)       | 1... .... | BSAM, QSAM, and (if DASD) BPAM support the  |\n|            |           | large block interface and the block size    |\n|            |           | limit is in the next doubleword.            |\n|____________|___________|_____________________________________________|\n| 1(1)       | 7         | Reserved, currently set to zeros.           |\n|____________|___________|_____________________________________________|\n| 8(8)       | 8         | Maximum block size supported. If you        |\n|            |           | specify a DD name to DEVTYPE for a data set |\n|            |           | concatenation, this value is the largest    |\n|            |           | for any of the DDs.  On output, OPEN does   |\n|            |           | not allow a block size that exceeds this    |\n|            |           | value except with EXCP.  On certain         |\n|            |           | cartridge tape drives, exceeding this limit |\n|            |           | can cause bypassing of hardware buffering.  |\n|____________|___________|_____________________________________________|\n| 16(10)     | 8         | Recommended maximum block size.  This is    |\n|            |           | less than or equal to the maximum block     |\n|            |           | size supported.  Above this length the      |\n|            |           | device might be less efficient or less      |\n|            |           | reliable.  If you specify a DD name to      |\n|            |           | DEVTYPE for a data set concatenation, this  |\n|            |           | value is the largest for any of the DDs     |\n|            |           | (refer to the previous figure).  Consult    |\n|            |           | hadware documentation for further           |\n|            |           | information.                                |\n|____________|___________|_____________________________________________|\n| 24(18)     | 8         | Maximum unspanned logical record length     |\n|            |           | supported by BSAM, QSAM, or BPAM.  Various  |\n|            |           | types of data sets on the device might have |\n|            |           | various maximum record lengths.  Therefore, |\n|            |           | if UCBLIST was coded on DEVTYPE and not a   |\n|            |           | DD name, this value is the smallest for the |\n|            |           | possible data set types for BSAM, QSAM, and |\n|            |           | BPAM.                                       |\n|____________|___________|_____________________________________________|\n __________________________________________________________\n| Optimum and Maximum Block Size Supported.                |\n|__________________________________________________________|\n| Device Type  | Optimum                | Maximum          |\n|______________|________________________|__________________|\n| DASD         | Half track             | 32,760           |\n|______________|________________________|__________________|\n| Reel tape    | 32,760                 | 32,760           |\n|______________|________________________|__________________|\n| 3480, 3490   | 65,535                 | 65,535           |\n|______________|________________________|__________________|\n| 3590         | 262,144 (256 KB)       | 262,144 (256 KB) |\n|              | except on some older   |                  |\n|              | models on which it is  |                  |\n|              | 229,376 (224 KB)       |                  |\n|______________|________________________|__________________|\n| DUMMY        | 16                     | 5,000,000        |\n|______________|________________________|__________________|\n\nDCBE\nTo use LBI, your program must supply a DCBE macro with a certain bit\nset.\n\nCode the DCBE= parameter on the DCB macro to point to an instance of\nthe DCBE.  Note that the DCB must be below the 16 MB line but the DCBE\noptionally can be above the 16 MB line even if your program is running\nin AMODE 24.\n\nCode a DCBE macro with the BLKSIZE= parameter.  The DCBE macro was\nfirst shipped in DFSMS/MVS 1.1.0, which came out about 1993.  It did\nnot support the BLKSIZE macro until OS/390 DFSMS 2.10, which is\navailable in September 2000.  During that time all DCBE macros are the\nsame length.  The new fields were zero in prior releases.\n\nWhen you code DCBE= on the DCB macro, it causes the first word in the\nDCB to point to the indicated area and it causes two bits, named DCBH0\nand DCBH1 to be on.  They are at offset X'20' in the DCB in a byte\nnamed DCBHIAR, DCBBFALN and DCBBFTEK.  If you want your DCBE to be in\ndynamic storage, you do not have to code the DCBE= parameter.  Instead\nyour program can turn on these two bits and store the DCBE address in\nthe first DCB word, which is named DCBDCBE.  If either of the two bits\nis off, then the first DCB word has a meaning only for BPAM or when\nusing BSAM or QSAM to access a partitioned data set member.  In that\ncase the first DCB word is called DCBRELAD.  If both bits are on, then\nthe content and meaning of that old DCB word is defined in a DCBE word\ncalled DCBERELA.\n\n(Historical note: If either of DCBH0 or DCBH1 is on but not both, it\nmeans that the user has coded the obsolete HIARCHY parameter on the DCB\nmacro or on the DD statement.  The valid values are 0 and 1.  Probably\nJCL no longer accepts it.  HIARCHY=1 means that you are requesting that\nOPEN get access method buffers from hierarchy 1 storage, which was\nslower, cheaper memory.  It was in a separate box, called IBM Large\nCore Storage.  The memory was ferrite core.  The IBM product type\nnumber apparently was 2361 and it was obsolete by the early seventies.\nThis type of memory was never supported on any OS/VS1, OS/VS2 or later\nsystem.  Note that the concept of slower and faster, but not cheaper,\nmemory is an innovation of the NUMA-Q architecture, which uses Intel\nprocessors and is owned by IBM.)\n\nTo request LBI, large block interface, you must code BLKSIZE=nnnn on\nthe DCBE macro.  This causes the value that you code to be in a word\nin the DCBE expansion and a bit, DCBEULBI, to be on.  If you code\nBLKSIZE=0, the word will still be zero but the bit will be on to show\nthat you coded BLKSIZE and want LBI.\n\nBefore OPEN calls your optional DCB OPEN exit routine, it turns on\nanother bit, DCBESLBI, if the access method supports LBI for that data\nset.  OPEN turns off that bit if the access method does not suport LBI\nfor that data set.  At that time (in your DCB OPEN exit routine), the\nsetting of DCBESLBI has nothing to do with whether the user's bit\nDCBEULBI, is on.  At that time, its sole purpose is to tell the user's\nDCB OPEN exit routine whether the system supports LBI for that data\nset.  If DCBESLBI is off at that time, it means either that the data\nset does not support LBI or you are running on a down level system.\n\nThat downlevel system might not even have recognized the DCBE.  There\nis another DCBE bit that tells whether OPEN recognized the DCBE (and\nsupports AMODE 31).  It is DCBEMD31.  For most disk, tape, subsystem,\nspooled and dummy data sets, it has been turned on since DFSMS/MVS\n1.1.0.  This bit has been documented for this purpose since that\nrelease and the whole DCBE has been an intended programming interface\nbut its fields were not documented until DFSMS/MVS 1.5.  This was an\noversight.  The fields are described in Appendix A in DFSMS Macro\nInstructions for Data Sets.  For all OS/390 manuals, see\nhttp://www.s390.ibm.com/os390/bkserv and select a release.\n\nBefore OPEN calls the DCB OPEN exit routine, it does not care about the\nvalue of the DCBEULBI bit.  After the exit routine, OPEN tests DCBEULBI\nand it sets DCBESLBI for a new meaning.  If DCBEULBI is on and OPEN\nearlier turned on DCBESLBI, then OPEN leaves DCBESLBI on.  If DCBEULBI\nis off, OPEN turns DCBESLBI off.  That means that after the exit,\nDCBESLBI is a reliable means to learn whether (1) the user requested\nLBI and (2) the system supports LBI for this data set.  (Therefore LBI\nis in effect until CLOSE.)\n\nTape Label Changes\n\nThe following statement applies to the old, five-character block size\nfield in the IBM standard label 2: \"If the block length field contains\nzeros, then there is a large block interface block length.  See field\n17, Large Block Length.\"  This applies to the HDR2, EOV2 and EOF2\nlabels.\n\nThe last ten bytes of the same label previously were reserved and now\nare defined as this:\n\n17--Large Block Length (10 bytes)\n\nContents: A number that can be greater than 32760 that indicates the\nblock length, in bytes.  Interpretation of the number depends on the\nassociated record format in Field 3, as follows:\n\n   Format F - Maximum block length (must be a multiple of the logical\n   record length in Field 5).  If field 12 (which means \"blocked\")\n   contains a blank, then this field is also the minimum block length.\n\n   Format V - Maximum block length (including the 4-byte length field\n   in the blocks)\n\n   Format U - Maximum block length\n\nThe system can determine the optimum block size when creating tape\ndata sets. For more information see OS/390 DFSMS: Using Data Sets.\n\nProcessing: Used when field 4, the Block Length field, contains zeros.\nThe number in the label is converted to binary and merged with\nappropriate fields in the JFCB, SWA, DCB, and DCBE.  The merging\nprocess is the same as that for the record format code in field 3 of\nthis label.  If the maximum block length is 32760 or less, the OPEN\nand EOV routines write it in field 4 and not this field. On input, the\nOPEN and EOV routines accept small or large values in the Large Block\nLength field.\n\nSystem-Determined Block Size with LBI\n\nIf you are using LBI when you open a tape data set for output and you\ntake advantage of OPEN determining a block size, OPEN normally will\ncalculate a value that exceeds 32760 bytes.  This means that the\nreading program must be able to handle large blocks.  No program,\nexcept possibly for an EXCP program, can read such a tape on OS/390\nbefore 2.10.  There is no way for OPEN to know what programs or\noperating system will be used to read the tape.\n\nIf you want OPEN to determine the block size and you want to use LBI,\nhere are some considerations:\n\n?    You might assume that the user of the writing program will take\nadvantage of the new BLKSZLIM keyword on the DD statement (or dynamic\nallocation), to limit the block size.  The minimum value that the user\ncan code is 32760.  That value of 32760 also is the IBM-provided\nsystem default value for BLKSZLIM.  The system programmer can change\nthe system default by setting the TAPEBLKSZLIM keyword in the DEVSUPxx\nmember of SYS1.PARMLIB..  Coding BLKSZLIM=32760 will ensure the tape\nwill be readable by non-LBI programs.  Note that with fixed-length\nrecords the BLKSZLIM value does not have to be a multiple of LRECL.\nThis is because BLKSZLIM is only a limit on the BLKSIZE value that\nOPEN will calculate.  A reason that someone might want to limit block\nsize to less than the device maximum is that the user might want to\ncopy the tape to another device type without reblocking.  The other\ndevice might have a smaller block size limit.\n\n?    You might assume that the user of the program will code the\nBLKSIZE parameter to force an appropriate maximum block size for the\ndata set.  This requires the user to know the maximum block size\nsupported by the device.  If you code BLKSIZE, it overrides any value\nof BLKSZLIM for the same DD statement.  If the device does not support\nblocks as large as the coded BLKSIZE value, OPEN will issue an ABEND\nunless you are using EXCP, in which case the device might cause a\nproblem.  IBM recommends letting OPEN calculate a block size if\nfeasible.  It is not feasible with unlabelled tape and IBM also\nrecommends using IBM or ISO/ANSI labelled tape.  The latter type of\ntape does not support blocks longer than 32760 bytes.\n\n?    Instead of relying on the BLKSZLIM or BLKSIZE keywords, you might\nwant to implement an option for the program.  IEBGENER and ICEGENER\nhave such options.  The purpose of the option might be to tell the\nprogram whether to use LBI.  Note that calling the option something\n\"LBI=YES\" will not be meaningfull for most users.  You might want to\nchoose for your program to take advantage of the system-level default\nfor copying programs.  IEBGENER and ICEGENER do that.  They test a DFA\nfield that contains the system-level default for the SDB keyword for\nIEBGENER.  To prevent OPEN from calculating a block size that exceeds\n32760, the easiest way is not to request LBI.  In other words, do not\nturn on DCBEULBI.  These are the values in the DFA:\n\n ____________________________________________________________________\n|13(D) BITSTRING | DFAFEAT6 | FEATURES BYTE 6                        |\n|____|___________|__________|________________________________________|\n|    | 1111 .... | DFACPSDB | COPYSDB VALUE IN DEVSUPxx IN PARMLIB.  |\n|    |           |          | SYSTEM LEVEL DEFAULT FOR THE SDB OPTION|\n|    |           |          | OF IEBGENER AND OTHER COPYING PROGRAMS.|\n|____|___________|__________|________________________________________|\n|    | 0001 .... | DFACPSNO | COPYSDB = NO                           |\n|____|___________|__________|________________________________________|\n|    | 0010 .... | DFACPSYE | COPYSDB = YES                          |\n|____|___________|__________|________________________________________|\n|    | 0010 .... | DFACPSSM | COPYSDB = SMALL (SAME AS COPYSDB = YES)|\n|____|___________|__________|________________________________________|\n|    | 0011 .... | DFACPSIN | COPYSDB = INPUT                        |\n|____|___________|__________|________________________________________|\n|    | 0100 .... | DFACPSLA | COPYSDB = LARGE                        |\n|____|___________|__________|________________________________________|\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT475/FILE475.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT475", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}