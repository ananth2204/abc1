{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012255000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1293292, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE527.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE527.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x16\\x13'", "DS1TRBAL": "b'A\\xbe'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xe8\\x00\\x0b\\x03\\xea\\x00\\x03\\x00\\x17'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x053O\\x01\\x053O\\tI\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-30T00:00:00", "modifydate": "2005-11-30T09:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-470"}, "text": "REGULAR CBT TAPE - VERSION 470    FILE:  527\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT470.FILE527\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 63 MEMBERS COUNTED; CUMULATIVE SIZE IS 11,921 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/30/05    09:49:10    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00R\\x01\\x01 \\x0f\\x01\\x02\\x10\\x1f\\x10\\x08\\x00%\\x00\\x12\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2001-07-19T00:00:00", "modifydate": "2002-04-11T10:08:52", "lines": 37, "newlines": 18, "modlines": 0, "user": "MSTITT"}, "text": "***********************************************************************\nADRUENQ    --     DFDSS user exit to turn off VTOC enqueue\n                  for full volume dumps.\n                  Useful for DFHSM dumps of SYSRES, etc.\nANFUXBDA   --     InfoPrint Server begin dataset exit to generate\n                  separator pages that look like JES2.\nANFUXEDA   --     InfoPrint Server end dataset exit to generate\n                  separator pages that look like JES2.\nCOBALLOC   --     assembler subroutine to use dynamic allocation\n                  for sysout files.  Allows COBOL modifications to\n                  report files, etc.\nCOBALASM   --     Assembler jcl for COBALLOC.\nDADSM      --     Program to list every volume, dataset and\n                  give hlq counts.  Old CBT mods program updated\n                  for full 31-bit capability.\nDADSMASM   --     Assembler jcl for DADSM.\n                  Note -- full 31-bit code.\nG207DCAN   --     Date converter program.\n                  Has 38+ functions, date calculator functions\n                  for between two dates, forward/backward dating,\n                  can be used to skip weekends.\n                  Also works in MVS, VM, and VSE -- any language.\nG207DOCS   --     Copy of top of assembler code.\n                  Provides basic documentation on how to use it.\nG207ASM    --     Assembler jcl for G207DCAN.\n                  Note -- not re-entrant code.\nHSMMCA     --     HSM copy book\nHSMMCB     --     HSM copy book\nHSMMCD     --     HSM copy book\nHSMMCK     --     HSM copy book\nIEAVMXIT   --     An implementation of some of our message processing.\nLISTICAT   --     An upgrade to the LISTICAT program originally found\n                  on file 047.  This one has major changes to the\n                  report layout among other things.\nLISTIASM   --     Assembler jcl for LISTICAT.\nLISTIJCL   --     Sample jcl for running LISTICAT.\nUCBTYPES   --     Old UCB type code copy book/macro\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x12\\x01\\x02\\x07?\\x01\\x050\\x7f\\x17#\\x01\\xba\\x01R\\x00}\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-03-14T00:00:00", "modifydate": "2005-11-03T17:23:12", "lines": 442, "newlines": 338, "modlines": 125, "user": "MSTITT"}, "text": "         TITLE 'DISCLAIMER - INSTALLATION INSTRUCTIONS'\n***********************************************************************\n*                                                                     *\n*     THIS PROGRAM, DEVELOPED AT CONTINENTAL BANK OF CANADA OR        *\n*     SUPPLIED BY OTHER USERS ON A NON-RESTRICTIVE BASIS, IS OF       *\n*     GENERAL INTEREST AND IS SUBMITTED FOR UNRESTRICTED DISTRIBUTION.*\n*                                                                     *\n*     THE AUTHOR HAS, SINCE DEVELOPING THIS PROGRAM, MOVED TO SUNCOR  *\n*     INC.  USERS ARE INVITED TO SUBMIT SUGGESTIONS OR ERROR          *\n*     DOCUMENTATION TO SUNCOR.  HOWEVER, NO PROMISE CAN BE MADE THAT  *\n*     SUCH SUGGESTIONS WILL BE IMPLEMENTED OR ERRORS CORRECTED.       *\n*     SUBMIT COMMENTS TO:                                             *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*              JIM LANE                                               *\n*              TECHNICAL SUPPORT GROUP                                *\n*              SUNCOR INC.                                            *\n*              36 YORK MILLS RD                                       *\n*              TORONTO, ONTARIO M2P 2C5                               *\n*                                                                     *\n*                PHONE: (416)-733-7396                                *\n*                                                                     *\n*                SHARE INSTALLATION CODE: SNI                         *\n*                                                                     *\n*     THIS PROGRAM IS MADE AVAILABLE BY SUNCOR WITHOUT CHARGE OR      *\n*     CONSIDERATION.  RECIPIENTS ARE FREE TO MAKE THIS PROGRAM        *\n*     AVAILABLE TO OTHERS IN LIKE MANNER.  IT MAY NOT BE SOLD.        *\n*                                                                     *\n*                                                                     *\n* NAME         LISTICAT                                               *\n*                                                                     *\n* FUNCTION     LIST THE CONTENTS OF AN ICF CATALOG AND SELECTED       *\n*              DSCB AND VVDS FIELDS.                                  *\n*                                                                     *\n* DESCRIPTION  THE UCBS OF ALL ONLINE DASD VOLUMES ARE LOCATED AND    *\n*              AN ATTEMPT IS MADE TO ALLOCATE SYS1.VVDS.VVOLSER.  IF  *\n*              THIS WORKS AN ACB AND RPL ARE GENERATED AND THEIR      *\n*              ADDRESSES ARE SAVED IN A LOOKUP TABLE.  THE BCS        *\n*              CLUSTER IS OPENED AS A DATASET AND READ SEQUENTIALLY.  *\n*              THE BCS RECORDS ARE SCANNED FOR CELL TYPES AND THE     *\n*              FOLLOWING CELLS ARE LISTED:                            *\n*                                                                     *\n*                NONVSAM                                              *\n*                CLUSTER                                              *\n*                INDEX                                                *\n*                DATA                                                 *\n*                AIX                                                  *\n*                PATH                                                 *\n*                GDG BASE                                             *\n*                GDG ENTRY                                            *\n*                                                                     *\n*              FOR NONVSAM ENTRIES THE FORMAT1 AND, IF IT EXISTS THE  *\n*              FORMAT 3, DSCB IS \"OBTAINED\" TO DETERMINE IF THE       *\n*              OBJECT EXISTS. IF IT DOES THE LRECL, BLKSIZE AND TOTAL *\n*              TRACKS ALLOCATED ARE EXTRACTED.  IF THE OBJECT IS      *\n*              CATALOGUED TO VOLSER \"MIGRAT\" THE HSM                  *\n*              MIGRATIONCONTROLDATASET IS OPENED (SYSUT2) AND USED    *\n*              INSTEAD OF THE VTOC.                                   *\n*                                                                     *\n*              FOR DATA AND INDEX ENTRIES THE VVDS OF THE VOLUME IN   *\n*              QUESTION, IF AVAILABLE, IS SCANNED TO DETERMINE THE    *\n*              LRECL, BLKSIZE AND TRACK ALLOCATION OF THE OBJECT.     *\n*                                                                     *\n* ENVIRONMENT  OS/VS2 MVS, JDM1113 OR HDQ1102                         *\n*              MVS/XA 2.1.5 DF/HSM 2.1.0                           @122\n*              MVS/XA 2.1.7  DF/HSM 2.2.0 DFP/XA 2.2.0             @131\n*              MVS/XA 2.2.0  DF/HSM 2.3.1 DFP/XA 2.3.0             @132\n*              MVS/ESA 3.1.3 DF/HSM 2.6.0 DFP/XA 2.3.0\n*              MVS/ESA 4.2.2 DF/HSM 2.6.0 DFP/XA 2.3.0\n*              MVS/ESA 5.2.2 DF/HSM 1.1.0 DFSMS  1.1.0\n*              OS/390 1.2    DF/HSM 1.1.0 DFSMS  1.1.0             @210\n*              OS/390 2.10   DF/HSM 2.10  DFSMS  2.10              @211\n*              Z/OS   1.5    DF/HSM 1.5   DFSMS  1.5               @211\n*                                                                     *\n* INPUT        THE BCS OF THE ICF CATALOG TO BE LISTED.               *\n*                                                                     *\n* OUTPUT       OUTPUT CONSISTS OF A LISTING OF THE CATALOG.           *\n*                                                                     *\n*                                                                     *\n*                   DSNAME - THE NAME OF THE COMPONENT BEING LISTED.  *\n*                        FOR GDG ENTRIES THIS IS DEVELOPED INTO THE   *\n*                        FORMAT THAT WOULD BE IN A FORMAT1 DSCB.      *\n*                                                                     *\n*                   VOLUME - THE VOLSER OF THE VOLUME TO WHICH THE    *\n*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *\n*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *\n*                                                                     *\n*                   UNIT - THE NAME OF THE UNIT TO WHICH THE          *\n*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *\n*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *\n*                                                                     *\n*                   TYPE - THE TYPE OF THE ALLOCATION USED AT         *\n*                        CREATION.  NOT FILLED IN FOR TAPE ENTRIES.   *\n*                          CYL - CYLINDERS                            *\n*                          TRK - TRACKS                               *\n*                          BLK - BLOCKS                               *\n*                                                                     *\n*                   PRM  - THE AMOUNT OF PRIMARY SPACE REQUESTED      *\n*                        AT ALLOCATION TIME.  NOT FILLED IN FOR       *\n*                        TAPE ENTRIES.                                *\n*                                                                     *\n*                   SEC  - THE AMOUNT OF SECONDARY SPACE REQUESTED    *\n*                        AT ALLOCATION TIME.  NOT FILLED IN FOR       *\n*                        TAPE ENTRIES.                                *\n*                                                                     *\n*                   EXT  - THE NUMBER OF EXTENTS THE ENTRY OCCUPIES   *\n*                        ON EACH VOLUME.  NOT FILLED IN FOR TAPE      *\n*                        ENTRIES.                                     *\n*                                                                     *\n*                   TRACK - THE NUMBER OF TRACKS ALLOCATED TO A DASD  *\n*                        RESIDENT OBJECT. LEFT BLANK FOR CATALOGED,   *\n*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *\n*                                                                     *\n*                   USD  - THE PERCENTAGE OF THE TOTAL SPACE          *\n*                        ALLOCATED WHICH CONTAINS DATA.               *\n*                                                                     *\n*                   TYPE - THE TYPE OF THE CELL BEING LISTED.         *\n*                          AIX - ALTERNATE INDEX                      *\n*                          PTH - ALTERNATE PATH ENTRY                 *\n*                          CLS - CLUSTER NAME                         *\n*                          DAT - CLUSTER/AIX DATA COMPONENT           *\n*                          IDX - CLUSTER/AIX INDEX COMPONENT          *\n*                          GDB - GDG BASE DEFINITION                  *\n*                          GDG - GDG ENTRY                            *\n*                                                                     *\n*                   DATE CREATED - THE CREATION DATE OF THE OBJECT.   *\n*                                                                     *\n*                   DATE EXPIRES - THE EXPIRATION DATE OF THE OBJECT. *\n*                                                                     *\n*                   NUM RECORDS -  THE NUMBER OF RECORDS/BLOCKS IN    *\n*                        THE DATASET.                                 *\n*                                                                     *\n*                   AVG - THE AVERAGE RECORD LENGTH OF THE OBJECT.    *\n*                                                                     *\n*                   MAX - THE MAXIMUM RECORD LENGTH OF THE OBJECT.    *\n*                        LEFT BLANK FOR TAPE-RESIDENT OBJECTS.        *\n*                                                                     *\n*                   CI SIZE -  THE CONTROL INTERVAL SIZE OF THE       *\n*                        OBJECT.                                      *\n*                                                                     *\n*                   KEY LEN -  THE LENGHT OF THE KEY TO THE RECORD    *\n*                        IF THIS IS A KSDS OR AIX OBJECT.             *\n*                                                                     *\n*                   CI SPLITS - THE NUMBER OF CI SPLITS SINCE THE     *\n*                        OBJECT WAS LAST CREATED.                     *\n*                                                                     *\n*                   CA SPLITS - THE NUMBER OF CA SPLITS SINCE THE     *\n*                        OBJECT WAS LAST CREATED.                     *\n*                                                                     *\n*                   SHR OPTS - THE SHARE OPTIONS SPECIFIED WHEN THE   *\n*                        OBJECT WAS LAST CREATED.                     *\n*                                                                     *\n*                   CI FSPC - THE FREE SPACE PERCENTAGE SPECIFIED     *\n*                        FOR THE CONTROL INTERVALS WHEN THE OBJECT    *\n*                        WAS LAST CREATED.                            *\n*                                                                     *\n*                   CA FSPC - THE FREE SPACE PERCENTAGE SPECIFIED     *\n*                        FOR THE CONTROL AREA WHEN THE OBJECT         *\n*                        WAS LAST CREATED.                            *\n*                                                                     *\n*                   ACCESS DATE - THE LAST REFERENCED DATE OF THE     *\n*                        OBJECT.                                      *\n*                                                                     *\n*                                                                     *\n* CONSIDERATIONS                                                      *\n*                                                                     *\n*              ABEND CODES:                                           *\n*                                                                     *\n*                   U0014 - BCS CLUSTER FAILED TO OPEN.               *\n*                        ERROR CODE IN REGISTER 2.                    *\n*                                                                     *\n*                   U0015 - BCS GET FAILED.                           *\n*                                                                     *\n*                   U0256 - VVDS TABLE OVERFLOW                    @131\n*                                                                     *\n* PARAMETER    DSN PREFIX   PRODUCES A LISTING OF ONLY THE DATASETS   *\n*                           WHICH START WITH THAT PREFIX.             *\n*                                                                     *\n* SYSIN        HEXPRINT     PRODUCES A HEX-TRANSLATED LISTING OF      *\n*                           BCS AND VVDS CELLS.                       *\n*          (NO)LEVEL        PRODUCES A LISTING OF THE CATALOG ENTRIES *\n*                           WITH(OUT) THE LEVEL YOU SPECIFY.          *\n*          (NO)VOLUME       PRODUCES A LISTING OF THE CATALOG ENTRIES *\n*                           WITH(OUT) THE VOLUME YOU SPECIFY.         *\n*          (NO)TAPE.        PRODUCES A LISTING OF THE CATALOG ENTRIES *\n*                           WITH(OUT) TAPE FILES ONLY.                *\n*          (NO)DASD.        PRODUCES A LISTING OF THE CATALOG ENTRIES *\n*                           WITH(OUT) DASD FILES ONLY.                *\n*         (NOT)CONTAINING   PRODUCES A LISTING OF THE CATALOG ENTRIES *\n*                           WITH(OUT) SPECIFIED CHARACTER STRINGS.    *\n*         (NOT)ENDING       PRODUCES A LISTING OF THE CATALOG ENTRIES *\n*                           WITH(OUT) SPECIFIED CHARACTER STRINGS AT  *\n*                           THE END OF THE DATASET NAME.              *\n*              BREAKLEVEL   PRODUCES A LISTING OF THE CATALOG ENTRIES *\n*                           WITH PAGE BREAK AT EACH HIGH LEVEL        *\n*                           QUALIFIER.                                *\n*                                                                     *\n*       NOTE ===>           AT THIS TIME ONLY THE (NO)LEVEL AND       *\n*                           THE (NO)VOLUME PARAMETERS ARE FUNCTIONAL. *\n*                                                                     *\n* EXECUTION    DDNAMES                                                *\n*                                                                     *\n*              SYSUT1   DEFINES THE ICF CATALOG TO BE LISTED.         *\n*                                                                     *\n*              SYSUT2   DEFINES THE HSM MIGRATIONCONTROLDATASET.      *\n*                       IF YOU DON'T HAVE HSM THIS CAN BE LEFT OUT.   *\n*                                                                     *\n*              SYSPRINT DEFINES THE OUTPUT LISTING DATA SET.          *\n*                                                                     *\n*              SYSLIST  DEFINES THE MESSAGES LISTING DATA SET.        *\n*                                                                     *\n* EXAMPLE                                                             *\n*                                                                     *\n*              //LCAT   EXEC  PGM=LISTICAT(,'QUAL1.QUAL2.....')       *\n*              //SYSLIST  DD  SYSOUT=*                                *\n*              //SYSPRINT DD  SYSOUT=*                                *\n*              //SYSUT1   DD  DSN=ICF.CATALOG,DISP=OLD                *\n*              //SYSUT2   DD  DSN=HSM.MCDS,DISP=OLD                   *\n*              //SYSUDUMP DD  SYSOUT=*                                *\n*              //SYSIN    DD  *  ======> ONLY IF PARAMETERS GIVEN     *\n*                                                                     *\n* NON-IBM MACROS USED (IN MAINLINE OR SUBROUTINES)                    *\n*              $EPILOG  - MAIN EXIT LINKAGE                           *\n*              $IN      - SUBROUTINE ENTRY LINKAGE                    *\n*              $OUT     - SUBROUTINE EXIT LINKAGE                     *\n*              $PROLOG  - MAIN ENTRY LINKAGE                          *\n*              $REGS    - REGISTER EQUATES                            *\n*              ALLOC    - DYNAMIC ALLOCATION                          *\n*              DYNSPACE - GENERATE PARMLIST FOR ALLOC                 *\n*              EDIT     - FORMAT A DISPLAY NUMERIC FIELD              *\n*              HEX      - CONVERT HEX TO PRINTABLE                    *\n*              XPRCLOSE - CLOSE A PRINT FILE                          *\n*              XPRDCB   - DEFINE A PRINT FILE                         *\n*              XPRHEAD  - DEFINE A REPORT HEADING                     *\n*              XPRLDEF  - DEFINE A REPORT LINE LAYOUT                 *\n*              XPRNTLIN - PRINT A REPORT LINE                         *\n*              XPROPEN  - OPEN A PRINT FILE                           *\n*                                                                     *\n* IBM MACROS USED  (IN MAINLINE OR SUBROUTINES)                       *\n*              ABEND    - ABNORMAL TERMINATION.                       *\n*              ACB      - DEFINE AN ACB                               *\n*              CAMLST   - DEFINE A PARMLIST FOR OBTAIN                *\n*              CLOSE    -                                             *\n*              DCB      - DEFINE A DCB                                *\n*              EXLST    - DEFINE AN EXIT LIST FOR EOF                 *\n*              FREEPOOL - FREE BUFFERS                                *\n*              GENCB    - GENERATE A VSAM CONTROL BLOCK               *\n*              GET      - READ A VSAM LOGICAL RECORD                  *\n*              GETMAIN  - ALLOCATE VIRTUAL STORAGE                    *\n*              IEFUCBOB - MAP A UCB                                   *\n*              IEFZB4D0 - DYNALLOC DATA AREAS                         *\n*              IEFZB4D2 - DYNALLOC DATA AREAS                         *\n*              IEZJSCB  - MAP MY JOBSTEP CONTROL BLOCK                *\n*              IKJTCB   - MAP MY TCB                                  *\n*              MODESET  - GET INTO AND OUT OF SUPR STATE/KEY 0        *\n*              OBTAIN   - READ A DSCB                                 *\n*              OPEN     -                                             *\n*              POINT    - ESTABLISH POSITIONING WITHIN A VSAM FILE    *\n*              SHOWCB   - PICK VSAM ERROR CODES.                      *\n*              SYNADAF  - DIAGNOSE A NON-VSAM I/O ERROR               *\n*              SYNADRLS - RELEASE SYNADAF WORKAREAS                   *\n*              TIME                                                   *\n*              WTO      - GIVE OPER THE BAD NEWS.                     *\n*                                                                     *\n* AUTHOR       THE PORTIONS OF THIS PROGRAM HAVING TO DO WITH         *\n*              PASSING THE BCS AND VVDS'S WERE WRITTEN BY J. LANE AT  *\n*              CBOC. A LOT OF THE REST OF THE CODE HAS BEEN BORROWED  *\n*              FROM VARIOUS SOURCES, MOSTLY OFF THE CBT TAPE. IF      *\n*              SOMETHING IN HERE LOOKS FAMILIAR, IT'S PROBABLY        *\n*              BECAUSE YOU WROTE IT!                                  *\n*                                                                     *\n* REGISTER USAGE                                                      *\n*                                                                     *\n*              R0  - WORK REGISTER.                                   *\n*              R1  - WORK REGISTER.                                   *\n*              R2  - WORK REGISTER.                                @122\n*              R3  - ADDRESS OF CURRENT BCS CELL.                  @122\n*              R4  - BASE ADDRESS OF DATASECT.                        *\n*              R5  - WORK REGISTER.                                   *\n*              R6  - ADDRESS OF CURRENT VVDS CELL.                    *\n*              R7  - WORK REGISTER.                                   *\n*              R8  - WORK REGISTER.                                   *\n*              R9  - SUBROUTINE LINKAGE.                              *\n*              R10 - PROGRAM BASE REGISTER 1                          *\n*              R11 - PROGRAM BASE REGISTER 2                          *\n*              R12 - PROGRAM BASE REGISTER 3                          *\n*              R13 - SAVE AREA ADDRESS                                *\n*              R14 - LINKAGE                                          *\n*              R15 - LINKAGE                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*                                                                     *\n* NOTES  A PROGRAM MUST BE APF-AUTHORIZED IN MVS TO OPEN A CATALOG    *\n*        AS A DATASET.                                                *\n*                                                                     *\n*        AT THE BANK I WAS GETTING PASSWORD PROMPTS WHEN I OPENED THE *\n*        CATALOG. RATHER THAN FIGURE OUT WHY I TURNED ON THE          *\n*        \"NO-PASSWORD\" BIT IN THE JSCB. THIS MAY NOT BE NECESSARY IN  *\n*        YOUR ENVIRONMENT AND, IF SO, YOU CAN TAKE OUT THE LOGIC.     *\n*                                                                     *\n*        THE HEX-DUMP LISTING CAN BE A SECURITY EXPOSURE AS WRITTEN   *\n*        BECAUSE IT PRINTS OUT THE \"SECURITY\" CELL, IF PRESENT, WHICH *\n*        CONTAINS THE PASSWORDS FOR PROTECTED OBJECTS. SECURITY       *\n*        OFFICERS MAY NOT TAKE THAT IN THE NICEST SORT OF WAY!        *\n*                                                                     *\n*        NO ATTEMPT IS MADE TO DISCERN WHETHER SYSUT1 IS ACTUALLY AN  *\n*        ICFCATALOG OR NOT. IF, INADVERTENTLY, IT ISN'T THIS CODE     *\n*        WILL PROBABLY DO SOME VERY STRANGE UNPREDICTABLE THINGS.     *\n*                                                                     *\n*        I WROTE THIS CODE IN THE WINTER OF 1983-1984 WHEN CBOC WAS   *\n*        CONVERTING TO ICF CATALOGS. SINCE THE CONVERSION WENT MORE   *\n*        SMOOTHLY THAN IT MIGHT HAVE DONE, I NEVER HAD A BROKEN       *\n*        CATALOG TO WORK WITH. THEREFORE, THIS CODE ASSUMES A VALIDLY *\n*        STRUCTURED CATALOG. I MAKE NO GUARANTEES WHAT MIGHT HAPPEN   *\n*        OTHERWISE.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*                                                                     *\n* CHANGE ACTIVITY SUMMARY:                                            *\n*                                                                     *\n*    @216    - FIXED PRINT ROUTINES PARAMETERS TO ADD A DUMMY FINAL   *\n*              ENTRY.  UNDER 31-BIT ADDRESSING THE FIRST LINE OF      *\n*              REPORT HEADING WOULD BE GARBAGE.                       *\n*            - LISTICAT NOW ASSEMBLES AS 31-BIT ADDRESSABLE.          *\n*    @215    - FIXED INVALID DEVICE TYPE TO HILITE ENTRY              *\n*            - CORRECTED INVALID ENTRY COUNTS                         *\n*            - CORRECTED COMMENT FOR INVALID ENTRY COUNTER            *\n*    @214    - FIXED SYMBOLIC OF ****** IN VOLUME NAME TO BECOME      *\n*              DEFAULT OF &SYSR1.                                     *\n*            - RECODED VTOC SUBROUTINE TO RESOLVE ISSUE OF DATE       *\n*              CONVERSIONS WHEN DATE IS LOADED AS 99.999              *\n*            - UPDATE COMMENTS TO SHOW SUPPORT OF Z/OS UP TO 1.5      *\n*    @213    - ADDED MISSING SHAREOPTIONS TO REPORT.                  *\n*            - CORRECTED DEVICE TYPE LENGTH ON REPORT.                *\n*    @212    - ADDED THE CURRENT DEVICE TYPE CODES.                   *\n*            - UPDATE COMMENTS TO SHOW SUPPORT OF OS/390 2.10         *\n*    @211    - MODIFIED THE DATE REPORTING STRUCTURE TO DISPLAY       *\n*              MORE ACCURATE INFORMATION AND LAST REFERENCED DATE     *\n*              FIXED THE PARM INPUT FOR MULTI-LEVEL REQUESTS          *\n*    @210    - COMPLETELY CHANGED THE REPORT STRUCTURE TO DISPLAY     *\n*              MORE INFORMATION.                                      *\n*            - CLEANED UP A FEW REGISTER USAGES PERTAINING TO THE     *\n*              DATASECT MODULE ADDRESSABILITY.                        *\n*            - ELIMINATED THE OPENING OF THE VVDS EXCEPT WHEN         *\n*              NEEDED FOR THE DATASET INFORMATION.                    *\n*            - ADDED CAPABILITY TO CORRECTLY DISPLAY MULTI-VOLUME     *\n*              DATASET INFORMATION.                                   *\n*            - UPDATE COMMENT SECTION TO SHOW SUPPORT OF              *\n*              OS/390 AND DFSMSHSM.                                   *\n*            - ADDED ADDITIONAL DEVICE TYPES                          *\n*                                                                     *\n*    @134    - REMOVE CODE FROM MAINLINE TO SUBROUTINES TO            *\n*              MAINTAIN ADDRESSABILITY. WAS GETTING CLOSE TO USING    *\n*              UP 3 BASE REGISTERS.                                   *\n*            - FIX BUG. PERCENT FREE SPACE CALC FOR VSAM WAS BOGUS    *\n*            - ADD DEVICE TYPE FOR 3480 IDRC CARTRIDGE.               *\n*            - PRINT >>> IF MORE THAN 999 CI SPLITS.                  *\n*            - UPDATE COMMENT SECTION TO SHOW SUPPORT OF              *\n*              MVS/ESA 3.1.3 AND DFHSM 2.6.0                          *\n*                                                                     *\n*    @AVV    - OPENING A VVDS REQUIRES AUTHORIZATION.                 *\n*            - FIX BUG. LOOP WHEN ZERO LENGTH (?) CELL FOUND.         *\n*                                                                     *\n*    @132    - FIX LOOP IN FINDVVDS ROUTINE.                          *\n*            - UPDATE COMMENT SECTION TO SHOWN SUPPORT OF DFP/XA V2.3 *\n*                                                                     *\n*    @131    - INCREASE MAXIMUM NUMBER OF VVDS'S SUPPORTED TO 256.    *\n*              ADD DIAGNOSTIC CHECKING TO DETECT AN OVERFLOW OF THAT  *\n*              LIMIT. THIS CAUSES MESSAGE 9 AND A USER ABEND.  THAT   *\n*              CONSTITUTES THE FIX TO A PROBLEM REPORTED BY SAM RENAUD*\n*              OF CORRIDAN JEWELLERS. THE PROGRAM USED TO HANDLE 32   *\n*              VVDS'S AND ABEND0C4 AFTER THAT.\n*            - UPDATE COMMENT SECTION TO SHOWN SUPPORT OF DFP/XA V2.  *\n*                                                                     *\n*    @130    - PRINT OUT EXTRA DATA FIELDS FOR VSAM OBJECTS: CI AND CA*\n*              SPLITS, BUFFERSPACE, CI AND CA FREESPACE, NUMBER OF    *\n*              EXTENTS AND PERCENT USED.                              *\n*            - PRODUCE MESSAGE IDENTIFYING DATASETS CATALOGUED THAT   *\n*              AREN'T ON THE VOLUME IN QUESTION.                      *\n*                                                                     *\n*    @122    - ADDED EXTRA DIAGNOSTIC CHECKING AND MESSAGES TO HANDLE *\n*              PROBLEM REPORTED BY R. DIETES OF H.E. BUTT GROCERY CO. *\n*              SITUATION WAS THE CASE WHERE THE BCS INFO EXISTS, THE  *\n*              VVDS EXISTS BUT IT DOESN'T CONTAIN ANYTHING TO MATCH   *\n*              THE DATASET FOUND IN THE BCS.  FIX WAS TO SENSE END OF *\n*              FILE REACHED WHILE SCANNING THE VVDS FOR THE VVR OF A  *\n*              CLUSTER COMPONENT, PRODUCE MESSAGE ABOUT VVR NOT FOUND *\n*              WHEN EXPECTED AND PASS A RETURN CODE TO THE CALLER.    *\n*            - ADD 3480 DEVICE TYPE SUPPORT.                          *\n*            - TEST HSM LOGIC WITH DFHSM 2.1.0                        *\n*            - CLOSE MCDS AT EOJ IF IT WAS OPENED.                    *\n*                                                                     *\n*    @121    - WAS ASSUMING AN 8-CHARACTER CATALOG NAME FOR THE TITLE *\n*              LINE. OOPS!                                            *\n*                                                                     *\n*    15JAN88 - DEUTZ-ALLIS MODIFICATION TO PROVIDE THE ABILITY TO LIST*\n*              ONLY THOSE ENTRIES THAT MATCH THE PARTIAL DATASET NAME *\n*              GIVEN IN A JCL PARM.   IT MATCHES COLUMN FOR COLUMN TO *\n*              THE DATASET NAME. TOTAL FIELDS ARE ADJUSTED.           *\n*                                                                     *\n*    13JAN88 - DEUTZ-ALLIS MODIFICATION TO PRINT OUT ALL THE VOLUME   *\n*              CELLS FOR NONVSAM, DATA, INDEX AND GDGENT CELLS.   THE *\n*              ORIGINAL VERSION IGNORED ALL BUT THE FIRST VOLUME CELL *\n*              WHICH THEN PRINTED ONLY THE FIRST VOLUME ON THE LIST.  *\n*                                                                     *\n*    09DEC87 - DEUTZ-ALLIS MODIFICATION ADDED TO PRINT A \"+\" BEFORE   *\n*              THE DATA SET TYPE FIELD ON GDG BASE RECORDS THAT       *\n*              CURRENTLY HAVE NO GDG ENTRY RECORDS                    *\n*                                                                     *\n*    30NOV87 - DEUTZ-ALLIS MODIFICATION ADDED TO PRINT AN \"*\" BEFORE  *\n*              THE DATA SET TYPE FIELD ON NON-VSAM DATASETS IF THE    *\n*              DATASET IS CATALOGED BUT NO FOUND ON THE PACK TO WHICH *\n*              THE CATALOG POINTS.                                    *\n*                                                                     *\n*    16DEC86 - DEUTZ-ALLIS MODIFICATION ADDED TO READ THE GDG AGING   *\n*              (ICF CATALOG) RECORD AND PRINT THE MAXIMUM GDG'S,      *\n*              SCRATCH/NOSCRATCH AND EMPTY/NOEMPTY GDG ATTRIBUTES.    *\n*              MODIFICATION MADE BY J. RAUSCH.  A CHANGE WAS ALSO MADE*\n*              TO HANDLE A 12 POSITION CATALOG NAME (I.E.             *\n*              \"ICAT.VPROCPK\").                                       *\n*                                                                     *\n*    @120    - CHANGES FOR MVS/XA. USE SCAN ROUTINE INSTEAD OF UCB    *\n*              HALF-WORD LOOKUP TABLE.                                *\n*            - LENGTHEN PRINTLINE AREA USED FOR PRINTING TOTALS TO    *\n*              CORRECT FORMATTING PROBLEM.                            *\n*            - BREAK OUT SOME PARTS OF THE CODE INTO COPY MEMBERS TO  *\n*              MAKE IT MORE EDITABLE.                                 *\n*            - AN RPL WAS NOT BEING CREATED PRIOR TO I/O IN THE       *\n*              HEX-PRINT PART OF THE LOGIC.                           *\n*            - ADD CELL TYPE COUNTING TO HEX LOGIC.                   *\n*                                                                     *\n*    24APR85 - BUGS FOUND AFTER AUTHOR'S MOVE TO MANULIFE.            *\n*            . 3380 MISSING FROM DEVICE TYPE TABLE.                   *\n*            . DONT BE SO SURE I KNOW HOW MANY TRACKS THERE ARE IN A  *\n*              CYLINDER. AT CBOC I HAD ONLY 3375'S.                   *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EDITP": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)\\x8f\\x00\\x95)\\x8f\\x13Y\\x00\\x89\\x00\\x89\\x00\\x00\\xd4\\xe5\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "1995-10-25T13:59:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "MVS"}, "text": "         MACRO\n&NAME    $EDITP  &PR,&NUM,&ED\n         LCLA  &A1,&A2,&A3,&A4\n         LCLB  &B1,&B2\n         LCLC  &C1,&C2,&C3\n         ACTR  200\n         AIF   (N'&SYSLIST EQ 2 AND K'&ED EQ 0).ANOP1\n         AIF   (N'&SYSLIST NE 3).MNOTE1\n         AIF   ('&ED'(1,1) EQ '-' OR '&ED'(1,1) EQ '$').EDMK\n.ANOP1   ANOP\n&A1      SETA  &A1+1\n         AIF   (K'&ED LT &A1).CONT\n&A2      SETA  &A2+1\n&A4      SETA  &A4+1\n         AIF   ('&ED'(&A1,1) NE 'Z' AND '&ED'(&A1,1) NE '&C2').NINE\n.ANOP2   ANOP\n&C1      SETC  '&C1.20'\n         AGO   .ANOP1\n.NINE    AIF   ('&ED'(&A1,1) NE '9').PER\n         AIF   (&B1).ANOP2\n&B1      SETB  1\n         AIF   (&A1 EQ 1).SIGNIF\n         AIF   (&A1 EQ 2 AND &B2).SIGNIF\n&C3      SETC  '&C1'(&A4*2-3,2)\n         AIF   ('&C3' NE '20').NINE2\n&C1      SETC  '&C1'(1,&A4*2-4).'2120'\n         AGO   .ANOP1\n.NINE2   ANOP\n&C1      SETC  '&C1'(1,&A4*2-6).'21&C3.20'\n         AGO   .ANOP1\n.SIGNIF  ANOP\n&C1      SETC  '21'\n         AGO   .ANOP1\n.PER     AIF   ('&ED'(&A1,1) NE '.').COMMA\n&C1      SETC  '&C1.4B'\n&A2      SETA  &A2-1\n         AGO   .ANOP1\n.COMMA   AIF   ('&ED'(&A1,1) NE 'V').SLASH\n&C1      SETC  '&C1.6B'\n&A2      SETA  &A2-1\n         AGO   .ANOP1\n.SLASH   AIF   ('&ED'(&A1,1) NE '/').DBCR\n&C1      SETC  '&C1.61'\n&A2      SETA  &A2-1\n         AGO   .ANOP1\n.DBCR    AIF   (&A1+1 NE K'&ED).MNOTE2\n         AIF   ('&ED'(&A1,2) NE 'CR').DB\n&C1      SETC  '&C1.C3D9'\n&A2      SETA  &A2-1\n         AGO   .CONT\n.DB      AIF   ('&ED'(&A1,2) NE 'DB').MNOTE2\n&C1      SETC  '&C1.C4C2'\n&A2      SETA  &A2-1\n.CONT    ANOP\n&C3      SETC  '&PR'\n         AIF   (L'&NUM*2-1 NE &A2).EDSIZE\n.ENDCHEC ANOP\n&A2      SETA  0\n         AIF   (K'&C1/2+1 NE L'&PR).AREASIZ\n.LAST    AIF   (&B2).EDMKEND\n&NAME    MVC   &C3,=X'40&C1'\n         ED    &C3,&NUM\n         MEXIT\n.EDSIZE  AIF   (L'&NUM*2-1 LT &A2).LONG\n.SHORT   ANOP\n&C1      SETC  '20&C1'\n&A3      SETA  &A3+1\n         AIF   (L'&NUM*2-1 GT &A2+&A3).SHORT\n         AGO   .ENDCHEC\n.LONG    ANOP\n&C1      SETC  '&C1'(3,K'&C1-2)\n&A3      SETA  &A3+1\n         AIF   (L'&NUM*2-1 LT &A2-&A3).LONG\n         AGO   .ENDCHEC\n.AREASIZ AIF   (K'&C1/2+1 LT L'&PR).LESS\n&A2      SETA  K'&C1/2+1-L'&PR\n&A3      SETA  K'&C1/2+1\n&C3      SETC  '&C3-&A2.(&A3)'\n&B1      SETB  1\n         AGO   .LAST\n.LESS    ANOP\n&B1      SETB  0\n&A3      SETA  K'&C1/2+1\n         AIF   (K'&C1/2+5 GE L'&PR).PLUSET\n&C3      SETC  '&C3.(&A3)'\n         AGO   .LAST\n.PLUSET  ANOP\n&A2      SETA  L'&PR-K'&C1/2-1\n&C3      SETC  '&C3+&A2.(&A3)'\n         AGO   .LAST\n.EDMK    AIF   ('&ED'(1,1) EQ '-').NEG\n&C2      SETC  '$'\n         AGO   .C2SET\n.NEG     ANOP\n&C2      SETC  '-'\n.C2SET   ANOP\n&A1      SETA  1\n&B2      SETB  1\n         AGO   .ANOP1\n.EDMKEND ANOP\n&A1      SETA  -1\n.EDMKNOP ANOP\n&A1      SETA  &A1+2\n         AIF   (K'&C1 LT &A1).SETA\n         AIF   ('&C1'(&A1,2) EQ '21').SETAA\n         AIF   ('&C1'(&A1,2) NE '4B').EDMKNOP\n&A1      SETA  (&A1+1)/2\n         AGO   .LA\n.SETA    ANOP\n&A1      SETA  (&A1+1)/2-1\n         AGO   .LA\n.SETAA   ANOP\n&A1      SETA  (&A1+1)/2+1\n.LA      ANOP\n         AIF   (&B1).MINUS\n&A1      SETA  &A1+&A2\n         AGO   .MVC\n.MINUS   ANOP\n&A1      SETA  &A1-&A2\n.MVC     ANOP\n&NAME    MVC   &C3,=X'40&C1'\n         LA    1,&PR+&A1\n         EDMK  &C3,&NUM\n         AIF   ('&C2' EQ '$').DOLLAR\n         BNM   EDIT&SYSNDX\n         BCTR  1,0\n         MVI   0(1),C'-'\n&C3      SETC  '&SYSNDX'\nEDIT&C3  EQU   *\n         MEXIT\n.DOLLAR  BCTR  1,0\n         MVI   0(1),C'$'\n         MEXIT\n.MNOTE1  MNOTE 8,'THREE OPERANDS MUST BE SPECIFIED'\n         MEXIT\n.MNOTE2  MNOTE 8,'INVALID EDIT PATTERN'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$EPILOG": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $EPILOG &RC\n&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS\n         L     R13,4(R13)          GET BACK CHAIN POINTER\n         L     R0,16(R13)          GET SAVEAREA LENGTH\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         AIF   (T'&RC EQ 'O').SPEC\n         LA    R15,&RC             SET RETURN CODE\n.SPEC    ANOP\n         L     R15,16(R13)         RESTORE RETURN CODE\n         BR    R14                 RETURN TO CALLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IN": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $IN   &REG1=R14,&REG2=R15,&DEPTH=DEPTH,                       X\n               &ENTRIES=ENTRIES,&EXITS=EXITS,&LREG=R9\n         AIF   (T'&LABEL EQ 'O').ERR1   MUST HAVE A LABEL\n&LABEL   DS    0H\n         LA    &REG1,&LABEL             GET SUBROUTINE ENTRY ADDR\n         L     &REG2,&DEPTH             GET CURRENT NESTING DEPTH\n         ST    &REG1,&ENTRIES.(&REG2)   SAVE ENTRY ADDR IN ENTRY TABLE\n         ST    &LREG,&EXITS.(&REG2)     SAVE RETURN ADDR\n         LA    &REG2,4(0,&REG2)         UPDATE NESTING FOR NEXT CALL\n         ST    &REG2,&DEPTH              AND SAVE IT...\n         AGO   .MEND\n.ERR1    MNOTE 8,'$IN MUST BE LABELLED'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MESSAGE": {"ttr": 775, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB    $MESSAGE &MSGNO,&SKIP=0,&DATA=\n         AIF   (T'&DATA EQ 'O').NODATA\n         LA    R2,&DATA\n.NODATA  ANOP\n         LM    R15,R1,=A(MESGRTN,&SKIP,&MSGNO)\n         BALR  R14,R15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$OUT": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $OUT  &REG1=R14,&DEPTH=DEPTH,                                 X\n               &EXITS=EXITS,&LREG=R9\n&LABEL   DS    0H\n         L     &REG1,&DEPTH             GET CURRENT NESTING DEPTH\n         S     &REG1,=F'4'              BACKUP TO OUR CALLER\n         ST    &REG1,&DEPTH             AND SAVE NEW DEPTH\n         L     &LREG,&EXITS.(&REG1)     PICK UP OUR RETURN ADDR\n         BR    &LREG                    AND GO THERE.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PROLOG": {"ttr": 779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   $PROLOG &LV=0\n.**********************************************************************\n.*\n.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY\n.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD\n.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE\n.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS\n.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:\n.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE\n.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE\n.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA\n.*                                             REG 10 IS BASE\n.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES\n.*\n.**********************************************************************\n         LCLA  &AA,&AB,&AC\n         GBLB  &PRORG\n&AC      SETA  4096\n&LABEL   CSECT\n         B     32(R15)             BRANCH AROUND\n         DC    AL1(26)\n         DC    CL8'&LABEL'         CSECT NAME\n         DC    C'-'\n         DC    CL8'&SYSDATE'       COMPILE DATE\n         DC    C'-'\n         DC    CL8'&SYSTIME'       COMPILE TIME\n         CNOP  0,4                 ALIGNMENT\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REG\n         USING &LABEL,R12          INFORM ASSEMBLER\n         AIF   (&LV GT 4023).MERR\n         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE\n         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER\n         AIF   (&LV+72 LE 256).XC2\n         AIF   (&LV+72 LE 512).XC1\n         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE\n         LR    R2,R1               SAVE POINTER IN EVEN REG\n         LA    R4,1(R1)            SET RECEIVING POINTER\n         LR    R5,R0               SET RECEIVING LENGTH\n         BCTR  R5,R0               DECREMENT LENGTH\n         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE\n         LA    R3,1                SET SENDING LENGTH\n         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'\n         AGO   .STORE\n.XC1     ANOP\n         XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA\n         XC    0(256,R1),0(R1)          CLEAR SAVE AREA\n         AGO   .STORE\n.XC2     ANOP\n         XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA\n.STORE   ANOP\n         ST    R13,4(R1)           SAVE BACK CHAIN\n         ST    R1,8(R13)           SET FORWARD CHAIN\n         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS\n         L     R15,16(R13)         RESTORE REG 15\n         ST    R0,16(R13)          SAVE SAVEAREA LENGTH\n         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN\n         LR    R13,R11             SET SAVEAREA POINTER\n         AIF   (N'&SYSLIST EQ 0).MEND\n         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT\n         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT\n         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG\n         DROP  R12                 DROP ASSUMED BASE REG\n         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER\n.SKIPIT  ANOP\n&AA      SETA  2\n.LOOP    ANOP\n         AIF   (&AA GT N'&SYSLIST).MEXIT\n&AB      SETA  &AA-1\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG\n         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER\n&AC      SETA  &AC+4096\n&AA      SETA  &AA+1\n         AGO   .LOOP\n.MEXIT   ANOP\n         AIF   (&PRORG).MEX2\n         SPACE\n         $REGS\n         SPACE\n.MEX2    ANOP\n&AA      SETA  &LV+72\n         MNOTE *,'TOTAL STORAGE AREA RECEIVED = &AA'\n         MEXIT\n.MEND    ANOP\n         MNOTE *,'NO REGISTER SPECIFIED - R12 ASSUMED'\n         AGO   .MEXIT\n.MERR    ANOP\n         MNOTE 12,'LV > 4023 - REQUEST IGNORED'\n         AGO   .MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$REGS": {"ttr": 782, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $REGS\n         GBLB  &PRORG\n         AIF   (&PRORG).MEX2\n&PRORG   SETB  1\n SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n SPACE\nREG0     EQU   0\nREG1     EQU   1\nREG2     EQU   2\nREG3     EQU   3\nREG4     EQU   4\nREG5     EQU   5\nREG6     EQU   6\nREG7     EQU   7\nREG8     EQU   8\nREG9     EQU   9\nREG10    EQU   10\nREG11    EQU   11\nREG12    EQU   12\nREG13    EQU   13\nREG14    EQU   14\nREG15    EQU   15\n SPACE\n.MEX2    ANOP\n       MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$TEST": {"ttr": 784, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $TEST   &FLAG,&MASK,&TABLE,&COMPRND,&LENGTH,                  X\n               &FOUND,&NOTFND,&REGS\n&R1      SETC  'R1'\n&R2      SETC  'R14'\n&R3      SETC  'R7'\n&R4      SETC  'R8'\n&R5      SETC  'R9'\n         AIF   (T'&REGS EQ 'O').NOREGS\n         AIF   (N'&REGS EQ 5).SETREGS\n         MNOTE 12,'5 REGISTERS MUST BE SPECIFIED.'\n         MEXIT\n.SETREGS ANOP\n&R1      SETC  '&REGS(1)'\n&R2      SETC  '&REGS(2)'\n&R3      SETC  '&REGS(3)'\n&R4      SETC  '&REGS(4)'\n&R5      SETC  '&REGS(5)'\n.NOREGS  ANOP\n&EXIT    SETC  'DEC'.'&SYSNDX'\n&AGAIN   SETC  'REP'.'&SYSNDX'\n&SCAN    SETC  'SCN'.'&SYSNDX'\n         TM    &FLAG,&MASK\n         BZ    &EXIT\n         AIF   (N'&COMPRND GT 1).NOTFIRST\n         LA    &R1,&TABLE\n&AGAIN   SR    &R2,&R2\n         IC    &R2,0(0,&R1)\n         BCTR  &R2,0\n         B     *+10\n         CLC   1(0,&R1),&COMPRND\n         EX    &R2,*-6\n         AIF   ('&FOUND'(1,1) EQ '(').OUTREG\n         BE    &FOUND\n         AGO   .OUTEND\n.OUTREG  ANOP\n&ER      SETC  '&FOUND(1)'\n         BER   &ER\n.OUTEND  ANOP\n         LA    &R1,&LENGTH.(0,&R1)\n         CLI   0(&R1),255\n         BNE   &AGAIN\n         AIF   ('&NOTFND'(1,1) EQ '(').NOTREG\n         B     &NOTFND\n         AGO   .NOTEND\n.NOTREG  ANOP\n&NR      SETC  '&NOTFND(1)'\n         BR    &NR\n.NOTEND  ANOP\n         AGO   .ENDTEST\n.NOTFIRST ANOP\n         AIF   (T'&COMPRND(2) EQ 'O').LAST\n         LA    &R1,&TABLE\n&AGAIN   LA    &R3,&COMPRND(1)\n         LA    &R4,1\n         LA    &R5,&COMPRND(1)\n         LA    &R5,&COMPRND(3).(0,&R5)\n         SR    &R2,&R2\n         IC    &R2,0(0,&R1)\n         SR    &R5,&R2\n         BCTR  &R2,0\n         B     *+10\n         CLC   1(0,&R1),0(&R3)\n&SCAN    EX    &R2,*-6\n         AIF   ('&FOUND'(1,1) EQ '(').FOUTREG\n         BE    &FOUND\n         AGO   .FOUTEND\n.FOUTREG ANOP\n&ER      SETC  '&FOUND(1)'\n         BER   &ER\n.FOUTEND ANOP\n         BXLE  &R3,&R4,&SCAN\n         LA    &R1,&LENGTH.(0,&R1)\n         CLI   0(&R1),255\n         BNE   &AGAIN\n         AIF   ('&NOTFND'(1,1) EQ '(').FNOTREG\n         B     &NOTFND\n         AGO   .FNOTEND\n.FNOTREG ANOP\n&NR      SETC  '&NOTFND(1)'\n         BR    &NR\n.FNOTEND ANOP\n         AGO   .ENDTEST\n.LAST    ANOP\n         LA    &R1,&TABLE\n&AGAIN   LA    &R3,&COMPRND(1)\n         LA    &R4,1\n         LA    &R5,&COMPRND(1)\n         LA    &R5,&COMPRND(3).(0,&R5)\n         CLI   0(&R3),X'41'\n         BL    *+8\n         BXLE  &R3,&R4,*-8\n         SR    &R2,&R2\n         IC    &R2,0(,&R1)\n         SR    &R3,&R2\n         BCTR  &R2,0\n         B     *+10\n         CLC   1(0,&R1),0(&R3)\n&SCAN    EX    &R2,*-6\n         AIF   ('&FOUND'(1,1) EQ '(').LOUTREG\n         BE    &FOUND\n         AGO   .LOUTEND\n.LOUTREG ANOP\n&ER      SETC  '&FOUND(1)'\n         BER   &ER\n.LOUTEND ANOP\n         LA    &R1,9(,&R1)\n         CLI   0(&R1),255\n         BNE   &AGAIN\n         AIF   ('&NOTFND'(1,1) EQ '(').LNOTREG\n         B     &NOTFND\n         AGO   .LNOTEND\n.LNOTREG ANOP\n&NR      SETC  '&NOTFND(1)'\n         BR    &NR\n.LNOTEND ANOP\n.ENDTEST ANOP\n&EXIT    DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@DADSM": {"ttr": 787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x004\\x01\\x01\\x02_\\x01\\x02\\x10\\x1f\\x10\\x18\\x00\\x11\\x00\\x02\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-04-11T10:18:34", "lines": 17, "newlines": 2, "modlines": 0, "user": "MSTITT"}, "text": "//*     DADSM      --     Program to list every volume, dataset     *   FILE 527\n//*                       give hlq counts.  Old CBT mods program    *   FILE 527\n//*                       updated for full 31-bit capability.       *   FILE 527\n//*                                                                 *   FILE 527\n//*                DADSM is full amode and rmode 31.  Yet it is     *   FILE 527\n//*                able to process DCBs, EXCPs, LSPACE, RDJFCB,     *   FILE 527\n//*                and a few other 24 bit functions without         *   FILE 527\n//*                separate modules or routines.                    *   FILE 527\n//*                                                                 *   FILE 527\n//*                Please note the STORAGE macro is written to      *   FILE 527\n//*                OS/390 V2R10 levels and could give assembly      *   FILE 527\n//*                errors at lower levels.  It is a simple change   *   FILE 527\n//*                to make the macro assemble at these lower        *   FILE 527\n//*                levels.  Also you will get binder errors due     *   FILE 527\n//*                to a couple of 3-byte ADCONS.  These can be      *   FILE 527\n//*                ignored.                                         *   FILE 527\n//*                                                                 *   FILE 527\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE527": {"ttr": 789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x053O\\x01\\x053O\\tH\\x00D\\x00D\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-30T00:00:00", "modifydate": "2005-11-30T09:48:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "CBT-470"}, "text": "//***FILE 527 is from Matthew Stitt, and contains some programs     *   FILE 527\n//*           of great usefulness.                                  *   FILE 527\n//*                                                                 *   FILE 527\n//*           email:  Matthew Stitt <mstitt@bellsouth.net>          *   FILE 527\n//*           email:  Matthew Stitt <mattstit@us.ibm.com> - emer    *   FILE 527\n//*                                                                 *   FILE 527\n//*   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   *   FILE 527\n//*                                                                 *   FILE 527\n//*     ADRUENQ    --     DFDSS user exit to turn off VTOC          *   FILE 527\n//*                       enqueue for full volume dumps.            *   FILE 527\n//*                       Useful for DFHSM dumps of SYSRES, etc.    *   FILE 527\n//*                                                                 *   FILE 527\n//*     ANFUXBDA   --     InfoPrint Server begin dataset exit       *   FILE 527\n//*                       to generate separator pages like JES2.    *   FILE 527\n//*                                                                 *   FILE 527\n//*     ANFUXEDA   --     InfoPrint Server end dataset exit         *   FILE 527\n//*                       to generate separator pages like JES2.    *   FILE 527\n//*                                                                 *   FILE 527\n//*     COBALLOC   --     Assembler subroutine to use dynamic       *   FILE 527\n//*                       allocation for sysout files.  Allows      *   FILE 527\n//*                       COBOL modifications to report files, etc. *   FILE 527\n//*                                                                 *   FILE 527\n//*     COBALASM   --     Assembler jcl for COBALLOC.               *   FILE 527\n//*                                                                 *   FILE 527\n//*     DADSM      --     Program to list every volume, dataset     *   FILE 527\n//*                       give hlq counts.  Old CBT mods program    *   FILE 527\n//*                       updated for full 31-bit capability.       *   FILE 527\n//*                                                                 *   FILE 527\n//*     DADSMASM   --     Assembler jcl for DADSM.                  *   FILE 527\n//*                       Note -- full 31-bit code.                 *   FILE 527\n//*                                                                 *   FILE 527\n//*     G207DCAN   --     Date converter program.                   *   FILE 527\n//*                       Has 38+ functions, date calculator        *   FILE 527\n//*                       functions for between two dates,          *   FILE 527\n//*                       forward/backward dating, can be used      *   FILE 527\n//*                       to skip weekends.                         *   FILE 527\n//*                       Also works in MVS, VM, and VSE -- any     *   FILE 527\n//*                       language.                                 *   FILE 527\n//*                                                                 *   FILE 527\n//*     G207DOCS   --     Copy of top of assembler code.            *   FILE 527\n//*                       Provides basic documentation on how       *   FILE 527\n//*                       to use it.                                *   FILE 527\n//*                                                                 *   FILE 527\n//*     G207ASM    --     Assembler jcl for G207DCAN.               *   FILE 527\n//*                       Note -- not re-entrant code.              *   FILE 527\n//*                                                                 *   FILE 527\n//*     HSMMCA     --     HSM copy book                             *   FILE 527\n//*                                                                 *   FILE 527\n//*     HSMMCB     --     HSM copy book                             *   FILE 527\n//*                                                                 *   FILE 527\n//*     HSMMCD     --     HSM copy book                             *   FILE 527\n//*                                                                 *   FILE 527\n//*     HSMMCK     --     HSM copy book                             *   FILE 527\n//*                                                                 *   FILE 527\n//*     IEAVMXIT   --     An implementation of some of our          *   FILE 527\n//*                       message processing.                       *   FILE 527\n//*                                                                 *   FILE 527\n//*     LISTICAT   --     An upgrade to the LISTICAT program        *   FILE 527\n//*                       originally found on File 047.             *   FILE 527\n//*                       This one has major changes to the         *   FILE 527\n//*                       report layout among other things.         *   FILE 527\n//*                                                                 *   FILE 527\n//*     LISTIASM   --     Assembler jcl for LISTICAT                *   FILE 527\n//*                                                                 *   FILE 527\n//*     LISTIJCL   --     Sample jcl for running LISTICAT           *   FILE 527\n//*                                                                 *   FILE 527\n//*     UCBTYPES   --     Old UCB type code macro                   *   FILE 527\n//*                                                                 *   FILE 527\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@LSTICAT": {"ttr": 791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x12\\x01\\x01\\x02_\\x01\\x02\\x10\\x1f\\x10#\\x00\\x0f\\x00\\x02\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-04-11T10:23:12", "lines": 15, "newlines": 2, "modlines": 0, "user": "MSTITT"}, "text": "//*     LISTICAT   --     An upgrade to the LISTICAT program        *\n//*                       originally found on file 047.             *\n//*                       This one has major changes to the         *\n//*                       report layout among other things.         *\n//*                                                                 *   FILE 527\n//*                LISTICAT was an old program lifted from file     *   FILE 527\n//*                047.  It accesses the ICF catalog BCS and VVDS   *   FILE 527\n//*                as data files instead of using the SHOWCB        *   FILE 527\n//*                macros.  This program has had its report changed *   FILE 527\n//*                to display many more fields, yet still keep the  *   FILE 527\n//*                one-line format.                                 *   FILE 527\n//*                                                                 *   FILE 527\n//*                At this time the HEXPRINT function is seriously  *   FILE 527\n//*                broken.  It will be re-written at a future date  *   FILE 527\n//*                and integrated more fully into the program.      *   FILE 527\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@UPDATES": {"ttr": 793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Y\\x01\\x03\\x16\\x1f\\x01\\x050\\x7f\\x170\\x00\\x16\\x00D\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-06-10T00:00:00", "modifydate": "2005-11-03T17:30:59", "lines": 22, "newlines": 68, "modlines": 0, "user": "MSTITT"}, "text": "//***UPDATES to FILE527                                             *   FILE 527\n//*                                                                 *   FILE 527\n//*   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   *   FILE 527\n//*                                                                 *   FILE 527\n//*     ANFUXBDA   --     Added PCL command codes for printer setup *   FILE 527\n//*                       After OS/390 2.10 InfoPrint Server now    *   FILE 527\n//*                       sends the command codes after the exit    *   FILE 527\n//*                       is done processing.                       *   FILE 527\n//*                                                                 *   FILE 527\n//*     DADSM      --     Made program capable of report greater    *   FILE 527\n//*                       than 10,000 cylinders correctly.  Also    *   FILE 527\n//*                       corrected some print line volume space    *   FILE 527\n//*                       information presentations.                *   FILE 527\n//*                                                                 *   FILE 527\n//*     G207DCAN   --     No code changes.  Sub-Program can be      *   FILE 527\n//*                       assembled for full 31-bit addressing.     *   FILE 527\n//*                                                                 *   FILE 527\n//*     G207ASM    --     Assembler jcl changed for 31-bit.         *   FILE 527\n//*                                                                 *   FILE 527\n//*     LISTICAT   --     Made program 31-bit addressable.  Also    *   FILE 527\n//*                       corrected issues with volume labels.      *   FILE 527\n//*                                                                 *   FILE 527\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ADRUENQ": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x00 o\\x01\\x00 \\x7f\\x14B\\x00\\x1e\\x00\\x11\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-07-24T00:00:00", "modifydate": "2000-07-25T14:42:00", "lines": 30, "newlines": 17, "modlines": 0, "user": "MSTITT"}, "text": "******************************************************\n* ADRUENQ USER EXIT.                                 *\n*   SETS RETURN CODE TO 4 INDICATING THAT THE VOLUME *\n*   WILL ONLY BE ENQUEUED FOR THE DURATION OF THE    *\n*   VTOC ACCESS FOR DUMP AND COPY OPERATIONS.        *\n*   R13  ADDRESS OF CALLING PROGRAM SAVE AREA        *\n*   R14  RETURN ADDRESS TO CALLING PROGRAM           *\n*   R15  ADDRESS OF THIS MODULE/RETURN CODE          *\n*   R1   ADDRESS OF THE CONTROL BLOCK BEING PASSED   *\n******************************************************\n         ADRUNQB\nADRUENQ  CSECT\nADRUENQ  AMODE 31\nADRUENQ  RMODE 24\n         STM   14,12,12(13)           SAVE REGS IN PREVIOUS SAVEAREA\n         USING ADRUENQ,15             SET ADDRESSABILITY TO THE EXIT\n         USING ADRUNQB,1              SET ADDRESSABILITY TO THE CB\n         TM    UNFLG2,UNDSN           DATASET DUMP FUNCTION?\n         BO    CONT1                  YES, CARRY ON\n         TM    UNFLG1,UNPRINT         PRINT FUNCTION REQUESTED?\n         BO    CONT1                  YES, CARRY ON\nCONT2    EQU   *\n         LA    15,4                   RELEASE ENQUEUE ON VTOC\n         BR    14                     RETURN\nCONT1    EQU   *\n         TM    UNFLG1,UNPRINT         PRINT FUNCTION REQUESTED?\n         BNO   CONT2                  NO, CARRY ON\n         LA    15,0                   KEEP ENQUEUE ON VTOC\n         BR    14                     RETURN\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOC": {"ttr": 1027, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    ALLOC &DUMMY,&PERM,&DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,      X\n               &TERM=,                                       CBOC      X\n               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X\n               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X\n               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X\n               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X\n               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,           X\n               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=\n.**********************************************************************\n.*                                                                    *\n.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *\n.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *\n.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *\n.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *\n.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *\n.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *\n.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *\n.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *\n.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *\n.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *\n.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *\n.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *\n.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *\n.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *\n.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *\n.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *\n.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *\n.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *\n.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *\n.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *\n.*    THAT QUANTITY. (SEE DYNSPACE)                                   *\n.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *\n.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *\n.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *\n.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *\n.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *\n.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *\n.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *\n.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *\n.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *\n.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *\n.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *\n.*                                                                    *\n.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE    *\n.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS    *\n.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN     *\n.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.  *\n.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.             *\n.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,      *\n.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                       *\n.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.             *\n.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED, *\n.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4    *\n.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO      *\n.*    CONTAIN THE LENGTH.                                            *\n.*    EG          ALLOC DSN=LOCATOR                                  *\n.*       LOCATOR  DC    A(DSN),Y(12)                                 *\n.*       DSN      DC    C'SYS1.LINKLIB'                              *\n.*                                                                   *\n.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER   *\n.*       SPECIFY A NUMERIC VALUE, COPIES=3,                          *\n.*       A VALUE IN A REGISTER, COPIES=(R3),                         *\n.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,            *\n.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A         *\n.*       FULLWORD FIELD.                                             *\n.*                                                                   *\n.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE     *\n.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.       *\n.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE        *\n.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG      *\n.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE     *\n.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE      *\n.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,        *\n.*       SUPERVISOR AND TSO).                                        *\n.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS   *\n.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)            *\n.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH  *\n.*       ARE TO RECEIVE THE DDNAME.                                  *\n.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE          *\n.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                         *\n.*                                                                   *\n.**********************************************************************\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS\n         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS\n         LCLA  &I                 COUNTER\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n.*\n.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&NAME    DS    0H\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&SSREQ' EQ 'YES').SSREQ\n.TDSN    AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&DSNPDE' NE '').DSNPDE\n         AIF   ('&DSNRET' NE '').DSNRT\n         AIF   ('&TERM' NE '').TERM             CBOC......\n         AIF   ('&SYSOUT' NE '').SYSOUT\n         AIF   ('&DUMMY' NE '').DUMMY\n         AIF   ('&QNAME' NE '').QNAME\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n         AIF   ('&DDNRET&DDNTO' NE '').DDNRT\n.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT\n.TVOLRET AIF   ('&VOLRET' NE '').VOLRET\n.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT\n.TLABEL  AIF   ('&LABEL' NE '').LABEL\n.TPSWD   AIF   ('&PASWORD' NE '').PASWORD\n.TFORUSE AIF   ('&FORUSER' NE '').FORUSER\n.TTU     AIF   ('&TU' NE '').TU\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TSPACE  AIF   ('&SPACE' NE '').SPACE\n.TLRECL  AIF   ('&LRECL' NE '').DCB\n         AIF   ('&DEN' NE '').DCB\n         AIF   ('&RECFM' NE '').DCB\n         AIF   ('&BLKSIZE' NE '').DCB\n         AIF   ('&DSORG' NE '').DCB\n         AIF   ('&KEYLEN' NE '').DCB\n.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN\n.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN\n.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE                         TE7343\n.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM\n         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM\n.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL\n         AGO   .SVC99\n.SSREQ   RCPSSREQ\n         AGO   .TDSN\n.DSN     RCPDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.DSNPDE  RCPDSNPD &DSNPDE\n         AGO   .TDDN\n.DSNRT   RCPDSNRT &DSNRET\n&DSNRTO  SETA  &DTUO-46\n         AGO   .TDDN\n.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X\n               FORMS=&FORMS\n         AGO   .TDDN\n.TERM    RCPTERM &TERM           CBOC....\n         AGO   .TDDN             CBOC..\n.DUMMY   RCPDUMMY &DUMMY\n         AGO   .TDDN\n.QNAME   RCPQNAME &QNAME\n         AGO   .TDDN\n.DDN     RCPDDN &DDN&F&FILE\n         AGO   .TUNIT\n.DDNRT   RCPDDNRT &DDNRET\n&DDNRTO  SETA  &DTUO-10\n         AGO   .TUNIT\n.UNIT   RCPUNIT &UNIT,&VOL\n         AGO   .TVOLRET\n.VOLRET  RCPVOLRT &VOLRET\n&VOLRTO  SETA  &DTUO-8\n         AGO   .TDSRGO\n.DSORGRT RCPDSRGR\n&DSRGRTO SETA  &DTUO-2\n         AGO   .TLABEL\n.LABEL   RCPLABEL &LABEL\n         AGO   .TPSWD\n.PASWORD RCPPSWD &PASWORD\n         AGO   .TFORUSE\n.FORUSER RCPFORUS &FORUSER\n         AGO   .TTU\n.TU      RCPTU &TU\n         AGO   .TDISP\n.DISP    RCPDISP &DISP\n         AGO   .TSPACE\n.SPACE   RCPSPACE &SPACE\n         AGO   .TLRECL\n.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X\n               DSORG=&DSORG,KEYLEN=&KEYLEN\n         AGO .TDCBDSN\n.DCBDSN  RCPDCBDS &DCBDSN\n         AGO .TDCBDDN\n.DCBDDN  RCPDCBDD &DCBDDN\n         AGO .TFREE                                              TE7343\n.FREE    RCPFREE  &FREE                                          TE7343\n         AGO   .TPERM\n.PERM    RCPPERM\n         AGO   .TSPECI\n.SPECIAL RCPSPEC &SPECIAL\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n         LA    R14,4(R1)               POINT TO REQUEST BLOCK\n.DYNA    DYNALLOC\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **\n.LTR     AIF   ('&ERROR' EQ '').TDDTO\n         LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE\n&I       SETA  0\n.DDNTOL  ANOP\n&I       SETA  &I+1\n         AIF   ('&DDNTO(&I)' EQ '').RESERVE\n         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR\n         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.DDNTOR  ANOP\n&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)\n         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE 1\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU21\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AIF   (&DSNRTO EQ 0).TDDNRTO\n&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN\n.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11\n&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME\n.DTU11   AIF   (&VOLRTO EQ 0).DTU12\n&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER\n.DTU12   AIF   (&DSRGRTO EQ 0).DTU10\n&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG\n         AGO   .DTU10\n.DTU21   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 3\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLVVDS": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00P\\x00\\x95)\\x8f\\x01\\x02\\x07?\\x08C\\x00I\\x00_\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "2002-03-14T08:43:50", "lines": 73, "newlines": 95, "modlines": 0, "user": "MSTITT"}, "text": "         TITLE ' - ALLOCATE ALL ONLINE VVDS''S.'\n* PASS THROUGH THE UCB LOOKUP TABLE. USING UCBVOLI DEVELOP A DSNAME OF\n* SYS1.VVDS.VVOLSER. TRY TO DYNAMICALLY ALLOCATE IT. IF SUCCESSFUL\n* GENERATE AN ACB AND AN RPL AND SAVE THEIR ADDRESSES. FINALLY OPEN\n* THE VVDS.\nALLVVDS  $PROLOG R12\n         L     R4,=V(DATASECT)                                     @130\n         USING DATASECT,R4                                         @130\n         L     R0,=A(VVDSGETL)     LENGTH OF TABLE.                @131\n         GETMAIN R,LV=(0)\n         ST    R1,VVDSTAD          SAVE TABLE START ADDRESS\n         LR    R5,R1               R5 AS BASE REG FOR VVDS TABLE.\n         USING VVDSTAB,R5\n         A     R1,=A(VVDSGETL)    ADD LENGTH OF TABLE              @131\n         LA    R0,VVDSTLEN        PICK UP ENTRY LENGTH             @131\n         SR    R1,R0              BACK UP 1 ENTRY                  @131\n         ST    R1,VVDSTEND        SAVE LAST ENTRY ADDR.            @131\n         SPACE ,\n         XC    UCBWORK,UCBWORK    CLEAR WORK AREA                  @120\nUCBLOOP  UCBSCAN COPY,WORKAREA=UCBWORK,UCBAREA=UCBCOPY,                X\n               DYNAMIC=YES,RANGE=ALL,DEVCLASS=DASD\n         LTR   R15,R15            WAS A UCB RETURNED?              @120\n         BNZ   LASTUCB            NO.                              @120\n         USING UCBOB,R2           ADDR TO UCB DSECT                @120\n         LA    R2,UCBCOPY         GET RETURNED UCB ADDR            @120\n         TM    UCBSTAT,UCBONLI     IS IT ONLINE?                   @120\n         BZ    UCBLOOP             NO, KEEP GOING                  @120\n         B     ALLVVDS1            PROCESS DASD VOLUME.            @120\nLASTUCB  B     ALLVVDS9                                            @120\n         SPACE ,\nALLVVDS1 DS    0H\n         MVI   VVDSFLG,C'O'        OSVTOC, BY DEFAULT.             @131\n         CVAFTST UCB=(2)           IS IT IXVTOC?                   @131\n         C     R15,=F'4'           LET'S SEE.                      @131\n         BE    *+8                 NO INDEX.                       @131\n         MVI   VVDSFLG,C'I'        IF INDEXED, REMEMBER FOR LATER  @131\n         MVC   VVDSNAME,UCBVOLI    SET UP VOLSER IN DSNAME\n         MVC   VVDDNAME,UCBVOLI    SET UP VOLSER IN DDNAME\n         MVC   VVDSVOL,UCBVOLI     SAVE VOLSER IN TABLE.\n         ALLOC DSN=LOCDSN,DISP=SHR,DDN=LOCDDN,ERROR=UCBLOOP\n         GENCB BLK=ACB,                                                X\n               AM=VSAM,                                                X\n               BUFSP=32768,                                            X\n               DDNAME=(*,VVDDN),                                       X\n               MACRF=(ADR,SEQ)\n         LTR   R15,R15             ACB GENERATED?\n         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.\n         STCM  R1,15,VVDSACB       STORE ACB ADDRESS\n         GENCB BLK=RPL,                                                X\n               AM=VSAM,                                                X\n               ACB=(*,VVDSACB),                                        X\n               AREA=(S,VVDSBUF),                                       X\n               OPTCD=(ADR,SEQ,LOC),                                    X\n               ARG=(S,VVDSARG)\n         LTR   R15,R15             RPL GENERATED?\n         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.\n         STCM  R1,15,VVDSRPL       STORE RPL ADDRESS\n*        ICM   R8,15,VVDSACB       GET ACB ADDRESS\n*        OPEN  ((8))               OPEN VVDS\n*        LTR   R15,R15             DID IT OPEN?                    @122\n*        BZ    ALLVVDS2            YES.                            @122\n*       $MESSAGE 5,DATA=UCBVOLI                                    @122\n*        B     UCBLOOP             TRY NEXT VOLUME.                @122\nALLVVDS2 DS    0H                                                  @122\n*        CLOSE ((8))                                               @122\n         LA    R5,VVDSTLEN(0,R5)   NEXT VVDSTAB ENTRY\n         C     R5,VVDSTEND         AM I OFF THE DEEP END?          @131\n         BNH   UCBLOOP             NO. TRY NEXT VOLUME.            @131\n        $MESSAGE 9                 GIVE HIM THE BAD NEWS.          @131\n         ABEND 256                 THEN CRASH AND BURN.            @131\nALLVVDS9 MVI   0(R5),255           SET END OF TABLE.\n         $EPILOG ,                 ALL DONE.\n         LTORG ,                                                   @130\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ANFUXBDA": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x10\\x01\\x00\\x06\\x0f\\x01\\x003?\\t\\x08\\x02\\x83\\x02=\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2000-02-29T00:00:00", "modifydate": "2000-11-28T09:08:10", "lines": 643, "newlines": 573, "modlines": 0, "user": "MSTITT"}, "text": "//MSTITT   JOB   (0),'MATTHEW STITT',\n//         CLASS=Q,\n//         MSGCLASS=X,\n//         MSGLEVEL=(1,1),\n//         NOTIFY=MSTITT,\n//         TIME=1440\n//*\n//*   ASSEMBLE SOURCE\n//ASM     EXEC PGM=ASMA90,REGION=1024K,\n//             PARM='OBJECT,NODECK,RENT'\n//SYSLIB   DD  DSN=SYS1.MACLIB,\n//             DISP=SHR\n//         DD  DSN=SYS1.AMODGEN,\n//             DISP=SHR\n//*        DD  DSN=ANF.SANFMAC,\n//*            DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(1700,(600,100))\n//SYSUT2   DD  UNIT=SYSALLDA,SPACE=(1700,(600,100))\n//SYSUT3   DD  UNIT=SYSALLDA,SPACE=(1700,(600,100))\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY,SYSOUT=B\n//SYSLIN   DD  DSN=&&OBJSET,\n//             DISP=(NEW,PASS),\n//             UNIT=SYSALLDA,SPACE=(80,(200,50))\n//SYSIN DD *\nANFUXBDA TITLE 'Begin Data Set Exit'\n****** START OF SPECIFICATIONS ****************************************\n*                                                                     *\n* MODULE NAME = ANFUXBDA                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Begin Data Set exit for putting out header page  *\n*                                                                     *\n* COPYRIGHT= 5695040 (c) COPYRIGHT IBM CORPORATION 1996               *\n*                                                                     *\n* STATUS = VERSION 1, RELEASE 1, LEVEL 0                              *\n*                                                                     *\n* FUNCTION =                                                          *\n*        produce a header page                                        *\n*                                                                     *\n* NOTES = none                                                        *\n* DEPENDENCIES = none                                                 *\n*                                                                     *\n* MODULE TYPE = PROCEDURE                                             *\n*    PROCESSOR = Assembler                                            *\n*    ATTRIBUTES =                                                     *\n*         REENTRANT                                                   *\n*         AMODE(31)                                                   *\n*         RMODE(ANY)                                                  *\n*                                                                     *\n* PATCH LABEL = none                                                  *\n*                                                                     *\n* ENTRY POINT =                                                       *\n*         ANFUXBDA                                                    *\n*                                                                     *\n*    LINKAGE =                                                        *\n*           LOAD ANFUXBDA                                             *\n*           CALL ANFUXBDA(addr(ANFUEXTP))                             *\n*           calling module passes address of Common Parameter         *\n*           area.                                                     *\n*                                                                     *\n* CHANGE ACTIVITY =                                                   *\n* 96/10/16 XXX Initial Version                                 @23418N*\n*                                                                     *\n***** END OF SPECIFICATIONS *******************************************\n*\nANFUXBDA CSECT ,                   Establish the csect\nANFUXBDA AMODE ANY                 It addresses all storage\nANFUXBDA RMODE ANY                 It can reside anywhere\n         USING ANFUXBDA,R15        Establish temporary addressability  X\n                                   to module\n         B     BDSINIT             Branch around copyright information\nANFUXBDA MODID BR=NO                       EYECATCHER INFO\n         DC    C'LICENSED MATERIALS-PROPERTY OF IBM  '\n         DC    C'THIS MODULE IS \"RESTRICTED MATERIALS OF IBM\"  '\n         DC    C'5695-040 (c) COPYRIGHT IBM CORP. 1996  '\n         DC    C'SEE COPYRIGHT INSTRUCTIONS  '\n         EJECT ,\n*---------------------------------------------------------------------*\n*   ANFUXBDA Module entry point                                       *\n*---------------------------------------------------------------------*\n*\nBDSINIT  DS    0H\n         STM   R14,R12,12(R13)     Save callers registers\n         LR    R12,R15             Move base register to R12\n         DROP  R15                 Done with this register\n         USING ANFUXBDA,R12        R12 is base reg for program code\n         L     R4,0(R1)            Get address of parm area\n         USING ANFUEXTP,R4         R4 is base for parm area\n         ST    R13,XTPSAVE+4       chain save areas\n         LA    R15,XTPSAVE         get my save area\n         ST    R15,8(R13)          point callers save area to it\n         LR    R13,R15             point R13 to my save area\n         L     R6,XTPJSPAP         Get address of parm area\n         USING IAZJSPA,R6          R6 is base for jspa area\n         L     R7,XTPSWBTP         Get address of parm area\n         L     R8,XTPSWBTL         Get length of parm area\n         BCTR  R8,R0               Subtract 1 from length\n         AR    R8,R7               R8 is endpoint of parm area\n*---------------------------------------------------------------------*\n*        Get storage for work area                                    *\n*---------------------------------------------------------------------*\n*\n         SLR   R2,R2               get a zero\n         L     R9,XTPWORK1         get working storage addr\n         USING BDSSTG,R9\n         CR    R9,R2               has work area been gotten?\n         BNE   BDSDOIT             yes, skip this\n         LA    R2,BDSSTGL          Get length of DSECT\n         GETMAIN RU,LV=(2),LOC=ANY Get program storage area\n         LR    R9,R1\n         ST    R4,BDSWORKB         put addr of parm\n         MVC   WRKJTBL,PYEARTAB    copy julian conversion table\n         ST    R9,XTPWORK1         save working storage addr\n*\n***********************************************************************\n*        Actual work - call to get block characters                   *\n***********************************************************************\nBDSDOIT  DS    0H\n         TM    XTPDSFLG,XTPDSJOB   first data set in job?\n*        BNO   BDSTRT              No, initialize status flags\n         BO    BDSTRT              Yes, force banner page\n         CLC   XTPCOPYS,=F'1'      Only 1 copy?\n         BH    BDSTRT              No, force banner page\n         CLC   XTPDSNAM(3),=C'JES'\n         BNE   BDSTRT\n         OI    XTPRCFLG,XTPRLAST   don't call again\n         B     GETOUT              Don't want a banner page\n*        TM    XTPRCFLG,XTPRDFST   first call for data set?\n*        BNO   BDSREST             no, don't do init stuff\nBDSTRT   DS    0H\n***********************************************************************\n*        Actual work - initialize status flags                        *\n***********************************************************************\n         TM    XTPRCFLG,XTPRDFST   first call for data set?\n         BNO   BDSREST             no, don't do init stuff\n         MVI   XTPRCFLG,X'10'      zero flags\n         MVI   BDSWORKD,0          clear status flags\n         MVC   BDSWORKD+1(15),BDSWORKD  clear the status flags\nBDSREST  DS    0H\n         OI    XTPRCFLG,XTPRCCC    assume it has carriage control\n         CLI   BDSWORKD+1,0        done with last line of text?\n         BNE   DOJOBID1            yes, do last line for page break\nGOTANID  DS    0H\n         MVC   XTPBSTRG,JSPAJBNM   copy job name for conversion\n         MVI   XTPBIFLG,X'00'      default formatting stuff\nSETFLAGS DS    0H\n*        OI    XTPBIFLG,XTPBPRFM   Narrow letters\n*        OI    XTPBIFLG,XTPBLJST   on left margin\nBDSREST1 DS    0H\n         CLI   BDSWORKD,0          done with last line of text?\n         BNE   DOLAST              yes, do last line for page break\n         ST    R4,BDSWORKB         put addr of parm\n         LA    R1,BDSWORKB\n         L     R15,=V(ANFUBLK)     get address of block builder\n         BALR  R14,R15\n         TM    XTPBOFLG,XTPBLAST   last one?\n         BNO   NOTLAST             no, keep going\n         MVI   BDSWORKD,1          saw last record, prepare to leave\nNOTLAST  DS    0H\n         SLR   R5,R5               get a zero\n         IC    R5,XTPBLENG         get record length\n         ST    R5,XTPERLEN         set length to print\n         B     DOLINE\nDOLAST   DS    0H\n         CLI   BDSWORKD+3,2        done with last line of text?\n         BH    DOJOBID             yes, do last line for page break\n         CLI   BDSWORKD+1,1        done with last line of text?\n         BH    DOBOX               yes, do the box\n         MVC   XTPBOUTP(1),=C' '   put in blank line CC\n         MVC   XTPBOUTP+1(L'XTPBOUTP-1),XTPBOUTP  blank the line\n         LA    R5,133              get length of record\n         ST    R5,XTPERLEN         set length to print\n         SR    R5,R5               zero the register\n         LH    R5,BDSWORKD+2       put the counter in the register\n         LA    R5,1(0,R5)          add 1 to it\n         STH   R5,BDSWORKD+2       put it back to the counter\n         B     DOLINE\nDOJOBID  DS    0H\n         CLI   BDSWORKD+1,0        done with last line of text?\n         BH    DOBOX               yes, end of block letters\n         MVI   BDSWORKD,0          not done yet\n         MVI   BDSWORKD+3,0        not done yet\n         MVI   BDSWORKD+1,1        don't do this again\n         MVI   XTPBIFLG,X'00'      default formatting stuff\n         OI    XTPBIFLG,XTPBFRST   first time for block letters\nDOJOBID1 DS    0H\n         MVC   XTPBSTRG,JSPAJBID   copy job id for conversion\n         MVI   XTPBOFLG,X'00'      clear done flag\n         B     SETFLAGS            generate block letters\nDOBOX    DS    0H\n         MVI   XTPBOUTP,C' '       begin blank line\n         MVC   XTPBOUTP+1(L'XTPBOUTP-1),XTPBOUTP  blank the line\n         MVI   XTPBOUTP+30,C'*'    begin asterisk\n         MVI   XTPBOUTP+109,C'*'   ending asterisk\n         LA    R5,110              get length of record\n         ST    R5,XTPERLEN         set length to print\n         SR    R5,R5               zero the register\n         LH    R5,BDSWORKD+6       put the counter in the register\n         LA    R5,1(0,R5)          add 1 to it\n         STH   R5,BDSWORKD+6       put it back to the counter\n         SR    R3,R3\n         ICM   R3,1,BDSWORKD+7\n         SLL   R3,2\n         LA    R5,XTPBOUTP         get record address\n         B     BTABLE(R3)\nBTABLE   DS    F\n         B     DOBOX1\n         B     DOBOX2\n         B     DOLINE\n         B     DOBOX4\n         B     DOBOX5\n         B     DOBOX6\n         B     DOBOX7\n         B     DOBOX8\n         B     DOBOX9\n         B     DOLINE\n         B     DOBOX11\n         B     DOBOX12\n         B     DOBOX13\n         B     DOBOX14\n         B     DOBOX15\n         B     DOBOX16\n         B     DOLINE\n         B     DOBOX18\n         B     DOBOX19\n         B     DOBOX20\n         B     DOBOX21\n         B     DOBOX22\n         B     DOBOX23\n         B     DOBOX24\n         B     DOBOX25\n         B     DOBOX1\n         B     DOEND\nDOBOX1   DS    0H\n         LA    R3,8                setup loop register\n         LA    R5,30(0,R5)         beginning offset into print line\nBOX1LP   DS    0H\n         MVC   0(10,R5),=C'**START***'\n         LA    R5,10(0,R5)         increment offset\n         BCT   R3,BOX1LP           circle around\n         B     DOLINE\nDOBOX2   DS    0H\n         MVC   XTPBOUTP+32(L'PHEAD),PHEAD  constant to print\n         B     DOLINE\nDOBOX4   DS    0H\n         MVC   XTPBOUTP+32(L'PJOBID),PJOBID  constant to print\n         MVC   XTPBOUTP+47(L'JSPAJBID),JSPAJBID job id\n         B     DOLINE\nDOBOX5   DS    0H\n         MVC   XTPBOUTP+32(L'PJOBNM),PJOBNM  constant to print\n         MVC   XTPBOUTP+47(L'JSPAJBNM),JSPAJBNM job name\n         B     DOLINE\nDOBOX6   DS    0H\n         MVC   XTPBOUTP+32(L'PUSERID),PUSERID constant to print\n         MVC   XTPBOUTP+47(L'XTPUSRID),XTPUSRID user id\n         B     DOLINE\nDOBOX7   DS    0H\n         MVC   XTPBOUTP+32(L'PSYSOUTC),PSYSOUTC constant to print\n         MVC   XTPBOUTP+47(L'JSPJSOCL),JSPJSOCL sysout class\n         LA    R10,DOCLASS\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX8   DS    0H\n         MVC   XTPBOUTP+32(L'POUTGRP),POUTGRP constant to print\n         MVC   XTPBOUTP+47(L'JSPJGRPN),JSPJGRPN output group name\n         MVI   XTPBOUTP+55,C'.'    separator\n         SR    R10,R10\n         LH    R10,JSPJGRP1\n         CVD   R10,BDSWORKH\n         MVC   XTPBOUTP+56(5),POGMASK\n         ED    XTPBOUTP+56(5),BDSWORKH+4\n         MVI   XTPBOUTP+62,C'.'    separator\n         SR    R10,R10\n         LH    R10,JSPJGRP2\n         CVD   R10,BDSWORKH\n         MVC   XTPBOUTP+63(5),POGMASK\n         ED    XTPBOUTP+63(5),BDSWORKH+4\n         B     DOLINE\nDOBOX9   DS    0H\n         MVC   XTPBOUTP+32(L'PTITLE),PTITLE  constant to print\n         LA    R10,DOTITLE\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX11  DS    0H\n         MVC   XTPBOUTP+32(L'PPRTTM),PPRTTM  constant to print\n***********************************************************************\n*                                                                     *\n*        Obtain time and date (year 2000 ready)                       *\n*        Routine called if BDSWORKD=7                                 *\n*                                                                     *\n***********************************************************************\n*\n         XC    WRKY2000(16),WRKY2000   Clear\n         TIME  DEC,WRKY2000,LINKAGE=SYSTEM,MF=(E,TIME1)\n         L     R0,WRKY2000+8           Point to date 0YYYYDDD\n         SLL   R0,4                    R0=YYYYDDD0\n         SLR   R1,R1                   R1=00000000\n         IC    R1,=X'0F'               R1=0000000F\n         OR    R0,R1                   R0=YYYYDDDF\n         ST    R0,WRKDATE              Save date packed decimal\n         L     R0,WRKY2000             Point to time HHMMSSTT\n*\n***********************************************************************\n*                                                                     *\n*        Adjust time for am/pm                                        *\n*                                                                     *\n***********************************************************************\n*\n         LA    R2,WRKTIME              Get address of work area\n         MVC   WRKAMPM(2),AM           Set AM/PM to AM\n         CL    R0,=X'12000000'         Test for zero hours\n         BL    PMORNING                Branch if AM\n         MVI   WRKAMPM,C'P'            Change from AM to PM\n         SL    R0,=X'12000000'         Subtract twelve hours\nPMORNING ST    R0,0(,R2)               Store adjusted time\n         CLI   0(R2),X'00'             Test for zero hours\n         BNE   PADJERR                 Br if not to test adj err\n         MVI   0(R2),X'12'             Convert zero to twelve\nPADJERR  TM    0(R2),X'08'             Test for adjustment errors\n         BZ    PEDTIME                 Branch if no error\n         NI    0(R2),X'09'             Correct for binary substr. err\nPEDTIME  DS    0H\n*\n***********************************************************************\n*                                                                     *\n*        Unpack hours minutes seconds                                 *\n*                                                                     *\n***********************************************************************\n*\n         MVI   WRKTH,X'0C'             Reset low order 2 bytes\n*                                      with sign for packed decimal\n         UNPK  WRKUTIME(7),WRKTIME(4)  Unpack time INTO PROPER FIELD\n         CLI   WRKHR,X'F0'             If hour has leading zero\n         BNE   PTIME\n         MVC   WRKHR(1),BLANK          Change zero to blank\nPTIME    DS    0H\n***********************************************************************\n*                                                                     *\n*        Obtain month, day and year                                   *\n*                                                                     *\n***********************************************************************\n*\n         MVC   WRKWORK+4(4),WRKDATE    Obtain date from saved area\n         TM    WRKWORK+5,X'01'          test\n         BO    NOLEAPYR                  for\n         TM    WRKWORK+5,X'12'            leap\n         BM    NOLEAPYR                    year\n         MVI   WRKJTBL+4,29            Adjust feb for leap year\nNOLEAPYR MVC   WRKYY(4),=X'20202020'   Place pattern for edit\n         ED    WRKYY(4),WRKWORK+4      Edit the year\n         MVC   WRKWORK(6),ZEROES       Reset all but julian date\n         SLR   R0,R0                   Clear for ic\n         CVB   1,WRKWORK               Convert to binary day\n         LA    2,WRKJTBL-4             Address od date conversion\n*                                       table\nSEARCH   SLR   R1,R0                     convert\n         LA    R2,4(,R2)                  julian day\n         IC    R0,0(,R2)                   to\n         CLR   R0,R1                        standard day\n         BL    SEARCH\n         CVD   1,WRKWORK               Convert to decimal day\n         UNPK  WRKDD(2),WRKWORK+6(2)   Unpack the day\n         OI    WRKDD+1,X'F0'           Insure sign nibble\n         MVC   WRKMMM(3),1(R2)         Set ebcidic alpha month\n         MVC   XTPBOUTP+47(L'WRKHR),WRKHR print hour\n         MVI   XTPBOUTP+49,C':'        time separator\n         MVC   XTPBOUTP+50(L'WRKMIN),WRKMIN print minute\n         MVI   XTPBOUTP+52,C':'        time separator\n         MVC   XTPBOUTP+53(L'WRKSEC),WRKSEC print second\n         MVC   XTPBOUTP+56(L'WRKAMPM),WRKAMPM print am or pm\n         B     DOLINE\nDOBOX12  DS    0H\n         MVC   XTPBOUTP+32(L'PPRTDT),PPRTDT  constant to print\n         MVC   XTPBOUTP+47(2),WRKDD\n         MVC   XTPBOUTP+50(3),WRKMMM\n         MVC   XTPBOUTP+54(4),WRKYY\n         B     DOLINE\nDOBOX13  DS    0H\n         MVC   XTPBOUTP+32(L'PPRTR),PPRTR  constant to print\n         MVC   XTPBOUTP+47(L'JSPADEVN),JSPADEVN  constant to print\n         B     DOLINE\nDOBOX14  DS    0H\n         MVC   XTPBOUTP+32(L'PSYSID),PSYSID  constant to print\n         L     R10,JSPAJMR\n         USING JMR,R10\n         MVC   XTPBOUTP+47(L'JMRCPUID),JMRCPUID  constant to print\n         DROP  R10\n         B     DOLINE\nDOBOX15  DS    0H\n         MVC   XTPBOUTP+32(L'PPDEF),PPDEF constant to print\n         LA    R10,DOPAGEDE\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX16  DS    0H\n         MVC   XTPBOUTP+32(L'PFDEF),PFDEF  constant to print\n         LA    R10,DOFORMD\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX18  DS    0H\n         MVC   XTPBOUTP+32(L'PDEST),PDEST constant to print\n         MVC   XTPBOUTP+47(L'XTPDEST),XTPDEST sysout destination\n         B     DOLINE\nDOBOX19  DS    0H\n         MVC   XTPBOUTP+32(L'PNAME),PNAME constant to print\n         LA    R10,DONAME\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX20  DS    0H\n         MVC   XTPBOUTP+32(L'PROOM),PROOM constant to print\n         MVC   XTPBOUTP+47(L'JSPJRMNO),JSPJRMNO sysout room\n         LA    R10,DOROOM\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX21  DS    0H\n         MVC   XTPBOUTP+32(L'PBLDG),PBLDG  constant to print\n         LA    R10,DOBUILD\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX22  DS    0H\n         MVC   XTPBOUTP+32(L'PDEPT),PDEPT  constant to print\n         LA    R10,DODEPT\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX23  DS    0H\n         MVC   XTPBOUTP+32(L'PADDRS),PADDRS  constant to print\n         LA    R10,DOADDRES\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX24  DS    0H\n*        LA    R10,DOADDRES\n*        STH   R10,BDSWORKD+4(2)\n*        B     SWBSCAN\n         B     DOLINE\nDOBOX25  DS    0H\n*        LA    R10,DOADDRES\n*        STH   R10,BDSWORKD+4(2)\n*        B     SWBSCAN\n         B     DOLINE\nDOBOX26  DS    0H\n*        LA    R10,DOADDRES\n*        STH   R10,BDSWORKD+4(2)\n*        B     SWBSCAN\n         B     DOLINE\nDOEND    DS    0H\n         MVC   XTPBOUTP(2),=C'1'   put in page eject CC\n         LA    R5,1                get length of record\n         ST    R5,XTPERLEN         set length to print\n         OI    XTPRCFLG,XTPRLAST   don't call again\n         LA    R2,BDSSTGL          Get length of DSECT\n         FREEMAIN RU,LV=(2),A=(R9) FREE PROGRAM STORAGE AREA\n         SLR   R2,R2               get a zero\n         ST    R2,XTPWORK1         no working storage addr\nDOLINE   DS    0H\n         LA    R5,XTPBOUTP         get record address\n         ST    R5,XTPERPTR         put it in XTP area\n         OI    XTPRCFLG,XTPRCTRN   translate it to ASCII\n         OI    XTPRCFLG,XTPRCEXT   print the record\n*\n*---------------------------------------------------------------------*\n*        Return to caller                                             *\n*---------------------------------------------------------------------*\nGETOUT   DS    0H\n         L     R13,XTPSAVE+4      Get address of caller's save area\n         LM    R14,R12,12(R13)    Restore caller's registers\n         BR    R14                Return to MVS\n*\n*---------------------------------------------------------------------*\n*        Scan SWBTU data area                                         *\n*---------------------------------------------------------------------*\nSWBSCAN  DS    0H\n         USING SJPRFX,R7           R7 is base for swbtu area\n         MVC   BDSWORKH+7(1),SJPRPLEN\n         LR    R11,R7\n         LH    R10,BDSWORKH+6\n         AR    R11,R10             Skip around swbtu prefix area\n         USING DOCNUNIT,R11        R11 is base for data descriptor area\nDOSWBL1  DS    0H\n         MVC   BDSWORKH(2),DOCNTLTH get length of field\n         LH    R10,BDSWORKH         get length of field\n         CLC   DOCNTKEY,BDSWORKD+4 this the field looking for?\n         BE    FNDSWB              yes, move it to output\n         AR    R11,R10             skip field\n         LA    R11,6(0,R11)        skip field headers\n         CR    R11,R8              at the end?\n         BL    DOSWBL1\n         B     OUTSWB              end of SWBTU\nFNDSWB   DS    0H\n         LA    R11,6(0,R11)        skip field headers\n         LA    R5,XTPBOUTP         get record address\n         LA    R5,47(0,R5)         go to beginning of print\nDOSWBL2  DS    0H\n         MVC   0(1,R5),0(R11)\n         LA    R5,1(0,R5)\n         LA    R11,1(0,R11)\n         BCT   R10,DOSWBL2\nOUTSWB   DS    0H\n         B     DOLINE\n*\n*---------------------------------------------------------------------*\n*        Constants and Literals                                       *\n*---------------------------------------------------------------------*\n         DS    0H\nSETUPSTR DS 0C\n*\n         DC X'27'                 escape\n         DC X'50'                 ampersand\n         DC C'l1S'                duplex   0=simplex 1=duplex 2=tumble\n*\n         DC X'27'                 escape\n         DC C'(8U'                code page roman-8\n*\n         DC X'27'                 escape\n         DC C'(s1p8v0s0b4101T'    change font to CG Times\n*\nSETUPLEN EQU  *-SETUPSTR\nSETUPLND DS 0C\n*\n         DC X'27'                 escape\n         DC X'50'                 ampersand\n         DC C'l1O'                landscape format\n*\n         DC X'27'                 escape\n         DC X'50'                 ampersand\n         DC C'l8D'                8 lines per inch\n*\n         DC X'27'                 escape\n         DC C'(10U'               IBM layout default symbol set\n*\n         DC X'27'                 escape\n         DC C'(s0p16.67h8.5v0s0b0T' change font to line printer\n*\nSETUPLNG EQU  *-SETUPLND\nPHEAD    DC   C'IP PRINTWAY V1R1  STC: PRINTWAY'\nPJOBID   DC   C'JOBID:'\nPJOBNM   DC   C'JOB NAME:'\nPUSERID  DC   C'USERID:'\nPSYSOUTC DC   C'SYSOUT CLASS:'\nPOUTGRP  DC   C'OUTPUT GROUP:'\nPTITLE   DC   C'TITLE:'      '\nPDEST    DC   C'DESTINATION:'\nPNAME    DC   C'NAME:'\nPROOM    DC   C'ROOM:'\nPBLDG    DC   C'BUILDING:'\nPDEPT    DC   C'DEPARTMENT:'\nPADDRS   DC   C'ADDRESS:'\nPPRTTM   DC   C'PRINT TIME:'\nPPRTDT   DC   C'PRINT DATE:'\nPPRTR    DC   C'PRINTER NAME:'\nPSYSID   DC   C'SYSTEM NAME:'\nPPDEF    DC   C'PAGEDEF:'\nPFDEF    DC   C'FORMDEF:'\nAM       DC   C'AM'\nBLANK    DC   C' '\nZEROES   DC   X'000000000000'\nPOGMASK  DC    X'2120202020'                MASK\nPYEARTAB DC    AL1(31),C'JAN',AL1(28),C'FEB'  JULIAN\n         DC    AL1(31),C'MAR',AL1(30),C'APR'   TO DAY\n         DC    AL1(31),C'MAY',AL1(30),C'JUN'    AND\n         DC    AL1(31),C'JUL',AL1(31),C'AUG'     MONTH\n         DC    AL1(30),C'SEP',AL1(31),C'OCT'      CONVERSION\n         DC    AL1(30),C'NOV',AL1(255),C'DEC'      TABLE\n         LTORG\n*---------------------------------------------------------------------*\n*        Work area                                                    *\n*---------------------------------------------------------------------*\nBDSSTG   DSECT\nBDSWORKB DS    CL256              area for output record\n         DS    0H\nBDSWORKD DS    8BL1\nBDSWORKH DS    8BL1\nWRKWORK  DS    CL8                     Work area for conversion\nWRKY2000 DS    CL16                    Time SVC work area\nWRKDATE  DS    CL4                     Current date - packed\nWRKTIME  DS    CL4                     Current time - packed\n         ORG   WRKTIME\n         DS    CL3                     Hours minutes seconds\nWRKTH    DS    CL1                     Tenths and hundredths\nWRKUDATE DS    CL8                     Current date - unpacked\n         ORG   WRKUDATE\nWRKMMM   DS    CL3                     Month\nWRKDD    DS    CL2                     Day\nWRKYY    DS    CL4                     Year\n         DS    CL1                     Reserved\nWRKAMPM  DS    CL2                     Current AM/PM\nWRKUTIME DS    CL7                     Current time - unpacked\n         ORG   WRKUTIME\nWRKHR    DS    CL2                     Hour\nWRKMIN   DS    CL2                     Minute\nWRKSEC   DS    CL2                     Second\n         DS    CL1                     Sign byte\nWRKJTBL  DS    CL48                    Julian conversion table\nTIME1    TIME  LINKAGE=SYSTEM,MF=L     Year 2000 ready\n         DS    10F                     Alignment\nDBLWRK   DS    D\n*\nBDSSTGL  EQU   *-BDSSTG          Length of program storage\n         ANFUEXTP LIST=YES\n         IAZJSPA LIST=YES\n         IEFSJPFX DSECT=YES\n         IEFDOTUM\n         IEFDOKEY\n*        IEFJESCT\n         IEFJMR\n*        IEFSJTRC\n*        IEFSJTRP DSECT=NO\n*---------------------------------------------------------------------*\n*        End of Program Storage                                       *\n*---------------------------------------------------------------------*\n*\nR0       EQU   0                   Register\nR1       EQU   1                     equates\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   ,                   End of ANFUXBD2 module\n//*   LINK-EDIT OBJECT TO LINKLIB\n//LINK     EXEC PGM=IEWL,\n//  PARM='MAP,LIST,XREF,AC=0,RENT,AMODE=31,RMODE=ANY',\n//        REGION=512K\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(4,1))\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DSN=HHSYS.PROD.LINKLIB,DISP=SHR\n//SANFSAMP DD  DSN=SYS1.SAMPLIB,DISP=SHR\n//SYSMOD   DD  DSN=&&OBJSET,\n//             DISP=(OLD,DELETE)\n//SYSLIN   DD  *\n INCLUDE SYSMOD\n INCLUDE SANFSAMP(ANFUBLK)\n INCLUDE SANFSAMP(ANFUBTBL)\n ENTRY ANFUXBDA\n NAME ANFUXBDA(R)\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ANFUXEDA": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x01\\x00\\x06?\\x01\\x02\\x03\\x9f\\x11Y\\x02\\x87\\x02\\x85\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-03-03T00:00:00", "modifydate": "2002-02-08T11:59:31", "lines": 647, "newlines": 645, "modlines": 0, "user": "MSTITT"}, "text": "//MSTITT   JOB   (0),'MATTHEW STITT',\n//         CLASS=Q,\n//         MSGCLASS=X,\n//         MSGLEVEL=(1,1),\n//         NOTIFY=MSTITT,\n//         TIME=1440\n//*                                                           /*JCTRL*/\n//*\n//*\n//*\n//*   ASSEMBLE SOURCE\n//ASM     EXEC PGM=ASMA90,REGION=1024K,\n//             PARM='OBJECT,NODECK,RENT'\n//SYSLIB   DD  DSN=SYS1.MACLIB,\n//             DISP=SHR\n//         DD  DSN=SYS1.AMODGEN,\n//             DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(1700,(600,100))\n//SYSUT2   DD  UNIT=SYSALLDA,SPACE=(1700,(600,100))\n//SYSUT3   DD  UNIT=SYSALLDA,SPACE=(1700,(600,100))\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY,SYSOUT=B\n//SYSLIN   DD  DSN=&&OBJSET,\n//             DISP=(NEW,PASS),\n//             UNIT=SYSALLDA,SPACE=(80,(200,50))\n//SYSIN DD *\nANFUXEDA TITLE 'Ending Data Set Exit'\n****** START OF SPECIFICATIONS ****************************************\n*                                                                     *\n* MODULE NAME = ANFUXEDA                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Ending Data Set exit for putting out sep page    *\n*                                                                     *\n* COPYRIGHT= 5695040 (c) COPYRIGHT IBM CORPORATION 1996               *\n*                                                                     *\n* STATUS = VERSION 1, RELEASE 1, LEVEL 0                              *\n*                                                                     *\n* FUNCTION =                                                          *\n*        produce a separator page                                     *\n*                                                                     *\n* NOTES = none                                                        *\n* DEPENDENCIES = none                                                 *\n*                                                                     *\n* MODULE TYPE = PROCEDURE                                             *\n*    PROCESSOR = Assembler                                            *\n*    ATTRIBUTES =                                                     *\n*         REENTRANT                                                   *\n*         AMODE(31)                                                   *\n*         RMODE(ANY)                                                  *\n*                                                                     *\n* PATCH LABEL = none                                                  *\n*                                                                     *\n* ENTRY POINT =                                                       *\n*         ANFUXEDA                                                    *\n*                                                                     *\n*    LINKAGE =                                                        *\n*           LOAD ANFUXEDA                                             *\n*           CALL ANFUXEDA(addr(ANFUEXTP))                             *\n*           calling module passes address of Common Parameter         *\n*           area.                                                     *\n*                                                                     *\n* CHANGE ACTIVITY =                                                   *\n* 96/10/16 XXX Initial Version                                 @23418N*\n*                                                                     *\n***** END OF SPECIFICATIONS *******************************************\n*\nANFUXEDA CSECT ,                   Establish the csect\nANFUXEDA AMODE ANY                 It addresses all storage\nANFUXEDA RMODE ANY                 It can reside anywhere\n         USING ANFUXEDA,R15        Establish temporary addressability  X\n                                   to module\n         B     BDSINIT             Branch around copyright information\nANFUXEDA MODID BR=NO                       EYECATCHER INFO\n         DC    C'LICENSED MATERIALS-PROPERTY OF IBM  '\n         DC    C'THIS MODULE IS \"RESTRICTED MATERIALS OF IBM\"  '\n         DC    C'5695-040 (c) COPYRIGHT IBM CORP. 1996  '\n         DC    C'SEE COPYRIGHT INSTRUCTIONS  '\n         EJECT ,\n*---------------------------------------------------------------------*\n*   ANFUXEDA Module entry point                                       *\n*---------------------------------------------------------------------*\n*\nBDSINIT  DS    0H\n         STM   R14,R12,12(R13)     Save callers registers\n         LR    R12,R15             Move base register to R12\n         DROP  R15                 Done with this register\n         USING ANFUXEDA,R12        R12 is base reg for program code\n         L     R4,0(R1)            Get address of parm area\n         USING ANFUEXTP,R4         R4 is base for parm area\n         ST    R13,XTPSAVE+4       chain save areas\n         LA    R15,XTPSAVE         get my save area\n         ST    R15,8(R13)          point callers save area to it\n         LR    R13,R15             point R13 to my save area\n         L     R6,XTPJSPAP         Get address of parm area\n         USING IAZJSPA,R6          R6 is base for jspa area\n         L     R7,XTPSWBTP         Get address of parm area\n         L     R8,XTPSWBTL         Get length of parm area\n         BCTR  R8,R0               Subtract 1 from length\n         AR    R8,R7               R8 is endpoint of parm area\n*---------------------------------------------------------------------*\n*        Get storage for work area                                    *\n*---------------------------------------------------------------------*\n*\n         SLR   R2,R2               get a zero\n         L     R9,XTPWORK1         get working storage addr\n         USING BDSSTG,R9\n         CR    R9,R2               has work area been gotten?\n         BNE   BDSDOIT             yes, skip this\n         LA    R2,BDSSTGL          Get length of DSECT\n         GETMAIN RU,LV=(2),LOC=ANY Get program storage area\n         LR    R9,R1\n         ST    R4,BDSWORKB         put addr of parm\n         MVC   WRKJTBL,PYEARTAB    FOR POSSIBLE UPDATE\n         ST    R9,XTPWORK1         save working storage addr\n*\n***********************************************************************\n*        Actual work - call to get block characters                   *\n***********************************************************************\nBDSDOIT  DS    0H\n         MVI   XTPBOUTP,C' '       begin blank line\n         MVC   XTPBOUTP+1(L'XTPBOUTP-1),XTPBOUTP  blank the line\n         TM    XTPDSFLG,XTPDSEJB   last data set in job?\n         BNO   BDSTRT              No, initialize status flags\n         TM    XTPRCFLG,XTPRDFST   first call for data set?\n         BNO   BDSREST             no, don't do init stuff\nBDSTRT   DS    0H\n***********************************************************************\n*        Actual work - initialize status flags                        *\n***********************************************************************\n         TM    XTPRCFLG,XTPRDFST   first call for data set?\n         BNO   BDSREST             no, don't do init stuff\n         MVI   XTPRCFLG,0          zero flags\n         MVI   BDSWORKD,0          clear status flags\n         MVC   BDSWORKD+1(15),BDSWORKD  clear the status flags\n         TM    XTPDSFLG,XTPDSEJB   last data set in job?\n         BO    BDSREST             yes, produce header\n         OI    XTPRCFLG,XTPRLAST   don't call again\n         B     DOLINE\nBDSREST  DS    0H\n         OI    XTPRCFLG,XTPRCCC    assume it has carriage control\n         CLI   BDSWORKD+1,0        done with last line of text?\n         BNE   DOJOBID1            yes, do last line for page break\nGOTANID  DS    0H\n         MVC   XTPBSTRG,JSPAJBNM   copy job name for conversion\n         MVI   XTPBIFLG,X'00'      default formatting stuff\nSETFLAGS DS    0H\n*        OI    XTPBIFLG,XTPBPRFM   Narrow letters\n*        OI    XTPBIFLG,XTPBLJST   on left margin\nBDSREST1 DS    0H\n         CLI   BDSWORKD,0          done with last line of text?\n         BNE   DOLAST              yes, do last line for page break\n         ST    R4,BDSWORKB         put addr of parm\n         LA    R1,BDSWORKB\n         L     R15,=V(ANFUBLK)     get address of block builder\n         BALR  R14,R15\n         CLI   BDSWORKD+2,0        done with last line of text?\n         BNE   BDSREST2            yes, do last line for page break\n         MVI   XTPBOUTP,X'F1'      put in page eject CC\n         MVI   BDSWORKD+2,1        page eject only once\nBDSREST2 DS    0H\n         TM    XTPBOFLG,XTPBLAST   last one?\n         BNO   NOTLAST             no, keep going\n         MVI   BDSWORKD,1          saw last record, prepare to leave\nNOTLAST  DS    0H\n         SLR   R5,R5               get a zero\n         IC    R5,XTPBLENG         get record length\n         ST    R5,XTPERLEN         set length to print\n         B     DOLINE\nDOLAST   DS    0H\n         CLI   BDSWORKD+3,2        done with last line of text?\n         BH    DOJOBID             yes, do last line for page break\n         CLI   BDSWORKD+1,1        done with last line of text?\n         BH    DOBOX               yes, do the box\n         MVC   XTPBOUTP(2),=C' '   put in blank line CC\n         LA    R5,1                get length of record\n         ST    R5,XTPERLEN         set length to print\n         SR    R5,R5               zero the register\n         LH    R5,BDSWORKD+2       put the counter in the register\n         LA    R5,1(0,R5)          add 1 to it\n         STH   R5,BDSWORKD+2       put it back to the counter\n         B     DOLINE\nDOJOBID  DS    0H\n         CLI   BDSWORKD+1,0        done with last line of text?\n         BH    DOBOX               yes, end of block letters\n         MVI   BDSWORKD,0          not done yet\n         MVI   BDSWORKD+3,0        not done yet\n         MVI   BDSWORKD+1,1        don't do this again\n         MVI   XTPBIFLG,X'00'      default formatting stuff\n         OI    XTPBIFLG,XTPBFRST   first time for block letters\nDOJOBID1 DS    0H\n         MVC   XTPBSTRG,JSPAJBID   copy job id for conversion\n         MVI   XTPBOFLG,X'00'      clear done flag\n         B     SETFLAGS            generate block letters\nDOBOX    DS    0H\n         MVI   XTPBOUTP,C' '       begin blank line\n         MVC   XTPBOUTP+1(L'XTPBOUTP-1),XTPBOUTP  blank the line\n         MVI   XTPBOUTP+30,C'*'    begin asterisk\n         MVI   XTPBOUTP+109,C'*'   ending asterisk\n         LA    R5,110              get length of record\n         ST    R5,XTPERLEN         set length to print\n         SR    R5,R5               zero the register\n         LH    R5,BDSWORKD+6       put the counter in the register\n         LA    R5,1(0,R5)          add 1 to it\n         STH   R5,BDSWORKD+6       put it back to the counter\n         SR    R3,R3\n         ICM   R3,1,BDSWORKD+7\n         SLL   R3,2\n         LA    R5,XTPBOUTP         get record address\n         B     BTABLE(R3)\nBTABLE   DS    F\n         B     DOBOX1\n         B     DOBOX2\n         B     DOLINE\n         B     DOBOX4\n         B     DOBOX5\n         B     DOBOX6\n         B     DOBOX7\n         B     DOBOX8\n         B     DOBOX9\n         B     DOLINE\n         B     DOBOX11\n         B     DOBOX12\n         B     DOBOX13\n         B     DOBOX14\n         B     DOBOX15\n         B     DOBOX16\n         B     DOLINE\n         B     DOBOX18\n         B     DOBOX19\n         B     DOBOX20\n         B     DOBOX21\n         B     DOBOX22\n         B     DOBOX23\n         B     DOBOX24\n         B     DOBOX25\n         B     DOBOX1\n         B     DOEND\nDOBOX1   DS    0H\n         LA    R3,8                setup loop register\n         LA    R5,30(0,R5)         beginning offset into print line\nBOX1LP   DS    0H\n         MVC   0(10,R5),=C'***END****'\n         LA    R5,10(0,R5)         increment offset\n         BCT   R3,BOX1LP           circle around\n         B     DOLINE\nDOBOX2   DS    0H\n         MVC   XTPBOUTP+32(L'PHEAD),PHEAD  constant to print\n         B     DOLINE\nDOBOX4   DS    0H\n         MVC   XTPBOUTP+32(L'PJOBID),PJOBID  constant to print\n         MVC   XTPBOUTP+47(L'JSPAJBID),JSPAJBID job id\n         B     DOLINE\nDOBOX5   DS    0H\n         MVC   XTPBOUTP+32(L'PJOBNM),PJOBNM  constant to print\n         MVC   XTPBOUTP+47(L'JSPAJBNM),JSPAJBNM job name\n         B     DOLINE\nDOBOX6   DS    0H\n         MVC   XTPBOUTP+32(L'PUSERID),PUSERID constant to print\n         MVC   XTPBOUTP+47(L'XTPUSRID),XTPUSRID user id\n         B     DOLINE\nDOBOX7   DS    0H\n         MVC   XTPBOUTP+32(L'PSYSOUTC),PSYSOUTC constant to print\n         MVC   XTPBOUTP+47(L'JSPJSOCL),JSPJSOCL sysout class\n         LA    R10,DOCLASS\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX8   DS    0H\n         MVC   XTPBOUTP+32(L'POUTGRP),POUTGRP constant to print\n         MVC   XTPBOUTP+47(L'JSPJGRPN),JSPJGRPN output group name\n         MVI   XTPBOUTP+55,C'.'    separator\n         SR    R10,R10\n         LH    R10,JSPJGRP1\n         CVD   R10,BDSWORKH\n         MVC   XTPBOUTP+56(5),POGMASK\n         ED    XTPBOUTP+56(5),BDSWORKH+4\n         MVI   XTPBOUTP+62,C'.'    separator\n         SR    R10,R10\n         LH    R10,JSPJGRP2\n         CVD   R10,BDSWORKH\n         MVC   XTPBOUTP+63(5),POGMASK\n         ED    XTPBOUTP+63(5),BDSWORKH+4\n         B     DOLINE\nDOBOX9   DS    0H\n         MVC   XTPBOUTP+32(L'PTITLE),PTITLE  constant to print\n         LA    R10,DOTITLE\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX11  DS    0H\n         MVC   XTPBOUTP+32(L'PPRTTM),PPRTTM  constant to print\n***********************************************************************\n*                                                                     *\n*        Obtain time and date (year 2000 ready)                       *\n*        Routine called if BDSWORKD=7                                 *\n*                                                                     *\n***********************************************************************\n*\n         XC    WRKY2000(16),WRKY2000   Clear\n         TIME  DEC,WRKY2000,LINKAGE=SYSTEM,MF=(E,TIME1)\n         L     R0,WRKY2000+8           Point to date 0YYYYDDD\n         SLL   R0,4                    R0=YYYYDDD0\n         SLR   R1,R1                   R1=00000000\n         IC    R1,=X'0F'               R1=0000000F\n         OR    R0,R1                   R0=YYYYDDDF\n         ST    R0,WRKDATE              Save date packed decimal\n         L     R0,WRKY2000             Point to time HHMMSSTT\n*\n***********************************************************************\n*                                                                     *\n*        Adjust time for am/pm                                        *\n*                                                                     *\n***********************************************************************\n*\n         LA    R2,WRKTIME              Get address of work area\n         MVC   WRKAMPM(2),AM           Set AM/PM to AM\n         CL    R0,=X'12000000'         Test for zero hours\n         BL    PMORNING                Branch if AM\n         MVI   WRKAMPM,C'P'            Change from AM to PM\n         SL    R0,=X'12000000'         Subtract twelve hours\nPMORNING ST    R0,0(,R2)               Store adjusted time\n         CLI   0(R2),X'00'             Test for zero hours\n         BNE   PADJERR                 Br if not to test adj err\n         MVI   0(R2),X'12'             Convert zero to twelve\nPADJERR  TM    0(R2),X'08'             Test for adjustment errors\n         BZ    PEDTIME                 Branch if no error\n         NI    0(R2),X'09'             Correct for binary substr. err\nPEDTIME  DS    0H\n*\n***********************************************************************\n*                                                                     *\n*        Unpack hours minutes seconds                                 *\n*                                                                     *\n***********************************************************************\n*\n         MVI   WRKTH,X'0C'             Reset low order 2 bytes\n*                                      with sign for packed decimal\n         UNPK  WRKUTIME(7),WRKTIME(4)  Unpack time INTO PROPER FIELD\n         CLI   WRKHR,X'F0'             If hour has leading zero\n         BNE   PTIME\n         MVC   WRKHR(1),BLANK          Change zero to blank\nPTIME    DS    0H\n***********************************************************************\n*                                                                     *\n*        Obtain month, day and year                                   *\n*                                                                     *\n***********************************************************************\n*\n         MVC   WRKWORK+4(4),WRKDATE    Obtain date from saved area\n         TM    WRKWORK+5,X'01'          test\n         BO    NOLEAPYR                  for\n         TM    WRKWORK+5,X'12'            leap\n         BM    NOLEAPYR                    year\n         MVI   WRKJTBL+4,29            Adjust feb for leap year\nNOLEAPYR MVC   WRKYY(4),=X'20202020'   Place pattern for edit\n         ED    WRKYY(4),WRKWORK+4      Edit the year\n         MVC   WRKWORK(6),ZEROES       Reset all but julian date\n         SLR   R0,R0                   Clear for ic\n         CVB   1,WRKWORK               Convert to binary day\n         LA    2,WRKJTBL-4             Address od date conversion\n*                                       table\nSEARCH   SLR   R1,R0                     convert\n         LA    R2,4(,R2)                  julian day\n         IC    R0,0(,R2)                   to\n         CLR   R0,R1                        standard day\n         BL    SEARCH\n         CVD   1,WRKWORK               Convert to decimal day\n         UNPK  WRKDD(2),WRKWORK+6(2)   Unpack the day\n         OI    WRKDD+1,X'F0'           Insure sign nibble\n         MVC   WRKMMM(3),1(R2)         Set ebcidic alpha month\n         MVC   XTPBOUTP+47(L'WRKHR),WRKHR print hour\n         MVI   XTPBOUTP+49,C':'        time separator\n         MVC   XTPBOUTP+50(L'WRKMIN),WRKMIN print minute\n         MVI   XTPBOUTP+52,C':'        time separator\n         MVC   XTPBOUTP+53(L'WRKSEC),WRKSEC print second\n         MVC   XTPBOUTP+56(L'WRKAMPM),WRKAMPM print am or pm\n         B     DOLINE\nDOBOX12  DS    0H\n         MVC   XTPBOUTP+32(L'PPRTDT),PPRTDT  constant to print\n         MVC   XTPBOUTP+47(2),WRKDD\n         MVC   XTPBOUTP+50(3),WRKMMM\n         MVC   XTPBOUTP+54(4),WRKYY\n         B     DOLINE\nDOBOX13  DS    0H\n         MVC   XTPBOUTP+32(L'PPRTR),PPRTR  constant to print\n         MVC   XTPBOUTP+47(L'JSPADEVN),JSPADEVN  constant to print\n         B     DOLINE\nDOBOX14  DS    0H\n         MVC   XTPBOUTP+32(L'PSYSID),PSYSID  constant to print\n         L     R10,JSPAJMR\n         USING JMR,R10\n         MVC   XTPBOUTP+47(L'JMRCPUID),JMRCPUID  constant to print\n         DROP  R10\n         B     DOLINE\nDOBOX15  DS    0H\n         MVC   XTPBOUTP+32(L'PPDEF),PPDEF constant to print\n         LA    R10,DOPAGEDE\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX16  DS    0H\n         MVC   XTPBOUTP+32(L'PFDEF),PFDEF  constant to print\n         LA    R10,DOFORMD\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX18  DS    0H\n         MVC   XTPBOUTP+32(L'PDEST),PDEST constant to print\n         MVC   XTPBOUTP+47(L'XTPDEST),XTPDEST sysout destination\n         B     DOLINE\nDOBOX19  DS    0H\n         MVC   XTPBOUTP+32(L'PNAME),PNAME constant to print\n         LA    R10,DONAME\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX20  DS    0H\n         MVC   XTPBOUTP+32(L'PROOM),PROOM constant to print\n         MVC   XTPBOUTP+47(L'JSPJRMNO),JSPJRMNO sysout room\n         LA    R10,DOROOM\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX21  DS    0H\n         MVC   XTPBOUTP+32(L'PBLDG),PBLDG  constant to print\n         LA    R10,DOBUILD\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX22  DS    0H\n         MVC   XTPBOUTP+32(L'PDEPT),PDEPT  constant to print\n         LA    R10,DODEPT\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX23  DS    0H\n         MVC   XTPBOUTP+32(L'PADDRS),PADDRS  constant to print\n         LA    R10,DOADDRES\n         STH   R10,BDSWORKD+4(2)\n         B     SWBSCAN\nDOBOX24  DS    0H\n*        LA    R10,DOADDRES\n*        STH   R10,BDSWORKD+4(2)\n*        B     SWBSCAN\n         B     DOLINE\nDOBOX25  DS    0H\n*        LA    R10,DOADDRES\n*        STH   R10,BDSWORKD+4(2)\n*        B     SWBSCAN\n         B     DOLINE\nDOBOX26  DS    0H\n*        LA    R10,DOADDRES\n*        STH   R10,BDSWORKD+4(2)\n*        B     SWBSCAN\n         B     DOLINE\nDOEND    DS    0H\n         MVC   XTPBOUTP(2),=C'1'   put in page eject CC\n         LA    R5,1                get length of record\n         ST    R5,XTPERLEN         set length to print\n         OI    XTPRCFLG,XTPRLAST   don't call again\n         LA    R2,BDSSTGL          Get length of DSECT\n         FREEMAIN RU,LV=(2),A=(R9) FREE PROGRAM STORAGE AREA\n         SLR   R2,R2               get a zero\n         ST    R2,XTPWORK1         no working storage addr\nDOLINE   DS    0H\n         LA    R5,XTPBOUTP         get record address\n         ST    R5,XTPERPTR         put it in XTP area\n         OI    XTPRCFLG,XTPRCTRN   translate it to ASCII\n         OI    XTPRCFLG,XTPRCEXT   print the record\n*\n*---------------------------------------------------------------------*\n*        Return to caller                                             *\n*---------------------------------------------------------------------*\nGETOUT   DS    0H\n         L     R13,XTPSAVE+4      Get address of caller's save area\n         LM    R14,R12,12(R13)    Restore caller's registers\n         BR    R14                Return to MVS\n*\n*---------------------------------------------------------------------*\n*        Scan SWBTU data area                                         *\n*---------------------------------------------------------------------*\nSWBSCAN  DS    0H\n         USING SJPRFX,R7           R7 is base for swbtu area\n         MVC   BDSWORKH+7(1),SJPRPLEN\n         LR    R11,R7\n         LH    R10,BDSWORKH+6\n         AR    R11,R10             Skip around swbtu prefix area\n         USING DOCNUNIT,R11        R11 is base for data descriptor area\nDOSWBL1  DS    0H\n         MVC   BDSWORKH(2),DOCNTLTH get length of field\n         LH    R10,BDSWORKH         get length of field\n         CLC   DOCNTKEY,BDSWORKD+4 this the field looking for?\n         BE    FNDSWB              yes, move it to output\n         AR    R11,R10             skip field\n         LA    R11,6(0,R11)        skip field headers\n         CR    R11,R8              at the end?\n         BL    DOSWBL1\n         B     OUTSWB              end of SWBTU\nFNDSWB   DS    0H\n         LA    R11,6(0,R11)        skip field headers\n         LA    R5,XTPBOUTP         get record address\n         LA    R5,47(0,R5)         go to beginning of print\nDOSWBL2  DS    0H\n         MVC   0(1,R5),0(R11)\n         LA    R5,1(0,R5)\n         LA    R11,1(0,R11)\n         BCT   R10,DOSWBL2\nOUTSWB   DS    0H\n         B     DOLINE\n*\n*---------------------------------------------------------------------*\n*        Constants and Literals                                       *\n*---------------------------------------------------------------------*\n         DS    0H\nSETUPSTR DS 0C\n*\n         DC X'27'                 escape\n         DC X'50'                 ampersand\n         DC C'l1S'                duplex   0=simplex 1=duplex 2=tumble\n*\n         DC X'27'                 escape\n         DC C'(8U'                code page roman-8\n*\n         DC X'27'                 escape\n         DC C'(s1p8v0s0b4101T'    change font to CG Times\n*\nSETUPLEN EQU  *-SETUPSTR\nSETUPLND DS 0C\n*\n         DC X'27'                 escape\n         DC X'50'                 ampersand\n         DC C'l1O'                landscape format\n*\n         DC X'27'                 escape\n         DC X'50'                 ampersand\n         DC C'l8D'                8 lines per inch\n*\n         DC X'27'                 escape\n         DC C'(10U'               IBM layout default symbol set\n*\n         DC X'27'                 escape\n         DC C'(s0p16.67h8.5v0s0b0T' change font to line printer\n*\nSETUPLNG EQU  *-SETUPLND\nPHEAD    DC   C'IP PRINTWAY V1R1  STC: PRINTWAY'\nPJOBID   DC   C'JOBID:'\nPJOBNM   DC   C'JOB NAME:'\nPUSERID  DC   C'USERID:'\nPSYSOUTC DC   C'SYSOUT CLASS:'\nPOUTGRP  DC   C'OUTPUT GROUP:'\nPTITLE   DC   C'TITLE:'      '\nPDEST    DC   C'DESTINATION:'\nPNAME    DC   C'NAME:'\nPROOM    DC   C'ROOM:'\nPBLDG    DC   C'BUILDING:'\nPDEPT    DC   C'DEPARTMENT:'\nPADDRS   DC   C'ADDRESS:'\nPPRTTM   DC   C'PRINT TIME:'\nPPRTDT   DC   C'PRINT DATE:'\nPPRTR    DC   C'PRINTER NAME:'\nPSYSID   DC   C'SYSTEM NAME:'\nPPDEF    DC   C'PAGEDEF:'\nPFDEF    DC   C'FORMDEF:'\nAM       DC   C'AM'\nBLANK    DC   C' '\nZEROES   DC   X'000000000000'\nPOGMASK  DC    X'2120202020'                MASK\nPYEARTAB DC    AL1(31),C'JAN',AL1(28),C'FEB'  JULIAN\n         DC    AL1(31),C'MAR',AL1(30),C'APR'   TO DAY\n         DC    AL1(31),C'MAY',AL1(30),C'JUN'    AND\n         DC    AL1(31),C'JUL',AL1(31),C'AUG'     MONTH\n         DC    AL1(30),C'SEP',AL1(31),C'OCT'      CONVERSION\n         DC    AL1(30),C'NOV',AL1(255),C'DEC'      TABLE\n         LTORG\n*---------------------------------------------------------------------*\n*        Work area                                                    *\n*---------------------------------------------------------------------*\nBDSSTG   DSECT\nBDSWORKB DS    CL256              area for output record\n         DS    0H\nBDSWORKD DS    8BL1\nBDSWORKH DS    8BL1\nWRKWORK  DS    CL8                     Work area for conversion\nWRKY2000 DS    CL16                    Time SVC work area\nWRKDATE  DS    CL4                     Current date - packed\nWRKTIME  DS    CL4                     Current time - packed\n         ORG   WRKTIME\n         DS    CL3                     Hours minutes seconds\nWRKTH    DS    CL1                     Tenths and hundredths\nWRKUDATE DS    CL8                     Current date - unpacked\n         ORG   WRKUDATE\nWRKMMM   DS    CL3                     Month\nWRKDD    DS    CL2                     Day\nWRKYY    DS    CL4                     Year\n         DS    CL1                     Reserved\nWRKAMPM  DS    CL2                     Current AM/PM\nWRKUTIME DS    CL7                     Current time - unpacked\n         ORG   WRKUTIME\nWRKHR    DS    CL2                     Hour\nWRKMIN   DS    CL2                     Minute\nWRKSEC   DS    CL2                     Second\n         DS    CL1                     Sign byte\nWRKJTBL  DS    CL48                    Julian conversion table\nTIME1    TIME  LINKAGE=SYSTEM,MF=L     Year 2000 ready\n         DS    10F                     Alignment\nDBLWRK   DS    D\n*\nBDSSTGL  EQU   *-BDSSTG          Length of program storage\n         ANFUEXTP LIST=YES\n         IAZJSPA LIST=YES\n         IEFSJPFX DSECT=YES\n         IEFDOTUM\n         IEFDOKEY\n*        IEFJESCT\n         IEFJMR\n*        IEFSJTRC\n*        IEFSJTRP DSECT=NO\n*---------------------------------------------------------------------*\n*        End of Program Storage                                       *\n*---------------------------------------------------------------------*\n*\nR0       EQU   0                   Register\nR1       EQU   1                     equates\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   ,                   End of ANFUXED2 module\n//*   LINK-EDIT OBJECT TO LINKLIB\n//LINK     EXEC PGM=IEWL,\n//  PARM='MAP,LIST,XREF,AC=0,RENT,AMODE=31,RMODE=ANY',\n//        REGION=512K\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(4,1))\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DSN=HHSYS.PROD.LINKLIB,DISP=SHR\n//SANFSAMP DD  DSN=SYS1.SAMPLIB,DISP=SHR\n//SYSMOD   DD  DSN=&&OBJSET,\n//             DISP=(OLD,DELETE)\n//SYSLIN   DD  *\n INCLUDE SYSMOD\n INCLUDE SANFSAMP(ANFUBLK)\n INCLUDE SANFSAMP(ANFUBTBL)\n ENTRY ANFUXEDA\n NAME ANFUXEDA(R)\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBALASM": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x00\\x12O\\x01\\x00\\x12O\\x176\\x00 \\x00 \\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-05-03T00:00:00", "modifydate": "2000-05-03T17:36:24", "lines": 32, "newlines": 32, "modlines": 0, "user": "MSTITT"}, "text": "//MSTITT   JOB  (XSYZ,MSTITT),'MATTHEW STITT',REGION=1024K,\n//             MSGCLASS=X,NOTIFY=MSTITT\n//ASM      EXEC PGM=ASMA90,PARM='NODECK,OBJECT'\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.AMACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//         DD   DSN=SYS1.AMODGEN,DISP=SHR\n//         DD   DSN=SYS1.AGENLIB,DISP=SHR\n//         DD   DSN=MSTITT.SRCE.ASM,DISP=SHR\n//SYSUT1   DD   DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB)\n//SYSUT2   DD   DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(1700,(300,50)),\n//             SEP=(SYSLIB,SYSUT1)\n//SYSUT3   DD   DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(1700,(300,50))\n//SYSPRINT DD   SYSOUT=*\n//SYSPUNCH DD   DUMMY\n//SYSLIN   DD   DSN=&&OBJSET,UNIT=SYSDA,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN DD DSN=MSTITT.SRCE.ASM(COBALLOC),DISP=SHR\n//LKED     EXEC PGM=IEWL,PARM=(LIST,MAP,LET,XREF),\n//             COND=(8,LT,ASM)\n//SYSLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN   DD   DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSUT1   DD   DSN=&&SYSUT1,UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),\n//             SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=*\n//SYSTERM  DD   SYSOUT=*\n//SYSLMOD DD  DSNAME=MSTITT.SRCE.LOAD,DISP=SHR\n//SYSIN  DD  *\n   NAME COBALLOC(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COBALLOC": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00$\\x00\\x90\\x19?\\x01\\x00\"\\x7f\\x142\\x01\\xc7\\x01\\xc5\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1990-07-12T00:00:00", "modifydate": "2000-08-14T14:32:24", "lines": 455, "newlines": 453, "modlines": 0, "user": "MSTITT"}, "text": "         TITLE 'COBALLOC - DYNAMIC SYSOUT ALLOCATION FROM COBOL'\n*      |--------------------------------------------------------------|\n*      |                                                              |\n*      |  PROGRAM ID:     COBALLOC (SYSOUT DYNAMIC ALLOCATION)        |\n*      |  AUTHOR:         R. D. MORTON.                               |\n*      |  DATE:           APRIL 29, 1982.                             |\n*      |                                                              |\n*      |  THIS IS A COPY OF CBLALLOC WITHOUT WTO'S.                   |\n*      |  THIS SUBROUTINE WILL ACCEPT THE CALL PARAMETER LIST FROM    |\n*      |     A COBOL PROGRAM AND BUILDS THE REQUIRED TEXT BLOCKS TO   |\n*      |     ISSUE A SVC 99 DYNAMIC ALLOCATION CALL TO MVS. ONLY      |\n*      |     SYSOUT TYPE ALLOCATIONS ARE SUPPORTED CURRENTLY.         |\n*      |  SAMPLE CALLING SEQUENCE:                                    |\n*      |     LINKAGE SECTION.                                         |\n*      |     01  ALLOCATE-PARMS                                       |\n*      |         05  ALLOC-VERB      PIC X.                           |\n*      |           88  ALLOCATE      VALUE IS 'A'.                    |\n*      |           88  UNALLOCATE    VALUE IS 'U'.                    |\n*      |         05  ALLOC-DDNAME    PIC X(8).                        |\n*      |         05  ALLOC-CLASS     PIC X.                           |\n*      |         05  ALLOC-COPIES    PIC 9(3).                        |\n*      |         05  ALLOC-DEST      PIC X(5).                        |\n*      |         05  ALLOC-FREE      PIC X.                           |\n*      |           88  FREE-CLOSE    VALUE IS 'Y'.                    |\n*      |         05  ALLOC-FORM      PIC X(4).                        |\n*      |         05  ALLOC-FCB       PIC X(4).                        |\n*      |         05  ALLOC-RESERVED  PIC X(12).                       |\n*      |         05  ALLOC-RETURN-CODE PIC 99.                        |\n*      |           88  RET-OK        VALUE 00.                        |\n*      |           88  RET-FAIL-VERB VALUE 01.                        |\n*      |           88  RET-FAIL-ENV  VALUE 04.                        |\n*      |           88  RET-FAIL-REQ  VALUE 08.                        |\n*      |           88  RET-FAIL-PARM VALUE 12.                        |\n*      |         05  ALLOC-ERROR     PIC 9999.                        |\n*      |         05  ALLOC-INFO      PIC 9999.                        |\n*      |         .                                                    |\n*      |         .                                                    |\n*      |     PROCEDURE DIVISION                                       |\n*      |     CALL 'COBALLOC ' USING ALLOCATE-PARMS.                   |\n*      |                                                              |\n*      |                                                              |\n*      |--------------------------------------------------------------|\n         EJECT\nR0       EQU   0                    /*    NOT USED                   */\nR1       EQU   1                    /* PARM ADDR. DYNALLOC PARM PTR  */\nR2       EQU   2                    /* CVB WORK, VAR PARM INDEX      */\nR3       EQU   3                    /* TEXT BLOCK ADDRESSES          */\nR4       EQU   4                    /* WORK REGISTER.                */\nR5       EQU   5                    /*    NOT USED                   */\nR6       EQU   6                    /* ADDRESS OF CALLERS I/O AREA   */\nR7       EQU   7                    /*    NOT USED                   */\nR8       EQU   8                    /*    NOT USED                   */\nR9       EQU   9                    /*    NOT USED                   */\nR10      EQU   10                   /*    NOT USED                   */\nR11      EQU   11                   /* TEMP BASE REG                 */\nR12      EQU   12                   /* BASE REGISTER                 */\nR13      EQU   13                   /* SAVE AREA POINTER             */\nR14      EQU   14                   /* RETURN ADDRESS                */\nR15      EQU   15                   /* ENTRY ADDRESS, DYNALLOC RTCD  */\n         EJECT\nPARMLIST DSECT                      /* OVERLAY FOR USERS I/O AREA    */\n         USING PARMLIST,R6          /* R6 IS BASE FOR USER I/O AREA  */\n*                                   /*                               */\nUSERPARM DS    0CL37                /*                               */\nUSERVERB DS    C                    /* A=ALLOC, U=UNALLOC            */\nUSERDDNM DS    CL8                  /* DDNAME                        */\nUSERCLAS DS    C                    /* CLASS                         */\nUSERCOPY DS    CL3                  /* NUMBER OF COPIES              */\nUSERDEST DS    CL5                  /* DESTINATION ID                */\nUSERFREE DS    C                    /* Y MEANS USE FREE=CLOSE        */\nUSERFORM DS    CL4                  /* FORM NAME                     */\nUSERFCB  DS    CL4                  /* FCB NAME                      */\nUSERRES  DS    CL12                 /* RESERVED FOR EXPANSION        */\nUSERRET  DS    CL2                  /* USER RETURN CODE              */\nUSERERR  DS    CL4                  /* USER ERROR CODE               */\nUSERINFO DS    CL4                  /* USER ERROR INFO CODE          */\n         EJECT\nCOBALLOC CSECT                      /* IDENTIFY ENTRY POINT          */\n*                                   /*                               */\n         SAVE  (14,12)              /* SAVE CALLER'S REGISTERS       */\n         BALR  R12,0                /* LOAD R12 AS BASE REGISTER     */\n         USING *,12                 /* TELL ASSEMBLER WHO'S BOSS     */\n         ST    R13,SAVEAREA+4       /* SAVE ADDR OF CALLER'S SAVEAREA*/\n         LA    R11,SAVEAREA         /* GET ADDR OF MY SAVEAREA       */\n         ST    R11,8(R13)           /* TELL CALLER WHERE MY AREA IS  */\n         LR    R13,R11              /* GET ADDR OF MY SAVEAREA IN R13*/\n         B     GOON                 /*                               */\n         SPACE 3                    /*                               */\n         DC    CL8'COBALLOC'        /* PROGRAM NAME TO PRT ON DUMPS  */\n*                                   /*                               */\nGOON     EQU   *                    /*                               */\n         L     R6,0(R1)             /* GET PARM ADDRESS IN R6        */\n         CLI   USERVERB,C'A'        /* TEST FOR ALLOCATE VERB        */\n         BE    ALLOCATE             /* BRANCH IF ALLOCATE            */\n         CLI   USERVERB,C'U'        /* TEST FOR UNALLOCATE VERB      */\n         BE    UNALLOC              /* BRANCH IF UNALLOCATE          */\n         MVC   USERRET,=C'01'       /* SET INVALID VERB CODE         */\n         B     RETURN               /* RETURN TO USER                */\n         SPACE 3                    /*                               */\nALLOCATE EQU   *                    /* START BUILDING ALLOC PARM     */\n         SPACE 1                    /*                               */\nTDDNAME0 EQU   *                    /* TEST USERS DDNAME FIELD       */\n         CLC   USERDDNM,BLANKS      /* IS DDNAME BLANK               */\n         BNE   TDDNAME1             /* NO-GO SET DDNAME              */\n*        MVC   DDNAME,=C'SYSOUT  '  /* SET DEFAULT OF SYSOUT         */\n         MVC   USERDDNM,=C'SYSOUT  ' * SET DEFAULT OF SYSOUT         */\n*        B     TDDNAME9             /* GO TO END OF DDNAME TESTS     */\nTDDNAME1 MVC   DDNAME,USERDDNM      /* MOVE USERS DDNAME TO TEXT BLK */\nTDDNAME9 EQU   *                    /*                               */\n         SPACE 1                    /*                               */\nTCLASS0  EQU   *                    /* TEST USERS CLASS FIELD        */\n         CLI   USERCLAS,C' '        /* IS CLASS  BLANK               */\n         BNE   TCLASS1              /* NO-GO SET CLASS CODE          */\n*        MVI   CLASS,C'A'           /* SET DEFAULT CLASS=A           */\n         MVI   USERCLAS,C'A'        /* SET DEFAULT CLASS=A           */\n*        B     TCLASS9              /* GO TO END OF CLASS TESTS      */\nTCLASS1  MVC   CLASS,USERCLAS       /* MOVE USERS CLASS TO TEXT BLK  */\nTCLASS9  EQU   *                    /*                               */\n         SPACE 1                    /*                               */\nTCOPIES0 EQU   *                    /* TEST USERS COPIES FIELD       */\n         CLC   USERCOPY,BLANKS      /* IS COPIES BLANK               */\n         BNE   TCOPIES2             /* NO-GO TEST FOR NUMERICS       */\nTCOPIES1 LA    R2,1                 /* SET DEFAULT COPIES=1          */\n         B     TCOPIES3             /* GO TO END OF COPIES TESTS     */\nTCOPIES2 EQU   *                    /*                               */\n         LA    R4,256               /* GET 256 IN R4                 */\n         PACK  CVBAREA,USERCOPY     /* PACK THE USER COPIES FIELD    */\n         CVB   R2,CVBAREA           /* CONVERT COPIES TO BINARY      */\n         LTR   R2,R2                /* SET CONDITION CODE            */\n         BNP   TCOPIES1             /* IF NOT POSITIVE SET DEFAULT 1 */\n         CR    R2,R4                /* COMPARE COPIES TO 256         */\n         BL    TCOPIES3             /* BRANCH IF COPIES LESS THAN 256*/\n         LA    R2,255               /* SET COPIES TO 255             */\nTCOPIES3 STC   R2,COPIES            /* STORE LOW BYTE IN COPIES PARM */\n         CVD   R2,CVBAREA           /* CONVERT MODIFIED COPIES TO PD.*/\n         UNPK  USERCOPY,CVBAREA+6(2) * UNPACK COPIES INTO USER AREA  */\n         OI    USERCOPY+2,X'F0'     /* FORCE NO SIGN IN LAST CHAR    */\nTCOPIES9 EQU   *                    /*                               */\n         SPACE 1                    /*                               */\nTDEST0   EQU   *                    /* TEST USERS DEST FIELD         */\n         CLC   USERDEST,BLANKS      /* IS DEST FIELD BLANK           */\n         BNE   TDEST1               /* NO-GO SET DEST CODE           */\n*        MVC   DEST,=C'LOCAL'       /* SET DEFAULT DEST=LOCAL        */\n         MVC   USERDEST,=C'LOCAL'   /*                               */\n*        B     TDEST9               /* GO TO END OF DEST TESTS       */\nTDEST1   MVC   DEST,USERDEST        /* MOVE USERS DEST TO TEXT BLK   */\nTDEST9   EQU   *                    /*                               */\n         SPACE 1                    /*                               */\n*  TEST OPTIONAL FIELDS TO SEE IF ANY ARE NONBLANK                   */\nOPTTEST  CLI   USERFREE,C'Y'        /* TEST FOR FREE=CLOSE           */\n         BE    TOPTION              /* BRANCH IF CLOSE SPECIFIED     */\n         CLI   USERFORM,C' '        /* TEST IF FORM NAME BLANK       */\n         BNE   TOPTION              /* BRANCH IF FORM SPECIFIED      */\n         CLI   USERFCB,C' '         /* TEST IF FCB  NAME BLANK       */\n         BNE   TOPTION              /* BRANCH IF FCB  SPECIFIED      */\n         SPACE 1                    /*                               */\n*  NO OPTIONAL PARMS WERE SPECIFIED- SET END OF PARM BIT             */\n         MVI   ALLOCPRV-4,X'80'     /*  SET AT END OF FIXED PARM LIST*/\n         B     ALLOCSVC             /* GO ISSUE ALLOCATE SVC 99      */\n         SPACE 1                    /*                               */\n*  ONE OR MORE OPTIONAL PARMS WERE SPECIFIED\nTOPTION  LA    R2,ALLOCPRV-4        /* GET START OF VAR PARM AREA    */\n         MVI   ALLOCPRV-4,X'00'     /* RESET END OF LIST BIT         */\n         SPACE 1                    /*                               */\n*                                   /*                               */\nTFREE0   CLI   USERFREE,C'Y'        /* TEST FOR FREE=CLOSE           */\n         BNE   TFORM0               /* NO FREE=CLOSE, GO TEST FORM   */\n         LA    R2,4(R2)             /* ADD 4 TO OFFSET ADDRESS       */\n         LA    R3,TXFREE            /* GET ADDRESS OF FREE=CLOSE TEXT*/\n         ST    R3,0(R2)             /* STORE IN VARIABLE PART OF PARM*/\n         SPACE 1                    /*                               */\nTFORM0   EQU   *                    /*                               */\n         CLI   USERFORM,C' '        /* IS FORM NAME SPECIFIED        */\n         BE    TFCB0                /* NO-GO TEST FOR FCB            */\n         MVC   FORM,USERFORM        /* MOVE FORM NAME TO TEXT BLK    */\n         LA    R2,4(R2)             /* ADD 4 TO OFFSET ADDRESS       */\n         LA    R3,TXFORM            /* GET ADDRESS OF FORM TEXT BLK  */\n         ST    R3,0(R2)             /* STORE IN VARIABLE PART OF PARM*/\n         SPACE 1                    /*                               */\nTFCB0    EQU   *                    /*                               */\n         CLI   USERFCB,C' '         /* IS FCB  NAME SPECIFIED        */\n         BE    SETEND               /* NO-GO SET END OF PARM LIST BIT*/\n         MVC   FCB,USERFCB          /* MOVE FCB  NAME TO TEXT BLK    */\n         LA    R2,4(R2)             /* ADD 4 TO OFFSET ADDRESS       */\n         LA    R3,TXFCB             /* GET ADDRESS OF FCB  TEXT BLK  */\n         ST    R3,0(R2)             /* STORE IN VARIABLE PART OF PARM*/\n         SPACE 1                    /*                               */\nSETEND   MVI   0(R2),X'80'          /* SET END OF PARM LIST BIT      */\n         SPACE 2                    /*                               */\n* ISSUE DYNALLOC INSTRUCTION AND REPORT COMPLETION STATUS            */\nALLOCSVC EQU   *                    /* PREPARE TO ISSUE SVC 99 ALLOC */\n         LA    R1,DYNALLOC          /* LOAD ADDRESS OF PARM PTR IN R1*/\n         DYNALLOC                   /* ISSUE SVC99 DYNAMIC ALLOCATE  */\n         CVD   R15,CVBAREA          /* CONVERT RETURN CODE TO PD.    */\n         UNPK  AMSGRET,CVBAREA+6(2) /* UNKP RETURN CODE INTO MSG     */\n         OI    AMSGRET+1,X'F0'      /* FORCE NO SIGN IN LAST CHAR    */\n         MVC   USERRET,AMSGRET      /* MOVE RETURN CODE TO USER      */\n         LTR   R15,R15              /* SET CONDITION CODE            */\n         BP    ALOCFAIL             /* GO WRITE FAILED MESSAGE       */\n*        WTO   MF=(E,ALOCOK)        /* WRITE ALLOCATION SUCCESSFUL   */\n*        DOM   MSG=(1),REPLY=YES    /* DELETE MSG FROM CONSOLE       */\n         B     ALLOC1               /*                               */\nALOCFAIL WTO   MF=(E,ALOCNO)        /* WRITE ALLOCATION FAILED       */\n*        DOM   MSG=(1),REPLY=YES    /* DELETE MSG FROM CONSOLE       */\nALLOC1   EQU   *\n         L     R15,ALLOCERR         /* GET ERROR AND INFO CODES      */\n         LR    R4,R15               /* COPY R15 INTO R4              */\n         SRL   R4,16                /* SHIFT ERR CODE TO RIGHT       */\n         CVD   R4,CVBAREA           /* CONVERT ERR CODE TO PD.       */\n         UNPK  AMSGERR,CVBAREA+5(3) /* UNKP ERROR CODE INTO MESSAGE  */\n         OI    AMSGERR+3,X'F0'      /* FORCE NO SIGN IN LAST CHAR    */\n         MVC   USERERR,AMSGERR      /* MOVE ERROR CODE TO USER       */\n         SLL   R15,16               /* CLEAR HIGH                    */\n         SRL   R15,16               /*    BITS OF R15 (INFO CODE)    */\n         CVD   R15,CVBAREA          /* CONVERT INFO CODE TO PD.      */\n         UNPK  AMSGINFO,CVBAREA+5(3)   UNKP INFO CODE INTO MESSAGE   */\n         OI    AMSGINFO+3,X'F0'     /* FORCE NO SIGN IN LAST CHAR    */\n         MVC   USERINFO,AMSGINFO    /* MOVE INFO  CODE TO USER       */\n         MVC   AMSGDDNM,USERDDNM    /* MOVE DDNAME TO MESSAGE        */\n         MVC   AMSGCLAS,USERCLAS    /* MOVE CLASS TO MESSAGE         */\n         MVC   AMSGCOPY,USERCOPY    /* MOVE COPIES TO MESSAGE        */\n         MVC   AMSGDEST,USERDEST    /* MOVE DEST TO MESSAGE          */\n         MVC   AMSGFREE,USERFREE    /* MOVE FREE=CLOSE TO MESSAGE    */\n         MVC   AMSGFORM,USERFORM    /* MOVE FORM TO MESSAGE          */\n         MVC   AMSGFCB,USERFCB      /* MOVE FCB TO MESSAGE           */\n*        WTO   MF=(E,ALLOCMSG)      /* WRITE ALLOCATION MESSAGE      */\n*        DOM   MSG=(1),REPLY=YES    /* DELETE MSG FROM CONSOLE       */\n         B     RETURN               /* RETURN TO USER                */\n         SPACE 3                    /*                               */\n* SET UP FOR DYNAMIC DE-ALLOCATION                                   */\nUNALLOC  EQU   *                    /* START BUILDING UNALLOC PARM   */\n         SPACE 1                    /*                               */\nTDDNM0   EQU   *                    /* TEST USERS DDNAME FIELD       */\n         CLC   USERDDNM,BLANKS      /* IS DDNAME BLANK               */\n         BNE   TDDNM1               /* NO-GO SET DDNAME              */\n         MVC   DDNAME,=C'SYSOUT  '  /* SET DEFAULT OF SYSOUT         */\n         MVC   USERDDNM,=C'SYSOUT  ' * SET DEFAULT OF SYSOUT         */\n         B     TDDNM9               /* GO TO END OF DDNAME TESTS     */\nTDDNM1   MVC   DDNAME,USERDDNM      /* MOVE USERS DDNAME TO TEXT BLK */\nTDDNM9   EQU   *                    /*                               */\n         SPACE 1                    /*                               */\n* ISSUE DYNALLOC INSTRUCTION AND REPORT COMPLETION STATUS            */\nUNALLOCS EQU   *                    /* PREPARE TO ISSUE SVC 99 ALLOC */\n         LA    R1,DYNUNALL          /* LOAD ADDRESS OF PARM PTR IN R1*/\n         DYNALLOC                   /* ISSUE SVC99 DYNAMIC ALLOCATE  */\n         CVD   R15,CVBAREA          /* CONVERT RETURN CODE TO PD.    */\n         UNPK  UMSGRET,CVBAREA+6(2) /* UNKP RETURN CODE INTO MSG     */\n         OI    UMSGRET+1,X'F0'      /* FORCE NO SIGN IN LAST CHAR    */\n         MVC   USERRET,UMSGRET      /* MOVE RETURN CODE TO USER      */\n         LTR   R15,R15              /* SET CONDITION CODE            */\n         BP    UNALFAIL             /* GO WRITE FAILED MESSAGE       */\n*        WTO   MF=(E,UNALOK)        /* WRITE UNALLOCATION SUCCESSFUL */\n*        DOM   MSG=(1),REPLY=YES    /* DELETE MSG FROM CONSOLE       */\n         B     UNALLOC1             /*                               */\nUNALFAIL WTO   MF=(E,UNALNO)        /* WRITE UNALLOCATION FAILED     */\n*        DOM   MSG=(1),REPLY=YES    /* DELETE MSG FROM CONSOLE       */\nUNALLOC1 EQU   *\n         L     R15,UNALLERR         /* GET ERROR AND INFO CODE       */\n         LR    R4,R15               /* COPY R15 INTO R4              */\n         SRL   R4,16                /* SHIFT ERR CODE TO RIGHT       */\n         CVD   R4,CVBAREA           /* CONVERT ERR CODE TO PD.       */\n         UNPK  UMSGERR,CVBAREA+5(3) /* UNKP ERROR CODE INTO MESSAGE  */\n         OI    UMSGERR+3,X'F0'      /* FORCE NO SIGN IN LAST CHAR    */\n         MVC   USERERR,UMSGERR      /* MOVE ERROR CODE TO USER       */\n         SLL   R15,16               /* CLEAR HIGH                    */\n         SRL   R15,16               /*    BITS OF R15 (INFO CODE)    */\n         CVD   R15,CVBAREA          /* CONVERT INFO CODE TO PD.      */\n         UNPK  UMSGINFO,CVBAREA+5(3)   UNKP INFO CODE INTO MESSAGE   */\n         OI    UMSGINFO+3,X'F0'     /* FORCE NO SIGN IN LAST CHAR    */\n         MVC   USERINFO,UMSGINFO    /* MOVE INFO CODE TO USER        */\n         MVC   UMSGDDNM,USERDDNM    /* MOVE DDNAME TO MESSAGE        */\n*        WTO   MF=(E,UNALLMSG)      /* WRITE UNALLOCATION MESSAGE    */\n*        DOM   MSG=(1),REPLY=YES    /* DELETE MSG FROM CONSOLE       */\n         B     RETURN               /* RETURN TO USER                */\n         SPACE 1                    /*                               */\n*                                   /*                               */\nRETURN   L     R13,SAVEAREA+4       /* RESTORE ADDR OF CALLERS SAVEAREA\n         RETURN (14,12),RC=0        /* RESTORE REGS AND RETURN       */\n*\n         SPACE 3                    /*                               */\n         CNOP  0,8                  /*                               */\n         DC    CL8'SAVEAREA'        /*                               */\nSAVEAREA DC    18F'0'               /* REGISTER SAVE AREA            */\n         SPACE 2                    /*                               */\nCVBAREA  DC    PL8'1'               /* WORK AREA FOR COPIES PARM     */\nBLANKS   DC    8C' '                /* DEFINE 8 BLANKS               */\n         CNOP  0,4                  /*                               */\n         DC    CL8'ALLOCBLK'        /*                               */\n         SPACE 3                    /*                               */\nDYNALLOC DC    X'80'                /* POINTER TO DYN ALLOC REQ BLK  */\n         DC    AL3(ALLOCBLK)        /*  TO BE LOADED IN R1           */\n         SPACE 3                    /*                               */\nALLOCBLK DS    0CL20                /* DYNAMIC ALLOCATION REQ BLOCK  */\n         DC    X'14'                /* LENGTH OF REQUEST BLOCK       */\nALLOCVB  DC    X'01'                /* ALLOCATE VERB = '01'          */\nALLOCF1  DC    B'0001000000000000'  /* ALLOCATE FLAGS 1 FIELD        */\nALLOCERR DC    X'0000'              /* ERROR RETURN CODE             */\nALLOCINF DC    X'0000'              /* INFO RETURN CODE              */\nALLOCTX  DC    AL4(ALLOCPRM)        /* POINTER TO ALLOCATE PARM LIST */\n         DC    X'00000000'          /* RESERVED                      */\nALLOCF2  DC    X'00000000'          /* ALLOCATE FLAGS 2              */\n         SPACE 3                    /*                               */\nALLOCPRM DS    0CL16                /* ALLOCATE PARM LIST            */\n         DC    AL4(TXDDNAME)        /* POINTER TO DDNAME TEXT BLOCK  */\n         DC    AL4(TXCLASS)         /* POINTER TO CLASS  TEXT BLOCK  */\n         DC    AL4(TXCOPIES)        /* POINTER TO COPIES TEXT BLOCK  */\n         DC    AL4(TXDEST)          /* POINTER TO DEST   TEXT BLOCK  */\nALLOCPRV EQU   *                    /* START OF VARIABLE PARM LIST   */\n         DC    AL4(0)               /* DEFINE AREA FOR 4 MORE PARMS  */\n         DC    AL4(0)               /* DEFINE AREA FOR 4 MORE PARMS  */\n         DC    AL4(0)               /* DEFINE AREA FOR 4 MORE PARMS  */\n         DC    AL4(0)               /* DEFINE AREA FOR 4 MORE PARMS  */\n         SPACE 3                    /*                               */\n         CNOP  0,4                  /*                               */\n         DC    CL8'UNALLBLK'        /*                               */\nDYNUNALL DC    X'80'                /* POINTER TO DYN UNALLOC REQ BLK*/\n         DC    AL3(UNALLBLK)        /*  TO BE LOADED IN R1           */\n         SPACE 3                    /*                               */\nUNALLBLK DS    0CL20                /* DYNAMIC UNALLOCATE REQ BLOCK  */\n         DC    X'14'                /* LENGTH OF REQUEST BLOCK       */\nUNALLVB  DC    X'02'                /* UNALLOCATE VERB = '02'        */\nUNALLF1  DC    B'0001000000000000'  /* UNALLOC FLAGS 1 FIELD         */\nUNALLERR DC    X'0000'              /* ERROR RETURN CODE             */\nUNALLINF DC    X'0000'              /* INFO RETURN CODE              */\nUNALLTX  DC    AL4(UNALLPRM)        /* POINTER TO UNALLOC PARM LIST  */\n         DC    X'00000000'          /* RESERVED                      */\nUNALLF2  DC    X'00000000'          /* UNALLOCATE FLAGS 2            */\n         SPACE 3                    /*                               */\nUNALLPRM DS    0CL4                 /* UNALLOCATE PARM LIST          */\n         DC    X'80'                /* SET HIGH ORDER BIT            */\n         DC    AL3(TXDDNAME)        /* POINTER TO DDNAME TEXT BLOCK  */\n         SPACE 3                    /*                               */\n***********************************************************************\n*        DDNAME TEXT BLOCK                                           *\n***********************************************************************\nTXDDNAME DC    X'0001'              /* DDNAME TEXT KEY = '0001'      */\n         DC    X'0001'              /* NUMBER OF FIELDS = 1          */\n         DC    X'0008'              /* LENGTH OF PARM                */\nDDNAME   DC    C'SYSOUT  '          /* DDNAME                        */\n         SPACE 3                    /*                               */\n***********************************************************************\n*        CLASS TEXT BLOCK                                            *\n***********************************************************************\nTXCLASS  DC    X'0018'              /* CLASS  TEXT KEY = '0018'      */\n         DC    X'0001'              /* NUMBER OF FIELDS = 1          */\n         DC    X'0001'              /* LENGTH OF PARM                */\nCLASS    DC    C'A'                 /* CLASS                         */\n         SPACE 3                    /*                               */\n***********************************************************************\n*        COPIES TEXT BLOCK                                           *\n***********************************************************************\nTXCOPIES DC    X'001D'              /* COPIES TEXT KEY = '001D'      */\n         DC    X'0001'              /* NUMBER OF FIELDS = 1          */\n         DC    X'0001'              /* LENGTH OF PARM                */\nCOPIES   DC    X'01'                /* NUMBER OF COPIES              */\n         SPACE 3                    /*                               */\n***********************************************************************\n*        DESTINATION TEXT BLOCK                                      *\n***********************************************************************\nTXDEST   DC    X'0058'              /* DEST TEXT KEY = '0058'        */\n         DC    X'0001'              /* NUMBER OF FIELDS = 1          */\n         DC    X'0005'              /* LENGTH OF PARM                */\nDEST     DC    C'LOCAL'             /* DESTINATION ID                */\n         SPACE 3                    /*                               */\n***********************************************************************\n*        FORMS TEXT BLOCK                                            *\n***********************************************************************\nTXFORM   DC    X'001A'              /* FORM TEXT KEY = '001A'        */\n         DC    X'0001'              /* NUMBER OF FIELDS = 1          */\n         DC    X'0004'              /* LENGTH OF PARM                */\nFORM     DC    C'    '              /* FORM NAME                     */\n         SPACE 3                    /*                               */\n***********************************************************************\n*        FREE=CLOSE TEXT BLOCK                                       *\n***********************************************************************\nTXFREE   DC    X'001C'              /* FREE=CLOSE KEY = '001C'       */\n         DC    X'0000'              /* NUMBER OF FIELDS = 0          */\n         SPACE 3                    /*                               */\n***********************************************************************\n*        FCB TEXT BLOCK                                              *\n***********************************************************************\nTXFCB    DC    X'0025'              /* FCB  TEXT KEY = '0025'        */\n         DC    X'0001'              /* NUMBER OF FIELDS = 1          */\n         DC    X'0004'              /* LENGTH OF PARM                */\nFCB      DC    C'****'              /* FCB NAME                      */\n         EJECT                      /*                               */\n**********************************************************************\n*        MESSAGES TO THE PROGRAMMER AND LOG.                         *\n**********************************************************************\n         CNOP  0,8                  /* ALIGN TO DOUBLEWORD           */\nALOCOK   WTO   'COBALLOC-SYSOUT DYNAMIC ALLOCATION IS SUCCESSFUL     ',X\n               ROUTCDE=11,DESC=10,MF=L\nALOCNO   WTO   'COBALLOC-SYSOUT DYNAMIC ALLOCATION IS UNSUCCESSFUL *** X\n               ERROR **',                                              X\n               ROUTCDE=11,DESC=10,MF=L\nUNALOK   WTO   'CBLUNALC-SYSOUT DYNAMIC DE-ALLOCATION SUCCESSFUL     ',X\n               ROUTCDE=11,DESC=10,MF=L\nUNALNO   WTO   'CBLUNALC-SYSOUT DYNAMIC DE-ALLOCATION UNSUCCESSFUL *** X\n               ERROR **',                                              X\n               ROUTCDE=11,DESC=10,MF=L\n         EJECT                      /*                               */\n         CNOP  0,8                  /* ALIGN TO DOUBLEWORD           */\nALLOCMSG WTO   '-------------------------------------------------------X\n               ---------------------------------------------',         X\n               ROUTCDE=11,DESC=10,MF=L\nAMSGEND  EQU   *                    /*                               */\n* THIS AREA OVERLAYS THE MSG TEXT AREA OF THE PRECEEDING WTO         */\n         ORG   ALLOCMSG+4           /*                               */\nAMSG     DS    0CL100               /*                               */\n         DC    C'COBALLOC-'         /*                               */\n         DC    C'DD='               /*                               */\nAMSGDDNM DC    C'        '          /*                               */\n         DC    C',CLASS='           /*                               */\nAMSGCLAS DC    C' '                 /*                               */\n         DC    C',COPY='            /*                               */\nAMSGCOPY DC    C'   '               /*                               */\n         DC    C',DEST='            /*                               */\nAMSGDEST DC    C'     '             /*                               */\n         DC    C',FREE='            /*                               */\nAMSGFREE DC    C' '                 /*                               */\n         DC    C',FORM='            /*                               */\nAMSGFORM DC    C'    '              /*                               */\n         DC    C',FCB='             /*                               */\nAMSGFCB  DC    C'    '              /*                               */\n         DC    C',RET='             /*                               */\nAMSGRET  DC    C'  '                /*                               */\n         DC    C',ERR='             /*                               */\nAMSGERR  DC    C'    '              /*                               */\n         DC    C',INFO='            /*                               */\nAMSGINFO DC    C'    '              /*                               */\n         ORG   AMSGEND              /* ORG BACK TO END OF LAST WTO   */\n         EJECT                      /*                               */\n         CNOP  0,8                  /* ALIGN TO DOUBLEWORD           */\nUNALLMSG WTO   '-------------------------------------------------------X\n               ---------------------------------------------',         X\n               ROUTCDE=11,DESC=10,MF=L\nUMSGEND  EQU   *                    /*                               */\n* THIS AREA OVERLAYS THE MSG TEXT AREA OF THE PRECEEDING WTO         */\n         ORG   UNALLMSG+4           /*                               */\nUMSG     DS    0CL100               /*                               */\n         DC    C'CBLUNALC-'         /*                               */\n         DC    C'DD='               /*                               */\nUMSGDDNM DC    C'        '          /*                               */\n         DC    C',RET='             /*                               */\nUMSGRET  DC    C'  '                /*                               */\n         DC    C',ERR='             /*                               */\nUMSGERR  DC    C'    '              /*                               */\n         DC    C',INFO='            /*                               */\nUMSGINFO DC    C'    '              /*                               */\n         DC    54C' '               /*                               */\n         ORG   UMSGEND              /* ORG BACK TO END OF LAST WTO   */\n         LTORG\n         IEFZB4D0\n         IEFZB4D2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DADSM": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00H\\x01\\x016\\x1f\\x01\\x05'\\x8f\\x15\\x18\\x05\\x80\\x05$\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2001-12-27T00:00:00", "modifydate": "2005-10-05T15:18:48", "lines": 1408, "newlines": 1316, "modlines": 0, "user": "MSTITT"}, "text": "         MACRO\n         PROLOG\n***********************************************************************\n**                                                                   **\n**                                                                   **\n**              DIRECT ACCESS DEVICE SPACE MANAGER                   **\n**                                                                   **\n**       IS A MANAGEMENT-ORIENTED REPORTING TOOL TO AID IN           **\n**       MONITORING AND CONTROLLING SPACE UTILIZATION                **\n**       CURRENTLY PRODUCES THE FOLLOWING REPORTS-                   **\n**                                                                   **\n**       1.  VOLUME SUMMARY                                          **\n**       2.  SUBSYSTEM SUMMARY                                       **\n**       3.  DATASET SUMMARY                                         **\n**                                                                   **\n**       THESE REPORTS ARE GENERATED ON A SYSTEM-WIDE BASIS          **\n**       FOR ALL VOLUMES ONLINE AND READY AT PROGRAM RUN-TIME.       **\n**                                                                   **\n**       EXAMPLE JCL FOLLOWS:                                        **\n**                                                                   **\n**       //JOBNAME  JOB  (ACCOUNT),PGMRNAME,                         **\n**       //         CLASS=A,MSGCLASS=A,NOTIFY=TS001                  **\n**       //DADSM    EXEC PGM=DADSM                                   **\n**       //SYSPRINT DD   SYSOUT=*                                    **\n**       //MCDS     DD   SYS2.HSM.MCDS         (IF HSM IS INSTALLED) **\n**       //ANYNAME  DD   UNIT=DASD,VOL=SER=ANY,DISP=SHR (OPTIONAL)   **\n**                                                                   **\n**       THIS ROUTINE HAS TWO MODES OF OPERATION:                    **\n**        1 - TOTAL SYSTEM REQUEST                                   **\n**            THIS MODE (THE DEFAULT) WILL CAUSE 'ALL' VOLUMES THAT  **\n**            ARE ONLINE AND READY TO BE INCLUDED IN THE EXECUTION.  **\n**        2 - SPECIFIC VOLUME REQUEST                                **\n**            THIS MODE CAUSES SPECIFIED VOLUMES TO BE THE TARGET    **\n**            OF THE EXECUTION (E.G. LIMITED TO CERTAIN VOLUMES).    **\n**                                                                   **\n**       FOR MODE-1 ABOVE (TOTAL SYSTEM), EACH VOLUME FOUND ONLINE   **\n**       AND READY WILL BE DYNAMICALLY ALLOCATED AND WILL EXCLUDE    **\n**       ALL MSS VOLUMES (DEFAULT).                                  **\n**       IF ALL ONLINE MSS VOLUMES ARE TO BE PROCESSED AS WELL,      **\n**       PROVIDE A PARM AS FOLLOWS:  PARM=MSS                        **\n**                                                                   **\n**       FOR MODE-2 ABOVE (SPECIFIC REQUEST), THE VOLUMES REFLECTED  **\n**       BY USER DEFINDED DATA DEFINITION STATEMENTS WILL BE USED    **\n**       AS INPUT TO THIS ROUTINE.  FOR NON-MVS SYSTEMS, THIS IS     **\n**       THE ONLY VALID OPTION (DYNAMIC ALLOCATION REQ'D).           **\n**                                                                   **\n**       ANY VOLUME WHOSE SERIAL BEGINS WITH 'VM' IS ASSUMED TO BE   **\n**       A VM/370 VOLUME AN IS BYPASSED BY THIS ROUTINE.  THIS IS    **\n**       BECAUSE VM/370 VTOCS ARE NON-STANDARD AND CAUSE EXTENT      **\n**       VIOLATION ERRORS TO BE REFLECTED BY IOS.                    **\n**                                                                   **\n**       NOTE THAT 'SYS1.AMODGEN' IS REQUIRED FOR ASSEMBLY.          **\n**                                                                   **\n**       THIS ROUTINE ORIGINALLY CAME FROM TRAILER-TRAIN COMPANY     **\n**       OF CHICAGO AND WAS MODIFIED AND INSTALLED AT BUCYRUS-ERIE   **\n**       BY LARRY SIMPSON (4-26-77).                                 **\n**                                                                   **\n**       THIS ROUTINE WAS MODIFIED FOR 31 BIT ADDRESSNG AND USAGE    **\n**       OF THE UCBSCAN MACRO BY MATTHEW STITT (06-15-97)            **\n**                                                                   **\n***********************************************************************\n         MEND\n         MACRO\n&LBL     BEGIN\n&LBL     CSECT\n         USING *,R15\n         B     &LBL+72\n         ORG   &LBL+72\n         STM   R14,R12,12(R13)\n         ST    R15,8(R13)\n         ST    R13,4(R15)\n         LR    R13,R15\n         DROP  R15\n         USING &LBL,R13\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRLNK     EQU   10\nRLNK2    EQU   2\n         MEND\n         MACRO\n&LBL     SORT  &START=,&END=,&ENTRYL=,&KEYLEN=,&KEYOFF=,&MODE=\n         TITLE 'DADSM-    DASD RESOURCE MANAGER'\n         LCLC  &OP1,&OP2,&OP3,&OP4\n         LCLC  &OPC,&OPD\n         LCLC  &M\n&OP1     SETC  '0(&KEYLEN,R9)'\n&OP2     SETC  '&ENTRYL'.'(R9)'\n&OP3     SETC  '&ENTRYL'.'(&ENTRYL,R9)'\n&OP4     SETC  '0(&ENTRYL,R9)'\n&OPC     SETC  '&KEYOFF'.'(&KEYLEN,R9)'\n&OPD     SETC  '&KEYOFF'.'+'.'&ENTRYL'.'(R9)'\n&M       SETC  'NH'\n         AIF   ('&MODE' EQ 'A').AN1\n&M       SETC  'NL'\n.AN1     ANOP\n&LBL     NOP   0\nS&SYSNDX EQU   *-1\n         LA    R6,&ENTRYL         PU ENTRY LENGTH\n         L     R7,&END            LOCATION OF TABLE END\n         SR    R7,R6             BACK UP TO LAST ENTRY\n         BCTR  R7,0               -1\nA&SYSNDX L     R9,&START           TABLE START\n         MVI   S&SYSNDX,0          SWITCH OFF\nB&SYSNDX CLC   &OPC,&OPD           COMPARE SUCCEEDING ENTRIES\n         B&M   C&SYSNDX            BRANCH MODE TO BXLE\n         XC    &OP4,&OP2\n         XC    &OP3,0(R9)\n         XC    &OP4,&OP2\n         OI    S&SYSNDX,X'FF'      SET SWAPPED SWITCH\nC&SYSNDX BXLE  R9,R6,B&SYSNDX     SHUFFLE\n         SR    R7,R6             SHUFFLE DOWN\n         CLI   S&SYSNDX,X'FF'      TEST SWAPPED SWITCH\n         BE    A&SYSNDX            DO IT AGIN\n         MEND\n         MACRO\n&LBL     MVOUT &STR,&LN,&END,&MODE,&RTN\n&LBL     L     R3,&STR\n         LA    R4,&LN\n         L     R5,&END\n         SLR   R5,R4\n         MVI   SW,&MODE\n         BAS   RLNK,PRINTHDR\nL&SYSNDX BAS   RLNK2,&RTN\n         BXLE  R3,R4,L&SYSNDX\n         MEND\n         PRINT ON\nDADSM    AMODE 31\nDADSM    RMODE ANY\n         PROLOG\nDADSM    BEGIN                     SETUP\n*AXVOLS  EQU   256                 MAXIMUM NUMBER OF VOLUME SERIALS\nMAXVOLS  EQU   1024                MAXIMUM NUMBER OF VOLUME SERIALS\n*AXINX   EQU   128                 MAXIMUM NUMBER OF DSN QUALIFIERS\n*AXINX   EQU   256                 MAXIMUM NUMBER OF DSN QUALIFIERS\n*AXINX   EQU   384                 MAXIMUM NUMBER OF DSN QUALIFIERS\nMAXINX   EQU   512                 MAXIMUM NUMBER OF DSN QUALIFIERS\n*AX#DSN  EQU   4096                MAXIMUM NUMBER OF DSNAMES IN TABLE\n*AX#DSN  EQU   8192                MAXIMUM NUMBER OF DSNAMES IN TABLE\n*AX#DSN  EQU   16384               MAXIMUM NUMBER OF DSNAMES IN TABLE\n*AX#DSN  EQU   65536               MAXIMUM NUMBER OF DSNAMES IN TABLE\nMAX#DSN  EQU   121072              MAXIMUM NUMBER OF DSNAMES IN TABLE\n         LR    R12,R13             SET SECOND BASEREG\n         LA    R12,4095(R12)\n         LA    R12,1(R12)\n         USING DADSM+4096,R12\n         OI    DYNPARM,X'80'\n         OI    DYNTUC1,X'80'\n         L     R1,0(R1)            PARM POINTER\n         LH    R2,0(R1)            PARM SIZE\n         LTR   R2,R2               ANY PARM?\n         BZ    NOPARM              NO, CONTINUE\n         CH    R2,=H'3'            VALID?\n         BNE   PARMERR             NO, ABEND\n         OC    2(3,R1),=CL3' '     UPPER CASE\n         CLC   2(3,R1),=C'MSS'     VALID?\n         BNE   PARMERR             NO, ABEND\n         OI    SW,MSS              SET OPTION\nNOPARM   EQU   *\n         MVI   HSMSW,C'Y'          INDICATE HSM PROCESSING\n**       INITIALIZE WORKAREAS FOR VOLUME,INDEX,AND DATASET TABLES    **\n         L     R2,VPARM\n         STORAGE OBTAIN,LENGTH=(2),ADDR=VSTART,LOC=(ANY,ANY)\n         L     R2,VSTART           PU START ADDRESS\n         L     R3,VPARM            PU LENGTH\n         AR    R3,R2               CALC END\n         ST    R3,VEND             STORE IT\n         ST    R2,VFREE            STORE FIRST SLOT\n         L     R2,IPARM\n         STORAGE OBTAIN,LENGTH=(2),ADDR=ISTART,LOC=(ANY,ANY)\n         L     R2,ISTART           PU TABLE START\n         L     R3,IPARM            PU TABLE  LENGTH\n         AR    R3,R2               COMPUTE END\n         ST    R3,IEND             STORE TABLE LIMIT\n         ST    R2,IAVAIL           STORE FIRST SLOT\n         L     R2,DPARM\n         STORAGE OBTAIN,LENGTH=(2),ADDR=DSTART,LOC=(ANY,ANY)\n         L     R2,DSTART           PU START\n         L     R3,DPARM            PU LENGTH\n         AR    R3,R2               CALC END\n         ST    R3,DEND             STORE END\n         ST    R2,DAVAIL           STORE FIRST SLOT\n         OPEN  (MCDS,INPUT),MODE=31 OPEN MCDS FOR INPUT\n         LTR   R15,R15             OPEN SUCCESSFUL?\n         BZ    OPENOUT             YES, CONTINUE\n         MVI   HSMSW,C'N'          INDICATE NO HSM PROCESSING\nOPENOUT  EQU   *\n         L     R2,PPARM\n         STORAGE OBTAIN,LENGTH=(2),ADDR=PSTART,LOC=BELOW\n         L     R11,PSTART\n         USING IOASECT,R11\n         MVC   SYSPRINT,SYSPR      COPY SYSPRINT DCB\n         MVC   IEFRDER,IEFRD       COPY IEFRDER DCB\n         MVC   OPENLST,OPENMOD     COPY MODEL OPEN MACRO\n         MVC   CLOSLST,CLOSMOD     COPY MODEL CLOSE MACRO\n         MVC   RDJFLST,RDJFMOD     COPY MODEL RDJFCB MACRO\n         LA    R0,SECR0            GET ADDRESS OF CCW PARAMETER\n         STCM  R0,B'0111',CCW1+1   STORE IT IN CCW\n         LA    R0,SECR1            GET ADDRESS OF CCW PARAMETER\n         STCM  R0,B'0111',CCW5+1   STORE IT IN CCW\n         LA    R0,DSCB1            GET ADDRESS OF CCW DATA AREA\n         STCM  R0,B'0111',CCW4+1   STORE IT IN CCW\n         LA    R2,IOB1             GET ADDRESS OF IOBLOCK\n         LA    R2,35(R2)           BUMP IT UP\n         STCM  R2,B'0111',CCW2+1   STORE IT IN CCW\n         LA    R2,CP1              GET ADDRESS OF CCW PARAMETER\n         LA    R2,08(R2)           BUMP IT UP\n         STCM  R2,B'0111',CCW3+1   STORE IT IN CCW\n         MVC   CP1,CP1A            COPY MODEL CCW STRING\n         LA    R0,EXIT1            GET ADDRESS OF EXIT LIST\n         STCM  R0,B'0111',DCBEXLSA-IHADCB+IEFRDER   STORE IT IN DCB\n         LA    R0,IOB1             GET ADDRESS OF IOBLOCK\n         ST    R0,DCBIOBAD-IHADCB+IEFRDER   STORE IT IN DCB\n         LA    R0,JFCB1            GET ADDRESS OF JFCB DATA AREA\n         STCM  R0,B'0111',EXIT1A   STORE IT IN EXIT LIST\n         MVI   EXIT1,X'87'         MAKE IT THE LAST ENTRY IN LIST\n         LA    R0,SYSEX            GET ADDRESS OF EXIT LIST\n         STCM  R0,B'0111',DCBEXLSA-IHADCB+SYSPRINT  STORE IT IN DCB\n         MVI   SYSEX,X'85'         MAKE IT THE LAST ENTRY IN LIST\n         LA    R0,SYSEXT           GET ADDRESS OF EXECUTABLE CODE\n         STCM  R0,B'0111',SYSEXL   STORE IT IN EXIT LIST\n         MVC   SYSEXT,SYSEXIT1     MOVE THE EXECUTABLE CODE\n         LA    R0,SYSEXIT\n         ST    R0,ADOPEN31\n         OI    ADOPEN31,X'80'\nOPENPRT  OPEN  (SYSPRINT),MF=(E,OPENLST),MODE=31\n         LA    R4,SYSPRINT         PT MESSAGE DCB\n         USING IHADCB,R4\n         TM    DCBOFLGS,OPEN       CHECK COMPLETION\n         DROP  R4\n         BNO   SYSERR1             BRANCH ON FAILURE\n         BAS   RLNK,PRINT          PRIME BUFFER\n         SPACE\n         EJECT\n***********************************************************************\n**                                                                   **\n**       DETERMINE MODE OF OPERATION BY CHECKING TIOT FOR A NON-     **\n**       SYSTEM DD ENTRY.  IF NONE IS FOUND, INDICATE MODE1 AND      **\n**       PROCESS ALL ONLINE/READY DASD VOLUMES.                      **\n**                                                                   **\n**       FOR MODE-2 (SPECIFIC REQUEST), LOOP THROUGH THE TIOT AND    **\n**       PROCESS ALL NON-RESERVED DDNAMES (IF DASD).                 **\n**                                                                   **\n***********************************************************************\n         SPACE 2\n         OI    SW,MODE1            INDICATE MODE-1 PROCESSING\n         EXTRACT TIOTPOSN,'S',FIELDS=(TIOT)\n         L     R15,TIOTPOSN\n         LA    R15,24(R15)         FIRST TIOT DD ENTRY\n         B     CHKTIOT             PROCESS FIRST ENTRY\nNEXTTIOT L     R15,TIOTPOSN        GET TIOT POSITION\nCHKTIOT  SR    R0,R0               CLEAR FOR IC\n         SR    R1,R1               CLEAR FOR IC\n         ST    R0,WORK3\n         MVC   WORK3+3,0(R15)\n         L     R0,WORK3\n         CR    R0,R1\n         BE    TIOTEND             NO SIZE, END OF TIOT\n         AR    R15,R0              NEW ENTRY LOC\n         ST    R15,TIOTPOSN        SAVE NEW TIOT LOCATION\n         CLC   4(3,R15),=CL3'SYS'      SYSTEM ENTRY?\n         BE    NEXTTIOT            YES, SKIP ENTRY\n         CLC   4(8,R15),=CL8'STEPLIB ' SYSTEM ENTRY?\n         BE    NEXTTIOT            YES, SKIP ENTRY\n         CLC   4(8,R15),=CL8'PGM=*.DD' SYSTEM ENTRY?\n         BE    NEXTTIOT            YES, SKIP ENTRY\n         CLC   4(8,R15),=CL8'STEPCAT ' SYSTEM ENTRY?\n         BE    NEXTTIOT            YES, SKIP ENTRY\n         CLC   4(8,R15),=CL8'JOBCAT  ' SYSTEM ENTRY?\n         BE    NEXTTIOT            YES, SKIP ENTRY\n         CLC   4(8,R15),=CL8'MCDS    ' HSM ENTRY?\n         BE    NEXTTIOT            YES, SKIP ENTRY\n         MVC   IEFRDER+DCBDDNAM-IHADCB(8),4(R15) MODIFY DCB DDNAME\n         RDJFCB IEFRDER,MF=(E,RDJFLST)  GET THE JFCB FOR THE FILE\n         MVC   SAVOL1,JFCB1+118    SAVE THE VOLSER\n         XC    WORKAREA,WORKAREA   INITIALIZE UCB WORK AREA\n         UCBSCAN COPY,UCBAREA=UCBA,DYNAMIC=YES,WORKAREA=WORKAREA,      X\n               RANGE=ALL,VOLSER=SAVOL1,DEVCLASS=DASD,RETCODE=WORK1,    X\n               RSNCODE=WORK2\n         CLI   WORK1+3,X'00'\n         BNE   NEXTTIOT\n         LA    R9,UCBA\n         USING UCBOB,R9\n         CLI   JFCB1+8,C'.'        COULD THIS BE A TEMPORARY NAME?\n         BNE   NEXTTIOT            NO, MIGHT BE A CATALOG\n         CLC   JFCB1(3),=CL3'SYS'  IS THIS A TEMPORARY FILE DSN?\n         BE    NOCAT               YES, CANNOT BE A CATALOG\n         B     NEXTTIOT            NO, MUST BE A CATALOG\nNOCAT    DS    0H\n*     A NON-SYSTEM DD ENTRY HAS BEEN FOUND, SET INDICATOR AND PROCESS\n         OI    SW,MODE2            INDICATE MODE-2 PROCESSING\n         B     PROCESS             PROCESS THIS DEVICE\nTIOTEND  TM    SW,MODE2            END OF TIOT, MODE-2?\n         BO    NEOJ                YES, PROVIDE REPORT\n         XC    WORKAREA,WORKAREA   INITIALIZE UCB WORK AREA\n***********************************************************************\n**                                                                   **\n**       FOR MODE-1 (ALL DASD DEVICES), LOOP THROUGH THE ALL UCB'S   **\n**       VIA ISOVSUCB AND PROCESS EACH DEVICE FOUND READY AND ONLINE.**\n**                                                                   **\n***********************************************************************\nNEXTUCB  DS    0H\n         UCBSCAN COPY,UCBAREA=UCBA,WORKAREA=WORKAREA,DYNAMIC=YES,      X\n               DEVCLASS=DASD,RANGE=ALL,RETCODE=WORK1,RSNCODE=WORK2\n         CLI   WORK1+3,X'04'\n         BE    NEOJ                NO, NORMAL END OF JOB\n         BH    DYNWTO              UCBSCAN FAILURE\n         LA    R9,UCBA             PU UCB ADDRESS\n         TM    UCBSTAT,X'80'       ONLINE?\n         BZ    NEXTUCB             NO\n         TM    UCBFL1,X'40'        NOT READY?\n         BO    NEXTUCB             YES\n         TM    SW,MSS              MSS REQUESTED?\n         BO    VSTOR               YES, CONTINUE\n         TM    UCBTYP+1,X'08'      IS THIS A VIRTUAL VOLUME\n         BO    NEXTUCB             YES, IGNORE MSS VOLUME\nVSTOR    EQU   *\n         MVC   DYNVOL,UCBVOLI      MOVE VOLSER TO DYNALLOC LIST\n         LA    R1,DYNPARM          ADDRESS OF DYNALLOC PARM\n         SVC   99                  ALLOCATE THE DEVICE\n         MVC   IEFRDER+DCBDDNAM-IHADCB(8),DYNDDN MODIFY DCB DDNAME\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    PROCESS             O.K, CONTINUE\n         MVC   DYNWTO+23,UCBVOLI   MODIFY MESSAGE TEXT\nDYNWTO   WTO   'DADSM - VOLUME XXXXXX NOT PROCESSED, DYNALLOC FAILED', X\n               ROUTCDE=11          INFORM USER\n         B     NEXTUCB             PROCESS NEXT DEVICE\n***********************************************************************\n**                                                                   **\n**       FOR EACH DEVICE TO BE PROCESSED, INVOKE THE LSPACE SVC      **\n**       (SVC-78) TO DETERMINE VOLUME FREE SPACE.                    **\n**                                                                   **\n**       BUILD A VOLUME TABLE ENTRY FOR EACH VOLUME ON WHICH LSPACE  **\n**       WAS SUCCESSFUL- DYNAMICALLY ALLOCATE THE DEVICE AND OPEN    **\n**       THE VTOC FOR THE VOLUME FOR EXCP ACCESS.                    **\n**       READ ALL FORMAT ONE DSCB'S ON THE VOLUME BUILDING           **\n**       THE DATASET AND INDEX TABLES CONCURRENTLY                   **\n**                                                                   **\n***********************************************************************\n* PROCESS  LA    R4,VOLRMSG          PU VOLUME MESSAGE AREA\nPROCESS  EQU   *\n         L     R4,VFREE            PU FREE VOLUME ENTRY\n*        LSPACE MF=I,MSG=(4),UCB=(9)\n         LSPACE MF=I,DATA=(4),UCB=(9)\n         LTR   R15,R15             TEST RETURN\n         BZ    LSPCOK              LSPACE FUNCTION IS O.K.\n         EX    R15,* <------------ 0C3 ABEND\n         BNZ   VERR1               LSPACE FAILURE\nLSPCOK   EQU   *\n*        L     R4,VFREE            PU FREE VOLUME ENTRY\n         USING VOLDSECT,R4\n*        MVC   VOLREPLY,VOLRMSG    VOLUME INFORMATION\n         MVC   VOLSER,UCBVOLI      VOLUME SERIAL\n         MVC   VOLSTAB,UCBSTAB     STATUS\n         MVC   VOLDMCT,UCBDMCT     USE\n         UCBDEVN DEVN=VOLNAME      CONVERT DEVICE NUMBER TO DISPLAY\n         LA    R4,VOLNGH(R4)       BUMP ENTRY PTR\n         C     R4,VEND             CHECK BOUNDS\n         BH    VERR2               MESSAGE ON OVERFLOW\n         ST    R4,VFREE            STORE IN FREE PTR\n         DROP  R4                  UNADDRESS\n         LA    R4,JFCB1            PT JFCB WORKAREA\n         USING JFCB,R4\n         MVI   JFCBTSDM,X'08'      SUPPRESS WRITEBACK\n         MVC   JFCBDSNM,=44X'04'   FORMAT 4 DSNAME\n         MVI   JFCBNVOL,1          ONE VOL AT A TIME\n         MVC   JFCBVOLS,UCBVOLI    VOLUME SERIAL\n         MVC   SAVOL,UCBVOLI       SAVE CURRENT VOLUME SERIAL #\n         DROP  R9\n         DROP  R4\n         LA    R4,IEFRDER          PT EXCP DCB\n         USING IHADCB,R4\n         OPEN  (IEFRDER),MF=(E,OPENLST),TYPE=J,MODE=24\n         TM    DCBOFLGS,OPEN       CHECK OPEN RETURN\n         BNO   FERR1               FATAL ERROR\n         L     R8,DCBDEBAD         PU DEB ADDRESS\n         DROP  R4\n         USING DEBBASIC,R8\n         LA    R8,DEBBASND         PT DEVICE SECTION\n         DROP  R8\n         USING DEBDASD,R8\n         LA    R7,IOB1             PT IOB WORKAREA\n         USING IOBSTDRD,R7\n         MVI   IOBFLAG1,X'42'      SETUP IOB FOR VTOC I/O\n         LA    R1,ECB1             STORE ECB ADDRESS\n         ST    R1,IOBECBPT\n         LA    R1,CP1              STORE CHANNEL PROGRAM ADDRESS\n         ST    R1,IOBSTART\n         LA    R1,IEFRDER          STORE DCB ADDRESS\n         ST    R1,IOBDCBPT\n         MVC   IOBCC(4),DEBSTRCC   MOVE VTOC START LOCATION\n         MVI   IOBR,1              FMT4 RECORD NUMBER\n         DROP  R8\n         BAS   RLNK,EXCP1\n         LA    R6,DSCB1+44         PT FORMAT FOUR ID\n         USING IECSDSF4,R6\n         CLI   DS4IDFMT,C'4'       JUST MAKING SURE\n         BNE   F4ERR               ITS KIND OF IMPORTANT\n         MVC   HIWATER,DS4HPCHR    VTOC HIGH FMT 1 CCHHR\n         MVC   DEV#TRKS,DS4DEVSZ+2  #TRKS/CYL\n         MVC   DEV#DSCB+1(1),DS4DEVDT  #:SCB'S PER TRACK\n         DROP  R6\n         SPACE 2\nREADLOOP DS    0H\n         BAS   RLNK,INCRSEEK       INCREMENT SEEK ADDRESS AND CHECK\n         BAS   RLNK,EXCP1          ISSUE READ\n         LA    R6,DSCB1            PT DSCB WORK\n         USING IECSDSF1,R6\n         CLI   DS1FMTID,C'1'       SKUP UNLESS FORMAT ONE\n         BNE   READLOOP            SKIP IF NOT\n         SPACE 2\n***********************************************************************\n**                                                                   **\n**       BUILD DATASET AND INDEX TABLE ENTRIES FOR EACH FORMAT       **\n**       ONE DSCB.  READ FORMAT TWO AND THREE IF PRESENT TO          **\n**       ACCUMULATE NUMBER OF EXTENTS AND SPACE ALLOCATION.  MOVE    **\n**       DATASET CHARACTERISTICS TO DATASET ENTRY.  THEN BINARY      **\n**       SEARCH THE INDEX LEVEL TREE, BUMP DATASET COUNT AND         **\n**       ALLOCATION TOTALS FOR THIS SUBSYSTEM.                       **\n**                                                                   **\n***********************************************************************\n         L     R1,TOT#DSN\n         LA    R1,1(R1)\n         ST    R1,TOT#DSN\n         L     R8,DAVAIL           PU PTR TO AVAILABLE ENTRY SLOT\n         LA    R2,DSNLNGH(R8)      PT NEXT\n         C     R2,DEND             CHECK LIMIT\n         BH    DSERR1              DATASET TABLE OVERFLOW\n         ST    R2,DAVAIL           STORE BACK\n         USING DSNSECT,R8\n         MVC   DSNAME,DS1DSNAM     MOVE DATASET CHARACTERISTICS\n         MVC   DSVOL,SAVOL         VL\n         MVC   DSORG,DS1DSORG      MOVE DSORG\n         MVC   DSRECFM+1(1),DS1RECFM  MOVE RECFM\n         MVC   DSLRECL,DS1LRECL    MOVE LRECL\n         MVC   DSBLKSIZ,DS1BLKL    MOVE BLOCK SIZE\n         MVC   DSCREDT,DS1CREDT    MOVE CREATION DATE\n         MVC   DSREFDT,DS1REFD     MOVE LAST REFERENCED DATE\n         MVC   DSUSED,DS1LSTAR     STORE LAST USED TRACK OFFSET\n         LH    R1,DSUSED           CONVERT RELATIVE TT\n         LA    R1,1(R1)            TO TOTAL TRACKS\n         STH   R1,DSUSED\n         L     R0,TOT#USE\n         AR    R0,R1\n         ST    R0,TOT#USE\n**       ACCUMULATE NUMBER OF EXTENTS IN R2                          **\n**                  TOTAL TRACKS ALLOCATED IN R3                     **\n         MVC   IOBSAVE,IOBCC       SAVE SEEK ADDRESS\n         SLR   R2,R2               INIT\n         SLR   R3,R3\n         LA    R4,3                FIRST THREE EXTENTS\n         LA    R5,DS1EXT1          PT EXTENT DESCRIPTORS\n         BAS   RLNK,ACCLOOP        ACCUMULATE ALLOC AND EXTS\n         OC    DS1PTRDS,DS1PTRDS   CHECK FOR TWO OR THREE\n         BZ    ENACC               END IF NONE\n         MVC   IOBCC(5),DS1PTRDS   MOVE SEEK OF NEXT IN CHAN\n         BAS   RLNK,EXCP1          READ IT\n         CLI   DSCB1,2             IS IT ISAM\n         BNE   FMT3                NO  BRANCH\n         OC    DS1PTRDS,DS1PTRDS   CHECK NEXT CHAIN PTR\n         BZ    ENACC               BRANCH OUT\n         MVC   IOBCC(5),DS1PTRDS   SET SEEK OF FMT3\n         BAS   RLNK,EXCP1          READ IT\nFMT3     LA    R4,4                FOUR EXTENTS\n         LA    R5,DSCB1+4          START OF DESCRIPTORS\n         BAS   RLNK,ACCLOOP        ACCUMULATE\n         LA    R4,9                NINE OF EM\n         LA    R5,DSCB1+45         FIRST\n         BAS   RLNK,ACCLOOP\nENACC    MVC   IOBCC(5),IOBSAVE    RESTORE SEEK POSITION\n         STC   R2,DS#EXTS          STORE NUMBER OF EXTENTS\n         STH   R3,DSALLOC          STORE NUMBER OF TRACKS ALLOCATED\n         L     R1,TOT#TRK\n         AR    R1,R3\n         ST    R1,TOT#TRK\n         SPACE 2\n***********************************************************************\n**                                                                   **\n**       HSMCHECK - IF THE DATASET SECOND LEVEL QUALIFIER IS HMIG    **\n**                  AND A MCDS DDCARD IS PRESENT, THE HSM MCDS       **\n**                  WILL BE QUERIED FOR REAL DATASET NAME AND ATTRIB **\n**                  THE DSCB VALUES FOR DISK SPACE WILL BE RETAINED  **\n**                                                                   **\n***********************************************************************\n         SPACE 2\nHSMCHECK EQU   *\n         CLI   HSMSW,C'N'          WAS HSM MCDS DDCARD NOT PRESENT?\n         BE    HSMEXIT             NO DDCARD, EXIT\n         LA    R2,DSNAME+2         BEGIN SEARCH FOR 'HMIG'\n         LA    R3,16               SCAN 16 CHARACTERS\nHSM010   EQU   *\n         CLC   0(4,R2),=CL4'HMIG'  HMIG TEST\n         BE    HSM020\n         LA    R2,1(R2)            INCREMENT R2\n         BCT   R3,HSM010           TRY TEST AGAIN\n         B     HSMEXIT\nHSM020   EQU   *\n         MVC   VSAMKEY,DSNAME      MOVE DSNAME FOR HSM MCDS QUERY\n         GET   RPL=VDIRRPL         GET A RECORD\n         LTR   R15,R15             CHECK FOR ERROR\n         BNZ   HSMEXIT             ERROR, FORGET IT\n         USING MCKRECRD,R2         INFORM ASSEMBLER R2 MCA DSECT BASE\n         L     R2,VSAMADDR         SET R2=VSAM RECORD ADDRESS\n         CLI   46(R2),X'11'        MIGRATION COPY NAME(MCA) RECORD ?\n         BE    HSM025              YES, GOTO P28190\n         WTO   'HMIG MCA ',ROUTCDE=11\n         ABEND 999,DUMP\nHSM025   EQU   *\n         MVC   DSNAME,MCAINTNM     MOVE ALIAS NAME(REAL DSNAME)\n         DROP  R2                  DROP MCA BASE\n         MVC   DSVOL,=CL6'MIGRAT'  SET VOLUME TO MIGRAT\n         MVI   DS#EXTS,X'FF'       PASS SWITCH FOR HSM REC\n         MVC   VSAMKEY,DSNAME      MOVE REAL DSN FOR HSM MCDS QUERY\n         GET   RPL=VDIRRPL         GET A RECORD\n         LTR   R15,R15             CHECK FOR ERROR\n         BNZ   HSMEXIT             ERROR, FORGET IT\n         USING MCKRECRD,R2         INFORM ASSEMBLER RD MCA DSECT BASE\n         L     R2,VSAMADDR         SET R2=VSAM RECORD ADDRESS\n         CLI   46(R2),X'00'        MIGRATION CONTROL(MCD) RECORD ?\n         BE    HSM030              YES, GOTO P28190\n         WTO   'HMIG MCD',ROUTCDE=11\n         ABEND 999,DUMP\nHSM030   EQU   *\n         MVC   DSCREDT,MCDDLC+1    MOVE CREATION DATE\n         MVC   DSREFDT,MCDDLR+1    MOVE LAST REFERENCED DATE\n         MVC   DSORG,MCDDSORG      MOVE DATASET ORGANIZATION\n         MVC   DSALLOC,MCDSIZE+2   MOVE TRACKS ALLOCATED\n         MVC   DSRECFM,MCDRECFM    MOVE RECORD FORMAT\n         MVC   DSBLKSIZ,MCDBLKSZ   MOVE BLOCK SIZE\n*        MVC   DS#EXTS,MCDCOMPR    COMPRESSION SAVINGS\n         DROP  R2                  DROP MCA BASE\nHSMEXIT  EQU   *                   FINISHED WITH HSM MCDS CHECK\n***********************************************************************\n**                                                                   **\n**       BUILD INDEX ENTRY OR INCREMENT EXISTING ONE.                **\n**       INDEX ENTRIES ARE STORED AS A BINARY TREE(SYMBOL TABLE)     **\n**       STRUCTURE FOR SPEED IN SEARCHING. STATISTICS KEPT FOR  EACH **\n**       SUBSYSTEM ARE NUMBER OF DATASETS AND TOTAL TRACKS ALLOCATED **\n**                                                                   **\n***********************************************************************\n         SPACE\n**       SETUP INPTINX FIELD BY PARSING DSNAME                       **\n         MVC   INPTINX,=CL8' '     CLEAR STORAGE\n         LA    R1,DSNAME+1         ASSUME FIRST CHAR EXISTS\n         LA    R2,1                INCREMENT VALUE\n         LA    R3,DSNAME+8         LIMIT\n         LA    R4,0                MACHINE FORM OF LENGTH\nPAR1     CLI   0(R1),C'A'          CHECK FOR DELIMITER\n         BL    P2                  AND OUT\n         LA    R4,1(R4)            BUMP LENGTH\n         BXLE  R1,R2,PAR1          SCAN\nP2       EX    R4,MVCINX           MOVE TO WORKAREA\n         USING INXSECT,R2\n         SLR   R0,R0               CONTANT FOR COMPARES\n         L     R2,IROOT            PU ROOT PTR\n         LTR   R2,R2               TEST\n         BNZ   T2                  SKIP UNLESS FIRST TIME\n         L     R2,IAVAIL           PU SLOT PTR\n         ST    R2,IROOT            SET FIRXT\n         B     T56                 TO CREATE ENTRY\nT2       CLC   INPTINX,INDEX       COMPARE INPUT TO ENTRY\n         BE    T6                  BUMP ENTRY\n         BH    T4                  CHASE CHAIN\nT3       C     R0,LLINK            CHECK LEFT SUBTREE\n         BE    T5                  STORE NEW\n         L     R2,LLINK            ELSE PU AND RUN\n         B     T2                  SEE WHAT I MEAN\nT4       C     R0,RLINK            CHECK DIS SIDE TOO\n         BE    T5\n         L     R2,RLINK\n         B     T2                  CHASE\nT5       L     R1,IAVAIL           SLOT FREE\n         EX    R4,CLCINX           TO SEE HOW WE GOT HERE\n         BH    T52                 IF VIA RIGHT TREE\n         ST    R1,LLINK            ELSE STORE LEFT\n         B     T54                 AROUND\nT52      ST    R1,RLINK            STORE RIGHT\nT54      LR    R2,R1               ROOL ADDRESSIBILITY\nT56      XC    INXSECT(ILNGH),INXSECT  CLEAR NEW ENTRY\n         MVC   INDEX,INPTINX       STORE INDEX\n         LA    R1,ILNGH(R2)\n         C     R1,IEND\n         BH    IERR1\n         ST    R1,IAVAIL\nT6       LH    R1,ICOUNT           BUMP DATASET COUNT\n         LA    R1,1(R1)\n         STH   R1,ICOUNT           STORE BACK\n         LH    R1,DSALLOC          PU ALLOCATED TRACKS\n         A     R1,IALLOC           ADD PREVIOUS TOTAL\n         ST    R1,IALLOC           STORE BACK\n         LH    R1,DSUSED\n         A     R1,IUSED\n         ST    R1,IUSED\n         B     READLOOP\n         SPACE 2\nMVCINX   MVC   INPTINX(0),DSNAME   SKELETON MOVE\nCLCINX   CLC   INPTINX(0),INDEX    COMPARE INPUT TO ENTRY\n         DROP  R2\nEODAD    CLOSE (IEFRDER),MF=(E,CLOSLST),MODE=31 CLOSE THE VTOC\n         TM    SW,MODE2            IS THIS MODE-1?\n         BO    NEXTTIOT            N, GET NEXT TIOT DEVICE\n         B     NEXTUCB             Y, GET NEXT LUT ENTRY\n         SPACE 2\nNEOJ     DS    0H\n         NOP   NOSORT\n         SORT  START=VSTART,END=VFREE,ENTRYL=VOLNGH,                   *\n               KEYLEN=6,KEYOFF=0,MODE=A\n         SORT  START=ISTART,END=IAVAIL,ENTRYL=ILNGH,                   *\n               KEYLEN=8,KEYOFF=8,MODE=A\n         SORT  START=DSTART,END=DAVAIL,ENTRYL=DSNLNGH,                 *\n               KEYLEN=44,KEYOFF=0,MODE=A\nNOSORT   DS    0H\n         MVOUT VSTART,VOLNGH,VFREE,VMODE,VPRINT\n         MVOUT ISTART,ILNGH,IAVAIL,IMODE,IPRINT\n         L     R1,BUFLOC\n         MVC   0(121,R1),HT1\n         BAS   RLNK,PRINT\n         L     R1,BUFLOC\n         USING TOTSECT,R1\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\n         L     R0,TOT#DSN\n         CVD   R0,DW\n         MVC   TOTDSN,=X'4020202020202120'\n         ED    TOTDSN,DW+4\n         L     R0,TOT#TRK\n         CVD   R0,DW\n         MVC   TOTCNT,=X'4020202020202120'\n         ED    TOTCNT,DW+4\n         L     R0,TOT#USE\n         CVD   R0,DW\n         MVC   TOTUSE,=X'4020202020202120'\n         ED    TOTUSE,DW+4\n         SLR   R8,R8\n         L     R15,TOT#TRK\n         L     R9,TOT#USE\n         MH    R9,=H'1000'         SCALING FACTOR\n         DR    R8,R15\n         STH   R9,WORK1\n         LH    R0,WORK1            FIELD TO CONVERT\n         CVD   R0,DW               CONVERT TO DECIMAL\n         MVC   TOTPCT,MASK5        MOVE MASK FIELD\n         ED    TOTPCT,DW+6         MAKE IT PRINTABLE\n         BAS   RLNK,PRINT\n         DROP  R1\n         MVOUT DSTART,DSNLNGH,DAVAIL,DMODE,DPRINT\n         SLR   R15,R15             SET ZERO RETURN\nRETURN   EQU   *                   SYSTEM SAVEAREA\n         CLOSE (MCDS),MODE=31      CLOSE FILE\n         CLOSE (SYSPRINT),MF=(E,CLOSLST),MODE=31     CLOSE PRINTER\n         L     R2,PPARM\n         STORAGE RELEASE,LENGTH=(2),ADDR=PSTART\n         L     R2,VPARM\n         STORAGE RELEASE,LENGTH=(2),ADDR=VSTART\n         L     R2,IPARM\n         STORAGE RELEASE,LENGTH=(2),ADDR=ISTART\n         L     R2,DPARM\n         STORAGE RELEASE,LENGTH=(2),ADDR=DSTART\n         L     R13,4(R13)          SYSTEM SAVEAREA\n         LM    R0,R12,20(R13)      RESTORE\n         L     R14,12(R13)         RETURN ADDRESS\n         BR    R14                 BYBY\n         DROP  R8\nHSMEODAD EQU   *\n         WTO   'EODAD MCDS',ROUTCDE=11\n         ABEND 999,DUMP\n         TITLE 'DADSM-    SUBROUTINES'\nACCLOOP  CLI   0(R5),0             CHECK FOR DATA IN EXTENT\n         BE    ENACC               BRANCH OUT IF NONE\n         LA    R2,1(R2)            ELSE BUMP EXTENT COUNT\n         LH    R0,6(R5)            PU HIGN CC\n         MH    R0,DEV#TRKS         TIMES  DEVICE CHAR\n         AH    R0,8(R5)            ADD HIGH TRACKS\n         LH    R1,2(R5)            LO W CC\n         MH    R1,DEV#TRKS\n         AH    R1,4(R5)            LOW TT\n         SR    R0,R1               TOTAL\n         LA    R3,1(R3)            BUMP FOR TRUE TOTAL\n         AR    R3,R0               INCR\n         LA    R5,10(R5)           PT NEXT DESC\n         BCT   R4,ACCLOOP\n         BR    RLNK                RETURN\n         TITLE 'DADSM-    EXCP ROUTINE'\n         SPACE 2\n**       ISSUE EXCP AND WAIT\nEXCP1    DS    0H\n         XC    ECB1,ECB1\n         EXCP  IOB1\n         WAIT  ECB=ECB1\n         TM    ECB1,X'7F'\n         BOR   RLNK                RETURN TO CALLER\nEXCPERR  ABEND 20,DUMP\n         SPACE 2\n**       INCREMENT SEEK ADDRESS AND EXTENT CHECKING\nINCRSEEK EQU   *\n         MVC   SECR0,SECR1         SWAP SECTOR VALI\n         SLR   R1,R1               CLEAR WORK REGISTER\n         IC    R1,IOBR             PU REC NUM\n         LA    R1,1(R1)            INCREMENT RECORD NUMBER\n         STC   R1,IOBR             STORE BACK\n         CH    R1,DEV#DSCB         CHECK LIMIT FOR DEVICE\n         BNH   CHKEXT              IF OK...BRANCH TO EXTENT CHECK\nINCRTRK  ICM   R1,B'0011',IOBHH    PU TRACK ADDRESS\n*              FROM IOBSEEK\n         LA    R1,1(R1)            INCREMENT IT\n         STCM  R1,B'0011',IOBHH    STORE BACK\n         MVI   IOBR,1              RECORD NUMBER 1\n         CLC   DEV#TRKS,IOBHH      CHECK AGIN DEVICE LIMIT\n         BH    CHKEXT              OK...CHECK EXTENT LIMITS\n         ICM   R1,B'0011',IOBCC    ELSE PU CYL ADDRESS\n         LA    R1,1(R1)            ENCREMENT\n         STCM  R1,B'0011',IOBCC    STORE SEEK\n         MVC   IOBHH,=H'0'         ZERO TRACK\nCHKEXT   CLC   HIWATER,IOBCC       CHECK VTOC HIGH WATER\n         BL    EODAD               END OF EXTENT ROUTINE WHEN HIGH\n         BR    RLNK                ELSE RETURN\n         DROP  R7\n         TITLE 'DADSM-    PRINT ROUTINE'\nPRINTMSG EQU   *                   INPUT IS MESSAGE LOCATION IN R2\n         ST    R2,WORK4\n         L     R2,BUFLOC           INSERT BUFFER ADDRESS\n         SLR   R3,R3               CLEAR ICREG\n         IC    R3,0(R1)            INSERT MESSAGE LENGTH\n         BCTR  R3,0                DECREMENT TO MACHINE FORM\n         EX    R3,MVCMSG           MOVE MESSAGE TO BUFFER\n         L     R2,WORK4\n         B     PRINT               PUT THE DUDE OUT\nMVCMSG   MVC   1(*-*,R2),1(R1)     MOVE MESSAGE SKELETON\nPRINTHDR EQU   *                   HEADER PRINT ROUTINE\n         TIME  ,                   GET TIME AND DATE FOR HEADER\n         STM   R0,R1,WORK1         STORE FOR LATER\n         MVC   TIME(8),MASK1\n         ED    TIME(8),WORK1\n         MVC   DATE(7),MASK2       MOVE EDIT MASK\n         ED    DATE(7),WORK2+1\n         AP    PAGECTR,P1\n         MVC   PAGE(4),=X'40202120'\n         ED    PAGE(4),PAGECTR     PUT PAGE # IN HEADER\n         ZAP   LINECTR,P0          ZERO LINE COUNTER\nTOPPAGE  PUT   SYSPRINT            GET A BUFFER\n         MVC   0(121,R1),HDR1      PUT HEADER IN IT\n         PUT   SYSPRINT            GET NEXT BUFFER\n         TM    SW,VMODE            TEST FOR VOLUME PRINT PHASE\n         BO    VOLHDR              PRINT CORRESPONDING HEADERS\n         TM    SW,IMODE            INDEX\n         BO    INXHDR\n         TM    SW,DMODE\n         BO    DSNHDR\n         PUT   SYSPRINT            GET BUFFER\n         ST    R1,BUFLOC           IF PRIME OPERATION ONLY\n         BR    RLNK                RETURN\nVOLHDR   MVC   0(121,R1),HV1\n         PUT   SYSPRINT\n         MVC   0(121,R1),HV2\n         PUT   SYSPRINT\n         B     STLOC\nINXHDR   DS    0H\n         MVC   0(121,R1),HI1\n         PUT   SYSPRINT\n         MVC   0(121,R1),HI2\n         PUT   SYSPRINT\n         B     STLOC\nDSNHDR   DS    0H\n         MVC   0(121,R1),HD1\n         PUT   SYSPRINT\n         MVC   0(121,R1),HD2\n         PUT   SYSPRINT\nSTLOC    DS    0H\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\nPRINT    EQU   *\n         CP    LINECTR,PAGELIM     CHECK LINE LIMIT\n         BH    PRINTHDR            PRINT HEADER WHEN REACHED\nPRTLINE  PUT   SYSPRINT            GET BUFFER\n         ST    R1,BUFLOC           SAVE LOCATION\n         MVI   0(R1),C' '          SET SINGLE SPACE CONTROL\n         MVC   1(120,R1),0(R1)     CLEAR LINE\n         AP    LINECTR,P1          INCREMENT LINE COUNTER\n         BR    RLNK                ELSE RETURN TO MAINSTREAM\n         USING VOLDSECT,R3\n         USING VLINE,R1\nVPRINT   DS    0H\n         L     R1,BUFLOC\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\n         MVC   VVOL,VOLSER\n         MVC   VUNIT,VOLNAME\n*        MVC   VFRCYL,VOLREPLY+6\n         L     R0,LSPDTTRK\n         CVD   R0,DW\n         MVC   VFRTRK,=X'402020202020'\n*        MVC   VFRCYL,=X'2020202020202020202120'\n         ED    VFRTRK,DW+5\n         L     R0,LSPDTCYL\n         CVD   R0,DW\n         MVC   VFRCYL,=X'40202020202120'\n         ED    VFRCYL(6),DW+5\n         MVI   VFRCYL+6,C'/'\n*        MVC   V#EXT,VOLREPLY+16\n         L     R0,LSPDNEXT\n         CVD   R0,DW\n         MVC   V#EXT,=X'40202020202020202120'\n         ED    V#EXT,DW+6\n*        MVC   VLARG,VOLREPLY+21\n         L     R0,LSPDLTRK\n         CVD   R0,DW\n         MVC   VLARGT,=X'402020202020'\n         ED    VLARGT,DW+5\n         L     R0,LSPDLCYL\n         CVD   R0,DW\n         MVC   VLARGC,=X'402020202120'\n         ED    VLARGC,DW+5\n         MVI   VLARGC+6,C'/'\n         LA    R9,3                BCT COUNT\n         LA    R8,STABTAB          PT TABLE\n         NI    VOLSTAB,B'00011100'  MASK EXES BITS\nV0010    CLC   VOLSTAB,0(R8)       COMPARE INDICATORS\n         BE    V0020               OUT ON MATCH\n         LA    R8,8(R8)            BUMP ONE\n         BCT   R9,V0010            BACK TRACK\nV0020    MVC   VUSE,1(R8)          MOVE IT OTU\n         BAS   RLNK,PRINT\n         BR    RLNK2\n         DROP  R1\n         DROP  R3\n         SPACE 2\n         USING ILINE,R1\n         USING INXSECT,R3\nIPRINT   DS    0H\n         L     R1,BUFLOC\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\n         MVC   IINX,INDEX\n         LH    R0,ICOUNT\n         CVD   R0,DW\n         MVC   I#DSN-1(4),MASK3\n         ED    I#DSN-1(4),DW+6\n         L     R0,IALLOC\n         CVD   R0,DW\n         MVC   I#TRK,=X'4020202020202120'\n         ED    I#TRK,DW+4\n         L     R0,IUSED\n         CVD   R0,DW\n         MVC   I#USED,=X'4020202020202120'\n         ED    I#USED,DW+4\n         MVC   IPCT,=C'100.0'\n         SLR   R8,R8\n         L     R15,IALLOC\n         L     R9,IUSED\n         CR    R9,R15\n         BE    IPCTALL\n         LTR   R15,R15             CHECK FOR ZERO DIVISOR S0C9\n         BZ    DPCT\n         MH    R9,=H'1000'         SCALING FACTOR\n         DR    R8,R15\n         STH   R9,WORK1\nDPCT     LH    R0,WORK1            FIELD TO CONVERT\n         CVD   R0,DW               CONVERT TO DECIMAL\n         MVC   IPCT,MASK5          MOVE MASK FIELD\n         ED    IPCT,DW+6           MAKE IT PRINTABLE\nIPCTALL  XC    WORK1,WORK1\n         BAS   RLNK,PRINT\n         BR    RLNK2\n         DROP  R1\n         DROP  R3\n         SPACE 2\n         USING DLINE,R1\n         USING DSNSECT,R3\nDPRINT   DS    0H                  PRINT DATASET ENTRIES\n         L     R1,BUFLOC           PU BUFFER ADDREA\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)\n         MVC   DDSN,DSNAME\n         MVC   DVOL,DSVOL\n         LH    R0,DSALLOC          FIELD TO CONVERT\n         CVD   R0,DW               CONVERT TO DECIMAL\n         MVC   WORK1(6),MASK7      MOVE MASK FIELD\n         ED    WORK1(6),DW+5       MAKE IT PRINTABLE\n         MVC   DALLOC,WORK1+1      MOVE TO OUTPUT\n         LH    R0,DSUSED           FIELD TO CONVERT\n         CVD   R0,DW               CONVERT TO DECIMAL\n         MVC   WORK1(6),MASK7      MOVE MASK FIELD\n         ED    WORK1(6),DW+5       MAKE IT PRINTABLE\n         MVC   DUSED,WORK1+1       MOVE MASK FIELD\nD0002    EQU   *\n         CLC   DSVOL,=C'MIGRAT'    IS THE MIGRATED DATASET?\n         BNE   D0006\n         MVC   DRECFM,=CL4' '      CLEAR RECFM   FOR HSM DATASETS\n         MVC   DBLKSIZ,=CL5' '     CLEAR BLKSIZ  FOR HSM DATASETS\n         MVC   DLRECL,=CL5' '      CLEAR LRECL   FOR HSM DATASETS\n         MVC   D#EXT,=CL2' '       CLEAR #EXTS   FOR HSM DATASETS\n         MVC   DDSORG,=CL2' '      CLEAR DSORG   FOR HSM DATASETS\n         CLI   DS#EXTS,X'FF' IS COMPRESSION GIVEN?\n         BE    D0006               NO, DONT PROVIDE\n         SR    R0,R0\n         ICM   R0,1,DS#EXTS        DS#EXTS FOR HSM USED TO PASS\n         CVD   R0,DW                 THE HSM COMPRESSION FACTOR\n         UNPK  DMISC(2),DW+6\n         OI    DMISC+1,X'F0'\n         MVC   DMISC+2(13),=C'% COMPACTION '\nD0006    EQU   *\n         LH    R0,DSLRECL          FIELD TO CONVERT\n         CVD   R0,DW               CONVERT TO DECIMAL\n         MVC   WORK1(6),MASK7      MOVE MASK FIELD\n         ED    WORK1(6),DW+5       MAKE IT PRINTABLE\n         MVC   DLRECL,WORK1+1      MOVE TO OUTPUT\nD0080    EQU   *                   END OF HSM PARMS\n         LH    R0,DSBLKSIZ         FIELD TO CONVERT\n         CVD   R0,DW               CONVERT TO DECIMAL\n         MVC   WORK1(6),MASK7      MOVE MASK FIELD\n         ED    WORK1(6),DW+5       MAKE IT PRINTABLE\n         MVC   DBLKSIZ,WORK1+1     MOVE TO OUTPUT\n         LA    R8,DSORGTBL\nD0010    CLC   DSORG,0(R8)\n         BE    D0020\n         LA    R8,4(R8)\n         CLC   =H'0',0(R8)         TABLE END INDICATOR\n         BNE   D0010               BACK IT\nD0020    MVC   DDSORG,2(R8)        MOVE IT ANYHOW\n         LA    R8,RECFMTBL\n         MVI   BYTE,0\n         SLR   R9,R9\nD0040    IC    R9,0(R8)\n         EX    R9,TMT              TEST IF DONE THIS ONE\n         BNZ   D0050               SKIP\n         EX    R9,TM\n         BO    D0060\nD0050    LA    R8,5(R8)\n         CLI   0(R8),0             END\n         BE    D0070               YES\n         B     D0040\nD0060    EX    R9,OI\n         OC    DRECFM,1(R8)\n         B     D0040\nD0070    DS    0H\n         CLI   DRECFM+2,C' '\n         BNE   D0070A\n         MVC   DRECFM+2(1),DRECFM+3\n         MVI   DRECFM+3,C' '\nD0070A   DS    0H\n         SLR   R9,R9\n         IC    R9,DS#EXTS\n         CVD   R9,DW\n         MVC   WORK1(4),MASK3\n         ED    WORK1(4),DW+6\n         MVC   D#EXT(2),WORK1+2\n* D0080    EQU   *                   END OF HSM PARMS\n* CREATION DATE ROUTINE\n         SLR   R9,R9\n         IC    R9,DSCREDT\n         LTR   R9,R9\n         BZ    D0099               SKIP CRUMMY VSAM CREDT\n         CLC   DSVOL,=CL6'MIGRAT'  CREATE DATE FOR MIGRAT?\n         BNE   D0085               NO, CONTINUE\n         UNPK  DCREDT,DSCREDT\n         OI    DCREDT+5,X'F0'\n         MVC   DCREDT(2),DCREDT+1\n         MVI   DCREDT+2,C'.'\n         B     D0099               CONTINUE\nD0085    EQU   *\n         CVD   R9,DW\n         LH    R9,DW+6\n         SRL   R9,4\n         SLL   R9,16\n         SLR   R8,R8\n         ICM   R8,3,DSCREDT+1\n         CVD   R8,DW\n         LH    R8,DW+6\n         OR    R8,R9\n         ST    R8,WORK1\n         MVC   DCREDT,MASK2\n         ED    DCREDT,WORK1+1\nD0099    DS    0H\n* REFERNCE DATE ROUTINE\n         SLR   R9,R9\n         IC    R9,DSREFDT\n         LTR   R9,R9\n         BZ    D0099A              SKIP CRUMMY VSAM REFDT\n         CLC   DSVOL,=CL6'MIGRAT'  CREATE DATE FOR MIGRAT?\n         BNE   D0099B              NO, CONTINUE\n         UNPK  DREFDT,DSREFDT\n         OI    DREFDT+5,X'F0'\n         MVC   DREFDT(2),DREFDT+1\n         MVI   DREFDT+2,C'.'\n         B     D0099A              CONTINUE\nD0099B   EQU   *\n         CVD   R9,DW\n         LH    R9,DW+6\n         SRL   R9,4\n         SLL   R9,16\n         SLR   R8,R8\n         ICM   R8,3,DSREFDT+1\n         CVD   R8,DW\n         LH    R8,DW+6\n         OR    R8,R9\n         ST    R8,WORK1\n         MVC   DREFDT,MASK2\n         ED    DREFDT,WORK1+1\nD0099A   DS    0H\n         BAS   RLNK,PRINT\n         BR    RLNK2\nTM       TM    DSRECFM+1,0\nOI       OI    BYTE,0\nTMT      TM    BYTE,0\n         DROP  R1\n         DROP  R3\n         TITLE 'DADSM-    EXIT AND ERROR ROUTINES'\nF4ERR    ABEND 44,DUMP\n         SPACE 2\n         USING UCBOB,R9\nFERR1    MVC   FSMSG1+1(6),UCBVOLI\n         LA    R1,FSMSG1           LOAD MESSAGE\n         BAS   RLNK,PRINTMSG\n         LA    R15,12              LOAD RETURN\n         B     RETURN\n         DROP  R9\nFSMSG1   DC    AL1(19),C'XXXXXX OPENJ FAILED'\n         SPACE 2\n         DS    0F\nSYSERR1  WTO   'DADSM: SYSPRINT OPEN FAILURE',                         *\n               ROUTCDE=(2,11),DESC=(7)\n         LA    R15,16              RETURN COD%\n         B     RETURN\n         SPACE 2\n         DS    0F\nSYSERR2  DS    0H\n         WTO   'LISTVTOC I/O ERROR ON SYSPRINT ABENDING',              *\n               ROUTCDE=(2,11),DESC=(7)\n         ABEND 40,DUMP\n         SPACE 2\nSYSEXIT1 EQU   *                   EXIT TO CHECK BLKSIZE AND PLUG\n         L     R15,ADOPEN31-SYSEXT(,R15)  ENTRY TO DCB OPEN EXIT\n         BSM   R14,R15             SWITCH TO 31-BIT AND GO THERE\nLENEXIT  EQU   *-SYSEXIT1\nSYSEXIT  EQU   *                   EXIT TO CHECK BLKSIZE AND PLUG\n         LH    R2,DCBBLKSI-IHADCB(R1)\n         LTR   R2,R2               IS IT ZERO\n         BNZ   SYSOUTX             IF NOT RETURN TO OPEN\n         LA    R2,121              IF SO PLUG 121 DEFAULT\n         LH    R2,DCBBLKSI-IHADCB(R1)\nSYSOUTX  BSM   0,R14               GO BACK TO BIG OS\nU0012    ABEND 12,DUMP             ABEND ON INVALID UCB\n         SPACE\nVERR1    MVI   MSGWORK,79          LENGTH\n         MVC   MSGWORK+1(14),=C'DADSM: VOLUME '\n         MVC   MSGWORK+14(6),SAVOL\n         MVC   MSGWORK+24(30),0(R1)  LSPACE MESSAGE\n         LA    R1,MSGWORK\n         BAS   RLNK,PRINTMSG\n         LA    R15,8\n         B     RETURN\nMSGWORK  DC    CL80' '\n         SPACE\nVERR2    LA    R1,VOLMSG2\n         BAS   RLNK,PRINTMSG\n         LA    R15,8\n         B     RETURN\n         DS    0F\nVOLMSG2  DC    AL1(80),CL80'DADSM:  VOLUME TABLE OVERFLOW'\n         SPACE 2\nIERR1    LA    R1,IDXMSG2\n         BAS   RLNK,PRINTMSG\n         LA    R15,8\n         B     RETURN\nIDXMSG2  DC    AL1(80),CL80'DADSM:  INDEX TABLE OVERFLOW'\n         SPACE\nDSERR1   LA    R1,DSMSG1\n         BAS   RLNK,PRINTMSG\n         LA    R15,8\n         B     RETURN\n         DS    0F\nDSMSG1   DC    AL1(80),CL80'DADSM:  DATASET TABLE OVERFLOW'\n         SPACE 2\nPARMERR  WTO   'DADSM: INVALID PARM SPECIFIED',ROUTCDE=11\n         ABEND 99,DUMP\n         SPACE\n         TITLE 'DADSM-    WORKAREAS,CONSTANTS,EQUATES,DSECTS'\n         LTORG\n         CNOP  0,4\nMOD24    DC    X'7FFFFFFF'    FOR SETTING AMODE 24\nMOD31    DC    X'80000000'    FOR SETTING AMODE 31\nWORKAREA DC    XL100'00'      IOSVSUCB WORK AREA\nTIOTPOSN DC    A(0)                PLACEHOLDER FOR TIOT ENTRY\nPSTART   DC    A(0)                DCB START\nPFREE    DC    A(0)                DCB START\nPEND     DC    A(0)                END OF VOLUME TABLE\nPPARM    DC    A(IOALNG)           SPACE FOR ONE\nVSTART   DC    A(0)                VOLUME TABLE START\nVFREE    DC    A(0)                VOLUME TABLE FREE SLOT\nVEND     DC    A(0)                END OF VOLUME TABLE\nVPARM    DC    A(MAXVOLS*VOLNGH)   OR MANY\nISTART   DC    A(0)                START OF INDEX TABLE\nIAVAIL   DC    A(0)                NEXT AVAIL INDEX SLOT\nIEND     DC    A(0)                END OF TABLE\nIROOT    DC    A(0)                ROOT OF INDEX TREE\nIPARM    DC    A(MAXINX*ILNGH)\nDSTART   DC    A(0)                DATASET TABLE START\nDAVAIL   DC    A(0)                NEXT DATASET TBL SLOT\nDEND     DC    A(0)                END OF DATASET TABLE\nDPARM    DC    A(MAX#DSN*DSNLNGH)\n*        DYNAMIC ALLOCATION LIST FOR THE SYSOUT INPUT FILE            *\n         DS    0F                 MUST BE FULLWORD ALIGNED\nDYNPARM  DC    A(DYNBLK)          ADDRESS OF DYNALLOC BLOCK\nDYNBLK   DC    AL1(20),AL1(1),X'0000' ALLOCATION REQUEST\n         DC    F'0'               ERROR/INFO CODES (RETURNED)\n         DC    A(DYNTUC)          START OF TEXT UNIT POINTER CHAIN\n         DC    A(0)               RESERVED\n         DC    A(0)               FLAGS\nDYNTUC   DC    A(DYNTU1,DYNTU2,DYNTU3,DYNTU4,DYNTU5,DYNTU6)\nDYNTUC1  DC    A(DYNTU7)\nDYNTU1   DC    X'0002',AL2(1)                   VTOC DSNAME TU\n         DC    AL2(12),CL44'FORMAT4.DSCB'\nDYNTU2   DC    X'0055',AL2(1),AL2(8)            DDNAME RETURN TU\nDYNDDN   DC    CL8' '                           DDNAME RETURNED\nDYNTU3   DC    X'0004',AL2(1),AL2(1),X'08'      STATUS TU (SHR)\nDYNTU4   DC    X'0005',AL2(1),AL2(1),X'08'      DISP TU (KEEP)\nDYNTU5   DC    X'0010',AL2(1),AL2(6)            VOLUME SERIAL TU\nDYNVOL   DC    CL6' '                              VOLUME SERIAL\nDYNTU6   DC    X'0015',AL2(1),AL2(8),CL8'SYSALLDA' UNIT NAME TU\nDYNTU7   DC    X'001C',AL2(0)                   FREE=CLOSE\nMCDS     ACB   AM=VSAM,                                                X\n               RMODE31=ALL,                                            X\n               MACRF=(DIR,SEQ),                                        X\n               STRNO=2,                                                X\n               EXLST=VSEXITL\nVSEXITL  EXLST AM=VSAM,EODAD=(HSMEODAD)\nVDIRRPL  RPL   ACB=MCDS,                                               X\n               AM=VSAM,                                                X\n               OPTCD=(DIR,LOC),                                        X\n               AREA=VSAMADDR,                                          X\n               AREALEN=4,                                              X\n               ARG=VSAMKEY\nFDBKAREA DC    F'0'                VSAM FDBK RC AREA\nVSAMADDR DC    F'0'                ADDRESS OF VSAM RECORD\nVSAMKEY  DC    CL44' '             VSAM RECORD KEY AREA\nHSMSW    DS    C                   SHOULD WE REFERENCE THE MCDS (HSM)\n         DS    0F\nWORK1    DC    F'0'\nWORK2    DC    F'0'\nWORK3    DC    F'0'\nWORK4    DC    F'0'\nCP1A     DS    0D                  READ VTOC CHANNEL PROGRAM\n*CW1     CCW   X'23',SECR0A,X'40',1  SET SECTOR\nCCW1     DC    X'23'\n         DS    CL3\n         DC    X'40'\n         DC    X'000001'\n*CW2     CCW   X'31',IOB1A+35,X'40',5\nCCW2     DC    X'31'\n         DS    CL3\n         DC    X'40'\n         DC    X'000005'\n*CW3     CCW   X'08',*-8,0,0       TIC *-8\nCCW3     DC    X'08'\n         DS    CL3\n         DC    X'00'\n         DC    X'000000'\n*CW4     CCW   X'0E',DSCB1A,X'20',140  READ KEY AND DATA\nCCW4     DC    X'0E'\n         DS    CL3\n         DC    X'20'\n         DC    X'00008C'\n*CW5     CCW   X'22',SECR1A,0,1     READ SECTOR\nCCW5     DC    X'22'\n         DS    CL3\n         DC    X'00'\n         DC    X'000001'\nLCP1A    EQU   *-CP1A\nSECR0A   DC    X'00'\nSECR1A   DC    X'00'\nDEV#DSCB DC    H'0'\nDEV#TRKS DC    H'0'\nHIWATER  DC    XL5'0'\nBYTE     DC    X'00'\nBUFLOC   DC    A(0)\nPAGECTR  DC    PL2'0'\nLINECTR  DC    PL2'0'\nPAGELIM  DC    PL2'52'\nP1       DC    P'1'\nP0       DC    P'0'\nIOBSAVE  DC    XL5'00'\nEDMSK    DC    PL8'0'\nSAVOL    DC    CL6' '\nSAVOL1   DC    CL6' '\nINPTINX  DC    CL8' '\nHV1      DC    CL50' ',CL71'VOLUME SUMMARY'\nHV2      DC    CL10'0',CL11'VOLUME',CL11'UNIT',CL10'USE'\n         DC    CL17'FREE CYL/TRK'\n         DC    CL18'#EXTENTS FREE'\n         DC    CL56'LARGEST FREE CYL/TRK'\nHI1      DC    CL50' ',CL71'SUBSYSTEM SUMMARY'\nHI2      DC    CL16'0',CL15'INDEX',CL25'NUMBER OF DATASETS'\n         DC    CL17'TOTAL TRACKS',CL15'TOTAL USED'\n         DC    CL33'PERCENTAGE'\nHD1      DC    CL50' ',CL71'DATASET SUMMARY'\nHD2      DC    CL2'0',CL7'VOLUME',CL6'ALLOC'\n         DC    CL5'USED',CL4'ORG',CL4'RFM',CL6'LRECL'\n         DC    CL6'BLKSZ',CL4'#E',CL7'CREDT',CL6'REFDT',CL56'DSNAME'\n         DC    CL20' '\nMASK1    DC    X'20204B20204B2020'\n*ASK2    DC    X'20204B202020'\nMASK2    DC    X'4020204B202020'\nMASK3    DC    X'40202020'\nMASK4    DC    X'4020202120'\nMASK5    DC    X'4021204B20'\nMASK6    DC    X'40202020202120'\nMASK7    DC    X'402020202120'\nHDR1     DS    0CL121\n         DC    CL9'1',CL75'DADSM-   DIRECT ACCESS SPACE MANAGER'\n         DC    C'DATE '\nDATE     DC    CL6' ',C'  TIME '\nTIME     DC    CL8' ',C'  PAGE '\nPAGE     DC    CL4' '\n         SPACE\nDSORGTBL DS    0F\n         DC    X'8000',C'IS'\n         DC    X'4000',C'PS'\n         DC    X'2000',C'DA'\n         DC    X'1000',C'CX'\n         DC    X'0200',C'PO'\n         DC    X'0080',C'GS'\n         DC    X'0040',C'TX'\n         DC    X'0020',C'TQ'\n         DC    X'0008',C'AM'       VSAM\n         DC    X'0004',C'TR'\n         DC    X'0000',C'UN'\n         DC    F'0'                END OF TABLE\nRECFMTBL DS    0X\n         DC    X'C0',C'U   '\n         DC    X'80',C'F   '\n         DC    X'40',C'V   '\n         DC    X'20',C'  T '\n         DC    X'10',C' B  '\n         DC    X'08',C'  S '\n         DC    X'04',C'   A'\n         DC    X'02',C'   M'\n         DC    XL5'0'              END OF TABLE\nSTABTAB  DS    0X\n         DC    X'10',CL7'PRIVATE'\n         DC    X'08',CL7'PUBLIC'\n         DC    X'04',CL7'STORAGE'\n         SPACE 4\n* VOLRMSG  DC    CL30' '             CCCC,TTTT,AAAA/CCCC,TTTT\nON       EQU   X'F0'\nOPEN     EQU   X'10'\nSW       DC    X'00'\nVMODE    EQU   X'80'\nIMODE    EQU   X'40'\nDMODE    EQU   X'20'\nMSS      EQU   X'10'\n*        EQU   X'08'\n*        EQU   X'04'\nMODE2    EQU   X'02'\nMODE1    EQU   X'01'\nDW       DC    D'0'\nTOT#DSN  DC    F'0'\nTOT#TRK  DC    F'0'\nTOT#USE  DC    F'0'\nHT1      DC    CL16' ',82C'-',CL23' '\nTOTSECT  DS    CL30\nTOTDSN   DS    CL8\n         DS    CL19\nTOTCNT   DS    CL8\n         DS    CL8\nTOTUSE   DS    CL8\n         DS    CL9\nTOTPCT   DS    CL5\nDSCB1A   DC    140X'00'\n         DC    0F\nUCBA     DC    48X'00'\nPREXLS   DC    A(SYSEXIT)\nSYSPR    DCB   DDNAME=SYSPRINT,MACRF=PL,DSORG=PS,RECFM=FBA,            *\n               LRECL=121,EXLST=PREXLS,DCBE=PRTDCBE\nLENPRNT  EQU   *-SYSPR\nOPENMOD  OPEN  (,(OUTPUT)),MF=L,MODE=31\nOPENLNG  EQU   *-OPENMOD\nCLOSMOD  CLOSE (,),MF=L,MODE=31\nCLOSLNG  EQU   *-CLOSMOD\nRDJFMOD  RDJFCB IEFRD,MF=L\nRDJFLNG  EQU   *-RDJFMOD\nIEFRD    DCB   DDNAME=IEFRDER,MACRF=(E),IOBAD=IOB1A,EXLST=EXITRDR\nLENRDR   EQU   *-IEFRD\nEXITRDR  DS    F\nIOB1A    DC    6D'0'\nPRTDCBE  DCBE  RMODE31=BUFF,SYNAD=SYSERR2\n         EJECT\nIOASECT  DSECT\nSYSPRINT DS    XL(LENPRNT)        24-BIT COPY OF DCB\nSYSEX    DS    X                  EXIT LIST CONTROL BYTE\nSYSEXL   DS    AL3                ADDRESS OF 24-BIT EXIT CODE\nSYSEXT   DS    XL(LENEXIT)        OPEN EXIT CODE\nADOPEN31 DS    A                  ADDRESS OF 31-BIT EXIT CODE\nOPENLST  DS    XL(OPENLNG)        OPEN MACRO CODE\nCLOSLST  DS    XL(CLOSLNG)        CLOSE MACRO CODE\nRDJFLST  DS    XL(RDJFLNG)        READ JFCB MACRO CODE\nIEFRDER  DS    XL(LENRDR)\nEXIT1    DC    X'87'\nEXIT1A   DC    AL3(JFCB1)\nJFCB1    DC    176X'00'\nIOB1     DC    6D'0'\nCP1      DS    CL(LCP1A)\nSECR0    DC    X'00'\nSECR1    DC    X'00'\nDSCB1    DC    140X'00'\nECB1     DC    F'0'\nIOALNG   EQU   *-IOASECT\n         SPACE 2\n* VOLDSECT DSECT\n* VOLREPLY DC    CL30' '             CCCC,TTTT,AAAA/CCCC,TTTT\n         SPACE 2\nVOLDSECT LSPACE MF=(D,DATA)\nVOLSER   DC    CL6' '              VOLUME SERIAL\nVOLSTAB  DC    X'00'               STATUS\nVOLDMCT  DC    X'00'               USE\nVOLNAME  DC    CL4' '              UNIT NAME\nVOLNGH   EQU   *-VOLDSECT\nINXSECT  DSECT\nLLINK    DC    A(0)                LEFT LINK FIELD\nRLINK    DC    A(0)                RIGHT LINK\nINDEX    DC    CL8' '              HIGHEST LEVEL QUALIFIER\nIALLOC   DC    F'0'                TOTAL TRACKS\nIUSED    DC    F'0'                TOTAL IN USE\nICOUNT   DC    H'0',H'0'           DATASET COUNT,FILLER\nILNGH    EQU   *-INXSECT\n         SPACE 2\nDSNSECT  DSECT\nDSNAME   DC    CL44' '             DATASET NAME\nDSVOL    DC    CL6' '              VOLUME SERIAL\nDSALLOC  DC    H'0'                TOTAL TRACKS\nDSUSED   DC    H'0'                TOTAL TRACKS\nDSORG    DC    H'0'                DATASET ORGANIZATION\nDSRECFM  DC    H'0'\nDSLRECL  DC    H'0'\nDSBLKSIZ DC    H'0'\nDSCREDT  DC    XL3'00'             YDD BINARY\nDSREFDT  DC    XL3'00'             YDD BINARY\nDS#EXTS  DC    X'00'               NUMBER OF EXTENTS THIS VOL\nDSNLNGH  EQU   *-DSNSECT\n         SPACE 2\nVLINE    DSECT\n         DS    CL10\nVVOL     DS    CL6,CL5\nVUNIT    DS    CL4,CL5\nVUSE     DS    CL7,CL6\nVFRCYL   DS    CL6,CL1\nVFRTRK   DS    CL6,CL9\nV#EXT    DS    CL4,CL10,CL4\nVLARGC   DS    CL6,CL1\nVLARGT   DS    CL6\n         SPACE 2\nILINE    DSECT\n         DS    CL16\nIINX     DS    CL8,CL7,CL4\nI#DSN    DS    CL3,CL19\nI#TRK    DS    CL8,CL8\nI#USED   DS    CL8,CL8\nIPCT     DS    CL5\n         SPACE 2\nDLINE    DSECT\n         DS    CL2\nDVOL     DS    CL6,CL1\nDALLOC   DS    CL5\nDUSED    DS    CL5,CL2\nDDSORG   DS    CL2,CL1\nDRECFM   DS    CL4\nDLRECL   DS    CL5,CL1\nDBLKSIZ  DS    CL5,CL1\n*#EXT    DS    CL2,CL1\nD#EXT    DS    CL2\n*CREDT   DS    CL6,CL1\nDCREDT   DS    CL7\nDREFDT   DS    CL7,CL1\nDDSN     DS    CL44,CL2\nDMISC    DS    CL20\n         SPACE 2\nFMT1     DSECT\n         IECSDSL1  (1)\nFMT4     DSECT\n         IECSDSL1  (4)\n         DCBD  DSORG=PS\nMCKRECRD DSECT\n         COPY HSMMCK\n         COPY HSMMCA\n         COPY HSMMCD\n         IEZDEB\n         IEZIOB\n         IKJTCB  SYS=AOS2                         WAS SYS=AOS1 FOR VS1\nUCB      DSECT\n         IEFUCBOB\n         UCBTYPES LIST=YES\nJFCB     DSECT\n         IEFJFCBN LIST=YES\nTIOT     DSECT\n         IEFTIOT1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DADSMASM": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00%\\x00\\x96\\x12\\x8f\\x01\\x016/\\x12\\x02\\x00 \\x00\\x1f\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1996-05-07T00:00:00", "modifydate": "2001-12-28T12:02:25", "lines": 32, "newlines": 31, "modlines": 0, "user": "MSTITT"}, "text": "//MSTITT   JOB (XSYZ,MSTITT),'MATTHEW STITT',MSGCLASS=X,NOTIFY=MSTITT,\n//       LINES=999999,TIME=1440,REGION=4M\n//ASM      EXEC PGM=ASMA90,PARM=OBJECT\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.AMACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//         DD   DSN=SYS1.AMODGEN,DISP=SHR\n//         DD   DSN=SYS1.AGENLIB,DISP=SHR\n//         DD   DSN=MSTITT.SRCE.ASM,DISP=SHR\n//SYSUT1   DD   DSN=&&SYSUT1,SPACE=(1700,(600,100))\n//SYSUT2   DD   DSN=&&SYSUT2,SPACE=(1700,(300,50))\n//SYSUT3   DD   DSN=&&SYSUT3,SPACE=(1700,(300,50))\n//SYSPRINT DD   SYSOUT=*\n//SYSPUNCH DD   DUMMY\n//SYSLIN   DD   DSN=&&OBJSET,UNIT=SYSDA,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN DD DSN=MSTITT.SRCE.ASM(DADSMY),DISP=SHR\n//LKED     EXEC PGM=IEWL,\n//  PARM=(LIST,MAP,LET,XREF),\n//             COND=(8,LT,ASM)\n//SYSLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN   DD   DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSUT1   DD   DSN=&&SYSUT1,\n//             SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=*\n//SYSTERM  DD   SYSOUT=*\n//SYSLMOD DD  DSNAME=MSTITT.SRCE.LOAD,DISP=SHR\n//SYSIN  DD  *\n   SETCODE AC(1)\n   NAME DADSMY(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATASECT": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00D\\x00\\x97%\\x9f\\x01\\x03\\x14\\x1f\\x16\\x17\\x01\\x96\\x01F\\x01\\x96\\xd4\\xc1\\xe3\\xe3@@@@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "1997-09-16T00:00:00", "modifydate": "2003-05-21T16:17:44", "lines": 406, "newlines": 326, "modlines": 406, "user": "MATT"}, "text": "         TITLE 'DATA AREAS'\nDATASECT CSECT\n         DS    0D\nDTWORK   DC    D'0'                WORK FIELD FOR DATE CONVERSION\nDTPARM   DC    AL4(0)\nDTL5     EQU   DTWORK+3,5          5 BYTES FOR EDIT MACRO\nDTL4     EQU   DTWORK+4,4          4 BYTES FOR EDIT MACRO\nDTL3     EQU   DTWORK+5,3          3 BYTES FOR EDIT MACRO\nDTL2     EQU   DTWORK+6,2          2 BYTES FOR EDIT MACRO\n         DS    0F\nBUFLEN   DC    AL4(1024*128)       128K RECORD BUFFER\nOPENERR  DC    AL4(0)              OPEN ERROR CODE.\nBUFPTR   DC    AL4(0)\nRPLICAT  DC    AL4(0)              MOVE MODE RPL FOR BCS ACCESS.\nACBICAT  ACB   AM=VSAM,DDNAME=SYSUT1,EXLST=EXLICAT,                    X\n               BUFNI=16,BUFND=16\nEXLICAT  EXLST EODAD=EODICAT\nPAGELEN  EQU   60\n         DS    0F\nMCDSPTR  DC    AL4(0)\nMCDSKEY  DC    CL44' '\nRPLMCDS  RPL   ACB=ACBMCDS,AM=VSAM,AREA=MCDSPTR,AREALEN=4,             X\n               ARG=MCDSKEY,                                            X\n               OPTCD=(KEY,DIR,LOC)\nACBMCDS  ACB   AM=VSAM,DDNAME=SYSUT2,BUFNI=16\nMCDSOPEN DC    X'00'\n         DS    0F\n*\n* THE FOLLOWING FIELDS ARE FILLED IN BY SUBROUTINES\n*   VVDS: FOR VSAM OBJECTS\n*   VTOC: FOR NONVSAM DATASETS\n*\nBLKSIZE  DC    F'0'\nLRECL    DC    F'0'\nTRACKS   DC    F'0'\nEXTENTS  DC    F'0'\nCREDT    DC    XL3'0'\nEXPDT    DC    XL3'0'\nREFDT    DC    XL3'0'\n         SPACE ,\nFDBK     DC    CL4' '              RPL FEEDBACK CODE.              @122\n         SPACE ,\nCNTDATA  DC    PL4'0'              COUNT OF DATA CELLS READ.\nCNTINDEX DC    PL4'0'              COUNT OF INDEX CELLS READ.\nCNTNVSAM DC    PL4'0'              COUNT OF NVSAM CELLS READ.\nCNTCLUST DC    PL4'0'              COUNT OF CLUSTER CELLS READ.\nCNTGDGB  DC    PL4'0'              COUNT OF GDG BASE CELLS READ.\nCNTGDGE  DC    PL4'0'              COUNT OF GDG ENTRY CELLS READ.\nCNTPATH  DC    PL4'0'              COUNT OF PATH CELLS READ.\nCNTAIX   DC    PL4'0'              COUNT OF ALTERNATE INDEX CELLS READ.\nBCSGETS  DC    PL4'0'              GETS ISSUED AGAINST BCS.\nVVDSGETS DC    PL4'0'              GETS ISSUED AGAINST VVDS'S.\nCNTNF    DC    PL4'0'              NUMBER OF DATASETS NOT REALLY THERE.\nCNTNOENT DC    PL4'0'              NUMBER OF GDGBASES WITH NO ENTRIES.\nONE      DC    PL1'1'\nSHREG    DC    CL1'1'              REGION SHARE OPTIONS\nSHSYS    DC    CL1'1'              SYSTEM SHARE OPTIONS\nDSPFX    DC    CL44' '                                          15JAN88\nDSPFXL   DC    F'0'                                             15JAN88\n         SPACE ,\nENDVVD   DC    F'0'                BCS RECORD END ADDRESS\nENDBCS   DC    F'0'                BCS RECORD END ADDRESS\nVVD0     DC    F'0'                PARAMETER AREA FOR FINDVVDS     @134\n         SPACE ,\nWORK     DC    D'0'\nDWK1     EQU   WORK+7,1\nDWK2     EQU   WORK+6,2\nDWK3     EQU   WORK+5,3\nDWK4     EQU   WORK+4,4\nSTARTTRK DC    F'0'\nR2SAVE   DC    F'0'                SAVE R2 WHEN CHECKING FOR OPTIONAL\n*                                  BCS CELLS\nR6SAVE   DC    F'0'                SAVE R6 WHEN CHECKING FOR OPTIONAL\n*                                  VVDS CELLS\nR9SAVE   DC    F'0'                SAVE R9 WHEN HEXING VVDS DATA\n         DS    0F\nLOCDSN   DC    AL4(VVDSN),Y(17)\nVVDSN    DC    C'SYS1.VVDS.V'\nVVDSNAME DC    CL6' '\n         DS    0F\nLOCDDN   DC    AL4(VVDDN),Y(8)\nVVDDN    DS    0CL8\n         DC    C'V'\nVVDDNAME DC    CL6' ',C' '\n* DSGETL EQU   256*VVDSTLEN        256 VVDS'S AT MOST              @131\nVVDSGETL EQU   1024*VVDSTLEN       1024 VVDS'S AT MOST\nVVDSTAD  DC    A(0)                ADDRESS OF VVDSTAB\nVVDSTEND DC    A(0)                LAST ELEMENT IN VVDSTAB         @131\nDSEXTLEN EQU   X'0A'               LENGTH OF EXTENT ENTRY\nDSEXTL   DC    XL1'80'\n         DC    AL3(256*DSEXTLEN)   256 EXTENTS PER VOLUME\nDSEXTAD  DC    A(0)                ADDRESS OF EXTENT TABLE\nHIGHUCB  DC    Y(0)                HIGHEST UCB ADDR FOUND\nRBASAVE  DC    F'0'                RBA ARG FOR VVDS GET\nSHOWRBA1 DC    F'0'\nSHOWRBA2 DC    F'0'\nSVCOMPN  DC    CL44' '             BCS NAME. FOR COMPARE TO VVRCOMP\nGDGSAVE  DC    CL44' '             GDG BASE NAME. SAVED TO DEVELOP\n*                                    ENTRY NAMES FROM NAME CELLS\nGDGWORK  DC    CL44' '             WORKAREA TO DEVELOP ENTRY NAME\nGWORD    DC    D'0'\nGWK3     EQU   GWORD+5,3\nGWK2     EQU   GWORD+6,2\n*\n* THIS SWITCH IS USED TO DETECT THE FIRST BCS CELL READ IN. THE THEORY\n* IS THAT THIS IS THE CLUSTER CELL FOR THE ICF CATALOG ITSELF. THE NAME\n* OF THE FOLLOWING DATA CELL IS THE CATALOG NAME (AS IT WERE) AND\n* IS INSERTED INTO THE HEADING FOR THE DELECTATION OF USERS WHO CAN'T\n* REMEMBER WHAT CATALOG THEY WERE LISTING.\n*\nFIRST    DC    XL1'00'\n* THIS SWITCH IS USED TO DETECT THE SITUATION OF A GDGBASE NOT BEING\n* FOLLOWED BY ANY ENTRIES FOR THE GDG.\nBASESW   DC    XL1'00'\nVOLINFSW DC    XL1'00'\nVOLDSSW  DC    XL1'00'\n* THIS SWITCH IS USED TO DETECT THE SITUATION OF A SECOND TO N-TH\n* VOLUME CELL FOLLOWING A PREVIOUSLY READ VOLUME CELL.\nVOLSW    DC    XL1'00'                                          13JAN88\n* THIS SWITCH IS USED TO TELL IF THE PREFIX GIVEN BY THE PARM MATCHES\n* THE DATASET OBJECT BEING PROCESSED.\n         DS    0F\nSAVECL   DC    AL4(0)              SAVE ADDR OF ICF CLUSTER CELL.\n         SPACE ,\nTRKCYL   DC    AL4(*-*)            TRACKS PER CYLINDER, CURRENT DS.\n         SPACE ,\n*\n*\n* DEVICE CODE NAME TABLE\n*\nDEVCDTBL DC    0H'0'\n         DC    X'30008001',CL6'2400',Y(12)\n         DC    X'30102004',CL6'9345',Y(15)\n         DC    X'30102006',CL6'2305-1',Y(08)\n         DC    X'30102007',CL6'2305-2',Y(08)\n         DC    X'30102008',CL6'2314',Y(20)\n         DC    X'3010200A',CL6'3340',Y(12)\n         DC    X'3010200C',CL6'3375',Y(12)    CBOC  18JAN84\n         DC    X'3010200E',CL6'3380',Y(15)    MLI   24APR85\n         DC    X'3010200F',CL6'3390',Y(15)    TEC   18NOV91\n         DC    X'3030200F',CL6'3390',Y(15)    MVS   13MAR02\n         DC    X'3030200C',CL6'3375',Y(12)    CBOC  18JAN84\n         DC    X'3050200B',CL6'3350',Y(30)    AFDSC 26MAR81\n         DC    X'3050200D',CL6'3330-1',Y(19)  AFDSC 26MAR81\n         DC    X'30502009',CL6'3330',Y(19)\n         DC    X'30582009',CL6'3330V',Y(19)   AFDSC 26MAR81\n         DC    X'3070200D',CL6'3330-1',Y(19)  AFDSC 26MAR81\n         DC    X'30702009',CL6'3330',Y(19)\n         DC    X'30782009',CL6'3330V',Y(19)   AFDSC 26MAR81\n         DC    X'30808001',CL6'2400-1',Y(00)\n         DC    X'30C08001',CL6'2400-2',Y(00)\n         DC    X'30C08003',CL6'3400-2',Y(00)  AFDSC 11MAY78\n         DC    X'32008003',CL6'3400-5',Y(00)  AFDSC 11MAY78\n         DC    X'32108003',CL6'3400-6',Y(00)  AFDSC 11MAY78\n         DC    X'34008001',CL6'2400-3',Y(00)\n         DC    X'34008003',CL6'3400-3',Y(00)  AFDSC 11MAY78\n         DC    X'34208001',CL6'2400-4',Y(00)\n         DC    X'34208003',CL6'3400-4',Y(00)  AFDSC 11MAY78\n         DC    X'78008080',CL6'3480',Y(00)    MLI   080CT86        @122\n         DC    X'78048080',CL6'3480X',Y(00)   MVS   23SEP97\n         DC    X'78048081',CL6'3490',Y(00)    MVS   23SEP97\n         DC    X'78048083',CL6'3590-1',Y(00)  MVS   23SEP97\n         DC    X'FFFFFFFF'\nLSTENTRY EQU   *                   .\n         SPACE ,\nPWA      XPRDCB  DDNAME=SYSPRINT\nHEADER1  XPRLDEF TEXT=HTEXT1,LENGTH=L'HTEXT1,SPB=(0,ATHOF),SPA=2\nHTEXT1   DC    C'&NAME &VERSION -- LISTING OF ICF CATALOG --           X\n                                            '                      @121\nCATNAME  EQU   HTEXT1+44                                           @121\nHEADER2  XPRLDEF TEXT=HTEXT2,LENGTH=HTEXT2L,SPA=1\nHTEXT2   DC    CL5'ENTRY'\n         DC    CL12' '\n         DC    CL10'ALLOCATION'\n         DC    CL3' '\n         DC    CL3'NUM'\n         DC    CL1' '\n         DC    CL5'ALLOC'\n         DC    CL1' '\n         DC    CL3'PCT'\n         DC    CL2' '\n         DC    CL3'ENT'\n         DC    CL3' '\n         DC    CL4'DATE'\n         DC    CL5' '\n         DC    CL4'DATE'\n         DC    CL6' '\n         DC    CL3'NUM'\n         DC    CL5' '\n         DC    CL8'REC SIZE'\n         DC    CL4' '\n         DC    CL2'CI'\n         DC    CL2' '\n         DC    CL3'KEY'\n         DC    CL2' '\n         DC    CL3'KEY'\n         DC    CL2' '\n         DC    CL6'SPLITS'\n         DC    CL1' '\n         DC    CL3'SHR'\n         DC    CL2' '\n         DC    CL4'FSPC'\n         DC    CL3' '\n         DC    CL4'DATE'\nHTEXT2L  EQU   *-HTEXT2\nHEADER2A XPRLDEF TEXT=HTEXT2A,LENGTH=HTEXT2AL,SPA=2\nHTEXT2A  DC    CL4'NAME'\n         DC    CL1' '\n         DC    CL3'VOL'\n         DC    CL1' '\n         DC    CL4'UNIT'\n         DC    CL2' '\n         DC    CL4'TYPE'\n         DC    CL2' '\n         DC    CL3'PRM'\n         DC    CL2' '\n         DC    CL3'SEC'\n         DC    CL1' '\n         DC    CL3'EXT'\n         DC    CL1' '\n         DC    CL5'TRACK'\n         DC    CL1' '\n         DC    CL3'USD'\n         DC    CL2' '\n         DC    CL4'TYPE'\n         DC    CL1' '\n         DC    CL7'CREATED'\n         DC    CL2' '\n         DC    CL7'EXPIRES'\n         DC    CL4' '\n         DC    CL5'RECDS'\n         DC    CL3' '\n         DC    CL3'AVG'\n         DC    CL3' '\n         DC    CL3'MAX'\n         DC    CL2' '\n         DC    CL4'SIZE'\n         DC    CL1' '\n         DC    CL3'LEN'\n         DC    CL2' '\n         DC    CL3'POS'\n         DC    CL2' '\n         DC    CL2'CI'\n         DC    CL2' '\n         DC    CL2'CA'\n         DC    CL1' '\n         DC    CL3'OPT'\n         DC    CL1' '\n         DC    CL2'CI'\n         DC    CL1' '\n         DC    CL2'CA'\n         DC    CL2' '\n         DC    CL6'ACCESS'\nHTEXT2AL EQU   *-HTEXT2A\nHEADER3  XPRLDEF TEXT=HTEXT3,LENGTH=HTEXT3L,SPA=2\nHTEXT3   DC    CL7'TYPE',CL2' '\n         DC    124C'-'\n         ORG   *-124\n         DC    C'CELL FORMATS '\nHTEXT3L  EQU   *-HTEXT3\nBLINE    DC    CL133' '\nRPTLINE1 DS    0CL133\n         DC    CL1' '\nL1SUB1   DS    0CL45\nL1DSNAME DC    CL44' ',CL1' '\nL1SUB2   DS    0CL22\nL1TYPE   DC    CL3' ',CL1' '\nL1CREDT  DC    CL8' ',CL1' '\nL1EXPDT  DC    CL8' ',CL1' '\nL1SUB3   DS    CL62\n         ORG   RPTLINE1+133\nRPTLINE2 DS    0CL133\nL2SUB1   DS    0CL45\n         DC    CL3' '\nL1VOLUME DC    CL6' ',CL1' '\n*1UNIT   DC    CL5' ',CL1' '\nL1UNIT   DC    CL6' ',CL1' '\nL1ALTYP  DC    CL3' '\nL1ALPRM  DC    CL5' '\nL1ALSEC  DC    CL5' ',CL1' '\nL1XTNT   DC    CL3' ',CL1' '                                       @130\nL1TRACKS DC    CL5' ',CL1' '\nL1USED   DC    CL3' ',CL2' '                                       @130\nL2SUB2   DC    CL22' '\nL1NOREC  DC    CL8' '\nL1LRECL  DC    CL6' '\nL1MRECL  DC    CL6' ',CL1' '\nL1BLKSIZ DC    CL5' ',CL1' '\nL1KLEN   DC    CL3' '\nL1KPOS   DC    CL5' '\nL1CISP   DC    CL4' '\nL1CASP   DC    CL4' ',CL1' '                                       @130\nL1CRSHR  DC    CL1' ',CL1' '                                       @130\nL1CSSHR  DC    CL1' ',CL1' '                                       @130\nL1CIFS   DC    CL2' ',CL1' '                                       @130\nL1CAFS   DC    CL2' ',CL1' '                                       @130\nL1ACCDT  DC    CL8' '\n         ORG    L1BLKSIZ\nL1GDGMAX DC    CL4' ',CL3' '                                    16DEC86\nL1GDGSCR DC    CL9' ',CL3' '                                    16DEC86\nL1GDGEMP DC    CL7' ',CL3' '                                    16DEC86\n         ORG   RPTLINE2+133\nRPTLINE3 DS    0CL133\n         DC    CL1' '\nL2TYPE   DC    CL7' ',CL2' '\nL2WORK   DC    CL124' '\nNUMBERS  DC    C'0123456789ABCDEF'\nTRHEX    EQU   *-256\nDEPTH    DC    F'0'\nENTRIES  DS    16F\nEXITS    DS    16F\n         SPACE ,                                                   @120\nBLNKLNE  DC    A(0,BLINE+1)       PARMS TO PRINT BLANK LINE\nPLINE1   DC    A(0,RPTLINE1+1)    PARMS TO PRINT RPTLINE1          @120\nPLINE2   DC    A(0,RPTLINE2+1)    PARMS TO PRINT RPTLINE2          @120\nPLINE2A  DC    A(1,RPTLINE3+1)    SKIP ONE, THEN PRINT RPTLINE2    @120\n         SPACE ,                                                   @120\nPARMLIST DS    3F                 PARMLIST MAPPING FOR UCB         @120\n         ORG   PARMLIST                                            @120\nPARMWA   DS    F                  ADDR OF 100-BYTE WORK AREA       @120\nPARMDEVT DS    F                  ADDR OF DEV TYPE TO SCAN FOR     @120\nPARMUCB  DS    F                  ADDR OF RETURNED UCB             @120\n         SPACE ,                                                   @120\nDEVCLASS DS    CL1                DEVICE CLASS TO SEARCH FOR       @120\nVOLTYP   DS    F                  RETURNED UCB ADDR                @120\nADDRUCB  DS    F                  RETURNED UCB ADDR                @120\nSCANSAVE DS    F                  ADDR OF SCAN SERVICE ROUTINE     @120\nXASWITCH DC    X'00'              INITIALIZE SWITCH                @120\n         DS    0D                 FOR ALIGNMENT                    @120\nUCBWORK  DS    CL100              UCB WORK AREA                    @120\nUCBCOPY  DS    CL48               UCB COPY AREA\nCOMPNAME DS    CL44               VSAM COMPONENT NAME\n         SPACE ,                                                   @120\n         DYNSPACE  ,\n         SPACE ,\n         DS    0F\nSYMBTBL  DS    CL(SYMBP_LEN)\nSYMBTL   DS    F\n         SPACE ,                                                   @130\n*                                                                  @130\n* FLAGS1                                                           @130\nTAPE     EQU   B'10000000'                                         @130\nDASD     EQU   B'00100000'                                         @130\nDUMP     EQU   B'00010000'                                         @130\nLEVEL    EQU   B'00000100'                                         @130\nNOLEVEL  EQU   B'00000010'                                         @130\n*                                                                  @130\n* FLAGS2                                                           @130\nVOLUME   EQU   B'10000000'                                         @130\nNOVOLUME EQU   B'01000000'                                         @130\nBRKLVL   EQU   B'00000010'                                         @130\n*                                                                  @130\n* FLAGS3                                                           @130\nCONTAIN  EQU   B'00100000'                                         @130\nENDING   EQU   B'00010000'                                         @130\nNOTCONT  EQU   B'00001000'                                         @130\nNOTEND   EQU   B'00000100'                                         @130\n*                                                                  @130\nNOTAPE   EQU   255-TAPE                                            @130\nNODASD   EQU   255-DASD                                            @130\nNOBRKLVL EQU   255-BRKLVL                                          @130\n*                                                                  @130\n* DEFAULTS: NOTAPE,DASD                                            @130\n*                                                                  @130\n         DS    0F                                                  @130\nFLAGS    DC    AL1(DASD),AL1(0),AL1(0)                             @130\nFLAGS1   EQU   FLAGS,1                                             @130\nFLAGS2   EQU   FLAGS+1,1                                           @130\nFLAGS3   EQU   FLAGS+2,1                                           @130\n         SPACE ,                                                   @130\nDFLTFLAG DC    AL1(DASD),AL1(0),AL1(0)                             @130\n         SPACE ,                                                   @130\nETAB     DS    0H                                                  @130\n         DC    AL1(255),CL8' '                                     @130\n         DC    16X'000000000000000000'                             @130\n         DC    X'FF'                                               @130\nCTAB     DS    0H                                                  @130\n         DC    AL1(255),CL8' '                                     @130\n         DC    16X'000000000000000000'                             @130\n         DC    X'FF'                                               @130\nNETAB    DS    0H                                                  @130\n         DC    AL1(255),CL8' '                                     @130\n         DC    16X'000000000000000000'                             @130\n         DC    X'FF'                                               @130\nNCTAB    DS    0H                                                  @130\n         DC    AL1(255),CL8' '                                     @130\n         DC    16X'000000000000000000'                             @130\n         DC    X'FF'                                               @130\nLTAB     DS    0H                                                  @130\n         DC    AL1(255),CL8' '                                     @130\n         DC    16X'000000000000000000'                             @130\n         DC    X'FF'                                               @130\nNLTAB    DS    0H                                                  @130\n         DC    AL1(255),CL8' '                                     @130\n         DC    16X'000000000000000000'                             @130\n         DC    X'FF'                                               @130\nNVTAB    DS    0H                                                  @130\n         DC    AL1(255),CL6' '                                     @130\n         DC    16X'00000000000000'                                 @130\n         DC    X'FF'                                               @130\nVTAB     DS    0H                                                  @130\n         DC    AL1(255),CL6' '                                     @130\n         DC    16X'00000000000000'                                 @130\n         DC    X'FF'                                               @130\n         SPACE ,\nCVPLMAP  ICVAFPL DSECT=NO                                          @131\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSECTS": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00H\\x01\\x02\\x07\\x9f\\x01\\x02\\x10/\\x10S\\x01?\\x01\\xa1\\x00\\x02\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-03-20T00:00:00", "modifydate": "2002-04-12T10:53:48", "lines": 319, "newlines": 417, "modlines": 2, "user": "MSTITT"}, "text": "         TITLE 'DSECTS FOR CATALOG CELLS.'\nVVDSTAB  DSECT ,\nVVDSVOL  DS    CL6                 VOLSER OF A VOLUME WITH A VVDS\nVVDSACB  DS    0F,AL4              ADDRESS OF A GENERATED ACB\nVVDSRPL  DS    AL4                 ADDRESS OF A GENERATED RPL\nVVDSBUF  DS    AL4                 ADDRESS OF A RECORD BUFFER\nVVDSARG  DS    AL4                 ADDRESS OF RBA TO READ THE VVDS\nVVDSFLG  DS    0CL1                INDEXED VTOC FLAG               @131\n         DS    AL4                                                 @131\nVVDSTLEN EQU   *-VVDSTAB           LENGTH OF AN ENTRY\n         SPACE 2\nVCNC     DSECT                     VSAM CLUSTER NAME CELL\nCLCELLN  DS    XL2                 LENGTH OF VCNC INCLUDING ITSELF\nCLTYPE   DS    CL1                 TYPE 'C' FOR CLUSTER\nCLCOMPLN DS    XL2                 LENGTH OF THE CLUSTER COMPONENT\nCLNOEXT  DS    XL1                 NUMBER OF EXTENSION RECORDS\nCLNMLEN  DS    XL1                 LENGTH OF THE CLUSTER KEY (45)\nCLNAME   DS    CL44                CLUSTER NAME\nCLNMPAD  DS    XL1                 PAD VALUE, SET TO X'00'\n         SPACE 2\nDINC     DSECT                     DATA OR INDEX NAME CELL\nDIDLEN   DS    XL2                 LENGTH OF DINC\nDIDTYPE  DS    CL1                 TYPE 'D' FOR DATA OR INDEX\nDIDCMPLN DS    XL2                 LENGTH OF DINC COMPONENT\nDIDIRFLG DS    XL1                 INTERRUPT RECOGNITION FLAGS\nDIDELETE EQU   B'1000000'          DELETE IN PROGRESS\nDIDUPDAT EQU   B'0100000'          UPDATE-EXTEND IN PROGRESS\nDIDSRMU  EQU   B'0010000'          SUB-RECORD MOVE/UPDATE IN PROGRESS\nDIDKEYLN DS    XL1                 CONDENSED KEYLENGTH\nDIDKEY   DS    0XL1                CONDENSED KEY\n         SPACE 2\nANC      DSECT                     ALTERNAME INDEX CELL\nAIXLEN   DS    XL2                 LENGTH OF ANC\nAIXTYPE  DS    CL1                 TYPE 'G' FOR ANC\nAIXCMPLN DS    XL2                 LENGTH OF AIX COMPONENT\nAIXFLAG  DS    XL1                 FLAG BYTE\nAIXUPG   EQU   B'1000000'          AIX IS MEMBER OF UPGRADE SET\nAIXKEYLN DS    XL1                 CONDENSED KEYLENGTH\nAIXKEY   DS    0XL1                CONDENSED KEY 2-45 BYTES\n         SPACE 2\nPNC      DSECT                     PATH NAME CELL\nPATHCELN DS    XL2                 LENGTH OF PATH CELL\nPATHTYPE DS    CL1                 TYPE 'R' FOR PATH\n         DS    XL2\nPATHATTR DS    XL1                 PATH ATTRIBUTES\nPATHUPG  EQU   B'1000000'          UPGRADE IF RELATED TO AIX\nPATHUPD  EQU   B'1000000'          UPDATE IF RELATED TO CLUSTER.\nPATHREL  EQU   B'0010000'          0=RELATED TO AIX,1=RELATED TO\n*                                  CLUSTER\nPATHKYLN DS    XL1                 LENGTH OF PATH KEY\nPATHNAME DS    CL44                PATH NAME.\n         SPACE 2\nNVNC     DSECT                     NONVSAM DATASET CELL\nNVCELEN  DS    XL2                 LENGTH OF NVNC\nNVTYPE   DS    CL1                 TYPE 'A' FOR NONVSAM\nNVRESV   DS    XL1                 RESERVED\nNVOLCNT  DS    XL2                 NUMBER OF VOLUME CELLS (255 MAX)\nNVKEYLN  DS    XL1                 LENGTH OF THE NONVSAM KEY\nNVNAME   DS    CL44                DATASET NAME\nNVPAD    DS    XL1                 PAD VALUE X'00'\n         SPACE 2\nOWNERC   DSECT                     OWNERSHIP CELL FORMAT.\nOWNCELLN DS    XL2                 LENGTH OF OWNERSHIP CELL\nOWNTYPE  DS    XL1                 TYPE X'01' FOR OWNER\nOWNID    DS    XL8                 OWNER ID\nOWNFLAG  DS    XL1                 FLAG\nOWNRACF  EQU   B'10000000'         RACF PROTECTED\nOWNKSDS  EQU   B'01000000'         INDEX COMPONENT DATASET\nOWNREUS  EQU   B'00100000'         REUSABLE DATASET.\nOWNERASE EQU   B'00010000'         ERASE\nOWNSWAP  EQU   B'00000010'         SWAPSPACE\nOWNPAGE  EQU   B'00000001'         PAGESPACE\nOWNCREDT DS    XL3                 CREATION DATE\nOWNEXPDT DS    XL3                 EXPIRY DATE\n         SPACE 2\nSECURITY DSECT                     SECURITY CELL\nSECELLN  DS    XL2                 LENGTH OF SECURITY CELL\nSECTYPE  DS    XL1                 TYPE X'02' FOR SECURITY.\nSECMSTR  DS    CL8                 MASTER PASSWORD.\nSECCI    DS    CL8                 CONTROL INTERVAL PASSWORD.\nSECUPDTE DS    CL8                 UPDATE PASSWORD.\nSECREAD  DS    CL8                 READ PASSWORD.\nSECPMTCD DS    CL8                 PASSWORD PROMPTING CODE.\nSECATMP  DS    XL2                 MAXIMUM NUMBER OF ATTEMPTS.\nSECVRMOD DS    CL8                 USER SECURITY VERIFICATION MOD.\nSECRCDLN DS    XL2                 USER AUTHORIZATION RECORD LENGTH.\nSECRCD   DS    0XL1                USER AUTHORIZATION RECORD (256 MAX)\n         SPACE 2\nASSOCC   DSECT                     ASSOCIATION CELL\nASCLEN   DS    XL2                 ASSOCIATION CELL LENGTH\nASCTYPE  DS    XL1                 TYPE X'03' FOR ASSOC\nASCOUNT  DS    XL2                 COUNT OF ASSOCIATIONS\n* THE FOLLOWING FIELDS ARE REPEATED THE NUMBER OF TIMES IN ASCOUNT\nASCKEYS  DS    0XL2\nASCFLAG  DS    XL1                 FLAG\nASCREUS  EQU   B'10000000'         USED IN RELATION CELL ONLY.\nASCKYLEN DS    XL1                 LENGTH OF CONDENSED ASSOC KEY.\nASCKEY   DS    0XL1                2-45 BYTE CONDENSED KEY.\n         SPACE 2\nGATC     DSECT\nGATCELN  DS    XL2                 LENGTH OF GATC INCLUDING ITSELF\nGATYPE   DS    CL1                 TYPE X'05' FOR GDG AGING TABLE\nGATATTR  DS    XL1                 GDG SCRATCH/DELETE ATTRIBUTE\nGATDELET EQU   B'10000000'         DELETE ALL GDGS\nGATSCRTH EQU   B'01000000'         SCRATCH IF MOUNTED\nGATLIMIT DS    XL1                 MAXIMUM GDS ENTRIES IN GDG BASE\nGATCNT   DS    XL1                 CURRENT NUMBER OF ENTRIES IN GAT\n* THE FOLLOWING FIELDS ARE REPEATED THE NUMBER OF TIMES IN GATCNT\nGAT      DS    0XL4                4-BYTE ENTRY FOR EACH GDS\nGATENT   DS    0XL4                GAT ENTRY\nGATEXTNO DS    XL1                 EXTENSION RECORD SEQUENCE NUMBER\nGATGEN   DS    XL2                 GENERATION NUMBER OF GDS\nGATWRAP  EQU   B'10000000'         GENERATION EXCEEDED 9999\nGATVER   DS    XL1                 VERSION NUMBER OF GDS\n         SPACE 2\nGDGNC    DSECT                     GDG BASE NAME CELL\nGDGCELLN DS    XL2                 LENGTH OF GDGNC INCLUDING ITSELF\nGDGTYPE  DS    CL1                 TYPE 'B' FOR GDG\nGDGCMPLN DS    XL2                 LENGTH OF THE GDG COMPONENT\nGDGNOEXT DS    XL1                 NUMBER OF EXTENSION RECORDS\nGDGKYLEN DS    XL1                 LENGTH OF THE GDG\nGDGNAME  DS    CL44                GDG NAME 1-35 BYTES BLANK PADDED\nGDGPAD   DS    XL1                 PAD VALUE, SET TO X'00'\n         SPACE 2\nGDSNC    DSECT                     GDG ENTRY NAME CELL\nGDSCELLN DS    XL2                 LENGTH OF GDSNC INCLUDING ITSELF\nGDSTYPE  DS    CL1                 TYPE 'H' FOR GDS\nGDSCMPLN DS    XL2                 LENGTH OF THE GDS COMPONENT\nGDSGENO  DS    XL2                 GENERATION NUMBER\nGDSVERNO DS    XL1                 VERSION NUMBER\nGDSVOLCT DS    XL2                 NUMBER OF VOLUME CELLS IN GDS\n         SPACE 2\nVOLCELL  DSECT                     VOLUME CELL\nVOLLEN   DS    XL2                 LENGTH OF VOLCELL\nVOLTYPE  DS    XL1                 TYPE X'04' FOR VOLUME CELL\nVOLOFSET DS    XL1                 UNUSED\nVOLSERN  DS    CL6                 VOLUME SERIAL NUMBER\nVOLDEVTP DS    XL4                 DEVICE TYPE\nVOLFLAG1 DS    XL1                 FLAG\nVOLPRIME EQU   B'10000000'         PRIME VOLUME-ALLOCATED SPACE\nVOLCANDI EQU   B'01000000'         CANDIDATE VOLUME NOSPACE\nVOLOFLOW EQU   B'00100000'         OVERFLOW KEYRANGE ONLY\nVOLCONV  EQU   B'00010000'         CONVERTED VSAM DATASET VOLUME\nVOLNVSAM EQU   B'00001000'         NONVSAM VOLUME CELL\nVOLKYRNG EQU   B'00000100'         KEYRANGE QUALIFIER PRESENT\nVOLVPCI  EQU   B'00000010'         PRIMARY VVR CI\nVOLSSQWD EQU   B'00000001'         SEQUENCE SET WITH DATA\nVOLFLAG2 DS    XL1                 RESERVED\nVOLVVRBA DS    0XL4                RELATIVE BYTE ADDRESS OF VVR\nVOLDSTTR DS    XL3                 NONVSAM FORMAT 1 DSCB TTR\n         DS    XL1                 RESERVED\nVOLFLSEQ DS    XL2                 NONVSAM FILE SEQUENCE NUMBER (TAPE)\nVOLKRQL  DS    XL4                 KEYRANGE QUALIFIER (VSAM ONLY)\nVOLLKYLN DS    XL2                 LENGTH OF LOW KEY RANGE KEY\n         SPACE 2\nRELCELL  DSECT                     RELATIONSHIP CELL.\nRELLEN   DS    XL2                 CELL LENGTH.\nRELTYPE  DS    XL1                 TYPE X'06'\nRELRESV  DS    XL1                 RESERVED.\nRELCNT   DS    XL1                 COUNT OF RELKEYS.\nRELKEYS  DS    0XL2\nRELFLAG  DS    XL1                 FLAG BYTE\nRELUPG   EQU   B'10000000'         UPGRADE AIX.\nRELGLEN  DS    XL1                 LENGTH OF AIX CONDENSED KEY.\nRELGKEY  DS    0XL1                AIX CONDENSED KEY.\n         SPACE 2\nVVR      DSECT\n*VVRLEN  DS    XL2                LENGTH OF ENTIRE VVR\nVVRHDLEN DS    XL2                 LENGTH OF VVR HEADER\nVVRTYPE  DS    CL1                 Z=PRIMARY VVR. Q=SECONDARY VVR\nVVRFLAG  DS    XL1                 HEADER FLAG\nVVRSELFD EQU   B'01000000'         SELF-DESCRIBING VVR FOR VVDS\nVVRCATDS EQU   B'00100000'         CATALOG SELF-DESCRIBING VVR\nVVRCOMTP EQU   B'00001000'         COMPONENT TYPE. 0='D' 1='I'\nVVRKRQ   DS    XL4                 KEY RANGE QUALIFIER\nVVRCMPNL DS    XL1                 COMPONENT NAME LENGTH\nVVRCMPNM DS    0CL44               COMPONENT NAME\n         SPACE 2\nVVRDSINF DSECT                     DATASET INFORMATION CELL\nVVRDSLEN DS    XL2                 CELL LENGTH.\nVVRDSTYP DS    XL1                 TYPE CODE IS X'21'\nVVRDSATR DS    0XL2                DATASET ATTRIBUTES\nVVRATTR1 DS    XL1\nVVRA1SPD EQU   B'10000000'         SPEED\nVVRA1UNQ EQU   B'01000000'         UNIQUE\nVVRA1REU EQU   B'00100000'         REUSE\nVVRA1ERS EQU   B'00010000'         ERASE\nVVRA1IUP EQU   B'00000100'         INHIBIT UPDATE\nVVRA1TEX EQU   B'00000010'         EXPORT TEMPORARY.\nVVRA1TKO EQU   B'00000001'         TRACK OVERFLOW\nVVRATTR2 DS    XL1\nVVRA2REG EQU   B'11000000'         CROSS-REGION SHROPTN\nVVRA2SYS EQU   B'00110000'         CROSS-SYSTEM SHROPTN\nVVRA2INT EQU   B'00000010'         INTERNAL DATASET\nVVRA2NUS EQU   B'00000001'         COMPONENT IS NOT USABLE.\nVVROPIND DS    XL1                 OPEN INDICATOR\nVVRBUFSZ DS    XL4                 MINIMUM BUFFER SIZE\nVVRPRISP DS    XL3                 PRIMARY SPACE ALLOCATION\nVVRSECSP DS    XL3                 SECONDARY SPACE ALLOCATION\nVVRSPCFG DS    XL1                 SPACE FLAGS\nVVRSPCOP EQU   B'11000000'         SPACE OPTIONS\nVVRDSHU  DS    XL4                 DATASET HIGH USED RBA\nVVRDSHA  DS    XL4                 DATASET HIGH ALLOCATED RBA\nVVRLRECL DS    XL4                 AVERAGE LOGICAL RECORD LENGTH\n         DS    XL2\nVVREXCPX DS    CL8                 EXCEPTION EXIT.\nVVRDSHK  DS    XL4                 DATASET HIGH KEY RBA.\nVVRCLSFG DS    XL1                 CLUSTER ATTRIBUTE FLAG\nVVRCFSWS EQU   B'00000010'         CLUSTER DESCRIBES A SWAP SPACE\nVVRCFPGS EQU   B'00000001'         CLUSTER DESCRIBES A PAGE SPACE\nVVRAIXFG DS    XL1                 AIX ATTRIBUTE FLAG\nVVRAIUPG EQU   B'00000001'         UPGRADE AIX.\nVVRTMSTP DS    XL8                 TIMESTAMP (CATALOG ONLY).\n         SPACE 2\nVVRVOLIN DSECT                     VVR VOLUME INFORMATION CELL\nVVRVOLLN DS    XL2                 LENGTH OF VOLUME CELL\nVVRVOLTP DS    XL1                 TYPE CODE IS X'23'\nVVRVOLFG DS    XL1                 VOLUME FLAGS\nVVRPRIME EQU   B'10000000'         PRIME VOLUME\nVVROVFLW EQU   B'00100000'         OVERFLOW VOLUME\nVVRNOEXT DS    XL1                 NUMBER OF EXTENTS ON THIS VOLUME.\nVVRHKRBA DS    XL4                 HIGH KEY RBA\nVVRHURBA DS    XL4                 HIGH USED RBA\nVVRHARBA DS    XL4                 HIGH ALLOCATED RBA\nVVRBLKSZ DS    XL4                 BLOCK SIZE\nVVRBLKTK DS    XL2                 NUMBER OF BLOCKS PER TRACK\nVVRTRKAU DS    XL2                 NUMBER OF TRACKS PER ALLOCATION UNIT\nVVRTPEXT DS    XL1                 EXTENT TYPE FLAG\nVVRSSDAT EQU   B'10000000'         SEQUENCE SET WITH DATA\nVVRNOPFM EQU   B'01000000'         EXTENTS NOT PRE-FORMATTED\nVVRCONV  EQU   B'00100000'         CONVERTED VSAM DATASET VOLUME.\nVVRTKCYL DS    XL2                 TRACKS PER CYLINDER\nVVRBYTTK DS    XL4                 BYTES PER TRACK.\nVVRBYTAU DS    XL4                 BYTES PER ALLOCATION UNIT\nVVRLOKYL DS    XL2                 LOW KEY LENGTH\nVVRLOKYV DS    0XL1                LOW KEY ON VOLUME\nVVRXTENT DS    0XL1                EXTENT SECTION. FOLLOWS LOW KEY\n*                                  VALUE\nVVRXTNTL DS    XL2                 TOTAL LENGTH OF EXTENT SECTION.\nVVRXTNT  DS    0XL20               20 BYTE EXTENT DESCRIPTION.\nVVRXSEQN DS    XL2                 SEQUENCE NUMBER\nVVRXSCH  DS    0XL4                STARTING CCHH\nVVRXSC   DS    XL2                 STARTING CC\nVVRXSH   DS    XL2                 STARTING HH\nVVRXECH  DS    0XL4                ENDING CCHH\nVVRXEC   DS    XL2                 ENDING CC\nVVRXEH   DS    XL2                 ENDING HH\nVVRXNTRK DS    XL2                 NUMBER OF TRACKS\nVVRXSRBA DS    XL4                 STARTING RBA\nVVRXERBA DS    XL4                 ENDING RBA\n         SPACE 2\nVVRAMDCL DSECT                     VVR AMDSB CELL\nVVRAMDCN DS    XL2                 LENGTH OF AMDSB CELL\nVVRAMCAT DS    0XL96               COPY OF AN AMDSB\nVVRAMID  DS    XL1                 TYPE CODE IS X'60'\nVVRAMATR DS    XL1                 ATTRIBUTES:\nVVRAMDST EQU   B'10000000'         1=KSDS, 0=ESDS\nVVRAMWCK EQU   B'01000000'         WRITE CHECK\nVVRAMSDT EQU   B'00100000'         SEQUENCE SET WITH DATA\nVVRAMREP EQU   B'00010000'         REPLICATION\nVVRAMORD EQU   B'00001000'         USE VOLUMES IN LIST ORDER\nVVRAMRGE EQU   B'00000100'         KEY RANGE DATASET\nVVRAMRDS EQU   B'00000010'         RRDS\nVVRAMRSN EQU   B'00000001'         SPANNED RECORDS ALLOWED\nVVRAMLEN DS    XL2                 LENGTH OF AMDSB\nVVRAMNST DS    0XL2                NUMBER OF ENTRIES IN INDEX SECTION\nVVRAMAKP DS    XL2                 ALTERNATE KEY RKP\nVVRAMRKP DS    XL2                 RKP\nVVRAMKNL DS    XL2                 KEY LENGTH\nVVRAMPCA DS    XL1                 % FREE CI IN CA\nVVRAMPCI DS    XL1                 % FREE BYTES IN CI\nVVRAMCCA DS    XL2                 CI'S PER CA\nVVRAMFCA DS    XL2                 FREE CI'S PER CA\nVVRAMFCI DS    XL4                 FREE BYTES PER CI\nVVRAMCIV DS    XL4                 CONTROL INTERVAL SIZE\nVVRAMLCL DS    XL4                 MAXIMUM RECORD SIZE\nVVRAMHLR DS    0XL4                RBA OF HI LEVEL INDEX RECORD\nVVRAMSLT DS    XL4                 SLOTS PER CI\nVVRAMSSR DS    0XL4                RBA OF FIRST SEQUENCE SET RECORD\nVVRAMMRR DS    XL4                 MAXIMUM RELATIVE RECORD NUMBER\nVVRAMARB DS    XL4                 POINTER TO 1ST ARDB\nVVRAMAT3 DS    XL1                 ATTRIBUTES\nVVRAMUNQ EQU   B'10000000'         UNIQUE OR NON-UNIQUE KEYS\nVVRAMFLT EQU   B'01000000'         CYLINDER FAULT MSS OR STAGE\nVVRAMBND EQU   B'00100000'         BIND OR DO NOT BIND ON MSS\nVVRAMWAT EQU   B'00010000'         WAIT OR DO NOT WAIT ON RELINQUISH\nVVRAMLM  EQU   B'00001000'         LOAD MODE OR DATASET LOADED.\nVVRAMSNO DS    XL1                 NUMBER OF CONCURRENT REQUESTS\n         DS    XL4\nVVRAMBFI DS    0XL2                NUMBER OF INDEX BUFFERS\nVVRAMBFD DS    XL2                 NUMBER OF DATA BUFFERS\nVVRAMSTS DS    XL8                 SYSTEM TIMESTAMP\nVVRAMNIL DS    XL2                 NUMBER OF INDEX LEVELS\nVVRAMNXT DS    XL2                 NUMBER OF EXTENTS\nVVRAMNLR DS    XL4                 NUMBER OF LOGICAL RECORDS\nVVRAMDLR DS    XL4                 NUMBER OF DELETED RECORDS\nVVRAMINR DS    XL4                 NUMBER OF INSERTED RECORDS\nVVRAMUPR DS    XL4                 NUMBER OF UPDATED RECORDS\nVVRAMRTR DS    XL4                 NUMBER OF RETRIEVED RECORDS\nVVRAMASP DS    XL4                 BYTES OF FREE SPACE IN DATASET\nVVRAMCIS DS    XL4                 NUMBER OF CI SPLITS\nVVRAMCAS DS    XL4                 NUMBER OF CA SPLITS\nVVRAMEXC DS    XL4                 NUMBER OF EXCPS\n         TITLE 'HSM - MCD DSECT.'\nMCDDSCT  DSECT\n         COPY  HSMMCK\n         COPY  HSMMCA\n         COPY  HSMMCD\n         TITLE 'DSECTS FOR SYSTEM DATA AREAS.'\n         CVT   DSECT=YES\nUCB      DSECT ,\n         IEFUCBOB  ,\n         UCBTYPES  LIST=YES\n         IEFZB4D0  ,\n         IEFZB4D2  ,\n         IEZJSCB ,\n         IKJTCB  DSECT=YES\n         IFGRPL  ,                                                 @122\n         ASASYMBP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNSPACE": {"ttr": 2821, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    DYNSPACE &TYPE\n.*\n.*    THIS IS AN INNER MACRO TO ALLOC/FREE.\n.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST\n.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY\n.*                         EACH, REMEMBERING THE LARGEST.\n.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.\n.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,\n.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,\n.*    OR BY BEGINWKA, IF THE LATTER IS USED.\n.*\n.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE\n.*     NAME DYNSPACE\n.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE\n.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL\n.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.\n.*\n.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL\n.*          DYNSPACE ADD\n.*     (NO NAME FIELD AND ONE OPERAND)\n.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE\n.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE\n.*     CURRENT REQUEST IS FOR A GREATER AMOUNT\n.*\n.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO\n.*     NAME OR OPERAND FIELD.\n.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME\n.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.\n.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.\n.*\n         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN\n         GBLC  &DYNP,&DYNSP\n         LCLA  &I\n         AIF   ('&NAME' NE '').NAME\n         AIF   ('&TYPE' EQ '').ALLOC\n.*   THE ACCUMULATE FUNCTION IS REQUIRED\n&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST\n         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT\n&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM\n         MEXIT\n.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT\n&DYNSP   SETC  'DYNSP&RCPDYN'           ELSE GENERATE A NAME\n.EXIT    MEXIT\n.ALLOC   AIF   ('&DYNSP' EQ '').EXIT\n*\n**     RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA\n*\n&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE\n&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0\n&DYNSPQ  SETA 0\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDVVDS": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x00\\x95)\\x8f\\x01\\x02\\x07O\\x083\\x00M\\x00M\\x00\\x01\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "2002-03-15T08:33:09", "lines": 77, "newlines": 77, "modlines": 1, "user": "MSTITT"}, "text": "         TITLE ' - FINDVVDS. ADVANCE R6 TO A SPECIFIED VVDS CELL.'\n* I ENTER HERE WITH R6 POINTING TO A CELL I HAVE JUST PROCESSED. THIS\n* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES\n* FOR A PARTICULAR CELL TYPE.\n* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF VVD0 CONTAINS X'FF' IF THE\n* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR\n* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED\n* BUT MAY NOT BE THE NEXT ONE.\n* THE RIGHT-MOST BYTE OF VVD0 CONTAINS THE ID OF THE CELL TYPE THE\n* CALLER WANTS.\n* IF VVD0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.\n* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.\nFINDVVDS $PROLOG R12\n         L     R4,=V(DATASECT)                                     @130\n         USING DATASECT,R4                                         @130\n         L     R0,VVD0             PICK UP CALLERS PARM            @134\n         ST    R6,VVD6             SAVE CELL ADDRESS\nFINDVVD1 SR    R1,R1               CLEAR REGISTER\n         SR    R15,R15             CLEAR PREVIOUS RETCODE.         @122\n         ICM   R1,3,0(R6)          PICK UP LENGTH OF CURRENT CELL.\n         LTR   R1,R1               IS THERE A LENGTH?              @132\n         BNP   FINDVVDX            NO. HOW ODD!                    @132\n         AR    R6,R1               SKIP OVER LENGTH\n         C     R6,ENDVVD           ANY MORE CELLS IN THIS RECORD?\n         BL    FINDVVD2            YES.\n         ICM   R8,15,VVDSRPL       PICK UP RPL ADDRESS\n         ST    R0,VVD0             SAVE CALLERS PARM\n         GET   RPL=(8)\n         LTR   R15,R15             GET OK?                         @122\n         BZ    FINDVVD3            YUP.                            @122\n         C     R15,=F'8'           LOGICAL ERROR?                  @122\n         BE    FINDVVD4            YES.                            @122\n         ABEND 16,DUMP             OTHERWISE CRASH AND BURN.       @122\nFINDVVD4 DS    0H                                                  @122\n         SR    R2,R2                                               @122\n         ICM   R2,1,RPLERRCD-IFGRPL(R1) GET REASON CODE.           @122\n         CVD   R2,DTWORK           PACK IT.                        @122\n         $EDITP FDBK,DWK3,ZZZ9     FORMAT NICELY.                  @122\n        $MESSAGE 2,DATA=FDBK       SAY LOGICAL ERROR.              @122\n         B     FINDVVDX            GO BACK WITH RC IN R15          @122\nFINDVVD3 DS    0H                                                  @122\n         AP    VVDSGETS,ONE        COUNT IT.\n         L     R0,VVD0             RESTORE CALLERS PARM\n         L     R6,VVDSBUF          ADDRESS OF RECORD JUST READ.\n         L     R1,VVDSRPL          ADDR OF RPL\n         L     R1,48(0,R1)         LENGTH OF RECORD JUST READ.\n         AR    R1,R6               END OF RECORD.\n         ST    R1,ENDVVD           SAVE FOR NEXT TIME.\n         CLC   0(2,R6),=H'0'       ANYTHING IN THIS RECORD?        @132\n         BNE   FINDVVD5            YES. LET'S DO IT.               @132\n         SR    R0,R0               OOPS!                           @132\n         B     FINDVVD9            GOBACK.                         @132\nFINDVVD5 LA    R6,2(0,R6)          SKIP OVER PREFIX.\nFINDVVD2 LTR   R0,R0               IF ZERO, ANYTHING WILL DO.\n         BZ    FINDVVD9\n         CLM   R0,1,2(R6)          CHECK FOR REQUESTED CELL TYPE\n         BE    FINDVVD9            YES.\n         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?\n         BNE   FINDVVD1            NO, THEN KEEP LOOKING.\n         L     R6,VVD6             RESTORE INITIAL CELL ADDRESS\n         LA    R15,8               GIVE HIM THE SAD NEWS.          @134\nFINDVVD9 DS    0H\n         LR    R1,R13              GET SAVEAREA ADDRESS            @134\n         L     R13,4(R13)          GET BACK CHAIN POINTER          @134\n         L     R0,16(R13)          GET SAVEAREA LENGTH             @134\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)      @134\n         ST    R6,44(R13)          SAVE REGISTER 15 (RETCODE)      @134\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA                   @134\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS            @134\n         L     R15,16(R13)         RESTORE RETURN CODE             @134\n         BR    R14                 RETURN TO CALLER                @134\nVVD9     DC    F'0'                SAVE R9 IN HERE.\nVVD6     DC    F'0'                SAVE R6 IN HERE.\nFINDVVDX LA    R15,8                                               @122\n         B     FINDVVD9                                            @122\n*        DROP  R5\n         LTORG ,                                                   @134\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "G207ASM": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00\\x06\\x8f\\x01\\x01 \\x0f\\x103\\x00\\x1f\\x00 \\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-03-08T00:00:00", "modifydate": "2001-07-19T10:33:00", "lines": 31, "newlines": 32, "modlines": 0, "user": "MSTITT"}, "text": "//MSTITT   JOB  (XSYZ,MSTITT),'MATTHEW STITT',REGION=1024K,\n//             MSGCLASS=X,NOTIFY=MSTITT\n//ASM      EXEC PGM=ASMA90,PARM='NODECK,OBJECT'\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.AMACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//         DD   DSN=SYS1.AMODGEN,DISP=SHR\n//         DD   DSN=SYS1.AGENLIB,DISP=SHR\n//SYSUT1   DD   DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1700,(600,100)),\n//             SEP=(SYSLIB)\n//SYSUT2   DD   DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(1700,(300,50)),\n//             SEP=(SYSLIB,SYSUT1)\n//SYSUT3   DD   DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(1700,(300,50))\n//SYSPRINT DD   SYSOUT=*\n//SYSPUNCH DD   DUMMY\n//SYSLIN   DD   DSN=&&OBJSET,UNIT=SYSDA,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN DD DSN=MSTITT.CBT000.FILE000.PDS(G207DCAN),DISP=SHR\n//LKED     EXEC PGM=IEWL,PARM=(LIST,MAP,LET,XREF),\n//             COND=(8,LT,ASM)\n//SYSLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN   DD   DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSUT1   DD   DSN=&&SYSUT1,UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),\n//             SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=*\n//SYSTERM  DD   SYSOUT=*\n//SYSLMOD DD  DSNAME=MSTITT.SRCE.LOAD,DISP=SHR\n//SYSIN  DD  *\n   NAME G207DCAN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "G207DCAN": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01*\\x00\\x16\\x00\\x95&O\\x01\\x04\\t/\\x13\\t\\x03-\\x02S\\x00\\x00\\xd4\\xc1\\xe3\\xe3@@@@@@'", "ispf": {"version": "01.42", "flags": 0, "createdate": "1995-09-21T00:00:00", "modifydate": "2004-04-01T13:09:16", "lines": 813, "newlines": 595, "modlines": 0, "user": "MATT"}, "text": "***********************************************************************\n*        G207DCAN -- DATE CONVERSION SUBPROGRAM                       *\n*        STANDARD PARAMETER FORMAT                                    *\n* (COBOL) CALL 'G207DCAN' USING FUNC-CODE, INPUT-DATE, OUTPUT-DATE    *\n*                                                                     *\n* FUNCTION CODES AVAILABLE FOR DATE CONVERSIONS                       *\n*                                                                     *\n*  01 - RETRIEVE CURRENT DATE IN CALENDAR FORMAT     - MM/DD/YY       *\n*  02 - RETRIEVE CURRENT DATE IN COMPRESSED FORMAT   - MMDDYY         *\n*  03 - RETRIEVE CURRENT DATE IN JULIAN FORMAT       - YYDDD          *\n*  04 - RETRIEVE CURRENT DATE IN ALPHANUMERIC FORMAT - MAY 31, 1947   *\n*  05 - CONVERT DATE FORMAT FROM CALENDAR TO COMPRESSED               *\n*  06 - CONVERT DATE FORMAT FROM CALENDAR TO JULIAN                   *\n*  07 - CONVERT DATE FORMAT FROM CALENDAR TO ALPHANUMERIC             *\n*  08 - CONVERT DATE FORMAT FROM COMPRESSED TO CALENDAR               *\n*  09 - CONVERT DATE FORMAT FROM COMPRESSED TO JULIAN                 *\n*  10 - CONVERT DATE FORMAT FROM JULIAN TO CALENDAR                   *\n*  11 - CONVERT DATE FROM JULIAN TO COMPRESSED                        *\n*  12 - CONVERT DATE FROM JULIAN TO ALPHANUMERIC                      *\n*  13 - CONVERT DATE FROM JULIAN TO DAY OF WEEK                       *\n*  14 - RETRIEVE DATE IN CENTURY CALENDAR            - MM/DD/YYYY     *\n*  15 - RETRIEVE DATE IN CENTURY JULIAN              - YYYYDDD        *\n*  16 - CONVERT CENTURY DATE FROM JULIAN TO CALENDAR                  *\n*  17 - CONVERT CENTURY DATE FROM CALENDAR TO JULIAN                  *\n*  18 - CONVERT CENTURY DATE FROM JULIAN TO ALPHANUMERIC              *\n*  19 - CONVERT CENTURY DATE FROM CALENDAR TO ALPHANUMERIC            *\n*  20 - CONVERT CENTURY DATE FROM JULIAN TO DAY OF WEEK               *\n*  21 - CONVERT DATE FROM CALENDAR TO CENTURY CALENDAR                *\n*  22 - CONVERT DATE FROM JULIAN TO CENTURY JULIAN                    *\n*  23 - CONVERT DATE FROM CALENDAR TO CENTURY JULIAN                  *\n*  24 - CONVERT DATE FROM COMPRESSED TO CENTURY JULIAN                *\n*  25 - CONVERT DATE FROM CENTURY JULIAN TO JULIAN                    *\n*  26 - CONVERT DATE FROM CENTURY JULIAN TO CALENDAR                  *\n*  27 - CONVERT DATE FROM CENTURY JULIAN TO COMPRESSED                *\n*  28 - CONVERT CALENDAR TO DAY OF WEEK                               *\n*  29 - CONVERT COMPRESSED TO DAY OF WEEK                             *\n*  30 - CONVERT CENTURY CALENDAR TO DAY OF WEEK                       *\n*  31 - CONVERT CENTURY CALENDAR TO CALENDAR                          *\n*  32 - CONVERT CENTURY CALENDAR TO COMPRESSED                        *\n*  33 - CONVERT CENTURY CALENDAR TO JULIAN                            *\n*  34 - CONVERT DATE FROM JULIAN TO CENTURY CALENDAR                  *\n*  35 - CONVERT DATE FROM TOD CLOCK TO CENTURY CALENDAR               *\n*  36 - CONVERT DATE FROM TOD CLOCK TO CENTURY JULIAN                 *\n*  37 - CONVERT DATE FROM TOD CLOCK TO ALPHANUMERIC                   *\n*  38 - CONVERT DATE FROM TOD CLOCK TO DAY OF WEEK                    *\n*                                                                     *\n*        FIELD FORMATS                                                *\n*  FUNCTION   INPUT PARAMETER        LENGTH  OUTPUT PARAMETER LENGTH  *\n*  01         MM/DD/YY     (OUTPUT)    08    NOT USED                 *\n*  02         MMDDYY       (OUTPUT)    06    NOT USED                 *\n*  03         YYDDD        (OUTPUT)    05    NOT USED                 *\n*  04         MAY 16, 1962 (OUTPUT)    19    NOT USED                 *\n*  05         MM/DD/YY                 08    MMDDYY             06    *\n*  06         MM/DD/YY                 08    YYDDD              05    *\n*  07         MM/DD/YY                 19    MAY 16, 1962       19    *\n*  08         MMDDYY                   06    MM/DD/YY           08    *\n*  09         MMDDYY                   06    YYDDD              05    *\n*  10         YYDDD                    05    MM/DD/YY           08    *\n*  11         YYDDD                    05    MMDDYY             06    *\n*  12         YYDDD                    05    MAY 16, 1962       19    *\n*  13         YYDDD                    05    4WEDNESDAY         10    *\n*  14         MM/DD/YYYY   (OUTPUT)    10    NOT USED                 *\n*  15         YYYYDDD      (OUTPUT)    07    NOT USED                 *\n*  16         YYYYDDD                  07    MM/DD/YYYY         10    *\n*  17         MM/DD/YYYY               10    YYYYDDD            07    *\n*  18         YYYYDDD                  07    MAY 16, 1962       19    *\n*  19         MM/DD/YYYY               10    MAY 16, 1962       19    *\n*  20         YYYYDDD                  07    4WEDNESDAY         10    *\n*  21         MM/DD/YY                 08    MM/DD/YYYY         10    *\n*  22         YYDDD                    05    YYYYDDD            07    *\n*  23         MM/DD/YY                 08    YYYYDDD            07    *\n*  24         MMDDYY                   06    YYYYDDD            07    *\n*  25         YYYYDDD                  07    YYDDD              05    *\n*  26         YYYYDDD                  07    MM/DD/YY           08    *\n*  27         YYYYDDD                  07    MMDDYY             06    *\n*  28         MM/DD/YY                 08    4WEDNESDAY         10    *\n*  29         MMDDYY                   06    4WEDNESDAY         10    *\n*  30         MM/DD/YYYY               10    4WEDNESDAY         10    *\n*  31         MM/DD/YYYY               10    MM/DD/YY           08    *\n*  32         MM/DD/YYYY               10    MMDDYY             06    *\n*  33         MM/DD/YYYY               10    YYDDD              05    *\n*  34         YYDDD                    05    MM/DD/YYYY         10    *\n*  35         XXXXXXXX                 08    MM/DD/YYYY         10    *\n*  36         XXXXXXXX                 08    YYYYDDD            07    *\n*  37         XXXXXXXX                 10    MAY 16, 1962       19    *\n*  38         XXXXXXXX                 07    4WEDNESDAY         10    *\n*                                                                     *\n*  IF THE FIRST PARAMETER IS PASSED AS A PACKED DECIMAL 7 DIGIT FIELD *\n*  RATHER THAN A TWO CHARACTER FUNCTION CODE THE CALCULATION ROUTINES *\n*  WILL BE ENTERED AND SUMS AND DIFFERENCES OF JULIAN DATES ARE       *\n*  CALCULATED.  IF PARAMETER 1 IS ZERO PARAMETER 2 WILL BE SUBTRACTED *\n*  FROM PARAMETER 3 AND THE RESULT WILL BE PLACED IN PARAMETER 1 AS A *\n*  SIGNED NUMBER OF DAYS DIFFERENCE.  IF PARAMETER 1 IS NOT ZERO THEN *\n*  IT WILL BE ADDED TO PARAMETER 2 AND THE RESULT PLACED IN PARAMETER *\n*  3 AS A JULIAN DATE. PARAMETER 2 AND PARAMETER 3 ARE ASSUMED TO BE  *\n*  7 CHARACTERS IN LENGTH SUITABLE FOR JULIAN DATES IN CENTURY FORMAT *\n*                                                                     *\n*  DATE FORMATS:                                                      *\n*  1.  MM/DD/YY            CALENDAR                                   *\n*  2.  MMDDYY              COMPRESSED                                 *\n*  3.  YYDDD               JULIAN                                     *\n*  4.  MONTH DAY, YEAR     ALPHANUMERIC                               *\n*  5.  DAY OF WEEK         1WEEKDAY                                   *\n*  6.  MM/DD/YYYY          EXTENDED CALENDAR                          *\n*  7.  YYYYDDD             EXTENDED JULIAN                            *\n*  8.  XXXXXXXX            TOD CLOCK FORMAT                           *\n*                                                                     *\n***********************************************************************\nG207DCAN AMODE 31\nG207DCAN RMODE ANY\nG207DCAN CSECT\nSTRTHRE  STM  14,12,12(13)\n         USING STRTHRE,15\n         LA    9,SJULIAN\n         ST    13,4(9)\n         ST    9,8(13)\n         BAL   13,PGMBEGIN\nSJULIAN  DS    18F\n         DC    CL8'G207DCAN'\nPGMBEGIN L     3,0(1)\n         TM    0(3),X'F0'\n         BNO   CALCRTN\n         CLC   0(2,3),=C'01'\n         BL    NOFUN\n         CLC   0(2,3),=C'38'\n         BH    NOFUN\n         L     4,4(1)\n         L     5,8(1)\n         MVC   DATEIN,0(4)\n         MVC   DATEOUT,DATEIN\n         PACK  DBLWRD,0(2,3)\n         CVB   6,DBLWRD\n         SLA   6,2\nBRNCHTAB B     *(6)\nF01      B     CV70\nF02      B     CV70\nF03      B     CV70\nF04      B     CV70\nF05      B     CV12\nF06      B     CV16\nF07      B     CV16\nF08      B     CV21\nF09      B     CV21\nF10      B     CV37\nF11      B     CV37\nF12      B     CV37\nF13      B     CV37\nF14      B     CV70\nF15      B     CV70\nF16      B     CV76\nF17      B     CV67\nF18      B     CV76\nF19      B     CV64\nF20      B     CV75\nF21      B     CV16\nF22      B     CV37\nF23      B     CV16\nF24      B     CV21\nF25      B     CV73\nF26      B     CV76\nF27      B     CV76\nF28      B     CV16\nF29      B     CV21\nF30      B     CV67\nF31      B     CV61\nF32      B     CV61\nF33      B     CV67\nF34      B     CV37\nF35      B     CV80\nF36      B     CV80\nF37      B     CV80\nF38      B     CV80\nNOFUN    DC    H'0'\n**************************************************************\n*                                                            *\n*  RETRIEVE CURRENT DATE IN CENTURY JULIAN FORMAT            *\n*  USING CURRENT CPU TOD CLOCK SETTING AS STARTING POINT     *\n*                                                            *\n*  FUNCTIONS: 01 02 03 04 14 15                              *\n*                                                            *\n**************************************************************\nCV70     EQU   *\n         LR    8,15\n         STCK  TODCLCK\n         LR    15,8\n         MVC   TSVTS,TODCLCK\n         L     8,16\n         L     8,X'130'(,8)\n         AL    8,TSVTS\n         ST    8,TSVTS\n         B     CV70A\n**************************************************************\n*                                                            *\n*  CONVERT CPU TOD CLOCK SETTING TO CENTURY JULIAN FORMAT    *\n*                                                            *\n*  FUNCTIONS: 35 36 37 38                                    *\n*                                                            *\n**************************************************************\nCV80     EQU   *\n         MVC   TSVTS,DATEIN\nCV70A    EQU   *\n         ZAP   TSJULIAN,=P'1900'\n         CLC   TSVTS,X4YEAR\n         BL    CK1YEAR\n         LA    7,X4YEAR\n         BAL   8,SUBTRACT\n         AP    TSJULIAN,=P'4'\nCK4MORE  CLC   TSVTS,X4YEARS           ..4 MORE YEARS?\n         BL    CKLEAPSW                ....NO,  GO CHECK FOR LEAP YEAR\n         AP    TSJULIAN,=P'4'\n         LA    7,X4YEARS\n         BAL   8,SUBTRACT              SUBTRACT\n         B     CK4MORE\nCKLEAPSW CLC   TSVTS,X366DAYS          DATE OTHER THAN LEAP YEAR?\n         BL    CALCDAYS\n         AP    TSJULIAN,=P'1'          ..YES, ADD LEAP YEAR\n         LA    7,X366DAYS\n         BAL   8,SUBTRACT              SUBTRACT\nCK1YEAR  CLC   TSVTS,X365DAYS         ANY MORE NON-LEAP YEARS LEFT?\n         BL    CALCDAYS\n         AP    TSJULIAN,=P'1'         ..YES, ADD NORMAL YEAR\n         LA    7,X365DAYS\n         BAL   8,SUBTRACT              SUBTRACT\n         B     CK1YEAR\nCALCDAYS SRP   TSJULIAN,3,0            CHANGE 0YYYY TO YYYYJJJ\n         AP    TSJULIAN,=P'1'          SET TO FIRST DAY IN YEAR\nCK1DAY   CLC   TSVTS,X1DAY             ONE MORE DAY REMAINING?\n         BL    ENDDATE                 ..NO, GOT THE DATE\n         AP    TSJULIAN,=P'1'\n         LA    7,X1DAY\n         BAL   8,SUBTRACT              SUBTRACT\n         B     CK1DAY\nENDDATE  UNPK  JDATE(7),TSJULIAN\n         OI    JDATE+L'JDATE-1,X'F0'\n         MVC   DATEOUT(7),JDATE\n         MVC   DATEIN(7),DATEOUT\n         CLC   0(2,3),=C'03'\n         BL    CV76\n         BE    CV73\n         CLC   0(2,3),=C'04'\n         BE    CV76\n         CLC   0(2,3),=C'14'\n         BE    CV76\n         CLC   0(2,3),=C'35'\n         BE    CV76\n         CLC   0(2,3),=C'37'\n         BE    CV76\n         CLC   0(2,3),=C'38'\n         BE    CV75\n         LA    11,6\n         B     OUT\nSUBTRACT L     9,TSVTS+4\n         SL    9,4(7)                  SET CONDITION CODE\n         ST    9,TSVTS+4\n         L     9,TSVTS\n         BNM   NOBORROW                BRANCH ON NO BORROW\n         BCTR  9,0                     SUBTRACT BORROWED BIT\nNOBORROW SL    9,0(7)\n         ST    9,TSVTS\n         BR    8\n**************************************************************\n*                                                            *\n*  CONVERT DATE FROM CALENDAR TO CENTURY CALENDAR            *\n*                                                            *\n*  FUNCTIONS: 06 07 21 23 28                                 *\n*             09 24 29                                       *\n*                                                            *\n**************************************************************\nCV16     EQU   *\n         MVC   DATEOUT(6),DATEIN\n         MVC   DATEOUT+8(2),DATEIN+6\n         CLI   DATEIN+6,C'5'\n         BL    CV16A\n         MVC   DATEOUT+6(2),=C'19'\n         B     CV16B\nCV16A    MVC   DATEOUT+6(2),=C'20'\nCV16B    MVC   DATEIN(10),DATEOUT\n         CLC   0(2,3),=C'06'\n         BE    CV67\n         CLC   0(2,3),=C'07'\n         BE    CV64\n         CLC   0(2,3),=C'09'\n         BE    CV67\n         CLC   0(2,3),=C'23'\n         BE    CV67\n         CLC   0(2,3),=C'24'\n         BE    CV67\n         CLC   0(2,3),=C'28'\n         BE    CV67\n         CLC   0(2,3),=C'29'\n         BE    CV67\n         LA    11,9\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT DATE FROM JULIAN TO CENTURY JULIAN                *\n*                                                            *\n*  FUNCTIONS: 10 11 12 13 22 34                              *\n*                                                            *\n**************************************************************\nCV37     EQU   *\n         MVC   DATEOUT+2(5),DATEIN\n         CLI   DATEIN,C'5'\n         BL    CV37A\n         MVC   DATEOUT(2),=C'19'\n         B     CV37B\nCV37A    MVC   DATEOUT(2),=C'20'\nCV37B    MVC   DATEIN(7),DATEOUT\n         CLC   0(2,3),=C'34'\n         BE    CV76\n         CLC   0(2,3),=C'13'\n         BL    CV76\n         BE    CV75\n         LA    11,6\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT DATE FROM CENTURY JULIAN TO JULIAN                *\n*                                                            *\n*  FUNCTIONS: 25                                             *\n*             03 33                                          *\n*             06                                             *\n*             09                                             *\n*                                                            *\n**************************************************************\nCV73     EQU   *\n         MVC   DATEOUT(5),DATEIN+2\n         MVC   DATEIN(5),DATEOUT\n         LA    11,4\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT CENTURY DATE FROM JULIAN TO CALENDAR              *\n*                                                            *\n*  FUNCTIONS: 16 18 26 27                                    *\n*             01 02 04 10 11 12 14 34 35 37                  *\n*                                                            *\n**************************************************************\nCV76     EQU   *\n         MVC   JDATE,DATEIN\n         STM   0,5,ZQSAV\n         PACK  DBLWRD,JDATE+0(4)\n         CVB   5,DBLWRD\n         PACK  DBLWRD,JDATE+4(3)\n         CVB   1,DBLWRD\n         LA    2,ZQTAB\n         LA    3,12\n         NI    ZQFND01+3,0\n         C     5,=F'1900'\n         BE    ZQLOP01\n         C     5,=F'1800'\n         BE    ZQLOP01\n         C     5,=F'1700'\n         BE    ZQLOP01\n         N     5,=F'3'\n         BC    4,ZQLOP01\n         CH    1,=H'60'\n         BL    ZQLOP01\n         BH    *+8\n         OI    ZQFND01+3,1\n         BCT   1,ZQLOP01\nZQLOP01  SLA   3,1\n         CH    1,0(3,2)\n         BH    ZQFND01\n         SRA   3,1\n         BCT   3,ZQLOP01\n         MVI   DBLWRD,X'F0'\n         MVC   DBLWRD+1(7),DBLWRD\n         B     ZQOUT\nZQFND01  LA    1,0(1)\n         SH    1,0(3,2)\n         SRA   3,1\n         MH    3,=H'1000'\n         AR    3,1\n         CVD   3,DBLWRD\n         UNPK  DBLWRD(5),DBLWRD+5(3)\n         OI    DBLWRD+4,X'F0'\n         MVC   DBLWRD+2(2),DBLWRD+3\n         MVC   DBLWRD+4(4),JDATE\nZQOUT    MVC   DATEOUT(2),DBLWRD\n         MVC   DATEOUT+3(2),DBLWRD+2\n         MVC   DATEOUT+6(4),DBLWRD+4\n         MVI   DATEOUT+2,C'/'\n         MVI   DATEOUT+5,C'/'\n         MVC   DATEIN(10),DATEOUT\n         LM    0,5,ZQSAV\n         CLC   0(2,3),=C'04'\n         BL    CV61\n         BE    CV64\n         CLC   0(2,3),=C'12'\n         BL    CV61\n         BE    CV64\n         CLC   0(2,3),=C'18'\n         BE    CV64\n         CLC   0(2,3),=C'26'\n         BE    CV61\n         CLC   0(2,3),=C'27'\n         BE    CV61\n         CLC   0(2,3),=C'37'\n         BE    CV64\n         LA    11,9\n         B     OUT\nZQSAV    DS    6F\n**************************************************************\n*                                                            *\n*  CONVERT CENTURY DATE FROM CALENDAR TO JULIAN              *\n*                                                            *\n*  FUNCTIONS: 17 30 33                                       *\n*             06 23 28                                       *\n*             09 24 29                                       *\n*                                                            *\n**************************************************************\nCV67     EQU   *\n         LA    2,DATEIN\n         PACK  DBLWRD,0(2,2)\n         CVB   6,DBLWRD\n         SLA   6,1\n         LA    6,ZQTAB(6)\n         PACK  DBLWRD,3(2,2)\n         CVB   7,DBLWRD\n         AH    7,0(6)\n         PACK  DBLWRD,6(4,2)\n         CVB   6,DBLWRD\n         C     6,=F'1900'\n         BE    NOLEAP1\n         C     6,=F'1800'\n         BE    NOLEAP1\n         C     6,=F'1700'\n         BE    NOLEAP1\n         N     6,=F'3'\n         BC    4,NOLEAP1\n         CLC   0(2,2),=C'03'\n         BL    NOLEAP1\n         LA    7,1(7)\nNOLEAP1  CVD   7,DBLWRD\n         UNPK  DATEOUT+4(3),DBLWRD+6(2)\n         OI    DATEOUT+6,X'F0'\n         MVC   DATEOUT(4),6(2)\n         MVC   DATEIN(7),DATEOUT\n         CLC   0(2,3),=C'06'\n         BE    CV73\n         CLC   0(2,3),=C'09'\n         BE    CV73\n         CLC   0(2,3),=C'28'\n         BE    CV75\n         CLC   0(2,3),=C'29'\n         BE    CV75\n         CLC   0(2,3),=C'30'\n         BE    CV75\n         CLC   0(2,3),=C'33'\n         BE    CV73\n         LA    11,6\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT CENTURY CALENDAR TO CALENDAR                      *\n*                                                            *\n*  FUNCTIONS: 31 32                                          *\n*             01 02 26 27                                    *\n*             04 10 11                                       *\n*                                                            *\n**************************************************************\nCV61     EQU   *\n         MVC   DATEOUT+6(2),DATEOUT+8\n         MVC   DATEIN(8),DATEOUT\n         CLC   0(2,3),=C'02'\n         BE    CV12\n         CLC   0(2,3),=C'32'\n         BE    CV12\n         CLC   0(2,3),=C'11'\n         BE    CV12\n         CLC   0(2,3),=C'27'\n         BE    CV12\n         LA    11,7\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT CALENDAR TO COMPRESSED CALENDAR                   *\n*                                                            *\n*  FUNCTIONS: 05                                             *\n*             02 32                                          *\n*             27                                             *\n*             11                                             *\n*                                                            *\n**************************************************************\nCV12     EQU   *\n         MVC   DATEOUT(2),DATEIN\n         MVC   DATEOUT+2(2),DATEIN+3\n         MVC   DATEOUT+4(2),DATEIN+6\n         LA    11,5\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT CENTURY DATE FROM CALENDAR TO ALPHANUMERIC        *\n*                                                            *\n*  FUNCTIONS: 19                                             *\n*             07 18                                          *\n*             04 12 37                                       *\n*                                                            *\n**************************************************************\nCV64     EQU   *\n         LA    6,DATEOUT\n         LA    7,MOTABLE\n         MVI   0(6),X'40'\n         MVC   1(18,6),0(6)\nTEST     CLC   0(2,7),DATEIN\n         BE    MVNAM\n         LA    7,11(0,7)\n         B     TEST\nMVNAM    MVC   0(9,6),2(7)\nTESTA    LA    6,1(0,6)\n         CLI   0(6),X'40'\n         BNE   TESTA\n         MVC   1(2,6),DATEIN+3\n         MVI   3(6),C','\n         CLI   DATEIN+8,X'40'\n         BH    CV64C\n         CLI   DATEIN+6,C'5'\n         BL    CV64A\n         MVC   4(2,6),=C'19'\n         B     CV64B\nCV64A    MVC   4(2,6),=C'20'\nCV64B    MVC   6(2,6),DATEIN+6\n         B     CV64D\nCV64C    MVC   4(4,6),DATEIN+6\nCV64D    LA    11,18\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT COMPRESSED CALENDAR TO CALENDAR                   *\n*                                                            *\n*  FUNCTIONS: 08 09 24 29                                    *\n*                                                            *\n**************************************************************\nCV21     EQU   *\n         MVC   DATEOUT(8),=C'  /  /  '\n         MVC   DATEOUT(2),DATEIN\n         MVC   DATEOUT+3(2),DATEIN+2\n         MVC   DATEOUT+6(2),DATEIN+4\n         MVC   DATEIN,DATEOUT\n         CLC   0(2,3),=C'09'\n         BE    CV16\n         CLC   0(2,3),=C'24'\n         BE    CV16\n         CLC   0(2,3),=C'29'\n         BE    CV16\n         LA    11,7\n         B     OUT\n**************************************************************\n*                                                            *\n*  CONVERT CENTURY DATE FROM JULIAN TO DAY OF WEEK           *\n*                                                            *\n*  FUNCTIONS: 20                                             *\n*             13 30 38                                       *\n*             28                                             *\n*             29                                             *\n*                                                            *\n**************************************************************\nCV75     EQU   *\n         ZAP   RESULT,ZEROS\n         LA    10,BASEDATE\n         LA    11,DATEIN\n         LA    12,RESULT\n         OI    RETURN+1,X'F0'\n         STM   14,12,12(13)\n         BAL   7,ENT2\n         NI    SW,0\n         LM    14,12,12(13)\n         NI    RETURN+1,X'0F'\n         DP    RESULT,SEVEN\n         ZAP   DBLWRD,RESULT+3(1)\n         CVB   2,DBLWRD\n         C     2,=F'0'\n         BNL   *+8\n         LA    2,7(2)\n         MH    2,=H'10'\n         LA    2,DAYTABLE(2)\n         MVC   DATEOUT(10),0(2)\n         LA    11,9\n         B     OUT\nOUT      EQU   *\n         CLC   0(2,3),=C'05'\n         BL    MOVEEX\n         CLC   0(2,3),=C'14'\n         BE    MOVEEX\n         CLC   0(2,3),=C'15'\n         BE    MOVEEX\n         OI    MOVEDAT+2,X'10'\nMOVEEX   EX    11,MOVEDAT\n         NI    MOVEDAT+2,X'EF'\n         L     13,4(13)\n         LM    14,12,12(13)\n         SR    15,15\n         BR    14\nMOVEDAT  MVC   0(0,4),DATEOUT\n*********************************************************************\n*                                                                   *\n*     TABLES, STORAGE, AND CONSTANTS                                *\n*                                                                   *\n*********************************************************************\nMOTABLE  DC    C'01JANUARY  '\n         DC    C'02FEBRUARY '\n         DC    C'03MARCH    '\n         DC    C'04APRIL    '\n         DC    C'05MAY      '\n         DC    C'06JUNE     '\n         DC    C'07JULY     '\n         DC    C'08AUGUST   '\n         DC    C'09SEPTEMBER'\n         DC    C'10OCTOBER  '\n         DC    C'11NOVEMBER '\n         DC    C'12DECEMBER '\nDAYTABLE DC    C'1SUNDAY   '\n         DC    C'2MONDAY   '\n         DC    C'3TUESDAY  '\n         DC    C'4WEDNESDAY'\n         DC    C'5THURSDAY '\n         DC    C'6FRIDAY   '\n         DC    C'7SATURDAY '\nZQTAB    DC    F'0'\n         DC    H'31'\n         DC    H'59'\n         DC    H'90'\n         DC    H'120'\n         DC    H'151'\n         DC    H'181'\n         DC    H'212'\n         DC    H'243'\n         DC    H'273'\n         DC    H'304'\nZQE      DC    H'334'\nTODCLCK  DS    D\nTSVTS    DS    D\nDBLWRD   DC    D'0'\nX4YEARS  DC    X'072CE4E26E000000' 1,461 DAYS, NO. OF DAYS INC LEAP YR\nX4YEAR   DC    X'072BA304F8000000' 1,460 DAYS, NO. OF DAYS\nX366DAYS DC    X'01CC2A9EB4000000' LEAP YEAR\nX365DAYS DC    X'01CAE8C13E000000' NORMAL YEAR\nX1DAY    DC    X'000141DD76000000' ONE DAY\nX1HOUR   DC    X'00000D693A400000' ONE HOUR\nX1MINUTE DC    X'0000003938700000' ONE MINUTE\nX1SECOND DC    X'00000000F4240000' ONE SECOND\nX1MILSEC DC    X'00000000003E8000' ONE MILLISECOND\nX1MICSEC DC    X'0000000000001000' ONE MICROSECOND\nZEROS    DC    PL4'0'\nTSJULIAN DS    PL4\nRESULT   DC    PL4'0'\nTSLEAP   DS    CL1\nSEVEN    DC    PL1'7'\nBASEDATE DC    CL7'1900063'\nJDATE    DS    CL7\nDATEIN   DS    CL10\nDATEOUT  DS    CL19\nSW       DC    X'0'\nCALC1    DS    F\nCALC2    DS    CL7'0'\nCALC3    DS    CL7'0'\n         DS    0D\n**************************************************************\n*                                                            *\n*  DATE CALCULATION ROUTINES.  IF THE FIRST ARGUMENT IS ZERO *\n*  THE DIFFERENCE BETWEEN TWO DATES WILL BE CACLULATED.  IF  *\n*  THE FIRST ARGUMENT IS NOT ZERO THEN IT WILL BE ADDED WITH *\n*  THE SECOND ARGUMENT AND THE RESULT PLACED INTO THE THIRD  *\n*  ARGUMENT.                                                 *\n*                                                            *\n**************************************************************\nCALCRTN  L     10,4(1)\n         L     11,8(1)\n         L     12,0(1)\nENT2     MVC   CALC1,0(12)\n         MVC   CALC2,0(10)\n         MVC   CALC3,0(11)\n         TM    2(12),X'0C'\n         BNO   CV3CB\n         MVC   CALC1,ZEROS\n         MVI   CALC2,X'F0'\n         MVC   CALC2+1(6),CALC2\n         MVC   CALC3,CALC2\n         MVC   CALC1+1(3),0(12)\n         MVC   CALC2+2(5),0(10)\n         MVC   CALC3+2(5),0(11)\n         CLI   CALC2+2,C'5'\n         BL    CV2CA\n         MVC   CALC2(2),=C'19'\n         B     CV2CB\nCV2CA    MVC   CALC2(2),=C'20'\nCV2CB    CLI   CALC3+2,C'5'\n         BL    CV3CA\n         MVC   CALC3(2),=C'19'\n         B     CV3CB\nCV3CA    MVC   CALC3(2),=C'20'\nCV3CB    CP    CALC1,ZEROS\n         BNE   FINDDATE\n         CLC   CALC2,CALC3\n         BE    RETURN\n         XR    8,8\n         XR    9,9\n         PACK  DBLWRD,CALC2(4)\n         CVB   2,DBLWRD\n         PACK  DBLWRD,CALC3(4)\n         CVB   3,DBLWRD\nCOMPYR   CR    2,3\n         BE    SAMEYR\n         BL    CKLEAP\n         OI    SW,1\n         XR    2,3\n         XR    3,2\n         XR    2,3\nCKLEAP   LR    5,2\n         C     2,=F'1900'\n         BE    NOLEAP2\n         C     2,=F'1800'\n         BE    NOLEAP2\n         C     2,=F'1700'\n         BE    NOLEAP2\n         N     5,=F'3'\n         BC    4,NOLEAP2\n         LA    8,1(8)\n         B     LEAP\nNOLEAP2  LA    9,1(9)\nLEAP     LA    2,1(2)\n         B     COMPYR\nSAMEYR   MH    8,=H'366'\n         MH    9,=H'365'\n         AR    9,8\n         PACK  DBLWRD,CALC2+4(3)\n         CVB   2,DBLWRD\n         PACK  DBLWRD,CALC3+4(3)\n         CVB   3,DBLWRD\n         TM    SW,1\n         BNO   NORVRS\n         XR    2,3\n         XR    3,2\n         XR    2,3\nNORVRS   AR    9,3\n         SR    9,2\n         TM    SW,1\n         BNO   NOTNEG\n         LCR   9,9\nNOTNEG   CVD   9,DBLWRD\n         ZAP   CALC1,DBLWRD+4(4)\nRETCALC  TM    2(12),X'0C'\n         BNO   RET2\n         MVC   0(3,12),CALC1+1\n         MVC   0(5,10),CALC2+2\n         MVC   0(5,11),CALC3+2\n         B     RETURN\nRET2     MVC   0(4,12),CALC1\n         MVC   0(7,10),CALC2\n         MVC   0(7,11),CALC3\nRETURN   NOPR  7\n         L     13,4(13)\n         NI    SW,0\n         LM    14,12,12(13)\n         SR    15,15\n         BR    14\nFINDDATE ZAP   DBLWRD,CALC1\n         CVB   2,DBLWRD\n         PACK  DBLWRD,CALC2(4)\n         CVB   3,DBLWRD\n         PACK  DBLWRD,CALC2+4(3)\n         CVB   4,DBLWRD\n         AR    4,2\n         LTR   2,2\n         BZ    SAMDAY\n         BP    POSIT\n         BCT   3,NEGAT\nPOSIT    LCR   3,3\n         B     DIFFYR\nNEGAT    LTR   4,4\n         BC    12,DIFFYR\n         LA    3,1(3)\n         B     END\nDIFFYR   LPR   4,4\nYR       C     4,=F'365'\n         BH    INCR\n         LTR   3,3\n         BM    END\n         OI    SW,1\nINCR     LR    6,3\n         LPR   6,6\n         C     6,=F'1900'\n         BE    DOWNYR\n         C     6,=F'1800'\n         BE    DOWNYR\n         C     6,=F'1700'\n         BE    DOWNYR\n         N     6,=F'3'\n         BZ    LEAP2\nDOWNYR   S     4,=F'365'\n         B     NOTLEAP2\nLEAP2    C     4,=F'366'\n         BE    END\n         S     4,=F'366'\nNOTLEAP2 C     4,=F'0'\n         BE    COUNTYR\n         TM    SW,1\n         BO    END\nCOUNTYR  BCT   3,YR\nEND      LPR   3,3\n         LPR   4,4\n         CVD   3,DBLWRD\n         UNPK  CALC3(5),DBLWRD+5(3)\n         MVC   CALC3(4),CALC3+1\n         CVD   4,DBLWRD\n         UNPK  CALC3+4(3),DBLWRD+6(2)\n         OI    CALC3+3,X'F0'\n         OI    CALC3+6,X'F0'\n         B     RETCALC\nSAMDAY   MVC   CALC3,CALC2\n         B     RETCALC\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "G207DOCS": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01 \\x0f\\x01\\x01 \\x0f\\x10!\\x00l\\x00l\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-07-19T00:00:00", "modifydate": "2001-07-19T10:21:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "MSTITT"}, "text": "***********************************************************************\n*        G207DCAN -- DATE CONVERSION SUBPROGRAM                       *\n*        STANDARD PARAMETER FORMAT                                    *\n* (COBOL) CALL 'G207DCAN' USING FUNC-CODE, INPUT-DATE, OUTPUT-DATE    *\n*                                                                     *\n* FUNCTION CODES AVAILABLE FOR DATE CONVERSIONS                       *\n*                                                                     *\n*  01 - RETRIEVE CURRENT DATE IN CALENDAR FORMAT     - MM/DD/YY       *\n*  02 - RETRIEVE CURRENT DATE IN COMPRESSED FORMAT   - MMDDYY         *\n*  03 - RETRIEVE CURRENT DATE IN JULIAN FORMAT       - YYDDD          *\n*  04 - RETRIEVE CURRENT DATE IN ALPHANUMERIC FORMAT - MAY 31, 1947   *\n*  05 - CONVERT DATE FORMAT FROM CALENDAR TO COMPRESSED               *\n*  06 - CONVERT DATE FORMAT FROM CALENDAR TO JULIAN                   *\n*  07 - CONVERT DATE FORMAT FROM CALENDAR TO ALPHANUMERIC             *\n*  08 - CONVERT DATE FORMAT FROM COMPRESSED TO CALENDAR               *\n*  09 - CONVERT DATE FORMAT FROM COMPRESSED TO JULIAN                 *\n*  10 - CONVERT DATE FORMAT FROM JULIAN TO CALENDAR                   *\n*  11 - CONVERT DATE FROM JULIAN TO COMPRESSED                        *\n*  12 - CONVERT DATE FROM JULIAN TO ALPHANUMERIC                      *\n*  13 - CONVERT DATE FROM JULIAN TO DAY OF WEEK                       *\n*  14 - RETRIEVE DATE IN CENTURY CALENDAR            - MM/DD/YYYY     *\n*  15 - RETRIEVE DATE IN CENTURY JULIAN              - YYYYDDD        *\n*  16 - CONVERT CENTURY DATE FROM JULIAN TO CALENDAR                  *\n*  17 - CONVERT CENTURY DATE FROM CALENDAR TO JULIAN                  *\n*  18 - CONVERT CENTURY DATE FROM JULIAN TO ALPHANUMERIC              *\n*  19 - CONVERT CENTURY DATE FROM CALENDAR TO ALPHANUMERIC            *\n*  20 - CONVERT CENTURY DATE FROM JULIAN TO DAY OF WEEK               *\n*  21 - CONVERT DATE FROM CALENDAR TO CENTURY CALENDAR                *\n*  22 - CONVERT DATE FROM JULIAN TO CENTURY JULIAN                    *\n*  23 - CONVERT DATE FROM CALENDAR TO CENTURY JULIAN                  *\n*  24 - CONVERT DATE FROM COMPRESSED TO CENTURY JULIAN                *\n*  25 - CONVERT DATE FROM CENTURY JULIAN TO JULIAN                    *\n*  26 - CONVERT DATE FROM CENTURY JULIAN TO CALENDAR                  *\n*  27 - CONVERT DATE FROM CENTURY JULIAN TO COMPRESSED                *\n*  28 - CONVERT CALENDAR TO DAY OF WEEK                               *\n*  29 - CONVERT COMPRESSED TO DAY OF WEEK                             *\n*  30 - CONVERT CENTURY CALENDAR TO DAY OF WEEK                       *\n*  31 - CONVERT CENTURY CALENDAR TO CALENDAR                          *\n*  32 - CONVERT CENTURY CALENDAR TO COMPRESSED                        *\n*  33 - CONVERT CENTURY CALENDAR TO JULIAN                            *\n*  34 - CONVERT DATE FROM JULIAN TO CENTURY CALENDAR                  *\n*  35 - CONVERT DATE FROM TOD CLOCK TO CENTURY CALENDAR               *\n*  36 - CONVERT DATE FROM TOD CLOCK TO CENTURY JULIAN                 *\n*  37 - CONVERT DATE FROM TOD CLOCK TO ALPHANUMERIC                   *\n*  38 - CONVERT DATE FROM TOD CLOCK TO DAY OF WEEK                    *\n*                                                                     *\n*        FIELD FORMATS                                                *\n*  FUNCTION   INPUT PARAMETER        LENGTH  OUTPUT PARAMETER LENGTH  *\n*  01         MM/DD/YY     (OUTPUT)    08    NOT USED                 *\n*  02         MMDDYY       (OUTPUT)    06    NOT USED                 *\n*  03         YYDDD        (OUTPUT)    05    NOT USED                 *\n*  04         MAY 16, 1962 (OUTPUT)    19    NOT USED                 *\n*  05         MM/DD/YY                 08    MMDDYY             06    *\n*  06         MM/DD/YY                 08    YYDDD              05    *\n*  07         MM/DD/YY                 19    MAY 16, 1962       19    *\n*  08         MMDDYY                   06    MM/DD/YY           08    *\n*  09         MMDDYY                   06    YYDDD              05    *\n*  10         YYDDD                    05    MM/DD/YY           08    *\n*  11         YYDDD                    05    MMDDYY             06    *\n*  12         YYDDD                    05    MAY 16, 1962       19    *\n*  13         YYDDD                    05    4WEDNESDAY         10    *\n*  14         MM/DD/YYYY   (OUTPUT)    10    NOT USED                 *\n*  15         YYYYDDD      (OUTPUT)    07    NOT USED                 *\n*  16         YYYYDDD                  07    MM/DD/YYYY         10    *\n*  17         MM/DD/YYYY               10    YYYYDDD            07    *\n*  18         YYYYDDD                  07    MAY 16, 1962       19    *\n*  19         MM/DD/YYYY               10    MAY 16, 1962       19    *\n*  20         YYYYDDD                  07    4WEDNESDAY         10    *\n*  21         MM/DD/YY                 08    MM/DD/YYYY         10    *\n*  22         YYDDD                    05    YYYYDDD            07    *\n*  23         MM/DD/YY                 08    YYYYDDD            07    *\n*  24         MMDDYY                   06    YYYYDDD            07    *\n*  25         YYYYDDD                  07    YYDDD              05    *\n*  26         YYYYDDD                  07    MM/DD/YY           08    *\n*  27         YYYYDDD                  07    MMDDYY             06    *\n*  28         MM/DD/YY                 08    4WEDNESDAY         10    *\n*  29         MMDDYY                   06    4WEDNESDAY         10    *\n*  30         MM/DD/YYYY               10    4WEDNESDAY         10    *\n*  31         MM/DD/YYYY               10    MM/DD/YY           08    *\n*  32         MM/DD/YYYY               10    MMDDYY             06    *\n*  33         MM/DD/YYYY               10    YYDDD              05    *\n*  34         YYDDD                    05    MM/DD/YYYY         10    *\n*  35         XXXXXXXX                 08    MM/DD/YYYY         10    *\n*  36         XXXXXXXX                 08    YYYYDDD            07    *\n*  37         XXXXXXXX                 10    MAY 16, 1962       19    *\n*  38         XXXXXXXX                 07    4WEDNESDAY         10    *\n*                                                                     *\n*  IF THE FIRST PARAMETER IS PASSED AS A PACKED DECIMAL 7 DIGIT FIELD *\n*  RATHER THAN A TWO CHARACTER FUNCTION CODE THE CALCULATION ROUTINES *\n*  WILL BE ENTERED AND SUMS AND DIFFERENCES OF JULIAN DATES ARE       *\n*  CALCULATED.  IF PARAMETER 1 IS ZERO PARAMETER 2 WILL BE SUBTRACTED *\n*  FROM PARAMETER 3 AND THE RESULT WILL BE PLACED IN PARAMETER 1 AS A *\n*  SIGNED NUMBER OF DAYS DIFFERENCE.  IF PARAMETER 1 IS NOT ZERO THEN *\n*  IT WILL BE ADDED TO PARAMETER 2 AND THE RESULT PLACED IN PARAMETER *\n*  3 AS A JULIAN DATE. PARAMETER 2 AND PARAMETER 3 ARE ASSUMED TO BE  *\n*  7 CHARACTERS IN LENGTH SUITABLE FOR JULIAN DATES IN CENTURY FORMAT *\n*                                                                     *\n*  DATE FORMATS:                                                      *\n*  1.  MM/DD/YY            CALENDAR                                   *\n*  2.  MMDDYY              COMPRESSED                                 *\n*  3.  YYDDD               JULIAN                                     *\n*  4.  MONTH DAY, YEAR     ALPHANUMERIC                               *\n*  5.  DAY OF WEEK         1WEEKDAY                                   *\n*  6.  MM/DD/YYYY          EXTENDED CALENDAR                          *\n*  7.  YYYYDDD             EXTENDED JULIAN                            *\n*  8.  XXXXXXXX            TOD CLOCK FORMAT                           *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEX": {"ttr": 3332, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NFS     HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=\n         GBLC  &HEXTAB#\n         LCLA  &LT                      UNPK \"TO\" LENGTH\n         LCLA  &LF                      UNPK \"FROM\" LENGTH\n         LCLA  &LTR                     TR \"TO\" LENGTH\n         LCLA  &LL                      &LEN ONE WAY OR ANOTHER\n         LCLC  &F1,&F2,&T1,&T2,&LX\n&F1      SETC  '&FROM(1)'               FOR SHORTER STRING LATER\n&F2      SETC  '&FROM(2)'               FOR SHORTER STRING LATER\n&T1      SETC  '&TO(1)'                 FOR SHORTER STRING LATER\n&T2      SETC  '&TO(2)'                 FOR SHORTER STRING LATER\n&LX      SETC  '&L&LEN'                 GET LENGTH USING EITHER METHOD\n         AIF   ('&LX' EQ '').DEFLEN     LENGTH WILL DEFAULT TO 4\n&LL      SETA  &LX                      GET IT\n         AGO   .OKLEN\n.DEFLEN  ANOP\n&LL      SETA  4                        SET THE DEFAULT LENGTH\n.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1\n&HEXTAB# SETC  '&HEXTAB'\n.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2\n&HEXTAB# SETC  'HEXTAB'\n.OKHEX2  ANOP\n&LT      SETA  &LL*2\n         AIF   ('&DIGITS' EQ '').OKDIGIT\n&LT      SETA  &DIGITS\n.OKDIGIT AIF   (N'&TO NE 2).TO1\n         AIF   (N'&FROM NE 2).T2F1\n&NFS     UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         AGO   .DONE\n.T2F1    AIF   (N'&FROM NE 1).ERRF\n&NFS     UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)\n         TR    &T1.(&LT,&T2),&HEXTAB#\n         MVI   &T1+&LT.(&T2),&BYTE\n         AGO   .DONE\n.TO1     AIF   (N'&TO NE 1).ERRT\n         AIF   (N'&FROM NE 2).T1F1\n&NFS     UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         AGO   .DONE\n.T1F1    AIF   (N'&FROM NE 1).ERRF\n&NFS     UNPK  &TO.(&LT+1),&FROM.(&LL+1)\n         TR    &TO.(&LT),&HEXTAB#\n         MVI   &TO+&LT,&BYTE\n         AGO   .DONE\n.ERRF    MNOTE 8,'ERROR IN \"FROM\" PARAMETER, MACRO TERMINATED'\n         MEXIT\n.ERRT    MNOTE 8,'ERROR IN \"TO\" PARAMETER, MACRO TERMINATED'\n         MEXIT\n.DONE    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HEXPRINT": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x00\\x97&\\x0f\\x01\\x02\\x07\\x7f\\x15$\\x02L\\x02L\\x00\\x04\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "2002-03-18T15:24:03", "lines": 588, "newlines": 588, "modlines": 4, "user": "MSTITT"}, "text": "         TITLE ' - PRINT A HEX LISTING.'\n*-------------------------------------------------------------*    @134\n* EXIT FROM HERE IS BY EODAD TO EODICAT IN THE MAINLINE       *    @134\n*-------------------------------------------------------------*    @134\nHEXPRINT $PROLOG R10,R11,R12\n         L     R4,=V(DATASECT)                                     @130\n         USING DATASECT,R4                                         @130\n         XPROPEN PWA,PAGELEN=PAGELEN,DDNAME=SYSPRINT\n         LTR   R15,R15             DID SYSPRINT OPEN?\n         BZ    HEXSYSOK            YES                             @134\n         L     R15,=A(EODICAT)                                     @134\n         BR    R15                 IF SYSPRINT DOESN'T OPEN        @134\nHEXSYSOK DS    0H                                                  @134\n         XPRHEAD PWA,LIST=(HEADER1,HEADER3)\n         L     R15,=V(ALLVVDS)                                     @130\n         BASR  R14,R15             ALLOCATE ALL VVDS'S             @130\n*        LA    R0,1                AUTHORIZATION ON.\n*        SVC   232                 **** INSTALLATION DEPENDANT ***\n         SPACE ,\n         L     R2,CVTPTR           A(CVT)\n         L     R2,0(0,R2)          TCB WORDS\n         L     R2,0(0,R2)          MY TCB.\n         USING TCB,R2\n         L     R2,TCBJSCB          TCB -> JSCB.\n         DROP  R2\n         USING IEZJSCB,R2\n         L     R2,JSCBACT          ACTIVE JSCB.\n         MODESET KEY=ZERO\n         SPACE ,\n*\n* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING\n* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER\n* A BREAK.\n*\n         OI    JSCBSWT1,JSCBPASS\n         SPACE ,\n         MODESET KEY=NZERO\n         OPEN  ACBICAT\n*        SR    R0,R0               AUTHORIZATION OFF.\n*        SVC   232                 **** INSTALLATION DEPENDANT ***\n         L     R15,=A(GENRPL)                                      @134\n         BASR  R9,R15              GENERATE RPL ADDR.              @134\nGETNEXTH L     R1,RPLICAT          GET RPL ADDR.\n         GET   RPL=(1)\n         LTR   R15,R15             RECORD READ OK?\n         BZ    HEXGETOK            YES                             @AVV\n         ICM   R2,15,RPLFDBK-IFGRPL(R1) GET FEEDBACK FIELD.        @AVV\n         ABEND 16,DUMP             DIE, SUCKER.                    @AVV\nHEXGETOK DS    0H                                                  @AVV\n         L     R3,BUFPTR           ADDR OF CATALOG RECORD\n         L     R2,RPLICAT          GET RPL ADDR FROM LAST GET.\n         L     R2,48(0,R2)         LENGTH OF RECORD READ\n         AR    R2,R3               POINT TO END OF CATALOG RECORD\n         LTR   R2,R2                                               @AVV\n         BNP   GETNEXTH            SKIP A BOGUS RECORD.            @AVV\n         ST    R2,ENDBCS           SAVE FOR FINDBCS ROUTINE\n         LA    R3,2(,R3)           SKIP OVER PREFIX\nHEXNEXT  CLI   2(R3),C'A'          A = NONVSAM\n         BE    HEXNVSAM\n         CLI   2(R3),C'C'          C = CLUSTER\n         BE    HEXCLUST\n         CLI   2(R3),C'D'          D = DATA COMPONENT\n         BE    HEXDATA\n         CLI   2(R3),C'I'          I = INDEX COMPONENT\n         BE    HEXINDEX\nENDHEX   SR    R1,R1\n         ICM   R1,3,0(R3)          PICK UP CELL LENGTH\n         LTR   R1,R1                                               @AVV\n         BNP   GETNEXTH            SKIP IF BOGUS LENGTH.           @AVV\n         AR    R3,R1               POINT TO NEXT CELL\n         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?\n         BL    HEXNEXT             YES, KEEP GOING\n         B     GETNEXTH            READ ANOTHER RECORD.\n         TITLE ' - HEX PRINT A NONVSAM CELL.'\n         USING NVNC,R3\nHEXNVSAM MVC   L2TYPE,=CL7'NONVSAM'\n         AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM             @120\n         HEX   L2WORK,NVCELEN,                                         X\n               2,HEXTAB=TRHEX      LENGTH OF NVNC\n         HEX   L2WORK+5,NVTYPE,                                        X\n               1,HEXTAB=TRHEX      TYPE 'A' FOR NONVSAM\n         HEX   L2WORK+8,NVRESV,                                        X\n               1,HEXTAB=TRHEX      RESERVED\n         HEX   L2WORK+11,NVOLCNT,                                      X\n               2,HEXTAB=TRHEX      NUMBER OF VOLUME CELLS (255 MAX)\n         HEX   L2WORK+16,NVKEYLN,                                      X\n               1,HEXTAB=TRHEX      LENGTH OF THE NONVSAM KEY\n         MVC   L2WORK+19(44),NVNAME\n         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         BAS   R9,HEXOWNER         OWNER CELL NEXT.\n         BAS   R9,HEXASSOC         ASSOCIATION (IF PRESENT).\n         BAS   R9,HEXVOL           VOLUME CELL(S).\n         B     ENDHEX\n         DROP  R3\n         TITLE ' - HEX PRINT A CLUSTER CELL.'\n         USING VCNC,R3\nHEXCLUST MVC   L2TYPE,=CL7'CLUSTER'\n         AP    CNTCLUST,ONE        COUNT A CLUSTER                 @120\n         HEX   L2WORK,CLCELLN,                                         X\n               2,HEXTAB=TRHEX      LENGTH OF VCNC INCLUDING ITSELF\n         HEX   L2WORK+5,CLTYPE,                                        X\n               1,HEXTAB=TRHEX      TYPE 'C' FOR CLUSTER\n         HEX   L2WORK+8,CLCOMPLN,                                      X\n               2,HEXTAB=TRHEX      LENGTH OF THE CLUSTER COMPONENT\n         HEX   L2WORK+13,CLNOEXT,                                      X\n               1,HEXTAB=TRHEX      NUMBER OF EXTENSION RECORDS\n         HEX   L2WORK+16,CLNMLEN,                                      X\n               1,HEXTAB=TRHEX      LENGTH OF THE CLUSTER KEY (45)\n         MVC   L2WORK+19(44),CLNAME\n         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         BAS   R9,HEXOWNER         OWNER CELL NEXT.\n         BAS   R9,HEXSECUR         SECURITY CELL (IF PRESENT).\n         BAS   R9,HEXASSOC         ASSOCIATION (IF PRESENT).\n         BAS   R9,HEXRELAT         RELATIONSHIP CELL (?)\n         B     ENDHEX\n         DROP  R3\n         TITLE ' - HEX PRINT A DATA OR INDEX CELL.'\n         USING DINC,R3\nHEXDATA  MVC   L2TYPE,=CL7'DATA'\n         AP    CNTDATA,ONE         COUNT IT                        @120\n         B     HEXDATA1\nHEXINDEX MVC   L2TYPE,=CL7'INDEX'\n         AP    CNTINDEX,ONE        COUNT IT.                       @120\nHEXDATA1 HEX   L2WORK,DIDLEN,                                          X\n               2,HEXTAB=TRHEX      LENGTH OF DINC\n         HEX   L2WORK+5,DIDTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE 'D' FOR DATA OR INDEX\n         HEX   L2WORK+8,DIDCMPLN,                                      X\n               2,HEXTAB=TRHEX      LENGTH OF DINC COMPONENT\n         HEX   L2WORK+13,DIDIRFLG,                                     X\n               1,HEXTAB=TRHEX      INTERRUPT RECOGNITION FLAGS\n         HEX   L2WORK+16,DIDKEYLN,                                     X\n               1,HEXTAB=TRHEX      CONDENSED KEYLENGTH\n         SR    R1,R1\n         ICM   R1,1,DIDKEYLN       GET LENGTH OF NAME KEY.\n         B     *+10\n         MVC   L2WORK+19(0),DIDKEY\n         EX    R1,*-6              MOVE IN NAME KEY.\n         B     *+10\n         MVC   SVCOMPN(0),DIDKEY   SAVE COMPONENT NAME\n         EX    R1,*-6              MOVE IN NAME KEY.\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         BAS   R9,HEXOWNER         OWNER CELL NEXT.\n         BAS   R9,HEXSECUR         SECURITY CELL (IF PRESENT).\n         BAS   R9,HEXVOL           VOLUME CELL(S).\n         B     ENDHEX\n         DROP  R3\n         TITLE ' - HEX AN OWNER CELL.'\nHEXOWNER $IN ,\n         ICM   R0,1,=XL1'01'       OWNER CELL TYPE.\n         L     R15,=V(FINDBCS)                                     @134\n         BASR  R9,R15                                              @134\n         USING OWNERC,R3\n         MVC   L2TYPE,=CL7' OWNER'\n         HEX   L2WORK,OWNCELLN,                                        X\n               2,HEXTAB=TRHEX      LENGTH OF OWNERSHIP CELL\n         HEX   L2WORK+5,OWNTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE X'01' FOR OWNER\n         HEX   L2WORK+8,OWNID,                                         X\n               4,HEXTAB=TRHEX      OWNER ID\n         HEX   L2WORK+16,OWNID+4,                                      X\n               4,HEXTAB=TRHEX      OWNER ID\n         HEX   L2WORK+25,OWNFLAG,                                      X\n               1,HEXTAB=TRHEX      FLAG\n         HEX   L2WORK+28,OWNCREDT,                                     X\n               3,HEXTAB=TRHEX      CREATION DATE\n         HEX   L2WORK+35,OWNEXPDT,                                     X\n               3,HEXTAB=TRHEX      EXPIRY DATE\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         $OUT  ,                   GET OUT.\n         TITLE ' - HEX AN ASSOCIATION CELL.'\nHEXASSOC $IN ,\n         ICM   R0,3,=XL2'FF03'     TYPE X'03', OPTIONAL.\n         L     R15,=V(FINDBCS)                                     @134\n         BASR  R9,R15                                              @134\n         LTR   R0,R0               SO WAS THERE?\n         BZ    HEXASS99            NO.\n         USING ASSOCC,R3\n         MVC   L2TYPE,=CL7' ASSOC'\n         HEX   L2WORK,ASCLEN,                                          X\n               2,HEXTAB=TRHEX      ASSOCIATION CELL LENGTH\n         HEX   L2WORK+5,ASCTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE X'03' FOR ASSOC\n         HEX   L2WORK+8,ASCOUNT,                                       X\n               2,HEXTAB=TRHEX      COUNT OF ASSOCIATIONS\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\nHEXASS99 $OUT  ,                   GET OUT\n         TITLE ' - HEX A SECURITY CELL.'\nHEXSECUR $IN ,\n         ICM   R0,3,=XL2'FF02'     TYPE X'02', OPTIONAL.\n         L     R15,=V(FINDBCS)                                     @134\n         BASR  R9,R15                                              @134\n         LTR   R0,R0               SO WAS THERE?\n         BZ    HEXSEC99            NO.\n         USING SECURITY,R3\n         MVC   L2TYPE,=CL7' SECUR'\n         HEX   L2WORK,SECELLN,                                         X\n               2,HEXTAB=TRHEX      LENGTH OF SECURITY CELL\n         HEX   L2WORK+5,SECTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE X'02' FOR SECURITY.\n         HEX   L2WORK+8,SECMSTR,                                       X\n               4,HEXTAB=TRHEX      MASTER PASSWORD.\n         HEX   L2WORK+16,                                              X\n               SECMSTR+4,                                              X\n               4,HEXTAB=TRHEX      MASTER PASSWORD.\n         HEX   L2WORK+27,SECCI,                                        X\n               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.\n         HEX   L2WORK+35,SECCI+4,                                      X\n               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.\n         HEX   L2WORK+44,                                              X\n               SECUPDTE,                                               X\n               4,HEXTAB=TRHEX      UPDATE PASSWORD.\n         HEX   L2WORK+52,                                              X\n               SECUPDTE+4,                                             X\n               4,HEXTAB=TRHEX      UPDATE PASSWORD.\n         HEX   L2WORK+61,SECREAD,                                      X\n               4,HEXTAB=TRHEX      READ PASSWORD.\n         HEX   L2WORK+69,                                              X\n               SECREAD+4,                                              X\n               4,HEXTAB=TRHEX      READ PASSWORD.\n         HEX   L2WORK+78,SECPMTCD,                                     X\n               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.\n         HEX   L2WORK+86,                                              X\n               SECPMTCD+4,                                             X\n               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.\n         HEX   L2WORK+95,SECATMP,                                      X\n               2,HEXTAB=TRHEX      MAXIMUM NUMBER OF ATTEMPTS.\n         HEX   L2WORK+100,                                             X\n               SECVRMOD,                                               X\n               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.\n         HEX   L2WORK+108,                                             X\n               SECVRMOD+4,                                             X\n               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.\n         HEX   L2WORK+117,                                             X\n               SECRCDLN,                                               X\n               2,HEXTAB=TRHEX      USER AUTHORIZATION RECORD LENGTH\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\nHEXSEC99 $OUT  ,                   GET OUT\n         TITLE ' - HEX A RELATION CELL.'\nHEXRELAT $IN ,\n         ICM   R0,3,=XL2'FF06'     OPTIONAL RELAT CELL\n         L     R15,=V(FINDBCS)                                     @134\n         BASR  R9,R15                                              @134\n         LTR   R0,R0               WAS IT THERE?\n         BZ    HEXREL99            NO.\n         USING RELCELL,R3\n         MVC   L2TYPE,=CL7' RELAT'\n         HEX   L2WORK,RELLEN,                                          X\n               2,HEXTAB=TRHEX      CELL LENGTH.\n         HEX   L2WORK+5,RELTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE X'06'\n         HEX   L2WORK+8,RELRESV,                                       X\n               1,HEXTAB=TRHEX      RESERVED.\n         HEX   L2WORK+11,RELCNT,                                       X\n               1,HEXTAB=TRHEX      COUNT OF RELKEYS.\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\nHEXREL99 $OUT  ,                   GET OUT\n         TITLE ' - HEX A VOLUME CELL.'\n* THIS LOGIC IS ENTERED AT A POINT WHERE THERE MUST BE AT LEAST ONE\n* VOLUME CELL POINTED TO BY R3. HOWEVER THERE COULD BE MORE THAN ONE.\n* HENCE, AFTER THE FIRST NON-VOLUME CELL IS RECOGNIZED R3 MUST BE\n* BACKED UP TO THE LAST VOLUME CELL SO THAT THE GENERAL CODE AT\n* \"ENDHEX\" CAN SKIP OVER IT.\nHEXVOL   $IN ,\nHEXVOL0  ICM   R0,3,=XL2'FF04'     VOLUME CELL\n         L     R15,=V(FINDBCS)                                     @134\n         BASR  R9,R15                                              @134\n         LTR   R0,R0               WAS THAT THE LAST ONE?\n         BZ    HEXVOL99            YES.\n         USING VOLCELL,R3\n         MVC   L2TYPE,=CL7' VOLUME'\n         HEX   L2WORK,VOLLEN,                                          X\n               2,HEXTAB=TRHEX      LENGTH OF VOLCELL\n         HEX   L2WORK+5,VOLTYPE,                                       X\n               1,HEXTAB=TRHEX      TYPE X'04' FOR VOLUME CELL\n         HEX   L2WORK+8,VOLOFSET,                                      X\n               1,HEXTAB=TRHEX      UNUSED\n         MVC   L2WORK+11(6),VOLSERN\n         HEX   L2WORK+18,VOLDEVTP,                                     X\n               4,HEXTAB=TRHEX      DEVICE TYPE\n         HEX   L2WORK+27,VOLFLAG1,                                     X\n               1,HEXTAB=TRHEX      FLAG\n         HEX   L2WORK+30,VOLFLAG2,                                     X\n               1,HEXTAB=TRHEX      RESERVED\n         HEX   L2WORK+33,VOLVVRBA,                                     X\n               4,HEXTAB=TRHEX      RELATIVE BYTE ADDRESS OF VVR\n         HEX   L2WORK+42,VOLFLSEQ,                                     X\n               2,HEXTAB=TRHEX      NONVSAM FILE SEQUENCE NUMBER (TAPE)\n         HEX   L2WORK+47,VOLKRQL,                                      X\n               4,HEXTAB=TRHEX      KEYRANGE QUALIFIER (VSAM ONLY)\n         HEX   L2WORK+56,VOLLKYLN,                                     X\n               2,HEXTAB=TRHEX      LENGTH OF LOW KEY RANGE KEY\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         TM    VOLFLAG1,VOLNVSAM   IS IT NONVSAM?\n         BO    HEXVOL99            IF SO, THAT'S ALL\n         TM    VOLFLAG1,VOLCANDI   IS IT A CANDIDATE VOLUME?\n         BO    HEXVOL99            IF SO, THAT'S ALL\n         MVC   RBASAVE,VOLVVRBA    SAVE RBA OF VVR\n         L     R5,VVDSTAD          GET VVDSTAB START ADDR\n         USING VVDSTAB,R5\nHEXVOL8  CLI   VVDSVOL,255         LAST ENTRY?\n         BE    HEXVOL99            YES, OH WELL.\n         CLC   VVDSVOL,VOLSERN     IS THIS THE VVDS?\n         BNE   HEXVOL6             NO, TRY AGAIN\n         ICM   R1,15,RBASAVE       GET VVR RBA\n         STCM  R1,15,VVDSARG       INSERT TO ARG FIELD FOR THIS RPL\n         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR\n         POINT RPL=(8)             POSITION TO DESIRED RECORD\n         GET   RPL=(8)             READ IN RECORD\n         LTR   R15,R15             RECORD READ OK?\n         L     R6,VVDSBUF          ADDR OF CATALOG RECORD\n         L     R1,VVDSRPL          GET ADDR OF RPL\n         L     R1,48(0,R1)         LENGTH OF RECORD READ\n         AR    R1,R6               POINT TO END OF CATALOG RECORD\n         ST    R1,ENDVVD           SAVE END OF RECORD ADDR\n         LA    R6,2(,R6)           SKIP OVER PREFIX\n         BAS   R9,HEXVVR           PRIMARY OR 2NDARY VVR\n         BAS   R9,HEXDSINF         DATASET INFORMATION CELL (MAYBE)\n         BAS   R9,HEXAMDSB         AMDSB CELL (IF PRESENT)\n         BAS   R9,HEXVOLIN         VOLUME INFORMATION CELL.\n         B     HEXVOL0             COULD BE MORE THAN ONE.\nHEXVOL6  LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY\n         B     HEXVOL8             WHAT IS IT JOHNNY?\nHEXVOL99 $OUT  ,                   GET OUT.\n         DROP  R3\n         TITLE ' - HEX PRINT A VVR.'\n* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI\n* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND\n* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY\n* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).\n         USING VVR,R6\nHEXVVR   $IN ,\n         MVC   L2TYPE,=CL7' VVR'\nHEXVVR0  CLI   2(R6),C'Q'          Q = SECONDARY VVR\n         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?\n         CLI   2(R6),C'Z'          Z = PRIMARY VVR\n         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?\nHEXVVR0A XC    VVD0,VVD0           NEXT CELL PLEASE.               @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         B     HEXVVR0             IS IT A VVR?\nHEXVVR0B SR    R1,R1\n         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.\n         BCTR  R1,0\n         BCTR  R1,0\n         B     HEXVVR0C\n         CLC   SVCOMPN(0),VVRCMPNM  (EXECUTED)\nHEXVVR0C EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.\n         BNE   HEXVVR0A            NO, MUST BE A RELATED COMPONENT.\n         HEX   L2WORK,VVRHDLEN,                                        X\n               2,HEXTAB=TRHEX\n         HEX   L2WORK+5,VVRTYPE,                                       X\n               1,HEXTAB=TRHEX\n         HEX   L2WORK+8,VVRFLAG,                                       X\n               1,HEXTAB=TRHEX\n         HEX   L2WORK+11,VVRKRQ,                                       X\n               4,HEXTAB=TRHEX\n         HEX   L2WORK+20,VVRCMPNL,                                     X\n               1,HEXTAB=TRHEX\n         SR    R1,R1\n         ICM   R1,1,VVRCMPNL       GET LENGTH OF COMPONENT KEY.\n         B     *+10\n         MVC   L2WORK+23(0),VVRCMPNM\n         EX    R1,*-6              MOVE IN COMPONENT KEY.\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         $OUT  ,                   GET OUT.\n         DROP  R6\n         TITLE ' - HEX A DATASET INFORMATION CELL.'\nHEXDSINF $IN ,\n         MVC   VVD0,=X'0000FF21'   DATASET INFORMATION CELL.       @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         LTR   R15,R15             WAS THERE ONE?                  @134\n         BNZ   HEXDSF99            NO.                             @134\n         USING VVRDSINF,R6\n         MVC   L2TYPE,=CL7' DSINFO'\n         HEX   L2WORK,VVRDSLEN,                                        X\n               2,HEXTAB=TRHEX      CELL LENGTH.\n         HEX   L2WORK+5,VVRDSTYP,                                      X\n               1,HEXTAB=TRHEX      TYPE CODE IS X'21'\n         HEX   L2WORK+8,VVRATTR1,                                      X\n               1,HEXTAB=TRHEX      DATASET ATTRIBUTES\n         HEX   L2WORK+11,VVRATTR2,                                     X\n               1,HEXTAB=TRHEX      DATASET ATTRIBUTES\n         HEX   L2WORK+14,VVROPIND,                                     X\n               1,HEXTAB=TRHEX      OPEN INDICATOR\n         HEX   L2WORK+17,VVRBUFSZ,                                     X\n               4,HEXTAB=TRHEX      MINIMUM BUFFER SIZE\n         HEX   L2WORK+26,VVRPRISP,                                     X\n               3,HEXTAB=TRHEX      PRIMARY SPACE ALLOCATION\n         HEX   L2WORK+33,VVRSECSP,                                     X\n               3,HEXTAB=TRHEX      SECONDARY SPACE ALLOCATION\n         HEX   L2WORK+40,VVRSPCFG,                                     X\n               1,HEXTAB=TRHEX      SPACE FLAGS\n         HEX   L2WORK+43,VVRDSHU,                                      X\n               4,HEXTAB=TRHEX      DATASET HIGH USED RBA\n         HEX   L2WORK+52,VVRDSHA,                                      X\n               4,HEXTAB=TRHEX      DATASET HIGH ALLOCATED RBA\n         HEX   L2WORK+61,VVRLRECL,                                     X\n               4,HEXTAB=TRHEX      AVERAGE LOGICAL RECORD LENGTH\n         HEX   L2WORK+70,VVREXCPX,                                     X\n               4,HEXTAB=TRHEX      EXCEPTION EXIT.\n         HEX   L2WORK+78,VVREXCPX+4,                                   X\n               4,HEXTAB=TRHEX      EXCEPTION EXIT.\n         HEX   L2WORK+87,VVRDSHK,                                      X\n               4,HEXTAB=TRHEX      DATASET HIGH KEY RBA.\n         HEX   L2WORK+96,VVRCLSFG,                                     X\n               1,HEXTAB=TRHEX      CLUSTER ATTRIBUTE FLAG\n         HEX   L2WORK+99,VVRAIXFG,                                     X\n               1,HEXTAB=TRHEX      AIX ATTRIBUTE FLAG\n         HEX   L2WORK+102,VVRTMSTP,                                    X\n               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).\n         HEX   L2WORK+110,VVRTMSTP+4,                                  X\n               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\nHEXDSF99 $OUT  ,                   GET OUT\n         TITLE ' - HEX AN AMDSB CELL.'\nHEXAMDSB $IN ,\n         MVC   VVD0,=X'0000FF60'   AMDSB CELL                      @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         LTR   R15,R15             WAS THERE ONE?                  @134\n         BNZ   HEXAMD99            NO.                             @134\n         USING VVRAMDCL,R6\n         MVC   L2TYPE,=CL7' AMDSB'\n         HEX   L2WORK+00,VVRAMDCN,                                     X\n               2,HEXTAB=TRHEX      LENGTH OF AMDSB CELL\n         HEX   L2WORK+05,VVRAMID,                                      X\n               1,HEXTAB=TRHEX      TYPE CODE IS X'60'\n         HEX   L2WORK+08,VVRAMATR,                                     X\n               1,HEXTAB=TRHEX      ATTRIBUTES:\n         HEX   L2WORK+11,VVRAMLEN,                                     X\n               2,HEXTAB=TRHEX      LENGTH OF AMDSB\n         HEX   L2WORK+16,VVRAMNST,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF ENTRIES IN INDEX SECTION\n         HEX   L2WORK+21,VVRAMRKP,                                     X\n               2,HEXTAB=TRHEX      RKP\n         HEX   L2WORK+26,VVRAMKNL,                                     X\n               2,HEXTAB=TRHEX      KEY LENGTH\n         HEX   L2WORK+31,VVRAMPCA,                                     X\n               1,HEXTAB=TRHEX      % FREE CI IN CA\n         HEX   L2WORK+34,VVRAMPCI,                                     X\n               1,HEXTAB=TRHEX      % FREE BYTES IN CI\n         HEX   L2WORK+37,VVRAMCCA,                                     X\n               2,HEXTAB=TRHEX      CI'S PER CA\n         HEX   L2WORK+42,VVRAMFCA,                                     X\n               2,HEXTAB=TRHEX      FREE CI'S PER CA\n         HEX   L2WORK+47,VVRAMFCI,                                     X\n               4,HEXTAB=TRHEX      FREE BYTES PER CI\n         HEX   L2WORK+56,VVRAMCIV,                                     X\n               4,HEXTAB=TRHEX      CONTROL INTERVAL SIZE\n         HEX   L2WORK+65,VVRAMLCL,                                     X\n               4,HEXTAB=TRHEX      MAXIMUM RECORD SIZE\n         HEX   L2WORK+74,VVRAMSLT,                                     X\n               4,HEXTAB=TRHEX      SLOTS PER CI\n         HEX   L2WORK+83,VVRAMMRR,                                     X\n               4,HEXTAB=TRHEX      MAXIMUM RELATIVE RECORD NUMBER\n         HEX   L2WORK+92,VVRAMARB,                                     X\n               4,HEXTAB=TRHEX      POINTER TO 1ST ARDB\n         HEX   L2WORK+101,VVRAMAT3,                                    X\n               1,HEXTAB=TRHEX      ATTRIBUTES\n         HEX   L2WORK+104,VVRAMSNO,                                    X\n               1,HEXTAB=TRHEX      NUMBER OF CONCURRENT REQUESTS\n         HEX   L2WORK+107,VVRAMBFD,                                    X\n               2,HEXTAB=TRHEX      NUMBER OF DATA BUFFERS\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         HEX   L2WORK+00,VVRAMSTS,                                     X\n               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP\n         HEX   L2WORK+08,VVRAMSTS+4,                                   X\n               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP\n         HEX   L2WORK+17,VVRAMNIL,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF INDEX LEVELS\n         HEX   L2WORK+22,VVRAMNXT,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF EXTENTS\n         HEX   L2WORK+27,VVRAMNLR,                                     X\n               4,HEXTAB=TRHEX      NUMBER OF LOGICAL RECORDS\n         HEX   L2WORK+38,VVRAMDLR,                                     X\n               4,HEXTAB=TRHEX      NUMBER OF DELETED RECORDS\n         HEX   L2WORK+47,VVRAMINR,                                     X\n               4,HEXTAB=TRHEX      NUMBER OF INSERTED RECORDS\n         HEX   L2WORK+56,VVRAMUPR,                                     X\n               4,HEXTAB=TRHEX      NUMBER OF UPDATED RECORDS\n         HEX   L2WORK+65,VVRAMRTR,                                     X\n               4,HEXTAB=TRHEX      NUMBER OF RETRIEVED RECORDS\n         HEX   L2WORK+74,VVRAMASP,                                     X\n               4,HEXTAB=TRHEX      BYTES OF FREE SPACE IN DATASET\n         HEX   L2WORK+83,VVRAMCIS,                                     X\n               4,HEXTAB=TRHEX      NUMBER OF CI SPLITS\n         HEX   L2WORK+92,VVRAMCAS,                                     X\n               4,HEXTAB=TRHEX      NUMBER OF CA SPLITS\n         HEX   L2WORK+101,VVRAMEXC,                                    X\n               4,HEXTAB=TRHEX      NUMBER OF EXCPS\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\nHEXAMD99 $OUT  ,                   GET OUT\n         TITLE ' - HEX A VOLUME INFORMATION CELL.'\nHEXVOLIN $IN ,\n         MVC   VVD0,=X'0000FF23'   VOLUME INFORMATION CELL         @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         LTR   R15,R15             WAS THERE ONE?                  @134\n         BNZ   HEXVLN99            NO.                             @134\n         USING VVRVOLIN,R6\n         MVC   L2TYPE,=CL7' VOLINF'\n         HEX   L2WORK+00,VVRVOLLN,                                     X\n               2,HEXTAB=TRHEX      LENGTH OF VOLUME CELL\n         HEX   L2WORK+05,VVRVOLTP,                                     X\n               1,HEXTAB=TRHEX      TYPE CODE IS X'23'\n         HEX   L2WORK+08,VVRVOLFG,                                     X\n               1,HEXTAB=TRHEX      VOLUME FLAGS\n         HEX   L2WORK+11,VVRNOEXT,                                     X\n               1,HEXTAB=TRHEX      NUMBER OF EXTENTS ON THIS VOLUME.\n         HEX   L2WORK+14,VVRHKRBA,                                     X\n               4,HEXTAB=TRHEX      HIGH KEY RBA\n         HEX   L2WORK+23,VVRHURBA,                                     X\n               4,HEXTAB=TRHEX      HIGH USED RBA\n         HEX   L2WORK+32,VVRHARBA,                                     X\n               4,HEXTAB=TRHEX      HIGH ALLOCATED RBA\n         HEX   L2WORK+41,VVRBLKSZ,                                     X\n               4,HEXTAB=TRHEX      BLOCK SIZE\n         HEX   L2WORK+50,VVRBLKTK,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF BLOCKS PER TRACK\n         HEX   L2WORK+55,VVRTRKAU,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF TRACKS PER ALLOCATION UNIT\n         HEX   L2WORK+60,VVRTPEXT,                                     X\n               1,HEXTAB=TRHEX      EXTENT TYPE FLAG\n         HEX   L2WORK+63,VVRTKCYL,                                     X\n               2,HEXTAB=TRHEX      TRACKS PER CYLINDER\n         HEX   L2WORK+68,VVRBYTTK,                                     X\n               4,HEXTAB=TRHEX      BYTES PER TRACK.\n         HEX   L2WORK+77,VVRBYTAU,                                     X\n               4,HEXTAB=TRHEX      BYTES PER ALLOCATION UNIT\n         HEX   L2WORK+86,VVRLOKYL,                                     X\n               2,HEXTAB=TRHEX      LOW KEY LENGTH\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         ST    R5,HEXR5            SAVE VVDSTAB BASE REG\n         SR    R5,R5\n         ICM   R5,1,VVRNOEXT       GET NUMBER OF EXTENTS\n         LR    R8,R6\n         LA    R8,40(0,R8)         POINT TO EXTENT DESCR.\n         USING VVRXTENT,R8\nHEXVLN97 HEX   L2WORK+00,VVRXSEQN,                                     X\n               2,HEXTAB=TRHEX      SEQUENCE NUMBER\n         HEX   L2WORK+05,VVRXSCH,                                      X\n               4,HEXTAB=TRHEX      STARTING CCHH\n         HEX   L2WORK+14,VVRXECH,                                      X\n               4,HEXTAB=TRHEX      ENDING CCHH\n         HEX   L2WORK+23,VVRXNTRK,                                     X\n               2,HEXTAB=TRHEX      NUMBER OF TRACKS\n         HEX   L2WORK+28,VVRXSRBA,                                     X\n               4,HEXTAB=TRHEX      STARTING RBA\n         HEX   L2WORK+37,VVRXERBA,                                     X\n               4,HEXTAB=TRHEX      ENDING RBA\n         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2\n         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134\n         BASR  R9,R15              PRINT LINE                      @134\n         LA    R8,20(0,R8)         POINT TO NEXT EXTENT DESCR.\n         BCT   R5,HEXVLN97         FORMAT ALL EXTENTS\n         L     R5,HEXR5            RESTORE VVDSTAB BASE REG\nHEXVLN99 $OUT  ,                   GET OUT\nHEXR5    DC    F'0'                I'M RUNNING OUT OF REGISTERS\n         DROP  R8\n         LTORG ,                                                   @134\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HSMMCA": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x00\\x96!\\x8f\\x00\\x96!\\x8f\\x13E\\x00\\x06\\x00\\x06\\x00\\x00\\xd4\\xe5\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-08-05T00:00:00", "modifydate": "1996-08-05T13:45:37", "lines": 6, "newlines": 6, "modlines": 0, "user": "MVS"}, "text": "MCA      ORG   MCHDATA\nMCAINTTP DS    CL1                 DATASET TYPE\nMCAVSATP DS    CL1                 VSAM ASSOCIATION TYPE\n         DS    CL2\nMCAINTNM DS    CL44                USER DATASET RECORD KEY\nMCABUIE  ORG   *\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HSMMCB": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x005\\x00\\x96\\x14_\\x00\\x96\\x14_\\x16)\\x00<\\x00<\\x00\\x00\\xd4\\xe5\\xe2@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1996-05-24T00:00:00", "modifydate": "1996-05-24T16:29:35", "lines": 60, "newlines": 60, "modlines": 0, "user": "MVS"}, "text": "MCB      ORG   MCHDATA\nMCBVSN   DS    CL6                 VOLUME SERIAL NUMBER\nMCBMBC   DS    XL2                 MAX BACKUP COPIES\nMCBMBCD  EQU   X'FFFF'                 USE SYSTEM DEFAULT\n         DS    CL8                 RESERVED\nMCBTSBU  DS    CL4                 BACKUP MADE TIME  HUNDREDTH SECS\nMCBDBU   DS    CL4                 BACKUP MADE DATE  X'00YYDDDS'\nMCBDSORG DS    XL2                 DSCB DSORG\nMCBBLKSZ DS    XL2                 DATASET BLOCK SIZE\nMCBKEYLN DS    XL1                 DATASET KEY LENGTH\nMCBRECFM DS    XL1                 VTOC RECORD FORMAT\nMCBRFV   EQU   B'10000000'             RECORD TYPE V\nMCBRFB   EQU   B'11000000'             RECORD TYPE B\nMCBRFF   EQU   B'01000000'             RECORD TYPE F\nMCBRFTO  EQU   B'00100000'             TRACK OVERFLOW\nMCBDSIND DS    XL1                 VTOC DATA SET INDICATORS\nMCBRACF  EQU   B'01000000'             RACF\nMCBFSCTY EQU   B'00100000'             PASSWORD\nMCBFWSEC EQU   B'00000100'             WRITE PROTECTED\nMCBDSCHA EQU   B'00000010'             CHANGED\nMCBCOMPR DS    XL1                 COMPACTION SAVINGS PERCENTAGE\nMCBSIZE  DS    XL4                 TRACKS ALLOCATED\nMCBSIZEB DS    XL4                 BYTES ALLOCATED\nMCBCSZ   DS    XL4                 NUMBER 2KB BLOCKS\n         DS    CL2\nMCBFLGS  DS    XL1                 FLAGS\nMCBFASN  EQU   B'10000000'             BACKUP VERSION INFORMATION\nMCBFDBU  EQU   B'01000000'             BACKUP VERSION FOUND\nMCBFSMS  EQU   B'00100000'             SMS MANAGED\nMCBFSIZE EQU   B'00010000'             MCBSIZEB IN KB\nMCBFCCSR EQU   B'00001000'             CONCURRENT COPY IN PROCESS\n         DS    CL1\nMCBGEN   DS    XL2                 NUMBER OF GENERATIONS\nMCBNBC   DS    XL2                 CURRENT BACKUP VERSIONS\nMCBTBC   DS    XL2                 TOTAL BACKUP VERSIONS\nMCBFREQ  DS    XL2                 BACKUP FREQUENCY\nMCBFRQD  EQU   X'FFFF'                 USE SYSTEM DEFAULT\nMCBDLRPB DS    CL4                 LAST REFERENCED DATE X'00YYDDDS'\nMCBCTID  DS    CL4                 COMPACTION TABLE ID\nMCBVSPWD DS    CL8                 VSAM MASTER PASSWORD\nMCBSCRD  DS    PL4                 NOT CATALOGED DATE\n         DS    CL4\n*                              BACKUP VERSION INFORMATION\nMCBBUI   ORG   *\nMCBBDSN  DS    CL44                BACKUP DATASET NAME\nMCBFRVOL DS    CL6                 ORIGINAL VOLUME SERIAL\nMCBBUIF  DS    XL1                 FLAGS\nMCBFONL1 EQU   B'10000000'             ON ML1 VOLUME\nMCBFCAT  EQU   B'01000000'             CATALOGED\nMCBFVSDS EQU   B'00100000'             VSAM DATASET\nMCBFTAPE EQU   B'00010000'             TAPE VERSION\nMCBFDBUV EQU   B'00001000'             RETIRED DATASET\nMCBFPROF EQU   B'00000100'             PROFILE EXISTS\nMCBFVSMS EQU   B'00000010'             SMS DATASET\nMCBFEXPD EQU   B'00000001'             EXPIRED DATASET\n         DS    CL1\nMCBCDATE DS    CL4                 VERSION CREATE DATE X'00YYDDDS'\nMCBVER   DS    XL4                 VERSION NUMBER\n         DS    CL4\nMCBBUIE  ORG   *\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HSMMCD": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x004\\x00\\x96 _\\x00\\x96\"\\x0f\\x125\\x00\\x8a\\x00d\\x00\\x00\\xd4\\xe5\\xe2@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1996-07-23T00:00:00", "modifydate": "1996-08-07T12:35:34", "lines": 138, "newlines": 100, "modlines": 0, "user": "MVS"}, "text": "MCD      ORG   MCHDATA\nMCDVSN   DS    CL6                 VOLUME SERIAL NUMBER\nMCDFLGS  DS    CL2\nMCDFASN  EQU   B'10000000'             VALID MIGRATED DATASET\nMCDFMIG  EQU   B'01000000'             TO BE MIGRATED\nMCDFNOMG EQU   B'00100000'             PREVENTED FROM MIGRATING\nMCDFDEL  EQU   B'00010000'             DATASET WAS DELETED\nMCDFSDP  EQU   B'00001000'             SMALL DATASET PACKING\nMCDFL2   EQU   B'00000100'             ON LEVEL 2 VOLUME\nMCDFNSCR EQU   B'00000010'             RECALL - STILL ON MIG VOLUME\nMCDJES3  EQU   B'00000001'             PROCESSED ON JES3 SYSTEM\n         ORG   MCDFLGS+1\nMCDFMCO  EQU   B'10000000'             MCO RECORD EXISTS (VSAM ASSOC)\nMCDFMIGP EQU   B'01000000'             VSAM MIGRATION IN PROGRESS\nMCDNOUPD EQU   B'00100000'             RACF DISCRETE PROFILE NOT CHGD\nMCDRACND EQU   B'00010000'             RACF INDICATED\nMCDFEOS  EQU   B'00001000'             ERASE ATTRIBUTE SPECIFIED\nMCDFSMVL EQU   B'00000100'             VALID SPACE MGMT FLAGS\nMCDFDUMD EQU   B'00000010'             DUMMY RECORD\nMCDFR3   EQU   B'00000001'             HSM 1.3 OR HIGHER\n         ORG   MCDFLGS+2\nMCDCOMPR DS    XL1                 COMPACTION SAVINGS PERCENTAGE\n         DS    CL3\nMCDDLC   DS    CL4                 DATASET CREATE DATE  X'00YYDDDS'\nMCDTSLR  DS    0CL8                LAST REFERENCED TIME STAMP\nMCDTLR   DS    CL4                     LAST USED TIME   X'HHMMSSTH'\nMCDDLR   DS    CL4                     LAST USED DATE   X'00YYDDDS'\nMCDTSLU  DS    0CL8                VSAM LAST CHANGED\nMCDTLU   DS    CL4                     LAST UPDATE TIME X'HHMMSSTH'\nMCDDLU   DS    CL4                     LAST UPDATE DATE X'00YYDDDS'\nMCDTSMIG DS    0CL8                MIGRATED TIME STAMP\nMCDTMIG  DS    CL4                     MIGRATED TIME    X'HHMMSSTH'\nMCDDMIG  DS    CL4                     MIGRATED DATE    X'00YYDDDS'\nMCDDSORG DS    XL2                 DSCB DSORG\nMCDBLKSZ DS    XL2                 DATASET BLOCK SIZE\nMCDKEYLN DS    XL1                 DATASET KEY LENGTH\nMCDRECFM DS    XL1                 VTOC RECORD FORMAT\nMCDRFF   EQU   B'10000000'             RECORD TYPE F\nMCDRFU   EQU   B'11000000'             RECORD TYPE U\nMCDRFV   EQU   B'01000000'             RECORD TYPE V\nMCDRFTO  EQU   B'00100000'             TRACK OVERFLOW\nMCDDSIND DS    XL1                 VTOC DATA SET INDICATORS\nMCDFLSTV EQU   B'10000000'             LAST VOLUME\nMCDRACF  EQU   B'01000000'             RACF\nMCDFSCTY EQU   B'00100000'             PASSWORD\nMCDFWSEC EQU   B'00000100'             WRITE PROTECTED\nMCDDSCHA EQU   B'00000010'             CHANGED\nMCDHID   DS    CL1                 HOST IDENTIFIER\nMCDSIZE  DS    XL4                 TRACKS ALLOCATED\nMCDSIZEB DS    XL4                 BYTES ALLOCATED\nMCDCSZ   DS    XL4                 NUMBER 2KB BLOCKS\nMCDNMIG  DS    CL2                 NUMBER OF MIGRATIONS\nMCDDAYS  DS    CL2                 DAYS TO MIGRATE\nMCDFRVSN DS    0CL6                ORIGINAL PRIMARY VOLUME\nMCDOVSN  DS    CL6                 RECALLED PRIMARY VOLUME\n         DS    CL1\nMCDFMCL  EQU   B'10000000'             MCL RECORD EXISTS\nMCDFNOD  EQU   B'01000000'             NO DELVOL ELIGIBLE\nMCDFCMCL EQU   B'00100000'             CREATE MCL RECORD\nMCDFBUWM EQU   B'00010000'             BACKED UP WHILE MIGRATED\nMCDFPDSE EQU   B'00001000'             PDSE DATASET\nMCDFDSS  EQU   B'00000010'             DSS DATA MOVER\nMCDDSRNM EQU   B'00000001'             ARECOVER RENAMED\nMCDMCL43 DS    CL1                 MCL RECORD KEY CHARACTER\nMCDCTID  DS    CL4                 COMPACTION TABLE ID\nMCDUCBTY DS    CL4                 PRIMARY VOLUME DEVICE TYPE\nMCDTRES  DS    CL4                 RECALL TIME STAMP  X'HHMMSSTH'\nMCDDRES  DS    CL4                 RECALL DATE STAMP  X'00YYDDDS'\nMCDMDEVT DS    CL4                 MIGRATE VOLUME DEVICE TYPE\n         ORG   MCDMDEVT+2\n         DS    CL1\nMCDFMVRT EQU   B'00001000'             VIRTUAL VOLUME\n         DS    CL1\nMCDTPDEV EQU   B'10000000'             TAPE VOLUME\nMCDFMVDA EQU   B'00100000'             DASD VOLUME\nMCDJDAYS DS    CL1                 DELAY MIGRATION\nMCDJDATE DS    CL3                 DELAY MIGRATION LAST DATE\nMCDJVEXD DS    CL3                 LAST VOLSER HOLD DATE\nMCDPDEP  DS    CL1                 VOLUME POOL TYPE\nMCDPDEPG EQU   C'1'                    GENERAL POOL\nMCDPDEPU EQU   C'2'                    USER DEFINED POOL\nMCDJCT   DS    CL1                 NUMBER ELIGIBLE RECALL VOLUMES\nMCDJVOLS DS    0CL50               PRESELECTED RECALL VOLUMES\nMCDJVSN  DS    CL6                 PRESELECTED VOLSER\nMCDJDEVT DS    CL4                 PRESELECTED DEVICE TYPE\n         ORG   MCDJVOLS+50\nMCDRECAL DS    CL1                 RECALL FLAGS\nMCDFDBA  EQU   B'10000000'             NO RECALL TO MIGRATE\nMCDFRBU  EQU   B'01000000'             DELETEIFBACKEDUP FLAG\nMCDFBDCS EQU   B'00100000'             BACKUP DEV CATEGORY SPECIFIED\nMCDFBDCT EQU   B'00010000'             BACKUP DEV CATEGORY TAPE\nMCDFAM   EQU   B'00001000'             USE SPACE MANAGED VOLUME\nMCDFAB   EQU   B'00000100'             USE AUTOBACKUP VOLUME\nMCDEXPDT DS    CL4                 EXPIRATION DATE  X'CCYYDDDS'\nMCDMCANM DS    CL44                MCA RECORD KEY - MIGRATION COPY\nMCDVSPWD DS    CL8                 VSAM MASTER PASSWORD\nMCDFBID  DS    CL4                 TAPE POSITIONING DATA\nMCDNVSN  DS    CL2                 NUMBER OF TAPE VOLUMES\nMCDNVSNO DS    CL2                 OFFSET TO MCDAVSN\nMCDTPBLK DS    CL4                 NUMBER 16K BLOCKS\nMCDTERN  DS    CL4                 TTOC EXTENSION RECORD ENTRY\nMCDVOLSQ DS    CL2                 TAPE VOLUME SEQUENCE NUMBER\nMCDFLGS2 DS    CL1                 MORE FLAGS\nMCDFSIZE EQU   B'10000000'             SIZE RECORDED IN KB\nMCDFSTRP EQU   B'01000000'             EXTENDED FORMAT MIGRATION\nMCDFPDSX EQU   B'00100000'             PDSEX(HFS) DATASET\n         DS    CL1\nMCDSMSWA DS    0CL96               SMS CONSTRUCTS\nMCDDCLEN DS    CL2                 LENGTH OF DATACLASS NAME\nMCDDCNAM DS    CL30                DATACLASS NAME\nMCDSCLEN DS    CL2                 LENGTH OF STORAGECLASS NAME\nMCDSCNAM DS    CL30                STORAGE CLASS NAME\nMCDMCLEN DS    CL2                 LENGTH OF MANAGEMENTCLASS NAME\nMCDMCNAM DS    CL30                MANAGEMENT CLASS NAME\nMCDDLBU  DS    CL8                 LAST BACKUP DATE (STCK)\nMCDRECOR DS    CL1                 DATASET RECORD ORGANIZATION (VSAM)\nMCDSMSFG DS    CL1                 SMS FLAGS\nMCDFSMS  EQU   B'10000000'             SMS MANAGED\nMCDFGDG  EQU   B'01000000'             GDG DATASET\nMCDFROG  EQU   B'00100000'             ROLLED OFF GDG\nMCDKEYRG EQU   B'00010000'             VSAM KEYRANGE\nMCDFMVOL EQU   B'00001000'             MULTIVOLUME\nMCDFRBLK EQU   B'00000100'             REBLOCKABLE\nMCDFCOMP EQU   B'00000010'             COMPRESSED\nMCDROWNR DS    CL16                RESOURCE OWNER NAME\nMCDRDATA DS    CL8                 RECOVERY DATA\nMCDSCALO DS    0CL4                SECONDARY ALLOCATION DATA\nMCDSCAL1 DS    CL1                 SECONDARY ALLOCATION FLAGS\nMCDALCYL EQU   B'11000000'             CYLINDER REQUEST\nMCDALTRK EQU   B'10000000'             TRACK REQUEST\nMCLALBLK EQU   B'01000000'             BLOCK REQUEST\nMCDSCAL3 DS    CL3                 SECONDARY ALLOCATION QUANTITY\n         DS    CL2\nMCDUSIZ  DS    CL4                 DATASET SIZE UNCOMPRESSED (KB)\nMCDCSIZ  DS    CL4                 DATASET SIZE COMPRESSED (KB)\n         DS    CL32\nMCDBUIE  ORG   *\nMCDAVSN  DS    CL6                 ADDITIONAL TAPE VOLUMES\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HSMMCK": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x00\\x96\\x14_\\x00\\x96\\x14_\\x111\\x006\\x007\\x00\\x00\\xd4\\xe5\\xe2@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-05-24T00:00:00", "modifydate": "1996-05-24T11:31:48", "lines": 54, "newlines": 55, "modlines": 0, "user": "MVS"}, "text": "MCKDSECT DS   0CL64\nMCK      DS   0CL44                RECORD KEY\nMCKTYPE  DS   CL1                  RECORD TYPE\n*                              MIGRATION CDS ENTRY TYPES\nMCKTYPU  EQU  X'01'                     AUTHORIZED USER CODE U\nMCKTYP1  EQU  X'02'                     FREE SPACE ON ML1 CODE 1\nMCKTYPV  EQU  X'04'                     VOLUME CODE V\nMCKTYPN  EQU  X'07'                     JES3 ALLOCATE CODE N\nMCKTYPS  EQU  X'10'                     STATISTICS CODE S\nMCKTYPO  EQU  X'12'                     VSAM ASSOCIATIONS CODE O\n*                               BACKUP CDS ENTRY TYPES\nMCKTYPY  EQU  X'21'                     DVL  CODE Y\nMCKTYPW  EQU  X'22'                     DCL  CODE W\nMCKTYPM  EQU  X'26'                     MOVE BACKUP COPY  CODE M\nMCKTYPL  EQU  X'27'                     BACKUP MIGRATED  CODE L\nMCKTYPP  EQU  X'28'                     PRIMARY VOLUME  CODE P\nMCKTYPG  EQU  X'29'                     DGN  CODE G\nMCKTYPQ  EQU  X'2A'                     ABR RECORD  CODE Q\nMCKTYPX  EQU  X'2C'                     BACKUP VOLUME  CODE X\nMCKTYPR  EQU  X'30'                     BCR,BVR,CDR RECORDS  CODE R\n*                               OFFLINE CDS ENTRY TYPES\nMCKTYPT  EQU  X'32'                     TTOC  CODE T\nMCKKEY2  DS   CL43\nMCKHDR   ORG  *\nMCH      DS   0CL20                 RECORD HEADER\nMCHLEN   DS   CL2                   RECORD LENGTH\nMCHTYPE  DS   CL1                   ENTRY TYPE\n*                               MIGRATION CDS ENTRY TYPES\nMCHTYPD  EQU  X'00'                     MIGRATED DATA SET  CODE D\nMCHTYPU  EQU  X'01'                     AUTHORIZED USER CODE U\nMCHTYP1  EQU  X'02'                     FREE SPACE ON ML1 CODE 1\nMCHTYPV  EQU  X'04'                     VOLUME CODE V\nMCHTYPN  EQU  X'07'                     JES3 ALLOCATE CODE N\nMCHTYPS  EQU  X'10'                     STATISTICS CODE S\nMCHTYPA  EQU  X'11'                     MIGRATED COPY NAME  CODE A\nMCHTYPO  EQU  X'12'                     VSAM ASSOCIATIONS CODE O\n*                               BACKUP CDS ENTRY TYPES\nMCHTYPB  EQU  X'20'                     BACKUP DATA SET  CODE B\nMCHTYPY  EQU  X'21'                     DVL  CODE Y\nMCHTYPW  EQU  X'22'                     DCL  CODE W\nMCHTYPC  EQU  X'24'                     BACKUP VERSION  CODE C\nMCHTYPM  EQU  X'26'                     MOVE BACKUP COPY  CODE M\nMCHTYPL  EQU  X'27'                     BACKUP MIGRATED  CODE L\nMCHTYPP  EQU  X'28'                     PRIMARY VOLUME  CODE P\nMCHTYPG  EQU  X'29'                     DGN  CODE G\nMCHTYPQ  EQU  X'2A'                     ABR RECORD  CODE Q\nMCHTYPX  EQU  X'2C'                     BACKUP VOLUME  CODE X\nMCHTYPR  EQU  X'30'                     BCR,BVR,CDR RECORDS  CODE R\n*                               OFFLINE CDS ENTRY TYPES\nMCHTYPT  EQU  X'32'                     TTOC  CODE T\n         DS   CL1                   RESERVED\nMCHTSLU  DS   CL8                   LAST UPDATE TIME (STCK FORMAT)\nMCHTSCR  DS   CL8                   CREATE TIME (STCK FORMAT)\nMCHDATA  EQU  *                     START OF ENTRY DATA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEAVMXIT": {"ttr": 3598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x00\\x00\\x95&\\x9f\\x01\\x01\\x17\\x1f\\x14\\x14\\x02\\xf7\\x02$\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "1995-09-26T00:00:00", "modifydate": "2001-06-20T14:14:00", "lines": 759, "newlines": 548, "modlines": 0, "user": "MSTITT"}, "text": "//IEAVMXIT JOB (XSYZ,MSTITT),'MATTHEW STITT',MSGCLASS=X,NOTIFY=MSTITT\n//C       EXEC PGM=ASMA90,\n//             PARM='OBJECT,NODECK,NOXREF'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR\n//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80\n//SYSLIN   DD  DSN=&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=3390,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSUT1   DD  DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             DCB=BUFNO=1\n//SYSIN    DD  *\n***********************************************************************\n*                                                                     *\n* MODULE NAME         =  IEAVMXIT                                     *\n*                                                                     *\n* DESCRIPTIVE NAME    =  SAMPLE COMMUNICATIONS TASK USER EXIT FOR     *\n*                        MSGS IFB010D, ILR022A, $HASP426, ERB306D     *\n*                                                                     *\n* FUNCTIONS           =  ROUTES MESSAGES VIA ROUTING CODE 11,         *\n*                        SUPPRESSES AND REPLIES TO MESSAGES           *\n*                                                                     *\n*                        ISSUES $S AFTER JES2 INITIALIZATION          *\n*                        ISSUES S TSO AFTER VTAM INITIALIATION        *\n*                                                                     *\n* OPERATION           =  DETERMINES WHICH MESSAGE IS PROCESSED.       *\n*                        REQUESTS TO CHANGE THE ROUTING CODES TO      *\n*                        ROUTING CODE 11 ONLY.                        *\n*                                                                     *\n*                        THIS EXIT ROUTINE                            *\n*                        REQUESTS TO SUPPRESS THE WTOR AND THEN       *\n*                        REPLIES TO IT VIA THE MSGR MACRO.            *\n*                                                                     *\n* ENTRY POINT         =  IEAVMXIT                                     *\n*                                                                     *\n*   LINKAGE           =  BASR                                         *\n*                                                                     *\n*   INPUT DATA        =  REG 1 POINTS TO THE ADDRESS OF THE CTXT      *\n*                        REG 13 ADDRESS OF STANDARD SAVE AREA         *\n*                        REG 15 ENTRY POINT                           *\n*                                                                     *\n*   REGISTERS SAVED   =  REG0 - REG15                                 *\n*                                                                     *\n*   REGISTER USAGE    =  REG5  - POINTER TO THE ADDRESS OF CTXT       *\n*                        REG11 - MODULE DATA REGISTER                 *\n*                        REG12 - MODULE BASE REGISTER                 *\n*                        REG13 - POINTER TO A STANDARD SAVE AREA      *\n*                        REG14 - RETURN POINT                         *\n*                                                                     *\n*   REGISTERS RESTORED = REG0 - REG15                                 *\n*                                                                     *\n*   CONTROL BLOCKS    =                                               *\n*     NAME     MAPPING MACRO   REASON USED                      USAGE *\n*     ----     -------------   -----------                     -------*\n*     CTXT      IEZVX100        USER EXIT PARAMETER LIST         R,W  *\n*     MGCR      IEZMGCR         SVC 34 PARAMETER LIST            C,D  *\n*                                                                     *\n*   KEY = R-READ, W-WRITE, C-CREATE, D-DELETE                         *\n*                                                                     *\n*   TABLES            =  NONE                                         *\n*                                                                     *\n*   MACROS            =  GETMAIN, FREEMAIN, MGCR, WTO                 *\n*                                                                     *\n***********************************************************************\n         EJECT\nIEAVMXIT CSECT\nIEAVMXIT AMODE 31                      31-BIT ADDRESSING MODE\nIEAVMXIT RMODE ANY                     31-BIT RESIDENCE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        REGISTER ASSIGNMENTS                                         *\n*                                                                     *\n***********************************************************************\nREG0     EQU   0\nREG1     EQU   1\nREG2     EQU   2\nREG3     EQU   3\nREG4     EQU   4\nREG5     EQU   5\nREG6     EQU   6\nREG7     EQU   7\nCTXTPTR  EQU   8\nREG11    EQU   11\nREG12    EQU   12\nREG13    EQU   13\nREG14    EQU   14\nREG15    EQU   15\nSPINPRVT EQU   230\n         EJECT\n***********************************************************************\n*                                                                     *\n*        STANDARD ENTRY LINKAGE                                       *\n*                                                                     *\n***********************************************************************\n         STM   REG14,REG12,12(REG13)   SAVE CALLER'S REGISTERS\n         BASR  REG12,REG0              ESTABLISH MODULE BASE\n         USING *,REG12                 REGISTER\n         L     CTXTPTR,0(REG1)         ESTABLISH ADDRESSABILITY\n         USING CTXT,CTXTPTR            TO THE CXTX\n***********************************************************************\n*                                                                     *\n*        DYNAMIC STORAGE FOR THIS MODULE IS BEING OBTAINED BELOW      *\n*        16-MEG LINE BECAUSE SVC 34 REQUIRES THE MQCR PARAMETER       *\n*        LIST TO BE IN 24-BIT ADDRESSABLE STORAGE.                    *\n*                                                                     *\n***********************************************************************\n         GETMAIN RU,LV=DATAEND,SP=SPINPRVT,LOC=BELOW\n         LR    REG11,REG1              ADDRESS RETURNED IN REG1\n         USING DATAAREA,REG11          ADDRESSABILITY TO DYNAMIC\n         ST    REG13,SAVEAREA+4        SET BACKWARD PTR\n         LA    REG15,SAVEAREA          GET ADDRESS OF SAVE AREA\n         ST    REG15,8(REG13)          SET FORWARD PTR\n         LR    REG13,REG15             SET REG13 TO POINT TO\n*                                      STANDARD SAVE AREA\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DETERMINE WHICH MESSAGE IS TO BE PROCESSED.                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO THE MSG ATTRIBUTES\n         LA    REG7,CTXTTMSG           ADDRESS OF TEXT AREA\n         USING MSGTEXT,REG7            BASE TEXT MAPPING\n*        CLC   MSGID,IKT005I           MESSAGE IKT005I?\n*        BE    MIKT005I\n         CLC   MSGID,IFB010D           MESSAGE IFB010D?\n         BE    MIFB010D\n         CLC   MSGID,ILR022A           MESSAGE ILR022A?\n         BE    MILR022A\n         CLC   MSGID,ARC0366           MESSAGE ARC0366A?\n         BE    MARC0366\n         CLC   MSGID,ARC0310           MESSAGE ARC0310A?\n         BE    MARC0310\n         CLC   MSGID,ARC0314           MESSAGE ARC0314A?\n         BE    MARC0314\n         CLC   MSGID,ARC0381           MESSAGE ARC0381A?\n         BE    MARC0381\n         CLC   MSGID,$HASP426          MESSAGE $HASP426?\n         BE    MHASP426\n         CLC   MSGID,ERB306D           MESSAGE ERB306D?\n         BE    MERB306D\n         CLC   MSGID,$HASP400          MESSAGE $HASP400?\n         BE    MHASP400\n         CLC   MSGID,IST020I           MESSAGE IST020I?\n         BE    MIST020I\n         CLC   MSGID,IEF238D           MESSAGE IEF238D?\n         BE    MIEF238D\n         CLC   MSGID,IEF433D           MESSAGE IEF433D?\n         BE    MIEF433D\n         CLC   MSGID,CAT9013           MESSAGE CAT9013?\n         BE    MCAT9013\n         CLC   MSGID,EZB6473I          MESSAGE EZB6473I?\n         BE    MEZB6473\n         CLC   MSGID,ERB100I           MESSAGE ERB100I?\n         BE    MERB100I\n*        CLC   MSGID,IEE362A           MESSAGE IEE362A?\n*        BE    MIEE362A\n*        L     REG6,CTXTRCP            ADDRESS OF ROUTING CODES\n*        USING CTXTROUT,REG6           BASE ROUTING MAPPING\n*        TM    CTXTR002,CTXTR14        ROUTE CODE 14?\n*        BO    NOHRDCPY\n         B     FINISHED\n*********************************************************************\n*                                                                     *\n*        ISSUE THE CONSOLE MESSAGE                                    *\n*                                                                     *\n***********************************************************************\nISSMSG   EQU   *\n         WTO   MF=(E,USERAUTO)         ISSUE THE MESSAGE\n*        BR    REG14                   RETURN TO CALLER\n*        B     FINISHED\n*********************************************************************\n*                                                                     *\n*        STANDARD EXIT LINKAGE                                        *\n*                                                                     *\n***********************************************************************\nFINISHED EQU   *\n         L     REG13,4(REG13)          RESTORE REG 13\n         FREEMAIN RU,LV=DATAEND,A=(REG11),SP=SPINPRVT FREE STORAGE\n         LM    REG14,REG12,12(REG13)   RESTORE CALLER'S REGISTERS\n         BR    REG14\n         EJECT\n***********************************************************************\n*                                                                     *\n*        REPLYING GO TO A MESSAGE                                     *\n*                                                                     *\n***********************************************************************\nMERB306D EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSUGO            REPLY 'R XX,GO'\nISSUGO   EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINGO),TXTINGO MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTINGO   GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO THE CALLER\n*        BAS   REG14,ISSUWGO           ISSUE THE MESSAGE\nISSUWGO  EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USERGO         MOVE WTO LIST FORM FROM\n*                                      STATIC TO SYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      THE MESSAGE ATTRIBUTES\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING U TO A MESSAGE                                      *\n*                                                                     *\n***********************************************************************\nMIFB010D EQU   *\nMILR022A EQU   *\nMCAT9013 EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSUU             REPLY 'R XX,U'\nISSUU    EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINU),TXTINU   MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTINU   GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO THE CALLER\n*        BAS   REG14,ISSUWU            ISSUE THE MESSAGE\nISSUWU   EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USERU          MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      THE MESSAGE ATTRIBUTES\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING NOREQ FOR ENTER REQUEST ($HASP426)                  *\n*                                                                     *\n***********************************************************************\nMHASP426 EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSU426           REPLY 'R XX,NOREQ'\nISSU426  EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTI426),TXTI426 MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI426   GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO THE CALLER\n*        BAS   REG14,ISSUW426          ISSUE THE MESSAGE\nISSUW426 EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USER426        MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      THE MESSAGE ATTRIBUTES\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING $S FOR ENTER REQUEST ($HASP400)                     *\n*                                                                     *\n***********************************************************************\nMHASP400 EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSU400           REPLY '$ S'\nISSU400  EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTIN400),TXTIN400 MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTIN400  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSUW400          ISSUE THE MESSAGE\nISSUW400 EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USER400        MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      STATIC TO DYNAMIC\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING S TSO AFTER VTAM INIT (IST020I)                     *\n*                                                                     *\n***********************************************************************\nMIST020I EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSU020A          REPLY 'S TSO'\nISSU020A EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI020A),TXTI020A MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI020A  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n*        MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSU020B          REPLY '$S LOGON1'\nISSU020B EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI020B),TXTI020B MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI020B  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSUW020          ISSUE THE MESSAGE\nISSU020C EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI020C),TXTI020C MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI020C  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSUW020          ISSUE THE MESSAGE\nISSU020D EQU   *\n         CLC   CTXTSYSN,PRDCTN         IS THIS PRODUCTION?\n         BNE   ISSUW020                NO, DO NOT BRING THESE UP\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI020D),TXTI020D MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI020D  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSUW020          ISSUE THE MESSAGE\nISSU020E EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI020E),TXTI020E MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI020E  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSUW020          ISSUE THE MESSAGE\nISSUW020 EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USER020        MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      STATIC TO DYNAMIC\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING S NET NETSPOOL AFTER TCPIP INIT (EZB6473I)          *\n*                                                                     *\n***********************************************************************\nMEZB6473 EQU   *\n         CLC   CTXTSYSN,PRDCTN         IS THIS PRODUCTION?\n         BNE   FINISHED                NO, DO NOT BRING THESE UP\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSU647A          REPLY 'S NETSPOOL'\nISSU647A EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI647A),TXTI647A MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI647A  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSU647B          REPLY '$S LOGON1'\nISSU647B EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI647B),TXTI647B MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI647B  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSU647C          REPLY '$S LOGON1'\nISSUW647 EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USER647        MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      STATIC TO DYNAMIC\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING F RMF,S III AFTER RMF INIT (ERB100I)                *\n*                                                                     *\n***********************************************************************\nMERB100I EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSU100I          REPLY 'S NETSPOOL'\nISSU1OOI EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI100I),TXTI100I MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI100I  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSU100B          REPLY '$S LOGON1'\nISSUW100 EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USER100        MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      STATIC TO DYNAMIC\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING S LMF AFTER TSO INIT (IKT005I)                      *\n*                                                                     *\n***********************************************************************\nMIKT005I EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSU005           REPLY 'S LMF'\nISSU005  EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI005),TXTI005 MOVE IN THE REPLY BUF.\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI005  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSUW005          ISSUE THE MESSAGE\nISSUW005 EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USER005        MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      STATIC TO DYNAMIC\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING WAIT TO IEF238D                                     *\n*                                                                     *\n***********************************************************************\nMIEF238D EQU   *\nMARC0381 EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSUWT            REPLY 'R XX,WAIT'\nISSUWT   EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         LA    REG3,CTXTTMSG           FIND START OF MESSAGE\n         LA    REG4,1\n         LA    REG5,CTXTTMSG+L'CTXTTMSG-6 FIND END OF MESSAGE\nWAITCK   EQU   *\n         CLC   0(6,REG3),=C'''WAIT'''    DID WE FIND WAIT?\n         BE    WAITOK\n         CLC   0(6,REG3),=C' WAIT '      DID WE FIND WAIT?\n         BE    WAITOK\n         CLC   0(7,REG3),=C' WAIT, '     DID WE FIND WAIT?\n         BE    WAITOK\n         CLC   0(4,REG3),=C'WAIT'        DID WE FIND WAIT?\n         BE    WAITOK\n         CLC   0(8,REG3),=C'''CANCEL'''    DID WE FIND CANCEL?\n         BE    CANCOK\n         CLC   0(8,REG3),=C' CANCEL '      DID WE FIND CANCEL?\n         BE    CANCOK\n         CLC   0(9,REG3),=C' CANCEL, '     DID WE FIND CANCEL?\n         BE    CANCOK\n         CLC   0(6,REG3),=C'CANCEL'        DID WE FIND CANCEL?\n         BE    CANCOK\nCONTCK   BXLE  REG3,REG4,WAITCK        KEEP SCANNING\n         B     FINISHED                NOT CORRECT MESSAGE FORMAT\nWAITOK   EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINWT),TXTINWT MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTINWT   GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO THE CALLER\n*        BAS   REG14,ISSUWWT           ISSUE THE MESSAGE\nISSUWWT  EQU   *\n         MVC   USERAUTO,USERWT         MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         B     ISSMSG                  ISSUE THE MESSAGE\nCANCOK   EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINCN),TXTINCN MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTINCN   GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO THE CALLER\n*        BAS   REG14,ISSUWCN           ISSUE THE MESSAGE\nISSUWCN  EQU   *\n         MVC   USERAUTO,USERCN         MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      THE MESSAGE ATTRIBUTES\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING NOHOLD TO IEF433D                                   *\n*                                                                     *\n***********************************************************************\nMIEF433D EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSUWT            REPLY 'R XX,WAIT'\nISSUNH   EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINNH),TXTINNH MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTINNH   GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO THE CALLER\n*        BAS   REG14,ISSUWNH           ISSUE THE MESSAGE\nISSUWNH  EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USERNH         MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      THE MESSAGE ATTRIBUTES\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        REPLYING Y TO A MESSAGE                                      *\n*                                                                     *\n***********************************************************************\nMARC0366 EQU   *\nMARC0314 EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSUY             REPLY 'R XX,Y'\nISSUY    EQU   *\n*        CLC   MSGID+10(4),=C'CONT'\n*        BNE   FINISHED\nMARC0310 EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINY),TXTINY   MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTINY   GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO THE CALLER\n*        BAS   REG14,ISSUWY            ISSUE THE MESSAGE\nISSUWY   EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USERY          MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      THE MESSAGE ATTRIBUTES\n         B     ISSMSG                  ISSUE THE MESSAGE\n***********************************************************************\n*                                                                     *\n*        SUBMIT SMF DATASET DUMP JOB   (IEE362A)                      *\n*                                                                     *\n***********************************************************************\nMIEE362A EQU   *\n*        OI    CTXTRFB2,CTXTRHCO       SUPPRESS THE MESSAGE\n*        BAS   REG14,ISSU362           REPLY WITH SUBMIT\nISSU362  EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVI   MGCRFLG1,X'80'          SET FLAG\n         MVC   MGCRTEXT(L'TXTI362),TXTI362 MOVE IN THE REPLY BUF.\n         CLI   MSGID+35,C'1'            SMF DATASET 1?\n         BE    M362A1\n         CLI   MSGID+35,C'2'            SMF DATASET 2?\n         BE    M362A2\n         MVI   MGCRTEXT+16,C'2'         THIRD JOB\n         B     M362ACN\nM362A1   EQU   *\n         MVI   MGCRTEXT+16,C'0'         FIRST JOB\n         B     M362ACN\nM362A2   EQU   *\n         MVI   MGCRTEXT+16,C'1'         SECOND JOB\nM362ACN  EQU   *\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTI362  GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH           SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0               CLEAR REGISTER ZERO\n         MGCR  MGCRPL                  ISSUE THE COMMAND\n*        BR    REG14                   RETURN TO CALLER\n*        BAS   REG14,ISSUW362          ISSUE THE MESSAGE\nISSUW362 EQU   *\n         L     REG2,CTXTTXPJ           ESTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2           TO MESSAGE ATTRIBUTES\n         MVC   USERAUTO,USER362        MOVE WTO LIST FORM FROM\n*                                      STATIC TO DYNAMIC\n         DROP  REG2                    DROP ADDRESSABILITY TO\n*                                      STATIC TO DYNAMIC\n         B     ISSMSG                  ISSUE THE MESSAGE\n         LTORG\n***********************************************************************\n*                                                                     *\n*        SUPPRESS MESSAGE FROM GOING TO HARDCOPY (ROUTE CODE 14)      *\n*                                                                     *\n***********************************************************************\nNOHRDCPY EQU   *\n         OI    CTXTRFB2,CTXTRDTM       FORCE NO HARDCOPY (WAS CTXTRNHC)\n         B     FINISHED\n***********************************************************************\n*                                                                     *\n*        PROCEDURE - ISSUMGCR                                         *\n*        FUNCTION  - REPLIES TO MESSAGES                              *\n*        INPUT     - NONE                                             *\n*        OUTPUT    - A REPLY COMMAND IS ISSUED VIA SVC 34             *\n*        NOTES     - THE MGCR MACRO MAY BE USED TO ISSUE THE REPLY    *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* PROCEDURE - ISSUWTO, FUNCTION - ISSUES A MESSAGE, INPUT - NONE      *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*        CHARACTER CONSTANTS                                          *\n*                                                                     *\n***********************************************************************\n$HASP426 DC    CL8'$HASP426'           MESSAGE $HASP426\n$HASP400 DC    CL8'$HASP400'           MESSAGE $HASP400\n$HASP091 DC    CL8'$HASP091'           MESSAGE $HASP091\nIEE362A  DC    CL8'IEE362A '           MESSAGE IEE362A\nIKT005I  DC    CL8'IKT005I '           MESSAGE IKT005I\nIST020I  DC    CL8'IST020I '           MESSAGE IST020I\nIEF238D  DC    CL8'IEF238D '           MESSAGE IEF238D\nIEF433D  DC    CL8'IEF433D '           MESSAGE IEF433D\nERB306D  DC    CL8'ERB306D '           MESSAGE ERB306D\nIFB010D  DC    CL8'IFB010D '           MESSAGE IFB010D\nCAT9013  DC    CL8'CAT9013P'           MESSAGE CAT9013\nILR022A  DC    CL8'ILR022A '           MESSAGE ILR022A\nARC0366  DC    CL8'ARC0366A'           MESSAGE ARC0366\nARC0310  DC    CL8'ARC0310A'           MESSAGE ARC0310\nARC0314  DC    CL8'ARC0314A'           MESSAGE ARC0314\nARC0381  DC    CL8'ARC0381A'           MESSAGE ARC0381\nERB100I  DC    CL8'ERB100I '           MESSAGE ERB100I\nEZB6473I DC    CL8'EZB6473I'           MESSAGE EZB6473I\nTXTINGO  DC    CL11'REPLY XX,GO'       REPLY GO\nTXTINWT  DC    CL13'REPLY XX,WAIT'     REPLY WAIT\nTXTINCN  DC    CL15'REPLY XX,CANCEL'   REPLY CANCEL\nTXTINNH  DC    CL15'REPLY XX,NOHOLD'   REPLY NOHOLD\nTXTINU   DC    CL10'REPLY XX,U'        REPLY U\nTXTINY   DC    CL10'REPLY XX,Y'        REPLY Y\nTXTIN400 DC    CL02'$S'                REPLY $S\nTXTI426  DC    CL14'REPLY XX,NOREQ'    REPLY NOREQ\nTXTI362  DC    CL21'S INTERN,JOB=D010PUAN' REPLY TO SUBMIT JOB\nTXTI020A DC    CL09'$S LOGON1'         REPLY $S LOGON1\nTXTI020B DC    CL05'S TSO'             REPLY S TSO\nTXTI020C DC    CL09'S TCPIP'           REPLY S TCPIP\nTXTI020D DC    CL09'S MOBIUSP'         REPLY S MOBIUSP\nTXTI020E DC    CL09'S EDIMAIL'         REPLY S EDIMAIL\nTXTI647A DC    CL10'S OSASFSRV'        REPLY S OSASFSRV\nTXTI647B DC    CL10'S NETSPOOL'        REPLY S NETSPOOL\nTXTI100I DC    CL11'F RMF,S III'       REPLY F RMF,S III\nTXTI091  DC    CL09'S JES328X'         REPLY S JES328X\nTXTI005  DC    CL05'S LMF'             REPLY S LMF\nPRDCTN   DC    CL08'OSPROD  '          PRODUCTION SYSNAME\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        LIST FORM OF WTO MACRO (STATIC)                              *\n*        NOTE: ALL LIST FORMS MUST HAVE THE SAME LENGTH !!!           *\n*                                                                     *\n***********************************************************************\nUSERWT   WTO   'HHS001I ANSWERED WITH WAIT                       ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nLWTOLIST EQU   *-USERWT\nUSERNH   WTO   'HHS002I ANSWERED WITH NOHOLD                     ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSERU    WTO   'HHS003I ANSWERED WITH U                          ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSER020  WTO   'HHS004I ANSWERED WITH S TSO                      ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSERCN   WTO   'HHS005I ANSWERED WITH CANCEL                     ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSERHD   WTO   'HHS006I ANSWERED WITH HIGHDATE                   ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSER426  WTO   'HHS007I ANSWERED WITH NOREQ                      ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSER005  WTO   'HHS008I ANSWERED WITH S LMF                      ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSERY    WTO   'HHS009I ANSWERED WITH Y                          ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSER362  WTO   'HHS010I ANSWERED WITH JOB SUBMIT                 ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSERGO   WTO   'HHS011I ANSWERED WITH GO                         ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSER400  WTO   'HHS012I ANSWERED WITH $ S                        ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSERSJ   WTO   'HHS013I ANSWERED WITH S JES328X                  ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSER647  WTO   'HHS015I ANSWERED WITH S OSASFSRV                 ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\nUSER100  WTO   'HHS016I ANSWERED WITH F RMF,S III                ',    X\n               ROUTCDE=(02),DESC=(4),MF=L\n         EJECT\n***********************************************************************\n*                                                                     *\n*        STORAGE DEFINITIONS                                          *\n*                                                                     *\n***********************************************************************\nDATAAREA DSECT\n         DS    0F\nSAVEAREA DS    18F                     STANDARD SAVE AREA\n         DS    0F\nUSERAUTO DS    CL(LWTOLIST)            DYNAMIC SAVE AREA\n         EJECT\nMGCR     IEZMGCR DSECT=NO\n         ORG   MGCRTEXT\nCOMMAND  DS    CL6                     THE REPLY COMMAND\nREPLY    DS    CL2                     REPLY ID\nREPLYMSG DS    CL15                    WTOR RESPONSE\n         ORG\nDATAEND  EQU   *-DATAAREA\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        MAPPING OF THE MESSAGE TEXT                                  *\n*                                                                     *\n***********************************************************************\nMSGTEXT  DSECT\nMSGID    DS    CL8                     MESSAGE ID\nJOBDATA  DS    CL8                     JOB DATA (ID AND NAME)\n         DS    CL80\n         ORG   MSGTEXT\n         DS    CL4\nWTORID   DS    CL8\n         EJECT\n         IEZVX100\n         EJECT\n         END   IEAVMXIT\n//LKED     EXEC PGM=HEWL,PARM=(XREF,LET,LIST,NCAL,RENT,REUS),\n//             REGION=512K,COND=(7,LT,C)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=SYS1.LINKLIB,DISP=SHR\n//SYSUT1   DD  SPACE=(1024,(50,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  NAME IEAVMXIT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTIASM": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00X\\x00\\x95(O\\x01\\x02\\x10\\x1f\\x10\\x07\\x00 \\x00#\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1995-10-11T00:00:00", "modifydate": "2002-04-11T10:07:58", "lines": 32, "newlines": 35, "modlines": 0, "user": "MSTITT"}, "text": "//MSTITT   JOB  (XSYZ,MSTITT),'MATTHEW STITT',REGION=1024K,\n//             MSGCLASS=X,NOTIFY=MSTITT\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK'\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.AMACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//         DD   DSN=SYS1.AMODGEN,DISP=SHR\n//         DD   DSN=SYS1.AGENLIB,DISP=SHR\n//         DD   DSN=MSTITT.CBTXXX.FILE527,DISP=SHR\n//SYSUT1   DD   DSN=&&SYSUT1,UNIT=3390,SPACE=(1700,(1600,100)),\n//             SEP=(SYSLIB)\n//SYSUT2   DD   DSN=&&SYSUT2,UNIT=3390,SPACE=(1700,(1300,50)),\n//             SEP=(SYSLIB,SYSUT1)\n//SYSUT3   DD   DSN=&&SYSUT3,UNIT=3390,SPACE=(1700,(1300,50))\n//SYSPRINT DD   SYSOUT=*\n//SYSPUNCH DD   DUMMY\n//SYSLIN   DD   DSN=&&OBJSET,UNIT=3390,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN    DD   DSN=MSTITT.CBTXXX.FILE527(LISTICAT),DISP=SHR\n//LKED     EXEC PGM=IEWL,PARM=(LIST,MAP,LET,XREF),\n//             COND=(7,LT,ASM)\n//SYSLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN   DD   DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSUT1   DD   DSN=&&SYSUT1,UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),\n//             SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=*\n//SYSTERM  DD   SYSOUT=*\n//SYSLMOD DD  DSNAME=MSTITT.SRCE.LOAD,DISP=SHR ====> APF LIBRARY\n//SYSIN  DD  *\n   NAME LISTICAT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTICAT": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00B\\x00\\x95)\\x8f\\x01\\x05\"\\x9f\\x11D\\x04P\\x03@\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "2005-08-17T11:44:42", "lines": 1104, "newlines": 832, "modlines": 0, "user": "MSTITT"}, "text": "         PRINT GEN\n         COPY  $DOC\n&NAME    SETC  'LISTICAT'\n&VERSION SETC  '2.1.5'\n         PUNCH ' SETCODE AC(1) '\nLISTICAT AMODE 31\nLISTICAT RMODE ANY\nLISTICAT TITLE ' - LIST AN ICF CATALOG.'\n         $REGS\nLISTICAT $PROLOG R10,R11,R12\n         LR    R6,R1               SAVE JCL PARM\n         L     R4,=V(DATASECT)     COMMON DATA AREA\n         USING DATASECT,R4\n        $MESSAGE 1                                                 @122\n         L     R15,=V(PARMS)       ADDRESS OF PARM DECODER.        @130\n         BASR  R14,R15             GO TO IT.                       @130\n         LR    R1,R6               RESTORE JCL PARM\n         L     R1,0(0,R1)          GET PARM POINTER\n         LH    R2,0(0,R1)          GET PARM SIZE\n         LTR   R2,R2               ANY PARM GIVEN?\n         BZ    NOPARM              NO, ASSUME LIST\n         BCTR  R2,0                MAKE IT THE MACHINE LENGTH   15JAN88\n         ST    R2,DSPFXL           SAVE PREFIX PARM LENGTH      15JAN88\n         EX    R2,MOVEPFX          SAVE THE PARM PREFIX         15JAN88\n         B     NOPARM                                           15JAN88\nMOVEPFX  MVC   DSPFX(0),2(R1)      EXECUTED INSTRUCTION!        15JAN88\nNOPARM   DS    0H\n         TM    FLAGS1,DUMP         HEX LISTING WANTED?             @130\n         BZ    NOTHEX              NO.                             @134\n         L     R15,=V(HEXPRINT)    HEXPRINT ROUTINE                @134\n         BR    R15                 GO THERE                        @134\nNOTHEX   DS    0H                                                  @134\n         XPROPEN PWA,                                                  X\n               PAGELEN=PAGELEN,                                        X\n               DDNAME=SYSPRINT     OPEN LISTING FILE.\n         LTR   R15,R15             DID SYSPRINT OPEN?\n         BNZ   EODICAT             IF NOT, NO REPORT.\n         L     R15,=V(ALLVVDS)                                     @130\n         BASR  R14,R15             ALLOCATE ALL VVDS'S             @130\n         SPACE ,\n*        LA    R1,AUTHREQ\n*        LA    R15,3               INDICATE AUTHORIZATION ON.\n*        SVC   252                 ***** INSTALLATION DEPENDANT ******\n         SPACE ,\n         L     R2,CVTPTR           A(CVT)\n         L     R2,0(0,R2)          TCB WORDS\n         L     R2,0(0,R2)          MY TCB.\n         USING TCB,R2\n         L     R2,TCBJSCB          TCB -> JSCB.\n         DROP  R2\n         USING IEZJSCB,R2\n         L     R2,JSCBACT          ACTIVE JSCB.\n         MODESET KEY=ZERO          JSCB IS IN KEY ZERO.\n         SPACE ,\n*\n* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING\n* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER\n* A BREAK.\n*\n         OI    JSCBSWT1,JSCBPASS   SAY, NO PASSWORDS PLEASE.\n         SPACE ,\n         MODESET KEY=NZERO         BACK TO USER KEY.\n         OPEN  ACBICAT             OPEN THE BCS CLUSTER.\n         LTR   R15,R15             DID IT OPEN?\n         BZ    OPENOK              YES.\n         SHOWCB  ACB=ACBICAT,                                          X\n               AREA=OPENERR,                                           X\n               LENGTH=4,                                               X\n               FIELDS=(ERROR)      STORE OPEN ERROR CODE.\n         L     R3,OPENERR          PICK ERROR CODE.\n         ABEND 14,DUMP             AND DIE.\nOPENOK   MODESET KEY=ZERO          KEY ZERO TO MODIFY JSCB.\n         NI    JSCBSWT1,255-JSCBPASS  BYPASS PASSWORD OFF.\n         MODESET KEY=NZERO         BACK TO USER KEY.\n         DROP  R2\n*        LA    R1,AUTHREQ\n*        LA    R15,4               INDICATE AUTHORIZATION OFF.\n*        SVC   252                 ***** INSTALLATION DEPENDANT. *****\n         BAS   R9,GENRPL           GENERATE RPL FOR BCS.           @120\n         L     R0,=A(DSEXTL)       LENGTH OF EXTENT TABLE\n         GETMAIN R,LV=(0)          ACQUIRE THE STORAGE\n         ST    R1,DSEXTAD          STORE ADDRESS OF EXTENT TABLE\n         TITLE ' - READ BCS RECORDS AND SCAN FOR CELL TYPES.'\nGETNEXT  L     R1,RPLICAT          PICK UP RPL ADDRESS.\n         GET   RPL=(1)             READ A BCS RECORD.\n         AP    BCSGETS,ONE         KEEP TRACK OF GETS ISSUED.\n         LTR   R15,R15             RECORD READ OK?\n         BZ    GETOK               GO PROCESS IT.\n         ABEND 15,DUMP             TOO BAD!\nGETOK    L     R3,BUFPTR           ADDR OF CATALOG RECORD\n         L     R1,RPLICAT          ADDR OF BCS RPL.\n         L     R1,48(0,R1)         LENGTH OF RECORD READ\n         AR    R1,R3               POINT TO END OF CATALOG RECORD\n         ST    R1,ENDBCS           SAVE END OF RECORD.\n         LA    R3,2(,R3)           SKIP OVER PREFIX\nNEXTCELL CLI   2(R3),C'A'          A = NONVSAM\n         BE    NONVSAM\n         CLI   2(R3),C'C'          C = CLUSTER\n         BE    CLUSTER\n         CLI   2(R3),C'D'          D = DATA\n         BE    DATA\n         CLI   2(R3),C'I'          I = INDEX\n         BE    INDEX\n         CLI   2(R3),C'B'          B = GDG BASE\n         BE    GDGBASE\n         CLI   2(R3),X'05'         X'05' = GDG AGING TABLE      16DEC86\n         BE    GDGAGE                                           16DEC86\n         CLI   2(R3),C'H'          H = GDG ENTRY\n         BE    GDGENT\n         CLI   2(R3),C'G'          G = ALTERNATE INDEX\n         BE    AIX\n         CLI   2(R3),C'R'          R = PATH\n         BE    PATH\n         CLI   2(R3),X'04'         X'04' = VOLUME CELL          13JAN88\n         BE    VOLCEL                                           13JAN88\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\nENDCELL  XC    BLKSIZE,BLKSIZE     RESET BLKSIZE\n         XC    LRECL,LRECL         RESET LRECL\n         XC    TRACKS,TRACKS       RESET TRACKS.\n         XC    EXTENTS,EXTENTS     RESET EXTENTS\n         XC    CREDT,CREDT         RESET CREATION DATE\n         XC    EXPDT,EXPDT         RESET EXPIRATION DATE\n         XC    REFDT,REFDT         RESET REFERENCED DATE\n         SR    R1,R1               CLEAR REGISTER.\n         ICM   R1,3,0(R3)          PICK UP CELL LENGTH\n         LTR   R1,R1                                               @AVV\n         BNP   GETNEXT            SKIP ZERO LENGTH CELL (?)        @AVV\n         AR    R3,R1               POINT TO NEXT CELL\n         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?\n         BL    NEXTCELL            YES, KEEP GOING\n         B     GETNEXT             READ ANOTHER RECORD.\nEODICAT  EQU   *                   LAST BCS RECORD READ.\n         CLOSE ACBICAT\n         CLI   MCDSOPEN,255        DID WE OPEN THE MCDS?           @122\n         BNE   EODICAT1            NO.                             @122\n         CLOSE ACBMCDS             IF OPEN, CLOSE IT.              @122\nEODICAT1 DS    0H                                                  @122\n         BAS   R9,COUNTS           PRINT THE STATS.\n         XPRCLOSE  PWA             CLOSE THE PRINT FILE.\n        $MESSAGE 0                                                 @122\n         $EPILOG ,                 AND GO HOME.\n         TITLE ' - LIST A NONVSAM RECORD.'\n         USING NVNC,R3\nNONVSAM  AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM.\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n         MVI   PFXSW,0             SWITCH OFF                   15JAN88\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   NONVSAM1            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nNONVSAM1 MVC   L1DSNAME,NVNAME     SETUP DSNAME\n         MVC   COMPNAME,NVNAME     SETUP DSNAME\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,NONVSAML,ENDCELL       @130\nNONVSAML DS    0H                                                  @130\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,NONVSAMN    @130\nNONVSAMN DS    0H                                                  @130\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88\n         BE    NONVCON2         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         BE    NONVCON1            MATCH, TURN ON PRINT         15JAN88\n         SP    CNTNVSAM,ONE        NO MATCH, DON'T PUT IN COUNT 15JAN88\n         B     NONVCON2            CONTINUE PROCESS             15JAN88\nNONVCON1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88\nNONVCON2 EQU   *                                                15JAN88\n         MVC   L1TYPE,=C'NVS'      SAY WHAT TYPE IT IS.\n         DROP  R3\n         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         USING OWNERC,R3\n         MVC   CREDT,OWNCREDT      STORE CREATION DATE\n         MVC   EXPDT,OWNEXPDT      STORE EXPIRATION DATE\n         DROP  R3\n         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88\n         USING VOLCELL,R3\n         MVC   VOLTYP,VOLDEVTP     SAVE DEVICE TYPE\n         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER\n         CLC   VOLSERN,=C'******'  SYSTEM SYMBOLIC?\n         BE    NONVSAM0            YES\n         CLI   VOLSERN,C'&&'       SYSTEM SYMBOLIC?\n         BNE   NONVSAM2            NO\nNONVSAM0 EQU   *\n         BAS   R9,SYMLOOK\nNONVSAM2 EQU   *\n        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,NONVSAMV,ENDCELL      @130\nNONVSAMV DS    0H                                                  @130\n        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,NONVSAMX   @130\nNONVSAMX DS    0H                                                  @130\n         MVC   L1UNIT,=C'??????'   CALL IT ???? IF UNIT NOT FOUND.\n         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.\nNONVSAM3 CLC   VOLTYP,0(R5)        IS THIS IT\n         BE    NONVSAM4            YES. GO GET DEVICE TYPE.\n         LA    R5,12(,R5)          NEXT DEVICE ENTRY\n         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE\n         BNE   NONVSAM3            LEAVE IT AT ????\n         MVC   TRACKS,=XL4'FFFFFFFF' INVALID VOLUME DEVICE TYPE\n         AP    CNTNF,ONE\n        $MESSAGE 7,DATA=COMPNAME\n         B     NONVSAM5            CHECK NEXT DEVICE TYPE.\nNONVSAM4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE\n         SR    R1,R1               CLEAR A REGISTER.\n         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.\n         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.\n         TM    2(R5),X'20'         IS IT A DASD DEVICE?\n         BZ    NONVSAM5            IF NOT, NO VTOC TO SEARCH.\n         L     R15,=V(VTOC)                                        @134\n         BASR  R14,R15             GET DSCB FIELDS.                @134\nNONVSAM5 CLC   L1VOLUME,=C'MIGRAT' IS IT MIGRATED BY HSM\n         BNE   NONVSAM6            IF NOT, SKIP MCDS CHECK.\n         BAS   R9,CHKHSM           SETUP MCDS FIELDS.\nNONVSAM6 L     R1,LRECL            PICK UP LRECL VALUE.\n         CVD   R1,WORK             CONVERT LRECL TO PACKED\n         $EDITP  L1LRECL,DWK3,ZZZZZ FORMAT IT NICELY\n         L     R1,BLKSIZE          PICK UP BLOCK SIZE.\n         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED\n         $EDITP  L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY\n*  THE FULL WORD TRACKS IS BEING USED AS A INDICATOR FOR THE DATASET\n*  BEING CATALOGED BUT NOT FOUND ON THE PACK THAT IT'S CATALOGED ON.\n         CLC   TRACKS,=XL4'FFFFFFFF' IS THE DATAST NOT ON PACK  30NOV87\n         BNE   NONVSAM7            IF WAS FOUND, BRANCH AROUND. 30NOV87\n         XC    TRACKS,TRACKS       ELSE, CLEAR OUT TRACKS CTR.  30NOV87\n         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87\nNONVSAM7 EQU   *                                                30NOV87\n         L     R1,TRACKS           PICK UP ALLOCATED TRACKS\n         CVD   R1,WORK             CONVERT TRACKS TO PACKED\n         $EDITP  L1TRACKS,                                             X\n               DWK4,ZZZZZ          FORMAT IT NICELY.\n         L     R1,EXTENTS          PICK UP ALLOCATED EXTENTS\n         CVD   R1,WORK             CONVERT EXTENT TO PACKED\n         $EDITP  L1XTNT,                                               X\n               DWK2,ZZZ            FORMAT IT NICELY.\n         BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         MVC   L2SUB2,L1SUB2\n         MVI   L1SUB2,X'40'\n         MVC   L1SUB2+1(L'L1SUB2-1),L1SUB2\n         LM    R0,R1,BLNKLNE       PARMS TO PRINT BLANK LINE\n         BAS   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.\n         LM    R0,R1,PLINE2        PARMS TO PRINT LINE RPTLINE2\n         BAS   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n         DROP  R3\n         TITLE ' - LIST THE SECOND TO N-TH VOLUME CELLS'        13JAN88\n         USING VOLCELL,R3                                       13JAN88\nVOLCEL   EQU   *                                                13JAN88\n         CLI   VOLSW,255           WAS VOL CELL IMMED. BEFORE   13JAN88\n         BE    VOLCEL1        YES, PRINT THE CELL INFO          13JAN88\n         B     ENDCELL        NO,  PROCESS NEXT BCS CELL.       13JAN88\nVOLCEL1  MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER   13JAN88\n         MVC   L1UNIT,=C'??????'   CALL IT ???? IF UNIT NOT FOUND.\n         MVC   VOLTYP,VOLDEVTP     SAVE DEVICE TYPE\n         CLC   VOLSERN,=C'******'  SYSTEM SYMBOLIC?\n         BE    VOLCEL0             YES\n         CLI   VOLSERN,C'&&'       SYSTEM SYMBOLIC?\n         BNE   VOLCELZ             NO\nVOLCEL0  EQU   *                                                13JAN88\n         BAS   R9,SYMLOOK          RESOLVE SYMBOLIC\nVOLCELZ  LA    R5,DEVCDTBL         DEVICE TYPE TABLE.           13JAN88\nVOLCEL2  CLC   VOLTYP,0(R5)        IS THIS IT                   13JAN88\n         BE    VOLCEL3             YES. GO GET DEVICE TYPE.     13JAN88\n         LA    R5,12(,R5)          NEXT DEVICE ENTRY            13JAN88\n         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE                 13JAN88\n         BNE   VOLCEL2             CHECK NEXT DEVICE TYPE.      13JAN88\n         MVC   TRACKS,=XL4'FFFFFFFF' INVALID DEVICE TYPE\n         AP    CNTNF,ONE\n        $MESSAGE 7,DATA=COMPNAME\n         B     VOLCEL4             LEAVE IT AT ????             13JAN88\nVOLCEL3  MVC   L1UNIT,4(R5)    SET UP DEVICE TYPE IN PRINT LINE 13JAN88\nVOLCEL4  MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88\n         CLC   VOLSERN,=C'*     '  FUTURE VOLUME?\n         BE    VOLCEL7\n         SR    R1,R1               CLEAR A REGISTER.\n         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.\n         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.\n         TM    2(R5),X'20'         IS IT A DASD DEVICE?\n         BZ    VOLCEL5             IF NOT, NO VTOC TO SEARCH.\n         L     R15,=V(VTOC)                                        @134\n         BASR  R14,R15             GET DSCB FIELDS.                @134\nVOLCEL5  CLC   L1VOLUME,=C'MIGRAT' IS IT MIGRATED BY HSM\n         BNE   VOLCEL6             IF NOT, SKIP MCDS CHECK.\n         BAS   R9,CHKHSM           SETUP MCDS FIELDS.\nVOLCEL6  EQU   *\n*  THE FULL WORD TRACKS IS BEING USED AS A INDICATOR FOR THE DATASET\n*  BEING CATALOGED BUT NOT FOUND ON THE PACK THAT IT'S CATALOGED ON.\n         CLC   TRACKS,=XL4'FFFFFFFF' IS THE DATAST NOT ON PACK  30NOV87\n         BNE   VOLCEL7             IF WAS FOUND, BRANCH AROUND. 30NOV87\n         XC    TRACKS,TRACKS       ELSE, CLEAR OUT TRACKS CTR.  30NOV87\n         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87\nVOLCEL7  EQU   *                                                30NOV87\n         L     R1,TRACKS           PICK UP ALLOCATED TRACKS\n         CVD   R1,WORK             CONVERT TRACKS TO PACKED\n         $EDITP  L1TRACKS,                                             X\n               DWK4,ZZZZZ          FORMAT IT NICELY.\n         L     R1,EXTENTS          PICK UP ALLOCATED EXTENTS\n         CVD   R1,WORK             CONVERT EXTENT TO PACKED\n         $EDITP  L1XTNT,                                               X\n               DWK2,ZZZ            FORMAT IT NICELY.\n         LM    R0,R1,PLINE2        PARMS TO PRINT LINE RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT BCS CELL.       13JAN88\n         DROP  R3                                               13JAN88\n         TITLE ' - LIST A CLUSTER RECORD.'\n         USING VCNC,R3\nCLUSTER  AP    CNTCLUST,ONE        COUNT A CLUSTER.\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n         MVI   PFXSW,0             SWITCH OFF                   15JAN88\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   CLUSTER1            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nCLUSTER1 DS    0H\n         CLI   CLNAME,X'00'        DOES THE NAME START WITH X'00'\n         BNE   MVWHOLE             NO MOVE THE REAL NAME\n         MVC   L1DSNAME(23),=C'INDEXED CATALOG CLUSTER'   ELSE USE THIS\n         B     MVCLUSTR            CONTINUE WITH CLUSTER ROUTINE\nMVWHOLE  EQU   *\n         MVC   L1DSNAME,CLNAME     SETUP CLUSTER NAME.\n         MVC   COMPNAME,CLNAME     SETUP CLUSTER NAME.\nMVCLUSTR EQU   *\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88\n         BE    CLSTCON2         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         BE    CLSTCON1            MATCH, TURN ON PRINT         15JAN88\n         SP    CNTCLUST,ONE        NOMATCH DON'T INCL IN COUNT  15JAN88\n         B     CLSTCON2            CONTINUE PROCESS             15JAN88\nCLSTCON1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88\nCLSTCON2 EQU   *                                                15JAN88\n         MVC   L1TYPE,=C'CLS'      CALL IT A CLUSTER.\n         CLI   FIRST,0             FIRST CLUSTER CELL?\n         BNE   NOTCL00             NO\n         MVI   FIRST,255           THAT WAS THE ONE.\n         ST    R3,SAVECL           FIRST CLUSTER HAS BCS NAME.\nGETBCSD  SR    R1,R1               CLEAR A FEW BYTES.\n         ICM   R1,3,0(R3)          PICK UP CELL LENGTH\n         AR    R3,R1               POINT TO NEXT CELL\n         CLI   2(R3),C'D'          IS IT A DATA CELL?\n         BNE   GETBCSD             KEEP ON LOOKING.\n         DROP  R3\n         USING DINC,R3\n         SR    R1,R1                                               @121\n         IC    R1,DIDKEYLN         GET LENGTH OF CATALOG NAME.     @121\n         SH    R1,=H'2'            DROP TWO BYTES OF JUNK          @130\n         B     *+10                                                @121\n         MVC   CATNAME(0),DIDKEY   SETUP CATNAME IN HEADING.       @121\n         EX    R1,*-6                                              @121\n         BAS   R9,SETHEAD          DEFINE REPORT HEADING.\n         L     R3,SAVECL           RESTORE CELL ADDR TO CLUSTER.\nNOTCL00  EQU   *\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,CLUSTERL,ENDCELL       @130\nCLUSTERL DS    0H                                                  @130\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,CLUSTERN    @130\nCLUSTERN DS    0H                                                  @130\n         LM    R0,R1,BLNKLNE       PARMS TO PRINT BLANK LINE\n         BAS   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n         DROP  R3\n         USING DINC,R3\nDATA     MVC   L1TYPE,=C'DAT'      DATA CELL (PARDON THE EXPRESSION)\n         AP    CNTDATA,ONE         COUNT IT.\n         B     SKIPDATA            GOTO COMMON FORMATTING LOGIC.\nINDEX    MVC   L1TYPE,=C'IDX'      CALL IT AN INDEX\n         AP    CNTINDEX,ONE        AND COUNT IT.\nSKIPDATA SR    R1,R1               CLEAR A REGISTER.\n         MVI   PFXSW,0             SWITCH OFF                   15JAN88\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n         MVI   COMPNAME,C' '\n         MVC   COMPNAME+1(L'COMPNAME-1),COMPNAME\n         IC    R1,DIDKEYLN         LENGTH OF INDEX/DATA NAME\n         SH    R1,=H'2'            CORRECT LENGTH PLEASE           @130\n         EX    R1,DIDMOVE          MOVE COMPONENT NAME FOR PRINT\n         MVC   L1DSNAME,COMPNAME\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88\n         BE    CLSTRCN2         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         BE    CLSTRCN1            MATCH, TURN ON PRINT         15JAN88\n         CLI   L1TYPE,C'D'         WAS IT DATA TYPE             15JAN88\n         BNE   CLSTRCN3         NO,CHECK FOR INDEX              15JAN88\n         SP    CNTDATA,ONE         DON'T INCLUDE IN COUNT       15JAN88\n         B     CLSTRCN2            CONTINUE PROCESS             15JAN88\nCLSTRCN3 CLI   L1TYPE,C'I'         WAS IT INDEX TYPE            15JAN88\n         BNE   CLSTRCN2         NO,CONTINUE PROCESS             15JAN88\n         SP    CNTINDEX,ONE        DON'T INCLUDE IN COUNT       15JAN88\n         B     CLSTRCN2            CONTINUE PROCESS             15JAN88\nCLSTRCN1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88\nCLSTRCN2 EQU   *                                                15JAN88\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   CLUSTER2            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nCLUSTER2 EQU   *\n         DROP  R3\n         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         USING OWNERC,R3\n         MVC   CREDT,OWNCREDT\n         MVC   EXPDT,OWNEXPDT\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,DATIDXL,ENDCELL        @130\nDATIDXL  DS     0H                                                 @130\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,DATIDXN     @130\nDATIDXN  DS     0H                                                 @130\n         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88\n         DROP  R3\n         USING VOLCELL,R3\n         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER\n         MVC   VOLTYP,VOLDEVTP     SAVE DEVICE TYPE\n         CLC   VOLSERN,=C'******'  SYSTEM SYMBOLIC?\n         BE    CLUSTER0            YES\n         CLI   VOLSERN,C'&&'       SYSTEM SYMBOLIC?\n         BNE   CLUSTERS            NO\nCLUSTER0 EQU   *\n         BAS   R9,SYMLOOK          RESOLVE SYMBOLIC\nCLUSTERS EQU   *\n        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,CLUSTERV,ENDCELL      @130\nCLUSTERV DS    0H                                                  @130\n        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,CLUSTERX   @130\nCLUSTERX DS    0H                                                  @130\n         MVC   L1UNIT,=C'??????'   CALL IT ???? IF UNIT NOT FOUND.\n         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.\nCLUSTER3 CLC   VOLTYP,0(R5)        IS THIS IT?\n         BE    CLUSTER4            YES\n         LA    R5,12(,R5)          NEXT DEVICE ENTRY\n         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE\n         BNE   CLUSTER3            TRY NEXT DEVICE TYPE.\n         MVC   TRACKS,=XL4'FFFFFFFF' INVALID DEVICE TYPE\n         AP    CNTNF,ONE\n        $MESSAGE 7,DATA=COMPNAME\n         B     CLUSTER5            LEAVE IT ????\nCLUSTER4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE\n         SR    R1,R1               CLEAR A REGISTER.\n         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.\n         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.\n         CLC   VOLSERN,=C'*     '  FUTURE VOLUME?\n         BE    CLUSTER5\n         TM    2(R5),X'20'         IS IT A DASD DEVICE?\n         BZ    CLUSTER5            IF NOT, NO VTOC TO SEARCH.\n         L     R15,=V(VTOC)                                        @134\n         BASR  R14,R15             GET DSCB FIELDS.                @134\nCLUSTER5 EQU   *                                                30NOV87\n         MVC   RBASAVE,VOLVVRBA    SAVE RBA OF CI CONTAINING VVR CELL.\n         DROP  R3\n         L     R5,VVDSTAD          GET VVDSTAB START ADDR\n         USING VVDSTAB,R5\nCLUSTER8 CLI   VVDSVOL,255         LAST ENTRY?\n         BE    CLUSTERU            YES, OH WELL.\n         CLC   VVDSVOL,L1VOLUME    IS THIS THE VVDS?\n         BNE   CLUSTERY            NO, TRY AGAIN\n         ICM   R1,15,VVDSRPL       STORE RPL ADDRESS\n         ICM   R8,15,VVDSACB       GET ACB ADDRESS\n         OPEN  ((8))               OPEN VVDS\n         LTR   R15,R15             DID IT OPEN?                    @122\n         BZ    CLUSTERZ            YES.                            @122\n         AP    CNTNF,ONE\n        $MESSAGE 7,DATA=COMPNAME\n         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87\n         B     CLUSTERY\nCLUSTERZ DS    0H                                                  @122\n         ICM   R1,15,RBASAVE       GET VVR RBA\n         STCM  R1,15,VVDSARG       INSERT INTO ARG FIELD FOR RPL\n         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR\n         POINT RPL=(8)             POSITION TO DESIRED RECORD\n         GET   RPL=(8)             READ IN RECORD\n         AP    VVDSGETS,ONE        KEEP A COUNT.\n         LTR   R15,R15             RECORD READ OK?\n         BNZ   CLUSTERT\n         L     R6,VVDSBUF          ADDR OF CATALOG RECORD\n         L     R1,VVDSRPL          GET ADDR OF RPL\n         L     R1,48(0,R1)         LENGTH OF RECORD READ\n         AR    R1,R6               POINT TO END OF CATALOG RECORD\n         ST    R1,ENDVVD           SAVE END OF RECORD\n         LA    R6,2(,R6)           SKIP OVER PREFIX\n         L     R15,=V(VVDS)                                        @134\n         BASR  R14,R15             PROCESS VVDS FIELDS.            @134\n         C     R15,=F'8'           DID WE GET THEM?                @122\n         BNE   CLUSTER6            YES.                            @122\nCLUSTERT EQU   *\n        $MESSAGE 4,DATA=COMPNAME                                   @122\n         B     CLUSTER9            PRINT WHAT WE GOT.              @122\nCLUSTER6 EQU   *\n         ICM   R1,15,VVDSRPL       STORE RPL ADDRESS\n         ICM   R8,15,VVDSACB       GET ACB ADDRESS\n         CLOSE ((8))               CLOSE VVDS\n         B     CLUSTER7            PRINT WHAT WE GOT\nCLUSTERY LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY\n         B     CLUSTER8            TRY NEXT VVDS\nCLUSTERU AP    CNTNF,ONE\n        $MESSAGE 7,DATA=COMPNAME\n         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87\n         B     CLUSTER9\nCLUSTER7 EQU   *\n*  THE FULL WORD TRACKS IS BEING USED AS A INDICATOR FOR THE DATASET\n*  BEING CATALOGED BUT NOT FOUND ON THE PACK THAT IT'S CATALOGED ON.\n         CLC   TRACKS,=XL4'FFFFFFFF' IS THE DATAST NOT ON PACK  30NOV87\n         BNE   CLUSTERA            IF WAS FOUND, BRANCH AROUND. 30NOV87\n         XC    TRACKS,TRACKS       ELSE, CLEAR OUT TRACKS CTR.  30NOV87\n         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87\nCLUSTERA EQU   *\n         L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH.\n         CVD   R1,WORK             CONVERT LRECL TO PACKED\n         $EDITP  L1LRECL,DWK3,ZZZZZ FORMAT IT NICELY\n         L     R1,BLKSIZE          GET PHYSICAL BLOCK LENGTH.\n         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED\n         $EDITP  L1BLKSIZ,                                             X\n               DWK3,ZZZZZ          FORMAT IT NICELY.\n         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.\n         CVD   R1,WORK             CONVERT TRACKS TO PACKED\n         $EDITP  L1TRACKS,                                             X\n               DWK4,ZZZZZ          FORMAT IT NICELY.\n         L     R1,EXTENTS          PICK UP ALLOCATED EXTENTS\n         CVD   R1,WORK             CONVERT EXTENT TO PACKED\n         $EDITP  L1XTNT,                                               X\n               DWK2,ZZZ            FORMAT IT NICELY.\nCLUSTER9 DS    0H                                                  @122\n         BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         MVC   L2SUB2,L1SUB2\n         MVI   L1SUB2,X'40'\n         MVC   L1SUB2+1(L'L1SUB2-1),L1SUB2\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         LM    R0,R1,PLINE2        PARMS TO PRINT LINE RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n         USING DINC,R3\nDIDMOVE  MVC   COMPNAME(0),DIDKEY  -> (EXECUTED) <-\n         DROP  R3\n         TITLE ' - LIST AN ALTERNATE INDEX RECORD.'\n         USING ANC,R3\nAIX      AP    CNTAIX,ONE          COUNT AN AIX ENTRY.\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n         MVI   PFXSW,0             SWITCH OFF                   15JAN88\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   AIX0                NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nAIX0     MVC   L1TYPE,=C'AIX'      CALL IT AN AIX.\n         SR    R1,R1               CLEAR A REGISTER.\n         MVI   COMPNAME,C' '\n         MVC   COMPNAME+1(L'COMPNAME-1),COMPNAME\n         ICM   R1,1,AIXKEYLN       PICK UP AIX NAME LENGTH\n         SH    R1,=H'2'            CORRECT LENGTH.                 @130\n         B     AIX1                BRANCH AROUND EXECUTED INSTRUCTION.\n         MVC   COMPNAME(0),AIXKEY  EXECUTED\nAIX1     EX    R1,*-6              MOVE AIX NAME TO PRINT LINE.\n         MVC   L1DSNAME,COMPNAME\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,AIXENTL,ENDCELL        @130\nAIXENTL DS     0H                                                  @130\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,AIXENTN     @130\nAIXENTN DS     0H                                                  @130\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88\n         BE    AIXCONT2         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         BE    AIXCONT1            MATCH, TURN ON PRINT         15JAN88\n         SP    CNTAIX,ONE          DON'T INCLUDE IN COUNT       15JAN88\n         B     AIXCONT2            CONTINUE PROCESS             15JAN88\nAIXCONT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88\nAIXCONT2 EQU   *                                                15JAN88\n         HEX   RPTLINE1+75,                                            X\n               ANC,7,HEXTAB=TRHEX  HEX TRANSLATE AIX CELL CONTENTS.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT CELL.\n         TITLE ' - LIST A PATH RECORD.'\n         USING PNC,R3\nPATH     AP    CNTPATH,ONE         COUNT A PATH CELL.\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n         MVI   PFXSW,0             SWITCH OFF                   15JAN88\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   PATH0               NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\n         MVI   BASESW,0            SWITCH OFF.\nPATH0    MVC   L1TYPE,=C'PTH'      CALL IT A PATH.\n         MVI   COMPNAME,C' '\n         MVC   COMPNAME+1(L'COMPNAME-1),COMPNAME\n         SR    R1,R1               CLEAR A REGISTER.\n         ICM   R1,1,PATHKYLN       PICK UP PATH NAME LENGTH\n         SH    R1,=H'2'            CORRECT LENGTH                  @130\n         B     PATH1               BRANCH AROUND EXECUTED INSTRUCTION.\n         MVC   COMPNAME(0),PATHNAME  EXECUTED\nPATH1    EX    R1,*-6              MOVE PATH NAME TO PRINT LINE.\n         MVC   L1DSNAME,COMPNAME\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,PTHENTL,ENDCELL        @130\nPTHENTL DS     0H                                                  @130\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,PTHENTN     @130\nPTHENTN DS     0H                                                  @130\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88\n         BE    PATHCNT2         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         BE    PATHCNT1            MATCH, TURN ON PRINT         15JAN88\n         SP    CNTPATH,ONE         DON'T INCLUDE IN COUNT       15JAN88\n         B     PATHCNT2            CONTINUE PROCESS             15JAN88\nPATHCNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88\nPATHCNT2 EQU   *                                                15JAN88\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT CELL.\n         TITLE ' - LIST A GDG BASE OR GDG ENTRY RECORD.'\n         USING GDGNC,R3\nGDGBASE  AP    CNTGDGB,ONE         COUNT A BASE.\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n         MVI   PFXSW,0             SWITCH OFF                   15JAN88\n         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.\n         BNE   GDGBASE1            NO.\n         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.\nGDGBASE1 MVI   BASESW,255          IDENTIFY GDGBASE.\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,GDGBASEL,ENDCELL       @134\nGDGBASEL DS    0H                                                  @134\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,GDGBASEN    @134\nGDGBASEN DS    0H                                                  @134\n         MVC   L1TYPE,=C'GDB'      IDENTIFY RECORD TYPE\n         MVC   L1DSNAME,GDGNAME    SETUP GDGNAME.\n         MVC   COMPNAME,GDGNAME    SETUP GDGNAME.\n         MVC   GDGSAVE,GDGNAME     SAVE GDGNAME.\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88\n         BE    GDGBCNT2         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         BE    GDGBCNT1            MATCH, TURN ON PRINT         15JAN88\n         SP    CNTGDGB,ONE         DON'T INCLUDE IN COUNT       15JAN88\n         B     GDGBCNT2            CONTINUE PROCESS             15JAN88\nGDGBCNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88\nGDGBCNT2 EQU   *                                                15JAN88\n         DROP  R3\n         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         USING OWNERC,R3\n         MVC   CREDT,OWNCREDT      SET UP CREATION DATE\n         MVC   EXPDT,OWNEXPDT      SET UP EXPIRATION DATE\n         BAS   R9,SETCREDT         FORMAT CREATION DATE.\n*\n* THE FOLLOWING HAVE BEEN TAKEN OUT FOR LOCAL DEUTZ-ALLIS       16DEC86\n*  MODIFICATION TO GIVE GDG AGING INFORMATION ON THE REPORT     16DEC86\n*                                                               16DEC86\n*        LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1 16DEC86\n*        BAS   R9,PRINT            PRINT LINE.                  16DEC86\n*                                                               16DEC86\n         B     ENDCELL             PROCESS NEXT CELL.\n         DROP  R3\n         USING GATC,R3\nGDGAGE   EQU   *                    GDG AGING CELL ROUTINE      16DEC86\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,GDGAGEL1,ENDCELL       @134\nGDGAGEL1 DS    0H                                                  @134\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,GDGAGEN1    @134\nGDGAGEN1 DS    0H                                                  @134\n         MVC   L1GDGSCR,=CL9'SCRATCH  '  MOVE SCRATCH TO PRINT  16DEC86\n         TM    GATATTR,GATSCRTH        IS ATTRIBUTE \"SCRATCH\"?  16DEC86\n         BO    GDGAGE1                YES, PRINT ALREADY MOVED  16DEC86\n         MVC   L1GDGSCR,=CL9'NOSCRATCH'  ELSE, MOVE NOSCRATCH   16DEC86\nGDGAGE1  MVC   L1GDGEMP,=CL7'EMPTY  '  MOVE EMPTY TO PRINT LINE 16DEC86\n         TM    GATATTR,GATDELET        IS ATTRIBUTE \"EMPTY\"?    16DEC86\n         BO    GDGAGE2                YES, PRINT ALREADY MOVED  16DEC86\n         MVC   L1GDGEMP,=CL7'NOEMPTY'  ELSE, MOVE NOEMPTY       16DEC86\nGDGAGE2  SR    R8,R8                  ZERO THE REGISTER         16DEC86\n         ICM   R8,1,GATLIMIT          INSERT # MAX GDGS IN REG  16DEC86\n         CVD   R8,WORK                CONVERT IT TO DECIMAL     16DEC86\n         $EDITP  L1GDGMAX,DWK2,ZZZZ   FORMAT NICE FOR PRINT     16DEC86\n         CLC   GATCNT,=BL1'00'     NO GENERATIONS IN GDG?       09DEC87\n         BNE   GDGAGE3             NUMBER OF ENTRIES NOT ZERO.  09DEC87\n         MVI   L1DSNAME+45,C'+'    OTHERWISE MARK WITH A + SIGN 09DEC87\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN   15JAN88\n         BE    GDGAGE2A         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD LENGTH OF PREFIX        15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         BNE   GDGAGE3        YES, DON'T ADD TO COUNT           15JAN88\nGDGAGE2A AP    CNTNOENT,ONE    COUNT A GDGBASE WITH NO ENTRIES. 09DEC87\nGDGAGE3  LM    R0,R1,BLNKLNE       PARMS TO PRINT BLANK LINE\n         BAS   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         LM    R0,R1,PLINE2        PARMS TO PRINT LINE RPTLINE2 16DEC86\n         BAS   R9,PRINT            PRINT LINE.                  16DEC86\n         B     ENDCELL             PROCESS NEXT CELL            16DEC86\n         DROP  R3                                               16DEC86\n         USING GDSNC,R3\nGDGENT   AP    CNTGDGE,ONE         COUNT IT.\n         MVI   VOLSW,0             SWITCH OFF                   13JAN88\n         MVI   PFXSW,0             SWITCH OFF                   15JAN88\n         CLI   BASESW,255          PRECEEDED BY GDGBASE?\n         BNE   GDGENT0             ???????\n         MVI   BASESW,0            SWITCH OFF\nGDGENT0  MVC   L1TYPE,=C'GDG'      IDENTIFY RECORD TYPE\n         MVC   GDGWORK,GDGSAVE     START WITH BASE NAME.\n         LA    R1,GDGWORK          GET ADDRESS OF BASE NAME\n         LA    R8,44               44 BYTES AT MOST\nGDGENT1  CLI   0(R1),C' '          SCAN FOR A BLANK\n         BE    GDGENT2             YES.\n         LA    R1,1(0,R1)          TRY NEXT CHARACTER.\n         BCT   R8,GDGENT1          KEEP LOOKING\nGDGENT2  SR    R8,R8               CLEAR A REGISTER.\n         ICM   R8,3,GDSGENO        PICK UP GENERATION NUMBER.\n         CVD   R8,GWORD            PACK IT.\n         UNPK  2(4,R1),GWK3        UNPACK GENERATION NUMBER.\n         OI    5(R1),X'F0'         FIX SIGN\n         SR    R8,R8               CLEAR A REGISTER.\n         ICM   R8,1,GDSVERNO       PICK UP VERSION NUMBER.\n         CVD   R8,GWORD            PACK IT.\n         UNPK  7(2,R1),GWK2        UNPACK VERSION NUMBER.\n         OI    8(R1),X'F0'         FIX SIGN\n         MVC   0(2,R1),=C'.G'      SET G0000\n         MVI   6(R1),C'V'          G0000V00\n         MVC   L1DSNAME,GDGWORK    MOVE IN DEVELOPED NAME\n         MVC   COMPNAME,GDGWORK    MOVE IN DEVELOPED NAME\n        $TEST  FLAGS1,LEVEL,LTAB,COMPNAME,9,GDGENTL1,ENDCELL       @134\nGDGENTL1 DS    0H                                                  @134\n        $TEST  FLAGS1,NOLEVEL,NLTAB,COMPNAME,9,ENDCELL,GDGENTN1    @134\nGDGENTN1 DS    0H                                                  @134\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88\n         BE    GDGECNT2         NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88\n         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88\n         MVC   L1DSNAME,COMPNAME\n         BE    GDGECNT1            MATCH, TURN ON PRINT         15JAN88\n         SP    CNTGDGE,ONE         DON'T INCLUDE IN COUNT       15JAN88\n         B     GDGECNT2            CONTINUE PROCESS             15JAN88\nGDGECNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88\nGDGECNT2 EQU   *                                                15JAN88\n         DROP  R3\n         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         USING OWNERC,R3\n         MVC   CREDT,OWNCREDT      SET UP CREATION DATE\n         MVC   EXPDT,OWNEXPDT      SET UP EXPIRATION DATE\n         DROP  R3\n         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.\n         BAS   R9,FINDBCS          SO GO LOOK FOR IT.\n         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88\n         USING VOLCELL,R3\n         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER\n         MVC   VOLTYP,VOLDEVTP     SAVE DEVICE TYPE\n         CLC   VOLSERN,=C'******'  SYSTEM SYMBOLIC?\n         BE    GDGENT3             YES\n         CLI   VOLSERN,C'&&'       SYSTEM SYMBOLIC?\n         BNE   GDGENTU             NO\nGDGENT3  EQU   *\n         BAS   R9,SYMLOOK          RESOLVE SYMBOLIC\nGDGENTU  EQU   *\n        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,GDGENTV,ENDCELL       @130\nGDGENTV DS     0H                                                  @130\n        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,GDGENTX    @130\nGDGENTX DS     0H                                                  @130\n         MVC   L1UNIT,=C'??????'   CALL IT ???? IF UNIT NOT FOUND.\n         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.\nGDGENT5  CLC   VOLTYP,0(R5)        IS THIS IT\n         BE    GDGENT6             GO TO SET IT UP.\n         LA    R5,12(,R5)          NEXT DEVICE ENTRY\n         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE\n         BNE   GDGENT5             NO, TRY NEXT DEVICE ENTRY.\n         MVC   TRACKS,=XL4'FFFFFFFF' IS THE DATAST NOT ON PACK  30NOV87\n         AP    CNTNF,ONE\n        $MESSAGE 7,DATA=COMPNAME\n         B     GDGENT7             YES, LEAVE IT AT ????\nGDGENT6  MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE\n         SR    R1,R1\n         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.\n         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.\n         TM    2(R5),X'20'         IS IT A DASD DEVICE.\n         BZ    GDGENT7             IF NOT, NO VTOC TO SEARCH.\n         CLC   VOLSERN,=C'*     '  FUTURE VOLUME?\n         BE    GDGENT7             YES\n         L     R15,=V(VTOC)                                        @134\n         BASR  R14,R15             GET DSCB FIELDS                 @134\nGDGENT7  CLC   L1VOLUME,=C'MIGRAT'  IS IT MIGRATED BY HSM?\n         BNE   GDGENTZ             IF NOT, SKIP MCDS CHECK.\n         BAS   R9,CHKHSM           SETUP MCDS FIELDS.\nGDGENTZ  EQU   *\n*  THE FULL WORD TRACKS IS BEING USED AS A INDICATOR FOR THE DATASET\n*  BEING CATALOGED BUT NOT FOUND ON THE PACK THAT IT'S CATALOGED ON.\n         CLC   TRACKS,=XL4'FFFFFFFF' IS THE DATAST NOT ON PACK  30NOV87\n         BNE   GDGENT8             IT WAS FOUND, BRANCH AROUND. 30NOV87\n         XC    TRACKS,TRACKS       ELSE, CLEAR OUT TRACKS CTR.  30NOV87\n         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87\nGDGENT8  EQU   *\n         L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH\n         CVD   R1,WORK             CONVERT LRECL TO PACKED\n         $EDITP  L1LRECL,DWK3,ZZZZZ FORMAT IT NICELY\n         L     R1,BLKSIZE          PICK UP BLOCK SIZE.\n         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED\n         $EDITP  L1BLKSIZ,                                             X\n               DWK3,ZZZZZ          FORMAT WITH ZERO SUPPRESSION.\n         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.\n         CVD   R1,WORK             CONVERT TRACKS TO PACKED\n         $EDITP  L1TRACKS,                                             X\n               DWK4,ZZZZZ          MAKE IT PRINTABLE.\n         L     R1,EXTENTS          PICK UP ALLOCATED EXTENTS\n         CVD   R1,WORK             CONVERT EXTENT TO PACKED\n         $EDITP  L1XTNT,                                               X\n               DWK2,ZZZ            FORMAT IT NICELY.\n         BAS   R9,SETCREDT         FORMAT CREATION DATE.\n         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1\n         BAS   R9,PRINT            PRINT LINE.\n         LM    R0,R1,PLINE2        PARMS TO PRINT LINE RPTLINE2\n         BAS   R9,PRINT            PRINT LINE.\n         B     ENDCELL             PROCESS NEXT BCS CELL.\n         TITLE ' - FINDBCS. ADVANCE R3 TO A SPECIFIED BCS CELL.'\n* I ENTER HERE WITH R3 POINTING TO A CELL I HAVE JUST PROCESSED. THIS\n* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES\n* FOR A PARTICULAR CELL TYPE.\n* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE\n* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR\n* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED\n* BUT MAY NOT BE THE NEXT ONE.\n* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE\n* CALLER WANTS.\n* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.\n* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.\n         ENTRY FINDBCS                                             @134\nFINDBCS  $IN ,\n         ST    R3,BCS2             SAVE CELL ADDRESS.\nFINDBCS1 SR    R1,R1               CLEAR REGISTER\n         ICM   R1,3,0(R3)          PICK UP LENGTH OF CURRENT CELL.\n         AR    R3,R1               AND SKIP OVER IT.\n         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?\n         BL    FINDBCS2            YES.\n         ST    R0,BCS0             SAVE CALLERS PARMS\n         L     R1,RPLICAT          GET RPL ADDR.\n         GET   RPL=(1)\n         AP    BCSGETS,ONE         COUNT OFF A GET.\n         L     R0,BCS0             RESTORE CALLERS PARMS\n         LTR   R15,R15             RECORD READ OK?\n         L     R3,BUFPTR           ADDRESS OF RECORD JUST READ.\n         L     R1,RPLICAT          GET RPL ADDR.\n         L     R1,48(0,R1)         RECORD LENGTH.\n         AR    R1,R3               END OF RECORD.\n         ST    R1,ENDBCS           SAVE FOR NEXT TIME.\n         LA    R3,2(0,R3)          SKIP OVER PREFIX.\nFINDBCS2 CLM   R0,1,2(R3)          CHECK FOR REQUESTED CELL TYPE\n         BE    FINDBCS9            YES.\n         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?\n         BNE   FINDBCS1            NO, SO KEEP LOOKING.\n         L     R3,BCS2             BACKUP TO WHERE WE STARTED.\n         SR    R0,R0               LET HIM KNOW ABOUT IT.\nFINDBCS9 $OUT  ,\nBCS9     DC    F'0'                SAVE R9 IN HERE.\nBCS2     DC    F'0'                SAVE R3 IN HERE.\nBCS0     DC    F'0'                SAVE R0 IN HERE.\n         TITLE ' - PRINT LINE SUBROUTINE.'\n         ENTRY  PRINT                                              @134\nPRINT    $IN ,\n         ST    R1,PRINT1\n         CLC   DSPFX(3),=C'   '        IS THERE DS PREFIX GIVEN 15JAN88\n         BE    PRINT2              NO, CONTINUE A NORMAL        15JAN88\n         CLI   PFXSW,255               IS THE PRINTIT SWITCH ON 15JAN88\n         BNE   PRINT2A            YES, DON'T PRINT THE LINE.    15JAN88\nPRINT2   EQU   *                                                15JAN88\n         XPRNTLIN  PWA,TEXT=(R1),LENGTH=132,SPB=((R0)),SPA=1\nPRINT2A  L     R1,PRINT1\n         MVI   0(R1),C' '\n         MVC   1(132,R1),0(R1)\n         $OUT  ,\nPRINT1   DC    F'0'\n         TITLE ' - DEFINE REPORT HEADING.'\nSETHEAD  $IN ,\n         XPRHEAD PWA,LIST=(HEADER1,HEADER2,HEADER2A)\n         $OUT\n         TITLE ' - FORMAT THE CREATION DATE FROM AN OWNER CELL.'\nSETCREDT $IN ,\n         SR    R0,R0               CLEAR R0.\n         ICM   R0,7,CREDT          PICK UP CREATION DATE.\n         LTR   R0,R0\n         BZ    SETCR1\n         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD\n         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION\n         LA    R1,DTWORK           SETUP ADDRESS\n         ST    R1,DTPARM           OF PACKED FIELD\n         LA    R1,DTPARM           IN PARMLIST\n         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE\n         BASR  R14,R15             CONVERT DATE\n         MVC   L1CREDT,DTWORK      SETUP CONVERTED DATE\n         SR    R0,R0               CLEAR R0.\nSETCR1   EQU   *\n         ICM   R0,7,EXPDT          PICK UP EXPIRATION DATE.\n         LTR   R0,R0\n         BZ    SETCR2\n         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD\n         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION\n         LA    R1,DTWORK           SETUP ADDRESS\n         ST    R1,DTPARM           OF PACKED FIELD\n         LA    R1,DTPARM           IN PARMLIST\n         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE\n         BASR  R14,R15             CONVERT DATE\n         MVC   L1EXPDT,DTWORK      SETUP CONVERTED DATE\n         SR    R0,R0               CLEAR R0.\nSETCR2   EQU   *\n         ICM   R0,7,REFDT          PICK UP CREATION DATE.\n         LTR   R0,R0\n         BZ    SETCR3\n         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD\n         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION\n         LA    R1,DTWORK           SETUP ADDRESS\n         ST    R1,DTPARM           OF PACKED FIELD\n         LA    R1,DTPARM           IN PARMLIST\n         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE\n         BASR  R14,R15             CONVERT DATE\n         MVC   L1ACCDT,DTWORK      SETUP CONVERTED DATE\nSETCR3   EQU   *\n         $OUT\n         TITLE ' - SETUP FIELDS FROM THE HSM MCD RECORD.'\nCHKHSM   DS    0H\n         CLI   MCDSOPEN,254        PREVIOUS OPEN FAILED?           @122\n         BER   R9                  YES. GIVE UP HOPE.              @122\n         CLI   MCDSOPEN,0          IS MCDS ALREADY OPEN?\n         BNE   CHKHSM1A\n         OPEN  (ACBMCDS)\n         LTR   R15,R15             DID IT OPEN.                    @122\n         BZ    CHKHSM1B            YES                             @122\n        $MESSAGE 6                 NO. SAY SO.                     @122\n         MVI   MCDSOPEN,254        FLAG NO SYSUT2.                 @122\n         BR    R9                  AND GO HOME.                    @122\nCHKHSM1B DS    0H                                                  @122\n         MVI   MCDSOPEN,255        FLAG IT OPEN\nCHKHSM1A MVC   MCDSKEY,COMPNAME    DSN AS MCDS KEY.\n         GET   RPL=RPLMCDS\n         LTR   R15,R15             RECORD READ OK?\n         BNZR  R9                  RETURN\n         L     R1,MCDSPTR          GET ADDRESS OF HSM MCD RECORD.\n         USING MCDDSCT,R1\n         CLI   MCHTYPE,X'00'       MIGRATED DATASET ENTRY?\n         BNER  R9\n         CLC   MCDSIZE,=F'32760'   DATA AND INDEX ENTRIES NO GOOD.\n         BH    CHKHSM2             SO LEAVE THEM AT ZERO\n         MVC   TRACKS,MCDSIZE      ORIGINAL SIZE IN TRACKS.\nCHKHSM2  MVC   BLKSIZE+2(2),MCDBLKSZ  ORIGINAL BLOCK SIZE.\n         MVC   CREDT,MCDDLC+1      SET UP CREATION DATE\n         MVC   REFDT,MCDDLR+1      SET UP REFERENCED DATE\n         DROP  R1\n         BR    R9                  EXIT\nSYMLOOK  $IN\n         LA    R1,SYMBTBL\n         USING SYMBP,R1\n         XC    SYMBTBL(SYMBP_LEN),SYMBTBL\n         MVC   WORK,VOLSERN\n         CLI   VOLSERN,C'*'\n         BNE   SYMLOOK1\n         MVC   WORK,=C'&&SYSR1'\nSYMLOOK1 EQU   *\n         LA    R9,WORK\n         LA    R9,0(R9)\n         ST    R9,SYMBPPATTERN@    STORE THE SYMBOLIC VOLSER\n         LA    R9,L'L1VOLUME\n         LA    R9,0(R9)\n         ST    R9,SYMBPPATTERNLENGTH  LENGTH OF THE SYMBOLIC\n         ST    R9,SYMBTL             LENGTH OF THE RECEIVER\n         LA    R9,SYMBTL\n         LA    R9,0(R9)\n         ST    R9,SYMBPTARGETLENGTH@ LENGTH OF THE RECEIVER\n         LA    R9,L1VOLUME\n         LA    R9,0(R9)\n         ST    R9,SYMBPTARGET@     STORE THE RECEIVING FIELD\n         LA    R9,FDBK\n         LA    R9,0(R9)\n         ST    R9,SYMBPRETURNCODE@ STORE THE RETURN INFO\n         LINK  EP=ASASYMBM,MF=(E,SYMBTBL)\n         DROP  R1\n         LA    R9,UCBCOPY\n         USING UCBOB,R9\n         XC    UCBWORK,UCBWORK    CLEAR WORK AREA\n         UCBSCAN COPY,WORKAREA=UCBWORK,UCBAREA=UCBCOPY,                X\n               DYNAMIC=YES,RANGE=ALL,DEVCLASS=DASD,                    X\n               VOLSER=L1VOLUME\n         LTR   R15,R15            WAS A UCB RETURNED?\n         BNZ   SYMLEND            NO, QUIT NOW\n         MVC   VOLTYP,UCBTYP      SAVE DEVICE TYPE\n         DROP  R9\nSYMLEND  EQU   *\n         $OUT\n         TITLE ' - PRINT OUT STATISTICS AT EOD.'\nCOUNTS   $IN ,\n         XPREJECT  PWA\n         XPRHEAD PWA,LIST=(HEADER1)\n         $EDITP  T1COUNT,CNTNVSAM,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1NVSAM),T1NVSAM\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=2,SPA=1\n         $EDITP  T1COUNT,CNTCLUST,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1CLUST),T1CLUST\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTINDEX,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1INDEX),T1INDEX\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTDATA,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1DATA),T1DATA\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTAIX,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1AIX),T1AIX\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTPATH,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1PATH),T1PATH\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTGDGB,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1GDGB),T1GDGB\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTGDGE,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1GDGE),T1GDGE\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,BCSGETS,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1BCS),T1BCS\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,VVDSGETS,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1VVDS),T1VVDS\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTNF,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1NF),T1NF\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         $EDITP  T1COUNT,CNTNOENT,ZZZZZZ9\n         MVI   T1TEXT,C' '\n         MVC   T1TEXT+1(122),T1TEXT\n         MVC   T1TEXT(L'T1NOENT),T1NOENT\n         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX ENTERED 15JAN88\n         BE    COUNTS1          NO,DON'T PRINT PARM LINE        15JAN88\n         L     R9,DSPFXL           LOAD PARM LENGTH             15JAN88\n         EX    R9,MVPARM           MOVE PARM TO PRINT LINE      15JAN88\n         LA    R8,T1INPARM         POINT START OF OUTPUT AREA   15JAN88\n         A     R9,=XL4'0000001'    BUMPUP TO GET CORRECT OFFSET 15JAN88\n         AR    R8,R9               POINT TO MOVE AREA           15JAN88\n         MVI   0(R8),C'\"'          MOVE IN A DOUBLE QUOTE SIGN  15JAN88\n         XPRNTLIN  PWA,TEXT=TOTAL1+1,LENGTH=132,SPB=2,SPA=1     15JAN88\nCOUNTS1  EQU   *                                                15JAN88\n         $OUT\nMVPARM   MVC   T1INPARM(0),DSPFX                                15JAN88\n         SPACE\nAUTHREQ  DC    C'AUTH'\nTOTAL    DS    0CL133\n         DC    CL1' '\nT1COUNT  DC    CL7' '\n         DC    CL1' '\nT1TEXT   DC    CL124' '                                            @120\nT1NVSAM  DC    C'NONVSAM ENTRIES FOUND.'\nT1CLUST  DC    C'CLUSTER ENTRIES FOUND.'\nT1INDEX  DC    C'INDEX ENTRIES FOUND.'\nT1DATA   DC    C'DATA ENTRIES FOUND.'\nT1AIX    DC    C'ALTERNATE INDEX ENTRIES FOUND.'\nT1PATH   DC    C'PATH ENTRIES FOUND.'\nT1GDGB   DC    C'GENERATION DATA GROUP BASES FOUND.'\nT1GDGE   DC    C'GENERATION DATA GROUP ENTRIES FOUND.'\nT1BCS    DC    C'GETS ISSUED AGAINST THE BASIC CATALOG STRUCTURE.'\nT1VVDS   DC    C'GETS ISSUED AGAINST VVDS(S).'\nT1NF     DC    C'DATASETS CATALOGUED BUT NOT FOUND. (MARKED WITH AN \"*\"-\n                BEFORE DATASET TYPE)'\nT1NOENT  DC    C'GENERATION DATA GROUP BASES FOUND WITH NO ENTRIES. (MA-\n               RKED WITH A \"+\" BEFORE DATASET TYPE)'\nTOTAL1   DS    0CL133\n         DC    CL1' '\n         DC    CL13'SEARCH FOR: \"'\nT1INPARM DC    CL119' '\nPFXSW    DC    XL1'00'                                          15JAN88\nCOMPDSN  CLC   DSPFX(0),COMPNAME   EXECUTED COMMAND             15JAN88\n         TITLE ' - GENERATE AN RPL TO ACCESS THE BCS CLUSTER.'\nGENRPL   $IN ,                                                     @120\n         L     R0,BUFLEN           LENGTH TO GETMAIN\n         GETMAIN R,LV=(0)          INPUT BUFFER FOR BCS RECORDS.\n         ST    R1,BUFPTR           SAVE ADDRESS OF RECORD BUFFER.\n         GENCB BLK=RPL,                                                X\n               ACB=(S,ACBICAT),                                        X\n               AM=VSAM,                                                X\n               AREA=(*,BUFPTR),                                        X\n               AREALEN=131072,                                         X\n               OPTCD=(KEY,SEQ,MVE)\n         ST    R1,RPLICAT          SAVE GENERATED RPL ADDR.\n         $OUT                                                      @120\n         LTORG ,\n         SPACE 2\n         COPY  PRINT                                               @120\n         COPY  VTOC                                                @134\n         COPY  VVDS                                                @134\n         COPY  FINDVVDS                                            @134\n         COPY  MESSAGES                                            @122\n         COPY  HEXPRINT                                            @134\n         COPY  ALLVVDS                                             @130\n         COPY  PARMS                                               @130\n         COPY  DATASECT                                            @120\n         COPY  DSECTS                                              @120\n         END   LISTICAT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTIJCL": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x02\\x07?\\x01\\x02\\x07?\\x15Q\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-14T00:00:00", "modifydate": "2002-03-14T15:51:58", "lines": 19, "newlines": 19, "modlines": 0, "user": "MSTITT"}, "text": "//LANEJ     JOB LANEJ,TECHSUPPORT,\n//*            USER=IBMUSER,\n//         NOTIFY=LANEJ,\n//         REGION=6M,\n//             MSGLEVEL=(1,1),MSGCLASS=X,\n//             CLASS=Z\n//*JOBLIB DD DSN=LANE.TECTSG.LOAD,DISP=SHR\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//*   THIS JCL IS IN:        LANEJ.TECTSG.LISTICAT($JCL)\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n//LCAT    EXEC PGM=LISTICAT,REGION=4M PARM=APMP\n//STEPLIB DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSUT1  DD DSN=UCAT.TSO,DISP=SHR\n//SYSUT2   DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSLIST  DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//SYSIN    DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MESSAGES": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00U\\x00\\x99&o\\x01\\x02\\x07/\\x14!\\x00V\\x00V\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "2002-03-13T14:21:55", "lines": 86, "newlines": 86, "modlines": 0, "user": "MSTITT"}, "text": "*        PRINT NOGEN\n         TITLE 'MESSAGE ROUTINE.'\nMESGRTN  $PROLOG R12\n         L     R4,=V(DATASECT)\n         USING DATASECT,R4\n         CLI   MALLOC,255        HAS SYSLIST BEEN ALLOCATED?\n         BE    MALLOC1           ONCE ONLY PLEASE.\n         MVI   MALLOC,255        MARK IT AS ALLOCATED.\n         ST    R1,MR1SAVE        FOLLOWING CODE BAGS R1\n         XPROPEN PWL,                                                  X\n               PAGELEN=PAGELEN,                                        X\n               DDNAME=SYSLIST    AND OPEN IT.\n         LTR   R15,R15           WELL......\n         BZ    MSGOK             YUP.\n         WTO   'SYSLIST NOT OPENED',ROUTCDE=11\n         ABEND 13\nMSGOK    XPREJECT PWL            SKIP TO A NEW PAGE.\n         XPRHEAD PWL,                                                  X\n               LIST=SLHEAD1      AND DEFINE THE HEADING.\n         L     R1,MR1SAVE        MESSAGE NUMBER FROM CALLER.\nMALLOC1  L     R3,=V(MESSAGES)   GET ADDRESS OF MESSAGE TABLE.\n         SLL   R1,1              TIMES 2 FOR HALFWORD INDEX\n         LH    R1,0(R1,R3)       PICKUP INDEX INTO MESSGAE TABLE.\n         AR    R1,R3             DEVELOP OFFSET OF MESSAGE TEXT.\n         SR    R3,R3             ZERO REGISTER.\n         IC    R3,0(,R1)         PICKUP TEXT LENGTH\n         SR    R11,R11           ZERO REGISTER.\n         IC    R11,1(,R1)        LENGTH TO BE INSERTED.\n         LTR   R11,R11             ANYTHING TO INSERT?\n         BZ    MSKIP2            NO, PRINT MESSAGE AS IS.\n         LR    R5,R3             MESSAGE LENGTH\n         SR    R5,R11            MINUS INSERT LENGTH\n         AR    R5,R1             PLUS START ADDR\n         LA    R5,2(,R5)         PLUS 2 IS INSERT POINT.\n         BCTR  R11,0             MINUS 1 FOR EX.\n         EX    R11,MINSERT       ADD INSERT TEXT.\nMSKIP2   LA    R1,2(,R1)         SKIP OVER LENGTH BYTES.\n         XPRNTLIN PWL,                                                 X\n               TEXT=(R1),                                              X\n               LENGTH=(R3),                                            X\n               SPB=((R0)),                                             X\n               SPA=1             PRINT THE MESSAGE TEXT.\nMSKIP1   EQU   *\n         $EPILOG ,\nNOSYSLST ABEND 130,DUMP\n         LTORG ,\nMINSERT  MVC   0(0,R5),0(R2)     CUSTOMIZE A MESSAGE.\nMALLOC   DC    A(*-*)            HAS SYSLIST BEEN ALLOCATED.\nMR1SAVE  DC    AL4(0)            SAVEAREA FOR REGISTER 1.\nPWL      XPRDCB DDNAME=SYSLIST\nSLHEAD1  XPRLDEF TEXT=SLHTXT1,                                         X\n               LENGTH=L'SLHTXT1,                                       X\n               SPB=(0,ATHOF),                                          X\n               SPA=2\nSLHTXT1  DC    C'&NAME &VERSION -- MESSAGES'\nMESSAGES CSECT\n         MACRO\n         MESG  &N,&F,&T\n&L       SETA  K'&SYSLIST(3)-2\n         AIF   (&SYSLIST(2) EQ 0).NOFILL\n&L       SETA  &L+&SYSLIST(2)\nMESG&N   DC    YL1(&L),YL1(&F),C&T,CL&F' '\n         MEXIT\n.NOFILL  ANOP\nMESG&N   DC    YL1(&L),YL1(&F),C&T\n         MEND\n         DC    Y(MESG0-MESSAGES)\n         DC    Y(MESG1-MESSAGES)\n         DC    Y(MESG2-MESSAGES)\n         DC    Y(MESG3-MESSAGES)\n         DC    Y(MESG4-MESSAGES)\n         DC    Y(MESG5-MESSAGES)\n         DC    Y(MESG6-MESSAGES)\n         DC    Y(MESG7-MESSAGES)                                   @130\n         DC    Y(MESG8-MESSAGES)                                   @130\n         SPACE ,\n         MESG  0,0,'&NAME &VERSION -- ENDED SUCCESSFULLY.'\n         MESG  1,0,'&NAME &VERSION -- STARTING.'\n         MESG  2,4,'VSAM LOGICAL ERROR ON VVDS GET. FDBK = '\n         MESG  3,44,'VVR NOT FOUND WHEN EXPECTED. DSN: '\n         MESG  4,44,'INCOMPLETE DATA FOR DSN: '\n         MESG  5,8,'OPEN FAILED FOR VVDS ON VOLUME: '\n         MESG  6,0,'OPEN FAILED FOR HSM MCDS, DDN: SYSUT2'\n         MESG  7,44,'CATALOG ENTRY BUT NO DATASET FOR DSN: '       @130\n         MESG  8,80,'SYSIN INPUT: '                                @130\n         MESG  9,0,'MORE THAN 1024 VVDS''S. RUN TERMINATED.'       @131\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PARMS": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x00\\x97&\\x0f\\x01\\x02\\x07/\\x14\\x16\\x00\\xba\\x00\\xba\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "2002-03-13T14:16:29", "lines": 186, "newlines": 186, "modlines": 0, "user": "MSTITT"}, "text": "         TITLE 'SCAN CONTROL CARDS.'\nPARMS    $PROLOG R12\n         L     R4,=V(DATASECT)\n         USING DATASECT,R4\n         OPEN  (SYSIN,INPUT)\n         TM    SYSIN+48,X'10'      DID SYSIN DCB OPEN?\n         BZ    PARM99              IF SYSIN NOT SUPPLIED, DEFAULT.\nPARMS1   GET   SYSIN,CARD\n         LA    R2,CARD             CARD IMAGE TO PRINT.\n         LM    R15,R1,=A(MESGRTN,0,8)                              @130\n         BASR  R14,R15             MESSAGE 8. PRINT CARD IMAGE.    @130\n         LA    R3,CARD             ADDRESS OF PARAMETER CARD.\n         LA    R11,1               SCAN 1 BYTE AT A TIME.\n         LR    R5,R3               START OF CARD\n         LA    R5,72(,R5)          PLUS 72 BYTES IS SCAN LIMIT.\nPARMS2   DS    0H\n         CLC   =C'LEVEL(',0(R3)    LEVEL IDENTIFIERS FOLLOW.\n         BE    PARMS5              PROCESS SCANNED PARM VALUE.\n         CLC   =C'NOLEVEL(',0(R3)  NOLEVEL IDENTIFIERS FOLLOW.\n         BE    PARMS6              PROCESS SCANNED PARM VALUE.\n         CLC   =C'VOLUME(',0(R3)   VOLSERS TO SELECT FROM.\n         BE    PARMS7              PROCESS SCANNED PARM VALUE.\n         CLC   =C'NOVOLUME(',0(R3)  VOLSER NOT TO SELECT FROM.\n         BE    PARMS8              PROCESS SCANNED PARM VALUE.\n         CLC   =C'TAPE.',0(R3)     SELECT TAPE DATASETS.\n         BE    PARMSB              PROCESS SCANNED PARM VALUE.\n         CLC   =C'NOTAPE.',0(R3)   DON'T SELECT TAPE DATASETS.\n         BE    PARMSC              PROCESS SCANNED PARM VALUE.\n         CLC   =C'DASD.',0(R3)     SELECT DASD DATASETS.\n         BE    PARMSF              PROCESS SCANNED PARM VALUE.\n         CLC   =C'NODASD.',0(R3)   DON'T SELECT DASD DATASETS.\n         BE    PARMSG              PROCESS SCANNED PARM VALUE.\n         CLC   =C'CONTAINING(',0(R3) SCAN DSNAME FOR STRING?\n         BE    PARMSM              YES.\n         CLC   =C'ENDING(',0(R3)   SELECT DSNAMES BY ENDING.\n         BE    PARMSN              YES.\n         CLC   =C'NOTCONTAINING(',0(R3) EXCLUDE BY CONTENTS.\n         BE    PARMSO              YES.\n         CLC   =C'NOTENDING(',0(R3) EXCLUDE DSNAMES BY ENDING\n         BE    PARMSP              YES.\n         SPACE ,\n         CLC   =C'DUMP.',0(R3)     HEX LISTING WANTED?             @130\n         BE    PARMSD              YES.                            @130\n         SPACE ,\n         CLC   =C'BREAKLEVEL.',0(R3)\n         BE    PARMSBL             BREAK ON LEVEL WANTED.\n         SPACE ,\nPARMSL1  BXLE  R3,R11,PARMS2       SCAN THE WHOLE CARD.\n         B     PARMS1              READ ANOTHER CARD.\nPARMS5   OI    FLAGS1,LEVEL        INDICATE LEVEL WANTED.\n         LA    R8,9                LENGTH OF A LEVEL\n         LA    R3,6(,R3)           SKIP OVER 'LEVEL('\n         LA    R7,LTAB             ADDR OF LEVEL TABLE.\n         B     BLDTAB              GOTO BUILD SUBLIST TABLE.\nPARMS6   OI    FLAGS1,NOLEVEL      INDICATE NOLEVEL WANTED.\n         LA    R8,9                LENGTH OF A LEVEL\n         LA    R3,8(,R3)           SKIP OVER 'NOLEVEL('\n         LA    R7,NLTAB            ADDR OF NOLEVEL TABLE.\n         B     BLDTAB              GOTO BUILD SUBLIST TABLE.\nPARMS7   OI    FLAGS2,VOLUME       INDICATE VOLUME WANTED.\n         LA    R8,7                LENGTH OF A VOLUME\n         LA    R3,7(,R3)           SKIP OVER 'VOLUME('\n         LA    R7,VTAB             ADDR OF VOLUME TABLE.\n         B     BLDTAB              GOTO BUILD SUBLIST TABLE.\nPARMS8   OI    FLAGS2,NOVOLUME     INDICATE NOVOLUME WANTED.\n         LA    R8,7                LENGTH OF A VOLUME\n         LA    R3,9(,R3)           SKIP OVER 'NOVOLUME('\n         LA    R7,NVTAB            ADDR OF NOVOLUME TABLE.\n         B     BLDTAB              GOTO BUILD SUBLIST TABLE.\nPARMSB   OI    FLAGS1,TAPE         INDICATE TAPE WANTED.\n         B     PARMSL1             CONTINUE SCAN.\nPARMSC   NI    FLAGS1,NOTAPE       INDICATE TAPE NOT WANTED.\n         LA    R3,3(,R3)           SKIP OVER 'NO'\n         B     PARMSL1             CONTINUE SCAN.\n         SPACE ,\nPARMSD   OI    FLAGS1,DUMP         HEX LISTING WANTED.             @130\n         B     PARMSL1             CONTINUE SCAN.                  @130\n         SPACE ,\nPARMSF   OI    FLAGS1,DASD         INDICATE DASD WANTED.\n         B     PARMSL1             CONTINUE SCAN.\nPARMSG   NI    FLAGS1,NODASD       INDICATE DASD NOT WANTED.\n         LA    R3,3(,R3)           SKIP OVER 'NO'\n         B     PARMSL1             CONTINUE SCAN.\n         SPACE ,\nPARMSM   OI    FLAGS3,CONTAIN      SAY SCAN DSNAME FOR STRINGS.\n         LA    R3,11(0,R3)         SKIP OVER CONTAINING(\n         LA    R8,9                8 CHARACTER SEARCH ARGS.\n         LA    R7,CTAB             ARG TABLE.\n         B     BLDTAB              GO EXTRACT SEARCH STRING.\nPARMSN   OI    FLAGS3,ENDING       SAY SELECT BY ENDING.\n         LA    R3,7(0,R3)          SKIP OVER ENDING(\n         LA    R8,9                8 CHARACTER ENDING ARGS.\n         LA    R7,ETAB             ARG TABLE.\n         B     BLDTAB              GO EXTRACT ENDING STRING.\nPARMSO   OI    FLAGS3,NOTCONT      SAY SCAN DSNAME FOR STRINGS.\n         LA    R3,14(0,R3)         SKIP OVER NOTCONTAINING(\n         LA    R8,9                8 CHARACTER SEARCH ARGS.\n         LA    R7,NCTAB            ARG TABLE.\n         B     BLDTAB              GO EXTRACT SEARCH STRING.\nPARMSP   OI    FLAGS3,NOTEND       SAY EXCLUDE BY ENDING.\n         LA    R3,10(0,R3)         SKIP OVER NOTENDING(\n         LA    R8,9                8 CHARACTER ENDING ARGS.\n         LA    R7,NETAB            ARG TABLE.\n         B     BLDTAB              GO EXTRACT ENDING STRING.\nPARMSBL  OI    FLAGS2,BRKLVL       PAGE EJECT EACH HI-LVL QUAL.\n         B     PARMSL1             CONTINUE SCAN.\n         SPACE ,\nBLDTAB   SR    R1,R1               R1 WILL BE ADDR OF SCANNED CHAR.\n         SR    R2,R2               R2 WILL CONTAIN SCANNED CHAR.\nBLDTAB1  TRT   0(9,R3),SCANTAB     SCAN FOR ) OR ,\n         LTR   R1,R1               DELIMITER FOUND\n         BZ    SUBLERR             NO, SYNATX ERROR IN SUBLIST.\n         CLC   0(2,R1),=C', '      END OF CARD?\n         BE    BLDTAB9             YES\n         LR    R15,R1              ADDR OF SCANNED DELIMITER.\n         SR    R15,R3              R15 -> LENGTH OF SUBLIST ELEMENT\n         STC   R15,0(,R7)          SAVE IT\n         BCTR  R15,0               MINUS 1 FOR EX.\n         EX    R15,BLDMVC          STORE MESSAGE ID.\n         CLI   0(R1),C')'          END OF SUBLIST?\n         BNE   BLDTAB2             NO, SKIP END OF TABLE.\n         AR    R7,R8               SPAN OVER LAST ELEMENT.\n         MVI   0(R7),255           SET END OF TABLE.\n         B     PARMSL1             KEEP ON SCANNING\nBLDTAB2  LA    R15,1(,R15)         ADD 1 AFTER EX.\n         AR    R3,R15              SKIP OVER MESSAGE ID.\n         AR    R7,R8               NEXT TABLE ENTRY.\n         BXLE  R3,R11,BLDTAB1      FIND NEXT MESSAGE.\nBLDTAB9  GET   SYSIN,CARD\n         LA    R3,CARD             START OF CARD\n         LA    R11,1               SCAN 1 COLUMN AT A TIME.\n         LR    R5,R3               START OF CARD\n         LA    R5,72(,R5)          PLUS 72 IS LAST COLUMN TO SCAN.\n         TRT   0(72,R3),ALPHTAB    SCAN TO 1ST APHAMERIC CHARACTER.\n         BZ    SUBLERR             SUBLIST ERROR IF NONE FOUND.\n         LR    R3,R1               R1 -> 1ST ALPHA CHARACTER.\n         B     BLDTAB1             RESUME DECODING OF SUBLIST ELEME\nSUBLERR  ABEND 98,DUMP\nBLDMVC   MVC   1(0,R7),0(R3)       SAVE A SUBLIST ITEM.\nEODIN    DS    0H                                                  @130\n         CLOSE (SYSIN)             ALL DONE. GET OUT.\nPARM99   DS    0H\n*       $CALL  OPTIONS\n         SPACE ,\n         $EPILOG ,\n         LTORG ,\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GM),EODAD=EODIN\n         DS    0D\nCARD     DC    CL80' '\n         SPACE ,\nSCANTAB  DS    0D\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'00000000000000000000000000000000'  0\n         DC    X'00000000000000000000000000000000'  1\n         DC    X'00000000000000000000000000000000'  2\n         DC    X'00000000000000000000000000000000'  3\n         DC    X'00000000000000000000000000000000'  4\n         DC    X'00000000000000000000000000020000'  5\n         DC    X'00000000000000000000000100000000'  6\n         DC    X'00000000000000000000000000000000'  7\n         DC    X'00000000000000000000000000000000'  8\n         DC    X'00000000000000000000000000000000'  9\n         DC    X'00000000000000000000000000000000'  A\n         DC    X'00000000000000000000000000000000'  B\n         DC    X'00000000000000000000000000000000'  C\n         DC    X'00000000000000000000000000000000'  D\n         DC    X'00000000000000000000000000000000'  E\n         DC    X'00000000000000000000000000000000'  F\nALPHTAB  DS    0D\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'00000000000000000000000000000000'  0\n         DC    X'00000000000000000000000000000000'  1\n         DC    X'00000000000000000000000000000000'  2\n         DC    X'00000000000000000000000000000000'  3\n         DC    X'00000000000000000000000000000000'  4\n         DC    X'0000000000000000000000FF00000000'  5\n         DC    X'00000000000000000000000000000000'  6\n         DC    X'00000000000000000000000000000000'  7\n         DC    X'00000000000000000000000000000000'  8\n         DC    X'00000000000000000000000000000000'  9\n         DC    X'00000000000000000000000000000000'  A\n         DC    X'00000000000000000000000000000000'  B\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000'  C\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000'  D\n         DC    X'0000FFFFFFFFFFFFFFFF000000000000'  E\n         DC    X'FFFFFFFFFFFFFFFFFFFF000000000000'  F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINT": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00&\\x00\\x97&\\x0f\\x01\\x05#\\x1f\\x107\\x04\\xb1\\x04\\xa3\\x00\\x00\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "2005-08-19T10:37:26", "lines": 1201, "newlines": 1187, "modlines": 0, "user": "MSTITT"}, "text": "         TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'\n         SPACE\n* FUNCTION/OPERATION:  THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE\n*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION\n*        FOR PRINTED OUTPUT.  IT IS INVOKED FROM A PROBLEM PROGRAM VIA\n*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES:\n*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER\n*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING\n*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME\n*              IN DCB, AND OPENS THE DATA SET.\n*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER\n*              'OPEN' EXCEPT THE DDNAME.\n*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED\n*              PAGE HEADINGS.\n*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.\n*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.\n*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.\n*           CLOSE - CLOSES THE DATA SET.\n         SPACE\n* ENTRY POINTS:  EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM\n*        THE BASE ADDRESS.  ENTRYS ARE EFFECTED BY A  BAL  14,D(15)\n*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND\n*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE\n*        AREA.\n         SPACE\n* INPUT:  ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH\n*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.\n*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE\n*        CALL MODE.  THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS\n*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.\n         SPACE\n         SPACE\n* OUTPUT:  PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM\n*        TO A SEQUENTIAL DATA SET.  EACH LINE IS REDUCED TO ITS MIN-\n*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.\n         SPACE\n* DATA SETS:  THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED\n*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE\n*        TO 1403 OR 1404 PRINTERS.  THE DDNAME IS SUPPLIED BY THE\n*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.\n         SPACE\n* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE\n*        PAGE HEADING LINE.\n         SPACE\n* EXITS - NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY\n*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.\n*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.\n         SPACE\n* EXITS - ERROR:  ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE\n*        FOLLOWING COMPLETION CODES:\n*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.\n*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA\n*              SET WHICH WAS NOT OPEN.\n*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.\n*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.\n*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT\n*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.\n*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.\n*           4007 - SYNCHRONOUS I/O ERROR.\n         SPACE\n* TABLES/WORK AREAS:  THE CALL PARAMETER LISTS, WORK AREA, AND PRINT\n*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS\n*        AT THE END OF THE PROGRAM.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA\n*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.\n         SPACE\n* OPERATING ENVIRONMENT:  RUNS UNDER OPERATING SYSTEM/360, USING\n*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE\n*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\nXPRNTSUB CSECT\n         SPACE 2\n* REGISTER ASSIGNMENTS:\n         SPACE 2\n* N.B.  REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE\n* KEPT IN ORDER FOR LM AND STM ORDERS.\n         SPACE\nRWA      EQU   2                   GENERAL WORK REG\nRWB      EQU   3                   GENERAL WORK REG\nRWC      EQU   4                   GENERAL WORK REG\nRWD      EQU   5                   GENERAL WORK REG\nRSPACE   EQU   6                   NUMBER OF LINES TO SPACE\nRBAL     EQU   7                   NUMBER OF LINES LEFT ON PAGE\nRLPEXIT  EQU   8                   EXIT FROM LIST PROCESSING ROUTINE\nRPARM    EQU   9                   CALL PARAMETER LIST ADDR\nRPLD     EQU   10                  PLD BLOCK BASE\nRWKAREA  EQU   11                  BASE REGISTER FOR WORK AREA\nRBASE    EQU   12                  BASE REGISTER FOR CODING\nRRET     EQU   14                  STANDARD RETURN ADDR\n         SPACE\n* MASKS FOR CONTROL BYTE \"SWITCHES\":\n         SPACE\nHOFBIT   EQU   X'80'               PAGE IS AT PHYSICAL HEAD-OF-FORM\nNOSKBIT  EQU   X'40'               DISALLOW EJECT DURING HEAD PRINTING\nTXT1BIT  EQU   X'20'               ON FOR FIRST TEXT LINE ON PAGE\nHD1BIT   EQU   X'10'               ON FOR FIRST HEAD LINE WITH PAGE\n*                                  NO, ETC\nSP0BIT   EQU   X'08'               LAST LINE SPACED 0\n         SPACE 2\nEJFORCE  EQU   255                 SPACING QUANTITY TO FORCE PAGE EJECT\nOPENBIT  EQU   X'10'               TO TEST 'DCBOFLGS' FOR SUCCESSFUL\n*                                  OPEN\nMAXLNGTH EQU   254                 MAXIMUM PAGE LENGTH\nMAXWIDTH EQU   132                 MAXIMUM PAGE WIDTH\nDEFBLKSZ EQU   1692                DEFAULT DCB BLOCK SIZE\n         EJECT\n**********************\n* ENTRY AND PROLOGUE *\n**********************\n         SPACE\n* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION \"BAL 14,X(0,15)\".\n* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT\n* \"X\" SELECTS THE ENTRY POINT.  EACH ENTRY SAVES REGISTERS, LOADS THE\n* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON\n* PROLOGUE.  NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN\n* AN ABEND.\n         SPACE 2\n         DROP  RBASE\nBASEADDR B     20(0,R15)           BRANCH AROUND MODULE IDENTIFIER\n         DC    AL1(15)             LENGTH OF IDENTIFIER\n         DC    CL15'XPRNTSUB-028214'\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         SR    R1,R1               SET ABEND COMPLETION CODE\n         LR    RBASE,R15           SET BASE REG FOR ABEND ROUTINE\n         USING BASEADDR,RBASE\n         B     ABEND\n         DROP  RBASE\n         SPACE 2\n* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING\n* AT BASEADDR+32.  EACH LOADS \"RWA\" WITH THE ADDRESS OF THE SUBROUTINE\n* TO GO TO AFTER EXECUTING \"PROLOGUE\".\n         SPACE\n         ORG   XPRNTSUB+32\n         USING BASEADDR,R15\n         SPACE\nPRENTRY  STM   R14,R12,12(R13)     PRINT\n         LA    RWA,PRPROC\n         B     PROLOGUE\nSPENTRY  STM   R14,R12,12(R13)     SPACE\n         LA    RWA,SPPROC\n         B     PROLOGUE\nOPENTRY  STM   R14,R12,12(R13)     OPEN\n         LA    RWA,OPPROC\n         B     PROLOGUE\nCLENTRY  STM   R14,R12,12(R13)     CLOSE\n         LA    RWA,CLPROC\n         B     PROLOGUE\nSHENTRY  STM   R14,R12,12(R13)     SETHEAD\n         LA    RWA,SHPROC\n         B     PROLOGUE\nEJENTRY  STM   R14,R12,12(R13)     EJECT\n         LA    RWA,EJPROC\n         B     PROLOGUE\nMDENTRY  STM   R14,R12,12(R13)     MODIFY\n         LA    RWA,MDPROC\n         B     PROLOGUE\n         SPACE 2\n* PROLOGUE.  SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN\n* SAVE AREAS IN STANDARD FASHION.  LOAD \"RBAL\" WITH CURRENT PAGE\n* BALANCE AND \"RPARM\" WITH THE CALLING PARAMETER LIST ADDRESS.\n         SPACE\n         DROP  R15\nPROLOGUE LR    RBASE,R15           LOAD CODING BASE REG\n         USING BASEADDR,RBASE\n         SPACE\n         LR    RWKAREA,R0          BASE REG FOR WORK AREA\n         USING WORKAREA,RWKAREA\n         SPACE\n         LR    RWB,R13             ADDR OF CALLER'S SAVE AREA\n         LA    R13,SAVEAREA        ADDR OF OUR SAVE AREA\n         ST    R13,8(RWB)          CHAIN TO US FROM CALLER\n         ST    RWB,SAVEAREA+4      CHAIN TO CALLER FROM US\n         SPACE\n         LR    RPARM,R1            LOAD PARAMETER LIST ADDR\n         LH    RBAL,PAGEBAL        LOAD PAGE LINE COUNT BALANCE\n         MVC   DCBSYNAD(3),=AL3(SYNAD)  PUT ERROR ROUTINE ADDRESS IN\n*                                  DCB\n         SPACE\n         TM    DCBOFLGS,OPENBIT    MAKE SURE DATA SET IS OPEN\n         BCR   1,RWA               BRANCH IF OPEN\n         CL    RWA,=A(OPPROC)      IF NOT, ONLY OPEN CALL ALLOWED\n         BCR   8,RWA               BR IF OPEN CALL\n         LA    R1,2                ERROR CODE 2, GO TO ABEND\n         SPACE 3\n* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.\n* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP\n         SPACE\n         CNOP  2,4                 ALIGN CONSTANT FOLLOWING SVC\nABEND    AL    R1,*+6              LOAD ABEND CODES\n         SVC   13                  ISSUE ABEND SVC\n         DC    X'80'               'DUMP' BIT FOR ABEND\n         DC    AL3(4000)           BASE FOR COMPLETION CODE\n         EJECT\n************\n* EPILOGUE *\n************\n         SPACE\n* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE.  IT EXITS WITH\n* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND\n* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.\n         SPACE 2\nEXIT4    LA    R15,4               SET RETURN CODE 4\n         B     EXIT\n         SPACE\nEXIT0    SR    R15,R15             SET RETURN CODE 0\n         SPACE\nEXIT     LH    R0,PAGENO           LOAD CURRENT PAGE NUMBER\n         LR    R1,RBAL             LOAD NUMBER OF LINES LEFT\n         STH   RBAL,PAGEBAL        SAVE PAGE BALANCE\n         XC    DCBSYNAD(3),DCBSYNAD  CLEAR ERROR ROUTINE ADDRESS\n         SPACE\n         L     R13,SAVEAREA+4      ADDRESS OF CALLER'S SAVE AREA\n         L     R14,12(R13)         LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE CALLER'S REGISTERS\n         MVI   12(R13),X'FF'       SET RETURN INDICATION\n         BR    R14                 RETURN TO CALLER\n         EJECT\n******************\n* PRINT FUNCTION *\n******************\n         SPACE\n* PRINT LINE DELIVERY CALL.  THE PARAMETER LIST IS A VARIABLE-LENGTH\n* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).\n* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED.  CALL\n* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.\n         SPACE 2\nPRPROC   BAS   RLPEXIT,LISTPROC    INVOKE LIST PROCESSOR\n         SPACE\n         B     EXIT0               EXIT TO CALLER\n         EJECT\n******************\n* SPACE FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES.  IF THE NUMBER\n* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS\n* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST.  IF THE PAGE\n* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT\n* IS SET IN THE PARAMETER LIST.  IN THE LATTER CASE, THE PAGE HEADINGS\n* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.\n         SPACE 2\n         USING SPPARM,RPARM        ADDRESSING FOR PARM LIST\n         SPACE\nSPPROC   TM    SWITCHES,HOFBIT     TEST IF AT HEAD-OF-FORM\n         BZ    SPSUBTR             BR IF NOT\n         TM    SPCOND,SPATHOF      IS SPACE ALLOWED AT HOF?\n         BZ    EXIT0               EXIT IF NOT\n         BAS   RRET,HEADPRNT       IF SO, PRINT HEADINGS FIRST\n         SPACE\nSPSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,SPQUAN       LOAD SPACING AMOUNT\n         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE\n         SPACE\n         BP    SPMOVE              BRANCH IF BAL STILL > 0\n         TM    SPCOND,SPNOEJ       TEST IF EJECT ALLOWED\n         BO    SPMOVE              BRANCH IF NOT\n         LA    RSPACE,EJFORCE      IF ALLOWED, FORCE EJECT\n         SPACE\nSPMOVE   BAS   RWA,MOVE            CALL PAPER MOVING SUB\n         B     EXIT0               EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n******************\n* EJECT FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER TO HEAD-OF-FORM.  IF THE PAGE IS ALREADY\n* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE\n* PARAMETER LIST IS ON.  IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT\n* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE.  IF THE MASK BITS\n* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS\n* REQUESTED.  THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY\n* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT\n* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.\n         SPACE 2\n         USING EJPARM,RPARM        FOR PARM LIST ADDRESSING\n         SPACE\nEJPROC   TM    SWITCHES,HOFBIT     TEST IF AT HOF\n         BZ    EJTEST              BR IF NOT\n         TM    EJCOND,EJATHOF      IF SO, IS EJECT ALLOWED?\n         BZ    EXIT0               IF NOT, EXIT\n         SPACE\nEJTEST   SR    R0,R0\n         IC    R0,EJQUAN           LOAD TEST QUANTITY\n         IC    R1,EJCOND           GET CONDITIONAL TEST MASK\n         N     R1,=XL4'000000F0'   KEEP BITS 24-27 ONLY\n         CR    RBAL,R0             COMPARE BALANCE WITH TEST QUAN\n         EX    R1,EJBC             EXECUTE BC WITH MASK FROM PARM\n         B     EXIT0               EXIT IF CONDITION NOT MET\n         SPACE\nEJMOVE   LA    RSPACE,EJFORCE      TO FORCE EJECT\n         BAS   RWA,MOVE            CALL PAPER MOVER SUB\n         B     EXIT0               EXIT TO CALLER\n         SPACE 2\nEJBC     BC    0,EJMOVE            BRANCH IF EJECT REQUIRED\n         SPACE\n         DROP  RPARM\n         EJECT\n*****************\n* OPEN FUNCTION *\n*****************\n         SPACE\n* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET.  IT SETS THE DDNAME\n* IN THE DCB AND OPENS THE DATA SET.   ALL COUNTERS AND SWITCHES ARE\n* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH\n* MAY HAVE BEEN SUPPLIED WITH THE CALL.  THE PAGE BALANCE IS SET TO\n* ZERO, BUT THE PAGE IS NOT MOVED.  THE PROGRAMMER SHOULD NORMALLY\n* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.\n         SPACE\n* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL\n* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A\n* 'MODIFY' CALL.\n         SPACE 2\n         USING OMPARM,RPARM\n         SPACE\nOPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS\n         MVI   HLTEXT,C' '         CLEAR HEADING TEXT\n         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT\n         SPACE\n         TIME  DEC                 GET CURRENT DATE & TIME\n         STM   R0,R1,HPRSAVE       SAVE TIME AND DATE\n         SPACE\n* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'.  OTHERWISE, INSERT\n* DDNAME AND OPEN IT.\n         SPACE\n         TM    DCBOFLGS,OPENBIT    TEST IF OPEN\n         BO    OPJOIN              BR TO 'MDPROC' IF OPEN\n         MVC   DCBDDNAM(8),OMDDNAME  INSERT DDNAME INTO CLOSED DCB\n         MVC   DCBEXLST(3),=AL3(EXLST)  INSERT ADDRESS OF EXIT LIST\n         SPACE\n         MVI   DWORK,X'80'         SET END-OF-LIST BIT\n         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)\n         SPACE\n         XC    DCBEXLST(3),DCBEXLST  CLEAR ADDRESS OF EXIT LIST\n         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPEN\n         BO    OPJOIN              TO 'MDPROC' IF O.K.\n         B     EXIT4               EXIT WITH RC=4 IF OPEN FAILS\n         SPACE\n         DROP  RPARM\n         EJECT\n* DCB EXIT ROUTINE FOR OPEN.  SET BLOCK SIZE TO THE DEFAULT VALUE IF\n* NOT SPECIFIED IN DS LABEL OR DD CARD.\n         SPACE\nEXLST    DS    0F                  EXIT LIST, ON BOUNDARY\n         DC    X'85'\n         DC    AL3(DCBMOD)\n         SPACE\nDCBMOD   LH    RWA,DCBBLKSZ        LOAD BLOCK SIZE\n         LTR   RWA,RWA             TEST IF ZERO\n         BNZ   DCBNZ               BRANCH IF NOT ZERO\nSETDEF   LA    RWA,DEFBLKSZ        SET DEFAULT BLOCK SIZE\n         STH   RWA,DCBBLKSZ        STORE IN DCB\n         BR    R14                 RETURN TO OPEN ROUTINE\nDCBNZ    CH    RWA,=H'141'         TEST FOR MINIMUM BLOCKSIZE\n         BL    SETDEF              USE DEFAULT IF TOO LOW\n         BR    R14                 RETURN TO OPEN IF OK\n         EJECT\n*******************\n* MODIFY FUNCTION *\n*******************\n         SPACE\n* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING: DATE, TIME, PAGE\n* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.\n* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST.  IF A PARAMETER IS\n* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.\n         SPACE\n* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,\n* WHICH JOINS THIS CODING AT 'OPJOIN'.  IN THAT CASE, THE VALUES\n* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.\n         SPACE\n         USING OMPARM,RPARM\n         SPACE\nMDPROC   SR    R0,R0               GENERATE TWO ZERO WORDS\n         SR    R1,R1\n         STM   R0,R1,HPRSAVE       SET DATE & TIME FIELDS TO ZERO\n         SPACE\n* ENTER HERE FROM 'OPEN'.  THE OBJECT OF THE FOLLOWING IS TO GET THE\n* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND\n* 'HPRSAVE+4', RESPECTIVELY.  THOSE FIELDS MAY HAVE BEEN FILLED IN BY\n* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'\n* ABOVE.  NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE\n* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.\n         SPACE\nOPJOIN   LM    RWA,RWB,OMTIMEAD    LOAD TIME & DATE ADDRS FROM PARM\n         LTR   RWA,RWA             TEST FOR TIME ADDR SUPPLIED\n         BZ    NOTIME              BRANCH IF ZERO\n         MVC   HPRSAVE(4),0(RWA)   GET TIME AS DECIMAL 'HHMMSSTH'\nNOTIME   LTR   RWB,RWB             TEST IF DATE ADDR SUPPLIED\n         BZ    DATEEDIT            BR IF NOT\n         MVC   HPRSAVE+4(4),0(RWB)  GET DECIMAL DATE AS '00YYDDD+'\n         SPACE\n* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT.  BOTH\n* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.\n         SPACE\nDATEEDIT LM    RWA,RWB,HPRSAVE     LOAD TIME & DATE FOR TESTING\n         LTR   RWB,RWB             TEST IF DATE WAS GIVEN\n         BZ    TIMEEDIT            BRANCH IF ZERO\n         SPACE\n         MVC   HLDAY(4),=C'DAY='   INSERT DAY NUMBER\n         UNPK  HLDAY+4(3),HPRSAVE+6(2)  UNPACK DAY NUMBER\n         OI    HLDAY+6,X'F0'       TIDY UP SIGN BITS\n         SPACE\n         ST    RWB,DWORK+4         STORE DATE ARG FOR EDIT RTNE\n         LA    R1,DWORK            CONSTRUCT ONE-WORD PARM LIST\n         ST    R1,HPRSAVE+4        FOR XDATEDIT CALL\n         LA    R1,HPRSAVE+4        LOAD PARM LIST ADDRESS\n         L     R15,=V(XDATEDIT)    LOAD ADDRESS OF DATE EDIT RTNE\n         BASR  R14,R15             TO EDIT DATE AS 'MM/DD/YY'\n         MVC   HLDATE(8),DWORK     INSERT RESULT IN HL TEXT\n         SPACE\n* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.\n         SPACE\nTIMEEDIT LTR   RWA,RWA             TEST IF TIME GIVEN\n         BZ    TSTPGNO             BR IF ZERO\n         SRL   RWA,4               ADD LEADING ZERO TO TIME\n         ST    RWA,HPRSAVE         STORE TIME IN WORK LOC\n         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR\n         ED    HLTIME(7),HPRSAVE   EDIT INTO ALPHA\n         SPACE\n* MODIFY PAGE NUMBER.  VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS\n* INCREMENTED BEFORE USE.\n         SPACE\nTSTPGNO  LH    RWA,OMPAGENO        GET VALUE FROM PARM LIST\n         LTR   RWA,RWA             TEST IF ZERO\n         BZ    TSTPGWID            BR IF ZERO\n         BCTR  RWA,0               DECREMENT BY 1\n         STH   RWA,PAGENO          STORE\n         SPACE\n* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.\n         SPACE\nTSTPGWID SR    RWA,RWA\n         IC    RWA,OMPAGWID        GET WIDTH FROM PARM LIST\n         LTR   RWA,RWA             TEST IF ZERO\n         BZ    TSTPGLNG            BRANCH IF SO\n         CLI   OMPAGWID,MAXWIDTH   TEST MAXIMUM SIZE\n         BNH   PGWIDOK\n         LA    R1,3                ERROR, TOO LARGE\n         B     ABEND\nPGWIDOK  STH   RWA,PAGWIDTH\n         SPACE\n* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.\n         SPACE\nTSTPGLNG SR    RWA,RWA\n         IC    RWA,OMPAGLNG        GET FROM PARM LIST\n         LTR   RWA,RWA             TEST IF SUPPLIED\n         BZ    TSTMAXLN            BR IF NOT\n         CLI   OMPAGLNG,MAXLNGTH   TEST FOR LEGAL VALUE\n         BNH   PGLNGOK\n         LA    R1,4                ERROR, ABORT\n         B     ABEND\nPGLNGOK  STH   RWA,PAGELNG         STORE\n         SPACE\n* MODIFY PRINT LINE LIMIT COUNTER.\n         SPACE\nTSTMAXLN L     RWA,OMMAXLIN        GET FROM PARM LIST\n         LTR   RWA,RWA             TEST IF SUPPLIED\n         BZ    EXIT0               EXIT IF NOT\n         ST    RWA,MAXLINES        STORE\n         B     EXIT0               EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n********************\n* SETHEAD FUNCTION *\n********************\n         SPACE\n* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING\n* AND SUB-HEADING LINES.  THE PARAMETER LIST IS A VARIABLE-LENGTH LIST\n* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS.  THE FIRST LINE WILL\n* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.\n* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE\n* FIELDS.  THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.\n* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT\n* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS\n* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE\n* ON THE PRECEDING PAGE.  THE ADDRESS OF THE PARAMETER LIST IS SAVED\n* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH\n* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED\n* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY\n* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE.  EACH CALL TO\n* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL.  A CALL WITH\n* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE\n* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND\n* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.\n         SPACE 2\nSHPROC   LTR   RPARM,RPARM         TEST FOR NULL LIST ADDR\n         BNZ   SHOK                BRANCH IF NON-ZERO\n         LA    RPARM,NOHDLIST      ADDRESS OF PLD FOR BLANK LINE\nSHOK     ST    RPARM,HEADLIST      STORE ADDR OF HEADING PARMS\n         B     EXIT0               EXIT\n         EJECT\n******************\n* CLOSE FUNCTION *\n******************\n         SPACE\n* THIS CALL CLOSES THE PRINTER DATA SET.  IT DOES NOT MOVE THE PAGE\n* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.\n* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.\n         SPACE 2\nCLPROC   TM    DCBOFLGS,OPENBIT    IS DCB OPEN NOW?\n         BZ    EXIT0               EXIT IF ALREADY CLOSED\n         MVI   DWORK,X'80'         SET END-OF-LIST BIT\n         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)\n         SPACE\n         FREEPOOL  PRINTDCB        FREE THE BUFFER CORE\n         SPACE\n         B     EXIT0               EXIT TO CALLER\n         EJECT\n************\n* LISTPROC *\n************\n         SPACE\n* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT\n* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.\n* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND\n* 'RLPEXIT' CONTAINING THE EXIT ADDRESS.  IT MAY DISCOVER THAT ITS\n* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING\n* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED.  WHEN THIS OCCURS,\n* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND\n* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.\n* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,\n* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF\n* YET ANOTHER CALL TO 'HEADPRNT'.)  AFTER THE HEADINGS ARE PRINTED,\n* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND\n* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS\n* CONTINUED.\n         SPACE 2\n         USING PLDBLOCK,RPLD       TO ADDRESS PLD BLOCKS\n         SPACE\nLISTPROC L     RPLD,0(RPARM)       LOAD A PLD BLOCK ADDRESS\n         SPACE\n*        LTR   RPLD,RPLD           TEST CURRENT PLD ADDRESS\n*        BCR   4,RLPEXIT           EXIT IF NEGATIVE\n         TM    0(RPARM),X'80'      EXIT IF NEGATIVE\n         BOR   RLPEXIT             EXIT IF NEGATIVE\n* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.\n         SPACE\n         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT     SEE IF HEAD-OF-FORM FLAG IS ON\n         BO    HEADPRNT            EXIT IF SO\n         SPACE 2\n* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,\n* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION.  IF NOT, BYPASS\n* PRE-SPACING ALTOGETHER.\n         SPACE\n         TM    SWITCHES,TXT1BIT    TEST IF FIRST TEXT LINE\n         BZ    PRSUBTR             BRANCH IF NOT\n         TM    PLDFLAGS,PRHOFBIT   TEST IF ALLOW SKIP AT HOF\n         BZ    POSTSP              SKIP PRESPACING IF NOT\n         SPACE\n* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.\n         SPACE\nPRSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPB       LOAD AMOUNT TO SPACE\n         SR    RBAL,RSPACE         DECREMENT PAGE BALANCE\n         SPACE\n* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE\n* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIP\n         BO    PREMOVE             BRANCH IF NOT\n         TM    PLDFLAGS,PRSKPBIT   TEST IF USER ALLOWS SKIP\n         BO    PREMOVE             BRANCH IF NOT\n         LTR   RBAL,RBAL           TEST PAGE BALANCE\n         BP    PREMOVE             BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE      FORCE A PAGE SKIP\n         SPACE\n* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.\n         SPACE\nPREMOVE  BAS   RWA,MOVE            TO PAPER MOVING SUBROUTINE\n         SPACE\n* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.\n         SPACE\n         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT     TEST HEAD-OF-FORM BIT\n         BO    HEADPRNT            EXIT IF AT HEAD\n         SPACE 2\n* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE\n* IS PRINTED.  BEGIN BY COMPUTING THE NEW PAGE BALANCE.\n         SPACE\nPOSTSP   SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPA       LOAD AMOUNT TO SPACE AFTER PRINT\n         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE\n         SPACE\n* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,\n* AND FORCE A SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIPPING\n         BO    GETPRCC             BRANCH IF NOT\n         TM    PLDFLAGS,SPSKPBIT   TEST IF USER ALLOWS SKIPPING\n         BO    GETPRCC             BRANCH IF NOT\n         LTR   RBAL,RBAL           TEST FOR PAGE END\n         BP    GETPRCC             BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE      FORCE PAGE SKIP\n         SPACE\n* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER.  IN THE INTERESTS\n* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT\n* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS.  IN THE\n* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER\n* AND MERELY SPACE.  IF THIS IS TO BE THE FIRST HEADING LINE OF THE\n* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO\n* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.\n         SPACE\nGETPRCC  DS    0H\n         SR    RWA,RWA\n         IC    RWA,PLDLNGTH        LOAD NOMINAL LENGTH OF TEXT\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET\n         SPACE\n         LA    R0,0(RWA,RWB)       LINE LENGTH = TEXT + OFFSET\n         CH    R0,PAGWIDTH         TEST AGAINST PAGE WIDTH\n         BNH   TSTHD1              BR IF OK\n         LA    R1,5                ERROR, LINE TOO LONG\n         B     ABEND\n         SPACE\nTSTHD1   TM    SWITCHES,HD1BIT     TEST IF FIRST HEADING LINE\n         BZ    BLNKSCAN            BR IF NOT\n         LH    RWB,PAGWIDTH        SET RECORD LENGTH AS PAGE WIDTH\n         B     GETBUF              SKIP BLANK SCANNING\n         SPACE\n* SET UP A 'BXH' FOR SCAN.  R0 IS INCREMENT, R1 IS COMPARAND, RWA\n* VARIABLE.\n         SPACE\nBLNKSCAN LH    R0,=H'-1'           INCREMENT IS MINUS 1\n*        L     R1,PLDTXTAD-1       LOAD TEXT ADDRESS\n         L     R1,PLDTXTAD         LOAD TEXT ADDRESS\n         LA    R1,0(R1)            ZERO HIGH-ORDER BYTE\n         BCTR  R1,0                DECREMENT BY ONE\n         AR    RWA,R1              SET RWA TO RIGHT-MOST TEXT BYTE\n         SPACE\n* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK.  RESULT IS NEW TEXT\n* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.\n         SPACE\nBLNKLOOP CLI   0(RWA),C' '         TEST FOR NON-BLANK CHAR\n         BNE   BLNKDONE            EXIT WHEN FOUND\n         BXH   RWA,R0,BLNKLOOP\nBLNKDONE SR    RWA,R1              NOW RWA IS NEW TEXT LENGTH\n         BC    13,POSTMOVE         NO PRINTING IF <= 0\n         SPACE\n* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.\n         SPACE\n         AR    RWB,RWA             ADD TEXT LENGTH\n         SPACE\n* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF\n* THE LINE.  THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE\n* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS.  GET\n* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.\n         SPACE\nGETBUF   LA    RWC,5(RWB)          LOAD LENGTH OF RECORD IN RWC\n         STH   RWC,DCBLRECL        PUT LRECL IN DCB FOR PUT CALL\n         SPACE\n         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE\n         LR    RWD,R1              RWD BECOMES BUFFER BASE REG\n         MVI   3(RWD),C' '         CLEAR BUFFER TO BLANKS\n         EX    RWB,BLNKMOVE\n         SLL   RWC,16              SET UP 4-BYTE 'V' CONTROL FIELD\n         ST    RWC,DWORK           CAN'T ASSUME BUFFER ON ANY\n         MVC   0(4,RWD),DWORK      BOUNDARY\n         SPACE\n* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT\n* THE PAGE NUMBER.\n         SPACE\n         TM    SWITCHES,HD1BIT     TEST IF FIRST LINE\n         BZ    MOVETEXT            BRANCH IF NOT\n         SPACE\n         LA    RWC,0(RWB,RWD)      ADDRESS RIGHT END -5\n         SH    RWC,=AL2(HLTXTLNG+10-5)  LOCATE PLACE FOR HEADING INFO\n         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME\n         SPACE\n         LH    R1,PAGENO           INCREMENT PAGE NUMBER\n         LA    R1,1(R1)\n         STH   R1,PAGENO\n         CVD   R1,DWORK            CONVERT TO DECIMAL\n         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS\n         LA    R1,HLTXTLNG+9(RWC)  IN CASE SIGNIFIGANCE FORCED\n         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR \"PAGE\"\n         SH    R1,=H'5'\n         MVC   0(4,R1),=C'PAGE'    INSERT WORD \"PAGE\"\n         SPACE\n* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.\n* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.\n         SPACE\nMOVETEXT BAS   RWB,CCGEN           GO GET CONTROL CHAR\n         STC   R0,4(RWD)           INSERT IN BUFFER\n         NI    4(RWD),B'11111101'  CHANGE SPACE IMMEDIATE TO WRITE\n         SPACE\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET\n         LA    RWB,5(RWB,RWD)      ADDRESS FOR FIRST TEXT BYTE\n         BCTR  RWA,0               DECREMENT LENGTH BY 1 FOR MVC\n*        L     RWC,PLDTXTAD-1      LOAD ADDRESS OF CALLER'S TEXT\n         L     RWC,PLDTXTAD        LOAD ADDRESS OF CALLER'S TEXT\n         EX    RWA,MOVEINST        MOVE TEXT\n         SPACE\n         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS\n         SPACE\n* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.\n         SPACE\n         L     R1,MAXLINES\n         S     R1,=F'1'            BCTR WOULD NOT SET COND CODE\n         ST    R1,MAXLINES\n         BP    POSTMOVE            BRANCH IF POSITIVE\n         LA    R1,6                ABORT, TOO MUCH OUTPUT\n         B     ABEND\n         SPACE\n* DO ANY ADDITIONAL SPACING NECESSARY.  AMOUNT STILL IN 'RSPACE'.\n         SPACE\nPOSTMOVE BAS   RWA,MOVE            CALL PAPER MOVING SUBROUTINE\n         SPACE 2\n* NOW WE ARE FINISHED WITH THAT LINE.  IF THE ADDRESS WHICH POINTED TO\n* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.\n* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.\n         SPACE\n         SPACE\n         LA    RPARM,4(RPARM)      INCREMENT LIST POINTER\n         B     LISTPROC            TO PROCESS NEXT LINE\n         SPACE 2\n* EXECUTED INSTRUCTIONS:\n         SPACE\nBLNKMOVE MVC   4(0,RWD),3(RWD)     SPREAD BLANKS IN OUTPUT BUFFER\nMOVEINST MVC   0(0,RWB),0(RWC)     MOVE CALLER'S TEXT TO OUTPUT BUF\n         SPACE\n         DROP  RPLD\n         EJECT\n************\n* HEADPRNT *\n************\n         SPACE\n* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT\n* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE.  SAVE THE REGISTERS\n* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING\n* THE HEADING AND SUB-HEADING LINES.\n         SPACE 2\nHEADPRNT ST    RRET,HPREXIT        SAVE RETURN ADDRESS\n         STM   RLPEXIT,RPARM,HPRSAVE  STORE LISTPROC REGISTERS\n         SPACE\n* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS\n* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER.  RESET PAGE BALANCE.\n         SPACE\n         NI    SWITCHES,255-HOFBIT  RESET HOF BIT\n         OI    SWITCHES,HD1BIT+NOSKBIT  SET HEADING AND NOSKIP BITS\n         LH    RBAL,PAGELNG        RESET PAGE BALANCE\n         SPACE\n* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.\n         SPACE\n         L     RPARM,HEADLIST      ADDRESS OF HEADINGS LIST\n         BAS   RLPEXIT,LISTPROC    CALL PROCESSING ROUTINE\n         SPACE\n* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF\n* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE\n* PAGE YET.  THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO\n* PROCESSING THE CALLER'S LINES.\n         SPACE\n         NI    SWITCHES,255-NOSKBIT  RESET NO-SKIP BIT\n         OI    SWITCHES,TXT1BIT    SET FIRST-TEXT-LINE BIT\n         SPACE\n         LM    RLPEXIT,RPARM,HPRSAVE  RESTORE LISTPROC REGISTERS\n         L     RRET,HPREXIT        RECOVER EXIT ADDRESS AND\n         BR    RRET                RETURN TO CALLER\n         EJECT\n***********************************\n* MOVE - VERTICAL SPACING ROUTINE *\n***********************************\n         SPACE\n* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER\n* 'RSPACE'.  RETURN ADDRESS IS IN 'RWA'.  IF THE CONTROL CHARACTER FOR\n* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE\n* GENERATING ANY EXTRA LINES.\n         SPACE 2\nMOVE     LTR   RSPACE,RSPACE       TEST NUMBER OF LINES TO BE MOVED\n         BCR   13,RWA              EXIT IF <= ZERO\n         TM    SWITCHES,SP0BIT     DID PREVIOUS LINE SPACE 0?\n         BZ    PREVNOT0            BRANCH IF NOT\n         L     R1,CCLAST           GET ADDRESS OF PREVIOUS LINE\n         BAS   RWB,CCGEN           GENERATE NEW CONTROL CHAR\n         NI    4(R1),X'02'         TEST WRITE/SPACE BIT IN OLD CC\n         STC   R0,4(R1)            STORE NEW CC IN PREVIOUS LINE\n         BNZ   *+8                 BR IF WRITE/SPACE BIT WAS ON\n         NI    4(R1),255-X'02'     TURN WRITE/SPACE BIT OFF\nPREVNOT0 DS    0H\n         MVC   DCBLRECL(2),MOVELINE  SET LOGICAL RECORD LENGTH IN DCB\n         SPACE\n         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE\n         MVC   0(6,R1),MOVELINE    INSERT FORMAT 'V' CONTROL RECORD\n         BAS   RWB,CCGEN           GET PRINT CONTROL CHAR IN R0\n         STC   R0,4(R1)            INSERT IN RECORD\n         SPACE\n         B     MOVE                LOOP UNTIL 'RSPACE' IS ZERO\n         SPACE 3\nMOVELINE DC    XL6'000600000340'   FORMAT 'V' CONTROL RECORD\n         EJECT\n*****************************************\n* CCGEN - GENERATE PRINTER CONTROL CHAR *\n*****************************************\n         SPACE\n* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT\n* IMMEDIATELY (WITHOUT PRINTING).  ENTER WITH THE TOTAL NUMBER OF\n* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'.  EXITS\n* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT\n* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.\n* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL\n* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM\n* BIT.  NOTE:  MUST NOT USE R1.\n         SPACE 2\nCCGEN    NI    SWITCHES,255-SP0BIT  RESET 'PREVIOUS SPACED 0' BIT\n         CH    RSPACE,=AL2(EJFORCE)  TEST FOR EJECT REQUEST\n         BL    CCNOEJ              BRANCH IF NOT\n         LA    R0,X'8B'            LOAD 'SKIP TO CHAN 1' CC\n         OI    SWITCHES,HOFBIT     SET HEAD-OF-PAGE BIT\n         SR    RBAL,RBAL           SET PAGE BALANCE TO ZERO\n         SR    RSPACE,RSPACE       SET REMAINING SPACING TO ZERO\n         BR    RWB                 EXIT\n         SPACE\nCCNOEJ   LR    R15,RSPACE          LOAD WORK REGISTER\n         CH    RSPACE,=H'3'        TEST IF OVER THREE LINES\n         BNH   CCOK                BR IF <= 3\n         LA    R15,3               SET 3, MAXIMUM FOR 1 OPERATION\nCCOK     SR    RSPACE,R15          DECR RSPACE BY AMOUNT SPACED\n         SLL   R15,3               PUT AMOUNT IN BITS 2-4 OF BYTE\n         LA    R0,X'03'(R15)       ADD COMMAND BITS AND PUT IN R0\n         LTR   R15,R15             TEST FOR ZERO SPACING\n         BCR   7,RWB               EXIT IF NOT ZERO\n         OI    SWITCHES,SP0BIT     SET 'LINE SPACED 0' BIT\n         BR    RWB                 EXIT\n         EJECT\n***********************\n* SYNAD ERROR ROUTINE *\n***********************\n         SPACE\n* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.\n         SPACE\nSYNAD    SYNADAF ACSMETH=QSAM      GET ERROR MESSAGE FROM O/S\n         LR    RWA,R1              SAVE MESSAGE ADDRESS\n         GETMAIN R,LV=128          GET BUFFER FOR MESSAGE\n         MVC   0(LIOMSG,R1),IOMSG  INSERT MESSAGE BEGINNING\n         MVC   LIOMSG(79,R1),49(RWA)  ADD TEXT FROM O/S\n         LR    RWA,R1              SAVE MESSAGE ADDRESS\n         SYNADRLS                  FREE O/S MESSAGE\n         WTO   MF=(E,(RWA))        TYPE MESSAGE ON CONSOLE\n         LA    R1,7                LOAD ERROR CODE\n         B     ABEND               TO ABORT AND DUMP\n         SPACE\nIOMSG    DC    AL2(LIOMSG+78,0)    FORMAT V CONTROL FIELD\n         DC    C'XPRNTSUB I/O ERROR'\nLIOMSG   EQU   *-IOMSG\n         EJECT\n**************************\n* CONSTANTS AND LITERALS *\n**************************\n         SPACE\n* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.\n         SPACE\nNOHDLIST DS    0F\n         DC    AL4(NOHDPLD)        ADDRESS OF PLD BELOW\n         DC    XL1'80'             VL LIST BIT\n         DC    XL3'00'             VL LIST DUMMY ADDRESS\n         SPACE\nNOHDPLD  DS    0F                  ALIGN ON FULL-WORD BOUNDARY\n         DC    AL4(BLANK1)         PRINT TEXT ADDRESS\n         DC    AL1(1)              PRINT TEXT LENGTH\n         DC    AL1(0)              LEFT MARGIN INDENTATION\n         DC    AL1(0)              SPACING BEFORE PRINTING\n         DC    AL1(3)              SPACING AFTER PRINTING\n         DC    BL1'00010000'       OPTION BITS\n         SPACE\n* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS\n* RECEIVED.  THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.\n         SPACE\nDEFAULTS DS    0F\n         DC    A(NOHDLIST)         PAGE HEADING PARM LIST ADDRESS\n         DC    F'1000000'          MAXIMUM NUMBER OF OUTPUT LINES\n         DC    H'132'              PAGE WIDTH\n         DC    H'57'               PAGE LENGTH            ***TRW***\n         DC    H'0'                PAGE NUMBER (-1)\n         DC    H'0'                PAGE BALANCE\n         DC    X'00'               SWITCHES\nDEFSIZE  EQU   *-DEFAULTS\n         SPACE\n* MISCELLANEOUS CONSTANTS:\n         SPACE\nBLANK1   DC    C' '                TEXT OF DUMMY HEADING LINE\n         LTORG\n         EJECT\n*******************\n* WORK AREA DSECT *\n*******************\n         SPACE\n* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM\n* PROGRAM FOR EACH DATA SET.  ITS ADDRESS IS PASSED IN PARAMETER\n* REGISTER 0 AT EACH CALL.\n         SPACE 2\nWORKAREA DSECT\n         SPACE 2\n* STANDARD 18-WORD SAVE AREA:\n         SPACE\nSAVEAREA DS    18F\n         SPACE 2\n* DATA CONTROL BLOCK FOR PRINTER DATA SET:\n         SPACE\n*        PRINT NOGEN\nPRINTDCB DCB   DDNAME=SYSPRINT,                                        X\n               DSORG=PS,                                               X\n               RECFM=VBM,                                              X\n               LRECL=137,                                              X\n               MACRF=PL,                                               X\n               BFTEK=S,                                                X\n               BUFNO=2,                                                X\n               EROPT=ACC\n         PRINT GEN\n         SPACE\nDCBEXLST EQU   PRINTDCB+37         ADDRESS OF EXIT LIST\nDCBOFLGS EQU   PRINTDCB+48         CONTAINS 'OPENED SUCCESSFULLY' BIT\nDCBDDNAM EQU   PRINTDCB+40         DDNAME (WHEN CLOSED)\nDCBSYNAD EQU   PRINTDCB+57         ADDRESS OF SYNCHRONOUS ERROR ROUTINE\nDCBBLKSZ EQU   PRINTDCB+62         BLOCK SIZE\nDCBLRECL EQU   PRINTDCB+82         LOGICAL RECORD LENGTH\n         SPACE 2\n* ADDRESS OF LAST BUFFER OBTAINED BY \"PUT\" MACRO:\n         SPACE\nCCLAST   DS    1A\n         SPACE\n         DS    1F                  SPARE FULL WORD\n         SPACE 2\n* TEMPORARY WORK CELLS:\n         SPACE\nDWORK    DS    1D                  DOUBLE-WORD WORK CELL\nHPREXIT  DS    1F                  HEADPRNT EXIT SAVE\nHPRSAVE  DS    2F                  HEADPRNT REGISTER STORAGE\n         SPACE 2\n* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.\n* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.\n         SPACE\nPAPARMS  DS    0F\nHEADLIST DS    1A                  PAGE HEADING PARM LIST ADDRESS\nMAXLINES DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES\nPAGWIDTH DS    1H                  PAGE WIDTH\nPAGELNG  DS    1H                  PAGE LENGTH\nPAGENO   DS    1H                  PAGE NUMBER OF CURRENT PAGE\nPAGEBAL  DS    1H                  PAGE BALANCE\nSWITCHES DS    1X                  SWITCHES\n         SPACE 2\n* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING:\n         SPACE\nHLTXTLNG EQU   24\nHLTEXT   DS    CL(HLTXTLNG)\nHLDAY    EQU   HLTEXT\nHLTIME   EQU   HLTEXT+7\nHLDATE   EQU   HLTEXT+16\n         EJECT\n*************************\n* PARAMETER LIST DSECTS *\n*************************\n         SPACE 2\n* PARAMETER LIST FOR 'EJECT' CALL:\n         SPACE\nEJPARM   DSECT\n         SPACE\nEJCOND   DS    1X                  CONDITIONAL MASK AND SWITCHES\nEJQUAN   DS    1X                  CONDITIONAL TEST QUANTITY\n         SPACE\nEJATHOF  EQU   X'01'               MASK FOR 'EJCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'SPACE' CALL:\n         SPACE\nSPPARM   DSECT\n         SPACE\nSPCOND   DS    1X                  CONDITIONAL BITS\nSPQUAN   DS    1X                  NUMBER OF LINES TO SPACE\n         SPACE\nSPATHOF  EQU   X'01'               MASK FOR 'SPCOND'\nSPNOEJ   EQU   X'02'               MASK FOR 'SPCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS:\n         SPACE\nOMPARM   DSECT\n         SPACE\nOMMAXLIN DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES\nOMPAGENO DS    1H                  INITIAL PAGE NUMBER\nOMPAGWID DS    1X                  PAGE WIDTH\nOMPAGLNG DS    1X                  PAGE LENGTH\nOMTIMEAD DS    1A                  ADDRESS OF TIME\nOMDATEAD DS    1A                  ADDRESS OF DATE\nOMDDNAME DS    CL8                 DDNAME (OPEN CALL ONLY)\n         EJECT\n*************\n* PLD DSECT *\n*************\n         SPACE\n* PRINT LINE DESCRIPTOR DUMMY SECTION:\n         SPACE 2\n*        ******************************************************\n*        *                                                    *\n*        *                                                    *\n*        *                          TEXT ADDRESS              *\n*        *                                                    *\n*        ******************************************************\n*        *            *            *            *             *\n*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *\n*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *\n*        *            *            *            *             *\n*        ******************************************************\n*        *            *\n*        *   OPTION   *\n*        *    BITS    *\n*        *            *\n*        **************\n         SPACE 3\nPLDBLOCK DSECT\n         SPACE\nPLDTXTAD DS    AL4                 TEXT ADDRESS\nPLDLNGTH DS    1X                  TEXT LENGTH\nPLDOFFST DS    1X                  TEXT OFFSET, OR LEFT MARGIN\nPLDSPB   DS    1X                  AMOUNT TO SPACE BEFORE PRINTING\nPLDSPA   DS    1X                  AMOUNT TO SPACE AFTER PRINTING\nPLDFLAGS DS    1X                  OPTION BITS\n         SPACE 2\nPRHOFBIT EQU   B'00000010'         MASK FOR 'PLDFLAGS'\nPRSKPBIT EQU   B'00000001'         MASK FOR 'PLDFLAGS'\nSPSKPBIT EQU   B'00010000'         MASK FOR 'PLDFLAGS'\n         TITLE 'DATE EDITING ROUTINE \"XDATEDIT\"'\n* STATUS:  VERSION 0, MOD 2, 5 OCTOBER 1967.\n         SPACE\n* FUNCTION/OPERATION:  EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO\n*        EBCDIC MONTH-DAY-YEAR FORM.  CORRECTS FOR LEAP YEARS AND\n*        FOR THE TURN OF A CENTURY.\n         SPACE\n* ENTRY POINTS:  ENTER AT \"XDATEDIT\" VIA BALR 14,15 WITH REG 13 SET\n*        TO A STANDARD 18-WORD SAVE AREA.  REGISTER 1 POINTS TO A\n*        PARAMETER LIST CONTAINING ONE ADDRESS.\n         SPACE\n* INPUT:  THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED\n*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS:\n*        X'0000000000YYDDD+'.\n         SPACE\n* OUTPUT:  THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS\n*        C'MM/DD/YY'.\n         SPACE\n* DATA SETS:  NONE.\n         SPACE\n* EXTERNAL ROUTINES:  NONE.\n         SPACE\n* EXITS-NORMAL:  RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n         SPACE\n* EXITS-ERROR:  IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE\n*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4\n*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.\n         SPACE\n* TABLES/WORK AREAS:  NONE.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ ONLY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\n* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.\n         SPACE\nDUMMY    DSECT\nDWORD    DS    1D\n         SPACE 6\n* BEGIN CONTROL SECTION HERE.  DEFINE REGISTER TAGS.\n         SPACE\nXDATEDIT CSECT\n         SPACE\nRDSECT   EQU   11                  BASE REG FOR ARGUMENT/RESULT\nRPARMD   EQU   1                   PARAMETER LIST POINTER\nRARGSAVE EQU   2                   TO SAVE ORIGINAL PACKED ARGUMENT\nRMONTH   EQU   3\nRDAY     EQU   4                   RDAY AND RYEAR ARE AN EVEN/ODD\nRYEAR    EQU   5                   PAIR FOR DIVISION\nRWORK    EQU   6\nRLIST    EQU   7\n         SPACE 6\n* ENTER HERE.  SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.\n         SPACE\n         SAVE  (14,12),,*\n         SPACE\n         BASR  RBASE,0\n         USING *,RBASE\n         L     RDSECT,0(RPARMD)    LOAD ARGUMENT ADDRESS\n         USING DWORD,RDSECT\n         EJECT\n* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.\n         SPACE\n         MVI   DWORD,X'00'         CLEAR HIGH DECIMAL DIGITS\n         MVC   DWORD+1(4),DWORD    IN ARG TO ZEROS\n         OI    DWORD+7,X'0F'       FORCE PLUS SIGN\n         L     RARGSAVE,DWORD+4    SAVE ARGUMENT FOR 'BADDATE'\n         SPACE\n         CVB   RYEAR,DWORD         CONVERT YYDDD TO BINARY\n         SR    RDAY,RDAY           CLEAR HIGH-ORDER DIVIDEND\n         D     RDAY,F1000          QUOTIENT=YEAR; REMAINDER=DAY\n         SPACE\n* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE\n* LIST OF MONTH SIZES.\n         SPACE\nDAYOK    DS    0H\n         LA    RLIST,STDLIST       POINT RLIST TO STANDARD MONTHS\n         LTR   RWORK,RYEAR         LOAD BINARY YEAR NUMBER\n         BZ    NOTLEAP             BR IF TURN OF CENTURY\n         N     RWORK,=F'3'         TEST LOW TWO BITS\n         BC    4,NOTLEAP           BR IF NON-ZERO\n         LA    RLIST,LPYLIST       POINT RLIST TO LEAP-YEAR MONTHS\nNOTLEAP  DS    0H\n         SPACE\n* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY\n* THE YEAR NUMBER.\n         SPACE\n         LTR   RDAY,RDAY           TEST FOR ZERO\n         BZ    ZERDATE             BR IF SO\n         CH    RDAY,0(0,RLIST)     TEST FOR UPPER LIMIT\n         BH    BADDATE             BR IF TOO LARGE\n         SPACE\n* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.\n         SPACE\n         LA    RMONTH,1            INITIAL MONTH NUMBER\n         SR    RWORK,RWORK\nDAYLOOP  IC    RWORK,1(RMONTH,RLIST)  LENGTH OF MONTH INTO RWORK\n         CR    RDAY,RWORK          TEST IF DAY IN THIS MONTH\n         BNH   DAYDONE             BR IF DAY LESS THAN MONTH SIZE\n         SR    RDAY,RWORK          REDUCE DAY BY LENGTH OF MONTH\n         LA    RMONTH,1(RMONTH)    INCREMENT MONTH\n         B     DAYLOOP\nZERDATE  DS    0H\n         SR    RDAY,RDAY\n         SR    RMONTH,RMONTH\n         SR    RYEAR,RYEAR\nDAYDONE  DS    0H\n         SPACE\n* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING\n* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.\n* THE TRICK IS THAT  1000(1000(MONTH)+DAY)+YEAR  GIVES  MM0DD0YY  WHEN\n* CONVERTED TO DECIMAL.  AFTER UNPACKING, THE ZEROS ARE REPLACED BY\n* SLASHES.\n         SPACE\n         MH    RMONTH,H1000\n         AR    RMONTH,RDAY\n         MH    RMONTH,H1000\n         AR    RMONTH,RYEAR\n         CVD   RMONTH,DWORD\n         MVC   DWORD(5),DWORD+3    MOVE OVER FOR UNPACKING\n         UNPK  DWORD(8),DWORD(5)   CONVERT TO ALPHA\n         OI    DWORD+7,X'F0'       COVER UP SIGN\n         MVI   DWORD+2,C'/'        INSERT SLASHES\n         MVI   DWORD+5,C'/'\n         SR    15,15               SET NORMAL RETURN CODE OF 0\n         SPACE\nEXITD    RETURN  (14,12),T,RC=(15)  RETURN TO CALLER\n         SPACE 2\n* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN\n* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.\n         SPACE\nBADDATE  ST    RARGSAVE,DWORD      RESTORE ORIGINAL PACKED ARGUMENT\n         UNPK  DWORD+2(5),DWORD+1(3)  UNPACK INTO ALPHA\n         MVC   DWORD+1(2),DWORD+2  SHIFT YEAR 1 LEFT\n         MVI   DWORD,C' '          APPLY COSMETICS\n         MVI   DWORD+3,C'.'\n         MVI   DWORD+7,C' '\n         LA    15,4                SET RETURN CODE\n         B     EXITD\n         EJECT\n* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS:\n         SPACE\nSTDLIST  DC    H'365'              DAY LIMIT FOR STANDARD YEARS\n         DC    AL1(31)\n         DC    AL1(28)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nLPYLIST  DC    H'366'              DAY LIMIT FOR LEAP YEARS\n         DC    AL1(31)\n         DC    AL1(29)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nF1000    DC    F'1000'\nH1000    EQU   F1000+2\n         LTORG\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RCPDDN": {"ttr": 5127, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         RCPDDN &DDN\n         GBLC  &DYNP\n         SPACE 1\n***********************************************************************\n**   BUILD THE DDNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DDN'(K'&DDN,1) EQ '/').BTU\n         AIF   ('&DDN'(1,1) EQ '''').Q\n         RCPSR2\n         AIF   ('&DDN'(1,1) EQ '(').R\n         L     R14,&DDN                LOAD ADDRESS OF DDNAME\n         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME\n         AGO   .STH\n.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME\n         LH    R2,4&DDN                LOAD LENGTH OF DDNAME\n.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DDNAME\n         MVI   S99TUKEY+1,DALDDNAM     MOVE IN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DALDDNAM,1,&DDN\n         MEXIT\n.BTU     RCPTUBFR DALDDNAM,14,&DDN\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDINC": {"ttr": 5129, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         RCPDINC &L1\n         GBLA  &DTUO,&DTUPO\n         GBLC  &DYNP\n         AIF   ('&L1' EQ '').T2\n         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT\n&DTUPO   SETA  &DTUPO+4\n&DTUO    SETA  &DTUO+&L1\n         MEXIT\n.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n&DTUPO   SETA  &DTUPO+4\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDISP": {"ttr": 5131, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         RCPDISP &DISP\n         LCLA  &I\n         LCLB  &B(4)\n         AIF   ('&DISP(1)' EQ '').TD2\n         SPACE\n***********************************************************************\n**     DATA SET INITIAL STATUS                                       **\n***********************************************************************\n&B(1)    SETB  ('&DISP(1)' EQ 'SHR')\n&B(2)    SETB  ('&DISP(1)' EQ 'NEW')\n&B(3)    SETB  ('&DISP(1)' EQ 'MOD')\n&B(4)    SETB  ('&DISP(1)' EQ 'OLD')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1\n         MNOTE 8,'&DISP(1) IS INVALID, DISP=SHR USED'\n&B(1)    SETB  1\n.OK1     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')\n         RCPDINC 8\n.TD2     AIF   ('&DISP(2)' EQ '').TD3\n         SPACE\n***********************************************************************\n**    DATA SET NORMAL DISPOSITION                                    **\n***********************************************************************\n&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2\n         MNOTE 8,'&DISP(2) IS INVALID, DISP=(,KEEP) USED'\n&B(1)    SETB  1\n.OK2     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.TD3     AIF   ('&DISP(3)' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   DATASET CONDITIONAL DISPOSITION                                 **\n***********************************************************************\n&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3\n         MNOTE 8,'&DISP(3) IS INVALID, DISP=(,,KEEP) USED'\n&B(1)    SETB  1\n.OK3     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVI   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPDSN": {"ttr": 5133, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         RCPDSN &DSN,&MEM\n         LCLC  &MEMBER\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**   BUILD THE DSNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DSN'(1,1) EQ '''').Q\n         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD\n         AIF   ('&DSN'(1,1) EQ '(').REG\n         AIF   ('&DSN'  EQ '*').TERM\n         RCPSR2\n         L     R14,&DSN                LOAD ADDRESS OF DSNAME\n         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME\n.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DSNAME\n         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 50\n         AGO   .TMEMBER\n.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME\n         RCPSR2\n         LH    R2,4&DSN                LOAD LENGTH OF DSNAME\n         AGO   .STH\n.TERM    MVI   S99TUKEY+1,DALTERM\n         RCPDINC 4\n         MEXIT\n.BD      RCPTUBFR DALDSNAM,50,&DSN\n         AGO   .TMEMBER\n.Q       RCPBTU DALDSNAM,1,&DSN\n.TMEMBER AIF   ('&MEM' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   BUILD THE MEMBER NAME TEXT UNIT                                 **\n***********************************************************************\n&MEMBER  SETC  '&MEM'\n         AIF   ('&MEM' NE '*').MOK\n         AIF   ('&DSN'(1,1) NE '''').MAST\n         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'\n         MEXIT\n.MAST    ANOP\n&MEMBER  SETC  '8+&DSN'\n.MOK     ANOP\n         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM\n         RCPSR2\n         AIF   ('&MEMBER'(1,1) EQ '(').RM\n         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER\n         AGO   .STHM\n.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME\n         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.BM      RCPTUBFR DALMEMBR,14,&MEMBER\n         MEXIT\n.QM      RCPBTU DALMEMBR,1,&MEMBER\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCPSR2": {"ttr": 5135, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         RCPSR2 &A\n         GBLB  &RCPSR2\n         GBLC  &DYNP\n         LCLC  &C\n.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY\n.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND\n.*    GENERATES MOVE INSTRUCTION FOR EXECUTE\n         AIF   ('&A' NE '').UNSAVE\n         AIF   (&RCPSR2).EXIT\n&RCPSR2  SETB  1\n         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2\n         MEXIT\n.UNSAVE  AIF   (NOT &RCPSR2).EXIT\n         B     *+10                    SKIP NEXT INSTRUCTION\n&C       SETC  '&DYNP.MVC'\n&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE\n         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2\n&RCPSR2  SETB  0\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UCBTYPES": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x01\\x02\\x00\\x7f\\x01\\x02\\x01\\x0f\\x07A\\x00\\xbc\\x00\\xbc\\x00\\x01\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-07T00:00:00", "modifydate": "2002-01-10T07:41:48", "lines": 188, "newlines": 188, "modlines": 1, "user": "MSTITT"}, "text": "          MACRO\n          UCBTYPES &LIST=YES,&GRAPHICS=NO\n*/*------------------------------------------------------------------*/\n*/*                                                                  */\n*/*    U N I T    C O N T R O L    B L O C K    T Y P E S            */\n*/*                                                                  */\n*/*------------------------------------------------------------------*/\n*/*                                                                  */\n*/*  STATUS = OS/VS2 JBB3311 01/30/90, LEVEL=1                       */\n*/*                                                                  */\n*/*  METHOD OF ACCESS                                                */\n*/*                                                                  */\n*/*  - THIS IS THE 4 BYTE FIELD LOCATED IN THE UCB LOOK UP TABLE     */\n*/*    AT OFFSET +16, X'10'. NO DSECT WAS SUPPLIED SO THIS IS IT.    */\n*/*    WHEN \"GRAPHICS=NO\" IS SPECIFIED, THEN EQUATES FOR GRAPHIC     */\n*/*    DEVICES WILL NOT BE SPECIFIED, THIS IS THE DEFAULT.           */\n*/*                                                                  */\n*/*  - SEE DEBUGGING HANDBOOK #5 FOR UCBTYPE DEFINITIONS             */\n*/*                                                                  */\n*/*                                                                  */\n*/*                                                                  */\n*/*----------------------------------------------------------------- */\n          PUSH  PRINT\n          AIF   ('&LIST' EQ 'YES').UCB1\n          PRINT OFF\n.UCB1     ANOP\n.*\n.*  NOTE: MUST BE USED AFTER IEFUCBOB MARCO OR ASSEMBLY ERROR !!!!\n.*\n#TYPE1    EQU   UCBTBYT1       @OFFSET +X'10' IN IEFUCBOB\n#TYPE2    EQU   UCBTBYT2       @OFFSET +X'11' IN IEFUCBOB\n#TYPE3    EQU   UCBTBYT3       @OFFSET +X'12' IN IEFUCBOB\n#TYPE4    EQU   UCBTBYT4       @OFFSET +X'13' IN IEFUCBOB\n*--------------------------------------------------------------------\n*---------->  OFFSET +16  OR  X'10'  INTO IEFUCBOB DSECT <-----------\n*--------------------------------------------------------------------\nUR16      EQU  *      + OFFSET +16 OR X'10'\nUR1HEXF0  EQU  X'F0'  - I/O SUPERVISOR FLAGS\nUR1HEX80  EQU  X'80'  - RESERVED\nUR1HEX40  EQU  X'40'  - OVERRUNNABLE DEVICE\nUR1HEX20  EQU  X'20'  - IF BURST MODE ON, BYTE MODE OFF\nUR1HEX10  EQU  X'0F'  - MODEL CODE\nUR17      EQU  *      + OPTION FLAGS\nUR2HEX80  EQU  X'80'  - UNIVERSAL CHAR SET\nUR2HEX4E  EQU  X'4E'  - RESERVED\nUR2HEX20  EQU  X'20'  - 3225 TWO-LINE PRINT FEATURE\nUR2HEX10  EQU  X'10'  - 3525 MULTI-LINE PRINT FEATURE\nUR2HEX01  EQU  X'01'  - CARD IMAGE (BINARY MODE)\nUR18      EQU  *      - CLASS BITS\nUR3HEX08  EQU  X'08'  - UNIT RECORD\nUR19      EQU  *      + DEVICE CODE\nUR4HEX04  EQU  X'04'  - 2501 CARD READER\nUR4HEX06  EQU  X'06'  - 3505 CARD READER\nUR4HEX08  EQU  X'08'  - PRINTER MODELS N1, 2, 7 AND 1404\nUR4HEX09  EQU  X'09'  - 3211 PRINTER\nUR4HEX0A  EQU  X'0A'  - 1443 PRINTER MODEL N1\nUR4HEX0B  EQU  X'0B'  - 3203 PRINTER\nUR4HEX0C  EQU  X'0C'  - 3525 CARD PUNCH\nUR4HEX0E  EQU  X'0E'  - 3800 PRINTER SUBSYSTEM\nUR4HEX11  EQU  X'11'  - 3263 PRINTER\nUR4HEX16  EQU  X'16'  - 3890 DOCUMENT PROCESSOR\nUR4HEX42  EQU  X'42'  - 3851 MASS STOR\nUR4HEX4C  EQU  X'4C'  - 3838 ARRAY PROCESSOR\nTAPE16    EQU  *      + MODEL BITS\nMT1HEXF0  EQU  X'F0'  - I/O SUPERVISOR FLAGS\nMT1HEX80  EQU  X'80'  - RESV\nMT1HEX40  EQU  X'40'  - OVERRUNNABLE DEVICE\nMT1HEX20  EQU  X'20'  - BURST / BYTE MODES\nMT1HEX10  EQU  X'10'  - DATA CHAINING\nMT1HEX0F  EQU  X'0F'  - MODEL CODES\nMT1HEX09  EQU  X'09'  - RESV\nMT1HEX04  EQU  X'04'  - 1600 BPI\nMT1HEX02  EQU  X'02'  - 6250 BPI\nTAPE17    EQU  *      + OPTION FLAGS\nMT2HEX80  EQU  X'80'  - 7-TRACK COMPAT.\nMT2HEX40  EQU  X'40'  - DATA CONVERSION\nMT2HEX20  EQU  X'20'  - DUAL DEN (800/1600 BPI)\nMT2HEX10  EQU  X'10'  - DUAL DEN (6250/1600 BPI)\nMT2HEX04  EQU  X'04'  - IDRC FEATURE (3480, 3490)\nMT2HEX05  EQU  X'05'  - RESV\nTAPE18    EQU  *      + CLASS BITS\nMT3HEX80  EQU  X'80'  - MAG TAPE\nTAPE19    EQU  *      + DEVICE CODE\nMT4HEX03  EQU  X'03'  - 3400 MAG TAPES\nMT4HEX80  EQU  X'80'  - 3480/3490 CARTRIDGE TAPES\nMT4HEX81  EQU  X'81'  - 3490E CARTRIDGE TAPES\nMT4HEX83  EQU  X'83'  - 35901 CARTRIDGE TAPES\nDASD16    EQU  *      + MODEL BITS\nDA1HEXF0  EQU  X'F0'  - I/O SUPERVISOR FLAGS\nDA1HEX80  EQU  X'80'  - RESV\nDA1HEX40  EQU  X'40'  - OVERRUNNABLE DEVICE\nDA1HEX20  EQU  X'20'  - BURST / BYTE MODES\nDA1HEX10  EQU  X'10'  - DATA CHAINING\nDA1HEX0F  EQU  X'0F'  - MODEL CODES\nDASD17    EQU  *      + OPTION FLAGS\nDA2HEX40  EQU  X'40'  - TRACK OVERFLOW\nDA2HEX20  EQU  X'20'  - SHARED DASD\nDA2HEX10  EQU  X'10'  - ROTATIONAL POSITION SENSING\nDA2HEX08  EQU  X'08'  - VIRTUAL DASD\nDA2HEX84  EQU  X'84'  - RESV\nDASD18    EQU  *      + CLASS BITS\nDA3HEX20  EQU  X'20'  - DASD\nDASD19    EQU  *      + DEVICE CODE\nDA4HEX04  EQU  X'04'  - 9345\nDA4HEX07  EQU  X'07'  - 2305 FIXED HEAD\nDA4HEX09  EQU  X'09'  - 3330 MODEL 1, 2\nDA4HEX0A  EQU  X'0A'  - 3340 DASD\nDA4HEX0B  EQU  X'0B'  - 3350 DASD, A2, B2, C2\nDA4HEX0C  EQU  X'0C'  - 3375 DASD\nDA4HEX0D  EQU  X'0D'  - 3330 DASD, 11\nDA4HEX0E  EQU  X'0E'  - 3380 DASD\nDA4HEX0F  EQU  X'0F'  - 3390 DASD\nTERM16    EQU  *      + TERMINAL DEVICES\nGC1HEX11  EQU  X'11'  - MODEL 1\nGC1HEX12  EQU  X'12'  - MODEL 2, 2A, 2B, 3, 3A, 3B, OR 4\nTERM17    EQU  *      + OPTIONAL FEATURES\nGC2HEXE0  EQU  X'E0'  - KEY BOARD TYPE\nGC2HEX00  EQU  X'00'  - NO KEY BOARD, DOMESTIC CHAR GEN+MONOCHAR GEN.\nGC2HEX20  EQU  X'20'  - 66 KEY EBCDIC TYPEWRITER KEYBOARD\nGC2HEX40  EQU  X'40'  - 78 KEY EBCDIC TYPEWRITER KEYBOARD\nGC2HEX60  EQU  X'60'  - 66 KEY DATA ENTRY KEYBOARD\nGC2HEX80  EQU  X'80'  - 78 KEY OPERATOR CONSOLE KEYBOARD\nGC2HEXA0  EQU  X'A0'  - 66 KEY ASCII TYPEWRITER KEYBOARD\nGC2HEXC0  EQU  X'C0'  - 78 KEY ASCII TYPEWRITER KEYBOARD\nGC2HEX10  EQU  X'10'  - AUDITABLE ALARM FEATURE\nGC2HEX0E  EQU  X'0E'  - CHAR GEN TYPE\nGC2HEX02  EQU  X'02'  - ASCII A CHAR GEN.\nGC2HEX04  EQU  X'04'  - ASCII B CHAR GEN.\nGC2HEX06  EQU  X'06'  - U. K.  CHAR GEN.\nGC2HEX08  EQU  X'08'  - FRENCH CHAR GEN.\nGC2HEX0A  EQU  X'0A'  - GERMAN CHAR GEN.\nGC2HEX01  EQU  X'01'  - CHAR GEN. CASE\nTERM18    EQU  *      + DEVICE CLASS\nGC3HEX10  EQU  X'10'  - GRAPHICS BIT ON ????\nTERM19    EQU  *      + DEVICE CODE\nGC3HEX09  EQU  X'09'  - 3277, 3278, OR 3279 DISPLAY STATION\nCCADP18   EQU  *      + CHANNEL TO CHANNEL ADAPTER\nCC3HEX41  EQU  X'41'  - CHANNEL TO CHANNEL ADAPTER BYTE +18\nCOMM16    EQU  *      + COMMUNICATIONS DEVICE EQUIPMENT\nCE1HEXF0  EQU  X'F0'  - I/O SUPERVISOR\nCE1HEX80  EQU  X'80'  - RSVD\nCE1HEX40  EQU  X'40'  - OVERRUNNABLE TABLE\nCE1HEX20  EQU  X'20'  - ON=BURST\nCE1HEX10  EQU  X'10'  - DATA CHAINING\nCE1HEX0F  EQU  X'0F'  - MODEL CODE(+ADAPTER CODE=MODEL)\nCE1HEX01  EQU  X'01'  - ADAPTER TYPE 1-UNIT 1050,2-1030,3-1050,4-83B3\n*                                                5-TWX,6-WTTA,8-2260\nCE1HEX02  EQU  X'02'  - ADAPTER TYPE 1-1060, W/ADPT 4 A 115A\nCE1HEX03  EQU  X'03'  - ADAPTER TYPE 1-2740\nCE1HEX04  EQU  X'04'  - ADAPTER TYPE 1-2740\nCE1HEX05  EQU  X'05'  - ADAPTER TYPE 1-2740C, W/ADPT 9 A BSC1\nCE1HEX06  EQU  X'06'  - ADAPTER TYPE 1-2741P, W/ADPT 9 A BSC2\nCE1HEX07  EQU  X'07'  - ADAPTER TYPE 1-1050X, W/ADPT 9 A BSC3\nCE1HEX08  EQU  X'08'  - ADAPTER TYPE 1-2740X\nCE1HEX09  EQU  X'09'  - ADAPTER TYPE 1-2740B\nCOMM17    EQU  *      + OPTIONAL FEATURES\nCE2HEX80  EQU  X'80'  - AUTO CALLING\nCE2HEX40  EQU  X'40'  - AUTO POLLING\nCE2HEX20  EQU  X'20'  - CHECKING (2740 ONLY) OR DUAL COMM (2701 SDA-II)\nCE2HEX10  EQU  X'10'  - AUTO ANSWER\nCE2HEX08  EQU  X'08'  - STATION CONTROL (2740 ONLY)\nCE2HEX04  EQU  X'04'  - DUAL CODE (2701 SDA-II) OR 2740 ONLY\nCE2HEX0C  EQU  X'0C'  - OPTICAL IMAGE UNIT\nCE2HEX03  EQU  X'03'  - SADTHREE\nCE2HEX02  EQU  X'02'  - SADTWO\nCE2HEX01  EQU  X'01'  - SADONE\nCE2HEX00  EQU  X'00'  - SADZER\nCOMM18    EQU  *      + DEVICE CLASS\nCE3HEX40  EQU  X'40'  - COMM EQUIPMENT\nCOMM19    EQU  *      + UNIT TYPE\nCE4HEXF0  EQU  X'F0'  - ADPATER TYPE\nCE4HEX10  EQU  X'10'  - ADAPTER TYPE I\nCE4HEX20  EQU  X'20'  - ADAPTER TYPE II\nCE4HEX30  EQU  X'30'  - TELEGRAPH ADAPTER TYPE\nCE4HEX40  EQU  X'40'  - TELEGRAPH ADAPTER TYPE I\nCE4HEX50  EQU  X'50'  - TELEGRAPH ADAPTER TYPE II\nCE4HEX60  EQU  X'60'  - WORLD TRADE TELEGRAPH ADAPTER\nCE4HEX70  EQU  X'70'  - SYNCHRONOUS ADAPTER TYPE I\nCE4HEX80  EQU  X'80'  - ADAPTER TYPE III\nCE4HEX90  EQU  X'90'  - SYNCHRONOUS ADAPTER TYPE II\nCE4HEX0F  EQU  X'0F'  - CONTROL UNIT\nCE4HEX01  EQU  X'01'  - 2702 CU\nCE4HEX02  EQU  X'02'  - 2701 CU\nCE4HEX03  EQU  X'03'  - 2703 CU\nCE4HEX04  EQU  X'04'  - 2955 CU\nCE4HEX15  EQU  X'15'  - 3704/3705/3725\nCE4HEXF1  EQU  X'F1'  - 3791-LOGICAL CONTROL UNIT\n.MEND     MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTOC": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00Q\\x00\\x97&_\\x01\\x03\\x16/\\tX\\x00\\xd2\\x00g\\x00\\x93\\xd4\\xc1\\xe3\\xe3@@@@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1997-09-22T00:00:00", "modifydate": "2003-06-11T09:58:51", "lines": 210, "newlines": 103, "modlines": 147, "user": "MATT"}, "text": "         TITLE ' - READ FORMAT1 DSCB AND SETUP DCB AND SPACE INFO.'\n* THIS CODE USES OBTAIN TO READ IN THE FORMAT 1 DSCB AND A FORMAT 3\n* DSCB IF ONE EXISTS. INFORMATION IS EXTRACTED AND PLACED INTO THE\n* FIELDS: LRECL, BLKSIZE AND TRACKS.\nVTOC     $PROLOG R12\n         L     R4,=V(DATASECT)                                     @130\n         USING DATASECT,R4                                         @130\n         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE\n         XC    LRECL,LRECL         RESET LRECL\n         XC    TRACKS,TRACKS       RESET TRACKS.\n         XC    EXTENTS,EXTENTS     RESET EXTENTS\n*        XC    CREDT,CREDT         RESET CREATE DATE\n*        XC    EXPDT,EXPDT         RESET EXPIRATION DATE\n*        XC    REFDT,REFDT         RESET REFERENCED DATE\n         MVC   CAMVOL,L1VOLUME     USE VOLSER FROM BCS VOLCELL\n         CLC   CAMVOL,=C'MIGRAT'   IS IT MIGRATED?\n         BE    VTOC99              IF SO, WHY BOTHER.\n*        MVC   CAMDSN,L1DSNAME     USE DSNAME FROM BCS.\n         MVC   CAMDSN,COMPNAME     USE DSNAME FROM BCS.\n         OBTAIN  SEARCH            READ FORMAT 1 DSCB BY DSNAME.\n         ST    R15,OBTAINRC        SAVE OBTAIN RETURN CODE.\n         LTR   R15,R15             WAS IT THERE?\n         BZ    VTOC1               YES.\n         MVC   TRACKS,=XL4'FFFFFFFF' INDICATE DATASET NOT FOUND 30NOV87\n         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN   15JAN88\n         BE    VTOC1A           NO,CONTINUE AS NORMAL           15JAN88\n         L     R9,DSPFXL           LOAD LENGTH OF PREFIX        15JAN88\n         EX    R9,COMPDSNV         COMPARE DSNAME TO PREFIX        @134\n         BNE   VTOC99         YES, DON'T ADD TO COUNT           15JAN88\nVTOC1A   AP    CNTNF,ONE           OTHERWISE COUNT AN ORPHAN.\n        $MESSAGE 7,DATA=COMPNAME                                   @130\n         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87\n         B     VTOC99              AND LEAVE IT BLANK.\nVTOC1    SR    R1,R1               CLEAR REGISTER 1.\n         ICM   R1,3,DS1BLKL        PICK UP BLKSIZE\n         ST    R1,BLKSIZE          AND SAVE FOR PRINT OUT.\n         ICM   R1,7,DS1SCAL3       PICK UP SECONDARY SPACE.        @130\n         CVD   R1,WORK             CONVERT TO DECIMAL.             @130\n         $EDITP  L1ALSEC,                                          @130X\n               DWK3,ZZZZ9          FORMAT IT.                      @130\n         TM    DS1SCAL1,DS1CYL     CYLINDER ALLOCATION\n         BM    VTOC1Z              NO, DO TRACK CALCULATION\n         SR    R0,R0               CLEAR A REGISTER.\n         SR    R1,R1               CLEAR A REGISTER.\n         LA    R5,DS1EXT1          ADDRESS PRIMARY EXTENT\n         ICM   R0,3,2(R5)          STARTING CC\n         ICM   R1,3,6(R5)          ENDING CC\n         SR    R1,R0               CYLS IN THIS EXTENT IN R1\n         LA    R1,1(,R1)           KEEP IT HONEST\n         B     VTOC1C\nVTOC1Z   EQU   *\n         SR    R0,R0               CLEAR A REGISTER.\n         LA    R5,DS1EXT1          ADDRESS PRIMARY EXTENT\n         ICM   R0,3,2(R5)          STARTING CC\n         SR    R14,R14             CLEAR A REGISTER.\n         L     R14,TRKCYL          TRACKS PER CYLINDER\n         SRDA  R0,32               SETUP FOR MULTIPLY.\n         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.\n         ICM   R14,3,4(R5)         STARTING TT\n         AR    R1,R14              STARTING RELATIVE TRACK.\n         ST    R1,STARTTRK         SAVE IT.\n         SR    R0,R0               CLEAR A REGISTER.\n         ICM   R0,3,6(R5)          ENDING CC\n         SR    R14,R14             CLEAR A REGISTER.\n         L     R14,TRKCYL          TRACKS PER CYLINDER\n         SRDA  R0,32               SETUP FOR MULTIPLY.\n         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.\n         ICM   R14,3,8(R5)         ENDING TT\n         AR    R1,R14              STARTING RELATIVE TRACK.\n         S     R1,STARTTRK         TRACKS IN THIS EXTENT IN R1\n         LA    R1,1(,R1)           KEEP IT HONEST\nVTOC1C   EQU   *\n         CVD   R1,WORK             CONVERT TO DECIMAL.             @130\n         $EDITP  L1ALPRM,                                          @130X\n               DWK3,ZZZZ9          FORMAT IT.                      @130\n         TM    DS1SCAL1,DS1CYL     CYLINDER ALLOCATION\n         BM    VTOC1D\n         MVC   L1ALTYP,=C'CYL'\n         B     VTOC1E\nVTOC1D   EQU   *\n         TM    DS1SCAL1,DS1TRK     TRACK ALLOCATION\n         BZ    VTOC1Y\n         MVC   L1ALTYP,=C'TRK'\n         B     VTOC1E\nVTOC1Y   TM    DS1SCAL1,DS1AVR     BLOCK ALLOCATION\n         BZ    VTOC1E\n         MVC   L1ALTYP,=C'BLK'\nVTOC1E   EQU   *\n         SR    R1,R1               CLEAR REGISTER                  @130\n         ICM   R1,3,DS1RKP         PICK UP KEY POSITION\n         CVD   R1,WORK             CONVERT TO DECIMAL\n         $EDITP  L1KPOS,                                           @130X\n               DWK2,ZZZ            FORMAT IT NICELY.\n         SR    R1,R1               CLEAR REGISTER\n         ICM   R1,3,DS1KEYL        PICK UP KEY LENGTH.\n         CVD   R1,WORK             CONVERT TO DECIMAL\n         $EDITP  L1KLEN,                                           @130X\n               DWK2,ZZZ            FORMAT IT NICELY.\n         ICM   R1,3,DS1LRECL       PICK UP LRECL\n         ST    R1,LRECL            AND SAVE FOR PRINT OUT.\n         L     R5,DSEXTAD          ADDRESS EXTENT TABLE\n         MVC   0(30,R5),DS1EXT1 SAVE EXTENTS 1 TO 3\n         CLC   DS1PTRDS,=5X'00'    IS THERE A FORMAT 3?\n         BE    VTOC2A              NO, SKIP IT.\n         LA    R5,30(R5)           GO AROUND FIRST 3 EXTENTS\n         MVC   CCHHR3,DS1PTRDS     POINTER TO FORMAT 3 DSCB.\nVTOC1B   OBTAIN  F3CAMLST          READ FORMAT 3 BY DISK ADDRESS.\n         LTR   R15,R15             DID WE GET IT?\n         BNZ   VTOC2A              OH WELL\n         MVC   0(40,R5),DS3EXTNT  EXTENTS 4,5,6 AND 7.\n         LA    R5,40(R5)\n         MVC   0(90,R5),DS3ADEXT EXTENTS 8 TO 16.\n         LA    R5,90(R5)\n         CLC   DS3PTRDS,=5X'00'    IS THERE A FORMAT 3?\n         BE    VTOC2A              NO, SKIP IT.\n         MVC   CCHHR3,DS3PTRDS     POINTER TO FORMAT 3 DSCB.\n         B     VTOC1B\nVTOC2A   SR    R15,R15             ZERO LOOP REGISTER\n         SR    R8,R8               ZERO COUNT OF TRACKS ALLOCATED.\n         IC    R15,DS1NOEPV        GET NUMBER OF EXTENTS\n         LTR   R15,R15             ARE THERE ANY EXTENTS?\n         BZ    VTOC5A              SKIP IT IF ZERO EXTENT\n         STCM  R15,15,EXTENTS\n         L     R5,DSEXTAD          START AT THE BEGINNING\nVTOC5B   EQU   *\n         CLI   0(R5),X'00'         IS THIS AN ACTIVE EXTENT?\n         BE    VTOC5C              IF NOT, SKIP IT.\n         SR    R0,R0               CLEAR A REGISTER.\n         ICM   R0,3,2(R5)          STARTING CC\n         SR    R14,R14             CLEAR A REGISTER.\n         L     R14,TRKCYL          TRACKS PER CYLINDER\n         SRDA  R0,32               SETUP FOR MULTIPLY.\n         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.\n         ICM   R14,3,4(R5)         STARTING TT\n         AR    R1,R14              STARTING RELATIVE TRACK.\n         ST    R1,STARTTRK         SAVE IT.\n         SR    R0,R0               CLEAR A REGISTER.\n         ICM   R0,3,6(R5)          ENDING CC\n         SR    R14,R14             CLEAR A REGISTER.\n         L     R14,TRKCYL          TRACKS PER CYLINDER\n         SRDA  R0,32               SETUP FOR MULTIPLY.\n         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.\n         ICM   R14,3,8(R5)         ENDING TT\n         AR    R1,R14              STARTING RELATIVE TRACK.\n         S     R1,STARTTRK         TRACKS IN THIS EXTENT IN R1\n         LA    R1,1(,R1)           KEEP IT HONEST\n         AR    R8,R1               COUNT IT\nVTOC5C   LA    R5,10(R5)           GET AN EXTENT ADDR IN R5.\n         BCT   R15,VTOC5B          LOOP THROUGH ALL EXTENTS.\nVTOC5A   LA    R8,0(0,R8)          PURIFY A REGISTER.\n         STCM  R8,15,TRACKS        TRACKS ALLOCATED\n         SLR   R1,R1\n         IC    R1,DS1CREDT\n         CVD   R1,DW\n         LH    R1,DW+6\n         SRL   R1,4\n         SLL   R1,16\n         SLR   R0,R0\n         ICM   R0,3,DS1CREDT+1\n         CVD   R0,DW\n         LH    R0,DW+6\n         OR    R0,R1\n         ST    R0,WORKA\n         MVC   CREDT,WORKA+1\n*        MVC   CREDT,DS1CREDT\n         SLR   R1,R1\n         IC    R1,DS1EXPDT\n         CVD   R1,DW\n         LH    R1,DW+6\n         SRL   R1,4\n         SLL   R1,16\n         SLR   R0,R0\n         ICM   R0,3,DS1EXPDT+1\n         CVD   R0,DW\n         LH    R0,DW+6\n         OR    R0,R1\n         ST    R0,WORKA\n         MVC   EXPDT,WORKA+1\n*        MVC   EXPDT,DS1EXPDT\n         SLR   R1,R1\n         IC    R1,DS1REFD\n         CVD   R1,DW\n         LH    R1,DW+6\n         SRL   R1,4\n         SLL   R1,16\n         SLR   R0,R0\n         ICM   R0,3,DS1REFD+1\n         CVD   R0,DW\n         LH    R0,DW+6\n         OR    R0,R1\n         ST    R0,WORKA\n         MVC   REFDT,WORKA+1\n*        MVC   REFDT,DS1REFD\nVTOC99   DS    0H\n         $EPILOG ,                 ALL DONE.\n         LTORG ,\nCOMPDSNV CLC   DSPFX(0),COMPNAME   EXECUTED COMMAND                @134\n         SPACE ,\nSEARCH   CAMLST  SEARCH,CAMDSN,CAMVOL,DS1FMTID\nCAMDSN   DC    CL44' '\nCAMVOL   DC    CL6' '\nDW       DC    D'0'\nWORKA    DC    F'0'\nFORMAT1  EQU   *\n         IECSDSL1 (1)\nOBTAINRC DC    F'0'\nF3CAMLST CAMLST  SEEK,CCHHR3,CAMVOL,FORMAT3\nCCHHR3   DC    XL5'00'\nFORMAT3  EQU   *\n         IECSDSL1 (3)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VVDS": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00F\\x00\\x95)\\x8f\\x01\\x03\\x16/\\t\\x16\\x00\\xb6\\x00t\\x00f\\xd4\\xc1\\xe3\\xe3@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "2003-06-11T09:16:46", "lines": 182, "newlines": 116, "modlines": 102, "user": "MATT"}, "text": "         TITLE ' - COLLECT DATA FROM VVDS CELLS.'\n* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI\n* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND\n* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY\n* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).\n         SPACE\nVVDS    $PROLOG R12\n         L     R4,=V(DATASECT)\n         USING DATASECT,R4\n         SR    R15,R15             RESET RETURN CODE.              @122\n         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE\n         XC    LRECL,LRECL         RESET LRECL\n         XC    TRACKS,TRACKS       RESET TRACKS.\n         XC    EXTENTS,EXTENTS     RESET EXTENTS\n         MVI   VOLINFSW,X'00'\n         MVI   VOLDSSW,X'00'\n         USING VVR,R6\nVVDS0    CLI   2(R6),C'Q'          Q = SECONDARY VVR\n         BE    VVDS0B              YES, IS IT THE RIGHT ONE?\n         CLI   2(R6),C'Z'          Z = PRIMARY VVR\n         BE    VVDS0B              YES, IS IT THE RIGHT ONE?\nVVDS0A   XC    VVD0,VVD0           NEXT CELL PLEASE                @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         C     R15,=F'8'           PROBLEMS?                       @122\n         BNE   VVDS0               NO. IS IT A VVR?                @122\n        $MESSAGE 3,DATA=COMPNAME                                   @122\n         B     VVDS98              RETURN WITH RC=8                @122\nVVDS0B   SR    R1,R1\n         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.\n         BCTR  R1,0\n         BCTR  R1,0\n         B     VVDS0C\n         CLC   COMPNAME(0),VVRCMPNM  (EXECUTED)\nVVDS0C   EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.\n         BNE   VVDS0A              NO, MUST BE A RELATED COMPONENT.\nVVDS0D   CLI   2(R6),C'Q'          Q = SECONDARY VVR\n         BE    VVDS1               YES, IS IT THE RIGHT ONE?\n         CLI   2(R6),C'Z'          Z = PRIMARY VVR\n         BE    VVDS2               YES, IS IT THE RIGHT ONE?\n         B     VVDS99              SHOULD NEVER HAPPEN!\nVVDS1    MVC   VVD0,=X'0000FF23'   VOLUME INFORMATION CELL         @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         LTR   R15,R15             WAS THERE A VOLINFO CELL?       @134\n         BNZ   VVDS2               NO.                             @134\n         MVI   VOLINFSW,X'FF'\n         USING VVRVOLIN,R6\n         SR    R1,R1               COUNT OF TRACKS\n         SR    R8,R8\n         ICM   R8,1,VVRNOEXT       GET NUMBER OF EXTENTS\n         ST    R8,EXTENTS\n         LA    R6,40(0,R6)         SKIP AHEAD TO EXTENT DESCR.\n         USING VVRXTENT,R6\nVVDS1B   AH    R1,VVRXNTRK         COUNT TRACKS THIS EXTENT\n         LA    R6,20(0,R6)         SKIP TO NEXT EXTENT DESCR.\n         BCT   R8,VVDS1B\n         ST    R1,TRACKS           SAVE ALLOCATED TRACKS.\n         CLI   VOLDSSW,X'FF'       GOT DATASET INFORMATION CELL YET?\n         BNE   VVDS2               NO, GO GET IT.\n         B     VVDS99\n         DROP  R6\nVVDS2    MVC   VVD0,=X'00000021'   DATASET INFORMATION CELL.       @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         MVI   VOLDSSW,X'FF'\n         USING VVRDSINF,R6\n         MVI   SHREG,C'1'\n         MVI   SHSYS,C'1'\n         TM    VVRATTR2,VVRA2REG\n         BM    VVDS3A\n         BNO   VVDS3\n         MVI   SHREG,C'4'\n         B     VVDS3\nVVDS3A   EQU   *\n         TM    VVRATTR2,B'01000000'\n         BNO   VVDS3B\n         MVI   SHREG,C'2'\n         B     VVDS3\nVVDS3B   EQU   *\n         MVI   SHREG,C'3'\nVVDS3    EQU   *\n         TM    VVRATTR2,VVRA2SYS\n         BM    VVDS4A\n         BNO   VVDS4\n         MVI   SHSYS,C'4'\n         B     VVDS4\nVVDS4A   EQU   *\n         TM    VVRATTR2,B'00010000'\n         BNO   VVDS4B\n         MVI   SHSYS,C'2'\n         B     VVDS4\nVVDS4B   EQU   *\n         MVI   SHSYS,C'3'\nVVDS4    EQU   *\n         MVC   LRECL,VVRLRECL      SAVE AVERAGE LRECL\n         ICM   R1,7,VVRSECSP       PICK UP SECONDARY SPACE.        @130\n         CVD   R1,WORK             CONVERT TO DECIMAL.             @130\n         $EDITP  L1ALSEC,                                          @130X\n               DWK3,ZZZZ9          FORMAT IT.                      @130\n         ICM   R1,7,VVRPRISP       PICK UP PRIMARY SPACE.          @130\n         CVD   R1,WORK             CONVERT TO DECIMAL.             @130\n         $EDITP  L1ALPRM,                                          @130X\n               DWK3,ZZZZ9          FORMAT IT.                      @130\n         TM    VVRSPCFG,DS1CYL     CYLINDER ALLOCATION\n         BM    VVDS1Z\n         MVC   L1ALTYP,=C'CYL'\n         B     VVDS1C\nVVDS1Z   TM    VVRSPCFG,DS1TRK     TRACK ALLOCATION\n         BZ    VVDS1Y\n         MVC   L1ALTYP,=C'TRK'\n         B     VVDS1C\nVVDS1Y   TM    VVRSPCFG,DS1AVR     BLOCK ALLOCATION\n         BZ    VVDS1Y\n         MVC   L1ALTYP,=C'BLK'\nVVDS1C   SR    R1,R1               CLEAR REGISTER                  @130\n         ICM   R0,15,VVRDSHU       GET HIGH USED RBA.              @130\n         SRDA  R0,32               READY FOR MULTIPLY              @130\n         M     R0,=F'100'          TIMES 100.                      @130\n*        LR    R0,R1                                               @130\n*        SRDA  R0,32               READY FOR DIVIDE.               @130\n         ICM   R2,15,VVRDSHA       GET HIGH ALLOC RBA              @130\n         DR    R0,R2               (USED*100)/ALLOC                @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1USED,                                           @130X\n               DWK2,ZZ9            FORMATTED.                      @130\n         DROP  R6\n         MVC   VVD0,=X'0000FF60'   NEED AN AMDSB NEXT              @134\n         L     R15,=V(FINDVVDS)                                    @134\n         BASR  R14,R15             SCAN VVDS                       @134\n         LTR   R15,R15             WAS THERE AN AMDSB?             @134\n         BNZ   VVDS1               NO. TRY A VOL INFO CELL.        @134\n         USING VVRAMDCL,R6\n         SR    R1,R1               CLEAR REGISTER                  @130\n         ICM   R1,1,VVRAMPCA       PICK UP CA FREESPACE %          @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1CAFS,                                           @130X\n               DWK2,Z9             AND FORMAT.                     @130\n         SR    R1,R1               CLEAR REGISTER                  @130\n         ICM   R1,1,VVRAMPCI       PICK UP CI FREESPACE %          @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1CIFS,                                           @130X\n               DWK2,Z9             AND FORMAT.                     @130\n         ICM   R1,15,VVRAMCAS      PICK UP CA SPLITS.              @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1CASP,                                           @130X\n               DWK2,ZZZ9           FORMAT IT NICELY.               @130\n         ICM   R1,15,VVRAMCIS      PICK UP CI SPLITS.              @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1CISP,                                           @130X\n               DWK2,ZZZ9           FORMAT IT NICELY.               @130\n         MVC   L1CRSHR,SHREG\n         MVC   L1CSSHR,SHSYS\n         SR    R1,R1               CLEAR REGISTER                  @130\n         ICM   R1,3,VVRAMRKP       PICK UP MAX KEY POSITION.       @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1KPOS,                                           @130X\n               DWK2,ZZ9            FORMAT IT NICELY.               @130\n         SR    R1,R1               CLEAR REGISTER                  @130\n         ICM   R1,3,VVRAMKNL       PICK UP KEY LENGTH.             @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1KLEN,                                           @130X\n               DWK2,ZZ9            FORMAT IT NICELY.               @130\n*        MVC   EXTENTS,VVRAMNXT    GET NUMBER OF EXTENTS.\n         ICM   R1,15,VVRAMLCL      PICK UP MAX RECORD LENGTH.      @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1MRECL,                                          @130X\n               DWK3,ZZZZZ9         FORMAT IT NICELY.               @130\n         ICM   R1,15,VVRAMNLR      PICK UP NUMBER OF RECORDS.      @130\n         CVD   R1,WORK             CONVERT TO DECIMAL              @130\n         $EDITP  L1NOREC,                                          @130X\n               DWK4,ZZZZZZZ9       FORMAT IT NICELY.               @130\n         MVC   BLKSIZE,VVRAMCIV    SAVE BLOCK SIZE.\n         CLI   VOLINFSW,X'FF'      GOT VOLUME INFORMATION CELL YET?\n         BNE   VVDS1               LOOK FOR VOLUME INFORMATION CELL\n         DROP  R6\nVVDS99   DS    0H\n        $EPILOG ,                                                  @134\nVVDSR9   DC    F'0'\nVVDS98   LA    R15,8               RC=8 FOR CALLER.                @122\n         B     VVDS99                                              @122\n         LTORG ,                                                   @134\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRCLOSE": {"ttr": 5388, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SYMBOL  XPRCLOSE  &WA\n.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.\n         CNOP  0,4\n&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS\n         XPRINNRA  &WA,68\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRDCB": {"ttr": 5390, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPREJECT": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x00\\x97&\\x0f\\x00\\x97&\\x0f\\x15E\\x002\\x002\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "1997-09-17T15:45:36", "lines": 50, "newlines": 50, "modlines": 0, "user": "IBMUSER"}, "text": "         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'COND TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRHEAD": {"ttr": 5635, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SYMBOL  XPRHEAD  &WA,&LIST=\n.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS\n.* TO 'XPRNTSUB'.\n&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRINNRA": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x00\\x97&\\x0f\\x00\\x97&\\x0f\\x15E\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "1997-09-17T15:45:51", "lines": 15, "newlines": 15, "modlines": 0, "user": "IBMUSER"}, "text": "         MACRO\n&TAG     XPRINNRA  &WA,&IHBPARM\n.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'\n         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS\n&TAG     L     15,*-4                  LOAD ENTRY POINT\n         AIF   ('&WA' NE '').WOK\n         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS\n         AGO   .BAL\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA                   LOAD WORK AREA ADDRESS\n         AGO   .BAL\n.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS\n.BAL     BAS   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRLDEF": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x05#\\x0f\\x01\\x05#\\x0f\\x13\\x12\\x004\\x003\\x00\\x03\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-08-18T00:00:00", "modifydate": "2005-08-18T13:12:01", "lines": 52, "newlines": 51, "modlines": 3, "user": "MSTITT"}, "text": "         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    AL4(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))                 POST-SPACING\n         AGO   .NDEF\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n.NDEF    ANOP\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XPRLIST": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00P\\x00\\x97&\\x0f\\x01\\x05#\\x0f\\tT\\x00/\\x00/\\x00\\x03\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "2005-08-18T09:54:50", "lines": 47, "newlines": 47, "modlines": 3, "user": "MSTITT"}, "text": "         MACRO\n&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32\n.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.\n         LCLA  &N,&K,&D\n         LCLC  &TAG,&SYM,&R\n         ACTR  100\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&LIST' NE '').LOK\n         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'\n         MEXIT\n.LOK     CNOP  0,4\n         AIF   ('&LIST' NE '(1)').STLOOP\n&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS\n         AGO   .VCON\n.STLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).STDONE\n         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP\n&K       SETA  K'&LIST(&N)-2\n&R       SETC  '&LIST(&N)'(2,&K)\n&D       SETA  4*(&N-1)\n&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST\n&SYM     SETC  ''\n         AIF   (&N NE N'&LIST).STLOOP\n         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT\n.STDONE  ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM LIST ADDRESS\n&SYM     SETC  '&TAG.A'\n&N       SETA  0\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).VCON\n         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG\n&SYM     DC    A(0)\n&SYM     SETC  ''\n         AGO   .LOOP\n.NOTREG  AIF   (&N GT N'&LIST).LAST\n&SYM     DC    A(&LIST(&N))\n&SYM     SETC  ''\n         AGO   .LOOP\n.LAST    ANOP\n.VCON    ANOP\n&SYM     DC    X'80'                   END-OF-LIST BIT\n         DC    AL3(0)\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRMOD": {"ttr": 5643, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRNTLIN": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x01\\x00\\x97&\\x0f\\x01\\x05#\\x0f\\x11B\\x00Y\\x00X\\x00*\\xd4\\xe2\\xe3\\xc9\\xe3\\xe3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "2005-08-18T11:42:01", "lines": 89, "newlines": 88, "modlines": 42, "user": "MSTITT"}, "text": "         MACRO\n&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1\n         LCLA  &N\n         LCLC  &B3,&B6,&B7,&T,&R\n         ACTR  25\n&T       SETC  'IHB&SYSNDX'\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:\n         CNOP  0,4\n         AIF   ('&SYMBOL' EQ '').IFR1\n&SYMBOL  DS    0H\n.IFR1    AIF   ('&TEXT' NE '00').TXTOK\n         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'\n.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2\n         ST    &TEXT(1),&T.A+0         STORE TEXT ADDRESS\n         MVI   &T.A+8,B'000&B3.00&B6&B7' INSERT OPTION BITS\n.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3\n         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH\n.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4\n         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET\n.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5\n&N       SETA  K'&SPB(1)-2\n&R       SETC  '&SPB(1)'(2,&N)\n         STC   &R,&T.A+6               STORE PRE-SPACING\n.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1\n&N       SETA  K'&SPA(1)-2\n&R       SETC  '&SPA(1)'(2,&N)\n         STC   &R,&T.A+7               STORE POST-SPACING\n.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:\n.LOAD1   BAS   1,&T.L                  LOAD PARM ADDRESS\n         DC    AL4(&T.A)               ADDRESS OF PLD\n         DC    X'80'                   MARK END OF ADDRESS LIST\n         DC    XL3'00'                 DUMMY ADDRESS\n.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:\n.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11\n&T.A     DC    AL4(0)                  TEXT ADDRESS\n         AGO   .IFR12\n.NOTR11  ANOP\n&T.A     DC    AL4(&TEXT)              TEXT ADDRESS\n.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12\n         DC    AL1(0)                  TEXT LENGTH\n         AGO   .IFR13\n.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH\n.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13\n         DC    AL1(0)                  MARGIN OFFSET\n         AGO   .IFR14\n.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET\n.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14\n         DC    AL1(0)                  PRE-SPACING\n         AGO   .IFR15\n.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .IFR15\n.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING\n.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15\n         DC    AL1(0)                  POST-SPACING\n         AGO   .VCON\n.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         AGO   .VCON\n.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING\n.VCON    ANOP\n         DC    B'000&B3.00&B6&B7'      OPTION BITS\n&T.L    XPRINNRA  &WA,32\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPROPEN": {"ttr": 5648, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x00\\x97&\\x0f\\x00\\x97&\\x0f\\x15F\\x009\\x009\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "1997-09-17T15:46:10", "lines": 57, "newlines": 57, "modlines": 0, "user": "IBMUSER"}, "text": "         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAS   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XPRSPACE": {"ttr": 5650, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x00\\x97&\\x0f\\x00\\x97&\\x0f\\x15F\\x00 \\x00 \\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-17T00:00:00", "modifydate": "1997-09-17T15:46:16", "lines": 32, "newlines": 32, "modlines": 0, "user": "IBMUSER"}, "text": "         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAS   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT527/FILE527.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT527", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}