{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011302000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE128.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE128.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x05'", "DS1TRBAL": "b'\\x8d\\xb6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xcd\\x00\\x07\\x00\\xcd\\x00\\x0e\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$INDEX": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n  ********************************************************************\n  *** NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE ***\n  *** NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE ***\n  *** NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE ***\n  *** NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE * NOTICE ***\n  ********************************************************************\n\n\n  The enclosed material is provided to you from the Information Systems\n  Department of The Church of Jesus Christ of Latter-day Saints.  This\n  is being done in an effort to share useful routines and information\n  with other data processing users.  In accepting this material, you\n  agree to the following conditions:\n\n\n  1.  The Church assumes no responsibility for the accuracy, support,\n      or applicability of this information.  The receiving organization\n      must understand that it uses this material at its own risk.\n\n\n  2.  The receiving organization may share this material with other\n      users, but it may not receive any payment or other financial\n      advantage from that sharing.\n\n ******************************************************************************\n ***                                                                        ***\n ***  THIS PDS CONTAINS THREE APPLICATIONS - 1) ISPF APPLICATION THAT       ***\n ***  ALLOWS THE ENTRY OF VTAM COMMANDS AND THE VIEWING OF THE RESULTS.     ***\n ***  2) A MVS/XA (2.2) ACTIVITY DISPLAY (BASED ON CHIMP) 3) A SYSLOG SCAN  ***\n ***  FACILITY.  THE SYSLOG SCAN FACILITY HAS BEEN TESTED UNDER MVS/XA      ***\n ***  2.1.7 AND MVS 2.2.0 WITH JES2 2.1.5.  ANY OTHER RELEASES OF MVS OR    ***\n ***  JES2 MAY REQUIRE PROGRAM MODIFICATIONS AS THE PROGRAM IS DEPENDANT    ***\n ***  ON MESSAGE NUMBERS.  SEE MEMBER UT017DOC FOR MORE DETAILS.            ***\n ***                                                                        ***\n ******************************************************************************\n\n\n              ******************************************\n              ***                                    ***\n              *** SUMMARY OF THE MEMBERS IN THIS PDS ***\n              ***                                    ***\n              ******************************************\n\n\n -----> $$$INDEX\n           THE MEMBER YOU ARE READING NOW.\n\n -----> ACT\n           MVS ACTIVITY DISPLAY.\n\n -----> APPLVTAM\n           OUR VTAMLST MEMBER FOR THE VTAM/ISPF COMMAND FACILITY.\n\n -----> SP1TC014\n           THE PROGRAM (ASSEMBLER) FOR THE VTAM/ISPF COMMAND FACILITY.\n           IT ALLOWS THE ENTRY OF VTAM COMMANDS WITH THE RECEIPT OF\n           THE RESPONSES.  IT HAS MANY SHORCUTS - \"R NODENAME\" TO DO\n           A \"V NET,INACT,R,ID=NODENAME\" FOR EXAMPLE.\n\n -----> SP1UT017\n           THE SYSLOG SCAN PROGRAM.\n\n -----> SP1VO00\n           THE ISPF PANEL FOR THE VTAM/ISPF COMMAND FACILITY.\n\n -----> SP1VO00A\n           THE ISPF HELP PANEL FOR THE VTAM/ISPF COMMAND FACILITY.\n\n -----> SP10\n           THE ISPF MESSAGES MEMBER FOR THE VTAM/ISPF COMMAND FACILITY.\n\n -----> SYSENTER\n           A VERY GENERAL PURPOSE ASSEMBLER PROGRAM ENTRY MACRO.  IT\n           SUPPORTS BOTH REENTRANT AND NON-REENTRANT PROGRAMS AND WILL\n           ALSO GETMAIN YOUR WORK AREA ALONG WITH YOUR SAVE AREA.  SEE\n           THE INTERNAL DOCUMENTATION FOR MORE DETAILS.  USED BY BOTH\n           SP1TC014 AND SP1UT017.\n\n -----> SYSRETRN\n           THE RETURN MACRO CORRESPONDING TO SYSENTER.  IT USES GLOBAL\n           VARIABLES SET IN SYSENTER TO DETERMINE WHETHER OR NOT TO\n           FREEMAIN THE SAVE AND WORK AREAS.  SEE THE INTERNAL\n           DOCUMENTATION FOR MORE DETAILS.\n\n -----> UT017DOC\n           DOCUMENTATION (FBA FORMAT) FOR THE SYSLOG SCAN FACILITY.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ACT": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET WHFACT     AT LEVEL 009 AS OF 03/31/89\n*          DATA SET WHFACT     AT LEVEL 005 AS OF 07/18/86\n*          DATA SET TOACT      AT LEVEL 030 AS OF 01/24/85\n***********************************************************************\n*                                                                     *\n*    PROGRAM NAME:                ACT - BASED ON CHIMP                *\n*                                                                     *\n*    AUTHOR:                      FRANCIS                             *\n*                                                                     *\n*    PURPOSE:                     TSO ACTIVITY DISPLAY COMMAND        *\n*                                                                     *\n*    DATE WRITTEN:                03/11/83                            *\n*                                                                     *\n*    SOURCE LIBRARY:              SKG.SYSPAN (PANDD7)                 *\n*                                                                     *\n*    LOAD LIBRARY:                SYS1.COMMON.CMDLIB                  *\n*                                                                     *\n*    ATTRIBUTES:                  STD                                 *\n*                                                                     *\n*    UPDATES:             02/84 - ADD FULL SCREEN AND PF3 SUPPORT     *\n*                         07/86 - UPDATE FOR MVS/XA                   *\n*                               - UPDATE FOR XA 2.2                   *\n*                                                                     *\n*    INPUT:                       COMMANDS FROM TSO TERMINAL          *\n*                                                                     *\n*    OUTPUT:                      SCREEN SHOWING ACTIVE TASKS         *\n*                                                                     *\n*    MESSAGES:                    NONE                                *\n*                                                                     *\n*    METHOD:                                                          *\n*                                                                     *\n*        LOOP THROUGH ASCB'S USING THE ASVT.  FORMAT A LINE ON THE    *\n*        OUTPUT SCREEN FOR EACH SELECTED MEMORY.  THE DISPLAY MAY     *\n*        BE CHANGED THROUGH TERMINAL INPUT AND IS CONTROLED BY THE    *\n*        VARIABLE 'FLAG'.                                             *\n*                                                                     *\n*    REGISTER USAGE:                                                  *\n*                                                                     *\n*        R0  - LINKAGE                                                *\n*        R1  - LINKAGE, WORK                                          *\n*        R2  - WORK                                                   *\n*        R3  - COUNTER OF ASCB'S TO PROCESS                           *\n*        R4  - POINTER INTO ASVT, WORK                                *\n*        R5  - BASE FOR ASCB, WORK                                    *\n*        R6  - BASE FOR OUCB, WORK                                    *\n*        R7  - WORK, BASE FOR CSCB                                    *\n*        R8  - WORK                                                   *\n*        R9  - WORK                                                   *\n*        R10 - WORK                                                   *\n*        R11 - WORK                                                   *\n*        R12 - ADDRESS OF BUFFER WHILE BUILDING OUTPUT                *\n*        R13 - SAVE AREA, PROGRAM BASE                                *\n*        R14 - LINKAGE                                                *\n*        R15 - LINKAGE                                                *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*\n* THIS COMMAND HAS SEVERAL DIFFERENT MODES OF DISPLAY:\n*\n*     I   - THIS MODE WILL DISPLAY ONLY THOSE MEMORIES WHICH ARE EITHER\n*           SWAPPED IN AND RUNNING OR SWAPPED OUT BUT READY TO RUN.\n*     O   - (DEFAULT) - THIS MODE WILL DISPLAY ALL ACTIVE MEMORIES IN\n*           THE SYSTEM, REGARDLESS OF LOCATION.\n*\n*   TO SWITCH BETWEEN MODES, TYPE EITHER I OR O.\n*\n*\n*      YOU MAY ALSO ENTER OPTIONS TO RESTRICT THE OUTPUT TO ONLY\n*      TSO MEMORIES (IN EITHER IN/OUT OR WAITING STATUS ACCORDING\n*      TO YOUR USE OF THE I AND O OPTIONS ABOVE) OR ONLY STARTED\n*      TASK/BATCH JOB MEMORIES:\n*\n*     T  - RESTRICTS THE OUTPUT TO ONLY TSO MEMORIES\n*\n*     B  - RESTRICTS THE OUTPUT TO BATCH MEMORIES\n*\n*     S  - RESTRICTS THE OUTPUT TO STARTED TASK AND ONLINE MEMORIES\n*\n*     A  - GIVES ALL THE ABOVE\n*\n*   TO EXIT FROM THIS COMMAND, SIMPLY TYPE E\n*\n***********************************************************************\nACT      TITLE 'ACT - MAIN STORAGE MONITOR FOR TSO - 3270S'\nACT      SYSENTER SYMREG=YES\nACT      AMODE 31\nACT      RMODE 24\n         PRINT NOGEN\n         STFSMODE ON,INITIAL=YES   SET FULLSCREEN MODE\n         EJECT\n#ACT0010 DS    0H\n         SR    R1,R1               R1<--A(PSA)\n         USING PSA,R1\n         L     R1,FLCCVT           R1<--A(CVT)\n         USING CVT,R1\n         L     R1,CVTASVT          R1<--A(ASVT)\n         USING ASVT,R1\n         L     R3,ASVTMAXU      MAXIMUM NUMBER OF ENTRIES\n         LA    R4,ASVTFRST      FIRST ENTRY\n         LA    R12,BUFFER       LOAD ADDRESS OF OUTPUT BUFFER.\n         DROP  R1\n***********************************************************************\n*    R4 CONTAINS THE POINTER INTO THE ADDRESS SPACE VECTOR TABLE.\n*    IF THE HIGH ORDER BIT IS ON THEN THE ASID IS AVAILABLE AND\n*    NOT ASSIGNED TO A JOB OR TASK.\n***********************************************************************\n#ACT0020 DS    0H\n         LA    R4,4(,R4)           BUMP BY FOUR.\n         ICM   R5,B'1111',0(R4)    R5<--A(ASCB).\n         BM    #ACT0350            BRANCH IF NOT IN USE.\n         USING ASCB,R5\n         MVI   LINE+2,C' '         CLEAR OUTPUT LINE TO BLANKS.\n         MVC   LINE+3(78),LINE+2   DITTO\n***********************************************************************\n*    TEST FOR SWAPPED IN/SWAPPED OUT\n***********************************************************************\n         L     R6,ASCBOUCB        R6<--A(OUCB)\n         USING OUCB,R6\n         TM    OUCBQFL,OUCBLSW    CHECK FOR A LOGICAL SWAP\n         BO    #ACT0030           CONSIDER LOGICAL SWAPS AS BEING IN\n         TM    ASCBRCTF,ASCBOUT   TEST FOR SWAPPED OUT.\n         BNO   #ACT0030           BRANCH IF SWAPPED IN\n         TM    FLAG,O             SWAPPED OUT MEMORIES REQUESTED ???\n         BNO   #ACT0350           ...NO: SKIP THIS ASCB\n#ACT0030 DS    0H\n         MVC   JOB(8),=CL8'STARTING'  TO BYPASS GARBAGE\n         ICM   R7,B'1111',ASCBJBNI    LOAD PTR TO JOBNAME.\n         BZ    #ACT0033            BRANCH IF ZERO POINTER.\n         MVC   JOB,0(R7)           OTHERWISE, MOVE IN JOBNAME.\n         S     R7,=A(CHKEY-CSCB)   POINT TO START OF CSCB\n         B     #ACT0036            BYPASS FURTHER JOBNAME PROCESSING.\n#ACT0033 DS    0H\n         ICM   R7,B'1111',ASCBJBNS    1TR IF S/M/L.\n         BZ    #ACT0036            BYPASS THIS MOVE IF POINTER IS ZERO.\n         MVC   JOB,0(R7)           MOVE IN JOBNAME FOR S/M/L MEMORIES.\n         S     R7,=A(CHCLS-CSCB)   POINT TO START OF CSCB\n         CLI   JOB,C'*'           IS THIS THE MASTER SCHEDULER ???\n         BNE   #ACT0036           ...NO: CONTINUE ON\n         SR    R7,R7              MASTER SCHED DOES NOT POINT TO CSCB\n         EJECT\n***********************************************************************\n*    TEST FOR TSO USER (LOGON CREATED USER BIT)\n***********************************************************************\n#ACT0036 DS    0H\n         TM    OUCBYFL,OUCBLOG    CHECK FOR TSO (LOGON CREATED)\n         BNO   #ACT0040           BRANCH IF NOT TSO\n         TM    FLAG,T             TSO MEMORIES REQUESTED ???\n         BNO   #ACT0350           ...NO: SKIP THIS ASCB\n         LA    R7,8(R7)           READJUST CSCB POINTER\n         MVI   TYPE,C'T'          SHOW TSO MEMORY\n         B     #ACT0060           ..YES: PROCESS THIS ASCB\n***********************************************************************\n*    TEST FOR STARTED TASK OR MOUNT (NON-INITIATED JOB)\n***********************************************************************\n#ACT0040 DS    0H\n         LTR   R7,R7              WAS CSCB FOUND ???\n         BZ    #ACT0045           ...NO: ASSUME STC\n         USING CSCB,R7\n         CLI   CHTRKID,CHJOBID    INITIATED JOB ???\n         BE    #ACT0050           ..YES: GO TEST FOR IT\n#ACT0045 DS    0H\n         TM    FLAG,S             STC/MOUNT MEMORIES REQUESTED ???\n         BNO   #ACT0350           ...NO: SKIP THIS ASCB\n         CLC   JOB,=CL8'INIT'     CHECK FOR INITIATOR\n         BE    #ACT0350           NEVER SHOW INACTIVE INITIATORS\n         MVI   TYPE,C'S'          SHOW STC MEMORY\n         B     #ACT0060           ..YES: PROCESS THIS ASCB\n***********************************************************************\n*    BATCH JOB - CHECK JOBNAME FOR SPECIAL PROCESSING\n***********************************************************************\n#ACT0050 DS    0H\n         CLI   CHVCD,X'04'        CHECK TO SEE IF BATCH JOB OR S/M/L\n         BE    #ACT0045           JOB IS START OR MOUNT\n         CLI   CHVCD,X'0C'        CHECK TO SEE IF BATCH JOB OR S/M/L\n         BE    #ACT0045           JOB IS START OR MOUNT\n         MVI   TYPE,C'B'          SHOW BATCH MEMORY\n         CLC   JOB,=CL8'CICS'     CICS ???\n         BE    #ACT0053           ..YES: SPECIAL TEST\n         CLC   JOB,=CL8'CICSTEST' CICSTEST ???\n         BE    #ACT0053           ..YES: SPECIAL TEST\n         CLC   JOB,=CL8'CICSAP'   CICSAP ???\n         BE    #ACT0053           ..YES: SPECIAL TEST\n         CLC   JOB,=CL8'NCCF'     NCCF ???\n         BE    #ACT0053           ..YES: SPECIAL TEST\n         CLC   JOB,=CL8'HCF'      HCF ???\n         BE    #ACT0053           ..YES: SPECIAL TEST\n         CLC   JOB,=CL8'PHOENIX'  PHOENIX ???\n         BE    #ACT0053           ..YES: SPECIAL TEST\n         B     #ACT0056           ...NO: CONTINUE ON\n         EJECT\n***********************************************************************\n*    ONLINE JOB - SHOW ONLY IF STARTE TASKS AND MOUNTS WERE REQUESTED\n***********************************************************************\n#ACT0053 DS    0H\n         TM    FLAG,S             STC/MOUNT/ONLINE REQUESTED ???\n         BNO   #ACT0350           ...NO:SKIP IT\n         B     #ACT0060           ..YES: PROCESS THIS ASCB\n***********************************************************************\n*    BATCH JOB - CHECK TO SEE IF BATCH JOBS ARE TO BE DISPLAYED\n***********************************************************************\n#ACT0056 DS    0H\n         TM    FLAG,B             DISPLAY BATCH MEMORIES ???\n         BNO   #ACT0350           ...NO: SKIP IT\n***********************************************************************\n*    MEMORY IS TO BE DISPLAYED - BUILD THE OUTPUT LINE FOR THIS MEMORY\n*    JOBNAME HAS BEEN SET - GET STEP AND PROCSTEP\n***********************************************************************\n#ACT0060 DS    0H\n         LTR   R7,R7              WAS CSCB FOUND ???\n         BZ    #ACT0120           ...NO: SKIP MOVES\n         CLI   CHVCD,X'04'        CHECK TO SEE IF BATCH JOB OR S/M/L\n         BE    #ACT0090           JOB IS START OR MOUNT\n         CLI   CHVCD,X'0C'        CHECK TO SEE IF BATCH JOB OR S/M/L\n         BE    #ACT0090           JOB IS START OR MOUNT\n         CLI   CHSTEP,X'00'       IS STEPNAME GIVEN ??\n         BE    #ACT0100           ...NO\n         MVC   STEP(8),CHSTEP     STEPNAME IS CHSTEP\n         B     #ACT0100           BYPASS FURTHER CSCB PROCESSING.\n#ACT0090 DS    0H\n         CLI   CHKEY,X'00'        IS STEPNAME GIVEN ??\n         BE    #ACT0100           ...NO\n         MVC   STEP(8),CHKEY      STEPNAME IS CHKEY\n#ACT0100 DS    0H\n         CLI   TYPE,C'T'                 TSO USER ???\n         BNE   #ACT0110                  ...NO: GO GET PROCSTEP\n         MVC   PROCSTEP,=CL8'TSO USER'   ..YES: SHOW IT\n         CLI   CHCLS,X'00'               IS STEP GIVEN ??\n         BE    #ACT0120                  ...NO\n         MVC   STEP,CHCLS                ..YES: SET STEP\n         B     #ACT0120           CONTINUE ON\n#ACT0110 DS    0H\n         CLI   CHPROCSN,X'00'     IS PROCSTEP GIVEN ??\n         BE    #ACT0120           ...NO\n         MVC   PROCSTEP,CHPROCSN  SET PROCSTEP\n         DROP  R7\n         EJECT\n***********************************************************************\n*    SHOW IF JOB IS SWAPPED IN OR OUT, OR IS IN TRANSITION\n***********************************************************************\n#ACT0120 DS    0H\n         MVI   LINE+1,X'E8'        DEFAULT TO HI-INTENSITY PROTECTED.\n         TM    OUCBQFL,X'E0'       CHECK FOR TRANSITIONING STATUS\n         BZ    #ACT0122            BRANCH IF MEMORY NOT TRANSITIONING.\n         MVC   STATUS,=CL3'<->'    INDICATE TRANSITIONING.\n         B     #ACT0160            BY-PASS REST OF POSITION PROCESSING.\n#ACT0122 DS    0H\n         TM    OUCBQFL,OUCBLSW     CHECK FOR LOGICAL SWAP INDICATOR.\n         BZ    #ACT0124            IF NOT, GO CHECK SWAP STATUS\n         MVC   STATUS,=CL3'LSW'    MOVE IN LOGICAL SWAP INDICATOR.\n         B     #ACT0160            BY-PASS REST OF POSITION PROCESSING.\n#ACT0124 DS    0H\n         TM    ASCBRCTF,ASCBOUT    TEST FOR SWAPPED OUT\n         BO    #ACT0130            BRANCH IF SWAPPED OUT.\n         CLC   OUCBNDS,=H'0'       TEST FOR NON-SWAP\n         BE    #ACT0126            BRANCH IF NOT NON-SWAP.\n         MVC   STATUS,=CL3'N/S'    MOVE IN NON-SWAP INDICATION.\n         B     #ACT0160            BY-PASS REST OF POSITION PROCESSING.\n#ACT0126 DS    0H\n         MVC   STATUS,=CL3'IN'     SET MEMORY POSITION TO IN.\n         B     #ACT0160            BY-PASS REST OF POSITION PROCESSING.\n#ACT0130 DS    0H\n         MVI   LINE+1,X'60'        MOVE IN 3270 LOW-INTENSITY ATTR BYTE\n         MVC   STATUS,=CL3'OUT'    MOVE IN OUT QUEUE POSITION.\n         B     #ACT0170            GO GET SWAP REASON\n#ACT0160 DS    0H\n         SR    R1,R1              CLEAR R1\n         ICM   R1,3,ASCBFMCT       LOAD ALLOC FRAME COUNT.\n         SLL   R1,2                MULTIPLY BY FOUR.\n         CVD   R1,WORK                 CONVERT TO DECIMAL FORMAT.\n         MVC   SIZE,=X'2020202120D2'   GET READY FOR EDIT.\n         ED    SIZE-1(6),WORK+5        EDIT THE RESULT.\n         B     #ACT0180\n***********************************************************************\n*    JOB IS SWAPPED OUT - PUT SWAP REASON IN PLACE OF MEMORY USAGE\n***********************************************************************\n#ACT0170 DS    0H\n         L     R1,=A(SWAPTBL)     R1<--A(SWAP REASON TABLE)\n#ACT0172 DS    0H\n         CLC   OUCBSRC(1),0(R1)   CHECK REASON CODE\n         BE    #ACT0174           ...MATCH\n         LA    R1,6(R1)           BUMP TO NEXT ENTRY\n         CLI   0(R1),X'FF'        END OF TABLE ???\n         BNE   #ACT0172           ...NO: CONTINUE SCAN\n#ACT0174 DS    0H\n         MVI   STATUS+4,C'-'\n         MVC   SIZE(5),1(R1)      GIVE SWAP REASON\n         EJECT\n***********************************************************************\n*    GET SWAP COUNT\n***********************************************************************\n#ACT0180 DS    0H\n         LH    R7,OUCBSWC          LOAD SWAP COUNT.\n         CVD   R7,WORK                CONVERT IT TO DECIMAL.\n         MVC   SWAPCNT(3),=X'202120'  MOVE IN THE EDIT MASK.\n         ED    SWAPCNT-1(4),WORK+6    EDIT THE OUTPUT FIELD.\n***********************************************************************\n*    GET SERVICE UNITS\n***********************************************************************\n#ACT0310 DS    0H\n         L     R7,OUCBWMS       LOAD SERVICE UNITS THIS XACTION\n         CVD   R7,WORK                         CONVERT TO DECIMAL.\n         MVC   SERVICE(7),=X'20202020202120'   MOVE IN THE EDIT MASK.\n         ED    SERVICE-1(8),WORK+4             EDIT THE RESULT.\n***********************************************************************\n*    GET NON-SPOOL I/O COUNT\n***********************************************************************\n         L     R7,ASCBIOSC      LOAD I/O COUNT\n         CVD   R7,WORK                         CONVERT TO DECIMAL.\n         MVC   IOCNT(7),=X'20202020202120'     MOVE IN THE EDIT MASK.\n         ED    IOCNT-1(8),WORK+4               EDIT THE RESULT.\n***********************************************************************\n*    CALCULATE CPU TIME\n***********************************************************************\n#ACT0320 DS    0H\n         LM    R8,R9,ASCBEJST   LOAD UP EJST (CPU TIME - TASK TYPE)\n         SRDL  R8,12            TO GET MICROSEC\n         D     R8,=F'10000'     TO GET MICROSEC\n         LM    R10,R11,ASCBSRBT LOAD UP SRB TIME.\n         SRDL  R10,12           TO GET MICROSEC\n         D     R10,=F'10000'    TO GET HUNDREDTHS\n         AR    R9,R11           ADD TOGETHER.\n         MVC   CPUTIME(11),=C'  .  .  .  '\n         SR    R8,R8\n         D     R8,=F'100'         GET MICROSECS\n         CVD   R8,WORK          CONVERT MICROSECS TO DECIMAL\n         UNPK  CPUTIME+9(2),WORK   CONVERT THE RESULT\n         OI    CPUTIME+10,X'F0'    MAKE IT PRINTABLE\n         SR    R8,R8\n         D     R8,=F'60'          GET SECONDS\n         CVD   R8,WORK          CONVERT SECONDS TO DECIMAL\n         UNPK  CPUTIME+6(2),WORK   CONVERT THE RESULT\n         OI    CPUTIME+7,X'F0'     MAKE IT PRINTABLE\n         SR    R8,R8\n         D     R8,=F'60'          GET MINUTES AND HOURS\n         CVD   R8,WORK          CONVERT MINUTES TO DECIMAL\n         UNPK  CPUTIME+3(2),WORK   CONVERT THE RESULT\n         OI    CPUTIME+4,X'F0'     MAKE IT PRINTABLE\n         CVD   R9,WORK          CONVERT HOURS TO DECIMAL\n         UNPK  CPUTIME(2),WORK   CONVERT THE RESULT\n         OI    CPUTIME+1,X'F0'     MAKE IT PRINTABLE\n         EJECT\n***********************************************************************\n*    THE LINE FOR THIS MEMORY IS FINISHED - SET IT IN OUTPUT\n*    BUFFER AND GO GET NEXT MEMORY IF THERE IS STILL ROOM\n***********************************************************************\n         TR    LINE+2(79),TRTAB PREVENT GARBAGE IN LINE\n         MVC   0(81,R12),LINE   MOVE THE LINE TO THE 3270 BUFFER.\n         LH    R7,SCRSIZE       BUMP BUFFER COUNTER.\n         LA    R7,81(,R7)\n         STH   R7,SCRSIZE\n         LA    R12,81(,R12)     SEE IF THE BUFFER IS FULL YET.\n         C     R12,ADBUF\n         BE    #ACT0380         IF YES, THE GO PUT THIS SCREEN.\n#ACT0350 DS    0H\n         BCT   R3,#ACT0020      BRANCH BACK TO LOOK AT NEXT MEMORY.\n         LA    R4,BUFFER        LOAD ADDRESS OF OUTPUT BUFFER.\n         CR    R4,R12           ARE WE STILL AT THE BEGINNING.\n         BNE   #ACT0360         IF NOT CONTINUE ON\n         MVC   JOB(20),=CL20'** NO JOBS ACTIVE **'\n         TR    LINE+2(79),TRTAB PREVENT GARBAGE IN LINE\n         MVC   0(81,R12),LINE   MOVE THE LINE TO THE 3270 BUFFER.\n         LH    R7,SCRSIZE       BUMP BUFFER COUNTER.\n         LA    R7,81(,R7)\n         STH   R7,SCRSIZE\n         DROP  R6                 DROP BASE FOR OUCB\n***********************************************************************\n**  LOOK THRU SRM CONTROL BLOCKS TO BUILD HEADER INFO\n***********************************************************************\n#ACT0360 DS    0H\n         SR    R1,R1               R1<--A(PSA)\n         USING PSA,R1\n         L     R1,FLCCVT           R1<--A(CVT)\n         USING CVT,R1\n         L     R1,CVTOPCTP         R1<--A(RMCT)\n         DROP  R1\n         L     R1,4(R1)            R1<--A(CCT)  FROM RMCTCCT\n         LH    R6,102(R1)          CPU UTILIZATION FROM CCTUTILP\n         CVD   R6,WORK             CONVERT TO DECIMAL...\n         OI    WORK+7,X'0F'        FIX THE SIGN\n         UNPK  HDRCPU,WORK+6(2)     ...AND EDIT\n         EJECT\n***********************************************************************\n*    WRITE THE SCREEN, WAIT FOR INPUT, AND PROCESS ANY RESPONSES\n***********************************************************************\n#ACT0380 DS    0H\n         LA    R1,CLEAR         PREPARE\n         LA    0,LENGTH            FOR\n         AH    0,SCRSIZE              THE\n         ICM   R1,8,TPUTFLG              FULL SCREEN\n         TPUT  (R1),(0),R                   TPUT\n         TGET  BUFFER,1,ASIS\n         CLI   BUFFER,X'F3'       END KEY ???\n         BE    #ACT0460           ..YES: END THIS THING\n         CLI   BUFFER,X'C3'       END KEY ???\n         BE    #ACT0460           ..YES: END THIS THING\n         TGET  BUFFER,1         READ THE INPUT DATA FROM USER.\n         OI    BUFFER,X'40'     GET TO UPPER CASE BEFORE COMPARE.\n         CLI   BUFFER,C'E'      CHECK IF TERMINATION REQUESTED.\n         BE    #ACT0460         BYE BYE BABY...\n         CLI   BUFFER,C'T'      CHECK FOR TSO ONLY.\n         BNE   #ACT0390         IF NOT, TRY FOR BATCH ONLY MODE.\n         NI    FLAG,255-A       RESET FLAG\n         OI    FLAG,T           ONLY TSO MEMORIES.\n         OI    MODESW,X'FF'     SET CHANGE OF MODES.\n         B     #ACT0440         BY-PASS FURTHER INPUT CHECKING.\n#ACT0390 DS    0H\n         CLI   BUFFER,C'B'      CHECK FOR BATCH ONLY\n         BNE   #ACT0400         BRANCH TO CHECK OTHER OPTIONS.\n         NI    FLAG,255-A       RESET FLAG\n         OI    FLAG,B           ONLY BATCH MEMORIES.\n         OI    MODESW,X'FF'     SET CHANGE OF MODES.\n         B     #ACT0440         BY-PASS FURTHER INPUT CHECKING.\n#ACT0400 DS    0H\n         CLI   BUFFER,C'S'      CHECK FOR STC/MOUNT ONLY\n         BNE   #ACT0410         BRANCH TO CHECK OTHER OPTIONS.\n         NI    FLAG,255-A       RESET FLAG\n         OI    FLAG,S           ONLY STC/MOUNT MEMORIES.\n         OI    MODESW,X'FF'     SET CHANGE OF MODES.\n         B     #ACT0440         BY-PASS FURTHER INPUT CHECKING.\n#ACT0410 DS    0H\n         CLI   BUFFER,C'A'      CHECK FOR EVERYTHING\n         BNE   #ACT0420         IF NOT, TRY FOR IN OR OUT MODES.\n         OI    FLAG,A           ALL MEMORIES.\n         OI    MODESW,X'FF'     SET CHANGE OF MODES.\n#ACT0420 DS    0H\n         CLI   BUFFER,C'O'      CHECK FOR OUT MODE\n         BNE   #ACT0430\n         NI    FLAG,255-I       RESET FLAG\n         OI    FLAG,O           IN OR OUT MEMORIES\n         OI    MODESW,X'FF'     SET CHANGE OF MODES.\n         B     #ACT0440\n#ACT0430 DS    0H\n         CLI   BUFFER,C'I'      CHECK FOR IN OR READY MODE\n         BNE   #ACT0440\n         NI    FLAG,255-O       RESET FLAG\n         OI    FLAG,I           SWAPPED IN ONLY\n         OI    MODESW,X'FF'     SET CHANGE OF MODES.\n#ACT0440 DS    0H\n         MVC   SCRSIZE,=H'0'    RESET SCREEN SIZE.\n         LA    R12,BUFFER       PREPARE\n         LA    R6,BUFFER           FOR\n         ICM   R6,8,C' '              THE\n         LA    R7,BUFLEN                 MOVE\n         LA    R8,BUFFER                    CHARACTER\n         SR    R9,R9                           LONG\n         MVCL  R6,R8                              TO CLEAR BUFFER.\n         CLI   MODESW,X'FF'     CHECK FOR CHANGE OF MODES.\n         BNE   #ACT0450         BRANCH IF SAME MODE.\n         MVI   MODESW,X'00'     RESET MODE CHANGE.\n         B     #ACT0010         START OVER FROM BEGINNING.\n#ACT0450 DS    0H\n         LTR   R3,R3            CHECK TO SEE IF MORE MEMORIES TO PROCES\n         BZ    #ACT0010         NO, TAKE IT FROM THE TOP\n         BCT   R3,#ACT0020      WAS THERE ONLY ONE LEFT AT BUFFER FULL\n         B     #ACT0010         YES, START OVER FROM THE TOP.\n#ACT0460 DS    0H\n         STFSMODE OFF           TERMINATE FULLSCREEN MODE\n         TCLEARQ INPUT\n         PRINT GEN\n         SYSRETRN\n         PRINT NOGEN\n         TITLE 'CONSTANTS'\n         LTORG\n         EJECT\n***********************************************************************\nMODESW   DC    X'00'  MODE CHANGE.\n***********************************************************************\nSWAPTBL  DS    0C\n         DC    X'01',CL5'TRMOT'\n         DC    X'02',CL5'TRMIN'\n         DC    X'03',CL5'LWAIT'\n         DC    X'04',CL5'AUXST'\n         DC    X'05',CL5'RSTOR'\n         DC    X'06',CL5'DWAIT'\n         DC    X'07',CL5'RQSWP'\n         DC    X'08',CL5'ENQEX'\n         DC    X'09',CL5'EXCHG'\n         DC    X'0A',CL5'UNLAT'\n         DC    X'FF',CL5'UNK  '\n***********************************************************************\nFLAG     DC    AL1(O+B)\n***********************************************************************\nI        EQU   X'80'              DISPLAY ONLY SWAPPED IN MEMORIES\nO        EQU   X'40'              DISPLAY REGARDLESS OF SWAP STATUS\nT        EQU   X'20'              DISPLAY ONLY TSO MEMORIES\nB        EQU   X'10'              DISPLAY ONLY BATCH MEMORIES\nS        EQU   X'08'              DISPLAY ONLY STC/MOUNT MEMORIES\nA        EQU   X'38'              DISPLAY ALL MEMORIES\n***********************************************************************\nTRTAB    DS    0CL256\n         DC    C'                '     X'00' - X'0F'\n         DC    C'                '     X'10' - X'1F'\n         DC    C'                '     X'20' - X'2F'\n         DC    C'                '     X'30' - X'3F'\n         DC    C'          \u00a2.<(+|'     X'40' - X'4\n         DC    C'&&         !$*);\u00ac'    X'50' - X'5F'\n         DC    C'-/        \u00a6,%_>?'     X'60' - X'6F'\n         DC    C'          :#@''=\"'    X'70' - X'7F'\n         DC    C'{abcdefghi      '     X'80' - X'8F'\n         DC    C' jklmnopqr      '     X'90' - X'9F'\n         DC    C'  stuvwxyz      '     X'A0' - X'AF'\n         DC    C'                '     X'B0' - X'BF'\n         DC    C'}ABCDEFGHI      '     X'C0' - X'CF'\n         DC    C' JKLMNOPQR      '     X'D0' - X'DF'\n         DC    C'  STUVWXYZ      '     X'E0' - X'EF'\n         DC    C'0123456789      '     X'F0' - X'FF'\n***********************************************************************\n         EJECT\n***********************************************************************\nWORK     DS    D\nHEX      DC    C'0123456789ABCDEF'\nSAVE     DS    18F\nLINE     DC    X'1D60'\nJOB      DC    CL8' '       8\n         DC    CL2' '      10\nSTEP     DC    CL8' '      18\n         DC    CL2' '      20\nPROCSTEP DC    CL8' '      28\n         DC    C' '        29\nTYPE     DC    C' '        30\n         DC    C' '        31\nSTATUS   DC    CL3' '      34\n         DC    CL3' '      37\nSIZE     DC    CL6' '      43\n         DC    CL2' '      45\nSWAPCNT  DC    CL3' '      48\n         DC    CL2' '      50\nSERVICE  DC    CL7' '      57\n         DC    CL2' '      59\nIOCNT    DC    CL7' '      66\n         DC    CL2' '      68\nCPUTIME  DC    CL11' '     79\n         DC    C' '        80\nSCRSIZE  DC    H'0'\nTPUTFLG  DC    X'03'\nADBUF    DC    A(Z)\n*   C3= WCC FOR CLEAR  11= SET BUFFER ADDRESS 4040 = BUFADD POS 0000\n*   3C= REPEAT TO ADDRESS 4040(0000) CHAR(00) 11 = SET BUFFER ADDRESS\n*   4040 = POSITION 0000(R=1 C=1)  1D = START FIELD 40= UNPROTECTED\n*   13 = INSERT CURSOR 40 = BLANK 1D = START FIELD E8 = PROTECT HILITE\n* CLEAR    DC    X'27F1C31140403C4040001140401D4013'\n*          DC    X'401DE8'\nCLEAR    DC    X'27F5C31140401D4013'\n         DC    X'401DE8'\nSYSHDR   DS    0CL77\n         DC    CL4'CPU='         CPU UTILIZATION\nHDRCPU   DC    CL3'XXX',C'%'\n         DC    CL69' '\n         DC    80C'-'\n         DC    X'404040'\nHEADING DC CL77'JOB     STEP      PROCSTEP T STATUS  SIZE SWAPS SERVICEX\n                 IOCOUNT   CPU TIME '\nBUFFER   DC    21CL81' '\nLENGTH   EQU   BUFFER-CLEAR\nZ        DS    X\nBUFLEN   EQU   Z-BUFFER\n         TITLE 'DSECTS'\n         PRINT NOGEN\n         IHAPSA\n         CVT   DSECT=YES\n         IHAASVT\n         IHAASCB\n         IRAOUCB\nCSCB     DSECT\n         IEECHAIN\n        END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPLVCMD": {"ttr": 772, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         VBUILD TYPE=APPL\nVTAMCMD  APPL  EAS=5,AUTH=(SPO),ACBNAME=VTAMCMD\nNETOP01  APPL  EAS=5,AUTH=(SPO),ACBNAME=NETOP01\nNETOP02  APPL  EAS=5,AUTH=(SPO),ACBNAME=NETOP02\nNETOP03  APPL  EAS=5,AUTH=(SPO),ACBNAME=NETOP03\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SP1TC014": {"ttr": 774, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET SP1TC014   AT LEVEL 002 AS OF 04/28/89\n***********************************************************************\n*                                                                     *\n*    PROGRAM NAME:                SP1TC014                            *\n*                                                                     *\n*    AUTHOR:                      FRANCIS                             *\n*                                                                     *\n*    PURPOSE:                     VTAM SECONDARY OPERATOR UNDER SPF   *\n*                                                                     *\n*    DATE WRITTEN:                04/22/83                            *\n*                                                                     *\n*    SOURCE LIBRARY:              SYS.SYSPAN                          *\n*                                                                     *\n*    LOAD LIBRARY:                SYS.SP1.ISPLDEV  (TEST)             *\n*                                 SYS.SP1.ISPLLIB  (PROD)             *\n*                                                                     *\n*    ATTRIBUTES:                  STD.                                *\n*                                                                     *\n*    UPDATES:                     12/14/83 - T FOR TRACE, N FOR       *\n*                                   NOTRACE, ? TO SHOW VTAM COMMAND   *\n*                                 04/27/89 - * ON SHORT CUT WILL USE  *\n*                                   PREVIOUSLY ENTERED NAME (EX: A *) *\n*                                                                     *\n*    INPUT (ISPF VARIABLES                                            *\n*           ON PANEL SP1VO00)   - WAIT TIME (TO ALLOW COMMAND         *\n*                                      COMPLETION)                    *\n*                                 ROLL (YES OR NO - OUTPUT CONTROL)   *\n*                                 COMMAND (VTAM COMMAND - SOME        *\n*                                      COMMANDS HAVE A SHORT FORM     *\n*                                      FOR THIS PROGRAM ONLY)         *\n*                                                                     *\n*    OUTPUT: (ISPF VARIABLES                                          *\n*             ON PANEL SP1VO00) - UP TO 19 LINES OF RESPONSE TO THE   *\n*                                 LAST COMMAND ENTERED.  IF ROLL=NO   *\n*                                 THE DISPLAY WILL NOT CHANGE         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*    MESSAGES: (ISPF)  SP100A  - USER NOT AUTHORIZED TO USE SP1TC014  *\n*                      SP100B  - ISPF SERVICE FAILED, RC = NNNN       *\n*                      SP100C  - MORE DATA AVAILABLE                  *\n*                      SP100D  - MORE DATA AVAILABLE                  *\n*                      SP100E  - ENTER VTAM COMMAND                   *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*    METHOD:                                                          *\n*                                                                     *\n*        1.  DISPLAY SPF PANEL.  IF A COMMAND IS ENTERED THEN ISSUE   *\n*            IT TO VTAM.                                              *\n*                                                                     *\n*        2.  IF OUTPUT IS DESIRED (SPR=YES) THEN FORMAT THE MESSAGES  *\n*            ON THE LOWER HALF OF THE SPF PANEL.                      *\n*                                                                     *\n*        3.  IF THE END KEY WAS PRESSED THEN TERMINATE.               *\n*                                                                     *\n*                                                                     *\n*    REGISTER USAGE:                                                  *\n*                                                                     *\n*        R0  - LINKAGE                                                *\n*        R1  - LINKAGE, WORK                                          *\n*        R2  - WORK, BASE FOR RPL                                     *\n*        R3  - WORK                                                   *\n*        R4  - WORK                                                   *\n*        R5  - WORK                                                   *\n*        R6  - NOT USED                                               *\n*        R7  - NOT USED                                               *\n*        R8  - NOT USED                                               *\n*        R9  - NOT USED                                               *\n*        R10 - NOT USED                                               *\n*        R11 - NOT USED                                               *\n*        R12 - PROGRAM BASE # 2                                       *\n*        R13 - LINKAGE, PROGRAM SAVE AREA, PROGRAM BASE # 1           *\n*        R14 - LINKAGE                                                *\n*        R15 - LINKAGE                                                *\n*                                                                     *\n***********************************************************************\nSP1TC014 TITLE 'VTAM SECONDARY OPERATOR PROGRAM FOR ISPF'\n         MACRO\n         ISPEXEC &PARAM\n         L       R15,ISPLNKEP\n         CALL    (15),&PARAM,VL\n         MEND\n         EJECT\nSP1TC014 SYSENTER R13,R12,SYMREG=YES\n         PRINT NOGEN\n         EJECT\n***********************************************************************\n*     LOAD ISPF INTERFACE ROUTINE ADDRESS AND SAVE LOCATION\n***********************************************************************\n         LOAD  EP=ISPLINK         GET ISPF INTERFACE\n         ST    R0,ISPLNKEP        SETUP FOR ISPEXEC MACRO\n***********************************************************************\n*     DEFINE ISPF VARIABLES\n***********************************************************************\n#VTO0010 DS    0H\n         MVC   SERVICE,=CL8'VDEFINE'   SET ISPF VDEFINE SERVICE\n**** DEFINE SPSERV - SPF SERVICE BEING EXECUTED - USED IN MESSAGES ****\n         ISPEXEC (SERVICE,SPSERVN,SERVICE,CHAR,L8)\n         LTR   R15,R15            Q. VDEFINE SUCCESSFULL ???\n         BNZ   #VTO0020           ...NO: GIVE ERROR\n**** DEFINE RCODE - RETURN CODE FROM SPF SERVICES - USED IN MESSAGES **\n         ISPEXEC (SERVICE,RCODEN,RCODE,CHAR,L4)\n         LTR   R15,R15            Q. VDEFINE SUCCESSFULL ???\n         BNZ   #VTO0020           ...NO: GIVE ERROR\n**** DEFINE OUTNAMES (LIST) - OUTPUT VARIABLES ************************\n         ISPEXEC (SERVICE,OUTNAMES,SP1VO1,CHAR,L79)\n         LTR   R15,R15            Q. VDEFINE SUCCESSFULL ???\n         BNZ   #VTO0020           ...NO: GIVE ERROR\n**** DEFINE SPR - SCREEN ROLL (YES OR NO) - INPUT *********************\n         ISPEXEC (SERVICE,SPRN,SPR,CHAR,L3)\n         LTR   R15,R15            Q. VDEFINE SUCCESSFULL ???\n         BNZ   #VTO0020           ...NO: GIVE ERROR\n**** DEFINE SP1VOCMD - INPUT VTAM COMMAND *****************************\n         ISPEXEC (SERVICE,SP1VCMDN,SP1VOCMD,CHAR,L80)\n         LTR   R15,R15            Q. VDEFINE SUCCESSFULL ???\n         BNZ   #VTO0020           ...NO: GIVE ERROR\n**** DEFINE SP1VOWT - WAIT TIME BEFORE GIVING OUTPUT (IN SECONDS) *****\n         ISPEXEC (SERVICE,SP1VOWTN,SP1VOWT,CHAR,L2)\n         LTR   R15,R15            Q. VDEFINE SUCCESSFULL ???\n         BNZ   #VTO0020           ...NO: GIVE ERROR\n         B     #VTO0040           ..YES: CONTINUE ON\n***********************************************************************\n*    FAILURE IN ISPF SERVICE - GIVE ERROR MESSAGE AND CLEAN UP\n***********************************************************************\n#VTO0020 DS    0H\n         CVD   R15,DBLWD                CONVERT RETURN CODE\n         UNPK  RCODE,DBLWD\n         OI    RCODE+L'RCODE-1,X'F0'    MAKE IT PRINTABLE\n#VTO0030 DS    0H\n         ISPEXEC (SETMSG,SP100B)        SET THE ERROR MESSAGE\n         MVC   SERVICE,=CL8'VDELETE'    SET ISPF VDELETE SERVICE\n         ISPEXEC (SERVICE,SPSERVN)\n         ISPEXEC (SERVICE,RCODEN)\n         ISPEXEC (SERVICE,OUTNAMES)\n         ISPEXEC (SERVICE,INNAMES)\n         SYSRETRN RC=8\n         EJECT\n***********************************************************************\n*    VARIABLES ALL DEFINED - NOW START PROCESSING\n***********************************************************************\n#VTO0040 DS    0H\n         OPEN  (NTOACB)           OPEN SPO ACB\n         LTR   R15,R15            Q. OPEN OK ???\n         BZ    #VTO0060           ..YES: CONTINUE\n         LA    R2,NTOACB          POINT TO ACB\n         USING IFGACB,R2\n***********************************************************************\n*    THE FOLLOWING CODE ALLOWS MULTIPLE ACB'S TO BE SIGNED ON TO AT\n*    ONE TIME.  THE DEFAULT IS THREE.  TO ALLOW MORE CHANGE THE\n*    INDICATED INSTRUCTION.\n***********************************************************************\n         CH    R15,=H'8'          Q. RETURN CODE = 8 ???\n         BNE   #VTO0050           ...NO: CAN'T RECOVER\n         CLI   ACBERFLG,X'58'     Q. THIS ACB IN USE ???\n         BNE   #VTO0050           ...NO: SOME OTHER ERROR\n         PACK  DBLWD,NTOACBAN+5(2) GET ACB NUMBER\n         AP    DBLWD,=P'+1'       GET NEXT ACB NUMBER\n         CP    DBLWD,=P'+3' <-- CHANGE THIS TO ALLOW MORE USERS\n*                                 Q. ARE WE OUT OF ACB'S ???\n         BH    #VTO0050           ..YES: THEN WE CAN'T OPEN\n         UNPK  NTOACBAN+5(2),DBLWD ..NO: SET NEXT ACB NAME\n         OI    NTOACBAN+6,X'F0'   MAKE IT PRINTABLE\n         B     #VTO0040           GO TRY OPENING THIS ONE\n#VTO0050 DS    0H\n         MVC   SERVICE,=CL8'OPEN ACB'   SHOW FAILURE\n         ST    R15,DBLWD                STORE RETURN CODE\n         UNPK  RCODE(3),DBLWD+3(2)      SET RETURN CODE\n         TR    RCODE(2),HXTAB-240       GET HEX REPRESENTATION\n         UNPK  RCODE+2(3),ACBERFLG(2)   SET FEEDBACK CODE\n         TR    RCODE+2(2),HXTAB-240     GET HEX REPRESENTATION\n         B     #VTO0030                 GO GIVE ERROR MESSAGE\n         DROP  R2\n***********************************************************************\n*    ALL INITIALIZED - GO DISPLAY PANEL\n***********************************************************************\n#VTO0060 DS    0H\n         MVC   MESSAGE,=CL8'SP100E' SET MESSAGE\n#VTO0070 DS    0H\n         MVC   SP1VOCMD,SP1VOCMD-1 CLEAN OUT COMMAND LINE\n#VTO0080 DS    0H\n         MVC   SERVICE,=CL8'DISPLAY'   SET ISPF VDELETE SERVICE\n         ISPEXEC (SERVICE,SP1VO00,MESSAGE)\n         LTR   R15,R15            Q. DISPLAY SUCCESSFULL ???\n         BZ    #VTO0100           ..YES: GO PROCESS IT\n         C     R15,L8             RC = 8 ???\n         BE    #VTO0340           ..YES: GO SHUT DOWN\n         B     #VTO0020           ...NO: GIVE ERROR\n#VTO0090 DS    0H\n         MVC   SP1VOCMD,NTOIN     SET VTAM COMMAND\n         B     #VTO0080\n         EJECT\n***********************************************************************\n*    NEW INPUT READ IN - PROCESS IT\n***********************************************************************\n#VTO0100 DS    0H\n         MVI   CMDFLAG,C' '       RESET COMMAND FLAG\n         CLI   SP1VOCMD,X'00'     Q. ANY COMMAND ENTERED ???\n         BE    #VTO0250           ...NO: GO CHECK FOR OUTPUT\n         CLI   SP1VOCMD,C' '      Q. ANY COMMAND ENTERED ???\n         BE    #VTO0250           ...NO: GO CHECK FOR OUTPUT\n         CLI   SP1VOCMD,C'?'      Q. DOES HE WANT VTAM COMMAND ???\n         BE    #VTO0090           ..YES: GO GIVE IT TO HIM\n         MVI   NTOIN,C' '\n         MVC   NTOIN+1(L'NTOIN-1),NTOIN   BLANK OUT COMMAND AREA\n         XC    TRTAB,TRTAB                CLEAN OUT XLATE TABLE\n         MVI   TRTAB,X'01'                     STOP ON X'00'\n         MVI   TRTAB+C' ',C' '                 STOP ON BLANK\n         TRT   SP1VOCMD+2(L'SP1VOCMD-2),TRTAB  GET END OF COMMAND\n         BNZ   *+8                      Q. DID WE FIND END ???\n         LA    R1,SP1VOCMD+L'SP1VOCMD   ...NO: FORCE TO END OF FIELD\n         S     R1,=A(SP1VOCMD)          R1<--LENGTH(INPUT COMMAND)\n         CLC   SP1VOCMD+2(3),=CL3'NET'  Q. NATIVE COMMAND ???\n         BNE   #VTO0120                 ...NO: GO PROCESS SHORT FORM\n#VTO0110 DS    0H\n         LR    R2,R1              R2<--LENGTH(COMMAND)\n         BCTR  R2,R0\n         EX    R2,$VTOCMMV        MOVE THE COMMAND\n         B     #VTO0240           GO PROCESS IT\n         SPACE\n$VTOCMMV MVC   NTOIN(0),SP1VOCMD  >>>EXECUTED<<<\n         EJECT\n***********************************************************************\n*    PROCESS SHORT FORM OF COMMAND\n***********************************************************************\n#VTO0120 DS    0H\n         LA    R2,SP1VOCMD(R1)    R2<--END OF COMMAND\n         SH    R2,=H'2'           BACK UP TWO BYTES\n         CLI   0(R2),C','         Q. TRACE TYPE GIVEN ???\n         BNE   #VTO0130           ...NO\n         MVC   TYPE,1(R2)         ..YES:SET TRACE TYPE\n         SH    R1,=H'2'           RESET COMMAND LENGTH\n#VTO0130 DS    0H\n         CLI   SP1VOCMD+2,C'*'    Q. USE PREVIOUS NETWORK ID ???\n         BE    #VTO0140           ..YES: SKIP SETTING NEW NAME\n         CH    R1,=H'10'          Q. IS IT TOO LONG ???\n         BH    #VTO0110           ..YES: GO PROCESS AS NATIVE COMMAND\n         MVC   NETNAME,=CL8' '    INIT NAME\n         LR    R2,R1              R2<--LENGTH(COMMAND)\n         SH    R2,=H'3'           GET EX LENGTH\n         BM    #VTO0110           ..NOT POSITIVE: BAD COMMAND\n         EX    R2,$VTOMVLC        MOVE THE NAME\n         B     #VTO0140           GO BUILD THE COMMAND\n         SPACE\n$VTOMVLC MVC   NETNAME(0),SP1VOCMD+2     >>>EXECUTED<<<\n         SPACE\n         EJECT\n***********************************************************************\n*    BUILD THE COMMAND TO BE PASSED TO VTAM\n***********************************************************************\n#VTO0140 DS    0H\n         CLC   SP1VOCMD(2),=CL2'D '   Q. DISPLAY REQUEST ???\n         BE    #VTO0150               ..YES: GO HANDLE IT\n         CLC   SP1VOCMD(2),=CL2'A '   Q. ACTIVATE REQUEST ???\n         BE    #VTO0160               ..YES: GO HANDLE IT\n         CLC   SP1VOCMD(2),=CL2'I '   Q. INACTIVATE REQUEST ???\n         BE    #VTO0170               ..YES: GO HANDLE IT\n         CLC   SP1VOCMD(2),=CL2'R '   Q. INACTIVATE REQUEST ???\n         BE    #VTO0170               ..YES: GO HANDLE IT\n         CLC   SP1VOCMD(2),=CL2'F '   Q. INACTIVATE REQUEST ???\n         BE    #VTO0170               ..YES: GO HANDLE IT\n         CLC   SP1VOCMD(2),=CL2'T '   Q. TRACE REQUEST ???\n         BE    #VTO0180               ..YES: GO HANDLE IT\n         CLC   SP1VOCMD(2),=CL2'N '   Q. NOTRACE REQUEST ???\n         BE    #VTO0190               ..YES: GO HANDLE IT\n         B     #VTO0110               ...NO: I DON'T KNOW WHAT IT IS\n#VTO0150 DS    0H\n         MVC   DISNAME,NETNAME             SET CONTROLLER NAME\n         MVC   NTOIN(L'DISSKEL),DISSKEL    SET THE COMMAND\n         LA    R1,L'DISSKEL                SET CORRECT LENGTH\n         B     #VTO0240                    GO PROCESS THE COMMAND\n#VTO0160 DS    0H\n         MVC   ACTNAME,NETNAME             SET CONTROLLER NAME\n         MVC   NTOIN(L'ACTSKEL),ACTSKEL    SET THE COMMAND\n         LA    R1,L'ACTSKEL                SET CORRECT LENGTH\n         B     #VTO0240                    GO PROCESS THE COMMAND\n#VTO0170 DS    0H\n         MVC   DACTNAME,NETNAME            SET CONTROLLER NAME\n         MVC   DACTTYPE,SP1VOCMD           SET INACT TYPE\n         MVC   NTOIN(L'DACTSKEL),DACTSKEL  SET THE COMMAND\n         LA    R1,L'DACTSKEL               SET CORRECT LENGTH\n         B     #VTO0240                    GO PROCESS THE COMMAND\n#VTO0180 DS    0H\n         MVC   TRCNAME,NETNAME             SET CONTROLLER NAME\n         MVC   NTOIN(L'TRCSKEL),TRCSKEL    SET THE COMMAND\n         LA    R1,L'TRCSKEL                SET CORRECT LENGTH\n         LA    R2,NTOIN+L'TRCSKEL-1        POINT TO LAST BYTE\n         B     #VTO0200                    GO SET THE TRACE TYPE\n#VTO0190 DS    0H\n         MVC   NTRNAME,NETNAME             SET CONTROLLER NAME\n         MVC   NTOIN(L'NTRSKEL),NTRSKEL    SET THE COMMAND\n         LA    R1,L'NTRSKEL                SET CORRECT LENGTH\n         LA    R2,NTOIN+L'NTRSKEL-1        POINT TO LAST BYTE\n         EJECT\n****SET THE TRACE TYPE*************************************************\n#VTO0200 DS    0H\n         CLI   0(R2),C' '         Q. END OF COMMAND ???\n         BNE   #VTO0210           ..YES\n         BCT   R2,#VTO0200        ...NO: BACK UP ONE BYTE\n#VTO0210 DS    0H\n         MVC   1(8,R2),=C',TYPE=IO' SET DEFAULT TYPE\n         CLI   TYPE,C'B'          Q. BUF TRACE ???\n         BE    #VTO0220           ..YES\n         CLI   TYPE,C'L'          Q. LINE TRACE ???\n         BE    #VTO0230           ..YES\n         B     #VTO0240           ...NO: USE DEFAULT\n#VTO0220 DS    0H\n         MVC   7(3,R2),=C'BUF'    SET BUFFER TRACE\n         B     #VTO0240           GO PROCESS COMMAND\n#VTO0230 DS    0H\n         MVC   7(4,R2),=C'LINE'   SET LINE TRACE\n         MVI   TYPE,C' '          RESET TYPE FIELD\n         B     #VTO0240           GO PROCESS COMMAND\n         EJECT\n***********************************************************************\n*    PASS THE COMMAND TO VTAM THROUGH SENDCMD\n***********************************************************************\n#VTO0240 DS    0H\n         LA    R2,NTORPLSC        POINT TO SENDCMD RPL\n         USING IFGRPL,R2\n         AH    R1,=H'4'           ADD HEADER LENGTH TO COMMAND LENGTH\n         ST    R1,RPLRLEN         STORE LENGTH IN RPL\n         MVI   CMDFLAG,X'FF'      SHOW COMMAND WAS ISSUED\n         SENDCMD RPL=NTORPLSC           PASS THE COMMAND TO VTAM\n         LTR   R15,R15                  Q. SUCCESSFUL ???\n         BZ    #VTO0250                 ...YES, GO GET RESPONSE\n         MVC   SERVICE,=CL8'SENDCMD'    SET COMMAND FOR ERROR MSG\n         UNPK  RCODE(3),RPLRTNCD(2)     SET RETURN CODE\n         TR    RCODE(2),HXTAB-240       GET HEX REPRESENTATION\n         UNPK  RCODE+2(3),RPLFDB2(2)    SET FEEDBACK CODE\n         TR    RCODE+2(2),HXTAB-240     GET HEX REPRESENTATION\n         ISPEXEC (SETMSG,SP100B)        GIVE ERROR MESSAGE\n         B     #VTO0070                 GO REWRITE SCREEN\n         DROP  R2\n***********************************************************************\n*    IF OUTPUT IS DESIRED - OBTAIN IT THROUGH RCVCMD\n***********************************************************************\n#VTO0250 DS    0H\n         CLC   SPR,=CL3'NO'       Q. IS OUTPUT DESIRED ???\n         BE    #VTO0070           ...NO: GO REDISPLAY\n         LA    R0,SP1VO1\n         L     R1,=A(19*L'SP1VO1)\n         SR    R2,R2\n         SR    R3,R3\n         ICM   R3,8,=X'40'\n         MVCL  R0,R2              CLEAN OUT OUTPUT AREA\n         LA    R2,NTORPLRC         GET RPL ADDRESS\n         USING IFGRPL,R2\n         CLI   CMDFLAG,X'FF'       Q. WAS A COMMAND ISSUED\n         BE    #VTO0260            ..YES: GO GET RESPONSE\n         LA    R3,SP1VO1           ...NO: SETUP FOR LOOP AND\n         LA    R4,19                      GO TRY FOR LEFTOVER MESSAGES\n         MVC   MESSAGE,=CL8'SP100E'\n         B     #VTO0310\n***********************************************************************\n*    OUTPUT IS DESIRED - WAIT SPECIFIED TIME BEFORE INQUIRING\n***********************************************************************\n#VTO0260 DS    0H\n         PACK  DBLWD,SP1VOWT\n         CVB   R1,DBLWD           R1<--NUMBER OF SECONDS TO WAIT\n         MH    R1,=H'100'         CONVERT TO HUNDREDTHS\n         ST    R1,SECS            SET IN CONSTANT\n         STIMER WAIT,BINTVL=SECS   WAIT FOR RESPONSE\n         EJECT\n***********************************************************************\n*    GET NEXT MESSAGE - WAIT FOR RESPONSE IF COMMAND WAS ISSUED\n***********************************************************************\n         RCVCMD RPL=NTORPLRC       ISSUE RCVCMD\n         LTR   R15,R15                 Q. ACCEPTED\n         BNZ   #VTO0320                ...NO: ERROR\n***********************************************************************\n*    LOOP FOR ALL MESSAGES BUILDING OUTPUT LINES\n***********************************************************************\n#VTO0270 DS    0H\n         LA    R3,SP1VO1               R3<--A(FIRST LINE OF OUTPUT)\n         LA    R4,19                   R4<--COUNT OF OUTPUT LINES\n         MVC   MESSAGE,=CL8'SP100E'    SET DEFAULT MESSAGE\n#VTO0280 DS    0H\n         CLI   RPLFDB2,X'06'      Q. END OF MESSAGES ???\n         BNE   #VTO0290           ...NO: GO PROCEES NEXT MESSAGE\n         CH    R4,=H'19'          Q. WERE ANY MESSAGES DISPLAYED ???\n         BNE   #VTO0070           ...NO: GO DISPLAY PANEL\n         CLI   NTOIN,C'D'         WAS THE LAST COMMAND A DISPLAY ???\n         BNE   #VTO0070           ...NO: GO DISPLAY PANEL\n         MVC   SP1VOCMD,NTOIN     SETUP COMMAND LINE\n         B     #VTO0100           GO DO PSEUDO-REENTRY OF DISPLAY CMD\n#VTO0290 DS    0H\n         L     R5,RPLRLEN         ...NO: THEN GET MESSAGE LENGTH\n         SH    R5,=H'4'                  LESS HEADER LENGTH\n         CH    R5,=Y(L'SP1VO1)    Q. TOO LONG FOR PANEL ???\n         BL    #VTO0300           ...NO\n         LA    R5,L'SP1VO1        ..YES: FORCE TRUNCATION\n#VTO0300 DS    0H\n         BCTR  R5,R0              GET EX LENGTH\n         EX    R5,$NMVRPLY        MOVE THE MESSAGE\n         SH    R4,=H'1'           ANY OUTPUT LINES LEFT ???\n         BZ    #VTO0330           ...NO: GO SHOW MORE OUTPUT AVAILABLE\n         LA    R3,L'SP1VO1(,R3)   BUMP TO NEXT LINE\n         EJECT\n***********************************************************************\n*    GET EACH MESSAGE THROUGH RCVCMD - NO WAIT - FDB2 = 6 IF DONE\n***********************************************************************\n#VTO0310 DS    0H\n         RCVCMD RPL=NTORPLRC,OPTCD=NQ   ISSUE ANOTHER RCVCMD\n         LTR   R15,R15                  Q. ACCEPTED\n         BZ    #VTO0280                 ...YES: GO PROCESS MESSAGE\n#VTO0320 DS    0H\n         MVC   SERVICE,=CL8'RCVCMD'    SET FUNCTION FOR ERROR MSG\n         UNPK  RCODE(3),RPLRTNCD(2)     SET RETURN CODE\n         TR    RCODE(2),HXTAB-240       GET HEX REPRESENTATION\n         UNPK  RCODE+2(3),RPLFDB2(2)    SET FEEDBACK CODE\n         TR    RCODE+2(2),HXTAB-240     GET HEX REPRESENTATION\n         ISPEXEC (SETMSG,SP100B)        GIVE ERROR MESSAGE\n         B     #VTO0070                GO GIVE ERROR MESSAGE\n#VTO0330 DS    0H\n         MVC   MESSAGE,=CL8'SP100C'    SHOW THERE IS MORE\n         B     #VTO0070                GO DISPLAY\n         SPACE\n$NMVRPLY MVC   0(0,R3),NTOOUT     >>>EXECUTED<<<\n         SPACE\n         DROP  R2\n         EJECT\n#VTO0340 DS    0H\n         RCVCMD RPL=NTORPLRC,OPTCD=NQ   ISSUE ANOTHER RCVCMD\n         LTR   R15,R15                  Q. ACCEPTED\n         BNZ   #VTO0320                 ...YES, RETURN\n         LA    R2,NTORPLRC         GET RPL ADDRESS\n         USING IFGRPL,R2\n         CLI   RPLFDB2,X'06'      Q. END OF MESSAGES ???\n         BE    #VTO0350           ..YES: GO QUIT\n         LA    R0,SP1VO1\n         L     R1,=A(19*L'SP1VO1)\n         SR    R2,R2\n         SR    R3,R3\n         ICM   R3,8,=X'40'\n         MVCL  R0,R2              CLEAN OUT OUTPUT AREA\n         LA    R2,NTORPLRC         GET RPL ADDRESS\n         LA    R3,SP1VO1               R3<--A(FIRST LINE OF OUTPUT)\n         LA    R4,19                   R4<--COUNT OF OUTPUT LINES\n         MVC   MESSAGE,=CL8'SP100D'    SET DEFAULT MESSAGE\n         B     #VTO0280                GO PROCESS REST OF OUTPUT\n#VTO0350 DS    0H\n         CLOSE (NTOACB)            CLOSE THE ACB\n         LTR   R15,R15            Q. OPEN OK ???\n         BZ    #VTO0360           ..YES: CONTINUE\n         LA    R2,NTOACB          POINT TO ACB\n         USING IFGACB,R2\n         MVC   SERVICE,=CL8'CLOS ACB'   ...NO: SHOW FAILURE\n         ST    R15,DBLWD                STORE RETURN CODE\n         UNPK  RCODE(3),DBLWD+3(2)      SET RETURN CODE\n         TR    RCODE(2),HXTAB-240       GET HEX REPRESENTATION\n         UNPK  RCODE+2(3),ACBERFLG(2)   SET FEEDBACK CODE\n         TR    RCODE+2(2),HXTAB-240     GET HEX REPRESENTATION\n         B     #VTO0030                 GO GIVE ERROR MESSAGE\n#VTO0360 DS    0H\n         MVC   SERVICE,=CL8'VDELETE'   SET ISPF VDELETE SERVICE\n         ISPEXEC (SERVICE,SPSERVN)\n         ISPEXEC (SERVICE,RCODEN)     DELETE ISPF VARIABLES\n         ISPEXEC (SERVICE,OUTNAMES)\n         ISPEXEC (SERVICE,INNAMES)\n         PRINT GEN\n         SYSRETRN                  RESTORE REGISTERS AND RETURN\n         PRINT NOGEN\n         SPACE 2\n#VTO0370 DS    0H\n         DC    H'0'               DUMMY EXIT ROUTINE\n         TITLE 'VARIABLES AND CONSTANTS'\n***********************************************************************\nLWAPSCB  EQU   24                  A(PSCB)\n***********************************************************************\nNTOACB   ACB   AM=VTAM,                                                *\n               APPLID=NTOACBAI,                                        *\n               MACRF=NLOGON\n***********************************************************************\nNTOACBAI DC    X'08'\nNTOACBAN DC    CL8'NETOP01'\n***********************************************************************\nNTORPLSC RPL   AM=VTAM,                                                *\n               ACB=NTOACB,                                             *\n               AREA=NTOCMDO,                                           *\n               RECLEN=NTOCMDOL,                                        *\n               OPTCD=(SYN)\n***********************************************************************\nNTORPLRC RPL   AM=VTAM,                                                *\n               ACB=NTOACB,                                             *\n               AREA=NTOCMDI,                                           *\n               AREALEN=NTOCMDIL,                                       *\n               EXIT=#VTO0370,                                          *\n               OPTCD=(Q,TRUNC)\n***********************************************************************\nDBLWD    DS    D                   DOUBLE WORD WORK AREA\nISPLNKEP DC    F'0'               ISPF INTERFACE E/P\nSECS     DC    A(0)               WAIT TIME FOR STIMER\nTRTAB    DC    XL256'00'          TRANSLATION TABLE\nHXTAB    DC    C'0123456789ABCDEF'\nNETNAME  DC    CL8' '             NETWORK NAME (COMMAND SHORT FORM)\nCMDFLAG  DC    C' '               C' ' IF NO CMD, X'FF' IF CMD\nTYPE     DC    C'I'               TRACE TYPE - DEFAULT IS 'I'\n***********************************************************************\nNTOCMDI  EQU   *                   COMMAND INPUT BUFFER (FROM VTAM)\n         DS    CL4                 COMMAND HEADER\nNTOOUT   DC    CL80' '             TPUT BUFFER\nNTOCMDIL EQU   *-NTOCMDI\n***********************************************************************\nNTOCMDO  EQU   *                   COMMAND OUTPUT BUFFER (TO VTAM)\n         DC    X'00'               COMMAND HEADER\n         DC    X'03'\n         DC    X'0000'\nNTOIN    DS    CL80                TGET BUFFER\nNTOCMDOL EQU   *-NTOCMDO\n***********************************************************************\n         EJECT\n***********************************************************************\nOUTNAMES DS    0D                 NAME LIST FOR OUTPUT VARIABLES\n         DC    F'19'              COUNT OF VARIABLES\n         DC    F'0'               MUST BE 0 OR 8\n         DC    CL8'SP1VO1'        VARIABLE NAME\n         DC    CL8'SP1VO2'        VARIABLE NAME\n         DC    CL8'SP1VO3'        VARIABLE NAME\n         DC    CL8'SP1VO4'        VARIABLE NAME\n         DC    CL8'SP1VO5'        VARIABLE NAME\n         DC    CL8'SP1VO6'        VARIABLE NAME\n         DC    CL8'SP1VO7'        VARIABLE NAME\n         DC    CL8'SP1VO8'        VARIABLE NAME\n         DC    CL8'SP1VO9'        VARIABLE NAME\n         DC    CL8'SP1VO10'       VARIABLE NAME\n         DC    CL8'SP1VO11'       VARIABLE NAME\n         DC    CL8'SP1VO12'       VARIABLE NAME\n         DC    CL8'SP1VO13'       VARIABLE NAME\n         DC    CL8'SP1VO14'       VARIABLE NAME\n         DC    CL8'SP1VO15'       VARIABLE NAME\n         DC    CL8'SP1VO16'       VARIABLE NAME\n         DC    CL8'SP1VO17'       VARIABLE NAME\n         DC    CL8'SP1VO18'       VARIABLE NAME\n         DC    CL8'SP1VO19'       VARIABLE NAME\n***********************************************************************\nSP1VO1   DC    CL79' '            OUTPUT LINE # 1\nSP1VO2   DC    CL79' '            OUTPUT LINE # 2\nSP1VO3   DC    CL79' '            OUTPUT LINE # 3\nSP1VO4   DC    CL79' '            OUTPUT LINE # 4\nSP1VO5   DC    CL79' '            OUTPUT LINE # 5\nSP1VO6   DC    CL79' '            OUTPUT LINE # 6\nSP1VO7   DC    CL79' '            OUTPUT LINE # 7\nSP1VO8   DC    CL79' '            OUTPUT LINE # 8\nSP1VO9   DC    CL79' '            OUTPUT LINE # 9\nSP1VO10  DC    CL79' '            OUTPUT LINE # 10\nSP1VO11  DC    CL79' '            OUTPUT LINE # 11\nSP1VO12  DC    CL79' '            OUTPUT LINE # 12\nSP1VO13  DC    CL79' '            OUTPUT LINE # 13\nSP1VO14  DC    CL79' '            OUTPUT LINE # 14\nSP1VO15  DC    CL79' '            OUTPUT LINE # 15\nSP1VO16  DC    CL79' '            OUTPUT LINE # 16\nSP1VO17  DC    CL79' '            OUTPUT LINE # 17\nSP1VO18  DC    CL79' '            OUTPUT LINE # 18\nSP1VO19  DC    CL79' '            OUTPUT LINE # 19\n***********************************************************************\n         EJECT\n***********************************************************************\nINNAMES  DS    0D                 NAME LIST FOR INPUT VARIABLES\n         DC    F'3'               COUNT OF VARIABLES\n         DC    F'0'               MUST BE 0 OR 8\n         DC    CL8'SPR'           VARIABLE NAME\n         DC    CL8'SP1VOCMD'      VARIABLE NAME\n         DC    CL8'SP1VOWT'       VARIABLE NAME\n***********************************************************************\nSERVICE  DC    CL8' '             SPF SERVICE BEING EXECUTED\nMESSAGE  DC    CL8' '             SPF MESSAGE TO BE GIVEN\nSETMSG   DC    CL8'SETMSG'        SPF SETMSG SERVICE\nSP1VO00 DC     CL8'SP1VO00'\nSPSERVN  DC    CL8'SPSERV'\nRCODEN   DC    CL8'RCODE'\nSPRN     DC    CL8'SPR'\nCHAR     DC    CL8'CHAR'\nSP1VCMDN DC    CL8'SP1VOCMD'\nSP1VOWTN DC    CL8'SP1VOWT'\nSP100A DC      CL8'SP100A'\nSP100B DC      CL8'SP100B'\n***********************************************************************\nSPR      DC    CL3'YES'           ROLL SCREEN (YES OR NO)\n         DC    C' '               USED TO CLEAR SP1VOCMD\nSP1VOCMD DC    CL80' '            CURRENT VTAM COMMAND\nSP1VOWT  DC    CL2'02'            WAIT TIME IN SECONDS\nRCODE    DC    CL4'0000'          RETURN CODE FROM SPF SERVICES\n         DC    C' '               SLACK FOR HEX CONVERSION\n***********************************************************************\nL2       DC    F'2'               LENGTH FIELD = 2\nL3       DC    F'3'               LENGTH FIELD = 3\nL4       DC    F'4'               LENGTH FIELD = 4\nL8       DC    F'8'               LENGTH FIELD = 8\nL79      DC    F'79'              LENGTH FIELD = 79\nL80      DC    F'80'              LENGTH FIELD = 80\n***********************************************************************\n         EJECT\n***********************************************************************\nACTSKEL  DC    CL21'V NET,ACT,ID=XXXXXXXX'\nACTNAME  EQU   ACTSKEL+13,8\n***********************************************************************\nDISSKEL  DC    CL19'D NET,E,ID=XXXXXXXX'\nDISNAME  EQU   DISSKEL+11,8\n***********************************************************************\nDACTSKEL DC    CL25'V NET,INACT,I,ID=XXXXXXXX'\nDACTTYPE EQU   DACTSKEL+12,1\nDACTNAME EQU   DACTSKEL+17,8\n***********************************************************************\nTRCSKEL DC     CL33'F NET,TRACE,ID=XXXXXXXX'\nTRCNAME EQU    TRCSKEL+15,8\n***********************************************************************\nNTRSKEL DC     CL35'F NET,NOTRACE,ID=XXXXXXXX'\nNTRNAME EQU    NTRSKEL+17,8\n***********************************************************************\n         LTORG\n         TITLE 'DSECTS'\n         ISTDPOHD\n         IFGACB AM=VTAM\n         IFGRPL AM=VTAM\n         IHAPSA\n         IHAASCB\n         IHAASXB\n         IKJPSCB\n        END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SP1UT017": {"ttr": 1028, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET SP1UT017   AT LEVEL 008 AS OF 02/27/89\n*          DATA SET SP1UT017   AT LEVEL 002 AS OF 01/30/86\n***********************************************************************\n*                                                                     *\n*    PROGRAM NAME:                SP1UT017                            *\n*                                                                     *\n*    AUTHOR:                      FRANCIS                             *\n*                                                                     *\n*    PURPOSE:                     SYSLOG HISTORY EXTRACTION           *\n*                                                                     *\n*    DATE WRITTEN:                JUNE 18, 1982                       *\n*                                                                     *\n*    SOURCE LIBRARY:              SYS.SYSPAN                          *\n*                                                                     *\n*    LOAD LIBRARY:                SYS1.SYS.LINKLIB                    *\n*                                                                     *\n*    ATTRIBUTES:                  STD                                 *\n*                                                                     *\n*    UPDATES:          02/07/85 - ADD PARTIAL MESSAGE SCAN            *\n*                      12/27/85 - UPDATED FOR MVS/XA SYSLOG           *\n*                      12/31/85 - UPDATED TO ACCEPT PDS AS INPUT      *\n*                      02/24/89 - IHAHCLOG MACRO SUPPORT ADDED        *\n*                               - MULTIPLE LINE MESSAGE SUPPORT       *\n*                                                                     *\n*    INPUT:            LOGIN    - SYSLOG HISTORY FILE                 *\n*                      PDSIN    - SYSLOG HISTORY PDS                  *\n*                      SYSIN    - PROGRAM PARAMETER CARDS             *\n*                                 (SEE SEPARATE DOCUMENTATION)        *\n*                                                                     *\n*    OUTPUT:           SYSPRINT - PROGRAM MESSAGES AND SYSLOG RECORDS *\n*                                                                     *\n*    MESSAGES:         USR0315E - JOB ID TABLE OVERFLOW -- POSSIBLE   *\n*                                 DATA LOSS                           *\n*                      USR0316E - UNALLOCATION FAILED, RC=NNNN        *\n*                      USR0317E - ALLOCATION FAILED, RC=NNNN          *\n*                                                                     *\n***********************************************************************\nSP1UT017 TITLE 'SYSLOG EXTRACTION PROGRAM'\n***********************************************************************\n*                                                                     *\n*    METHOD:                                                          *\n*                                                                     *\n*        1.  VALIDATE INPUT PARAMETER CARDS AND BUILD CONTROL TABLES. *\n*                                                                     *\n*        2.  READ EACH RECORD.  VERIFY THE RECORDS FITS WITHIN THE    *\n*            DATE AND TIME RANGE.  IF NOT CONTINUE READING UNTIL A    *\n*            RECORD IS FOUND THAT DOES.                               *\n*                                                                     *\n*        3.  IF NO OTHER TESTS WERE REQUESTED THEN PRINT THE RECORD.  *\n*            IF OTHER TESTS WERE REQUESTED PRINT THE RECORD IF IT     *\n*            PASSES ANY OF THE OTHER TESTS.                           *\n*                                                                     *\n*        4.  QUIT ON END OF FILE OR REACHING THE HIGH DATE AND TIME.  *\n*                                                                     *\n*    REGISTER USAGE:                                                  *\n*                                                                     *\n*        R0  - LINKAGE                                                *\n*        R1  - LINKAGE, WORK                                          *\n*        R2  - WORK                                                   *\n*        R3  - WORK                                                   *\n*        R4  - WORK                                                   *\n*        R5  - WORK                                                   *\n*        R6  - WORK                                                   *\n*        R7  - WORK                                                   *\n*        R8  - INTERNAL LINKAGE                                       *\n*        R9  - ERROR CODE DURING INPUT DECIPHERING                    *\n*        R10 - BASE FOR INPUT LINE DSECT (IHAHCLOG)                   *\n*        R11 - PROGRAM BASE                                           *\n*        R12 - PROGRAM BASE                                           *\n*        R13 - LINKAGE, SAVE AREA, PROGRAM BASE                       *\n*        R14 - LINKAGE, WORK                                          *\n*        R15 - LINKAGE, WORK                                          *\n*                                                                     *\n***********************************************************************\n         EJECT\nSP1UT017 SYSENTER R13,R12,R11,SYMREG=YES\n         PRINT NOGEN\n         EJECT\n         LA    R10,LOGRECD         R100<--A(INPUT RECORD)\n         USING HCL,R10\n         OPEN  (SYSPRINT,OUTPUT)\n         BAL   R8,#PRM0000         GET CONTROL CARDS\n         DEVTYPE PDSDD,DEVINFO\n         LTR   R15,R15\n         BNZ   #LOG1100\n         MVI   PDSFLAG,X'FF'       SHOW PDS PRESENT\n         RDJFCB (PDSIN)\n         MVC   DSN,JFCBAREA        SET DSN IN TITLES\n         OPEN  (PDSIN,INPUT)\n         LA    R2,43               USED TO CALCULATE MEMBER NAME LENGTH\n#LOG0100 DS    0H\n         LA    R1,DSN              R1<--A(DATASET NAME)\n         AR    R1,R2               POINT TO LAST BYTE\n         CLI   0(R1),C' '          Q. STILL BLANK ???\n         BNE   #LOG0200            ...NO: EXIT LOOP\n         BCT   R2,#LOG0100         ..YES: TRY NEXT BYTE\n#LOG0200 DS    0H\n         LA    R2,1(,R2)           GET TRUE LENGTH\n         STH   R2,DSNLEN           SAVE IN ALLOCATION TEXT\n         LA    R7,MEMTABL\n         USING PDS2,R6\n***********************************************************************\n*    GET (READ) A NEW DIRECTORY BLOCK\n***********************************************************************\n#LOG0300 DS    0H\n         READ  DECB1,SF,PDSIN,DIRAREA   GET DIRECTORY BLOCK\n         CHECK DECB1\n         LH    R2,DIRAREA          SET DIR BLOCK LENGTH\n         SH    R2,=H'2'            GET DIRECTORY DATA LENGTH\n         LA    R6,DIRAREA+2        GET ADDRESS OF FIRST ENTRY\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY ???\n         BE    #LOG0600            ..YES\n         B     #LOG0500            GO PROCESS THIS ENTRY\n***********************************************************************\n*    GET NEXT DIRECTORY ENTRY\n***********************************************************************\n#LOG0400 DS    0H\n         SR    R1,R1\n         IC    R1,PDS2INDC         GET BYTE CONTAINING ENTRY LENGTH\n         SLL   R1,27               MASK OUT HIGH ORDER BITS\n         SRL   R1,26               MULTIPLY BY TWO FOR USER DATA LENGTH\n         LA    R1,PDS2USRD-PDS2(,R1)  ADD IN NON USER DATA LENGTH\n         SR    R2,R1               SUBTRACT FROM REMAINING LENGTH\n         BNP   #LOG0300            END OF BLOCK: GO GET NEW BLOCK\n         AR    R6,R1               POINT TO NEXT ENTRY\n         CLI   PDS2NAME,X'FF'      END OF DIRECTORY ???\n         BE    #LOG0600\n         B     #LOG0500            GO PROCESS THIS ENTRY\n         EJECT\n***********************************************************************\n*    PROCESS DIRECTORY ENTRY\n***********************************************************************\n#LOG0500 DS    0H\n         MVC   0(8,R7),PDS2NAME    SET MEMBER NAME\n         LA    R7,8(,R7)           BUMP TO NEXT TABLE ENTRY\n         AP    MEMCT,=P'+1'        BUMP MEMBER COUNT\n         B     #LOG0400            CONTINUE FOR ALL MEMBERS\n         DROP  R6\n#LOG0600 DS    0H\n         CLOSE (PDSIN)\n         B     #LOG0800\n***********************************************************************\n*    UNALLOCATE LOGIN\n***********************************************************************\n#LOG0700 DS    0H\n         LA    R1,DEARBPTR         R1<--A(DYNALLOC RB)\n         DYNALLOC\n         LTR   R15,R15             Q. DID IT FREE UP ???\n         BZ    #LOG0800            ..YES\n         UNPK  $UNAWTO+43(5),DEAERR(3)\n         TR    $UNAWTO+43(4),HXTAB-240\n         MVI   $UNAWTO+47,C' '\n$UNAWTO  WTO   'USR0316E - UNALLOCATION FAILED, RC=XXXX ',             X\n               ROUTCDE=(11)\n         SYSRETRN RC=8\n         EJECT\n***********************************************************************\n*    ALLOCATE EACH MEMBER FOUND IN PDSIN TO\n*    DDNAME LOGIN FOR SEQUENTIAL PROCESSING\n***********************************************************************\n#LOG0800 DS    0H\n         L     R7,NEXTMEM          R7<--A(NEXT MEMBER TO BE PROCESSED)\n         MVC   MEMBER,0(R7)        SET MEMBER NAME IN TEXT\n         LA    R7,8(,R7)           BUMP TO NEXT MEMBER\n         ST    R7,NEXTMEM          SAVE MEMBER ADDRESS\n         LA    R2,7                USED TO CALCULATE MEMBER NAME LENGTH\n#LOG0900 DS    0H\n         LA    R1,MEMBER           R1<--A(MEMBER NAME)\n         AR    R1,R2               POINT TO LAST BYTE\n         CLI   0(R1),C' '          Q. STILL BLANK ???\n         BNE   #LOG1000            ...NO: EXIT LOOP\n         BCT   R2,#LOG0900         ..YES: TRY NEXT BYTE\n#LOG1000 DS    0H\n         LA    R2,1(,R2)           GET TRUE LENGTH\n         STH   R2,MEMBLEN          SAVE IN ALLOCATION TEXT\n         LA    R1,DYNRBPTR         R1<--A(PERM LIST FOR ALLOCATION)\n         DYNALLOC\n         LTR   R15,R15             Q. DID IT ALLOCATE ???\n         BZ    #LOG1100            ..YES\n         UNPK  $ALCWTO+41(5),DYNERR(3)\n         TR    $ALCWTO+41(4),HXTAB-240\n         MVI   $ALCWTO+45,C' '\n$ALCWTO  WTO   'USR0317E - ALLOCATION FAILED, RC=XXXX ',               X\n               ROUTCDE=(11)\n         SYSRETRN RC=8\n         EJECT\n#LOG1100 DS    0H\n         OPEN  (LOGIN,INPUT)\n         GET   LOGIN,LOGRECIN      GET FIRST INPUT RECORD\n         MVC   FIRSDATE,HCLDATE    SET STARTING DATE\n         MVC   FIRSTIME,HCLTIME    SET STARTING TIME\n         PUT   SYSPRINT,HDR4       SHOW STARTING TIME OF HISTORY\n         PUT   SYSPRINT,HDR3\n         B     #LOG1300            CONTINUE ON\n#LOG1200 DS    0H\n         MVC   LOGRECIN(133),LOGRECIN-1 CLEAN OUT INPUT RECORD\n         GET   LOGIN,LOGRECIN      GET EACH LOG RECORD\n#LOG1250 DS    0H\n         CLI   HCLDATE,C' '        Q. BLANK WHERE WE EXPECT DATE ???\n         BE    #LOG1300            ..YES: DON'T SAVE DATE\n         MVC   LASTDATE,HCLDATE    SAVE RECORD DATE\n         MVC   LASTTIME,HCLTIME    SAVE RECORD TIME\n#LOG1300 DS    0H\n         CLI   FLAG,X'00'          Q. ANY OPTIONS SPECIFIED ???\n         BE    #LOG4200            ...NO: PRINT ALL RECORDS\n***********************************************************************\n*    PROCESS DATERANGE OPTION IF SPECIFIED\n***********************************************************************\n#LOG1400 DS    0H\n         TM    FLAG,DTRNG          Q. WAS DATERANGE SPECIFIED ???\n         BZ    #LOG2000            ...NO: GO CHECK OTER OPTIONS\n         CLC   HCLDATE,LOWDATE     CHECK AGAINST LOWDATE\n         BL    #LOG1200            TOO LOW: KEEP READIN\n         TM    OPTFLAG,HIDT        Q. WAS HIGHDATE GIVEN ???\n         BZ    #LOG1500            ...NO: GO CHECK TIME\n         CLC   HCLDATE,HIGHDATE    CHECK HIGH DATE\n         BH    #LOG4300            HIGH: WE ARE ALL DONE\n         EJECT\n***********************************************************************\n*    PROCESS TIMERANGE OPTION IF SPECIFIED\n***********************************************************************\n#LOG1500 DS    0H\n         TM    FLAG,255-DTRNG      Q. ANY OTHER OPTIONS ???\n         BZ    #LOG4200            ...NO: RECORD PASSED FILTERING\n         TM    FLAG,TMRNG          Q. WAS TIMERANGE OPTION SPECIFIED ?\n         BZ    #LOG2000            ...NO: GO CHECK OTHER OPTIONS\n         TM    OPTFLAG,LOTIMOK     Q. LOW TIME REACHED ???\n         BO    #LOG1700            ..YES: GO CHECK HIGH TIME\n         CLC   HCLDATE,LOWDATE     Q. IS THIS LOWDATE ???\n         BE    #LOG1600            ..YES: GO CHECK LOW TIME\n         OI    OPTFLAG,LOTIMOK     ...NO: NO NEED TO CHECK LOW TIME\n         B     #LOG1700            GO CHECK HIGH TIME\n#LOG1600 DS    0H\n         CLC   HCLTIME(L'LOWTIME),LOWTIME CHECK LOW TIME\n         BL    #LOG1200            TOO LOW: GO TRY ANOTHER LOG RECORD\n         OI    OPTFLAG,LOTIMOK     NOT TOO LOW: SHOW IT\n         B     #LOG2000            GO CHECK OTHER OPTIONS\n#LOG1700 DS    0H\n         TM    OPTFLAG,HITIM       Q. HIGH TIME GIVEN ???\n         BZ    #LOG2000            ...NO: GO CHECK OTHER OPTIONS\n         TM    OPTFLAG,HIDT        Q. HIGH DATE GIVEN ???\n         BZ    #LOG1800            ...NO: GO CHECK TIME FOR ONE DAY\n         CLC   HCLDATE,HIGHDATE    CHECK HIGH DATE\n         BL    #LOG2000            LOW: GO CHECK OTHER OPTIONS\n         B     #LOG1900            GO CHECK TIME\n#LOG1800 DS    0H\n         CLC   HCLDATE,LOWDATE     CHECK DATE -- ONE DAY ONLY\n         BNE   #LOG4300            ...NE: DONE\n#LOG1900 DS    0H\n         CLC   HCLTIME(L'HIGHTIME),HIGHTIME DATE MATCH: CHECK TIME\n         BNH   #LOG2000            LOW: GO CHECK OTHER OPTIONS\n         B     #LOG4300            HIGH: WE ARE ALL DONE\n***********************************************************************\n*    PROCESS OTHER OPTIONS IF SPECIFIED\n***********************************************************************\n#LOG2000 DS    0H\n         TM    FLAG,255-(DTRNG+TMRNG)  Q. ANY OTHER OPTIONS ???\n         BZ    #LOG4200            ...NO: RECORD PASSED FILTERING\n         TM    FLAG,255-(DTRNG+TMRNG)  Q. ANY OTHER OPTIONS ???\n         BZ    #LOG4200            ...NO: RECORD PASSED FILTERING\n         EJECT\n***********************************************************************\n*    PROCESS JOBNAME OPTION IF SPECIFIED\n***********************************************************************\n#LOG2100 DS    0H\n         TM    FLAG,JOBNAM         Q. WAS JOBNAME OPTION SPECIFIED ?\n         BZ    #LOG3300            ...NO: GO PROCESS JOBNUMB\n         ICM   R7,15,JOBNMCNT      Q. SPECIFIC JOBNAMES ???\n         BNZ   #LOG2200            ..YES\n         CLC   HCLJOBID+4(4),=CL4' ' Q. JOBNUMBER ON THIS MESSAGE ???\n         BE    #LOG3600            ...NO: CONTINUE ON\n         CLC   HCLJOBID(3),=C'JOB' Q. JOB ???\n         BE    #LOG4200            ..YES: GO PRINT THIS MESSAGE\n         CLC   HCLJOBID(3),=C'STC' Q. STC ???\n         BE    #LOG4200            ..YES: GO PRINT THIS MESSAGE\n         CLC   HCLJOBID(3),=C'TSU' Q. TSU ???\n         BE    #LOG4200            ..YES: GO PRINT THIS MESSAGE\n         B     #LOG3300            ...NO: GO CHECK JOB NUMBERS\n#LOG2200 DS    0H\n         CLC   HCLTEXT+1(8),=CL8'$HASP100' Q. JOB ON READER MESSAGE ???\n         BE    #LOG2300            ..YES: GO CHECK NAME\n         CLC   HCLTEXT+1(8),=CL8'$HASP373' Q. JOB STARTED MESSAGE ???\n         BE    #LOG2600            ..YES: GO CHECK NAME\n         CLC   HCLTEXT+1(8),=CL8'$HASP395' Q. JOB ENDED MESSAGE ???\n         BE    #LOG2800            ..YES: GO CHECK NAME\n         CLC   HCLTEXT+1(8),=CL8'$HASP250' Q. JOB PURGED MESSAGE ???\n         BE    #LOG2800            ..YES: GO CHECK NAME\n         B     #LOG3300\n***********************************************************************\n*    MESSAGE $HASP100 - JOB X ON READER - CHECK JOBNAME AGAINST TABLE\n***********************************************************************\n#LOG2300 DS    0H\n         BAL   R8,#LOG3100         CHECK JOBNAME AGAINST JOBNAME TABLE\n         LTR   R14,R14             Q. FOUND ???\n         BNZ   #LOG3300            ...NO: TRUCK ON\n***********************************************************************\n*    JOBNAME MATCH - INSERT JOB NUMBER INTO JOBID TABLE\n***********************************************************************\n#LOG2400 DS    0H\n         L     R1,JOBIDCNT         R1<--COUNT(TABLE ENTRIES)\n         LA    R2,1(,R1)           R2<--NEW COUNT\n         C     R2,=F'100'          Q. TABLE OVERFLOW ???\n         BH    #LOG2500            ...YES: GO GIVE ERROR\n         ST    R2,JOBIDCNT         SAVE NEW COUNT\n         MH    R1,=H'4'            R1<--OFFSET INTO TABLE\n         A     R1,=A(JOBIDS)       R1<--A(NEW TABLE ENTRY)\n         MVC   0(4,R1),HCLJOBID+4  SAVE JOB NUMBER IN TABLE\n         OC    0(4,R1),=CL4'0000'  MAKE IT ALL NUMERIC\n         B     #LOG4200            GO WRITE THIS RECORD\n***********************************************************************\n*    JOB ID TABLE OVERFLOW -- GIVE ERROR\n***********************************************************************\n#LOG2500 DS    0H\n         WTO   'USR0315E - JOB ID TABLE OVERFLOW - POSSIBLE DATA LOST',*\n               ROUTCDE=(11)\n         B     #LOG3300            CONTINUE TRYING THIS RECORD\n         EJECT\n***********************************************************************\n*    $HASP373 - X STARTED - CHECK JOBNAME AGAINST TABLE\n***********************************************************************\n#LOG2600 DS    0H\n         BAL   R8,#LOG3100         CHECK AGAINST JOBNAME TABLE\n         LTR   R14,R14             Q. FOUND IN TABLE ???\n         BNZ   #LOG3300            ...NO: GO TO NEXT OPTION TEST\n***********************************************************************\n*    JOBNAME FOUND IN JOBNAME TABLE -- CHECK JOBID TABLE -- IF ALREADY\n*    IN TABLE (FROM $HASP100) THEN PRINT THIS RECORD -- IF NOT ALREADY\n*    IN TABLE THEN GO ADD IT TO THE TABLE.\n***********************************************************************\n         ICM   R1,15,JOBIDCNT      R1<--COUNT(TABLE ENTRIES)\n         BZ    #LOG2400            ..NONE: GO INSERT\n         LA    R2,JOBIDS           R2<--A(JOBID TABLE)\n         MVC   JOBTEMP,HCLJOBID+4  GET JOB NUMBER\n         OC    JOBTEMP,=CL4'0000'  FORCE ALL NUMERICS\n#LOG2700 DS    0H\n         CLC   JOBTEMP,0(R2)       COMPARE AGAINST JOBID TABLE\n         BE    #LOG4200            ..MATCH: GO WRITE THIS RECORD\n         LA    R2,4(,R2)           R2<--A(NEXT TABLE ENTRY)\n         BCT   R1,#LOG2700         LOOP FOR ALL TABLE ENTRIES\n         B     #LOG2400            ..NOT FOUND -- GO INSERT THIS ID\n***********************************************************************\n*    $HASP250 - X IS PURGED      -- OR --\n*    $HASP395 - X ENDED - FIND JOB ID IN TABLE AND DELETE IT\n***********************************************************************\n#LOG2800 DS    0H\n         BAL   R8,#LOG3100         SEARCH JOBNAME TABLE THIS NAME\n         LTR   R14,R14             Q. WAS JOBNAME FOUND IN TABLE ???\n         BNZ   #LOG3300            ...NO: GO TO NEXT TEST\n***********************************************************************\n*    JOBNAME MATCH -- SEARCH JOBID TABLE AND DELETE ENTRY FOR THIS JOB\n***********************************************************************\n         ICM   R1,15,JOBIDCNT      R1<--COUNT(TABLE ENTRIES)\n         BZ    #LOG3300            ..NONE -- NO NEED TO SEARCH TABLE\n         LA    R2,JOBIDS           R2<--A(JOBID TABLE)\n         MVC   JOBTEMP,HCLJOBID+4  GET JOB ID\n         OC    JOBTEMP,=CL4'0000'  ENSURE ALL NUMERICS\n#LOG2900 DS    0H\n         CLC   JOBTEMP,0(R2)       CHECK AGAINST TABLE\n         BE    #LOG3000            ..MATCH\n         LA    R2,4(,R2)           R2<--ADDRESS(NEXT TABLE ENTRY)\n         BCT   R1,#LOG2900         LOOP FOR ALL TABLE ENTRIES\n         B     #LOG3300            ..NOT FOUND -- TO NEXT TEST\n#LOG3000 DS    0H\n         MVC   0(4,R2),4(R2)       MOVE IN NEXT ENTRY\n         LA    R2,4(,R2)           POINT TO NEXT TABLE ENTRY\n         BCT   R1,#LOG3000         LOOP FOR ALL TABLE ENTRIES\n         L     R1,JOBIDCNT         GET ID COUNT\n         BCTR  R1,R0               DECREMENT COUNT\n         ST    R1,JOBIDCNT         SAVE UPDATED COUNT\n         B     #LOG4200            GO WRITE THIS RECORD\n         EJECT\n***********************************************************************\n*    JOBNAME TABLE SEARCH ROUTINE - ON ENTRY R7 HAS TABLE ENTRY COUNT\n*    AND R8 HAS RETURN ADDRESS\n***********************************************************************\n#LOG3100 DS    0H\n         LA    R6,JOBNAMES         R6<--ADDRESS(JOBNAME TABLE)\n         USING JOBDSECT,R6\n         SR    R14,R14             SET GOOD RETURN CODE\n#LOG3200 DS    0H\n         L     R5,@JLEN            R5<--LENGTH FOR COMPARE\n         EX    R5,$JBNMCMP         COMPARE AGAINST TABLE ENTRY\n         BER   R8                  ..MATCH: RETURN\n         LA    R6,@JENTLEN(,R6)    R6<--ADDRESS(NEXT TABLE ENTRY)\n         BCT   R7,#LOG3200         LOOP FOR ALL ENTRIES\n         LA    R14,8               SET BAD RETURN CODE\n         BR    R8                  RETURN TO CALLER\n$JBNMCMP CLC   @JNAME(0),HCLTEXT+10  >>>>EXECUTED<<<<\n         DROP  R6\n***********************************************************************\n*    PROCESS JOBNUMBER OPTION IF SPECIFIED\n***********************************************************************\n#LOG3300 DS    0H\n         TM    FLAG,JOBNAM+JOBNUM  Q. WAS JOBNAM OR JOBNUM SPECIFIED ?\n         BZ    #LOG3600            ...NO: GO PROCESS MESSAGE IDS\n         CLC   HCLJOBID+4(4),=CL4' ' Q. JOB NUMBER IN LOG RECORD ???\n         BE    #LOG3600            ...NO: SKIP ALL JOB PROCESSING\n         CLC   HCLJOBID(3),=C'JOB' Q. JOB ???\n         BE    #LOG3400            ..YES\n         CLC   HCLJOBID(3),=C'STC' Q. STC ???\n         BE    #LOG3400            ..YES\n         CLC   HCLJOBID(3),=C'TSU' Q. TSU ???\n         BE    #LOG3400            ..YES\n         B     #LOG3600            ...NO: GO CHECK JOB NUMBERS\n#LOG3400 DS    0H\n         ICM   R2,15,JOBIDCNT      GET NUMBER OF TABLE ENTRIES\n         BZ    #LOG3600            NONE: GO CHECK MESSAGE IDS\n***********************************************************************\n*    SEARCH TABLE FOR MATCH ON JOB NUMBER\n***********************************************************************\n         LA    R3,JOBIDS           GET TABLE OF JOB NUMBERS\n         MVC   JOBTEMP,HCLJOBID+4  GET JOB ID\n         OC    JOBTEMP,=CL4'0000'  FORCE ALL NUMERIC\n#LOG3500 DS    0H\n         CLC   0(4,R3),JOBTEMP     Q. LOG RECORD MATCH TABLE ENTRY ?\n         BE    #LOG4200            ..YES: GO WRITE IT\n         LA    R3,4(,R3)           POINT TO NEXT TABLE ENTRY\n         BCT   R2,#LOG3500         LOOP FOR ALL TABLE ENTRIES\n         EJECT\n***********************************************************************\n*    PROCESS MESSAGE ID OPTION IF SPECIFIED\n***********************************************************************\n#LOG3600 DS    0H\n         TM    FLAG,MSGID          Q. WAS MESSAGE OPTION SPECIFIED ?\n         BZ    #LOG3800            ...NO: GO CHECK FOR ABEND\n         ICM   R1,15,MSGIDCNT      GET MESSAGE COUNT\n         BZ    #LOG3800\n         LA    R2,MSGIDS           GET MESSAGE ID TABLE\n#LOG3700 DS    0H\n         IC    R3,0(R2)           R3<--COMPARE LENGTH\n         EX    R3,$MSGCMP         Q. DOES THE MESSAGE MATCH ???\n         BE    #LOG4200            ..YES: PRINT IT\n         LA    R2,9(,R2)           ...NO: GET NEXT TABLE ENTRY\n         BCT   R1,#LOG3700         LOOP FOR ALL TABLE ENTRIES\n***********************************************************************\n*    PROCESS ABEND OPTION IF SPECIFIED\n***********************************************************************\n#LOG3800 DS    0H\n         TM    FLAG,ABEND          Q. WAS ABEND OPTION SPECIFIED ???\n         BZ    #LOG4000            ...NO: GO CHECK DATA OPTION\n         CLC   HCLTEXT+1(8),=CL8'IEF450I' Q. JOB ABENDED MESSAGE ???\n         BNE   #LOG4000            ...NO: GO CHECK FOR DATA CARDS\n         TM    OPTFLAG,ABSTC+ABTSO+ABJOB  Q. TYPE CHECKING ???\n         BZ    #LOG3840                   ...NO: GO CHECK FOR ABEND IDS\n         TM    OPTFLAG,ABSTC       Q. STC ABENDS ???\n         BZ    #LOG3820\n         CLC   HCLJOBID(3),=C'STC' Q. STC ???\n         BE    #LOG3840            ..YES: GO CHECK FOR SPECIFIC ID'S\n         B     #LOG4000            ...NO: GO CHECK DATA OPTION\n#LOG3820 DS    0H\n         TM    OPTFLAG,ABTSO       Q. TSO ABENDS ???\n         BZ    #LOG3830\n         CLC   HCLJOBID(3),=C'TSU' Q. TSO ???\n         BE    #LOG3840            ..YES: GO CHECK FOR SPECIFIC ID'S\n         B     #LOG4000            ...NO: GO CHECK DATA OPTION\n#LOG3830 DS    0H\n         CLC   HCLJOBID(3),=C'JOB' Q. JOB ???\n         BE    #LOG3840            ..YES: GO CHECK FOR SPECIFIC ID'S\n         B     #LOG4000            ...NO: GO CHECK DATA OPTION\n#LOG3840 DS    0H\n         TM    OPTFLAG,ABIDS       Q. SPECIFIC ID'S ???\n         BZ    #LOG4200            ...NO: PRINT THIS ABEND\n         XC    TRTTAB,TRTTAB       CLEAN OUT TRT TABLE\n         MVI   TRTTAB+C'-',C'-'    SET CHARACTER FOR SCAN\n         TRT   HCLTEXT+9(30),TRTTAB FIND THE '-' IN THE MESSAGE\n         BZ    #LOG4000            ..NOT THERE\n         CLC   0(7,R1),=CL7'- ABEND' Q. IS IT WHAT WE EXPECTED ???\n         BNE   #LOG4000            ...NO\n         LA    R3,8(,R1)           R3<--A(SYSTEM ABEND ID FIELD)\n         ICM   R1,15,ABNDCNT       GET COUNT OF ABEND ID'S\n         BZ    #LOG4000\n         LA    R2,ABNDIDS          R2<--A(ABEND ID TABLE)\n#LOG3900 DS    0H\n         CLC   0(4,R3),0(R2)       CHECK SYSTEM ABEND ID\n         BE    #LOG4200            -->MATCH\n         CLC   5(5,R3),0(R2)       CHECK USER ABEND ID\n         BE    #LOG4200            -->MATCH\n         LA    R2,5(,R2)           POINT TO NEXT TABLE ENTRY\n         BCT   R1,#LOG3900         GO THROUGH ENTIRE TABLE\n         EJECT\n***********************************************************************\n*    PROCESS DATA OPTION IF SPECIFIED\n***********************************************************************\n#LOG4000 DS    0H\n         TM    FLAG,DATA\n         BZ    #LOG1200\n         ICM   R1,15,DATACNT       GET COUNT OF DATA ITEMS\n         BZ    #LOG1200            ..NOT THERE\n         LA    R2,DATATBL          R2<--ADDRESS(TABLE OF DATA ITEMS)\n         USING DATDSECT,R2\n#LOG4100 DS    0H\n         LA    R3,HCLDATE          R3<--ADDRESS(DATE FIELD)\n         AH    R3,@DOFF            R3<--ADDRESS(COMPARISON FIELD)\n         LH    R4,@DLEN            R4<--LENGTH FOR COMPARE\n         EX    R4,$DATACMP         DO THE DATA COMPARISON\n         BE    #LOG4200            ..EQUAL: GO WRITE THIS RECORD\n         LA    R2,@DENTLEN(,R2)    BUMP TO NEXT TABLE ENTRY\n         BCT   R1,#LOG4100         CONTINUE FOR ALL DATA ITEMS\n         B     #LOG1200            ..NOT FOUND: GO GET NEXT RECORD\n$MSGCMP  CLC   HCLTEXT+1(0),1(R2)  >>>>EXECUTED<<<<\n$DATACMP CLC   0(0,R3),@DATA       >>>>EXECUTED<<<<\n         DROP  R2\n***********************************************************************\n*    RECORD PASSED FILTERING - PRINT IT\n***********************************************************************\n#LOG4200 DS    0H\n         AP    LOGCOUNT,=P'+1'     KEEP RECORD TOTAL\n         MVC   LINEDATA,LOGRECD    MOVE DATA TO OUTPUT LINE\n         PUT   SYSPRINT,LINEOUT    WRITE OUTPUT LINE\n         CLI   HCLRECTP,HCLMLWTO   CHECK FOR MULTI-LINE MESSAGE\n         BNE   #LOG4225            NO, DON'T SET FLAG\n         OI    OPTFLAG,MULTMSG     TURN OFF MULTI-LINE MSG FLAG\n#LOG4225 DS    0H\n         MVC   LINEOUT(133),LINEOUT-1  CLEAN OUT THE OUTPUT LINE\n         MVC   LOGRECIN(133),LOGRECIN-1 CLEAN OUT INPUT RECORD\n         GET   LOGIN,LOGRECIN      GET EACH LOG RECORD\n         TM    OPTFLAG,MULTMSG     PROCESSING MULTIPLE LINE MESSAGE ???\n         BNO   #LOG4250            ...NO: CONTINUE ON\n         CLI   HCLRECTP,HCLLABEL   CHECK FOR MULTI-LINE MESSAGE\n         BE    #LOG4200            YES, GO PRINT THIS PORTION\n         CLI   HCLRECTP,HCLDATA    CHECK FOR MULTI-LINE MESSAGE\n         BE    #LOG4200            YES, GO PRINT THIS PORTION\n         NI    OPTFLAG,255-MULTMSG TURN OFF MULTI-LINE MSG FLAG\n         CLI   HCLRECTP,HCLDTEND   CHECK FOR END OF MULTI-LINE MESSAGE\n         BE    #LOG4200            YES, GO PRINT LAST PORTION\n#LOG4250 DS    0H\n         CLI   HCLRECTP,HCLSPLIT   CHECK FOR SPLIT MESSAGE\n         BE    #LOG4200            YES, GO PRINT SECOND PORTION\n         B     #LOG1250            GO PROCESS NEXT RECORD\n         EJECT\n***********************************************************************\n*    END OF FILE ROUTINE FOR HISTORY FILE -- SHUT DOWN\n***********************************************************************\n#LOG4300 DS    0H\n         CLOSE (LOGIN)\n         PUT   SYSPRINT,TRLR3      SHOW LAST LOG RECORD TIME\n         CLI   PDSFLAG,X'FF'       Q. PROCESSING A PDS ???\n         BNE   #LOG4400            ...NO: EXIT\n         SP    MEMCT,=P'+1'        Q. ANY MEMBERS LEFT ???\n         BP    #LOG0700            ..YES\n#LOG4400 DS    0H\n         MVC   TRLR1+5(10),=X'40206B2020206B202120'  SET EDIT MASK\n         ED    TRLR1+5(10),LOGCOUNT  SET RECORD COUNT IN MESSAGE\n         PUT   SYSPRINT,TRLR1      WRITE REPORT\n         PUT   SYSPRINT,TRLR2      TRAILER RECORDS\n         CLOSE (SYSPRINT)\n         PRINT GEN\n         SYSRETRN RC=0\n         PRINT NOGEN\n         EJECT\n***********************************************************************\n*\n*    THE PRMCHK ROUTINE READS THE INPUT DECK AND BUILDS TABLES FROM\n*    THE INPUT CARDS TO CONTROL THE EXECUTION OF THE LOG SCAN.\n*\n*    REGISTER USAGE:\n*\n*    R4  = BASE FOR KYWDSECT\n*    R7  = CURRENT POINTER INTO INPUT CARD\n*    R8  = RETURN ADDRESS\n*    R14 = ERROR CODE\n*\n***********************************************************************\n#PRM0000 DS    0H\n         PUT   SYSPRINT,HDR1\n         OPEN  (SYSIN,INPUT)\n#PRM0100 DS    0H\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         GET   SYSIN,CARD          GET EACH PARAMETER CARD\n         LA    R7,CARD             R7<--A(START OF DATA CARD)\n         PUT   SYSPRINT,CARD-1     ECHO EACH INPUT CARD\n         MVI   CARD-1,C' '         RESET CARRAIGE CONTROL\n         LA    R9,0                SET ERROR CODE\n         TRT   CARD(71),BLNKTRT    FIND FIRST NON-BLANK CHAR\n         BZ    #PRM2700            NON FOUND: ERROR\n         LR    R7,R1               UPDATE POINTER\n         MVI   TRTTAB+C' ',C' '    SETUP TRT TABLE\n         MVI   TRTTAB+C'(',C'('\n         TRT   0(10,R7),TRTTAB     FIND ' ' OR '('\n         BZ    #PRM2700            NOTHING FOUND: ERROR\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         LR    R3,R1               R3<--A(END OF KEYWORD)\n         SR    R3,R7               R3<--LENGTH(KEYWORD)\n         LA    R4,KYWDTBL          R4<--A(KEYWORD TABLE)\n         USING KYWDSECT,R4\n         LA    R9,1                SET ERROR CODE\n***********************************************************************\n*    SEARCH TABLE FOR KEYWORD -- IF FOUND GO TO THE ROUTINE TO\n*    HANDLE THE KEYWORD AND IT'S PARAMETERS\n***********************************************************************\n#PRM0200 DS    0H\n         CH    R3,@LEN             Q. DOES LENGTH MATCH ???\n         BL    #PRM0300            ..LOW: GO TRY NEXT TABLE ENTRY\n         BE    #PRM0400            ..YES: GO TRY THIS TABLE ENTRY\n         BH    #PRM2700            ...HI: NOT IN TABLE\n         EJECT\n***********************************************************************\n*    LENGTH BAD -- GET NEXT TABLE ENTRY\n***********************************************************************\n#PRM0300 DS    0H\n         LA    R4,@KLEN(,R4)       BUMP TO NEXT TABLE ENTRY\n         CLI   @LEN,X'FF'          Q. END OF TABLE ???\n         BNE   #PRM0200            ...NO: GO TRY THIS ENTRY\n         LA    R9,1                SET ERROR CODE\n         B     #PRM2700            ..YES: KEYWORD NOT IN TABLE\n***********************************************************************\n*    LENGTH EQUAL -- CHECK FOR KEYWORD MATCH  -- ON ENTRY TO THE\n*    KEYWORD ROUTINES R9 = 0 IF R7 POINTS TO A PAREN AND R9 = 3\n*    IF A PAREN WAS NOT FOUND (NO OPERANDS FOR THE KEYWORD)\n***********************************************************************\n#PRM0400 DS    0H\n         SR    R9,R9               CLEAN OUT R9\n         LR    R5,R3               R5<--ITEM LENGTH\n         BCTR  R5,R0               GET LENTH FOR EXECUTE\n         EX    R5,$KEYWCHK         COMPARE DATA WITH TABLE\n         BNE   #PRM0300            ...NE: GO TRY NEXT TABLE ENTRY\n         LR    R7,R1               POINT TO BLANK OR PAREN\n         L     R6,@ADDR            R6<--A(KEYWORD ROUTINE)\n         CLM   R2,1,=C'('          Q. WAS A PAREN FOUND ???\n         BER   R6                  ..YES: GO PROCESS KEYWORD\n         LA    R5,CARD+70          GET END OF DATA COLUMN - 1\n         SR    R5,R7               GET EXECUTABLE LENGTH LEFT IN CARD\n         LA    R9,3                SET ERROR CODE\n         EX    R5,$KEYWPRN         TRY TO FIND PAREN\n         BZR   R6                  ..NOT FOUND: GO PROCESS KEYWORD\n         LR    R7,R1               ..FOUND: POINT TO IT\n         SR    R9,R9               CLEAN OUT R9\n         CLI   0(R1),C'('          Q. WAS A PAREN FOUND ???\n         BER   R6                  ..YES: GO PROCESS KEYWORD\n         LA    R9,4                SET ERROR MESSAGE\n         B     #PRM2700            BAD DATA: ERROR\n$KEYWCHK CLC   0(0,R7),@KYWD       >>>EXECUTED<<<\n$KEYWPRN TRT   0(0,R7),BLNKTRT     >>>EXECUTED<<<\n         DROP  R4\n         EJECT\n***********************************************************************\n*\n*    PROCESS DATERANGE CARD -- DATES IN FORMAT YY.DDD\n*\n*         MOVE FIRST DATE FIELD INTO 'LOWDATE'\n*\n*         MOVE SECOND DATE FIELD INTO 'HIGHDATE' AND SET 'HIDAT' FLAG\n*\n***********************************************************************\n#PRM0600 DS    0H\n         LTR   R9,R9               Q. WAS PAREN FOUND ???\n         BNZ   #PRM2700            ...NO: ERROR\n         LA    R9,6                SET ERROR CODE\n         TM    FLAG,DTRNG          Q. PROCESSED KEYWORD BEFORE ???\n         BO    #PRM2700            ..YES: ERROR\n         OI    FLAG,DTRNG          SHOW OPTION\n         LA    R7,1(,R7)           BUMP OVER PAREN\n         LA    R9,4                SET ERROR CODE\n         CLI   2(R7),C'.'          CHECK FORMAT\n         BNE   #PRM2700            ..ERROR\n         MVZ   DBLWD(6),0(R7)      CONTINUE CHECKING FORMAT\n         CLC   DBLWD(6),=C'00 000'\n         BNE   #PRM2700\n         MVC   LOWDATE(2),0(R7)    SET LOW YEAR\n         MVC   LOWDATE+2(3),3(R7)  SET LOW DATE\n         LA    R7,6(,R7)           BUMP OVER FIRST DATE\n         CLI   0(R7),C')'          Q. ONLY ONE TIME GIVEN ???\n         BE    #PRM0100            ..YES: GO GET ANOTHER CARD\n         CLI   0(R7),C','          CHECK FORMAT\n         BNE   #PRM2700\n         LA    R7,1(,R7)           BUMP OVER COMMA\n         CLI   2(R7),C'.'          CHECK FORMAT\n         BNE   #PRM2700\n         MVZ   DBLWD(6),0(R7)      CONTINUE CHECKING FORMAT\n         CLC   DBLWD(6),=C'00 000'\n         BNE   #PRM2700\n         LA    R9,8                SET ERROR CODE\n         MVC   HIGHDATE(2),0(R7)   SET HIGH YEAR\n         MVC   HIGHDATE+2(3),3(R7) SET HIGH DATE\n         CLC   HIGHDATE,LOWDATE    VALIDATE HIGH DATE\n         BL    #PRM2700\n         OI    OPTFLAG,HIDT        SHOW DATE GIVEN\n         LA    R7,6(,R7)           BUMP OVER DATE\n         CLI   0(R7),C')'          CHECK FORMAT\n         BE    #PRM0100            ...OK: GO GET NEXT CARD\n         B     #PRM2700\n         EJECT\n***********************************************************************\n*\n*    PROCESS TIMERANGE CARD -- TIMES IN FORMAT HH.MM :\n*\n*         MOVE FIRST TIME FIELD INTO 'LOWTIME'\n*\n*         MOVE SECOND TIME FIELD INTO 'HIGHTIME' AND SET 'HITIM' FLAG\n*\n***********************************************************************\n#PRM0700 DS    0H\n         LTR   R9,R9               Q. WAS PAREN GIVEN ???\n         BNZ   #PRM2700            ...NO\n         LA    R9,6                SET ERROR CODE\n         TM    FLAG,TMRNG          Q. PREVIOUSLY SPECIFIED ???\n         BO    #PRM2700            ..YES\n         LA    R9,5                SET ERROR CODE\n         TM    FLAG,DTRNG          Q. WAS DATERANGE GIVEN ???\n         BZ    #PRM2700            ...NO\n         OI    FLAG,TMRNG          SET IN FLAG\n         LA    R7,1(,R7)           BUMP OVER PAREN\n         LA    R9,4                SET ERROR CODE\n         CLI   2(R7),C':'          CHECK FORMAT\n         BNE   #PRM2700\n         MVZ   DBLWD(5),0(R7)      CHECK FORMAT\n         CLC   DBLWD(5),=XL5'F0F070F0F0'\n         BNE   #PRM2700\n         MVC   LOWTIME,0(R7)       SET LOW TIME\n         LA    R7,5(,R7)           POINT PAST TIME FIELD\n         CLI   0(R7),C')'          Q. END OF TIME PARMS ???\n         BE    #PRM0100            ..YES\n         CLI   0(R7),C','          CHECK FORMAT\n         BNE   #PRM2700\n         LA    R7,1(,R7)           BUMP OVER COMMA\n         CLI   2(R7),C':'          CHECK FORMAT\n         BNE   #PRM2700\n         MVZ   DBLWD(5),0(R7)      CONTINUE CHECKING FORMAT\n         CLC   DBLWD(5),=XL5'F0F070F0F0'\n         BNE   #PRM2700\n         OI    OPTFLAG,HITIM       SHOW HIGH TIME GIVEN\n         MVC   HIGHTIME,0(R7)      SAVE HIGH TIME\n         LA    R7,5(,R7)           BUMP OVER THE TIME FIELD\n         CLI   0(R7),C')'          CHECK FORMAT\n         BE    #PRM0100\n         B     #PRM2700\n         EJECT\n***********************************************************************\n*\n*    PROCESS JOB CARD -- IF JOBNAMES ARE GIVEN:\n*\n*         MOVE EACH JOBNAME AND IT'S LENGTH INTO TABLE 'JOBNAMES'\n*\n*         SET COUNT OF TABLE ENTRIES IN 'JOBNMCNT'\n*\n*              R4 = POINTER INTO JOBNAME TABLE\n*              R5 = COUNT OF JOBNAMES\n*\n*    IF NO JOBNAMES ARE GIVEN LEAVE COUNT AT 0 AND GO GET NEXT CARD\n*\n***********************************************************************\n#PRM0800 DS    0H\n         LR    R6,R9               SAVE ENTRY CODE\n         LA    R9,6                SET ERROR CODE\n         TM    FLAG,JOBNAM         Q. ALREADY SPECIFIED ???\n         BO    #PRM2700            ..YES: ERROR\n         OI    FLAG,JOBNAM         SHOW JOBNAME SPECIFIFED\n         LTR   R9,R6               Q. WAS PAREN GIVEN ???\n         BNZ   #PRM0100            ...NO: GO GET NEXT PARM CARD\n         LA    R7,1(,R7)           SKIP OVER PAREN\n         LA    R4,JOBNAMES         R4<--A(TABLE OF JOBNAMES)\n         USING JOBDSECT,R4\n         SR    R5,R5               R5<--COUNT OF JOBNAMES\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         MVI   TRTTAB+C',',C','    SETUP TRT TABLE\n         MVI   TRTTAB+C')',C')'\n#PRM0900 DS    0H\n         LA    R9,4                SET ERROR CODE\n         TRT   0(9,R7),TRTTAB      FIND END OF JOBNAME\n         BZ    #PRM2700            ERROR IN JOBNAME\n         LR    R2,R1               SAVE ADDRESS\n         SR    R1,R7               GET LENGTH OF JOBNAME\n         BCTR  R1,R0               GET EXECUTABLE LENGTH\n         ST    R1,@JLEN            SAVE LENGTH IN TABLE\n         EX    R1,$JOBNMMV         MOVE JOBNAME INTO TABLE\n         LA    R5,1(,5)            BUMP NUMBER OF JOB NAMES\n         LA    R4,@JENTLEN(,R4)    BUMP TO NEXT TABLE ENTRY\n         LA    R9,9                SET ERROR CODE\n         C     R5,=F'50'           Q. TOO MANY JOBNAMES ???\n         BH    #PRM2700            ..YES\n         CLI   0(R2),C')'          Q. PAREN FOUND ???\n         BE    #PRM1000            ..YES: END OF PARM CARD\n         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???\n         BE    #PRM1100            ..YES: GO PROCESS IT\n         LA    R7,2(R1,R7)         SKIP OVER THIS JOB ID\n         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)\n         LA    R9,7                SET ERROR CODE\n         CR    R7,R1               Q. PAST END OF CARD DATA ???\n         BL    #PRM0900            ...NO\n         B     #PRM2700            ..YES: ERROR\n$JOBNMMV MVC   @JNAME(0),0(R7)     >>>EXECUTED<<<\n         EJECT\n***********************************************************************\n*    ALL JOBNAMES PROCESSED -- SAVE COUNT\n***********************************************************************\n#PRM1000 DS    0H\n         ST    R5,JOBNMCNT         SAVE COUNT OF JOBNAMES\n         B     #PRM0100            GO GET NEXT PARM CARD\n***********************************************************************\n*    CONTINUATION CARD NEEDED -- CALL CONTINUATION ROUTINE\n***********************************************************************\n#PRM1100 DS    0H\n         BAL   R6,#PRM2500         GO GET CONTINUATION CARD\n         B     #PRM0900            GO PROCESS IT\n         DROP  R4\n         EJECT\n***********************************************************************\n*    PROCESS JOBNUMBER CARD -- SET EACH JOB NUMBER INTO TABLE AND SET\n*         COUNT OF TABLE ENTRIES IN 'JOBIDCNT'\n*\n*         R4 = POINTER INTO JOBID TABLE\n*         R5 = COUNT OF JOB NUMBERS\n***********************************************************************\n#PRM1200 DS    0H\n         LTR   R9,R9               Q. WAS PAREN GIVEN ???\n         BNZ   #PRM2700            ...NO: ERROR\n         LA    R9,6                SET ERROR CODE\n         TM    FLAG,JOBNUM         Q. ALREADY SPECIFIED ???\n         BO    #PRM2700            ..YES: ERROR\n         OI    FLAG,JOBNUM\n         LA    R7,1(,R7)           SKIP OVER PAREN\n         LA    R4,JOBIDS           R4<--A(TABLE OF JOB NUMBERS)\n         SR    R5,R5               R5<--COUNT OF JOBNUMBERS\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         MVI   TRTTAB+C',',C','    SETUP TRT TABLE\n         MVI   TRTTAB+C')',C')'\n#PRM1300 DS    0H\n         LA    R9,4                SET ERROR CODE\n         TRT   0(5,R7),TRTTAB      FIND END OF JOB NUMBER\n         BZ    #PRM2700            ERROR IN JOB NUMBER\n         LR    R2,R1               SAVE ADDRESS\n         SR    R1,R7               GET LENGTH OF JOB NUMBER\n         LA    R6,4                R6<--EXPECTED LENGTH\n         SR    R6,R1               R6<--OFFSET FOR MOVE\n         AR    R6,R4               R6<--ADDRESS FOR MOVE\n         BCTR  R1,R0               GET EXECUTABLE LENGTH\n         EX    R1,$JOBIDMV         MOVE JOB NUMBER INTO TABLE\n         LA    R5,1(,5)            BUMP NUMBER OF JOB NUMBERS\n         OC    0(4,R4),=CL4'0000'  FORCE ALL NUMERICS\n         LA    R4,4(,R4)           BUMP TO NEXT TABLE ENTRY\n         LA    R9,14               SET ERROR CODE\n         C     R5,=F'50'           Q. TOO MANY JOB NUMBERS ???\n         BH    #PRM2700            ..YES\n         CLI   0(R2),C')'          Q. PAREN FOUND ???\n         BE    #PRM1400            ..YES: END OF PARM CARD\n         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???\n         BE    #PRM1500            ..YES: GO PROCESS IT\n         LA    R7,1(,R2)           SKIP OVER THIS JOB ID\n         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)\n         LA    R9,7                SET ERROR CODE\n         CR    R7,R1               Q. PAST END OF CARD DATA ???\n         BL    #PRM1300            ...NO\n         B     #PRM2700            ..YES: ERROR\n#PRM1400 DS    0H\n         ST    R5,JOBIDCNT         SAVE COUNT OF JOBNAMES\n         B     #PRM0100            GO GET NEXT PARM CARD\n$JOBIDMV MVC   0(0,R6),0(R7)       >>>EXECUTED<<<\n#PRM1500 DS    0H\n         BAL   R6,#PRM2500         GO GET CONTINUATION CARD\n         B     #PRM1300            GO PROCESS IT\n         EJECT\n***********************************************************************\n*    PROCESS MESSAGE CARD -- SET EACH MESSAGE ID INTO TABLE AND SET\n*         COUNT OF TABLE ENTRIES IN 'MSGIDCNT'\n*\n*         R4 = POINTER INTO MSGIDS TABLE\n*         R5 = COUNT OF MESSAGE IDS\n***********************************************************************\n#PRM1600 DS    0H\n         LTR   R9,R9               Q. WAS PAREN GIVEN ???\n         BNZ   #PRM2700            ...NO: ERROR\n         LA    R9,6                SET ERROR CODE\n         TM    FLAG,MSGID          Q. ALREADY SPECIFIED ???\n         BO    #PRM2700            ..YES: ERROR\n         OI    FLAG,MSGID          SET OPTION FLAG\n         LA    R7,1(,R7)           SKIP OVER PAREN\n         LA    R4,MSGIDS           R4<--A(TABLE OF MESSAGE IDS)\n         SR    R5,R5               R5<--COUNT OF MESSAGE IDS\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         MVI   TRTTAB+C',',C','    SETUP TRT TABLE\n         MVI   TRTTAB+C')',C')'\n#PRM1700 DS    0H\n         LA    R9,4                SET ERROR CODE\n         TRT   0(9,R7),TRTTAB      FIND END OF MESSAGE ID\n         BZ    #PRM2700            ERROR IN MESSAGE ID\n         LR    R2,R1               SAVE ADDRESS\n         SR    R1,R7               GET LENGTH OF MESSAGE ID\n         BCTR  R1,R0               GET EXECUTABLE LENGTH\n         STC   R1,0(R4)           SAVE COMPARE LENGTH\n         EX    R1,$MSGIDMV         MOVE MESSAGE ID INTO TABLE\n         LA    R5,1(,5)            BUMP NUMBER OF MESSAGE IDS\n         LA    R4,9(,R4)           BUMP TO NEXT TABLE ENTRY\n         LA    R9,11               SET ERROR CODE\n         C     R5,=F'50'           Q. TOO MANY MESSAGE IDS ???\n         BH    #PRM2700            ..YES\n         CLI   0(R2),C')'          Q. PAREN FOUND ???\n         BE    #PRM1800            ..YES: END OF PARM CARD\n         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???\n         BE    #PRM1900            ..YES: GO PROCESS IT\n         LA    R7,2(R1,R7)         SKIP OVER THIS MESSAGE ID\n         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)\n         LA    R9,7                SET ERROR CODE\n         CR    R7,R1               Q. PAST END OF CARD DATA ???\n         BL    #PRM1700            ...NO\n         B     #PRM2700            ..YES: ERROR\n#PRM1800 DS    0H\n         ST    R5,MSGIDCNT         SAVE COUNT OF MESSAGE IDS\n         B     #PRM0100            GO GET NEXT PARM CARD\n$MSGIDMV MVC   1(0,R4),0(R7)       >>>EXECUTED<<<\n***********************************************************************\n*    CONTINUATION CARD NEEDED -- CALL CONTINUATION ROUTINE\n***********************************************************************\n#PRM1900 DS    0H\n         BAL   R6,#PRM2500         GO GET CONTINUATION CARD\n         B     #PRM1700            GO PROCESS IT\n         EJECT\n***********************************************************************\n*    PROCESS ABEND CARD -- IF IDS ARE SPECIFIED THEN SET EACH ABEND ID\n*         INTO TABLE AND SET COUNT OF TABLE ENTRIES IN 'ABNDCNT'\n*\n*         R4 = POINTER INTO ABNDIDS TABLE\n*         R5 = COUNT OF JOB NUMBERS\n***********************************************************************\n#PRM2000 DS    0H\n         LR    R6,R9               SAVE ENTRY CODE\n         LA    R9,6                SET ERROR CODE\n         TM    FLAG,ABEND          Q. ALREADY SPECIFIED ???\n         BO    #PRM2700            ..YES: ERROR\n         OI    FLAG,ABEND          ...NO: SHOW IT NOW\n         LTR   R9,R6               Q. PAREN FOUND ???\n         BNZ   #PRM0100            ...NO: DONE WITH THIS CARD\n         LA    R7,1(,R7)           ..YES: SKIP OVER IT\n         CLC   =C'STC',0(R7)       Q. STC ABENDS ONLY ???\n         BNE   #PRM2010            ...NO: CONTINUE CHECKING\n         OI    OPTFLAG,ABSTC       SET STC ABEND ONLY FLAG\n         LA    R7,3(,R7)           SKIP OVER PARAMETER\n         B     #PRM2030\n#PRM2010 DS    0H\n         CLC   =C'TSO',0(R7)       Q. TSO ABENDS ONLY ???\n         BNE   #PRM2020            ...NO: CONTINUE CHECKING\n         OI    OPTFLAG,ABTSO       SET TSO ABEND ONLY FLAG\n         LA    R7,3(,R7)           SKIP OVER PARAMETER\n         B     #PRM2030\n#PRM2020 DS    0H\n         CLC   =C'JOB',0(R7)       Q. JOB ABENDS ONLY ???\n         BNE   #PRM2040            ...NO: CONTINUE CHECKING\n         OI    OPTFLAG,ABJOB       SET JOB ABEND ONLY FLAG\n         LA    R7,3(,R7)           SKIP OVER PARAMETER\n#PRM2030 DS    0H\n         CLI   0(R7),C')'          Q. END OF ABEND PARMS\n         BE    #PRM0100            ..YES: DONE WITH THIS CARD\n         LA    R9,4                SET ERROR CODE\n         CLI   0(R7),C','          Q. ABEND PARMS CONTINUE ???\n         BNE   #PRM2700            ...NO: CAN'T DECIPHER IT\n         LA    R7,1(,R7)           ..YES: SKIP OVER COMMA\n#PRM2040 DS    0H\n         OI    OPTFLAG,ABIDS       SET SUB-OPTION FLAG\n         LA    R4,ABNDIDS          R4<--A(TABLE OF ABEND IDS)\n         SR    R5,R5               R5<--COUNT OF ABEND IDS\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         MVI   TRTTAB+C',',C','    SETUP TRT TABLE\n         MVI   TRTTAB+C')',C')'\n#PRM2100 DS    0H\n         LA    R9,4                SET ERROR CODE\n         TRT   0(6,R7),TRTTAB      FIND END OF ABEND ID\n         BZ    #PRM2700            ERROR IN ABEND ID\n         LR    R2,R1               SAVE ADDRESS\n         SR    R1,R7               GET LENGTH OF ABEND ID\n         BCTR  R1,R0               GET EXECUTABLE LENGTH\n         EX    R1,$ABDIDMV         MOVE ABEND ID INTO TABLE\n         LA    R5,1(,5)            BUMP NUMBER OF ABEND IDS\n         LA    R4,5(,R4)           BUMP TO NEXT TABLE ENTRY\n         LA    R9,12               SET ERROR CODE\n         C     R5,=F'50'           Q. TOO MANY ABEND IDS ???\n         BH    #PRM2700            ..YES\n         CLI   0(R2),C')'          Q. PAREN FOUND ???\n         BE    #PRM2200            ..YES: END OF PARM CARD\n         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???\n         BE    #PRM2300            ..YES: GO PROCESS IT\n         LA    R7,2(R1,R7)         SKIP OVER THIS ABEND ID\n         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)\n         LA    R9,7                SET ERROR CODE\n         CR    R7,R1               Q. PAST END OF CARD DATA ???\n         BL    #PRM2100            ...NO\n         B     #PRM2700            ..YES: ERROR\n#PRM2200 DS    0H\n         ST    R5,ABNDCNT          SAVE COUNT OF ABEND IDS\n         B     #PRM0100            GO GET NEXT PARM CARD\n$ABDIDMV MVC   0(0,R4),0(R7)       >>>EXECUTED<<<\n***********************************************************************\n*    CONTINUATION CARD NEEDED -- CALL CONTINUATION ROUTINE\n***********************************************************************\n#PRM2300 DS    0H\n         BAL   R6,#PRM2500         GO GET CONTINUATION CARD\n         B     #PRM2100            GO PROCESS IT\n         EJECT\n***********************************************************************\n*    PROCESS DATA CARD -- FOR EACH DATA CARD SET THE LENGTH AND DATA\n*         IN THE DATA TABLE KEEPING THE COUNT IN 'DATACNT'\n*\n*         R5 = POINTER INTO DATATBL\n***********************************************************************\n#PRM2400 DS    0H\n         LTR   R9,R9               Q. PAREN FOUND ???\n         BNZ   #PRM2700            ...NO: ERROR\n         OI    FLAG,DATA           SET OPTION FLAG\n         L     R5,DATACNT          R5<--COUNT(DATA ITEMS)\n         LA    R5,1(,R5)           R5<--NEW TOTAL\n         LA    R9,13               R9<--ERROR CODE\n         C     R5,=F'10'           Q. TOO MANY DATA ITEMS ???\n         BH    #PRM2700            ..YES: ERROR\n         ST    R5,DATACNT          ...NO: SAVE NEW COUNT\n         BCTR  R5,R0               R5<--R5-1\n         MH    R5,=Y(@DENTLEN)     R5<--OFFSET(NEXT DATA ITEM)\n         A     R5,=A(DATATBL)      R5<--ADDRESS(NEXT DATA ITEM)\n         USING DATDSECT,R5\n         LA    R9,4                R9<--ERROR CODE\n         LA    R7,1(,R7)           SKIP OVER PAREN\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         MVI   TRTTAB+C',',C','    SET SCAN FOR COMMA\n         TRT   0(4,R7),TRTTAB      FIND NEXT COMMA\n         BZ    #PRM2700            ..NOT FOUND: ERROR\n         LR    R2,R1               R2<--ADDRESS(COMMA)\n         SR    R1,R7               R1<--LENGTH(OFFSET)\n         BCTR  R1,R0               R1<--R1-1  (EXECUTABLE LENGTH)\n         EX    R1,$DATAMVZ         PICK UP ZONES OF OFFSET\n         EX    R1,$DATACLC         Q. IS THE OFFSET FIELD NUMERIC ???\n         BNE   #PRM2700            ...NO: ERROR\n         LA    R9,15               R9<--ERROR CODE\n         EX    R1,$DATAPAK         CONVERT THE OFFSET TO PD\n         CVB   R3,DBLWD            CONVERT THE OFFSET TO BINARY\n         C     R3,=F'116'          Q. OFFSET WITHIN BOUNDS ???\n         BH    #PRM2700            ...NO: ERROR\n         BCTR  R3,R0               CONVERT TO 0 BASED OFFSET\n         STH   R3,@DOFF            SAVE OFFSET\n         LA    R7,1(R2)            R7<--ADDRESS(COMMA+1)  (DATA FIELD)\n         LA    R9,4                R9<-- ERROR CODE\n         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE\n         MVI   TRTTAB+C')',C')'    SET SCAN FOR RIGHT PAREN\n         TRT   0(21,R7),TRTTAB     FIND END OF DATA STRING\n         BZ    #PRM2700            ..NOT FOUND: ERROR\n         SR    R1,R7               R1<--LENGTH(DATA)\n         BCTR  R1,R0               R1<--R1-1  (EXECUTABLE LENGTH)\n         EX    R1,$DATAMVC         MOVE DATA FIELD INTO TABLE\n         STH   R1,@DLEN            SAVE DATA LENGTH\n         B     #PRM0100            GO GET NEXT PARAMETER CARD\n$DATAMVZ MVZ   DBLWD(0),0(R7)      >>>>EXECUTED<<<<\n$DATACLC CLC   DBLWD(0),=CL3'000'  >>>>EXECUTED<<<<\n$DATAPAK PACK  DBLWD(8),0(0,R7)    >>>>EXECUTED<<<<\n$DATAMVC MVC   @DATA(0),0(R7)      >>>>EXECUTED<<<<\n         DROP  R5\n         EJECT\n***********************************************************************\n*    GET PARAMETER CONTINUATION CARD\n***********************************************************************\n#PRM2500 DS    0H\n         OI    PRMFLAG,PRMCONT     SHOW CONTINUATION IN CASE OF EOF\n         GET   SYSIN,CARD          GET NEXT PARM CARD\n         NI    PRMFLAG,255-PRMCONT LIFT CONTINUATION FLAG\n         LA    R7,CARD             POINT TO START OF CARD\n         PUT   SYSPRINT,CARD-1     ECHO INPUT\n         LA    R9,10               SET ERROR CODE\n         TRT   CARD(71),BLNKTRT    FIND FIRST NON-BLANK\n         BZ    #PRM2700            BLANK CARD NOT ALLOWED\n         LR    R7,R1               RESET POINTER\n         BR    R6                  RETURN TO CALLER\n***********************************************************************\n*    END OF FILE ON PARAMETER CARDS -- RETURN IF NO ERRORS\n***********************************************************************\n#PRM2600 DS    0H\n         LA    R9,2                SET ERROR CODE\n         TM    PRMFLAG,PRMCONT     Q. PROCESSING A CONTINUATION CARD ?\n         BO    #PRM2700            ..YES: ERROR\n         CLOSE (SYSIN)\n         BR    R8                  RETURN TO CALLER\n***********************************************************************\n*    ERROR ROUTINE FOR PARAMETER CARD ERROR -- R9 CONTAINS ERROR CODE\n***********************************************************************\n#PRM2700 DS    0H\n         S     R7,=A(CARD)         GET OFFSET TO DATA\n         LA    R7,LINEDATA(R7)     GET OFFSET TO ERROR\n         MVI   0(R7),C'$'          SET ERROR POINTER\n         MVI   LINEOUT,C' '        SET CARRIAGE CONTROL\n         PUT   SYSPRINT,LINEOUT\n         MH    R9,=H'133'          GET OFFSET TO ERROR MESSAGE\n         A     R9,=V(MSGCSECT)     POINT TO ACTUAL ERROR MESSAGE\n         PUT   SYSPRINT,0(R9)      WRITE THE ERROR MESSAGE\n         MVC   TRLR1+6(9),=C'        0'  SET RECORD COUNT\n         PUT   SYSPRINT,TRLR1      WRITE REPORT\n         PUT   SYSPRINT,TRLR2      TRAILER RECORDS\n         CLOSE (SYSIN,,SYSPRINT)\n         PRINT GEN\n         SYSRETRN RC=8\n         PRINT NOGEN\n         EJECT\n         LTORG\n         SPACE\nDBLWD    DC    D'0'              WORK AREA\nKYWDTBL  DS    0D\n         DC    A(#PRM0600),H'09',CL10'DATERANGE  '\n         DC    A(#PRM0700),H'09',CL10'TIMERANGE  '\n         DC    A(#PRM1200),H'09',CL10'JOBNUMBER  '\n         DC    A(#PRM1600),H'07',CL10'MESSAGE    '\n         DC    A(#PRM2000),H'05',CL10'ABEND      '\n         DC    A(#PRM0800),H'04',CL10'JOBS       '\n         DC    A(#PRM2400),H'04',CL10'DATA       '\n         DC    A(#PRM0800),H'03',CL10'JOB        '\n         DC    A(#PRM1600),H'03',CL10'MSG        '\n         DC    A(#PRM0600),H'02',CL10'DT         '\n         DC    A(#PRM0700),H'02',CL10'TM         '\n         DC    A(#PRM1200),H'02',CL10'JN         '\n         DC    A(#PRM0800),H'01',CL10'J          '\n         DC    A(#PRM2400),H'01',CL10'D          '\n         DC    A(#PRM2000),H'01',CL10'A          '\n         DC    A(0),4X'FF'\n         EJECT\nPDSIN    DCB   DDNAME=PDSIN,DSORG=PS,EODAD=#LOG0600,MACRF=R,RECFM=F,   *\n               LRECL=256,BLKSIZE=256,EXLST=LSTA\nLOGIN    DCB   DDNAME=LOGIN,DSORG=PS,EODAD=#LOG4300,MACRF=GM\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,EODAD=#PRM2600,MACRF=GM\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      C\n               RECFM=FBA,LRECL=133,BLKSIZE=2660\n         SPACE\nLSTA     DS    0F\n         DC    X'87'               JFCB AREA EXIT\n         DC    AL3(JFCBAREA)\n         SPACE\n         DS    0F\n         DC    CL8'JFCB'           EYE READABLE HEADER FOR DUMP\nJFCBAREA DS    0F\n         DC    CL176' '            AREA FOR JFCB\n         SPACE\nMEMCT    DC    PL4'+0'             COUNT OF MEMBER IN PDS\nLOGCOUNT DC    PL4'+0'             COUNT OF RECORDS PRINTED\nJOBIDCNT DC    F'0'                COUNT OF ACTIVE JOB ID'S\nJOBNMCNT DC    F'0'                COUNT OF JOBNAME TABLE ENTRIES\nMSGIDCNT DC    F'0'                COUNT OF MESSAGE ID TABLE ENTRIES\nDATACNT  DC    F'0'                COUNT OF DATA ITEMS\nABNDCNT  DC    F'0'                COUNT OF ABEND ID TABLE ENTRIES\nNEXTMEM  DC    A(MEMTABL)          A(MEMBER TABLE)\nDEVINFO  DS    2F                  FOR INFORMATION FROM DEVTYPE\nPDSDD    DC    CL8'PDSIN'          DDNAME FOR DEVTYPE\nHXTAB    DC    C'0123456789ABCDEF' FOR HEX CONVERSIONS\nJOBNAMES DC    50CL12' '           ALIGN ON FULLWORD BOUNDARY\nDATATBL  DC    10CL24' '           ALIGN ON FULLWORD BOUNDARY\nMSGIDS   DC    50CL9' '\nABNDIDS  DC    50CL5' '\nJOBIDS   DC    100CL4' '\nMEMTABL  DC    100CL8' '           DIRECTORY OF MEMBERS ON PDS\n*\nPDSFLAG  DC    X'00'               X'FF' IF INPUT IS FROM PDS\n*\nFLAG     DC    X'00'\n*\nDTRNG    EQU   X'40'               DATERANGE SPECIFIED\nTMRNG    EQU   X'20'               TIMERANGE SPECIFIED\nJOBNUM   EQU   X'10'               JOBNUMBER SPECIFIED\nJOBNAM   EQU   X'08'               JOBNAME SPECIFIED\nMSGID    EQU   X'04'               MESSAGE SPECIFIED\nABEND    EQU   X'02'               ABEND SPECIFIED\nDATA     EQU   X'01'               DATA SPECIFIFED\n*\nOPTFLAG  DC    X'00'\n*\nHIDT     EQU   X'80'               HIGH DATE WAS GIVEN\nLOTIMOK  EQU   X'40'               LOW TIME HAS BEEN PASSED\nHITIM    EQU   X'20'               HIGH TIME WAS GIVEN\nABIDS    EQU   X'10'               ABEND IDS WERE GIVEN\nMULTMSG  EQU   X'08'               MULTIPLE LINE MESSAGE\nABSTC    EQU   X'04'               STC ABENDS ONLY\nABTSO    EQU   X'02'               TSO ABENDS ONLY\nABJOB    EQU   X'01'               JOB ABENDS ONLY\n*\nPRMFLAG  DC    X'00'\n*\nPRMCONT  EQU   X'80'               PROCESSING CONTINUATION CARD\n*\n         DC    C' '\nLINEOUT  DC    C'0'\nLINEDATA DC    CL132' '\nLOWDATE  DC    CL5' '\nHIGHDATE DC    CL5' '\nLOWTIME  DC    CL5' '\nHIGHTIME DC    CL5' '\nJOBTEMP  DC    CL4'0000'\nSYSTEM   DC    CL2' '\n         DC    C'0'                MUST BE IN FRONT OF CARD\nCARD     DC    CL80' '\n         DC    CL52' '             FOR ECHO OF INPUT\nBLNKTRT  DC    64X'FF',X'00',191X'FF'\n         DS    0F\nTRTTAB   DC    256X'00'\nDIRAREA  DC    CL256' '            I/O AREA FOR PDS DIRECTORY\n         EJECT\nHDR1     DC    CL133'1                                  SYSLOG HISTORY C\n               SCAN PROGRAM'\nHDR2     DC    CL133'0**** INPUT PARAMETER CARDS:'\nHDR3     DC    CL133' **** SELECTED LOG RECORDS:'\nHDR4     DS    0CL133\n         DC    CL27'0**** HISTORY START DATE = '\nFIRSDATE DC    CL5' '\n         DC    CL8' TIME = '\nFIRSTIME DC    CL5' '\n         DC    CL87' '\nTRLR1    DC    CL133' **** N,NNN,NNN LOG RECORDS PRINTED'\nTRLR2    DC    CL133' **** END OF JOB'\nTRLR3    DS    0CL133\n         DC    CL25'0**** HISTORY END DATE = '\nLASTDATE DC    CL5' '\n         DC    CL8' TIME = '\nLASTTIME DC    CL5' '\n         DC    CL89' '\n         DS    0F\n***********************************************************************\n*     MAP FOR INPUT SYSLOG RECORD\n***********************************************************************\n         DC    C' '                TO CLEAR INPUT RECORD\nLOGRECIN DS    0CL133\nLOGRECCC DC    C' '\nLOGRECD  DC    CL132' '\n         EJECT\n***********************************************************************\n*    CONTROL BLOCKS FOR DYNAMIC ALLOCATION\n***********************************************************************\nDYNRBPTR DC    A(DYNRB+X'80000000') PTR TO REQUEST BLOCK\n         SPACE\nDYNRB    DS    0F                  REQUEST BLOCK\n         DC    AL1(20),AL1(S99VRBAL),AL2(0) ALLOCATE\nDYNERR   DC    AL2(0),AL2(0)       ERROR & INFO CODES\n         DC    A(DYNTUPL),A(0)     PTR TO TEXT POINTERS\n         DC    A(0)\nDYNTUPL  DC    A(DSNTEXT)\n         DC    A(MEMBTEXT)\n         DC    A(DDNTEXT)\n         DC    A(STATTEXT+X'80000000')\n         DS    0F\nDSNTEXT  DC    AL2(DALDSNAM),AL2(1)\nDSNLEN   DC    H'0'                LENGTH OF DATASET NAME\nDSN      DC    CL44' '             DATASET NAME\n         DS    0F\nMEMBTEXT DC    AL2(DALMEMBR),AL2(1)\nMEMBLEN  DC    H'0'                LENGTH OF MEMBER NAME\nMEMBER   DC    CL8' '              MEMBER NAME\n         DS    0F\nDDNTEXT  DC    AL2(DALDDNAM),AL2(1),AL2(5),C'LOGIN'\n         DS    0F\nSTATTEXT DC    AL2(DALSTATS),AL2(1),AL2(1),X'08'\nDEARBPTR DC    A(DEARB+X'80000000') PTR TO REQUEST BLOCK\n         SPACE\nDEARB    DS    0F                  REQUEST BLOCK\n         DC    AL1(20),AL1(S99VRBUN),AL2(0) ALLOCATE\nDEAERR   DC    AL2(0),AL2(0)       ERROR & INFO CODES\n         DC    A(DEATUPL),A(0)     PTR TO TEXT POINTERS\n         DC    A(0)\nDEATUPL  DC    A(DEATEXT+X'80000000')\n         DS    0F\nDEATEXT  DC    AL2(DUNDDNAM),AL2(1),H'5',C'LOGIN'\n         DS    0F\n         EJECT\nMSGCSECT CSECT\nMSG00    DC    CL133'-**** NO KEYWORD FOUND'\nMSG01    DC    CL133'-**** UNKNOWN KEYWORD'\nMSG02    DC    CL133'-**** END OF FILE RECEIVED DURING CONTINUATION OF X\n               A PARAMETER CARD'\nMSG03    DC    CL133'-**** THIS KEYWORD REQUIRES AN OPERAND BUT ONE WASX\n                NOT SUPPLIED'\nMSG04    DC    CL133'-**** INVALID OPERAND'\nMSG05    DC    CL133'-**** DATERANGE MUST BE PREVIOUSLY SPECIFIED'\nMSG06    DC    CL133'-**** THIS OPTION HAS BEEN PREVIOUSLY SPECIFIED'\nMSG07    DC    CL133'-**** INVALID CONTINUATION'\nMSG08    DC    CL133'-**** DATE2 NOT LATER THAN DATE1'\nMSG09    DC    CL133'-**** MAXIMUM NUMBER OF JOB NAMES EXCEEDED'\nMSG10    DC    CL133'-**** NO DATA ON CONTINUATION CARD'\n         EJECT\nKYWDSECT DSECT\n@ADDR    DS    F\n@LEN     DS    H\n@KYWD    DS    CL10\n@KLEN    EQU   *-KYWDSECT\n         SPACE 2\nDATDSECT DSECT\n@DOFF    DS    H\n@DLEN    DS    H\n@DATA    DS    CL20\n@DENTLEN EQU   *-DATDSECT\n         SPACE 2\nJOBDSECT DSECT\n@JLEN    DS    F\n@JNAME   DS    CL8\n@JENTLEN EQU   *-JOBDSECT\n         SPACE 2\n         PRINT GEN\n         IHAHCLOG\n         PRINT NOGEN\n         IEFZB4D0\n         IEFZB4D2\n         IHAPDS PDSBLDL=NO\n        END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SP1VO00": {"ttr": 1541, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")BODY\n%-----------------  VTAM SECONDARY OPERATOR FACILITY  --------------------------\n%COMMAND ===>_ZCMD                                                             +\n%\n+   SCREEN ROLL%===>_SPR+  (YES or NO)      WAIT%==>_S +Seconds                %\n+-------------------------------------------------------------------------------\n+&SP1VO1                                                                       +\n+&SP1VO2                                                                       +\n+&SP1VO3                                                                       +\n+&SP1VO4                                                                       +\n+&SP1VO5                                                                       +\n+&SP1VO6                                                                       +\n+&SP1VO7                                                                       +\n+&SP1VO8                                                                       +\n+&SP1VO9                                                                       +\n+&SP1VO10                                                                      +\n+&SP1VO11                                                                      +\n+&SP1VO12                                                                      +\n+&SP1VO13                                                                      +\n+&SP1VO14                                                                      +\n+&SP1VO15                                                                      +\n+&SP1VO16                                                                      +\n+&SP1VO17                                                                      +\n+&SP1VO18                                                                      +\n+&SP1VO19                                                                      +\n)INIT\n  .HELP = SP1VO00A\n  &ZCMD = &SP1VOCMD\n  &S = &SP1VOWT\n  .CURSOR = ZCMD\n)PROC\n  VER (&SPR,NB,LIST,YES,NO)             /* VERIFY SPR IS CORRECT      */\n  VER (&S,NB,NUM)                       /* VERIFY WAIT IS CORRECT     */\n  &SP1VOWT = &S                         /* SET FOR FUNCTION POOL      */\n  &SP1VOCMD = &ZCMD                     /* SET FOR FUNCTION POOL      */\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SP1VO00A": {"ttr": 1543, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "%TUTORIAL---------  VTAM SECONDARY OPERATOR FACILITY  ------------------TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n+\nThe VTAM secondary operator facility allows you to enter VTAM commands and\nreceive the generated messages.  The VTAM command is entered on the command\nline.  There are short forms of several VTAM commands:\n%   D node    means  D NET,E,ID=node\n    A node    means  V NET,ACT,ID= node\n    I node    means  V NET,INACT,I,ID=node\n    R node    means  V NET,INACT,R,ID=node\n    F node    means  V NET,INACT,F,ID=node\n    T node    means  F NET,TRACE,F,ID=node,TYPE=IO\n    T node,x  means  F NET,TRACE,F,ID=node,TYPE=t   (x=B: t=BUF, x=L: t=LINE)\n    N node    means  F NET,NOTRACE,F,ID=node   +\nSetting the%SCREEN ROLL+parameter to 'NO' allows commands to be entered without\nthe display portion of the screen changing.  The%WAIT+parameter controls how\nlong the program waits after issueing a command before trying to display the\nresults.  This allows VTAM time to process the command.  All output from\ncommands must be processed before you can exit from this panel.  To display the\nnext screen of messages simply press the enter key without entering a command.\nIf the last command issued was a display command and there is no output waiting\nthen the display command will be reissued.  To see the command that was sent to\nVTAM enter a \"?\".  Using a node of \"*\" will operate on the last node enterd.\n)PROC\n   &ZUP = ISR00003\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SP10": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SP100A       '&SYSUID NOT AUTHORIZED'\n'&SYSUID IS NOT ALLOWED TO PERFORM THE REQUESTED FUNCTION'\n\nSP100B       '&SPSERV FAILED, RC=&RCODE'\n'ISPF SERVICE &SPSERV FAILED, THE RETURN CODE WAS &RCODE'\n\nSP100C       'MORE...'\n'THERE IS MORE OUTPUT AVAILABLE'\n\nSP100D       'MORE...'\n'SHUTDOWN IS NOT ALLOWED UNTIL ALL MESSAGES ARE PROCESSED'\n\nSP100E       'ENTER VTAM COMMAND ... '\n'A VTAM COMMAND CAN BE ENTERED ON THE COMMAND FIELD'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSENTER": {"ttr": 1547, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    SYSENTER &B1,&B2,&B3,&B4,&CSECT=YES,&SYMREG=NO,&RENT=NO,&XTRA=\n.*\n.*   THE SYSENTER MACRO IS USED TO ENTER PROGRAMS USING STANDARD\n.*   LINKAGE CONVENTIONS.  UP TO FOUR BASE REGISTERS MAY BE\n.*   SPECIFIED AND THESE ARE POSITIONAL OPERANDS.  THE REMAINING\n.*   OPERANDS ARE KEYWORDS.  SPECIFYING RENT=YES WILL CAUSE A\n.*   GETMAIN TO BE ISSUED FOR THE SAVE AREA.  SPECIFYING XTRA=NNN\n.*   WILL GETMAIN NNN EXTRA BYTES FOR A WORKAREA.  SPECIFYING CSECT=NO\n.*   WILL CAUSE A 'DS 0H' TO BE GENERATED IN LIEU OF A CSECT.\n.*   SPECIFYING SYMREG=YES WILL CAUSE EQUATES TO BE GENERATED\n.*   FOR THE GENERAL PURPOSE REGISTERS.\n.*\n         LCLC  &N                  CSECT NAME\n         LCLC  &B                  BASE\n         GBLC  &SAVMOD,&SAVXTRA    SAVE MODE AND EXTRA GETMAIN\n&SAVMOD  SETC  'REUS'\n&N       SETC  'CSCT&SYSNDX'\n&B       SETC  '13'\n         AIF   ('&NAME' EQ '').S010\n&N       SETC  '&NAME'\n.S010    ANOP\n         AIF   ('&B1' EQ '').S015\n         AIF   ('&B1' EQ '13').S015\n         AIF   ('&B1' EQ 'R13').S015\n&B       SETC  '&B1'\n         AGO   .S020\n.S015    ANOP\n         AIF   ('&RENT' EQ 'NO').S020\n         MNOTE 8,'R13 NOT ALLOWED AS BASE FOR REENTERANT CODE'\n         MEXIT\n.S020    ANOP\n         SPACE 1\n         AIF   ('&CSECT' EQ 'YES').S030\n&N       DS    0H\n         AGO   .S040\n.S030    ANOP\n&N       CSECT\n.S040    ANOP\n         SPACE 1\n         USING &N,15\n         SPACE 1\n         B     STM&SYSNDX          BRANCH AROUND ID/SAVE AREA\n         SPACE 1\n         DC    AL1(24)             >>> ID AREA <<<\n         DC    CL8'&N'\n         DC    CL1' '\n         DC    CL8'&SYSDATE'           DATE\n         DC    CL1' '\n         DC    CL6'&SYSTIME'           TIME\n         DC    3XL1'FF'\n         SPACE 1\n         AIF   ('&RENT' EQ 'NO').S060\n&SAVMOD  SETC  'RENT'\nCONH4096 DC    H'4096'\n         SPACE 1\nSTM&SYSNDX  STM   14,12,12(13)\n         LR    &B,15\n         DROP  15\n         USING &N,&B\n         AIF   ('&XTRA' EQ '').S043\n         GETMAIN R,LV=72+&XTRA\n&SAVXTRA SETC  '&XTRA'\n         AGO   .S046\n.S043    ANOP\n         GETMAIN R,LV=72\n.S046    ANOP\n         LR    15,1                R15<--A(NEW SAVE AREA)\n         L     1,24(13)            RESTORE PARMS\n         ST    13,4(15)            CHAIN FORWARD\n         ST    15,8(13)            CHAIN BACKWARD\n         LR    13,15               SET NEW SAVE AREA\n         AIF   ('&B2' EQ '').S050\n         LR    &B2,&B\n         AH    &B2,CONH4096\n         AIF   ('&B3' EQ '').S050\n         LR    &B3,&B2\n         AH    &B3,CONH4096\n         AIF   ('&B4' EQ '').S050\n         LR    &B4,&B3\n         AH    &B4,CONH4096\n.S050    ANOP\n         DROP  &B\n         AIF   ('&B4' EQ '').S051\n         USING &N,&B,&B2,&B3,&B4\n         AGO   .S09X\n.S051    ANOP\n         AIF   ('&B3' EQ '').S052\n         USING &N,&B,&B2,&B3\n         AGO   .S09X\n.S052    ANOP\n         AIF   ('&B2' EQ '').S053\n         USING &N,&B,&B2\n         AGO   .S09X\n.S053    ANOP\n         USING &N,&B\n         AGO   .S09X\n.S060    ANOP\nSAVE&SYSNDX DC    18F'0'           >>> SAVE AREA <<<\nBASE&SYSNDX DC    A(SAVE&SYSNDX)\n         AIF   ('&B2' EQ '').S065\n         DC    A(SAVE&SYSNDX+1*4096)\n         AIF   ('&B3' EQ '').S065\n         DC    A(SAVE&SYSNDX+2*4096)\n         AIF   ('&B4' EQ '').S065\n         DC    A(SAVE&SYSNDX+3*4096)\n.S065    ANOP\n         SPACE 1\nSTM&SYSNDX  STM   14,12,12(13)     >>> SAVE AND CHAIN <<<\n         LR    1,13                SAVE PREV SAVE AREA\n         LA    13,SAVE&SYSNDX      GET NEW SAVE AREA\n         ST    13,8(1)             CHAIN FORWARD\n         ST    1,4(13)             CHAIN BACKWARD\n         L     1,24(1)             RESTORE PARM\n         AIF   ('&B' EQ '13').S070\n         AIF   ('&B' EQ 'R13').S070\n         L     &B,BASE&SYSNDX\n.S070    ANOP\n         AIF   ('&B2' EQ '').S080\n         L     &B2,BASE&SYSNDX+4\n         AIF   ('&B3' EQ '').S080\n         L     &B3,BASE&SYSNDX+8\n         AIF   ('&B4' EQ '').S080\n         L     &B4,BASE&SYSNDX+12\n.S080    ANOP\n         SPACE 1\n         DROP  15\n         AIF   ('&B4' EQ '').S090\n         USING SAVE&SYSNDX,&B,&B2,&B3,&B4\n         AGO   .S09X\n.S090    ANOP\n         AIF   ('&B3' EQ '').S09A\n         USING SAVE&SYSNDX,&B,&B2,&B3\n         AGO   .S09X\n.S09A    ANOP\n         AIF   ('&B2' EQ '').S09B\n         USING SAVE&SYSNDX,&B,&B2\n         AGO   .S09X\n.S09B    ANOP\n         USING SAVE&SYSNDX,&B\n.S09X    ANOP\n         SPACE 1\n         AIF   ('&SYMREG' EQ 'NO').S100\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\n.S100    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSRETRN": {"ttr": 1551, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    SYSRETRN &RC=0\n.*\n.*   THIS MACRO IS USED TO EXIT FROM PROGRAMS WHICH USED THE\n.*   SYSENTER MACRO FOR INITIALIZATION.  THE DEFAULT RETURN CODE IS\n.*   ZERO AND MAY BE CHANGED BY SPECIFYING THE RC OPERAND OF THIS\n.*   MACRO.  A VALUE MAY BE PASSED BY SPECIFYING RC=NN, OR THE\n.*   RETURN CODE MAY BE PASSED IN A REGISTER - RC=(R2).  IF THE\n.*   RETURN CODE WAS PREVIOUSLY SET IN R15 THEN CODE RC=(15) OR\n.*   RC=(R15).  THE USE OF R15 TO CONTAIN THE RETURN CODE WILL SAVE\n.*   FOUR BYTES OF MACRO EXPANSION.  IF THE SYSENTER MACRO SPECIFIED\n.*   REENTRABILITY THEN SYSRETRN WILL DO A FREEMAIN ON THE SAVE\n.*   AREA.  THIS STATUS (REENTRABLE) WAS SAVED IN THE '&SAVMOD'\n.*   GLOBAL SYMBOL.  IF EXTRA MEMORY WAS OBTAINED THROUGH SYSENTER\n.*   THEN THE AMOUNT OF EXTRA STORAGE WILL BE PASSED IN THE\n.*   '&SAVXTRA' GLOBAL SYSMBOL.  MULTIPLE USES OF THE SYSENTER MACRO\n.*   WITH MIXED MODES (I.E. RENT AND REUS) IN A SINGLE ASSEMBLY MAY\n.*   RESULT IN EXECUTION ERRORS BECAUSE OF THE '&SAVMOD' GLOBAL.\n.*\n         GBLC  &SAVMOD,&SAVXTRA\n&NAME    DS    0H\n         AIF   ('&SAVMOD' NE 'RENT').R050\n         AIF   ('&RC'(1,1) NE '(').R010\n         LA    2,0&RC              SAVE RC ACROSS FREEMAIN\n.R010    ANOP\n         LR    1,13                GET ADDR FOR FREEMAIN\n         L     13,4(13)            GET PREV SAVE AREA\n         AIF   ('&SAVXTRA' EQ '').R013\n         FREEMAIN R,LV=72+&SAVXTRA,A=(1)\n         AGO   .R016\n.R013    ANOP\n         FREEMAIN R,LV=72,A=(1)\n.R016    ANOP\n         XC    8(4,13),8(13)       CLEAR NEXT SA PTR\n         AIF   ('&RC'(1,1) NE '(').R020\n         LR    15,2                RESTORE RETURN CODE\n         AGO   .R040\n.R020    ANOP\n         AIF   ('&RC' LT '4096').R030\n         MNOTE 1,'RETURN CODE &RC IS > 4095, RC IGNORED'\n         AGO   .R040\n.R030    ANOP\n         LA    15,&RC\n.R040    ANOP\n         L     14,12(,13)          RESTORE RETURN ADDRESS\n         LM    0,12,20(13)         RESTORE REGISTERS\n         MVI   12(13),X'FF'        SET RETURN INDICATOR\n         BR    14                  RETURN TO CALLER\n         MEXIT\n.R050    ANOP\n         L     13,4(13)            GET PREV SAVE AREA\n         AIF   ('&RC'(1,1) NE '(').R060\n         AIF   ('&RC' EQ '(15)').R040\n         AIF   ('&RC' EQ '(R15)').R040\n         LA    15,0&RC             SET RETURN CODE\n         AGO   .R040\n.R060    ANOP\n         AIF   ('&RC' LT '4096').R070\n         MNOTE 1,'RETURN CODE &RC IS > 4095, RC IGNORED'\n         AGO   .R040\n.R070    ANOP\n         LA    15,&RC              SET RETURN CODE\n         AGO   .R040\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UT017DOC": {"ttr": 1553, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n0\n-\n-\n-\n-\n-\n-                                  \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n                                   |                    |\n                                   |  SP1UT017          |\n                                   |                    |\n                                   |                    |\n                                   |   SYSLOG           |\n                                   |                    |\n                                   |                    |\n                                   |    SCAN            |\n                                   |                    |\n                                   |                    |\n                                   |  PROGRAM           |\n                                   |                    |\n                                   \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0          Table of Contents\n+          _____ __ ________\n-\n      JCL Requirements  . . . . . . . . . . . . . . . . . . . . . . . . . .  2\n0     Message Dependencies  . . . . . . . . . . . . . . . . . . . . . . . .  3\n0     Parameter Card Summary  . . . . . . . . . . . . . . . . . . . . . . .  4\n0     Parameter Card Descriptions . . . . . . . . . . . . . . . . . . . . .  5\n        The DATERANGE Card  . . . . . . . . . . . . . . . . . . . . . . . .  5\n        The TIMERANGE Card  . . . . . . . . . . . . . . . . . . . . . . . .  6\n        The JOBS Card . . . . . . . . . . . . . . . . . . . . . . . . . . .  7\n        The JOBNUMBER Card  . . . . . . . . . . . . . . . . . . . . . . . .  7\n        The ABEND Card  . . . . . . . . . . . . . . . . . . . . . . . . . .  8\n        The MESSAGE Card  . . . . . . . . . . . . . . . . . . . . . . . . .  8\n        The DATA Card . . . . . . . . . . . . . . . . . . . . . . . . . . .  9\n        EXAMPLE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0     JCL Requirements\n+     ___ ____________\n-\n         SP1UT017 is a syslog  scan program that can be used  to pull specific\n      records off of a syslog history file. This program has been tested using\n      MVS/XA 2.1.7.  Keywords may be given in a SYSIN input stream to restrict\n      the  amount of  output data  to only  the items  desired.   The  program\n      SP1UT017 resides  in SYS1.SYS.LINKLIB and  the JCL  to execute it  is as\n      follows:\n0          //STEP010 EXEC PGM=SP1UT017\n           //SYSPRINT DD  SYSOUT=*\n           //SYSUDUMP DD  SYSOUT=*\n           //LOGIN    DD  DSN=sequential dataset name,DISP=SHR\n                  -->or<--\n           //PDSIN    DD  DSN=partitioned dataset name,DISP=SHR\n           //SYSIN    DD  *\n            input parameter cards\n0     INPUT:  LOGIN    - This is  the syslog history  file in  sequential form\n                         (e.g.  a  member of SYS2.SYSLOG.DATA).   If  LOGIN is\n                         coded then do not use the PDSIN DD name.\n0             PDSIN    - This  is the  syslog history  file  as a  partitioned\n                         dataset.   In  this form all  members in  the dataset\n                         will be scanned in the PDS directory order.  Separate\n                         starting  and ending  dates will  be  shown for  each\n                         member.   The LOGIN DD name  cannot be coded if PDSIN\n                         is coded or an error will occur.\n0             SYSIN    - This  is the  input stream  containing the  parameter\n                         cards  used to  determine which  history records  are\n                         printed.\n0     OUTPUT: SYSPRINT - This  is the  only output  file.    It contains  both\n                         program messages and any  syslog history records that\n                         were to be printed.\n-\n-\n-\n-                                      - 2 -\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0                        Message Dependencies\n+                        _______ ____________\n-\n                            There are some specific messages looked at by this\n                         program depending on the  options specefied.   Future\n                         releases  of  JES  or MVS  may  require  source  code\n                         modifications to this program if the number or format\n                         of these messages is changed:\n0          $HASP100 (Job on reader)\n           $HASP250 (Job purged)\n           $HASP373 (Job started)\n           $HASP395 (Job ended)\n           IEF450I (Job abended)\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n0                                      - 3 -\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0     Parameter Card Summary\n+     _________ ____ _______\n-\n        DATERANGE(yy.ddd) or (yy.ddd,yy.ddd)\n        DT(yy.ddd) or (yy.ddd,yy.ddd)\n0       TIMERANGE(hh:mm) or (hh:mm,hh:mm)\n        TM(hh.mm) or (hh:mm,hh:mm)\n0       JOBS\n0       JOBS(jobname, ... )        Maximum 50 Jobnames\n        JOB(jobname, ... )\n        J(jobname, ... )\n0       MESSAGE(msgid, ... )       Maximum 50 Message ID's\n        MSG(msgid, ... )\n0       JOBNUMBER(nnnn, ... )      Maximum 50 Job Numbers\n        JN(nnnn, ... )\n0       DATA(nnn,string)           nnn = Offset\n        D(nnn,string)                  string = Char String <= 20 BYTES\n0       ABEND\n0       ABEND(ttt,xxxxx, ... )     Maximum 50 Abend ID's\n        ABEND(ttt)                 ttt = STC, TSO or JOB\n        ABEND(xxxxx, ... )         xxxxx = Snnn of Unnnn\n        A(ttt,xxxxx, ... )\n-\n-\n-\n-\n-\n-\n                                       - 4 -\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0     Parameter Card Descriptions\n+     _________ ____ ____________\n-\n         Parameter  cards are  used to  specify  the search  criteria for  the\n      syslog scan  program.   If no parameter  cards are present then  all log\n      records will be printed.   The DATERANGE and TIMERANGE cards can be used\n      to limit  the records that  will be searched.    Only one each  of these\n      cards can be  specified for any single execution of  this program.   All\n      other parameter  cards are  processed as \"OR\"  conditions (i.e.   if any\n      single request  is satisfied  then the  record is  printed).   The  only\n      parameter card  that can be  specified more than  once is the  DATA card\n      which  can be  specified  up  to ten  times.    A  continuation card  is\n      specified  by following  a comma  with  a space.    The first  non-blank\n      character on  the next card  is used as  the beginning of  the continued\n      data.  A description of each of the parameter cards follows:\n-\n      The DATERANGE Card\n+     ___ _________ ____\n-          FORMAT1: DATERANGE(YY.DDD)\n           FORMAT2: DATERANGE(YY.DDD,YY.DDD)\n0          ABBREVIATIONS: DT\n0          DEFAULT: All dates will be processed\n0          NOTES: If  FORMAT1  is  used  processing  will  be  from  the  date\n                  specified to the  end of the log unless a  TIMERANGE card is\n                  also used.  Using FORMAT1 with a TIMERANGE card will process\n                  only the times specified on  the single day given.   FORMAT2\n                  gives the beginning and ending dates,  which can be the same\n                  day.   The  program will  normally print  the beginning  and\n                  ending dates  of the log tape.    If the ending  date and/or\n                  time is  specified the  ending date  printed by  the program\n                  will be  this date and  not that of  the last record  on the\n                  log.\n-\n-\n-\n0                                      - 5 -\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0     The TIMERANGE Card\n+     ___ _________ ____\n-          FORMAT1: TIMERANGE(HH:MM)\n           FORMAT2: TIMERANGE(HH:MM,HH:MM)\n0          ABBREVIATIONS: TM\n0          DEFAULTS: 00:00 for the starting time, 24:00 for the ending time\n0          NOTES: To  use TIMERANGE  a  DATERANGE  must have  been  previously\n                  specified.    If  FORMAT1  is used  then  it  specifies  the\n                  beginning  time.    If  FORMAT2  is  used  with  FORMAT1  of\n                  DATERANGE  then  the  times  given   are  for  the  one  day\n                  specified.   Otherwise the starting  time is associated with\n                  the starting date and the ending time is associated with the\n                  ending date from the DATERANGE card.\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-                                      - 6 -\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0     The JOBS Card\n+     ___ ____ ____\n-          FORMAT1: JOBS\n           FORMAT2: JOBS(xxxxxxxx, ... )\n0          ABBREVIATIONS: JOB, J\n0          DEFAULTS: All job messages will be printed.\n0          NOTES: If JOBS is specified without any operands (FORMAT1) then all\n                  messages with  a JES  job number  tagged onto  them will  be\n                  printed.  xxxxxxxx specifies a full or partial job name.  Up\n                  to 50  job names are allowed.    The comparison is  made for\n                  only the length of the given string so if a partial job name\n                  is  given  then any  jobs  beginning  with that  prefix  are\n                  printed.  When a a $HASP100 (JOB ON READER) or $HASP373 (JOB\n                  STARTED)  message is found the  job name is compared against\n                  the name(s)  specified.    If a match is found  then the job\n                  number is placed  in the job number  table.   The processing\n                  continues as if  the specific job number was  specified on a\n                  JOBNUMBER card  until a $HASP250  (JOB PURGED)   or $HASP395\n                  (JOB ENDED)   message is  encountered.   When  one of  these\n                  messages is  detected the  job name  will again  be compared\n                  against the name(s) specified.  If a match is found then the\n                  job number is removed from the  job number table.   There is\n                  room  for 100  entries  in the  job  number  table.   If  an\n                  overflow occurs then data may be lost.\n-\n      The JOBNUMBER Card\n+     ___ _________ ____\n-          FORMAT: JOBNUMBER(nnnn, ... )\n0          ABBREVIATIONS: JN\n0          DEFAULTS: NONE\n0          NOTES: nnnn gives  the JES  job (STC  or TSO  user)  number.    Any\n                  messages for  a job,   started task,  or  TSO user  that are\n                  tagged with that JES job number  will be printed.   Up to 50\n                  job numbers may be entered.   There  are an extra 50 entries\n                  in the job  number table  for job numbers  generated by JOBS\n                  card requests.\n-\n                                       - 7 -\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0     The ABEND Card\n+     ___ _____ ____\n-          FORMAT1: ABEND\n           FORMAT2: ABEND(xxxxx, ... )\n           FORMAT3: ABEND(ttt,xxxxx, ... )\n0          ABBREVIATIONS: A\n0          DEFAULTS: Print all ABEND messages.\n0          NOTES: If FORMAT1 is used then all abends (Message IEF450I) will be\n                  printed.   If FORMAT2 is used then xxxxx specifies the abend\n                  ID (Snnn for system abends or  Unnnn for user abends).   The\n                  system and user abend ID fields  in the message IEF450I will\n                  be compared  with the specified  abend IDs and  only matches\n                  will be printed.   The format of the abend code given in the\n                  control card  must match the  format in the  IEF450I message\n                  (i.e.   \"SD37\" or  \"U0013\").   Up  to  50 abend  IDs may  be\n                  specified.  FORMAT3 allofs restricting the abends printed to\n                  STC (started task), TSO or JOB records.  Specific abend ID's\n                  may be used with FORMAT3 but they are not required.\n-\n      The MESSAGE Card\n+     ___ _______ ____\n-          FORMAT: MESSAGE(xxxxxxxx, ... )\n0          ABBREVIATIONS: MSG\n0          DEFAULTS: NONE\n0          NOTES: Up to 50 full or partial message IDs may be specified.   All\n                  matching messages in the log will be printed.\n-\n-\n-\n-\n0                                      - 8 -\n1\n0     SP1UT017                  Syslog Scan Utility                   SP1UT017\n0     The DATA Card\n+     ___ ____ ____\n-          FORMAT: DATA(nnn,xxxxxxxx)\n0          ABBREVIATIONS: D\n0          DEFAULTS: NONE\n0          NOTES: nnn specifies the  1-based offset from the  beginning of the\n                  date.  xxxxxxxx is the string that will be compared with the\n                  data at  offset nnn in each  message.   All matches  will be\n                  printed.  Up to 10 DATA cards may be specified.   The offset\n                  to the time field is 7, JES job identifier field is 19,  and\n                  message number field is 38.\n-     EXAMPLE\n+     _______\n-\n         To print all  the VTAM messages between 8  am and 5 pm on  day 247 of\n      1985 you would enter:\n0          //STEP010 EXEC PGM=SP1UT017\n           //SYSPRINT DD  SYSOUT=*\n           //SYSUDUMP DD  SYSOUT=*\n           //PDSIN    dd  DSN=SYS2.SYSLOG.DATA,DISP=SHR\n           //SYSIN    DD  *\n            DATERANGE(85.247)\n            TIMERANGE(08:00,17:00)\n            MESSAGE(IST)\n-\n-\n-\n-\n-\n-                                      - 9 -\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT128/FILE128.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT128", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}