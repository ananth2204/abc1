{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013617000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE966.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE966.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x07'", "DS1TRBAL": "b'{\\xea'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\x0c\\x00\\r\\n\\r\\x00\\x05\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00\\x07\\x01\\x190\\x7f\\x01\\x190\\x7f\\x17&\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T17:26:07", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  966\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE966\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 12 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,175 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/03/19    17:26:07    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x01\\xa0\\x01\\xa0\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 416, "newlines": 416, "modlines": 0, "user": "V2L4"}, "text": "Member   Purpose\n$DOC     This member\nHLASM    Help member for SYS1.HELP\nINSTALL  Install HLASM to a \"permanent\" library using the object\n         \"deck\" in member OBJECT.  Follow the instructions in the\n         member.\nINSTALLA Install HLASM to a permanent library by assembling and\n         linking the source module in the SOURCE member.  Follow the\n         instructions in the member.\nINSTALLB Inatall HLASM to a permanent library entirely in batch by\n         assembling the source module in the SOURCE member and\n         linking the object preoduced by the assembly.  Except\n         for date and time information assembled into the object\n         this object is byte to byte identical to the object in\n         the OBJECT member.\nLINCLUDE Binder control statements used with the INSTALLA job.\nOBJECT   The object \"deck\" of the HLASM program.\nODT      User document in Open Document format.  This member\n         requires additional processing to prepare it for use on a\n         work station.  See the discussion later in this member.\nSOURCE   The source code of the program.\nUSING    A brief discussion about using the HLASM command.\n\nThe HLASM program is a TSO command processor to run the High\nLevel Assembler in a TSO session.\n\nThis HLASM command is a complete, but incompatible, replacement\nof the HLASM command in the CBTTAPE \"file\" 300 collection.  It\nuses the IKJPARS TSO service to examine the contents of the\ncommand line, uses MVS dynamic allocation to allocate all the\ndata sets required for the assembly, and uses the TSO PUTLINE\nservice to communicate with the terminal operator or the SYSTSPRT\nDD statement if run in TSO in batch.  It will run directly from\nthe TSO READY prompt; it does not require a CLIST or Rexx exec to\npre allocate the data sets required for the assembly unless the\nLIBDD or LIBFILE parameters are used to specify a preallocated DD\nstatement (FILE in TSO usage).\n\nThe command syntax is\n\nHLASM  data set  NOADATA/ADATA(data set)  NOALIGN/ALIGN  NOASMAOPTS/\n       ASMAOPT(data set)  NOBATCH/BATCH  NODBCS/DBCS  NODXREF/\n       DXREF  NOESD/ESD  NOFOLD/FOLD  NOGOFF/GOFF(NOADATA.ADATA)\n       NOLIBMAC/LIBMAC  NOLIST/LIST(121/133)\n       NOMXREF/MXREF(FULL/ SOURCE/XREF)  NOOBJECT/OBJECT(data set)\n       NOPRINT/PRINT(data set)  NORC/RC  NORLD/RLD  NORXREF/RXREF\n       NOTERM/TERM(data set)  NOTEST/TEST  NOTHREAD/THREAD  VERSION\n       NOXOBJ/XOBJ(NOADATA/ADATA)  NOXREF/XREF(FULL/SHORT UNREFS)\n       LIB(data set ... data set)/LIBDD(dd name)/LIBFILE(dd name)\n Required - data set\n Default - OBJECT TERM(*) LIB('SYS1.MODGEN' 'SYS1.MACLIB') PRINT TEST\n           If the source data set is not fully qualified, the full\n           data set name is formed by using the data set prefix\n           appended to the start of the name and .ASM appended to\n           the data set name.\n\n           If the TERM data set name is not specified, and the\n           source data data set name is not fully qualified, HLASM\n           forms the data set name as prefix.dsn.TERMLIST.\n\n           If the OBJECT data set name is not specified, and the\n           source data data set name is not fully qualified, HLASM\n           forms the dasta set name as prefix.dsn.OBJ.\n\n           If the PRINT data set name is not specified, and the\n           source data data set name is not fully qualified, HLASM\n           forms the data set name as prefix.dsn.ASMLIST.\n\n           If the ADATA data set name is not specified, and the\n           source data data set name is not fully qualified, HLASM\n           forms name as prefix.dsn.ADATA.\n\n           If the source data set is fully qualified or it is\n           specified with a member, the command will prompt the\n           terminal operator for the remainder of the data sets.\n\n           HLASM will allocate the OBJ, TERMLIST, ASMLIST and ADATA\n           data sets if they are not already allocated.\n\n           If TSO \"file\" ASMAOPTS is allocated and no ASMAOPTS\n           data set is specified in the command line, the High\n           Level Assembler will use the TSO \"file.\"\n\nMessages -\n\nThe High Level Assembler will issue a number of messages if the\ncommand line specifies TERM(*).  In addition, the IKJPARS TSO service\nwill display messages as required.  These messages are not documented\nhere.\n\nHLA001I RUNNING HIGH LEVEL ASSEMBLER\n\nReason: HLASM has completed preparing the environment for the High\nLevel Assembler.\nAction: HLASM runs the High Level Assembler.\nProgrammer Response: None required.\n\nHLA002I ASM90 RC = nn\n\nReason: The High Level Assembler completed with return code nn.\nAction: HLASM releases the data sets it allocated to run the High Level\nAssembler and terminates.\nProgrammer Response: Examine the TERMLIST data set if was directed to a\ndata set if the return code is not 0, correct any errors, and rerun\nHLASM.\n\nHLA003I HLASM V2L3 12/01/17 07.25\n\nReason: The VERSION option was specified in the HLASM command line.\nHLASM displays the version and the date and time the source data set\nwas assembled.\nAction: HLASM completes preparing the environment to run the High\nLevel Assembler and runs it.\nProgrammer Response: None reqired.\n\nHLA004E dsname IS TOO LONG TO ADD STANDARD QUALIFIERS\n\nReason: HLASM determined the data set name specified as an \"ordinary\"\n  data set rather than a fully qualified data set name is too long to\n  apply standard data set qualifiers.\nAction: HLASM directs the IKJPARS service routine to prompt the\n  TSO terminal operator to enter a more appropriate data set name.\n  If the TSO terminal operator is unable tp enter a proper data set\n  name, the command terminates.\nProgrammer response: See the discussion in the action paragraph.\n\nHLA005E mmm IS NOT IN ddd\n\nReason: HLASM determined that member mmm is not in data set ddd.\n  This message may appear if data set ddd is not a Partitioned\n  data set.\nAction: If ddd is the data set specified for the source statement\n  data set, HLASM may prompt the terminal operator to reenter\n  the data set.  If ddd is the data set specified for High Level\n  Assembler options data set, HLASM terminates.\nProgrammer response: If HLASM prompts you to reenter the source\n  data set, reenter the source data set.  Otherwise, reenter\n  the entire HLASM command.\n\nHLA006E TOO MANY DATA SETS SPECIFIED IN THE LIB PARAMETER\n\nReason: HLASM determined the LIB parameter in the command line\n  specified more than 22 data sets.  The maximum number of data sets\n  HLASM can concatenate is 22.\nAction: HLASM frees the data sets it allocated and terminates.\n  If HLASM was entered from a CLIST or Rexx exec, it is terminsted.\nProgrammer response: Specify fewer libraries in the LIB parameter.\n  If this is not possible run the assembly in batch.\n\nHLA007A UNABLE TO USE dddd: THE DATA SET IS NOT SEQUENTIAL OR\nPARTITIONED\n\nReason: HLASM determined that data set dddd is not sequential or\n  partitioned.\nAction: HLASM prompts the terminal operator for a valid data set.\nProgrammer response: Enter a valid data set.\n\nHLA008A UNABLE TO USE dddd: THE DATA SET IS SEQUENTIAL BUT THE COMMAND\nLINE SPECIFIES A MEMBER\n\nReaaon: The command line specifies a data set name in the form\n  dddd(member), but HLASM determined the data set is sequential.\nAction: HLASM prompts the terminal operator for a valid data set.\nProgrammer response: Enter a valid data set.\n\nHLA009A UNABLE TO USE dddd: THE DATA SET IS PARTITIONED BUT THE\n  COMMAND LINE DOES NOT SPECIFY A MEMBER\n\nReason: HLASM determined that the command line specified a partitioned\n  data set, but it did not specify a member name.\nAction: HLASM prompts the terminal operator for a valid data set.\nProgrammer response: Enter a valid data set.\n\nHLA010E UNABLE TO USE dddd: THE DATA SET IS NOT PARTITIONED.\n\nReason: HLASM determined that data set dddd specified in the LIB\n  parameter is not a partitioned data set.\nAction: HLASM termninates.\nProgrammer response: Reenter the HLASM command specifying a\n  partitioned data set for the LIB parameter.\n\nHLA011A LIBRARY DD IS NOT ALLOCATED\n\nReason: HLASM determined the file name specified in the LIBDD or\n  LIBFILE keyword is not allocated to the TSO session.\nAction: HLASM directs IKJPARS to prompt the terminal operator to\n  enter a valid DD name or file name.\nProgrammer response: Enter a valid file name and press your Enter\n  key.\n\n******************* Specified Operating Environment *******************\n\nHLASM requires the same operating environment as the High Level\nAssembler.\n\n**************************** Testing HLASM ****************************\n\nMore testing can be accomplished by various mechanisms from the\nREADY prompt in a TSO session.  For example -\n\n READY\ntest 'xxxxxx.hlasm.cbt.v2l4.pds(object)' object cp\n IEW2278I B352 INVOCATION PARAMETERS -\n          TERM,NOPRINT,NCAL,NOMAP,NORES,LET,NAME=TEMPNAME\n\n IEW2008I 0F03 PROCESSING COMPLETED.  RETURN CODE =  0.\n IKJ57090A ENTER COMMAND FOR CP\nhlasm 'xxxxxx.hlasm.v2l4.cbt.pds(source)'\n TEST\ngo\n IKJ56700A ENTER NAME OF DATA SET TO CONTAIN THE ASSEMBLER LISTING -\ntsthlasm\n IKJ56700A ENTER NAME OF DATA SET TO CONTAIN THE ASSEMBLER OBJECT OUTPUT\ntsthlasm\n HLA001I RUNNING HIGH LEVEL ASSEMBLER\n Assembler Done HLASM No Statements Flagged\n HLA002I ASMA90 RC = 0\n IKJ57023I PROGRAM UNDER TEST HAS TERMINATED NORMALLY+\n TEST\nend\n READY\n\nIn the example, the TSO TEST command used the linking loader to\nload the HLASM command object module from\nxxxxxx.hlasm.cbt.pds(object), where xxxxxx is your userid.  The\nTEST command prompted the terminal operator to enter a command to\nexecute -\n\nhlasm 'xxxxxx.hlasm.cbt.pds(source)'\n\nThe go command directs TEST to run the command it loaded.\n\nThe IKJ56700A ENTER NAME OF DATA SET TO CONTAIN THE ASSEMBLER\nLISTING message was issued by TSO to request the terminal\noperator to enter the data set name of the data set to contain\nthe listing.  HLASM actually creates data set\nXXXXXX.TSTHLASM.ASMLIST.  Then TSO requests a data set to contain\nthe object module from the assembly.\n\nHLASM then runs the High Level Assembler to create data in the\nASMLIST and OBJ data sets.\n\n************************* Load Module Location ************************\n\nFor testing purposes, store the HLASM command in a library that\ncan be used by the TSOLIB facility or an equivalent facility as\nspecified by the INSTALL member.  For a permanent installation,\nstore it in a linklist library.  It can also be stored in LPALIB.\nThe module requires about 8K above the line.\n\n**************************** Link Pack Area ***************************\n\nHLASM is a reasonable candidate for the link pack area.  It is small\n(less than 12K), RMODE ANY and it is reenterable.\n\n************************** Customizing HLASM **************************\n\nSpecialized macro library specifications can be added by altering\nthe IKJPARS statements.  For example, add these statements after\n\nHLLIB    IKJKEYWD ...\n\n         IKJNAME PRODMAC,INSERT='LIB(''production macro library'' ''SYSX\n               1.MODGEN'' ''SYS1.MACLIB'')\n\nand before\n\nHLRC     IKJKEYWD ...\n\nAfter making this change, assemble and reinstall HLASM.\n\nTo use this macro library, run HLASM like normal and add PRODMAC as a\nkeyword:\n\nHLASM program prodmac\n\nTwo examples are present in the source as comment lines.\n\n************************* Preparing ODT Member ************************\n\nThe ODT member contains a user document in Open Document format\nfor use by the Writer component of the Apache OpenOffice or Libre\nOffice products.  I understand the more recent versions of\nMicrosoft Office or Word Perfect can also read these files.\n\nYou must use the contents of the ODT member to prepare a data set\nthat can be sent to a work station.  Execute this command.\n\nRECEIVE INDATASET('thisdataset(ODT)')\n\nThe RECEIVE command will prompt you to enter the data set name of\nthe data set to receive the data.\n\nDataset XXXXXX.HLASM.V2L4.ODT from XXXXXX on NODENAME\nEnter restore parameters or 'DELETE' or 'END' +\n\nEnter the data set name you want as DATASET(xxxx) or just press\nyour Enter key to use the default userid.HLASM.V2L4.ODT.  After\nyou have prepared this data set you can download it to your work\nstation as a binary data set.  Once you have received the data\nset you can open the file with Apache Open Office or Libre Office,\nor with Micosoft Word or WordPerfect if it supports opening data in\nOpen Document format.\n\n*************************** Sequence Numbers ***************************\n\nCorrection material may be sent as source updates in IEBUPDTE format,\nthough not in a form acceptable as a ++SRCUPD to SMP, so DO NOT ALTER\nTHE SEQUENCE NUMBERS.\n\n***************************** CHANGE LOG *******************************\n\n** Changes From V2L0 (the version in CBT \"file\" 966 as of January 2018 *\n\n- When TERM(*) is specified and HLASM is run in TSO in batch, the High\n  Level Assembler messages directed to the data set normally\n  specified by the DD statement with DD name SYSTERM are sent to the\n  TSO data set specified by the DD statement with DD name SYSTSPRT.\n- When TERM(*) specified and HLASM is run by a CLIST or Rexx exec, the\n  High Level Assembler messages directed to the data set normally\n  specified by the DD statement with DD name SYSTERM can be \"trapped\"\n  by the CLIST or Rexx exec.\n- Data sets specified as just a member name are allocated to a data\n  set with data set name prefix.suffix(member), where prefix is the\n  value specified by the PROFILE PREFIX(prefix) TSO command.  This\n  prefix is normally your TSO userid.\n\n** Changes From V2L2 (the version in CBT \"file\" 966 as of March 2018) **\n\n- Interpret data set name entered as only (member) as\n  userid.suffix(member), where suffix depends on the context.\n- Added messages HLA007A, HLA008A, HLA009A, HLA010A and HLA011E.\n- Internal changes to add addressability.\n- Added LIBDD/LIBFILE keywords to the command line.\n- Corrected multiple problems encoountered when entering a member\n  name in the input data set name.\n- Refreshed the user documentation in ODT.\n- Updated member HLASM (the SYS1.HELP member) to support\n  LIBDD/LIBFILE.\n\n***************************** Restrictions ****************************\n\nHLASM allocates new data sets, including the data set specified\nby the OBJECT parameter, to use System Determined BLKSIZE.  The\nactual BLKSIZE, usually 27920 on 3390 or pseudo 3390 devices, is\ntoo large for the OS/VS Linkage Editor (program HEWLKED) which\nIBM has retained for compatibility reasons.  If it is necessary\nto use the object output with HEWLKED, pre allocate the object\ndata set with a BLKSIZE that HEWLKED will accept, such as\nBLKSIZE=3200.  In all other respects the normal object output,\nunless modified by the XOBJ or GOFF parameters, is acceptable to\nHEWLKED.  More information is available in the \"z/OS Program\nManagement User's Guide and Reference,\" \"z/OS Program Management\nAdvanced Facilities\" and \"HLASM V1R6 Programmer's Guide.\"  The\nHLASM in the last manual title refers to the High Level\nAssembler, not the TSO HLASM command in this document.\n\n*************************** Version Summary ***************************\n\nV1L0 - Initial release, no support for fully qualified data set names.\n       Not released to CBT.\nV2L0 - Support for fully quaalifed data set names.  Released to CBT.\nV2L1 - High Level Assembler SYSTERM data \"trapped\" and sent to TSO\n       session via PUTLINE.  Not released to CBT.\nV2L2 - Support for member only data set names.  Released to CBT.\nV2L3 - Improved support for XREF(UNREFS).  This is documented as\n       corrective maintenance, not a feature.  Not released to CBT.\nV2L4 - Corrected error when member specified for the Assembler\n       input data set.  Added LIBDD/LIBFILE to specify preallocated\n       SYSLIB data sets.  No futher enhancements expected.\n\nAdditional details are in the change log in the source.\n\n***************  No further feature changes are expected ***************\n\nWhile there is no influence from the ASMAHL command used by the\nz/VM version of the High Level Assembler, the generic goal is\nsimilar.  The LINECOU option provided by ASMAHL is provided by\nHLASM as a standard keyword abbreviation provided by TSO, not as\na separate option.\n\n******************************* Support *******************************\n\nContact the author at mvsprog@yahoo.com\n\n************************** Author's Comments **************************\n\nThere are several problems with material in the CBT distribution\nmethod.\n\n - Support\n\n   Obviously paid support through a large company like IBM is better.\n   Another issue is authors move on and can no longer support their\n   product for one reason or another.\n\n - Release dependencies\n\n   HLASM was developed for use with High Level Assembler Verson 1\n   Release 6.  For the most part it was assembled and tested with\n   Version 1 Release 5.  It is unknown if future High Level Assembler\n   releases will have a significant impact on HLASM.  Certainly no\n   issues were detected going from Release 5 to Release 6.\n\n   In addition, z/OS 2.3 inserted significant potential issues for\n   HLASM.  To the maximum extent possible these issues have been\n   mitigated by using IKJPARS to insert the data set prefix for\n   user data sets.  While HLASM has not been tested on z/OS 2.3, or\n   higher releases, it is hopeful the previously discussed\n   mitigation issues will be sufficent to avoid problems,\n\n - Author prefrences\n\n   The command is used in an environment where relatively small\n   programs are being written and tested.  The default space\n   allocations, particularly for PDS data sets, reflect this reality.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE966": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00\\x01\\x01\\x190\\x7f\\x01\\x190\\x7f\\x17&\\x00a\\x00a\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T17:26:01", "lines": 97, "newlines": 97, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 966 is from Steve Myers and contains a TSO command        *   FILE 966\n//*           called HLASM which is a full prompter for the High    *   FILE 966\n//*           Level Assembler (ASMA90).                             *   FILE 966\n//*                                                                 *   FILE 966\n//*           email:  Steve Myers <mvsprog@yahoo.com>               *   FILE 966\n//*                                                                 *   FILE 966\n//*     Members in this pds:                                        *   FILE 966\n//*                                                                 *   FILE 966\n//*     Member   Purpose                                            *   FILE 966\n//*     ------   -------                                            *   FILE 966\n//*     $DOC     This member                                        *   FILE 966\n//*     HLASM    Help member for SYS1.HELP                          *   FILE 966\n//*     INSTALL  Install HLASM.  The install is to a temporary      *   FILE 966\n//*              library to test the program.  It will have to      *   FILE 966\n//*              be rerun to install it into a \"permanent\"          *   FILE 966\n//*              library.                                           *   FILE 966\n//*     OBJECT   The object \"deck\" of the HLASM program.            *   FILE 966\n//*     ODT      A user document in Open Document format.  This     *   FILE 966\n//*              member requires additional processing to           *   FILE 966\n//*              prepare it for use on a work station.  See the     *   FILE 966\n//*              discussion later in this member.                   *   FILE 966\n//*     SOURCE   The source code of the program.                    *   FILE 966\n//*     USING    A brief discussion about using the HLASM           *   FILE 966\n//*              command.                                           *   FILE 966\n//*                                                                 *   FILE 966\n//*     The HLASM program is a TSO command processor to run the     *   FILE 966\n//*     High Level Assembler in a TSO session.                      *   FILE 966\n//*                                                                 *   FILE 966\n//*     This HLASM command is a complete and incompatible           *   FILE 966\n//*     replacement of the HLASM command in the CBTTAPE \"file\"      *   FILE 966\n//*     300 collection.  It uses the IKJPARS TSO service to         *   FILE 966\n//*     examine the contents of the command line, uses MVS          *   FILE 966\n//*     dynamic allocation to allocate all the datasets required    *   FILE 966\n//*     for the assembly, and uses the TSO PUTLINE service to       *   FILE 966\n//*     communicate with the terminal operator or the SYSTSPRT DD   *   FILE 966\n//*     statement if run in TSO in batch.  It will run directly     *   FILE 966\n//*     from the TSO READY prompt; it does not require a CLIST or   *   FILE 966\n//*     REXX exec to pre-allocate the datasets required for the     *   FILE 966\n//*     assembly.                                                   *   FILE 966\n//*                                                                 *   FILE 966\n//*     The command syntax is                                       *   FILE 966\n//*                                                                 *   FILE 966\n//*     HLASM  dataset   NOADATA/ADATA(dataset)   NOALIGN/ALIGN     *   FILE 966\n//*            NOASMAOPTS/ ASMAOPTS(dataset)   NOBATCH/BATCH        *   FILE 966\n//*            NODBCS/DBCS  NODXREF/ DXREF  NOESD/ESD NOFOLD/FOLD   *   FILE 966\n//*            NOGOFF/GOFF(NOADATA.ADATA) LIB(dataset dataset)      *   FILE 966\n//*            NOLIBMAC/LIBMAC NOLIST/LIST(121/133)                 *   FILE 966\n//*            NOMXREF/MXREF(FULL/ SOURCE/XREF)                     *   FILE 966\n//*            NOOBJECT/OBJECT(dataset) NOPRINT/PRINT(dataset)      *   FILE 966\n//*            NORC/RC  NORLD/RLD NORXREF/RXREF                     *   FILE 966\n//*            NOTERM/TERM(dataset)   NOTEST/TEST NOTHREAD/THREAD   *   FILE 966\n//*            VERSION NOXOBJ/XOBJ(NOADATA/ADATA)                   *   FILE 966\n//*            NOXREF/XREF(FULL/SHORT UNREFS)                       *   FILE 966\n//*                                                                 *   FILE 966\n//*      Required - dataset                                         *   FILE 966\n//*                                                                 *   FILE 966\n//*      Default - OBJECT TERM(*) LIB('SYS1.MODGEN' 'SYS1.MACLIB')  *   FILE 966\n//*                PRINT                                            *   FILE 966\n//*                                                                 *   FILE 966\n//*                If the source dataset is not fully qualified,    *   FILE 966\n//*                the full dataset name is formed by using the     *   FILE 966\n//*                dataset prefix appended to the start of the      *   FILE 966\n//*                name and .ASM appended to the dataset name.      *   FILE 966\n//*                                                                 *   FILE 966\n//*                If the TERM dataset name is not specified, and   *   FILE 966\n//*                the source data dataset name is not fully        *   FILE 966\n//*                qualified, HLASM for the name as                 *   FILE 966\n//*                prefix.dsn.TERMLIST.                             *   FILE 966\n//*                                                                 *   FILE 966\n//*                If the OBJECT dataset name is not specified,     *   FILE 966\n//*                and the source data dataset name is not fully    *   FILE 966\n//*                qualified, HLASM forms name as prefix.dsn.OBJ.   *   FILE 966\n//*                                                                 *   FILE 966\n//*                If the PRINT dataset name is not specified,      *   FILE 966\n//*                and the source data dataset name is not fully    *   FILE 966\n//*                qualified, HLASM forms name as                   *   FILE 966\n//*                prefix.dsn.ASMLIST.                              *   FILE 966\n//*                                                                 *   FILE 966\n//*                If the ADATA dataset name is not specified,      *   FILE 966\n//*                and the source data dataset name is not fully    *   FILE 966\n//*                qualified, HLASM forms name as                   *   FILE 966\n//*                prefix.dsn.ADATA.                                *   FILE 966\n//*                                                                 *   FILE 966\n//*                If the source dataset is fully qualified or it   *   FILE 966\n//*                is specified with a member, the command will     *   FILE 966\n//*                prompt the terminal operator for the remainder   *   FILE 966\n//*                of the datasets.                                 *   FILE 966\n//*                                                                 *   FILE 966\n//*                HLASM will allocate the OBJ, TERMLIST, ASMLIST   *   FILE 966\n//*                and ADATA datasets if they are not already       *   FILE 966\n//*                allocated.                                       *   FILE 966\n//*                                                                 *   FILE 966\n//*                If TSO \"file\" ASMAOPTS is allocated and no       *   FILE 966\n//*                ASMAOPTS dataset is specified in the command     *   FILE 966\n//*                line, the High Level Assembler will use the      *   FILE 966\n//*                TSO \"file.\"                                      *   FILE 966\n//*                                                                 *   FILE 966\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HLASM": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x00Y\\x00Y\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 89, "newlines": 89, "modlines": 0, "user": "V2L4"}, "text": "* Help information for the HLASM command.  Copy this member to your\n* SYS1.HELP data set\n)F Function -\n  Use the HLASM command to run the High Level Assembler to analyze\n  the contents of a data set and produce object output and printed\n  output as directed by the command.\n)X Syntax -\n  HLASM  'dsname'  NOADATA/ADATA('dsname')  NOALIGN/ALIGN  NOASMAOPT/\n           ASMAOPT('dsname')  NOBATCH/BATCH  NODBCS/DBCS  NODXREF/\n           DXREF  NOESD/ESD  NOFOLD/FOLD  GOFF(NOADATA/ADATA)\n           NOLIBMAC/LIBMAC  NOLIST/LIST(121/133)\n           NOMXREF/MXREF/  MXREF(FULL/SOURCE/XREF)\n           NOOBJECT/OBJECT('dsname')  NOPRINT/PRINT('dsname')\n           NORA2/RA2  NORC/RC  NORLD/RLD  NORXREF/RXREF\n           NOTERM/TERM('dsname'/*)  NOTEST/TEST  NOTHREAD/THREAD\n           XOBJ(NOADATA/ADATA)  VERSION  NOXREF/XREF(SHORT/FULL UNREFS)\n           LIB('dslist')/LIBDD('dd name')/LIBFILE('dd name')\n  Required - 'dsname'\n  Defaults - OBJECT('dsname')\n             LIB('SYS1.MODGEN' 'SYS1.MACLIB')\n             PRINT('dsname')\n             TERM(*)\n             NODXREF  TEST  NOADATA  NORLD\n)O Operands -\n  'dsname' - Specify the name of a data set containing Assembler\n             source statements.\n))NOADATA - Do not produce ADATA output.\n))ADATA('dsname') -\n            Produce ADATA output in the data set specified by dsname.\n))NOALIGN - Specify the NOALIGN High Level Assembler option.\n))ALIGN - Specify the ALIGN High Level Assembler option.\n))NOASMAOPT - Direct the HLASM command that it is not to provide\n               an options data set for the High Level Assembler.\n))ASMAOPT('dsname') -\n            Specify a data set containing High Level Assembler\n            options.\n))NOBATCH - Specify the NOBATCH High Level Assembler option.\n))BATCH - Specify the BATCH High Level Assembler option.\n))NODBCS - Specify the NODBCS High Level Assembler option.\n))DBCS - Specify the DBCS High Level Assembler option.\n))NODXREF - Specify the NODXREF High Level Assembler option.\n))DXREF - Specify the DXREF High Level Assembler option.\n))NOESD - Specify the NOESD High Level Assembler option.\n))ESD - Specify the ESD High Level Assembler option.\n))NOFOLD - Specify the NOFOLD High Level Assembler option.\n))FOLD - Specify the FOLD High Level Assembler option.\n))GOFF(NOADATA/DATA) - Specify the GOFF High Level Assembler option.\n))XOBJ(NOADATA/DATA) - Specify the XOBJ High Level Assembler option.\n))LIB('dslist') - Specify the data set names of one or more partitioned\n            data sets containing members with macro or \"copy\" code\n            for the High Level Assembler.\n))LIBDD('dd name') - Specify the DD name to use as the Assembler\n            SYSLIB data sets.\n))LIBFILE('dd name') - Specify the DD name to use as the Assembler\n            SYSLIB data sets.\n))NOLIBMAC - Specify the NOLIBMAC High Level Assembler option.\n))LIBMAC - Specify the LIBMAC High Level Assembler option.\n))NOLIST - Specify the NOLIST High Level Assembler option.\n))LIST(121/133) - Specify the LIST(nnn) High Level Assembler option.\n))NOMXREF - Specify the NOMXREF High Level Assembler option.\n))MXREF(FULL/SOURCE/XREF) - Specify the MXREF High Level Assembler\n            option.\n))NOOBJECT - Specify the NOOBJECT High Level Assembler option.\n))OBJECT('dsname') - Specify the OBJECT High Level Assembler option\n            and the name of the data set to receive this data.\n))NOPRINT - Direct HLASM to not print High Level Assembler print\n            output.\n))PRINT('dsname') - Direct HLASM to allocate a data set to receive\n            High Level Assembler printed output.\n))NORA2 - Specify the NORA2 High Level Assembler option.\n))RA2 - Specify the RA2 High Level Assembler option.\n))NORC - Direct HLASM to not list the High Level Assembler return code.\n))RC - Direct HLASM to list the High Level Assembler return code.\n))NORLD - Specify the NORLD High Level Assembler option.\n))RLD - Specify the RLD High Level Assembler option.\n))NORXREF - Specify the NORXREF High Level Assembler option.\n))RXREF - Specify the RXREF High Level Assembler option.\n))NOTERM - Specify the NOTERM High Level Assembler option.\n))TERM('dsname'/*)- Specify the TERM High Level Assembler option and\n            specify the data set to receive the output.  Specify\n            TERM(*) to direct the output to the TSO terminal.\n))NOTEST - Specify the NOTEST High Level Assembler option.\n))TEST - Specify the TEST High Level Assembler option.\n))NOTHREAD - Specify the NOTHREAD High Level Assembler option.\n))THREAD - Specify the THREAD High Level Assembler option.\n))VERSION - Direct HLASM to list the version of the command.\n))NOXREF - Specify the NOXREF High Level Assembler option.\n))XREF(FULL/SHORT UNREFS) - Specify the XREF( ...) High Level Assembler\n            option.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00Q\\x01\\x190\\x7f\\x01\\x190\\x7f\\x17#\\x00\\x11\\x00\\x11\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T17:23:51", "lines": 17, "newlines": 17, "modlines": 0, "user": "V2L4"}, "text": "//* This job uses the data set name standard used to prepare the PDS\n//* submitted to cbttape.org: userid.HLASM.V2L4.CBT.PDS.  Modify this\n//* job to correspond to the name standard being used, add a JOB\n//* statement to correspond to your standard and submit the job.\n//*\n//PREPARE EXEC PGM=IEFBR14\n//LOAD     DD  DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0),\n//             DSN=&SYSUID..CBT966.LOAD\n//INSTALL EXEC PGM=IEWL,PARM='MAP,XREF,LIST,RENT,REFR,REUS'\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DISP=(,CATLG),UNIT=SYSDA,SPACE=(TRK,(1,1,1)),\n//             DSN=*.PREPARE.LOAD\n//SYSLIN   DD  DISP=SHR,DSN=&SYSUID..HLASM.V2L4.CBT.PDS(OBJECT)\n//         DD  *\n ENTRY HLASM\n ALIAS HLASM\n NAME HLASM24(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSTALLA": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 30, "newlines": 30, "modlines": 0, "user": "V2L4"}, "text": "//* Install HLASM by assembling and linking it.  This job, in essence,\n//* represents an Installation Verification Procedure (IVP) of HLASM.\n//* It uses the TSO TEST command to load and run the object in the CBT\n//* distribution, and then uses the TSO LINK command to prepare a\n//* load module of the command.  The HLASM \"command\" after the TEST\n//* command is the prototype command TEST requires when the CP option\n//* appears on the TEST command line; the command name can be any\n//* command name, but it is not actually used for anything.\n//*\n//* Add a JOB JCL statement, alter the data set names to meet your\n//* standards and submit the job.  You should expect two additional\n//* created SYSOUT data sets in the output.  The first data set is\n//* the SYSTERM data set created by the Linking Loader when it\n//* loads the object specified by the TEST command.  The second data\n//* set is the SYSTERM data set created by the LINK command.\n//PREPARE EXEC PGM=IEFBR14\n//LOAD     DD  DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0),\n//             DSN=&SYSUID..CBT966.LOAD\n//ASMLIST  DD  DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0),\n//             DSN=&SYSUID..CBT966.ASMLIST\n//OBJ      DD  DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0),\n//             DSN=&SYSUID..CBT966.OBJ\n//INSTALL EXEC PGM=IKJEFT01\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\nTEST 'XXXXXX.HLASM.V2L4.CBT.PDS(OBJECT)' CP OBJECT\nHLASM 'XXXXXX.HLASM.V2L4.CBT.PDS(SOURCE)' OBJECT(CBT966) +\n  PRINT(CBT966) VERSION NOTEST\nRUN\nLINK (CBT966 'XXXXXX.HLASM.V2L4.CBT.PDS(LINCLUDE)') RENT REFR REUS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALLB": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 26, "newlines": 26, "modlines": 0, "user": "V2L4"}, "text": "//* This job uses the data set name standard used to prepare the PDS\n//* submitted to cbttape.org: userid.HLASM.V2L4.CBT.PDS.  Modify this\n//* job to orrespond to the name standard being used, add a JOB\n//* statement to correspond to your standard and submit the job.\n//*\n//* This job assembles the source module in member SOURCE and links\n//* the object deck in batch.\n//PREPARE EXEC PGM=IEFBR14\n//LOAD     DD  DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0),\n//             DSN=&SYSUID..CBT966.LOAD\n//ASM     EXEC PGM=ASMA90,PARM='OBJECT,NODECK,NOTEST'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(TRK,(1,1)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD  DISP=SHR,DSN=&SYSUID.HLASM.V2L4.CBT.PDS(SOURCE)\n//INSTALL EXEC PGM=IEWL,PARM='MAP,XREF,LIST,RENT,REFR,REUS'\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DISP=(,CATLG),UNIT=SYSDA,SPACE=(TRK,(1,1,1)),\n//             DSN=*.PREPARE.LOAD\n//SYSLIN   DD  DISP=DISP=OLD,DSN=*.ASM.SYSLIN\n//         DD  *\n ENTRY HLASM\n ALIAS HLASM\n NAME HLASM24(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LINCLUDE": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x00\\x03\\x00\\x03\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 3, "newlines": 3, "modlines": 0, "user": "V2L4"}, "text": " ENTRY HLASM\n ALIAS HLASM\n NAME HLASM24(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OBJECT": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x00\\xb1\\x00\\xb1\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 177, "newlines": 177, "modlines": 0, "user": "V2L4"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ODT": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x01\\xaa\\x01\\xaa\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 426, "newlines": 426, "modlines": 0, "user": "V2L4"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SOURCE": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x06\\xdd\\x06\\xdd\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 1757, "newlines": 1757, "modlines": 0, "user": "V2L4"}, "text": "HLASM    TITLE '                   S T E V E   M Y E R S ''   H L A S M>\n                  T S O   C O M M A N D'\n***********************************************************************\n*                                                                     *\n* Title - HLASM                                                       *\n*                                                                     *\n* Function / Operation - HLASM is a TSO command to run the High Level *\n*   Assembler from the TSO command line.  For the most part HLASM     *\n*   supports the Assembler H portion of the Assembler; however it     *\n*   supports many High Level Assembler features -                     *\n*    - RECFM VB for the listing data set                              *\n*    - LIST(133)                                                      *\n*    - DXREF                                                          *\n*    - ASMAOPT                                                        *\n*    - ADATA                                                          *\n*    - XREF(UNREF)                                                    *\n*                                                                     *\n* Command line -                                                      *\n*   HLASM  data set  NODXREF/DXREF  NORENT/RENT  NOTEST/TEST  NORC/RC *\n*                    NOESD/ESD  NORLD/RLD  VERSION NOTHREAD/THREAD    *\n*                    XREF(SHORT/FULL UNREFS) NOBATCH/BATCH            *\n*                    LIB(data set  data set ...)/LIBDD(ddname)/       *\n*                    LIBFILE(ddname)                                  *\n*                    NOLIST/LIST(nnn)  NOTERM/TERM(data set)          *\n*                    NOOBJECT/OBJECT(data set)  ADATA(data set)       *\n*                    NOPRINT/PRINT(data set)  ASMAOPT(data set)       *\n*                                                                     *\n*     LIBFILE is essentially an alias of LIBDD.  LIBDD is the         *\n*     documented keyword.                                             *\n*                                                                     *\n*     Required - data set                                             *\n*     Defaults - NODXREF  TEST  NORLD  XREF(SHORT)                    *\n*       LIB('SYS1.MODGEN' 'SYS1.MACLIB')  OBJECT(data set)            *\n*       PRINT(data set)  TERM(*)                                      *\n*     Data set names can be specified as unqualified names or as      *\n*     fully qualified names.  Fully qualified data set names are      *\n*     surrounded by quotation marks; unqualified dataset names are a  *\n*     simple character string.  'Sys1.maclib' is an example of a      *\n*     fully qualified data set name; xyz is an example of an          *\n*     unqualified data set name.  Fully qualified data set names are  *\n*     used as they are entered.  Unqualified data set names will have *\n*     a prefix and, most of the time, a suffix added to the name.     *\n*     The prefix is determined by the data set prefix established by  *\n*     PROFILE PREFIX(xxx) TSO command; it is usually the userid of    *\n*     the TSO user.  The suffix depends on the context.               *\n*     +----------+---------+----------+                               *\n*     | H L ASM  | Command | Suffix   |  H L ASM DD NAME refers to    *\n*     | DD name  | Keyword |          |  the DD name used by a normal *\n*     +----------+---------+----------+  batch invocation of the High *\n*     | SYSIN    |   ---   | ASM      |  Level Assembler              *\n*     +----------+---------+----------+                               *\n*     | SYSPRINT | PRINT   | ASMLIST  |                               *\n*     +----------+---------+----------+                               *\n*     | SYSADATA | ADATA   | ADATA    |                               *\n*     +----------+---------+----------+  The default data set name    *\n*     | SYSLIN   | OBJECT  | OBJ      |  for the TERM keyword is *,   *\n*     +----------+---------+----------+  to indicate the TSO user's   *\n*     | SYSTERM  | TERM    | TERMLIST |  terminal                     *\n*     +----------+---------+----------+                               *\n*     | ASMAOPT  | OPT     | ASMAOPT  |  Unqualified daa set names    *\n*     +----------+---------+----------+  specified by the LIB keyword *\n*     | SYSLIB   | LIB     |  --      |  do not have a suffix         *\n*     +----------+---------+----------+  appended to the dsname       *\n*     For example, PRINT(xyz) spacified in the command will generate  *\n*     data set name prefix.XYZ.ASMLIST.                               *\n*                                                                     *\n*     In addition, when the source data set name is specified as an   *\n*     unqualified data set name, the command will create data set     *\n*     names for the PRINT OBJ and TERM keywords if no data set name   *\n*     is specified.                                                   *\n*                                                                     *\n* Status / Change Level --                                            *\n*   V2L4 -- October 2019                                              *\n*    - Correct multiple errors in TESTMEMB and its calls.  Msg     P002\n*      HLA005E issued with incorrect member name.                  P002\n*    - Change HLA005E to HLA005A, as the message is immedately        *\n*      followed by a prompt from IKJPARS for a valid data set name.   *\n*    - Add LIBDD(ddname) to specify the DD name of a preallocated     *\n*      SYSLIB data set.  This is more flexible than adding canned     *\n*      additional libraries.  Since, presumably, the libraries will   *\n*      be allocated using the ALLOCATE command or even in the LOGON   *\n*      procedure, the requirement that the data sets must be          *\n*      catalogged is removed.  The only verification is to verify     *\n*      the DD name is allocated; if it is not allocated, IKJPARS      *\n*      will prompt the terminal operator for the DD name.             *\n*    - Update HLA003I nessage to show V2L4.                           *\n*    - Add HLA011A message to notify the terminal operator the SYSLIB *\n*      DD specified in LIBDD(library DD) is not allocated.            *\n*   V2L3 -- January 2019                                              *\n*    - XREF(FULL UNREFS) can be specified.  UNREFS is valid only   P001\n*      with XREF(SHORT).  UNREFS will only be inserted if          P001\n*      XREF(SHORT) is specified.                                   P001\n*    - Altered code to use IKJEFF02 to construct and issue most       *\n*      messages.  Added CSECT HLAMSGS to contain message skeletons    *\n*      for IKJEFF02.                                                  *\n*    - Multiple changes to add addressability.                        *\n*    - Correct Sx13 ABENDs in High Level Assembler caused by not      *\n*      validating command line parameters.  Added messages HLA007E,   *\n*      HAL008E, and HAL009E.                                          *\n*    - DSORG test extended to ALLOCASM (the IKJPARS validity check    *\n*      routine) for the source data set.                              *\n*    - Verify LIB data sets are partitioned.  DCB attributes are not  *\n*      checked.  Added message HLA010E.                               *\n*    - Minor documentation changes scattered through the source.      *\n*    - Added macro BASLONG to provide a non relocatable address       *\n*      constant linkage to \"distant\" functions such as the new        *\n*      IKJEFF02 function to invoke IKJEFF02.                          *\n*   V2L2 -- March 2018                                                *\n*    - Interpret data set name specified as (member) as               *\n*      'prefix.suffix(member)' where suffix depends on the related    *\n*      context.  The userid.suffix data set name is generated in a    *\n*      way that does not use the UPT prefix directly so as to avoid   *\n*      problems with 8 byte prefixes in z/OS 2.3.                     *\n*    - When the source data set name is specified as (member), the    *\n*      default PRINT, OBJECT and ASMAOPT data set names become        *\n*      prefix.suffix(member).                                         *\n*    - Correct and expand the description of data set names.          *\n*   V2L1 -- February 2018                                             *\n*    - TERM(*) processing altered to allocate a temporary data set    *\n*      used to spool systerm messages.  The contents of the data set  *\n*      are subsequently written to the terminal via PUTLINE.  This    *\n*      allows the messages to be \"trapped\" by CLIST or Rexx           *\n*      processing and retrieved by the CLIST or Rexx exec, or, if     *\n*      HLASM is run in TSO in batch, for SYSTERM messages to be       *\n*      stored in the TSO SYSTSPRT data set.                           *\n*    - LINECOUNT(nnn) option added to the command.  Alias LC is       *\n*      provided.                                                      *\n*    - The data set specified by the TERM keyword is checked to       *\n*      verify that, if the name contains a *, it is a 1 byte data set *\n*      name.                                                          *\n*    - An error in the AUT DYNALLOC skeleton was corrected.  Since    *\n*      this table was not used prior to V2L1, it does not affect      *\n*      previous releases.                                             *\n*    - The AUT DYNALLOC skeleton was expanded with 3 additional       *\n*      DYNALLOC keys that are used when the AUT skeleton is used to   *\n*      allocate the H L Assembler SYSTERM data set.                   *\n*    - Many tables and other data areas moved out of addressability.  *\n*    - The APARM DSECT and the TESTLIST data areas were expanded for  *\n*      future use.                                                    *\n*   V2L0 -- January 2018                                              *\n*    - LIST(dsn) changed to PRINT(dsn)                                *\n*    - LIST(121) and LIST(133) added as options.                      *\n*    - Restriction about fully qualified data set names and member    *\n*      names removed.                                                 *\n*    - Prompting for data sets added where appropriate.               *\n*    - Default space request for data sets made dependent by default  *\n*      data set suffix.                                               *\n*   V1L1                                                              *\n*    - Add option ASMAOPT(data set) to spacify a data set containing  *\n*      Assembler options not provided by the command.                 *\n*   V1L0 -- December 2017                                             *\n*                                                                     *\n* Attributes -- HLASM is reenterable, refreshable and reusable.  It   *\n*   operates as a TSO command processor in task mode, enabled,        *\n*   problem state and problem key.  It uses no APF restricted z/OS    *\n*   resources.                                                        *\n*                                                                     *\n* Restrictions - This command requires High Level Assembler Release   *\n*   5 or higher because it defines a SYSPRINT with RECFM VBM and does *\n*   not allocate a SYSUT1 data set, though the dynamic allocation     *\n*   skeleton remains in the program.                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n         MACRO\n&NAME    LINKPARS &MF=\n         LCLC  &C\n&C       SETC  '$LK&SYSNDX'\n&NAME    L     15,CVTPTR\n         ICM   15,B'1111',CVTPARS-CVTMAP(15)\n         BZ    $LK&SYSNDX.A\n         CALL  (15),MF=&MF\n         B     $LK&SYSNDX.B\n&C.A     LINK  SF=(E,LINKPARS),MF=&MF\n&C.B     DC    0H'0'\n         MEND\n         SPACE 2\n         MACRO\n&NAME    BASLONG &REG,&ADDR\n&NAME    BAS   &REG,*+L'*+2\n         DC    AL2(&ADDR-*)\n         AH    &REG,0(,&REG)\n         BASR  &REG,&REG\n         MEND\n         SPACE 5\nHLASM    CSECT                     DEFINE THE PROGRAM CSECT\nHLASM    AMODE 31                  SPECIFY THE AMODE\nHLASM    RMODE ANY                 SPECIFY THE RMODE\n         USING PPL,11              ESTABLISH PPL & WORK AREA ADDRESSING\n         USING *,12                ESTABLISH PROGRAM ADDRESSABILITY\n         B     SAVEREGS-*(,15)     BR AROUND THE ID\n         DC    AL1(L'ID)\nID       DC    C'HLASM Command Prompter &SYSDATE &SYSTIME Copyright (c)>\n                2017-2019 J. Stephen Myers'\n         DC    0H'0'\nSAVEREGS SAVE  (14,12)             SAVE REGISTERS\n         LR    12,15               PREPARE THE PROGRAM BASE REGISTER\n         LR    2,1                 COPY THE CPPL ADDRESS TO REG 2\n         LM    6,9,0(1)            LOAD THE CPPL INTO REGISTERS\n         LHI   5,WASIZE            LOAD THE SIZE OF THE WORK AREA\n         GETMAIN R,LV=(5)          ALLOCATE THE WORK AREA\n         LR    4,1                 COPY THE ADDRESS TO REG 4\n         LR    11,1                PREPARE THE PPL/WORK AREA BASE REG\n         SR    15,15               CLEAR THE PPL &  WORK AREA\n         MVCL  4,14\n         LA    0,LIBLIST           INITIALIZE THE LIST OF SYSLIB DDS\n         ST    0,LIBLIST+4\n         LA    15,SAVEAREA         ADD THE NEW SAVE AREA\n         ST    13,4(,15)            TO THE SAVE AREA CHAIN\n         ST    15,8(,13)\n         LR    13,15               PREPARE THE NEW SAVE AREA POINTER\n* PREPARE THE PPL AND OTHER DATA AREAS\n         ST    2,DFCPPLP\n         ST    2,MTCPPLP           INITIALIZE\n         LA    0,MTCSECTP           THE\n         ST    0,MTPLPTR             IKJEFFMT\n         LA    0,PUTLECB              DATA\n         ST    0,MTECBP                AREA\n         L     0,=A(HLAMSGS)            FOR\n         ST    0,MTCSECTP                IKJEFF02\n         MVI   MTSW1,MTPUTLSW\n         MVI   MTSW2,MTFMT\n         LA    0,=A(0)\n         ST    0,DFJEFF02\n         LA    0,=AL1(0,DFSVC99)\n         ST    0,DFIDP\n         ST    RUPT,PPLUPT\n         ST    RUPT,(IOPLUPT-IOPL)+MYIOPL\n         ST    RECT,PPLECT\n         ST    RECT,(IOPLECT-IOPL)+MYIOPL\n         LA    0,PDLADDR\n         ST    0,PPLANS\n         LA    0,ECB\n         ST    0,PPLECB\n         ST    0,(IOPLECB-IOPL)+MYIOPL\n         L     15,=A(SUFCMD)         GENERATE USERID.SUFFIX DATA SET\n         MVC   ASMPARM(SUFCMDL),0(15)  NAMES USING IKJPARS\n         LA    0,ASMPARM\n         ST    0,PPLCBUF\n         L     0,=A(SUFPCL)\n         ST    0,PPLPCL\n         LINKPARS MF=(E,(11))\n         LTR   15,15               RC = 0?\n         BZ    *+L'*+2             YES\n         DC    H'0'                OOPS\n         LA    0,SUFTABN           LOAD NUMBER OF SUFTAB ENTRIES\n         L     1,=A(SUFTAB)        LOAD ADDRESS OF SUFTAB\nINITXTAB LH    14,0(,1)            LOAD OFFSET OF THE PDE IN SUFPDL\n         A     14,PDLADDR          COMPUTE ADDRESS OF THE PDE\n         LH    15,4(,14)           LOAD LENGTH OF THE DATA SET NAME\n         L     14,0(,14)           LOAD ADDRESS OF THE DATA SET NAME\n         LH    2,2(,1)             LOAD OFFSET OF THE DATA SET NAME   ->\n                                    IN THE WORK AREA\n         LA    3,17                STORE THE LENGTH IN REG 3\n         AR    2,11                COMPUTE ADDRESS OF THE DSNAME\n         STH   15,0(,2)            STORE THE LENGTH\n         LA    2,2(,2)             COMPUTE THE ADDRESS\n         ICM   15,B'1000',=C' '    LOAD THE FILL CHARACTER\n         MVCL  2,14                COPY THE DATA SET NAME TO WORK AREA\n         LA    1,4(,1)             COMPUTE ADDRE OF NEXT SUFTAB ENTRY\n         BCT   0,INITXTAB          GO COPY THE DATA SET\n         LA    1,PDLADDR           FREE THE SUFPDL\n         BAS   14,FREEPDL\n         ST    RCBUF,PPLCBUF       STORE THE REAL CBUF ADDRESS\n         L     0,=A(HLPCL)\n         ST    0,PPLPCL\n         ST    11,PPLUWA\n*        LINK  SF=(E,LINKPARS),MF=(E,(11))  USE IKJPARS TO EXAMINE    ->\n                                             THE COMMAND LINE\n         LINKPARS MF=(E,(11))\n         LTR   10,15               TEST THE IKJPARS RETURN CODE\n         BNZ   EXIT12              QUIT IF ERROR\n         L     10,PDLADDR          LOAD ADDRESS OF THE PDL PREPARED   ->\n                                    BY IKJPARS\n         USING HLPDL,10\n         LH    0,HLVER             VERSION OPTION SPECIFIED?\n         LTR   0,0\n         BZ    SKIPVER\n         L     0,=C'MSG3'\n         BASLONG 14,IKJEFF02\nSKIPVER  DC    0H'0'\nSKIPOPT  LM    3,5,=A(TESTLIST,TESTL,TESTLAST)\n         USING APARM,3\nALLOC100 LH    2,APOPT             LOAD OFFSET OF THE KEYYWORD PDE\n         LTR   2,2                 PRESENT?\n         BZ    ALLOC999            NO\n         AR    2,10                COMPUTE ADDRESS OF THE PDE\n         LH    0,0(,2)             LOAD THE KEYWORD INDEX\n         CH    0,=H'1'             NO?\n         BE    ALLOC999            SKIP IT\n         NI    FLAGS,255-NEWDS\n         L     15,=A(A)\n         MVC   DYNPARM(AL),0(15)\n         LH    2,APDSN             LOAD OFFSET OF THE DATA SET PDE\n         AR    2,10                COMPUTE ADDRESS OF THE PDE\n         ICM   0,B'1111',0(2)      LOAD ADDRESS OF THE DATA SET NAME\n         BNZ   ALLOC200            BR  IF PRESENT\n         ICM   0,B'1111',8(2)      LOAD ADDRESS OF THE MEMBER NAME\n         BZ    ALLOC180            BR IF NO MEMBER NAME\n         LH    15,*-*              LOAD OFFSET OF THE DEFAULT DSNAME\n         ORG   *-2                 DEFEAT STORAGE\n         DC    S(APDFLT)            ALIGNMENT WARNING\n         AR    15,11               COMPUTE ADDRESS OF DEFAULT DSNAME\n         MVC   4(2,2),0(15)        COPY THE LENGTH TO THE PDE\n         LA    15,2(,15)           COMPUTE ADDRESS OF THE DSNAME\n         ST    15,0(,2)            STORE THE ADDRESS IN THE PDE\n         OI    6(2),X'C0'          NOTE DSNAME PRESENT & QUALIFIED\n         B     ALLOC200            GO ALLOCATE THE DATA SET\nALLOC180 DC    0H'0'\n         TM    HLDSN+6,X'01'       SYSIN SPECIFIED AS (MEMBER)?\n         BZ    ALLOC190            NO\n         LH    15,*-*              LOAD OFFSET OF THE DEFAULT DSNAME\n         ORG   *-2                 DEFEAT STORAGE\n         DC    S(APDFLT)            ALIGNMENT WARNING\n         AR    15,11               COMPUTE THE ADDRESS\n         MVC   4(2,2),0(15)        COPY THE LENGTH\n         LA    15,2(,15)\n         ST    15,0(,2)\n         OI    6(2),X'C0'          NOTE DSNAME PRESENT & QUALIFIED\n         MVC   8(8,2),HLDSN+8      COPY MEMBER ADDRESS, LENGTH AND FLAG\n         NOPR  0                   ** DEBUG FREEZE POINT **\n         B     ALLOC200\nALLOC190 DC    0H'0'\n         TM    FLAG,QUALIFIED      TEST IF SYSIN IS FULLY QUALIFIED\n         BO    ALLOC600            BR IF SO\n         LA    2,HLDSN             USE SYSIN\nALLOC200 L     1,0(,2)             LOAD ADDRESS OF THE DSN\n         CLI   0(1),C'*'           TERMINAL?\n         BNE   ALLOC300            NO\n         L     1,=A(AUT)           PREPARE THE AUT DYNALLOC SKELETON\n         MVC   DYNPARM(AUTL),0(1)   TO BE USED FOR SYSTERM\n         MVC   (AUTTXT06-AUT)+DYNPARM,=AL2(DALRECFM)\n         MVC   (AUTTXT07-AUT)+DYNPARM,=AL2(DALLRECL)\n         MVC   (AUTTXT08-AUT)+DYNPARM,=AL2(DALDSORG)\n         B     ALLOC500\nALLOC300 MVC   (ATXT05-A+6)+DYNPARM(L'APPRIME),APPRIME  INITIALIZE\n         MVC   (ATXT06-A+6)+DYNPARM(L'APSECND),APSECND   SPACE AMOUNTS\n         LA    14,(ADSN-A)+DYNPARM\n         L     0,0(,2)             LOAD ADDRESS OF THE DATA SET NAME\n         LH    1,4(,2)             LOAD LENGTH\n         LR    15,1                COPY LENGTH TO REG 15\n         MVCL  14,0                COPY DSN TO DYNPARM\n         TM    6(2),X'40'          FULLY QUALIFIED?\n         BO    ALLOC400\n         MVI   0(14),C'.'          ADD STANDARD SUFFIX TO THE NAME\n         MVC   1(L'APSUFFIX,14),APSUFFIX\nALLOC400 TM    8+6(2),X'80'        MEMBER NAME?\n         BZ    ALLOC500            NO\n         L     0,8(,2)             LOAD ADDRESS OF THE MEMBER NAME\n         LH    1,8+4(2)            LOAD THE LENGTH\n         LA    14,(AMEMB-A)+DYNPARM  COPY MEMBER TO DYNPARM\n         LR    15,1\n         MVCL  14,0\n         MVC   ((AMEMB-A)-6)+DYNPARM(2),=AL2(DALMEMBR)\nALLOC500 LA    1,XPDL              FREE THE PROMPTING PDL\n         BAS   14,FREEPDL\n         B     ALLOC700\nALLOC600 ICM   1,B'1111',APPCL     LOAD ADDRESS OF THE PROMPTING PCL\n         BZ    EXIT12              BR IF NO PROMPTING PCL\n         BAS   14,PROMPT\n         LTR   15,15               TEST PARS RC\n         BNZ   EXIT12              OOPS\n         L     2,XPDL              LOAD ADDRESS OF THE PDL\n         LA    2,TERMDSN-TERMPDL(,2)  LOAD ADDRESS OF THE DSN\n         ICM   0,B'1111',0(2)      DATA SET NAME?\n         BNZ   ALLOC200            YES\n         B     EXIT12              OOPS\nALLOC700 TM    APRECFM,X'FF'       NEW DATA SET POSSIBLE?\n         BZ    *+L'*+4             NO\n         OI    FLAGS,NEWDS         SET NEW DATA SET FLAG\n         LA    1,DYNPARM           ALLOCATE THE DATA SET\n         BASLONG 14,DYNALLOC\n         LTR   15,15               OK?\n         BNZ   EXIT12              NO\n         TM    APRECFM,X'FF'       OUTPUT DATA SET?\n         BZ    ALLOC740            NO\n         LA    0,DDTERM-PPL        IS THIS SYSTERM?\n         CH    0,APDD\n         BNE   ALLOC710            NO\n         LH    15,APDSN            LOAD OFFSET OF THE PDE\n         AR    15,10               COMPUTE ADDRESS OF THE PDE\n         L     15,0(,15)           LOAD ADDRESS OF THE DATA SET NAME\n         CLI   0(15),C'*'          TERM(*)?\n         BE    ALLOC740            YES, SKIP THE DSORG TEST\nALLOC710 MVC   12(2,13),(ADSORG-A)+DYNPARM  COPY DSORG TO WORK AREA\n         OC    12(2,13),12(13)     NO DSORG IS SEQUENTIAL\n         BZ    ALLOC720\n         NC    12(2,13),=AL1(255-DCBDSGU,X'FF') REMOVE UNUSABLE ATTR\n         CLC   12(2,13),=AL1(DCBDSGPS,0)  SEQUENTIAL?\n         BE    ALLOC720            YES\n         CLC   12(2,13),=AL1(DCBDSGPO,0)  PARTITIONED?\n         BE    ALLOC730            YES\n         LA    0,L'ADSN            INIT MTINSRTS WITH THE DATA SET NAME\n         LA    1,(ADSN-A)+DYNPARM   TO INDICATE THE DSORG IS UNKNOWN\n         STM   0,1,MTINSRTS\n         L     0,=C'MSG7'\n         BASLONG 14,IKJEFF02\n*        B     EXIT12\n         B     ALLOC600\nALLOC720 TM    (AMEMB-A)+DYNPARM,255-C' '  SEQUENTIAL DATA SET WITH A\n         BZ    ALLOC740                     MEMBER NAME?  NO\n         LA    0,L'ADSN            INIT MTINSRTS WITH THE DATA SET NAME\n         LA    1,(ADSN-A)+DYNPARM\n         STM   0,1,MTINSRTS\n         L     0,=C'MSG8'\n         BASLONG 14,IKJEFF02\n*        B     EXIT12\n         B     ALLOC600\nALLOC730 TM    (AMEMB-A)+DYNPARM,255-C' '  PDS.  MEMBER SPECIFIED?\n         BNZ   ALLOC740                    YES, OK\n         LA    0,L'ADSN            INIT MTINRTS WITH THE\n         LA    1,(ADSN-A)+DYNPARM   DATA SET NAME\n         STM   0,1,MTINSRTS\n         L     0,=C'MSG9'\n         BASLONG 14,IKJEFF02\n*        B     EXIT12\n         B     ALLOC600\nALLOC740 DC    0H'0'\n         LH    15,APDD             LOAD DDNAME OFFSET\n         LA    0,DDASMOPT-PPL      LOAD OFFSET FOR ASMAOPT\n         CR    0,15                DO WE JUST ALLOCATE ASMAOPT?\n         BNE   ALLOC900            NO\n         TM    (AMEMB-A)+DYNPARM,255-C' '   DID WE ALLOCATE A PDS?\n         BZ    ALLOC800            NO\n         LA    0,(ADDN-A)+DYNPARM   VERIFY MEMBER\n         LA    1,(AMEMB-A)+DYNPARM   IN DATA SET\n         BAS   14,TESTMEMB\n         LTR   15,15               TEST RC\n         BZ    ALLOC800            OK\n         LA    1,ASMPARM           WRITE MESSAGE FROM TESTMEMB\n         BASLONG 14,PUTLINE\n         B     EXIT12              AND QUIT, HARD\nALLOC800 LH    15,APDD             RELOAD THE ASMAOPT DD OFFSET\nALLOC900 AR    15,11\n         MVC   0(8,15),(ADDN-A)+DYNPARM COPY ALLOCATED DDNAME TO DDLIST\nALLOC999 BXLE  3,4,ALLOC100\n         DROP  3                   KILL APARM ADDRESSABILITY\n         LA    2,HLLIBDS           LOAD ADDRESS OF THE LIB D.S. PDE\n         TM    6(2),X'80'          LIB(...) SPECIFIED?\n         BZ    LIBOK               NO\nALLOCLIB ICM   0,B'1111',0(2)      LOAD ADDRESS OF THE DSNAME\n         BZ    EXIT12              HUH?\n         LH    1,4(,2)             LOAD THE LENGTH\n         L     15,=A(A)\n         MVC   DYNPARM(AL),0(15)   INIT DYNPARM\n         LA    14,(ADSN-A)+DYNPARM COPY THE LIBRARY DATA SET NAME\n         LR    15,1                 TO DYNPARM\n         MVCL  14,0\n         LA    1,DYNPARM           ALLOCATE A SYSLIB\n         BASLONG 14,DYNALLOC\n         LTR   15,15               OK?\n         BNZ   EXIT12              NO\n         MVC   12(2,13),(ADSORG-A)+DYNPARM  VERIFY\n         NC    12(2,13),=AL1(255-DCBDSGU,255)  DATA SET\n         CLC   12(2,13),=AL1(DCBDSGPO,0)        IS PARTITIONED\n         BE    LIBPO\n         LA    0,L'ADSN            PREPARE MTINSRTS\n         LA    1,(ADSN-A)+DYNPARM\n         STM   0,1,MTINSRTS\n         L     0,=C'MS10'          WRITE DATA SET CAN'T BE USED\n         BASLONG 14,IKJEFF02\n         B     EXIT12\nLIBPO    DC    0H'0'\n         LA    0,16                SAVE THE DD NAME\n         BAS   14,GETMAIN\n         MVC   4(8,1),(ADDN-A)+DYNPARM\n         L     15,LIBLIST+4        ADD IT TO THE SYSLIB LIST\n         ST    1,0(,15)\n         ST    1,LIBLIST+4\n         XC    0(4,1),0(1)\n         L     2,24(,2)            LOAD ADDRESS OF THE NEXT LIB DSN PDE\n         N     2,=A(X'FFFFFF')\n         BNZ   ALLOCLIB            BR IF NOT END OF LIST\n         L     2,LIBLIST           LOAD ADDRESS OF THE FIRST DD NAME\n         MVC   DDSYSLIB,4(2)\n         SR    3,3\n         LA    2,LIBLIST           LOAD ADDRESS OF THE FIRST DD NAME\nCOUNTLIB ICM   2,B'1111',0(2)      LOAD ADDRESS OF THE NEXT DD\n         BZ    CONCAT              BR IF THE END OF THE CHAIN\n         LA    3,1(,3)\n         B     COUNTLIB\nCONCAT   CH    3,=H'1'             1 DATA SET?\n         BE    LIBOK               YES\n         LA    0,MAXLIB            VERIFY WE CAN CONCATENATE THE\n         CR    3,0                  DATA SETS\n         BNH   BUILDCC             YES WE CAN!\n         L     0,=C'MSG6'\n         BASLONG 14,IKJEFF02\n         B     EXIT12\nBUILDCC  DC    0H'0'\n         L     1,=A(CC)            COPY THE DYNALLOC SKELETON TO\n         MVC   DYNPARM(CCL),0(1)    CONCATENATE DD STATEMENTS\n         STH   3,((CCTXT01-CC)+2)+DYNPARM  STORE THE NUMBER OF DDS\n         L     1,LIBLIST           LOAD ADDRESS OF THE FIRST DD\n         LA    3,DYNPARM+CCL       LOAD ADDRESS OF THE FIRST DD ENTRY ->\n                                    IN THE CONCAT PARM DATA\nADDDD    LA    0,8                 STORE THE LENGTH\n         STH   0,0(,3)\n         MVC   2(8,3),4(1)         COPY THE DD NAME\n         LA    3,10(,3)            COMPUTE ADDRESS OF THE NEXT DD\n         ICM   1,B'1111',0(1)      LOAD ADDRESS OF THE NEXT DD\n         BNZ   ADDDD\n         LA    1,DYNPARM           ALL THE DD NAMES HAVE BEEN COPIED  ->\n                                    TO THE CONCAT PARM LIST\n         BASLONG 14,DYNALLOC\n         LTR   15,15               OK?\n         BNZ   EXIT12              NO\n* BUILD THE ASSEMBLER PARM DATA\nLIBOK    DC    0H'0'\n         LH    0,HLPRINT           LOAD THE PRINT KEYWORD INDEX\n         CH    0,=H'1'             NOPRINT?\n         BNE   PRINTOK             NO\n         L     1,=A(ADUMMY)        COPY THE DYNALLOC SKELETON TO\n         MVC   DYNPARM(ADUML),0(1)  ALLOCATE A DUMMY DATA SET\n         LA    1,DYNPARM\n         BASLONG 14,DYNALLOC\n         LTR   15,15               OK?\n         BNZ   EXIT12              NO\n         MVC   DDSYSPRT,(ADDDN-ADUMMY)+DYNPARM\nPRINTOK  MVC   ASMPARM+2(L'BASEPARM),BASEPARM  START IT OFF WITH NODECK\n         LA    14,ASMPARM+2+L'BASEPARM\n         LA    2,GENPARM           LOAD ADDRESS OF THE GENPARM TABLE\nNEXTPARM LH    3,2(,2)             LOAD OFFSET OF THE PDE\n         AR    3,10                COMPUTE THE PDE ADDRESS\n         LH    3,0(,3)             LOAD THE PDE VALUE\n         CH    3,4(,2)             PDE MATCH THIS PARM?\n         BNE   SKIPPARM            NO\n         MVI   0(14),C','          INSEERT A ,\n         LA    14,1(,14)\n         LH    15,6(,2)            LOAD THE LENGTH\n         LA    0,8(,2)             LOAD TEXT ADDRESS\n         LR    1,15                COPY THE PARM\n         MVCL  14,0\nSKIPPARM SR    0,0                 LOAD OFFSET OF THE NEXT TABLE ENTRY\n         ICM   0,B'0011',0(2)\n         BZ    XRPARM              0, DONE\n         AR    2,0                COMPUTE THE ADDRESS OF THE NEXT ENTRY\n         B     NEXTPARM\nXRPARM   LH    0,HLXREF            XREF SPECIFIED?\n         CH    0,=H'2'\n         BNE   ADDMXREF            NO\n*                         ----+-\n         MVC   0(6,14),=C',XREF('  START IT OFF\n         LA    14,6(,14)\n         LH    1,HLXSHORT          SHORT OR FULL?\n         LA    15,5\n         LA    0,=C'SHORT'\n         CH    1,=H'1'\n         BE    *+L'*+8\n         LA    15,4\n         LA    0,=C'FULL'\n         LR    1,15\n         MVCL  14,0                ADD SHORT OR FULL\n         LH    0,HLXSHORT          XREF(SHORT)?                    P001\n         CH    0,=H'1'                                             P001\n         BNE   XRCLOSE             NO                              P001\n         LH    1,HLXUREF           UNREFS?\n         CH    1,=H'1'\n         BNE   *+L'*+10            NO\n*                         ----+--\n         MVC   0(7,14),=C',UNREFS' ADD UNREFS\n         LA    14,7(,14)\nXRCLOSE  MVI   0(14),C')'          CLOSE XREF(...)                 P001\n         LA    14,1(,14)\nADDMXREF LH    0,HLMXREF           MXREF WITH NO ADDED KEYWORD?\n         CH    0,=H'2'             NO\n         BNE   NOMXREF\n         ICM   0,B'0011',HLMX\n         BNZ   NOMXREF\n         MVC   0(6,14),=C',MXREF'  ADD MXREF\n         LA    14,6(,14)\nNOMXREF  DC    0H'0'\nADDXOBJ  LH    0,HLXOBJ            LOAD THE KEYWORD INDEX\n         LTR   0,0                 SOMETHING SPECIFIED?\n         BZ    SKIPXOBJ            NO\n         CH    0,=H'2'             NOXOBJ OR NOGOFF?\n         BNH   SKIPXOBJ            YES, ALREADY ENTERED\n         LH    0,HLXOBAD           ADATA OR NOADATA SPECIFIED?\n         LTR   0,0\n         BNZ   SKIPXOBJ            YES, ALREADY FILLED IN\n         MVC   0(5,14),=C',XOBJ'   ADD XOBJ\n         LA    14,5(,14)\nSKIPXOBJ DC    0H'0'\nADDLIST  LH    0,HLLIST            LOAD THE LIST KEYWORD INDEX\n         CH    0,=H'2'             LIST SPECIFIED?\n         BNE   ADDLC               NO\n         L     1,HLLSIZE           LOAD ADDRESS OF THE AMOUNT\n         MVC   0(6,14),=C',LIST('\n         MVC   6(3,14),0(1)        COPY THE VALIDATED TEXT\n         MVI   9(14),C')'\n         LA    14,10(,14)          UPDATE THE POINTER\nADDLC    TM    HLLC+6,X'80'        LINECOUNT SPECIFIED?\n         BZ    STORLEN             NO\n*                          ----+----1-\n         MVC   0(11,14),=C',LINECOUNT('  ADD THE KEYWORD\n         LA    14,11(,14)          UPDATE THE POINTER\n         LH    15,HLLC+4           COPY\n         LR    1,15                 THE\n         L     0,HLLC+0              VALUE\n         MVCL  14,0\n         MVI   0(14),C')'          TERMINATE THE PARAMETER\n         LA    14,1(,14)\nSTORLEN  LA    1,ASMPARM+2         COMPUTE THE LENGTH\n         SR    14,1\n         STH   14,ASMPARM\n         LA    0,DDSIZE            INSERT THE LENGTH OF THE DD LIST\n         STH   0,DDLIST\n* RUN ASM90 HERE\n         L     0,=C'MSG1'\n         BASLONG 14,IKJEFF02\n         LINK  SF=(E,LINKASM),MF=(E,PARMLIST),                        ->\n               PARAM=(ASMPARM,DDLIST),VL=1\n         LR    5,15\n         BASLONG 14,LISTTERM\n         LR    15,5\n         LR    5,15                SAVE THE RETURN CODE\n         LH    1,HLRC              LOAD THE RC OPTION\n         DROP  10                  KILL PDL ADDRESSABILITY\n         LR    10,15               DESTROY THE PDL POINTER\n         LA    0,2\n         CR    0,1                 RC SPECIFIED?\n         BNE   EXIT                NO\n         ST    15,DYNRC\n         L     0,=A(X'80000000'+L'DYNRC)\n         LA    1,DYNRC\n         STM   0,1,MTINSRTS\n         L     0,=C'MSG2'\n         BASLONG 14,IKJEFF02\n         B     EXIT\n* A SERIOUS ERROR HAS BEEN ENCOUNTERED.\nEXIT12   LA    10,12\n         XC    STACKPB,STACKPB\n         STACK MF=(E,MYIOPL),DELETE=PROC,ECB=PUTLECB,PARM=STACKPB,    ->\n               ENTRY=CALLSTCK\nCALLSTCK L     15,CVTPTR\n         ICM   15,B'1111',CVTSTCK-CVTMAP(15)\n         BZ    STCKLINK\n         CALL  (15),MF=(E,(1))\n         B     TCLEARQ\nSTCKLINK LINK  SF=(E,LINKSTCK),MF=(E,(1))\nTCLEARQ  TCLEARQ INPUT\nEXIT     LA    1,PDLADDR\n         BAS   14,FREEPDL\n         ICM   1,B'1111',LIBLIST\n         BZ    X0100\n         ICM   0,B'1111',0(1)\n         BZ    X0100\n         L     15,=A(DC)\n         MVC   DYNPARM(DCL),0(15)\n         MVC   (DCDDN-DC)+DYNPARM,4(1)\n         LA    1,DYNPARM\n         BASLONG 14,DYNALLOC\nX0100    ICM   2,B'1111',ALIST\n         BZ    X0200\n         MVC   ALIST,0(2)\n         L     1,=A(U)\n         MVC   DYNPARM(UL),0(1)\n         MVC   (UDDN-U)+DYNPARM,4(2)\n         LA    1,DYNPARM\n         BASLONG 14,DYNALLOC\n         B     X0100\nX0200    BAS   14,FREEALL\n         L     13,4(,13)\n          LHI   0,WASIZE\n         FREEMAIN R,LV=(0),A=(11)\n         LR    15,10\n         RETURN (14,12),RC=(15)\n         EJECT\n* INVOKE IKJPARS TO PROMPT FOR A MISSING PARAMETER\n         CNOP  0,8\nPROMPT   BASR  15,0\n         SAVE  (14,1),,PROMPT      SAVE REGISTERS\n         LA    15,72(,13)          ADD NEW SAVE AREA TO THE\n         ST    13,4(,15)            SAVE AREA CHAIN\n         ST    15,8(,13)\n         LR    13,15               PREPARE NEW SAVE AREA POINTER\n         ST    1,PPLPCL            SAVE THE PCL ADDRESS\n         MVC   ASMPARM(5),CMD      PREPARE A PSEUDO COMMOND BUFFER\n         LA    0,ASMPARM\n         ST    0,PPLCBUF           STORE THE COMMAND BUFFER ADDRESS\n         LA    0,XPDL              STORE THE ADDRESS OF THE NEW\n         ST    0,PPLANS             PDL ADDRESS\n*        LINK  SF=(E,LINKPARS),MF=(E,(11))  CALL IKJPARS TO OBTAIN A  ->\n                                             PARAMETER\n         LINKPARS MF=(E,(11))\n         L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA\n         RETURN (14,1),RC=(15)     RESTORE REGISTERS & RETURN\n         EJECT\n* FREE THE PDL WHOSE ADDRESS IS IN THE WORD SPECIFIED BY REG 1\n         CNOP  0,8\nFREEPDL  BASR  15,0\n         SAVE  (14,1),,FREEPDL     SAVE REGISTERS\n         IKJRLSA (1)               FREE THE PDL\n         RETURN (14,1)             RESTORE REGISTERS & RETURN\n         EJECT\n* Allocate a small amount of storage\n         DC    0D'0'\nCPAMT    EQU   1*1024              BYTES IN A SINGLE CELL POOL\nGETMAIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n*        USING *,12                ESTABLISH ADDRESSABILITY\n         USING CPOOL,10\n         SAVE  (14,12),,GETMAIN    SAVE REGISTERS\n*        LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12\n         LR    2,0                 COPY AMOUNT OF STORAGE TO REG 2\n         AHI   2,7                 ROUND REQUEST UP TO AN 8 BYTE\n         N     2,ROUND8             MULTIPLE\nGM0100   LA    10,CPLIST-(CPNEXT-CPOOL)  LOAD ADDR OF A DUMMY CPOOL\nGM0200   ICM   10,B'1111',CPNEXT   LOAD ADDR OF THE NEXT CPOOL\n         JZ    GM0300              BR IF END OF LIST\n         C     2,CPLEFT            COMPARE REQUESTED AMOUNT WITH      ->\n                                    FREE STORAGE IN THIS CPOOL\n         JH    GM0200              BR IF NOT ENOUGH STORAGE IN THIS   ->\n                                    CPOOL\n         MVC   24(4,13),CPNEXTA    REPLACE CALLER'S REG 1 W/ CURRENT  ->\n                                    FREE SPACE ADDRESS IN THIS CPOOL\n         L     0,CPLEFT            LOAD FREE BYTES IN THIS CPOOL\n         SR    0,2                 SUBTRACT AMOUNT OF STORAGE WE      ->\n                                    JUST ALLOCATED\n         ST    0,CPLEFT            UPDATE FREE SPACE AMOUNT\n         A     2,CPNEXTA           ADD ADDRESS OF STORAGE WE JUST     ->\n                                    ALLOCATED TO AMOUNT OF STORAGE    ->\n                                     WE JUST ALLOCATED\n         ST    2,CPNEXTA           UPDATE ADDRESS OF FREE STORAGE\n         J     GM0800              AND EXIT\nGM0300   LHI   0,CPAMT-(CPSTART-CPOOL)  SET REG 0 = FREE STORAGE IN A ->\n                                         SINGLE CPOOL\nGM0400   CR    0,2                 COMPARE W/ AMOUNT WE NEED\n         JNL   GM0500              BR IF ENOUGH\n         AHI   0,CPAMT             ADD CPAMT TO REG 0\n         J     GM0400              CONTINUE\nGM0500   AHI   0,CPSTART-CPOOL     SET REG 0 TO A K MULTIPLE\n         LR    3,0                 COPY AMOUNT OF STORAGE TO REG 3\n         TAM   ,                   TEST ADDRESSING MODE\n         JNZ   GM0600              BR IF NOT AMODE 24\n         GETMAIN RU,LV=(0)         ALLOCATE STORAGE\n         J     GM0700\nGM0600   GETMAIN RU,LV=(0),LOC=(31,ANY)  ALLOCATE STORAGE\nGM0700   LR    10,1                COPY ADDRESS TO REG 11\n*        XC    0(CPSTART-CPOOL,11),0(11)  CLEAR THE HEADER\n         ST    3,CPSIZE            STORE THE SIZE\n         LA    0,CPSTART\n         ST    0,CPNEXTA\n         AHI   3,-(CPSTART-CPOOL)  SUBTRACT HEADER SIZE FROM          ->\n                                    ALLOCATED STORAGE\n         ST    3,CPLEFT            STORE FREE SPACE SIZE\n         MVC   CPNEXT,CPLIST       ADD THE NEW SUBPOOL TO THE\n         ST    10,CPLIST            SUBPOOL CHAIN\n         J     GM0100              AND RESTART ALLOCATION\nGM0800   RETURN (14,12),T          RESTORE REGS & RETURN\n         SPACE 5\n         CNOP  0,8\nFREEALL  BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n*        USING *,12                ESTABLISH ADDRESSABILITY\n         SAVE  (14,12),,FREEALL    SAVE REGISTERS\n*        LR    12,15               COPY THE ENTRY POINT ADDR TO REG 12\nFR0100   ICM   10,B'1111',CPLIST   LOAD ADDR OF THE NEXT CPOOL\n         JZ    FR0200              EXIT IF DONE\n         MVC   CPLIST,CPNEXT       REMOVE CURRENT CPOOL FROM THE CHAIN\n         L     0,CPSIZE            LOAD SIZE\n         FREEMAIN RU,LV=(0),A=(10) FREE THE CPOOL\n         J     FR0100              GO FREE THE NEXT CPOOL\nFR0200   RETURN (14,12),T          RESTORE REGS & RETURN\n         SPACE 1\nROUND8   DC    F'-8'\n         DROP  10\n         CNOP  0,8\nTESTLDD  SAVE  (14,12),,*          SAVE REGISTERS\n         LR    12,15               COPY TESTLDD ADDRESS TO REG 12\n         LA    0,TESTLDD-HLASM     LOAD OFFSET OF TESTLDD IN HLASM\n         SLR   12,0                COMPUTE ADDRESS OF HLASM\n         L     11,4(,1)            LOAD ADDRESS OF THE HLASM WORK AREA\n         LR    15,13               ADD A\n         LA    13,SAVEAREA+72       NEW SAVE AREA TO\n         ST    15,4(,13)             THE\n         ST    13,8(,15)              SAVE AREA CHAIN\n         L     2,0(,1)             LOAD ADDRESS OF THE PDE\n         LA    14,DDSYSLIB         COMPUTE ADDRESS OF A WORK AREA\n         LA    15,8                LOAD WORK AREA LENGTH\n         L     0,0(,2)             LOAD ADDRESS OF THE LIBRARY DD\n         LH    1,4(,2)             LOAD LENGTH OF THE LIBRARY DD\n         ICM   1,B'1000',=C' '     LOAD MVCL FILL CHARACTER\n         MVCL  14,0                COPY LIBRARY DD TO WORK AREA\n         DEVTYPE DDSYSLIB,12(,13)  VERIFY LIBRARY DD ALLOCATED\n         LTR   15,15               OK?\n         BZ    TLDD0200            YES\n         L     0,=C'MS11'          ISSUE MSG HLA011A\n         BASLONG 14,IKJEFF02\n         LA    15,8                LOAD THE RETURN CODE\nTLDD0200 L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA\n         RETURN (14,12),RC=(15)   RESTORE REGISTERS & RETURN TO IKJPARS\n         EJECT\n* IKJPARS VALIDITY CHECK ROUTINE TO CHECK THE ASSEMBLER SYSIN DATA SET\n* AND ALLOCATE IT.  IF THE ALLOCATION FAILS WE CAN RETURN TO IKJPARS\n* TO DIRECT IT TO PROMPT THE TERMINAL OPERATOR FOR A VALID DATA\n* DATA SET NAME.\n         SPACE 1\n         CNOP  0,8\nALLOCASM SAVE  (14,12),,ALLOCASM\n* PREPARE ADDRESSABILITY\n         LA    0,ALLOCASM-HLASM\n         LR    12,15\n         SR    12,0\n         L     11,4(,1)\n         LA    15,SAVEAREA+72      ADD A NEW SAVE AREA TO\n         ST    13,4(,15)            THE SAVE AREA CHAIN\n         ST    15,8(,13)\n         LR    13,15\n         NI    FLAGS,255-QUALIFIED RESET QUALIFIED\n         L     2,0(,1)             LOAD ADDRESS OF THE PDE\n         L     15,=A(A)\n         MVC   DYNPARM(AL),0(15)   ALLOCATE THE DATA SET\n         LA    14,(ADSN-A)+DYNPARM\n         LH    15,4(2)\n         NI    6(2),X'C0'          MAKE SURE ONLY IBM DEFINED FLAGS   ->\n                                    REMAIN\n         LTR   15,15               LENGTH = 0?\n         BNZ   AASM0050            NO\n         LH    15,XASM             LOAD THE LENGTH\n         LA    0,XASM+2            LOAD ADDRESS OF THE DSNAME\n         ST    0,0(,2)             STORE THE ADDRESS OF THE DSNAME\n         STH   15,4(,2)            STORE THE LENGTH\n         OI    6(2),X'C1'          NOTE IT'S PRESENT & QUALIFIED\nAASM0050 DC    0H'0'\n         L     0,0(,2)\n         LR    1,15\n         MVCL  14,0\n         TM    6(2),X'40'          FULLY QUALIFIED DATA SET NAME?\n         BZ    AASM0100            NO\n         OI    FLAGS,QUALIFIED     NOTE THE INPUT IS FULLY QUALIFIED\n         B     AASM0300\nAASM0100 LH    1,4(,2)             LOAD THE DSNAME LENGTH\n         CHI   1,44-9              TEST MAX LENGTH\n         BNH   AASM0200            OK\n         LA    0,L'ADSN\n         LA    1,(ADSN-A)+DYNPARM\n         STM   0,1,MTINSRTS\n         L     0,=C'MSG4'\n         BASLONG 14,IKJEFF02\n         B     AASM0500            AND EXIT WITH RC = 8\nAASM0200 MVC   0(4,14),=C'.ASM'    ADD THE STANDARD QUALIFIER\nAASM0300 TM    8+6(2),X'80'        MEMBER SPECIFIED?\n         BZ    AASM0400            NO\n         OI    FLAGS,QUALIFIED     INDICATE SOURCE NAME FULLY QUALIFIED\n         L     0,8(,2)             LOAD ADDRESS OF THE MEMBER\n         LH    1,8+4(,2)           LOAD LENGTH\n         LA    14,(AMEMB-A)+DYNPARM  COPY MEMBER NAME TO DYNPARM\n         LR    15,1\n         MVCL  14,0\n         MVC   ((AMEMB-A)+DYNPARM)-6(2),=AL2(DALMEMBR)\nAASM0400 LA    1,DYNPARM           ALLOCATE THE DATA SET\n         BASLONG 14,DYNALLOC\n         LTR   15,15               OK?\n         BNZ   AASM0500            NO\n         MVC   DDSYSIN,(ADDN-A)+DYNPARM  SAVE THE ALLOCATED DD NAME\n         MVC   12(2,13),(ADSORG-A)+DYNPARM\n         NC    12(2,13),=AL1(255-DCBDSGU,255)\n         CLC   12(2,13),=AL1(DCBDSGPS,0)  DATA SET SEQUENTIAL?\n         BE    AASM0410                   YES\n         CLC   12(2,13),=AL1(DCBDSGPO,0)  DATA SET PARTITIONED?\n         BE    AASM0430                   YES\n         L     0,=C'MSG7'          DSORG UNKNOWN, WRITE THE DIAGNOSTIC\n         B     AASM0450\nAASM0410 TM    (AMEMB-A)+DYNPARM,255-C' '  MEMBER SPECIFIED?\n         BZ    AASM0420                    NO, USE THE DATA SET\n         L     0,=C'MSG8'          DSORG PO, NO MEMBER\n         B     AASM0450\nAASM0420 SR    15,15               SET RC = 0\n         B     AASM0600            EXIT DSN OK\nAASM0430 TM    (AMEMB-A)+DYNPARM,255-C' '  MEMBER SPECIFIED\n         BNZ   AASM0440                    YES\n         L     0,=C'MSG9'                  WRITE THE DIAGNBOSTIC\n         B     AASM0450\nAASM0440 DC    0H'0'               MEMBER PRESENT & DATA SET IS PO\n         LA    0,DDSYSIN           TEST IF\n         LA    1,(AMEMB-A)+DYNPARM  MEMBER IN DATA SET\n         BAS   14,TESTMEMB\n         LTR   15,15               TEST THE RC\n         BZ    AASM0600            0, DSN OK\n         LA    1,ASMPARM           WRITE THE DIAGNOSTIC FROM TESTMEMB\n         BASLONG 14,PUTLINE\n         B     AASM0500\nAASM0450 LA    14,L'ADSN\n         LA    15,(ADSN-A)+DYNPARM\n         STM   14,15,MTINSRTS\n         BASLONG 14,IKJEFF02\n         B     AASM0500\n         TM    (AMEMB-A)+DYNPARM,255-C' '  MEMBER REQUESTED?\n         BZ    AASM0600            NO\n         LA    0,DDSYSIN           TEST IF\n         LA    1,(AMEMB-A)+DYNPARM  MEMBER IN DATA SET\n         BAS   14,TESTMEMB\n         LTR   15,15               TEST BLDL RC\n         BZ    AASM0600            OK\n         LA    1,ASMPARM           WRITE THE MESSAGE BUILT BY TESTMEMB\n         BASLONG 14,PUTLINE\nAASM0500 LA    15,8                SET RC TO PROMPT FOR A BETTER NAME\nAASM0600 L     13,4(,13)\n         RETURN (14,12),RC=(15)\n         EJECT\n* IKJPARS VALIDITY CHECK ROUTINE TO VALIDATE THE LIST SIZE\n         CNOP  0,8\nTSTLSIZE SAVE  (14,12),,TSTLSIZE   SAVE REGISTERS\n* PREPARE ADDRESSABILITY\n         LA    0,TSTLSIZE-HLASM\n         LR    12,15\n         SR    12,0\n         LA    15,4                INIT THE RETURN CODE\n         L     2,0(,1)             LOAD ADDRESS OF THE PDE\n         LH    3,4(,2)             LOAD DATA LENGTH\n         CH    3,=H'3'             3 BYTES?\n         BNE   TSTL0200            NO\n         L     1,0(,2)             LOAD ADDRESS OF THE DATA\n         CLC   =C'121',0(1)        121?\n         BE    TSTL0100            OK\n         CLC   =C'133',0(1)        133?\n         BNE   TSTL0200\nTSTL0100 SR    15,15               SET RC = 0\nTSTL0200 RETURN (14,12),RC=(15)    RETURN TO IKJPARS\n         EJECT\n         CNOP  0,8\n*        LA    0,DDNAME\n*        LA    1,MEMBER\n*        BAS   14,TESTMEMB\nTESTMEMB BASR  15,0\n         SAVE  (14,2),,TESTMEMB    SAVE REGISTERS\n         MVC   MNAME,0(1)          COPY MEMBER NAME TO BLDL AREA\n         L     1,=A(MOPEN)         PREPARE\n         MVC   OCPARM,0(1)          OCPARM\n         L     1,=A(MDCB)            AND\n         MVC   EXCPDCB,0(1)           EXCPDCB\n         L     1,20(,13)           LOAD DD NAME ADDRESS FROM REG 0    ->\n                                    SLOT IN THE SAVE AREA\n         MVC   (DCBDDNAM-IHADCB)+EXCPDCB,0(1)  COPY DDNAME TP THE DCB\n         OPEN  EXCPDCB,MF=(E,OCPARM)  OPEN THE DCB\n         MVC   BLDLPARM,=AL2(1,MSIZE) PREPARE THE ENTRY COUNT AND     ->\n                                       ENTRY LENGTH\n         BLDL  EXCPDCB,BLDLPARM    MEMBER IN DATA SET?\n         LTR   2,15                COPY THE RETURN CODE TO REG 2\n         BZ    TSTM0900\n*                              ----+---\n         MVC   ASMPARM+4(8),=C'HLA005A '  BUILD THE HLA005A MESSAGE\n         MVC   ASMPARM+4+8(L'AMEMB),(AMEMB-A)+DYNPARM\n         LA    14,ASMPARM+4+8+L'AMEMB\nTSTM0100 BCTR  14,0\n         TM    0(14),255-C' '\n         BZ    TSTM0100\n*                          ----+----1-\n         MVC   1(11,14),=C' IS NOT IN '\n         MVC   1+11(L'ADSN,14),(ADSN-A)+DYNPARM\n         LA    14,1+11+L'ADSN(,14)\nTSTM0200 BCTR  14,0\n         TM    0(14),255-C' '\n         BZ    TSTM0200\n         LA    14,1(,14)\n         LA    1,ASMPARM           COMPUTE THE MESSAGE LENGTH\n         SR    14,1\n         SLL   14,16               CONVERT THE MESSAGE LENGTH TO AN RDW\n         STCM  14,B'1111',0(1)     STORE THE RDW\nTSTM0900 L     1,=A(MCLOSE)        CLOSE THE DCB\n         MVC   OCPARM,0(1)\n         CLOSE EXCPDCB,MF=(E,OCPARM)\n         LR    15,2                COPY THE BLDL RC TO REG 15\n         RETURN (14,2),RC=(15)     RESTORE REGISTERS & RETURN\n         SPACE 1\nLINKPARS LINK  SF=L,EP=IKJPARS\nLINKPUTL LINK  SF=L,EP=IKJPUTL\nLINKDF   LINK  SF=L,EP=IKJEFF18\nLINKASM  LINK  SF=L,EP=ASMA90\nLINKSTCK LINK  SF=L,EP=IKJSTCK\n         SPACE 1\n         DC    0D'0'\n         LTORG ,\n         SPACE 1\nBASEPARM DC    C'NODECK'\n         SPACE 1\nCMD      DC    AL2(5,1),C'Z'\n         SPACE 1\n* GENPARM MUST BE ADDRESSABLE; IT DEFINES THE END OF ADDRESSABILITY\nGENPARM  DC    AL2(PARM2-*,HLTERM-HLPDL,1,6),C'NOTERM'\nPARM2    DC    AL2(PARM3-*,HLTERM-HLPDL,2,4),C'TERM'\nPARM3    DC    AL2(PARM4-*,HLRENT-HLPDL,1,6),C'NORENT'\nPARM4    DC    AL2(PARM5-*,HLRENT-HLPDL,2,4),C'RENT'\nPARM5    DC    AL2(PARM6-*,HLTEST-HLPDL,1,6),C'NOTEST'\nPARM6    DC    AL2(PARM7-*,HLTEST-HLPDL,2,4),C'TEST'\nPARM7    DC    AL2(PARM8-*,HLESD-HLPDL,1,5),C'NOESD'\nPARM8    DC    AL2(PARM9-*,HLESD-HLPDL,2,3),C'ESD'\nPARM9    DC    AL2(PARM10-*,HLRLD-HLPDL,1,5),C'NORLD'\nPARM10   DC    AL2(PARM12-*,HLLIST-HLPDL,1,6),C'NOLIST'\nPARM12   DC    AL2(PARM13-*,HLOBJ-HLPDL,1,8),C'NOOBJECT'\nPARM13   DC    AL2(PARM14-*,HLOBJ-HLPDL,2,6),C'OBJECT'\nPARM14   DC    AL2(PARM15-*,HLRLD-HLPDL,2,3),C'RLD'\nPARM15   DC    AL2(PARM16-*,HLDXREF-HLPDL,1,7),C'NODXREF'\nPARM16   DC    AL2(PARM17-*,HLDXREF-HLPDL,2,5),C'DXREF'\nPARM17   DC    AL2(PARM18-*,HLXREF-HLPDL,1,6),C'NOXREF'\nPARM18   DC    AL2(PARM19-*,HLTHREAD-HLPDL,1,8),C'NOTHREAD'\nPARM19   DC    AL2(PARM20-*,HLTHREAD-HLPDL,2,6),C'THREAD'\nPARM20   DC    AL2(PARM21-*,HLBATCH-HLPDL,1,7),C'NOBATCH'\nPARM21   DC    AL2(PARM22-*,HLBATCH-HLPDL,2,5),C'BATCH'\nPARM22   DC    AL2(PARM23-*,HLADATA-HLPDL,2,5),C'ADATA'\nPARM23   DC    AL2(PARM24-*,HLADATA-HLPDL,1,7),C'NOADATA'\nPARM24   DC    AL2(PARM25-*,HLRXREF-HLPDL,1,7),C'NORXREF'\nPARM25   DC    AL2(PARM26-*,HLRXREF-HLPDL,2,5),C'RXREF'\nPARM26   DC    AL2(PARM27-*,HLMXREF-HLPDL,1,7),C'NOMXREF'\nPARM27   DC    AL2(PARM28-*,HLMX-HLPDL,1,11),C'MXREF(FULL)'\nPARM28   DC    AL2(PARM29-*,HLMX-HLPDL,2,13),C'MXREF(SOURCE)'\nPARM29   DC    AL2(PARM30-*,HLMX-HLPDL,3,11),C'MXREF(XREF)'\nPARM30   DC    AL2(PARM31-*,HLALIGN-HLPDL,1,7),C'NOALIGN'\nPARM31   DC    AL2(PARM32-*,HLALIGN-HLPDL,2,5),C'ALIGN'\nPARM32   DC    AL2(PARM33-*,HLDBCS-HLPDL,1,6),C'NODBCS'\nPARM33   DC    AL2(PARM34-*,HLDBCS-HLPDL,2,4),C'DBCS'\nPARM34   DC    AL2(PARM35-*,HLFOLD-HLPDL,1,6),C'NOFOLD'\nPARM35   DC    AL2(PARM36-*,HLFOLD-HLPDL,2,4),C'FOLD'\nPARM36   DC    AL2(PARM37-*,HLLIBMAC-HLPDL,1,8),C'NOLIBMAC'\nPARM37   DC    AL2(PARM38-*,HLLIBMAC-HLPDL,2,6),C'LIBMAC'\nPARM38   DC    AL2(PARM39-*,HLXOBAD-HLPDL,1,13),C'XOBJ(NOADATA)'\nPARM39   DC    AL2(PARM40-*,HLXOBAD-HLPDL,2,11),C'XOBJ(ADATA)'\nPARM40   DC    AL2(PARM41-*,HLXOBJ-HLPDL,1,6),C'NOXOBJ'\nPARM41   DC    AL2(PARM42-*,HLXOBJ-HLPDL,2,6),C'NOGOFF'\nPARM42   DC    AL2(PARM43-*,HLRA2-HLPDL,1,5),C'NORA2'\nPARM43   DC    AL2(PARM44-*,HLRA2-HLPDL,2,3),C'RA2'\nPARM44   EQU   PARM43\n         SPACE 2\n* ALLOCATE A DATA SET.  THE NULL KEYS ARE FILLED IN TO ALLOCATE A NEW\n* DATA SET\nA        DC    A(X'80000000'+(ARB-A))\nARB      DC   AL1(S99RBEND-S99RB,S99VRBAL,S99NOCNV+S99NOMNT+S99NOMIG,0)\n         DC    2AL2(0)\n         DC    A(ATXTPP-A,0,0)\n* THIS KEY MUST BE FIRST\nATXT02   DC    AL2(DALRTDDN,1,L'ADDN)\nADDN     DC    CL8' '\nATXT01   DC    AL2(DALDSNAM,1,L'ADSN)\nADSN     DC    CL44' '\nATXT09   DC    AL2(*-*,1,2)  DALLRECL\nALRECL   DC    AL2(80)\nATXT04   DC    AL2(DALRTORG,1,L'ADSORG)\nADSORG   DC    AL2(0)\nATXT05   DC    AL2(*-*,1,3),AL3(20)  DALPRIME\nATXT06   DC    AL2(*-*,1,3),AL3(10)  DALSECND\nATXT07   DC    AL2(*-*,1,3),AL3(3200)  DALBLKLN\nATXT08   DC    AL2(*-*,1,1)  DALRECFM\nARECFM   DC    AL1(DCBRECF+DCBRECBR)\nATXT03   DC    AL2(DALSTATS,1,1)\nDISP1    DC    AL1(DISPSHR)\nATXT10   DC    AL2(*-*,1,1)  DALNDISP\nDISP2    DC    AL1(DISPCAT)\nATXT11   DC    AL2(*-*,1,2)  DALDSORG\n         DC    0AL2(0),AL1(DCBDSGPS,0)\nATXT12   DC    AL2(*-*,0)  DALRLSE\nATXT13   DC    AL2(*-*,1,L'AMEMB)   DALMEMBR\nAMEMB    DC    CL8' '\nATXT14   DC    AL2(*-*,1,3),AL3(2)  DALDIR\nATXTPP   DC    A(ATXT01-A,ATXT02-A,ATXT03-A,ATXT04-A,ATXT05-A)\n         DC    A(ATXT06-A,ATXT07-A,ATXT08-A,ATXT10-A,ATXT11-A)\n         DC    A(ATXT12-A,ATXT13-A,ATXT14-A)\n         DC    A(X'80000000'+(ATXT09-A))\nAL       EQU   *-A\n         SPACE 2\nATRM     DC    A(X'80000000'+(ATRMRB-ATRM))\nATRMRB   DC    AL1(S99RBEND-S99RB,S99VRBAL,S99NOCNV,0)\n         DC    2AL2(0)\n         DC    A(ATRMPP-ATRM,0,0)\n* THIS KEY MUST BE FIRST\nATRM01   DC    AL2(DALRTDDN,1,L'ATRMDDN)\nATRMDDN  DC    CL8' '\nATRM02   DC    AL2(DALTERM,0)\nATRMPP   DC    A(ATRM01-ATRM,X'80000000'+(ATRM02-ATRM))\nATRML    EQU   *-ATRM\n         SPACE 2\nADUMMY   DC    A(X'80000000'+(ADUMRB-ADUMMY))\nADUMRB   DC    AL1(S99RBEND-S99RB,S99VRBAL,0,0)\n         DC    2AL2(*-*),A(ADTXTPP-ADUMMY,0,0)\n* THIS KEY MUST BE FIRST\nADTXT01  DC    AL2(DALRTDDN,1,L'ADDDN)\nADDDN    DC    CL8' '\nADTXT02  DC    AL2(DALDUMMY,0)\nADTXTPP  DC    A(ADTXT01-ADUMMY,X'80000000'+(ADTXT02-ADUMMY))\nADUML    EQU   *-ADUMMY\n         SPACE 2\nAUT      DC    A(X'80000000'+(AUTRB-AUT))\nAUTRB    DC    AL1(S99RBEND-S99RB,S99VRBAL,0,0)\n         DC    2AL2(0),A(AUTTXTPP-AUT,0,0)\n* THIS KEY MUST BE FIRST\nAUTTXT05 DC    AL2(DALRTDDN,1,L'AUTDDN)\nAUTDDN   DC    CL8' '\nAUTTXT01 DC    AL2(DALSTATS,1,1),AL1(DISPNEW)\nAUTTXT02 DC    AL2(DALCYL,0)\nAUTTXT03 DC    AL2(DALPRIME,1,3),AL3(3)\nAUTTXT04 DC    AL2(DALSECND,1,3),AL3(3)\nAUTTXT06 DC    AL2(*-*,1,1),AL1(DCBRECF+DCBRECBR+DCBRECCA)  DALRECFM\nAUTTXT07 DC    AL2(*-*,1,2),AL2(121)                        DALLRECL\nAUTTXT08 DC    AL2(*-*,1,2),AL1(DCBDSGPS,0)                 DALDSORG\nAUTTXTPP DC    A(AUTTXT01-AUT,AUTTXT02-AUT,AUTTXT03-AUT,AUTTXT04-AUT)\n         DC    A(AUTTXT06-AUT,AUTTXT07-AUT,AUTTXT08-AUT)\n         DC    A(X'80000000'+(AUTTXT05-AUT))\nAUTL     EQU   *-AUT\n         SPACE 2\nCC       DC    A(X'80000000'+(CCRB-CC))\nCCRB     DC    AL1(S99RBEND-S99RB,S99VRBCC,0,0)\n         DC    2AL2(0),A(CCTXTPP-CC,0,0)\nCCTXTPP  DC    A(X'80000000'+(CCTXT01-CC))\nCCTXT01  DC    AL2(DCCDDNAM,*-*)\nCCL      EQU   *-CC\nMAXLIB   EQU   (256-CCL)/10\n         SPACE 2\nDC       DC    A(X'80000000'+(DCRB-DC))\nDCRB     DC    AL1(S99RBEND-S99RB,S99VRBDC,0,0)\n         DC    2AL2(0),A(DCTXTPP-DC,0,0)\nDCTXTPP  DC    A(X'80000000'+(DCTXT01-DC))\nDCTXT01  DC    AL2(DDCDDNAM,1,L'DCDDN)\nDCDDN    DC    CL8' '\nDCL      EQU   *-DC\n         SPACE 2\nU        DC    A(X'80000000'+(URB-U))\nURB      DC    AL1(S99RBEND-S99RB,S99VRBUN,0,0)\n         DC    2AL2(0),A(UTXTPP-U,0,0)\nUTXTPP   DC    A(X'80000000'+(UTXT01-U))\nUTXT01   DC    AL2(DUNDDNAM,1,L'UDDN)\nUDDN     DC    CL8' '\nUL       EQU   *-U\n         SPACE 1\nDISPOLD  EQU   X'01'\nDISPNEW  EQU   X'04'\nDISPSHR  EQU   X'08'\nDISPCAT  EQU   X'02'\nDISPKEEP EQU   X'08'\n         SPACE 1\n         PUSH  PRINT\n         PRINT NOGEN\nMOPEN    OPEN  *-*,MF=L\nMCLOSE   CLOSE *-*,MF=L\nMDCB     DCB   MACRF=E,DDNAME=FILLMEIN\n         POP   PRINT\n         SPACE 2\nTESTLIST DC    AL4(TERMPCL)\n         DC    AL2(HLTERM-HLPDL,HLTERMDS-HLPDL,DDTERM-PPL,121)\n         DC    AL1(DCBRECF+DCBRECBR+DCBRECCM)\n         DC    CL8'TERMLIST',AL3(5,3)\n         DC    AL2(XTLIST-PPL)\nTESTL    EQU   *-TESTLIST\n         DC    AL4(PRINTPCL)\n         DC    AL2(HLPRINT-HLPDL,HLLSTDS-HLPDL,DDSYSPRT-PPL,137)\n         DC    AL1(DCBRECV+DCBRECBR+DCBRECCM)\n         DC    CL8'ASMLIST',AL3(40,20)\n         DC    AL2(XLIST-PPL)\n         DC    AL4(ADATAPCL)\n         DC    AL2(HLADATA-HLPDL,HLADDS-HLPDL,DDADATA-PPL,4095)\n         DC    AL1(DCBRECV+DCBRECBR),CL8'ADATA',AL3(160,75)\n         DC    AL2(XADATA-PPL)\n         DC    AL4(OBJPCL)\n         DC    AL2(HLOBJ-HLPDL,HLOBJDS-HLPDL,DDSYSLIN-PPL,80)\n         DC    AL1(DCBRECF+DCBRECBR),CL8'OBJ',AL3(20,10)\n         DC    AL2(XOBJ-PPL)\nTESTLAST DC    AL4(OPTPCL)\n         DC    AL2(HLOPT-HLPDL,HLOPTDSN-HLPDL,DDASMOPT-PPL,0),AL1(0)\n         DC    CL8'ASMAOPT',2AL3(0),AL2(XOPT-PPL)\n         DC    0D'0'\n         EJECT\n         PUSH  PRINT\n         PRINT NOGEN\nHLPCL    IKJPARM DSECT=HLPDL\nHLPCL    RMODE ANY\nHLDSN    IKJPOSIT DSNAME,USID,VALIDCK=ALLOCASM,                       ->\n               PROMPT='NAME OF DATA SET CONTAINING PROGRAM TO ASSEMBLE'\nHLLIBMAC IKJKEYWD\n         IKJNAME NOLIBMAC\n         IKJNAME LIBMAC\nHLFOLD   IKJKEYWD\n         IKJNAME NOFOLD\n         IKJNAME FOLD\nHLALIGN  IKJKEYWD\n         IKJNAME NOALIGN\n         IKJNAME ALIGN\nHLDBCS   IKJKEYWD\n         IKJNAME NODBCS\n         IKJNAME DBCD\nHLMXREF  IKJKEYWD\n         IKJNAME NOMXREF\n         IKJNAME MXREF,SUBFLD=HLSF09\nHLRXREF  IKJKEYWD\n         IKJNAME NORXREF\n         IKJNAME RXREF\nHLBATCH  IKJKEYWD\n         IKJNAME NOBATCH\n         IKJNAME BATCH\nHLVER    IKJKEYWD\n         IKJNAME VERSION\nHLTERM   IKJKEYWD DEFAULT='TERM(*)'\n         IKJNAME NOTERM\n         IKJNAME TERM,SUBFLD=HLSF01\nHLDXREF  IKJKEYWD DEFAULT='NODXREF'\n         IKJNAME NODXREF\n         IKJNAME DXREF\nHLRENT   IKJKEYWD\n         IKJNAME NORENT\n         IKJNAME RENT\nHLTEST   IKJKEYWD DEFAULT='TEST'\n         IKJNAME NOTEST\n         IKJNAME TEST\nHLESD    IKJKEYWD\n         IKJNAME NOESD\n         IKJNAME ESD\nHLRLD    IKJKEYWD DEFAULT='NORLD'\n         IKJNAME NORLD\n         IKJNAME RLD\nHLTHREAD IKJKEYWD\n         IKJNAME NOTHREAD\n         IKJNAME THREAD\nHLLIST   IKJKEYWD\n         IKJNAME NOLIST\n         IKJNAME LIST,SUBFLD=HLSF08\nHLPRINT  IKJKEYWD DEFAULT='PRINT'\n         IKJNAME NOPRINT\n         IKJNAME PRINT,SUBFLD=HLSF02\nHLOBJ    IKJKEYWD DEFAULT='OBJECT'\n         IKJNAME NOOBJECT\n         IKJNAME OBJECT,SUBFLD=HLSF03\nHLXREF   IKJKEYWD DEFAULT='XREF'\n         IKJNAME NOXREF\n         IKJNAME XREF,SUBFLD=HLSF05\nHLADATA  IKJKEYWD DEFAULT='NOADATA'\n         IKJNAME NOADATA\n         IKJNAME ADATA,SUBFLD=HLSF06\nHLLIB    IKJKEYWD DEFAULT='LIB(''SYS1.MODGEN'' ''SYS1.MACLIB'')'\n*        IKJNAME MVTMAC,INSERT='LIB(MVT.MODGEN MVT.MACLIB MVT.TSOMAC ASX\n               M)'\n*        IKJNAME HLASMMAC,                                            ->\n               INSERT='LIB(''HLASM.SASMMAC1'' ''SYS1.MODGEN'' ''SYS1.MA>\n               CLIB'' ASM)'\n         IKJNAME LIB,SUBFLD=HLSF04\n         IKJNAME LIBDD,SUBFLD=HLSF12\n         IKJNAME LIBFILE,SUBFLD=HLSF12\nHLRC     IKJKEYWD DEFAULT='RC'\n         IKJNAME NORC\n         IKJNAME RC\nHLOPT    IKJKEYWD DEFAULT='NOASMOPT'\n         IKJNAME NOASMOPT\n         IKJNAME ASMAOPT,ALIAS='OPTDS',SUBFLD=HLSF07\nHLXOBJ   IKJKEYWD\n         IKJNAME NOXOBJ\n         IKJNAME NOGOFF\n         IKJNAME XOBJ,SUBFLD=HLSF10\n         IKJNAME GOFF,SUBFLD=HLSF10\nHLRA2    IKJKEYWD\n         IKJNAME NORA2\n         IKJNAME RA2\nHLLINEC  IKJKEYWD\n         IKJNAME LINECOUNT,ALIAS='LC',SUBFLD=HLSF11\nHLSF12   IKJSUBF\nHLLIBDD  IKJIDENT 'SYSLIB DD NAME',FIRST=ALPHA,OTHER=ALPHANUM,        ->\n               MAXLNTH=8,VALIDCK=TESTLDD,                             ->\n               PROMPT='FILE NAME OF PREALLOCATED DATA SETS TO USE AS SY>\n               LIB FOR THE ASSEMBLY'\nHLSF11   IKJSUBF\nHLLC     IKJIDENT 'LINES PER PAGE',FIRST=NUMERIC,OTHER=NUMERIC,       ->\n               MAXLNTH=3,PROMPT='LINES PER PAGE'\nHLSF10   IKJSUBF\nHLXOBAD  IKJKEYWD\n         IKJNAME NOADATA\n         IKJNAME ADATA\nHLSF09   IKJSUBF\nHLMX     IKJKEYWD\n         IKJNAME FULL\n         IKJNAME SOURCE\n         IKJNAME XREF\nHLSF08   IKJSUBF\nHLLSIZE  IKJIDENT 'LIST SIZE',FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=3,  ->\n               PROMPT='BYTES IN A PRINT LINE',VALIDCK=TSTLSIZE\nHLSF07   IKJSUBF\nHLOPTDSN IKJPOSIT DSNAME,USID,                                        ->\n               PROMPT='NAME OF DATA SET CONTAINING ASSEMBLER OPTIONS'\nHLSF06   IKJSUBF\nHLADDS   IKJPOSIT DSNAME,USID\nHLSF05   IKJSUBF\nHLXSHORT IKJKEYWD DEFAULT='SHORT'\n         IKJNAME SHORT\n         IKJNAME FULL\nHLXUREF  IKJKEYWD\n         IKJNAME UNREFS\nHLSF04   IKJSUBF\nHLLIBDS  IKJPOSIT DSNAME,USID,LIST,                                   ->\n               PROMPT='NAME OF DATA SET CONTAINING MACRO AND COPY CODE'\nHLSF03   IKJSUBF\nHLOBJDS  IKJPOSIT DSNAME,USID\nHLSF02   IKJSUBF\nHLLSTDS  IKJPOSIT DSNAME,USID\nHLSF01   IKJSUBF\nHLTERMDS IKJPOSIT DSTHING,USID,VALIDCK=TSTTRMDS,                      ->\n               PROMPT='NAME OF DATA SET TO CONTAIN ASSEMBLER SUMMARY'\n         IKJENDP\n         SPACE 2\n* IKJPARS PCLS AND PDLS USED TO PROMPT THE TERMINAL OPERATOR FOR\n* SPECIFIC DATA SETS\nTERMPCL  IKJPARM DSECT=TERMPDL\nTERMPCL  RMODE ANY\nTERMDSN  IKJPOSIT DSTHING,USID,                                       ->\n               PROMPT='NAME OF DATA SET TO CONTAIN ASSEMBLER ERRORS AND>\n                SUMMARY'\n         IKJENDP\n         SPACE 2\nPRINTPCL IKJPARM DSECT=PRINTPDL\nPRINTPCL RMODE ANY\nPRINTDSN IKJPOSIT DSNAME,USID,                                        ->\n               PROMPT='NAME OF DATA SET TO CONTAIN THE ASSEMBLER LISTIN>\n               G'\n         IKJENDP\n         SPACE 2\nOBJPCL   IKJPARM DSECT=OBJPDL\nOBJPCL   RMODE ANY\nOBJDSN   IKJPOSIT DSNAME,USID,                                        ->\n               PROMPT='NAME OF DATA SET TO CONTAIN THE ASSEMBLER OBJECT>\n                OUTPUT'\n         IKJENDP\n         SPACE 2\nADATAPCL IKJPARM DSECT=ADATAPDL\nADATAPCL RMODE ANY\nADATADSN IKJPOSIT DSNAME,USID,                                        ->\n               PROMPT='NAME OF DATA SET TO CONTAIN THE ASSEMBLER ADATA >\n               OUTPUT'\n         IKJENDP\n         SPACE 2\nOPTPCL   IKJPARM DSECT=OPTPDL\nOPTPCL   RMODE ANY\nOPTDSN    IKJPOSIT DSNAME,USID,                                       ->\n               PROMPT='NAME OF DATA SET CONTAINING ASSEMBLER OPTIONS'\n         IKJENDP\n         SPACE 2\nSUFPCL   IKJPARM DSECT=SUFPDL\nSUFPCL   RMODE ANY\nSUFASM   IKJPOSIT DSNAME,USID\nSUFLIST  IKJPOSIT DSNAME,USID\nSUFOBJ   IKJPOSIT DSNAME,USID\nSUFTLIST IKJPOSIT DSNAME,USID\nSUFADATA IKJPOSIT DSNAME,USID\nSUFOPT   IKJPOSIT DSNAME,USID\n         IKJENDP\n         EJECT\n* COMMAND BUFFER WITH THE DATA SET SUFFIXES WE USE\nSUFCMD   DC    Y(SUFCMDL,2),C'Z ASM ASMLIST OBJ TERMLIST ADATA ASMAOPT'\nSUFCMDL  EQU   *-SUFCMD\n         SPACE 2\nSUFTAB   DC    Y(SUFASM-SUFPDL,XASM-PPL)\n         DC    Y(SUFLIST-SUFPDL,XLIST-PPL)\n         DC    Y(SUFOBJ-SUFPDL,XOBJ-PPL)\n         DC    Y(SUFTLIST-SUFPDL,XTLIST-PPL)\n         DC    Y(SUFADATA-SUFPDL,XADATA-PPL)\n         DC    Y(SUFOPT-SUFPDL,XOPT-PPL)\nSUFTABN  EQU   (*-SUFTAB)/4\n         EJECT\n* VERIFY A TERMINAL DATA SET NAME DOES NOT HAVE A * OR ITS LENGTH = 1\n         SPACE 1\n         PUSH  USING\n         DROP  ,\n         CNOP  0,8\nTSTTRMDS SAVE  (14,4),,TSTTRMDS    SAVE REGISTERS\n         BASR  4,0                 PREPARE BASE REGISTER\n         USING *,4                 ESTABLISH ADDRESSABILITY\n         L     3,0(,1)             LOAD ADDRESS OF THE PDE\n         LA    0,1                 INIT REG 0\n         L     1,0(,3)             LOAD ADDRESS OF THE DATA SET NAME\n         LH    15,4(,3)            LOAD LENGTH OF THE DATA SET NAME\n         BCTR  15,0                REDUCE LENGTH BY 1\n         EX    15,TTRM0200         TRT 0(*-*,1),TTRM0300\n         BZ    TTRM0100            BR IF DATA SET NAME OK\n         LA    15,1(,15)           RESTORE THE LENGTH\n         CR    15,0                LENGTH = 1?\n         BE    TTRM0100\n         RETURN (14,4),RC=4        DSN HAS AN ASTERISK, BUT LENGTH \u00ac= 1\nTTRM0100 RETURN (14,4),RC=0        DSN OK\nTTRM0200 TRT   0(*-*,1),TTRM0300   ** EX ONLY **\n         CNOP  0,8\nTTRM0300 DC    0XL256'0'\n         DC    (C'*')X'00',X'04',(256-(*-TTRM0300))X'00'\n         POP   USING\n         SPACE 2\n         EJECT\n         CNOP  0,8\nDYNALLOC BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n         USING *,9\n         SAVE  (14,12),,DYNALLOC   SAVE REGISTERS\n         LR    9,15\n         LA    15,72(,13)          ADD NEW SAVE AREA TO THE\n         ST    13,4(,15)            SAVE AREA CHAIN\n         ST    15,8(,13)\n         LR    13,15\n         BAS   14,DYNRELOC         RELOCATE THE ADDRESS CONSTANTS\n         L     2,0(,1)             LOAD ADDRESS OF THE REQUEST BLOCK\n         ST    2,DFS99RBP          STORE ADDRESS FOR DAIRFAIL\nRETRY    DYNALLOC ,                EXECUTE THE ALLOCATION\n         LTR   10,15               OK?\n         BZ    DYNA0200            YES\n         TM    FLAG,NEWDS\n         BZ    DYNA0100\n         CLC   S99ERROR-S99RB(,2),=X'1708'  DATA SET NOT CATALOGED?\n         BNE   DYNA0100                    NO\n*        MVC   (ATXTPP-A)+DYNPARM(44),ATXTPP    UPDATE THE PARAMETERS\n         MVC   (ATXT05-A)+DYNPARM,=AL2(DALPRIME) TO\n         MVC   (ATXT06-A)+DYNPARM,=AL2(DALSECND)  ALLOCATE\n         MVC   (ATXT07-A)+DYNPARM,=AL2(DALBLKLN)   A\n         MVC   (ATXT08-A)+DYNPARM,=AL2(DALRECFM)    NEW\n         MVI   (DISP1-A)+DYNPARM,DISPNEW             DATA\n         MVC   (ATXT10-A)+DYNPARM,=AL2(DALNDISP)      DATA SET\n         MVC   (ATXT11-A)+DYNPARM,=AL2(DALDSORG)\n         MVC   (ATXT09-A)+DYNPARM,=AL2(DALLRECL)\n         MVC   (ATXT12-A)+DYNPARM,=AL2(DALRLSE)\n         MVC   (ARECFM-A)+DYNPARM,APRECFM-APARM(3)\n         MVC   (ALRECL-A)+DYNPARM,APLRECL-APARM(3)\n         TM    (AMEMB-A)+DYNPARM,255-C' '\n         BZ    DYNA0050\n         XC    (ATXT11-A)+DYNPARM,(ATXT11-A)+DYNPARM\n         MVC   (ATXT14-A)+DYNPARM,=AL2(DALDIR)\nDYNA0050 NI    FLAG,255-NEWDS      RESET THE NEWDS FLAG\n         L     15,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA\n         L     1,24(,15)           RELOAD REGISTER 1\n         B     RETRY               AND RETRY THE ALLOCATION\nDYNA0100 ST    15,DYNRC            SAVE THE RETURN CODE FOR DAIRFAIL\n         LINK  SF=(E,LINKDF),MF=(E,DFPARMS)  RUN DAIRFAIL\n         LTR   15,15               OK?\n         BZ    DYNA0300            YES\n         DC    H'0'                OOPS\nDYNA0200 L     2,DFS99RBP          LOAD THE RB ADDRESS\n         CLI   S99VERB-S99RB(2),S99VRBAL  ALLOCATE FUNCTION?\n         BNE   DYNA0300            NO\n         LA    0,16                SAVE THE DD NAME\n*        GETMAIN R,LV=(0)\n         BAS   14,GETMAIN\n         MVC   0(4,1),ALIST\n         ST    1,ALIST\n         MVC   4(8,1),ADDN-ARB(2)\nDYNA0300 LR    15,10               COPY THE RETURN CODE TO REG 15\n         L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA\n         RETURN (14,12),RC=(15)    RESTORE REGISTERS & RETURN\n         DROP  9\n         EJECT\n***********************************************************************\n*                                                                     *\n* Title -- DYNRELOC                                                   *\n*                                                                     *\n* Function / Operation -- Translate address offsets in a coded        *\n*   dynamic allocation parameter list to true addresses               *\n*                                                                     *\n* Status / Change Level --                                            *\n*           March 2012                                                *\n*    - Change comment.  The IEFZB4D2 macro name in a comment was      *\n*      incorrectly specified as IEFAB4D2.  The change level was not   *\n*      altered since the only change was in a comment and in this     *\n*      change log.                                                    *\n*    - Added comment about attributes.                                *\n*   V3L0 -- April 2010                                                *\n*                                                                     *\n* Example Calling Sequence --                                         *\n*   ----+----1----+----2----+----3----+----4----+----5----+----6      *\n*            LA    1,DYNPARMS                                         *\n*            BRAS  14,DYNRELOC                                        *\n*            ...                                                      *\n*   DYNPARMS DC    A(X'80000000'+(RB-DYNPARMS))                       *\n*   RB       DC    AL1(S99RBEND-S99RB,S99VRBAL,0,0),2AL2(0)           *\n*            DC    A(TUP001-DYNPARMS)                                 *\n*            DC    2A(0)                                              *\n*   TUP001   DC    A(TU001-DYNPARMS)                                  *\n*            DC    A(TU002-DYNPARMS)                                  *\n*            DC    A(TU003-DYNPARMS)                                  *\n*            DC    A(X'800000000'+(TU004-DYNPARMS))                   *\n*   TU001    DC    AL2(DALDSNAM,1,L'DSN)                              *\n*   DSN      DC    C'SYS1.MACLIB'                                     *\n*   TU002    DC    AL2(DALSTATS,1,1),AL1(8)                           *\n*   TU003    DC    AL2(DALRTORG,1,2),AL2(0)                           *\n*   TU004    DC    AL2(DALRTDDN,1,8),CL8' '                           *\n*                                                                     *\n* Attributes -- DYNRELOC is reenterable, refreshable and reusable.    *\n*   It operates in TCB mode, in problem key and problem state.  It    *\n*   operates in AMODE 24 or 31 that is consistent with the location   *\n*   of the code, the register save area, and the dynamic allocation   *\n*   parameter list.  It uses no external operating system resources.  *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n         DC    0D'0'\n         PUSH  USING\nDYNRELOC BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n         USING *,9\n         SAVE  (14,12),,DYNRELOC   SAVE REGISTERS\n         LR    9,15                PREPARE THE BASE REGISTER\n         LR    2,1                 COPY ADDRESS OF THE RB POINTER TO  ->\n                                    REG 2\n         L     3,0(,1)             LOAD OFFSET OF THE REQUEST BLOCK\n         ALR   3,2                 COMPUTE THE REQUEST BLOCK ADDRESS\n         ST    3,0(,1)             STORE THE REQUEST BLOCK ADDRESS\n         USING S99RB,3             ESTABLISH S99RB ADDRESSABILITY\n         L     4,S99TXTPP          LOAD OFFSET OF THE FIRST TEXT      ->\n                                    UNIT POINTER\n         ALR   4,2                 COMPUTE ADDRESS OF THE TEXT UNIT   ->\n                                    POINTER\n         ST    4,S99TXTPP          STORE ITS ADDRESS IN THE S99RB\nDYNR0100 L     15,0(,4)            LOAD OFFSET OF A TEXT UNIT POINTER\n         LR    14,15               COPY OFFSET TO REG 14\n         N     14,DYNR0300         REMOVE THE VL BIT\n         JZ    DYNR0200            BR IF NO POINTER IN THE POSITION\n         ALR   15,2                COMPUTE ADDRESS OF THE TEXT UNIT\n         ST    15,0(,4)            STORE TEXT UNIT ADDRESS IN THE     ->\n                                    TEXT UNIT POINTER\nDYNR0200 TM    0(4),X'80'          TEST IF LAST TEXT UNIT POINTER\n         LA    4,4(,4)             COMPUTE ADDRESS OF THE NEXT TEXT   ->\n                                    UNIT POINTER\n         JZ    DYNR0100            BR IF NOT THE LAST TEXT UNIT POINTER\n         RETURN (14,12)            RESTORE REGISTERS & RETURN TO CALLER\nDYNR0300 DC    A(X'7FFFFFFF')      MASK TO REMOVE THE VL BIT\n         POP   USING               RESTORE PREVIOUS USING\n*        IEFZB4D0 ,\n*        IEFZB4D2 ,\n         EJECT\n         PRINT GEN\nPUTLINE  BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n         USING *,2\n         SAVE  (14,2),,PUTLINE     SAVE REGISTERS\n         LR    2,15                Prepare base register\n         LA    15,72(,13)          ADD NEW SAVE AREA\n         ST    13,4(,15)            TO THE SAVE AREA CHAIN\n         ST    15,8(,13)\n         LR    13,15\n         XC    OLD(12),OLD         CLEAR THE OUTPUT LINE DESCRIPTOR\n         ST    1,OLD+8             PREPARE THE\n         LA    0,1                  OUTPUT LINE\n         ST    0,OLD+4               DESCRIPTOR\n         XC    PUTLPB(PUTLPBL),PUTLPB\n         MVI   PUTLECB,0\n         PUTLINE MF=(E,MYIOPL),PARM=PUTLPB,ENTRY=CALLPUTL,            ->\n               OUTPUT=(OLD,TERM,MULTLVL,INFOR),ECB=PUTLECB\nCALLPUTL L     15,CVTPTR           LOAD ADDRESS OF THE CVT\n         ICM   15,B'1111',CVTPUTL-CVTMAP(15)  LOAD ADDRESS OF IKJPUTL\n         BZ    PUTLLINK            BR IF IKJPUTL NOT PRE LOADED\n         CALL  (15),MF=(E,(1))     CALL IKJPUTL\n         B     PUTLEXIT\nPUTLLINK  LINK  SF=(E,LINKPUTL),MF=(E,(1))\nPUTLEXIT L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA\n         RETURN (14,2),RC=(15)     RESTORE REGISTERS & RETURN\n         EJECT\n         CNOP  0,8\nIKJEFF02 BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n         USING *,2\n         SAVE  (14,2),,IKJEFF02    SAVE REGISTERS\n         LR    2,15                PREPARE BASE REGISTER\n         LA    15,72(,13)          ADD NEW SAVE AREA\n         ST    13,4(,15)            TO THE SAVE AREA CHAIN\n         ST    15,8(,13)\n         LR    13,15               PREPARE NEW SAVE AREA POINTER\n         STCM  0,B'1111',MTMSGID   STORE THE MESSAGE ID\n         L     15,CVTPTR           LOAD ADDRESS OF THE CVT\n         ICM   15,B'1111',CVTEFF02-CVTMAP(15)  LOAD POSSIBLE IKJEFF02 ->\n                                                ADDRESS\n         BZ    FF020100            BR IF ADDRESS NOT INCVT\n         CALL  (15),MF=(E,MTPARML) CALL IKJEFF02\n         B     FF020200\nFF020100 LINK  SF=(E,LINKFF02),MF=(E,MTPARML)  CALL IKJEFF02\nFF020200 L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA\n         RETURN (14,2),RC=(15)     RESTORE REGISTERS & RETURN\n         SPACE 1\nLINKFF02 LINK  SF=L,EP=IKJEFF02    LINK MACRO PARAMETER LIST\n         DROP  2                   KILL ADDRESSABILITY\n         EJECT\n         CNOP  0,8\nLISTTERM BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n         SAVE  (14,12),,LISTTERM   SAVE REGISTERS\n         BASR  8,0                 STORE CURRENT ADDRESS IN REG 8\n         USING *,8                 ESTABLISH ADDRESSABILITY\n         USING HLPDL,10            ESTABLISH PDL ADDRESSABILITY\n         LA    15,72(,13)          ADD NEW SAVE AREA\n         ST    13,4(,15)            TO THE SAVE AREA CHAIN\n         ST    15,8(,13)\n         LR    13,15               PREPARE NEW SAVE AREA POINTER\n         ICM   1,B'1111',HLTERMDS  LOAD ADDRESS OF THE TERMINAL DSN\n         BZ    LTRM0700            NO DSN\n         CLI   0(1),C'*'           DSN *\n         BNE   LTRM0700            NO\n         MVC   QDCBE,MQDCBE        INITIALIZE THE DCBE\n         MVC   QOPARM,MQOPARM      INITIALIZE THE OPEN PARM LIST\n         MVC   QDCB,MQDCB          INITIALIZE THE DCB\n         LA    0,QDCBE             ADD THE DCBE ADDRESS TO THE DCB\n         ST    0,(DCBDCBE-IHADCB)+QDCB\n         MVC   (DCBDDNAM-IHADCB)+QDCB,DDTERM  COPY DDNAME TO THE DCB\n         OPEN  QDCB,MF=(E,QOPARM)  OPEN THE DCB\nLTRM0100 GET   QDCB                READ A RECORD\n         LA    0,1(,1)             SKIP THE CARRIAGE CONTROL\n         LH    3,(DCBLRECL-IHADCB)+QDCB  LOAD THE LRECL\n         LR    4,3                 COPY THE LRECL TO REG 4\n         BCTR  4,0                 SUBTRACT 2\n         BCTR  4,0\n         AR    3,1                 COMPUTE THE END OF THE RECORD\nLTRM0200 BCTR  3,0                 BACKUP 1 BYTE\n         TM    0(3),255-C' '       BLANK?\n         BNZ   LTRM0300            NO\n         BCT   4,LTRM0200          TRY AGAIN\n         B     LTRM0100            ALL BLANKS, SKIP THE RECORD\nLTRM0300 LA    1,1(,3)             COMPUTE END OF RECORD\n         SR    1,0                 COMPUTE THE LENGTH\n         BP    *+L'*+4             OK\n         DC    AL2(0,0)            OOPS\n         LA    14,ASMPARM+4        LOAD START OF TEXT\n         LR    15,1                COPY THE LENGTH TO REG 15\n         MVCL  14,0                COPY THE RECORD TO ASMPARM\n         LA    2,ASMPARM           PREPARE TO PUTLINE THE RECORD\n         SR    14,2                COMPUTE THE LINE LENGTH\n         SLL   14,16               CONVERT THE LENGTH TO AN RDW\n         STCM  14,B'1111',0(2)     STORE THE RDW\n         MVI   PUTLECB,0\n         XC    PUTLPB(PUTLPBL),PUTLPB\n         PUTLINE MF=(E,MYIOPL),PARM=PUTLPB,ENTRY=LTRM0400,            ->\n               OUTPUT=((2),TERM,SINGLE,DATA),ECB=PUTLECB\nLTRM0400 L     15,CVTPTR           LOAD ADDRESS OF THE CVT\n         ICM   15,B'1111',CVTPUTL-CVTMAP(15)  LOAD ADDR OF A POSSIBLE ->\n                                               IKJPUTL ROUTINE\n         BZ    LTRM0500            BR IF IKJPUTL NOT PRELOADED\n         CALL  (15),MF=(E,(1))     CALL IKJPUTL\n         B     LTRM0100\nLTRM0500 LINK  SF=(E,LINKPUTL),MF=(E,(1))  CALL IKJPUTL\n         B     LTRM0100\nLTRM0600 CLOSE QDCB,MF=(E,QOPARM)  CLOSE THE SYSTERM DCB\n         FREEPOOL QDCB             FREE THE BUFFER POOL\nLTRM0700 L     13,4(,13)           RESTORE REGISTERS & RETURN\n         RETURN (14,12)\n         SPACE 2\n         PUSH  PRINT\n         PRINT NOGEN\nMQDCB    DCB   DSORG=PS,MACRF=GL,DDNAME=FILLMEIN,DCBE=*-*\nMQDCBE   DCBE  EODAD=LTRM0600\nMQOPARM  OPEN  *-*,MF=L\n         POP   PRINT\n         DC    0D'0'\n         LTORG ,\n         DC    0D'0'\n         DROP  ,\n         SPACE 1\n         EJECT\n         PRINT NOGEN\nHLAMSGS  CSECT\nHLAMSGS  RMODE ANY\n         IKJTSMSG ('HLA001I RUNNING HIGH LEVEL ASSEMBLER'),MSG1\n         IKJTSMSG ('HLA002I ASMA90 RC = ',),MSG2\n         IKJTSMSG ('HLA003I HLASM V2L4 &SYSDATE &SYSTIME'),MSG3\n         IKJTSMSG ('HLA004A ',,' IS TOO LONG TO ADD STANDARD QUALIFIERS>\n               '),MSG4\n         IKJTSMSG ('HLA006E TOO MANY DATA SETS SPECIFIED IN THE LIB PAR>\n               AMETER'),MSG6\n         IKJTSMSG ('HLA007A UNABLE TO USE ',,': THE DATA SET IS NOT SEQ>\n               UENTIAL OR PARTITIONED'),MSG7\n         IKJTSMSG ('HLA008A UNABLE TO USE ',,': THE DATA SET IS SEQUENT>\n               IAL, BUT THE COMMAND LINE SPECIFIES A MEMBER'),MSG8\n         IKJTSMSG ('HLA009A UNABLE TO USE ',,': THE DATA SET IS PARTITI>\n               ONED, BUT THE COMMAND LINE DOES NOT SPECIFY A MEMBER'),M>\n               SG9\n         IKJTSMSG ('HLA010E UNABLE TO USE ',,': THE DATA SET IS NOT PAR>\n               TITIONED'),MS10\n         IKJTSMSG ('HLA011A LIBRARY DD IS NOT ALLOCATED'),MS11\n         IKJTSMSG\n         DC    0D'0'\n         SPACE 1\n         DCBD  DSORG=QS,DEVD=DA\n         IEFZB4D0 ,\n         IEFZB4D2 ,\n         CVT   DSECT=YES\n         IKJCPPL ,\nRCBUF    EQU   6+(CPPLCBUF-CPPL)/4\nRECT     EQU   6+(CPPLECT-CPPL)/4\nRUPT     EQU   6+(CPPLUPT-CPPL)/4\n         IKJIOPL ,\nIOPLSIZE EQU   *-IOPL\n         IKJPPL ,                  TSO PPL\n*        ORG   PPL+256                                          *DEBUG*\nDYNPARM  DS    XL256\n* EXTEND THE PPL TO BUILD MY WORK AREA\nSAVEAREA DS    (5*9)D              5 72 BYTE SAVE AREAS\nMYIOPL   DS    XL(IOPLSIZE),0D     TSO IOPL FOR STACK AND PUTLINE\nPUTLPB   PUTLINE MF=L              PUTLINE PARAMETER BLOCK\nPUTLPBL  EQU   *-PUTLPB\nSTACKPBS STACK MF=L                STACK PARAMETER BLOCK\nSTACKPB  EQU   STACKPBS,*-STACKPBS\nOLD      DS    3A                  PUTLINE OUTPUT LINE DESCRIPTOR\n         IKJEFFDF DFDSECT=NO,DFDSEC2=YES \"DAIRFAIL\" PARM LIST\nPPL      DSECT                     RETURN TO PPL DSECT\n         PUSH  PRINT\n         PRINT NOGEN\n         IKJEFFMT MTDSECT=NO,MTFORMAT=NEW\n         POP   PRINT\nCPLIST   DC    A(*-*)              ADDRESS OF FIRST SUBPOOL\nDYNRC    DS    F                   DYNAMIC ALLOCATION RETURN CODE\nALIST    DS    A                   ALLOCATED DD NAMES\nLIBLIST  DS    2A                  ALLOCATED SYSLIB DD NAMES\nPDLADDR  DS    A                   ADDRESS OF HLPDL\nXPDL     DS    A                   ADDRESS OF SECONDARY PDL\nECB      DS    F                   ECB FOR IKJPARS\nPUTLECB  DS    F                   ECB FOR PUTLINE AND STACK\nPARMLIST CALL  ,(*-*,*-*),MF=L     PARAMETER LIST FOT ASSEMBLER\nOCPARMS  OPEN  *-*,MF=L            OPEN / CLOSE PARAMETER LIST\nOCPARM   EQU   OCPARMS,*-OCPARMS\nQDCBS    DCB   DSORG=PS,MACRF=GL,DDNAME=FILLMEIN,DCBE=*-*\nQDCB     EQU   QDCBS,*-QDCBS\nQDCBES   DCBE  EODAD=*-*\nQDCBE    EQU   QDCBES,*-QDCBES\nQOPARMS  OPEN  *-*,MF=L\nQOPARM   EQU   QOPARMS,*-QOPARMS\nEXCPDCBS DCB   MACRF=E,DDNAME=FILLMEIN EXCP DCB AREA\nEXCPDCB  EQU   EXCPDCBS,*-EXCPDCBS\nBLDLPARM DS    F                   BLDL PARAMETER AREA\nMNAME    DS    CL8,XL3,3X\nMSIZE    EQU   *-MNAME\n         CNOP  6,8\nDDLIST   DS    H                   DD LIST SENT TO ASSEMBLER\nDDSYSLIN DS    CL8\n         DS    2D\nDDSYSLIB DS    CL8\nDDSYSIN  DS    CL8\nDDSYSPRT DS    CL8\n         DS    D\nDDSYSUT1 DS    CL8\n         DS    3D\nDDTERM   DS    CL8\n         DS    3D\nDDADATA  DS    CL8\n         DS    3D\nDDASMOPT DS    CL8\nDDSIZE   EQU   (*-DDLIST)-2\nASMPARM   DS   H,CL128             PARAMETER STRING SENT TO ASSEMBLER\nFLAG     DS    0AL1                FLAG BITS\nFLAGS    DS    AL1\nNEWDS    EQU   X'80'\nQUALIFIED EQU  X'01'\nXASM     DS    H,CL17,0H\nXLIST    DS    H,CL17,0H\nXOBJ     DS    H,CL17,0H\nXTLIST   DS    H,CL17,0H\nXADATA   DS    H,CL17,0H\nXOPT     DS    H,CL17,0H\n         DS    0D\n*        ORG   PPL+4096                                         *DEBUG*\nWASIZE   EQU   *-PPL               SIZE OF PPL AND WORK AREA\n         SPACE 2\n* FORMAT OF TESTLIST ENTRIES\nAPARM    DSECT\nAPPCL    DS    A                   ADDRESS OF PROMPTING PCL\nAPOPT    DS    H                  OFFSET OF OPTION KEYWORD PDE IN HLPDL\nAPDSN    DS    H                   OFFSET OF DATA SET PDE IN HLPDL\nAPDD     DS    H                   OFFSET OF DD NAME IN WORK AREA\nAPLRECL  DS    AL2                 DEFAULT LRECL OF NEW DATA SET\nAPRECFM  DS    AL1                 DEFAULT RECFM OF NEW DATA SET\nAPSUFFIX DS    CL8                 DATA SET SUFFIX\nAPPRIME  DS    AL3                 VALUE MOVED TO DALPRIME KEY\nAPSECND  DS    AL3                 VALUE MOVED TO DALSECND KEY\nAPDFLT   DS    AL2                 OFFSET OF USERID.SUFFIX DSN\n         SPACE 2\nCPOOL    DSECT                     CELL POOL CONTAINER\nCPNEXT   DS    A                   ADDRESS OF THE NEXT CONTAINER\nCPSIZE   DS    F                   BYTES ALLOCATED FOR THIS SUBPOOL\nCPLEFT   DS    F                   FREE BYTES LEFT IN THIS CONTAINER\nCPNEXTA  DS    A,0D                ADDRESS OF FIRST FREE BYTE\nCPSTART  EQU   *\n         POP   PRINT\n         END   HLASM\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USING": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00@\\x01\\x190\\x7f\\x01\\x190\\x7f\\x16\\x17\\x00}\\x00}\\x00\\x00\\xe5\\xf2\\xd3\\xf4@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2019-11-03T00:00:00", "modifydate": "2019-11-03T16:17:40", "lines": 125, "newlines": 125, "modlines": 0, "user": "V2L4"}, "text": "                         U S I N G   H L A S M\n\nThe HLASM command is a tool to run the IBM High Level Assembler in\nyour TSO session rather than in the background as a batch job.  For\nexample -\n\nhlasm tstparse\n RUNNING HIGH LEVEL ASSEMBLER\n Assembler Done No Statements Flagged\n ASMA90 RC = 0\n READY\n\nThe first parameter, tstparse in this example, specifies the input\ndata set, userid.TSTPARSE.ASM.\n\nMost of the time High Level Assembler error messages are directed\nto the TSO terminal (or, if you are running HLASM in TSO in batch\nto the SYSTSPRT data set) -\n\nhlasm tstparse\n RUNNING HIGH LEVEL ASSEMBLER\n 000018 0000 0000            00000    13          LA    R5,WASIZE\nLoad the size of the work area\n ASMA044E Undefined symbol - R5\n ASMA029E Incorrect register specification - R5\n ASMA435I Record 8 in XXXXXX.TSTPARSE.ASM on volume: XXXX15\n Assembler Done      1 Statement  Flagged /   8 was Highest Severity\nCode\n ASMA90 RC = 8\n\nHowever, the error messages can be directed to a data set.\n\nThe command can create three other output data sets: a data set\ncontaining the Assembler listing, a data set containing the\n\"object\" output of the Assembler, and a data set containing\nassociated data (ADATA) output.  When the command specifies a\nregular input data set, these data sets default to\nuserid.dsn.ASMLIST, userid.dsn.OBJ, and userid.dsn.ADATA.  You\nmust request ADATA output by specifying the ADATA option in the\nHLASM command line.\n\nYou can specify a fully qualified input data set by enclosing the\nname in quotation marks: 'prod.pgms(tstparse)'.  When you specify\na fully qualified data set name, the HLASM command will prompt\nthe user for the print and object data set names, or they can be\nspecified in the HLASM command line.  For example -\n\nhlasm 'xxxxxx.tstparse.asm'\n ENTER NAME OF DATA SET TO CONTAIN THE ASSEMBLER LISTING -\ntsthlasm\n ENTER NAME OF DATA SET TO CONTAIN THE ASSEMBLER OBJECT OUTPUT -\ntsthlasm\n RUNNING HIGH LEVEL ASSEMBLER\n Assembler Done No Statements Flagged\n ASMA90 RC = 0\n\nor\n\nhlasm 'xxxxxx.tstparse.asm' print(tsthlasm) object(tsthlasm)\n RUNNING HIGH LEVEL ASSEMBLER\n Assembler Done No Statements Flagged\n ASMA90 RC = 0\n\nYou can also specify a data set as just a member name enclosed in\nparenthesis: (member).  When you just specify a member, HLASM\nuses data set userid.suffix(member).\n\nhlasm (member)\n\nis equivalent to\n\nhlasm 'userid.asm(member)' object('userid.obj(member)')\nprint('userid.asmlist(member)')\n\nYou specify the member name by itself with a keyword like\nprint((member)) to use data set USERID.ASMLIST(MEMBER).\n\nAssembler Options\n\nThe High Level Assembler accepts a large number of options\ndescribed in the HLASM Programmer's Guide.  You can specify most\nof these options in the HLASM command line.\n\nhlasm dataset option option ...\n\n****************** Running HLASM while in ISPF edit ********************\n\nThe HLASM command processor is a TSO line mode command.  TSO line\nmode commands and ISPF are not exactly compatible.  However,\nwithin these linmitations HLASM within ISPF works reasonably\nwell.\n\nYou can run HLASM while you are in ISPF EDIT from the command line.\nFor example -\n\n  File  Edit  Edit_Settings  Menu  Utilities  Compilers  Test  Help\n----------------------------------------------------------------------\nEDIT       XXXXXX.HLASM.TEST.ASM                           Columns 000\nCommand ===> save;tso hlasm hlasm.test                        Scroll =\n****** ***************************** Top of Data *********************\n050000 HLASM    TITLE '                   S T E V E   M Y E R S ''   H\n100000                   T S O   C O M M A N D'\n150000 ***************************************************************\n200000 *\n250000 * Title - HLASM\n300000 *\n350000 * Function / Operation - HLASM is a TSO command to run the High\n\nHere the terminal operator chose to combine the ISPF SAVE command\nand run HLASM after ISPF completed the SAVE command.  The\nassembly is the HLASM command in this data set.\n\nAfter the assembly completed here is the bottom part of the screen.\n\n465000 *     fully qualified names.  Fully qualified data set names ar\n470000 *     surrounded by quotation marks; unqualifieed dataset names\n475000 *     simple character string.  'Sys1.maclib' is an example of\nRUNNING HIGH LEVEL ASSEMBLER\nAssembler Done HLASM No Statements Flagged\nASMA90 RC = 0\n***\n\nThere is enough to see whether the assembly completed OK or not.\nThe terminal operator can easily display the assembly listing in a\nsecond ISPF window and correct any errors.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT966/FILE966.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT966", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}