HLASM    TITLE '                   S T E V E   M Y E R S ''   H L A S M>
                  T S O   C O M M A N D'
***********************************************************************
*                                                                     *
* Title - HLASM                                                       *
*                                                                     *
* Function / Operation - HLASM is a TSO command to run the High Level *
*   Assembler from the TSO command line.  For the most part HLASM     *
*   supports the Assembler H portion of the Assembler; however it     *
*   supports many High Level Assembler features -                     *
*    - RECFM VB for the listing data set                              *
*    - LIST(133)                                                      *
*    - DXREF                                                          *
*    - ASMAOPT                                                        *
*    - ADATA                                                          *
*    - XREF(UNREF)                                                    *
*                                                                     *
* Command line -                                                      *
*   HLASM  data set  NODXREF/DXREF  NORENT/RENT  NOTEST/TEST  NORC/RC *
*                    NOESD/ESD  NORLD/RLD  VERSION NOTHREAD/THREAD    *
*                    XREF(SHORT/FULL UNREFS) NOBATCH/BATCH            *
*                    LIB(data set  data set ...)/LIBDD(ddname)/       *
*                    LIBFILE(ddname)                                  *
*                    NOLIST/LIST(nnn)  NOTERM/TERM(data set)          *
*                    NOOBJECT/OBJECT(data set)  ADATA(data set)       *
*                    NOPRINT/PRINT(data set)  ASMAOPT(data set)       *
*                                                                     *
*     LIBFILE is essentially an alias of LIBDD.  LIBDD is the         *
*     documented keyword.                                             *
*                                                                     *
*     Required - data set                                             *
*     Defaults - NODXREF  TEST  NORLD  XREF(SHORT)                    *
*       LIB('SYS1.MODGEN' 'SYS1.MACLIB')  OBJECT(data set)            *
*       PRINT(data set)  TERM(*)                                      *
*     Data set names can be specified as unqualified names or as      *
*     fully qualified names.  Fully qualified data set names are      *
*     surrounded by quotation marks; unqualified dataset names are a  *
*     simple character string.  'Sys1.maclib' is an example of a      *
*     fully qualified data set name; xyz is an example of an          *
*     unqualified data set name.  Fully qualified data set names are  *
*     used as they are entered.  Unqualified data set names will have *
*     a prefix and, most of the time, a suffix added to the name.     *
*     The prefix is determined by the data set prefix established by  *
*     PROFILE PREFIX(xxx) TSO command; it is usually the userid of    *
*     the TSO user.  The suffix depends on the context.               *
*     +----------+---------+----------+                               *
*     | H L ASM  | Command | Suffix   |  H L ASM DD NAME refers to    *
*     | DD name  | Keyword |          |  the DD name used by a normal *
*     +----------+---------+----------+  batch invocation of the High *
*     | SYSIN    |   ---   | ASM      |  Level Assembler              *
*     +----------+---------+----------+                               *
*     | SYSPRINT | PRINT   | ASMLIST  |                               *
*     +----------+---------+----------+                               *
*     | SYSADATA | ADATA   | ADATA    |                               *
*     +----------+---------+----------+  The default data set name    *
*     | SYSLIN   | OBJECT  | OBJ      |  for the TERM keyword is *,   *
*     +----------+---------+----------+  to indicate the TSO user's   *
*     | SYSTERM  | TERM    | TERMLIST |  terminal                     *
*     +----------+---------+----------+                               *
*     | ASMAOPT  | OPT     | ASMAOPT  |  Unqualified daa set names    *
*     +----------+---------+----------+  specified by the LIB keyword *
*     | SYSLIB   | LIB     |  --      |  do not have a suffix         *
*     +----------+---------+----------+  appended to the dsname       *
*     For example, PRINT(xyz) spacified in the command will generate  *
*     data set name prefix.XYZ.ASMLIST.                               *
*                                                                     *
*     In addition, when the source data set name is specified as an   *
*     unqualified data set name, the command will create data set     *
*     names for the PRINT OBJ and TERM keywords if no data set name   *
*     is specified.                                                   *
*                                                                     *
* Status / Change Level --                                            *
*   V2L4 -- October 2019                                              *
*    - Correct multiple errors in TESTMEMB and its calls.  Msg     P002
*      HLA005E issued with incorrect member name.                  P002
*    - Change HLA005E to HLA005A, as the message is immedately        *
*      followed by a prompt from IKJPARS for a valid data set name.   *
*    - Add LIBDD(ddname) to specify the DD name of a preallocated     *
*      SYSLIB data set.  This is more flexible than adding canned     *
*      additional libraries.  Since, presumably, the libraries will   *
*      be allocated using the ALLOCATE command or even in the LOGON   *
*      procedure, the requirement that the data sets must be          *
*      catalogged is removed.  The only verification is to verify     *
*      the DD name is allocated; if it is not allocated, IKJPARS      *
*      will prompt the terminal operator for the DD name.             *
*    - Update HLA003I nessage to show V2L4.                           *
*    - Add HLA011A message to notify the terminal operator the SYSLIB *
*      DD specified in LIBDD(library DD) is not allocated.            *
*   V2L3 -- January 2019                                              *
*    - XREF(FULL UNREFS) can be specified.  UNREFS is valid only   P001
*      with XREF(SHORT).  UNREFS will only be inserted if          P001
*      XREF(SHORT) is specified.                                   P001
*    - Altered code to use IKJEFF02 to construct and issue most       *
*      messages.  Added CSECT HLAMSGS to contain message skeletons    *
*      for IKJEFF02.                                                  *
*    - Multiple changes to add addressability.                        *
*    - Correct Sx13 ABENDs in High Level Assembler caused by not      *
*      validating command line parameters.  Added messages HLA007E,   *
*      HAL008E, and HAL009E.                                          *
*    - DSORG test extended to ALLOCASM (the IKJPARS validity check    *
*      routine) for the source data set.                              *
*    - Verify LIB data sets are partitioned.  DCB attributes are not  *
*      checked.  Added message HLA010E.                               *
*    - Minor documentation changes scattered through the source.      *
*    - Added macro BASLONG to provide a non relocatable address       *
*      constant linkage to "distant" functions such as the new        *
*      IKJEFF02 function to invoke IKJEFF02.                          *
*   V2L2 -- March 2018                                                *
*    - Interpret data set name specified as (member) as               *
*      'prefix.suffix(member)' where suffix depends on the related    *
*      context.  The userid.suffix data set name is generated in a    *
*      way that does not use the UPT prefix directly so as to avoid   *
*      problems with 8 byte prefixes in z/OS 2.3.                     *
*    - When the source data set name is specified as (member), the    *
*      default PRINT, OBJECT and ASMAOPT data set names become        *
*      prefix.suffix(member).                                         *
*    - Correct and expand the description of data set names.          *
*   V2L1 -- February 2018                                             *
*    - TERM(*) processing altered to allocate a temporary data set    *
*      used to spool systerm messages.  The contents of the data set  *
*      are subsequently written to the terminal via PUTLINE.  This    *
*      allows the messages to be "trapped" by CLIST or Rexx           *
*      processing and retrieved by the CLIST or Rexx exec, or, if     *
*      HLASM is run in TSO in batch, for SYSTERM messages to be       *
*      stored in the TSO SYSTSPRT data set.                           *
*    - LINECOUNT(nnn) option added to the command.  Alias LC is       *
*      provided.                                                      *
*    - The data set specified by the TERM keyword is checked to       *
*      verify that, if the name contains a *, it is a 1 byte data set *
*      name.                                                          *
*    - An error in the AUT DYNALLOC skeleton was corrected.  Since    *
*      this table was not used prior to V2L1, it does not affect      *
*      previous releases.                                             *
*    - The AUT DYNALLOC skeleton was expanded with 3 additional       *
*      DYNALLOC keys that are used when the AUT skeleton is used to   *
*      allocate the H L Assembler SYSTERM data set.                   *
*    - Many tables and other data areas moved out of addressability.  *
*    - The APARM DSECT and the TESTLIST data areas were expanded for  *
*      future use.                                                    *
*   V2L0 -- January 2018                                              *
*    - LIST(dsn) changed to PRINT(dsn)                                *
*    - LIST(121) and LIST(133) added as options.                      *
*    - Restriction about fully qualified data set names and member    *
*      names removed.                                                 *
*    - Prompting for data sets added where appropriate.               *
*    - Default space request for data sets made dependent by default  *
*      data set suffix.                                               *
*   V1L1                                                              *
*    - Add option ASMAOPT(data set) to spacify a data set containing  *
*      Assembler options not provided by the command.                 *
*   V1L0 -- December 2017                                             *
*                                                                     *
* Attributes -- HLASM is reenterable, refreshable and reusable.  It   *
*   operates as a TSO command processor in task mode, enabled,        *
*   problem state and problem key.  It uses no APF restricted z/OS    *
*   resources.                                                        *
*                                                                     *
* Restrictions - This command requires High Level Assembler Release   *
*   5 or higher because it defines a SYSPRINT with RECFM VBM and does *
*   not allocate a SYSUT1 data set, though the dynamic allocation     *
*   skeleton remains in the program.                                  *
*                                                                     *
***********************************************************************
         SPACE 5
         MACRO
&NAME    LINKPARS &MF=
         LCLC  &C
&C       SETC  '$LK&SYSNDX'
&NAME    L     15,CVTPTR
         ICM   15,B'1111',CVTPARS-CVTMAP(15)
         BZ    $LK&SYSNDX.A
         CALL  (15),MF=&MF
         B     $LK&SYSNDX.B
&C.A     LINK  SF=(E,LINKPARS),MF=&MF
&C.B     DC    0H'0'
         MEND
         SPACE 2
         MACRO
&NAME    BASLONG &REG,&ADDR
&NAME    BAS   &REG,*+L'*+2
         DC    AL2(&ADDR-*)
         AH    &REG,0(,&REG)
         BASR  &REG,&REG
         MEND
         SPACE 5
HLASM    CSECT                     DEFINE THE PROGRAM CSECT
HLASM    AMODE 31                  SPECIFY THE AMODE
HLASM    RMODE ANY                 SPECIFY THE RMODE
         USING PPL,11              ESTABLISH PPL & WORK AREA ADDRESSING
         USING *,12                ESTABLISH PROGRAM ADDRESSABILITY
         B     SAVEREGS-*(,15)     BR AROUND THE ID
         DC    AL1(L'ID)
ID       DC    C'HLASM Command Prompter &SYSDATE &SYSTIME Copyright (c)>
                2017-2019 J. Stephen Myers'
         DC    0H'0'
SAVEREGS SAVE  (14,12)             SAVE REGISTERS
         LR    12,15               PREPARE THE PROGRAM BASE REGISTER
         LR    2,1                 COPY THE CPPL ADDRESS TO REG 2
         LM    6,9,0(1)            LOAD THE CPPL INTO REGISTERS
         LHI   5,WASIZE            LOAD THE SIZE OF THE WORK AREA
         GETMAIN R,LV=(5)          ALLOCATE THE WORK AREA
         LR    4,1                 COPY THE ADDRESS TO REG 4
         LR    11,1                PREPARE THE PPL/WORK AREA BASE REG
         SR    15,15               CLEAR THE PPL &  WORK AREA
         MVCL  4,14
         LA    0,LIBLIST           INITIALIZE THE LIST OF SYSLIB DDS
         ST    0,LIBLIST+4
         LA    15,SAVEAREA         ADD THE NEW SAVE AREA
         ST    13,4(,15)            TO THE SAVE AREA CHAIN
         ST    15,8(,13)
         LR    13,15               PREPARE THE NEW SAVE AREA POINTER
* PREPARE THE PPL AND OTHER DATA AREAS
         ST    2,DFCPPLP
         ST    2,MTCPPLP           INITIALIZE
         LA    0,MTCSECTP           THE
         ST    0,MTPLPTR             IKJEFFMT
         LA    0,PUTLECB              DATA
         ST    0,MTECBP                AREA
         L     0,=A(HLAMSGS)            FOR
         ST    0,MTCSECTP                IKJEFF02
         MVI   MTSW1,MTPUTLSW
         MVI   MTSW2,MTFMT
         LA    0,=A(0)
         ST    0,DFJEFF02
         LA    0,=AL1(0,DFSVC99)
         ST    0,DFIDP
         ST    RUPT,PPLUPT
         ST    RUPT,(IOPLUPT-IOPL)+MYIOPL
         ST    RECT,PPLECT
         ST    RECT,(IOPLECT-IOPL)+MYIOPL
         LA    0,PDLADDR
         ST    0,PPLANS
         LA    0,ECB
         ST    0,PPLECB
         ST    0,(IOPLECB-IOPL)+MYIOPL
         L     15,=A(SUFCMD)         GENERATE USERID.SUFFIX DATA SET
         MVC   ASMPARM(SUFCMDL),0(15)  NAMES USING IKJPARS
         LA    0,ASMPARM
         ST    0,PPLCBUF
         L     0,=A(SUFPCL)
         ST    0,PPLPCL
         LINKPARS MF=(E,(11))
         LTR   15,15               RC = 0?
         BZ    *+L'*+2             YES
         DC    H'0'                OOPS
         LA    0,SUFTABN           LOAD NUMBER OF SUFTAB ENTRIES
         L     1,=A(SUFTAB)        LOAD ADDRESS OF SUFTAB
INITXTAB LH    14,0(,1)            LOAD OFFSET OF THE PDE IN SUFPDL
         A     14,PDLADDR          COMPUTE ADDRESS OF THE PDE
         LH    15,4(,14)           LOAD LENGTH OF THE DATA SET NAME
         L     14,0(,14)           LOAD ADDRESS OF THE DATA SET NAME
         LH    2,2(,1)             LOAD OFFSET OF THE DATA SET NAME   ->
                                    IN THE WORK AREA
         LA    3,17                STORE THE LENGTH IN REG 3
         AR    2,11                COMPUTE ADDRESS OF THE DSNAME
         STH   15,0(,2)            STORE THE LENGTH
         LA    2,2(,2)             COMPUTE THE ADDRESS
         ICM   15,B'1000',=C' '    LOAD THE FILL CHARACTER
         MVCL  2,14                COPY THE DATA SET NAME TO WORK AREA
         LA    1,4(,1)             COMPUTE ADDRE OF NEXT SUFTAB ENTRY
         BCT   0,INITXTAB          GO COPY THE DATA SET
         LA    1,PDLADDR           FREE THE SUFPDL
         BAS   14,FREEPDL
         ST    RCBUF,PPLCBUF       STORE THE REAL CBUF ADDRESS
         L     0,=A(HLPCL)
         ST    0,PPLPCL
         ST    11,PPLUWA
*        LINK  SF=(E,LINKPARS),MF=(E,(11))  USE IKJPARS TO EXAMINE    ->
                                             THE COMMAND LINE
         LINKPARS MF=(E,(11))
         LTR   10,15               TEST THE IKJPARS RETURN CODE
         BNZ   EXIT12              QUIT IF ERROR
         L     10,PDLADDR          LOAD ADDRESS OF THE PDL PREPARED   ->
                                    BY IKJPARS
         USING HLPDL,10
         LH    0,HLVER             VERSION OPTION SPECIFIED?
         LTR   0,0
         BZ    SKIPVER
         L     0,=C'MSG3'
         BASLONG 14,IKJEFF02
SKIPVER  DC    0H'0'
SKIPOPT  LM    3,5,=A(TESTLIST,TESTL,TESTLAST)
         USING APARM,3
ALLOC100 LH    2,APOPT             LOAD OFFSET OF THE KEYYWORD PDE
         LTR   2,2                 PRESENT?
         BZ    ALLOC999            NO
         AR    2,10                COMPUTE ADDRESS OF THE PDE
         LH    0,0(,2)             LOAD THE KEYWORD INDEX
         CH    0,=H'1'             NO?
         BE    ALLOC999            SKIP IT
         NI    FLAGS,255-NEWDS
         L     15,=A(A)
         MVC   DYNPARM(AL),0(15)
         LH    2,APDSN             LOAD OFFSET OF THE DATA SET PDE
         AR    2,10                COMPUTE ADDRESS OF THE PDE
         ICM   0,B'1111',0(2)      LOAD ADDRESS OF THE DATA SET NAME
         BNZ   ALLOC200            BR  IF PRESENT
         ICM   0,B'1111',8(2)      LOAD ADDRESS OF THE MEMBER NAME
         BZ    ALLOC180            BR IF NO MEMBER NAME
         LH    15,*-*              LOAD OFFSET OF THE DEFAULT DSNAME
         ORG   *-2                 DEFEAT STORAGE
         DC    S(APDFLT)            ALIGNMENT WARNING
         AR    15,11               COMPUTE ADDRESS OF DEFAULT DSNAME
         MVC   4(2,2),0(15)        COPY THE LENGTH TO THE PDE
         LA    15,2(,15)           COMPUTE ADDRESS OF THE DSNAME
         ST    15,0(,2)            STORE THE ADDRESS IN THE PDE
         OI    6(2),X'C0'          NOTE DSNAME PRESENT & QUALIFIED
         B     ALLOC200            GO ALLOCATE THE DATA SET
ALLOC180 DC    0H'0'
         TM    HLDSN+6,X'01'       SYSIN SPECIFIED AS (MEMBER)?
         BZ    ALLOC190            NO
         LH    15,*-*              LOAD OFFSET OF THE DEFAULT DSNAME
         ORG   *-2                 DEFEAT STORAGE
         DC    S(APDFLT)            ALIGNMENT WARNING
         AR    15,11               COMPUTE THE ADDRESS
         MVC   4(2,2),0(15)        COPY THE LENGTH
         LA    15,2(,15)
         ST    15,0(,2)
         OI    6(2),X'C0'          NOTE DSNAME PRESENT & QUALIFIED
         MVC   8(8,2),HLDSN+8      COPY MEMBER ADDRESS, LENGTH AND FLAG
         NOPR  0                   ** DEBUG FREEZE POINT **
         B     ALLOC200
ALLOC190 DC    0H'0'
         TM    FLAG,QUALIFIED      TEST IF SYSIN IS FULLY QUALIFIED
         BO    ALLOC600            BR IF SO
         LA    2,HLDSN             USE SYSIN
ALLOC200 L     1,0(,2)             LOAD ADDRESS OF THE DSN
         CLI   0(1),C'*'           TERMINAL?
         BNE   ALLOC300            NO
         L     1,=A(AUT)           PREPARE THE AUT DYNALLOC SKELETON
         MVC   DYNPARM(AUTL),0(1)   TO BE USED FOR SYSTERM
         MVC   (AUTTXT06-AUT)+DYNPARM,=AL2(DALRECFM)
         MVC   (AUTTXT07-AUT)+DYNPARM,=AL2(DALLRECL)
         MVC   (AUTTXT08-AUT)+DYNPARM,=AL2(DALDSORG)
         B     ALLOC500
ALLOC300 MVC   (ATXT05-A+6)+DYNPARM(L'APPRIME),APPRIME  INITIALIZE
         MVC   (ATXT06-A+6)+DYNPARM(L'APSECND),APSECND   SPACE AMOUNTS
         LA    14,(ADSN-A)+DYNPARM
         L     0,0(,2)             LOAD ADDRESS OF THE DATA SET NAME
         LH    1,4(,2)             LOAD LENGTH
         LR    15,1                COPY LENGTH TO REG 15
         MVCL  14,0                COPY DSN TO DYNPARM
         TM    6(2),X'40'          FULLY QUALIFIED?
         BO    ALLOC400
         MVI   0(14),C'.'          ADD STANDARD SUFFIX TO THE NAME
         MVC   1(L'APSUFFIX,14),APSUFFIX
ALLOC400 TM    8+6(2),X'80'        MEMBER NAME?
         BZ    ALLOC500            NO
         L     0,8(,2)             LOAD ADDRESS OF THE MEMBER NAME
         LH    1,8+4(2)            LOAD THE LENGTH
         LA    14,(AMEMB-A)+DYNPARM  COPY MEMBER TO DYNPARM
         LR    15,1
         MVCL  14,0
         MVC   ((AMEMB-A)-6)+DYNPARM(2),=AL2(DALMEMBR)
ALLOC500 LA    1,XPDL              FREE THE PROMPTING PDL
         BAS   14,FREEPDL
         B     ALLOC700
ALLOC600 ICM   1,B'1111',APPCL     LOAD ADDRESS OF THE PROMPTING PCL
         BZ    EXIT12              BR IF NO PROMPTING PCL
         BAS   14,PROMPT
         LTR   15,15               TEST PARS RC
         BNZ   EXIT12              OOPS
         L     2,XPDL              LOAD ADDRESS OF THE PDL
         LA    2,TERMDSN-TERMPDL(,2)  LOAD ADDRESS OF THE DSN
         ICM   0,B'1111',0(2)      DATA SET NAME?
         BNZ   ALLOC200            YES
         B     EXIT12              OOPS
ALLOC700 TM    APRECFM,X'FF'       NEW DATA SET POSSIBLE?
         BZ    *+L'*+4             NO
         OI    FLAGS,NEWDS         SET NEW DATA SET FLAG
         LA    1,DYNPARM           ALLOCATE THE DATA SET
         BASLONG 14,DYNALLOC
         LTR   15,15               OK?
         BNZ   EXIT12              NO
         TM    APRECFM,X'FF'       OUTPUT DATA SET?
         BZ    ALLOC740            NO
         LA    0,DDTERM-PPL        IS THIS SYSTERM?
         CH    0,APDD
         BNE   ALLOC710            NO
         LH    15,APDSN            LOAD OFFSET OF THE PDE
         AR    15,10               COMPUTE ADDRESS OF THE PDE
         L     15,0(,15)           LOAD ADDRESS OF THE DATA SET NAME
         CLI   0(15),C'*'          TERM(*)?
         BE    ALLOC740            YES, SKIP THE DSORG TEST
ALLOC710 MVC   12(2,13),(ADSORG-A)+DYNPARM  COPY DSORG TO WORK AREA
         OC    12(2,13),12(13)     NO DSORG IS SEQUENTIAL
         BZ    ALLOC720
         NC    12(2,13),=AL1(255-DCBDSGU,X'FF') REMOVE UNUSABLE ATTR
         CLC   12(2,13),=AL1(DCBDSGPS,0)  SEQUENTIAL?
         BE    ALLOC720            YES
         CLC   12(2,13),=AL1(DCBDSGPO,0)  PARTITIONED?
         BE    ALLOC730            YES
         LA    0,L'ADSN            INIT MTINSRTS WITH THE DATA SET NAME
         LA    1,(ADSN-A)+DYNPARM   TO INDICATE THE DSORG IS UNKNOWN
         STM   0,1,MTINSRTS
         L     0,=C'MSG7'
         BASLONG 14,IKJEFF02
*        B     EXIT12
         B     ALLOC600
ALLOC720 TM    (AMEMB-A)+DYNPARM,255-C' '  SEQUENTIAL DATA SET WITH A
         BZ    ALLOC740                     MEMBER NAME?  NO
         LA    0,L'ADSN            INIT MTINSRTS WITH THE DATA SET NAME
         LA    1,(ADSN-A)+DYNPARM
         STM   0,1,MTINSRTS
         L     0,=C'MSG8'
         BASLONG 14,IKJEFF02
*        B     EXIT12
         B     ALLOC600
ALLOC730 TM    (AMEMB-A)+DYNPARM,255-C' '  PDS.  MEMBER SPECIFIED?
         BNZ   ALLOC740                    YES, OK
         LA    0,L'ADSN            INIT MTINRTS WITH THE
         LA    1,(ADSN-A)+DYNPARM   DATA SET NAME
         STM   0,1,MTINSRTS
         L     0,=C'MSG9'
         BASLONG 14,IKJEFF02
*        B     EXIT12
         B     ALLOC600
ALLOC740 DC    0H'0'
         LH    15,APDD             LOAD DDNAME OFFSET
         LA    0,DDASMOPT-PPL      LOAD OFFSET FOR ASMAOPT
         CR    0,15                DO WE JUST ALLOCATE ASMAOPT?
         BNE   ALLOC900            NO
         TM    (AMEMB-A)+DYNPARM,255-C' '   DID WE ALLOCATE A PDS?
         BZ    ALLOC800            NO
         LA    0,(ADDN-A)+DYNPARM   VERIFY MEMBER
         LA    1,(AMEMB-A)+DYNPARM   IN DATA SET
         BAS   14,TESTMEMB
         LTR   15,15               TEST RC
         BZ    ALLOC800            OK
         LA    1,ASMPARM           WRITE MESSAGE FROM TESTMEMB
         BASLONG 14,PUTLINE
         B     EXIT12              AND QUIT, HARD
ALLOC800 LH    15,APDD             RELOAD THE ASMAOPT DD OFFSET
ALLOC900 AR    15,11
         MVC   0(8,15),(ADDN-A)+DYNPARM COPY ALLOCATED DDNAME TO DDLIST
ALLOC999 BXLE  3,4,ALLOC100
         DROP  3                   KILL APARM ADDRESSABILITY
         LA    2,HLLIBDS           LOAD ADDRESS OF THE LIB D.S. PDE
         TM    6(2),X'80'          LIB(...) SPECIFIED?
         BZ    LIBOK               NO
ALLOCLIB ICM   0,B'1111',0(2)      LOAD ADDRESS OF THE DSNAME
         BZ    EXIT12              HUH?
         LH    1,4(,2)             LOAD THE LENGTH
         L     15,=A(A)
         MVC   DYNPARM(AL),0(15)   INIT DYNPARM
         LA    14,(ADSN-A)+DYNPARM COPY THE LIBRARY DATA SET NAME
         LR    15,1                 TO DYNPARM
         MVCL  14,0
         LA    1,DYNPARM           ALLOCATE A SYSLIB
         BASLONG 14,DYNALLOC
         LTR   15,15               OK?
         BNZ   EXIT12              NO
         MVC   12(2,13),(ADSORG-A)+DYNPARM  VERIFY
         NC    12(2,13),=AL1(255-DCBDSGU,255)  DATA SET
         CLC   12(2,13),=AL1(DCBDSGPO,0)        IS PARTITIONED
         BE    LIBPO
         LA    0,L'ADSN            PREPARE MTINSRTS
         LA    1,(ADSN-A)+DYNPARM
         STM   0,1,MTINSRTS
         L     0,=C'MS10'          WRITE DATA SET CAN'T BE USED
         BASLONG 14,IKJEFF02
         B     EXIT12
LIBPO    DC    0H'0'
         LA    0,16                SAVE THE DD NAME
         BAS   14,GETMAIN
         MVC   4(8,1),(ADDN-A)+DYNPARM
         L     15,LIBLIST+4        ADD IT TO THE SYSLIB LIST
         ST    1,0(,15)
         ST    1,LIBLIST+4
         XC    0(4,1),0(1)
         L     2,24(,2)            LOAD ADDRESS OF THE NEXT LIB DSN PDE
         N     2,=A(X'FFFFFF')
         BNZ   ALLOCLIB            BR IF NOT END OF LIST
         L     2,LIBLIST           LOAD ADDRESS OF THE FIRST DD NAME
         MVC   DDSYSLIB,4(2)
         SR    3,3
         LA    2,LIBLIST           LOAD ADDRESS OF THE FIRST DD NAME
COUNTLIB ICM   2,B'1111',0(2)      LOAD ADDRESS OF THE NEXT DD
         BZ    CONCAT              BR IF THE END OF THE CHAIN
         LA    3,1(,3)
         B     COUNTLIB
CONCAT   CH    3,=H'1'             1 DATA SET?
         BE    LIBOK               YES
         LA    0,MAXLIB            VERIFY WE CAN CONCATENATE THE
         CR    3,0                  DATA SETS
         BNH   BUILDCC             YES WE CAN!
         L     0,=C'MSG6'
         BASLONG 14,IKJEFF02
         B     EXIT12
BUILDCC  DC    0H'0'
         L     1,=A(CC)            COPY THE DYNALLOC SKELETON TO
         MVC   DYNPARM(CCL),0(1)    CONCATENATE DD STATEMENTS
         STH   3,((CCTXT01-CC)+2)+DYNPARM  STORE THE NUMBER OF DDS
         L     1,LIBLIST           LOAD ADDRESS OF THE FIRST DD
         LA    3,DYNPARM+CCL       LOAD ADDRESS OF THE FIRST DD ENTRY ->
                                    IN THE CONCAT PARM DATA
ADDDD    LA    0,8                 STORE THE LENGTH
         STH   0,0(,3)
         MVC   2(8,3),4(1)         COPY THE DD NAME
         LA    3,10(,3)            COMPUTE ADDRESS OF THE NEXT DD
         ICM   1,B'1111',0(1)      LOAD ADDRESS OF THE NEXT DD
         BNZ   ADDDD
         LA    1,DYNPARM           ALL THE DD NAMES HAVE BEEN COPIED  ->
                                    TO THE CONCAT PARM LIST
         BASLONG 14,DYNALLOC
         LTR   15,15               OK?
         BNZ   EXIT12              NO
* BUILD THE ASSEMBLER PARM DATA
LIBOK    DC    0H'0'
         LH    0,HLPRINT           LOAD THE PRINT KEYWORD INDEX
         CH    0,=H'1'             NOPRINT?
         BNE   PRINTOK             NO
         L     1,=A(ADUMMY)        COPY THE DYNALLOC SKELETON TO
         MVC   DYNPARM(ADUML),0(1)  ALLOCATE A DUMMY DATA SET
         LA    1,DYNPARM
         BASLONG 14,DYNALLOC
         LTR   15,15               OK?
         BNZ   EXIT12              NO
         MVC   DDSYSPRT,(ADDDN-ADUMMY)+DYNPARM
PRINTOK  MVC   ASMPARM+2(L'BASEPARM),BASEPARM  START IT OFF WITH NODECK
         LA    14,ASMPARM+2+L'BASEPARM
         LA    2,GENPARM           LOAD ADDRESS OF THE GENPARM TABLE
NEXTPARM LH    3,2(,2)             LOAD OFFSET OF THE PDE
         AR    3,10                COMPUTE THE PDE ADDRESS
         LH    3,0(,3)             LOAD THE PDE VALUE
         CH    3,4(,2)             PDE MATCH THIS PARM?
         BNE   SKIPPARM            NO
         MVI   0(14),C','          INSEERT A ,
         LA    14,1(,14)
         LH    15,6(,2)            LOAD THE LENGTH
         LA    0,8(,2)             LOAD TEXT ADDRESS
         LR    1,15                COPY THE PARM
         MVCL  14,0
SKIPPARM SR    0,0                 LOAD OFFSET OF THE NEXT TABLE ENTRY
         ICM   0,B'0011',0(2)
         BZ    XRPARM              0, DONE
         AR    2,0                COMPUTE THE ADDRESS OF THE NEXT ENTRY
         B     NEXTPARM
XRPARM   LH    0,HLXREF            XREF SPECIFIED?
         CH    0,=H'2'
         BNE   ADDMXREF            NO
*                         ----+-
         MVC   0(6,14),=C',XREF('  START IT OFF
         LA    14,6(,14)
         LH    1,HLXSHORT          SHORT OR FULL?
         LA    15,5
         LA    0,=C'SHORT'
         CH    1,=H'1'
         BE    *+L'*+8
         LA    15,4
         LA    0,=C'FULL'
         LR    1,15
         MVCL  14,0                ADD SHORT OR FULL
         LH    0,HLXSHORT          XREF(SHORT)?                    P001
         CH    0,=H'1'                                             P001
         BNE   XRCLOSE             NO                              P001
         LH    1,HLXUREF           UNREFS?
         CH    1,=H'1'
         BNE   *+L'*+10            NO
*                         ----+--
         MVC   0(7,14),=C',UNREFS' ADD UNREFS
         LA    14,7(,14)
XRCLOSE  MVI   0(14),C')'          CLOSE XREF(...)                 P001
         LA    14,1(,14)
ADDMXREF LH    0,HLMXREF           MXREF WITH NO ADDED KEYWORD?
         CH    0,=H'2'             NO
         BNE   NOMXREF
         ICM   0,B'0011',HLMX
         BNZ   NOMXREF
         MVC   0(6,14),=C',MXREF'  ADD MXREF
         LA    14,6(,14)
NOMXREF  DC    0H'0'
ADDXOBJ  LH    0,HLXOBJ            LOAD THE KEYWORD INDEX
         LTR   0,0                 SOMETHING SPECIFIED?
         BZ    SKIPXOBJ            NO
         CH    0,=H'2'             NOXOBJ OR NOGOFF?
         BNH   SKIPXOBJ            YES, ALREADY ENTERED
         LH    0,HLXOBAD           ADATA OR NOADATA SPECIFIED?
         LTR   0,0
         BNZ   SKIPXOBJ            YES, ALREADY FILLED IN
         MVC   0(5,14),=C',XOBJ'   ADD XOBJ
         LA    14,5(,14)
SKIPXOBJ DC    0H'0'
ADDLIST  LH    0,HLLIST            LOAD THE LIST KEYWORD INDEX
         CH    0,=H'2'             LIST SPECIFIED?
         BNE   ADDLC               NO
         L     1,HLLSIZE           LOAD ADDRESS OF THE AMOUNT
         MVC   0(6,14),=C',LIST('
         MVC   6(3,14),0(1)        COPY THE VALIDATED TEXT
         MVI   9(14),C')'
         LA    14,10(,14)          UPDATE THE POINTER
ADDLC    TM    HLLC+6,X'80'        LINECOUNT SPECIFIED?
         BZ    STORLEN             NO
*                          ----+----1-
         MVC   0(11,14),=C',LINECOUNT('  ADD THE KEYWORD
         LA    14,11(,14)          UPDATE THE POINTER
         LH    15,HLLC+4           COPY
         LR    1,15                 THE
         L     0,HLLC+0              VALUE
         MVCL  14,0
         MVI   0(14),C')'          TERMINATE THE PARAMETER
         LA    14,1(,14)
STORLEN  LA    1,ASMPARM+2         COMPUTE THE LENGTH
         SR    14,1
         STH   14,ASMPARM
         LA    0,DDSIZE            INSERT THE LENGTH OF THE DD LIST
         STH   0,DDLIST
* RUN ASM90 HERE
         L     0,=C'MSG1'
         BASLONG 14,IKJEFF02
         LINK  SF=(E,LINKASM),MF=(E,PARMLIST),                        ->
               PARAM=(ASMPARM,DDLIST),VL=1
         LR    5,15
         BASLONG 14,LISTTERM
         LR    15,5
         LR    5,15                SAVE THE RETURN CODE
         LH    1,HLRC              LOAD THE RC OPTION
         DROP  10                  KILL PDL ADDRESSABILITY
         LR    10,15               DESTROY THE PDL POINTER
         LA    0,2
         CR    0,1                 RC SPECIFIED?
         BNE   EXIT                NO
         ST    15,DYNRC
         L     0,=A(X'80000000'+L'DYNRC)
         LA    1,DYNRC
         STM   0,1,MTINSRTS
         L     0,=C'MSG2'
         BASLONG 14,IKJEFF02
         B     EXIT
* A SERIOUS ERROR HAS BEEN ENCOUNTERED.
EXIT12   LA    10,12
         XC    STACKPB,STACKPB
         STACK MF=(E,MYIOPL),DELETE=PROC,ECB=PUTLECB,PARM=STACKPB,    ->
               ENTRY=CALLSTCK
CALLSTCK L     15,CVTPTR
         ICM   15,B'1111',CVTSTCK-CVTMAP(15)
         BZ    STCKLINK
         CALL  (15),MF=(E,(1))
         B     TCLEARQ
STCKLINK LINK  SF=(E,LINKSTCK),MF=(E,(1))
TCLEARQ  TCLEARQ INPUT
EXIT     LA    1,PDLADDR
         BAS   14,FREEPDL
         ICM   1,B'1111',LIBLIST
         BZ    X0100
         ICM   0,B'1111',0(1)
         BZ    X0100
         L     15,=A(DC)
         MVC   DYNPARM(DCL),0(15)
         MVC   (DCDDN-DC)+DYNPARM,4(1)
         LA    1,DYNPARM
         BASLONG 14,DYNALLOC
X0100    ICM   2,B'1111',ALIST
         BZ    X0200
         MVC   ALIST,0(2)
         L     1,=A(U)
         MVC   DYNPARM(UL),0(1)
         MVC   (UDDN-U)+DYNPARM,4(2)
         LA    1,DYNPARM
         BASLONG 14,DYNALLOC
         B     X0100
X0200    BAS   14,FREEALL
         L     13,4(,13)
          LHI   0,WASIZE
         FREEMAIN R,LV=(0),A=(11)
         LR    15,10
         RETURN (14,12),RC=(15)
         EJECT
* INVOKE IKJPARS TO PROMPT FOR A MISSING PARAMETER
         CNOP  0,8
PROMPT   BASR  15,0
         SAVE  (14,1),,PROMPT      SAVE REGISTERS
         LA    15,72(,13)          ADD NEW SAVE AREA TO THE
         ST    13,4(,15)            SAVE AREA CHAIN
         ST    15,8(,13)
         LR    13,15               PREPARE NEW SAVE AREA POINTER
         ST    1,PPLPCL            SAVE THE PCL ADDRESS
         MVC   ASMPARM(5),CMD      PREPARE A PSEUDO COMMOND BUFFER
         LA    0,ASMPARM
         ST    0,PPLCBUF           STORE THE COMMAND BUFFER ADDRESS
         LA    0,XPDL              STORE THE ADDRESS OF THE NEW
         ST    0,PPLANS             PDL ADDRESS
*        LINK  SF=(E,LINKPARS),MF=(E,(11))  CALL IKJPARS TO OBTAIN A  ->
                                             PARAMETER
         LINKPARS MF=(E,(11))
         L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA
         RETURN (14,1),RC=(15)     RESTORE REGISTERS & RETURN
         EJECT
* FREE THE PDL WHOSE ADDRESS IS IN THE WORD SPECIFIED BY REG 1
         CNOP  0,8
FREEPDL  BASR  15,0
         SAVE  (14,1),,FREEPDL     SAVE REGISTERS
         IKJRLSA (1)               FREE THE PDL
         RETURN (14,1)             RESTORE REGISTERS & RETURN
         EJECT
* Allocate a small amount of storage
         DC    0D'0'
CPAMT    EQU   1*1024              BYTES IN A SINGLE CELL POOL
GETMAIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
*        USING *,12                ESTABLISH ADDRESSABILITY
         USING CPOOL,10
         SAVE  (14,12),,GETMAIN    SAVE REGISTERS
*        LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12
         LR    2,0                 COPY AMOUNT OF STORAGE TO REG 2
         AHI   2,7                 ROUND REQUEST UP TO AN 8 BYTE
         N     2,ROUND8             MULTIPLE
GM0100   LA    10,CPLIST-(CPNEXT-CPOOL)  LOAD ADDR OF A DUMMY CPOOL
GM0200   ICM   10,B'1111',CPNEXT   LOAD ADDR OF THE NEXT CPOOL
         JZ    GM0300              BR IF END OF LIST
         C     2,CPLEFT            COMPARE REQUESTED AMOUNT WITH      ->
                                    FREE STORAGE IN THIS CPOOL
         JH    GM0200              BR IF NOT ENOUGH STORAGE IN THIS   ->
                                    CPOOL
         MVC   24(4,13),CPNEXTA    REPLACE CALLER'S REG 1 W/ CURRENT  ->
                                    FREE SPACE ADDRESS IN THIS CPOOL
         L     0,CPLEFT            LOAD FREE BYTES IN THIS CPOOL
         SR    0,2                 SUBTRACT AMOUNT OF STORAGE WE      ->
                                    JUST ALLOCATED
         ST    0,CPLEFT            UPDATE FREE SPACE AMOUNT
         A     2,CPNEXTA           ADD ADDRESS OF STORAGE WE JUST     ->
                                    ALLOCATED TO AMOUNT OF STORAGE    ->
                                     WE JUST ALLOCATED
         ST    2,CPNEXTA           UPDATE ADDRESS OF FREE STORAGE
         J     GM0800              AND EXIT
GM0300   LHI   0,CPAMT-(CPSTART-CPOOL)  SET REG 0 = FREE STORAGE IN A ->
                                         SINGLE CPOOL
GM0400   CR    0,2                 COMPARE W/ AMOUNT WE NEED
         JNL   GM0500              BR IF ENOUGH
         AHI   0,CPAMT             ADD CPAMT TO REG 0
         J     GM0400              CONTINUE
GM0500   AHI   0,CPSTART-CPOOL     SET REG 0 TO A K MULTIPLE
         LR    3,0                 COPY AMOUNT OF STORAGE TO REG 3
         TAM   ,                   TEST ADDRESSING MODE
         JNZ   GM0600              BR IF NOT AMODE 24
         GETMAIN RU,LV=(0)         ALLOCATE STORAGE
         J     GM0700
GM0600   GETMAIN RU,LV=(0),LOC=(31,ANY)  ALLOCATE STORAGE
GM0700   LR    10,1                COPY ADDRESS TO REG 11
*        XC    0(CPSTART-CPOOL,11),0(11)  CLEAR THE HEADER
         ST    3,CPSIZE            STORE THE SIZE
         LA    0,CPSTART
         ST    0,CPNEXTA
         AHI   3,-(CPSTART-CPOOL)  SUBTRACT HEADER SIZE FROM          ->
                                    ALLOCATED STORAGE
         ST    3,CPLEFT            STORE FREE SPACE SIZE
         MVC   CPNEXT,CPLIST       ADD THE NEW SUBPOOL TO THE
         ST    10,CPLIST            SUBPOOL CHAIN
         J     GM0100              AND RESTART ALLOCATION
GM0800   RETURN (14,12),T          RESTORE REGS & RETURN
         SPACE 5
         CNOP  0,8
FREEALL  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
*        USING *,12                ESTABLISH ADDRESSABILITY
         SAVE  (14,12),,FREEALL    SAVE REGISTERS
*        LR    12,15               COPY THE ENTRY POINT ADDR TO REG 12
FR0100   ICM   10,B'1111',CPLIST   LOAD ADDR OF THE NEXT CPOOL
         JZ    FR0200              EXIT IF DONE
         MVC   CPLIST,CPNEXT       REMOVE CURRENT CPOOL FROM THE CHAIN
         L     0,CPSIZE            LOAD SIZE
         FREEMAIN RU,LV=(0),A=(10) FREE THE CPOOL
         J     FR0100              GO FREE THE NEXT CPOOL
FR0200   RETURN (14,12),T          RESTORE REGS & RETURN
         SPACE 1
ROUND8   DC    F'-8'
         DROP  10
         CNOP  0,8
TESTLDD  SAVE  (14,12),,*          SAVE REGISTERS
         LR    12,15               COPY TESTLDD ADDRESS TO REG 12
         LA    0,TESTLDD-HLASM     LOAD OFFSET OF TESTLDD IN HLASM
         SLR   12,0                COMPUTE ADDRESS OF HLASM
         L     11,4(,1)            LOAD ADDRESS OF THE HLASM WORK AREA
         LR    15,13               ADD A
         LA    13,SAVEAREA+72       NEW SAVE AREA TO
         ST    15,4(,13)             THE
         ST    13,8(,15)              SAVE AREA CHAIN
         L     2,0(,1)             LOAD ADDRESS OF THE PDE
         LA    14,DDSYSLIB         COMPUTE ADDRESS OF A WORK AREA
         LA    15,8                LOAD WORK AREA LENGTH
         L     0,0(,2)             LOAD ADDRESS OF THE LIBRARY DD
         LH    1,4(,2)             LOAD LENGTH OF THE LIBRARY DD
         ICM   1,B'1000',=C' '     LOAD MVCL FILL CHARACTER
         MVCL  14,0                COPY LIBRARY DD TO WORK AREA
         DEVTYPE DDSYSLIB,12(,13)  VERIFY LIBRARY DD ALLOCATED
         LTR   15,15               OK?
         BZ    TLDD0200            YES
         L     0,=C'MS11'          ISSUE MSG HLA011A
         BASLONG 14,IKJEFF02
         LA    15,8                LOAD THE RETURN CODE
TLDD0200 L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA
         RETURN (14,12),RC=(15)   RESTORE REGISTERS & RETURN TO IKJPARS
         EJECT
* IKJPARS VALIDITY CHECK ROUTINE TO CHECK THE ASSEMBLER SYSIN DATA SET
* AND ALLOCATE IT.  IF THE ALLOCATION FAILS WE CAN RETURN TO IKJPARS
* TO DIRECT IT TO PROMPT THE TERMINAL OPERATOR FOR A VALID DATA
* DATA SET NAME.
         SPACE 1
         CNOP  0,8
ALLOCASM SAVE  (14,12),,ALLOCASM
* PREPARE ADDRESSABILITY
         LA    0,ALLOCASM-HLASM
         LR    12,15
         SR    12,0
         L     11,4(,1)
         LA    15,SAVEAREA+72      ADD A NEW SAVE AREA TO
         ST    13,4(,15)            THE SAVE AREA CHAIN
         ST    15,8(,13)
         LR    13,15
         NI    FLAGS,255-QUALIFIED RESET QUALIFIED
         L     2,0(,1)             LOAD ADDRESS OF THE PDE
         L     15,=A(A)
         MVC   DYNPARM(AL),0(15)   ALLOCATE THE DATA SET
         LA    14,(ADSN-A)+DYNPARM
         LH    15,4(2)
         NI    6(2),X'C0'          MAKE SURE ONLY IBM DEFINED FLAGS   ->
                                    REMAIN
         LTR   15,15               LENGTH = 0?
         BNZ   AASM0050            NO
         LH    15,XASM             LOAD THE LENGTH
         LA    0,XASM+2            LOAD ADDRESS OF THE DSNAME
         ST    0,0(,2)             STORE THE ADDRESS OF THE DSNAME
         STH   15,4(,2)            STORE THE LENGTH
         OI    6(2),X'C1'          NOTE IT'S PRESENT & QUALIFIED
AASM0050 DC    0H'0'
         L     0,0(,2)
         LR    1,15
         MVCL  14,0
         TM    6(2),X'40'          FULLY QUALIFIED DATA SET NAME?
         BZ    AASM0100            NO
         OI    FLAGS,QUALIFIED     NOTE THE INPUT IS FULLY QUALIFIED
         B     AASM0300
AASM0100 LH    1,4(,2)             LOAD THE DSNAME LENGTH
         CHI   1,44-9              TEST MAX LENGTH
         BNH   AASM0200            OK
         LA    0,L'ADSN
         LA    1,(ADSN-A)+DYNPARM
         STM   0,1,MTINSRTS
         L     0,=C'MSG4'
         BASLONG 14,IKJEFF02
         B     AASM0500            AND EXIT WITH RC = 8
AASM0200 MVC   0(4,14),=C'.ASM'    ADD THE STANDARD QUALIFIER
AASM0300 TM    8+6(2),X'80'        MEMBER SPECIFIED?
         BZ    AASM0400            NO
         OI    FLAGS,QUALIFIED     INDICATE SOURCE NAME FULLY QUALIFIED
         L     0,8(,2)             LOAD ADDRESS OF THE MEMBER
         LH    1,8+4(,2)           LOAD LENGTH
         LA    14,(AMEMB-A)+DYNPARM  COPY MEMBER NAME TO DYNPARM
         LR    15,1
         MVCL  14,0
         MVC   ((AMEMB-A)+DYNPARM)-6(2),=AL2(DALMEMBR)
AASM0400 LA    1,DYNPARM           ALLOCATE THE DATA SET
         BASLONG 14,DYNALLOC
         LTR   15,15               OK?
         BNZ   AASM0500            NO
         MVC   DDSYSIN,(ADDN-A)+DYNPARM  SAVE THE ALLOCATED DD NAME
         MVC   12(2,13),(ADSORG-A)+DYNPARM
         NC    12(2,13),=AL1(255-DCBDSGU,255)
         CLC   12(2,13),=AL1(DCBDSGPS,0)  DATA SET SEQUENTIAL?
         BE    AASM0410                   YES
         CLC   12(2,13),=AL1(DCBDSGPO,0)  DATA SET PARTITIONED?
         BE    AASM0430                   YES
         L     0,=C'MSG7'          DSORG UNKNOWN, WRITE THE DIAGNOSTIC
         B     AASM0450
AASM0410 TM    (AMEMB-A)+DYNPARM,255-C' '  MEMBER SPECIFIED?
         BZ    AASM0420                    NO, USE THE DATA SET
         L     0,=C'MSG8'          DSORG PO, NO MEMBER
         B     AASM0450
AASM0420 SR    15,15               SET RC = 0
         B     AASM0600            EXIT DSN OK
AASM0430 TM    (AMEMB-A)+DYNPARM,255-C' '  MEMBER SPECIFIED
         BNZ   AASM0440                    YES
         L     0,=C'MSG9'                  WRITE THE DIAGNBOSTIC
         B     AASM0450
AASM0440 DC    0H'0'               MEMBER PRESENT & DATA SET IS PO
         LA    0,DDSYSIN           TEST IF
         LA    1,(AMEMB-A)+DYNPARM  MEMBER IN DATA SET
         BAS   14,TESTMEMB
         LTR   15,15               TEST THE RC
         BZ    AASM0600            0, DSN OK
         LA    1,ASMPARM           WRITE THE DIAGNOSTIC FROM TESTMEMB
         BASLONG 14,PUTLINE
         B     AASM0500
AASM0450 LA    14,L'ADSN
         LA    15,(ADSN-A)+DYNPARM
         STM   14,15,MTINSRTS
         BASLONG 14,IKJEFF02
         B     AASM0500
         TM    (AMEMB-A)+DYNPARM,255-C' '  MEMBER REQUESTED?
         BZ    AASM0600            NO
         LA    0,DDSYSIN           TEST IF
         LA    1,(AMEMB-A)+DYNPARM  MEMBER IN DATA SET
         BAS   14,TESTMEMB
         LTR   15,15               TEST BLDL RC
         BZ    AASM0600            OK
         LA    1,ASMPARM           WRITE THE MESSAGE BUILT BY TESTMEMB
         BASLONG 14,PUTLINE
AASM0500 LA    15,8                SET RC TO PROMPT FOR A BETTER NAME
AASM0600 L     13,4(,13)
         RETURN (14,12),RC=(15)
         EJECT
* IKJPARS VALIDITY CHECK ROUTINE TO VALIDATE THE LIST SIZE
         CNOP  0,8
TSTLSIZE SAVE  (14,12),,TSTLSIZE   SAVE REGISTERS
* PREPARE ADDRESSABILITY
         LA    0,TSTLSIZE-HLASM
         LR    12,15
         SR    12,0
         LA    15,4                INIT THE RETURN CODE
         L     2,0(,1)             LOAD ADDRESS OF THE PDE
         LH    3,4(,2)             LOAD DATA LENGTH
         CH    3,=H'3'             3 BYTES?
         BNE   TSTL0200            NO
         L     1,0(,2)             LOAD ADDRESS OF THE DATA
         CLC   =C'121',0(1)        121?
         BE    TSTL0100            OK
         CLC   =C'133',0(1)        133?
         BNE   TSTL0200
TSTL0100 SR    15,15               SET RC = 0
TSTL0200 RETURN (14,12),RC=(15)    RETURN TO IKJPARS
         EJECT
         CNOP  0,8
*        LA    0,DDNAME
*        LA    1,MEMBER
*        BAS   14,TESTMEMB
TESTMEMB BASR  15,0
         SAVE  (14,2),,TESTMEMB    SAVE REGISTERS
         MVC   MNAME,0(1)          COPY MEMBER NAME TO BLDL AREA
         L     1,=A(MOPEN)         PREPARE
         MVC   OCPARM,0(1)          OCPARM
         L     1,=A(MDCB)            AND
         MVC   EXCPDCB,0(1)           EXCPDCB
         L     1,20(,13)           LOAD DD NAME ADDRESS FROM REG 0    ->
                                    SLOT IN THE SAVE AREA
         MVC   (DCBDDNAM-IHADCB)+EXCPDCB,0(1)  COPY DDNAME TP THE DCB
         OPEN  EXCPDCB,MF=(E,OCPARM)  OPEN THE DCB
         MVC   BLDLPARM,=AL2(1,MSIZE) PREPARE THE ENTRY COUNT AND     ->
                                       ENTRY LENGTH
         BLDL  EXCPDCB,BLDLPARM    MEMBER IN DATA SET?
         LTR   2,15                COPY THE RETURN CODE TO REG 2
         BZ    TSTM0900
*                              ----+---
         MVC   ASMPARM+4(8),=C'HLA005A '  BUILD THE HLA005A MESSAGE
         MVC   ASMPARM+4+8(L'AMEMB),(AMEMB-A)+DYNPARM
         LA    14,ASMPARM+4+8+L'AMEMB
TSTM0100 BCTR  14,0
         TM    0(14),255-C' '
         BZ    TSTM0100
*                          ----+----1-
         MVC   1(11,14),=C' IS NOT IN '
         MVC   1+11(L'ADSN,14),(ADSN-A)+DYNPARM
         LA    14,1+11+L'ADSN(,14)
TSTM0200 BCTR  14,0
         TM    0(14),255-C' '
         BZ    TSTM0200
         LA    14,1(,14)
         LA    1,ASMPARM           COMPUTE THE MESSAGE LENGTH
         SR    14,1
         SLL   14,16               CONVERT THE MESSAGE LENGTH TO AN RDW
         STCM  14,B'1111',0(1)     STORE THE RDW
TSTM0900 L     1,=A(MCLOSE)        CLOSE THE DCB
         MVC   OCPARM,0(1)
         CLOSE EXCPDCB,MF=(E,OCPARM)
         LR    15,2                COPY THE BLDL RC TO REG 15
         RETURN (14,2),RC=(15)     RESTORE REGISTERS & RETURN
         SPACE 1
LINKPARS LINK  SF=L,EP=IKJPARS
LINKPUTL LINK  SF=L,EP=IKJPUTL
LINKDF   LINK  SF=L,EP=IKJEFF18
LINKASM  LINK  SF=L,EP=ASMA90
LINKSTCK LINK  SF=L,EP=IKJSTCK
         SPACE 1
         DC    0D'0'
         LTORG ,
         SPACE 1
BASEPARM DC    C'NODECK'
         SPACE 1
CMD      DC    AL2(5,1),C'Z'
         SPACE 1
* GENPARM MUST BE ADDRESSABLE; IT DEFINES THE END OF ADDRESSABILITY
GENPARM  DC    AL2(PARM2-*,HLTERM-HLPDL,1,6),C'NOTERM'
PARM2    DC    AL2(PARM3-*,HLTERM-HLPDL,2,4),C'TERM'
PARM3    DC    AL2(PARM4-*,HLRENT-HLPDL,1,6),C'NORENT'
PARM4    DC    AL2(PARM5-*,HLRENT-HLPDL,2,4),C'RENT'
PARM5    DC    AL2(PARM6-*,HLTEST-HLPDL,1,6),C'NOTEST'
PARM6    DC    AL2(PARM7-*,HLTEST-HLPDL,2,4),C'TEST'
PARM7    DC    AL2(PARM8-*,HLESD-HLPDL,1,5),C'NOESD'
PARM8    DC    AL2(PARM9-*,HLESD-HLPDL,2,3),C'ESD'
PARM9    DC    AL2(PARM10-*,HLRLD-HLPDL,1,5),C'NORLD'
PARM10   DC    AL2(PARM12-*,HLLIST-HLPDL,1,6),C'NOLIST'
PARM12   DC    AL2(PARM13-*,HLOBJ-HLPDL,1,8),C'NOOBJECT'
PARM13   DC    AL2(PARM14-*,HLOBJ-HLPDL,2,6),C'OBJECT'
PARM14   DC    AL2(PARM15-*,HLRLD-HLPDL,2,3),C'RLD'
PARM15   DC    AL2(PARM16-*,HLDXREF-HLPDL,1,7),C'NODXREF'
PARM16   DC    AL2(PARM17-*,HLDXREF-HLPDL,2,5),C'DXREF'
PARM17   DC    AL2(PARM18-*,HLXREF-HLPDL,1,6),C'NOXREF'
PARM18   DC    AL2(PARM19-*,HLTHREAD-HLPDL,1,8),C'NOTHREAD'
PARM19   DC    AL2(PARM20-*,HLTHREAD-HLPDL,2,6),C'THREAD'
PARM20   DC    AL2(PARM21-*,HLBATCH-HLPDL,1,7),C'NOBATCH'
PARM21   DC    AL2(PARM22-*,HLBATCH-HLPDL,2,5),C'BATCH'
PARM22   DC    AL2(PARM23-*,HLADATA-HLPDL,2,5),C'ADATA'
PARM23   DC    AL2(PARM24-*,HLADATA-HLPDL,1,7),C'NOADATA'
PARM24   DC    AL2(PARM25-*,HLRXREF-HLPDL,1,7),C'NORXREF'
PARM25   DC    AL2(PARM26-*,HLRXREF-HLPDL,2,5),C'RXREF'
PARM26   DC    AL2(PARM27-*,HLMXREF-HLPDL,1,7),C'NOMXREF'
PARM27   DC    AL2(PARM28-*,HLMX-HLPDL,1,11),C'MXREF(FULL)'
PARM28   DC    AL2(PARM29-*,HLMX-HLPDL,2,13),C'MXREF(SOURCE)'
PARM29   DC    AL2(PARM30-*,HLMX-HLPDL,3,11),C'MXREF(XREF)'
PARM30   DC    AL2(PARM31-*,HLALIGN-HLPDL,1,7),C'NOALIGN'
PARM31   DC    AL2(PARM32-*,HLALIGN-HLPDL,2,5),C'ALIGN'
PARM32   DC    AL2(PARM33-*,HLDBCS-HLPDL,1,6),C'NODBCS'
PARM33   DC    AL2(PARM34-*,HLDBCS-HLPDL,2,4),C'DBCS'
PARM34   DC    AL2(PARM35-*,HLFOLD-HLPDL,1,6),C'NOFOLD'
PARM35   DC    AL2(PARM36-*,HLFOLD-HLPDL,2,4),C'FOLD'
PARM36   DC    AL2(PARM37-*,HLLIBMAC-HLPDL,1,8),C'NOLIBMAC'
PARM37   DC    AL2(PARM38-*,HLLIBMAC-HLPDL,2,6),C'LIBMAC'
PARM38   DC    AL2(PARM39-*,HLXOBAD-HLPDL,1,13),C'XOBJ(NOADATA)'
PARM39   DC    AL2(PARM40-*,HLXOBAD-HLPDL,2,11),C'XOBJ(ADATA)'
PARM40   DC    AL2(PARM41-*,HLXOBJ-HLPDL,1,6),C'NOXOBJ'
PARM41   DC    AL2(PARM42-*,HLXOBJ-HLPDL,2,6),C'NOGOFF'
PARM42   DC    AL2(PARM43-*,HLRA2-HLPDL,1,5),C'NORA2'
PARM43   DC    AL2(PARM44-*,HLRA2-HLPDL,2,3),C'RA2'
PARM44   EQU   PARM43
         SPACE 2
* ALLOCATE A DATA SET.  THE NULL KEYS ARE FILLED IN TO ALLOCATE A NEW
* DATA SET
A        DC    A(X'80000000'+(ARB-A))
ARB      DC   AL1(S99RBEND-S99RB,S99VRBAL,S99NOCNV+S99NOMNT+S99NOMIG,0)
         DC    2AL2(0)
         DC    A(ATXTPP-A,0,0)
* THIS KEY MUST BE FIRST
ATXT02   DC    AL2(DALRTDDN,1,L'ADDN)
ADDN     DC    CL8' '
ATXT01   DC    AL2(DALDSNAM,1,L'ADSN)
ADSN     DC    CL44' '
ATXT09   DC    AL2(*-*,1,2)  DALLRECL
ALRECL   DC    AL2(80)
ATXT04   DC    AL2(DALRTORG,1,L'ADSORG)
ADSORG   DC    AL2(0)
ATXT05   DC    AL2(*-*,1,3),AL3(20)  DALPRIME
ATXT06   DC    AL2(*-*,1,3),AL3(10)  DALSECND
ATXT07   DC    AL2(*-*,1,3),AL3(3200)  DALBLKLN
ATXT08   DC    AL2(*-*,1,1)  DALRECFM
ARECFM   DC    AL1(DCBRECF+DCBRECBR)
ATXT03   DC    AL2(DALSTATS,1,1)
DISP1    DC    AL1(DISPSHR)
ATXT10   DC    AL2(*-*,1,1)  DALNDISP
DISP2    DC    AL1(DISPCAT)
ATXT11   DC    AL2(*-*,1,2)  DALDSORG
         DC    0AL2(0),AL1(DCBDSGPS,0)
ATXT12   DC    AL2(*-*,0)  DALRLSE
ATXT13   DC    AL2(*-*,1,L'AMEMB)   DALMEMBR
AMEMB    DC    CL8' '
ATXT14   DC    AL2(*-*,1,3),AL3(2)  DALDIR
ATXTPP   DC    A(ATXT01-A,ATXT02-A,ATXT03-A,ATXT04-A,ATXT05-A)
         DC    A(ATXT06-A,ATXT07-A,ATXT08-A,ATXT10-A,ATXT11-A)
         DC    A(ATXT12-A,ATXT13-A,ATXT14-A)
         DC    A(X'80000000'+(ATXT09-A))
AL       EQU   *-A
         SPACE 2
ATRM     DC    A(X'80000000'+(ATRMRB-ATRM))
ATRMRB   DC    AL1(S99RBEND-S99RB,S99VRBAL,S99NOCNV,0)
         DC    2AL2(0)
         DC    A(ATRMPP-ATRM,0,0)
* THIS KEY MUST BE FIRST
ATRM01   DC    AL2(DALRTDDN,1,L'ATRMDDN)
ATRMDDN  DC    CL8' '
ATRM02   DC    AL2(DALTERM,0)
ATRMPP   DC    A(ATRM01-ATRM,X'80000000'+(ATRM02-ATRM))
ATRML    EQU   *-ATRM
         SPACE 2
ADUMMY   DC    A(X'80000000'+(ADUMRB-ADUMMY))
ADUMRB   DC    AL1(S99RBEND-S99RB,S99VRBAL,0,0)
         DC    2AL2(*-*),A(ADTXTPP-ADUMMY,0,0)
* THIS KEY MUST BE FIRST
ADTXT01  DC    AL2(DALRTDDN,1,L'ADDDN)
ADDDN    DC    CL8' '
ADTXT02  DC    AL2(DALDUMMY,0)
ADTXTPP  DC    A(ADTXT01-ADUMMY,X'80000000'+(ADTXT02-ADUMMY))
ADUML    EQU   *-ADUMMY
         SPACE 2
AUT      DC    A(X'80000000'+(AUTRB-AUT))
AUTRB    DC    AL1(S99RBEND-S99RB,S99VRBAL,0,0)
         DC    2AL2(0),A(AUTTXTPP-AUT,0,0)
* THIS KEY MUST BE FIRST
AUTTXT05 DC    AL2(DALRTDDN,1,L'AUTDDN)
AUTDDN   DC    CL8' '
AUTTXT01 DC    AL2(DALSTATS,1,1),AL1(DISPNEW)
AUTTXT02 DC    AL2(DALCYL,0)
AUTTXT03 DC    AL2(DALPRIME,1,3),AL3(3)
AUTTXT04 DC    AL2(DALSECND,1,3),AL3(3)
AUTTXT06 DC    AL2(*-*,1,1),AL1(DCBRECF+DCBRECBR+DCBRECCA)  DALRECFM
AUTTXT07 DC    AL2(*-*,1,2),AL2(121)                        DALLRECL
AUTTXT08 DC    AL2(*-*,1,2),AL1(DCBDSGPS,0)                 DALDSORG
AUTTXTPP DC    A(AUTTXT01-AUT,AUTTXT02-AUT,AUTTXT03-AUT,AUTTXT04-AUT)
         DC    A(AUTTXT06-AUT,AUTTXT07-AUT,AUTTXT08-AUT)
         DC    A(X'80000000'+(AUTTXT05-AUT))
AUTL     EQU   *-AUT
         SPACE 2
CC       DC    A(X'80000000'+(CCRB-CC))
CCRB     DC    AL1(S99RBEND-S99RB,S99VRBCC,0,0)
         DC    2AL2(0),A(CCTXTPP-CC,0,0)
CCTXTPP  DC    A(X'80000000'+(CCTXT01-CC))
CCTXT01  DC    AL2(DCCDDNAM,*-*)
CCL      EQU   *-CC
MAXLIB   EQU   (256-CCL)/10
         SPACE 2
DC       DC    A(X'80000000'+(DCRB-DC))
DCRB     DC    AL1(S99RBEND-S99RB,S99VRBDC,0,0)
         DC    2AL2(0),A(DCTXTPP-DC,0,0)
DCTXTPP  DC    A(X'80000000'+(DCTXT01-DC))
DCTXT01  DC    AL2(DDCDDNAM,1,L'DCDDN)
DCDDN    DC    CL8' '
DCL      EQU   *-DC
         SPACE 2
U        DC    A(X'80000000'+(URB-U))
URB      DC    AL1(S99RBEND-S99RB,S99VRBUN,0,0)
         DC    2AL2(0),A(UTXTPP-U,0,0)
UTXTPP   DC    A(X'80000000'+(UTXT01-U))
UTXT01   DC    AL2(DUNDDNAM,1,L'UDDN)
UDDN     DC    CL8' '
UL       EQU   *-U
         SPACE 1
DISPOLD  EQU   X'01'
DISPNEW  EQU   X'04'
DISPSHR  EQU   X'08'
DISPCAT  EQU   X'02'
DISPKEEP EQU   X'08'
         SPACE 1
         PUSH  PRINT
         PRINT NOGEN
MOPEN    OPEN  *-*,MF=L
MCLOSE   CLOSE *-*,MF=L
MDCB     DCB   MACRF=E,DDNAME=FILLMEIN
         POP   PRINT
         SPACE 2
TESTLIST DC    AL4(TERMPCL)
         DC    AL2(HLTERM-HLPDL,HLTERMDS-HLPDL,DDTERM-PPL,121)
         DC    AL1(DCBRECF+DCBRECBR+DCBRECCM)
         DC    CL8'TERMLIST',AL3(5,3)
         DC    AL2(XTLIST-PPL)
TESTL    EQU   *-TESTLIST
         DC    AL4(PRINTPCL)
         DC    AL2(HLPRINT-HLPDL,HLLSTDS-HLPDL,DDSYSPRT-PPL,137)
         DC    AL1(DCBRECV+DCBRECBR+DCBRECCM)
         DC    CL8'ASMLIST',AL3(40,20)
         DC    AL2(XLIST-PPL)
         DC    AL4(ADATAPCL)
         DC    AL2(HLADATA-HLPDL,HLADDS-HLPDL,DDADATA-PPL,4095)
         DC    AL1(DCBRECV+DCBRECBR),CL8'ADATA',AL3(160,75)
         DC    AL2(XADATA-PPL)
         DC    AL4(OBJPCL)
         DC    AL2(HLOBJ-HLPDL,HLOBJDS-HLPDL,DDSYSLIN-PPL,80)
         DC    AL1(DCBRECF+DCBRECBR),CL8'OBJ',AL3(20,10)
         DC    AL2(XOBJ-PPL)
TESTLAST DC    AL4(OPTPCL)
         DC    AL2(HLOPT-HLPDL,HLOPTDSN-HLPDL,DDASMOPT-PPL,0),AL1(0)
         DC    CL8'ASMAOPT',2AL3(0),AL2(XOPT-PPL)
         DC    0D'0'
         EJECT
         PUSH  PRINT
         PRINT NOGEN
HLPCL    IKJPARM DSECT=HLPDL
HLPCL    RMODE ANY
HLDSN    IKJPOSIT DSNAME,USID,VALIDCK=ALLOCASM,                       ->
               PROMPT='NAME OF DATA SET CONTAINING PROGRAM TO ASSEMBLE'
HLLIBMAC IKJKEYWD
         IKJNAME NOLIBMAC
         IKJNAME LIBMAC
HLFOLD   IKJKEYWD
         IKJNAME NOFOLD
         IKJNAME FOLD
HLALIGN  IKJKEYWD
         IKJNAME NOALIGN
         IKJNAME ALIGN
HLDBCS   IKJKEYWD
         IKJNAME NODBCS
         IKJNAME DBCD
HLMXREF  IKJKEYWD
         IKJNAME NOMXREF
         IKJNAME MXREF,SUBFLD=HLSF09
HLRXREF  IKJKEYWD
         IKJNAME NORXREF
         IKJNAME RXREF
HLBATCH  IKJKEYWD
         IKJNAME NOBATCH
         IKJNAME BATCH
HLVER    IKJKEYWD
         IKJNAME VERSION
HLTERM   IKJKEYWD DEFAULT='TERM(*)'
         IKJNAME NOTERM
         IKJNAME TERM,SUBFLD=HLSF01
HLDXREF  IKJKEYWD DEFAULT='NODXREF'
         IKJNAME NODXREF
         IKJNAME DXREF
HLRENT   IKJKEYWD
         IKJNAME NORENT
         IKJNAME RENT
HLTEST   IKJKEYWD DEFAULT='TEST'
         IKJNAME NOTEST
         IKJNAME TEST
HLESD    IKJKEYWD
         IKJNAME NOESD
         IKJNAME ESD
HLRLD    IKJKEYWD DEFAULT='NORLD'
         IKJNAME NORLD
         IKJNAME RLD
HLTHREAD IKJKEYWD
         IKJNAME NOTHREAD
         IKJNAME THREAD
HLLIST   IKJKEYWD
         IKJNAME NOLIST
         IKJNAME LIST,SUBFLD=HLSF08
HLPRINT  IKJKEYWD DEFAULT='PRINT'
         IKJNAME NOPRINT
         IKJNAME PRINT,SUBFLD=HLSF02
HLOBJ    IKJKEYWD DEFAULT='OBJECT'
         IKJNAME NOOBJECT
         IKJNAME OBJECT,SUBFLD=HLSF03
HLXREF   IKJKEYWD DEFAULT='XREF'
         IKJNAME NOXREF
         IKJNAME XREF,SUBFLD=HLSF05
HLADATA  IKJKEYWD DEFAULT='NOADATA'
         IKJNAME NOADATA
         IKJNAME ADATA,SUBFLD=HLSF06
HLLIB    IKJKEYWD DEFAULT='LIB(''SYS1.MODGEN'' ''SYS1.MACLIB'')'
*        IKJNAME MVTMAC,INSERT='LIB(MVT.MODGEN MVT.MACLIB MVT.TSOMAC ASX
               M)'
*        IKJNAME HLASMMAC,                                            ->
               INSERT='LIB(''HLASM.SASMMAC1'' ''SYS1.MODGEN'' ''SYS1.MA>
               CLIB'' ASM)'
         IKJNAME LIB,SUBFLD=HLSF04
         IKJNAME LIBDD,SUBFLD=HLSF12
         IKJNAME LIBFILE,SUBFLD=HLSF12
HLRC     IKJKEYWD DEFAULT='RC'
         IKJNAME NORC
         IKJNAME RC
HLOPT    IKJKEYWD DEFAULT='NOASMOPT'
         IKJNAME NOASMOPT
         IKJNAME ASMAOPT,ALIAS='OPTDS',SUBFLD=HLSF07
HLXOBJ   IKJKEYWD
         IKJNAME NOXOBJ
         IKJNAME NOGOFF
         IKJNAME XOBJ,SUBFLD=HLSF10
         IKJNAME GOFF,SUBFLD=HLSF10
HLRA2    IKJKEYWD
         IKJNAME NORA2
         IKJNAME RA2
HLLINEC  IKJKEYWD
         IKJNAME LINECOUNT,ALIAS='LC',SUBFLD=HLSF11
HLSF12   IKJSUBF
HLLIBDD  IKJIDENT 'SYSLIB DD NAME',FIRST=ALPHA,OTHER=ALPHANUM,        ->
               MAXLNTH=8,VALIDCK=TESTLDD,                             ->
               PROMPT='FILE NAME OF PREALLOCATED DATA SETS TO USE AS SY>
               LIB FOR THE ASSEMBLY'
HLSF11   IKJSUBF
HLLC     IKJIDENT 'LINES PER PAGE',FIRST=NUMERIC,OTHER=NUMERIC,       ->
               MAXLNTH=3,PROMPT='LINES PER PAGE'
HLSF10   IKJSUBF
HLXOBAD  IKJKEYWD
         IKJNAME NOADATA
         IKJNAME ADATA
HLSF09   IKJSUBF
HLMX     IKJKEYWD
         IKJNAME FULL
         IKJNAME SOURCE
         IKJNAME XREF
HLSF08   IKJSUBF
HLLSIZE  IKJIDENT 'LIST SIZE',FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=3,  ->
               PROMPT='BYTES IN A PRINT LINE',VALIDCK=TSTLSIZE
HLSF07   IKJSUBF
HLOPTDSN IKJPOSIT DSNAME,USID,                                        ->
               PROMPT='NAME OF DATA SET CONTAINING ASSEMBLER OPTIONS'
HLSF06   IKJSUBF
HLADDS   IKJPOSIT DSNAME,USID
HLSF05   IKJSUBF
HLXSHORT IKJKEYWD DEFAULT='SHORT'
         IKJNAME SHORT
         IKJNAME FULL
HLXUREF  IKJKEYWD
         IKJNAME UNREFS
HLSF04   IKJSUBF
HLLIBDS  IKJPOSIT DSNAME,USID,LIST,                                   ->
               PROMPT='NAME OF DATA SET CONTAINING MACRO AND COPY CODE'
HLSF03   IKJSUBF
HLOBJDS  IKJPOSIT DSNAME,USID
HLSF02   IKJSUBF
HLLSTDS  IKJPOSIT DSNAME,USID
HLSF01   IKJSUBF
HLTERMDS IKJPOSIT DSTHING,USID,VALIDCK=TSTTRMDS,                      ->
               PROMPT='NAME OF DATA SET TO CONTAIN ASSEMBLER SUMMARY'
         IKJENDP
         SPACE 2
* IKJPARS PCLS AND PDLS USED TO PROMPT THE TERMINAL OPERATOR FOR
* SPECIFIC DATA SETS
TERMPCL  IKJPARM DSECT=TERMPDL
TERMPCL  RMODE ANY
TERMDSN  IKJPOSIT DSTHING,USID,                                       ->
               PROMPT='NAME OF DATA SET TO CONTAIN ASSEMBLER ERRORS AND>
                SUMMARY'
         IKJENDP
         SPACE 2
PRINTPCL IKJPARM DSECT=PRINTPDL
PRINTPCL RMODE ANY
PRINTDSN IKJPOSIT DSNAME,USID,                                        ->
               PROMPT='NAME OF DATA SET TO CONTAIN THE ASSEMBLER LISTIN>
               G'
         IKJENDP
         SPACE 2
OBJPCL   IKJPARM DSECT=OBJPDL
OBJPCL   RMODE ANY
OBJDSN   IKJPOSIT DSNAME,USID,                                        ->
               PROMPT='NAME OF DATA SET TO CONTAIN THE ASSEMBLER OBJECT>
                OUTPUT'
         IKJENDP
         SPACE 2
ADATAPCL IKJPARM DSECT=ADATAPDL
ADATAPCL RMODE ANY
ADATADSN IKJPOSIT DSNAME,USID,                                        ->
               PROMPT='NAME OF DATA SET TO CONTAIN THE ASSEMBLER ADATA >
               OUTPUT'
         IKJENDP
         SPACE 2
OPTPCL   IKJPARM DSECT=OPTPDL
OPTPCL   RMODE ANY
OPTDSN    IKJPOSIT DSNAME,USID,                                       ->
               PROMPT='NAME OF DATA SET CONTAINING ASSEMBLER OPTIONS'
         IKJENDP
         SPACE 2
SUFPCL   IKJPARM DSECT=SUFPDL
SUFPCL   RMODE ANY
SUFASM   IKJPOSIT DSNAME,USID
SUFLIST  IKJPOSIT DSNAME,USID
SUFOBJ   IKJPOSIT DSNAME,USID
SUFTLIST IKJPOSIT DSNAME,USID
SUFADATA IKJPOSIT DSNAME,USID
SUFOPT   IKJPOSIT DSNAME,USID
         IKJENDP
         EJECT
* COMMAND BUFFER WITH THE DATA SET SUFFIXES WE USE
SUFCMD   DC    Y(SUFCMDL,2),C'Z ASM ASMLIST OBJ TERMLIST ADATA ASMAOPT'
SUFCMDL  EQU   *-SUFCMD
         SPACE 2
SUFTAB   DC    Y(SUFASM-SUFPDL,XASM-PPL)
         DC    Y(SUFLIST-SUFPDL,XLIST-PPL)
         DC    Y(SUFOBJ-SUFPDL,XOBJ-PPL)
         DC    Y(SUFTLIST-SUFPDL,XTLIST-PPL)
         DC    Y(SUFADATA-SUFPDL,XADATA-PPL)
         DC    Y(SUFOPT-SUFPDL,XOPT-PPL)
SUFTABN  EQU   (*-SUFTAB)/4
         EJECT
* VERIFY A TERMINAL DATA SET NAME DOES NOT HAVE A * OR ITS LENGTH = 1
         SPACE 1
         PUSH  USING
         DROP  ,
         CNOP  0,8
TSTTRMDS SAVE  (14,4),,TSTTRMDS    SAVE REGISTERS
         BASR  4,0                 PREPARE BASE REGISTER
         USING *,4                 ESTABLISH ADDRESSABILITY
         L     3,0(,1)             LOAD ADDRESS OF THE PDE
         LA    0,1                 INIT REG 0
         L     1,0(,3)             LOAD ADDRESS OF THE DATA SET NAME
         LH    15,4(,3)            LOAD LENGTH OF THE DATA SET NAME
         BCTR  15,0                REDUCE LENGTH BY 1
         EX    15,TTRM0200         TRT 0(*-*,1),TTRM0300
         BZ    TTRM0100            BR IF DATA SET NAME OK
         LA    15,1(,15)           RESTORE THE LENGTH
         CR    15,0                LENGTH = 1?
         BE    TTRM0100
         RETURN (14,4),RC=4        DSN HAS AN ASTERISK, BUT LENGTH ¬= 1
TTRM0100 RETURN (14,4),RC=0        DSN OK
TTRM0200 TRT   0(*-*,1),TTRM0300   ** EX ONLY **
         CNOP  0,8
TTRM0300 DC    0XL256'0'
         DC    (C'*')X'00',X'04',(256-(*-TTRM0300))X'00'
         POP   USING
         SPACE 2
         EJECT
         CNOP  0,8
DYNALLOC BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,9
         SAVE  (14,12),,DYNALLOC   SAVE REGISTERS
         LR    9,15
         LA    15,72(,13)          ADD NEW SAVE AREA TO THE
         ST    13,4(,15)            SAVE AREA CHAIN
         ST    15,8(,13)
         LR    13,15
         BAS   14,DYNRELOC         RELOCATE THE ADDRESS CONSTANTS
         L     2,0(,1)             LOAD ADDRESS OF THE REQUEST BLOCK
         ST    2,DFS99RBP          STORE ADDRESS FOR DAIRFAIL
RETRY    DYNALLOC ,                EXECUTE THE ALLOCATION
         LTR   10,15               OK?
         BZ    DYNA0200            YES
         TM    FLAG,NEWDS
         BZ    DYNA0100
         CLC   S99ERROR-S99RB(,2),=X'1708'  DATA SET NOT CATALOGED?
         BNE   DYNA0100                    NO
*        MVC   (ATXTPP-A)+DYNPARM(44),ATXTPP    UPDATE THE PARAMETERS
         MVC   (ATXT05-A)+DYNPARM,=AL2(DALPRIME) TO
         MVC   (ATXT06-A)+DYNPARM,=AL2(DALSECND)  ALLOCATE
         MVC   (ATXT07-A)+DYNPARM,=AL2(DALBLKLN)   A
         MVC   (ATXT08-A)+DYNPARM,=AL2(DALRECFM)    NEW
         MVI   (DISP1-A)+DYNPARM,DISPNEW             DATA
         MVC   (ATXT10-A)+DYNPARM,=AL2(DALNDISP)      DATA SET
         MVC   (ATXT11-A)+DYNPARM,=AL2(DALDSORG)
         MVC   (ATXT09-A)+DYNPARM,=AL2(DALLRECL)
         MVC   (ATXT12-A)+DYNPARM,=AL2(DALRLSE)
         MVC   (ARECFM-A)+DYNPARM,APRECFM-APARM(3)
         MVC   (ALRECL-A)+DYNPARM,APLRECL-APARM(3)
         TM    (AMEMB-A)+DYNPARM,255-C' '
         BZ    DYNA0050
         XC    (ATXT11-A)+DYNPARM,(ATXT11-A)+DYNPARM
         MVC   (ATXT14-A)+DYNPARM,=AL2(DALDIR)
DYNA0050 NI    FLAG,255-NEWDS      RESET THE NEWDS FLAG
         L     15,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA
         L     1,24(,15)           RELOAD REGISTER 1
         B     RETRY               AND RETRY THE ALLOCATION
DYNA0100 ST    15,DYNRC            SAVE THE RETURN CODE FOR DAIRFAIL
         LINK  SF=(E,LINKDF),MF=(E,DFPARMS)  RUN DAIRFAIL
         LTR   15,15               OK?
         BZ    DYNA0300            YES
         DC    H'0'                OOPS
DYNA0200 L     2,DFS99RBP          LOAD THE RB ADDRESS
         CLI   S99VERB-S99RB(2),S99VRBAL  ALLOCATE FUNCTION?
         BNE   DYNA0300            NO
         LA    0,16                SAVE THE DD NAME
*        GETMAIN R,LV=(0)
         BAS   14,GETMAIN
         MVC   0(4,1),ALIST
         ST    1,ALIST
         MVC   4(8,1),ADDN-ARB(2)
DYNA0300 LR    15,10               COPY THE RETURN CODE TO REG 15
         L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA
         RETURN (14,12),RC=(15)    RESTORE REGISTERS & RETURN
         DROP  9
         EJECT
***********************************************************************
*                                                                     *
* Title -- DYNRELOC                                                   *
*                                                                     *
* Function / Operation -- Translate address offsets in a coded        *
*   dynamic allocation parameter list to true addresses               *
*                                                                     *
* Status / Change Level --                                            *
*           March 2012                                                *
*    - Change comment.  The IEFZB4D2 macro name in a comment was      *
*      incorrectly specified as IEFAB4D2.  The change level was not   *
*      altered since the only change was in a comment and in this     *
*      change log.                                                    *
*    - Added comment about attributes.                                *
*   V3L0 -- April 2010                                                *
*                                                                     *
* Example Calling Sequence --                                         *
*   ----+----1----+----2----+----3----+----4----+----5----+----6      *
*            LA    1,DYNPARMS                                         *
*            BRAS  14,DYNRELOC                                        *
*            ...                                                      *
*   DYNPARMS DC    A(X'80000000'+(RB-DYNPARMS))                       *
*   RB       DC    AL1(S99RBEND-S99RB,S99VRBAL,0,0),2AL2(0)           *
*            DC    A(TUP001-DYNPARMS)                                 *
*            DC    2A(0)                                              *
*   TUP001   DC    A(TU001-DYNPARMS)                                  *
*            DC    A(TU002-DYNPARMS)                                  *
*            DC    A(TU003-DYNPARMS)                                  *
*            DC    A(X'800000000'+(TU004-DYNPARMS))                   *
*   TU001    DC    AL2(DALDSNAM,1,L'DSN)                              *
*   DSN      DC    C'SYS1.MACLIB'                                     *
*   TU002    DC    AL2(DALSTATS,1,1),AL1(8)                           *
*   TU003    DC    AL2(DALRTORG,1,2),AL2(0)                           *
*   TU004    DC    AL2(DALRTDDN,1,8),CL8' '                           *
*                                                                     *
* Attributes -- DYNRELOC is reenterable, refreshable and reusable.    *
*   It operates in TCB mode, in problem key and problem state.  It    *
*   operates in AMODE 24 or 31 that is consistent with the location   *
*   of the code, the register save area, and the dynamic allocation   *
*   parameter list.  It uses no external operating system resources.  *
*                                                                     *
***********************************************************************
         SPACE 5
         DC    0D'0'
         PUSH  USING
DYNRELOC BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,9
         SAVE  (14,12),,DYNRELOC   SAVE REGISTERS
         LR    9,15                PREPARE THE BASE REGISTER
         LR    2,1                 COPY ADDRESS OF THE RB POINTER TO  ->
                                    REG 2
         L     3,0(,1)             LOAD OFFSET OF THE REQUEST BLOCK
         ALR   3,2                 COMPUTE THE REQUEST BLOCK ADDRESS
         ST    3,0(,1)             STORE THE REQUEST BLOCK ADDRESS
         USING S99RB,3             ESTABLISH S99RB ADDRESSABILITY
         L     4,S99TXTPP          LOAD OFFSET OF THE FIRST TEXT      ->
                                    UNIT POINTER
         ALR   4,2                 COMPUTE ADDRESS OF THE TEXT UNIT   ->
                                    POINTER
         ST    4,S99TXTPP          STORE ITS ADDRESS IN THE S99RB
DYNR0100 L     15,0(,4)            LOAD OFFSET OF A TEXT UNIT POINTER
         LR    14,15               COPY OFFSET TO REG 14
         N     14,DYNR0300         REMOVE THE VL BIT
         JZ    DYNR0200            BR IF NO POINTER IN THE POSITION
         ALR   15,2                COMPUTE ADDRESS OF THE TEXT UNIT
         ST    15,0(,4)            STORE TEXT UNIT ADDRESS IN THE     ->
                                    TEXT UNIT POINTER
DYNR0200 TM    0(4),X'80'          TEST IF LAST TEXT UNIT POINTER
         LA    4,4(,4)             COMPUTE ADDRESS OF THE NEXT TEXT   ->
                                    UNIT POINTER
         JZ    DYNR0100            BR IF NOT THE LAST TEXT UNIT POINTER
         RETURN (14,12)            RESTORE REGISTERS & RETURN TO CALLER
DYNR0300 DC    A(X'7FFFFFFF')      MASK TO REMOVE THE VL BIT
         POP   USING               RESTORE PREVIOUS USING
*        IEFZB4D0 ,
*        IEFZB4D2 ,
         EJECT
         PRINT GEN
PUTLINE  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,2
         SAVE  (14,2),,PUTLINE     SAVE REGISTERS
         LR    2,15                Prepare base register
         LA    15,72(,13)          ADD NEW SAVE AREA
         ST    13,4(,15)            TO THE SAVE AREA CHAIN
         ST    15,8(,13)
         LR    13,15
         XC    OLD(12),OLD         CLEAR THE OUTPUT LINE DESCRIPTOR
         ST    1,OLD+8             PREPARE THE
         LA    0,1                  OUTPUT LINE
         ST    0,OLD+4               DESCRIPTOR
         XC    PUTLPB(PUTLPBL),PUTLPB
         MVI   PUTLECB,0
         PUTLINE MF=(E,MYIOPL),PARM=PUTLPB,ENTRY=CALLPUTL,            ->
               OUTPUT=(OLD,TERM,MULTLVL,INFOR),ECB=PUTLECB
CALLPUTL L     15,CVTPTR           LOAD ADDRESS OF THE CVT
         ICM   15,B'1111',CVTPUTL-CVTMAP(15)  LOAD ADDRESS OF IKJPUTL
         BZ    PUTLLINK            BR IF IKJPUTL NOT PRE LOADED
         CALL  (15),MF=(E,(1))     CALL IKJPUTL
         B     PUTLEXIT
PUTLLINK  LINK  SF=(E,LINKPUTL),MF=(E,(1))
PUTLEXIT L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA
         RETURN (14,2),RC=(15)     RESTORE REGISTERS & RETURN
         EJECT
         CNOP  0,8
IKJEFF02 BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,2
         SAVE  (14,2),,IKJEFF02    SAVE REGISTERS
         LR    2,15                PREPARE BASE REGISTER
         LA    15,72(,13)          ADD NEW SAVE AREA
         ST    13,4(,15)            TO THE SAVE AREA CHAIN
         ST    15,8(,13)
         LR    13,15               PREPARE NEW SAVE AREA POINTER
         STCM  0,B'1111',MTMSGID   STORE THE MESSAGE ID
         L     15,CVTPTR           LOAD ADDRESS OF THE CVT
         ICM   15,B'1111',CVTEFF02-CVTMAP(15)  LOAD POSSIBLE IKJEFF02 ->
                                                ADDRESS
         BZ    FF020100            BR IF ADDRESS NOT INCVT
         CALL  (15),MF=(E,MTPARML) CALL IKJEFF02
         B     FF020200
FF020100 LINK  SF=(E,LINKFF02),MF=(E,MTPARML)  CALL IKJEFF02
FF020200 L     13,4(,13)           LOAD ADDRESS OF THE HIGHER SAVE AREA
         RETURN (14,2),RC=(15)     RESTORE REGISTERS & RETURN
         SPACE 1
LINKFF02 LINK  SF=L,EP=IKJEFF02    LINK MACRO PARAMETER LIST
         DROP  2                   KILL ADDRESSABILITY
         EJECT
         CNOP  0,8
LISTTERM BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         SAVE  (14,12),,LISTTERM   SAVE REGISTERS
         BASR  8,0                 STORE CURRENT ADDRESS IN REG 8
         USING *,8                 ESTABLISH ADDRESSABILITY
         USING HLPDL,10            ESTABLISH PDL ADDRESSABILITY
         LA    15,72(,13)          ADD NEW SAVE AREA
         ST    13,4(,15)            TO THE SAVE AREA CHAIN
         ST    15,8(,13)
         LR    13,15               PREPARE NEW SAVE AREA POINTER
         ICM   1,B'1111',HLTERMDS  LOAD ADDRESS OF THE TERMINAL DSN
         BZ    LTRM0700            NO DSN
         CLI   0(1),C'*'           DSN *
         BNE   LTRM0700            NO
         MVC   QDCBE,MQDCBE        INITIALIZE THE DCBE
         MVC   QOPARM,MQOPARM      INITIALIZE THE OPEN PARM LIST
         MVC   QDCB,MQDCB          INITIALIZE THE DCB
         LA    0,QDCBE             ADD THE DCBE ADDRESS TO THE DCB
         ST    0,(DCBDCBE-IHADCB)+QDCB
         MVC   (DCBDDNAM-IHADCB)+QDCB,DDTERM  COPY DDNAME TO THE DCB
         OPEN  QDCB,MF=(E,QOPARM)  OPEN THE DCB
LTRM0100 GET   QDCB                READ A RECORD
         LA    0,1(,1)             SKIP THE CARRIAGE CONTROL
         LH    3,(DCBLRECL-IHADCB)+QDCB  LOAD THE LRECL
         LR    4,3                 COPY THE LRECL TO REG 4
         BCTR  4,0                 SUBTRACT 2
         BCTR  4,0
         AR    3,1                 COMPUTE THE END OF THE RECORD
LTRM0200 BCTR  3,0                 BACKUP 1 BYTE
         TM    0(3),255-C' '       BLANK?
         BNZ   LTRM0300            NO
         BCT   4,LTRM0200          TRY AGAIN
         B     LTRM0100            ALL BLANKS, SKIP THE RECORD
LTRM0300 LA    1,1(,3)             COMPUTE END OF RECORD
         SR    1,0                 COMPUTE THE LENGTH
         BP    *+L'*+4             OK
         DC    AL2(0,0)            OOPS
         LA    14,ASMPARM+4        LOAD START OF TEXT
         LR    15,1                COPY THE LENGTH TO REG 15
         MVCL  14,0                COPY THE RECORD TO ASMPARM
         LA    2,ASMPARM           PREPARE TO PUTLINE THE RECORD
         SR    14,2                COMPUTE THE LINE LENGTH
         SLL   14,16               CONVERT THE LENGTH TO AN RDW
         STCM  14,B'1111',0(2)     STORE THE RDW
         MVI   PUTLECB,0
         XC    PUTLPB(PUTLPBL),PUTLPB
         PUTLINE MF=(E,MYIOPL),PARM=PUTLPB,ENTRY=LTRM0400,            ->
               OUTPUT=((2),TERM,SINGLE,DATA),ECB=PUTLECB
LTRM0400 L     15,CVTPTR           LOAD ADDRESS OF THE CVT
         ICM   15,B'1111',CVTPUTL-CVTMAP(15)  LOAD ADDR OF A POSSIBLE ->
                                               IKJPUTL ROUTINE
         BZ    LTRM0500            BR IF IKJPUTL NOT PRELOADED
         CALL  (15),MF=(E,(1))     CALL IKJPUTL
         B     LTRM0100
LTRM0500 LINK  SF=(E,LINKPUTL),MF=(E,(1))  CALL IKJPUTL
         B     LTRM0100
LTRM0600 CLOSE QDCB,MF=(E,QOPARM)  CLOSE THE SYSTERM DCB
         FREEPOOL QDCB             FREE THE BUFFER POOL
LTRM0700 L     13,4(,13)           RESTORE REGISTERS & RETURN
         RETURN (14,12)
         SPACE 2
         PUSH  PRINT
         PRINT NOGEN
MQDCB    DCB   DSORG=PS,MACRF=GL,DDNAME=FILLMEIN,DCBE=*-*
MQDCBE   DCBE  EODAD=LTRM0600
MQOPARM  OPEN  *-*,MF=L
         POP   PRINT
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         DROP  ,
         SPACE 1
         EJECT
         PRINT NOGEN
HLAMSGS  CSECT
HLAMSGS  RMODE ANY
         IKJTSMSG ('HLA001I RUNNING HIGH LEVEL ASSEMBLER'),MSG1
         IKJTSMSG ('HLA002I ASMA90 RC = ',),MSG2
         IKJTSMSG ('HLA003I HLASM V2L4 &SYSDATE &SYSTIME'),MSG3
         IKJTSMSG ('HLA004A ',,' IS TOO LONG TO ADD STANDARD QUALIFIERS>
               '),MSG4
         IKJTSMSG ('HLA006E TOO MANY DATA SETS SPECIFIED IN THE LIB PAR>
               AMETER'),MSG6
         IKJTSMSG ('HLA007A UNABLE TO USE ',,': THE DATA SET IS NOT SEQ>
               UENTIAL OR PARTITIONED'),MSG7
         IKJTSMSG ('HLA008A UNABLE TO USE ',,': THE DATA SET IS SEQUENT>
               IAL, BUT THE COMMAND LINE SPECIFIES A MEMBER'),MSG8
         IKJTSMSG ('HLA009A UNABLE TO USE ',,': THE DATA SET IS PARTITI>
               ONED, BUT THE COMMAND LINE DOES NOT SPECIFY A MEMBER'),M>
               SG9
         IKJTSMSG ('HLA010E UNABLE TO USE ',,': THE DATA SET IS NOT PAR>
               TITIONED'),MS10
         IKJTSMSG ('HLA011A LIBRARY DD IS NOT ALLOCATED'),MS11
         IKJTSMSG
         DC    0D'0'
         SPACE 1
         DCBD  DSORG=QS,DEVD=DA
         IEFZB4D0 ,
         IEFZB4D2 ,
         CVT   DSECT=YES
         IKJCPPL ,
RCBUF    EQU   6+(CPPLCBUF-CPPL)/4
RECT     EQU   6+(CPPLECT-CPPL)/4
RUPT     EQU   6+(CPPLUPT-CPPL)/4
         IKJIOPL ,
IOPLSIZE EQU   *-IOPL
         IKJPPL ,                  TSO PPL
*        ORG   PPL+256                                          *DEBUG*
DYNPARM  DS    XL256
* EXTEND THE PPL TO BUILD MY WORK AREA
SAVEAREA DS    (5*9)D              5 72 BYTE SAVE AREAS
MYIOPL   DS    XL(IOPLSIZE),0D     TSO IOPL FOR STACK AND PUTLINE
PUTLPB   PUTLINE MF=L              PUTLINE PARAMETER BLOCK
PUTLPBL  EQU   *-PUTLPB
STACKPBS STACK MF=L                STACK PARAMETER BLOCK
STACKPB  EQU   STACKPBS,*-STACKPBS
OLD      DS    3A                  PUTLINE OUTPUT LINE DESCRIPTOR
         IKJEFFDF DFDSECT=NO,DFDSEC2=YES "DAIRFAIL" PARM LIST
PPL      DSECT                     RETURN TO PPL DSECT
         PUSH  PRINT
         PRINT NOGEN
         IKJEFFMT MTDSECT=NO,MTFORMAT=NEW
         POP   PRINT
CPLIST   DC    A(*-*)              ADDRESS OF FIRST SUBPOOL
DYNRC    DS    F                   DYNAMIC ALLOCATION RETURN CODE
ALIST    DS    A                   ALLOCATED DD NAMES
LIBLIST  DS    2A                  ALLOCATED SYSLIB DD NAMES
PDLADDR  DS    A                   ADDRESS OF HLPDL
XPDL     DS    A                   ADDRESS OF SECONDARY PDL
ECB      DS    F                   ECB FOR IKJPARS
PUTLECB  DS    F                   ECB FOR PUTLINE AND STACK
PARMLIST CALL  ,(*-*,*-*),MF=L     PARAMETER LIST FOT ASSEMBLER
OCPARMS  OPEN  *-*,MF=L            OPEN / CLOSE PARAMETER LIST
OCPARM   EQU   OCPARMS,*-OCPARMS
QDCBS    DCB   DSORG=PS,MACRF=GL,DDNAME=FILLMEIN,DCBE=*-*
QDCB     EQU   QDCBS,*-QDCBS
QDCBES   DCBE  EODAD=*-*
QDCBE    EQU   QDCBES,*-QDCBES
QOPARMS  OPEN  *-*,MF=L
QOPARM   EQU   QOPARMS,*-QOPARMS
EXCPDCBS DCB   MACRF=E,DDNAME=FILLMEIN EXCP DCB AREA
EXCPDCB  EQU   EXCPDCBS,*-EXCPDCBS
BLDLPARM DS    F                   BLDL PARAMETER AREA
MNAME    DS    CL8,XL3,3X
MSIZE    EQU   *-MNAME
         CNOP  6,8
DDLIST   DS    H                   DD LIST SENT TO ASSEMBLER
DDSYSLIN DS    CL8
         DS    2D
DDSYSLIB DS    CL8
DDSYSIN  DS    CL8
DDSYSPRT DS    CL8
         DS    D
DDSYSUT1 DS    CL8
         DS    3D
DDTERM   DS    CL8
         DS    3D
DDADATA  DS    CL8
         DS    3D
DDASMOPT DS    CL8
DDSIZE   EQU   (*-DDLIST)-2
ASMPARM   DS   H,CL128             PARAMETER STRING SENT TO ASSEMBLER
FLAG     DS    0AL1                FLAG BITS
FLAGS    DS    AL1
NEWDS    EQU   X'80'
QUALIFIED EQU  X'01'
XASM     DS    H,CL17,0H
XLIST    DS    H,CL17,0H
XOBJ     DS    H,CL17,0H
XTLIST   DS    H,CL17,0H
XADATA   DS    H,CL17,0H
XOPT     DS    H,CL17,0H
         DS    0D
*        ORG   PPL+4096                                         *DEBUG*
WASIZE   EQU   *-PPL               SIZE OF PPL AND WORK AREA
         SPACE 2
* FORMAT OF TESTLIST ENTRIES
APARM    DSECT
APPCL    DS    A                   ADDRESS OF PROMPTING PCL
APOPT    DS    H                  OFFSET OF OPTION KEYWORD PDE IN HLPDL
APDSN    DS    H                   OFFSET OF DATA SET PDE IN HLPDL
APDD     DS    H                   OFFSET OF DD NAME IN WORK AREA
APLRECL  DS    AL2                 DEFAULT LRECL OF NEW DATA SET
APRECFM  DS    AL1                 DEFAULT RECFM OF NEW DATA SET
APSUFFIX DS    CL8                 DATA SET SUFFIX
APPRIME  DS    AL3                 VALUE MOVED TO DALPRIME KEY
APSECND  DS    AL3                 VALUE MOVED TO DALSECND KEY
APDFLT   DS    AL2                 OFFSET OF USERID.SUFFIX DSN
         SPACE 2
CPOOL    DSECT                     CELL POOL CONTAINER
CPNEXT   DS    A                   ADDRESS OF THE NEXT CONTAINER
CPSIZE   DS    F                   BYTES ALLOCATED FOR THIS SUBPOOL
CPLEFT   DS    F                   FREE BYTES LEFT IN THIS CONTAINER
CPNEXTA  DS    A,0D                ADDRESS OF FIRST FREE BYTE
CPSTART  EQU   *
         POP   PRINT
         END   HLASM
