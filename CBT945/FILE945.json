{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013538000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2527798, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 18, "INMDSNAM": "CBT.V500.FILE945.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2527798, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2527798, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE945.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00)\\n'", "DS1TRBAL": "b'\\x0b\\xf4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xb9\\x00\\x0e\\t\\xbc\\x00\\n\\x00*'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00D\\x01\\x16\\x18\\x1f\\x01\\x16\\x18\\x1f\\x02%\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-06-29T00:00:00", "modifydate": "2016-06-29T02:25:44", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  945\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE945\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 72 MEMBERS COUNTED; CUMULATIVE SIZE IS 23,702 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/29/16    02:25:43    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE945": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x001\\x01\\x16\\x18\\x1f\\x01\\x16\\x18\\x1f\\x02%\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-06-29T00:00:00", "modifydate": "2016-06-29T02:25:31", "lines": 15, "newlines": 15, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 945 contains articles downloaded from Xephon archives,    *   FILE 945\n//*           from VSAM Update magazines, which are now supported   *   FILE 945\n//*           by www.cbttape.org, bu way of permission from Thomas  *   FILE 945\n//*           Publishing and Bob Thomas.  The Xephon company is     *   FILE 945\n//*           now defunct, the rights were given over to Thomas     *   FILE 945\n//*           publishing, who gave the support rights to us.  So    *   FILE 945\n//*           you can now use all this information and code, in     *   FILE 945\n//*           good conscience.                                      *   FILE 945\n//*                                                                 *   FILE 945\n//*           Articles in this file are from April 1991 thru        *   FILE 945\n//*           January 1993.                                         *   FILE 945\n//*                                                                 *   FILE 945\n//*           email:  sbgolob@cbttape.org                           *   FILE 945\n//*                   sbgolob@attglobal.net                         *   FILE 945\n//*                                                                 *   FILE 945\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A001A00I": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 15, "newlines": 15, "modlines": 0, "user": "VSAMUPD"}, "text": "A001 - VSAM Update Issue #1  April 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA001A01   Analysing AIX record size\nA001A02   VSAM initialization routine\nA001A03   Selection of index CI size\nA001A04   Improving KSDS performance using IAM\nA001A05   Compact VSAM ESDS printout\nA001A06   VSAM DASD management with help from REXX\nA001A07   Building a VSAM alternate index\nA001A08   Generation of 'aliases' in a master catalog\nA001A09   Delete VSAM user catalog\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A001A01": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01k\\x01k\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 363, "newlines": 363, "modlines": 0, "user": "VSAMUPD"}, "text": "Analysing AIX record size\n\nAn alternate index (AIX) is, basically, nothing but a VSAM\nKSDS file which enables you to access a base VSAM file using\na different key field.  The records in an alternate index are\nvariable length, based on the number of occurrences of the\nalternate key field in the base file.  When defining the alternate\nindex the maximum record size must be provided as a\nparameter.  Typically the programmer guesses at this value or,\neven worse, picks some large number such as 32 000,\nassuming that this number will never be reached.\n\nWhen the alternate index is actually created you will receive\nmessages to indicate if the maximum record size you selected\nwas not large enough (IBM messages IDC1646I on VSE/SP\n3.1).  For example, you may see something like this:\n\nIDC1646I   1234 EXCESS PRIME KEY VALUES FOR AIX KEY F9F9F8F8F7F7F6F6\n\nIt is then possible to redefine the AIX with a larger maximum\nrecord size to alleviate this problem.\n\nHowever, the opposite of this problem can also occur, that is,\nthe specified maximum record size can be greater than the\nvalue that is actually needed.  This means that the size of a\nCICS program can be considerably larger than it should be in\norder to hold the AIX work areas.  If the AIX work area is\nunder the CICS program COMMAREA it can needlessly\nincrease the size of the on-line workset and have an adverse\neffect on performance.\n\nThe effect can be even worse if you are using a CICS version\nprior to 1.7 because records spanning Control Intervals are not\nsupported.  When you consider the buffer and GETVIS\nimplications of having the large CIs to handle the excessive\nrecord sizes, the results can be disastrous.\n\nWith this in mind I wrote a program to read an AIX as a KSDS\nfile and print a report showing the range of record sizes as well\nas the minimum and maximum record sizes.\n\nWhen a new AIX is to be built, I initially define the maximum\nrecord size as 32 000, then run this program using the new AIX\nas input.  I use the output of this program to adjust the\nmaximum record size for the AIX to something more\nreasonable, delete and define the AIX, and rebuild the AIX.\n\nA sample output report might look like Figure 1.\n\nKnowing that the largest AIX record in the file is 1435\ncharacters in length and only 2 out of 9451 records are in the\nsize range of 1001-1500 I could safely choose a maximum AIX\nrecord size of less than 2000.  Periodic monitoring of this file\n(using this program) will make sure that the AIX record size\nremains reasonable.\n\nRegarding the program itself, the user macros for REGIS,\nBEGIN, and PRRTN are used to maintain program consistency\nand to alleviate some of the redundancy for basic programming\ntasks.  You can place the code 'in line' if you like.  In addition,\nthe record size ranges can be changed easily by modifying\nTABLE.\n\nThe JCL to run this job is as follows:\n\n// ASSGN SYS009,CUU     ASSIGN YOUR PRINTER\n// DLBL IJUC001,'YOUR.VSAM.USER.CATALOG',,VSAM\n// DLBL ZZWRKDI,'AIX.FILE.NAME',,VSAM,CAT=IJUC001\n// EXEC PZZ0051,SIZE=PZZ0051\n/*\n\nSimply change the AIX file name and VSAM user catalog\nname as appropriate, and assign the printer.\n\n0051     TITLE 'JOB ZZ0051 ANALYZE VSAM AIX FOR MAX RECORD SIZE'\n* MACRO DEFINITIONS\n         MACRO\n         REGIS\n* MACRO        ==> REGIS\n* PARAMETERS   ==> NONE\n* PURPOSE      ==> ASSIGN TAGS TO REGISTERS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n         MACRO\n&NAME    BEGIN &SUB\n* MACRO        ==> BEGIN &SUB\n* PARAMETERS   ==>  &SUB = NONE - NORMAL PHASE\n*                   &SUB = SUB  - CALLED SUBROUTINE\n* PURPOSE      ==> USED BY ASSEMBLER PHASES TO ESTABLISH REGISTER SAVE\n*                  AREAS AND BY CALLED SUBROUTINES TO ESTABLISH RETURN\n*                  LINKAGE AS WELL.\n         DS    0H\n&NAME    EQU   *\n         AIF   ('&SUB' EQ 'SUB').ITSSUB\n         BALR  R15,R0              IT'S A PHASE, LOAD R15\n         USING *,R15               ADDRESSABILITY\n         CNOP  0,4\n         BAL   R13,*+4+(18*4)      NO CALLING PROG, FAKE IT\nSAV$$RGP DC    18F'0'\n         DROP  R15\n         BALR  R15,R0              IT'S A PHASE, LOAD R15\n.ITSSUB  ANOP\n         USING *,R15               ADDRESSABILITY\n         SAVE  (14,12)             STORE REG 14 THRU 12 IN CALLING PROG\n         ST    R13,SAV$$REG+4      STORE R13 IN MY SAVE AREA\n         MVC   8(4,R13),SAVADCON   PASS BACK ADDRESS OF MY SAVE AREA\n         L     R13,SAVADCON        PUT ADDR OF MY SAVE AREA IN R13\n         B     CONTIN$$\nSAV$$REG DC    18F'0'\nMAX$$RET DC    F'0'                USED TO STORE MAX RETURN CODE\nSAVADCON DC    A(SAV$$REG)\n         DS    0H\nCONTIN$$ EQU   *\n         DROP  R15\n         MEND\n         MACRO\n         PRRTN &SKIP=12,&MARGIN=128\n* MACRO      ==> PRRTN &SKIP=12,&MARGIN+128\n* PARAMETERS ==>  &SKIP PAGE OVERFLOW ON CHANNEL 12 OR 9\n*                 &MARGIN RIGHT MARGIN, DEFAULT = 128\n* PURPOSE    ==> USED BY ASSEMBLER PROGRAMS TO SIMPLIFY PRINTING\n* ****************************************************************\n* THE PURPOSE OF THIS ROUTINE IS TO ENABLE AN ASSEMBLER PROGRAM TO\n*  INCLUDE A STANDARD PRINT AND HEADING ROUTINE WITH A MINIMUM OF\n*  CODING.\n*   ROUTINE USES REGISTERS 10 AND 4 WITHOUT STORING CONTENTS\n*   ROUTINE ASSUMES FOLLOWING FIELDS:\n*      JOBNUMBR - THE JOB NUMBER OF THE REPORT\n*      DATADATE - THE DATE OF THE DATA CONTAINED IN THE REPORT\n*      HEAD1, HEAD2, HEAD3 - 3 132 POSITION PRINT LINE FOR HEADING\n*        NOTE:     ROUTINE ASSUMES PRINT OVERFLOW ON CHANNEL 12. IF\n*                  YOU WANT TO OVERFLOW ON ANOTHER CHANNEL # USE\n*                  THE 'SKIP=' OPERAND\n         DC    C'- '\nPRNTR    DS    CL132\n         DS    0H\nWRITE    L     R13,=A(SAV$$REG)       ADDR OF MY REG SAVE AREA\n         PUT   PRINT,PRNTR\n         MVC   PRNTR,PRNTR-1\n         PRTOV PRINT,&SKIP,OVFLOW\n         BR    R10\nOVFLOW   ST    R10,HOLD$10\n         BAL   R4,HEADING\n         L     R10,HOLD$10\n         BR    R10\nHOLD$10  DS    F\nPRPAGE   DC    PL3'0'            PAGE #\nPR$ONE   DC    P'1'\nHEADING  EQU   *\n         ST    R4,HOLD$R4\n         CNTRL PRINT,SK,1\n         L     R1,=A(HEAD1)\n         MVC   PRNTR,0(R1)\n         BAL   R10,WRITE\n* RUN DATE / PAGE NUMBER\n         MVC   PRNTR+4(9),=C'RUN DATE='\n         COMRG\n         MVC   PRNTR+13(8),0(R1)\n         AP    PRPAGE,PR$ONE\n         L     R1,=A(PRNTR)\n         AH    R1,=H'&MARGIN'\n         SH    R1,=H'19'\n         MVC   0(12,R1),=C'PAGE NUMBER:'\n         MVC   12(6,R1),=X'402020202021'\n         ED    12(6,R1),PRPAGE\n         BAL   R10,WRITE\n* DATA DATE / REPORT ID\n         L     R1,=A(DATADATE)\n         CLI   0(R1),C'*'\n         BE    *+20\n         MVC   PRNTR+4(6),=C'AS OF='\n         L     R1,=A(DATADATE)\n         MVC   PRNTR+10(25),0(R1)\n         L     R1,=A(PRNTR)\n         AH    R1,=H'&MARGIN'\n         SH    R1,=H'19'\n         MVC   0(10,R1),=C'REPORT ID:'\n         L     R4,=A(JOBNUMBR)\n         MVC   11(8,R1),0(R4)\n         BAL   R10,WRITE\n         CNTRL PRINT,SP,2\n         L     R1,=A(HEAD2)\n         MVC   PRNTR,0(R1)\n         BAL   R10,WRITE\n         L     R1,=A(HEAD3)\n         MVC   PRNTR,0(R1)\n         BAL   R10,WRITE\n         MVC   PRNTR,PRNTR-2\n         BAL   R10,WRITE\n         CNTRL PRINT,SP,2\n         L     R4,HOLD$R4\n         BR    R4\nHOLD$R4  DS    F\n* MACRO END PRRTN\n         MEND\n         EJECT\nZZ0051   START 0\n* THE PURPOSE OF THIS PROGRAM IS TO READ A VSAM AIX FILE AND PRINT\n* INFORMATION RELATING TO RECORD SIZE.\n* REGISTER USAGE:\n*     R3  = BASE\n*     R4  = LINKAGE TO 'HEADING'\n*     R7  = WORK\n*     R10 = LINKAGE TO 'WRITE'\n* RETURN CODES\n*      0  = NORMAL EOJ\n* CHANGE LOG:\n* MM/DD/YY WHO    CHANGE\n         PRINT NOGEN\n         REGIS\n         SPACE 2\n* ACB TO ACCESS ALTERNATE INDEXES AS VARIABLE LENGTH KSDS FILE\nZZWRKDI  ACB   MACRF=(SEQ),EXLST=ZZEXLST\nZZEXLST  EXLST AM=VSAM,EODAD=ENDAIX\nZZAXRPL  RPL   ACB=ZZWRKDI,AREA=IWORK,AREALEN=32000,                   *\n               OPTCD=(SEQ,KGE,MVE)\n         SPACE 2\n* PRINT DTF & PRMOD\nPRINT    DTFPR DEVADDR=SYS009,IOAREA1=PRNTR,BLKSIZE=132,CONTROL=YES,   *\n               DEVICE=PRT1,PRINTOV=YES,RECFORM=FIXUNB\n         PRMOD DEVICE=PRT1,CONTROL=YES,PRINTOV=YES,RECFORM=FIXUNB\n         SPACE 2\n* REPORT HEADINGS\nJOBNUMBR DC    CL8'ZZ0051'\nDATADATE DC    CL25'*'\nHEAD1    DC    CL132'             V S A M    A I X    A N A L Y S I S'\nHEAD2    DC    CL132'   AIX          NUMBER OF '\nHEAD3    DC    CL132'RECORD-SIZE    OCCURRENCES'\n         SPACE 2\n* 'RANGE' TABLE\n*    1ST FIELD - FULLWORD WITH A VALUE 1 MORE THAN THE HIGHEST LENGTH\n*                RECORD TO BE INCLUDED IN THIS RANGE.\n*    2ND FIELD - 16 CHARACTER RANGE DESCRIPTION.\n*    3RD FIELD - PACKED FIELD TO ACCUMULATE NUMBER OF OCCURRENCES.\n         DS    0F     ALIGNMENT\nTABLE    EQU   *\n         DC    F'000101',CL16'    1 -   100',PL4'0'\n         DC    F'000201',CL16'  101 -   200',PL4'0'\n         DC    F'000301',CL16'  201 -   300',PL4'0'\n         DC    F'000401',CL16'  301 -   400',PL4'0'\n         DC    F'000501',CL16'  401 -   500',PL4'0'\n         DC    F'001001',CL16'  501 -  1000',PL4'0'\n         DC    F'001501',CL16' 1001 -  1500',PL4'0'\n         DC    F'002001',CL16' 1501 -  2000',PL4'0'\n         DC    F'002501',CL16' 2001 -  2500',PL4'0'\n         DC    F'003001',CL16' 2501 -  3000',PL4'0'\n         DC    F'003501',CL16' 3001 -  3500',PL4'0'\n         DC    F'004001',CL16' 3501 -  4000',PL4'0'\n         DC    F'004501',CL16' 4001 -  4500',PL4,0'\n         DC    F'005001',CL16' 4501 -  5000',PL4'0'\n         DC    F'010001',CL16' 5001 - 10000',PL4'0'\n         DC    F'015001',CL16'10001 - 15000',PL4'0'\n         DC    F'020001',CL16'15001 - 20000',PL4'0'\n         DC    F'025001',CL16'20001 - 25000',PL4'0'\n         DC    F'030001',CL16'25001 - 30000',PL4'0'\n         DC    X'FFFFFFFF',CL16'       >30000',PL4'0'\n         SPACE 2\n* DSECT FOR ACCESSING 'TABLE'\nDSECT1   DSECT\n         USING *,R7\nTHIRANGE DS    F         USED TO CHECK RANGE\nTRANGE   DS    CL16      RANGE DESCRIPTION\nTCOUNT   DS    PL4       # OF OCCURRENCES IN THE RANGE\nZZ0051   CSECT\n         EJECT\n* HOUSEKEEPING\nSTART    BEGIN\n         BALR  R3,R0\n         USING *,R3\n         OPEN  PRINT,ZZWRKDI\n         BAL   R4,HEADING          PRINT PAGE HEADING\n* MAINLINE\nGETAIX   L     R13,=A(SAV$$REG)\n         GET   RPL=ZZAXRPL\n         L     R1,=A(ZZAXRPL)\n         L     R13,=A(SAV$$REG)\n         SHOWCB RPL=(1),RECLEN=(0) GET LENGTH OF RECORD\n         ST    R0,LENGTH           STORE LENGTH OF REC READ\n         L     R7,=A(TABLE)        LOAD ADDRESS OF TABLE FOR DSECT\nLOOP     CLC   LENGTH,THIRANGE     COMPARE RECORD LENGTH TO HI-RANGE\n         BL    HIT                 FOUND IT\n         LA    R7,24(R7)           INCREMENT TO NEXT TABLE ENTRY\n         B     LOOP                GO CHECK RANGE\nHIT      AP    TCOUNT,ONE          ADD OCCURRENCE\n         L     R7,LENGTH           CONVERT  RECORD LENGTH\n         CVD   R7,RECLENTH          ... TO PACKED DECIMAL\n         CP    RECLENTH,LARGEREC   IS THIS RECORD THE LARGEST SO FAR?\n         BNH   *+10                 ... NO\n         ZAP   LARGEREC,RECLENTH    ... YES, THEN STORE IT\n         CP    RECLENTH,SMALLREC   IS THIS RECORD THE SMALLEST SO FAR?\n         BNL   *+10                 ... NO\n         ZAP   SMALLREC,RECLENTH    ... YES, THEN STORE IT\n         B     GETAIX              GO GET ANOTHER AIX RECORD\n         SPACE 2\n* END OF JOB PROCESSING\nENDAIX   EQU   *\n         CLOSE ZZWRKDI\n         L     R7,=A(TABLE-24)     LOAD ADDRESS FOR DSECT USE\nLOOOPA   EQU   *\n         LA    R7,24(R7)           INCREMENT TO NEXT TABLE ENTRY\n         MVC   PRNTR(16),TRANGE\n         MVC   PRNTR+18(L'EDIT),EDIT\n         ED    PRNTR+18(L'EDIT),TCOUNT\n         AP    TOTAL,20(4,R7)\n         BAL   R10,WRITE\n         CLI   THIRANGE,X'FF'      HAVE I GONE THRU ENTIRE TABLE?\n         BNE   LOOPA               NO\n         MVC   PRNTR+5(9),=C'TOTAL ==>'\n         MVC   PRNTR+18(L'EDIT),EDIT\n         ED    PRNTR+18(L'EDIT),TOTAL\n         CNTRL PRINT,SP,2\n         BAL   R10,WRITE\n         MVC   PRNTR+3(13),=C'RECORD SIZES:'\n         CNTRL PRINT,SP,2\n         BAL   R10,WRITE\n         MVC   PRNTR+5(12),=C'SMALLEST ==>'\n         MVC   PRNTR+18(L'EDIT),EDIT\n         ED    PRNTR+18(L'EDIT),SMALLREC    SMALLEST RECORD\n         BAL   R10,WRITE\n         MVC   PRNTR+5(12),=C'LARGEST  ==>'\n         MVC   PRNTR+18(L'EDIT),EDIT\n         ED    PRNTR+18(L'EDIT),LARGEREC    LARGEST RECORD\n         BAL   R10,WRITE\n         CLOSE PRINT\n         EOJ   RC=0\n         SPACE 2\n* COMMON PRINT ROUTINE\n         PRRTN MARGIN=50\n         EJECT\n* CONSTANTS AND WORK AREAS\n         LTORG\nRECLENTH DS    D                   RECORD LENGTH (PACKED DECIMAL)\nLENGTH   DS    F\nONE      DC    P'1'\nTOTAL    DC    PL4'0'\nSMALLREC DC    PL4'9999999'        SMALLEST RECORD SIZE\nLARGEREC DC    PL4'0'              LARGEST RECORD SIZE\nEDIT     DC    X'4020202020202021'\nIWORK    DS    0CL32000\n         ORG   IWORK+32000\n         END   START\n*END PRINT        336 RECORDS\n\n\nAngelo Sileo\nManager Technical Services\nPatrick Media Group (USA)                        c Angelo Sileo 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A001A02": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00g\\x00g\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 103, "newlines": 103, "modlines": 0, "user": "VSAMUPD"}, "text": "VSAM initialization routine\n\nThe following program will initialize an empty KSDS (one that\nhas just been defined) by inserting a record and then deleting\nthe record.  No parameters are required.\n\nI00VLOAD CSECT\n         USING I00VLOAD,R15\n         B     START\n         DC    C'I00VLOAD'\n         DC    C'NMGC/SS '\n         DC    C'&SYSDATE'\n         DROP  R15\nSTART    DS    0H\n         STM   R14,R12,12(R13)    save registers\n         BALR  R12,0              load base register\n         USING *,R12              assign base register\n         ST    R13,SAVEAREA+4     backward pointer\n         LA    R14,SAVEAREA       address of my savearea\n         ST    R14,8(R13)         forward pointer\n         LR    R13,R14            R13 --> my savearea\n         MVC   FUNCTION(8),=C'OPEN ACB'\n         OPEN  (VSAMACB)          open the VSAM DATASET\n         LTR   R15,R15\n         BNZ   ERROR\n         MVC   FUNCTION(8),C='SHOWCB  '\n         SHOWCB ACB=VSAMACB,      determine attributes                 X\n               AREA=DISPLAY,      keylength                            X\n               FIELDS=(KEYLEN,    record length                        X\n               LRECL,RKP,ENDRBA), record key position                  X\n               LENGTH=16          and end rba\n         LTR   R15,R15\n         BNZ   ERROR\n         MVC   FUNCTION(8),=C'ENDRBA  '\n         CLC   ENDRBA(4),=F'0'    empty ?\n         BNE   ERROR\n         MVC   FUNCTION(8),=C'LRECL   '\n         L     R2,LRECL\n         C     R2,=F'2048'\n         BH    ERROR\n         MVC   FUNCTION(8),=C'MODCB RL'\n         MODCB RPL=RPLLIST,       set up record length                 X\n               RECLEN=(2)         in request parameter list\n         LTR   R15,R15\n         BNE   ERROR\n         MVC   FUNCTION(8),=C'PUT     '\n         PUT   RPL=RPLLIST        add the \"null\" record\n         LTR   R15,R15\n         BNZ   ERROR\n         MVC   FUNCTION(8),=C'CLOSE   '\n         CLOSE (VSAMACB)\n         LTR   R15,R15\n         BNZ   ERROR\n         MVC   FUNCTION(8),=C'OPEN (2)'\n         OPEN  (VSAMACB)\n         LTR   R15,R15\n         BNZ   ERROR\n         MVC   FUNCTION(8),=C'MODCB OP'\n         MODCB RPL=RPLLIST,       set RPL for keyed read               X\n               ARG=LVKEY,                                              X\n               OPTCD=(KEY,DIR,SYN,UPD,MVE,FKS,KEQ)\n         LTR   R15,R15\n         BNZ   ERROR\n         MVC   FUNCTION(8),=C'GET     '\n         GET   RPL=RPLLIST        read the \"null\" record\n         LTR   R15,R15\n         BNZ   ERROR\n         MVC   FUNCTION(8),=C'ERASE   '\n         ERASE RPL=RPLLIST        delete the \"null\" record\n         LTR   R15,R15\n         BNZ   ERROR\n         CLOSE (VSAMACB)\n         L     R13,4(R13)         R13 --> callers savearea\n         L     R14,12(R13)        return address\n         LM    R0,R12,20(R13)     restore caller's registers\n         BR    R14                return to MVS\nERROR    ABEND 99,DUMP\n         EJECT\nSAVEAREA DC    18F'0'\nFUNCTION DC    CL12' '\nDISPLAY  DS    0F\nKEYLEN   DC    F'0'\nLRECL    DC    F'0'\nRKP      DC    F'0'\nENDRBA   DC    F'0'\n         SPACE\nVSAMACB  ACB   AM=VSAM,DDNAME=VSAM,                                    X\n               MACRF=(KEY,SEQ,DIR,OUT),STRNO=1\n         SPACE\nRPLLIST  RPL   ACB=VSAMACB,AREA=RECORD,                                X\n               AREALEN=2048,                                           X\n               OPTCD=(KEY,SEQ,SYN,MVE)\n         SPACE\n         LTORG\nLVKEY    DC    64X'00'\nRECORD   DC    2048X'00'\n         END\n\nDavid Welch\nSystems Programmer\nNational Mutual Group Computing (New Zealand)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A001A03": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12V\\x02\\xee\\x02\\xed\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:56:32", "lines": 750, "newlines": 749, "modlines": 0, "user": "VSAMUPD"}, "text": "Selection of index CI size\n\nThe IBM VSE/VSAM Programmer's Reference states \"Pick the\nsmallest index CI you can\". But it does not clearly explain\nwhy.  It seems to me that the reasoning is as follows.  The\nsmaller the index Control Interval size, the more index records\nthat can be held in a given amount of buffer space.  Therefore,\nthe probability that a given index record is in memory will\nincrease and fewer I/Os will be required to access the index -\nnone if all index records can be held in memory.  (This\nreasoning does not apply to SHAREOPTIONS(4) files where\nthe buffers are refreshed before every read.)\n\nThe BUFFERSPACE buffer allocation algorithm used by\nVSAM for direct processing emphasizes this point.  Once the\nminimum allocation of data and index buffers is made (either\nby default or using BUFND and BUFNI), VSAM allocates the\nremaining buffer space to index CIs.  Therefore, the smaller\nthe index CI size, the more buffers can be allocated to index\nrecords and the probability of index I/O is reduced.  This is an\nimportant consideration in storage-constrained systems since\nsmaller index CI sizes will make more effective use of scarce\nbuffer resources than larger CI sizes.  A further saving of\nresources (disk storage) can be made if all index records can be\nheld in memory.  It is evident that IMBED (which uses an\nadditional CI per CA) gives no performance advantage if no\nindex I/O is necessary.\n\nBut the index CI size cannot be set to the minimum size (512\nbytes) in all cases.  An index sequence set record (ie the lowest\nlevel of index) must be able to contain entries for all data\nControl Intervals in a given Control Area.  Since index Control\nIntervals cannot contain spanned index records, if the index\nControl Interval is too small, then VSAM will not fill all data\nCIs in the CA, but only as many as can be indexed by one\nindex CI.  The unused data CI space cannot be used for CI/CA\nsplits - it is simply unavailable.  Therefore too small an index\nCI size can result in huge amounts of wasted space.  It might\nbe said that disk space is relatively cheap compared to memory\nresources.  But not just disk space is wasted.  Longer disk\naccess time will be required to a read a given data record, since\nmore arm movement is required for a more spread out dataset.\nAlso, since each Control Area is effectively filled up well\nbefore a typical allocation of CA Free Space (say 10%), the\nspecified CA Free Space will be ineffective.  Thus each CI\nsplit will result in a very I/O costly CA split.\n\nIt follows that the effect of key compression is important, since\nit allows more entries per index record.  Key compression is\nthe technique VSAM uses to attempt to maximize the number\nof entries in an index record.  Characters which are not\nnecessary to distinguish a given key from adjacent keys are\nremoved from the front and back of a key.  The greater the\ndegree of key compression, the smaller the index CI size can\nbe without causing wasted space.  (The mechanics of key\ncompression for KSDS files was discussed in some detail in\nDavid Haines' article VSAM Tuning in Xephon's VSAM\nYearbook 1989.)\n\nIt is possible under the right conditions to compress some keys\nto less than half their original length (eg from 20-30 bytes to 8-\n9 bytes).  The degree of compression depends on the structure\nof the keys - some keys compress very poorly.  VSAM makes\nan estimate of key compression when a cluster or alternate\nindex is DEFINEd and will override the specified index CI size\nif it is considered too small.  Since IDCAMS cannot know in\nadvance what the actual key compression will be, the\nsubstituted value may be incorrect.  The correct key\ncompression value can only be determined after the dataset is\nloaded.\n\nDumping selected index records and determining the key\ncompression ratio by hand may give a reasonable estimate.\nBut it is better to automate the process.  The following program\nVKEYC reads all the index records of a KSDS or alternate\nindex and calculates the key compression in each record.  At\nend-of-file, the average key compression is calculated and a\nminimum index CI size is recommended based on the formula:\n\n      Index CIsize > CIs per CA * compressed key length\n\nThis minimum should then be rounded up to the next multiple\nof 512 (maximum index CI size is 8192).\n\nVKEYC is written for the VSE/VSAM environment.  The only\npart of the program that needs to be revised for the MVS\nenvironment (other than program prologue/epilogue) is that\nrelating to catalog access (to determine CIs per CA), since\nVSE/VSAM catalogs and MVS catalogs have different\nformats.  Otherwise, the algorithm for determining key\ncompression is the same.\n\n TITLE 'VKEYC - PROGRAM TO ESTIMATE KEY COMPRESSION FOR VSE/VSAM KSDS'\n*   PROGRAM NAME - VKEYC\n*   FUNCTION     - ESTIMATE KEY COMPRESSION FOR VSAM KSDS\n*                  AND RECOMMEND MINIMUM INDEX CISIZE\n*   INPUT FILES  - VSAM FILE\n*   OUTPUT FILES - PRINT FILE\n* REQUIRED JCL\n* // JOB KEYJOB\n* // LIBDEF *,SEARCH=LIB.SUBLIB\n* // DLBL CFILE,'VSAM.CLUSTER',,VSAM,CAT=USERCAT\n* // DLBL IFILE,'VSAM.CLUSTER.INDEX',,VSAM,CAT=USERCAT,BUFSP=NNNNN\n* // EXEC VKEYC,SIZE=AUTO\n* /*\n* /&\n*\n         EJECT\n*   REGISTER USAGE\n*   R1-R6 - WORK REGISTERS\n*   R7  -  PRINT BUFFER PTR\n*   R8  -  2ND PROGRAM BASE\n*   R10 -  LINK REGISTER\n*   R13 -  VSAM SAVE AREA PTR\n         EJECT\n* PSEUDO-CODE OVERVIEW\n* OPEN PRINT FILE (FOR ERROR MESSAGES)\n* FIND ADDRESS OF CATALOG ACB (SHOWCAT FOR CLUSTER COMPONENT)\n* FIND CI ADDRESS OF DATA COMPONENT CATALOG RECORD\n* READ CATALOG RECORD TO FIND KEY LENGTH, CIS PER CA\n* OPEN INDEX COMPONENT (SEQ INPUT)\n* FIND INDEX CISIZE\n* DO UNTIL END-OF-FILE ON VSAM FILE\n*    READ RECORD\n*    IF READ ERROR\n*       NOTIFY FATAL ERROR\n*    ENDIF\n*    CALCULATE KEY COMPRESSION\n* ENDDO\n* CLOSE VSAM FILE\n* PRINT SUMMARY (AVERAGE KEY LENGTH ETC)\n* CLOSE PRINT FILE\nVKEYC    CSECT\n         BALR  R11,0\n         USING *,R11,R8            SET PROGRAM BASE REGS R11, R8\n         LA    R8,1(R11)\n         LA    R8,4095(R8)\n         EJECT\n         LA    R13,VSAMSAVE        R13 => VSAM SAVE AREA\n         XC    VSMARG,VSMARG       CLEAR DUMMY ARGUMENT\n* OPEN PRINT FILE\n         OPEN  PRINTFL             OPEN PRINT FILE\n* SPACE 2 LINES\n         MVI   PRTBUF,NEWLINE2     CTL CHAR\n         BAL   R10,PRINT           SPACE 2\n         LA    R7,PRTBUF+1         R7 => PRINT BUFFER + CTL CHR\n* FIND ADDRESS OF CATALOG ACB\n         MVC   OPERATN,=CL8'SHOWCAT' VSAM OPERATION ID\n         SHOWCAT DDNAME=CFILE,AREA=SHOWAREA\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              SOMETHING WRONG\n         ENDIF\n         IF    (CLI,TYPE,NE,C'C')\n         MVC   PRTBUF+1(27),=CL27'*** NOT A CLUSTER ENTRY ***'\n         BAL   R10,PRINT\n         B     EXIT\n         ENDIF\n* FIND CI OF DATA RECORD\n         LH    R1,NOOBJS           R1 = NO. OF ENTRIES\n         LA    R2,OBJTAB           R2 => OBJECT TABLE\n         DO    FROM=(R1)           DO UNTIL END OF TABLE\n         IF    (CLI,0(R2),EQ,C'D')       IF DATA ENTRY\n         MVC   INDEXCI(L'INDEXCI),1(R2)  GET CI NO.\n         B     ENDTAB                    END OF SEARCH\n         ENDIF\n         LA    R2,4(R2)            BUMP POINTER\n         ENDDO\nENDTAB   DS    0H\n         IF    (OC,INDEXCI,INDEXCI,Z)\n         MVC   PRTBUF+1(29),=CL29'*** INVALID CATALOG ENTRY ***'\n         BAL   R10,PRINT\n         B     EXIT\n         ENDIF\n* READ CATALOG TO FIND FILE PARMS\n         BAL   R10,READCAT\n* OPEN INDEX COMPONENT\n         MVC   OPERATN,=CL8'OPEN'\n         OPEN  VSMACB              OPEN INDEX\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              SOMETHING WRONG\n         ENDIF\n* GET INDEX CONTROL INTERVAL SIZE\n         MVC   OPERATN,=CL8'SHOWCB'\n         SHOWCB ACB=VSMACB,AREA=CISZ,LENGTH=4,FIELDS=(CINV)\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              SOMETHING WRONG\n         ENDIF\n         L     R1,CISZ\n         BAL   R10,CONVERTP        CONVERT TO PRINTABLE (DECIMAL)\n         MVC   PRTBUF+1(29),=CL29'CURRENT CONTROL INTERVAL SIZE'\n         MVC   PRTBUF+50(L'WORK6),WORK6\n         BAL   R10,PRINT\n* READ VSAM FILE UNTIL EOF\n         MVC   OPERATN,=CL8'GET'   VSAM OPERATION ID\n         DO    INF                 START READ LOOP\n         GET   RPL=VSMRPL          READ A RECORD\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     EOF                 ANY ERROR = EOF\n         ENDIF\n* CALCULATE KEY ENTRY LENGTH\n         BAL   R10,CALC\n* BUMP RECORD COUNT\n         LA    R5,1                BUMP RECORD COUNT\n         A     R5,RCOUNT\n         ST    R5,RCOUNT\n         ENDDO                     END READ LOOP\n* EOF PROCESSING - GIVE FINAL MSGS\nEOF      DS    0H                  EOF ADDRESS\n         L     R1,NOSEQS\n         BAL   R10,CONVERTP        CONVERT TO PRINTABLE (DECIMAL)\n         MVC   PRTBUF+1(33),=CL33'NO. OF SEQUENCE SET INDEX RECORDS'\n         MVC   PRTBUF+50(L'WORK6),WORK6\n         BAL   R10,PRINT\n         IF    (OC,NOSEQS,NOSEQS,NZ)   IF SEQ SET RECORDS > 0\n         L     R2,ENTLEN           GET TOTAL AVERAGE KEY ENTRY LENGTH\n         SRDA  R2,32(0)            SET UP R2/R3 FOR DIVIDE\n         D     R2,NOSEQS           TOTAL / NO RECORDS = AVERAGE\n         LR    R1,R3\n         BAL   R10,CONVERTP        CONVERT TO PRINTABLE (DECIMAL)\n         MVC   PRTBUF+1(19),=CL19'AVERAGE KEY LENGTH'\n         MVC   PRTBUF+50(L'WORK6),WORK6\n         BAL   R10,PRINT\n         M     R2,CICA             AVERAGE X CIS/CA = MIN. CI SIZE\n         LR    R1,R3\n         BAL   R10,CONVERTP        CONVERT TO PRINTABLE (DECIMAL)\n         MVC   PRTBUF+1(29),=CL29'MINIMUM CONTROL INTERVAL SIZE'\n         MVC   PRTBUF+50(L'WORK6),WORK6\n         BAL   R10,PRINT\n         ENDIF\n         BAL   R10,PRINT           SPACE 1\n         MVC   OPERATN,=CL8'CLOSE'\n         CLOSE VSMACB              CLOSE VSAM FILE\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              SOMETHING WRONG\n         ENDIF\n* PRINT TOTAL NO. RECORDS\n         L     R1,RCOUNT           GET RECORD COUNT\n         BAL   R10,CONVERTP        CONVERT TO PRINTABLE (DECIMAL)\n         MVC   PRTBUF+1(20),=CL20'NO. OF INDEX RECORDS'\n         MVC   PRTBUF+50(L'WORK6),WORK6        RECORD COUNT\n         BAL   R10,PRINT\nEXIT     DS    0H\n         CLOSE VSMACB              CLOSE VSAM FILE\n         CLOSE PRINTFL             CLOSE PRINT FILE\n         EOJ\n* SHOWCB, SHOWCAT WORK AREAS\nCISZ     DC    F'0'                INDEX CISZ\nCFILE    DC    CL7'CFILE'\nSHOWAREA DS    0F\nAREALEN  DC    H'200'\nWLEN     DS    H                   ACTUAL WORKAREA LENGTH\nCATACB   DS    F                   ADDR OF CATALOG ACB\nTYPE     DS    CL1\nFILL1    DS    XL1                 RESERVED\nNOOBJS   DS    XL2                 NO. OF ASSOCIATED OBJECTS\nOBJTAB   DS    0C\nOBJTYPE  DS    CL1\nOBJCI    DS    XL3\n         ORG   SHOWAREA+200\nOBJTABL  EQU   *-OBJTAB\n         EJECT\n* CALC - CALCULATE AVERAGE KEY ENTRY LENGTH IF SEQUENCE SET RECORD\nCALC     DS    0H\n         ST    R10,CSAVE1\n* DETERMINE BEGINNING ADDRESS OF 1ST KEY ENTRY\n         L     R7,BUFADDR\n         USING ISECT,R7\n         IF    (CLI,LEVEL,EQ,X'01')    IF SEQUENCE SET RECORD\n         XR    R2,R2\n         ICM   R2,B'0011',UNUSED   R2 = OFFSET OF START OF UNUSED SPACE\n         XR    R4,R4\n         ICM   R4,B'0011',ILEN     R4 = RECORD LENGTH\n         SR    R4,R2               R4 = SEARCH LENGTH\n         AR    R2,R7               R2 => START OF UNUSED DATA\n         DO    FROM=(R4)\n         DOEXIT (CLI,0(R2),NE,X'00')   STOP AT FIRST USED BYTE\n         LA    R2,1(R2)                ELSE BUMP PTR\n         ENDDO\n         SR    R2,R7\n         ST    R2,ADDR1            SAVE OFFSET OF 1ST KEY\n* DETERMINE NUMBER OF USED DATA CIS IN THE CA\n         IF    (LTR,R4,R4,NZ)       IF SOME USED\n         XR    R2,R2\n         ICM   R2,B'0011',UNUSED    UNUSED OFFSET\n         SH    R2,=AL2(IHDRLEN)     LESS HDR LEN = LEN OF FREE PTR LIST\n         SRDA  R2,32(0)             SET UP R2/R3 FOR DIVIDE\n         XR    R4,R4\n         ICM   R4,B'0001',VLEN      R4 = PTR LENGTH\n         IF    (LTR,R4,R4,NZ)       IF VALID LENGTH\n         DR    R2,R4                R3 = LEN OF PTR LIST / PTR LEN\n         L     R4,CICA              R4 = TOTAL CIS/CA\n         SR    R4,R3                TOTAL LESS UNUSED = USED\n         IF    (LTR,R4,R4,NZ)       IF USED > 0\n         ST    R4,USED              SAVE IT\n* CALCULATE SPACE USED BY KEY ENTRIES\n         XR    R2,R2\n         ICM   R2,B'0011',ILEN      R2 = RECORD LENGTH - OFFSET 1ST KEY\n         S     R2,ADDR1             (I.E. SPACE USED BY KEY ENTRIES)\n* GET AVERAGE KEY ENTRY LENGTH\n         SRDA  R2,32(0)             SET UP R2/R3 FOR DIVIDE\n         D     R2,USED              SPACE USED / USED CIS PER CA\n         A     R3,ENTLEN            ADD TO TOTAL\n         ST    R3,ENTLEN            ADD TO TOTAL\n         LA    R2,1\n         A     R2,NOSEQS            COUNT SSI RECORDS\n         ST    R2,NOSEQS\n         ENDIF\n         ENDIF\n         ENDIF\n         ENDIF\n         DROP  R7\n         L     R10,CSAVE1\n         BR    R10\nCSAVE1   DS    F\nADDR1    DC    F'0'                ADDR OF 1ST KEY ENTRY\nUSED     DC    F'0'                USED CIS/CA\nCICA     DC    F'0'                CIS/CA\nNOSEQS   DC    F'0'                NO. OF SEQUENCE SET RECORDS\nENTLEN   DC    F'0'                TOTAL KEY ENTRY LENGTH\n         EJECT\n* READCAT - READ OWNING CATALOG TO FIND CIS/CA, KEY LENGTH\nREADCAT  DS    0H\n         ST    R10,RDSAVE1\n* SET CATALOG ACB ADDRESS IN RPL\n         L     R2,CATACB\n         MVC   OPERATN,=CL8'MODCB'\n         MODCB RPL=CATRPL,ACB=(2)\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n* READ CLUSTER'S CATALOG RECORD\n         USING DATREC,R3\n         MVC   OPERATN,=CL8'GET'\n         GET   RPL=CATRPL          READ A RECORD\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              ERROR\n         ENDIF\n         LA    R3,RECBUF           R3 => RECORD BUFFER\n* POINT TO FIRST GROUP OCCURRENCE IN RECORD\n         XR    R1,R1\n         ICM   R1,B'0001',GOPNO\n         IF    (LTR,R1,R1,M),OR,  IF NO GROUP OCCURENCES               +\n               (LTR,R1,R1,Z)\n         MVC   PRTBUF+1(30),=CL30'*** INVALID CATALOG RECORD ***'\n         BAL   R10,PRINT\n         B     EXIT               EXIT\n         ENDIF\n         LA    R4,GOPNO+1         POINT TO START OF GOP'S\n         DO    FROM=(R1)          DO UNTIL END OF GOP'S\n         LA    R4,GOPLEN(R4)      POINT TO NEXT GOP\n         ENDDO\n         LA    R4,2(R4)           POINT PAST CONTROL BYTES\n* POINT TO AMSDB GROUP OCCURRENCE IN INDEX RECORD\n         USING AMSDB,R4\n* PRINT KEY LENGTH\n         XR    R1,R1\n         ICM   R1,B'0011',AMDKEYLN\n         BAL   R10,CONVERTP\n         MVC   PRTBUF+1(18),=CL18'DEFINED KEY LENGTH'\n         MVC   PRTBUF+50(L'WORK6),WORK6\n         BAL   R10,PRINT\n* SAVE NO. OF CONTROL INTERVALS PER CONTROL AREA\n         XR    R1,R1\n         ICM   R1,B'0011',AMDCIPCA\n         IF    (LTR,R1,R1,Z)\n         MVC   PRTBUF+1(20),=CL20'** INVALID CIS/CA **'\n         BAL   R10,PRINT\n         B     EXIT\n         ENDIF\n         ST    R1,CICA             SAVE CIS/CA\n         L     R10,RDSAVE1\n         BR    R10\nRDSAVE1  DS    F\n         DROP  R3,R4\n         EJECT\n* PRINT - PRINT RTN, CLEARS BUFFER AFTER PRINT\nPRINT    DS    0H\n         ST    R10,PRSAVE1\n         IF    (CLI,PRTBUF,NE,NEWLINE),AND,   IF INVALID CTL CHAR      +\n               (CLI,PRTBUF,NE,NEWPAGE),AND,                            +\n               (CLI,PRTBUF,NE,NEWLINE2)\n         MVI   PRTBUF,NEWLINE                 SET DEFAULT\n         ENDIF\n         PUT   PRINTFL\n         MVI   PRTBUF,NEWLINE                 RESET CTL CHAR\n         MVC   PRTBUF+1(L'PRTBUF-1),PRTBUF    CLEAR PRINT BUFFER\n         L     R10,PRSAVE1\n         BR    R10                 RETURN\nPRSAVE1  DS    F\n         EJECT\n* BADRET - TEST VSAM RETCODE\n* INPUT - R15\nBADRET   DS    0H\n* SAVE RETCODE, SET UP VSAM SAVE AREA FIELD\n         ST    R15,SAVER15         SAVE R15\n         BAL   R10,PRINT           SPACE 1\n* PRINT HEADING\n         LA    R5,4                FOR RETCODE TEST\n         LA    R4,PRTBUF+1         R4 = PRT BUFFER PTR (PAST CTL CHAR)\n         MVC   0(L'VSAMMSG,R4),VSAMMSG   'VSAM ERROR'\n         LA    R4,L'VSAMMSG+1(R4)  BUMP BUFFER PTR\n         MVC   0(L'OPERATN,R4),OPERATN   IDENTIFY VSAM OPERATION\n         BAL   R10,PRINT           ERROR MESSAGE HEADER\n* PRINT R15 VALUE\n         LA    R4,PRTBUF+1         R4 => PRINT BUFFER + CTL CHAR\n         MVC   0(L'HDR3,R4),HDR3   GET HEADER 3\n         LA    R4,L'HDR3(R4)       BUMP BUFFER PTR\n         MVC   WORK1,SAVER15       GET R15 VALUE\n         BAL   R10,CONVERT         CONVERT TO PRINTABLE HEX\n         MVC   0(L'WORK2,R4),WORK2  MOVE VALUE TO BUFFER\n         BAL   R10,PRINT           PRINT R15 VALUE\n* IF OPEN/CLOSE, TEST ACB FOR RETCODE\n         LA    R4,PRTBUF+1         R5 => PRT BUFFER PTR + CTL CHAR\n         IF    (CLC,OPERATN,EQ,=CL8'OPEN'),OR,    IF OPEN/CLOSE        +\n               (CLC,OPERATN,EQ,=CL8'CLOSE')\n         SHOWCB ACB=VSMACB,                                            +\n               AM=VSAM,                                                +\n               AREA=RETCODE,                                           +\n               LENGTH=4,                                               +\n               FIELDS=ERROR\n         MVC   WORK1,RETCODE       GET RETCODE\n         BAL   R10,CONVERT         CONVERT TO PRINTABLE HEX\n         LA    R4,PRTBUF+1         R4 => PRT BUFFER PTR + CTL CHAR\n         MVC   0(L'HDR1,R4),HDR1   GET HEADER 1\n         LA    R4,L'HDR1(R4)       BUMP BUFFER PTR\n         MVC   0(L'WORK2,R4),WORK2 MOVE VALUE TO BUFFER\n         LA    R4,L'WORK2+2(R4)    BUMP BUFFER PTR\n         BAL   R10,PRINT           PRINT ACB INFO\n         B     EXIT                END IT ALL\n         ENDIF\n* IF 'SHOWCB', GET ERROR CODE\n         IF    (CLC,OPERATN,EQ,=CL8'SHOWCB')     IF 'SHOWCB'\n         SHOWCB RPL=VSMRPL,        SHOWCB FOR RPL                      +\n               AM=VSAM,                                                +\n               AREA=RETCODE,                                           +\n               LENGTH=4,                                               +\n               FIELDS=FDBK\n         MVC   WORK1,RETCODE       GET RETCODE\n         BAL   R10,CONVERT         CONVERT TO PRINTABLE HEX\n         MVC   0(L'HDR5,R4),HDR5   GET HEADER 2\n         LA    R4,L'HDR5(R4)       BUMP BUFFER PTR\n         MVC   0(L'WORK2,R4),WORK2  MOVE VALUE TO BUFFER\n         BAL   R10,PRINT           PRINT RPL INFO\n         B     EXIT                END IT ALL\n         ENDIF\n* IF 'GET', GET FEEDBACK CODE\n         IF    (CLC,OPERATN,EQ,=CL8'GET')\n         SHOWCB RPL=CATRPL,AREA=CATSHOW,LENGTH=72,FIELDS=FDBK\n         L     R1,CATSHOW\n         BAL   R10,CONVERTP\n         MVC   PRTBUF+1(24),=CL24'VSAM ERROR CODE (DEC) = '\n         MVC   PRTBUF+1+24(L'WORK6),WORK6\n         BAL   R10,PRINT           PRINT ERROR CODE\n         BAL   R10,PRINT           PRINT A LINE\n         B     EXIT                END IT ALL\n         ENDIF\n* EXIT\n         B     EXIT                END IT ALL\nSAVER15  DC    F'0'                SAVE FIELD FOR R15\nCATSHOW  DS    CL72\n         EJECT\n* CONVERTP - CONVERT BINARY TO PRINTABLE DECIMAL NO.\n* INPUT  - R1\n* OUTPUT - WORK6 (11 BYTES)\nCONVERTP DS    0H\n         ST    R10,COSAVE1         SAVE RETURN ADDRESS\n         XC    WORK5,WORK5         CLEAR WORK FIELD\n         CVD   R1,WORK5            PUT INTO DW FIELD\n         MVC   WORK6,EDIT1         PUT IN EDIT PATTERN\n         ED    WORK6,WORK5         EDIT RESULT INTO WORK6\n         IF    (CLC,WORK6(L'WORK6),EQ,KBLANKS)  IF NO MESSAGES\n         MVI   WORK6+L'WORK6-1,C'0' SET TO ZERO\n         ENDIF\n         L     R10,COSAVE1\n         BR    R10                 RETURN\nCOSAVE1  DS    F\n         EJECT\n* CONVERT - CONVERT TO PRINTABLE HEX\n* INPUT  - WORK1 (4 BYTES)\n* OUTPUT - WORK2 (10 BYTES)\nCONVERT  DS    0H\n         ST    R10,CONSAVE1        SAVE RETURN ADDRESS\n         XC    WORK2,WORK2         CLEAR WORK2 FIELD\n         UNPK  WORK2(9),WORK1(5)   UNPACK INPUT FLD\n         TR    WORK2(8),HEXTAB-240 CONVERT TO HEX\n         IF    (OC,WORK2,WORK2,NZ)  IF NOT CONTROL RECORD\n         LA    R5,L'WORK2-1        R5 = LENGTH WORK FIELD - 1\n         LA    R3,WORK2            R3 => WORK FIELD\n         DO    FROM=(R5)           DO UNTIL END OF FIELD\n         IF    (CLI,0(R3),EQ,X'00')   IF ZERO\n         MVI   0(R3),C' '          REPLACE BY BLANKS\n         ENDIF\n         LA    R3,1(R3)            BUMP PTR\n         ENDDO\n         ENDIF\n         L     R10,CONSAVE1        RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\nCONSAVE1 DS    F\n         EJECT\nDATAAREA DS    0F\n         LTORG\n* REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nTRTAB    DC    X'FAFBFCFDFEFF'\n         ORG   TRTAB+240-193\n         DC    C'0123456789'\nRCOUNT   DC    F'0'                  RECORD COUNT\nOPERATN  DC    CL8' '                VSAM OPERATION BEING PERFORMED\nVSAMMSG  DC    C'VSAM ERROR FOR '    HEADER FOR VSAM ERROR MESSAGE\nVSAMSAVE DC    18F'0'                VSAM SAVE AREA FOR SHOWCB\nKBLANKS  DC    CL16' '\nWORK1    DC    F'0'                  WORK FIELD\nWORK2    DC    XL10'00000000000000000000'\nWORK3    DC    D'0'\nWORK5    DC    D'0'\nWORK6    DC    CL16' '\nEDIT1    DC    XL16'4B202020202020202020202020202020'   EDIT PATTERN\n         DS    0F\nPRTBUF   DC    CL132' '              PRINT BUFFER\nPRTLEN   EQU   *-PRTBUF              PRINT BUFFER LENGTH\nNEWLINE  EQU   C' '                  NEW LINE PRT CTL CHAR\nNEWLINE2 EQU   C'0'                  NEW LINE PRT CTL CHAR (SPACE 2)\nNEWPAGE  EQU   C'1'                  PRINT CTL CHAR FOR NEW PAGE\nRETCODE  DC    F'0'                  VSAM RETCODE\nHEXTAB   DC    C'0123456789ABCDEF'\nHDR1     DC    C'OPEN/CLOSE CODE = '\n         DS    0F\nHDR5     DC    C'REQUEST CODE = '\n         DS    0F\nHDR3     DC    C'R15 = '\n* DTF'S, ACB'S ETC.\n         DS    0F\nPRINTFL  DTFPR DEVADDR=SYSLST,     PRINT FILE DTF                      +\n               DEVICE=1403,                                            +\n               BLKSIZE=132,                                            +\n               CTLCHR=ASA,                                             +\n               IOAREA1=PRTBUF,                                         +\n               RECFORM=FIXUNB\n* CATALOG RPL (ACB ADDRESS IS PLUGGED IN BY THE PROGRAM)\nCATKEY   DC    X'00'\nINDEXCI  DC    XL3'000000'              SEARCH ARG = CI NO\nCATRPL   RPL   AM=VSAM,                                                +\n               AREA=RECBUF,                                            +\n               KEYLEN=4,                                               +\n               ARG=CATKEY,                                             +\n               AREALEN=505,                                            +\n               OPTCD=(KEY,DIR,NUP,MVE,GEN),                            +\n               RECLEN=505               MAX. RECLEN\nRECBUF   DS    CL505\n* VSAM ACB\n         DS    0F\nVSMACB   ACB   AM=VSAM,                                                +\n               DDNAME=IFILE,                                           +\n               MACRF=(ADR,SEQ,IN),                                     +\n               EXLST=VSMEXIT,                                          +\n               STRNO=1\nIFILE    DC    CL7'IFILE'\nVSMEXIT  DS    0H\n         EXLST AM=VSAM,                                                +\n               EODAD=EOF\n* VSAM RPL\n         DS    0F\nVSMARG   DS    CL40                DUMMY ARGUMENT (NOT USED)\n         DS    0F\nVSMRPL   RPL   ACB=VSMACB,                                             +\n               AM=VSAM,                                                +\n               AREA=BUFADDR,                                           +\n               ARG=VSMARG,                                             +\n               AREALEN=4,               LOCATE MODE - ONLY WANT ADDRESS+\n               OPTCD=(ADR,SEQ,NUP,LOC),                                +\n               RECLEN=16384             MAX. RECLEN\nBUFADDR  DS    F                     VSAM BUFFER ADDRESS (RETURNED)\n* DSECT FOR INDEX RECORD\nISECT    DSECT\nIHDRLEN  EQU   24                    LENGTH OF INDEX RECORD HDR\nILEN     DS    XL2                   RECORD LENGTH\nCTRLLEN  DS    XL1                   LENGTH OF CONTROL INFO\nVLEN     DS    XL1                   LENGTH OF VERTICAL PTR\n         ORG   ILEN+X'10'\nLEVEL    DS    XL1                   LEVEL NO. (X'01' = SEQUENCE SET)\n         DS    XL1\nUNUSED   DS    XL2                   OFFSET OF UNUSED DATA\n* CATALOG RECORD DSECT FOR DATA COMPONENT\nDATREC   DSECT\nKEY      DS    CL44                    KEY\n         ORG   KEY\n         DS    XL1                     BINARY ZEROES\nENTIDNO  DS    XL3                     CI NO OF ENTRY\nRELIND   DS    XL1                     RELEASE INDICATOR\nCRAVOL   DS    CL6                     CRA VOLSER\nCRAIDNO  DS    XL3                     CRA CI NO\nCRADEVT  DS    CL4                     CRA DEVICE TYPE\n         DS    XL26                    BINARY ZEROES\nENTYPE   DS    CL1                     'D' FOR DATA, 'I' FOR INDEX\nRRECLEN  DS    XL2                     RECORD LENGTH\n         DS    XL1                     ALWAYS ZERO\nFIXLEN   DS    XL1                     LENGTH OF FIXED LENGTH FIELDS\nNAME     DS    CL44                    ENTRY NAME\nOWNERID  DS    CL8                     OWNER\nDSETCRDT DS    PL3                     CREATION DATE (YDD)\nDSETEXDT DS    PL3                     EXPIRY DATE (YDD)\nATTR1    DS    XL1                     ATTRIBUTES\nSPEED    EQU   X'80'   1... ....       SPEED\nUNIQUE   EQU   X'40'   .1.. ....       UNIQUE\nREUSE    EQU   X'20'   ..1. ....       REUSE\nERASE    EQU   X'10'   ...1 ....       ERASE\nRECOVER  EQU   X'08'   .... 1...       RECOVERABLE CATALOG\nNOUPDATE EQU   X'04'   .... .1..       UPDATE INHIBITED\nEXPIND   EQU   X'02'   .... ..1.       TEMPORARILY EXPORTED\n***                    .... ...X       RESERVED FOR OS/VSAM\nATTR2    DS    XL1                     ATTRIBUTES (DATASHARING)\n**                     00XX XXXX       SHR(1)\nSHR2     EQU   X'40'   01XX XXXX       SHR(2)\nSHR3     EQU   X'80'   10XX XXXX       SHR(3)\nSHR4     EQU   X'C0'   11XX XXXX       SHR(4)\nNOALLOC  EQU   X'08'   .... 1...       NO-ALLOCATION CLUSTER\nNOUSE    EQU   X'01'   .... ...1       DATASET NOT USEABLE\n**                     .... .XX.       RESERVED\nOPENIND  DS    XL1                     OPEN FLAG\nOPEN     EQU   X'80'                   DATA SET OPEN FOR OUTPUT\nBUFSIZE  DS    XL4                     MINIMUM BUFFERSIZE\nPRIMSPAC DS    XL3                     PRIMARY ALLOCATION\nSCONSPAC DS    XL3                     SECONDARY ALLOCATION\nSPACOPTN DS    XL1                     SPACE OPTIONS FLAGS\nTRACKS   EQU   X'80'   10XX XXXX       TRACKS\nCYLS     EQU   X'C0'   11XX XXXX       CYLINDERS\nSECPRIM  EQU   X'20'   ...0 0000       SECONDARY SPACE CLASS = PRIMARY\nSEC0     EQU   X'10'   ...1 0000       SECONDARY IS CLASS 0\nCLASS0   EQU   X'00'   XXXX X000       CLASS 0 SPACE\nCLASS1   EQU   X'01'   XXXX X001       CLASS 1 SPACE\nCLASS2   EQU   X'02'   XXXX X010       CLASS 2 SPACE\nCLASS3   EQU   X'03'   XXXX X011       CLASS 3 SPACE\nCLASS4   EQU   X'04'   XXXX X100       CLASS 4 SPACE\nCLASS5   EQU   X'05'   XXXX X101       CLASS 5 SPACE\nCLASS6   EQU   X'06'   XXXX X110       CLASS 6 SPACE\nCLASS7   EQU   X'07'   XXXX X111       CLASS 7 SPACE\nHURBADS  DS    CL4                     HIGH USED RBA\nHARBADS  DS    CL4                     HIGH ALLOC RBA\nLRECL    DS    CL4                     LRECL FOR DATA, X'FF'S FOR IDX\nUSERINFO DS    CL2                     USER INFO FOR ISAM INTERFACE\nEXCPEXIT DS    CL8                     NAME OF EXCEPTION EXIT\nEXTPTR   DS    XL5                     POINTER TO EXTENSION RECORD\n**                                     (ZERO IF NONE)\nGOPNO    DS    XL1                     NO. OF GROUP OCCURENCE PTRS\n         DS    0C                      SEE GOPREC DSECT\n* GROUP OCCURENCE DSECTS\nGOPREC   DSECT                         GO PTRS\nGROUP0   DS    CL5                     REPEATED 'GOPNO' TIMES\n         ORG   GROUP0\n         DS    XL1                     RESERVED\nGPTR     DS    XL2                     CI NO OF EXTENSION RECORD\n*                                      (IF GRPFLAG = B'10XXXXXX')\n*                                      ELSE DISP FROM GROUP0\n*                                      (IF GRPFLAG = B'00XXXXXX')\n*                                      ELSE DELETED GROUP\n*                                      (IF GRPFLAG = B'01XXXXXX')\nGRPFLAG  DS    XL1\nAMSDBTYP EQU   X'01'                   AMSDB POINTER\nGSEQNO   DS    XL1                     SEQUENCE NO. OF GROUP\nGOPLEN   EQU   *-GROUP0                LENGTH OF GROUP OCCURENCE PTR\n* AMSDB - ACCESS METHOD DATA STATS BLOCK FOR CATALOG RECORD\nAMSDB    DSECT\nAMSDBID  DS    XL1                     IDENTIFIER\nAMID     EQU   X'60'\nAMDATTR1 DS    XL1                     ATTRIBUTES\nAMDDST   EQU   X'80'   1... ....       KSDS\nAMDWCK   EQU   X'40'   .1.. ....       WRITECHECK\nAMDSDT   EQU   X'20'   ..1. ....       IMBED\nAMDREPL  EQU   X'10'   ...1 ....       REPLICATE\nAMDORDER EQU   X'08'   .... 1...       ORDERED\nAMDRANGE EQU   X'04'   .... .1..       FILE HAS KEYRANGES\nAMDRRDS  EQU   X'02'   .... ..1.       RRDS\nAMDSPAN  EQU   X'01'   .... ...1       SPANNED\nAMDLEN   DS    XL2                     LENGTH OF THIS BLOCK\nAMDNEST  DS    XL2                     NO. OF ENTRIES IN INDEX SECTION\n         ORG   AMDNEST                 (EXCEPT IF DATA RECD OF AIX)\nAMDAXRKP DS    XL2                     RELATIVE KEY POSITION IF AIX\nAMDRKP   DS    XL2                     RELATIVE KEY POSITION\nAMDKEYLN DS    XL2                     KEY LENGTH\nAMDPCTCA DS    XL1                     CA FREE % (UNLESS SAM ESDS)\n         ORG   AMDPCTCA\nAMDRCFRM DS    XL1                     SAM ESDS ATTRIBUTES\nAMDIMPFD EQU   X'80'   1... ....       IMPLICIT DEFINE\n**       EQU   X'40'   .1.. ....\nAMDNCIFT EQU   X'20'   ..1. ....       NO-CIFORMAT\nAMDNCAFT EQU   X'10'   ...1 ....       NO-CAFORMAT (SAM ESDS)\n**       EQU   X'08'   .... 1...       ORDERED\nAMDSBLKD EQU   X'04'   .... .1..       BLOCKED RECORDS\nAMDSVAR  EQU   X'02'   .... ..1.       VARIABLE LENGTH\nAMDSFIXD EQU   X'01'   .... ...1       FIXED LENGTH\nAMDPCTCI DS    XL1                     CI FREE %\nAMDCIPCA DS    XL2                     CIS PER CA\nAMDFSCA  DS    XL2                     FREE CIS PER CA\nAMDFSCI  DS    XL4                     FREE BYTES PER CI\nAMDCINV  DS    XL4                     CISIZE\nAMDLRECL DS    XL4                     MAX. RECSZ\nAMDHLRBA DS    XL4                     RBA OF HIGH LEVEL INDEX RECORD\n         ORG   AMDHLRBA\nAMDNSLOT DS    XL4                     NO. OF RELATIVE RECORD SLOTS\n         ORG   AMDHLRBA\nAMDBLREC DS    XL4                     SAM LRECL FOR FB SAM ESDS\nAMDSSRBA DS    XL4                     RBA OF 1ST SEQUENCE SET RECORD\n         ORG   AMDSSRBA\nAMDMAXRR DS    XL4                     MAX. RELATIVE RECORD NO.\nAMDPARDB DS    XL4                     POINTER TO 1ST ARDB\nAMDATTR3 DS    XL1                     ATTRIBUTES\nAMDUNQ   EQU   X'80'   1... ....       NON-UNIQUE KEYS IN AIX\n*******  EQU   X'00'   .... ....       UNIQUE KEYS IN AIX\n         DS    XL7                     RESERVED\n* STATISTICS\nAMDSTAT  DS    0C                      STATISTICS\nAMDSTMST DS    XL8                     SYSTEM TIME STAMP\nAMDSTAT1 DS    0C\nAMDNIL  DS    XL2                     NO. OF INDEX LEVELS\nAMDNEDB DS    XL2                     NO. OF EDB'S\n        ORG   AMDNEDB\nAMDNEXT DS    XL2                     NO. OF EXTENTS\nAMDNLR  DS    XL4                     NO. OF LOGICAL RECORDS\nAMDDELR DS    XL4                     NO. OF DELETED RECORDS\nAMDIREC DS    XL4                     NO. OF INSERTED RECORDS\nAMDUPR  DS    XL4                     NO. OF UPDATED RECORDS\nAMDRETR DS    XL4                     NO. OF RETRIEVED RECORDS\nAMDASPA DS    XL4                     BYTES FREE SPACE IN DATA SET\nAMDNCIS DS    XL4                     NO. OF CI SPLITS\nAMDNCAS DS    XL4                     NO. OF CA SPLITS\nAMDEXCP DS    XL4                     EXCPS\n         END\n\nThe equations used to calculate the average key entry length of\na VSAM KSDS file were excerpted from the book VSAM\nTuning and Advanced Topics by Michael D Sachais (Van\nNostrand Reinhold Publishers, ISBN 0-442-31822-0).\n\nDavid Roth (Australia)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A001A04": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00b\\x00b\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 98, "newlines": 98, "modlines": 0, "user": "VSAMUPD"}, "text": "Improving KSDS performance using IAM\n\n\nTHE PROBLEM\n\nIn 1988 our company had an influx of business which needed\nto be processed through one of our computer systems.  This\nincrease in throughput had a dramatic effect on the\nperformance of these systems.  For example, some programs\nwhich would have normally run for 10 or 15 minutes were now\nrunning for 7 or more hours.  This had an impact on the on-line\nsystem and the operational day had to be extended to 24 hours\nto accommodate all the work.\n\nThe problem was related to the fact that there was a significant\nincrease in the activity against VSAM files.  We began to tune\nthe system by adding and reviewing VSAM tuning parameters\nfollowing a review of the definitions of these files.  This did\nimprove the situation to a degree; however, the effect was still\nnegligible in relation to the needs of the business and the\noperation of the systems.\n\n\nTHE SOLUTION\n\nWe began to review the tuning products which existed on the\nmarket to see what we could use to assist us with automatic\ntuning of VSAM files and, more importantly, to find a product\nwhich could dramatically change the performance of the\napplication against the VSAM files.\n\nWe heard about Innovation Access Method (IAM) from\nInnovation Data Processing, who claimed that the product\ncould change the performance of VSAM files with no change\nto the application code, but with either a minor change to JCL\nor by changing the name of a dataset.  The claims were:\n\no      Ease of switching between IAM and VSAM\n\no      Slashing disk I/O by between 50% and 90%\n\no      A CPU saving of 20% to 40%\n\no      Disk savings of 30% to 70%, although this would have a\n      negative effect on some of the savings made above.\n\nOur initial reaction was that it could not really be true; after all\nwe had tried most, if not all, of the parameter changes that are\npossible and the effect was not as dramatic.  Because we were\ndesperate to find a solution to our problem, we took delivery of\nthe product for a trial.\n\n\nTHE TRIAL\n\nThe product was easy to install.  The trial was fairly\nstraightforward in that we already had the testing example; all\nthat was needed was for us to rebuild the files under IAM and\nrun the tests.  As we adopted the principle of changing the JCL\nand not renaming files, it was extremely simple to change the\nfile between VSAM and IAM.\n\nThe first test was to run a back-up job against one of the rebuilt\nfiles, which gave a saving of 20% in elapsed time, and 58% in\nEXCP.  We therefore extended our testing to a processing job\nwhich used the same files but randomly.  The first program that\nwe tested gave a saving of 79% in elapsed time, down from 41\nminutes to just over 8 minutes, and an EXCP saving of 79%\nalso, with I/Os being reduced from 251 000 to just over 50 000.\n\nWe then ran our program which had taken seven hours.  The\nresults were more dramatic still, with savings of 89% in\nelapsed time, down from just over seven hours to just over 50\nminutes, and a reduction of I/O rates from over 1 300 000\nEXCPs down to 358 000.\n\nWithin IAM there are various tuning parameters which can be\nused to improve performance even further.  These parameters\nare now being used to ensure that we are able to get the most\nfrom the product.  We have not concerned ourselves with disk\nspace reduction because our main objective is to improve the\nperformance of applications.  However, we did trial that\nfeature and noticed a reduction in performance.\n\n\nCONCLUSION\n\nThe end result is that the operational day has been reduced and\nthe business is processed within the reduced operational day.\nAs with every good story there are some drawbacks, and IAM\nis no exception.  This product can be used against standard\nKSDS files only; it does not currently permit conversion of\nESDS, RRDS, or any KSDS file that have an alternate index defined.\n\nPhilip Matta\nApplication Support Superintendent\nProvident Mutual Life Assurance Association (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A001A05": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x02\\x03\\x02\\x03\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 515, "newlines": 515, "modlines": 0, "user": "VSAMUPD"}, "text": "Compact VSAM ESDS printout\n\n\nPURPOSE\n\nThe standard IBM utility for processing VSAM clusters,\nIDCAMS, is characterized by its lack of many elementary\nfunctions, eg the ability to process individual records.\nHowever, such processing can often be achieved by using\nIDCAMS facilities in combination; eg record deletion can be\nperformed by copying those records which are not to be deleted\nto another dataset, deleting the original dataset, and then\nrenaming the second dataset to the name of the first dataset.\nThis, however, requires that the records can be identified; for\nKSDS clusters this is easily done by means of the key, for\nESDS clusters the record identification is the RBA (Relative\nByte Address).  The dataset must be printed to obtain the RBA.\nSuch a printout is practicable only for a small dataset - this is\nespecially true for datasets containing large records (only\ncomplete records can be printed).\n\nThe ESDSLIST program produces a compact listing giving:\n\no      One (selected) line for each record\n\no      Only each nth record is printed (eg every hundredth record).\n\nThe part of the records to be printed and the step size (n) can\nbe specified as parameters.  The listed records are\nautomatically formatted in character or hexadecimal, as\nappropriate.\n\n\nSAMPLE JOB\n\n//S1       EXEC PGM=ESDSLIST,PARM=01000140\n//SYSUT1   DD   DSN=VSAM.TEST.ESDS,DISP=SHR\n//SYSPRINT DD   SYSOUT=A\n\nSYSUT1 is the VSAM cluster, and SYSPRINT gives the name\nof the list file.  The optional EXEC PARM (mmmmnnnnpppp)\nspecifies the following parameters:\n\no      mmmm      first position in the record to be listed (default 0001)\n\no      nnnn      last position in the record to be listed (default 0080)\n\no      pppp      step size (default 0001).\n\nEach of these sub-options can be omitted from the right-hand side.\n\n\nSAMPLE OUTPUT\n\nFigure 1 shows an example of the output.  The dataset name (in\nthis case VSAM.TEST.ESDS) is printed in the second heading\n\nline.\n\nRECNO gives the record number, RBA the relative byte\naddress of the listed record, RECLEN specifies the record\nlength, FLAGS lists any status flags.  These could be:\n\no      X - record printed in hexadecimal format\n\no      L - record length warning, the specified last position (from\n      the EXEC PARM) lies outside the record\n\no      T - truncation error, the specified first position (from the\n      EXEC PARM) lies outside the record - no record data are\n      printed.\n\nRECORD gives the displayed data.\n\n\nPROGRAM\n\n         TITLE 'VSAM RBA-PRINT'\n         PRINT NOGEN\n         SPACE 2\n* Compact analysis-program for VSAM-ESDS file (record number and RBA)\n         SPACE 1\n* DD-Statements:\n*    SYSUT1 - INPUT (VSAM) FILE\n*  SYSPRINT - LIST-FILE\n         SPACE 1\n* EXEC-Parameter (optional): mmmmnnnnpppp\n*    mmmm - start position of data in record (default 0001)\n*    nnnn - end position of data in record (default 0080)\n*    pppp - step size (default 0001)\n         SPACE 1\n* Return Code:\n*   0 - ok\n*   8 - nok, EXEC-parameter length error (not 0, 4, 8 or 12)\n*  12 - nok, EXEC-parameter formal error\n         SPACE 3\nESDSLIST CSECT\n* initialise addressing\n         STM   R14,R12,12(R13)    save registers\n         BALR  R12,0              base register\n         USING *,R12\n         LA    R15,SA             A(save-area)\n         ST    R13,4(R15)         backward ptr\n         ST    R15,8(R13)         forward ptr\n         LR    R13,R15            A(new save-area)\n         B     SA_END             jump over save-area\nSA       DS    18A                save-area\nSA_END   DS    0H\n         SPACE 1\n         L     R2,0(R1)           A(EXEC-parameter)\n         LH    R0,0(R2)           L(EXEC-parameter)\n         LTR   R0,R0\n         BZ    A010               :no parameter\n         SR    R1,R1              zeroize R1\n         SRDL  R0,2               R0-R1 / 4\n* test for ramainder (= error)\n         MVC   RC,=H'8'           set default ReturnCode\n         LTR   R1,R1\n         BNZ   EOJ                :length error\n         CH    R1,3               maximum no. of sub-parameters\n         BH    EOJ                :too many\n* process parameters\n         MVC   RC,=H'12'          set default ReturnCode (if error)\n         LA    R3,STARTADD        first parameter (processed)\n         SPACE 1\nA020     PACK  D,2(4,R2)\n         CVB   R1,D\n         LTR   R1,R1\n         BZ    EOJ                zero value invalid\n         ST    R1,0(R3)           save processed parameter\n         LA    R2,4(R2)           update pointer (input)\n         LA    R3,4(R3)           update pointer (output)\n         BCT   R0,A020            :loop\n         SPACE 1\n* validate parameters\n         L     R1,ENDADD          end address\n         S     R1,STARTADD        - start address (=difference)\n         BM    EOJ                end address < start address\n         C     R1,=A(L'P1REC)     test maximum length\n         BH    EOJ                too long\n         SPACE 1\nA010     MVC   RC,=H'0'           reset ReturnCode\n         SPACE 1\n         OPEN  (SYSUT1,(INPUT),SYSPRINT,(OUTPUT))\n         SPACE 1\n         LA    R5,SYSUT1          A(ACB)\n         USING IFGACB,R5\n         BAL   R14,GETDSN         get DS-Name\n         MVC   P3DSNAME,DSNAME\n* get date and time-of-day\n         TIME\n* R0: time of day (hhmmssth)\n* R1: date (00yydddF)\n         ST    R0,WK\n         MVC   P3TOD,=X'4021207A2020'\n         ED    P3TOD,WK\n         ST    R1,WK\n         MVC   P2DATE,=X'4021204B202020'\n         ED    P2DATE,WK+1\n         SPACE 1\n* print headings\n         PUT   SYSPRINT,P2\n         PUT   SYSPRINT,P3\n         PUT   SYSPRINT,P5\n         SPACE 2\n* set stepsize (for display)\nA100     L     R4,STEPSIZE\n* read record\nA110     LA    R3,RPL\n         GET   RPL=RPL            get record\n         STH   R15,RC\n         BAL   R14,MSG\n         DC    CL8'GET'\n* increment record-count\n         AP    RECCT,=P'1'        total count\n         SPACE 1\n         BCT   R4,A110\n         SPACE 1\n* get RBA and record length\n         SHOWCB RPL=RPL,                                               X\n               AREA=RBA,                                               X\n               LENGTH=8,                                               X\n               FIELDS=(RBA,RECLEN)\n         SPACE 1\n* format record number\n         MVC   P1RECNO,=X'4020202020202120'\n         ED    P1RECNO,RECCT\n         SPACE 1\n* format RBA\n         L     R0,RBA\n         CVD   R0,D\n         MVC   P1RBA,=X'4020202020202120'\n         ED    P1RBA,D+4\n         SPACE 1\n* format record length\n         L     R0,RECLEN\n         CVD   R0,D\n         MVC   P1RECLEN,=X'4020202020202120'\n         ED    P1RECLEN,D+4\n         SPACE 1\n* display record identifier\n         SPACE 1\n         BAL   R14,PRINTREC\n         SPACE 1\n         B     A100               next step block\n         SPACE 3\nA200     DS    0H                 end-of-file\n         SPACE 1\n         MVC   P1,P1-1            clear P1\n         PUT   SYSPRINT,P1        print blank line\n         ZAP   D,RECCT\n         SPACE 1\n         MVC   P1+12(24),=CL24'RECORD(S) READ'\n         BAL   R14,PRINTCT        print record count\n         SPACE 2\nA300     CLOSE (SYSPRINT,,SYSUT1)\n         SPACE 1\nEOJ      DS    0H\n         LH    R15,RC             program ReturnCode\n         L     R13,4(R13)         restore A(old save-area)\n         RETURN (14,12),RC=(15)\n         SPACE 1\n* symbolic register equates\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nRC       DS    H\n         EJECT\n         DC    A(0)\nMSG      ST    R14,MSG-4\n         MVC   P0OP,0(R14)\n         SR    R1,R1\n         IC    R1,15(R3)          Reason code (feedback code)\n         ST    R1,FDBK\n         CVD   R1,D\n         UNPK  P0FDBK,D\n         OC    P0FDBK,=C'00'\n         SPACE\n         LTR   R15,R15\n         BZ    MSG1\n         CVD   R15,D\n         UNPK  P0RC,D\n         OC    P0RC,=C'00'\n         CVD   R0,D\n         UNPK  P0R0,D\n         OC    P0R0,=C'00'\n         SPACE\n         PUT   SYSPRINT,P0\n         SPACE\nMSG1     L     R14,MSG-4\n         B     8(R14)\n         EJECT\n         SPACE 1\n         DS    A\nPRINTREC ST    R14,PRINTREC-4\n* print current record (partial)\n* input:\n         SPACE 1\n* get record address (-> R8)\n         BAL   R14,GETREC\n* R2: L(data)\n* format data\n         SPACE\n* truncate if record longer than <P1REC>\n         LA    R15,L'P1REC        L(P1REC) = maximum length\n         CR    R2,R15             L(data):L(P1REC)\n         BL    *+6                L(data)<L(P1REC)\n         LR    R2,R15\n         LTR   R2,R2\n         BZ    PRINTREC1          :no data\n         SPACE\n         BCTR  R2,0               LC(data)\n         MVC   P1REC(0),0(R8)\n         EX    R2,*-6\n         SPACE 1\nPRINTREC1 PUT   SYSPRINT,P1\n         MVC   P1,P1-1            clear\n         SPACE 1\n         L     R14,PRINTREC-4\n         BR    R14\n         SPACE 3\n         DS    A\nGETREC   ST    R14,GETREC-4\n* get record\n* output:\n*        R2: L(record)\n*    <ADDR>: A(record)\n*  <RECLEN>: L(record)\n         SPACE 1\n         LA    R2,0               R2:=0\n         SPACE 1\n         L     R8,ADDR\n         A     R8,STARTADD\n         BCTR  R8,0\n*       R8: A(partial record)\n* check whether record non-display\n         L     R3,ENDADD          end address\n         C     R3,RECLEN\n         BL    *+12\n         L     R3,RECLEN\n         MVI   P1LENFL,C'L'       set length flag\n         SPACE\n         S     R3,STARTADD        - start address\n         MVI   P1TRUNFL,C'T'      set truncated flag\n         SH    R3,=H'1'           LC(partial record)\n         BM    GETREC1\n         MVI   P1TRUNFL,C' '      reset truncated flag\n         TRT   0(0,R8),TRT1\n         EX    R3,*-6\n         LA    R2,1(R3)           L(partial record)\n         BZ    GETREC1            OK\n* non-display character\n* convert to hex\n         MVI   P1HEXFL,C'X'       set hex flag\n         SPACE\n         LR    R0,R2              L(partial record)\n         SRL   R0,1               LENGTH/2\n         LR    R1,R8              A(partial record - input)\n         LA    R15,RECHEX         A(RECHEX) - output\n         LR    R8,R15             A(RECHEX) - output\n         SPACE\nGETREC2  UNPK  WK,0(2,R1)         WK:X'FAFBXX'\n         NC    WK,=X'0F0F00'      WK:X'0A0B00'\n         TR    WK,TR1             WK:C'AB0'\n         MVC   0(2,R15),WK\n         LA    R1,1(R1)\n         LA    R15,2(R15)\n         BCT   R0,GETREC2\n         SPACE\nGETREC1  L     R14,GETREC-4\n         BR    R14\n         SPACE 2\nTRT1     DC    256X'1'\n         ORG   TRT1+X'40'\n         DC    X'0'               BLANK\n         ORG   TRT1+C'\u0082'\n         DC    X'0'\n         ORG   TRT1+C'#'\n         DC    X'0'\n         ORG   TRT1+C'@'\n         DC    X'0'\n         ORG   TRT1+X'81'\n         DC    9X'0'              A-I\n         ORG   TRT1+X'91'\n         DC    9X'0'              J-R\n         ORG   TRT1+X'A2'\n         DC    8X'0'              S-Z\n         ORG   TRT1+C'A'\n         DC    9X'0'\n         ORG   TRT1+C'J'\n         DC    9X'0'\n         ORG   TRT1+C'S'\n         DC    8X'0'\n         ORG   TRT1+C'0'\n         DC    10X'0'\n         ORG\n         SPACE 2\nTR1      DC    C'0123456789ABCDEF'\n         SPACE 2\nRECHEX   DC    CL(L'P1REC)' '\n         DC    C' '\n         SPACE 1\nWK       DS    CL3,C              work-area\n         SPACE 3\n         DS    A\nPRINTCT  ST    R14,PRINTCT-4\n         MVC   P1+3(8),=X'4020202020202120'\n         ED    P1+3(8),D+4\n         SPACE 1\n         PUT   SYSPRINT,P1\n         MVC   P1,P1-1            CLEAR\n         L     R14,PRINTCT-4\n         BR    R14\n         SPACE 3\n         DS    A\nGETDSN   ST    R14,GETDSN-4\n         SPACE 2\n* input:\n*  <ACBTIOT>: offset from TIOT origin to TIOELNGH field\n* output:\n*  <DSNAME>: DSNAME result\n         SPACE\n* GET TIOT-ADDRESS\n         EXTRACT ATIOT,FIELDS=(TIOT)\n         L     R1,ATIOT\n* R1: A(TIOT)\n         SPACE\n         USING TIODSECT,R1\n         AH    R1,ACBTIOT         + offset\n         SPACE 1\n         ICM   R1,B'0111',TIOEJFCB A(JFCB)\n         USING JFCDSECT,R1\n         SPACE\n         MVC   DSNAME,JFCBDSNM\n         SPACE\n         L     R14,GETDSN-4\n         BR    R14                RETURN\n         SPACE\nATIOT    DS    A\nDSNAME   DS    CL44\n         EJECT\nP0       DC    CL121' '\n         ORG   P0+1\n         DC    C'VSAM error '\nP0OP     DS    CL8\n         DC    C'  RC:'\nP0RC     DS    CL2\n         DC    C' FDBK:'\nP0FDBK   DS    CL2\n         DC    C'  R0:'\nP0R0     DS    CL2\n         ORG\n         SPACE 2\n         DC    C' '               clear byte\nP1       DC    CL121' '\n         ORG   P1+1\nP1RECNO  DS    CL8,CL2\nP1RBA    DS    CL8,CL2\nP1RECLEN DS    CL8,CL2\nP1HEXFL  DS    CL1\nP1LENFL  DS    CL1\nP1TRUNFL DS    CL1,CL4\nP1REC    DS    CL80\n         ORG\n         SPACE 1\nP2       DC    CL121'1'\n         ORG   P2+50\n         DC    C'VSAM ESDS LIST'\n         ORG   P2+110\nP2DATE   DS    C' yy.ddd'\n         ORG\n         SPACE 1\nP3       DC    CL121'0'\n         ORG   P3+50\nP3DSNAME DS    CL44\n         ORG   P3+110\nP3TOD    DS    C' hh:mm'\n         ORG\n         SPACE 1\n* heading line\nP5       DC    CL121' '\n         ORG   P5+P1RECNO-P1\n         DC    CL8'   RECNO'\n         ORG   P5+P1RBA-P1\n         DC    CL8'     RBA'\n         ORG   P5+P1RECLEN-P1\n         DC    CL8'  RECLEN'\n         ORG   P5+P1HEXFL-P1\n         DC    C'FLAGS'\n         ORG   P5+P1REC-P1\n         DC    C'RECORD'\n         ORG\n         SPACE 2\nFDBK     DS    A\nD        DS    D\n         SPACE 2\n* counters\nRECCT    DC    PL4'0'             record count\n         SPACE 3\n* DCBS, ACBS, ETC.\nSYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,RECFM=FBA,                     X\n               LRECL=121,BLKSIZE=2420,DSORG=PS,DEVD=DA\n         SPACE 2\nSYSUT1   ACB   DDNAME=SYSUT1,MACRF=(IN,ADR,SEQ),EXLST=EXLST\n         SPACE 1\nEXLST    EXLST EODAD=A200\n         SPACE 2\nRPL      RPL   ACB=SYSUT1,                                             X\n               OPTCD=(NUP,ADR,SYN,LOC,FWD),                            X\n               AREA=ADDR,                                              X\n               AREALEN=4\n         SPACE 2\nADDR     DS    A                  address of data-record\n         SPACE 1\nRBA      DS    A                  RBA address\nRECLEN   DS    A                  record length as read\n         SPACE 1\nSTARTADD DC    A(1)\nENDADD   DC    A(64)\nSTEPSIZE DC    A(1)\n         SPACE 2\n         LTORG\n         SPACE 3\n* dummy-sections\nTIODSECT DSECT\nTIOELNGH DS    AL1                entry length\n         DS    XL3\nTIOEDDNM DS    CL8                DD-Name\nTIOEJFCB DS    AL3                A(JFCB)\n         SPACE 2\nJFCDSECT DSECT\n         DS    XL16               prefix (16 bytes)\n         IEFJFCBN                 , JFCB mapping\n         SPACE 2\n         IFGACB                   , ACB mapping\n         SPACE 2\nACBDSECT DSECT\n         END\nA S Rudd (Germany)                  c A S Rudd 1991\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A001A06": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\xc1\\x01\\xc1\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 449, "newlines": 449, "modlines": 0, "user": "VSAMUPD"}, "text": "VSAM DASD management with help from REXX\n\nDASD management is an essential element of any size DP\nshop.  There are several methods to accomplish this sometimes\nmundane task.  One method that I found very helpful was with\nthe use of REXX.  Our particular shop is VM/SP with VSE and\nMVS guests running underneath.  Therefore, REXX was easy\nto come by.  One of my early assignments was to examine the\nDASD situation on both the VSE and MVS machines,\nimplement dataset naming conventions, eliminate non-essential\ndatasets and continually monitor DASD utilization.  In order to\nobtain the information required, I started with IDCAMS\nLISTCATs.  However the output from the LISTCAT is hard to\ndecipher in that particular format.  Therefore, I wrote a REXX\nEXEC to convert the LISTCAT output to the format that I\nneeded.  The real benefit of this comes from the fact that I can\nquery this data and obtain specific information depending on\nthe situation - for example, if I want to know which VSAM\ndatasets have split CIs and how many.\n\nThe three EXECs and their associated descriptions follow:\n\no      DASDMAN - converts LISTCAT output to 'DASDMAN' format\n\no      QMF - query facility; this simply puts you into full-screen CMS\n\no      SEL - SQL command processor that you can use under\n      QMF or in CMS alone.\n\nAfter running DASDMAN, I can start QMF and type the\nfollowing command to show me the number of VSAM datasets\nwith over 10 split CIs:\n\n      EL * WHERE SPLITCI > 10\n\nYou can look at the SEL EXEC and determine all the keywords\n(eg SPLITCI, SPLITCA, DSN, etc).\n\n\nDASDMAN EXEC\n\n/* REXX   DASD MAN  ***/\n/* READS LISTCAT INFO FROM IDCAMS LISTCAT AND BUILDS A RECORD     */\n/* FOR VSAM COMPONENTS                                            */\n\"VMFCLEAR\"\n\"ERASE DASDMAN DATA A\"\n\"EXECIO * DISKR LISTCAT DATA (STEM X. FINIS\"\nSAY;\nDO I=1 TO X.0 /* DO */\n   PARSE VAR X.I TYPE . DSN .\n   SELECT     /* SELECT */\n    WHEN TYPE = 'AIX' THEN DO          /* THATS ALL FOLKS */\n         I = X.0\n    END                                /* WHEN */\n    WHEN TYPE = \"CLUSTER\" THEN\n     DO\n      DO UNTIL COL1 = \"ASSOCIATIONS\"\n         I = I+1\n         PARSE VAR X.I COL1\n         X.I = TRANSLATE(X.I,\" \",\"-\")\n         FIND = POS(\"CREATION\",X.I)\n          IF FIND > 0 THEN\n             DO\n             PARSE VAR X.I \"CREATION\" CRTDT .\n          END /* IF */\n     END /*DO UNTIL*/\n     DATA = ''\n     DATA = OVERLAY(DSN,DATA,1)\n     DATA = OVERLAY(\"** CLUSTER **\",DATA,33)\n     DATA = OVERLAY(CRTDT,DATA,46)\n     SAY DATA\n     \"EXECIO 1 DISKW DASDMAN DATA A (FINIS VAR DATA\"\n    END /* WHEN */\n   WHEN TYPE = \"DATA\" THEN\n    DO\n     STAR = ''\n     DO UNTIL COL1 = \"EXTENTS:\"\n        CALL FINDVALS\n     END /*DO UNTIL*/\n     DATA = ''\n     DATA = OVERLAY(DSN,DATA,1)\n     DATA = OVERLAY(CRTDT,DATA,46)\n     DATA = OVERLAY(CISIZE,DATA,53)\n     DATA = OVERLAY(SPLITCI,DATA,59)\n     DATA = OVERLAY(SPLITCA,DATA,65)\n     DATA = OVERLAY(TYPE,DATA,71)\n     DATA = OVERLAY(PRI,DATA,80)\n     DATA = OVERLAY(SEC,DATA,86)\n     DATA = OVERLAY(VOLSER,DATA,92)\n     DATA = OVERLAY(EXTENT,DATA,99)\n     DATA = OVERLAY(STAR,DATA,102)\n     SAY DATA\n     \"EXECIO 1 DISKW DASDMAN DATA A (FINIS VAR DATA\"\n    END  /*DO*/\n   WHEN TYPE = \"INDEX\"\n    THEN DO\n     DO UNTIL COL1 = \"EXTENTS:\"\n        CALL FINDVALS\n     END /*DO UNTIL*/\n     DATA = ''\n     DATA = OVERLAY(DSN,DATA,1)\n     DATA = OVERLAY(CRTDT,DATA,46)\n     DATA = OVERLAY(CISIZE,DATA,53)\n     DATA = OVERLAY(SPLITCI,DATA,59)\n     DATA = OVERLAY(SPLITCA,DATA,65)\n     DATA = OVERLAY(TYPE,DATA,71)\n     DATA = OVERLAY(PRI,DATA,80)\n     DATA = OVERLAY(SEC,DATA,86)\n     DATA = OVERLAY(VOLSER,DATA,92)\n     DATA = OVERLAY(EXTENT,DATA,99)\n     SAY DATA\n     \"EXECIO 1 DISKW DASDMAN DATA A (FINIS VAR DATA\"\n    END  /*DO*/\nOtherwise\nEND /* SELECT */\nEND /* DO */\nEXIT 0\n/* FINDVALS PROCDURE */\nFINDVALS:\n        I = I+1\n        PARSE VAR X.I COL1\n        X.I = TRANSLATE(X.I,\" \",\"-\")\n        FIND = POS(\"SAMDATASET\",X.I)\n           IF FIND > 0 THEN\n              DO\n              STAR = '*'\n              END\n        FIND = POS(\"CREATION\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"CREATION\" CRTDT .\n           END /* IF */\n        FIND = POS(\"CISIZE\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"CISIZE\" CISIZE .\n           END /* IF */\n        FIND = POS(\"SPLITS CI\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"SPLITS\" . SPLITCI .\n           END /* IF */\n        FIND = POS(\"SPLITS CA\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"SPLITS\" . SPLITCA .\n           END /* IF */\n        FIND = POS(\"SPACE TYPE\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"SPACE \" . TYPE .\n           END /* IF */\n        FIND = POS(\"SPACE PRI\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"SPACE \" . PRI .\n           END /* IF */\n        FIND = POS(\"SPACE SEC\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"SPACE \" . SEC .\n           END /* IF */\n        FIND = POS(\"VOLSER\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"VOLSER\" VOLSER .\n           END /* IF */\n        FIND = POS(\"EXTENT NUMBER\",X.I)\n           IF FIND > 0 THEN\n              DO\n              PARSE VAR X.I \"EXTENT\" . EXTENT .\n           END /* IF */\nRETURN\n\n\nQMF EXEC\n\n/* REXX */\n/* TURN FULLSCREEN CMS ON TO SIMULATE QMF */\nSET FULLSCREEN ON\n\"VMFCLEAR\"\n\n\nSEL EXEC\n\n/* REXX   DASD MAN  SEL EXEC */\n/* (SQL TYPE PROCESSOR)                                              */\n/* READS DASDMAN DATA A FILE AND PROCESSES ACCORDINGLY               */\n/* FORMAT OF THE ARGUMENTS ARE AS FOLLOWS:                           */\n/* SELECT * WHERE OPERAND1 OPERATOR OPERAND2                         */\n/* OP1  VALUES :DSN CRTDT CISIZE SPLITCI SPLITCA TYPE PRI SEC VOLSER */\n/* OP   VALUES :< > =                                                */\n/* OP2  VALUES :ANYTHING                                             */\n/* (EG SELECT * WHERE CISIZE > 2048)                                 */\n/*                                                                   */\n\"VMFCLEAR\"\nPARSE UPPER ARG AST  . OPERAND1 OPERATOR OPERAND2\nDATA = ''\nDATA = OVERLAY(\"DSN\",DATA,1)\nDATA = OVERLAY(\"CRTDT\",DATA,46)\nDATA = OVERLAY(\"CISZ\",DATA,53)\nDATA = OVERLAY(\"SPCI\",DATA,59)\nDATA = OVERLAY(\"SPCA\",DATA,65)\nDATA = OVERLAY(\"TYPE\",DATA,71)\nDATA = OVERLAY(\"PRI\",DATA,80)\nDATA = OVERLAY(\"SEC\",DATA,86)\nDATA = OVERLAY(\"VOLSER\",DATA,92)\nDATA = OVERLAY(\"EXTENTS\",DATA,99)\nSAY DATA\n\"EXECIO * DISKR DASDMAN DATA A (STEM X. FINIS\"\nDO I=1 TO X.0\n PARSE VAR X.I DSN CRTDT CISIZE SPLITCI SPLITCA TYPE PRI SEC VOLSER EX\n SELECT\n  WHEN OPERATOR = '' THEN\n       DO\n       IF AST = \"*\" THEN\n          DO\n          SAY X.I\n          END\n       END\n  WHEN OPERATOR = \"=\" THEN\n   DO\n    IF OPERAND1 = \"DSN\" THEN\n       DO\n       IF OPERAND2 = DSN THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"CRTDT\" THEN\n       DO\n       IF OPERAND2 = CRTDT THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"CISIZE\" THEN\n       DO\n       IF OPERAND2 = CISIZE THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SPLITCI\" THEN\n       DO\n       IF OPERAND2 = SPLITCI THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SPLITCA\" THEN\n       DO\n       IF OPERAND2 = SPLITCA THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"TYPE\" THEN\n       DO\n       IF OPERAND2 = TYPE THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"PRI\" THEN\n       DO\n       IF OPERAND2 = PRI THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SEC\" THEN\n       DO\n       IF OPERAND2 = SEC THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"VOLSER\" THEN\n       DO\n       IF OPERAND2 = VOLSER THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"EXTENT\" THEN\n       DO\n       IF OPERAND2 = EX THEN\n          DO\n          SAY X.I\n          END\n       END\n    END /* WHEN DO*/\n  WHEN OPERATOR = \">\" THEN\n   DO\n    IF OPERAND1 = \"DSN\" THEN\n       DO\n       IF OPERAND2 < DSN THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"CRTDT\" THEN\n       DO\n       IF OPERAND2 < CRTDT THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"CISIZE\" THEN\n       DO\n       IF OPERAND2 < CISIZE THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SPLITCI\" THEN\n       DO\n       IF OPERAND2 < SPLITCI THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SPLITCA\" THEN\n       DO\n       IF OPERAND2 < SPLITCA THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"TYPE\" THEN\n       DO\n       IF OPERAND2 < TYPE THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"PRI\" THEN\n       DO\n       IF OPERAND2 < PRI THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SEC\" THEN\n       DO\n       IF OPERAND2 < SEC THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"VOLSER\" THEN\n       DO\n       IF OPERAND2 < VOLSER THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"EXTENT\" THEN\n       DO\n       IF OPERAND2 < EX THEN\n          DO\n          SAY X.I\n          END\n       END\n    END /* WHEN DO*/\n  WHEN OPERATOR = \"<\" THEN\n   DO\n    IF OPERAND1 = \"DSN\" THEN\n       DO\n       IF OPERAND2 > DSN THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"CRTDT\" THEN\n       DO\n       IF OPERAND2 > CRTDT THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"CISIZE\" THEN\n       DO\n       IF OPERAND2 > CISIZE THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SPLITCI\" THEN\n       DO\n       IF OPERAND2 > SPLITCI THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SPLITCA\" THEN\n       DO\n       IF OPERAND2 > SPLITCA THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"TYPE\" THEN\n       DO\n       IF OPERAND2 > TYPE THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"PRI\" THEN\n       DO\n       IF OPERAND2 > PRI THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"SEC\" THEN\n       DO\n       IF OPERAND2 > SEC THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"VOLSER\" THEN\n       DO\n       IF OPERAND2 > VOLSER THEN\n          DO\n          SAY X.I\n          END\n       END\n    IF OPERAND1 = \"EXTENT\" THEN\n       DO\n       IF OPERAND2 > EX THEN\n          DO\n          SAY X.I\n          END\n       END\n    END /* WHEN DO*/\n OTHERWISE\n END /* SELECT */\nEND /* DO     */\nSAY;\nEXIT 0\n\nR Scott Ray\nSoftware Engineer\nGT Software Inc (USA)                  c GT Software Inc 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A001A07": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\xc1\\x00\\xc1\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 193, "newlines": 193, "modlines": 0, "user": "VSAMUPD"}, "text": "Building a VSAM alternate index\n\nOperating system and other pre-requisites for all the utilities:\n\no      MVS - DFP 2.3\n\no      CICS/VS - 1.7, 2.1\n\no      The VSAM programs are written for DFP 2.3, and some\n      are release dependent.  The release dependency is due to\n      the inclusion of the AMBL, the AMB, and the AMDSB\n      macros.  The macros for defining these DSECTs are not\n      usually available.\n\n\nAIXBLD1.COB\n\nThis is a COBOL II program that will build a VSAM alternate\nindex from a KSDS.  The code illustrates the method for\nbuilding a UNIQUE alternate index.  The program uses the\nstandard COBOL internal sort verb.  This program replaces the\nBLDINDEX command.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. AIXBLD.\n      *\n      *            THIS PROGRAM WILL BUILD A UNIQUE ALTERNATE\n      *            INDEX FROM A BASE KSDS\n      *\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT VSAMKSDS ASSIGN      VSAMKSDS\n                                  ORGANIZATION INDEXED\n                                  ACCESS SEQUENTIAL\n                                  RECORD VSAMKSDS-KEY\n                                  FILE STATUS WS-VSAMKSDS\n                                              WS-VSAMKSDS-EXT.\n           SELECT VSAMAIX  ASSIGN      VSAMAIX\n                                  ORGANIZATION INDEXED\n                                  ACCESS SEQUENTIAL\n                                  RECORD VSAMAIX-KEY.\n           SELECT SORTFILE ASSIGN UT-S-SORTFILE.\n      /            DATA DIVISION - FILE SECTION\n       DATA DIVISION.\n       FILE SECTION.\n       FD  VSAMKSDS                 RECORD 120\n                                    LABEL RECORDS STANDARD.\n       01  VSAMKSDS-REC.\n           03  VSAMKSDS-KEY         PIC  X(09).\n           03  FILLER               PIC  X(11).\n           03  VSAMKSDS-AKEY        PIC  X(08).\n           03  FILLER               PIC  X(92).\n           SKIP2\n       FD  VSAMAIX                  RECORD 22\n                                    LABEL RECORDS STANDARD.\n       01  VSAMAIX-REC.\n           03  FILLER               PIC  X(05).\n           03  VSAMAIX-KEY          PIC  X(08).\n           03  VSAMAIX-RELKEY       PIC  X(09).\n           SKIP2\n       SD  SORTFILE                 RECORD 22.\n       01  SORTFILE-REC.\n           03  SORTFILE-CONTROL.\n               05  SORTFILE-KSDS    PIC  X(01).\n               05  SORTFILE-PKL     PIC  X(01).\n               05  SORTFILE-OCC     PIC S9(04)     COMP.\n               05  SORTFILE-AKL     PIC  X(01).\n           03  SORTFILE-KEY         PIC  X(08).\n           03  SORTFILE-RELKEY      PIC  X(09).\n      /            DATA DIVISION - WORKING-STORAGE SECTION\n       WORKING-STORAGE SECTION.\n           SKIP1\n       01  WS-FILE-STATI.\n           03  WS-VSAMKSDS          PIC  X(02).\n       01  WS-FILE-STATI-EXT.\n           03  WS-VSAMKSDS-EXT.\n               05  WS-VSAMKSDS-RC   PIC S9(04)     COMP.\n               05  WS-VSAMKSDS-FC   PIC S9(04)     COMP.\n               05  WS-VSAMKSDS-FB   PIC S9(04)     COMP.\n           SKIP1\n       01  WS-FLAGS-ET-ALIA.\n           03  WS-EOF               PIC  X(01).\n               88  EOF-ERROR                                 VALUE '2'.\n               88  EOF                                       VALUE '1'.\n               88  NOT-EOF                                   VALUE '0'.\n           03  WS-COMP-01           PIC S9(04)     COMP      VALUE +1.\n           03  FILLER               REDEFINES WS-COMP-01.\n               05  FILLER           PIC  X(01).\n               05  WS-HEX-01        PIC  X(01).\n           03  WS-COMP-2057         PIC S9(04)     COMP     VALUE 2057.\n           03  FILLER               REDEFINES WS-COMP-2057.\n               05  WS-HEX-08        PIC  X(01).\n               05  WS-HEX-09        PIC  X(01).\n      /            PROCEDURE DIVISION - MAIN CONTROL\n           SKIP1\n       PROCEDURE DIVISION.\n           SKIP1\n       A100-MAIN-CONTROL SECTION.\n           SKIP1\n           PERFORM B100-INITIALIZE.\n           PERFORM B200-PROCESS.\n           PERFORM B300-TERMINATE.\n           STOP RUN.\n      /               THIS SECTION PERFORMS\n      *                   INITIALIZATION OF WORKING STORAGE\n      *                   OPENING OF FILES, READ FIRST INPUT RECORD\n           SKIP2\n       B100-INITIALIZE SECTION.\n           SKIP1\n           SET NOT-EOF              TO TRUE.\n           MOVE ALL '0'             TO WS-FILE-STATI.\n           OPEN INPUT VSAMKSDS.\n           IF  WS-FILE-STATI NOT     = ALL '0'\n               DISPLAY 'OPEN ERROR OCCURRED - FILE'\n               PERFORM Z100-FILE-ERROR\n           END-IF.\n           PERFORM R100-VSAMKSDS.\n      /               THIS SECTION PERFORMS\n      *                   PROGRAM MAIN PROCESSING\n           SKIP2\n       B200-PROCESS SECTION.\n           SKIP1\n           SORT SORTFILE\n               ASCENDING SORTFILE-KEY\n               INPUT  PROCEDURE C100-E15-INPUT\n               GIVING VSAMAIX.\n           IF  SORT-RETURN NOT       = +0\n               SET EOF-ERROR        TO TRUE\n           END-IF.\n      /               THIS SECTION PERFORMS\n      *                   PROGRAM TERMINATION PROCESSING\n           SKIP2\n       B300-TERMINATE SECTION.\n           SKIP1\n           CLOSE VSAMKSDS.\n           IF  WS-FILE-STATI NOT     = ALL '0'\n               DISPLAY 'CLOSE ERROR OCCURRED - FILE'\n               PERFORM Z100-FILE-ERROR.\n           IF  EOF\n               MOVE +0              TO RETURN-CODE\n           ELSE\n               MOVE +16             TO RETURN-CODE\n           END-IF.\n      /               THIS SECTION PERFORMS\n      *                   THE CONTROLLING OF THE E15 (INPUT) EXIT\n      *                       FORMAT THE SORT RECORD\n      *                       RELEASING THE RECORD TO THE SORT\n      *                       READING THE NEXT KSDS RECORD\n           SKIP2\n       C100-E15-INPUT SECTION.\n           SKIP1\n           PERFORM UNTIL NOT NOT-EOF\n               MOVE WS-HEX-01       TO SORTFILE-KSDS\n               MOVE WS-HEX-09       TO SORTFILE-PKL\n               MOVE WS-COMP-01      TO SORTFILE-OCC\n               MOVE WS-HEX-08       TO SORTFILE-AKL\n               MOVE VSAMKSDS-KEY    TO SORTFILE-RELKEY\n               MOVE VSAMKSDS-AKEY   TO SORTFILE-KEY\n               RELEASE SORTFILE-REC\n               PERFORM R100-VSAMKSDS\n           END-PERFORM.\n      /               THIS SECTION PERFORMS\n      *                   THE PROCESSING OF THE INPUT KSDS\n           SKIP2\n       R100-VSAMKSDS SECTION.\n           SKIP1\n           READ VSAMKSDS\n               END\n               SET EOF              TO TRUE\n               MOVE '00'            TO WS-VSAMKSDS.\n           IF  WS-VSAMKSDS NOT       = '00'\n               DISPLAY 'READ ERROR OCCURRED - FILE'\n               PERFORM Z100-FILE-ERROR\n           END-IF.\n      /               THIS SECTION PERFORMS\n      *                   DISPLAYS FOR FILE STATUS ERRORS\n           SKIP2\n       Z100-FILE-ERROR SECTION.\n           SKIP1\n           SET EOF-ERROR            TO TRUE.\n           IF  WS-VSAMKSDS NOT       = '00'\n               DISPLAY 'INPUT VSAM KSDS     ' WS-VSAMKSDS\n               DISPLAY 'VSAM RETURN CODE    ' WS-VSAMKSDS-RC\n               DISPLAY 'VSAM FUNCTION CODE  ' WS-VSAMKSDS-FC\n               DISPLAY 'VSAM FEED BACK CODE ' WS-VSAMKSDS-FB\n               MOVE +16             TO SORT-RETURN\n           END-IF.\n\nDave Loveluck\nInstructor/Consultant (USA)            c Dave Loveluck 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A001A08": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\xa3\\x00\\xa3\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 163, "newlines": 163, "modlines": 0, "user": "VSAMUPD"}, "text": "Generation of 'aliases' in a master catalog\n\nThis simple PL/I program helps to keep synchronized the\n'aliases' in two master catalogs (ICF catalogs) on an MVS\nsystem.\n\nThe program is useful when generating all the aliases in a new\nmaster catalog (if installing a new system) or to find some\nmissing aliases in an existing master catalog.\n\nThis is now it works:\n\n1      The program produces a list of the aliases in an 'input'\n      master catalog.\n\n      LISTCAT UCAT ALL CAT(IN_MASTERCAT)\n\n2      The program scans this list and writes IDCAMS cards for\n      the generation of these aliases in an 'output' master catalog.\n\n      DEFINE ALIAS (NAME(XXXX) RELATE(USERCAT) -\n             CAT(OUT_MASTERCAT)\n\nNotes:\n\no      The aliases discussed above are the entries representing\n      alternative names for user catalogs, not those for non-VSAM\n      datasets.\n\no      The program depends upon the layout of the SYSOUT in\n      IDCAMS, so be careful if you are installing or running a\n      new version.\n\no      The program seems to work fine but I always check the\n      output before submitting it to IDCAMS.\n\no      It is very easy to rewrite this short program in Assembler\n      or COBOL if you want.\n\n//STODOGAL JOB (,   ***---> PIERRE OUELLET <---***\n//  '256136532',89OD0001),'OUELLET PIERRE',\n//  NOTIFY=ROUP002,CLASS=C,MSGCLASS=A,TIME=(0003,30),\n//  REGION=2M\n/*ROUTE PRINT ECRAN\n/*JOBPARM ROOM=523\n//*\n//*  GENALIAS:  GENERATION OF IDCAMS/'DEFINE ALIAS' CARDS\n//*\n//GENALIAS PROC\n//***************************************************\n//*  EXTRACTION OF ALIAS FROM INPUT MASTER CATALOG  *\n//***************************************************\n//IDCAMS EXEC PGM=IDCAMS\n//SYSPRINT DD DSN=&&ALIAS,DISP=(NEW,PASS),UNIT=VIO,SPACE=(80,(250,100))\n//*\n//***************************************************\n//*  GENERATION OF CARDS FOR OUTPUT MASTER CATALOG  *\n//*  (PL/I COMPILE/LINK&GO)                         *\n//***************************************************\n//PLI      EXEC PGM=IEL0AA,PARM='OBJECT,NODECK,AG,MAP',REGION=1024K\n//SYSPRINT DD  DUMMY\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(80,(250,100))\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,\n//             SPACE=(1024,(200,50),,CONTIG,ROUND),DCB=BLKSIZE=1024\n//*\n//LKED     EXEC PGM=IEWL,PARM='XREF,LIST',COND=(9,LT,PLI),REGION=1256K\n//SYSLIB   DD  DSN=SYS2.PLILIB,DISP=SHR   <---- YOUR PL/I LIBRARY\n//SYSLMOD  DD  DSN=&&GOSET(GO),DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(1024,(50,20,1))\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1024,(200,20)),\n//             DCB=BLKSIZE=1024\n//SYSPRINT DD  DUMMY\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  DUMMY\n//*\n//GO       EXEC PGM=*.LKED.SYSLMOD,COND=((9,LT,PLI),(9,LT,LKED)),\n//             REGION=900K\n//SYSPRINT DD  DUMMY\n//PLIDUMP DD SYSOUT=A\n//SYSUDUMP DD SYSOUT=A\n//SYS100   DD DSN=&&ALIAS,DISP=(OLD,DELETE)\n//*\n//* SYS200:  IDCAMS 'DEFINE ALIAS ... ' CARDS\n//* ======   (VERIFY THEM BEFORE EXECUTION ...)\n//*\n//SYS200   DD DSN=SYS0.ROUP002.GENALIAS,   <---- YOUR OUTPUT DSN\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//            UNIT=3380,SPACE=(TRK,(9,9)),DISP=(,CATLG,DELETE)\n//*\n//  PEND\n//************************************************************\n//*                       END OF PROCEDURE                   *\n//************************************************************\n//*\n//EXECUTE  EXEC GENALIAS\n//*\n//*   --->  YOUR INPUT MASTER CATALOG IN 'CAT(XXXXXXXX)' BELOW\n//IDCAMS.SYSIN    DD *\n   LISTCAT UCAT ALL CAT(CATALOG.SYS2RA)\n/*\n//*\n//*   --->  YOUR OUTPUT MASTER CATALOG IN 'INIT('XXXXXXXX')' BELOW\n//PLI.SYSIN       DD *\n-VFTEMP:PROC OPTIONS(MAIN);\n   DCL CATESA CHAR(25) INIT('CATALOG.SYS1RA           ');\n   DCL SYS100 FILE INPUT RECORD;\n   DCL SYS200 FILE OUTPUT RECORD;\n   DCL SW_SYS100 BIT(1) INIT('0'B);\n   DCL 1 IN,\n         5 LIBRE1     CHAR(1),\n         5 USERCAT    CHAR(12),\n         5 LIBRE2     CHAR(4),\n         5 UCAT_ALIAS CHAR(20),\n         5 LIBRE3     CHAR(6),\n         5 ENTETE     CHAR(11),\n         5 MCAT       CHAR(20),\n         5 LIBRE4     CHAR(177);\n   DCL 1 OUT1,\n         5 STRING1    CHAR(21) INIT('  DEFINE ALIAS (NAME('),\n         5 ALIAS      CHAR(8),\n         5 STRING2    CHAR(9) INIT(') RELATE('),\n         5 UCAT       CHAR(20),\n         5 STRING3    CHAR(4) INIT(')) -'),\n         5 LIBRE      CHAR(18);\n   DCL 1 OUT2,\n         5 STRING1    CHAR(12) INIT('    CATALOG('),\n         5 MCAT       CHAR(25),\n         5 STRING2    CHAR(1) INIT(')'),\n         5 LIBRE      CHAR(42);\n   ON ENDFILE(SYS100) SW_SYS100='1'B;\n   ON ERROR BEGIN;\n     DISPLAY('*** ERROR GENALIAS ***');\n     ON ERROR SYSTEM;\n     CALL PLIDUMP('TFHCB');\n     STOP;\n   END;\n   OPEN FILE(SYS100);\n   OPEN FILE(SYS200);\n   IN=''; OUT1.LIBRE=' '; OUT2.MCAT=CATESA; OUT2.LIBRE=' ';\n   READ FILE(SYS100) INTO(IN);\n   DO WHILE(SW_SYS100='0'B);\n     IF IN.USERCAT = 'USERCATALOG ' THEN OUT1.UCAT=IN.UCAT_ALIAS;\n     IF SUBSTR(IN.USERCAT,8,5) = 'ALIAS' THEN\n     DO;\n       OUT1.ALIAS=SUBSTR(IN.UCAT_ALIAS,1,8);\n       WRITE FILE(SYS200) FROM(OUT1);\n       WRITE FILE(SYS200) FROM(OUT2);\n     END;\n     IN='';\n     READ FILE(SYS100) INTO(IN);\n   END;\n   CLOSE FILE(SYS100);\n   CLOSE FILE(SYS200);\n   END VFTEMP;\n/*\n//\n\nPierre Ouellet\nSystems Programmer\nGovernment of Quebec (Canada)             c Government of Quebec 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A001A09": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00~\\x00~\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 126, "newlines": 126, "modlines": 0, "user": "VSAMUPD"}, "text": "Delete VSAM user catalog\n\nWhen deleting a VSAM user catalog, the catalog must be\nempty.  This program will read an input file created by\nIDCAMS LIST SPC and create an output file containing all\ncluster names.  The output file is then used as input to an\nIDCAMS job assigning SYSIPT to the file.  After completion\nof this job, the user catalog is empty and can be deleted.\n\nAll user catalog names must start with 'UCAT.', or any name\nyou choose, and all cluster names must use 'DATA' and\n'INDEX'.\n\nName examples:\n\no      User catalog       - UCAT.ONLINE\no      Cluster               - ONLINE.STOP.HOLD\no      Data                  - ONLINE.STOP.HOLD.DATA\no      Index                 - ONLINE.STOP.HOLD.INDEX\n\nThis program can also be used for creating cluster names for\nmassive deletes.\n\n         BALR  R12,0\n         USING *,R12\n         OPEN  INFILE,OUTFILE\nREAD     EQU   *   ...READ SYSLST FILE...\n         MVI   LINEO,X'40'                CLEAR\n         MVC   LINEO+1(79),LINEO          CLEAR\n         MVC   LINEO+1(3),=C'DEL'         SET CONSTANT\n         LA    R9,LINEO+5                 LOAD OUTPUT DISPLACEMENT\n         GET   INFILE,LINEI               READ SYSLST FILE\n         CLC   LINEI+10(7),=C'DSN----'    IS THIS \"DATASET\" NAME\n         BNE   READ                         NO--BRANCH\n         LA    R7,LINEI+17                LOAD NAME DISPLACEMENT\n         CLC   0(5,R7),=C'UCAT.'          IS THIS \"USER CATALOG\"\n         BE    READ                         YES--BRANCH\nMVCLOOP  EQU   *   ...LOOP WHILE MOVING NAME...\n         CLI   0(R7),C'.'                 IS THIS \"PERIOD\"\n         BNE   MVCCHAR                      NO--BRANCH\n         LA    R7,1(,R7)                  BUMP DISPLACEMENT BY 1\n         CLC   0(5,R7),=C'DATA '          IS THIS \"DATA\" NAME\n         BE    SETCL                        YES--BRANCH\n         CLC   0(6,R7),=C'INDEX '         IS THIS \"INDEX\" NAME\n         BE    READ                         YES--BRANCH\n         BCTR  R7,0                       SET DISPLACEMENT DOWN BY 1\nMVCCHAR  EQU   *   ...MOVE NAME CHARACTER...\n         MVC   0(1,R9),0(R7)              MOVE CHARACTER TO OUTPUT\n         LA    R7,1(,R7)                  BUMP INPUT TO NEXT CHARACTER\n         LA    R9,1(,R9)                  BUMP OUTPUT TO NEXT CHARACTER\n         B     MVCLOOP                      --BRANCH\nSETCL    EQU   *   ...SET IDCAMS PARMS...\n         MVC   0(7,R9),=C' CL PRG'         MOVE CONSTANT TO OUTPUT\n         PUT   OUTFILE,LINEOUT            WRITE OUTPUT FROM WORK AREA\n         EXCP  WRITE                      WRITE NAME TO LISTING\n         WAIT  WRITE\n         B     READ                         --BRANCH\nEOJ      EQU   *   ...END OF JOB...\n         CLOSE INFILE,OUTFILE             CLOSE FILES\n         EOJ\n         DS   OD\nWRITE    CCB   SYSLST,WCCW\nWCCW     CCW   9,LINEO,X'20',80\nINFILE   DTFSD BLKSIZE=121,DEVADDR=SYS010,WORKA=YES,RECFORM=FIXUNB,    X\n               TYPEFLE=INPUT,DEVICE=3380,EOFADDR=EOJ\n*\nOUTFILE  DTFSD BLKSIZE=88,DEVADDR=SYS011,WORKA=YES,RECFORM=FIXUNB,     X\n               TYPEFLE=OUTPUT,DEVICE=3380\nLINEI    DC    CL121' '\nLINEOUT  DS   0CL88\n         DC    CL8' '\nLINEO    DC    CL80' '\n         LTORG\n         END\n\n\nJCL EXAMPLES FOR RUNNING THE JOB\n\nThe files are defined using CA-DYNAM and allocated on\n3380s.  The job name is VSAMLIST.  It will create a VSAM\nLIST SPC spooling list on DASD.\n\n// JOB VSAMLIST\n// LOG\n// DLBL IJSYSLS,'VSAM.DEL.SYSLST',1,SD\n// EXTENT SYSLST,TEMPWK,,,1,105\nASSGN SYSLST,DISK,VOL=338020,SHR\n// EXEC IDCAMS,SIZE=128K\n   LISTC SPC CAT(UCAT.ONLINE)ALL\n/*\nCLOSE SYSLST,FEE\n/&\n\nThe job name is VSAMCLUS.  It will create a VSAM file\ncontaining the names of clusters to be deleted.\n\n// JOB VSAMCLUS\nLIBDEF PHASE,SEARCH=BOMLIBS.CICS\n// DLBL INFILE,'INFOPAC.SYSLST(D)',1\n// EXTENT SYS010,TEMPWK,,,1,1\n// ASSGN SYS010,DISK,VOL=338020,SHR\n// DLBL OUTFILE,'INFOPAC,SYSLST,SYSIPT(D)',1\n// EXTENT SYS011,TEMPWK,,,1,120\n// ASSGN SYS011,DISK,VOL=338020,SHR\n// EXEC INFODEL,SIZE=128K\n/*\n/&\n\nThe job name is VSAMDEL.  It will use the input file,\nSYSIPT, for cluster deletes.\n\n// JOB VSAMDEL\n// DLBL IJSYSUC,'UCAT.ONLINE',,VSAM\n// DLBL IJSYSIN,'INFOPAC.SYSLST.SYSIPT(D)',1\n// EXTENT SYSIPT,TEMPWK,,,1,120\n ASSGN SYSIPT,DISK,VOL=338020,SHR\n// EXEC IDCAMS,SIZE=128K\n/*\n/&\nCLOSE SYSIPT,FEC\n*END PRINT        147 RECORDS\n\nJesse Joyner\nSystems Programmer\nBank of Mississippi (USA)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A002A00I": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 14, "newlines": 14, "modlines": 0, "user": "VSAMUPD"}, "text": "A002 - VSAM Update Issue #2  July 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA002A01   Reading KSDS files from REXX\nA002A02   IDCAMS dialogue on the VSE system console\nA002A03   Building a non-unique VSAM alternate index\nA002A04   Deleting VSAM SAM files\nA002A05   Automating diagnose JCL creation\nA002A06   VSAM utility programs\nA002A07   Allocating datasets using esoteric group names\nA002A08   SQL queries for VSAM catalog information\nA002A09   Using SPEED or RECOVERY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A002A01": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\x07\\x01\\x07\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 263, "newlines": 263, "modlines": 0, "user": "VSAMUPD"}, "text": "Reading KSDS files from REXX\n\n\nPURPOSE\n\nAlthough the REXX procedural language is a powerful programming\ntool, a number of features are missing from the MVS (TSO/E)\nimplementation.  The most important deficiency is probably the lack\nof VSAM support - particularly for KSDS, which is the most\nfrequently used access method.  To read a keyed record, the\nRXVSREAD program can be invoked directly from a REXX EXEC.\nThe record is returned as a number of REXX variables.\n\nTo keep the RXVSREAD program to a publishable size, only the read\nfunction for a single record is implemented.\n\n\nPROGRAM DESCRIPTION\n\nThe VSAM file must have been allocated to the file name (DDname)\nVSAM before RXVSREAD is invoked.  RXVSREAD uses the\ncontents of the KEY variable to read the record matching this key.\nThe data length of the KEY variable is used as the length of the\ngeneric key.  The record matching this (generic) key is returned in the\nRECORD variable.  The RECLEN variable is set to contain the length\nof the read record.\n\nNote: REXX programs must be linked with addressing mode\n(AMODE) 31, residency mode (RMODE) may be 24.\n\nThe REXX variables used are:\n\no      KEY      (generic) key field - search criterion\no      RECORD      VSAM record read\no      RECLEN      length of the VSAM record read.\n\nThe return codes used are:\n\no      0      successful processing\no      4      no record found\no      8      VSAM read error\no      12      REXX environment error (error returned from IRXEXCOM).\n\n\nSAMPLE PROCEDURE\n\n/* REXX - VSAM-KSDS Read Interface Example */\n/* allocate VSAM file */\nADDRESS TSO \"ALLOC F(VSAM) DA('VSAM.TEST.INFO') SHR REUS\"\n/* set access key */\nkey = 'BETA'\nADDRESS LINK \"RXVSREAD\";\nIF rc = 0 THEN DO;\n  SAY 'record' record;\n  SAY 'reclen' reclen;\nEND;\n\n\nPROGRAM\n\nRXVSREAD TITLE 'REXX-VSAM(KSDS) INTERFACE (READ OPERATION)'\n         PRINT NOGEN\n* Function: Read VSAM record and return contents as REXX variables\n* Note: Program AMODE must be 31 (for REXX)\n* VSAM dataset: VSAM (DD-name)\n* input variable:   <KEY> - key\n* output variables: <RECORD> - record\n*                   <RECLEN> - record length\n         SPACE 1\n* ReturnCode: 0 ok - record retrieved\n*             4 nok - record not found\n*             8 nok - VSAM read error\n*            12 nok - REXX variable access error\n* register usage:\n*   R3: A(current data item)\n*   R4: L(current data item)\n*   R6: A(SHVBLOCK)\n*  R12: base register\n* other registers are general work registers\nRXVSREAD CSECT\n* initialise addressing\n         STM   R14,R12,12(R13)    save registers\n         BALR  R12,0              base register\n         USING *,R12\n         LA    R15,SA             A(save-area)\n         ST    R13,4(R15)         backward ptr\n         ST    R15,8(R13)         forward ptr\n         LR    R13,R15            A(new save-area)\n         B     SA_END             jump over save-area\nSA       DS    18A                save-area\nSA_END   DS    0H\n         SPACE 1\n* load REXX communications module (IRXEXCOM)\n         LOAD  EP=IRXEXCOM        load IRXEXCOM\n         ST    R0,AIRXEXCOM       save EP-address\n         SPACE 1\n* suppress VSAM OPEN warning messages\n         LA    R1,VSAM            A(ACB)\n         USING IFGACB,R1\n         OI    ACBINFL2,ACBSWARN  set 'suppress warning messages flag'\n         SPACE 1\n* open VSAM dataset\n         OPEN  (VSAM)\n* obtain VSAM dataset attributes\n         SHOWCB ACB=VSAM,                                              X\n               AREA=VSAM_ATTR,                                         X\n               LENGTH=L'VSAM_ATTR,                                     X\n               OBJECT=DATA,                                            X\n               FIELDS=(KEYLEN,LRECL,RKP)\n         SPACE 1\n         MVC   RC,=H'12'          preset ReturnCode (REXX error)\n         SPACE 1\n* Obtain <KEY>\n         LA    R6,IRX_SHVBLOCK\n         USING SHVBLOCK,R6\n         MVI   SHVCODE,SHVFETCH\n         MVC   SHVBUFL,=A(L'IKEY)\n         MVC   SHVVALA,=A(IKEY)\n         LA    R1,=C'KEY'         A(varname)\n         ST    R1,SHVNAMA\n         LA    R0,3               L(varname)\n         ST    R0,SHVNAML\n         L     R15,AIRXEXCOM      A(IRXEXCOM)\n         CALL  (15),(IRX_IRXEXCOM,0,0,IRX_SHVBLOCK),VL\n         LTR   R15,R15            REXX return code\n         BNZ   EOJ                parameter error\n         L     R1,SHVVALL         L(parameter)\n         ST    R1,IKEYLEN         generic length\n         SPACE 1\n         MODCB RPL=RPL,KEYLEN=(*,IKEYLEN),OPTCD=(GEN)\n         SPACE 1\n* allocate record buffer\n         L     R2,LRECL\n* R2: VSAM logical (maximum) record length\n         GETMAIN EU,LV=(2),A=AREC\n* pass parameters to VSAM\n         SPACE 1\n         MODCB RPL=RPL,AREA=(*,AREC),AREALEN=(*,LRECL)\n         POINT RPL=RPL            position\n         SPACE 2\n* read record\n         MVC   RC,=H'4'           preset ReturnCode (EOF)\n         GET   RPL=RPL\n         MVC   RC,=H'8'           preset ReturnCode (read error)\n         LTR   R15,R15\n         BNZ   EOJ                read error\n         SHOWCB RPL=RPL,                                               X\n               AREA=RECLEN,                                            X\n               LENGTH=4,                                               X\n               FIELDS=(RECLEN)\n         SPACE 1\n* get key and pass to REXX\n* calculate address of key\n         L     R3,AREC            A(record)\n         A     R3,RKP             +RKP (key displacement)\n* R3: A(key)\n         L     R4,KEYLEN          L(key)\n* R4: L(key)\n         LA    R0,3               L(VN)\n         LA    R1,=C'KEY'\n* set data into REXX variable\n         BAL   R14,SETVAR\n         SPACE 2\n* get record and pass to REXX (variable name: RECORD)\n         L     R3,AREC            A(record)\n         L     R4,RECLEN          L(record)\n         LA    R0,6               L(varname)\n         LA    R1,=C'RECORD'      A(varname)\n         BAL   R14,SETVAR         pass to REXX\n         SPACE 1\n* convert record length to display format\n* and pass to REXX (variable name: RECLEN)\n         L     R4,RECLEN          L(record)\n         CVD   R4,D               convert to decimal\n         OI    D+7,X'0F'          remove sign\n         UNPK  WK,D\n         LA    R3,WK              A(converted record length)\n         LA    R4,L'WK            L(converted record length)\n         LA    R0,6               L(varname)\n         LA    R1,=C'RECLEN'      A(varname)\n         BAL   R14,SETVAR         pass to REXX\n         SPACE 2\n         MVC   RC,=H'0'           set ReturnCode (=ok)\n         SPACE 1\nEOJ      DS    0H                 job end\n         CLOSE (VSAM)\n         SPACE 1\n         L     R13,4(R13)         restore A(old save-area)\n         LH    R15,RC             load ReturnCode\n         RETURN (14,12),RC=(15)\n         SPACE 1\n* symbolic register equates\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR6       EQU   6\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\nRC       DS    H                  return code\n         TITLE 'Subroutines'\n         DS    A                  savearea\nSETVAR   ST    R14,SETVAR-4       save return address\n* set REXX variable\n*   R0: L(variable name)\n*   R1: A(variable name)\n*   R3: A(variable data)\n*   R4: L(variable data)\n         LA    R6,IRX_SHVBLOCK\n         USING SHVBLOCK,R6\n         ST    R0,SHVNAML         L(varname), normalised\n         ST    R1,SHVNAMA         A(varname)\n         MVI   SHVCODE,SHVSTORE   set store-flag\n         ST    R3,SHVVALA         A(data)\n         ST    R4,SHVVALL         L(data)\n         L     R15,AIRXEXCOM      A(IRXEXCOM)\n         CALL  (15),(IRX_IRXEXCOM,0,0,IRX_SHVBLOCK),VL\n         L     R14,SETVAR-4\n         BR    R14                RETURN\n         TITLE 'Data areas'\nD        DS    0D,PL8             double-word work-area\nWK       DS    CL6\n         SPACE 2\nIKEYLEN  DS    A                  input key length\nIKEY     DS    CL256              input key\n         SPACE 1\n         DS    0A                 alignment\nAREC     DS    A                  A(record)\nRECLEN   DS    A                  L(record)\n         SPACE 2\nVSAM_ATTR DS   0XL12              VSAM attributes (3 contiguous fields)\nKEYLEN   DS    A                  .) key length\nLRECL    DS    A                  .) logical (maximum) record length\nRKP      DS    A                  .) relative key position\n         SPACE 3\n         LTORG\n         SPACE 1\nAIRXEXCOM DS   A                  A(IRXEXCOM)\n         SPACE 1\nIRX_IRXEXCOM DC CL8'IRXEXCOM'\n         DS    0A                 align\nIRX_SHVBLOCK DC (SHVBLEN)X'0'\n         TITLE 'VSAM control blocks'\nVSAM     ACB   DDNAME=VSAM,MACRF=(KEY,DSN,DIR),EXLST=EXLST\n         SPACE 1\nEXLST    EXLST EODAD=EOJ\n         SPACE 2\nRPL      RPL   ACB=VSAM,ARG=IKEY,OPTCD=(NUP,KEQ,GEN,MVE)\n         TITLE 'DSECTs'\n* REXX Shared Variable request Block\n         IRXSHVB\n         SPACE 1\n* VSAM ACB\n         IFGACB\n         END\n\nA S Rudd\nSystems Programmer (Germany)                  c A S Rudd 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A002A02": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\xe1\\x00\\xe1\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 225, "newlines": 225, "modlines": 0, "user": "VSAMUPD"}, "text": "IDCAMS dialogue on the VSE system console\n\nThis routine was born under pressure, after the VSAM master\ncatalog broke and no on-line system (eg ICCF or CMS) was\navailable to define a new catalog and necessary cluster.  It\nshould be placed in the VSE system library (BAM).\n\nThe input is entered on the system console and contains\nIDCAMS commands.  The output messages, from the called\nIDCAMS program, are displayed unchanged on the system\nconsole.\n\nAMSC           TITLE 'AMSCONS  -  IDCAMS INPUT FROM CONSOLE'\n           PUNCH '   PHASE AMSCONS,* '\n           SPACE 3\nAMSCONS  CSECT\n*  REGISTER-BENUTZUNG\nR0      EQU   0       COUNTREG\nR1      EQU   1       WORKREG\nR2      EQU   2       WORKREG\nR3      EQU   3       BASEREG\nR4      EQU   4       .\nR5      EQU   5       .\nR6      EQU   6       .\nR7      EQU   7       .\nR8      EQU   8       .\nR9      EQU   9       .\nR10     EQU   10      WORKREG\nR11     EQU   11      .\nR12     EQU   12      .\nR13     EQU   13      ADDRESS OF OWN SAVE AREA\nR14     EQU   14      RETURN ADDR / BALREG\nR15     EQU   15      ENTRY ADDR\n          EJECT\n          SAVE  (14,12)\n          LR    R3,R15\n          USING AMSCONS,R3\n          B     BEGIN\n          DC    CL8'AMSCONS'            PROGRAM NAME\n          DC    C' V.1.0 '              VERSION\n          DC    C'&UDATE '              DATE OF UPDATE\n          DC    C'&UTIME '              TIME OF UPDATE\n          DC    C'author: willi j. kuhn '\nBEGIN     DS    0H\n          ST    R13,SAVEAREA+4          SAVE PREVIOUS SAVEAREA ADDR\n          LR    R2,R13                  SAVE REG 13\n          LA    R13,SAVEAREA            LOAD OWN SAVEAREA ADDR\n          ST    R13,8(R2)             CHAIN IT TO PREVIOUS AREA\n          EJECT\n*  PERFORM IDCAMS FOR PROCESSING                             *\nIDCAMS    DS    0H\n          SPACE\n          CDLOAD IDCAMS\n          SPACE\n          LTR   R15,R15                    CDLOAD OK\n          BZ    IDCAMS10             YES - LINK IDCAMS\n          SPACE\n          DC    H'0'               ABEND\n          DC    C'ERROR CDLOAD IDCAMS'\n          SPACE\nIDCAMS10  DS    0H\n          LA    R15,6(R1)      ENTRY TO IDCAMS\n          LA    R1,ARGLIST\n          SPACE\n          BALR  R14,R15\n          EJECT\n*  PROGRAM-END      *\nPROGEND   DS    0H\n          L     R13,4(R13)\n          L     R14,12(R13)\n          SPACE\n          RETURN (0,12)\n          EJECT\n*  IDCAMS INPUT ROUTINE       *\nIOSYSIPT  DS    0H\n          USING *,R15\n          STM   R0,R15,SAVEIPT            SAVE ALL REGS\n          L     R3,=A(AMSCONS)            LOAD BASE REG\n          DROP  R15\n          SPACE\n          L     R2,4(R1)             GET IOFLAGS ADDR\n          CLI   0(R2),X'08'        IS IT A GET REQUEST\n          BE    GETIPT                    YES - BUILD INPUT\n          SPACE\n          LM    R0,R15,SAVEIPT            RELOAD ALL REGS\n          LA    R15,0                     RETURN CODE NORMAL\n          BR    R14                       RETURN TO IDCAMS\n          SPACE\nGETIPT    DS    0H\n          L     R2,8(R1)                GET IOINFO ADDR\n          MVC   0(4,R2),=A(IPTDATA)     SET IO AREA ADDR\n          MVC   4(4,R2),=AL4(L'IPTDATA) SET IO AREA LENGTH\n          SPACE\n          LA    R2,L'MSGENTER\n          PUT   SYSLOG,MSGENTER\n          SPACE\n          MVI   IPTDATA,C' '       CLEAR INPUT AREA\n          MVC   IPTDATA+1(L'IPTDATA-1),IPTDATA\n          SPACE\n          GET   SYSLOG,IPTDATA+1\n          SPACE\n          LTR   R2,R2\n          BZ    EOFIPT\n          SPACE\n          OC    IPTDATA,BLANK            TRANSLATE TO UPPERCASE\n          SPACE\n          CLC   =C'END',IPTDATA+1\n          BE    EOFIPT\n          SPACE\n          LM    R0,R15,SAVEIPT            RELOAD ALL REGS\n          LA    R15,0                     RETURN CODE NORMAL\n          BR    R14                       RETURN TO IDCAMS\n          SPACE\nEOFIPT  DS    0H\n          LM    R0,R15,SAVEIPT             RELOAD ALL REGS\n          LA    R15,4                      END OF PROCESSING\n          BR    R14                        RETURN TO IDCAMS\n          EJECT\n*  IDCAMS OUTPUT ROUTINE      *\nIOSYSLST DS    0H\n          USING *,R15\n          STM   R0,R15,SAVELST            SAVE ALL REGS\n          L     R3,=A(AMSCONS)          LOAD BASE REG\n          DROP  R15\n          SPACE\n          L     R2,4(R1)                GET IOFLAGS ADDR\n          CLI   0(R2),X'0C'             IS IT A PUT REQUEST\n          BNE   ENDLST                  NO - RETURN TO IDCAMS\n          SPACE\n          MVI   IO1LST,C' '             CLEAR OUT AREA\n          MVC   IO1LST+1(L'IO1LST-1),IO1LST\n          SPACE\n          L     R10,8(R1)               GET IOINFO ADDR\n          L     R2,4(R10)               GET RECORD LENGTH\n          L     R10,0(R10)              GET IO AREA ADDR\n          SPACE\n          BCTR  R2,0                      -1\n          EX    R2,EXMVCLST             EXECUTE MOVE\n          SPACE\n          PUT   SYSLST\n          SPACE\n          CLC   =C'IDC',1(R10)     MSG PREFIX\n          BNE   ENDLST                  NO - RETURN\n          SPACE\n          CLC   =C'AMS',4(R10)     MSG PREFIX\n          BE    ENDLST                  NO - RETURN\n          SPACE\n          PUT   SYSLOG,IO1LST+1\n          SPACE\nENDLST DS    0H\n          LM    R0,R15,SAVELST          RELOAD ALL REGS\n          LA    R15,0                   RETURN CODE NORMAL\n          BR    R14                     RETURN TO IDCAMS\n          SPACE 2\nEXMVCLST MVC   IO1LST(0),0(R10)   MOVE DATA\n          EJECT\n*  CONSTANTS/AREAS/LITERALS                                           *\nBLANK          DC    CL80' '\nMSGENTER DC    C'Enter IDCAMS command or END/eob'\nSAVEAREA DS    18F                      MAIN SAVE AREA\nSAVEIPT  DS    18F                      SUB SAVE AREA\nSAVELST  DS    18F                      SUB SAVE AREA\nARGLIST  DC    A(OPTIONS)               SEE IDCAMS RULES\n         DC    A(DNAMES)\n         DC    A(PAGENUM)\n         DC    X'80'\n         DC    AL3(IOLIST)\nOPTIONS  DC    H'0'\nDNAMES   DC    H'0'\nPAGENUM  DC    H'0'\nIOLIST   DC    F'2'                     NUMBER OF MANAGED FILES\n         DC    A(DNAMEIPT)\n         DC    A(IOSYSIPT)\n         DC    A(IPTDATA)\n         DC    A(DNAMELST)\n         DC    A(IOSYSLST)\n         DC    A(LSTDATA)\n         SPACE\nDNAMEIPT DC    CL10'DDSYSIPT'\nIPTDATA  DC    CL80' '\n         SPACE\nDNAMELST DC    CL10'DDSYSLST'\nLSTDATA  DS    10CL256\n         SPACE 2\n         LTORG\n         EJECT\n*  SYSLOG CONTROL BLOCK                                               *\nSYSLOG    DTFCN DEVADDR=SYSLOG,                                        C\n          IOAREA1=IO1LOG,                                              C\n          BLKSIZE=256,                                                 C\n          RECFORM=UNDEF,                                               C\n          RECSIZE=(2),                                                 C\n          TYPEFLE=INPUT,                                               C\n          WORKA=YES\n          SPACE 2\nIO1LOG    DC    CL256' '\n          EJECT\n*          SYSLST CONTROL BLOCK                                       *\nSYSLST    DTFPR DEVADDR=SYSLST,                                        C\n          IOAREA1=IO1LST,                                              C\n          BLKSIZE=133,                                                 C\n          CTLCHR=ASA\nIO1LST    DC    CL133' '\n          EJECT\n*  DUMMY SECTIONS                                                     *\n         SPACE 3\n         END   AMSCONS\n\nSample JCL.\n\n* $$ JOB JNM=AMSCONS,CLASS=A,USER=KUHN\n* $$ LST CLASS=J\n// JOB AMSCONS SH24 KUHN     IDCAMS FROM SYSLOG\n// EXEC AMSCONS,SIZE=AUTO\n/*\n/&\n* $$ EOJ\n\nThe program can also be executed by entering the EXEC\nstatement on the system console or in an ICCF interactive\npartition.\n\nWilli Kuhn\nFreelance Systems Programmer (Germany)             c Willi Kuhn 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A002A03": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\"\\x01\"\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:56", "lines": 290, "newlines": 290, "modlines": 0, "user": "VSAMUPD"}, "text": "Building a non-unique VSAM alternate index\n\nThis is a COBOL II program that will build a VSAM alternate\nindex from a KSDS.  The code illustrates the method for\nbuilding a NONUNIQUE alternate index.  This program is\nsimilar to one published in issue 1 that built a UNIQUE\nalternate index.  Both programs could quite easily be modified\nto build multiple alternate indexes.\n\nOperating system and other pre-requisites:\n\no      MVS - DFP 2.3\no      CICS/VS - 1.7, 2.1.\n\n\nCOBOL PROGRAM\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.    AIXBLD.\n      *\n      *               THIS PROGRAM WILL BUILD A NON-UNIQUE ALTERNATE\n      *               INDEX FROM A BASE KSDS\n      *\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT VSAMKSDS ASSIGN        VSAMKSDS\n                                    ORGANIZATION INDEXED\n                                    ACCESS SEQUENTIAL\n                                    RECORD VSAMKSDS-KEY\n                                    FILE STATUS WS-VSAMKSDS\n                                                WS-VSAMKSDS-EXT.\n           SELECT VSAMAIX  ASSIGN        VSAMAIX\n                                    ORGANIZATION INDEXED\n                                    ACCESS SEQUENTIAL\n                                    RECORD VSAMAIX-KEY\n                                    FILE STATUS WS-VSAMAIX\n                                                WS-VSAMAIX-EXT.\n           SELECT SORTFILE ASSIGN   UT-S-SORTFILE.\n      /            DATA DIVISION - FILE SECTION\n       DATA DIVISION.\n       FILE SECTION.\n       FD  VSAMKSDS                 RECORD 120\n                                    LABEL RECORDS STANDARD.\n       01  VSAMKSDS-REC.\n           03  VSAMKSDS-KEY         PIC  X(09).\n           03  FILLER               PIC  X(11).\n           03  VSAMKSDS-AKEY        PIC  X(08).\n           03  FILLER               PIC  X(92).\n           SKIP2\n       FD  VSAMAIX                  RECORD 22 TO 32755\n                                    LABEL RECORDS STANDARD.\n       01  VSAMAIX-REC.\n           03  VSAMAIX-CONTROL.\n               05  VSAMAIX-KSDS     PIC  X(01).\n               05  VSAMAIX-PKL      PIC  X(01).\n               05  VSAMAIX-OCC      PIC S9(04)     COMP.\n               05  VSAMAIX-AKL      PIC  X(01).\n           03  VSAMAIX-KEY          PIC  X(08).\n           03  VSAMAIX-RELKEY       OCCURS 1 TO 3638\n                                    DEPENDING WS-VSAMAIX-OCC\n                                    PIC  X(09).\n           SKIP2\n       SD  SORTFILE.\n       01  SORTFILE-REC.\n           03  SORTFILE-KEY         PIC  X(08).\n           03  SORTFILE-RELKEY      PIC  X(09).\n      /            DATA DIVISION - WORKING-STORAGE SECTION\n       WORKING-STORAGE SECTION.\n           SKIP2\n       01  WS-FILE-STATI.\n           03  WS-VSAMAIX           PIC  X(02).\n           03  WS-VSAMKSDS          PIC  X(02).\n       01  WS-FILE-STATI-EXT.\n           03  WS-VSAMAIX-EXT.\n               05  WS-VSAMAIX-RC    PIC S9(04)     COMP.\n               05  WS-VSAMAIX-FC    PIC S9(04)     COMP.\n               05  WS-VSAMAIX-FB    PIC S9(04)     COMP.\n           03  WS-VSAMKSDS-EXT.\n               05  WS-VSAMKSDS-RC   PIC S9(04)     COMP.\n               05  WS-VSAMKSDS-FC   PIC S9(04)     COMP.\n               05  WS-VSAMKSDS-FB   PIC S9(04)     COMP.\n           SKIP1\n       01  WS-FLAGS-ET-ALIA.\n           03  WS-EOF               PIC  X(01).\n               88  EOF-ERROR                                 VALUE '2'.\n               88  EOF                                       VALUE '1'.\n               88  NOT-EOF                                   VALUE '0'.\n           03  WS-COMP-01           PIC S9(04)     COMP      VALUE +1.\n           03  FILLER               REDEFINES WS-COMP-01.\n               05  FILLER           PIC  X(01).\n               05  WS-HEX-01        PIC  X(01).\n           03  WS-COMP-2057         PIC S9(04)     COMP     VALUE 2057.\n           03  FILLER               REDEFINES WS-COMP-2057.\n               05  WS-HEX-08        PIC  X(01).\n               05  WS-HEX-09        PIC  X(01).\n           03  WS-PREV-SORT-KEY     PIC  X(08).\n           SKIP1\n       01  WS-VSAMAIX-REC.\n           03  WS-VSAMAIX-CONTROL.\n               05  WS-VSAMAIX-KSDS  PIC  X(01).\n               05  WS-VSAMAIX-PKL   PIC  X(01).\n               05  WS-VSAMAIX-OCC   PIC S9(04)     COMP.\n               05  WS-VSAMAIX-AKL   PIC  X(01).\n           03  WS-VSAMAIX-KEY       PIC  X(08).\n           03  WS-VSAMAIX-RELKEY    OCCURS 1 TO 3638\n                                    DEPENDING WS-VSAMAIX-OCC\n                                    INDEXED WS-IND\n                                    PIC  X(09).\n      /            PROCEDURE DIVISION - MAIN CONTROL\n           SKIP1\n       PROCEDURE DIVISION.\n           SKIP1\n       A100-MAIN-CONTROL SECTION.\n           SKIP1\n           PERFORM B100-INITIALIZE.\n           PERFORM B200-PROCESS.\n           PERFORM B300-TERMINATE.\n           STOP RUN.\n      /               THIS SECTION PERFORMS\n      *                   INITIALIZATION OF WORKING STORAGE\n      *                   OPENING OF FILES, READ FIRST INPUT RECORD\n           SKIP2\n       B100-INITIALIZE SECTION.\n           SKIP1\n           SET NOT-EOF               TO TRUE.\n           MOVE ALL '0'              TO WS-FILE-STATI.\n           MOVE LOW-VALUES           TO WS-PREV-SORT-KEY.\n           OPEN INPUT  VSAMKSDS\n                OUTPUT VSAMAIX.\n           IF  WS-FILE-STATI      NOT = ALL '0'\n               DISPLAY 'OPEN ERROR OCCURRED - FILE'\n               PERFORM Z100-FILE-ERROR\n           END-IF.\n           PERFORM R100-VSAMKSDS.\n      /               THIS SECTION PERFORMS\n      *                   PROGRAM MAIN PROCESSING\n           SKIP2\n       B200-PROCESS SECTION.\n           SKIP1\n           SORT SORTFILE\n               ASCENDING SORTFILE-KEY\n               INPUT  PROCEDURE C100-E15-INPUT\n               OUTPUT PROCEDURE C200-E35-OUTPUT.\n           IF  SORT-RETURN        NOT = +0\n               SET EOF-ERROR         TO TRUE\n           END-IF.\n      /               THIS SECTION PERFORMS\n      *                   PROGRAM TERMINATION PROCESSING\n           SKIP2\n       B300-TERMINATE SECTION.\n           SKIP1\n           CLOSE VSAMAIX\n                 VSAMKSDS.\n           IF  WS-FILE-STATI      NOT = ALL '0'\n               DISPLAY 'CLOSE ERROR OCCURRED - FILE'\n               PERFORM Z100-FILE-ERROR.\n           IF  EOF\n               MOVE +0               TO RETURN-CODE\n           ELSE\n               MOVE +16              TO RETURN-CODE\n           END-IF.\n      /               THIS SECTION PERFORMS\n      *                   THE CONTROLLING OF E15 (INPUT) EXIT\n      *                       FORMAT THE SORT RECORD\n      *                       RELEASING THE RECORD TO THE SORT\n      *                       READING THE NEXT KSDS RECORD\n           SKIP2\n       C100-E15-INPUT SECTION.\n           SKIP1\n           PERFORM UNTIL NOT NOT-EOF\n               MOVE VSAMKSDS-KEY     TO SORTFILE-RELKEY\n               MOVE VSAMKSDS-AKEY    TO SORTFILE-KEY\n               RELEASE SORTFILE-REC\n               PERFORM R100-VSAMKSDS\n           END-PERFORM.\n      /               THIS SECTION PERFORMS\n      *                   THE CONTROLLING OF E35 (OUTPUT) EXIT\n      *                       CHECK FOR CHANGE IN ALTERNATE KEY\n      *                       IF CHANGE - WRITE PREVIOUS RECORD\n      *                                 - FORMAT NEXT RECORD\n      *                       IF NO CHANGE - ADD KEY TO BUCKET\n      *                       RETURN THE NEXT SORTED RECORD\n           SKIP2\n       C200-E35-OUTPUT SECTION.\n           SKIP1\n           SET NOT-EOF               TO TRUE.\n           PERFORM R200-SORTFILE.\n           PERFORM UNTIL NOT NOT-EOF\n               IF  SORTFILE-KEY   NOT = WS-PREV-SORT-KEY\n               AND WS-PREV-SORT-KEY\n                                  NOT = LOW-VALUES\n                   PERFORM W100-VSAMAIX\n               END-IF\n               IF  SORTFILE-KEY   NOT = WS-PREV-SORT-KEY\n           SKIP1\n      *               OUTPUT AIX CONTROL INFORMATION\n           SKIP1\n                   MOVE WS-HEX-01    TO WS-VSAMAIX-KSDS\n                   MOVE WS-HEX-09    TO WS-VSAMAIX-PKL\n                   MOVE WS-COMP-01   TO WS-VSAMAIX-OCC\n                   MOVE WS-HEX-08    TO WS-VSAMAIX-AKL\n           SKIP1\n      *               OUTPUT OTHER AIX DATA\n           SKIP1\n                   MOVE SORTFILE-KEY TO WS-VSAMAIX-KEY\n                                        WS-PREV-SORT-KEY\n                   MOVE SORTFILE-RELKEY\n                                     TO WS-VSAMAIX-RELKEY (1)\n                   SET WS-IND        TO +2\n           SKIP1\n      *               PROCESS NON-UNIQUE PRIME KEYS\n           SKIP1\n               ELSE\n                   IF  WS-VSAMAIX-OCC < +3638\n                       COMPUTE WS-VSAMAIX-OCC\n                                      = WS-VSAMAIX-OCC\n                                      + +1\n                       MOVE SORTFILE-RELKEY\n                                     TO WS-VSAMAIX-RELKEY (WS-IND)\n                       SET WS-IND    UP BY +1\n                   ELSE\n                       DISPLAY 'EXCESSIVE NON-UNIQUE KEYS'\n                       DISPLAY 'FOR KEY: ' WS-VSAMAIX-KEY\n                       SET EOF-ERROR TO TRUE\n                       MOVE +16      TO SORT-RETURN\n                   END-IF\n               END-IF\n           SKIP1\n               PERFORM R200-SORTFILE\n           END-PERFORM.\n           PERFORM W100-VSAMAIX.\n      /               THIS SECTION PERFORMS\n      *                   THE PROCESSING OF THE INPUT KSDS\n           SKIP2\n       R100-VSAMKSDS SECTION.\n           SKIP1\n           READ VSAMKSDS\n               END\n               SET EOF               TO TRUE\n               MOVE '00'             TO WS-VSAMKSDS.\n           IF  WS-VSAMKSDS        NOT = '00'\n               DISPLAY 'READ ERROR OCCURRED - FILE'\n               PERFORM Z100-FILE-ERROR\n           END-IF.\n           SKIP2\n      *               THIS SECTION PERFORMS\n      *                   THE RETURN OF DATA FROM THE LAST PHASE\n      *                   OF THE SORT\n           SKIP2\n       R200-SORTFILE SECTION.\n           SKIP1\n           RETURN SORTFILE\n               END\n               SET EOF               TO TRUE.\n      /               THIS SECTION PERFORMS\n      *                   THE PROCESSING OF THE OUTPUT AIX\n           SKIP2\n       W100-VSAMAIX SECTION.\n           SKIP1\n           WRITE VSAMAIX-REC FROM WS-VSAMAIX-REC.\n           IF  WS-VSAMAIX         NOT = '00'\n               DISPLAY 'WRITE ERROR OCCURRED - FILE'\n               PERFORM Z100-FILE-ERROR\n           END-IF.\n      /               THIS SECTION PERFORMS\n      *                   DISPLAYS FOR FILE STATUS ERRORS\n           SKIP2\n       Z100-FILE-ERROR SECTION.\n           SKIP1\n           IF  WS-VSAMKSDS        NOT = '00'\n               DISPLAY 'INPUT VSAM KSDS     ' WS-VSAMKSDS\n               DISPLAY 'VSAM RETURN CODE    ' WS-VSAMKSDS-RC\n               DISPLAY 'VSAM FUNCTION CODE  ' WS-VSAMKSDS-FC\n               DISPLAY 'VSAM FEED BACK CODE ' WS-VSAMKSDS-FB\n           END-IF.\n           IF  WS-VSAMAIX         NOT = '00'\n               DISPLAY 'OUTPUT VSAM AIX     ' WS-VSAMAIX\n               DISPLAY 'VSAM RETURN CODE    ' WS-VSAMAIX-RC\n               DISPLAY 'VSAM FUNCTION CODE  ' WS-VSAMAIX-FC\n               DISPLAY 'VSAM FEED BACK CODE ' WS-VSAMAIX-FB\n           END-IF.\n           SET EOF-ERROR             TO TRUE.\n           MOVE +16                  TO SORT-RETURN.\n\n\nDave Loveluck\nInstructor/Consultant (USA)                        c Dave Loveluck 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A002A04": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12V\\x00\\x97\\x00\\x96\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:56:55", "lines": 151, "newlines": 150, "modlines": 0, "user": "VSAMUPD"}, "text": "Deleting VSAM SAM files\n\nVSAM space managed SAM files can be explicitly or\nimplicitly defined.  Explicit SAM files are defined by\nIDCAMS.  When an explicitly defined SAM file is closed,\nwith DISP=(,DELETE) on the DLBL, all space acquired by the\nfile is released and only the definition remains in the VSAM\ncatalog.  An implicit SAM file is defined automatically by\nVSAM, when it is opened for output, based on information in\nthe program's DTF and in the RECORDS and RECSIZE\noperands on the file's DLBL.  When an implicitly defined SAM\nfile is closed, with DISP=(,DELETE) on the DLBL, all space\nacquired by the file is released and its definition is deleted from\nthe VSAM catalog.  But what if we don't want to delete a SAM\nfile immediately an application program closes it?  Perhaps it is\ndesirable to keep some SAM files until an entire job has\nexecuted successfully or even longer.  How do we get rid of\nSAM files later?\n\nUsing IDCAMS to DELETE SAM files is not a good solution\nbecause the definition is deleted for explicit SAM files.\nImplicit SAM files are easily created without the use of\nIDCAMS.  Shouldn't there be an equally simple way to delete\nthose files without using IDCAMS?  Shouldn't there be a\ncommon solution for both implicit and explicit SAM files?\nThe answer is yes.\n\nThe solution is simple.  Consider a program which does\nnothing more than open and close a sequential disk file named\nUOUT.  Call it OPNCLOSE.  This program could be used to\nopen and close any SAM file, thereby allowing VSAM to\ndelete or reset the file as appropriate.  For an explicit SAM\nfile, execute the following job step:\n\n// DLBL UOUT,'file-id',,VSAM,DISP=(,DELETE)\n// EXEC OPNCLOSE\n\nThe file UOUT is opened and immediately closed.  VSAM,\nbecause of the DISP=(,DELETE) operand on the DLBL, frees\nany space acquired by the file and resets the file's RBA pointer\nto zero.  If you are sure an implicit SAM file exists, the same\nJCL can be used.  However, attempting to open a SAM file\nwhich does not exist without coding the RECORDS and\nRECSIZE operands on the DLBL will cause the program to\ncancel.  If there is any doubt as to the existence of an implicit\nSAM file, code the DLBL like this:\n\n// DLBL UOUT,'file-id',,VSAM,DISP=(NEW,DELETE),   *\n       RECORDS=1,RECSIZE=512\n// EXEC OPNCLOSE\n\nWhether or not the implicit SAM file exists, the open\ncommand will be successful.  When the file is closed, any\nspace acquired by the file is released and the definition\nremoved from the VSAM catalog.\n\nWhen a close disposition for a SAM file is not specified on the\nDLBL, it defaults to KEEP unless the file is defined in the\nprogram as a work file, in which case the default is DELETE.\nThus, if the OPNCLOSE program defines file UOUT as\nTYPEFLE=WORK rather than OUTPUT, no close disposition\nis required on the DLBL to delete the file.\n\nThe seven character name of a file is stored in bytes 23 to 29 of\nits DTF.  If the OPNCLOSE program is written in Assembler,\nthe programmer might code the following:\n\n      MVC   UOUT+22(7),=C'SAMFILE'\n      OPEN  UOUT\n      CLOSE UOUT\n\nAlthough the program seems to open and close a file named\nUOUT it actually opens and closes a file named SAMFILE.\nThe same DTF could be used again for another file by moving\na different seven-character name into the DTF and opening and\nclosing UOUT again.  Thus, one execution of the program\ncould be used to open and close more than one file.  The ability\nto tell the program what files to open and close could make it a\nuseful tool because one execution of the program could delete\none or more SAM files whose names are provided by the user.\nThis could be done easily be providing the file names to the\nprogram via the PARM operand on the EXEC statement.  To\nopen and close the files FILE1, FILE2 and FILE3, the EXEC\nstatement would look like this:\n\n// EXEC OPNCLOSE,PARM='FILE1,FILE2,FILE3'\n\nIn this and the preceding examples it might be necessary to\ncode the SIZE=AUTO operand on the EXEC statement\nalthough the default SIZE coded in your ASI PROC is probably\nsufficient.\n\nThe following program implements all that is described above.\nIf one or more files are specified in the PARM operand, those\nfiles are opened and closed.  If the PARM operand is omitted,\nthe file UOUT is opened and closed.  Both implicit and explicit\nSAM files can be specified in the same execution and, because\nthe DTF is defined as a work file, it is not necessary to code a\ndelete disposition on the DLBLs.  Also, this program can be\nused to delete ordinary sequential disk files from a volume.\n\n         TITLE 'OPNCLOSE - *** OPEN/CLOSE SD WORK FILES'\n         PRINT NOGEN\nOPNCLOSE START 0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR11      EQU   11\n         BALR  R11,0\n         USING *,R11\n         LA    R2,PARM                    POINT TO PARM WORK AREA\n         TM    0(R1),X'80'                IS THERE A PARM\n         BZ    OPEN                       ...NO\n         L     R1,0(R1)                   ..YES, GET PARM ADDRESS\n         LH    R3,0(R1)                   GET LENGTH OF PARM DATA\n         BCTR  R3,0                           MINUS 1\n         EX    R3,MVC                     GET PARM DATA\n         B     CHKPARM1\nMVC      MVC   PARM(1),2(R2)\nCHKPARM1 LA    R3,FILE\n         MVC   FILE,CLEAR\nCHKPARM2 CLI   0(R2),C' '                 IS THIS A BLANK\n         BE    CHKPARM4                   ...YES\n         CLI   0(R2),C','                 IS THIS A COMMA\n         BE    CHKPARM3                   ...YES\n         MVC   0(1,R3),0(R2)              GET ONE BYTE OF THE FILE NAME\n         CLI   TEST,C'  '                 IS FILE NAME TOO LONG\n         BNE   EOJ                        ...YES, QUIT\n         LA    R2,1(,R2)                  POINT TO NEXT BYTE OF NAME\n         LA    R3,1(,R3)\n         B     CHKPARM2                   LOOP BACK\nCHKPARM3 LA    R2,1(,R2)                  POINT PAST COMMA\nCHKPARM4 CLI   FILE,C' '                  IS THERE A FILE NAME\n         BE    EOJ                        ...NO, QUIT\n         MVC   UOUT+22(7),FILE            MOVE FILE NAME TO DTF\nOPEN     OPEN  UOUT\nEOF      CLOSE UOUT\n         B     CHKPARM1                   GO CHECK FOR ANOTHER FILE\nEOJ      EOJ\nPARM     DC    CL256' '\nCLEAR    DC    CL7' '\nFILE     DC    CL7' '\nTEST     DC    C' '\nUOUT     DTFSD BLKSIZE=512,RECFORM=UNDEF,EOFADDR=EOF,    *\n               DEVADDR=SYS000,TYPEFLE=WORK\n         LTORG\n         END\n\nJames E Holler\nLittle Blue Systems (USA)                   c Little Blue Systems 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A002A05": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12W\\x02\\x7f\\x02\\x7f\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:57:46", "lines": 639, "newlines": 639, "modlines": 0, "user": "VSAMUPD"}, "text": "Automating diagnose JCL creation\n\nThis program will create IDCAMS diagnose control cards for\nevery pack that contains a SYS1.VVDS pointed to by a\nspecific catalog.\n\n\nJCL TO EXECUTE PROGRAM\n\n//T#ENVRP2 JOB (0,845-TXTEC-----P1-DUMP-SMF-DATA-ASYS---),'H45  B23',\n//             MSGLEVEL=(1,1),MSGCLASS=A,CLASS=V,NOTIFY=T1BK\n//*    BUILDS DIAGNOSE CARDS\n//BLDDIAG EXEC PGM=BLDDIAG\n//STEPLIB  DD  DSN=T08M.TECH.LINKLIB,DISP=SHR\n//AMSPRINT DD  SYSOUT=*\n//SYSPNCH  DD  DSN=T08M.DIAG.JCL,DISP=OLD\n//SYSUDUMP DD  SYSOUT=*\n//SYSIN    DD  *\n  CATALOG.VMSCATP\n  CATALOG.ICFBKUP\n  CATALOG.ICFCADAM\n  CATALOG.ICFCICS\n  CATALOG.ICFDB2\n  CATALOG.ICFHSM\n  CATALOG.ICFMISC\n  CATALOG.ICFTSO\n  CATALOG.ICFVEND\n//*********************************************************************\n//DIAGNOS EXEC PGM=IEBGENER\n//*  THIS STEP WILL GENERATE THE DIAGNOSE JCL\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY,DCB=BLKSIZE=80\n//SYSUT2   DD  SYSOUT=(A,INTRDR)\n//SYSUT1   DD  DSN=T08M.DIAG.JCL,DISP=OLD\n\n\nBLDDIAG\n\n* BLDDIAG PROGRAM TO CREATE IDCAMS DIAGNOSE JCL AND CONTROL           *\n* CARDS. THIS PROGRAM WILL PRODUCE DIAG VVDS AND DIAG ICFCAT          *\n* CONTROL CARDS FOR EVERY VVDS FOUND IN AN ICF CATALOG.               *\n* THE PROGRAM PRODUCES THE CARDS BY CALLING IDCAMS AND PERFORMING     *\n* A 'LISTC LVL(SYS1.VVDS) CAT(XXX)' WHERE XXX IS A CATALOG NAME       *\n* PASSED THRU A SYSIN INPUT STREAM.                                   *\n* LOCAL MODIFICATIONS TO CODE WILL BE NEEDED.                         *\n* MODIFICATIONS INCLUDE JOB CARD WHICH MAY BE FOUND BY                *\n* DOING 'F JOBCARD 1' UNDER ISPF OR SIMILAR EDITOR.                   *\n* THE CARDS PUNCHED BY THIS UTILITY FOLLOW THE JOBCARD.               *\n* THESE MAY NEED TO BE MODIFIED TO SUIT LOCAL STANDARDS.              *\n* A TABLE AT THE END OF THE PROGRAM MAY NEED TO BE INCREASED          *\n* IN A SHOP WITH MANY ICF CATALOGS AND VOLUMES WITH VVDSS ON          *\n* THEM. SIMPLY FIND 'HCARDS' IN COL 1 AND INCREASE THE NUMBER.        *\n* THIS TABLE CONTAINS THE NAME OF THE VVDS AND THE CATALOG            *\n* WHICH CONTAINS THE POINTER TO THAT VVDS.                            *\n         MACRO\n&NAME    SBMSAVE                                                       X\n               &BASE=R15,                                              X\n               &SVAREA=INTERNAL,                                       X\n               &ROOT=NO,                                               X\n               &SAMECC=NO,                                             X\n               &RETURN=(RETURN,0),                                     X\n               &PARMREG=R1,                                            X\n               &PASSREG=\n         GBLB  &SAVEB\n         LCLA  &SAVEA,&SAVEAA,&SAVEAAA,&SAVEA1\n         LCLA  &CNT,&CNT1,&CNT2\n         LCLA  &RC,&RTNCTL,&RTCCTL\n         LCLB  &SAVEBB,&RT\n         LCLB  &B13,&LPCT\n         LCLB  &B13S\n         LCLC  &USLBL\n         LCLC  &RETL\n         LCLC  &SAVEC\n         LCLC  &USBS(6)\n&USLBL   SETC  '*'\n&RT      SETB  ('&ROOT' EQ 'YES')\n&RTNCTL  SETA  1\n&RTCCTL  SETA  2\n&B13     SETB  ('&BASE(1)' EQ '13' OR '&BASE(1)' EQ 'R13' AND '&SVAREA'X\n                EQ 'INTERNAL')\n&SAVEA1  SETA  &SYSNDX\n         AIF   (&SAVEB).NOREGDF\n&SAVEB   SETB  1\n&NAME    CSECT\n          SPACE\n*              GENERAL REGISTER DEFINITION FOR XREF                  *\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         AGO   .USG\n.NOREGDF ANOP\n         ENTRY &NAME\n&NAME    DS    0H                  ENTRY POINT\n.USG     ANOP\n         AIF   ('&NAME' NE '').SVCNT\n&SAVEC   SETC  'GOGO'\n         AGO   .NORE\n.SVCNT   ANOP\n&SAVEC   SETC  '&NAME'(1,4)\n.NORE    ANOP\n         USING *,R15\n         AIF   (NOT &RT).C0\n         LR    R15,R1              DOS ROOT PHASE COMPATIBILITY\n.C0      ANOP\n         B     *+28\n         DC    AL1(24),CL8'&NAME',CL15'&SYSDATE.--&SYSTIME'\n         AIF   (&RT).C1\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n.C1      ANOP\n&SAVEAA  SETA  1\n&SAVEA   SETA  N'&BASE\n         AIF   ('&SVAREA' EQ 'NO').NOTBSER\n         AIF   ('&BASE' NE '15' AND '&BASE' NE 'R15').NOTBSER\n         MNOTE 8,'*** POSSIBLE BASE PROBLEM, SVAREA REQ''D BASE=&BASE'\n.NOTBSER ANOP\n.REGLOP  AIF   (&SAVEAAA EQ &SAVEA).REGLOP1\n&SAVEAAA SETA  &SAVEAAA+1\n         AIF   ('&BASE(&SAVEAAA)' NE '&PARMREG').REGLOP\n         MNOTE 12,'*** PARMREG AND BASE &BASE(&SAVEAAA) EQUAL CORRECT'\n.REGLOP1 ANOP\n         AIF   ('&BASE' EQ '15' OR '&BASE' EQ 'R15').NOMOBS\n         AIF   (N'&BASE NE 1).REGLOP2\n&USBS(1) SETC  '&BASE'\n         AGO   .USEND\n.REGLOP2 ANOP\n&CNT     SETA  K'&BASE\n&CNT1    SETA  2\n&CNT2    SETA  1\n.USLOP   AIF   (&CNT-&CNT1 LT 9).USLAST\n&USBS(&CNT2) SETC '&BASE'(&CNT1,8)\n&CNT1    SETA  &CNT1+8\n&CNT2    SETA  &CNT2+1\n         AGO   .USLOP\n.USLAST  ANOP\n         AIF   (&CNT-&CNT1-1 LE 0).USEND\n&USBS(&CNT2) SETC '&BASE'(&CNT1,&CNT-&CNT1)\n.USEND   ANOP\n         AIF   (&B13).NOMOBS\n         BALR  &BASE(1),R0         LOAD FIRST OR ONLY BASE\n.B13USG  USING &USLBL,&USBS(1)&USBS(2)&USBS(3)&USBS(4)&USBS(5)&USBS(6)\n.LOADBSS AIF   ('&SAVEA' EQ '1').NOMOBS\n&SAVEA   SETA  &SAVEA-1\n&SAVEAAA SETA  &SAVEAA\n&SAVEAA  SETA  &SAVEAA+1\n         LA    &BASE(&SAVEAA),2048(&BASE(&SAVEAAA)) LOAD BASE\n         LA    &BASE(&SAVEAA),2048(&BASE(&SAVEAA)) LOAD BASE\n         AGO   .LOADBSS\n.NOMOBS  ANOP\n         AIF   (&B13S).B13OUT\n         AIF   ('&PARMREG' EQ 'R1' OR '&PARMREG' EQ '1').NOPRG\n&SAVEBB  SETB  1\n         LR    &PARMREG,R1         SAVE PARAMETER LIST ADDRESS\n         AGO   .PRGLOD\n.NOPRG   AIF   ('&SVAREA' EQ 'NO').NOSVE\n         AIF   ('&BASE' NE '2' AND '&BASE' NE '2').OKPSVE\n         MNOTE 8,'***  &BASE  EQUAL TO PARM SAVE DEFAULT REG R2 - CHANGX\n               E BASE OR CODE THE PARMREG PARAMETER'\n.OKPSVE  ANOP\n         LR    R2,R1               SAVE PARAMETER LIST ADDRESS\n.PRGLOD  AIF   ('&SVAREA' EQ 'NO').NOSVE\n         AIF   ('&SVAREA' EQ 'EXTERNAL' OR '&SVAREA' EQ 'YES').GTMN\n         LA    R1,&SAVEC&SYSNDX    GET ADDRESS OF INTERNAL SAVE AREA\n         AGO   .SVELNK\n.GTMN    GETMAIN R,LV=72           GET A NEW SAVEAREA\n.SVELNK  ANOP\n         ST    R13,4(R1)\n         AIF   (&RT).C2\n         ST    R1,8(R13)           SAVE NEW SAVEAREA ADDRESS\n.C2      ANOP\n         LR    R13,R1              SET NEW SAVEAREA ADDRESS IN R13\n&B13S    SETB  1\n&USLBL   SETC  '&SAVEC&SYSNDX'\n         AIF   (&B13).B13USG\n.B13OUT  ANOP\n         AIF   ('&SVAREA' NE 'EXTERNAL' AND &SVAREA' NE 'YES').SVBR\n         AIF   ('&SVAREA' NE 'EXTERNAL').SVBR\n.NOSVE   AIF   ('&RETURN' EQ 'NO').NORET\n.SVBR    B     &SAVEC&SAVEA1       GO TO EXECUTE\n         AIF   ('&SVAREA' EQ 'EXTERNAL' OR '&SVAREA' EQ 'YES' OR '&SVARX\n               EA' EQ 'NO').NOISVE\n&SAVEC&SYSNDX DC 9D'0'             INTERNAL SAVEAREA\n.NOISVE  ANOP\n         AIF   (&RT OR '&RETURN' EQ 'NO').NORET\n&RETL    SETC  'RETURN'\n         AIF   ('&RETURN' EQ '').NORLB\n&RETL    SETC  '&RETURN(&RTNCTL)'\n.NORLB   ANOP\n&RETL    DS    OH            RETURN TO CALLER\n         AIF   ('&SVAREA' EQ 'NO').NOSVE2\n         AIF   ('&SVAREA' NE 'EXTERNAL').SVL13\n         LR    R1,R13              GET ADDRESS OF SAVAREA TO FREE\n.SVL13   L     R13,4(R13)          RESTORE OLD SAVEAREA ADDRESS IN R13\n         AIF   ('&SVAREA' NE 'EXTERNAL').NOSVE2\n         FREEMAIN R,LV=72,A=(1)    FREE NEW SAVEAREA\n.NOSVE2  ANOP\n         AIF   ('&PASSREG' EQ '').SLM\n         AIF   ('&PASSREG' EQ '15' OR '&PASSREG' EQ 'R15').LEAV15\n         LR    R15,&PASSREG        SAVE VALUE IN PASSREG\n         LM    R0,R12,20(R13)      RESTORE ALL REGS BUT R14-R15\n         L     R14,12(R13)         RESTORE R16\n         LR    &PASSREG,R15        RESTORE PASSREG VALUE\n         AGO   .RC\n.LEAV15  LM    R0,R12,20(R13)      RESTORE ALL REGS BUT R14-R15\n         L     R14,12(R13)         RESTORE R16\n         AGO   .RC\n.TWO     ANOP\n&RTNCTL  SETA  &RTNCTL+2\n&RTCCTL  SETA  &RTCCTL+2\n         AGO   .NOISVE\n.SLM     ANOP\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n.RC      AIF   (N'&RETURN LT 2).NORCD\n&RC      SETA  &RETURN(&RTCCTL)\n.NORCD   ANOP\n         AIF   ('&PASSREG' EQ '15' OR '&PASSREG' EQ 'R15').R15PSRG\n         LA    R15,&RC             PLACE RETURN CODE IN R15\n.R15PSRG AIF   ('&SAMECC' EQ 'NO').BR14\n         SPM   R14                 RESTORE CONDITION CODE\n.BR14    BR    R14                 RETURN TO CALLER\n         AIF   (&RTCCTL LT N'&RETURN).TWO\n.NORET   ANOP\n&SAVEC&SAVEA1  EQU *               START OF MODULE\n         AIF   (&SAVEBB).PRMREG\n         AIF   ('&SVAREA' EQ 'NO').PRMREG\n         LR    R1,R2               RESTORE PARAMETER REGISTER\n.PRMREG  ANOP\n         EJECT\n         MEND\nBLDG     TITLE 'BUILD DIAGNOSE CARDS FOR NIGHTLY RUNS'\n         EJECT\n*    THE FOLLOWING IS USED TO MAP THE IDCAMS INPUT RECORDS            *\nIDCREC   DSECT\nIDCCC     DS    CL1        PRINTER CONTROL FIELD\nIDCDATA  DS    CL120      MAXIMUM IDCAMS RECORD\n         SPACE 2\n         ORG   IDCDATA             OVERLAY THE IDCDATA AREA\nIDCNVTG  DS    CL7        'CLUSTER'   TAG OF RECORD\n         DS    CL9        ' ------- '\nIDCNAME  DS    CL44       MAXIMUM DATASET NAME\n         SPACE 2\n         ORG   IDCDATA             OVERLAY THE IDCDATA AREA\n         DS    CL5        '     '\nIDCVLTG  DS    CL6        'IN-CAT'   TAG OF RECORD\n         DS    CL5        ' --- '\nIDCAT    DS    CL44       CATALOG NAME\n         ORG\nIDCLENX  EQU   *-IDCCC             LENGTH OF ENTRY\n         EJECT\nIOPNTRS  DSECT\nIOUSR    DS    A                   ADDRESS OF USER DATA\nIOFLGS   DS    A                   ADDRESS OF FLAGS\n*      BYTE 1 (OPERATION)\nIOPEN    EQU   0                   OPEN FILE\nIOCLOSE  EQU   4                   CLOSE FILE\nIOGET    EQU   8                   GET RECORD\nIOPUT    EQU   12                  PUT RECORD\n*      BYTE 2\nIOPENG   EQU   128                 OPEN FOR INPUT\nIOPENP   EQU   64                  OPEN FOR OUTPUT\nIOPENI   EQU   32        IOINFO CONTAINS ADDRESS OF DDNAME ON OPEN\nIOPEND   EQU   16        IOINFO CONTAINS ADDRESS OF DATASET ON OPEN\n*      BYTE 3,4 (RECORD TYPE FOR PUT ONLY\nIOPUTN   EQU   0                   NORMAL DATA RECORD TO BE WRITTEN\n*              N     MESSAGE SERIAL NUMBER IF IDC MESSAGE TO BE\n*                    WRITTEN\nIOINFO   DS    A                   ADDRESS OF I/O INFO\n*   ON OPEN, IOINFO CONTAINS POINTER TO DDNAME OR DATASETNAME\n*      DDNAME - 8 BYTE FIELD LEFT-JUSTIFIED CONTAINING DDNAME.\n*      DATASETNAME - 44 BYTE FIELD CONTAINING THE DATASET NAME.\n*   ON CLOSE, IOINFO CONTAINS POINTER TO DATASET NAME AS ABOVE.\n*   FOR A GET OR PUT IOINFO POINTS TO AN 8 BYTE AREA.\n*         (ON A GET THE USER I/O ROUTINE RETURNS THE INFO TO\n*               THE PROCESSOR, FOR A PUT THE PROCESSOR GIVES\n*               THIS INFORMATION TO THE USER'S I/O ROUTINE.)\n*   RECORD(GET):    ADDRESS OF RETRIEVED RECORD\n*   RECORD(LENGTH): FULL WORD LENGTH OF RETRIEVED RECORD.\n*\n*   RECORD(PUT):    ADDRESS OF RECORD TO BE WRITTEN\n*   RECORD(LENGTH): FULL WORD LENGTH OF RECORD TO BE WRITTEN.\n*\n*     GET OR PUT   ADDRESS OF RECORD   A\n*                  RECORD LENGTH       F\n         EJECT\nBLDDIAG  SBMSAVE BASE=(R12)\n         EJECT\n         L     R3,=V(HCARDS)\n         ST    R3,SAVE3\n         OPEN  (SYSIN,(INPUT))\n         OPEN  (SYSPUNCH,(OUTPUT))\nBLLOOP   DS    0H\n         GET   SYSIN,CARDREC\n         EJECT\n         MVC   ADSN,CARDREC            MOVE TO USER AREA\n         LINK EP=IDCAMS,PARAM=(IDOPTS,IDDNMS,IDPGNO,IDIOLST),VL=1\n         LTR  R15,R15              CHECK RETURN\n         B    BLLOOP\nENDIT    DS   0H\n         CLOSE SYSIN\n         L     R3,=V(HCARDS)\n         ST    R3,SAVE3\n         MVC   PRJCL,JOBCARD\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,JOBCARD1\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,ROUTCARD\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\nSTEPLOOP DS    0H\n         ZAP   DDNBRP,=P'0'\n         MVC   HOLDCAT,45(R3)\n         MVC   COMCAT,HOLDCAT\n         MVC   PRJCL,COMCARD1\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,COMCARD\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,COMCARD1\n         PUT   SYSPUNCH,PRJCL\n         AP    STNBRP,=P'1'\n         UNPK  STEPNBR,STNBRP\n         OI    STEPNBR+2,X'F0'\n         MVC   PRJCL,STEPCARD\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,PRNTCARD\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\nLOPDDCD  DS    0H\n         AP    DDNBRP,=P'1'\n         MVC   DDDSN,0(R3)\n         MVC   DDVOLS,DDDSN+11\n         MVC   DDCNBR,DDVOLS\n         MVC   PRJCL,DDCARD1\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,DDCARD2\n         PUT   SYSPUNCH,PRJCL\n         LA    R3,88(R3)\n         CLC   HOLDCAT(20),45(R3)    IS IT SAME CATALOG\n         BE    LOPDDCD\n         ST    R3,SAVE3A\n         L     R3,SAVE3\nGETOUT   DS    0H\n         MVC   PRJCL,SYSCARD\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\n         ZAP   DDNBRP,=P'0'\nLOPDINP  DS    0H\n         MVC   DIAV1NBR,11(R3)\n         MVC   DIAV3NBR,DIAV1NBR\n         MVC   DIAV2CAT,45(R3)\n         MVC   DIAV4CAT,45(R3)\n         MVC   PRJCL,DIAV1\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,DIAV2\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,DIAV3\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\n         MVC   PRJCL,DIAV4\n*        PUT   SYSPRINT,PLINE\n         PUT   SYSPUNCH,PRJCL\n         LA    R3,88(R3)\n         CLC   HOLDCAT(20),45(R3)    IS IT SAME CATALOG\n         BE    LOPDINP\n         CLC   0(8,R3),BLANKS\n         BE    GETOUTX\n         L     R3,SAVE3A\n         ST    R3,SAVE3\n         B     STEPLOOP\nGETOUTX  DS    0H\n         CLOSE SYSPRINT\n         CLOSE SYSPUNCH\n         B   RETURN\n         EJECT\n*     IDCAMS CALL OPTION LIST\nIDOPTS   DC    H'0'                NO OPTIONS TO PASS\nIDDNMS   DC    H'0'                NO ALTERNATE DDNAMES\nIDPGNO   DC    H'0'                NO PAGE NUMBER\nIDIOLST  DC    F'2'                NUMBER OF GROUPS WHICH FOLLOW\nIDADN1   DC    A(ASYSIN)           ADDRESS OF SYSIN\nIDAIO1   DC    A(BLDSIO)           ADDRESS OF I/O ROUTINE\nIDAUS1   DC    A(ASYSUS)           ADDRESS OF USER AREA\nIDADN2   DC    A(ASYSPRNT)         ADDRESS OF SYSIN\nIDAIO2   DC    A(BLDSIP)           ADDRESS OF I/O ROUTINE\nIDAUS2   DC    A(ASYSUS)           ADDRESS OF USER AREA\nASYSIN   DC    CL10'DDSYSIN'       USE THIS FOR SYSIN\nASYSUS   DC    CL80' '             I/O AREA\n         ORG   ASYSUS\nADSN     DC    CL44' '\n         ORG\nASYSPRNT DC    CL10'DDSYSPRINT'    USE THIS FOR SYSPRINT\n         EJECT\n         LTORG\nCARDREC  DS    CL80\n         EJECT\n*   SYSIN   - DCB FOR INPUT SWAP CARDS                            *\nSYSIN    DCB   DSORG=PS,MACRF=GM,RECFM=FB,,LRECL=80,                   X\n               DDNAME=SYSIN,EODAD=ENDIT\n         EJECT\nBLDSIO   SBMSAVE ROOT=NO,RETURN=(A90,0,A94,4,A98,8,A9C,12),BASE=(R8)\n         LR    R6,R1              LOAD PASSED PARMS\n         USING IOPNTRS,R6\n         L     R15,IOFLGS\n         XR    R5,R5\n         IC    R5,0(R15)          REG 3 CONTAINS TYPE OF OPERATION\n         B     ASYSFUNC(R5)\nASYSFUNC DS    0H\n         B     ASOPEN\n         BE    ASCLOSE\n         BE    ASGET\n         BE    ASPUT\n         DC    F'0'                THEN ABEND\nASOPEN   DS    0H\n         L     R5,IOUSR            POINT TO USER AREA\n         MVC   ASC1NM,0(R5)        MOVE NAME TO I/O AREA\n         MVC   PDSCAT,BLANKS     CLEAR THE DATA SET NAME\n         MVC   PDSCAT(L'ASC1NM),ASC1NM\n         MVI   FIRST,C' '          RESET TO FIRST CARD\n         B     A90\nASPUT    DS    0H\nASCLOSE  DS    0H\n*      NO ACTUAL FILE SO JUST RETURN TO PROCESSOR\n*      WITH 0 RETURN CODE\n         B     A90\nASGET    DS    0H\n         L     R5,IOINFO\n         CLI   FIRST,C'1'\n         BE    A94\n         MVI   FIRST,C'1'      SHOW DONE WITH FUNCTION\n         MVC   0(4,R5),=A(ASCARD1)\n         MVC   4(4,R5),=F'80'\n         B     A90\n         EJECT\nASCARD1  DC    CL80' '\n         ORG   ASCARD1+2\n         DC    C'LISTC LVL(SYS1.VVDS) CAT('\nASC1NM   DC    CL30' '\n         DC    C')'\n         ORG\nFIRST    DC    C' '\n         TITLE 'IDCAMS PROCESSOR FOR PRINT LINES'\nBLDSIP   SBMSAVE ROOT=NO,RETURN=(B90,0,B94,4,B98,8,B9C,12),           X\n               BASE=(R10,R11)\n         LR    R6,R1              LOAD PASSED PARMS\n         USING IOPNTRS,R6\n         L     R15,IOFLGS\n         MVC   HOLDER,2(R15)      MOVE ERROR TO HOLD POSITION\n         XR    R5,R5\n         IC    R5,0(R15)          REG 3 CONTAINS TYPE OF OPERATION\n         B     BSYSFUNC(R5)\nBSYSFUNC DS    0H\n         B     BSOPEN\n         BE    BSCLOSE\n         BE    BSGET\n         BE    BSPUT\n         DC    F'0'                THEN ABEND\nBSOPEN   DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         B     B90\nBSGET    DS    0H\n*      NO ACTUAL FILE SO JUST RETURN TO PROCESSOR\n*      WITH 0 RETURN CODE\n         B     B90\nBSPUT    DS    0H\n         L     R5,IOINFO\n         L     R9,0(R5)\n         L     R7,4(R5)            LENGTH OF FIELD FOR VARIABLE MOVE\n         USING IDCREC,R9\nBLDTBL   DS    0H\n         SPACE 2\n         CLC   HOLDER,=H'0'        IS THERE AN ERROR\n         BE    ARNDUM              NOT THIS TIME\n         CLC   HOLDER,=X'FFFF'     NORMAL COMPLETION\n         BE    B90                 NOT THIS TIME\n         CLC   HOLDER,=X'FFFE'     NORMAL COMPLETION\n         BE   B90                  NOT THIS TIME\n         EX   R7,MVCDUM\n         PT   SYSPRINT,IDCLINE\n         MVC  IDCLINE,BLANKS\n         LH   R5,HOLDER           PICK UP ERROR CODE\n         CP   DWORD,=P'1'           NORMAL COMPLETION\n         BE    B90                 NOT THIS TIME\n         CLC  DWORD,=P'2'\n         BE    B90                 NOT THIS TIME\n         CVD  R5,DWORD            MAKE IT USEFUL\n         DC   F'0'\n         MVC  IDCLINE+2(6),ED5MSK\n         ED   IDCLINE+2(6),DWORD+5\n         PUT  SYSPRINT,IDCLINE\n         MVC  IDCLINE,BLANKS\n         B    ARNDUM\nMVCDUM   MVC  IDCLINE(0),0(R9)\nARNDUM   DS    0H\n         CLC   IDCNVTG,=C'CLUSTER'    IS THIS A DATASET NAME\n         BE    BLDNAME             MOVE THE NAME\n         CLC   IDCVLTG,=C'IN-CAT'    IS THIS A VOLSER RECORD?\n         BNE   B90\n         EJECT\nGOTVOLS  DS    0H\n         MVC   PDSCAT,BLANKS     CLEAR THE DATASET NAME\n         LA    R4,17               LENGTH OF UNWANTED STUFF\n         SR    R7,R4               FROM LENGTH OF WHOLE LINE\n         BCTR  R7,0                MINUS 1 FOR EX LENGTH\n         EX    R7,MOVCAT\n         PUT   SYSPRINT,PLINE\n         MVC   PLINE,BLANKS\n         B     B90\n         SPACE 3\nMOVCAT   MVC  PDSCAT(0),IDCAT\n         SPACE 3\nBLDNAME  DS    0H\n         MVC   PDSVVDS,BLANKS     CLEAR THE DATASET NAME\n         LA    R4,17               LENGTH OF UNWANTED STUFF\n         SR    R7,R4               FROM LENGTH OF WHOLE LINE\n         BCTR  R7,0                MINUS 1 FOR EX LENGTH\n         EX    R7,MOVVVDS\n         ST   R3,SAVE3A\n         L    R3,SAVE3\n         MVC  0(44,R3),PDSVVDS\n         MVC  45(44,R3),PDSCAT\n         LA   R3,88(R3)\n         ST   R3,SAVE3\n         L    R3,SAVE3A\n         B     B90\n         SPACE 3\nMOVVVDS  MVC  PDSVVDS(0),IDCNAME\n         SPACE 3\n         EJECT\nENDBLD   DS    0H\nBSCLOSE  DS    0H\n         B     B90\n*  PRINTER/PUNCH WORK AREAS\nIDCLINE  DC    CL133' '\n         SPACE 2\nPDSCAT   DC    CL44' '             DATASET ORGANIZATION\nPDSVVDS  DC    CL44' '             RECORD FORMAT\nPLINE    DC    CL133' '\n         ORG   PLINE\n         ORG   PLINE+10\nPRJCL    DS    CL80\n         ORG\n         EJECT\nDWORD    DC    D'0'                DOUBLEWORD WORK AREA\nHOLDER   DC    H'0'                HOLD ERROR FROM IDCAMS\nED4MSK   DC    XL4'40202120'         EDIT MASK FOR EXTENTS\nED5MSK   DC    XL6'402020202120'     EDIT MASK FOR BLK AND LRECL\nBLANKS   DC    CL200' '\nSAVE3    DC   F'0'\nSAVE3A   DC   F'0'\nDDNBRP   DC   PL2'0'\nSTNBRP   DC   PL2'0'\nHOLDCAT  DC   CL44' '\nJOBCARD  DC   CL80'//T#TCDIAG JOB (0,845-T#T100TC--P1------),H45D7,'\nJOBCARD1 DC   CL80'//  MSGCLASS=A,CLASS=5,NOTIFY=T#TC '\nROUTCORD DC   CL80'/*ROUTE PRINT U99'\nCOMCARD1 DC   CL80'//*'\nCOMCARD  DC   CL80' '\n         ORG   COMCARD\n         DC   C'//* CATALOG DIAGNOSE FOR '\nCOMCAT   DC   CL42' '\n         ORG\nSTEPCARD DC   CL80' '\n         ORG  STEPCARD\n         DC   C'//STEP'\nSTEPNBR  DC   CL3'000'\n         DC   C'   EXEC PGM=IDCAMS '\n         ORG\nPRNTCARD DC   CL80'//SYSPRINT DD  SYSOUT=A '\nDDCARD1  DC   CL80' '\n         ORG  DDCARD1\n         DC   C'//'\nDDCNBR   DC   CL6' '\n         DC   C'   DD  AMP=AMORG,DISP=SHR,UNIT=DISK,'\n         ORG\nDDCARD2  DC   CL80' '\n         ORG  DDCARD2\n         DC   C'//    VOL=SER='\nDDVOLS   DC   CL6' '\n         DC   C',DSN='\nDDDSN    DC   CL44' '\n         ORG\nSYSCARD  DC   CL80'//SYSIN  DD * '\nDIAV1    DC   CL80' '\n         ORG  DIAV1\n         DC   C'  DIAG VVDS NOLIST IFILE('\nDIAV1NBR DC   CL6' '\n         DC   C') -'\n         ORG\nDIAV2    DC   CL80' '\n         ORG  DIAV2\n         DC   C'   CMPRDS('\nDIAV2CAT DC   CL42' '\n         DC   C')'\n         ORG\nDIAV3    DC   CL80' '\n         ORG  DIAV3\n         DC   C'  DIAG ICFCAT NOLIST CMPRDD('\nDIAV3NBR DC   CL6' '\n         DC   C') -'\n         ORG\nDIAV4    DC   CL80' '\n         ORG  DIAV4\n         DC   C'   IDS('\nDIAV4CAT DC   CL42' '\n         DC   C')'\n         ORG\n         EJECT\n*   SYSPRINT- DCB FOR DSN LISTING                                 *\nSYSPRINT DCB   DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133,BLKSIZE=133,      X\n               DDNAME=AMSPRINT\nSYSPUNCH DCB   DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,                    X\n               DDNAME=SYSPNCH\nBUFFERS   CSECT\n          ENTRY HCARDS\n          DS    0F\nHCARDS   DC    500CL88' '\n         DC    CL60'FFF'\n         END\n\nLarry D House\nSenior Systems Programmer\nIllinois Power Company (USA)              c Illinois Power Company 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A002A06": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\xab\\x00\\xab\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 171, "newlines": 171, "modlines": 0, "user": "VSAMUPD"}, "text": "VSAM utility programs\n\nThe following two programs were developed because we\nneeded to set a return code that depended on the status of a file.\nThe first program, VSMP01, is used to set a return code of 0 if\nthe file (normally a VSAM space managed work file) contains\nany records, and a return code of 8 if the file is empty.  The\nexecution of our jobstream can now be based on this return\ncode.  Prior to this program and VSE's conditional JCL, an\noperator would need to watch for VSAM open errors and/or\nprogram abends to determine the correct job flow.\n\nThe second program, VSMP02, opens a VSAM file for output.\nIf it cannot open the file a return code of 8 is generated.  If the\nfile can be opened, a 0 return code is generated.  This program\nis useful to determine if a file is currently open by another job,\nfor example CICS.  The file to be tested must be defined with\nshareoption 3 and have a corresponding DLBL in the jobstream\nor in standard labels.  The filename of the cluster must be\nsupplied to this program using the PARM function of the //\nEXEC statement.\n\n\nVSMP01\n\n* THIS PROGRAM WILL READ CATALOG INFO TO DETERMINE IF ANY RECORDS\n* EXIST FOR THE ASSOCIATED FILE.  THE ONLY REQUIREMENT TO EXECUTE IS\n* A DLBL FOR FILENAME... \"VSMP01\" WITH THE CORRESPONDING FILE-ID OF\n* THE FILE TO BE TESTED.\n* USED ENDRBA WITH TESTCB BECAUSE VSAM SPACE MANAGER\n* NEVER APPEARS TO UPDATE NLOGR CATALOG FIELD... ALWAYS 0.\nVSAMCHK  START 0\n         COPY  EQUREG\n         BALR  3,0\n         USING *,3\n         OPEN  CONSOLE\n         OPEN  BLOCK\n         LA    R7,OPERR            LOAD ADDR OF OPEN ERROR MESSAGE\n         LA    R5,0                SET RETURN CODE = 0\n         LTR   R15,R15             GOOD OPEN?\n         BNZ   END                 NO... END\n         TESTCB ACB=BLOCK,AM=VSAM,                                     C\n               ENDRBA=0,                                               C\n               ERET=END\n         BE    GOTNUN              IF CC = 0 THEN WE HAVE NO DATA\nGOTSUM   LA    R5,0                SET RC = 0\n         LA    R7,DATAFND          LOAD ADDR OF DATA FOUND MSG\n         B     END                 YES.. EXIT WITH RC = 0\nGOTNUN   LA    R7,NODATA           NO.. LOAD ADDR OF NO RECS MESSAGE\n         LA    R5,8                     AND SET RETURN CODE = 8\nEND      EQU   *\n         CLOSE BLOCK\n         MVC   CONWRK,0(R7)\n         PUT   CONSOLE,CONWRK      DISPLAY CONSOLE MESSAGE\n         CLOSE CONSOLE\n         LR    R15,R5              MOVE IN RETURN CODE\n         EOJ   RC=(15)             END OF JOB.. SET RETURN CODE\nOPERR    DC    CL80'VSMP01 - VSAM DATA SET OPEN ERROR    - NO ACTION'\nSHOWERR  DC    CL80'VSMP01 - VSAM DATA SET SHOWCB ERROR  - NO ACTION'\nDATAFND  DC    CL80'VSMP01 - VSAM DATA SET CONTAINS DATA - NO ACTION'\nNODATA   DS    0CL80\n         DC    CL09'VSMP01 - '\n         DC    CL71'VSAM DATA SET CONTAINS 0 RECORDS - RC=8'\nDISPLAY  DS    0D\nNLOGR    DS    F\n         DS    F\nCONSOLE  DTFCN DEVADDR=SYSLOG,                                         C\n               IOAREA1=CONSIO,                                         C\n               WORKA=YES\nCONSIO   DS    CL80\nCONWRK   DS    CL80\nBLOCK    ACB   DDNAME=VSMP01,                                          C\n               MACRF=(ADR,SEQ,OUT)\nLIST     RPL   ACB=BLOCK\n         END   VSAMCHK\n/*\n\nExample JCL\n\n// DLBL VSMP01,'PROD.VSAM.MYFILE',,VSAM,CAT=USRCAT1\n// EXEC VSMP01,SIZE=VSMP01\n/* A RETURN CODE OF 0 IMPLIES RECORDS ARE PRESENT\n// IF $RC NE 0 THEN\n// GOTO STEP2\n/. STEP1\n.\n.\n/. STEP2\n.\n\n\nVSMP01\n\n* THIS PROGRAM WILL OPEN A VSAM FILE FOR OUTPUT.  IF AN OPEN ERROR\n* OCCURS IT PLACES A VALUE OF '08' INTO REGISTER 15.  (RC = 08)\n* A PARM='FILENAME' IS REQUIRED ON THE // EXEC CARD\n* ASSOCIATED DLBL FOR FILENAME MUST BE ACCESSIBLE.\nVSMP02   START 0\n         COPY  EQUREG\n         BALR  3,0\n         USING *,3\n         COMRG\n         ST    R6,PARMSAVE\n         USING PRMDSECT,R6\n         MVC   FNAME,PARMDATA\n         TR    FNAME,TABLE\n         MODCB ACB=BLOCK,DDNAME=(*,FNAME)\n* OPEN ACB\n         OPEN  CONSOLE\n         OPEN  BLOCK\n         LA    R7,OPGOOD           LOAD ADDR OF OPEN MESSAGE\n         LA    R5,0                SET RETURN CODE = 0\n         LTR   R15,R15             GOOD OPEN?\n         BZ    END                 NO... GET OUT OF TOWN\n         LA    R7,OPERR            LOAD ADDR OF OPEN ERROR MESSAGE\n         LA    R5,8                SET RC = 8 (OPEN ERROR)\nEND      EQU   *\n         CLOSE BLOCK\n         MVC   CONWRK,0(R7)\n         PUT   CONSOLE,CONWRK      DISPLAY CONSOLE MESSAGE\n         CLOSE CONSOLE\n         LR    R15,R5              MOVE IN RETURN CODE\n         EOJ   RC=(15)             END OF JOB.. SET RETURN CODE\nOPGOOD   DC    CL80'VSMP02 - VSAM DATA SET CLOSED        - RC = 00  '\nOPERR    DC    CL80'VSMP02 - VSAM DATA SET OPEN ERROR    - RC = 08  '\nTABLE    DC    256X'40'\n         ORG   TABLE+X'C1'\n         DC    X'C1C2C3C4C5C6C7C8C9'\n         ORG   TABLE+X'D1'\n         DC    X'D1D2D3D4D5D6D7D8D9'\n         ORG   TABLE+X'E2'\n         DC    X'E2E3E4E5E6E7E8E9'\n         ORG   TABLE+X'F0'\n         DC    X'F0F1F2F3F4F5F6F7F8F9'\n         ORG   TABLE+256\nDISPLAY  DS    0D\nNLOGR    DS    F\nPARMSAVE DC    F'0'\nFNAME    DC    CL8'        '\n         DS    F\nCONSOLE  DTFCN DEVADDR=SYSLOG,                                         C\n               IOAREA1=CONSIO,                                         C\n               WORKA=YES\nCONSIO   DS    CL80\nCONWRK   DS    CL80\nBLOCK    ACB   DDNAME=VSMP02,                                          C\n               MACRF=(ADR,SEQ,OUT)\nLIST     RPL   ACB=BLOCK\nPRMDSECT DSECT\nPARMADDR DS    F\nPARMLEN  DS    H\nPARMDATA DS    CL8\nVSMP02   CSECT ,\n         END   VSMP02\n\nExample JCL\n\n// DLBL MYFILE,'PROD.VSAM.MYFILE',,VSAM,CAT=USRCAT1\n.\n// EXEC VSMP02,PARM='MYFILE'\n// IF $RC EQ 0 THEN\n// GOTO NOTOPEN\n// PAUSE MYFILE IS OPEN IN ANOTHER PARTITION (CHECK CICS).\n/. NOTOPEN\n.\n.\n.\n\nMark Johnson\nSystems Programmer (USA)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A002A07": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00I\\x00I\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 73, "newlines": 73, "modlines": 0, "user": "VSAMUPD"}, "text": "Allocating datasets using esoteric group names\n\n\nPROBLEM\n\nWhen I was a DASD Manager, I always felt that it would be nice to\nallocate VSAM datasets in the same manner as I allocated other\ndatasets, ie via an esoteric group name in the JCL UNIT parameter.\nSoftware on the market at the time seemed much too costly to provide\na service that should be readily available to MVS users.\n\nAfter giving it some thought, I came up with a solution which was\nsimple, worked well, and required little additional overhead.\n\n\nSOLUTION\n\nTo implement the method I devised, all that is required are a few\nadditions and changes to JCL in the IDCAMS procedures currently in\nplace, and the creation of an identically named VSAM parameter\nlibrary on each DASD volume on which VSAM datasets reside.  If\nesoteric group names do not exist for required volumes or are not\ncompatible with your shop's standards (eg VSAM datasets may be\nrestricted to all but selected volumes within an esoteric group), you\nwill be required to develop new pool names for this purpose.\n\nThe additional JCL is in the form of a BR14 job step.\n\n//BR14     EXEC PGM=IEFBR14\n//BR14     DD DSN=USER.VSAM.ALLOC.DISP=(NEW,DELETE),SPACE=(CYL,1000),\n//         UNIT=VSAM01\n//IDCAMS   EXEC PGM=IDCAMS\n//DASD     DD DISP=SHR,VOL=REF=*.BR14.BR14 (optional)\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=VSAM.PARM.LIB(VFILE1),DISP=SHR,VOL=REF=*.BR14.BR14\n\nIn the example JCL, a 'temporary' dataset is allocated within a VSAM\nDASD pool using IEFBR14 and UNIT=VSAM01.  In the IDCAMS\nstep following it, SYSIN (and the VSAM.PARM.LIB) is allocated via\na backward reference to the 'temporary' dataset allocation.  In this case\nall VSAM parameter libraries within the VSAM01 DASD pool must\nbe uncatalogued and named VSAM.PARM.LIB.  This is not a major\nproblem since as many as two hundred PARMLIB members can\nreside in a one-cylinder PDS.  Any software product purchased will\nprobably require several times the DASD space.\n\nBelow is a sample portion of the IDCAMS parameters located in\nVSAM.PARM.LIB (member VFILE1) which resides on volume\nVSM001.\n\nDEFINE CLUSTER (NAME(USER.VSAM.FILE1) -\nVOLUMES(VSM001)  -\nFILE(DASD) -      optional\nCYLINDERS(800 100)\n....\n....\n....\nDATA(NAME(USER.VSAM.FILE1.DATA) -\nCISZ(22528)) -\nINDEX(NAME(USER.VSAM.FILE1.INDX) -\nCISZ(1024))\n\nExcept for the VOLUMES parameter, member name VFILE1 would\nbe identical to all other VFILE1s on all other VSAM.PARM.LIBs.\nOn VSM002 the volume parameter would read\nVOLUMES(VSM002); on VSM003 the volume parameter would read\nVOLUMES(VSM003); and so on for every volume defined to the\nVSAM01 DASD pool.  As a result of using this method your VSAM\ncluster will be allocated as long as there is enough space on at least\none volume within a specified DASD pool.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A002A08": {"ttr": 2562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x050\\x050\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 1328, "newlines": 1328, "modlines": 0, "user": "VSAMUPD"}, "text": "SQL queries for VSAM catalog information\n\nTo analyse changes in performance of a VSAM file over time\nnecessarily involves wrestling with LISTCAT printouts and\nrecording the information of interest (eg CI splits).  The\nclerical effort involved is often discouraging and error-prone.  I\nhave written an extract program (VRECORD) to write all\nLISTCAT information for VSAM datasets to a VSAM work\nfile.  The work file is then used to load the LISTCAT\ninformation to an SQL table using the standard SQL table load\nutility.  One of the fields in the work file record is the system\ndate, so SQL queries can be written that track file behaviour\nover time.\n\nHaving LISTCAT information available in SQL format would\nallow a VSAM exception reporting system to be quickly\nwritten as a set of ISQL queries.  More elaborate SQL batch or\non-line report applications could include:\n\no      Graphs/bar charts\n\no      Reports on 'ineffective' CI Free Space (ie where %CI Free\n      Space is less than the record size)\n\no      Reports on clusters that vary from installation standards\n\no      STRNO, BUFNI, BUFND, SHAREOPTIONS\n\no      Programs which produce replacement IDCAMS and JCL\n      statements for clusters with unsatisfactory parameters.\n      Perhaps these programs could be a mandatory VSAM\n      definition interface for application programmers.\n\nSimple ISQL queries can give very useful information quickly.\nThe following query, for instance, would list Control Interval\nsplit behaviour over time:\n\n     SELECT CLUSTER, CATALOG, CISPLIT, PCTCI,\n            UPDATES, INSERTS, RDATE\n     FROM VSAMINFO         /* VSAM info table name */\n     WHERE\n     OBJECT = 'K'          /* KSDS only */\n     AND CLUSTER = 'MY.CLUSTER'\n     AND CISPLIT > 0\n     ORDER BY CISPLIT;     /* In severity order */\n\nTo list where updates are causing too many Control Interval\nsplits:\n\n     SELECT CLUSTER, CATALOG, CISPLIT, UPDATES, PCTCI, RDATE\n     FROM VSAMINFO\n     WHERE\n     OBJECT = 'K'\n     AND CLUSTER = 'MY.CLUSTER'\n     AND (UPDATE > CISPLIT) < 10\n     ORDER BY CISPLIT;\n\nTo list inactive clusters or alternate indexes:\n\n     SELECT CLUSTER, CATALOG, OBJECT, RDATE\n     FROM VSAMINFO\n     WHERE\n     OBJECT = 'K' OR OBJECT = 'A'    /* KSDS or AIX */\n     AND RETRIEVES = 0\n     ORDER BY CLUSTER;\n\nTo list clusters or alternate indexes with possible space\nproblems for a given date:\n\n     SELECT CLUSTER, CATALOG, OBJECT, RDATE, FREEBYTE, EXTENTS\n     FROM VSAMINFO\n     WHERE OBJECT = 'K' OR OBJECT = 'A'\n     WHERE EXTENTS > 5\n     OR FREEBYTE < 100000\n     AND RDATE = '27/10/90';\n     ORDER BY CLUSTER;\n\nTo plot EXCPs against retrieves for KSDSs over time for a\ngiven catalog:\n\n     SELECT CLUSTER, CATALOG, RETRIEVES, EXCP, RDATE\n     FROM VSAMINFO\n     WHERE OBJECT = 'K'\n     AND CATALOG = 'MY.USER.CATALOG'\n     AND RETRIEVES > 0\n     ORDER BY EXCP;\n\nVRECORD was assembled using the structured programming\nmacros IF, ENDIF, DO, ENDDO etc.  These make the\nprogram logic much clearer.  If you do not have these macros,\nreplace them with standard Assembler constructs.  The\nprogram was written for VSE/VSAM 1.3.0, VSE/SP 2.1.4 - if\nyou have a different release (or use FBA devices), you may\nneed to check it for correct operation.  All flag fields and\nnumeric fields in the catalog records are converted to\nalphameric fields in the work file record, simplifying the load\nto the SQL table.\n\n TITLE 'VRECORD - PROGRAM TO EXTRACT LISTCAT INFO TO WORK FILE'\n*  REFERENCE : VSE/VSAM LOGIC, VOLUME 1 LY24-5191-2\n* REQUIRED JCL\n* // JOB LISTJOB\n* /*\n* /* DEFINE THE WORK FILE\n* // EXEC IDCAMS,SIZE=AUTO\n*    DELETE WORK.FILE CLUSTER CAT(WORK.CATALOG)\n*     DEFINE CLUSTER (          -\n*          NAME (WORK.FILE)     -\n*          NONINDEXED           -\n*          CISZ(4096)           -\n*          RECORDSIZE(460 460)) -\n*          CATALOG(WORK.CATALOG)\n*     IF LASTCC NE 0 THEN CANCEL JOB\n* /*\n* /* WRITE ALL THE CATALOG INFO TO THE WORK FILE\n* // LIBDEF *,SEARCH=LIB.SUBLIB\n* // DLBL CFILE,'WORK.FILE',,VSAM,BUFSP=40960\n* // EXEC VRECORD,SIZE=AUTO\n* /*\n* // IF $RC NE 0 THEN\n* // GOTO $EOJ\n* /*\n* /* IF ALL OK, LOAD WORK FILE TO SQL TABLE\n* /*\n* /*\n* /&\n*\n         EJECT\n* LOGIC OVERVIEW :\n* OPEN PRINT, WORK FILE (VSAM ESDS)\n* GET STORAGE FOR USERCATALOG TABLE\n* DO UNTIL EOF ON MASTERCATALOG\n*    IF USERCATALOG RECORD, SAVE NAME & ACB ADDRESS IN TABLE\n* ENDDO\n* DO UNTIL END OF USERCATALOG TABLE\n*    POINT READ RPL TO CURRENT USERCAT ENTRY\n*    DO UNTIL EOF\n*       IF CLUSTER/AIX RECORD, SAVE NAME & CINO IN CLUSTER TABLE\n*    ENDDO\n*    SORT CLUSTER TABLE IN NAME SEQUENCE\n*    DO UNTIL END OF CLUSTER TABLE\n*       READ CLUSTER'S CATALOG RECORD (KEY = CINO)\n*       DO UNTIL END OF ASSOCIATED RECORD PTRS\n*          READ ASSOCIATED DATA RECORD\n*          POINT TO AMDSB (STATS BLOCK) WITHIN RECORD\n*          GET DETAILS\n*          IF KSDS OR AIX\n*             READ ASSOCIATED INDEX RECORD\n*             PRINT DETAILS                                             ........\n*          ENDIF\n*          WRITE DETAILS TO WORK FILE     ........\n*       ENDDO\n*    ENDDO\n*    PRINT COMPLETION MSGS\n* ENDDO\n         EJECT\n*   REGISTER USAGE\n*\n*   R1-R2  WORK\n*   R3  -  BASE REG FOR RECORD DSECTS\n*   R4  -  WORK\n*   R5  -  PRINT BUFFER PTR\n*   R6-R7  WORK\n*   R8  -  CATALOG TABLE PTR\n*   R9  -  NOT USED\n*   R10 -  LINK REGISTER\n*   R11,R12 -  PROGRAM BASE\n*   R13 -  VSAM SAVE AREA PTR\n         EJECT\n         PRINT NOGEN\nVRECORD    CSECT\n         BALR  R11,0               R11 = PROGRAM BASE\n         USING *,R11,R12           SET PROGRAM BASE REGS R11, R12\n         LA    R12,1(R11)\n         LA    R12,4095(R12)\n         LA    R13,VSAMSAVE        R13 => VSAM SAVE AREA\n* GET SYSTEM DATE AND TIMESTAMP\n         COMRG REG=1               GET SUPERVISOR COMMS ADDRESS\n         MVC   SYSDATE(L'SYSDATE),0(R1)      GET DATE\n* OPEN PRINT FILE, GETMAIN WORKING STORAGE\n         OPEN  PRINTFL             OPEN PRINT FILE\n         BAL   R10,GETMAIN         GETMAIN WORKAREAS\n* OPEN CLUSTER INFO FILE\n         MVC   OPERATN,=CL8'OPEN'\n         OPEN  CACB\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n* READ MASTER CATALOG, THEN READ EACH CATALOG IN THE MASTER CATALOG\n         BAL   R10,MASTCAT         READ MASTER CATALOG\n         BAL   R10,USERCAT         READ USER CATALOGS\nRECDEXIT EQU   *                   EXIT POINT\n         BAL   R10,PRINT\n         IF    (OC,PROGRET,PROGRET,Z)\n         MVC   0(17,R5),=CL17'NORMAL COMPLETION'\n         BAL   R10,PRINT\n         MVC   0(14,R5),=CL14'OUTPUT RECORDS'\n         LA    R5,15(R5)\n         L     R1,RCOUNT\n         BAL   R10,CONVERTP\n         BAL   R10,PRINT\n         ENDIF\n         CLOSE CACB                CLOSE OUTPUT FILE\n         CLOSE PRINTFL             CLOSE PRINT FILE\n         XR    R15,R15\n         ICM   R15,B'0001',PROGRET  SET PROGRAM RETCODE\n         EOJ   RC=(15)\n         EJECT\n* GETMAIN WORKAREAS\nGETMAIN  DS    0H\n         ST    R10,GETSAV1\n         L     R0,CSIZE            R0 = SIZE OF CATALOG TABLE\n         GETVIS                    , ISSUE GETMAIN\n         IF    (LTR,R15,R15,NZ)    IF GETMAIN FAILED\n         B     BADMAIN             HANDLE ERROR\n         ENDIF\n         ST    R1,CATTAB\n         L     R0,CLSIZE           R0 = SIZE OF CLUSTER TABLE\n         GETVIS                    , ISSUE GETMAIN\n         IF    (LTR,R15,R15,NZ)    IF GETMAIN FAILED\n         B     BADMAIN             HANDLE ERROR\n         ENDIF\n         ST    R1,CLUSTAB\n         L     R10,GETSAV1\n         BR    R10\nGETSAV1  DS    F\nBADMAIN  DS    0H                  ERROR EXIT\n         ST    R15,PROGRET         SAVE RETCODE\n         MVC   PRTBUF+1(20),=CL20'** GETMAIN FAILED **'\n         BAL   R10,PRINT           NOTIFY &\n         B     RECDEXIT            EXIT\n         EJECT\n* MASTCAT - READ MASTER CATALOG TO GET USER CATALOG NAMES\nMASTCAT  DS    0H\n         ST    R10,MASSAV1\n* GET MASTER CATALOG ACB ADDRESS\n         LA    R2,=CL44'VSAM.MASTER.CATALOG'    FILE NAME\n         LA    R6,SHOWAREA         R6  => VSAM WORKAREA\n         USING WORKAREA,R6\n         MVC   AREALEN,=AL2(SHOWLEN)  SET LENGTH OF WORK AREA\n         MVC   OPERATN,=CL8'SHOWCAT'\n         SHOWCAT NAME=(2),AREA=(6)\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n* SET MASTER CATALOG ACB ADDRESS IN RPL\n         L     R2,CATACB\n         MVC   OPERATN,=CL8'MODCB'\n         MODCB RPL=CATRPLA,ACB=(2)\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n* WIPE CATALOG TABLE CLEAN BEFORE USE\n         L     R2,CATTAB           GET TABLE ADDRESS\n         L     R3,CSIZE            GET TABLE SIZE\n         XR    R4,R4\n         XR    R5,R5\n         MVCL  R2,R4\n         L     R7,CATTAB           R7 => CATALOG TABLE\n         USING CATSECT,R7\n         LA    R6,MAXCATS          R6 = MAX. ENTRIES\n         DO    INF                 DO UNTIL EOF\n         MVC   OPERATN,=CL8'GET'\n         GET   RPL=CATRPLA         READ A RECORD\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     MASTEOF             IF ANY ERROR, TREAT AS EOF\n         ENDIF\n         L     R3,RECBUFA          R3 => RECORD BUFFER\n         USING DATREC,R3\n         IF    (CLI,0(R3),NE,X'00')        DON'T GO PAST LO KEY RANGE\n         B     MASTEOF\n         ENDIF\n         IF    (CLI,ENTYPE,EQ,C'U'),AND,   IF USERCATALOG ENTRY        +\n               (CLC,NAME(L'NAME),NE,=CL44'VSAM.MASTER.CATALOG')\n         MVC   PRTBUF+1(L'NAME),NAME\n         BAL   R10,PRINT\n         MVC   UNAME,NAME\n         LA    R2,NAME\n         BAL   R10,SHOWCAT             GET ACB\n         ST    R2,UACB                 SAVE IT IN TABLE\n         LA    R7,ULEN(R7)             BUMP TABLE PTR\n         ENDIF\n         ENDDO\n         DROP  R3,R6,R7\nMASTEOF  EQU   *\n         L     R10,MASSAV1\n         BR    R10\nMASSAV1  DS    F\n         EJECT\n* USERCAT - FOR EACH USER CATALOG ENTRY IN CATALOG TABLE, SAVE ALL\n* CLUSTER/AIX NAMES IN CLUSTER PROCESSING TABLE\nUSERCAT  DS    0H\n         ST    R10,USESAV1\n         L     R3,CATTAB           R3 => CATALOG NAME/ACB TABLE\n         USING CATSECT,R3\n         LA    R4,MAXCATS          R4 =  MAX. NO. OF ENTRIES\n* CHANGE READ MODE TO DIRECT, KEYED - PARTIAL KEY ON CI NO.\n         MVC   OPERATN,=CL8'MODCB'\n         MODCB RPL=CATRPLA,OPTCD=(KEY,DIR,NUP,MVE,GEN),KEYLEN=4\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n* DO UNTIL LAST VALID ENTRY IN USER CATALOG TABLE\n         DO    FROM=(R4)\n         DOEXIT (OC,UNAME,UNAME,Z)\n* WIPE CLUSTER TABLE BEFORE USE\n         L     R6,CLUSTAB           GET TABLE ADDRESS\n         L     R7,CLSIZE            GET TABLE SIZE\n         XR    R8,R8\n         XR    R9,R9\n         MVCL  R6,R8\n         L     R7,CLUSTAB           R7 => CLUSTER TABLE\n         USING CLSECT,R7\n* SET HEADER = USER CATALOG NAME\n         MVC   HNAME(L'UNAME),UNAME        SET CATALOG NAME\n* SET ACB ADDRESS FOR THIS USERCATALOG IN RPLS A & B\n         L     R2,UACB             PLUG IN ACB ADDRESS FOR RPL\n         MVC   OPERATN,=CL8'MODCB'\n         MODCB RPL=CATRPLA,ACB=(2)\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n* READ USER CATALOG UNTIL EOF, PRINTING DETAILS FOR EACH CLUSTER\n         XC    CINO,CINO           START CI = 0\n         DO    INF                 DO UNTIL EOF\n         MVC   OPERATN,=CL8'GET'\n         GET   RPL=CATRPLA         READ A RECORD\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     CATEOF              IF ANY ERROR, TREAT AS EOF\n         ENDIF\n         LA    R2,RECBUFA          R2 => CATALOG RECORD\n         USING CLUSTREC,R2\n         IF    (CLC,CNAME,NE,UNAME)        IF NOT CAT'S CLUSTER ENTRY\n         IF    (CLI,CENTYPE,EQ,C'C'),OR,   IF CLUSTER ENTRY            +\n               (CLI,CENTYPE,EQ,C'G')       OR AIX ENTRY\n         BAL   R10,POST                    POST ENTRY TO TABLE\n         ENDIF\n         ENDIF\n         LA    R1,1                   BUMP CINO\n         A     R1,CINOF\n         ST    R1,CINOF\n         IF    (CLC,CINOF(1),GT,=XL1'00')   DON'T GO PAST LO KEY RANGE\n         B     CATEOF\n         ENDIF\n         ENDDO\nCATEOF   EQU   *\n* USE DIFFERENT BUFFER FOR CLUSTER READS\n         MVC   OPERATN,=CL8'MODCB'\n         MODCB RPL=CATRPLA,AREA=RECBUFB\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n         BAL   R10,CLUSTER            PROCESS CLUSTER TABLE\n* RESET TO BUFFER 'A' FOR CATALOG READS\n         MVC   OPERATN,=CL8'MODCB'\n         MODCB RPL=CATRPLA,AREA=RECBUFA\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n         LA    R3,ULEN(R3)        BUMP CATALOG TABLE PTR\n         ENDDO\n         DROP  R2,R3,R7\n* RESET COUNTS\n         XC    ACOUNT,ACOUNT\n         XC    CCOUNT,CCOUNT\n         L     R10,USESAV1\n         BR    R10\nACOUNT   DS    F\nCCOUNT   DS    F\nUSESAV1  DS    F\nHNAME    DC    CL44' '\nCLC1     CLC   0(0,R1),0(R2)\n         EJECT\n* POST ENTRIES TO CLUSTER TABLE\nPOST     DS    0H\n         ST    R10,POSSAV1\n         USING CLSECT,R7\n         USING CLUSTREC,R2\n* BUMP CLUSTER/AIX COUNTS\n         IF    (CLI,CENTYPE,EQ,C'G')\n         LA    R1,1\n         A     R1,ACOUNT\n         ST    R1,ACOUNT           BUMP AIX COUNT\n         ELSE\n         LA    R1,1\n         A     R1,CCOUNT\n         ST    R1,CCOUNT           BUMP CLUSTER COUNT\n         ENDIF\n         MVC   CLNAME,CNAME                FILL IN TABLE ENTRY\n         MVC   CLCINO,CINO\n         ST    R7,CLTABEND                 R7 => CURRENT LAST ENTRY\n         LA    R7,CLLEN(R7)                BUMP TABLE PTR\n         DROP  R2,R7\n         L     R10,POSSAV1\n         BR    R10\nPOSSAV1  DS    F\nCLTABEND DS    F\n         EJECT\n* CLUSTER - RECORD DETAILS OF CLUSTER RECORDS\nCLUSTER  DS    0H\n         ST    R10,CLUSAV1\n         STM   R1,R6,CLUSAV2\n* DON'T PROCESS IF NO CLUSTERS\n         L     R1,ACOUNT\n         A     R1,CCOUNT\n         IF    (LTR,R1,R1,NZ)      IF +VE ENTRIES\n* BUBBLE SORT CLUSTER TABLE BY NAME\n         L     R1,CLTABEND         SET R1 => LAST ENTRY\n         DO    INF                 DO UNTIL SORTED\n         L     R7,CLUSTAB          R7 => CLUSTER TABLE\n         XR    R2,R2               RESET SWAP FLAG\n         DO    INF                 DO WHILE NOT LAST ENTRY\n         DOEXIT (CR,R7,GE,R1)\n         IF    (CLC,0(L'CLNAME,R7),GT,CLLEN(R7))  IF ENTRY N > N + 1\n         MVC   SORTWK(CLLEN),CLLEN(R7)         SWAP THEM\n         MVC   CLLEN(CLLEN,R7),0(R7)\n         MVC   0(CLLEN,R7),SORTWK\n         LA    R2,1                             SET SWAP FLAG\n         ENDIF\n         LA    R7,CLLEN(R7)                     BUMP TABLE PTR\n         ENDDO\n         DOEXIT (LTR,R2,R2,Z)      EXIT IF NO SWAPS\n         S     R1,=AL4(CLLEN)      ELSE DECR. END ADDRESS\n         ENDDO\n         L     R7,CLUSTAB             R7 => CLUSTER TABLE\n         USING CLSECT,R7\n         L     R6,ACOUNT\n         A     R6,CCOUNT\n         DO    FROM=(R6)              DO UNTIL LAST ENTRY\n         MVC   CINO,CLCINO            GET CI NO\n         BAL   R10,RECGET             READ CLUSTER RECORD\n         LA    R3,RECBUFB             R3 => CATALOG RECORD\n         USING CLUSTREC,R3\n* SET OUTPUT RECORD TO NUMERIC '0'\n* (PC DOWNLOAD CLIPS OFF TRAILING BLANKS)\n         MVI   FREC,C'0'\n         MVI   FREC2,C'0'\n         MVC   FREC+1(FREC1LEN-1),FREC\n         MVC   FREC2+1(FREC2LEN-1),FREC2\n* GET CATALOG, CLUSTER NAME\n         MVC   FCATNAME,HNAME             CATALOG NAME\n         MVC   FNAME,CNAME                CLUSTER/AIX NAME\n* CREATION & EXPIRY DATES\n         MVC   FCREATE,=XL5'2020202020'\n         ED    FCREATE,CDSETCRD           CREATION DATE\n         IF    (CLI,FCREATE,EQ,X'20')     IF NO DATE\n         MVC   FCREATE,=CL5'00000'        THEN ZEROS\n         ENDIF\n         MVC   FEXPIRY,=XL5'2020202020'\n         ED    FEXPIRY,CDSETEXD           EXPIRY DATE\n         IF    (CLI,FEXPIRY,EQ,X'20')     IF NO DATE\n         MVC   FEXPIRY,=CL5'00000'        THEN ZEROS\n         ENDIF\n         IF    (CLI,CENTYPE,EQ,C'G')      IF AIX\n         MVI   OBJECT,C'A'                 FLAG IT\n         OI    FLAG1,AIXON                 FLAG IT\n         IF    (TM,CATTR,UPGRADE,O)\n         MVI   FUPGRADE,C'U'\n         ELSE\n         MVI   FUPGRADE,C'N'\n         ENDIF\n         ELSE\n         NI    FLAG1,255-AIXON            RESET AIX FLAG\n         ENDIF\n         IF    (CLI,COWNERID,LT,C'A'),OR,                              +\n               (CLI,COWNERID,GT,C'Z')\n         MVC   FOWNER(8),=CL8'(NULL)'\n         ELSE\n         MVC   FOWNER(8),COWNERID\n         ENDIF\n* POINT TO FIRST GROUP OCCURRENCE IN RECORD\n         XR    R1,R1\n         ICM   R1,B'0001',CGOPNO\n         IF    (LTR,R1,R1,P)      IF ANY GO'S\n         LA    R8,CGOPNO+1        POINT TO START OF GOP'S\n         DO    FROM=(R1)          DO UNTIL END OF GOP'S\n         LA    R8,GOPLEN(R8)      POINT TO NEXT GOP\n         ENDDO\n         USING ASSOC,R8\n* PROCESS DATA (& INDEX) GROUP OCCURRENCES\n         MVC   CINO,ACINOD\n         MVC   INDCI,ACINOI\n         BAL   R10,DATA\n         IF    (TM,FLAG1,INDX,O)\n         MVC   CINO,INDCI\n         BAL   R10,INDEX\n         ELSE                                   IF NOT INDEX\n         MVI   FINAME,C' '\n         MVC   FINAME+1(L'FINAME-1),FINAME      INDEX NAME IS BLANK\n         ENDIF\n         ENDIF                     ENDIF - +VE GO'S\n         LA    R7,CLLEN(R7)        BUMP CLUSTER TABLE PTR\n         DOEXIT (CLI,0(R7),EQ,X'00')   EXIT IF LAST ENTRY PROCESSED\n* WRITE CLUSTER/AIX RECORD TO CLUSTER RECORDS FILE\n         STM   R2,R3,WSAVE\n         LA    R2,FREC+FRECLEN-1   POINT TO END OF RECORD\n         LA    R3,FRECLEN\n         DO    FROM=(R3)\n         DOEXIT (CLI,0(R2),NE,C' ')  DOEXIT AT 1ST NON-BLANK\n         IF    (CLI,0(R2),EQ,C' ')   IF BLANK\n         MVI   0(R2),C'0'            REPLACE BY C'0'\n         ENDIF\n         BCTR  R2,0                  DECR PTR\n         ENDDO\n         LM    R2,R3,WSAVE\n         MVC   RDATE,SYSDATE       SAVE DATE\n         MVC   OPERATN,=CL8'PUT'\n         PUT   RPL=CRPL            WRITE TO CLUSTER RECORD FILE\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n         LA    R1,1                BUMP OUTPUT COUNT\n         A     R1,RCOUNT\n         ST    R1,RCOUNT\n         ENDDO\n         ENDIF                     ENDIF - ANY CLUSTERS ?\n         DROP  R3,R7,R8\n         LM    R1,R6,CLUSAV2\n         L     R10,CLUSAV1\n         BR    R10\nCLUSAV1  DS    F\nCLUSAV2  DS    6F\nWSAVE    DS    2F\nRCOUNT   DS    F                   OUTPUT RECORD COUNT\nSORTWK   DS    CL47                SORT WORK FIELD\nINDCI    DS    XL3\n         EJECT\n* AMDPOS - POINT TO AMSDB WITHIN DATA OR INDEX RECORD\n* INPUT  - R4 => RECORD\n* OUTPUT - R3 => AMSDB\nAMDPOS   DS    0H\n         ST    R10,AMDSAV1\n         USING DATREC,R4\n         XR    R1,R1\n         ICM   R1,B'0001',GOPNO\n         IF    (LTR,R1,R1,P)      IF ANY GO'S\n         LA    R3,GOPNO+1         POINT TO START OF GOP'S\n         USING GOPREC,R3\n         LR    R10,R1\n         DO    FROM=(R10)         DO UNTIL END OF GOP'S\n         LA    R3,GOPLEN(R3)      POINT TO NEXT GOP\n         ENDDO\n         ELSE\n         MVC   PRTBUF+1(32),=CL32'** NO GRP OCCURRENCES FOR RECORD'\n         BAL   R10,PRINT\n         ENDIF\n         LA    R3,2(R3)           POINT PAST GO CONTROL BYTES\n* VALIDATE AMSDB\n         DROP  R3\n         USING AMSDB,R3\n         IF    (TM,AMSDBID,AMID,Z)\n         MVC   PRTBUF+1(19),=CL19'** INVALID AMSDB **'\n         BAL   R10,PRINT\n         B     BADRET\n         ENDIF\n         DROP  R3,R4\n         L     R10,AMDSAV1\n         BR    R10\nAMDSAV1  DS    F\n         EJECT\n* INDEX  - RECORD DETAILS OF CLUSTER'S INDEX RECORD\n* INPUT  - CINO OF INDEX RECORD\nINDEX    DS    0H\n         ST    R10,INDSAV1\n         BAL   R10,RECGET          READ GO RECORD (RETURN ADDR IN R1)\n         LA    R4,RECBUFB\n         USING DATREC,R4\n         MVC   FINAME,NAME         GET INDEX NAME\n* POINT TO AMSDB GROUP OCCURRENCE IN INDEX RECORD\n         BAL   R10,AMDPOS          R3 => AMSDB\n         USING AMSDB,R3\n         ICM   R1,B'1111',AMDCINV      CISZ\n         BAL   R10,CONVERTF\n         MVC   FICISZ(L'FICISZ),WORK15+L'WORK15-L'FICISZ\n         IF    (TM,FLAG1,NOALLOC,Z)               IF NOT NO-ALLOC\n         ICM   R1,B'1111',AMDCINV                     GET INDEX CISZ\n         BAL   R10,CONVERTF\n         MVC   FICISZ(L'FICISZ),WORK15+L'WORK15-L'FICISZ\n         ENDIF\n         L     R10,INDSAV1\n         BR    R10\nINDSAV1  DS    F\n         EJECT\n* DATA   - RECORD DETAILS OF CLUSTER'S DATA RECORD\n* INPUT  - CINO OF DATA RECORD\nDATA     DS    0H\n         ST    R10,DATSAV1\n         STM   R2,R7,DATSAV2\n         BAL   R10,RECGET          READ GO RECORD (RETURN ADDR IN R1)\n         LA    R4,RECBUFB\n         USING DATREC,R4\n* POINT TO AMSDB GROUP OCCURRENCE IN DATA RECORD\n         BAL   R10,AMDPOS                R3 => AMSDB\n         USING AMSDB,R3\n* FLAG IF FILE OPEN\n         IF    (TM,OPENIND,OPEN,O)\n         OI    FLAG1,OPEN1\n         ELSE\n         NI    FLAG1,255-OPEN1\n         ENDIF\n         MVC   FDNAME,NAME               DATA NAME\n* GET ATTRIBUTES\n         IF    (TM,AMDATTR1,AMDDST,O)    IF INDEXED\n         OI    FLAG1,INDX                FLAG IT\n         IF    (TM,FLAG1,AIXON,Z)        IF NOT AIX\n         MVI   OBJECT,C'K'                FLAG IT\n         ENDIF\n         XR    R1,R1\n         ICM   R1,B'0011',AMDKEYLN       KEYLENGTH\n         BAL   R10,CONVERTF\n         MVC   FKEYLEN(L'FKEYLEN),WORK15+L'WORK15-L'FKEYLEN\n         XR    R1,R1\n         ICM   R1,B'0011',AMDRKP         KEY OFFSET\n         BAL   R10,CONVERTF\n         MVC   FRKP(L'FRKP),WORK15+L'WORK15-L'FRKP\n         IF    (TM,AMDATTR1,AMDSDT,O)    IMBED\n         MVI   FIMBED,C'I'\n         ELSE\n         MVI   FIMBED,C'N'\n         ENDIF\n         IF    (TM,AMDATTR1,AMDREPL,O)\n         MVI   FREPL,C'R'\n         ELSE\n         MVI   FREPL,C'N'\n         ENDIF\n         ELSE                            ELSE - NOT INDEXED\n         NI    FLAG1,255-INDX            FLAG IT\n         IF    (TM,AMDATTR1,AMDRRDS,O)\n         MVI   OBJECT,C'R'                RRDS\n         ELSE\n         IF    (TM,AMDATTR1,AMDNCAFT,O)\n         MVI   OBJECT,C'S'                ESDS-SAM\n         ELSE\n         MVI   OBJECT,C'E'                ESDS\n         ENDIF\n         ENDIF\n         ENDIF\n         IF    (TM,AMDATTR1,AMDSPAN,O)\n         MVI   FSPANNED,C'S'\n         ELSE\n         MVI   FSPANNED,C'N'\n         ENDIF\n         IF    (TM,ATTR1,SPEED,O)\n         MVI   FSPEED,C'S'\n         ELSE\n         MVI   FSPEED,C'R'\n         ENDIF\n         IF    (TM,ATTR2,NOALLOC,O)\n         MVI   FALLOC,C'N'\n         OI    FLAG1,NOALLOC                      FLAG TYPE\n         ELSE\n         NI    FLAG1,255-NOALLOC\n         IF    (TM,ATTR1,UNIQUE,O)\n         MVI   FUNIQUE,C'U'\n         ELSE\n         MVI   FUNIQUE,C'N'\n         ENDIF\n         ENDIF\n         IF    (TM,ATTR1,REUSE,O)\n         MVI   FREUSE,C'R'\n         ELSE\n         MVI   FREUSE,C'N'\n         ENDIF\n         IF    (TM,ATTR1,ERASE,O)\n         MVI   FERASE,C'E'\n         ELSE\n         MVI   FERASE,C'N'\n         ENDIF\n         IF    (TM,AMDATTR1,AMDWCK,O)\n         MVI   FWRT,C'W'\n         ELSE\n         MVI   FWRT,C'N'\n         ENDIF\n         IF    (TM,ATTR2,SHR4,O)            SHARE OPTIONS\n         MVI   FSHARE,C'1'\n         ELSE\n         IF    (TM,ATTR2,SHR2,O)\n         MVI   FSHARE,C'2'\n         ELSE\n         IF    (TM,ATTR2,SHR3,O)\n         MVI   FSHARE,C'3'\n         ELSE\n         MVI   FSHARE,C'4'\n         ENDIF\n         ENDIF\n         ENDIF\n         IF    (TM,FLAG1,AIXON,O)          IF AIX\n         IF    (TM,AMDATTR3,UNIQUE,O)      IF UNIQUE\n         MVI   FUNIQUE,C'U'\n         ELSE\n         MVI   FUNIQUE,C'N'\n         ENDIF\n         ENDIF\n         IF    (TM,SPACOPTN,CYLS,O)\n         MVI   FALLOC,C'C'                 ALLOC IN CYLS\n         ELSE\n         IF    (TM,SPACOPTN,TRACKS,O)\n         MVI   FALLOC,C'T'                 ALLOC IN TRKS\n         ELSE\n         MVI   FALLOC,C'B'                 ALLOC IN BLKS\n         ENDIF\n         ENDIF\n         XR    R1,R1\n         ICM   R1,B'0111',PRIMSPAC           PRIMARY ALLOCATION\n         BAL   R10,CONVERTF\n         MVC   FPRIME(L'FPRIME),WORK15+L'WORK15-L'FPRIME\n         LA    R5,20(R5)\n         XR    R1,R1\n         ICM   R1,B'0111',SCONSPAC           SECONDARY ALLOCATION\n         BAL   R10,CONVERTF\n         MVC   FSECOND(L'FSECOND),WORK15+L'WORK15-L'FSECOND\n         ICM   R1,B'1111',LRECL                  AVERAGE RECSZ\n         BAL   R10,CONVERTF\n         MVC   FAVERAGE,WORK15\n         MVC   FAVERAGE(L'FAVERAGE),WORK15+L'WORK15-L'FAVERAGE\n         ICM   R1,B'1111',AMDLRECL               MAXIMUM RECSZ\n         BAL   R10,CONVERTF\n         MVC   FMAX(L'FMAX),WORK15+L'WORK15-L'FMAX\n         IF    (CLC,LRECL,EQ,AMDLRECL)           FLAG IF FIXED LENGTH\n         OI    FLAG1,FIXED\n         MVI   FFIXED,C'F'\n         ELSE\n         MVI   FFIXED,C'V'\n         NI    FLAG1,255-FIXED\n         ENDIF\n         ICM   R1,B'1111',AMDCINV                    DATA CISZ\n         BAL   R10,CONVERTF\n         MVC   FDCISZ(L'FDCISZ),WORK15+L'WORK15-L'FDCISZ\n         IF    (TM,FLAG1,INDX,O)                 IF INDEXED\n         XR    R1,R1\n         ICM   R1,B'0001',AMDPCTCI               % FREE CI\n         BAL   R10,CONVERTF\n         MVC   FPCTCI(L'FPCTCI),WORK15+L'WORK15-L'FPCTCI\n         XR    R1,R1\n         ICM   R1,B'0001',AMDPCTCA               % FREE CA\n         BAL   R10,CONVERTF\n         MVC   FPCTCA(L'FPCTCA),WORK15+L'WORK15-L'FPCTCA\n         XR    R1,R1\n         ICM   R1,B'0011',AMDNEXT                NO. OF EXTENTS\n         BAL   R10,CONVERTF\n         MVC   FEXT(L'FEXT),WORK15+L'WORK15-L'FEXT\n         L     R1,AMDNLR                          NO. OF LOGICAL RECS\n         BAL   R10,CONVERTF\n         MVC   FNLR(L'FNLR),WORK15+L'WORK15-L'FNLR\n         L     R1,AMDDELR                         NO. OF DELETES\n         BAL   R10,CONVERTF\n         MVC   FDELR(L'FDELR),WORK15+L'WORK15-L'FDELR\n         L     R1,AMDIREC                         NO. OF INSERTS\n         BAL   R10,CONVERTF\n         MVC   FIREC(L'FIREC),WORK15+L'WORK15-L'FIREC\n         L     R1,AMDUPR                          NO. OF UPDATES\n         BAL   R10,CONVERTF\n         MVC   FUPDR(L'FUPDR),WORK15+L'WORK15-L'FUPDR\n         L     R1,AMDRETR                         NO. OF RETRIEVES\n         BAL   R10,CONVERTF\n         MVC   FRETR(L'FRETR),WORK15+L'WORK15-L'RETR\n         L     R1,AMDASPA                         BYTES FREE SPACE\n         BAL   R10,CONVERTF\n         MVC   FASPA(L'FASPA),WORK15+L'WORK15-L'FASPA\n         L     R1,AMDEXCP                         NO. OF EXCPS\n         BAL   R10,CONVERTF\n         MVC   FEXCP(L'FEXCP),WORK15+L'WORK15-L'FEXCP\n         ENDIF                                    ENDIF - KSDS ?\n         DROP  R4\n         LM    R2,R7,DATSAV2\n         L     R10,DATSAV1\n         BR    R10\nDATSAV1  DS    F\nDATSAV2  DS    6F\nFLAG1    DC    XL1'00'              FLAG VALUES\nFIXED    EQU   X'80'                FIXED LENGTH\nOPEN1    EQU   X'40'                OPEN\nAIXON    EQU   X'20'                AIX\n*NOALLOC EQU   X'08'                (NOALLOC)\nINDX     EQU   X'04'                INDEXED\n         EJECT\n* PRINT - PRINT RTN, CLEARS BUFFER AFTER PRINT\n* OUTPUT - R5 => PRTBUF+1\nPRINT    DS    0H\n         ST    R10,PRISAV1\n         ST    R1,PRISAV2\n         PUT   PRINTFL\n         MVI   PRTBUF,NEWLINE                 RESET CTL CHAR\n         MVC   PRTBUF+1(PRTLEN-1),PRTBUF      CLEAR PRINT BUFFER\n         LA    R5,PRTBUF+1         R5 => START OF PRINT BUFFER\n         L     R1,PRISAV2\n         L     R10,PRISAV1\n         BR    R10                 RETURN\n         EJECT\n         BR    R10                 RETURN\nPRISAV1  DS    F\nPRISAV2  DS    F\nPRTBUF   DC    CL132' '              PRINT BUFFER\nPRTLEN   EQU   *-PRTBUF              PRINT BUFFER LENGTH\nNEWLINE  EQU   C' '                  NEW LINE PRT CTL CHAR\nNEWLINE2 EQU   C'0'                  NEW LINE PRT CTL CHAR (SPACE 2)\nNEWPAGE  EQU   C'1'                  PRINT CTL CHAR FOR NEW PAGE\n* RECGET - READ CLUSTER'S DATA & CI RECORDS\n* INPUT  - CINO    - CI NO.\n* OUTPUT - RECBUFB (RECORD BUFFER)\nRECGET   DS    0H\n         ST    R10,RECSAV1\n         MVC   OPERATN,=CL8'GET'\n         GET   RPL=CATRPLA         READ A RECORD\n* IF MISSING GROUP OCCURENCE, MUST BE SERIOUS PROBLEM WITH CLUSTER'S\n* CATALOG RECORD. FLAG AND BAIL OUT.\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         L     R1,CINOF\n     MVC  PRTBUF+1(38),=CL38'MISSING GROUP OCCURRENCE AT CI NO (DEC)'\n         LA    R5,PRTBUF+1+38\n         BAL   R10,CONVERTP\n         BAL   R10,PRINT\n         B     BADRET              BAIL OUT\n         ENDIF\n         L     R10,RECSAV1\n         BR    R10\nRECSAV1  DS    F\n         EJECT\n* SHOWCAT - GET ACB ADDRESS USING FILE NAME\n* INPUT  - R2 = FILE NAME\n* OUTPUT - R2 = ACB ADDRESS\nSHOWCAT  DS    0H\n         ST    R10,SHOSAV1\n         LA    R6,SHOWAREA         R6  => VSAM WORKAREA\n         USING WORKAREA,R6\n         MVC   AREALEN,=AL2(SHOWLEN)  SET LENGTH OF WORK AREA\n         MVC   OPERATN,=CL8'SHOWCAT'\n         SHOWCAT NAME=(2),CATDSN=(2),AREA=(6)\n         IF    (LTR,R15,R15,NZ)    TEST VSAM RETCODE\n         B     BADRET              HANDLE BAD RETCODE\n         ENDIF\n         L     R2,CATACB           GET ACB ADDRESS\n         DROP  R6\n         L     R10,SHOSAV1\n         BR    R10\nSHOSAV1  DS    F\n         EJECT\n* HEADER - PRINT PAGE HEADER\nHEADER   DS    0H                    PRINT HEADING\n         ST    R10,HEASAV1\n         ST    R5,HEASAV2\n         ST    R1,HEASAV3\n         MVI   PRTBUF,NEWPAGE\n         MVC   PRTBUF+48(27),=CL27'*** RECORD LISTCAT INFO ***'\n         MVC   PRTBUF+80(8),SYSDATE\n         MVC   PRTBUF+122(4),=CL4'PAGE'\n         LA    R5,PRTBUF+127\n         LH    R1,PAGENO\n         BAL   R10,CONVERTP\n         BAL   R10,PRINT\n         MVC   PRTBUF+60(L'HNAME),HNAME\n         BAL   R10,PRINT\n         LA    R1,1                  BUMP PAGE COUNT\n         AH    R1,PAGENO\n         STH   R1,PAGENO\n         L     R5,HEASAV2\n         L     R1,HEASAV3\n         L     R10,HEASAV1\n         BR    R10\nHEASAV1  DS    F\nHEASAV2  DS    F\nHEASAV3  DS    F\nPAGENO   DC    H'1'\nSYSDATE  DC    CL8' '                SYSTEM DATE\n         EJECT\n* BADRET - TEST VSAM RETCODE\n* INPUT - R15\nBADRET   DS    0H\n* SAVE RETCODE, SET UP VSAM SAVE AREA FIELD\n         ST    R15,SAVER15         SAVE R15\n         BAL   R10,PRINT           SPACE 1\n* PRINT HEADING\n         MVC   0(16,R5),=CL16'** VSAM ERROR **'\n         MVC   16+4(8,R5),OPERATN   IDENTIFY VSAM OPERATION\n         BAL   R10,PRINT           ERROR MESSAGE HEADER\n* PRINT R15 VALUE\n         L     R1,SAVER15          GET R15 VALUE\n         MVC   0(16,R5),=CL16'R15 (DECIMAL) = '\n         LA    R5,16(R5)\n         BAL   R10,CONVERTP\n         BAL   R10,PRINT           PRINT R15 VALUE\n* IF OPEN ERROR FOR CLUSTER RECORD FILE, GET ERROR CODE\n         IF    (CLC,OPERATN,EQ,=CL8'OPEN')\n         MVC   0(17,R5),=CL17'OPEN ERROR CODE ='\n         LA    R5,18(R5)\n         SHOWCB ACB=CACB,AREA=SHOWAREA,LENGTH=4,FIELDS=ERROR\n         L     R1,SHOWAREA\n         BAL   R10,CONVERTP\n         BAL   R10,PRINT           PRINT ERROR CODE\n         ENDIF\n* IF SHOWCAT, SHOW NAME\n         IF    (CLC,OPERATN,EQ,=CL8'SHOWCAT')\n         MVC   5(44,R5),0(R2)\n         BAL   R10,PRINT\n         ELSE\n* IF 'GET', GET FEEDBACK CODE\n         IF    (CLC,OPERATN,EQ,=CL8'GET')\n         SHOWCB RPL=CATRPLA,AREA=SHOWAREA,LENGTH=72,FIELDS=FDBK\n         L     R1,SHOWAREA\n         MVC   5(24,R5),=CL24'VSAM ERROR CODE (DEC) = '\n         LA    R5,29(R5)\n         BAL   R10,CONVERTP\n         BAL   R10,PRINT           PRINT ERROR CODE\n         ELSE\n* IF SHOWCB, GET ERROR CODE IN R0\n         IF    (CLC,OPERATN,EQ,=CL8'SHOWCB')\n         LR    R1,R0\n         MVC   5(24,R5),=CL24'VSAM ERROR CODE (DEC) = '\n         LA    R5,29(R5)\n         BAL   R10,CONVERTP\n         BAL   R10,PRINT           PRINT ERROR CODE\n         ENDIF\n         ENDIF\n         ENDIF\n* EXIT\n         MVC   PROGRET(1),SAVER15+3   SET PROGRAM RETCODE\n         B     RECDEXIT               END IT ALL\nSAVER15  DS    F\nOPERATN  DC    CL8' '                VSAM OPERATION BEING PERFORMED\nPROGRET  DC    XL1'00'               PROGRAM RETCODE\nRETCODE  DC    F'0'                  VSAM RETCODE\nVSAMSAVE DC    18F'0'                VSAM SAVE AREA FOR SHOWCB\n         EJECT\n* CONVERTF - CONVERT BINARY TO PRINTABLE DECIMAL NO.\n*            FOR MOVE TO CLUSTER FILE BUFFER\n* INPUT  - R1\n* OUTPUT - WORK15 (15 BYTES)\nCONVERTF DS    0H\n         ST    R10,FSAV1             SAVE RETURN ADDRESS\n         STM   R2,R3,FSAV2\n         XC    WORKD,WORKD         CLEAR WORK FIELD\n         CVD   R1,WORKD            PUT INTO DW FIELD\n         MVC   WORK15,EDIT2        PUT IN EDIT PATTERN\n         ED    WORK15,WORKD        EDIT RESULT\n         LA    R2,WORK15\n         LA    R3,L'WORK15\n         DO    FROM=(R3)\n         IF    (CLI,0(R2),EQ,X'20')\n         MVI   0(R2),C'0'\n         ENDIF\n         LA    R2,1(R2)\n         ENDDO\n         L     R10,FSAV1\n         LM    R2,R3,FSAV2\n         BR    R10\nFSAV1    DS    F\nFSAV2    DS    2F\nEDIT2    DC    XL15'202020202020202020202020202020'   EDIT PATTERN\n         EJECT\n* CONVERTP - CONVERT BINARY TO PRINTABLE DECIMAL NO. AND\n*            MOVE TO PRINT BUFFER, AND PLUG IN BRACKETS.\n* INPUT  - R1 (NUMBER TO PRINT)\n*        - R5    (ADDRESS OF PRINT BUFFER)\n* OUTPUT - WORK15 (15 BYTES)\n*        - R5    (ADDRESS OF PRINT BUFFER JUST PAST CLOSING BRACKET)\nCONVERTP DS    0H\n         ST    R10,CONSAV1         SAVE RETURN ADDRESS\n         ST    R2,CONSAV2\n         XC    WORKD,WORKD         CLEAR WORK FIELD\n         CVD   R1,WORKD            PUT INTO DW FIELD\n         MVC   WORK15,EDIT1        PUT IN EDIT PATTERN\n         LA    R1,WORK15+L'WORK15-1   AT LEAST PRINT LAST 0\n         EDMK  WORK15,WORKD        EDIT RESULT INTO WORK15\n         LA    R2,WORK15+L'WORK15\n         SR    R2,R1               R2 = LENGTH\n         BCTR  R2,0                ADJUST FOR EXECUTE\n         IF    (LTR,R2,R2,M)       MUST BE AT LEAST 0\n         XR    R2,R2\n         ENDIF\n         MVI   0(R5),C'('          PLUG IN OPENING BRACKET\n         LA    R5,1(R5)            POINT PAST BRACKET\n         EX    R2,MVC1             MOVE RESULT TO PRINT BUFFER\n         AR    R5,R2               POINT PAST PRINT\n         MVI   1(R5),C')'          PLUG IN FINAL BRACKET\n         LA    R5,2(R5)\n         L     R2,CONSAV2\n         L     R10,CONSAV1         RESTORE RETURN ADDRESS\n         BR    R10                 RETURN\nCONSAV1  DS    F\nCONSAV2  DS    F\nWORK15   DC    CL15' '\nWORKD    DC    D'0'\nEDIT1    DC    XL15'202020202020202020202020202120'   EDIT PATTERN\nMVC1     MVC   0(0,R5),0(R1)\n         EJECT\nDATAAREA DS    0F\n         LTORG\n         EJECT\n* REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n* DTF'S, ACB'S ETC.\nPRINTFL  DTFPR DEVADDR=SYSLST,     PRINT FILE DTF                      +\n               DEVICE=1403,                                            +\n               BLKSIZE=132,                                            +\n               CTLCHR=ASA,                                             +\n               IOAREA1=PRTBUF,                                         +\n               RECFORM=FIXUNB\n         DS    0F\nRECBUFA  DS    CL505                    RECORD BUFFER 'A'\nRECLEN   EQU   *-RECBUFA\n         DS    0F\nRECBUFB  DS    CL505                    RECORD BUFFER 'B'\n* CATALOG SEQ READ RPL (ACB ADDRESS IS PLUGGED IN BY THE PROGRAM)\nCINOF    DC    F'0'\n         ORG   CINOF+1\nCINO     DS    XL3\nCATRPLA  RPL   AREA=RECBUFA,                                           +\n               ARG=CINOF,                                              +\n               AREALEN=505,                                            +\n               OPTCD=(ADR,SEQ,NUP,LOC),                                +\n               RECLEN=505               MAX. RECLEN\n* CLUSTER RECORD FILE ACB\n         DS    0F\nCACB     ACB   DDNAME=CFILE,MACRF=(ADR,SEQ,OUT)\nCRPL     RPL   ACB=CACB,                                               +\n               AREA=FREC,               OUTPUT BUFFER ADDRESS          +\n               AREALEN=460,                                            +\n               OPTCD=(ADR,SEQ,MVE),                                    +\n               RECLEN=460\n         DS    0F\nSHOWAREA DS    CL72                    SHOWCAT WORK AREA\nSHOWLEN  EQU   72\nCATTAB   DC    AL4(0)                  ADDR OF USER CATALOG TABLE\nMAXCATS  EQU   100\nCSIZE    DC    F'4400'                 TABLE SIZE = MAXCATS X 44\nCLUSTAB  DC    AL4(0)                  ADDR OF CLUSTER TABLE\nMAXCLUST EQU   1000                    MAXIMUM CLUSTERS ALLOWED\nCLSIZE   DC    F'47000'                TABLE SIZE = MAXCLUST X 47\n        EJECT\n* CLUSTER INFO FILE RECORD\n* NOTE THAT THE CLUSTER INFO FILE RECORD IS ALL IN CHARACTER FORMAT\n* TO SIMPLIFY CODING FOR SQL LOAD\nFREC     DS    0F\nFCATNAME DS    CL44                    CATALOG NAME\nFNAME    DS    CL44                    CLUSTER/AIX NAME\nRDATE    DS    CL8                     DATE\nFDNAME   DS    CL44                    CLUSTER/AIX DATA NAME\nFINAME   DS    CL44                    CLUSTER/AIX INDEX NAME\nFREC1LEN EQU   *-FREC                  LENGTH OF RECORD PART 1\nFREC2    EQU   *\nFOWNER   DS    CL8                     OWNER\nFCREATE  DS    CL5                     CREATION DATE (YDD)\nFEXPIRY  DS    CL5                     EXPIRY DATE (YDD)\nFSPEED   DS    CL1                     'S' OR 'R'\nFUNIQUE  DS    CL1                     'U' OR 'N' UNIQUE KEYS (IF AIX)\nFREUSE   DS    CL1                     'R' OR 'N'\nFERASE   DS    CL1                     'E' OR 'N'\nOBJECT   DS    CL1                     'K' (KSDS) 'R' (RRDS) 'E' (ESDS)\n****                                   'S' (SAM-ESDS) OR 'A' (AIX)\nFSHARE   DS    CL1                     SHR(1 OR 2 OR 3 OR 4)\nFUPGRADE DS    CL1                     'U' OR 'N' UPGRADE (IF AIX)\nFALLOC   DS    CL1                     ALLOC TYPE 'C' (CYLS) 'T' TRKS\nFWRT     DS    CL1                     'W' WRITECHECK ELSE 'N'\nFIMBED   DS    CL1                     IMBED 'I' ELSE 'N'\nFSPANNED DS    CL1                     SPANNED 'S' ELSE 'N'\nFREPL    DS    CL1                     REPLICATE 'R' ELSE 'N'\nFFIXED   DS    CL1                     FIXED LENGTH 'F' ELSE 'V'\n* NUMERIC FIELDS\nFDCISZ   DS    CL5                     DATA CISZ\nFICISZ   DS    CL5                     INDEX CISZ\nFPRIME   DS    CL8                     PRIMARY ALLOCATION\nFSECOND  DS    CL8                     SECONDARY ALLOCATION\nFAVERAGE DS    CL5                     AVERAGE RECORD LENGTH\nFMAX     DS    CL5                     AVERAGE RECORD LENGTH\nFRKP     DS    CL5                     RELATIVE KEY POSITION\nFKEYLEN  DS    CL3                     KEY LENGTH\nFEXT     DS    CL3                     NO. OF EXTENTS\nFNLR     DS    CL8                     NO. OF LOGICAL RECORDS\nFDELR    DS    CL8                     NO. OF DELETES\nFIREC    DS    CL8                     NO. OF INSERTS\nFUPR     DS    CL8                     NO. OF UPDATES\nFRETR    DS    CL8                     MO. OF RECORDS RETRIEVED\nFASPA    DS    CL8                     NO. OF BYTES FREE SPACE\nFEXCP    DS    CL8                     NO. EXCP'S\nFPCTCA   DS    CL3                     CA % FREE\nFPCTCI   DS    CL3                     CI % FREE\nFRECLEN  EQU   *-FREC                  TOTAL LENGTH OF RECORD\nFREC2LEN EQU   *-FREC2                 LENGTH OF RECORDPART 2\n* USER CATALOG TABLE DSECT\nCATSECT  DSECT\nUACB     DS    F                       ACB\nUNAME    DS    CL44                    USERCATALOG NAME\nULEN     EQU   *-UACB                  ENTRY LENGTH\n* CLUSTER TABLE DSECT\nCLSECT   DSECT\nCLNAME   DS    CL44                    CLUSTER/AIX NAME\nCLCINO   DS    CL3                     CI NO OF CLUSTER RECORD\nCLLEN    EQU   *-CLNAME                ENTRY LENGTH\nWORKAREA DSECT\nAREALEN  DS    AL2                     LENGTH OF WORKAREA\nWORKLEN  DS    AL2                     RETURNED LENGTH OF WORKAREA\nCATACB   DS    F                       ADDRESS OF MASTCAT ACB\nCTYPE    DS    CL1                     TYPE ( = 'C' FOR MASTCAT)\n         DS    XL1                     RESERVED\nNOPAIRS  DS    AL2                     NO. OF PAIRS OF FIELDS\nFTYPE    DS    CL1                     FIRST COMPONENT TYPE\nCINVNO   DS    XL3                     FIRST CI NO.\n         EJECT\n* CLUSTER RECORD DSECT\nCLUSTREC DSECT\nCKEY     DS    CL44                    KEY\n         ORG   CKEY\n         DS    XL1                     BINARY ZEROS\nCENTIDNO DS    XL3                     CI NO OF ENTRY\nCRELIND  DS    XL1                     RELEASE INDICATOR\nCCRAVOL  DS    CL6                     CRA VOLSER\nCCRAIDNO DS    XL3                     CRA CI NO\nCCRADEVT DS    CL4                     CRA DEVICE TYPE\n         DS    XL26                    BINARY ZEROS\nCENTYPE  DS    CL1                     'C' FOR CLUSTER\nCRRECLEN DS    XL2                     RECORD LENGTH\n         DS    XL1                     ALWAYS ZERO\nCFIXLEN  DS    XL1                     LENGTH OF FIXED LENGTH FIELDS\nCNAME    DS    CL44                    ENTRY NAME\nCOWNERID DS    CL8                     OWNER\nCDSETCRD DS    PL3                     CREATION DATE (YDD)\nCDSETEXD DS    PL3                     EXPIRY DATE (YDD)\nCATTR    DS    XL1                     AIX ATTRIBUTE FLAG IF AIX\nUPGRADE  EQU   X'80'                   UPGRADE (AIX)\nAIXGOPNO DS    XL1                     NO. OF GRP OCCURENCE PTRS IF AIX\n         ORG   AIXGOPNO\nCEXTPTR  DS    XL5                     POINTER TO EXTENSION RECORD\n**                                     (ZERO IF NONE)\nCGOPNO   DS    XL1                     NO. OF GROUP OCCURRENCE PTRS\n         DS    0C                      SEE GOPREC DSECT\n        EJECT\n* DATA/INDEX RECORD DSECT\nDATREC   DSECT\nKEY      DS    CL44                    KEY\n         ORG   KEY\n         DS    XL1                     BINARY ZEROS\nENTIDNO  DS    XL3                     CI NO OF ENTRY\nRELIND   DS    XL1                     RELEASE INDICATOR\nCRAVOL   DS    CL6                     CRA VOLSER\nCRAIDNO  DS    XL3                     CRA CI NO\nCRADEVT  DS    CL4                     CRA DEVICE TYPE\n         DS    XL26                    BINARY ZEROS\nENTYPE   DS    CL1                     'D' FOR DATA, 'I' FOR INDEX\nRRECLEN  DS    XL2                     RECORD LENGTH\n         DS    XL1                     ALWAYS ZERO\nFIXLEN   DS    XL1                     LENGTH OF FIXED LENGTH FIELDS\nNAME     DS    CL44                    ENTRY NAME\nOWNERID  DS    CL8                     OWNER\nDSETCRDT DS    PL3                     CREATION DATE (YDD)\nDSETEXDT DS    PL3                     EXPIRY DATE (YDD)\nATTR1    DS    XL1                     ATTRIBUTES\nSPEED    EQU   X'80'   1... ....       SPEED\nUNIQUE   EQU   X'40'   .1.. ....       UNIQUE\nREUSE    EQU   X'20'   ..1. ....       REUSE\nERASE    EQU   X'10'   ...1 ....       ERASE\nRECOVER  EQU   X'08'   .... 1...       RECOVERABLE CATALOG\nNOUPDATE EQU   X'04'   .... .1..       UPDATE INHIBITED\nEXPIND   EQU   X'02'   .... ..1.       TEMPORARILY EXPORTED\n***                    .... ...X       RESERVED FOR OS/VSAM\nATTR2    DS    XL1                     ATTRIBUTES (DATASHARING)\n**                     00XX XXXX       SHR(1)\nSHR2     EQU   X'40'   01XX XXXX       SHR(2)\nSHR3     EQU   X'80'   10XX XXXX       SHR(3)\nSHR4     EQU   X'C0'   11XX XXXX       SHR(4)\nNOALLOC  EQU   X'08'   .... 1...       NO-ALLOCATION CLUSTER\nNOUSE    EQU   X'01'   .... ...1       DATASET NOT USABLE\n**                     .... .XX.       RESERVED\nOPENIND  DS    XL1                     OPEN FLAG\nOPEN     EQU   X'80'                   DATA SET OPEN FOR OUTPUT\nBUFSIZE  DS    XL4                     MINIMUM BUFFERSIZE\nPRIMSPAC DS    XL3                     PRIMARY ALLOCATION\nSCONSPAC DS    XL3                     SECONDARY ALLOCATION\nSPACOPTN DS    XL1                     SPACE OPTIONS FLAGS\nTRACKS   EQU   X'80'   10XX XXXX       TRACKS\nCYLS     EQU   X'C0'   11XX XXXX       CYLINDERS\nSECPRIM  EQU   X'20'   ...0 0000       SECONDARY SPACE CLASS = PRIMARY\nSEC0     EQU   X'10'   ...1 0000       SECONDARY IS CLASS 0\nCLASS0   EQU   X'00'   XXXX X000       CLASS 0 SPACE\nCLASS1   EQU   X'01'   XXXX X001       CLASS 1 SPACE\nCLASS2   EQU   X'02'   XXXX X010       CLASS 2 SPACE\nCLASS3   EQU   X'03'   XXXX X011       CLASS 3 SPACE\nCLASS4   EQU   X'04'   XXXX X100       CLASS 4 SPACE\nCLASS5   EQU   X'05'   XXXX X101       CLASS 5 SPACE\nCLASS6   EQU   X'06'   XXXX X110       CLASS 6 SPACE\nCLASS7   EQU   X'07'   XXXX X111       CLASS 7 SPACE\nHURBADS  DS    CL4                     HIGH USED RBA\nHARBADS  DS    CL4                     HIGH ALLOC RBA\nLRECL    DS    CL4                     LRECL FOR DATA, X'FF'S FOR IDX\nUSERINFO DS    CL2                     USER INFO FOR ISAM INTERFACE\nEXCPEXIT DS    CL8                     NAME OF EXCEPTION EXIT\nEXTPTR   DS    XL5                     POINTER TO EXTENSION RECORD\n**                                     (ZERO IF NONE)\nGOPNO    DS    XL1                     NO. OF GROUP OCCURRENCE PTRS\n         DS    0C                      SEE GOPREC DSECT\n        EJECT\n* AMSDB - ACCESS METHOD DATA STATS BLOCK\nAMSDB    DSECT\nAMSDBID  DS    XL1                     IDENTIFIER\nAMID     EQU   X'60'\nAMDATTR1 DS    XL1                     ATTRIBUTES\nAMDDST   EQU   X'80'   1... ....       KSDS\nAMDWCK   EQU   X'40'   .1.. ....       WRITECHECK\nAMDSDT   EQU   X'20'   ..1. ....       IMBED\nAMDREPL  EQU   X'10'   ...1 ....       REPLICATE\nAMDORDER EQU   X'08'   .... 1...       ORDERED\nAMDRANGE EQU   X'04'   .... .1..       FILE HAS KEYRANGES\nAMDRRDS  EQU   X'02'   .... ..1.       RRDS\nAMDSPAN  EQU   X'01'   .... ...1       SPANNED\nAMDLEN   DS    XL2                     LENGTH OF THIS BLOCK\nAMDNEST  DS    XL2                     NO. OF ENTRIES IN INDEX SECTION\n         ORG   AMDNEST                 (EXCEPT IF DATA RECD OF AIX)\nAMDAXRKP DS    XL2                     RELATIVE KEY POSITION IF AIX\nAMDRKP   DS    XL2                     RELATIVE KEY POSITION\nAMDKEYLN DS    XL2                     KEY LENGTH\nAMDPCTCA DS    XL1                     CA FREE % (UNLESS SAM ESDS)\n         ORG   AMDPCTCA\nAMDRCFRM DS    XL1                     SAM ESDS ATTRIBUTES\nAMDIMPFD EQU   X'80'   1... ....       IMPLICIT DEFINE\n**       EQU   X'40'   .1.. ....\nAMDNCIFT EQU   X'20'   ..1. ....       NO-CIFORMAT\nAMDNCAFT EQU   X'10'   ...1 ....       NO-CAFORMAT (SAM ESDS)\n**       EQU   X'08'   .... 1...       ORDERED\nAMDSBLKD EQU   X'04'   .... .1..       BLOCKED RECORDS\nAMDSVAR  EQU   X'02'   .... ..1.       VARIABLE LENGTH\nAMDSFIXD EQU   X'01'   .... ...1       FIXED LENGTH\nAMDPCTCI DS    XL1                     CI FREE %\nAMDCIPCA DS    XL2                     CIS PER CA\nAMDFSCA  DS    XL2                     FREE CIS PER CA\nAMDFSCI  DS    XL4                     FREE BYTES PER CI\nAMDCINV  DS    XL4                     CISIZE\nAMDLRECL DS    XL4                     MAX. RECSZ\nAMDHLRBA DS    XL4                     RBA OF HIGH LEVEL INDEX RECORD\n         ORG   AMDHLRBA\nAMDNSLOT DS    XL4                     NO. OF RELATIVE RECORD SLOTS\n         ORG   AMDHLRBA\nAMDBLREC DS    XL4                     SAM LRECL FOR FB SAM ESDS\nAMDSSRBA DS    XL4                     RBA OF 1ST SEQUENCE SET RECORD\n         ORG   AMDSSRBA\nAMDMAXRR DS    XL4                     MAX. RELATIVE RECORD NO.\nAMDPARDB DS    XL4                     POINTER TO 1ST ARDB\nAMDATTR3 DS    XL1                     ATTRIBUTES\nAMDUNQ   EQU   X'80'   1... ....       NON-UNIQUE KEYS IN AIX\n*******  EQU   X'00'   .... ....       UNIQUE KEYS IN AIX\n         DS    XL7                     RESERVED\n* STATISTICS\nAMDSTAT  DS    0C                      STATISTICS\nAMDSTMST DS    XL8                     SYSTEM TIME STAMP\nAMDSTAT1 DS    0C\nAMDNIL  DS    XL2                      NO. OF INDEX LEVELS\nAMDNEDB DS    XL2                      NO. OF EDB'S\n        ORG   AMDNEDB\nAMDNEXT DS    XL2                      NO. OF EXTENTS\nAMDNLR  DS    XL4                      NO. OF LOGICAL RECORDS\nAMDDELR DS    XL4                      NO. OF DELETED RECORDS\nAMDIREC DS    XL4                      NO. OF INSERTED RECORDS\nAMDUPR  DS    XL4                      NO. OF UPDATED RECORDS\nAMDRETR DS    XL4                      NO. OF RETRIEVED RECORDS\nAMDASPA DS    XL4                      BYTES FREE SPACE IN DATA SET\nAMDNCIS DS    XL4                      NO. OF CI SPLITS\nAMDNCAS DS    XL4                      NO. OF CA SPLITS\nAMDEXCP DS    XL4                      EXCPS\n        EJECT\n* GROUP OCCURENCE DSECTS\nGOPREC   DSECT                         GO PTRS\nGROUP0   DS    CL5                     REPEATED 'GOPNO' TIMES\n         ORG   GROUP0\n         DS    XL1                     RESERVED\nGPTR     DS    XL2                     CI NO OF EXTENSION RECORD\n*                                      (IF GRPFLAG = B'10XXXXXX')\n*                                      ELSE DISP FROM GROUP0\n*                                      (IF GRPFLAG = B'00XXXXXX')\n*                                      ELSE DELETED GROUP\n*                                      (IF GRPFLAG = B'01XXXXXX')\nGRPFLAG  DS    XL1\nAMSDBTYP EQU   X'01'                   AMSDB POINTER\nGSEQNO   DS    XL1                     SEQUENCE NO. OF GROUP\nGOPLEN   EQU   *-GROUP0                LENGTH OF GROUP OCCURRENCE PTR\n* THIS DSECT ASSUMES THAT FIRST TWO GROUP OCCURRENCES FOR A CLUSTER\n* WILL ALWAYS BE THE DATA & INDEX GROUP OCCURRENCES.\nASSOC    DSECT                         ASSOCIATION GRP OCCURRENCE\nANO      DS    XL1                     NO. OF FIELDS\nADISPD   DS    XL1                     DISP TO 1ST VAR LENGTH FIELD\nATYPED   DS    XL1                     TYPE\nACINOD   DS    XL3                     CONTROL INTERVAL NO. (DATA)\nALEN     EQU   *-ANO                   LENGTH FOR DATA OR INDEX\nANOI     DS    XL1\nADISPI   DS    XL1\nATYPEI   DS    XL1\nACINOI   DS    XL3                     CONTROL INTERVAL NO. (INDEX)\nVOLREC   DSECT                         VOLUME INFO GROUP OCCURRENCE\nVCOUNT   DS    XL1                     NO. OF VARIABLE FIELDS\nVDISP    DS    XL1                     DISP TO 1ST VARIABLE FIELD\nVTYPE    DS    CL4                     DEVICE TYPE\nVOLSER   DS    CL6                     VOL SER\nVSEQ     DS    XL2                     FILE SEQ NO. (USED FOR TAPES)\nVOLFLG   DS    XL1                     VOLUME FLAGS\nPRIME    EQU   X'80'   1... ....       PRIME VOLUME\nCANDIDAT EQU   X'40'   .1.. ....       CANDIDATE VOLUME\nOVERFLOW EQU   X'20'   ..1. ....       OVERFLOW VOLUME\nVEXTNO   DS    XL1                     NO. OF EXTENTS ON THIS VOLUME\nHKRBA    DS    XL4                     HI-KEY RBA\nVHURBA   DS    XL4                     HI-USED RBA\nVHARBA   DS    XL4                     HI-ALLOC RBA\nPHYBLKSZ DS    XL4                     PHYSICAL BLOCK SIZE\nNOBLKTRK DS    XL2                     BLKS / TRK\nNOTRKAU  DS    XL2                     TRKS / CA\nITYPEXT  DS    XL1                     FLAG\nDSDIRSN  DS    XL2                     DATA SET DIRECTORY SEQ NO.\n* FOLLOWING FIELDS REPEAT\nVARFLD   DS    0C                      VARIABLE\nVARLEN   DS    XL2                     FIELD LENGTH\n* (IF THIS FIELD IS 0 THEN LENGTH IS 2)\n*VARDATA DS    (VARIABLE)\n         END\n\nDavid Roth\nSystems Programmer (Australia)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A002A09": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00!\\x00!\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 33, "newlines": 33, "modlines": 0, "user": "VSAMUPD"}, "text": "Using SPEED or RECOVERY\n\nWhen using the IDCAMS DEFINE command, there are two\nmutually exclusive options that can be used.  These are SPEED\nand RECOVERY.  RECOVERY is the default.\n\nRECOVERY is only applicable when data is loaded into a\ncluster for the first time - an activity known as initial load.\nWhen RECOVERY is used, IDCAMS loads the data into a\ncluster, and also preformats another Control Area with EOF\nrecords.  If the system crashes during this initial load, a\nsubsequent read of the file will identify how far the data load\nhad gone before the failure occurred.  The load can then be\nrestarted from this point.\n\nThe alternative is to use SPEED.  SPEED does no\npreformatting of Control Areas with EOF records.  Therefore\nthe initial load takes place faster, and fewer I/Os are\nperformed.\n\nApart from the overhead when using RECOVERY, it also\nrequires the user to work out where the initial load failure\noccurred and to take all the necessary steps to restart the load\nfrom the correct point.  This may take a considerable amount\nof time and require considerable effort on the part of the end\nuser.\n\nIn general, for all but the largest initial loads, it takes more\ntime to work out the restart logic than simply to rerun the\nwhole job again.  Therefore, it is recommended that SPEED is\ncoded when performing the initial load for all but the largest\nfiles.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A003A00I": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 12, "newlines": 12, "modlines": 0, "user": "VSAMUPD"}, "text": "A003 - VSAM Update Issue #3  October 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA003A01   Recreating VSAM file definitions\nA003A02   Displaying VSAM information\nA003A03   DL/I, VSAM and performance\nA003A04   Generation of diagnose cards for IDCAMS\nA003A05   Deleting uncatalogued VSAM datasets\nA003A06   IMBED and performance\nA003A07   Correction\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A003A01": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x05&\\x05&\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 1318, "newlines": 1318, "modlines": 0, "user": "VSAMUPD"}, "text": "Recreating VSAM file definitions\n\nHow many times have you needed the source definition\nstatements for a VSAM file, but after searching everywhere\ndecided they were nowhere to be found?  In turn, you probably\nrecreated the definition manually by examining all the detail\nfrom a catalog listing of the file.\n\nAfter being frustrated by this a couple of times, I decided to\nwrite a program that would dynamically recreate the definition\nstatements for me.  The program, called VSGETDEF,\ninterfaces with IDCAMS and extracts information from the\noutput from LISTCAT.  The recreated definition statements are\noutput to a PDS member described in the JCL.  By extracting\ninformation from LISTCAT, instead of going directly into the\nICF catalog, the program is fairly well insulated against catalog\nstructure changes.  This is illustrated by the fact that the\nprogram was originally written under DFP 2.3 but continues to\nfunction without modification with DFP 3.2.\n\nThe VSAM files for which you want definitions recreated are\ninput to the program via a REQUESTS DD statement.  In\naddition to the VSAM file, the program looks for three flags\nrelative to each definition being produced.  The first flag\nindicates whether or not to include alternate index definitions in\nthe output.  A value of Y indicates that they are to be included.\nThis can be very beneficial if the file has associated AIXs\nwhich also need their definitions recreated.  The AIX itself\ncould be input individually to get that single definition if\ndesired.  Next is the path flag.  Again, if there are associated\npath definitions, the information is extracted to recreate the\npaths, and the flag value is Y.  Finally there is the catalog flag.\nIn most shops the alias high-level qualifier of a dataset is used\nto put a file definition into the proper catalog.  Thus, it is not\nnecessary, and in fact undesirable, to code the CATALOG\nstatement.  If you change the name of a cluster after recreating\nits definition you don't have to be concerned about possibly\nchanging the catalog.  VSGETDEF will only produce\nCATALOG statements if a value of Y is coded in the catalog\nflag.  Logic for all VSAM file types (INDEXED,\nNONINDEXED, NUMBERED, and LINEAR) is included.\nOutput from the program is complete in that it handles all\npossible DEFINE parameters as of DFP 2.3.\n\n\nSAMPLE JCL TO RUN VSGETDEF\n\n//EISHMANX JOB  (),'VSGETDEF',MSGCLASS=1\n//*\n//STEP1    EXEC PGM=IEFBR14\n//DD1      DD   DSN=EISHMAN.TEMP,DISP=(,CATLG),\n//  UNIT=SYSWK,SPACE=(CYL,1),\n//  DCB=(LRECL=80,BLKSIZE=6800,RECFM=FB)\n//*\n//STEP2    EXEC PGM=VSGETDEF\n//STEPLIB  DD   DSN=EISHMAN.LIB.LOAD,DISP=SHR\n//IDCSYSIN DD   DSN=EISHMAN.TEMP,DISP=(OLD,DELETE)\n//SYSIN    DD   DSN=EISHMAN.TEMP,DISP=OLD\n//DEFSTMTS DD   DSN=EISHMAN.LIB.DATA(VSGETDEF),DISP=SHR\n//SYSOUT   DD   SYSOUT=*\n//SYSPRINT DD   UNIT=VIO,SPACE=(CYL,1)\n//*     REQUESTS INPUT LAYOUT BY COLUMN:\n//*           1 - Y = INCLUDE ALTERNATE INDEX DEFINITIONS\n//*               N = EXCLUDE ALTERNATE INDEX DEFINITIONS (DEFAULT)\n//*           2 - Y = INCLUDE PATH DEFINITIONS\n//*               N = EXCLUDE PATH DEFINITIONS (DEFAULT)\n//*           3 - Y = INCLUDE CATALOG DEFINITION STATEMENT\n//*               N = EXCLUDE CATALOG DEFINITION STATEMENT (DEFAULT)\n//*        4-47 - VSAM DATASET NAME, LEFT JUSTIFIED\n//REQUESTS DD  *\nYYNEISHMAN.TEST.VSAM.FILE\nNNYSYS1.MAN1\nNNYMVSSMPE.GLOBAL.CSI\n\n\nSAMPLE OUTPUT\n\n/*     CLUSTER DEFINITION FOLLOWS FOR:                   */\n/*     EISHMAN.TEST.VSAM.FILE                            */\nDEFINE CLUSTER (NAME(EISHMAN.TEST.VSAM.FILE                  ) -\nINDEXED    -\nSPANNED    -\nSHAREOPTIONS(2 3) -\nKEYS(064 0000) -\nRECORDSIZE(00080 00080) -\nFREESPACE(010 010) -\nMASTERPW(   MSTPW) -\nATTEMPTS(05) -\nUPDATEPW(   UPDPW) -\nCONTROLPW(  CNTLPW) -\nREADPW(    RDPW) -\nCODE(  EICODE) -\nAUTHORIZATION(  ERNIES DATA                                  ) -\nBUFFERSPACE(08704) -\n    ERASE -\nRECOVERY -\nWRITECHECK   -\nORDERED   -\nCYLINDERFAULT -\nDESTAGEWAIT -\nTO(1995155) -\nOWNER( EISHMAN) -\nKEYRANGE( -\n(X'F040404040404040404040404040404040404040404040404040404040404040+\n4040404040404040404040404040404040404040404040404040404040404040' -\nX'F1404040404040404040404040404040404040404040404040404040404040404+\n040404040404040404040404040404040404040404040404040404040404040') -\n) -\n NOREUSE) -\nDATA ( -\nNAME(EISHMAN.TEST.VSAM.FILE.DATE                             ) -\nVOLUMES(WORK01 WORK02                                        ) -\nEXCEPTIONEXIT(   E1MOD) -\nCONTROLINTERVALSIZE(04096) -\nTRACKS   (0004 0004) ) -\nINDEX ( -\nNAME(EISHMAN.TEST.VSAM.FILE.INDEX                            ) -\nREPLICATE   -\nIMBED   -\nVOLUMES(WORK01 WORK02                                        ) -\nCONTROLINTERVALSIZE(00512) -\nEXCEPTIONEXIT(   E1MOD) -\nTRACKS   (0001 0001)) -\nCATALOG(SYS1.VTST002.TCAT                                    )\n/*     ALTERNATE INDEX DEFINITION FOLLOWS FOR:          */\n/*     EISHMAN.TEST.VSAM.FILE.AIX                       */\nDEFINE AIX (NAME(EISHMAN.TEST.VSAM.FILE.AIX                  ) -\nRELATE(EISHMAN.TEST.VSAM.FILE                                ) -\nNOUPGRADE -\nUNIQUEKEY    -\nSHAREOPTIONS(2 3) -\nKEYS(064 0005) -\nRECORDSIZE(00080 00080) -\nFREESPACE(000 000) -\nMASTERPW(   ERNIE) -\nATTEMPTS(05) -\nUPDATEPW(   UPDPW) -\nCONTROLPW(   ERNIE) -\nREADPW(   ERNIE) -\nCODE(  EICODE) -\nAUTHORIZATION(   ERNIE DATA                                  ) -\nBUFFERSPACE(08704) -\n  NOERASE -\nRECOVERY -\nNOWRITECHECK -\nUNORDERED -\nCYLINDERFAULT -\nTO(1995155) -\nOWNER( EISHMAN) -\n NOREUSE) -\nDATA ( -\nNAME(EISHMAN.TEST.VSAM.FILE.AIX.DATA                         ) -\nVOLUMES(WORK03                                               ) -\nEXCEPTIONEXIT(   E1MOD) -\nCONTROLINTERVALSIZE(04096) -\nTRACKS   (0002 0002)) -\nINDEX ( -\nNAME(EISHMAN.TEST.VSAM.FILE.AIX.INDEX                        ) -\nNOREPLICATE -\nNOIMBED -\nVOLUMES(WORK03)                                              ) -\nCONTROLINTERVALSIZE(00512) -\nEXCEPTIONEXIT(   E1MOD) -\nTRACKS   (0001 0001)) -\nCATALOG(SYS1.VTST002.TCAT                                    )\n/*     PATH DEFINITION FOLLOWS FOR:                   */\n/*     EISHMAN.TEST.VSAM.FILE.PATH                    */\nDEFINE PATH (NAME(EISHMAN.TEST.VSAM.FILE.PATH                ) -\nPATHENTRY(EISHMAN.TEST.VSAM.FILE.AIX                         ) -\nNOUPDATE ) -\nCATALOG(SYS1.VTST002.TCAT                                    )\n\n\nVSGETDEF\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. VSGETDEF.\n       AUTHOR.     ERNIE ISHMAN.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT REQUESTS ASSIGN TO REQUESTS.\n           SELECT DEFSTMTS ASSIGN TO DEFSTMTS.\n           SELECT IDCSYSIN ASSIGN TO IDCSYSIN.\n           SELECT SYSPRINT ASSIGN TO SYSPRINT.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  IDCSYSIN\n           LABEL RECORDS ARE STANDARD\n           RECORDING MODE F\n           BLOCK 0 RECORDS.\n       01  IDCSYSIN-RECORD     PIC X(80).\n       FD  DEFSTMTS\n           LABEL RECORDS ARE STANDARD\n           RECORDING MODE F\n           BLOCK 0 RECORDS.\n       01  DEFSTMTS-RECORD     PIC X(80).\n       FD  SYSPRINT\n           LABEL RECORDS ARE STANDARD\n           RECORDING MODE V\n           BLOCK 0 RECORDS.\n       01  SYSPRINT-RECORD     PIC X(125).\n       FD  REQUESTS\n           LABEL RECORDS ARE STANDARD\n           RECORDING MODE F\n           BLOCK 0 RECORDS.\n       01  REQUESTS-RECORD.\n           03  RR-AIX-FLAG          PIC X.\n           03  RR-PATH-FLAG         PIC X.\n           03  RR-CATALOG-FLAG      PIC X.\n           03  RR-DSN               PIC X(44).\n           03  FILLER               PIC X(33).\n       WORKING-STORAGE SECTION.\n       01  LISTC-RECORD.\n           03  FILLER                  PIC X.\n           03  LR-COLS-2-4             PIC X(3).\n           03  LR-COLS-5-61.\n               05  FILLER              PIC XX.\n               05  LR-COLS-7-12        PIC X(6).\n               05  FILLER              PIC X(5).\n               05  LR-COLS-18-61.\n                   07  FILLER          PIC X(9).\n                   07  LR-COLS-27-61-GROUP.\n                       09  LR-COLS-27-61 OCCURS 35 TIMES PIC X.\n                   07  LR-COLS-27-61-REDEF REDEFINES\n                       LR-COLS-27-61-GROUP.\n                       09  LR-COLS-27-32   PIC X(6).\n                       09  FILLER          PIC X(21).\n                       09  LR-COLS-54-57   PIC X(4).\n                       09  FILLER          PIC X.\n                       09  LR-COLS-59-61   PIC X(3).\n           03  LR-COLS-5-61-REDEF REDEFINES LR-COLS-5-61.\n               05  LR-COLS-5-8         PIC X(4).\n               05  LR-COLS-9-17        PIC X(9).\n               05  LR-COLS-18          PIC X.\n               05  FILLER              PIC X.\n               05  LR-COLS-20          PIC X.\n               05  FILLER              PIC X(4).\n               05  LR-COLS-25-32-GROUP.\n                   07  LR-COLS-25-32 OCCURS 8 TIMES PIC X.\n               05  FILLER              PIC X(5).\n               05  LR-COLS-38-47       PIC X(10).\n               05  LR-COLS-48-50       PIC X(3).\n               05  FILLER              PIC XX.\n               05  LR-COLS-53-61.\n                   07  FILLER          PIC X.\n                   07  LR-COLS-54-61 OCCURS 8 TIMES PIC X.\n               05  LR-COLS-53-61-REDEF REDEFINES LR-COLS-53-61.\n                   07  FILLER          PIC X(4).\n                   07  LR-COLS-57-61 OCCURS 5 TIMES PIC X.\n           03  FILLER                  PIC X(5).\n           03  LR-COLS-67-76           PIC X(10).\n           03  FILLER                  PIC X(4).\n           03  LR-COLS-81-90.\n               05  FILLER                  PIC XX.\n               05  LR-COLS-83-90 OCCURS 8 TIMES PIC X.\n           03  FILLER                  PIC X(5).\n           03  LR-COLS-96-102          PIC X(7).\n           03  FILLER                  PIC X(9).\n           03  LR-COLS-112-119-GROUP.\n               05  LR-COLS-112-119 OCCURS 8 TIMES PIC X.\n           03  LR-COLS-112-119-REDEF REDEFINES LR-COLS-112-119-GROUP.\n               05  FILLER              PIC X(3).\n               05  LR-COLS-115-119 OCCURS 5 TIMES PIC X.\n           03  FILLER                  PIC XX.\n       01  LISTC-RECORD-REDEF REDEFINES LISTC-RECORD.\n           03  FILLER                  PIC X(30).\n           03  LR-COLS-31-120 OCCURS 90 TIMES PIC X.\n           03  FILLER                  PIC X.\n       01  LISTC-COMMAND.\n           03  FILLER           PIC X(15)     VALUE ' LISTC ENTRIES('.\n           03  LISTC-DSN        PIC X(44).\n           03  FILLER           PIC X(5)      VALUE ') ALL'.\n       01  CLUSTER-STATEMENT.\n           03  FILLER           PIC X(22)\n                                VALUE ' DEFINE CLUSTER (NAME('.\n           03  CLUSTER-NAME     PIC X(44).\n           03  FILLER           PIC X(3)      VALUE ') -'.\n       01  AIX-STATEMENT.\n           03  FILLER           PIC X(18)\n                                VALUE ' DEFINE AIX (NAME('.\n           03  AIX-NAME         PIC X(44).\n           03  FILLER           PIC X(3)      VALUE ') -'.\n       01  PATH-NAME-STATEMENT.\n           05  FILLER           PIC X(19)\n                                VALUE ' DEFINE PATH (NAME('.\n           05  PATH-NAME        PIC X(44).\n           05  FILLER           PIC X(3)      VALUE ') -'.\n       01  PATH-ENTRY-STATEMENT.\n           03  FILLER           PIC X(11)\n                                VALUE ' PATHENTRY('.\n           03  PATH-ENTRY       PIC X(44).\n           03  FILLER           PIC X(3)      VALUE ') -'.\n       01  RELATE-STATEMENT.\n           03  FILLER           PIC X(8)\n                                VALUE ' RELATE('.\n           03  RELATE-NAME      PIC X(44).\n           03  FILLER           PIC X(3)      VALUE ') -'.\n       01  CATALOG-STATEMENT.\n           03  FILLER  PIC X(9)  VALUE ' CATALOG('.\n           03  CATALOG           PIC X(44).\n           03  FILLER  PIC X     VALUE ')'.\n       01  DATA-NAME-STATEMENT.\n           03  FILLER  PIC X(6)  VALUE ' NAME('.\n           03  DATA-NAME         PIC X(44).\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  INDEX-NAME-STATEMENT.\n           03  FILLER  PIC X(6)  VALUE ' NAME('.\n           03  INDEX-NAME        PIC X(44).\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  SHROPTIONS-STATEMENT.\n           03  FILLER  PIC X(14) VALUE ' SHAREOPTIONS('.\n           03  XREGSHR           PIC X.\n           03  FILLER  PIC X     VALUE ' '.\n           03  XSYSSHR           PIC X.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  VOLUME-DATA-STATEMENT.\n           03  FILLER  PIC X(9) VALUE ' VOLUMES('.\n           03  VOLUME-DATA-GROUP.\n               05  DATA-VOLUME PIC X(7) OCCURS 5 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  KEYS-STATEMENT.\n           03  FILLER  PIC X(6) VALUE ' KEYS('.\n           03  KEYLEN PIC X OCCURS 3 TIMES.\n           03  FILLER  PIC X     VALUE ' '.\n           03  RKP PIC X OCCURS 4 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  RECORDSIZE-STATEMENT.\n           03  FILLER  PIC X(12) VALUE ' RECORDSIZE('.\n           03  AVGLRECL PIC X OCCURS 5 TIMES.\n           03  FILLER  PIC X     VALUE ' '.\n           03  MAXLRECL PIC X OCCURS 5 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  VOLUME-INDEX-STATEMENT.\n           03  FILLER  PIC X(9) VALUE ' VOLUMES('.\n           03  VOLUME-INDEX-GROUP.\n               05  VOLUME-INDEX PIC X(7) OCCURS 5 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  BUFSPACE-STATEMENT.\n           03  FILLER  PIC X(13) VALUE ' BUFFERSPACE('.\n           03  BUFSPACE PIC X OCCURS 5 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  EXCPEXIT-DATA-STATEMENT.\n           03  FILLER  PIC X(15) VALUE ' EXCEPTIONEXIT('.\n           03  EXCPEXIT-DATA-GROUP.\n               05  EXCPEXIT-DATA PIC X OCCURS 8 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  EXCPEXIT-INDEX-STATEMENT.\n           03  FILLER  PIC X(15) VALUE ' EXCEPTIONEXIT('.\n           03  EXCPEXIT-INDEX-GROUP.\n               05  EXCPEXIT-INDEX PIC X OCCURS 8 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  CISIZE-DATA-STATEMENT.\n           03  FILLER  PIC X(21) VALUE ' CONTROLINTERVALSIZE('.\n           03  CISIZE-DATA PIC X OCCURS 5 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  CISIZE-INDEX-STATEMENT.\n           03  FILLER  PIC X(21) VALUE ' CONTROLINTERVALSIZE('.\n           03  CISIZE-INDEX PIC X OCCURS 5 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  FREESPACE-STATEMENT.\n           03  FILLER  PIC X(11) VALUE ' FREESPACE('.\n           03  CIFREESP PIC X OCCURS 3 TIMES.\n           03  FILLER  PIC X     VALUE ' '.\n           03  CAFREESP PIC X OCCURS 3 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  MASTER-PASSWORD-STATEMENT.\n           03  FILLER  PIC X(10) VALUE ' MASTERPW('.\n           03  MASTER-PASSWORD PIC X OCCURS 8 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  UPDATE-PASSWORD-STATEMENT.\n           03  FILLER  PIC X(10) VALUE ' UPDATEPW('.\n           03  UPDATE-PASSWORD PIC X OCCURS 8 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  CONTROL-PASSWORD-STATEMENT.\n           03  FILLER  PIC X(11) VALUE ' CONTROLPW('.\n           03  CONTROL-PASSWORD PIC X OCCURS 8 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  READ-PASSWORD-STATEMENT.\n           03  FILLER  PIC X(8)  VALUE ' READPW('.\n           03  READ-PASSWORD PIC X OCCURS 8 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  PASSWORD-CODE-STATEMENT.\n           03  FILLER  PIC X(6)  VALUE ' CODE('.\n           03  PASSWORD-CODE PIC X OCCURS 8 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  ATTEMPTS-STATEMENT.\n           03  FILLER  PIC X(10) VALUE ' ATTEMPTS('.\n           03  ATTEMPTS PIC X OCCURS 2 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  AUTHORIZATION-STATEMENT.\n           03  FILLER  PIC X(15) VALUE ' AUTHORIZATION('.\n           03  USVR PIC X OCCURS 8 TIMES.\n           03  FILLER PIC X VALUE ' '.\n           03  USAR-GROUP.\n               05  USAR PIC X OCCURS 35 TIMES.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  REPLICATE-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  REPLICATE PIC X(11).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  UPGRADE-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  UPGRADE         PIC X(9).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  UPDATE-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  UPDATE          PIC X(9).\n           03  FILLER          PIC XX   VALUE ') '.\n           03  UPDATE-DASH     PIC X.\n       01  ERASE-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  ERASE PIC X(9).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  RECOVERY-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  RECOVERY PIC X(8).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  CLUSTER-TYPE-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  CLUSTER-TYPE    PIC X(10).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  WRITECHECK-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  WRITECHECK PIC X(12).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  IMBED-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  IMBED         PIC X(7).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  ORDER-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  ORDERED PIC X(9).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  REUSE-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  REUSE           PIC X(8).\n           03  FILLER          PIC X(3) VALUE ') -'.\n       01  UNIQUEKEY-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  UNIQUEKEY PIC X(12).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  SPANNED-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  SPANNED PIC X(10).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  DATA-STATEMENT.\n           03  FILLER          PIC X(9) VALUE ' DATA ( -'.\n       01  INDEX-STATEMENT.\n           03  FILLER          PIC X(10) VALUE ' INDEX ( -'.\n       01  STAGE-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  STAGE           PIC X(13).\n           03  FILLER          PIC XX VALUE ' -'.\n       01  DESTAGE-STATEMENT  PIC X(14) VALUE ' DESTAGEWAIT -'.\n       01  PAREN-STATEMENT    PIC X(4)  VALUE ' ) -'.\n       01  ALLOCATION-DATA-STATEMENT.\n           03  FILLER                 PIC X VALUE ' '.\n           03  ALLOCATION-TYPE-DATA   PIC X(9).\n           03  FILLER                 PIC X   VALUE '('.\n           03  PRIMARY-DATA OCCURS 4 TIMES PIC X.\n           03  FILLER                 PIC X   VALUE ' '.\n           03  SECONDARY-DATA OCCURS 4 TIMES PIC X.\n           03  FILLER  PIC X(3)  VALUE ')) '.\n           03  ALLOCATION-DATA-DASH   PIC X.\n       01  ALLOCATION-INDEX-STATEMENT.\n           03  FILLER          PIC X VALUE ' '.\n           03  ALLOCATION-TYPE-INDEX PIC X(9).\n           03  FILLER                 PIC X   VALUE '('.\n           03  PRIMARY-INDEX OCCURS 4 TIMES PIC X.\n           03  FILLER                 PIC X   VALUE ' '.\n           03  SECONDARY-INDEX OCCURS 4 TIMES PIC X.\n           03  FILLER  PIC X(3)  VALUE ')) '.\n           03  ALLOCATION-INDEX-DASH  PIC X.\n       01  TO-STATEMENT.\n           03  FILLER                 PIC X(4)  VALUE ' TO('.\n           03  TO-YEAR                PIC X(4).\n           03  TO-DAY                 PIC X(3).\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  OWNER-STATEMENT.\n           03  FILLER  PIC X(7) VALUE ' OWNER('.\n           03  OWNER OCCURS 8 TIMES PIC X.\n           03  FILLER  PIC X(3)  VALUE ') -'.\n       01  KEYRANGE-STATEMENT.\n           03  FILLER  PIC X(10) VALUE ' KEYRANGE('.\n           03  FILLER          PIC XX VALUE ' -'.\n       01  KEYRANGE-GROUP.\n           03  KEYRANGE-DETAIL OCCURS 5 TIMES.\n               05  LOW-KEYRANGE-DETAIL-1.\n                   07  LOW-KEYRANGE-1 OCCURS 71 TIMES PIC X.\n               05  LOW-KEYRANGE-DETAIL-2.\n                   07  LOW-KEYRANGE-2 OCCURS 71 TIMES PIC X.\n               05  HIGH-KEYRANGE-DETAIL-1.\n                   07  HIGH-KEYRANGE-1 OCCURS 71 TIMES PIC X.\n               05  HIGH-KEYRANGE-DETAIL-2.\n                   07  HIGH-KEYRANGE-2 OCCURS 71 TIMES PIC X.\n       01  COMMENT-STATEMENT-1.\n           03  FILLER  PIC X(8)  VALUE ' /*'.\n           03  FILLER  PIC X(49) VALUE SPACES.\n           03  FILLER  PIC XX    VALUE '*/'.\n       01  COMMENT-STATEMENT-2.\n           03  FILLER  PIC X(8)  VALUE ' /*'.\n           03  COMMENT-DSN  PIC X(44).\n           03  FILLER  PIC X(7)  VALUE '     */'.\n       01  COMMENT-STATEMENT-3.\n           03  FILLER  PIC X(8)  VALUE ' /*'.\n           03  FILLER  PIC X(31) VALUE\n               'CLUSTER DEFINITION FOLLOWS FOR:'.\n           03  FILLER  PIC X(18) VALUE SPACES.\n           03  FILLER  PIC XX    VALUE '*/'.\n       01  COMMENT-STATEMENT-4.\n           03  FILLER  PIC X(8)  VALUE ' /*'.\n           03  FILLER  PIC X(39) VALUE\n               'ALTERNATE INDEX DEFINITION FOLLOWS FOR:'.\n           03  FILLER  PIC X(10) VALUE SPACES.\n           03  FILLER  PIC XX    VALUE '*/'.\n       01  COMMENT-STATEMENT-5.\n           03  FILLER  PIC X(8)  VALUE ' /*'.\n           03  FILLER  PIC X(28) VALUE\n               'PATH DEFINITION FOLLOWS FOR:'.\n           03  FILLER  PIC X(21) VALUE SPACES.\n           03  FILLER  PIC XX    VALUE '*/'.\n       01  EOF-REQUESTS-FLAG    PIC 9 COMP VALUE 0.\n           88  EOF-REQUESTS                VALUE 1.\n       01  EOF-SYSPRINT-FLAG    PIC 9 COMP VALUE 0.\n           88  EOF-SYSPRINT                VALUE 1.\n       01  END-OF-KEYRANGE-FLAG PIC 9 COMP VALUE 0.\n           88  END-OF-KEYRANGE             VALUE 1.\n       01  KEYRANGE-FIRST-LINE-FLAG PIC 9 COMP VALUE 0.\n           88  KEYRANGE-FIRST-LINE             VALUE 0.\n       01  KEYRANGE-FLAG        PIC 9 COMP VALUE 0.\n           88  NEED-KEYRANGE               VALUE 1.\n       01  EXCPEXIT-DATA-FLAG   PIC 9 COMP VALUE 0.\n           88  NEED-EXCPEXIT-DATA          VALUE 1.\n       01  EXCPEXIT-INDEX-FLAG  PIC 9 COMP VALUE 0.\n           88  NEED-EXCPEXIT-INDEX         VALUE 1.\n       01  OWNER-FLAG           PIC 9 COMP VALUE 0.\n           88  NEED-OWNER                  VALUE 1.\n       01  TO-FLAG              PIC 9 COMP VALUE 0.\n           88  NEED-TO                     VALUE 1.\n       01  DESTAGE-FLAG              PIC 9 COMP VALUE 0.\n           88  NEED-DESTAGE                VALUE 1.\n       01  STAGE-FLAG                PIC 9 COMP VALUE 0.\n           88  NEED-STAGE                  VALUE 0.\n       01  VOLUME-INDEX-FLAG         PIC 9 COMP VALUE 0.\n           88  NEED-VOLUME-INDEX           VALUE 1.\n       01  PROCESS-AIX-FLAG          PIC 9 COMP VALUE 0.\n           88  PROCESSING-AIX              VALUE 1.\n       01  CONTROL-PASSWORD-FLAG     PIC 9 COMP VALUE 0.\n           88  NEED-CONTROL-PASSWORD       VALUE 1.\n       01  UPDATE-PASSWORD-FLAG      PIC 9 COMP VALUE 0.\n           88  NEED-UPDATE-PASSWORD        VALUE 1.\n       01  READ-PASSWORD-FLAG        PIC 9 COMP VALUE 0.\n           88  NEED-READ-PASSWORD          VALUE 1.\n       01  PASSWORD-CODE-FLAG        PIC 9 COMP VALUE 0.\n           88  NEED-PASSWORD-CODE          VALUE 1.\n       01  AUTHORIZATION-FLAG        PIC 9 COMP VALUE 0.\n           88  NEED-AUTHORIZATION          VALUE 1.\n       01  PROTECTION-GROUP-FLAG     PIC 9 COMP VALUE 0.\n           88  NEED-PROTECTION-GROUP       VALUE 1.\n       01  CLUSTER-TYPE-FLAG    PIC 9 COMP VALUE 0.\n           88  CLUSTER-INDEXED             VALUE 1.\n           88  CLUSTER-NONINDEXED          VALUE 2.\n           88  CLUSTER-NUMBERED            VALUE 3.\n           88  CLUSTER-LINEAR              VALUE 4.\n       01  SAVE-AIX-NAME-GROUP.\n           03  SAVE-AIX-NAME OCCURS 10 TIMES PIC X(44).\n       01  SAVE-PATH-INFO-GROUP.\n           03  SAVE-PATH-INFO OCCURS 5 TIMES.\n               05  SAVE-PATH-NAME       PIC X(44).\n               05  SAVE-PATH-ENTRY      PIC X(44).\n               05  SAVE-UPDATE          PIC X(9).\n               05  SAVE-CATALOG         PIC X(44).\n       01  AIX-CNT           COMP   PIC 99  VALUE 0.\n       01  VOL-CNT           COMP   PIC 9   VALUE 0.\n       01  PATH-CNT          COMP   PIC 9   VALUE 0.\n       01  KEYRANGE-CNT      COMP   PIC 9   VALUE 0.\n       01  KEYRANGE-WORK-CNT COMP   PIC 99  VALUE 0.\n       01  WORK-INDEX-1      COMP   PIC 999 VALUE 0.\n       01  WORK-INDEX-2      COMP   PIC 999 VALUE 0.\n       01  IDCAMS                   PIC X(6) VALUE 'IDCAMS'.\n       PROCEDURE DIVISION.\n       100-MAINLINE.\n           OPEN INPUT REQUESTS\n                OUTPUT DEFSTMTS.\n           PERFORM 270-READ-REQUESTS.\n           MOVE RR-DSN TO LISTC-DSN CLUSTER-NAME AIX-NAME COMMENT-DSN.\n           PERFORM 140-PROCESS-REQUESTS UNTIL EOF-REQUESTS.\n           PERFORM 120-SHUTDOWN.\n       120-SHUTDOWN.\n           CLOSE REQUESTS DEFSTMTS.\n           STOP RUN.\n       140-PROCESS-REQUESTS.\n           OPEN OUTPUT IDCSYSIN.\n           WRITE IDCSYSIN-RECORD FROM LISTC-COMMAND.\n           CLOSE IDCSYSIN.\n           CALL IDCAMS.\n           IF RETURN-CODE NOT = 0\n               DISPLAY '--    BAD RETURN CODE FROM IDCAMS     --'\n               DISPLAY '-- CHECK FOR MISSPELLED CLUSTER NAME  --'\n               DISPLAY '-- CLUSTER NAMED USED FOR LISTCAT:    --'\n               DISPLAY '-- ' LISTC-DSN\n               MOVE 12 TO RETURN-CODE\n               PERFORM 120-SHUTDOWN\n           ELSE\n               MOVE 0 TO OWNER-FLAG VOL-CNT KEYRANGE-CNT PATH-CNT\n                         EXCPEXIT-DATA-FLAG EXCPEXIT-INDEX-FLAG\n                         TO-FLAG DESTAGE-FLAG STAGE-FLAG\n                         EOF-SYSPRINT-FLAG KEYRANGE-FLAG\n                         PROCESS-AIX-FLAG PROTECTION-GROUP-FLAG\n                         CONTROL-PASSWORD-FLAG UPDATE-PASSWORD-FLAG\n                         READ-PASSWORD-FLAG PASSWORD-CODE-FLAG\n                         AUTHORIZATION-FLAG CLUSTER-TYPE-FLAG\n               MOVE SPACES TO VOLUME-DATA-GROUP VOLUME-INDEX-GROUP\n                              KEYRANGE-GROUP EXCPEXIT-DATA-GROUP\n                              EXCPEXIT-INDEX-GROUP\n               OPEN INPUT SYSPRINT\n               PERFORM 280-READ-SYSPRINT\n               PERFORM 170-PRIME-DEFINE-FIELDS\n                       UNTIL EOF-SYSPRINT\n               CLOSE SYSPRINT\n               PERFORM 190-WRITE-DEFINE-STATEMENTS\n               IF AIX-CNT > 0\n                   MOVE SAVE-AIX-NAME(AIX-CNT) TO\n                        LISTC-DSN AIX-NAME COMMENT-DSN\n                   SUBTRACT 1 FROM AIX-CNT\n               ELSE\n                   PERFORM 270-READ-REQUESTS\n                   MOVE RR-DSN TO LISTC-DSN CLUSTER-NAME\n                                  AIX-NAME COMMENT-DSN.\n       170-PRIME-DEFINE-FIELDS.\n           IF LR-COLS-7-12 = 'IN-CAT'\n               MOVE LR-COLS-18-61 TO CATALOG\n           ELSE\n           IF LR-COLS-38-47 = 'EXPIRATION'\n               PERFORM 260-CHECK-EXPIRATION-DATE\n           ELSE\n           IF LR-COLS-2-4 = 'AIX'\n               MOVE 1 TO PROCESS-AIX-FLAG\n           ELSE\n           IF LR-COLS-9-17 = 'CLUSTER--'\n               MOVE LR-COLS-18-61 TO RELATE-NAME\n           ELSE\n           IF LR-COLS-9-17 = 'NOUPGRADE'\n               MOVE LR-COLS-9-17 TO UPGRADE\n           ELSE\n           IF LR-COLS-9-17 = 'UPGRADE  '\n               MOVE LR-COLS-9-17 TO UPGRADE\n           ELSE\n           IF LR-COLS-7-12 = 'PROTEC' AND LR-COLS-18 = ' '\n               PERFORM 200-GET-PROTECTION-GROUP\n           ELSE\n           IF LR-COLS-7-12 = '  AIX-' AND RR-AIX-FLAG = 'Y'\n               ADD 1 TO AIX-CNT\n               IF AIX-CNT > 10\n                   DISPLAY '--  VSGETDEF CANNOT HANDLE FILES WITH --'\n                   DISPLAY '--  MORE THAN TEN ALTERNATE INDEXES   --'\n                   MOVE 12 TO RETURN-CODE\n                   PERFORM 120-SHUTDOWN\n               ELSE\n                   MOVE LR-COLS-18-61 TO SAVE-AIX-NAME(AIX-CNT)\n           ELSE\n           IF LR-COLS-7-12 = '  OWNE' AND LR-COLS-25-32(3) NOT = '('\n               MOVE 1 TO WORK-INDEX-1 OWNER-FLAG\n               PERFORM 259-GET-OWNER 8 TIMES\n           ELSE\n           IF LR-COLS-5-8  = 'DATA'\n               MOVE LR-COLS-18-61 TO DATA-NAME\n               PERFORM 175-GET-DATA-COMPONENT-FIELDS UNTIL\n                   EOF-SYSPRINT.\n           IF NOT EOF-SYSPRINT\n              PERFORM 280-READ-SYSPRINT.\n       175-GET-DATA-COMPONENT-FIELDS.\n           IF LR-COLS-9-17 = 'KEYLEN---'\n               MOVE 6 TO WORK-INDEX-1\n               MOVE 1 TO WORK-INDEX-2\n               PERFORM 176-GET-KEYLEN 3 TIMES\n               MOVE 1 TO WORK-INDEX-1\n               PERFORM 178-GET-AVGLRECL 5 TIMES\n               MOVE 4 TO WORK-INDEX-1\n               MOVE 1 TO WORK-INDEX-2\n               PERFORM 181-GET-BUFSPACE 5 TIMES\n               MOVE 1 TO WORK-INDEX-1\n               PERFORM 183-GET-CISIZE-DATA 5 TIMES\n           ELSE\n           IF LR-COLS-9-17 = 'RKP------'\n               MOVE 5 TO WORK-INDEX-1\n               MOVE 1 TO WORK-INDEX-2\n               PERFORM 177-GET-RKP 4 TIMES\n               MOVE 1 TO WORK-INDEX-1\n               PERFORM 179-GET-MAXLRECL 5 TIMES\n               IF LR-COLS-83-90(3) = '('\n                   MOVE SPACES TO EXCPEXIT-DATA-GROUP\n               ELSE\n                   MOVE 1 TO WORK-INDEX-1\n                   PERFORM 182-GET-EXCPEXIT-DATA 8 TIMES\n           ELSE\n           IF LR-COLS-48-50 = '%CI'\n               MOVE 3 TO WORK-INDEX-1\n               MOVE 1 TO WORK-INDEX-2\n               PERFORM 184-GET-CIFREESP 3 TIMES\n           ELSE\n           IF LR-COLS-48-50 = '%CA'\n               MOVE 3 TO WORK-INDEX-1\n               MOVE 1 TO WORK-INDEX-2\n               PERFORM 185-GET-CAFREESP 3 TIMES\n           ELSE\n           IF LR-COLS-9-17 = 'SHROPTNS('\n               MOVE LR-COLS-18 TO XREGSHR\n               MOVE LR-COLS-20 TO XSYSSHR\n               PERFORM 185-CHECK-DATA-ATTRIBUTES\n           ELSE\n           IF LR-COLS-9-17 = 'SPACE-TYP'\n               PERFORM 212-GET-DATA-ALLOCATION\n           ELSE\n           IF LR-COLS-9-17 = 'VOLSER---'\n               ADD 1 TO VOL-CNT\n               IF VOL-CNT > 5\n                   DISPLAY '--  VSGETDEF CANNOT HANDLE FILES WITH --'\n                   DISPLAY '--  MORE THAN FIVE VOLUMES SPECIFIED  --'\n                   MOVE 12 TO RETURN-CODE\n                   PERFORM 120-SHUTDOWN\n               ELSE\n                   MOVE LR-COLS-27-32 TO DATA-VOLUME(VOL-CNT)\n           ELSE\n           IF LR-COLS-9-17 = 'LOW-KEY--'\n               ADD 1 TO KEYRANGE-CNT\n               MOVE 1 TO KEYRANGE-FLAG WORK-INDEX-1\n               MOVE 0 TO END-OF-KEYRANGE-FLAG KEYRANGE-FIRST-LINE-FLAG\n               MOVE ' ' TO LOW-KEYRANGE-1(KEYRANGE-CNT 1)\n               MOVE '(' TO LOW-KEYRANGE-1(KEYRANGE-CNT 2)\n               MOVE 'X' TO LOW-KEYRANGE-1(KEYRANGE-CNT 3)\n               MOVE '''' TO LOW-KEYRANGE-1(KEYRANGE-CNT 4)\n               MOVE 5 TO KEYRANGE-WORK-CNT\n               PERFORM 215-GET-LOW-KEY UNTIL END-OF-KEYRANGE\n           ELSE\n           IF LR-COLS-9-17 = 'HIGH-KEY-'\n               MOVE 1 TO WORK-INDEX-1\n               MOVE 0 TO END-OF-KEYRANGE-FLAG KEYRANGE-FIRST-LINE-FLAG\n               MOVE ' ' TO HIGH-KEYRANGE-1(KEYRANGE-CNT 1)\n               MOVE 'X' TO HIGH-KEYRANGE-1(KEYRANGE-CNT 2)\n               MOVE '''' TO HIGH-KEYRANGE-1(KEYRANGE-CNT 3)\n               MOVE 4 TO KEYRANGE-WORK-CNT\n               PERFORM 216-GET-HIGH-KEY UNTIL END-OF-KEYRANGE\n           ELSE\n           IF LR-COLS-5-8  = 'INDE'\n               MOVE LR-COLS-18-61 TO INDEX-NAME\n               MOVE 0 TO VOL-CNT\n               PERFORM 180-GET-INDEX-COMPONENT-FIELDS UNTIL\n                   EOF-SYSPRINT.\n           IF NOT EOF-SYSPRINT\n              PERFORM 280-READ-SYSPRINT.\n       176-GET-KEYLEN.\n           IF LR-COLS-25-32(WORK-INDEX-1) = '-'\n               MOVE 0 TO KEYLEN(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    KEYLEN(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       177-GET-RKP.\n           IF LR-COLS-25-32(WORK-INDEX-1) = '-'\n               MOVE 0 TO RKP(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    RKP(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       178-GET-AVGLRECL.\n           IF LR-COLS-57-61(WORK-INDEX-1) = '-'\n               MOVE 0 TO AVGLRECL(WORK-INDEX-1)\n           ELSE\n               MOVE LR-COLS-57-61(WORK-INDEX-1) TO\n                    AVGLRECL(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       179-GET-MAXLRECL.\n           IF LR-COLS-57-61(WORK-INDEX-1) = '-'\n               MOVE 0 TO MAXLRECL(WORK-INDEX-1)\n           ELSE\n               MOVE LR-COLS-57-61(WORK-INDEX-1) TO\n                    MAXLRECL(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       180-GET-INDEX-COMPONENT-FIELDS.\n           IF LR-COLS-9-17 = 'KEYLEN---'\n               MOVE 1 TO WORK-INDEX-1\n               PERFORM 217-GET-CISIZE-INDEX 5 TIMES\n           ELSE\n           IF LR-COLS-9-17 = 'RKP------'\n               IF LR-COLS-83-90(3) = '('\n                   MOVE SPACES TO EXCPEXIT-INDEX-GROUP\n               ELSE\n                   MOVE 1 TO WORK-INDEX-1\n                   PERFORM 218-GET-EXCPEXIT-INDEX 8 TIMES\n           ELSE\n           IF LR-COLS-9-17 = 'SHROPTNS('\n               IF LR-COLS-96-102 = 'NOREPLI'\n                   MOVE 'NOREPLICATE' TO REPLICATE\n               ELSE\n                   MOVE 'REPLICATE' TO REPLICATE\n           ELSE\n           IF LR-COLS-9-17 = 'SPACE-TYP'\n               PERFORM 220-GET-ALLOCATION-INDEX\n           ELSE\n           IF LR-COLS-9-17 = 'VOLSER---'\n               MOVE 1 TO WORK-INDEX-1 VOLUME-INDEX-FLAG\n               PERFORM 223-CHECK-VOLUME-INDEX VOL-CNT TIMES\n               IF NEED-VOLUME-INDEX\n                   ADD 1 TO VOL-CNT\n                   IF VOL-CNT > 5\n                     DISPLAY '--  VSGETDEF CANNOT HANDLE FILES WITH --'\n                     DISPLAY '--  MORE THAN FIVE VOLUMES SPECIFIED  --'\n                     MOVE 12 TO RETURN-CODE\n                     PERFORM 120-SHUTDOWN\n                   ELSE\n                       MOVE LR-COLS-27-32 TO\n                            VOLUME-INDEX(VOL-CNT)\n               ELSE\n                   NEXT SENTENCE\n           ELSE\n               IF LR-COLS-5-8  = 'PATH' AND RR-PATH-FLAG = 'Y'\n                       PERFORM 195-GET-PATH-INFO UNTIL EOF-SYSPRINT.\n           IF NOT EOF-SYSPRINT\n               PERFORM 280-READ-SYSPRINT.\n       181-GET-BUFSPACE.\n           IF LR-COLS-83-90(WORK-INDEX-1) = '-'\n               MOVE 0 TO BUFSPACE(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-83-90(WORK-INDEX-1) TO\n                    BUFSPACE(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       182-GET-EXCPEXIT-DATA.\n           IF LR-COLS-83-90(WORK-INDEX-1) = '-'\n               MOVE SPACE TO EXCPEXIT-DATA(WORK-INDEX-1)\n           ELSE\n               MOVE 1 TO EXCPEXIT-DATA-FLAG\n               MOVE LR-COLS-83-90(WORK-INDEX-1) TO\n                    EXCPEXIT-DATA(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       183-GET-CISIZE-DATA.\n           IF LR-COLS-115-119(WORK-INDEX-1) = '-'\n               MOVE 0 TO CISIZE-DATA(WORK-INDEX-1)\n           ELSE\n               MOVE LR-COLS-115-119(WORK-INDEX-1) TO\n                    CISIZE-DATA(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       184-GET-CIFREESP.\n           IF LR-COLS-57-61(WORK-INDEX-1) = '-'\n               MOVE 0 TO CIFREESP(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-57-61(WORK-INDEX-1) TO\n                    CIFREESP(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       185-GET-CAFREESP.\n           IF LR-COLS-57-61(WORK-INDEX-1) = '-'\n               MOVE 0 TO CAFREESP(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-57-61(WORK-INDEX-1) TO\n                    CAFREESP(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       185-CHECK-DATA-ATTRIBUTES.\n           MOVE LR-COLS-25-32-GROUP TO RECOVERY.\n           MOVE LR-COLS-53-61 TO ERASE.\n           IF LR-COLS-67-76 = 'INDEXED   '\n               MOVE 1 TO CLUSTER-TYPE-FLAG\n               MOVE 'INDEXED' TO CLUSTER-TYPE\n           ELSE\n               IF LR-COLS-67-76 = 'NONINDEXED'\n                   MOVE 2 TO CLUSTER-TYPE-FLAG\n                   MOVE 'NONINDEXED' TO CLUSTER-TYPE\n               ELSE\n                   IF LR-COLS-67-76 = 'NUMBERED  '\n                       MOVE 3 TO CLUSTER-TYPE-FLAG\n                       MOVE 'NUMBERED' TO CLUSTER-TYPE\n                   ELSE\n                       IF LR-COLS-67-76 = 'LINEAR'\n                           MOVE 4 TO CLUSTER-TYPE-FLAG\n                           MOVE 'LINEAR' TO CLUSTER-TYPE.\n           IF LR-COLS-81-90 = 'NOWRITECHK'\n               MOVE 'NOWRITECHECK' TO WRITECHECK\n           ELSE\n               MOVE 'WRITECHECK' TO WRITECHECK.\n           MOVE LR-COLS-96-102 TO IMBED.\n           PERFORM 280-READ-SYSPRINT.\n           MOVE LR-COLS-9-17 TO ORDERED.\n           MOVE LR-COLS-25-32-GROUP TO REUSE.\n           MOVE LR-COLS-38-47 TO SPANNED.\n           IF LR-COLS-53-61 = 'UNIQUEKEY'\n               MOVE 'UNIQUEKEY' TO UNIQUEKEY\n           ELSE\n               IF LR-COLS-53-61 = 'ONUNIQKEY'\n                   MOVE 'NONUNIQUEKEY' TO UNIQUEKEY.\n           IF LR-COLS-53-61 = ' CYLFAULT' OR\n              LR-COLS-67-76 = 'CYLFAULT  '\n                   MOVE 'CYLINDERFAULT' TO STAGE\n           ELSE\n               IF LR-COLS-53-61 = '     BIND' OR\n                  LR-COLS-67-76 = 'BIND      '\n                   MOVE LR-COLS-53-61 TO STAGE\n               ELSE\n                   MOVE 1 TO STAGE-FLAG.\n           IF LR-COLS-81-90 = 'DSTGWAIT  ' OR\n              LR-COLS-67-76 = 'DSTGWAIT  ' OR\n              LR-COLS-53-61 = ' DSTGWAIT'\n                   MOVE 1 TO DESTAGE-FLAG.\n       190-WRITE-DEFINE-STATEMENTS.\n           WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-1.\n           IF PROCESSING-AIX\n               WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-4\n               WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-2\n               WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-1\n               WRITE DEFSTMTS-RECORD FROM AIX-STATEMENT\n               WRITE DEFSTMTS-RECORD FROM RELATE-STATEMENT\n               WRITE DEFSTMTS-RECORD FROM UPGRADE-STATEMENT\n               WRITE DEFSTMTS-RECORD FROM UNIQUEKEY-STATEMENT\n           ELSE\n               WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-3\n               WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-2\n               WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-1\n               WRITE DEFSTMTS-RECORD FROM CLUSTER-STATEMENT\n               WRITE DEFSTMTS-RECORD FROM CLUSTER-TYPE-STATEMENT\n               IF NOT CLUSTER-LINEAR\n                   WRITE DEFSTMTS-RECORD FROM SPANNED-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM SHROPTIONS-STATEMENT.\n           IF CLUSTER-INDEXED\n               WRITE DEFSTMTS-RECORD FROM KEYS-STATEMENT.\n           IF NOT CLUSTER-LINEAR\n               WRITE DEFSTMTS-RECORD FROM RECORDSIZE-STATEMENT\n               WRITE DEFSTMTS-RECORD FROM FREESPACE-STATEMENT.\n           IF NEED-PROTECTION-GROUP\n               WRITE DEFSTMTS-RECORD FROM MASTER-PASSWORD-STATEMENT\n               WRITE DEFSTMTS-RECORD FROM ATTEMPTS-STATEMENT.\n           IF NEED-UPDATE-PASSWORD\n               WRITE DEFSTMTS-RECORD FROM UPDATE-PASSWORD-STATEMENT.\n           IF NEED-CONTROL-PASSWORD\n               WRITE DEFSTMTS-RECORD FROM CONTROL-PASSWORD-STATEMENT.\n           IF NEED-READ-PASSWORD\n               WRITE DEFSTMTS-RECORD FROM READ-PASSWORD-STATEMENT.\n           IF NEED-PASSWORD-CODE\n               WRITE DEFSTMTS-RECORD FROM PASSWORD-CODE-STATEMENT.\n           IF NEED-AUTHORIZATION\n               WRITE DEFSTMTS-RECORD FROM AUTHORIZATION-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM BUFSPACE-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM ERASE-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM RECOVERY-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM WRITECHECK-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM ORDER-STATEMENT.\n           IF NEED-STAGE\n               WRITE DEFSTMTS-RECORD FROM STAGE-STATEMENT.\n           IF NEED-DESTAGE\n               WRITE DEFSTMTS-RECORD FROM DESTAGE-STATEMENT.\n           IF NEED-TO\n               WRITE DEFSTMTS-RECORD FROM TO-STATEMENT.\n           IF NEED-OWNER\n               WRITE DEFSTMTS-RECORD FROM OWNER-STATEMENT.\n           IF NEED-KEYRANGE\n               WRITE DEFSTMTS-RECORD FROM KEYRANGE-STATEMENT\n               MOVE 0 TO WORK-INDEX-1\n               PERFORM 211-WRITE-KEYRANGE KEYRANGE-CNT TIMES\n               WRITE DEFSTMTS-RECORD FROM PAREN-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM REUSE-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM DATA-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM DATA-NAME-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM VOLUME-DATA-STATEMENT.\n           IF NEED-EXCPEXIT-DATA\n               WRITE DEFSTMTS-RECORD FROM EXCPEXIT-DATA-STATEMENT.\n           IF NOT CLUSTER-LINEAR\n               WRITE DEFSTMTS-RECORD FROM CISIZE-DATA-STATEMENT.\n           IF CLUSTER-INDEXED OR RR-CATALOG-FLAG = 'Y'\n               MOVE '-' TO ALLOCATION-DATA-DASH\n           ELSE\n               MOVE ' ' TO ALLOCATION-DATA-DASH.\n           WRITE DEFSTMTS-RECORD FROM ALLOCATION-DATA-STATEMENT.\n           IF CLUSTER-INDEXED\n               PERFORM 210-WRITE-INDEX-STATEMENTS.\n           IF RR-CATALOG-FLAG = 'Y'\n               WRITE DEFSTMTS-RECORD FROM CATALOG-STATEMENT.\n           MOVE 0 TO WORK-INDEX-1.\n           PERFORM 192-WRITE-PATH-NAME-STATEMENTS PATH-CNT TIMES.\n       192-WRITE-PATH-NAME-STATEMENTS.\n           ADD 1 TO WORK-INDEX-1.\n           MOVE SAVE-PATH-NAME(WORK-INDEX-1) TO\n                PATH-NAME COMMENT-DSN.\n           WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-1.\n           WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-5.\n           WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-2.\n           WRITE DEFSTMTS-RECORD FROM COMMENT-STATEMENT-1.\n           WRITE DEFSTMTS-RECORD FROM PATH-NAME-STATEMENT.\n           MOVE SAVE-PATH-ENTRY(WORK-INDEX-1) TO PATH-ENTRY.\n           WRITE DEFSTMTS-RECORD FROM PATH-ENTRY-STATEMENT.\n           MOVE SAVE-UPDATE(WORK-INDEX-1) TO UPDATE.\n           IF RR-CATALOG-FLAG = 'Y'\n               MOVE '-' TO UPDATE-DASH\n               WRITE DEFSTMTS-RECORD FROM UPDATE-STATEMENT\n               MOVE SAVE-CATALOG(WORK-INDEX-1) TO CATALOG\n               WRITE DEFSTMTS-RECORD FROM CATALOG-STATEMENT\n           ELSE\n               MOVE ' ' TO UPDATE-DASH\n               WRITE DEFSTMTS-RECORD FROM UPDATE-STATEMENT.\n       195-GET-PATH-INFO.\n           IF LR-COLS-5-8  = 'PATH'\n               ADD 1 TO PATH-CNT\n               IF PATH-CNT > 5\n                 DISPLAY '--  VSGETDEF CANNOT HANDLE FILES WITH --'\n                 DISPLAY '--  MORE THAN FIVE PATHS SPECIFIED    --'\n                 MOVE 12 TO RETURN-CODE\n                 PERFORM 120-SHUTDOWN\n               ELSE\n                   MOVE LR-COLS-18-61 TO SAVE-PATH-NAME(PATH-CNT).\n           IF LR-COLS-9-17 = 'AIX------'\n               MOVE LR-COLS-18-61 TO SAVE-PATH-ENTRY(PATH-CNT)\n           ELSE\n           IF LR-COLS-9-17 = 'CLUSTER--'\n               MOVE LR-COLS-18-61 TO SAVE-PATH-ENTRY(PATH-CNT)\n           ELSE\n           IF LR-COLS-7-12 = 'IN-CAT'\n               MOVE LR-COLS-18-61 TO SAVE-CATALOG(PATH-CNT)\n           ELSE\n           IF LR-COLS-9-17 = 'NOUPDATE '\n               MOVE LR-COLS-9-17 TO SAVE-UPDATE(PATH-CNT)\n           ELSE\n           IF LR-COLS-9-17 = 'UPDATE   '\n               MOVE LR-COLS-9-17 TO SAVE-UPDATE(PATH-CNT).\n           PERFORM 280-READ-SYSPRINT.\n       200-GET-PROTECTION-GROUP.\n           PERFORM 280-READ-SYSPRINT.\n           MOVE 1 TO WORK-INDEX-1 PROTECTION-GROUP-FLAG.\n           PERFORM 201-GET-MASTER-PASSWORD 8 TIMES.\n           IF LR-COLS-54-61(3) NOT = '('\n               MOVE 1 TO WORK-INDEX-1 UPDATE-PASSWORD-FLAG\n               PERFORM 202-GET-UPDATE-PASSWORD 8 TIMES.\n           IF LR-COLS-83-90(3) NOT = '('\n               MOVE 1 TO WORK-INDEX-1 PASSWORD-CODE-FLAG\n               PERFORM 203-GET-PASSWORD-CODE 8 TIMES.\n           PERFORM 280-READ-SYSPRINT.\n           IF LR-COLS-25-32(3) NOT = '('\n               MOVE 1 TO WORK-INDEX-1 CONTROL-PASSWORD-FLAG\n               PERFORM 204-GET-CONTROL-PASSWORD 8 TIMES.\n           IF LR-COLS-54-61(3) NOT = '('\n               MOVE 1 TO WORK-INDEX-1 READ-PASSWORD-FLAG\n               PERFORM 205-GET-READ-PASSWORD 8 TIMES.\n           IF LR-COLS-83-90(7) = '-'\n               MOVE 0 TO ATTEMPTS(1)\n           ELSE MOVE LR-COLS-83-90(7) TO ATTEMPTS(1).\n           IF LR-COLS-83-90(8) = '-'\n               MOVE 0 TO ATTEMPTS(2)\n           ELSE MOVE LR-COLS-83-90(8) TO ATTEMPTS(2).\n           IF LR-COLS-112-119(3) NOT = '('\n               MOVE 1 TO WORK-INDEX-1 AUTHORIZATION-FLAG\n               PERFORM 206-GET-USVR 8 TIMES.\n           PERFORM 280-READ-SYSPRINT.\n           MOVE SPACES TO USAR-GROUP.\n           IF LR-COLS-27-61(1) NOT = '('\n               MOVE 1 TO WORK-INDEX-1\n               PERFORM 207-GET-USAR 35 TIMES.\n       201-GET-MASTER-PASSWORD.\n           IF LR-COLS-25-32(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    MASTER-PASSWORD(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO MASTER-PASSWORD(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       202-GET-UPDATE-PASSWORD.\n           IF LR-COLS-54-61(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-54-61(WORK-INDEX-1) TO\n                    UPDATE-PASSWORD(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO UPDATE-PASSWORD(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       203-GET-PASSWORD-CODE.\n           IF LR-COLS-83-90(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-83-90(WORK-INDEX-1) TO\n                    PASSWORD-CODE(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO PASSWORD-CODE(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       204-GET-CONTROL-PASSWORD.\n           IF LR-COLS-25-32(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    CONTROL-PASSWORD(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO CONTROL-PASSWORD(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       205-GET-READ-PASSWORD.\n           IF LR-COLS-54-61(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-54-61(WORK-INDEX-1) TO\n                    READ-PASSWORD(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO READ-PASSWORD(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       206-GET-USVR.\n           IF LR-COLS-112-119(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-112-119(WORK-INDEX-1) TO\n                    USVR(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO USVR(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       207-GET-USAR.\n           IF LR-COLS-27-61(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-27-61(WORK-INDEX-1) TO\n                    USAR(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO USAR(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       210-WRITE-INDEX-STATEMENTS.\n           WRITE DEFSTMTS-RECORD FROM INDEX-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM INDEX-NAME-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM REPLICATE-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM IMBED-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM VOLUME-INDEX-STATEMENT.\n           WRITE DEFSTMTS-RECORD FROM CISIZE-INDEX-STATEMENT.\n           IF NEED-EXCPEXIT-INDEX\n               WRITE DEFSTMTS-RECORD FROM EXCPEXIT-INDEX-STATEMENT.\n           IF RR-CATALOG-FLAG = 'Y'\n               MOVE '-' TO ALLOCATION-INDEX-DASH\n           ELSE\n               MOVE ' ' TO ALLOCATION-INDEX-DASH.\n           WRITE DEFSTMTS-RECORD FROM ALLOCATION-INDEX-STATEMENT.\n       211-WRITE-KEYRANGE.\n           ADD 1 TO WORK-INDEX-1.\n           WRITE DEFSTMTS-RECORD FROM\n                 LOW-KEYRANGE-DETAIL-1(WORK-INDEX-1).\n           IF LOW-KEYRANGE-1(WORK-INDEX-1 69) = '+'\n               WRITE DEFSTMTS-RECORD FROM\n                     LOW-KEYRANGE-DETAIL-2(WORK-INDEX-1).\n           WRITE DEFSTMTS-RECORD FROM\n                 HIGH-KEYRANGE-DETAIL-1(WORK-INDEX-1).\n           IF HIGH-KEYRANGE-1(WORK-INDEX-1 69) = '+'\n               WRITE DEFSTMTS-RECORD FROM\n                     HIGH-KEYRANGE-DETAIL-2(WORK-INDEX-1).\n       212-GET-DATA-ALLOCATION.\n           IF LR-COLS-25-32-GROUP = 'CYLINDER'\n               MOVE 'CYLINDERS' TO ALLOCATION-TYPE-DATA\n           ELSE\n               MOVE 'TRACKS' TO ALLOCATION-TYPE-DATA.\n           PERFORM 280-READ-SYSPRINT.\n           MOVE 5 TO WORK-INDEX-1.\n           MOVE 1 TO WORK-INDEX-2.\n           PERFORM 213-GET-PRIMARY-DATA 4 TIMES.\n           MOVE 5 TO WORK-INDEX-1.\n           MOVE 1 TO WORK-INDEX-2.\n           PERFORM 214-GET-SECONDARY-DATA 4 TIMES.\n       213-GET-PRIMARY-DATA.\n           IF LR-COLS-25-32(WORK-INDEX-1) = '-'\n               MOVE 0 TO PRIMARY-DATA(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    PRIMARY-DATA(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       214-GET-SECONDARY-DATA.\n           IF LR-COLS-25-32(WORK-INDEX-1) = '-'\n               MOVE 0 TO SECONDARY-DATA(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    SECONDARY-DATA(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       215-GET-LOW-KEY.\n           IF KEYRANGE-WORK-CNT = 69\n               MOVE '+' TO LOW-KEYRANGE-1(KEYRANGE-CNT 69)\n               MOVE 1 TO KEYRANGE-FIRST-LINE-FLAG\n               MOVE SPACE TO LOW-KEYRANGE-2(KEYRANGE-CNT 1)\n               MOVE 2 TO KEYRANGE-WORK-CNT.\n           IF WORK-INDEX-1 = 91\n               PERFORM 280-READ-SYSPRINT\n               IF LR-COLS-9-17 NOT =  '         '\n                   MOVE 1 TO END-OF-KEYRANGE-FLAG\n               ELSE\n                   MOVE 1 TO WORK-INDEX-1\n           ELSE\n               IF LR-COLS-31-120(WORK-INDEX-1) NOT = SPACE\n                   IF KEYRANGE-FIRST-LINE\n                       MOVE LR-COLS-31-120(WORK-INDEX-1) TO\n                            LOW-KEYRANGE-1(KEYRANGE-CNT\n                            KEYRANGE-WORK-CNT)\n                       ADD 1 TO WORK-INDEX-1 KEYRANGE-WORK-CNT\n                   ELSE\n                       MOVE LR-COLS-31-120(WORK-INDEX-1) TO\n                            LOW-KEYRANGE-2(KEYRANGE-CNT\n                            KEYRANGE-WORK-CNT)\n                       ADD 1 TO WORK-INDEX-1 KEYRANGE-WORK-CNT\n               ELSE\n                   IF KEYRANGE-FIRST-LINE\n                       MOVE '''' TO LOW-KEYRANGE-1\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE ' ' TO LOW-KEYRANGE-1\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE '-' TO LOW-KEYRANGE-1\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       MOVE 1 TO END-OF-KEYRANGE-FLAG\n                   ELSE\n                       MOVE '''' TO LOW-KEYRANGE-2\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE ' ' TO LOW-KEYRANGE-2\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE '-' TO LOW-KEYRANGE-2\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       MOVE 1 TO END-OF-KEYRANGE-FLAG.\n       216-GET-HIGH-KEY.\n           IF KEYRANGE-WORK-CNT = 69\n               MOVE '+' TO HIGH-KEYRANGE-1(KEYRANGE-CNT 69)\n               MOVE 1 TO KEYRANGE-FIRST-LINE-FLAG\n               MOVE SPACE TO HIGH-KEYRANGE-2(KEYRANGE-CNT 1)\n               MOVE 2 TO KEYRANGE-WORK-CNT.\n           IF WORK-INDEX-1 = 91\n               PERFORM 280-READ-SYSPRINT\n               IF LR-COLS-9-17 NOT =  '         '\n                   MOVE 1 TO END-OF-KEYRANGE-FLAG\n               ELSE\n                   MOVE 1 TO WORK-INDEX-1\n           ELSE\n               IF LR-COLS-31-120(WORK-INDEX-1) NOT = SPACE\n                   IF KEYRANGE-FIRST-LINE\n                       MOVE LR-COLS-31-120(WORK-INDEX-1) TO\n                            HIGH-KEYRANGE-1(KEYRANGE-CNT\n                            KEYRANGE-WORK-CNT)\n                       ADD 1 TO WORK-INDEX-1 KEYRANGE-WORK-CNT\n                   ELSE\n                       MOVE LR-COLS-31-120(WORK-INDEX-1) TO\n                            HIGH-KEYRANGE-2(KEYRANGE-CNT\n                            KEYRANGE-WORK-CNT)\n                       ADD 1 TO WORK-INDEX-1 KEYRANGE-WORK-CNT\n               ELSE\n                   IF KEYRANGE-FIRST-LINE\n                       MOVE '''' TO HIGH-KEYRANGE-1\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE ')' TO HIGH-KEYRANGE-1\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE ' ' TO HIGH-KEYRANGE-1\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE '-' TO HIGH-KEYRANGE-1\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       MOVE 1 TO END-OF-KEYRANGE-FLAG\n                   ELSE\n                       MOVE '''' TO HIGH-KEYRANGE-2\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE ')' TO HIGH-KEYRANGE-2\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE ' ' TO HIGH-KEYRANGE-2\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       ADD 1 TO KEYRANGE-WORK-CNT\n                       MOVE '-' TO HIGH-KEYRANGE-2\n                                (KEYRANGE-CNT KEYRANGE-WORK-CNT)\n                       MOVE 1 TO END-OF-KEYRANGE-FLAG.\n       217-GET-CISIZE-INDEX.\n           IF LR-COLS-115-119(WORK-INDEX-1) = '-'\n               MOVE 0 TO CISIZE-INDEX(WORK-INDEX-1)\n           ELSE\n               MOVE LR-COLS-115-119(WORK-INDEX-1) TO\n                    CISIZE-INDEX(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       218-GET-EXCPEXIT-INDEX.\n           IF LR-COLS-83-90(WORK-INDEX-1) = '-'\n               MOVE SPACE TO EXCPEXIT-INDEX(WORK-INDEX-1)\n           ELSE\n               MOVE 1 TO EXCPEXIT-INDEX-FLAG\n               MOVE LR-COLS-83-90(WORK-INDEX-1) TO\n                    EXCPEXIT-INDEX(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       220-GET-ALLOCATION-INDEX.\n           IF LR-COLS-25-32-GROUP = 'CYLINDER'\n               MOVE 'CYLINDERS' TO ALLOCATION-TYPE-INDEX\n           ELSE\n               MOVE 'TRACKS' TO ALLOCATION-TYPE-INDEX.\n           PERFORM 280-READ-SYSPRINT.\n           MOVE 5 TO WORK-INDEX-1.\n           MOVE 1 TO WORK-INDEX-2.\n           PERFORM 221-GET-PRIMARY-INDEX 4 TIMES.\n           MOVE 5 TO WORK-INDEX-1.\n           MOVE 1 TO WORK-INDEX-2.\n           PERFORM 222-GET-SECONDARY-INDEX 4 TIMES.\n       221-GET-PRIMARY-INDEX.\n           IF LR-COLS-25-32(WORK-INDEX-1) = '-'\n               MOVE 0 TO PRIMARY-INDEX(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    PRIMARY-INDEX(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       222-GET-SECONDARY-INDEX.\n           IF LR-COLS-25-32(WORK-INDEX-1) = '-'\n               MOVE 0 TO SECONDARY-INDEX(WORK-INDEX-2)\n           ELSE\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    SECONDARY-INDEX(WORK-INDEX-2).\n           ADD 1 TO WORK-INDEX-1 WORK-INDEX-2.\n       223-CHECK-VOLUME-INDEX.\n           IF LR-COLS-27-32 = VOLUME-INDEX(WORK-INDEX-1)\n               MOVE 0 TO VOLUME-INDEX-FLAG.\n           ADD 1 TO WORK-INDEX-1.\n       259-GET-OWNER.\n           IF LR-COLS-25-32(WORK-INDEX-1) NOT = '-'\n               MOVE LR-COLS-25-32(WORK-INDEX-1) TO\n                    OWNER(WORK-INDEX-1)\n           ELSE\n               MOVE SPACE TO OWNER(WORK-INDEX-1).\n           ADD 1 TO WORK-INDEX-1.\n       260-CHECK-EXPIRATION-DATE.\n           IF LR-COLS-54-57 NOT = '0000'\n               MOVE LR-COLS-54-57 TO TO-YEAR\n               MOVE LR-COLS-59-61 TO TO-DAY\n               MOVE 1 TO TO-FLAG.\n       270-READ-REQUESTS.\n           READ REQUESTS AT END\n                MOVE '1' TO EOF-REQUESTS-FLAG.\n       280-READ-SYSPRINT.\n           READ SYSPRINT INTO LISTC-RECORD AT END\n                MOVE '1' TO EOF-SYSPRINT-FLAG.\n\nErnie Ishman\nSenior Systems Programmer\nGeisinger System Services (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A003A02": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x047\\x047\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 1079, "newlines": 1079, "modlines": 0, "user": "VSAMUPD"}, "text": "Displaying VSAM information\n\nWe use this program to find out if any of our VSAM files\nshould be reorganized.  The files are displayed in green,\nyellow, or red.  The program also creates a list which contains\nsome of the information.  We update the lists every morning.\n\nFigure 1 shows an example of the menu, Figure 2 shows a file\ndisplay, and Figure 3 shows a display for a specified file.\n\nThe colours mean:\n\no      Green   - file is OK\n\no      Yellow - file should be examined and perhaps reorganized\n\n\no      Red      - file should be reorganized.\n\nThese colours are set to our own specifications and can be\nchanged in the program VSAMCALC.\n\nThe program can also create a list of how many tracks are\nassigned to a volume on a catalog and how many of these are\nused and how many are free.\n\nThe programs that update the lists are running on a machine\n(LISTCAT) that is autologged every morning.  Their names\nare:\n\no      PROFILE EXEC\n\no      MAKECAT EXEC\n\no      LISTCAT EXEC\n\no      SPACECAL EXEC\n\no      VSAMCALC EXEC\n\no      TEMPDISK EXEC\n\no      LISTCALL AMSERV\n\no      LISTCSPA AMSERV.\n\nThe TEMPDISK EXEC creates a temporary disk, but if one\nhas already been created and its size is equal to or greater than\nthe requested size, it is simply re-accessed using the ERASE\noption.\n\nThe other programs, VCAT EXEC and VCATPROF XEDIT,\nare placed on a general disk.  The TEMPDISK EXEC can also\nbe placed on the general disk; it could be useful for other users.\n\nThe display has a search field where you can type part of a\nVSAM name and/or colour and/or the volser.  The colours\nmust be specified as *GRE, *YEL, or *RED.  The volser must\nbe specified as VOL=volser.  If more than one of the options\nare entered they must be separated by a comma.  The cursor\nmust be placed at the catalog you wish to display.  You can\nalso enter catalog and search together with VCAT command, ie\nVCAT catalog search.\n\nTo update catalog information enter:\n\n      MAKECAT catalog ALL\n\nTo update space information lists enter:\n\n      MAKECAT catalog SPACE\n\nWe autolog the LISTCAT machine the following way:\n\no      CP AUTOLOG LISTCAT password WEEKLY - This will\n      run a MAKECAT ALL and a MAKECAT SPACE for all\n      our catalogs.  We also print the lists weekly.\n\no      CP AUTOLOG LISTCAT password DAILY - This will\n      run a MAKECAT ALL for all our catalogs.\n\nThe PROFILE EXEC on the LISTCAT machine controls this.\n\nNote: the LISTCAT machine has two mini-disks and the\nVCAT EXEC links to its E disk (300).\n\nExample of the directory definition for the LISTCAT machine:\n\nUSER LISTCAT passw 3M 3M G\n...\n...\nMDISK 191 3380 001 005 volid rpass wpass mpass\nMDISK 300 3380 006 003 volid ALL   wpass mpass\n\nOur system is VM/SP 5.0 HPO, VSE/SP 4.1.0.\n\n\nPROFILE EXEC\n\n/**  Profile for the LISTCAT machine                                 **/\n'ACC 300 E'\n/**  Check for AUTOLOG                                               **/\n Parse Value Diag(8,'QUERY' Userid()) With . . Check '15'X\n If Check <> 'DSC' Then Exit\n/**  If we get here we have been autologged                          **/\n'CP PURGE PRT ALL'\n Parse Pull Command\n If Command <> 'DAILY' & Command <> 'WEEKLY' Then Signal Exit\n'EXEC MAKECAT PP1    ALL'\n'EXEC MAKECAT PP2    ALL'\n'EXEC MAKECAT PP3    ALL'\n'EXEC MAKECAT EGUCAT ALL'\n'EXEC MAKECAT VSESP  ALL'\n If Command = 'DAILY' Then Signal Exit\n'PRINT PP1    LISTING A'\n'PRINT PP2    LISTING A'\n'PRINT PP3    LISTING A'\n'PRINT EGUCAT LISTING A'\n'PRINT VSESP  LISTING A'\n'EXEC MAKECAT PP1    SPACE'\n'EXEC MAKECAT PP2    SPACE'\n'EXEC MAKECAT PP3    SPACE'\n'EXEC MAKECAT EGUCAT SPACE'\n'EXEC MAKECAT VSESP  SPACE'\n'PRINT PP1    SPACE   A (CC'\n'PRINT PP2    SPACE   A (CC'\n'PRINT PP3    SPACE   A (CC'\n'PRINT EGUCAT SPACE   A (CC'\n'PRINT VSESP  SPACE   A (CC'\nExit:\n'CP LOGOFF'\n\n\nMAKECAT EXEC\n\n/** MAKECAT: Make catalog informations. ALL or SPACE.                **/\n Arg Cat Function\n'EXEC LISTCAT' Cat Function\n If Rc <> 0 Then Exit Rc\n If Function = 'ALL'   Then 'EXEC VSAMCALC' Cat\n If Function = 'SPACE' Then 'EXEC SPACECAL' Cat\n\n\nLISTCAT EXEC\n\n/** LISTCAT: Run listcat for a specific catalog.                     **/\n Arg Cat Function\n Amserv =\n If Function = 'SPACE' Then Amserv = 'LISTCSPA'\n If Function = 'ALL'   Then Amserv = 'LISTCALL'\n If Amserv = ' ' Then Exit\n'SET DOS ON (VSAM'\n Select\n    When Cat = 'PP1'     Then Do\n         Call Mast_Setup 'VSEIPO VSEIPO 144'\n         Input = 'PP1.USER.CATALOG    VSEIPO  VSEIPO  146'\n         End\n    When Cat = 'PP2'     Then Do\n         Call Mast_Setup 'VSEIPO VSEIPO 144'\n         Input = 'PP2.USER.CATALOG    VSEIPO  VSEIPO  145'\n         End\n    When Cat = 'PP3'     Then Do\n         Call Mast_Setup 'VSEIPO VSEIPO 144'\n         Input = 'PP3.USER.CATALOG    VSEIPO  VSEIPO  147'\n         End\n    When Cat = 'EGUCAT'  Then Do\n         Call Mast_Setup 'VSEIPO VSEIPO 144'\n         Input = 'EGUCAT.USER.CATALOG VSEOKO  VSEOKO  244'\n         End\n    When Cat = 'VSESP'   Then Do\n         Call Mast_Setup 'VSETEST VSETEST 24E'\n         Input = 'VSESP.USER.CATALOG  VSETEST VSETEST 24F'\n         End\n    Otherwise\n         Say 'Unknown catalog name'\n         Exit 100\n    End\n Parse Value Input With Vsamname UserSys UserPass UserCuu\n'CP LINK' UserSys UserCuu '146 RR' UserPass\n'ACCESS 146 O'\n'ASSGN SYS146 O'\n'DLBL IJSYSUC O DSN' Vsamname '(VSAM SYS146 BUFSP 3584'\n'EXEC TEMPDISK 30'\n'REL 191'                      /* Release A disk                      */\n'ACC 100 A'                    /* Access tempdisk as A                */\n'AMSERV' Amserv   Cat          /* AMSERV will write to first R/W disk */\n'ACC 191 A'                    /* Restore disks                       */\n'ACC 100 T'\n'DLBL * CLEAR'\n'SET DOS OFF'\n'REL 144 (DET'\n'REL 146 (DET'\nExit\nMast_Setup:\n      Parse Arg MasterSys MasterPass MasterCuu\n     'REL 144 (DET'\n     'CP LINK' MasterSys MasterCuu '144 RR' MasterPass\n     'ACCESS 144 N'\n     'ASSGN SYSCAT N'\n     'DLBL IJSYSCT N DSN VSAM MASTER CATALOG (SYSCAT VSAM'\n      Return\n\n\nSPACECAL EXEC\n\n/** This EXEC calculates the space used on a specific volume.        **/\n          Parse Arg Catalog .\n          Input_File  = Catalog 'LISTING T'\n          Output_File = Catalog 'SPACE A'\n          Line.1 = '1VOLUME  EXT. TOTAL-TRK  USED-TRK  FREE-TRK'\n          Count = 1\nAgain:\n          Total_T_Trk = 0\n          Total_U_Trk = 0\n          Total_Ext   = 0\n/** Find VOLUME id.                                                  **/\n       'EXECIO * DISKR' Input_File '(ZONE 2 7 MARGINS 18 23 LO /VOLUME/'\n          If Rc <> 0 Then Do\n            'ERASE' Output_File\n            'EXECIO' Count 'DISKW' Output_File '(FINIS STEM LINE.'\n             Exit\n             End\n          Pull .\n          Pull Vol_Id\n/** Find dataspaces.                                                **/\n          'EXECIO * DISKR'\n                 Input_File '(ZONE 96 103 MARGINS 117 119 LO /DATASPCS/'\n          Pull .\n          Pull Spaces\n          Spaces = Reform(Spaces)\n/** Is spaces not 0, find number of extents.                         **/\n          If Spaces = 0 Then Signal MakeLine\n          Spa_Count = 0\nLocExt:\n     'EXECIO * DISKR' Input_File '(ZONE 9 15 MARGINS 30 32 LO /EXTENTS/'\n          Pull .\n          Pull Extents\n          Extents = Reform(Extents)\n          Total_Ext = Total_Ext + Extents\n          Ext_Count = 0\n/** Find number of tracks.                                           **/\nLocTrk:\n      'EXECIO * DISKR' Input_File '(ZONE 9 14 MARGINS 28 32 LO /TRACKS/'\n          Pull .\n          Pull T_Tracks\n          T_Tracks = Reform(T_Tracks)\n          Total_T_Trk = Total_T_Trk + T_Tracks\n      'EXECIO * DISKR' Input_File '(ZONE 9 14 MARGINS 28 32 LO /TRACKS/'\n          Pull .\n          Pull U_Tracks\n          U_Tracks = Reform(U_Tracks)\n          Total_U_Trk = Total_U_Trk + U_Tracks\n          Ext_Count = Ext_Count + 1\n          If Ext_Count < Extents Then Signal LocTrk\n          Spa_Count = Spa_Count + 1\n          If Spa_Count < Spaces  Then Signal LocExt\n/** Make one more output line.                                       **/\nMakeLine:\n          Free_Track  = Total_T_Trk - Total_U_Trk\n          Total_Ext   = Right(Total_Ext,4)\n          Total_T_Trk = Right(Total_T_Trk,10)\n          Total_U_Trk = Right(Total_U_Trk,9)\n          Free_Track  = Right(Free_Track,9)\n          Count = Count + 1\n          Line.Count = ' 'Vol_id Total_Ext Total_T_Trk Total_U_Trk Free_Track\n          Signal Again\nReform:\n         Parse Arg Input , Start , Length\n         If Start  = ' ' Then Start = 1\n         If Length = ' ' Then Length = Length(Input)\n         Input = Abs(Translate(Substr(Input,Start,Length),'0','-'))\n         Return Input\n\n\nVSAMCALC EXEC\n\n/** Creates xxxxxxxx VSAM files.                                     **/\n         Arg Catalog .\n         Output_File  = Catalog 'VSAM E'\n         Listing_File = Catalog 'LISTING A'\n         LineCount = 47\n         LineCheck = LineCount - 1\n         Prt_Count =  0\n         PageCount =  0\n         Count     =  0\n         Red       =  0\n         Yel       =  0\n         Gre       =  0\n         CatLine   =\n         CatLine.  =\n         IndexLine =\n         Calc. =\n         Calc.512    = 46\n         Calc.1024   = 31\n         Calc.1536   = 23\n         Calc.2048   = 18\n         Calc.2560   = 15\n         Calc.3072   = 13\n         Calc.3584   = 11\n         Calc.4096   = 10\n         Calc.4608   = 9\n         Calc.5120   = 8\n         Calc.5632   = 7\n         Calc.6144   = 7\n         Calc.6656   = 6\n         Calc.7168   = 6\n         Calc.7680   = 5\n         Calc.8192   = 5\n         Calc.10240  = 4\n         Calc.12288  = 3\n         Calc.14336  = 3\n         Calc.16384  = 2\n         Calc.18432  = 2\n         Calc.20480  = 2\n         Calc.22528  = 2\n         Calc.24576  = 1\n         Calc.26624  = 1\n         Calc.28672  = 1\n         Calc.30720  = 1\n         Calc.32768  = 1\n         PrtHeader   = '1'Left('CLUSTER NAME',41) ,\n                'EXTENTS  TRACKS FREE-TRACKS  RECORDS   CREATE   VOLUME'\n/**  Read the input file - Stop if 'IDC0002'.                        **/\nAgain:\n        'EXECIO 1 DISKR' Catalog 'LISTING T (VAR INLIN'\n         If Rc <> 0 Then Exit Rc\n         Art  = Substr(Inlin,2,7)\n         ArtX = Substr(Inlin,5,7)\n         If Art  = 'CLUSTER' | Art = 'AIX ---' Then Do\n            Call Get_Name\n            Call Locate 'DATA  5 9 * *'\n            Pull Inline\n            Data_Name = Strip(Substr(Inline,18,44))\n            Call Get_Info\n            Call Make_Prtline\n            C_Extent = Extent\n            C_Ttrack = Ttrack\n            Maxnote = '-.'\n            PrtNote = '-.'\n            If Ttrack <> 0 Then Call Check 'C'\n            If PrtNote = '-;' Then Do\n               PrtSaveLine = '+'Substr(PrtLine.Prt_Count,2)\n               Do 3\n                  Prt_Count = Prt_Count + 1\n                  PrtLine.Prt_Count = PrtSaveline\n                  End\n               End\n            C_Note  = Maxnote\n            Catline = ClustName C_Note || Data_Name Extent Ttrack ,\n                                        Ftrack Trec Spci Spca Fsci Fsca\n            Catline = Catline Keylen Rkp Avglrecl MaxLrecl ,\n                                      Ci_Pr_Ca Ci SpcType SpcPri SpcSec\n            Catline = Catline Buffersp Attributes Create Volser\n            Catline = Space(Catline,1)\n            End\n         If ArtX = 'INDEX -' Then Do\n            IndexName = Strip(Substr(Inlin,18,44))\n            Call Get_Info\n            Maxnote = '-.'\n            If Ttrack <> 0 Then Do\n               If Find(Attributes,'IMBED') <> 0 Then Do\n                  Extent = Extent - C_Extent\n                  Ttrack = Ttrack - C_Ttrack\n                  End\n               Call Check 'I'\n               End\n            I_Note  = Maxnote\n            IndexLine = I_Note || IndexName Levels Extent Ttrack ,\n                                        Ftrack Trec Ci_Pr_Ca Ci Spctype\n         IndexLine = IndexLine Spcpri spcsec Buffersp Volser Attributes\n            End\n         If Art <> 'IDC0002' Then Signal Again\n         Call Makeline\n         Catline.1 = Red Yel Gre\n        'ERASE' Output_File\n        'EXECIO' Count 'DISKW' Output_File '(FINIS STEM CATLINE.'\n         If Rc <> 0 Then Do\n            Say 'Error' Rc 'writing' Output_File 'to disk.'\n           'ERASE' Output_File\n            Exit\n            End\n        'ERASE' Listing_File\n        'EXECIO' Prt_Count 'DISKW' Listing_File '(FINIS STEM PRTLINE.'\n         If Rc <> 0 Then Do\n            Say 'Error' Rc 'writing' Listing_File 'to disk.'\n           'ERASE' Listing_File\n            Exit\n            End\n         Exit\nGet_Name:\n         Call Makeline\n         IndexLine =\n         ClustName = Substr(Inlin,18,44)\n         Chk.    = 'N'\n         Call Locate 'CREATION 38 45 56 61'\n         Pull Create .\n         Return\nGet_Info:\n         Ttrack  = 0\n         Ftrack  = 0\n         Call Locate 'CISIZE 96 101 * *'\n         Pull Inline\n         Ci       = Reform(Inline,115,5)\n         Keylen   = Reform(Inline,25,8)\n         Avglrecl = Reform(Inline,57,5)\n         Buffersp = Reform(Inline,84,7)\n         Call Locate 'RKP---- 9 15 * *'\n         Pull Inline\n         Rkp      = Reform(Substr(Inline,25,8))\n         Maxlrecl = Reform(Substr(Inline,57,5))\n         Ci_Pr_Ca = Reform(Substr(Inline,116,4))\n         Call Attri\n         Call Locate 'REC-TOT 9 15 * *'\n         Pull Inlin\n         Trec    = Reform(Substr(Inlin,25,8))\n         Spci    = Reform(Substr(Inlin,58,4))\n         Call Locate 'EXTENTS 67 73 * *'\n         Pull Inlin\n         Extent = Reform(Substr(Inlin,88,3))\n         Spca    = Reform(Substr(Inlin,59,3))\n         Levels  = Reform(Substr(Inlin,115,5))\n         Call Locate 'FREESPACE-%CI 38 50 60 61'\n         Pull Fsci\n         Fsci = Reform(Fsci)\n         Call Locate 'FREESPACE-%CA 38 50 60 61'\n         Pull Fsca\n         Fsca = Reform(Fsca)\n         If Extent = 0 Then Signal Vol_Loc\n         Call Locate 'FREESPC 38 44 53 61'\n         Pull Fsb\n         Fsb = Reform(Fsb)\n         If Fsb = 0 Then Signal Vol_Loc\n         If Ci  = 0 Then Signal Vol_Loc\n/**              Calculate number of free tracks.                    **/\n         Ftrack = (Fsb % Ci) % Calc.Ci\nVol_Loc:\n         Call Locate 'SPACE-TYPE 9 18 19 32'\n         Pull SpcType\n         SpcType = Strip(Translate(SpcType,' ','-'))\n         Call Locate 'SPACE-PRI 9 17 25 32'\n         Pull SpcPri\n         SpcPri = Strip(Translate(SpcPri,' ','-'))\n         Call Locate 'SPACE-SEC 9 17 25 32'\n         Pull SpcSec\n         SpcSec = Strip(Translate(SpcSec,' ','-'))\n         Call Locate 'VOLSER 9 14 27 32'\n         Pull Volser .\n         If Extent <> 0 Then Do A=1 To Extent By 1\n            Call Locate 'TRACKS 67 72 86 91'\n            Pull Atrack .\n            Ttrack = Ttrack + Reform(Atrack)\n            End\n         Return\n/**                     S u b r o u t i n e s                        **/\nCheck:   Parse Arg Check_Type\n         Note    = '-.'\n         If Extent > 2      Then Call SetNote ','\n         If Extent > 4      Then Call SetNote ';'\n         Extent = Note || Strip(Extent)\n         Note   = '-.'\n         If Ttrack <> 1 & Ttrack = Ftrack Then Call SetNote ','\n         Ttrack = Note || Strip(Ttrack)\n         Ftrack = Note || Strip(Ftrack)\n         Note   = '-.'\n         If Ftrack  > 45     Then Call SetNote ','\n         If Ftrack  > 75     Then Call SetNote ';'\n         If Note <> '-.' Then FTrack = Note || Stirp(Substr(FTrack,3))\n         If Check_Type = 'I' Then Do\n            If Levels = 3  Then Call SetNote ','\n            If Levels > 3  Then Call SetNote ';'\n            Levels = Note || Strip(Levels)\n            Return\n            End\n         PrtNote = MaxNote\n         Note    = '-.'\n         If Spci > 10  Then Call SetNote ','\n         If Spci > 30  Then Call SetNote ';'\n         Spci    = Note || Strip(Spci)\n         Note    = '-.'\n         If Spca > 5   Then Call SetNote ','\n         If Spca > 15  Then Call SetNote ';'\n         Spca    = Note || Strip(Spca)\n         Return\nMakeLine:\n         Select\n            When C_Note = '-;' Then MaxNote = '-;'\n            When I_Note = '-;' Then MaxNote = '-;'\n            When C_Note = '-,' Then MaxNote = '-,'\n            When I_Note = '-,' Then MaxNote = '-,'\n            Otherwise MaxNote = '-.'\n            End\n         Count = Count + 1\n         If Count = 1 Then Return\n         CatLine.Count = MaxNote || CatLine IndexLine\n         IndexLine =\n         If MaxNote = '-;' Then Red = Red + 1\n         If MaxNote = '-,' Then Yel = Yel + 1\n         If MaxNote = '-.' Then Gre = Gre + 1\n         Return\nMake_Prtline:\n         Prt_Prefix = ' '\n         Prt_Count = Prt_Count + 1\n         LineCheck = LineCheck + 1\n         If LineCheck = LineCount Then Do\n            PageCount = PageCount + 1\n            PrtLine.Prt_Count = PrtHeader ,\n                '  CATALOG:' Left(Catalog,10) 'PAGE' Right(PageCount,4)\n            Prt_Count = Prt_Count + 1\n            Prt_Prefix = '0'\n            Linecheck  =  0\n            End\n         Prt_Extent = Right(Abs(Extent),4)\n         Prt_Ttrack = Right(Abs(Ttrack),7)\n         Prt_Ftrack = Right(Abs(Ftrack),11)\n         Prt_Trec   = Right(Abs(Trec),8)\n         PrtLine.Prt_Count = Prt_Prefix || ClustName Prt_Extent,\n                   Prt_Ttrack PrT_Ftrack Prt_Trec'   'Create'   'Volser\n         Return\nSetNote: Parse Arg Note\n         Note = '-'Note\n         If MaxNote = '-;' Then Return\n         MaxNote = Note\n         Return\nReform:\n         Parse Arg Input , Start , Length\n         If Start  = ' ' Then Start = 1\n         If Length = ' ' Then Length = Length(Input)\n         If Substr(Input,Start,Length) = ' ' Then Return ' '\n         Input = Abs(Translate(Substr(Input,Start,Length),'0','-'))\n         Return Input\nLocate:  Parse Arg Locate Zon1 Zon2 Marg1 Marg2\n         If Zon1  <> '*' Then Zone = 'ZONE' Zon1 Zon2\n                         Else Zone = ' '\n         If Marg1 <> '*' Then Marg = 'MARGINS' Marg1 Marg2\n                         Else Marg = ' '\n        'EXECIO * DISKR' Catalog 'LISTING T (STRIP' ,\n                                           Zone Marg 'LOCATE #'Locate'#'\n         Pull . Lastread .\n         Return\nAttri:   Call Locate 'SHROPTN 9 15 2 130'\n         Pull OldLin\nAtr_Again:\n        'EXECIO 1 DISKR' Catalog 'LISTING T' (Lastread+1) ,\n                                              '(MARGINS 2 130 VAR INLIN'\n         If Substr(Inlin,1,7) = '1IDCAMS' Then Do\n            Lastread = Lastread + 2\n            Signal Atr_Again\n            END\n         Attributes = Space('+++' Oldlin Inlin' +++',1)\n         Return\n\n\nTEMPDISK EXEC\n\n/** TEMPDISK - Define (or re-access) a temporary disk.               **/\n/**            Input: Number of cylinder - 10 is default.            **/\nTrace Off\nArg Size\nIf Size = '' Then Size = 10\n'QUERY DISK T (STACK'\n Pull . . Accessed .\n If Accessed <> 'NOT' Then Do\n    Pull Check1 . . Check2 Check3 .\n    Call Check 'TEMP01'\n    End\n Parse Value DiagRc(08,'QUERY VIRTUAL 100') With Rc . . . . Check1,\n                                                        Check2 Check3 .\n If Rc = 0 Then Call Check '(TEMP)'\n'SET CMSTYPE HT'\n'RELEASE 100'\n Parse Value Diag(08,'DETACH 100') With .\n Parse Value DiagRc(08,'DEFINE T3380 100' Size) With Rc . Error\n If Rc <> 0 Then Do\n   'SET CMSTYPE RT'\n    Say Strip(Error)\n    Exit Rc\n    End\n'DESBUF'\n Queue 'YES'\n Queue 'TEMP01'\n'FORMAT 100 T'\n'SET CMSTYPE RT'\n Exit\nCheck:\n    Arg Test1\n    Select\n       When Check1 <> Test1 Then Return\n       When Check2 <> 'R/W' Then Return\n       When Check3 <  Size  Then Return\n       Otherwise\n           'SET CMSTYPE HT'\n           'ACCESS 100 T (ERASE'\n           'SET CMSTYPE RT'\n            Exit\n       End\n\n\nLISTCALL AMSERV\n\n       LISTCAT ALL\n\n\nLISTCSPA AMSERV\n\n       LISTCAT SPACE ALL\n\n\nVCAT EXEC\n\n/**                                                                  **/\n Trace Off\n Arg Selected File\n'SET CMSTYPE HT'\n'GETFMADR'\n Pull . Fm Addr Check .\n If Check <> ' ' Then Do\n   'SET CMSTYPE RT'\n    Say 'No free disk modes.'\n    Exit\n    End\n Parse Value Diagrc(8,'LINK LISTCAT 300' Addr 'RR') With Rc .\n If Rc <> 0 Then Exit Rc\n'ACCESS' Addr Fm'/'Fm\n'SET CMSTYPE RT'\n Parse Value Diag(8,'QUERY SET') With 'EMSG' Emsg ','\n'CP SET EMSG OFF'\n Queue 'MACRO VCATPROF' Fm Selected File\n'XEDIT VCAT' Userid() Fm '(NOPROF'\n Rx = Rc\n'CP SET EMSG' Emsg\n'RELEASE' Addr\n Parse Value Diag(8,'DETACH' Addr) With .\n Exit Rx\n\n\nVCATPROF XEDIT\n\n/* VCATPROF - Profile for VCAT.                                       */\n          Arg Fm Selected Input .\n         'EXTRACT /LSCREEN/'\n         'SET TOFEOF  OFF'\n         'SET CMDLINE OFF'\n         'SET PREFIX  OFF'\n         'SET SCALE   OFF'\n         'SET LINEND  OFF'\n         'SET ENTER   AFTER'\n         'SET REMOTE  ON'\n         'SET MSGLINE ON -3 OVERLAY'\n         'SET MSGMODE ON'\n         'SET CTLCHAR -   ESCAPE'\n         'SET CTLCHAR #   PROTECT BLU NON NOHIGH'\n         'SET CTLCHAR %   PROTECT   HIGH'\n         'SET CTLCHAR \u00ac NOPROTECT RED NON   HIGH'\n         'SET CTLCHAR ` NOPROTECT BLU NON NOHIGH'\n         'SET CTLCHAR ( NOPROTECT WHI NON   HIGH'\n         'SET CTLCHAR )   PROTECT BLU NON NOHIGH'\n         'SET CTLCHAR \\   PROTECT GRE NON NOHIGH'\n         'SET CTLCHAR /   PROTECT YEL NON   HIGH'\n         'SET CTLCHAR +   PROTECT WHI REV   HIGH'\n         'SET CTLCHAR -   PROTECT WHI NON   HIGH'\n          Do A=1 To 24 By 1\n            'SET PF'A 'BEFORE QUIT'\n             End\n          Month.1  = 'Jan'\n          Month.2  = 'Feb'\n          Month.3  = 'Mar'\n          Month.4  = 'Apr'\n          Month.5  = 'May'\n          Month.6  = 'Jun'\n          Month.7  = 'Jul'\n          Month.8  = 'Aug'\n          Month.9  = 'Sep'\n          Month.10 = 'Oct'\n          Month.11 = 'Nov'\n          Month.12 = 'Dec'\n          Catname. =\n          Line.    =\n          Line.5   = '   -+Catalog -# -+Entries-#  -+*RED-#  ',\n                            '-+*YEL-#  -+*GRE-# -+    Last update    -#'\n          Getnum   = 0\n          Curpos1 = '3 12'\n         'LISTFILE * VSAM' Fm '(NOHEADER STACK DATE'\n          If Rc <> 0 Then Do\n             Say 'No VCAT informations found.'\n             Call Exit Rc\n             End\n          Do X=1 To Queued() By 1\n             Pull Catname.X . . . . Size . MM '/' DD '/' YY Up_Time .\n             Catname.X = Left(Catname.X,8)\n             Lcount = X + 5\n             MM = Strip(MM)\n             Up_date = Right(DD,2) Month.MM YY\n             Up_Time = Right(Up_Time,8)\n             Updated.X = Up_date Right(Up_Time,8)\n            'EXECIO 1 DISKR' Catname.X 'VSAM' Fm '1 (FINIS VAR STATUS'\n             Size = Size - 1\n             Parse Value Status With Red_num Yel_num Gre_Num\n             Line.Lcount = '-(_-)' Catname.X'   'Right(Size,7)'-;',\n                             Right(Red_Num,7)'-,'Right(Yel_Num,7)'-.',\n                             Right(Gre_Num,7)'-)  'Up_Date'  'Up_time\n             If Catname.X = Selected Then Do\n                Getnum  = X\n                Curpos1 = X+5 '2'\n                End\n             End\n          Call Check_Input\n          If Getnum <> 0 Then Queue 'CMD'\n/** Display available catalogs                                       **/\nMenu_Start:\n         'SET CTLCHAR .   PROTECT GRE NON NOHIGH'\n         'SET CTLCHAR ,   PROTECT YEL NON NOHIGH'\n         'SET CTLCHAR ;   PROTECT RED NON   HIGH'\n          Pfkeys = '3=Exit'\nMenu:     Call Header\n         'SET RESERVED 3 BLU NON NOHIGH' Search_Line\n          Do X=4 To Lscreen.1-2 By 1\n            'SET RESERVED' X 'BLU NON N' LINE.X\n             End\n         'CURSOR SCREEN' Curpos1\n         'READ NO TAG'\n          Cursor.1 = 0\n          SELECTED =\n          Do Queued()\n             Pull Key Num Pos Input\n             Select\n                When Key = 'PFK' Then Do\n                    'DROPBUF'\n                     If Num = 3 | Num = 15 Then Call Exit 0\n                     End\n                When Key = 'RES' & Num = 3 Then Call Check_Input\n                When Key = 'RES' Then Do\n                     Cursor.1 = Num\n                     Cursor.2 = Pos\n                     End\n                When Key = 'CMD' Then Do\n                     If Cursor.1 = 0 Then 'EXTRACT /CURSOR/'\n                     Curpos1 = Cursor.1 Cursor.2\n                     Getnum = Cursor.1 - 5\n                     SELECTED = CATNAME.GETNUM\n                     If Cursor.1 = All Then Selected = 'ALL'\n                     End\n                Otherwise Nop\n                End\n             End\n          If Selected = ' ' Then Signal Menu\n/** Specific catalog display                                         **/\nCatalog_Ok:\n         'DESBUF'\n          If Search_Error = 'YES' Then Do\n            \"EMSG Error in search field.\"\n             Curpos1 = '3 12'\n             Signal Menu_Start\n             End\n          CATLINES. =\n          Selected   = Strip(Selected)\n          Prefix = '*'\n          If Color = '*RED' Then Prefix = '-;'\n          If Color = '*YEL' Then Prefix = '-,'\n          If Color = '*GRE' Then Prefix = '-.'\n         'EXECIO * DISKR' Selected 'VSAM' FM '2 (FINIS STEM CATLINES.'\n          If Color <> ' ' | File <> ' ' | AskVol <> ' ' Then Do\n             Loops = Catlines.0\n             Match = 0\n             Do Y=1 To Loops\n        Parse Value Catlines.Y With Chk_Name . '+++' . '+++' . Chk_Vol .\n           If Prefix = '*' | Substr(Chk_Name,1,2) = Prefix Then Do\n              If file = ' ' | Pos(File,Substr(Chk_Name,3)) <> 0 Then Do\n                      If Askvol = ' ' | AskVol = Chk_Vol Then Do\n                         Match = Match + 1\n                         MatchLine.Match = Catlines.Y\n                         End\n                      End\n                   End\n                End\n             If Match = 0 Then Do\n       \"EMSG No files in\" Selected \"catalog match the requested search.\"\n                Signal Menu_Start\n                End\n             Catlines. =\n             Catlines.0 = Match\n             Do Y=1 To Match\n                Catlines.Y = Matchline.Y\n                End\n             End\n          CLine   = 0\n          Curpos2 = '3 12'\n          If Catlines.0 = 1 Then Do\n             Curpos2 = '4 2'\n             Queue 'CMD'\n             End\nXtraHead =\nScroll:  'SET CTLCHAR . NOPROTECT GRE NON NOHIGH'\n         'SET CTLCHAR , NOPROTECT YEL NON NOHIGH'\n         'SET CTLCHAR ; NOPROTECT RED NON   HIGH'\n          Pre_Cline = Cline\n          Do X=4 To Lscreen.1-2 By 1\n             Cline = Cline + 1\n            'SET RESERVED' X 'N' Word(CatLines.Cline,1)\n             End\n          If Pre_Cline = 0       Then Pf7 = '     '\n                                 Else Pf7 = '7=Bwd'\n          If Cline >= Catlines.0 Then Pf8 = '     '\n                                 Else Pf8 = '8=Fwd'\n          Pfkeys = Left('3=Return  4=Exit  'Pf7'  'Pf8,47),\n                                            '-\\Updated:' UpDated.Getnum\n          Call Header Selected XtraHead\n         'SET RESERVED 3 BLU NON NOHIGH' Search_Line\n         'CURSOR SCREEN' Curpos2\nCatRead: 'READ NO TAG'\n          Do Queued()\n             Pull Key Num Pos Input\n             Select\n                When Key = 'PFK' Then Do\n                    'DROPBUF'\n                     Curpos2 = '3 12'\n                     If Num > 12 Then Num = Num - 12\n                     If Num = 3 Then Signal Menu_Start\n                     If Num = 4 Then Call Exit 0\n                     If Num = 7 & Pf7 <> ' ' Then Do\n                        Cline = Pre_Cline - (Lscreen.1-5)\n                        If Cline < 1 Then Cline = 0\n                        Signal Scroll\n                        End\n                     If Num = 8 & Pf8 <> ' ' Then Do\n                        If Cline > Catlines.0 Then Cline = Pre_Cline\n                        Signal Scroll\n                        End\n                     End\n                When Key = 'RES' & Num = 3 Then Do\n                     Call Check_Input\n                    'DROPBUF'\n                     Queue 'CMD'\n                     Signal Menu_Start\n                     End\n                When Key = 'CMD' Then Do\n                    'EXTRACT /CURSOR/'\n                     If Cursor.1 > 3 & Cursor.1 < Lscreen.1-1 Then Do\n                        SelLine = Pre_Cline + (Cursor.1-3)\n                        Curpos2 = Cursor.1 Cursor.2\n                        If Catlines.Selline <> ' ' Then Call Specific\n                        End\n                     Cline = Pre_Cline\n                     Signal Scroll\n                     End\n                Otherwise Nop\n                End\n             End\n          Signal CatRead\n/** Detailed display                                                 **/\nSpecific:\n         'SET CTLCHAR .   PROTECT BLU NON NOHIGH'\n         'SET CTLCHAR ,   PROTECT YEL NON NOHIGH'\n         'SET CTLCHAR ;   PROTECT RED NON   HIGH'\nSpecific_Scroll:\n          X = Selline - 1\n          If X > 0 Then Pf7 = '7=File-1'\n                   Else Pf7 = '        '\n          X = Selline + 1\n          If Catlines.X <> ' ' Then Pf8 = '8=File+1'\n                               Else Pf8 = '        '\n          Today  = Insert('.',Date('J'),2)\n          Parse Value Catlines.Selline With,\n                Vsamname,\n                DataName,\n                Ext,\n                Ttrk,\n                Ftrk,\n                Records,\n                CiSp,\n                CaSp,\n                CIfree,\n                CAfree,\n                Keylen,\n                Rkp,\n                Avglrecl,\n                Maxlrecl,\n                Clust_Ci_Pr_Ca,\n                Clust_CiSize,\n                Spctype,\n                Spcpri,\n                Spcsec,\n                Bufsp,\n                '+++' Clust_Attri '+++',\n                Create,\n                Volume,\n                IndexName,\n                Levels,\n                I_Ext,\n                I_Ttrk,\n                I_Ftrk,\n                I_Recs,\n                I_Ci_Pr_Ca,\n                I_Cisize,\n                I_Spctype,\n                I_Spcpri,\n                I_Spcsec,\n                I_BUFSP,\n                I_VOLUME,\n                '+++' Index_Attri '+++'\n          If Substr(DataName,1,2)  = '-.' ,\n                              Then DataName  = '-\\'Substr(DataName,3)\n          If Substr(IndexName,1,2) = '-.' ,\n                              Then IndexName = '-\\'Substr(IndexName,3)\n          Name_Prefix = Substr(Vsamname,1,2)\n          If Name_Prefix = '-.' Then Name_Prefix = '-\\'\n          Vsamname = Left(Substr(Vsamname,3),47)\n          Xtra5. =\n          If Keylen <> 0 Then Do\n             Xtra5.1 = 'Key-length/Offset'\n             Xtra5.2 = Keylen' / 'Rkp\n             End\n          Display = 'DATA'\nData_Index:\n          If Display = 'DATA' Then Do\n             Call Reserve  7 'Record-length Avg/Max' ,\n                       Avglrecl' / 'Maxlrecl , 'CI-Size' , Clust_Cisize\n             Call Reserve  8 Xtra5.1 , Xtra5.2 , 'CI per CA' ,\n                                                         Clust_Ci_Pr_Ca\n             Call Reserve  9 'Records' , Records , 'CI Splits' , CiSp\n             Call Reserve 10 'Extents' , Ext     , 'CA Splits' , CaSp\n             Call Reserve 11 'Tracks'  , Ttrk    , 'CI Free space' ,\n                                                                 CiFree\n             Call Reserve 12 'Free Tracks' , Ftrk , 'CA Free space' ,\n                                                                 CaFree\n             Call Reserve 13 'Allocation Pri/Sec' , SpcPri' / 'Spcsec ,\n                                           'Bufferspace' , Strip(Bufsp)\n             Call Reserve 14 'Allocation Type' , SpcType , 'Volser' ,\n                                                                 Volume\n             Call Reserve 15\n             Call Split_Attri Clust_Attri\n             If Levels <> ' ' Then Pf12 = '12=Index'\n                              Else Pf12 = ' '\n             Point4 = 'WHI NON H'\n             Point5 = 'BLU NON N'\n             End\n          If Display = 'INDEX' Then Do\n             Call Reserve 7  'Levels' , Levels , 'CI-Size' , I_Cisize\n             Call Reserve 8  ' '       ,            , 'CI per CA' ,\n                                                             I_Ci_pr_Ca\n             Call Reserve 9  'Records' , I_Recs , ' ' , ' '\n             Call Reserve 10 'Extents' , I_Ext     , ' ' , ' '\n             Call Reserve 11 'Tracks'  , I_Ttrk    , ' ' , ' '\n             Call Reserve 12 'Free Tracks' , I_Ftrk , ' ' , ' '\n             Call Reserve 13 'Allocation Pri/Sec' ,\n                                      I_Spcpri' / 'I_Spcsec , ' ' , ' '\n             Call Reserve 14 'Allocation Type' , I_Spctype , 'Volser' ,\n                                                               I_Volume\n             Call Reserve 15\n             Call Split_Attri Index_Attri\n             Pf12   = '12=Data'\n             Point4 = 'BLU NON N'\n             Point5 = 'WHI NON H'\n             End\n         'SET RESERVED 3 BLU NON N Cluster....'Name_Prefix'',\n                                        VsamName '-#Create date='Create\n         'SET RESERVED 4' Point4 'Data.......'Left(Dataname,49),\n                                                  '-#Todays date='Today\n          If Levels <> ' ' Then  'SET RESERVED 5' Point5,\n                                                 'Index......'Indexname\n                           Else  'SET RESERVED 5 N'\n         'SET RESERVED  6 GRE NON N' Copies('=',80)\n         'SET RESERVED 16 BLU NON N'\n         'SET RESERVED 17 BLU NON N' Attri1\n         'SET RESERVED 18 BLU NON N' Attri2\n          Do X=19 To (Lscreen.1-2)\n            'SET RESERVED' X 'N'\n             End\n          Pfkeys = Left('3=Return  4=Exit  'Pf7'  'Pf8,\n                                '  'Pf12,47)'-\\Updated:' Updated.Getnum\n          Call Header Selected\n         'CURSOR SCREEN 1 1'\n          Do Forever\n            'READ ALL TAG'\n             Pull Key Lin .\n             If Key = 'PFK' Then Do\n                If Lin > 12 Then Lin = Lin - 12\n                If Lin = 3  Then Return\n                If Lin = 4  Then Call Exit 0\n                If Lin = 7  & Pf7 <> ' ' Then Do\n                   Selline = Selline - 1\n                   Signal Specific_Scroll\n                   End\n                If Lin = 8  & Pf8 <> ' ' Then Do\n                   Selline = Selline + 1\n                   Signal Specific_Scroll\n                   End\n                If Lin = 12 & Levels <> ' ' Then Do\n                   Select\n                      When Display = 'DATA'  Then Display = 'INDEX'\n                      When Display = 'INDEX' Then Display = 'DATA'\n                      Otherwise Nop\n                      End\n                   Signal Data_Index\n                   End\n                End\n             End\n/**                   E n d   o f   p r o g r a m                    **/\nExit:     Arg Rx\n         'DROPBUF'\n         'COMMAND QUIT' Rx\n          Exit Rx\n/**                      S u b r o u t i n e s                       **/\n/** Check input in search field.                                     **/\nCheck_Input:\n          SaveInput = Strip(Input)\n          File   =\n          AskVol =\n          Color  =\n          Search_Error = 'NO'\n          If SaveInput <> ' ' Then Do\n             InputFile = SaveInput','\n             Xpos = Pos(',',Inputfile)\n             Do Until Xpos = 0\n                Parse Value Inputfile With Check ',' Inputfile\n                Xpos = Pos(',',Inputfile)\n                Select\n                   When Color  = ' ' & Check              = '*RED' ,\n                                                   Then Color  = '*RED'\n                   When Color  = ' ' & Check              = '*YEL' ,\n                                                   Then Color  = '*YEL'\n                   When Color  = ' ' & Check              = '*GRE' ,\n                                                   Then Color  = '*GRE'\n                   When AskVol = ' ' & Substr(Check,1,4)  = 'VOL=' ,\n                                          Then AskVol = Substr(Check,5)\n                   When File   = ' ' Then Do\n                        If Check             = '*RED' ,\n                                              Then Search_Error = 'YES'\n                        If Check             = '*YEL' ,\n                                              Then Search_Error = 'YES'\n                        If Check             = '*GRE' ,\n                                              Then Search_Error = 'YES'\n                        If Substr(Check,1,4) = 'VOL=' ,\n                                              Then Search_Error = 'YES'\n                        If Search_Error      = 'NO'   ,\n                                                      Then File = Check\n                        End\n                   Otherwise Search_Error = 'YES'\n                   End\n                End\n             End\n          Search_Line = 'Search -->-('Left(SaveInput,50)'-)'\n          Return\n/** Create top and bottom lines for all pictures.                    **/\nHeader:   Parse Arg Text1 , Text2\n          Text1 = Strip(Text1)\n          Text2 = Strip(Text2)\n          If Text1 <> ' ' Then Text1 = ' - 'Text1\n         'SET RESERVED 1 YEL NON N' Left(Date(),11) ,\n                Center('Vsam catalog display'Text1,53) Right(Time(),11)\n         'SET RESERVED 2 GRE NON N' Copies('=',80)\n         'SET RESERVED -2 GRE NON N' Copies('=',80)\n         'SET RESERVED -1 YEL NON H Pf:' Pfkeys\n          Return\n/** Justify the lines for the detailed display.                      **/\nReserve:  Parse Arg Lnum T1 , D1 , T2 , D2\n          If T1 = ' ' Then F1 = ' '\n                      Else F1 = '.'\n          If T2 = ' ' Then F2 = ' '\n                      Else F2 = '.'\n          If Substr(D1,1,1) <> '-' Then D1 = '-.'D1\n          If Substr(D2,1,1) <> '-' Then D2 = '-.'D2\n         'SET RESERVED' Lnum 'BLU NON N',\n                      Left(Left(T1,28,F1)''D1,44)'-#'Left(T2,28,F2)''D2\n          Return\n/** Split attribute lines - Put as many on first line as possible.   **/\nSplit_Attri:\n          Parse Arg Attributes\n          Temp =\n          Do While Attributes <> ' '\n             Temp = Temp || Word(Attributes,1)' '\n             If Length(Temp) > 79 Then Leave\n             Attri1 = Temp\n             Attributes = Delword(Attributes,1,1)\n             End\n          Attri2 = Strip(Attributes,L)\n          Return\n\nMichael Plannthin (Denmark)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A003A03": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\x90\\x01\\x90\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 400, "newlines": 400, "modlines": 0, "user": "VSAMUPD"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "A003A04": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x9e\\x00\\x9e\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 158, "newlines": 158, "modlines": 0, "user": "VSAMUPD"}, "text": "Generation of diagnose cards for IDCAMS\n\nThis PL/I program creates IDCAMS cards ('DIAGNOSE\nICFCAT VS VVDS' and 'DIAGNOSE VVDS VS ICFCAT) for\nICF catalogs in an MVS system.\n\nThis is useful after a crash on several user catalogs or disks; it\ngreatly reduces the tedious work (searching and editing)\nnecessary to write these diagnose cards for all the volumes\ninvolved in such a situation.\n\nThe program produces a list of all the volumes present in the\nuser catalog.\n\n      IDCAMS:   LISTCAT LEVEL(SYS1.VVDS) NAME CAT(USERCAT)\n\nThen scans this list and writes IDCAMS DIAGNOSE cards.\n\n      IDCAMS:   DIAGNOSE ICFCAT INFILE(INCAT) -\n                 COMPAREDS(SYS1.VVDS.VXXXXXX)\n\nand\n\n               DIAGNOSE VVDS IDS(SYS1.VVDS.VXXXXXX) -\n                 COMPAREDD(INCAT)\n\nNotes:\n\no      The program depends upon the layout of the SYSOUT in\n      IDCAMS, so be careful if you are installing or running a\n      new version.\n\no      It is very easy to rewrite this short program in Assembler\n      or COBOL if you want.\n\no      You can execute the diagnoses in separate jobs if you want\n      to (these functions take a lot of time to complete).\n\n//STODODC1 JOB (,   ***---> PIERRE OUELLET <---***\n//  '256136532',89OD0001),'OUELLET PIERRE',\n//  NOTIFY=ROUP002,CLASS=O,MSGCLASS=A,TIME=(0004,30)\n/*ROUTE PRINT ECRAN\n/*JOBPARM ROOM=523\n//*  DCATVVDS:  DIAGNOSE ICFCAT <---> VVDS\n//DCATVVDS PROC\n//*  LISTCAT:  ASSOCIATIONS CAT/VVDS\n//LISTCAT  EXEC PGM=IDCAMS\n//SYSPRINT DD DUMMY\n//OUT1     DD DSN=&&LISTCV,DISP=(NEW,PASS),\n//         UNIT=VIO,\n//         SPACE=(TRK,(9,9)),DCB=(RECFM=VBA,LRECL=255,BLKSIZE=3600)\n//*  PLIXCLG: START (GENERATION OF DIAGNOSE CARDS (IDCAMS))\n//PLI      EXEC PGM=IEL0AA,PARM='OBJECT,NODECK,AG,MAP',REGION=1024K\n//SYSPRINT DD  DUMMY\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(80,(250,100))\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,\n//             SPACE=(1024,(200,50),,CONTIG,ROUND),DCB=BLKSIZE=1024\n//* ---> PL/I PROGRAM IN YOUR PDS BELOW (OR IN STREAM IF YOU PREFER)\n//SYSIN    DD  DSN=TR40051,ROUP002.JCL(DCATVPLI),DISP=SHR\n//LKED     EXEC PGM=IEWL,PARM='XREF,LIST',COND=(9,LT,PLI),REGION=1256K\n//SYSLIB   DD  DSN=SYS2.PLILIB,DISP=SHR   <--- YOUR PL/I LIBRARY\n//SYSLMOD  DD  DSN=&&GOSET(GO),DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(1024,(50,20,1))\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1024,(200,20)),\n//             DCB=BLKSIZE=1024\n//SYSPRINT DD  DUMMY\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  DUMMY\n//GO       EXEC PGM=*.LKED.SYSLMOD,COND=((9,LT,PLI),(9,LT,LKED)),\n//             REGION=900K\n//SYSPRINT DD  DUMMY\n//PLIDUMP  DD SYSOUT=A\n//SYSUDUMP DD SYSOUT=A\n//SYS100   DD DSN=&&LISTCV,DISP=(OLD,DELETE)\n//SYS201   DD DSN=&&TEMP1,DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//            UNIT=VIO,SPACE=(TRK,(9,9)),DISP=(NEW,PASS)\n//SYS202   DD DSN=&&TEMP2,DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//            UNIT=VIO,SPACE=(TRK,(9,9)),DISP=(NEW,PASS)\n//*  PLIXCLG: END\n//*  DIAGCV:  DIAGNOSE CAT VS VVDS (IDCAMS)\n//DIAGCV EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=A\n//INCAT    DD DSN=&UCAT,DISP=SHR\n//SYSIN    DD DSN=&&TEMP1,DISP=(OLD,DELETE)\n//*  DIAGVC:  DIAGNOSE VVDS VS CAT (IDCAMS)\n//DIAGVC EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=A\n//INCAT    DD DSN=&UCAT,DISP=SHR\n//SYSIN    DD DSN=&&TEMP2,DISP=(OLD,DELETE)\n//       PEND\n//*  ---> THE CATALOG NAME IN 'UCAT=...' AND 'CAT(...)' BELOW\n//RUN    EXEC DCATVVDS,UCAT='ICF.CATA.DEV1'\n//LISTCAT.SYSIN DD *\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(ICF.CATA.DEV1) OUTFILE(OUT1)\n//\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(ICF.CATA.PRO1) OUTFILE(OUT1)\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(ICF.CATA.DEV1) OUTFILE(OUT1)\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(ICF.VCATPROD)  OUTFILE(OUT1)\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(ICF.VCATEST)   OUTFILE(OUT1)\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(ICF.SYSV.REV237) OUTFILE(OUT1)\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(MCATSYS1) OUTFILE(OUT1)\n  LISTCAT LEVEL(SYS1.VVDS) NAME CAT(CATALOG.SYS2RA) OUTFILE(OUT1)\n-VFTEMP:PROC OPTIONS(MAIN);\n0  DCL SYS100 FILE INPUT RECORD;\n   DCL SYS201 FILE OUTPUT RECORD;\n   DCL SYS202 FILE OUTPUT RECORD;\n   DCL SW_SYS100 BIT(1) INIT('0'B);\n0  DCL 1 IN,\n         5 LIBRE1 CHAR(17),\n         5 VVDS CHAR(17),\n         5 LIBRE2 CHAR(221);\n0  DCL 1 OUT1,\n         5 STRING1 CHAR(42)\n           INIT('  DIAGNOSE ICFCAT INFILE(INCAT) COMPAREDS('),\n         5 VVDS CHAR(17),\n         5 STRING2 CHAR(1) INIT(')'),\n         5 STRING3 CHAR(20) INIT(' ');\n0  DCL 1 OUT2,\n         5 STRING1 CHAR(20)\n           INIT('  DIAGNOSE VVDS IDS('),\n         5 VVDS CHAR(17),\n         5 STRING2 CHAR(1) INIT(')'),\n         5 STRING3 CHAR(17) INIT(' COMPAREDD(INCAT)'),\n         5 STRING4 CHAR(25) INIT(' ');\n0  ON ENDFILE(SYS100) SW_SYS100='1'B;\n0  ON ERROR BEGIN;\n     DISPLAY('*** ERR. DCATVVDS ***');\n     ON ERROR SYSTEM;\n     CALL PLIDUMP('TFHCB');\n     STOP;\n   END;\n-  OPEN FILE(SYS100); OPEN FILE(SYS201); OPEN FILE(SYS202);\n   CALL LIRE_SYS100;\n0  DO WHILE (SW_SYS100='0'B);\n     IF SUBSTR(IN.VVDS,1,10)='SYS1.VVDS.' THEN\n     DO;\n0      OUT1.VVDS=IN.VVDS; OUT2.VVDS=IN.VVDS;\n       WRITE FILE(SYS201) FROM(OUT1);\n       WRITE FILE(SYS202) FROM(OUT2);\n     END;\n     CALL LIRE_SYS100;\n   END;\n   CLOSE FILE(SYS100);\n   CLOSE FILE(SYS201); CLOSE FILE(SYS202);\n-  LIRE_SYS100: PROC;\n0    IF SW_SYS100 ='0'B THEN\n     DO;\n       IN=' '; READ FILE(SYS100) INTO(IN);\n     END;\n0  END LIRE_SYS100;\n-  END VFTEMP;\n\nPierre Ouellet\nSystems Programmer\nGovernment of Quebec (Canada)                   c Government of Quebec 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A003A05": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\xa5\\x00\\xa5\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 165, "newlines": 165, "modlines": 0, "user": "VSAMUPD"}, "text": "Deleting uncatalogued VSAM datasets\n\nHave you ever experienced VSAM datasets that could not be\ndeleted because the master or user catalog where the dataset\nwas catalogued had been deleted?  Using ICF catalogs, the\ndataset has entries in the VTOC for both the data and index\nparts of the cluster, and this may result in a lot of unusable\nspace on the volume.\n\nIf you are not able to recatalogue the dataset in another catalog,\nthen, of course, you could back up the volume, create a new\nVTOC, and restore all data except the unwanted dataset.  But\nin most cases this cannot be done during prime-time, and if the\nvolume contains linklist libraries, APF libraries, or other\ncritical datasets, this may not be possible at all (except by\nIPLing another system).\n\nOne way to get rid of the dataset is by zapping the VTOC.\nThis article describes how you can do it.\n\nFirst, you list the VTOC entries for the dataset (both data and\nindex part) in hex dump format, to get the cylinder-track-record\naddress of the format 1 DSCBs, and the contents of the fields\nyou want to change.\n\nThen you run the VTOCZAP1 job to remove the expiration\ndate, to flag the dataset as physical sequential (PS) instead of\nVSAM, to remove the ICF catalog flag, and to remove the\npassword required flag.  After this job, the system believes that\nthe dataset is a straightforward physical sequential dataset (if\nthe dataset has no more than 16 extents), and you can easily\ndelete it in any way you like.\n\nWhen updating the VTOC by AMASPZAP you must answer Y\nto the following message on the system operating console:\n\n      AMA1I7D REPLY Y OR N TO UPDATE VTOC volser cuu jobname.\n\nIf the VSAM dataset has more than 16 extents and you try to\ndelete the dataset at this stage you will get a permanent I/O\nerror message and lose your VTOC index (message: IEC606I\nVTOC INDEX DISABLED ON cuu,volser,.....).  In this case\nyou must run job VTOCZAP2 to reset the extent counter to 16\nand remove a pointer from the format 1 to the two format 3\nDSCBs.  (The format 1 DSCB contains information for the first\nthree extents, and a pointer to a format 3 DSCB which contains\ninformation for 13 additional extents.  In the case of an ICF\ndataset with more than 16 extents, two or more format 3\nDSCBs are linked together, but for other types of dataset 16\nextents is the maximum allowed.)\n\nNow you can delete the dataset, but the additional extents are\nlost, and must be taken care of separately.\n\nThis could be done in two ways.  If the original two format 3\nDSCBs are intact, you could allocate a dummy dataset and fill\nit with enough records to make exactly three extents (to fill the\nextent information in the format 1 DSCB).  Then you can run\njob VTOCZAP3 to update the extent counter to the total\nnumber of extents, update the pointer from the format 1 DSCB\nto the format 3 DSCB, and update the extent sequence numbers\nin the format 3 DSCB.  Now you can delete your dummy\ndataset.\n\nOn one occassion, the original two format 3 DSCBs were\nzeroed out when the VSAM dataset was deleted, therefore I\nallocated a dummy dataset with just one extent.  Then I ran job\nVTOCZAP4 to fill in extent information for two extents at a\ntime.  The extent information (lower and upper limit addresses)\nyou can get from the listing of the original format 3 DSCB.\nAfter deleting the dummy dataset, this must be repeated until\nall extents are taken care of.\n\n//LISTVTOC JOB jobcard info .....\n//LIST     EXEC PGM=IEHLIST\n//SYSPRINT DD SYSOUT=*\n//VOL      DD UNIT=3380,VOL=SER=volser,DISP=SHR\n//SYSIN    DD *\n  LISTVTOC DUMP,VOL=3380=volser,DSN=your.vsam.dataset.DATA\n  LISTVTOC DUMP,VOL=3380=volser,DSN=your.vsam.dataset.INDEX\n/*\n\n//VTOCZAP1 JOB jobcard info .....\n//ZAP      EXEC PGM=AMASPZAP\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=FORMAT4.DSCB,VOL=SER=volser,DISP=OLD,UNIT=3380\n//SYSIN    DD *\n* your.vsam.dataset.DATA\n  CCHHR    0000000109              Address of the format 1 DSCB\n  VER      38    63016D  DS1EXPDT  Expiration date 31.12.99\n  REP      38    000000\n  VER      52    0008    DS1DSORG  DSORG=VSAM\n  REP      52    4000              DSORG=PS\n  VER      55    80      DS1OPTCD  D/S in ICF catalog\n  REP      55    00\n  VER      5D    12      DS1DSIND  Password is required\n  REP      5D    80                Last volume\n* your.vsam.dataset.INDEX\n  CCHHR    000000010A              Address of the format 1 DSCB\n  VER      38   63016D   DS1EXPDT  Expiration date 31.12.99\n  REP      38   000000\n  VER      52   0008     DS1DSORG  DSORG=VSAM\n  REP      52   4000               DSORG=PS\n  VER      55   80       DS1OPTCD  D/S in ICF catalog\n  REP      55   00\n  VER      5D   10       DS1DSIND  Password is required\n  REP      5D   80                 Last volume\n/*\n\n//VTOCZAP2 JOB jobcard info .....\n//ZAP      EXEC PGM=AMASPZAP\n//SYSPRINT DD   SYSOUT=*\n//SYSLIB   DD   DSN=FORMAT4.DSCB,VOL=SER=volser,DISP=OLD,UNIT=3380\n//SYSIN    DD   *\n* your.vsam.dataset.DATA\n  CCHHR    0000000109                Address of the format 1 DSCB\n  VER      3B    14         DS1NOEPV Number of extents on volume\n  REP      3B    10                  Reset to 16 extents\n  CCHHR    0000000223                Address of the 1.format 3 DSCB\n  VER      87    0000000220 DS3PTRDS Pointer to the 2.format 3 DSCB\n  REP      87    0000000000\n/*\n\n//VTOCZAP3 JOB jobcard info .....\n//ZAP      EXEC PGM=AMASPZAP\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=FORMAT4.DSCB,VOL=SER=volser,DISP=OLD,UNIT=3380\n//SYSIN    DD  *\n* your.dummy.dataset with exactly 3 extents\n  CCHHR    0000000109                  Address of the format 1 DSCB\n  VER      3B    03          DS1NOEPV  Number of extents\n  REP      3B    07                    plus 4 extents in format 3 DSCB\n  VER      87    0000000000  DS3PTRDS\n  REP      87    0000000220            Pointer to the disconnected format 3 DSCB\n* FORMAT 3 DSCB\n  CCHHR    0000000220                  Address of the format 3 DSCB\n  VER      05    10                    Extent 17\n  REP      05    03                    Reset to extent 4\n  VER      0F    11                    Extent 18\n  REP      0F    04                    Reset to extent 5\n  VER      19    12                    Extent 19\n  REP      19    05                    Reset to extent 6\n  VER      23    13                    Extent 20\n  REP      23    06                    Reset to extent 7\n/*\n\n//VTOCZAP4 JOB jobcard info .....\n//ZAP      EXEC PGM=AMASPZAP\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=FORMAT4.DSCB,VOL=SER=volser,DISP=OLD,UNIT=3380\n//SYSIN    DD  *\n* your.dummy.dataset with 1 extent\n  CCHHR    0000000109                        Address of the format 1 DSCB\n  VER      3B    01                DS1NOEPV  Number of extents\n  REP      3B    03                          plus 4 extents in format 3 DSCB\n  VER      73    0000,0000,0000,0000,0000    DS1EXT2      Second extent descr.\n  REP      73    0101,0220,0000,0222,000E                 2. byte must be 01\n  VER      7D    0000,0000,0000,0000,0000    DS1EXT3      Third extent descr.\n  REP      7D    0102,028E,0000,0294,000E                 2. byte must be 02\n/*\n\nKjell A Wahl\nSystems Programmer\nOslo Data (Norway)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A003A06": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 30, "newlines": 30, "modlines": 0, "user": "VSAMUPD"}, "text": "IMBED and performance\n\nWhen defining a KSDS (not an ESDS or RRDS) it is possible\nto specify the IMBED parameter.  IMBED, which can be\nshortened to IMBD, affects the sequence set component of an\nindex or an alternate index.  When IMBD is used, the sequence\nset is duplicated around  a track on a disk as many times as it\nwill fit.  The use of IMBD should reduce the amount of time\ntaken to access the data on a disk because, theoretically, it will\ntake less time for the disk to rotate to a position such that the\nheads are over the start of the sequence set.  Once the sequence\nset has been read, the data component can be accessed.  If\nthere was only one copy of the sequence set, the disk would,\non average, have to rotate more before the heads were over the\nstart of the sequence set.  Therefore, IMBD should, in general,\nbe used in preference to the default NOIMBD.\n\nHowever, there is a price to pay for the performance\nimprovements.  If duplicate copies of the sequence set are to be\nmade, more disk space will be used to store the file.  With\nIMBD, the sequence set occupies the whole of the first\nphysical track of the data Control Area.\n\nIf the Control Area allocation is two tracks, the IMBDed\nsequence set will use one of them.  This reduces the effective\ndata CA utilization by 50%.  Therefore, when using IMBD,\nperformance improvements can best be achieved by allocating\nspace for the data component in cylinders.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A003A07": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 12, "newlines": 12, "modlines": 0, "user": "VSAMUPD"}, "text": "Correction\n\nJesse Joyner  has written with a correction to his article Delete\nVSAM user catalog, which was published in issue 1 of VSAM\nUpdate.  The execution JCL has an error in VSAMLIST.  The\nline\n\n      // DLBL IJSYSLS,'VSAM.DEL.SYSLST',1,SD\n\nshould be replaced by:\n\n      // DLBL IJSYSLS,'INFOPAC.SYSLST',1,SD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A004A00I": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\r\\x00\\r\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 13, "newlines": 13, "modlines": 0, "user": "VSAMUPD"}, "text": "A004 - VSAM Update Issue #4 January 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA004A01   Display allocation information for VSAM datasets\nA004A02   The VVDS dissected\nA004A03   Displaying VSAM information - update\nA004A04   Writing to KSDS files from REXX\nA004A05   Printing Control Intervals\nA004A06   Quick listing of VSAM files\nA004A07   Obtaining information about VSAM files\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A004A01": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x026\\x026\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 566, "newlines": 566, "modlines": 0, "user": "VSAMUPD"}, "text": "Display allocation information for VSAM datasets\n\nThe VSAT program is used to display allocation information\nfor all types of VSAM datasets.  VSAT will report on statistics\nusing the Access Method Control Block.  The VSAT listing is\nsimilar to the formatted listing given by the DSAT program\nfrom CBT.  VSAT may be invoked from a LINKLIST library\nthrough either TSO or batch.  On TSO, type in VSAT at the\nREADY prompt or at option 6 (TSO Command Processor) of ISPF.\n\nThe following instructions are displayed for TSO invocations\nonly.\n\nINPUT IS CLUSTER NAME STARTING IN COL 1 W/O QUOTES\n      AND IS ALLOCATED TO SYSIN\nOUTPUT IS ALLOCATED TO SYSOUT\nWHEN YOU ARE FINISHED TYPE IN /* TO END\n\nAs the instructions state, the SYSIN and SYSOUT DDnames\nmust be allocated to the terminal.  At this point you may key in\na VSAM cluster name. You can key in as many cluster names\nas necessary.  When you have finished, key in /* to end the\nprogram input.\n\nIf CISV.PROD.MXRF is the cluster name entered, the VSAT\nlisting shown in Figure 1 would result.\n\nFor batch invocation, the following JCL can be used.\n\n//JOBNAME JOB MSGCLASS=?,CLASS=?\n//VSAT    EXEC PGM=VSAT\n//STEPLIB DD DSN=YOUR.STEPLIB,DISP=SHR    <==STEPLIB IF NOT IN LINKLIST\n//SYSOUT  DD SYSOUT=?\n//SYSIN   DD *\nCISV.PROD.MXRF\nCISV.TEST.MXRF\nCISV.INTG.MXRF\n\nAn example of the batch VSAT listing is shown in Figure 2.\n\nIn the reports, the following abbreviations are used:\n\nTYPE\n      KS-DA - KSDS cluster data component\n      KS-IX - KSDS cluster index component\n      ES-DA - ESDS cluster data component\n      RR-DA - RRDS cluster data component\n      LD-DA - LDS cluster data component.\n\nLRECL      The maximum LRECL of the data component or\n            the index component.\n\nK-LEN      The key length of the respective component.  Zero\n            will be displayed if it is not a KSDS type cluster.\n\nRKP      The relative key position of the respective component.\n\nCISZ      The CI size of the respective component.\n\n%USED      The amount of primary space used in the component.\n\nXTNT      The number of extents used in the component.\n\nSPLITS CI/CA\n      The number of CI splits and CA splits in the component.\n\nRECORDS TOTAL-INSERT-DELETE\n      The total number of records, records inserted, and records\n      deleted within the component.\n\n\nVSAT\n\n*      R0  = REASON CODE FOR DISPLAY ERROR                            *\n*      R1  = ADDRESS OF COMMON BUFFER OR PARMLIST                     *\n*      R2  = USED FOR EVEN-ODD PAIR IN DIVIDE                         *\n*      R3  = USED FOR EVEN-ODD PAIR IN DIVIDE                         *\n*      R4  = WORK REGISTER FOR DYNALLOC                               *\n*      R5  = WORK AREA FOR FORMATTING PRINT                           *\n*      R6  = WORK AREA FOR DIVIDE                                     *\n*      R7  = STORAGE AREA FOR PRINT LINE                              *\n*      R8  =                                                          *\n*      R9  = WORK AREA USED FOR PRINT MASKING                         *\n*      R10 =                                                          *\n*      R11 = BASE REGISTER                                            *\n*      R12 = SECOND BASE REGISTER                                     *\n*      R13 = SAVE AREA AND SAVE AREA POINTER                          *\n*      R14 = CONTENTS OF REGISTERS UPON ENTRY                         *\n*      R15                                                            *\n\nEditor's note: register equates go here.\n\nVSAT CSECT\n         AMODE 24\n         RMODE 24\n         SAVE  (14,12)                   SAVE REGISTERS\n         LR    R11,R15                   SET BASE REG FROM ENTRY ADDR.\n         USING VSAT,R11                  ADDRESSABILITY FOR ASSEMBLER\n         L     R12,$VSAT2                SET R12 FOR SECOND BASE REG\n         USING VSAT+4096,R12             ADDRESSABILITY FOR 2ND BASE\n         ST    R13,SAVE+4                STORE BACKWARD SAVEAREA PTR\n         LA    R14,SAVE                  ADDRESS CURRENT SAVE AREA\n         ST    R14,8(R13)                STORE FORWARD SAVEAREA PTR\n         LR    R13,R14                   PUT SAVEAREA ADDR IN R13\n*        CHECK FOR TSO OR BATCH INVOCATION                            *\nSTART    L     R2,0(,R1)              ADDR. OF COMM. BUFFER OR PARMLIST\n         LH    R3,0(,R2)              GET PARM LENGTH\n         LTR   R2,R2                  IS CALLER TSO OR BATCH\n         BL    BATCH                  BATCH.... GO TO BATCH ROUTINE\n*        OPEN SYSOUT DD IF TSO ENVOCATION                             *\nTSO      OPEN  (MSGDCB,OUTPUT)            OPEN MSG DATASET (SYSOUT)\n         LA    R7,MSGOPERR                POINT TO SYSOUT OPEN ERROR\n         TM    MSGDCB+48,X'10'            GOOD OPEN?  CHECK DCBOFLGS\n*                                              NUMBER 3\n         BNO   NOCLOSE                    NO....SYSOUT OPEN ERROR\nINFO     PUT   MSGDCB,SPACES              PRINT LINE OF SPACES\n         LA    R7,INFO0                   POINT TO INPUT INFO0 MESSAGE\n         PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         LA    R7,INFOA                   POINT TO INPUT INFOA MESSAGE\n         PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         LA    R7,INFOB                   POINT TO INPUT INFOB MESSAGE\n         PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         LA    R7,INFO1                   POINT TO TSO INFO1 MESSAGE\n         PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         PUT   MSGDCB,SPACES              PRINT LINE OF SPACES\n         B     OPENINC                    MSGDCB IS OPEN....OPEN SYSIN\n*        OPEN SYSOUT DD FOR BATCH USE                                 *\nBATCH    OPEN  (MSGDCB,OUTPUT)            OPEN MSG DATASET (SYSOUT)\n         LA    R7,MSGOPERR                POINT TO SYSOUT OPEN ERROR\n         TM    MSGDCB+48,X'10'            GOOD OPEN?  CHECK DCBOFLGS\n*                                              NUMBER 3\n         BNO   NOCLOSE                    NO....SYSOUT OPEN ERROR\n*        OPEN SYSIN DD                                                *\nOPENINC  OPEN  (INCARDS,INPUT)\n         LA    R7,OPERRIN                 POINT TO OPEN ERROR\n         TM    INCARDS+48,X'10'           GOOD OPEN?  CHECK DCBOFLGS\n*                                              NUMBER 3\n         BNO   NOCLOSE                    NO....SYSIN OPEN ERROR.\nREADLOOP GET   INCARDS,INCAREA\n         CLI   INCLUST,C' '               BLANK NAME ENTERED ?\n         BE    BADINPUT                         YES....ISSUE MESSAGE\n         LA    R4,CLUSTIN                 POINT AT RECEIVING AREA\n         MVC   0(44,R4),INCLUST           MOVE SYSIN TO CLUSTIN\n*                ALLOCATE THE CLUSTER TO BE DISPLAYED\nALLOC8   CNOP  0,4           ALIGN LIST TO FULLWORD\n         BAL   1,IGX0020     BRANCH AROUND LIST, POINT REG1 TO LIST\nAK0ORG   DC     0F'0'\n*                SVC 99 INPUT REQUEST BLOCK\nAK0RBP   DS    0F\nAK0RBPTR DC    A(AK0RB+X'80000000')    REQUEST BLOCK POINTER\nAK0RB    DS    0F\nAK0RBLN  DC    AL1(AK0RBEND-AK0RB)     LENGTH OF REQUEST BLOCK\nAK0VERB  DC    AL1(S99VRBAL)    VERB CODE\nAK0FLAG1 DS    0CL2             FLAGS\nAK0FLG11 DC    AL1(0)           FIRST FLAGS BYTE\nAK0FLG12 DC    AL1(0)           SECOND BYTE OF FLAGS\nAK0RSC   DS    0CL4             REASON CODE FIELDS\nAK0ERROR DC    XL2'0'           ERROR REASON CODE\nAK0INFO  DC    XL2'0'           INFORMATION REASON CODE\nAK0TXTPP DC    A(AK0TUPL)       ADDR OF LIST OF TEXT UNIT PTRS\nAK0RSV01 DC    F'0'             RESERVED\nAK0FLAG2 DS    0CL4             FLAGS FOR AUTHORIZED FUNCTIONS\nAK0FLG21 DC    AL1(0)           FIRST BYTE OF FLAGS\nAK0FLG22 DC    AL1(0)           SECOND BYTE OF FLAGS\nAK0FLG23 DC    AL1(0)           THIRD BYTE OF FLAGS\nAK0FLG24 DC    AL1(0)           FOURTH BYTE OF FLAGS\nAK0RBEND EQU   *                END MARKER\n* SVC 99 TEXT UNIT POINTER LIST\nAK0TUPL  DS    0F                      TEXT UNIT POINTER LIST\nAK0PTR1  DC    A(AK0TU1)               1ST TEXT UNIT POINTER, DDNAM\nAK0PTR2  DC    A(AK0TU2)               2ND TEXT UNIT POINTER, DSNAM\nAK0PTR3  DC    A(AK0TU3+X'80000000')   3RD TEXT UNIT POINTER, STATS\n* SVC 99 TEXT UNITS\nAK0TU1   DS    0F                 BEGIN 1ST TEXT UNIT, DALDDNAM\nAK0KEY1  DC    AL2(DALDDNAM)      1ST KEY\nAK0NUM1  DC    AL2(1)             # OF LENGTH+PARAMETER ENTRIES  .XCHK\nAK0ENT1  DS    0C                 ENTRY OF LENGTH+PARAMETER      .XCHK\nAK0LNG1  DC    AL2(7)             LENGTH OF 1ST PARM. OF 1ST KEY .XCHK\nAK0DDNAM DS    0CL7               CREATE LABEL FOR USER\nAK0PAR1  DC    CL7'CLUSTIN'       VALUE OF 1ST PARM. OF 1ST KEY  .XCHK\nAK0TU2   DS    0F                 BEGIN 2ND TEXT UNIT, DALDSNAM\nAK0KEY2  DC    AL2(DALDSNAM)      2ND KEY\nAK0NUM2  DC    AL2(1)             # OF LENGTH+PARAMETER ENTRIES  .XCHK\nAK0ENT2  DS    0C                 ENTRY OF LENGTH+PARAMETER      .XCHK\nAK0LNG2  DC    AL2(44)            LENGTH OF 1ST PARM. OF 2ND KEY .XCHK\nAK0DSNAM DS    0CL44              CREATE LABEL FOR USER\nAK0PAR2  DC    CL44' '            VALUE OF 1ST PARM. OF 2ND KEY  .XCHK\nAK0TU3   DS    0F                 BEGIN 3RD TEXT UNIT, DALSTATS\nAK0KEY3  DC    AL2(DALSTATS)      3RD KEY\nAK0NUM3  DC    AL2(1)             # OF LENGTH+PARAMETER ENTRIES  .XLAT\nAK0ENT3  DS    0C                 ENTRY OF LENGTH+PARAMETER      .XLAT\nAK0LNG3  DC    AL2(1)             LENGTH OF 1ST PARM. OF 3RD KEY .XLAT\nAK0PAR3  DC    AL1(X'08')         VALUE OF 1ST PARM. OF 3RD KEY  .XLAT\n         DS    0D                 FILL OUT DATA SECTION\nAK0AK0A  EQU   *-AK0ORG           CALCULATE THE HEX LENGTH\nAK0DSECT DS    CL(AK0AK0A)        NOW L'&CEC#P.DSECT AVAILABLE\nIGX0020  DS    0H                 BRANCHED AROUND LIST\n         MVC   AK0PAR2,CLUSTIN    1ST PARM. OF 2ND KEY  .XCHK .AAACH\n         DYNALLOC\n         MVC   DYNRCLUS,INCLUST           MOVE CLUSTER NAME TO MSG\n         LA    R7,DYNERR                  POINT TO DYNALLOC ERROR\n         LTR   R15,R15                    SUCCESSFUL DYNALLOC\n         BNZ   DYNAERR                    NOT ZERO PUT ERROR MSG\n*        SETUP AND PRINT HEADINGS                                     *\n         MVC   CLUSTHD,INCLUST            MOVE CLUSTER NAME TO MSG\n         PUT   MSGDCB,SPACES              PRINT LINE OF SPACES\n         PUT   MSGDCB,CLHEAD              PRINT VSAM FILE NAME\n*        OPEN VSAM DATASET                                            *\nOPENVSAM OPEN  VSAMACB                    OPEN VSAM CLUSTER SEQUENTIAL\n         LA    R7,OPERR                   POINT TO OPEN ERROR\n         TM    INCARDS+48,X'10'           GOOD OPEN?  CHECK DCBOFLGS\n*                                              NUMBER 3\n         BNO   NOCLOSE                    NO....SYSIN OPEN ERROR.\n*        SET UP REPORT LINE FOR PRINT                                 *\n         MVI   REPORT,X'40'               MOVE SPACE TO FIRST BYTE\n         MVC   REPORT+1(79),REPORT        SPACE OUT REMAINDER\n         MVI   RDASH,C'-'                 MOVE DASH TO REPORT LINE\n         MVI   RPCENT,C'%'                MOVE % TO REPORT LINE\n         MVI   RSLASH,C'/'                MOVE SLASH TO REPORT LINE\n         SHOWCB AREA=DATAFACT,                                         X\n               FIELDS=ACB,                                             X\n               LENGTH=4,                                               X\n               RPL=VSAMRPL\n         LA    R7,SHOWERR                 POINT TO SHOWCB ERROR\n         LTR   R15,R15                    SUCCESSFUL SHOWCB\n         BNZ   PRTEND                     NOT ZERO PUT ERROR MSG\n*        TEST TO SEE IF DATASET IS KSDS, ESDS, OR RRDS                *\n         TESTCB ACB=VSAMACB,                                           X\n               ATRB=LDS,                                               X\n               ERET=TESTERR               TEST FOR ESDS\n         MVC   RTYPED,LLDS                MOVE LDS TO O/P LINE\n         BE    PROCESD                    DATASET IS LDS\n         TESTCB ACB=VSAMACB,                                           X\n               ATRB=ESDS,                                              X\n               ERET=TESTERR               TEST FOR ESDS\n         MVC   RTYPED,LESDS               MOVE ESDS TO O/P LINE\n         BE    PROCESD                    DATASET IS ESDS\n         TESTCB ACB=VSAMACB,                                           X\n               ATRB=RRDS,                                              X\n               ERET=TESTERR               TEST FOR RRDS\n         MVC   RTYPED,LRRDS               MOVE RRDS TO O/P LINE\n         BE    PROCESD                    DATASET IS RRDS\n         TESTCB ACB=VSAMACB,                                           X\n               ATRB=KSDS,                                              X\n               ERET=TESTERR               TEST FOR KSDS\n         MVC   RTYPED,LKSDS               MOVE KSDS TO O/P LINE\n         BE    PROCESD                    DATASET IS ESDS\n*        NAME ENTERED IS NOT AN ESDS, KSDS, RRDS, OR LDS TYPE CLUSTER *\n         LA    R7,TYPERROR\n         PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         B     END                        SKIP AND GET ANOTHER LCLUSTER\n*        ACCESS THE AMDSB FOR THE DATA COMPONENT                      *\nPROCESD EQU    *\n         MVC   RTYPEC,LDATA               MOVE \"DATA\" TO HEADER\n         PUT   MSGDCB,HEADER              PRINT HEADING LINE\n         SHOWCB ACB=VSAMACB,              GET VALUSE FOR: KEY LENGTH,  X\n               AREA=DISPLAY,              LRECL, RKP, CINV, ENDRBA,    X\n               OBJECT=DATA,               DISPLAY DATA COMPONENT       X\n               FIELDS=(KEYLEN,            NEXT, NCIS, NSSS, NLOGR,     X\n               LRECL,RKP,CINV,            NINSR, HALCRBA AND NDELR     X\n               ENDRBA,NEXT,NCIS,                                       X\n               NSSS,NLOGR,NINSR,                                       X\n               HALCRBA,NDELR),                                         X\n               LENGTH=48\n         LA    R7,SHOWERR                 POINT TO SHOWCB ERROR\n         LTR   R15,R15                    SUCCESSFUL SHOWCB\n         BNZ   PRTEND                     NOT ZERO PUT ERROR MSG\n         L     R9,KEYLEN                  GET KEY LENGTH\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RKEYL,WORKB+3              MOVE KEYLEN TO O/P LINE\n         L     R9,RKP                     GET RKP\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RRKP,WORKB+5               MOVE RKP TO O/P LINE\n         L     R9,LRECL                   GET LRECL\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RLRECL,WORKB+3             MOVE LRECL TO O/P LINE\n         L     R9,CINV                    GET CI SIZE\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RCINV,WORKB+3              MOVE TO O/P LINE\n         SR    R2,R2                      LOAD R2 WITH ZEROS\n         L     R3,ENDRBA                  LOAD R3 WITH HI USED RBA\n         M     R2,=F'100'                 MULTIPLY BY 100 FOR PERCENT\n         D     R2,HALCRBA                 DIVIDE HI-USED BY HI-ALLOC\n         LR    R9,R3                      LOAD R9 WITH DIVIDEND\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RUSED,WORKB+5              MOVE TO O/P LINE\n         L     R9,NEXT                    GET NUMBER OF EXTENTS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNEXT,WORKB+4              MOVE TO O/P LINE\n         L     R9,NCIS                    GET NUMBER OF CI SPLITS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNCIS,WORKB+4              MOVE TO O/P LINE\n         L     R9,NSSS                    GET NUMBER OF CA SPLITS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNSSS,WORKB+4              MOVE TO O/P LINE\n         L     R9,NLOGR                   GET NUMBER RECORDS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNLOGR,WORKB               MOVE TO O/P LINE\n         L     R9,NINSR                   GET NUMBER RECORDS INSERTED\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNINSR,WORKB+2             MOVE TO O/P LINE\n         L     R9,NDELR                   GET NUMBER RECORDS DELETED\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNDELR,WORKB+2             MOVE TO O/P LINE\n         LA    R7,REPORT                  LOAD REPORT LINE TO R7\n         PUT   MSGDCB,0(R7)               PRINT REPORT DATA LINE\n         CLC   =C'KS',RTYPED              IF TYPE NOT = KSDS\n         BNE   END                           THEN GO TO END\n*        NOW ACCESS THE AMDSB FOR THE INDEX COMPONENT                 *\nPROCESI  EQU   *\n         MVI   RPCENT,C' '                MOVE SLASH TO REPORT LINE\n         MVC   RTYPEC,LINDEX              MOVE \"INDEX\" TO HEADER\n         SHOWCB ACB=VSAMACB,              GET VALUSE FOR: KEY LENGTH,  X\n               AREA=DISPLAY,              LRECL, RKP, CINV, ENDRBA,    X\n               OBJECT=INDEX,              DISPLAY INDEX COMPONENT      X\n               FIELDS=(KEYLEN,            NEXT, NCIS, NSSS, NLOGR,     X\n               LRECL,RKP,CINV,            NINSR, HALCRBA AND NDELR     X\n               ENDRBA,NEXT,NCIS,                                       X\n               NSSS,NLOGR,NINSR,                                       X\n               HALCRBA,NDELR),                                         X\n               LENGTH=48\n         LA    R7,SHOWERR                 POINT TO SHOWCB ERROR\n         LTR   R15,R15                    SUCCESSFUL SHOWCB\n         BNZ   PRTEND                     NOT ZERO PUT ERROR MSG\n         L     R9,KEYLEN                  GET KEY LENGTH\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RKEYL,WORKB+3              MOVE KEYLEN TO O/P LINE\n         L     R9,RKP                     GET RKP\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RRKP,WORKB+5               MOVE RKP TO O/P LINE\n         L     R9,LRECL                   GET LRECL\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RLRECL,WORKB+3             MOVE LRECL TO O/P LINE\n         L     R9,CINV                    GET CI SIZE\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RCINV,WORKB+3              MOVE TO O/P LINE\n         MVC   RUSED,C' '                 MOVE SPACES TO %USED\n         L     R9,NEXT                    GET NUMBER OF EXTENTS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNEXT,WORKB+4              MOVE TO O/P LINE\n         L     R9,NCIS                    GET NUMBER OF CI SPLITS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNCIS,WORKB+4              MOVE TO O/P LINE\n         L     R9,NSSS                    GET NUMBER OF CA SPLITS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNSSS,WORKB+4              MOVE TO O/P LINE\n         L     R9,NLOGR                   GET NUMBER RECORDS\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNLOGR,WORKB               MOVE TO O/P LINE\n         L     R9,NINSR                   GET NUMBER RECORDS INSERTED\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNINSR,WORKB+2             MOVE TO O/P LINE\n         L     R9,NDELR                   GET NUMBER RECORDS DELETED\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   RNDELR,WORKB+2             MOVE TO O/P LINE\n         LA    R7,REPORT                  LOAD REPORT LINE TO R7\n         B     PRTEND\nFORMAT   CVD   R9,WORKA                   CONVERT TO PACKED DECIMAL\n         OI    WORKA+7,X'0F'              SWAP LAST BIT\n         MVC   WORKB,EDMASK               MOVE EDIT MASK TO WORKB\n         ED    WORKB,WORKA+4              SUPPRESS LEADING ZEROS\n         BR    R5                         GO BACK TO ADDRESS IN R5\n*        PRINT CURRENT REPORT LINE                                    *\nPRTEND   PUT   MSGDCB,0(R7)               PRINT MESSAGE\n*        CLOSE CURRENT AND GET NEXT RECORD (CLUSTER NAMES COLS. 1-44) *\nEND      CLOSE VSAMACB                    CLOSE VSAM DATASET\n*                THIS CODE IS FOR DE-ALLOCATION\n         CNOP  0,4           ALIGN LIST TO FULLWORD\n         BAL   1,IGX0633     BRANCH AROUND LIST, POINT REG1 TO LIST\nALHORG   DC     0F'0'\n*                SVC 99 INPUT REQUEST BLOCK\nALHRBP   DS    0F\nALHRBPTR DC    A(ALHRB+X'80000000')   REQUEST BLOCK POINTER\nALHRB    DS    0F\nALHRBLN  DC    AL1(ALHRBEND-ALHRB)    LENGTH OF REQUEST BLOCK\nALHVERB  DC    AL1(S99VRBUN)         VERB CODE\nALHFLAG1 DS    0CL2                  FLAGS\nALHFLG11 DC    AL1(0)                FIRST FLAGS BYTE\nALHFLG12 DC    AL1(0)                SECOND BYTE OF FLAGS\nALHRSC   DS    0CL4                  REASON CODE FIELDS\nALHERROR DC    XL2'0'                ERROR REASON CODE\nALHINFO  DC    XL2'0'                INFORMATION REASON CODE\nALHTXTPP DC    A(ALHTUPL)            ADDR OF LIST OF TEXT UNIT PTRS\nALHRSV01 DC    F'0'                  RESERVED\nALHFLAG2 DS    0CL4                  FLAGS FOR AUTHORIZED FUNCTIONS\nALHFLG21 DC    AL1(0)                FIRST BYTE OF FLAGS\nALHFLG22 DC    AL1(0)                SECOND BYTE OF FLAGS\nALHFLG23 DC    AL1(0)                THIRD BYTE OF FLAGS\nALHFLG24 DC    AL1(0)                FOURTH BYTE OF FLAGS\nALHRBEND EQU   *                     END MARKER\n* SVC 99 TEXT UNIT POINTER LIST\nALHTUPL  DS    0F                      TEXT UNIT POINTER LIST\nALHPTR1  DC    A(ALHTU1+X'80000000')   1ST TEXT UNIT POINTER, DDNAM\n* SVC 99 TEXT UNITS\nALHTU1   DS    0F               BEGIN 1ST TEXT UNIT, DUNDDNAM\nALHKEY1  DC    AL2(DUNDDNAM)    1ST KEY\nALHNUM1  DC    AL2(1)           # OF LENGTH+PARAMETER ENTRIES  .XCHK\nALHENT1  DS    0C               ENTRY OF LENGTH+PARAMETER      .XCHK\nALHLNG1  DC    AL2(7)           LENGTH OF 1ST PARM. OF 1ST KEY .XCHK\nALHDDNAM DS    0CL7             CREATE LABEL FOR USER\nALHPAR1  DC    CL7'CLUSTIN'     VALUE OF 1ST PARM. OF 1ST KEY  .XCHK\n         DS    0D               FILL OUT DATA SECTION\nALHALHA  EQU   *-ALHORG         CALCULATE THE HEX LENGTH\nIGX0633  DS    0H               BRANCHED AROUND LIST\n         DYNALLOC\n         LA    R7,DEALERR                 POINT TO DYNALLOC ERROR\n         LTR   R15,R15                    SUCCESSFUL DYNALLOC\n         BNZ   NOCLOSE                    NOT ZERO PUT ERROR MSG\n         B     READLOOP\n*        CLOSE THE DATASETS AND RETURN                                *\nEOF      LA    R7,NORMAL                  EOF SUCCESSFUL\n         B     NOCLOSE\nDEALERR  LA    R7,DALLER                  POINT TO SHOWCB ERROR\n*\nNOCLOSE  EQU   *\n         PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         CLOSE (MSGDCB,,INCARDS)          CLOSE MESSAGE DATASET\n         L     R13,SAVE+4                 POINT TO PREVIOUS SAVE AREA\n         RETURN (14,12),RC=0              RETURN BACK TO SYSTEM\nBADINPUT PUT   MSGDCB,SPACES              PRINT LINE OF SPACES\n         LA    R7,INERROR1                POINT TO BAD INPUT MSG\n         PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         LA    R7,INPTGRID                LOAD INPUT NAME GRID\n         PUT   MSGDCB,0(R7)               PRINT INPUT NAME GRID\n         MVC   INERRCLS,INCLUST           MOVE CLUSTER NAME TO MSG\n         LA    R7,INERROR2                LOAD CLUSTER NAME DISPLAY\n         PUT   MSGDCB,0(R7)               PRINT CLUSTER NAME DISPLAY\n         B     READLOOP                   GET NEXT SYSIN RECORD\nDYNAERR  PUT   MSGDCB,0(R7)               PRINT MESSAGE\n         B     READLOOP                   GET NEXT SYSIN RECORD\n*        ERROR HANDLING ROUTINE FOR TESTCB                            *\nTESTERR  LR    R9,R15                     SETUP RETURN CODE FOR DISPLAY\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   TCBRC,WORKB+6              MOVE TO O/P LINE\n         LR    R9,R0                      SETUP REASON CODE FOR DISPLAY\n         BAL   R5,FORMAT                  FORMAT PRINT\n         MVC   TCBRSN,WORKB+6             MOVE TO O/P LINE\n         LA    R7,TESTMSG                 POINT TO TESTCB ERROR\n         PUT   MSGDCB,0(R7)               PRINT ERROR MESSAGE\n         B     END                        GET ANOTHER CLUSTER\n         LTORG\nSAVE     DS    18F\n$VSAT2   DC    A(VSAT+4096)\nCLUSTIN  DS    CL44\nCLHEAD   DS    0CL80\nCLUSTHD  DS    CL44\n         DC    CL36' SPLITS           RECORDS           '\nSPACES   DC    CL80' '\nDISPLAY  DS    0F\nKEYLEN   DS    F\nLRECL    DS    F\nRKP      DS    F\nCINV     DS    F\nENDRBA   DS    F\nNEXT     DS    F\nNCIS     DS    F\nNSSS     DS    F\nNLOGR    DS    F\nNINSR    DS    F\nHALCRBA  DS    F\nNDELR    DS    F\nDATAFACT DS    F\nWORKA    DS    D\nWORKB    DS    D\nWORKC    DS    D\nEDMASK   DC    X'4020202020202120'\nFDBKCDE  DS    F\n         DS    C                          EXTRA BYTE FOR UNPACK\nWKFLD    DS    CL4\nRECNO    DS    CL4                        RELATIVE RECORD NUMBER\n         DS    0F          FULLWORD ALIGNMENT\n*==>                ....+....1....+....2....+....3....+....4....+....5\nLKSDS    DC    CL02'KS'\nLESDS    DC    CL02'ES'\nLRRDS    DC    CL02'RR'\nLLDS     DC    CL02'LD'\nLDATA    DC    CL02'DA'\nLINDEX   DC    CL02'IX'\nINERROR1 DC    CL80'SYSIN INPUT ERROR - INPUT IS CLUSTER NAME STARTING X\n               IN COL 1 W/O QUOTES'\nINPTGRID DC    CL80'                 ....+....1....+....2....+....3....X\n               +....4....'\nINERROR2 DS    0CL80\n         DC    CL17'INPUT RECEIVED = '\nINERRCLS DS    CL63\nINFO0    DC    CL80'INPUT IS CLUSTER NAME STARTING IN COL 1 W/O QUOTES'\nINFOA    DC    CL80'      AND IS ALLOCATED TO SYSIN'\nINFOB    DC    CL80'OUTPUT IS ALLOCATED TO SYSOUT'\nINFO1    DC    CL80'WHEN YOU ARE FINISHED TYPE IN /* TO END'\nOPERRIN  DC    CL80'ERROR OPENING SYSIN DATASET'\nOPERR    DC    CL80'ERROR OPENING VSAM DATASET'\nMSGOPERR DC    CL80'ERROR OPENING SYSOUT DATASET'\n         DS    0F          FULLWORD ALIGNMENT\nDYNERR   DS    0CL80\n         DC    CL25'VSAM CLUSTER NOT FOUND = '\nDYNRCLUS DS    CL55\nDALLER   DC    CL80'DE-ALLOCATION FAILED FOR DDNAME CLUSTIN'\nSHOWERR  DC    CL80'UNABLE TO RETRIEVE ACCESS METHOD CONTROL BLOCK'\nTYPERROR DC    CL80'  NAME ENTERED IS NOT AN ESDS, KSDS, RRDS, OR LDS TX\n               YPE VSAM CLUSTER'\nCLOSERR  DC    CL80'UNABLE TO CLOSE VSAM DATASET'\nTESTMSG  DS    0CL80\n*==>                ....+....1....+....2....+....3....+....4....+....5\n         DC    CL48'UNABLE TO TEST ACCESS METHOD CONTROL BLOCK / RC='\nTCBRC    DS    CL02\n         DC    CL14', REASON CODE='\nTCBRSN   DS    CL02\n         DC    CL14'              '\nNORMAL   DC    CL80'*** NORMAL END OF TASK ***'\nHEADER   DC    CL80'     TYPE LRECL K-LEN RKP  CISZ %USED XTNT  CI / CAX\n                    TOTAL-INSERT-DELETE     '\nREPORT   DS    0CL80\n         DC    CL04' '\nRTYPED   DS    CL02\nRDASH    DC    CL01'-'\nRTYPEC   DS    CL02\n         DC    CL01' '\nRLRECL   DS    CL05\n         DC    CL01' '\nRKEYL    DS    CL05\n         DC    CL01' '\nRRKP     DS    CL03\n         DC    CL01' '\nRCINV    DS    CL05\n         DC    CL02' '\nRUSED    DS    CL03\nRPCENT   DS    CL01\n         DC    CL01' '\nRNEXT    DS    CL04\n         DC    CL01' '\nRNCIS    DS    CL04\nRSLASH   DC    CL01'/'\nRNSSS    DS    CL04\n         DC    CL01' '\nRNLOGR   DS    CL08\n         DC    CL01' '\nRNINSR   DS    CL06\n         DC    CL01' '\nRNDELR   DS    CL06\nMSGFDBK  DS    0CL80\n         DC    CL80'VSAM FEEDBACK CODE IS '\nMSGCDE   DS    CL3\n         DC    CL55' '\nTRTBL    DC    C'0123456789ABCDE'\n         DS    0F          FULLWORD ALIGNMENT\nINCAREA  DS    0CL80\nINCLUST  DS    CL44\n         DS    CL36\nINCARDS  DCB   DSORG=PS,RECFM=FB,MACRF=GM,                             X\n               LRECL=80,DDNAME=SYSIN,EODAD=EOF\nVSAMACB  ACB   DDNAME=CLUSTIN\nVSAMRPL  RPL   ACB=VSAMACB\nMSGDCB   DCB   BLKSIZE=080,                                            X\n               LRECL=080,                                              X\n               DDNAME=SYSOUT,                                          X\n               DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               RECFM=F\n         IEFZB4D0                             IBM SUPPLIED MACROS\n         IEFZB4D2                             IBM SUPPLIED MACROS\n         END   VSAT\n\nLorenzo DiCioccio\nSystems Programmer\nCenterior Energy Corporation (USA)      c Lorenzo DiCioccio 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A004A02": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00m\\x00m\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 109, "newlines": 109, "modlines": 0, "user": "VSAMUPD"}, "text": "The VVDS dissected\n\nVSAM at MVS sites has developed from a user catalog and\ndataspace system into one that uses ICF (Integrated Catalog\nFacility) catalogs.  An ICF catalog is divided into two parts:\nthere is the BCS (Basic Catalog Structure) that contains data\nabout VSAM and non-VSAM datasets; and the VVDS (VSAM\nVolume DataSet) which contains information about VSAM\ndatasets that reside on the same pack as the VVDS.  The\nVVDS (an ESDS) is made up of variable length records that\ndescribe each VSAM entity on the disk.  The information\nincluded in a record includes dataset attributes, high allocated\nRBA (Relative Byte Address), high used RBA, and AMDSB\n(Access Method Data Statistics Block).\n\nDFP (Data Facility Product) Version 3 introduced System\nManaged Storage (SMS).  With this, class information (ie data\nclass, management class, storage class, and storage group) for\neach SMS VSAM and non-VSAM dataset is duplicated in the\nBCS and the VVDS\n\nOnly one VVDS, conventionally named SYS1.VVDS.volser,\ncan exist on a disk.  The volser part of its name must match the\nVOLSER in the UCB (Unit Control Block) of the device it is\non.  A VVDS can be defined explicitly using DEFINE\nCLUSTER, or implicitly when the first dataset is defined on a\nvolume.  The CI size is always 4K, the default space allocation\nis now TRK (10,10).  The VVDS is a frequently accessed\ndataset and should be placed near the VTOC, and, like the\nVTOC, getting its size right can be very important.  With SMS\nadditional records describing non-VSAM datasets are placed in\nthe VVDS.  This can cause the VVDS to go into secondary\nextents and cause performance to deteriorate dramatically.  The\nsize of the VVDS must be large enough right from the start,\nand this will usually mean allocating space in cylinders rather\nthan tracks.\n\nThe VVDS is a very special ESDS in that records can be\nadded, expanded, or removed anywhere that space exists in a\ncontrol interval.  This action is controlled by the VVDS\nManager (IGG0CLE0/IGG0CLHV).  When a record is to be\nadded to a VVDS, it locates a CI that has enough space to\ncontain the record.  The CI is read into storage and the new\nrecord is placed after the last existing record in the CI.  The CI\ncontrol information is updated, and an RDF (Record Definition\nField) describing the length of the new record is added.  The\nCIDF (Control Interval Definition Field) is updated.  The CIDF\ncontains information about available Free Space and the offset\nto the beginning of the Free Space.  When a record is removed\nfrom a VVDS, all the records in the CI that come after it are\nmoved forward so that Free Space exists only after the records,\nnot in between them.  The RDF for a deleted record is removed\nand the CIDF is updated appropriately.  If a record is to be\nexpanded, the system will check first to ensure that there is\nenough Free Space in the CI to contain this extra information.\nIf enough space exists, the records following the one to be\nexpanded are moved down the CI, and the record is expanded.\nThe RDF and CIDF are updated appropriately.  If not enough\nFree Space exists in the CI, another CI is found that contains\nenough space for the expanded record.  The whole record is\nmoved to the new CI.  The space in the original CI is then\nreclaimed.  All RDFs and CIDFs are updated appropriately.\n\nA VVDS contains five types of record.  They are: VVCR\n(VSAM Volume Control Record), VVR (VSAM Volume\nRecord), NVR (Non-VSAM Volume Record), VVCN (VVCR\nCatalog Name extension record), and VVCM (VVCR space\nMap extension record).  Each VVDS contains one VVCR (the\nfirst record in the VVDS) and at least one VVR.  NVR records\nwill only exist on SMS volumes.  VVCN and VVCM exist on\nDFP Version 3 systems.\n\nThe VVCR is located at RBA 0 and occupies an entire CI.  It\ncontains the names of up to 36 BCSs that have VSAM datasets,\nstored on the same pack as the VVDS, catalogued in them.\nEach catalog name slot is formatted such that from position 0\nfor 44 characters is the catalog name; from position 44 for 4\ncharacters is the RBA of the BCS data component; from 48 for\n4 characters is the RBA of the BCS index component; and from\nposition 52 for four characters is the RBA of the BCS sequence\nset.  The VVCR also contains a map detailing each CI in the\nVVDS.  Two-byte entries describe the available Free Space in\neach CI.  These entries help speed up the process of locating a\nCI with enough Free Space for a new record to be inserted.\nThe VVCR knows how many CIs are in the VVDS\n\nVVRs and NVRs are made up of cells and subcells and can\noccur anywhere in the VVDS after RBA 8192.  A VSAM\ndataset has a primary VVR in the VVDS on the pack\ncontaining the dataset's primary extent.  Secondary VVRs are\nused to describe secondary extents that exist on other disks,\nand exist on other packs.  Extent information occurs in cell\nX'23' and in the VTOC.\n\nBCS catalog entries for VSAM datasets and SMS non-VSAM\ndatasets contain RBA pointers to the VVR and NVR\nrespectively.  This greatly enhances performance.\n\nThe VVCN record raises the number of catalogs that the VVDS\ncan reference by 72.  Although this increases flexibility, it can\nmake recovery a nightmare.\n\nThe VVCM record removes the VVDS size restriction by\nallowing more 2-byte space map entries.\n\n\nJ Phillips\nConsultant (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A004A03": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00M\\x00M\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 77, "newlines": 77, "modlines": 0, "user": "VSAMUPD"}, "text": "Displaying VSAM information - update\n\nThe October issue of VSAM Update contained an article\nentitled Displaying VSAM information.  The author, Michael\nPlannthin, has made the following enhancements to the\nVSAMCALC EXEC.\n\nOn page 36, after:\n\n      IndexLine =\n\nDelete the next 29 lines, beginning Calc. and insert:\n\n      If Art = 'AIX ---' Then Do\n         Call Locate 'AXRKP-- 9 15 25 32'\n         Pull Inline\n         Rkp = Reform(Inline)\n         End\n\nOn page 39, after:\n\n      Fsca = Reform(Fsca)\n\nInsert:\n\n      Fsb  = 0\n\nAfter:\n\n      Fsb  = Reform (Fsb)\n\nDelete the next four lines.\n\nAfter:\n\n      SpcSec = Strip(Translate(SpcSec,' ','-'))\n\nDelete the next two lines, and insert:\n\n      Call Locate 'VOLSER 9 14 * *'\n      Pull Inline\n      Volser   = Substr(Inline,27,6)\n      Physrecl = Reform(Substr(Inline,57,5))\n      If Physrecl = 0 Then Physrecl = 1\n      Call Locate 'DEVTYPE 9 15 56 61'\n      Pull Physrec_Trk\n      Physrec_Trk = Reform(Physrec_Trk)\n      If Fsb <> 0 Then Ftrack = (Fsb % Physrecl) % Physrec_Trk\n                  Else Ftrack = 0\n\nOn page 40, after:\n\n      If MaxNote = '-.' Then Gre = Gre + 1\n\nInsert:\n\n      MaxNote = '-.'\n      C_Note  = '-.'\n      I_Note  = '-.'\n\nOn page 41, after the label:\n\n      Atr_Again:\n\nDelete the rest of the program and replace with:\n\n      'EXECIO 1 DISKR' Catalog 'LISTING T' (Lastread+1) ,\n                              '(MARGINS 1 130 VAR INLIN'\n      If Left (Inlin,1) = '1' | Left(Inlin,1) = '-' Then Do\n      Lastread = Lastread + 1\n      Signal Atr_Again\n      End\n      Inlin = Substr(Inlin,2)\n      Attributes = Space('+++' Oldlin Inlin' +++',1)\n      Return\n\nThese changes do not affect any of the other programs in the article.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A004A04": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01y\\x01y\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 377, "newlines": 377, "modlines": 0, "user": "VSAMUPD"}, "text": "Writing to KSDS files from REXX\n\n\nPURPOSE\n\nThe MVS (TSO/E) implementation of REXX lacks VSAM\nsupport.  The RXVSWRIT program can be invoked directly\nfrom a REXX EXEC to write records into a VSAM KSDS.\nThe records to be written may be either REXX (stem) variables\nor stack entries.\n\n\nPROGRAM DESCRIPTION\n\nThe VSAM file must have been allocated to the file name\n(DDname) VSAM before RXVSWRIT is invoked.  The EXEC\nparameter specifies the source of the records to be written.  The\nEXEC parameter, if present, specifies the stem name,\notherwise the stack is used.  The write operation is terminated\nby either the first uninitialized variable or the count in\n<varname>0, <varname> being the name of the variable\nspecified in the EXEC parameter.  If named variables are used,\nthen the variables <varname>i (i = 1 to <varname>0) are\nwritten to the VSAM file.\n\nNote: REXX programs must be linked with addressing mode\n(AMODE) 31, residency mode (RMODE) may be 24.\n\nThe REXX named variables used are:\n\no      <varname>0      number of records to be written\n\no      <varname>i      ith record to be written.\n\nThe return codes used are:\n\no      0      successful processing\n\no      4      no records written\n\no      8      VSAM write error\n\no      12      REXX environment error (error returned from IRXEXCOM).\n\n\nSAMPLE PROCEDURES\n\nExample 1 using named variables.\n\n/* REXX - VSAM-KSDS Write Interface Example */\n/* allocate VSAM file */\nADDRESS TSO \"ALLOC F(VSAM) DA('VSAM.TEST.INFO') SHR REUS\"\n/* set stem variables */\nRECORD.1 = \"ssaassdddsdssdadasaddasdssddssddssdddddsdds\";\nRECORD.2 = \"rttrtrttrtrreerwwewewrertrrttrtrtrtrrtr\";\nRECORD.3 = \"zutrztutuztutuuuzuzutzjujtjtzjtttjtjzttttt\";\n/* set record count */\nRECORD.0 = 3;\nADDRESS LINK \"RXVSWRIT RECORD.\";\nSAY \"rc\" rc;\n\nExample 2 using stack variables.\n\n/* REXX - VSAM-KSDS Write Interface Example */\n/* allocate VSAM file */\nADDRESS TSO \"ALLOC F(VSAM) DA('VSAM.TEST.INFO') SHR REUS\";\n/* set entries into stack */\nQUEUE = \"ssaassdddsdssdadasaddasdssddssddssdsddssddsdds\";\nQUEUE = \"rttrtrttrtrreerwwewewrertrrttrtrtrtrtrtrtrtr\";\nQUEUE = \"zutrztutuztutuuuzuzutzjujtjtzjtttjtjzttttzztt\";\nADDRESS LINK \"RXVSWRIT\";\nSAY \"rc\" rc;\n\n\nPROGRAM\n\n         TITLE 'REXX-VSAM(KSDS) INTERFACE (WRITE OPERATIONS)'\n         PRINT NOGEN\n* REGISTER USAGE:\n*  R2:   work-register\n*  R3:   work-register\n*  R4:   work-register\n*  R5:   A(SHVBLOCK)\n*  R6:   loop counter\n*  R7:   L(varname)\n*  R8:\n*  R9:\n*  R10:\n*  R11:\n*  R12:  base register\n**\nRXVSWRIT CSECT\n* initialise addressing\n         STM   R14,R12,12(R13)         save registers\n         BALR  R12,0                   base register\n         USING *,R12\n         LA    R15,SA                  A(save-area)\n         ST    R13,4(R15)              backward ptr\n         ST    R15,8(R13)              forward ptr\n         LR    R13,R15                 A(new save-area)\n         B     SA_END                  jump over save-area\nSA       DS    18A                     save-area\nSA_END   DS    0H\n         SPACE 1\n         LM    R6,R7,0(R1)\n* R6: A(A(varname))\n* R7: A(L(varname))\n         L     R6,0(R6)\n         L     R7,0(R7)\n* R6: A(varname)\n* R7: L(varname)\n         LA    R0,=CL8'IRXSTK'    IRX stack processing (default)\n         LR    R1,R7              L(varname)\n         SH    R1,=H'1'           LC(EXEC-Parameter)\n         BM    A010               no EXEC-parameter\n         LA    R0,=CL8'IRXEXCOM'  IRX variable module\n         MVC   VARNAME(0),0(R6)\n         EX    R1,*-6             move variable name\n         SPACE 1\n* load REXX access module (IRXSTK or IRXEXCOM, as appropriate)\nA010     LOAD  EPLOC=(0)          load IRX module\n         ST    R0,AIRXMOD         save EP-address\n         SPACE 1\n* suppress VSAM OPEN warning messages\n         LA    R1,VSAM            A(ACB)\n         USING IFGACB,R1\n         OI    ACBINFL2,ACBSWARN  set 'suppress warning messages flag'\n         SPACE 1\n* open VSAM dataset\n         OPEN  (VSAM)\n* obtain VSAM dataset attributes\n         SHOWCB ACB=VSAM,                                              X\n               AREA=VSAM_ATTR,                                         X\n               LENGTH=L'VSAM_ATTR,                                     X\n               OBJECT=DATA,                                            X\n               FIELDS=(KEYLEN,LRECL,RKP)\n         SPACE 1\n* allocate record buffer\n         L     R2,LRECL\n* R2: VSAM logical (maximum) record length\n         GETMAIN EU,LV=(2),A=AREC\n* pass parameters to VSAM\n         L     R2,AREC            A(record)\n         A     R2,RKP             +RKP\n         ST    R2,AKEY            A(key)\n         SPACE 1\n         MODCB RPL=RPL,AREA=(*,AREC),AREALEN=(*,LRECL)\n         MODCB RPL=RPL,ARG=(*,AKEY)\n         SPACE 2\n         ZAP   INDEX,=P'0'        initialize record number\n         SPACE 1\n         MVC   RC,=H'12'          preset ReturnCode (REXX error)\n* test whether access via variables or stack\n         LTR   R7,R7              L(varname)\n         BZ    A100               0 = access via stack\n* else variable access\n         SPACE 1\n* obtain <varname0> (no. of output records)\n         MVC   VN,VARNAME         variable name\n         LA    R1,VN(R7)\n         MVC   0(2,R1),=C'0 '\n         LA    R3,NREC\n         LA    R4,L'NREC\n         BAL   R14,GETVAR\n* R4: actual parameter length\n         L     R6,=F'99999999'    set default\n         MVC   RC,=H'4'           preset RC: zero records\n         SH    R4,=H'1'           LC(parameter)\n         BM    A100               null variable, use default\n         PACK  D,NREC(0)          pseudo-PACK\n         EX    R4,*-6             PACK using correct length\n         CVB   R6,D               no. of records\n         LTR   R6,R6\n         BZ    EOJ\n* write record\nA100     LTR   R7,R7              L(varname)\n         BZ    A200               0 = access via stack\nA110     AP    INDEX,=P'1'        increment record count\n* convert INDEX to character format (.n)\n         MVC   VNINDEX,=X'4020202020202120'\n         LA    R1,VNINDEX+7\n         EDMK  VNINDEX,INDEX\n         MVC   VNINDEX,0(R1)      set into <VNINDEX>\n         SPACE 1\n* get record content\n         MVC   VN,VARNAME         variable name\n         LA    R1,VN(R7)\n         MVC   0(8,R1),VNINDEX\n         L     R3,AREC\n         L     R4,LRECL\n         BAL   R14,GETVAR\n* R4: actual record length\nA130     LTR   R4,R4\n         BZ    EOJ                null variable (=job end)\n         ST    R4,RECRECL\n         MVC   RC,=H'0'           reset RC: records processed\n         SPACE 1\n         MODCB RPL=RPL,OPTCD=(NUP)\n         POINT RPL=RPL\n         LTR   R15,R15\n         BNZ   A120               ok, new record\n         SPACE 1\n         MODCB RPL=RPL,OPTCD=(UPD,LOC),AREA=AINREC\n         GET   RPL=RPL\n         SPACE 1\nA120     MODCB RPL=RPL,RECLEN=(4),OPTCD=(MVE),AREA=(*,AREC)\n         PUT   RPL=RPL\n         LTR   R15,R15\n         BNZ   VSAMERR            read error\n         SPACE 1\n         BCT   R6,A100            return to write-loop\n* end of processing\n         LA    R15,0              set RC value\nEXIT     STH   R15,RC             reset RC\n         SPACE 2\nEOJ      DS    0H                 End of job\n         CLOSE (VSAM)\n         SPACE 1\n         L     R13,4(R13)         restore A(old save-area)\n         LH    R15,RC\n         RETURN (14,12),RC=(15)\n         SPACE 1\n* symbolic register equates\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nRC       DS    H                  return code\n         SPACE 3\nA200     DS    0H                 get next stack element\n         L     R15,AIRXMOD        A(IRXSTK)\n         CALL  (15),(PULL,AELEM,LELEM,FRC),VL\n         CH    R15,=H'4'          service return code\n         BH    EXIT\n         LA    R15,0\n         BE    EXIT               end of stack\n* else stack element retrieved, move to buffer\n         LM    R0,R1,AELEM\n         LR    R15,R1             length\n         LR    R4,R1              length\n         L     R14,AREC           address\n         MVCL  R14,R0             move record\n         B     A130\n         SPACE 1\nAELEM    DS    2A\nLELEM    EQU   AELEM+4\n         TITLE 'SUBROUTINES'\nVSAMERR  DS    0H\n* retrieve VSAM error code, and display\n         SHOWCB RPL=RPL,                                               X\n               AREA=VSAM_FDBK,                                         X\n               LENGTH=L'VSAM_FDBK,                                     X\n               OBJECT=DATA,                                            X\n               FIELDS=(FDBK)\n* display message\n         L     R0,VSAM_FDBK\n         CVD   R0,D\n         MVC   M0FDBK,=X'40202120'\n         ED    M0FDBK,D+6\n         TPUT  M0,M0L\n         SPACE 1\n         MVC   RC,=H'8'           set return code\n         B     EOJ\n         SPACE 2\nM0       DC    C'VSAM error - feedback code:'\nM0FDBK   DS    CL4\nM0L      EQU   *-M0\n         SPACE 3\nGETVNL   DS    0H\n* determine actual length of name\n* input: <VN> - name\n* output: R0 - L(name)\n*         R15 - A(FIRST BLANK)\n         LA    R1,L'VN\n         SR    R0,R0              counter\n         LA    R15,VN\nGETVNL1  CLI   0(R15),C' '\n         BER   R14                end found\n         AH    R0,=H'1'\n         LA    R15,1(R15)\n         BCT   R1,GETVNL1\n* R0: L(name), without trailing blanks\n         BR    R14\n         SPACE 3\n         DS    A\nGETVAR   ST    R14,GETVAR-4\n* get REXX variable\n*  <VN>: variable name\n*  R4: L(variable buffer/data)\n*  R3: A(variable buffer/data)\n         BAL   R14,GETVNL        get L(VN)\n* R0: L(VN), R15: A(first blank in <VN>)\n         LA    R5,IRX_SHVBLOCK\n         USING SHVBLOCK,R5\n         ST    R0,SHVNAML         L(name), normalized\n         MVC   SHVNAMA,=A(VN)     A(name)\n         MVI   SHVCODE,SHVFETCH   set fetch-flag\n         ST    R3,SHVVALA         A(buffer)\n         ST    R4,SHVBUFL         L(buffer)\n         L     R15,AIRXMOD        A(IRXEXCOM)\n         CALL  (15),(IRX_IRXEXCOM,0,0,IRX_SHVBLOCK),VL\n         L     R4,SHVVALL         L(data)\n         L     R14,GETVAR-4\n         TM    SHVRET,SHVNEWV     new variable\n         BZR   R14                :no (=ok), return\n         SR    R4,R4              else zero length\n         BR    R14                return\n         TITLE 'DATA AREAS'\nVARNAMEL DS    H                  L(VARNAME)\nVARNAME  DC    CL100' '\nVN       DS    2CL16              variable-name\n         SPACE 1\nINDEX    DS    PL4\nVNINDEX  DC    CL8' ',C' '\n         SPACE 1\nD        DS    0D,PL8             double-word work-area\nWK       DS    CL6\n         SPACE 3\nNREC     DS    PL8                no. of records to be output\n         SPACE 1\nAINREC   DS    A\n         SPACE 1\n         DS    0A                 alignment\nAREC     DS    A                  .)\nRECLEN   DS    A                  .)\n         SPACE 1\nAKEY     DS    A\n         SPACE 2\nVSAM_ATTR DS   0XL12\nKEYLEN   DS    F                  VSAM key length\nLRECL    DS    F                  VSAM logical (maximum) record length\nRKP      DS    F                  relative key position\n         SPACE 1\nVSAM_FDBK DS   F\n         SPACE 1\nRECRECL  DS    F\n         SPACE 3\n         LTORG\n         SPACE 1\nPULL     DC    CL8'PULL'\nFRC      DS    F                  function return code\nAIRXMOD  DS    A\n         SPACE 1\nIRX_IRXEXCOM DC CL8'IRXEXCOM'\n         DS    0A                 align\nIRX_SHVBLOCK DC (SHVBLEN)X'0'\n         TITLE 'VSAM control blocks'\nVSAM     ACB   DDNAME=VSAM,MACRF=(KEY,DIR,DSN,OUT)\n         SPACE 2\nRPL      RPL   ACB=VSAM,OPTCD=(KEY,DIR,NUP,KEQ,FKS,MVE)\n         TITLE 'DSECTS'\n* REXX Shared Variable request Block\n         IRXSHVB\n         SPACE 1\n* VSAM ACB\n         IFGACB\n* VSAM RPL\n         IFGRPL\n         END\n\n\nA S Rudd\nSystems Programmer (Germany)                              c A S Rudd 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A004A05": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\xe4\\x01\\xe4\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 484, "newlines": 484, "modlines": 0, "user": "VSAMUPD"}, "text": "Printing Control Intervals\n\nThis Assembler program will print all, or a range, of physically\nadjacent Control Intervals, including the CIDF and any RDFs\nthat are present.  All CIs containing data will be printed in the\nactual physical sequence.  The CI containing the VSAM SEOF\nis not printed.  The program uses Control Interval access to\nperform the reading of the input VSAM object.  As a result,\nthis program may be used to print the CIs from any form of\nVSAM object: eg ESDS, KSDS, LDS, RRDS, VVDS, PATH,\nor AIX.\n\nVSAMCIP  TITLE 'PROGRAM FOR PRINTING VSAM CONTROL INTERVALS'\n         PRINT NOGEN\n         SPACE 1\n*        SUGGESTED JCL - TO PRINT DATA COMPONENT CIS (BY DEFAULT)\n         SPACE 1\n*        //       EXEC PGM=VSAMCIP\n*        //SYSUDUMP DD SYSOUT=*\n*        //SYSPRINT DD SYSOUT=*\n*        //VSAM     DD DSN=CLUSTER.NAME,DISP=SHR\n         SPACE 1\n*        OR - TO PRINT A SPECIFIC COMPONENT'S CIS\n         SPACE 1\n*        //VSAM     DD DSN=CLUSTER.NAME.INDEX,DISP=SHR\n*        OR\n*        //VSAM     DD DSN=CLUSTER.NAME.DATA,DISP=SHR\n         TITLE 'MACROS, DSECTS AND CONTROL BLOCKS USED'\n*        ABEND                          ABEND THE PROGRAM\n*        ACB                            ACCESS METHOD CONTROL BLOCK\n*        CLOSE                          CLOSE FILE(S)\n*        DCB                            DATA CONTROL BLOCK\n*        DCBD (IHADCB)                  DCB DSECT FOR MAPPING DCB\n*        EXLST                          VSAM EXIT LIST\n*        FREEMAIN                       RELEASE STORAGE\n*        FREEPOOL                       RELEASE BUFFER POOL\n*        GET - VSAM                     ACCESS A RECORD\n*        GETMAIN                        ACQUIRE STORAGE\n*        IEFJFCBN                       JFCB MAPPING\n*        IFGACB                         ACB DSECT MAPPING\n*        OPEN                           PREPARE FILE(S) FOR PROCESSING\n*        PUT - QSAM                     WRITE A RECORD\n*        RDJFCB                         READ SPECIFIC JFCB\n*        RPL                            VSAM REQUEST PARAMETER LIST\n*        SHOWCB                         OBTAIN DATA FOR VSAM OBJECT\n*        WTO                            WRITE TO OPERATOR\n         SPACE 2\n*        REGISTER EQUATES\n         SPACE 1\n         TITLE 'PROGRAM CONTROL CODE'\n*        1.    PROGRAM PROLOG\n*        2.    PROCESS OPTIONAL JOB STEP PARAMETER\n*        3.    PERFORM PROGRAM INITIALIZATION PROCESSING\n*        4.    PERFORM PROGRAM MAIN PROCESSING\n*        5.    PERFORM PROGRAM TERMINATION PROCESSING\n*        6.    PROGRAM EPILOG\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        10                             . BRANCH AND SAVE\n*        12                             . CSECT BASE REGISTER\n*        13                             . -> SAVE AREA\n*        14                             . -> RETURN\n*        15                             . -> ENTRY POINT\n         SPACE 2\nVSAMCIP  CSECT\n         STM   R14,R12,12(R13)          . SAVE CALLER'S REGISTERS\n         LR    R12,R15                  . LOAD 12 AS PROGRAM BASE\n         USING VSAMCIP,R12              . ESTABLISH ADDRESSABILITY\n         GETMAIN R,                     . GETMAIN FOR SAVE AREA        C\n               LV=72\n         ST    R13,4(,R1)               . BACKWARD SAVE AREA ->\n         ST    R1,8(,R13)               . FORWARD SAVE AREA ->\n         LR    R13,R1                   . 13 -> PROGRAM'S SAVE AREA\n         BAS   R10,JOBPARM              . PROCESS JOB STEP PARAMETER\n         BAS   R10,INITIAL              . PROGRAM INITIALIZATION\n         BAS   R10,PROCESS              . MAIN PROCESSING\n         BAS   R10,TERMIN               . TERMINATION PROCESSING\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN SAVE AREA           C\n               LV=72,                                                  C\n               A=(R2)\n         L     R14,12(,R13)             . 14 -> RETURN\n         SLR   R15,R15                  . 15 - ZERO\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         TITLE 'CODE PROCESSING THE OPTIONAL JOB STEP PARAMETER'\n*        1.    ACCESS CALLER'S SAVE AREA\n*        2.    CHECK LENGTH OF PARAMETER\n*        3.    IF NOT PRESENT, DEFAULT TO ALL FILE\n*        4.    IF PRESENT, EDIT FOR NUMERIC\n*        5.    IF NOT NUMERIC, DEFAULT TO ALL FILE\n*        6.    SAVE RANGE OF CIS TO BE PROCESSED\n*        REGISTER USAGE\n*        1                              . WORK\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nJOBPARM  EQU   *\n         MVI   PARM,OFF                 . SWITCH OFF PARAMETER SWITCH\n         L     R1,4(,R13)               . 1 -> CALLER'S SAVE AREA\n         L     R1,24(,R1)               . 1 -> ADDRESS OF PARAMETER\n         L     R1,0(,R1)                . 1 -> PARAMETER\n         OC    0(2,R1),0(R1)            . Q. PARAMETER PRESENT?\n         BZR   R10                      . A. NO - EXIT\n         MVC   TEST(18),ZEROS           . CHECK FOR NUMERIC DATA\n         MVZ   TEST(18),2(R1)\n         CLC   TEST(18),ZEROS           . Q. NUMERIC DATA ENTERED?\n         BNE   B0001                    . A. NO - ABEND\n         MVI   PARM,ON                  . INDICATE PARAMETER VALID\n         PACK  FROM#(5),2(9,R1)         . SAVE START OF RANGE\n         PACK  TO#(5),11(9,R1)          . SAVE END OF RANGE\n         BR    R10                      . EXIT\nB0001    EQU   *\n*                                       . PARAMETER NOT NUMERIC\n         WTO   'JOB STEP PARAMETER SPECIFIED NOT NUMERIC',             C\n               ROUTCDE=11\n         ABEND 101,                                                    C\n               DUMP\n         TITLE 'PROGRAM INITIALIZATION PROCESSING'\n*        1.    ISSUE READ JFCB\n*        2.    INITIALIZE DATA AREAS\n*        3.    OPEN FILES AND CHECK OPENS\n*        4.    DETERMINE CI SIZE\n*        5.    COMPUTE NUMBER OF 'PASSES' REQUIRED TO PRINT CI\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . -> DCB\n*                                       . -> ACB\n*                                       . WORK\n*        3                              . COMPUTATION\n*        4                              . COMPUTATION\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nINITIAL  EQU   *\n         RDJFCB DUMMY                   . GO GET JFCB\n         LTR   R15,R15                  . Q. RDJFCB WORK?\n         BNZ   C0001                    . A. NO\n         MVC   DSNTITLE,JFCBDSNM        . MOVE OUT DSN\nC0001    EQU   *\n         ZAP   #READ,=P'+0'             . INITIALIZE DATA AREAS\n         ZAP   #PRINT,=P'+0'\n         ZAP   #LINE,=P'+60'\n         ZAP   #PAGE,=P'+1'\n         OPEN  (VSAM,,SYSPRINT,OUTPUT)  . OPEN FILES\n         LTR   R15,R15                  . Q. OPEN OKAY?\n         BZ    C0002                    . A. YES\n         LA    R2,SYSPRINT              . 2 -> SYSPRINT DCB\n         USING IHADCB,R2                . USE DSECT TO MAP DCB\n         TM    DCBOFLGS,DCBOFOPN        . Q. OPEN OF SYSPRINT OK?\n         BO    C0003                    . A. OPEN FAILED\n         DROP  R2                       . DCB DSECT NOT REQUIRED\n         LA    R2,VSAM                  . 2 -> VSAM ACB\n         USING IFGACB,R2                . ACB DSECT ADDRESSABILITY\n         TM    ACBOFLGS,ACBOPEN         . Q. VSAM OPEN OKAY?\n         BNO   C0004                    . A. OPEN FAILED\n         DROP  R2                       . ACB DSECT NOT REQUIRED\nC0002    EQU   *\n         SHOWCB ACB=VSAM,               . DETERMINE CI SIZE            C\n               AREA=CISZ,                                              C\n               FIELDS=CINV,                                            C\n               LENGTH=4\n         L     R2,CISZ                  . 2 - CONTROL INTERVAL SIZE\n         CVD   R2,WORKD                 . CONVERT CI SIZE TO DECIMAL\n         MVC   CISIZE,MASK5             . PUT EDIT MASK IN THE OUTPUT\n         ED    CISIZE,WORKD+5\n         SH    R2,=H'+4'                . SUBTRACT FOUR FROM CI SIZE\n         ST    R2,CIDFDISP              . SAVE CIDF DISPLACEMENT\n*                                       . COMPUTE NUMBER OF PASSES\n         L     R3,CISZ                  . 3 - CONTROL INTERVAL SIZE\n         LA    R4,1                     . 4 - ONE\n         C     R3,=F'+16384'            . Q. CI SIZE > 16384?\n         BNH   *+8                      . A. NO\n         LA    R4,2                     . 4 - TWO\n         SLR   R2,R2                    . 2 - ZERO\n         D     R2,=F'+129'              . DIVIDE CI SIZE BY 129\n         AR    R3,R4                    . INCREMENT QUOTIENT BY\n*                                       .   CONTENT OF 4\n         ST    R3,#PASSES               . STORE NUMBER OF PASSES\n*                                       .   PER CONTROL INTERVAL\n         BR    R10                      . EXIT\n         TITLE 'PROGRAM INITIALIZATION - ERRORS'\nC0003    EQU   *\n*                                       . OPEN FAILURE SYSPRINT\n         WTO   'OPEN FAILURE FOR FILE SYSPRINT',                       C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN OF SAVE AREA        C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,10                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         SPACE 2\nC0004    EQU   *\n*                                       . OPEN FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         WTO   'OPEN FAILURE FOR FILE VSAM',                           C\n               ROUTCDE=11\n*                                       . GET ACB ERROR CODE\n         SHOWCB ACB=VSAM,                                              C\n               AREA=OPENERR,                                           C\n               FIELDS=ERROR,                                           C\n               LENGTH=4\n         LM    R2,R3,VSAMERR            . 2 - 3 VSAM ERROR CODES\n         ABEND 102,                     . ABEND TASK                   C\n               DUMP\n         TITLE 'PROGRAM MAIN PROCESSING'\n*        1.    GET NEXT PHYSICAL CI\n*        2.    DETERMINE IF WITHIN REQUESTED RANGE\n*        3.    IF PRIOR TO START OF RANGE, IGNORE\n*        4.    IF AFTER END OF RANGE - EXIT\n*        5.    FORMAT CI HEADING\n*        6.    EXAMINE CIDF FREE SPACE OFFSET\n*        7.    IF CI EMPTY, PRINT EMPTY, IGNORE FROM FURTHER\n*              PROCESSING\n*        8.    IF NOT EMPTY, PRINT THE CONTENT, 128 BYTES PER\n*              LINE\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . CIDF DISPLACEMENT\n*                                       . -> CIDF\n*        3                              . NUMBER OF PASSES\n*        5                              . -> CI\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nPROCESS  EQU   *\n         ST    R10,DSAVE                . SAVE 10\nD0001    EQU   *\n         GET   RPL=GETRPL               . GET THE NEXT CI\n         LTR   R15,R15                  . Q. GET ON VSAM OK?\n         BNZ   D0009                    . A. NO - GET FAILED\n         AP    #READ,=P'+1'             . NUMBER OF CIS PROCESSED\n         CLI   PARM,ON                  . Q. RANGE PARAMETER SPECIFIED?\n         BNE   D0002                    . A. NO\n         CP    #READ,FROM#              . Q. BEFORE START POINT?\n         BL    D0001                    . A. YES - READ NEXT CI\n         CP    #READ,TO#                . Q. AFTER END POINT?\n         BH    D0008                    . A. YES - END OF TASK\nD0002    EQU   *\n         MVC   CINUM,MASK9              . OUTPUT EDIT MASK\n         ED    CINUM,#READ\n         L     R5,@CI                   . 5 -> CI\n         L     R2,CIDFDISP              . 2 - CIDF DISPLACEMENT\n         LA    R2,0(R2,R5)              . 2 -> CIDF\n         OC    0(2,R2),0(R2)            . Q. ANY DATA IN CI?\n         BNZ   D0004                    . A. YES\n         MVC   CONTIN,=C'EMPTY    '     . EMPTY CI\n         CP    #LINE,=P'+57'            . Q. PAGE HEADINGS REQUIRED?\n         BL    D0003                    . A. NO\n         BAS   R10,HEADING              . OUTPUT REPORT HEADINGS\nD0003    EQU   *\n         PUT   SYSPRINT,                . OUTPUT CI NUMBER ...         C\n               STITLE3\n         MVC   CONTIN,=9C' '\n         AP    #LINE,=P'+2'             . INCREMENT LINE NUMBER\n         AP    #PRINT,=P'+1'            . INCREMENT PRINT COUNT\n         B     D0001                    . GO GET NEXT PHYSICAL CI\nD0004    EQU   *                        . GET SET TO PRINT CI\n         MVC   CONTIN,=9C' '\n         L     R3,#PASSES               . 3 - NUMBER OF PASSES\nD0005    EQU   *\n         CP    #LINE,=P'+57'            . Q. PAGE HEADINGS REQUIRED?\n         BL    D0006                    . A. NO\n         BAS   R10,HEADING              . OUTPUT HEADINGS\n         PUT   SYSPRINT,                . OUTPUT CI NUMBER             C\n               STITLE3\n         MVC   CONTIN,=C'CONTINUED'     . INDICATE CONTINUATION\n*                                       .   FOR NEXT TIME POSSIBLY\n         AP    #LINE,=P'+2'             . INCREMENT LINES OUTPUT\nD0006    EQU   *\n         CLI   CONTIN,C'C'              . Q. CI NUMBER TO BE OUTPUT?\n         BE    D0007                    . A. NO\n         PUT   SYSPRINT,                . OUTPUT CI NUMBER             C\n               STITLE3\n         MVC   CONTIN,=C'CONTINUED'\n         AP    #LINE,=P'+2'             . INCREMENT LINES OUTPUT\nD0007    EQU   *\n         MVI   OUTLINE,C'0'             . SET ASA CONTROL CHARACTER\n         MVC   OUTLINED,0(R5)           . OUTPUT EBCDIC DATA\n         TR    OUTLINED,PRTBL           . MAKE PRINTABLE\n         PUT   SYSPRINT,                . OUTPUT CHARACTER DATA        C\n               OUTLINE\n         MVI   OUTLINE,C' '             . RESET ASA CONTROL CHARACTER\n         MVC   OUTLINED,0(R5)           . PROCESS ZONE NIBBLES\n         NC    OUTLINED,=128X'F0'\n         TR    OUTLINED,ZONETBL\n         PUT   SYSPRINT,                . OUTPUT ZONE NIBBLES          C\n               OUTLINE\n         MVC   OUTLINED,0(R5)           . PROCESS NUMERIC NIBBLES\n         NC    OUTLINED,=128X'0F'\n         TR    OUTLINED,NUMTBL\n         PUT   SYSPRINT,                . OUTPUT NUMERIC NIBBLES       C\n               OUTLINE\n         AP    #LINE,=P'+4'             . INCREMENT LINES PRINTED\n         LA    R5,128(,R5)              . INDEX ALONG INPUT CI\n         BCT   R3,D0005                 . OUTPUT REST OF CI\n         AP    #PRINT,=P'+1'            . INCREMENT CIS PRINTED\n         B     D0001                    . GO GET NEXT CI\nD0008    EQU   *\n         L     R10,DSAVE                . RESTORE 10\n         BR    R10                      . EXIT\n         TITLE 'MAIN PROCESSING LOGIC - GET ERROR'\nD0009    EQU   *\n*                                       . GET FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         WTO   'GET FAILURE FOR FILE VSAM',                            C\n               ROUTCDE=11\n*                                       . GET RPL FEED BACK CODE\n         SHOWCB RPL=GETRPL,                                            C\n               AREA=RPLFDBK,                                           C\n               FIELDS=FDBK,                                            C\n               LENGTH=4\n         LM    R2,R4,VSAMERR            . 2 - 4 VSAM ERROR CODES\n         LA    R3,VSAM                  . 3 -> ACB\n         ABEND 103,                     . ABEND TASK                   C\n               DUMP\n         TITLE 'END OF PROCESSING ROUTINE'\n*        1.    OUTPUT TOTALS\n*        2.    CLOSE FILES\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nTERMIN   EQU   *\n         ST    R10,ESAVE                . SAVE 10\n         BAS   R10,HEADING              . FORCE PAGE CHANGE\n         MVC   RECOUT,MASK9             . OUTPUT CIS PRINTED\n         ED    RECOUT,#PRINT\n         PUT   SYSPRINT,                                               C\n               STITLE4\n         CLOSE (VSAM,,SYSPRINT)         . CLOSE FILES\n         FREEPOOL SYSPRINT              . RELEASE BUFFER POOL\n         L     R10,ESAVE                . RESTORE 10\n         BR    R10                      . EXIT\n         TITLE 'REPORT PAGE HEADING ROUTINE'\n*        1.    OUTPUT PAGE NUMBER\n*        2.    OUTPUT HEADING LINES\n*        3.    RESET ACCUMULATORS\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nHEADING  EQU   C\n         MVC   PAGEOUT,MASK5            . OUTPUT PAGE NUMBER\n         ED    PAGEOUT,#PAGE\n         PUT   SYSPRINT,                . PRIMARY HEADING              C\n               TITLE\n         PUT   SYSPRINT,                . SECONDARY HEADING LINES      C\n               STITLE1\n         PUT   SYSPRINT,                                               C\n               STITLE2\n         AP    #PAGE,=P'+1'             . INCREMENT PAGE NUMBER\n         ZAP   #LINE,=P'+4'             . RESET LINE NUMBER\n         BR    R10                      . RETURN FROM WHENCE THOU CAME\n         TITLE 'DATA AREAS'\nWORKD    DS    D                        . USED IN CVD INSTRUCTIONS\n@CI      DS    F                        . ADDRESS OF CI READ\n#PASSES  DS    F                        . NUMBER OF PASSES TO PRINT CI\nCISZ     DS    F                        . CI SIZE\nCIDFDISP DS    F                        . CIDF DISPLACEMENT\nDSAVE    DS    F                        . REGISTER SAVE AREA\nESAVE    DS    F                        . REGISTER SAVE AREA\nVSAMERR  DS    0F                       . VSAM ERROR AREA\nREG15    DS    F                        . CONTENT OF REGISTER 15\nOPENERR  DS    F                        . ACB ERROR CODE\nRPLFDBK  DS    F                        . RPL FEED BACK CODE\n#READ    DS    PL5                      . NUMBER OF CIS READ\n#PRINT   DS    PL5                      . NUMBER OF CIS PRINTED\nFROM#    DS    PL5                      . RANGE START\nTO#      DS    PL5                      . RANGE END\n#LINE    DS    PL2                      . LINES ON PAGE\n#PAGE    DS    PL3                      . PAGE NUMBER\nPARM     DS    CL1                      . JOB STEP PARAMETER SWITCH\nON       EQU   X'01'                    . LOGICAL - ON\nOFF      EQU   X'00'                    . LOGICAL - OFF\nTEST     DS    CL18                     . NUMERIC TEST WORK AREA\nZEROS    DC    18C'0'                   . NUMERIC TEST DATA\nMASK5    DC    X'402020202120'          . EDIT MASK\nMASK9    DC    X'40202020202020202120'  . EDIT MASK\n*                                       . PRINT LINES\nTITLE    DC    CL21'1'\n         DC    CL34'CONTROL INTERVAL PRINT OF OBJECT: '\nDSNTITLE DC    CL44' '\n         DC    CL19' '\n         DC    CL4'PAGE'\nPAGEOUT  DS    CL6\n         DC    CL5' '\nSTITLE1  DC    CL5' '\n         DC    CL48'               1               2               3'\n         DC    CL48'               4               5               6'\n         DC    CL32'               7               8'\nSTITLE2  DC    CL5' '\n         DC    CL48'123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0'\n         DC    CL48'123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0'\n         DC    CL32'123456789ABCDEF0123456789ABCDEF0'\nSTITLE3  DC    CL11'0CI NUMBER '\nCINUM    DS    CL10\n         DC    CL26'    CONTROL INTERVAL SIZE '\nCISIZE   DS    CL6\n         DC    CL6' '\nCONTIN   DS    CL9\n         DC    CL65' '\nSTITLE4  DC    CL13'-CIS PRINTED '\nRECOUT   DS    CL10\n         DC    CL110' '\nOUTLINE  DC    CL5' '\nOUTLINED DC    CL128' '\n         TITLE 'TRANSLATE TABLES'\nNUMTBL   DC    C'0123456789ABCDEF'\nZONETBL  DC    C'0',15C'*',C'1',15C'*',C'2',15C'*',C'3',15C'*'\n         DC    C'4',15C'*',C'5',15C'*',C'6',15C'*',C'7',15C'*'\n         DC    C'8',15C'*',C'9',15C'*',C'A',15C'*',C'B',15C'*'\n         DC    C'C',15C'*',C'D',15C'*',C'E',15C'*',C'F',15C'*'\nPRTBL    DC    256C'.'\n         ORG   PRTBL+X'40'\n         DC    X'40'\n         ORG   PRTBL+X'4A'\n         DC    X'4A4B4C4D4E4F50'\n         ORG   PRTBL+X'5A'\n         DC    X'5A5B5C5D5E5F6061'\n         ORG   PRTBL+X'6B'\n         DC    X'6B6C6D6E6F'\n         ORG   PRTBL+X'7A'\n         DC    X'7A7B7C7D7E7F'\n         ORG   PRTBL+X'81'\n         DC    X'818283848586878889'\n         ORG   PRTBL+X'91'\n         DC    X'919293949596979899'\n         ORG   PRTBL+X'A2'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG   PRTBL+X'C1'\n         DC    X'C1C2C3C4C5C6C7C8C9'\n         ORG   PRTBL+X'D1'\n         DC    X'D1D2D3D4D5D6D7D8D9'\n         ORG   PRTBL+X'E2'\n         DC    X'E2E3E4E5E6E7E8E9'\n         ORG   PRTBL+X'F0'\n         DC    X'F0F1F2F3F4F5F6F7F8F9'\n         ORG\n         TITLE 'CONTROL BLOCKS'\nVSAM     ACB   AM=VSAM,                                                C\n               DDNAME=VSAM,                                            C\n               EXLST=EXITLST,                                          C\n               MACRF=(CNV,SEQ,IN)\nEXITLST  EXLST EODAD=D0008\nGETRPL   RPL   ACB=VSAM,                                               C\n               AM=VSAM,                                                C\n               AREA=@CI,                                               C\n               AREALEN=4,                                              C\n               OPTCD=(CNV,SEQ,LOC)\nSYSPRINT DCB   BLKSIZE=15428,                                          C\n               DDNAME=SYSPRINT,                                        C\n               DSORG=PS,                                               C\n               LRECL=133,                                              C\n               MACRF=PM,                                               C\n               RECFM=ABFS\nDUMMY    DCB   DDNAME=VSAM,                                            C\n               DSORG=PS,                                               C\n               EXLST=DCBEXIT,                                          C\n               MACRF=GM\n         DS    0F                       . FULL WORD ALIGN DCB EXIT\nDCBEXIT  EQU   *                        . DCB EXIT FOR JFCB\n         DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN                       . MAPPING FOR JFCB\n         DCBD  DEVD=DA,                 . DSECT MAPPING DCB            C\n               DSORG=PS\n         IFGACB                         . DSECT MAPPING ACB\n         TITLE 'LITERALS AND TERMINATION'\nVSAMCIP  CSECT                          . RE-ESTABLISH CSECT\n         LTORG\n         END\n\n\nDave Loveluck\nInstructor/Consultant (USA)                        c Dave Loveluck 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A004A06": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\xb4\\x01\\xb4\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 436, "newlines": 436, "modlines": 0, "user": "VSAMUPD"}, "text": "Quick listing of VSAM files\nThis program can be used to print a more readable VSAM\ncatalog listing for evaluating the condition of CICS/VSAM\nfiles.  The report is sorted alphabetically on name, and printed\nwith a space whenever the first three characters of the name\nchange.  Submit the JCL once for each catalog to be used.  A\ncontrol card of 'D' prints the data portion only, 'B' will print\nboth data and index, and 'A' will print the cluster, AIX, and\npath names, along with both data and index entries.\n\nVSAM gives space usage of files in tracks.  FBA users can\nchange space computations to match their devices number of\nblocks per track. CKD users may need to make changes.  The\ncurrent settings are for 9335 DASD with 71 blocks per track,\n426 blocks per cylinder.\n\n* $$ JOB JNM=QUICKCAT,CLASS=0,DISP=D\n* $$ LST DISP=H,CLASS=Q\n// JOB QUICKCAT\n// LIBDEF PHASE,CATALOG=USERLIB.GENERAL\n// OPTION CATAL\n   PHASE QUICKCAT,*\n// EXEC FCOBOL,SIZE=400K\n CBL ADV,APOST,STATE\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.    QUICKCAT.\n       AUTHOR.        TOM WEIDEMAN.\n       DATE-WRITTEN.  10/22/91.\n       DATE-COMPILED.\n      * EXAMPLE JCL                                                   *\n      * // DLBL IJSYSUC,'SYSWKB.USER.CATALOG',,VSAM,CAT=IJSYSCT       *\n      * // DLBL CATALOG,'SYSWKB.USER.CATALOG',,VSAM,CAT=IJSYSUC       *\n      * // EXEC QUICKCAT,SIZE=(AUTO,100K)                             *\n      * B                                                             *\n      * /*                                                            *\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.    IBM-4331.\n       OBJECT-COMPUTER.    IBM-4331.\n       SPECIAL-NAMES.      C01 IS TOP-OF-PAGE.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT CAT-FILE ASSIGN TO SYS032-DA-FBA1-CATALOG\n               ORGANIZATION IS INDEXED\n               ACCESS MODE IS SEQUENTIAL\n               RECORD KEY IS CAT-KEY.\n           SELECT PRINTER ASSIGN TO SYS007-UR-1403-S.\n           SELECT SORT-FILE ASSIGN TO SYS001-DA-FBA1-S-SORTWK1.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  CAT-FILE\n           LABEL RECORDS ARE STANDARD\n           RECORD CONTAINS 505 CHARACTERS\n           DATA RECORD IS CAT-RECORD.\n       01  CAT-RECORD.\n           05  CAT-KEY.\n               10  CAT-PREFIX      PIC XX.\n               10  CAT-CI-NUM      PIC 9(4)    COMP.\n               10  FILLER          PIC X(40).\n           05  CAT-REC-TYPE        PIC X.\n           05  CAT-REC-LEN         PIC 9(4)    COMP.\n           05  FILLER              PIC X(2).\n           05  ENTRY-NAME          PIC X(44).\n           05  FILLER              PIC X(8).\n           05  CREATE-DATE         PIC 9(5)    COMP-3.\n           05  EXPIRE-DATE         PIC 9(5)    COMP-3.\n           05  ATTRB-BYTE          PIC X.\n           05  SHROPT-BYTE         PIC X.\n           05  FILLER              PIC X(6).\n           05  SPACE-PRI           PIC 9(4)    COMP.\n           05  FILLER              PIC X.\n           05  SPACE-SEC           PIC 9(4)    COMP.\n           05  FILLER              PIC X.\n           05  HU-RBA              PIC 9(9)    COMP.\n           05  HA-RBA              PIC 9(9)    COMP.\n           05  AVE-REC-L           PIC 9(9)    COMP.\n           05  FILLER              PIC X(15).\n           05  NUM-GROUP-PTRS      PIC X.\n           05  FIVE-POINTER-FORMAT.\n               10  FIVE-5-BYTE-PTRS     PIC X(25).\n               10  FIVE-PTR-GROUP       PIC X(309).\n               10  9TH-EXTENT-INFO      PIC X(20).\n               10  FILLER               PIC XX.\n           05  SIX-POINTER-FORMAT REDEFINES FIVE-POINTER-FORMAT.\n               10  SIX-5-BYTE-PTRS      PIC X(30).\n               10  SIX-PTR-GROUP        PIC X(309).\n               10  FILLER               PIC X(17).\n       FD  PRINTER\n           LABEL RECORDS ARE OMITTED\n           RECORD CONTAINS 132 CHARACTERS\n           DATA RECORD IS PRINT-LINE.\n       01  PRINT-LINE              PIC X(132).\n       SD  SORT-FILE\n           RECORD CONTAINS 132 CHARACTERS\n           DATA RECORD IS SORT-RECORD.\n       01  SORT-REC.\n           05  SK1                 PIC XX.\n           05  SK2                 PIC X(36).\n           05  FILLER              PIC X(94).\n       WORKING-STORAGE SECTION.\n       01  FILLER      PIC X(27)   VALUE 'WORKING STORAGE STARTS HERE'.\n       01  CARD-IN.\n           05  PRT-SWT         PIC X     VALUE 'D'.\n           05  FILLER          PIC X(79) VALUE  SPACES.\n      * FIELD POSITIONS IN COL. 74-80 VALID WITH 5-POINTER FORMAT  *\n      * ELSE ADD 5 FOR 6-POINTER FORMAT.                           *\n       01  RECORD-OFFSET-AREA.\n           05  FILLER              PIC X(10).\n           05  KEY-LEN             PIC 9(4)    COMP.\n           05  FREE-CA             PIC X.\n           05  FREE-CI             PIC X.\n           05  FILLER              PIC X(8).\n           05  CI-SIZE             PIC 9(9)    COMP.\n           05  MAX-REC-L           PIC 9(9)    COMP.\n           05  FILLER              PIC X(30).\n           05  NUM-EXTENTS         PIC 9(4)    COMP.\n           05  REC-TOTAL           PIC 9(9)    COMP.\n           05  REC-DELETED         PIC 9(9)    COMP.\n           05  REC-INSERTED        PIC 9(9)    COMP.\n           05  REC-UPDATED         PIC 9(9)    COMP.\n           05  REC-RETRIEVED       PIC 9(9)    COMP.\n           05  FREE-SPACE-BYTES    PIC 9(9)    COMP.\n           05  CI-SPLITS           PIC 9(9)    COMP.\n           05  CA-SPLITS           PIC 9(9)    COMP.\n           05  EXCPS               PIC 9(9)    COMP.\n           05  FILLER              PIC X(26).\n           05  HIGH-USED-RBA       PIC 9(9)    COMP.\n           05  FILLER              PIC X(203).\n       01  HEAD-ONE.\n           05  FILLER      PIC X(24)  VALUE 'QUICKCAT CATALOG LISTING'. '.\n           05  FILLER      PIC X(32)  VALUE SPACES.\n           05  CAT-OUT     PIC X(44).\n           05  FILLER      PIC X(09)  VALUE  SPACES.\n           05  FILLER      PIC X(5)   VALUE  'DATE '.\n           05  DATE-O      PIC X(8).\n           05  FILLER      PIC X(6)   VALUE  '  PAGE'.\n           05  PAGE-O      PIC ZZZ9.\n       01  HEAD-TWO.\n           05  FILLER      PIC X(44)   VALUE\n              '                                        CREA'.\n           05  FILLER      PIC X(44)   VALUE\n              'TE   SPACE  SPACE  EX  PCT.   -SPLIT-   FREE'.\n           05  FILLER      PIC X(44)   VALUE\n              'SPACE   CI   ---------RECORD-------- SHR REU'.\n       01  HEAD-THREE.\n           05  FILLER      PIC X(44)   VALUE\n              'TYPE     ENTRY NAME                      DAT'.\n           05  FILLER      PIC X(44)   VALUE\n              'E     PRI    SEC   TS  FULL   CI   CA    CI '.\n           05  FILLER      PIC X(44)   VALUE\n              '  CA   SIZE  AVE-L MAX-L KEY-L TOTAL OPT SPD'.\n       01  NAME-LINE.\n           05  TYPE-N          PIC X.\n           05  FILLER          PIC X      VALUE  SPACES.\n           05  NAME-N          PIC X(44).\n           05  FILLER          PIC X(86)   VALUE  SPACES.\n       01  DETAIL-LINE.\n           05  TYPE-O          PIC XX.\n           05  NAME-O.\n               10  NAME-P      PIC XXX.\n               10  FILLER      PIC X(33).\n           05  FILLER          PIC X.\n           05  CDATE-O.\n               10  MM-O        PIC XX.\n               10  SLASH-1     PIC X.\n               10  DD-O        PIC XX.\n               10  SLASH-2     PIC X.\n               10  YY-O        PIC XX.\n           05  SPACE-PRI-O     PIC ZZZZZZ9.\n           05  SPACE-SEC-O     PIC ZZZZZZ9.\n           05  NUM-EXTENTS-O   PIC ZZZ9.\n           05  PCT-FULL-O      PIC ZZZZ9.\n           05  PCTSIGN1-O      PIC X.\n           05  IDX-ED1.\n               10  CI-SPLIT-O      PIC ZZZZ9.\n               10  CA-SPLIT-O      PIC ZZZZ9.\n               10  FREE-CI-O       PIC ZZZZ9.\n               10  PCTSIGN2-O      PIC X.\n               10  FREE-CA-O       PIC ZZZ9.\n               10  PCTSIGN3-O      PIC X.\n           05  CISIZE-O        PIC ZZZZZZ9.\n           05  AVE-REC-L-O     PIC ZZZZZ9.\n           05  MAX-REC-L-O     PIC ZZZZZ9.\n           05  KEY-LEN-O       PIC ZZZZ9.\n           05  REC-TOTAL-O     PIC ZZZZZZ9-.\n           05  SHROPT-O        PIC ZZ9.\n           05  FILLER          PIC XXX.\n           05  REUSE-O         PIC XX.\n      * WORK AREAS\n       01  BIN-DATA            PIC S9(4) COMP.\n       01  FILLER REDEFINES BIN-DATA.\n           05  FILLER          PIC X.\n           05  BIN-BYTE        PIC X.\n       01  HIGH-USED-BLOCK     PIC 9(9)       COMP-3  VALUE 0.\n       01  SPACE-PRI-SAVE      PIC 9(7)       COMP-3  VALUE 0.\n       01  SPACE-SEC-SAVE      PIC 9(7)       COMP-3  VALUE 0.\n       01  PCT-FULL-SAVE       PIC 9(5)       COMP-3  VALUE 0.\n       01  LINE-COUNT          PIC 999        COMP-3  VALUE 99.\n       01  PAGE-COUNT          PIC 999        COMP-3  VALUE 0.\n       01  EOF                 PIC 9          COMP-3  VALUE 0.\n       01  NAME-SAVE           PIC XXX        VALUE  SPACES.\n      * DATE CONVERSION AREA *\n       01  WRKDATE-CONVERSION.\n           02  WRKDT-SUB               PIC S999 COMP.\n           02  WRKDT-DOW               PIC S9 COMP-3.\n           02  WRKDT-RESULT            PIC S9(7) COMP-3.\n           02  WRKDT-WORK              PIC S9(7) COMP-3.\n           02  WRKDT-WRK               REDEFINES WRKDT-WORK.\n               03  FILLER              PIC XX.\n               03  WRKDT-RMDR          PIC 999 COMP-3.\n           02  WRKDT-TABLE             COMP-3.\n               03  FILLER              PIC S999 VALUE +000.\n               03  FILLER              PIC S999 VALUE +031.\n               03  FILLER              PIC S999 VALUE +059.\n               03  FILLER              PIC S999 VALUE +090.\n               03  FILLER              PIC S999 VALUE +120.\n               03  FILLER              PIC S999 VALUE +151.\n               03  FILLER              PIC S999 VALUE +181.\n               03  FILLER              PIC S999 VALUE +212.\n               03  FILLER              PIC S999 VALUE +243.\n               03  FILLER              PIC S999 VALUE +273.\n               03  FILLER              PIC S999 VALUE +304.\n               03  FILLER              PIC S999 VALUE +334.\n               03  FILLER              PIC S999 VALUE +365.\n           02  WRKDT-TBLE              REDEFINES WRKDT-TABLE.\n               03  WRKDT-DOM           PIC S999 COMP-3 OCCURS 13.\n           02  WRKDT-DATE              PIC 9(6).\n           02  WRKDT-DATEX             REDEFINES WRKDT-DATE.\n               03  WRKDT-MON           PIC 99.\n               03  WRKDT-DAY           PIC 99.\n               03  WRKDT-YR            PIC 99.\n           02  WRKDT-JULIAN            PIC 9(7).\n           02  WRKDT-JULIANX           REDEFINES WRKDT-JULIAN.\n               03  WRKDT-JULYR         PIC 9(4).\n               03  WRKDT-JULDAYS       PIC 999.\n           02  WRKDV-NUMBER.\n               03  WRKDV-DIG           PIC X.\n               03  WRKDV-NBR           PIC X(5).\n           02  WRKDV-TABLE.\n               03  FILLER              PIC X(24)\n                   VALUE '312831303130313130313031'.\n           02  WRKDV-TBLE              REDEFINES WRKDV-TABLE.\n               03  WRKDV-MON           PIC 99 OCCURS 12 TIMES.\n           02  WRKDT-DATE1             PIC S9(7) COMP-3.\n           02  WRKDT-DATE2             PIC S9(7) COMP-3.\n           02  WRKDT-LEAP              PIC S9(7) COMP-3.\n           02  WRKDT-LEAPX REDEFINES WRKDT-LEAP PIC S9(4)V999 COMP-3.\n       01  FILLER      PIC X(25)   VALUE 'WORKING STORAGE ENDS HERE'.\n       PROCEDURE DIVISION.\n       START-PROGRAM.\n           OPEN INPUT  CAT-FILE\n                OUTPUT PRINTER.\n           ACCEPT CARD-IN.\n           IF  PRT-SWT EQUAL 'A' OR EQUAL 'B' OR EQUAL 'D'\n               NEXT SENTENCE\n           ELSE\n               DISPLAY 'CONTROL CARD INVALID OR MISSING'\n               DISPLAY 'MUST BE  \"A\" OR \"B\" OR \"D\"'\n               GO TO STOP-PROGRAM.\n           SORT SORT-FILE ON ASCENDING KEY SK2, SK1\n               INPUT PROCEDURE IS READ-SORT-CAT THRU RSC-EXIT\n               OUTPUT PROCEDURE IS PRINT-SORT-CAT THRU PSC-EXIT.\n       STOP-PROGRAM.\n           CLOSE CAT-FILE, PRINTER.\n           STOP RUN.\n       READ-SORT-CAT SECTION.\n           PERFORM READ-LOOP THRU RL-EXIT\n               UNTIL EOF EQUAL 1.\n           GO TO RSC-EXIT.\n       READ-LOOP.\n           READ CAT-FILE\n                AT END MOVE 1 TO EOF\n                       GO TO RL-EXIT.\n           IF  CAT-CI-NUM EQUAL 0 OR EQUAL 1\n               GO TO RL-EXIT.\n           IF  CAT-CI-NUM EQUAL 2 AND CAT-REC-TYPE EQUAL 'C'\n               MOVE ENTRY-NAME TO CAT-OUT\n               GO TO RL-EXIT.\n           IF  CAT-REC-TYPE EQUAL 'C' OR EQUAL 'G' OR EQUAL 'R'\n               IF  PRT-SWT EQUAL 'A'\n                   MOVE CAT-REC-TYPE   TO TYPE-N\n                   MOVE ENTRY-NAME TO NAME-N\n                   MOVE NAME-LINE TO SORT-REC\n                   RELEASE SORT-REC\n                   GO TO RL-EXIT.\n           IF  CAT-REC-TYPE EQUAL 'I'\n               IF  PRT-SWT EQUAL 'A' OR EQUAL 'B'\n                   PERFORM DETAIL-ROUTINE THRU DR-EXIT\n                   GO TO RL-EXIT.\n           IF  CAT-REC-TYPE EQUAL 'D'\n               PERFORM DETAIL-ROUTINE THRU DR-EXIT.\n       RL-EXIT. EXIT.\n       DETAIL-ROUTINE.\n           MOVE SPACES TO DETAIL-LINE.\n           MOVE ZERO TO BIN-DATA.\n           MOVE NUM-GROUP-PTRS TO BIN-BYTE.\n           IF  BIN-DATA IS EQUAL 5\n               MOVE FIVE-PTR-GROUP TO RECORD-OFFSET-AREA\n           ELSE\n              IF  BIN-DATA IS EQUAL 6\n                  MOVE SIX-PTR-GROUP TO RECORD-OFFSET-AREA\n              ELSE\n                  DISPLAY 'UNDETERMINED RECORD TYPE ', ENTRY-NAME\n                  GO TO DR-EXIT.\n           MOVE CREATE-DATE  TO WRKDT-JULIAN.\n           PERFORM GREGORIAN THRU GREGORIAN-EXIT.\n           MOVE '/' TO SLASH-1, SLASH-2.\n           MOVE WRKDT-MON TO MM-O.\n           MOVE WRKDT-DAY TO DD-O.\n           MOVE WRKDT-YR  TO YY-O.\n           MULTIPLY SPACE-PRI BY 71 GIVING SPACE-PRI-SAVE.\n           MULTIPLY SPACE-SEC BY 71 GIVING SPACE-SEC-SAVE.\n           COMPUTE HIGH-USED-BLOCK = ( HU-RBA / 512 ) * 100.\n           COMPUTE PCT-FULL-SAVE ROUNDED =\n                                 ( HIGH-USED-BLOCK / SPACE-PRI-SAVE).\n           IF  AVE-REC-L EQUAL -1 MOVE 0 TO AVE-REC-L.\n           MOVE '???' TO REUSE-O.\n           MOVE ZERO TO BIN-DATA.\n           MOVE ATTRB-BYTE TO BIN-BYTE.\n           IF BIN-DATA EQUAL  00 MOVE '--' TO REUSE-O.\n           IF BIN-DATA EQUAL  32 MOVE 'R-' TO REUSE-O.\n           IF BIN-DATA EQUAL  48 MOVE 'R-' TO REUSE-O.\n           IF BIN-DATA EQUAL  64 MOVE '--' TO REUSE-O.\n           IF BIN-DATA EQUAL  96 MOVE 'R-' TO REUSE-O.\n           IF BIN-DATA EQUAL 112 MOVE 'R-' TO REUSE-O.\n           IF BIN-DATA EQUAL 128 MOVE '-S' TO REUSE-O.\n           IF BIN-DATA EQUAL 160 MOVE 'RS' TO REUSE-O.\n           IF BIN-DATA EQUAL 192 MOVE '-S' TO REUSE-O.\n           IF BIN-DATA EQUAL 224 MOVE 'RS' TO REUSE-O.\n           MOVE ZERO TO BIN-DATA, SHROPT-O.\n           MOVE SHROPT-BYTE TO BIN-BYTE.\n           IF BIN-DATA EQUAL  32 MOVE 1 TO SHROPT-O.\n           IF BIN-DATA EQUAL  96 MOVE 2 TO SHROPT-O.\n           IF BIN-DATA EQUAL 160 MOVE 3 TO SHROPT-O.\n           IF BIN-DATA EQUAL 224 MOVE 4 TO SHROPT-O.\n           MOVE SPACE-PRI-SAVE         TO SPACE-PRI-O.\n           MOVE SPACE-SEC-SAVE         TO SPACE-SEC-O.\n           MOVE PCT-FULL-SAVE          TO PCT-FULL-O.\n           MOVE AVE-REC-L              TO AVE-REC-L-O.\n           MOVE REC-TOTAL              TO REC-TOTAL-O.\n           MOVE CAT-REC-TYPE           TO TYPE-O.\n           MOVE ENTRY-NAME             TO NAME-O.\n           MOVE MAX-REC-L              TO MAX-REC-L-O.\n           MOVE KEY-LEN                TO KEY-LEN-O.\n           MOVE CI-SIZE                TO CISIZE-O.\n           MOVE NUM-EXTENTS            TO NUM-EXTENTS-O.\n           MOVE ZEROS                  TO BIN-DATA.\n           MOVE FREE-CI                TO BIN-BYTE.\n           MOVE BIN-DATA               TO FREE-CI-O.\n           MOVE CI-SPLITS              TO CI-SPLIT-O.\n           MOVE ZEROS                  TO BIN-DATA.\n           MOVE FREE-CA                TO BIN-BYTE.\n           MOVE BIN-DATA               TO FREE-CA-O.\n           MOVE CA-SPLITS              TO CA-SPLIT-O.\n           MOVE '%'             TO PCTSIGN1-O, PCTSIGN2-O, PCTSIGN3-O.\n           MOVE DETAIL-LINE TO SORT-REC\n           RELEASE SORT-REC.\n       DR-EXIT. EXIT.\n       RSC-EXIT. EXIT.\n       PRINT-SORT-CAT SECTION.\n           MOVE 0 TO EOF\n               PERFORM PRINT-LOOP THRU PL-EXIT\n               UNTIL EOF = 1.\n           GO TO PSC-EXIT.\n       PRINT-LOOP.\n           RETURN SORT-FILE INTO DETAIL-LINE\n               AT END MOVE 1 TO EOF\n                   GO TO PL-EXIT.\n           IF  LINE-COUNT IS GREATER THAN 70\n               PERFORM HEADING-ROUTINE THRU HR-EXIT.\n           IF  NAME-P NOT EQUAL NAME-SAVE\n               MOVE NAME-P TO NAME-SAVE\n               MOVE SPACES TO PRINT-LINE\n               WRITE PRINT-LINE AFTER ADVANCING 1 LINES\n               ADD 1 TO LINE-COUNT.\n           IF  TYPE-O EQUAL 'I'\n               MOVE SPACES TO IDX-ED1.\n           WRITE PRINT-LINE FROM DETAIL-LINE\n               AFTER ADVANCING 1 LINES\n               ADD 1 TO LINE-COUNT.\n       PL-EXIT. EXIT.\n       HEADING-ROUTINE.\n               ADD 1 TO PAGE-COUNT.\n               MOVE PAGE-COUNT TO PAGE-O.\n               MOVE CURRENT-DATE TO DATE-O.\n               WRITE PRINT-LINE FROM HEAD-ONE\n                   AFTER ADVANCING TOP-OF-PAGE.\n               WRITE PRINT-LINE FROM HEAD-TWO\n                   AFTER ADVANCING 3 LINES.\n               WRITE PRINT-LINE FROM HEAD-THREE\n                   AFTER ADVANCING 1 LINES.\n               MOVE SPACES TO PRINT-LINE.\n               MOVE SPACES TO NAME-SAVE.\n               MOVE 5 TO LINE-COUNT.\n       HR-EXIT. EXIT.\n       PSC-EXIT. EXIT.\n       GREGORIAN SECTION.\n       GREGORIAN-START.\n           IF WRKDT-JULIAN IS NOT NUMERIC\n           OR WRKDT-JULIAN IS EQUAL TO 0\n               GO TO GREGORIAN-EXIT.\n           MOVE WRKDT-JULIAN TO WRKDT-LEAP.\n           MOVE WRKDT-JULYR TO WRKDT-YR.\n           MOVE WRKDT-JULYR TO WRKDT-WORK.\n           MULTIPLY 250 BY WRKDT-WORK.\n           IF WRKDT-RMDR EQUAL TO +000\n               AND WRKDT-JULDAYS IS GREATER THAN 59\n                   SUBTRACT 1 FROM WRKDT-JULDAYS.\n           MOVE 1 TO WRKDT-SUB.\n       GREG-LOOP.\n           ADD 1 TO WRKDT-SUB.\n           IF WRKDT-JULDAYS IS GREATER THAN 365\n               MOVE 0 TO WRKDT-DATE\n               GO TO GREGORIAN-EXIT.\n           IF WRKDT-JULDAYS IS GREATER THAN WRKDT-DOM (WRKDT-SUB)\n               GO TO GREG-LOOP.\n           SUBTRACT 1 FROM WRKDT-SUB.\n           MOVE WRKDT-SUB TO WRKDT-MON.\n           IF WRKDT-RMDR IS EQUAL TO +000\n               AND WRKDT-JULDAYS IS EQUAL TO 59\n                   MOVE WRKDT-LEAP TO WRKDT-JULIAN.\n           SUBTRACT WRKDT-DOM (WRKDT-SUB) FROM WRKDT-JULDAYS\n               GIVING WRKDT-DAY.\n           MOVE WRKDT-LEAP TO WRKDT-JULIAN.\n       GREGORIAN-EXIT. EXIT.\n/*\n// EXEC LNKEDT\n/*\n/&\n* $$ EOJ\n\n\nThomas W Weideman\nSystem Programmer\nArea 3-4 Computer Centre (USA)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A004A07": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x03\\xd9\\x03\\xd9\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 985, "newlines": 985, "modlines": 0, "user": "VSAMUPD"}, "text": "Obtaining information about VSAM files\n\nThis CLIST can be invoked from a screen by entering:\n\n      tso %vsaminfo\n\nThere are no keywords to submit - a panel will ask for the\nnecessary information.  You can skip this panel by adding the\nkeyword dsn(xxx), where xxx is your VSAM component\nname.\n\nIt gives the most frequently used key information from the\nLISTCAT on each important group of components, eg the base\ncluster (see Figure 1) or an alternate index cluster (see Figure\n2), in a formatted and easily readable screen.  It works as well\nwith KSDS, ESDS, RRDS, and LDS.\n\nYou can enter the CLIST starting from whatever component\nyou know, eg cluster, index, aix-data, path, (see Figures 3 and\n4).  You will always obtain in the first screen the type, creation\ndate and catalog of the entered component, the information\nabout the associated base cluster (including the last update date\nand time), and the names of the AIX clusters associated with\nthis base cluster.  Then you may ask for information about each\nAIX dataset by entering its number.  Although the screen for\nthe base cluster shows only the names of four AIXs (sufficient\nin most cases) all of them are accessible by number.  The\nCLIST converts Julian dates and timestamps to normal date\ninformation.\n\nIt is easy to use in conjunction with the ISPF/PDF panel 3.4 :\n\no      When first used, type before the name of the VSAM\n      component:\n\n      %vsaminfo dsn(/)\n\no      If immediately reused, type '=' before the name of a\n      component.\n\n\nCLIST\n\nPROC 0 DSN() DEBUG\n     /*            */\n     /*  VSAMINFO  */\n     /*            */\nIF &DEBUG = DEBUG THEN CONTROL LIST SYMLIST CONLIST\nCONTROL NOMSG NOFLUSH NOPROMPT END(ENDO)\n     /*            */\n     /* initialize */\n     /*            */\nSET VSN = &DSN\nSET VSTYP1 = CLUSTER\nSET VSTYP2 = AIX\nSET VSTYP3 = PATH\nSET VSTYP4 = DATA\nSET VSTYP5 = INDEX\n     /*                         */\n     /* ask VSAM component name */\n     /*                         */\nIF &VSN \u00ac= &STR() THEN GOTO SKP1\nLNAME: +\nISPEXEC DISPLAY PANEL(VSINNAM)\n     /*                  */\n     /* end of program ? */\n     /*                  */\nIF &VSN = EEEEEEEEE THEN END\n     /*                   */\n     /* dataset exists ?  */\n     /*                   */\nSKP1: +\nIF &SYSDSN('&VSN') = OK +\n  OR &SYSDSN('&VSN') = UNAVAILABLE DATASET +\n  THEN GOTO OK1\n     /*      */\n     /*  no  */\n     /*      */\nCONTROL ASIS\nSET &ZEDSMSG = &STR(Entry not catalogued)\nSET &ZEDLMSG = &STR(&VSN is not found in the catalog)\nISPEXEC SETMSG MSG(ISRZ001)\nCONTROL CAPS\nGOTO LNAME\n     /*                 */\n     /* yes: initialize */\n     /*                 */\nOK1: +\nSET BC = &STR( )\nSET A = 0\nSET N = 1\nDO I = 1 TO 5\n  SET AIX&I = &STR( )\nENDO\n     /*              */\n     /* trap listcat */\n     /*              */\nSET DATASET = &VSN\nSET LABEL = RVSN\nGOTO TRAPLCT\nRVSN: SET NOP = NOP\n     /*                    */\n     /* inspect first line */\n     /*                    */\nSET LINE = &STR(&SYSOUTLINE1)\nSET POS = &SYSINDEX(-,&LINE)\nIF &POS = 0 +\n  THEN +\n    DO\n      CONTROL ASIS\n      SET &ZEDSMSG = &STR(Non-VSAM)\n      SET &ZEDLMSG = &STR(First line of listcat is : &LINE)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      CONTROL CAPS\n      GOTO LNAME\n    ENDO\n     /*                        */\n     /* find type of component */\n     /*                        */\nSET N = 1\nSET STRING = &SUBSTR(1:&POS-2,&STR(&LINE))\nDO WHILE &N < 6\n  SET ARG = &&VSTYP&N\n  SET POS = &SYSINDEX(&STR(&ARG),&STRING)\n  IF &POS \u00ac= 0 +\n    THEN +\n      DO\n        SET TYPN = &N\n        SET N = 99\n      ENDO\n    ELSE +\n      SET N = &N + 1\nENDO\n     /*            */\nIF &N \u00ac= 99 +\n  THEN +\n    DO\n      CONTROL ASIS\n      SET &ZEDSMSG = &STR(Non-VSAM)\n      SET &ZEDLMSG = &STR(First line of listcat is : &LINE)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      CONTROL CAPS\n      GOTO LNAME\n    ENDO\n     /*                                  */\n     /* fill in information known so far */\n     /*                                  */\nSELECT\n  WHEN (&TYPN = 1) +\n    DO\n      SET TYP = BASE CLUSTER\n      SET BC = &VSN\n      GOTO LCAT\n    ENDO\n  WHEN (&TYPN = 2) +\n    DO\n      SET TYP = AIX CLUSTER\n      SET LINE = &STR(&&SYSOUTLINE11)\n      SET POS = &SYSINDEX(CLUSTER,&LINE)\n      SET BC = &SUBSTR(&POS+9:&LENGTH(&STR(&LINE)),&STR(&LINE))\n      GOTO LCAT\n    ENDO\n  WHEN (&TYPN = 3) +\n    DO\n      SET TYP = PATH\n      SET LINE = &STR(&&SYSOUTLINE8)\n      SET POS = &SYSINDEX(CLUSTER,&LINE)\n      IF &POS = 0 THEN GOTO LAIX1\n      SET BC = &SUBSTR(&POS+9:&LENGTH(&STR(&LINE)),&STR(&LINE))\n      GOTO LCAT\n    ENDO\n  WHEN (&TYPN = 4 OR &TYPN = 5) +\n    DO\n      SET LINE = &STR(&&SYSOUTLINE8)\n      SET POS1 = &SYSINDEX(CLUSTER,&LINE)\n      SET POS2 = &SYSINDEX(AIX,&LINE)\n      SELECT\n        WHEN (&POS1 \u00ac= 0 AND &TYPN = 4) +\n          DO\n            SET TYP = BASE DATA\n            SET BC = &SUBSTR(&POS1+9:&LENGTH(&STR(&LINE)),&STR(&LINE))\n            GOTO LCAT\n          ENDO\n        WHEN (&POS1 \u00ac= 0 AND &TYPN = 5) +\n          DO\n            SET TYP = BASE INDEX\n            SET BC = &SUBSTR(&POS1+9:&LENGTH(&STR(&LINE)),&STR(&LINE))\n            GOTO LCAT\n          ENDO\n        WHEN (&POS2 \u00ac= 0 AND &TYPN = 4) +\n          DO\n            SET TYP = AIX DATA\n            GOTO LAIX1\n          ENDO\n        WHEN (&POS2 \u00ac= 0 AND &TYPN = 5) +\n          DO\n           SET TYP = AIX INDEX\n           GOTO LAIX1\n          ENDO\n      ENDO   /* INNER SELECT           */\n    ENDO     /* LAST WHEN OUTER SELECT */\n  OTHERWISE +\n    DO\n     /*                             */\n     /* not a regular VSAM dataset  */\n     /*                             */\n      SET LINE = &STR(&LINE)\n      CONTROL ASIS\n      SET &ZEDSMSG = &STR(Non-Vsam)\n      SET &ZEDLMSG = &STR(8-th line of listcat is : &LINE)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      CONTROL CAPS\n      GOTO LNAME\n    ENDO\nENDO         /* OUTER SELECT */\n     /*                             */\n     /* not a regular VSAM dataset  */\n     /*                             */\nSET LINE = &STR(&LINE)\nCONTROL ASIS\nSET &ZEDSMSG = &STR(Non-VSAM)\nSET &ZEDLMSG = &STR(8th line of listcat is : &LINE)\nISPEXEC SETMSG MSG(ISRZ001)\nCONTROL CAPS\nGOTO LNAME\n     /*                                     */\n     /* search AIX-cluster of aix component */\n     /*                                     */\nLAIX1: +\nSET LINE = &STR(&&SYSOUTLINE8)\nSET POS = &SYSINDEX(AIX,&LINE)\nSET AIX1 = &SUBSTR(&POS+9:&LENGTH(&STR(&LINE)),&STR(&LINE))\n     /*                     */\n     /* catalog information */\n     /*                     */\nLCAT: +\nSET LINE = &STR(&&SYSOUTLINE2)\nSET POS = &SYSINDEX(---,&LINE)\nSET CAT = &SUBSTR(&POS+4:&LENGTH(&STR(&LINE)),&STR(&LINE))\n     /*               */\n     /* creation date */\n     /*               */\nSET LINE = &STR(&&SYSOUTLINE4)\nSET POS = &SYSINDEX(.,&LINE)\nSET CREDAT = &SUBSTR(&POS-2:&POS+3,&STR(&LINE))\nSET ND = &STR( )\nSYSCALL CONVJD &CREDAT ND\nIF &LASTCC = 12 THEN END\n     /*                        */\n     /* display component type */\n     /*                        */\nISPEXEC CONTROL DISPLAY LOCK\nISPEXEC DISPLAY PANEL(VSINCMP)\n     /*            */\nIF &TYPN = 1 THEN GOTO INFOBC\n     /*            */\nIF &BC \u00ac= &STR( ) THEN GOTO LSTCBC\n     /*                                    */\n     /* search base cluster on AIX listcat */\n     /*                                    */\nSET DATASET = &AIX1\nSET LABEL = RAIX1\nGOTO TRAPLCT\nRAIX1: SET NOP = NOP\nSET LINE = &STR(&&SYSOUTLINE11)\nSET POS = &SYSINDEX(CLUSTER,&LINE)\nSET BC = &SUBSTR(&POS+9:&LENGTH(&STR(&LINE)),&STR(&LINE))\n     /*                         */\n     /* listcat of base cluster */\n     /*                         */\nLSTCBC: +\nSET DATASET = &BC\nSET LABEL = RBC\nGOTO TRAPLCT\nRBC: SET NOP = NOP\n     /*                                                  */\n     /* search additional info on base cluster  -  start */\n     /*                                                  */\nINFOBC: +\nSET LINE = &STR(&&SYSOUTLINE8)\nSET POS = &SYSINDEX(DATA,&LINE) + 9\nSET BD = &SUBSTR(&POS:&LENGTH(&STR(&LINE)),&STR(&LINE))\nSET A = 0\nSET DLT = 9\nSET LINE = &STR(&&SYSOUTLINE9)\nIF &SYSINDEX(INDEX,&LINE) = 0 +\n  THEN SET BI = &STR( )\n  ELSE +\n    DO\n      SET BI = &SUBSTR(&POS:&LENGTH(&STR(&LINE)),&STR(&LINE))\n      SET DLT = 10\n    ENDO\n     /*            */\nSTARTAIX: +\nSET L = &A + &DLT\nSET LINE = &STR(&&SYSOUTLINE&L)\nIF &SYSINDEX(AIX,&LINE) = 0 THEN GOTO ENDAIX\nSET A = &A + 1\nSET AIX&A = &SUBSTR(&POS:&LENGTH(&STR(&LINE)),&STR(&LINE))\nGOTO STARTAIX\n     /*            */\nENDAIX: +\nIF &A > 4 +\n  THEN SET MORE = MORE\n  ELSE SET MORE = &STR()\n     /*            */\nSET SEARCH = CREATION\nSET LABEL = RBCRD\nGOTO RETRV\nRBCRD: +\nSET BCRDJ = &SUBSTR(3:8,&STR(&RESULT))\nSET BCRD = &STR( )\nSYSCALL CONVJD &BCRDJ BCRD\n     /*            */\nSET SEARCH = KEYLEN\nSET LABEL = RBK\nGOTO RETRV\nRBK: +\nSET BK = &RESULT\n     /*            */\nSET SEARCH = AVGLRECL\nSET LABEL = RBRA\nGOTO RETRV\nRBRA: +\nSET BRA = &RESULT\n     /*            */\nSET SEARCH = CISIZE\nSET LABEL = RBCI\nGOTO RETRV\nRBCI: +\nSET BCI = &RESULT\n     /*            */\nSET L = &L + 1\nSET SEARCH = RKP\nSET LABEL = RBP\nGOTO RETRV\nRBP: +\nSET BP = &RESULT\n     /*            */\nSET SEARCH = MAXLRECL\nSET LABEL = RBRM\nGOTO RETRV\nRBRM: +\nSET BRM = &RESULT\n     /*            */\nSET POS = 0\nDO WHILE &POS = 0\n  SET L = &L + 1\n  SET LINE = &STR(&&SYSOUTLINE&L)\n  SET POS = &SYSINDEX(SHROPT,&STR(&LINE))\nENDO\nSET BSHROPT = &SUBSTR(&POS:&POS+12,&LINE)\nSET DSTYP = &SUBSTR(66:75,&LINE)\nSELECT\n  WHEN (&DSTYP = &STR(NONINDEXED))  SET BT = ESDS\n  WHEN (&DSTYP = &STR(INDEXED   ))  SET BT = KSDS\n  WHEN (&DSTYP = &STR(NUMBERED  ))  SET BT = RRDS\n  WHEN (&DSTYP = &STR(LINEAR    ))  SET BT = LDS\n  OTHERWISE +\n    DO\n      WRITE *** ERROR IN CLIST ***\n      END\n    ENDO\nENDO\n     /*            */\nSET L = &L + 1\nSET LINE = &STR(&&SYSOUTLINE&L)\nSET POS = &SYSINDEX(REUSE,&LINE)\nSET BREUS = &SUBSTR(&POS-2:&POS+4,&LINE)\n     /*            */\nSET SEARCH = &STR(REC-TOTAL)\nSET LABEL = RBRN\nGOTO RETRV\nRBRN: +\nSET BRN = &RESULT\n     /*            */\nSET SEARCH = &STR(SPLITS-CI)\nSET LABEL = RBSI\nGOTO RETRV\nRBSI: +\nSET BSI = &RESULT\n     /*            */\nSET L = &L + 1\nSET SEARCH = &STR(SPLITS-CA)\nSET LABEL = RBSA\nGOTO RETRV\nRBSA: +\nSET BSA = &RESULT\n     /*            */\nSET SEARCH = EXTENTS\nSET LABEL = RBRE\nGOTO RETRV\nRBRE: +\nSET BRE = &RESULT\n     /*            */\nSET L = &L + 2\nSET LINE = &STR(&&SYSOUTLINE&L)\nSET POS = &SYSINDEX(&STR(X'),&LINE)\nSET TMSTMP = &SUBSTR(&POS+2:&POS+14,&LINE)\nIF &TMSTMP = &STR(0000000000000) +\n  THEN SET BUPD = UNUSED\n  ELSE +\n    DO\n      SET BUPD = &STR( )\n      SYSCALL CONVTST &TMSTMP BUPD\n    ENDO\n     /*            */\nSET SEARCH = VOLSER\nSET LABEL = RBVD\nGOTO RETRV\nRBVD: +\nSET BVD = &RESULT\n     /*            */\nIF &BT = KSDS +\n  THEN +\n    DO\n      SET POS = 0\n      DO WHILE &POS = 0\n        SET L = &L + 1\n        SET LINE = &STR(&&SYSOUTLINE&L)\n        SET POS = &SYSINDEX(INDEX,&LINE)\n      ENDO\n      SET POS = 0\n      DO WHILE &POS = 0\n        SET L = &L + 1\n        SET LINE = &STR(&&SYSOUTLINE&L)\n        SET POS = &SYSINDEX(IMBED,&STR(&LINE))\n      ENDO\n      SET BIMB = &SUBSTR(&POS-2:&POS+4,&LINE)\n      SET POS = &SYSINDEX(REPLICAT,&STR(&LINE))\n      SET BREPL = &SUBSTR(&POS-2:&POS+7,&LINE)\n     /*            */\n      SET SEARCH = LEVELS\n      SET LABEL = RBIL\n      GOTO RETRV\n      RBIL: +\n      SET BIL = &RESULT\n     /*            */\n      SET SEARCH = VOLSER\n      SET LABEL = RBVI\n      GOTO RETRV\n      RBVI: +\n      SET BVI = &RESULT\n    ENDO\n  ELSE +\n    DO\n      SET BIMB = &STR( )\n      SET BREPL = &STR( )\n      SET BIL = &STR( )\n      SET BVI = &STR( )\n    ENDO\n     /*                                                  */\n     /* search additional info on base cluster  -  end   */\n     /*                                                  */\nIF &A > 0 +\n  THEN SET N = 1\n  ELSE SET N = 0\n     /*                                               */\n     /* display info on base cluster & associated AIX */\n     /*                                               */\nDISPASS: +\nISPEXEC DISPLAY PANEL(VSINASS)\nIF &N = 0 THEN GOTO LNAME\n     /*            */\nIF &N > &A +\n  THEN +\n    DO\n      CONTROL ASIS\n      SET &ZEDSMSG = &STR(Invalid AIX number)\n      SET &ZEDLMSG = &STR(There are only &A AIX associated to this VSAM)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      CONTROL CAPS\n      GOTO DISPASS\n    ENDO\n     /*                                                */\n     /* search & display info on specified AIX - start */\n     /*                                                */\nSET AC = &STR(&&AIX&N)\nSET AC = &AC\nSET DATASET = &AC\nSET LABEL = RAC\nGOTO TRAPLCT\nRAC: SET NOP = NOP\nSET LINE = &STR(&&SYSOUTLINE4)\nSET POS = &SYSINDEX(.,&LINE)\nSET ACRDJ = &SUBSTR(&POS-2:&POS+3,&STR(&LINE))\nSET ACRD = &STR( )\nSYSCALL CONVJD &ACRDJ ACRD\nSET LINE = &STR(&&SYSOUTLINE9)\nSET POS = &SYSINDEX(DATA,&LINE) + 9\nSET AD = &SUBSTR(&POS:&LENGTH(&STR(&LINE)),&STR(&LINE))\nSET LINE = &STR(&&SYSOUTLINE10)\nSET AI = &SUBSTR(&POS:&LENGTH(&STR(&LINE)),&STR(&LINE))\nSET LINE = &STR(&&SYSOUTLINE12)\nIF &SYSINDEX(PATH,&LINE) \u00ac= 0 +\n  THEN SET APT = &SUBSTR(&POS:&LENGTH(&STR(&LINE)),&STR(&LINE))\n  ELSE SET APT = &STR( )\n     /*            */\nSET L = 12\nSET POS = 0\nDO WHILE &POS = 0\n  SET L = &L + 1\n  SET LINE = &STR(&&SYSOUTLINE&L)\n  SET POS = &SYSINDEX(UPGRADE,&STR(&LINE))\nENDO\nSET AUPG = &SUBSTR(&POS-2:&POS+6,&LINE)\n     /*            */\nSET L = 20\nSET SEARCH = KEYLEN\nSET LABEL = RAK\nGOTO RETRV\nRAK: +\nSET AK = &RESULT\n     /*            */\nSET SEARCH = AVGLRECL\nSET LABEL = RARA\nGOTO RETRV\nRARA: +\nSET ARA = &RESULT\n     /*            */\nSET SEARCH = CISIZE\nSET LABEL = RACI\nGOTO RETRV\nRACI: +\nSET ACI = &RESULT\n     /*            */\nSET L = &L + 1\nSET SEARCH = MAXLRECL\nSET LABEL = RARM\nGOTO RETRV\nRARM: +\nSET ARM = &RESULT\n     /*            */\nSET SEARCH = AXRKP\nSET LABEL = RAP\nGOTO RETRV\nRAP: +\nSET AP = &RESULT\n     /*            */\nSET POS = 0\nDO WHILE &POS = 0\n  SET L = &L + 1\n  SET LINE = &STR(&&SYSOUTLINE&L)\n  SET POS = &SYSINDEX(SHROPT,&STR(&LINE))\nENDO\nSET ASHROPT = &SUBSTR(&POS:&POS+12,&LINE)\nSET L = &L + 1\nSET LINE = &STR(&&SYSOUTLINE&L)\nSET POS = &SYSINDEX(REUSE,&LINE)\nSET AREUS = &SUBSTR(&POS-2:&POS+4,&LINE)\nIF &SYSINDEX(NONUNIQ,&LINE) \u00ac= 0 +\n  THEN SET AT = NONUNIQ\n  ELSE SET AT = UNIQUE\n     /*            */\nSET SEARCH = &STR(REC-TOTAL)\nSET LABEL = RARN\nGOTO RETRV\nRARN: +\nSET ARN = &RESULT\n     /*            */\nSET SEARCH = &STR(SPLITS-CI)\nSET LABEL = RASI\nGOTO RETRV\nRASI: +\nSET ASI = &RESULT\n     /*            */\nSET L = &L + 1\nSET SEARCH = &STR(SPLITS-CA)\nSET LABEL = RASA\nGOTO RETRV\nRASA: +\nSET ASA = &RESULT\n     /*            */\nSET SEARCH = EXTENTS\nSET LABEL = RARE\nGOTO RETRV\nRARE: +\nSET ARE = &RESULT\n     /*            */\nSET L = &L + 2\nSET LINE = &STR(&&SYSOUTLINE&L)\nSET POS = &SYSINDEX(&STR(X'),&LINE)\nSET TMSTMP = &SUBSTR(&POS+2:&POS+14,&LINE)\nIF &TMSTMP = &STR(0000000000000) +\n  THEN SET AUPD = UNUSED\n  ELSE +\n    DO\n      SET AUPD = &STR( )\n      SYSCALL CONVTST &TMSTMP AUPD\n    ENDO\n     /*            */\nSET SEARCH = VOLSER\nSET LABEL = RAVD\nGOTO RETRV\nRAVD: +\nSET AVD = &RESULT\n     /*            */\nSET POS = 0\nDO WHILE &POS = 0\n  SET L = &L + 1\n  SET LINE = &STR(&&SYSOUTLINE&L)\n  SET POS = &SYSINDEX(INDEX,&LINE)\nENDO\n     /*            */\nSET POS = 0\nDO WHILE &POS = 0\n  SET L = &L + 1\n  SET LINE = &STR(&&SYSOUTLINE&L)\n  SET POS = &SYSINDEX(IMBED,&STR(&LINE))\nENDO\nSET AIMB = &SUBSTR(&POS-2:&POS+4,&LINE)\nSET POS = &SYSINDEX(REPLICAT,&STR(&LINE))\nSET AREPL = &SUBSTR(&POS-2:&POS+7,&LINE)\n     /*            */\nSET SEARCH = LEVELS\nSET LABEL = RAIL\nGOTO RETRV\nRAIL: +\nSET AIL = &RESULT\n     /*            */\nSET SEARCH = VOLSER\nSET LABEL = RAVI\nGOTO RETRV\nRAVI: +\nSET AVI = &RESULT\n     /*            */\nIF &APT = &STR( ) +\n  THEN +\n    DO\n      SET PCRD = &STR( )\n      SET PUPD = &STR( )\n    ENDO\n  ELSE +\n    DO\n      SET POS = 0\n      DO WHILE &POS = 0\n        SET L = &L + 1\n        SET LINE = &STR(&&SYSOUTLINE&L)\n        SET POS = &SYSINDEX(PATH,&LINE)\n      ENDO\n      SET SEARCH = CREATION\n      SET LABEL = RDPT\n      GOTO RETRV\n      RDPT: +\n      SET PCRDJ = &SUBSTR(3:8,&STR(&RESULT))\n      SET PCRD = &STR( )\n      SYSCALL CONVJD &PCRDJ PCRD\n     /*            */\n      SET POS = 0\n      DO WHILE &POS = 0\n        SET L = &L + 1\n        SET LINE = &STR(&&SYSOUTLINE&L)\n        SET POS = &SYSINDEX(UPDATE,&LINE)\n      ENDO\n      SET PUPD = &SUBSTR(&POS-2:&POS+5,&LINE)\n    ENDO\n     /*            */\nISPEXEC DISPLAY PANEL(VSINAIX)\n     /*                                                 */\n     /* search & display info on specified AIX - end    */\n     /*                                                 */\n     /* return to info on base cluster & associated AIX */\n     /*                                                 */\nIF &N = &A +\n  THEN SET N = 1\n  ELSE SET N = &N + 1\nGOTO DISPASS\n     /*            */\n     /*******************************************************/\n     /* procedure RETRV : retrieve value of keyword - start */\n     /*******************************************************/\nRETRV:+\nSET LINE = &STR(&&SYSOUTLINE&L)\nSET POS = &SYSINDEX(&STR(&SEARCH),&STR(&LINE))\nDO WHILE &POS = 0\n  SET L = &L + 1\n  SET LINE = &STR(&&SYSOUTLINE&L)\n  SET POS = &SYSINDEX(&STR(&SEARCH),&STR(&LINE))\nENDO\nSET POS = &POS + 23\nSET POSE = &POS\nSET CHAR = &STR( )\nDO WHILE &STR(&CHAR) \u00ac= &STR(-)\n  SET POS = &POS - 1\n  SET CHAR = &SUBSTR(&POS:&POS,&LINE)\nENDO\nSET RESULT = &SUBSTR(&POS+1:&POSE,&LINE)\nGOTO &LABEL\n     /*******************************************************/\n     /* procedure RETRV : retrieve value of keyword - end   */\n     /*******************************************************/\n     /*            */\n     /********************************************/\n     /* procedure TRAPLCT : trap listcat - start */\n     /********************************************/\nTRAPLCT: +\nIF &DEBUG = DEBUG +\n  THEN +\n    DO\n      CONTROL NOLIST NOSYMLIST NOCONLIST\n      WRITE *** SYSOUTTRAP OF LISTCAT OF &DATASET *****\n    ENDO\nSET SYSOUTTRAP = 150\nLISTCAT ENT('&DATASET') ALL\nSET SYSOUTTRAP = 0\nIF &DEBUG = DEBUG THEN CONTROL LIST SYMLIST CONLIST\nGOTO &LABEL\n     /********************************************/\n     /* procedure TRAPLCT : trap listcat - end   */\n     /********************************************/\n     /*            */\n     /*****************************************************/\n     /* subprocedure CONVJD : convert julian date - start */\n     /*****************************************************/\nCONVJD: +\n  PROC 2 PJD PND\n     /*                                           */\nSYSREF &PND\nSET ID = FALSE   /* INVALID DATE */\nSET SJ = FALSE   /* LEAP-YEAR    */\nIF &LENGTH(&STR(&PJD)) \u00ac= 6 +\n  THEN SET ID = TRUE\n  ELSE IF &SUBSTR(3:3,&STR(&PJD)) \u00ac= . THEN SET ID = TRUE\nIF &ID = TRUE THEN GOTO ERR\nSET JJ = &SUBSTR(1:2,&STR(&PJD))\nIF &DATATYPE(&JJ) \u00ac= NUM +\n  THEN SET ID = TRUE\n  ELSE IF &JJ//4 = 0 THEN SET SJ = TRUE\nSET DDD = &SUBSTR(4:6,&STR(&PJD))\nIF &DATATYPE(&DDD) \u00ac= NUM      THEN SET ID = TRUE\nIF &DDD > 366                  THEN SET ID = TRUE\nIF &DDD > 365 AND &SJ = FALSE  THEN SET ID = TRUE\nERR: +\nIF &ID = TRUE +\n  THEN +\n    DO\n      WRITE *** INVALID JULIAN DATE : &PJD ***\n      RETURN CODE(12)\n    ENDO\nIF &SJ = FALSE +\n  THEN SET MD = &STR(312831303130313130313031)\n  ELSE SET MD = &STR(312931303130313130313031)\nSET CUMUL = 0\nSET TEL = 0\nDO WHILE &CUMUL < &DDD\n  SET TEL = &TEL + 1\n  SET MDV = &EVAL(&SUBSTR((&TEL-1)*2+1:&TEL*2,&MD))\n  SET CUMUL = &CUMUL + &MDV\nENDO\nSET MM = &TEL\nIF &LENGTH(&MM) = 1 THEN SET MM = &STR(0&MM)\nSET DD = &DDD - (&CUMUL - &MDV)\nIF &LENGTH(&DD) = 1 THEN SET DD = &STR(0&DD)\n     /*               */\n     /* BEGIAN FORMAT */\n     /*               */\nSET PND = &STR(&DD./&MM./&JJ)\n     /*               */\nENDO\n     /*****************************************************/\n     /* subprocedure CONVJD : convert julian date - end   */\n     /*****************************************************/\n     /*               */\n     /********************************************************/\n     /* subprocedure CONVTST : convert hex timestamp - start */\n     /********************************************************/\nCONVTST: +\n  PROC 2 TMSTMP PTIM\n     /*                                           */\nSYSREF &PTIM\n/* no validity check of timestamp is done */\n/* for performance reasons                */\nSET HEX = &STR(0123456789ABCDEF)\nDO WHILE &LENGTH(&TMSTMP) < 13\n  SET TMSTMP = &STR(&TMSTMP.0)\nENDO\nSET VT9 = 0\nSET VT5 = 0\nSET VT0 = 0\n/*          */\nDO &I = 1 TO 13\n  SET HB = &SUBSTR(&I:&I,&TMSTMP)\n  SET HBV = &SYSINDEX(&HB,&HEX) - 1\n  SET VT9 = &VT9 * 16\n  SET VT5 = &VT5 * 16\n  SET VT0 = &VT0 * 16 + &HBV\n  SET VT5 = &VT5 + &VT0 / 100000\n  SET VT0 = &VT0 // 100000\n  SET VT9 = &VT9 + &VT5 / 10000\n  SET VT5 = &VT5 // 10000\nENDO\n/*          */\nSET Y = &VT9 / 31536\nSET LPY = (&Y - 1) / 4\nSET VT9 = &VT9 // 31536\nSET VT8 = &VT9 * 10 + &VT5 / 1000\nSET VT5 = &VT5 // 1000\nSET D = &VT8 / 864\nSET VT8 = &VT8 // 864\nSET D = &D - &LPY + 1\nIF &D <= 0 AND &Y > 0 +\n  THEN +\n    DO\n      SET Y = &Y - 1\n      SET D = &D + 365\n    ENDO\nSET U = &VT8 / 36\nSET VT8 = &VT8 // 36\nSET VT5 = &VT8 * 1000 + &VT5\nSET M = &VT5 / 600\nSET VT5 = &VT5 // 600\nSET S = &VT5 / 10\n/*          */\nIF &LENGTH(&D) = 1 THEN SET D = &STR(00&D)\nIF &LENGTH(&D) = 2 THEN SET D = &STR(0&D)\nIF &Y > 99 THEN SET Y = &Y - 100\nSET JD = &STR(&Y..&D)\nIF &LENGTH(&U) = 1 THEN SET U = &STR(0&U)\nIF &LENGTH(&M) = 1 THEN SET M = &STR(0&M)\nIF &LENGTH(&S) = 1 THEN SET S = &STR(0&S)\nSET DAT = &STR( )\nSYSCALL CONVJD &JD DAT\nSET PTIM = &STR(&DAT &U.:&M.:&S)\nENDO\n     /********************************************************/\n     /* subprocedure CONVTST : convert hex timestamp - end   */\n     /********************************************************/\n\n\nPANELS\n\n)ATTR\n/**********************************************/\n/* panel VSINNAM by Etienne used in VSAMINFO  */\n/**********************************************/\n% TYPE(TEXT) INTENS(HIGH)\n+ TYPE(TEXT) INTENS(LOW)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(NULLS)\n/*  */\n)BODY EXPAND(//)\n+-/-/-% VSAM INFORMATION+-/-/-\n%COMMAND ===>_ZCMD    / /\n+\n+\n+\n+\n+ Enter the name of the VSAM component :\n+\n    %===>_VSN      / /\n+\n+\n+\n+\n+\n+Press%ENTER+to continue\n+\n+Press%END+to terminate\n+\n)INIT\n.CURSOR=VSN\n)REINIT\n.CURSOR=VSN\n)PROC\nIF (.RESP=ENTER)\n  VER(&VSN,DSNAME)\n  VER(&VSN,NONBLANK)\nIF (.RESP=END) &VSN=EEEEEEEEE\n)END\n\n)ATTR\n/**********************************************/\n/* panel VSINCMP by Etienne used in VSAMINFO  */\n/**********************************************/\n% TYPE(TEXT) INTENS(HIGH)\n+ TYPE(TEXT) INTENS(LOW)\n\u00dd TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(NULLS)\n@ TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(LEFT) PAD(NULLS)\n/*  */\n)BODY EXPAND(//)\n+-/-/-% VSAM INFORMATION+-/-/-\n%COMMAND ===>_ZCMD    / /\n+\n+ The\u00ddTYP         +VSAM dataset\u00ddVSN                                           +\n+ was created on\u00ddCREDAT+(\u00ddND      +) in catalog\u00ddCAT                           +\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n%Searching further information.+\n)END\n\n)ATTR\n/**********************************************/\n/* panel VSINASS by Etienne used in VSAMINFO  */\n/**********************************************/\n% TYPE(TEXT) INTENS(HIGH)\n+ TYPE(TEXT) INTENS(LOW)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(NULLS)\n\u00dd TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(NULLS)\n@ TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(LEFT) PAD(NULLS)\n/*  */\n)BODY EXPAND(//)\n+-/-/-% VSAM INFORMATION+-/-/-\n%COMMAND ===>_ZCMD    / /\n+\n+ The\u00ddTYP         +VSAM dataset\u00ddVSN                                           +\n+ was created on\u00ddCREDAT+(\u00ddND      +) in catalog\u00ddCAT                           +\n+\n+ Information on the\u00ddBT  +base cluster ( last update on\u00ddBUPD             +)\n+\n    + Cluster :\u00ddBC                                         +created\u00ddBCRD    +\n    + Data    :\u00ddBD                                         +on vol.\u00ddBVD     +\n    + Index   :\u00ddBI                                         +on vol.\u00ddBVI     +\n+\n+ Key: length   :\u00ddBK   +     +Lrecl: avg :\u00ddBRA  +     +# records   :\u00ddBRN   +\n+      position :\u00ddBP   +             max :\u00ddBRM  +     +# extents   :\u00ddBRE+\n+ Index levels  :\u00ddBIL  +     +CIsize     :\u00ddBCI  +     +Splits CI\u00a8CA:\u00ddBSI+\u00a8\u00ddBSA+\n+\u00ddBSHROPT      +          \u00ddBREUS  +          \u00ddBIMB   +          \u00ddBREPL     +\n+\n+ Associated AIX :\u00ddA+\n+1.\u00ddAIX1                              + +3.\u00ddAIX3                              +\n+2.\u00ddAIX2                              + +4.\u00ddAIX4                              +\n                                        +\u00ddMORE\n+Enter number of AIX for more information about it :_N+\n+Press%END+to terminate\n)INIT\n.CURSOR=N\n)REINIT\n.CURSOR=N\n)PROC\nIF (.RESP=END) &N=0\n)END\n\n)ATTR\n/**********************************************/\n/* panel VSINAIX by Etienne used in VSAMINFO  */\n/**********************************************/\n% TYPE(TEXT) INTENS(HIGH)\n+ TYPE(TEXT) INTENS(LOW)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(NULLS)\n\u00dd TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(NULLS)\n@ TYPE(OUTPUT) INTENS(LOW) CAPS(ON) JUST(LEFT) PAD(NULLS)\n/*  */\n)BODY EXPAND(//)\n+-/-/-% VSAM INFORMATION+-/-/-\n%COMMAND ===>_ZCMD    / /\n+\n+ The\u00ddTYP         +VSAM dataset\u00ddVSN                                           +\n+ was created on\u00ddCREDAT+(\u00ddND      +) in catalog\u00ddCAT                           +\n+\n+ Information on associated AIX : ( last update on\u00ddAUPD             +)\n+\n    + Cluster :\u00ddAC                                         +created\u00ddACRD    +\n    + Data    :\u00ddAD                                         +on vol.\u00ddAVD     +\n    + Index   :\u00ddAI                                         +on vol.\u00ddAVI     +\n    + Path    :\u00ddAPT                                        +created\u00ddPCRD    +\n+\n+ Key: length   :\u00ddAK+        +Lrecl: avg :\u00ddARA  +     +# records   :\u00ddARN   +\n+      position :\u00ddAP   +             max :\u00ddARM  +     +# extents   :\u00ddARE+\n+      type     :\u00ddAT     +   +CIsize     :\u00ddACI  +     +Splits CI\u00a8CA:\u00ddASI+\u00a8\u00ddASA+\n+ Index levels  :\u00ddAIL  +\n+\n+ Aix :\u00ddAUPG     +           +Path :\u00ddPUPD    +                                +\n+\u00ddASHROPT      +          \u00ddAREUS  +          \u00ddAIMB   +          \u00ddAREPL     +\n+\n+Press%END+or%ENTER+to continue.\n)END\n\n\nEtienne de Samblanckx\nSystem Engineer\nKamer Volksvertegen Woordigers (Belgium)      c Etienne de Samblanckx 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A005A00I": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 12, "newlines": 12, "modlines": 0, "user": "VSAMUPD"}, "text": "A005 - VSAM Update issue #5 April 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA005A01   Catalog back-up process\nA005A02   Estimating VSAM cluster parameters\nA005A03   KSDS data component information\nA005A04   Displaying the status of CICS VSAM files\nA005A05   Analysing files in a VSAM catalog\nA005A06   Checking volume security\nA005A07   VSAM for VM users\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A005A01": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\x16\\x01\\x16\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 278, "newlines": 278, "modlines": 0, "user": "VSAMUPD"}, "text": "Catalog back-up process\n\nUntil recently we had no separate back-up process for our\ncatalogs. We used only standard full volume and incremental\nback-up processes as security against the loss of a catalog.\n\nWe decided that this was an unsuitable practice and I wrote the\nfollowing processes to enable us to back up our catalogs at a\npre-defined time, to allow restoration of our catalogs, and to\ntrack back-up information. Our current catalog subsystem\nconsists of an ICF master catalog and several ICF user catalogs\nwhich are allocated across various DASD devices.\nTo perform back-ups in this environment I created the catalog\nback-up process presented below. This process uses the\nIDCAMS program to create a sequential back-up of all catalogs\nusing the EXPORT command. This sequential back-up is\ncreated in the form of a multi-file tape volume, with each file\ncontaining one catalog. Although we currently have 20 catalogs\nin use at our installation, I have only presented the first part of\nthe JCL to provide an example.\n\nThe EXPORT command uses the TEMPORARY keyword to\nensure that the catalog remains intact on DASD. This keyword\nflags the catalog to inform IDCAMS that a back-up exists. It is\nalso responsible for the writing of a TYPE 36 SMF record to a\nSYS1.MANx dataset.\n\nThe other JCL presented below is used to produce a report on a\ndaily basis of the TYPE 36 SMF records. This JCL contains\nthe SAS program source code as instream data. The SMF data\nis dumped from the SYS1.MANx dataset to a tape volume at\n06:00 hours each day. We then run this process to produce the\nreport shown in Figure 1. This process was originally written in\nAssembler, however, the SAS code simplifies the extraction of\nthese records. This report is vital if a restore has to be\nperformed. For any users who do not utilize the SAS product,\nIBM provides the IFASMFI6 macro to map the fields in the\nTYPE 36 record. I have presented the format of this record\nbelow.\n\nThis process has been in production for several months and we\nhave already performed a catalog restore from the tape back-\nup. I have purposely not covered the restore operation as this\ncan depend upon your individual environment. The following\nmanuals can be used to help automate catalog recovery and\nalso provide detailed information on the various facilities\ncovered in this article:\n\no      DFPXA Catalog Administration Guide      -      GC26-4138\no      DFPXA ICF Administration: AMS Reference      -      GC26-4135\no      MVSXA SPL: SMF      -      GC28-1153\n\nFurther procedures could be developed to automate recovery\nusing the following SMF records:\n\no      TYPE17 - Scratch dataset statistics\no      TYPE18 - Rename dataset statistics\no      TYPE60 - VVDS updated\no      TYPE61 - ICF define activity\no      TYPE63 - VSAM entry defined\no      TYPE65 - ICF delete activity\no      TYPE66 - ICF alter activity\no      TYPE67 - VSAM entry deleted\no      TYPE68 - VSAM entry renamed\no      TYPE69 - VSAM dataspace defined, extended, or deleted.\n\n\nCATALOG BACK-UP PROCESS\n\n//STS01A        JOB      CLASS=A,MSGCLASS=H,MSGLEVEL=(1,1)\n//IDCAMS1       EXEC     PGM=IDCAMS,REGION=2M\n//STEPCAT       DD       DSN=CATALOG.FDRABR,DISP=SHR\n//BACKUP        DD       DSN=PROD.CATALOG.CAT1(+1),\n//              DISP=(,CATLG,DELETE),\n//              DCB=GDG,\n//              UNIT=(TAPE,,DEFER),\n//              LABEL=(1,SL,EXPDT=99000),\n//              VOL=(,RETAIN)\n//SYPSPRINT     DD       SYSOUT=*\n//SYSIN         DD       *\n  EXPORT -\n  CATALOG.FDRABR -\n  OUTFILE(BACKUP) -\n  TEMPORARY\n/*\n//*\n//IDCAMS2       EXEC     PGM=IDCAMS,REGION=2M\n//STEPCAT       DD       DSN=CATALOG.MVSA,DISP=SHR\n//BACKUP        DD       DSN=PROD.CATALOG.CAT2(+1),\n//              DISP=(,CATLG,DELETE),\n//              DCB=GDG,\n//              UNIT=(TAPE,,DEFER),\n//              LABEL=(2,SL,EXPDT=99000),\n//              VOL=(,RETAIN,REF=*.IDCAMS1.BACKUP)\n//SYSPRINT      DD       SYSOUT=*\n//SYSIN         DD       *\n  EXPORT -\n  CATALOG.MVSA -\n  OUTFILE(BACKUP) -\n  TEMPORARY\n/*\n//*\n//IDCAMS3       EXEC     PGM=IDCAMS,REGION=2M\n//STEPCAT       DD       DSN=CATALOG.PROD,DISP=SHR\n//BACKUP        DD       DSN=PROD.CATALOG.CAT3(+1),\n//              DISP=(,CATLG,DELETE),\n//              DCB=GDG,\n//              UNIT=(TAPE,,DEFER),\n//              LABEL=(3,SL,EXPDT=99000),\n//              VOL=(,RETAIN,REF=*.IDCAMS1.BACKUP)\n//SYSPRINT      DD       SYSOUT=*\n//SYSIN         DD       *\n  EXPORT -\n  CATALOG.PROD -\n  OUTFILE(BACKUP) -\n  TEMPORARY\n/*\n\n\nSAS CODE AND JCL TO PRODUCE TYPE36 RECORD REPORT\n\n//STS01A      JOB   (SDTS),'J.BRADLEY',CLASS=A,MSGCLASS=Q,NOTIFY=STS01\n//*      * THIS PROCESS IS USED TO FORMAT TYPE 36 EXPORT SMF RECORDS  *\n//*      * TO PRODUCE A REPORT OF ICF CATALOG EXPORTS.                *\n//*      * STEP1 - THIS STEP OF THE PROCESS EXTRACTS TYPE 36 RECORDS  *\n//*      *         FROM THE DAILY SMF BACK-UP DATASET AND WRITES      *\n//*      *         THEM TO A TEMPORARY DATASET.                       *\n//*      *         DD CARD SMF IS USED AS INPUT.                      *\n//*      *         DD CARD PDB IS USED AS OUTPUT.                     *\n//*\n//STEP1       EXEC  PGM=SASXAL,\n//            PARM='VERSIONLONG',\n//            REGION=4M\n//STEPLIB     DD    DISP=SHR,DSN=SAS.V6R06.LIBRARY\n//CONFIG      DD    DISP=SHR,DSN=SAS.V6R06.CNTL(BATCHXA)\n//            DD    DISP=SHR,DSN=MXG.V7R7.USER.SOURCE(BATCHCNF)\n//SASAUTOS    DD    DISP=SHR,DSN=SAS.V6R06.AUTOLIB\n//SASHELP     DD    DISP=SHR,DSN=SAS.V6R06.SASHELP\n//SASMSG      DD    DISP=SHR,DSN=SAS.V6R06.SASMSG\n//WORK        DD    UNIT=WORK,SPACE=(6144,(8000,500),,,ROUND),\n//            DCB=(RECFM=FS,DSORG=PS,LRECL=6144,BLKSIZE=6144)\n//SASLOG      DD    SYSOUT=*\n//SASLIST     DD    SYSOUT=*\n//SASPARM     DD    UNIT=WORK,SPACE=(400,(100,300)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=400,BUFNO=1)\n//SYSUDUMP    DD    SYSOUT=*\n//SASLOG      DD    SYSOUT=Q\n//SASLIST     DD    SYSOUT=*\n//SYSPRINT    DD    SYSOUT=*\n//SYSOUT      DD    SYSOUT=*\n//PDB         DD    DSN=&&SASTEMP,\n//            DISP=(NEW,PASS,DELETE),\n//            UNIT=WORK,\n//            SPACE=(CYL,(100,10),RLSE)\n//SPIN        DD    UNIT=WORK,SPACE=(CYL,(2,5)),DSN=&&SASDUMM,\n//            DISP=(NEW,DELETE,DELETE)\n//LIBRARY     DD    DSN=MXG.V7R7.SAS.FORMATS,DISP=SHR\n//SOURCLIB    DD    DSN=MXG.V7R7.USER.SOURCE,DISP=SHR\n//            DD    DSN=MXG.V7R7.SOURCE,DISP=SHR\n//            DD    DSN=STS01.BD.DATA,DISP=SHR\n//SMF         DD    DSN=SPROD.BD.LW.SMFTAPA(0),DISP=SHR\n//SYSIN       DD    *\n%INCLUDE SOURCLIB(VMACSMF ,VMAC36,\n                  IMACPDB ,EXPDBINC,EXPDBVAR,EXPDBCDE,IMACKEEP);\nRUN;\nOPTIONS SOURCE SOURCE2;\nDATA\n ID (KEEP=ID SYSTEM)\n _VAR36\n_SMF\n OUTPUT ID;\n _CDE36\nRUN;\nPAGE;\nPROC CONTENTS DATA=TYPE36; RUN ; QUIT ;\nPROC SORT NODUP DATA=TYPE36 OUT=PDB.TYPE36 _PROTECT;\n  BY SYSTEM;\n  RUN;\n  QUIT;\n/*\n//*      * STEP2 - THIS STEP OF THE PROCESS USES A SIMPLE SAS PR0GRAM *\n//*      *         TO PRODUCE A FORMATTED REPORT OF THE TYPE 36       *\n//*      *         RECORDS.                                           *\n//*\n//STEP1       EXEC  PGM=SASXAL,\n//            PARM='VERSIONLONG',\n//            REGION=4M\n//STEPLIB     DD    DISP=SHR,DSN=SAS.V6R06.LIBRARY\n//CONFIG      DD    DISP=SHR,DSN=SAS.V6R06.CNTL(BATCHXA)\n//            DD    DISP=SHR,DSN=MXG.V7R7.USER.SOURCE(BATCHCNF)\n//SASAUTOS    DD    DISP=SHR,DSN=SAS.V6R06.AUTOLIB\n//SASHELP     DD    DISP=SHR,DSN=SAS.V6R06.SASHELP\n//SASMSG      DD    DISP=SHR,DSN=SAS.V6R06.SASMSG\n//WORK        DD    UNIT=WORK,SPACE=(6144,(8000,500),,,ROUND),\n//            DCB=(RECFM=FS,DSORG=PS,LRECL=6144,BLKSIZE=6144)\n//SASLOG      DD    SYSOUT=*\n//SASLIST     DD    SYSOUT=*\n//SASPARM     DD    UNIT=WORK,SPACE=(400,(100,300)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=400,BUFNO=1)\n//SYSUDUMP    DD    SYSOUT=*\n//SASLOG      DD    SYSOUT=Q\n//SASLIST     DD    SYSOUT=*\n//SYSPRINT    DD    SYSOUT=*\n//SYSOUT      DD    SYSOUT=*\n//LIBRARY     DD    DSN=MXG.V7R7.SAS.FORMATS,DISP=SHR\n//SOURCLIB    DD    DSN=MXG.V7R7.USER.SOURCE,DISP=SHR\n//            DD    DSN=MXG.V7R7.SOURCE,DISP=SHR\n//            DD    DSN=STS01.BD.DATA,DISP=SHR\n//FT11F001    DD    SYSOUT=*\n//FT12F001    DD    SYSOUT=*\n//JXB         DD    DSN=&&SASTEMP,DISP=(OLD,DELETE)\n//SASLIB      DD    DSN=MXG.V7R7.SASLIB,DISP=SHR\n//SYSIN       DD    *\nDATA TYPE36;\n SET JXB.TYPE36;\nPROC SORT DATA=TYPE36;\n BY CATLNAME;\nLABEL CATLNAME='CATALOG NAME'\n      CATVOL='CATALOG VOLUME'\n      SYSTEM='SYSTEM ID'\n      EXPOTIME='EXPORT TIME AND DATE'\n      PORTVOL='TAPE VOLUME'\n      PORTNAME='TAPE DATASET NAME';\nPROC PRINT DATA=TYPE36 LABEL NOOBS;\nVAR CATLNAME CATVOL SYSTEM EXPOTIME PORTVOL PORTNAME;\nTITLE1 'REPORT ON ICF CATALOG BACK-UP PROCEDURE';\nTITLE2 '=======================================';\nRUN;\n\n\nFORMAT OF SMF TYPE 36 RECORD\n\nOFFSET       LENGTH     FORMAT     DESCRIPTION\n\n  0             2        Binary     Record Length.\n  2             2        Binary     Segment Descriptor.\n  4             1        Binary     Header Flag Byte.\n  5             1        Binary     Record Type.\n  6             4        Binary     Time record moved to SMF buffer.\n  10            4        Packed     Date record mvoed to SMF buffer.\n  14            4        EBCDIC     System identification.\n  18            4        EBCDIC     Subsystem identification.\n  22            2        EBCDIC     Record subtype.\n  24            2        Binary     Number of triplets.\n  26            2                   Reserved.\n  28            4        Binary     Offset to product section.\n  32            2        Binary     Length of product section.\n  34            2        Binary     Number of product sections.\n  36            4        Binary     Offset to data section.\n  40            2        Binary     Length of data section.\n  42            2        Binary     Number of data sections.\n\nPRODUCT SECTION\n\n  44            2        EBCDIC     Product version.\n  46            8        EBCDIC     Product name.\n  54            2        EBCDIC     Record type 36 level.\n\nDATA SECTION\n\n  56            8        EBCDIC     Jobname.\n  64            4        Binary     Reader start time.\n  68            4        Packed     Reader start date.\n  72            8        EBCDIC     User identification.\n  80            8        EBCDIC     Program name.\n  88            44       EBCDIC     ICF catalog name.\n  132           6        EBCDIC     Catalog volume serial number.\n  138           4        Binary     UCB device type.\n  142           8        EBCDIC     Date of export.\n  150           8        EBCDIC     Time of export.\n  158           44       EBCDIC     Portable dataset name.\n  202           6        EBCDIC     Portable dataset volume serial.\n  208           4        Binary     Portable dataset UCB device type.\n  212           2        EBCDIC     Export indicator.\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A005A02": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12X\\x02R\\x02Q\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:58:37", "lines": 594, "newlines": 593, "modlines": 0, "user": "VSAMUPD"}, "text": "Estimating VSAM cluster parameters\n\nThe two programs, NEKX and NEKY, can be used to\nestimate, on-line, the optimum size of an index Control\nInterval and to obtain information about a data Control\nInterval. The programs have been tested with VSE/SP 2.1, and\nVSAM Release 3. The name of the transactions NEKX and\nNEKY, programs NEKVP4 and NEKVP5, and maps\nNEKVM4 and NEKVM5 must be put in the CICS tables PPT\nand PCT.\n\n\nNEKX\n\nThe program and mapset with NEKX give an on-line estimate\nof VSAM KSDS index Control Interval size. This is a simple\nmethod of getting the index Control Interval size using the\nCICS command level interpreter. You need to know only the\nnumber of Control Intervals in the Control Area. This\ninformation can be obtained from a LISTCAT for the cluster.\nThis value is entered on the screen and the program says what\nis the best Control Interval size to use for the index component.\n\nThe formula used is:\n\n      CISZ = 24 + 7 + (Number of CI per CA x 9)\n\nWhere 24 is the number of bytes in the header, 7 is CIDF and\nRDF size, and 9 is used as approximately the length of one\nindex entry. The CI per CA value cannot be greater then 906.\n\nFigures 1, 2, and 3 show the initial screen, an example of the\nentered parameters, and an estimate of CI size, respectively.\n\n\nNEKY\n\nThe program and mapset with NEKY give an on-line estimate\nof VSAM data Control Interval size. This is a simple method\nof getting the data Control Interval size using the CICS\ncommand level interpreter. However, it only works for fixed\nlength records. You have to enter the record length, Free\nSpace, and mode of the cluster (sequential for greater CI sizes,\nand direct or mixed for smaller CI sizes).\n\nAs a result the program tells you how many records you have\nin one Control Interval, and, for a KSDS, how many reserve\nrecords, how many bytes are lost per Control Interval, and how\nmany are lost per record.\n\nFigures 4, 5, and 6 show the initial screen, an example of the\nentered parameters, and an estimate of CI size, respectively.\n\nNEKVP4\n\n         PRINT   NOGEN,ON\n* ON-LINE ASSEMBLER PROGRAM NEKVP4\n         MACRO\n&LABEL   NEKV1 &P1,&P2\n         CLC POM3C,=C'&P1'\n         BNE &LABEL\n         MVC POM2,=X&P2\n         B L1\n&LABEL   EQU *\n         MEND\n         MACRO\n&LABEL   NEKV2 &P1,&P2\n         CLC POM3A,=X'&P1'\n         BNE &LABEL\n         NC  POM2A,=X&P2\n         B L3\n&LABEL   EQU *\n         MEND\n         MACRO\n&LABEL   NEKV4  &P1\n         CP  POM3P,=P'&P1'   MACRO |\n         BH &LABEL\n         MVC CSZIO,=CL10'&P1'\n         B SNDMAP\n&LABEL   EQU *\n         MEND\nDFHEISTG DSECT\n         COPY  NEKVM4\n         COPY  DFHBMSCA\nPROGRAM  CSECT\n         EXEC CICS HANDLE AID    ENTER(LENTER) PF6(KRAJ) PF18(KRAJ)    C\n                                               ANYKEY(LANY) NOEDF\n         EXEC CICS HANDLE CONDITION ERROR(ERRORS) NOEDF\nSNDMAP   MVC NUMBERL,=X'FFFF'   CURSOR HERE\n         EXEC CICS SEND MAP('NEKVM4') CURSOR ERASE NOEDF\n         EXEC CICS RECEIVE MAP('NEKVM4') NOEDF\nLENTER   EQU *\n         MVC POM3,NUMBERI\n         MVI LINE10A,DFHBMASB\n         MVI CSZIA,DFHBMASB\nLX00     NEKV1  0,'000C'\nLX01     NEKV1  1,'001C'\nLX02     NEKV1  2,'002C'\nLX03     NEKV1  3,'003C'\nLX04     NEKV1  4,'004C'\nLX05     NEKV1  5,'005C'\nLX06     NEKV1  6,'006C'\nLX07     NEKV1  7,'007C'\nLX08     NEKV1  8,'008C'\nLX09     NEKV1  9,'009C'\n         B LBAD\nL1       EQU *\n         CLC POM3B,=X'F0'\n         BE L2\n         CLC POM3B,=X'F1'\n         BE L2\n         CLC POM3B,=X'F2'\n         BE L2\n         CLC POM3B,=X'F3'\n         BE L2\n         CLC POM3B,=X'F4'\n         BE L2\n         CLC POM3B,=X'F5'\n         BE L2\n         CLC POM3B,=X'F6'\n         BE L2\n         CLC POM3B,=X'F7'\n         BE L2\n         CLC POM3B,=X'F8'\n         BE L2\n         CLC POM3B,=X'F9'\n         BE L2\n         B LBAD\nL2       MVC POM2(1),POM3B\nLB00     NEKV2 F0,'0F'\nLB01     NEKV2 F1,'1F'\nLB02     NEKV2 F2,'2F'\nLB03     NEKV2 F3,'3F'\nLB04     NEKV2 F4,'4F'\nLB05     NEKV2 F5,'5F'\nLB06     NEKV2 F6,'6F'\nLB07     NEKV2 F7,'7F'\nLB08     NEKV2 F8,'8F'\nLB09     NEKV2 F9,'9F'\n         B LBAD\nL3       EQU *\n* POM2P HAS THE NUMBER\n         CP POM2P,=P'906'\n         BH LBIG\n         ZAP POM3P,POM2P\n         MP  POM3P,P9\n         AP  POM3P,P31\n* NOW ESTIMATE NEAREST VSAM CISIZE 512,1024 ...\nLXB00    NEKV4    512\nLXB01    NEKV4    1024\nLXB02    NEKV4    1536\nLXB03    NEKV4    2048\nLXB04    NEKV4    2560\nLXB05    NEKV4    3072\nLXB06    NEKV4    3584\nLXB07    NEKV4    4096\nLXB08    NEKV4    4608\nLXB09    NEKV4    5120\nLXB10    NEKV4    5632\nLXB11    NEKV4    6144\nLXB12    NEKV4    6656\nLXB13    NEKV4    7168\nLXB14    NEKV4    7680\nLXB15    NEKV4    8192\n         MVC CSZIO,=CL10'ERROR XXXX'\n         B SNDMAP\nERRORS   MVC ERRMSGO,=CL79' ERRORS     CALL SYSTEM PROGRAMMER'\n         B SNDMAP\nLANY     MVC ERRMSGO,=CL79'         WRONG KEY  '\n         B SNDMAP\nLBAD     MVC ERRMSGO,=CL79'  ENTERED NUMBER NOT CORRECTED |'\n         B SNDMAP\nLBIG     MVC ERRMSGO,=CL79'  ENTERED NUMBER TOO HIGH |'\n         B SNDMAP\nKRAJ     MVC PORUKA,=CL19'NORMAL END OF TASK '\n         EXEC CICS SEND FROM(PORUKA) ERASE NOEDF\n         EXEC CICS RETURN  NOEDF\nP9       DC PL1'9'\nP31      DC PL2'31'\nPOM3P    DS PL3\nPOM3     DS CL3\n         ORG POM3\nPOM3A    DS CL1\nPOM3B    DS CL1\nPOM3C    DS CL1\n         ORG ,\nPOM2     DS CL2\n         ORG POM2\nPOM2A    DS CL1\nPOM2B    DS CL1\n         ORG POM2\nPOM2P    DS PL2\n         ORG ,\nPORUKA   DS CL19\n         END\n\n\nNEKVM4\n\nMAPSET   DFHMSD TYPE=&SYSPARM,MODE=INOUT,CTRL=(FREEKB,FRSET),          C\n               TIOAPFX=YES,STORAGE=AUTO\nNEKVM4   DFHMDI SIZE=(24,80)\nIME      DFHMDF POS=(1,1),LENGTH=7,INITIAL='NEKVM4',ATTRB=(ASKIP,FSET)\n         DFHMDF POS=(1,12),ATTRB=(ASKIP),                              C\n               LENGTH=56,                                              C\n               INITIAL='                                               C\n                         '\nLINE3    DFHMDF POS=(3,1),                                             C\n               ATTRB=(PROT,ASKIP,BRT),                                 C\n               LENGTH=73,                                              C\n               INITIAL='E S T I M A T E   I N D E X   C O N T R O L  I C\n               N T E R V A L   S I Z E'\nLINE6    DFHMDF POS=(6,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=69,                                              C\n               INITIAL='ENTER NUMBER OF CONTROL INTERVAL  PER CONTROL AC\n               REA(DATA COMPONENT) : '\nNUMBER   DFHMDF POS=(6,71),                                            C\n               ATTRB=(UNPROT,BRT,NUM),                                 C\n               LENGTH=3\n         DFHMDF POS=(6,75),LENGTH=4\nLINE10   DFHMDF POS=(10,1),                                            C\n               ATTRB=(PROT,ASKIP,DRK),                                 C\n               LENGTH=52,                                              C\n               INITIAL='FOR YOUR CONTROL INTERVAL SIZE(INDEX COMPONENT)C\n               PUT : '\nCSZI     DFHMDF POS=(10,55),LENGTH=10,                                 C\n               ATTRB=(FSET,PROT,DRK)\nLINE23   DFHMDF POS=(23,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=79,                                              C\n               INITIAL='                           PF6,PF18 - CICS'\nERRMSG   DFHMDF POS=(24,1),LENGTH=79,ATTRB=(BRT,PROT)\n         DFHMSD TYPE=FINAL\n         END\n\n\nNEKVP5\n\n         PRINT   NOGEN,ON\n* ON-LINE ASSEMBLER PROGRAM NEKVP5\n         MACRO\n&LABEL   NEKVX &P1,&P2,&P3,&P4,&P5,&P6\n         CLC &P3,=X'&P1'\n         BNE &LABEL\n         &P4 &P5,=X&P2\n         B &P6\n&LABEL   EQU *\n         MEND\n         MACRO\n&LABEL   NEKVCS &P1,&P2\n         MVC LINE1,=CL6' &P1  '\n         MVC LINE+6(74),=CL74' '\n         CP P&P1,POM3P              CISIZE > RECORD LENGTH ?\n         BL &LABEL                  NO, GO FURTHER\n         ZAP POM6P,P&P1\n         DP POM6P,POM3P\n         MVC POM16,EDIT3\n         ED  POM16,POM6PA\n         MVC LINE3,POMB      TOTAL\n         MVC POM16,EDIT3\n         ED  POM16,POM6PB\n         MVC LINE9,POMB      LOST BYTES\n         ZAP POMTOT,POM6PA   POMTOT HAS NOW TOTAL\n         ZAP POMP6,POM6PB\n         DP  POMP6,POMTOT    LOST BYTES/TOTAL RECORDS\n         SRP POMP6A,1,0      FOR NEXT ADDING MULTIPLY 10\n         SRP POMP6B,1,0      FOR NEXT DIVIDING MULTIPLY 10\n         ZAP POM6P,POMP6B\n         DP  POM6P,POMTOT    1. DECIMAL PLACE\n         AP  POMP6A,POM6PA   POMP6A HAS NUMBER, 10 TIMES GREATHER\n         MVC POM16,EDIT3A\n         ED  POM16,POMP6A\n         MVC LINE11,POMB\n         ZAP POM6P,POMTOT\n         MP  POM6P,POM2P     TOTAL RECORDS X PERCENT\n         DP  POM6P,P100       DIVIDE 100\n         MVC POM16,EDIT3\n         ED  POM16,POM6PA\n         MVC LINE7,POMB      RESERVE RECORDS ON THE SCREEN\n         SP POMTOT,POM6PA    POMTOT HAS NOW RECORDS FOR USE\n         MVC POM16,EDIT3\n         ED  POM16,POMTOT\n         MVC LINE5,POMB      RECORDS FOR USE ON THE SCREEN\n&LABEL   EQU *\n         MVC &P2,LINE\n         MEND\nDFHEISTG DSECT\n         COPY  NEKVM5\n         COPY  DFHBMSCA\nPROGRAM  DFHEIENT CODEREG=(2,3)\n         EXEC CICS HANDLE AID    ENTER(LENTER) PF6(KRAJ) PF18(KRAJ)    C\n                                               ANYKEY(LANY) NOEDF\n         EXEC CICS HANDLE CONDITION ERROR(ERRORS) NOEDF\n* INITIAL VALUES\n         MVC XPOM5,=CL5'00100'\n         MVC IND,=CL1'S'\n         MVC FREES,=CL2'00'\nSNDMAP   MVC LENGTHL,=X'FFFF'   CURSOR HERE\n         EXEC CICS SEND MAP('NEKVM5') CURSOR ERASE NOEDF\n         EXEC CICS RECEIVE MAP('NEKVM5') NOEDF\nLENTER   EQU *\n         MVI LINE8A,DFHBMASB\n         MVI LINE7A,DFHBMASB\n         CLC LENGTHI,=X'0000000000'\n         BE LX1         IF NO ENTRY OLD INPUT USE\n         MVC XPOM5,LENGTHI\nLX1      MVC POM5,XPOM5\n         MVC LENGTHO,XPOM5\nLX00     NEKVX F0,'00000C',POM5E,MVC,POM3,L1\nLX01     NEKVX F1,'00001C',POM5E,MVC,POM3,L1\nLX02     NEKVX F2,'00002C',POM5E,MVC,POM3,L1\nLX03     NEKVX F3,'00003C',POM5E,MVC,POM3,L1\nLX04     NEKVX F4,'00004C',POM5E,MVC,POM3,L1\nLX05     NEKVX F5,'00005C',POM5E,MVC,POM3,L1\nLX06     NEKVX F6,'00006C',POM5E,MVC,POM3,L1\nLX07     NEKVX F7,'00007C',POM5E,MVC,POM3,L1\nLX08     NEKVX F8,'00008C',POM5E,MVC,POM3,L1\nLX09     NEKVX F9,'00009C',POM5E,MVC,POM3,L1\nL1       EQU *\n         MVC POM3+1(1),POM5D\nLB00     NEKVX F0,'0F',POM5C,NC,POM3B,L3\nLB01     NEKVX F1,'1F',POM5C,NC,POM3B,L3\nLB02     NEKVX F2,'2F',POM5C,NC,POM3B,L3\nLB03     NEKVX F3,'3F',POM5C,NC,POM3B,L3\nLB04     NEKVX F4,'4F',POM5C,NC,POM3B,L3\nLB05     NEKVX F5,'5F',POM5C,NC,POM3B,L3\nLB06     NEKVX F6,'6F',POM5C,NC,POM3B,L3\nLB07     NEKVX F7,'7F',POM5C,NC,POM3B,L3\nLB08     NEKVX F8,'8F',POM5C,NC,POM3B,L3\nLB09     NEKVX F9,'9F',POM5C,NC,POM3B,L3\nL3       EQU *\n         MVC POM3(1),POM5B\nLZ00     NEKVX F0,'0F',POM5A,NC,POM3A,L5\nLZ01     NEKVX F1,'1F',POM5A,NC,POM3A,L5\nLZ02     NEKVX F2,'2F',POM5A,NC,POM3A,L5\nLZ03     NEKVX F3,'3F',POM5A,NC,POM3A,L5\nLZ04     NEKVX F4,'4F',POM5A,NC,POM3A,L5\nLZ05     NEKVX F5,'5F',POM5A,NC,POM3A,L5\nLZ06     NEKVX F6,'6F',POM5A,NC,POM3A,L5\nLZ07     NEKVX F7,'7F',POM5A,NC,POM3A,L5\nLZ08     NEKVX F8,'8F',POM5A,NC,POM3A,L5\nLZ09     NEKVX F9,'9F',POM5A,NC,POM3A,L5\nL5       EQU *\n* POM3P HAS THE NUMBER OF RECORD LENGTH\n         CP POM3P,=P'32758'\n         BH LBIG\n         CLC FREESI,=X'0000'\n         BE LX2         IF NO ENTRY OLD INPUT USE\n         MVC FREES,FREESI\nLX2      MVC POM2,FREES\n         MVC FREESO,FREES\nL200     NEKVX  F0,'000C',POM2B,MVC,POM2X,L11\nL201     NEKVX  F1,'001C',POM2B,MVC,POM2X,L11\nL202     NEKVX  F2,'002C',POM2B,MVC,POM2X,L11\nL203     NEKVX  F3,'003C',POM2B,MVC,POM2X,L11\nL204     NEKVX  F4,'004C',POM2B,MVC,POM2X,L11\nL205     NEKVX  F5,'005C',POM2B,MVC,POM2X,L11\nL206     NEKVX  F6,'006C',POM2B,MVC,POM2X,L11\nL207     NEKVX  F7,'007C',POM2B,MVC,POM2X,L11\nL208     NEKVX  F8,'008C',POM2B,MVC,POM2X,L11\nL209     NEKVX  F9,'009C',POM2B,MVC,POM2X,L11\nL11      EQU *\nL300     NEKVX  F0,'00',POM2A,MVC,POM2X(1),L12\nL301     NEKVX  F1,'01',POM2A,MVC,POM2X(1),L12\nL302     NEKVX  F2,'02',POM2A,MVC,POM2X(1),L12\nL303     NEKVX  F3,'03',POM2A,MVC,POM2X(1),L12\nL304     NEKVX  F4,'04',POM2A,MVC,POM2X(1),L12\nL305     NEKVX  F5,'05',POM2A,MVC,POM2X(1),L12\nL306     NEKVX  F6,'06',POM2A,MVC,POM2X(1),L12\nL307     NEKVX  F7,'07',POM2A,MVC,POM2X(1),L12\nL308     NEKVX  F8,'08',POM2A,MVC,POM2X(1),L12\nL309     NEKVX  F9,'09',POM2A,MVC,POM2X(1),L12\nL12      EQU *\n* POM2P HAS % FREESPACE\n         CLC INDI,=X'00'\n         BE LX3         IF NO ENTRY OLD INPUT USE\n         MVC IND,INDI\nLX3      MVC INDO,IND\n         CLC IND,=C'S'\n         BE LSEQ\n* FOR MIXED AND DIRECT PROCESSING :\nLMIXS    EQU *\nLLL09    NEKVCS  512,LINE09O\nLLL10    NEKVCS 1024,LINE10O\nLLL11    NEKVCS 1536,LINE11O\nLLL12    NEKVCS 2048,LINE12O\nLLL13    NEKVCS 2560,LINE13O\nLLL14    NEKVCS 3072,LINE14O\nLLL15    NEKVCS 3584,LINE15O\nLLL16    NEKVCS 4096,LINE16O\nLLL17    NEKVCS 4608,LINE17O\nLLL18    NEKVCS 5120,LINE18O\nLLL19    NEKVCS 5632,LINE19O\nLLL20    NEKVCS 6144,LINE20O\nLLL21    NEKVCS 6656,LINE21O\n         B SNDMAP\nLSEQ     EQU *\nLXL09    NEKVCS   7168,LINE09O\nLXL10    NEKVCS   7680,LINE10O\nLXL11    NEKVCS   8192,LINE11O\nLXL12    NEKVCS  10240,LINE12O\nLXL13    NEKVCS  12288,LINE13O\nLXL14    NEKVCS  14336,LINE14O\nLXL15    NEKVCS  16384,LINE15O\nLXL16    NEKVCS  18432,LINE16O\nLXL17    NEKVCS  20480,LINE17O\nLXL18    NEKVCS  22528,LINE18O\nLXL19    NEKVCS  24576,LINE19O\nLXL20    NEKVCS  26624,LINE20O\nLXL21    NEKVCS  28672,LINE21O\nLXL22    NEKVCS  30720,LINE22O\n         B SNDMAP\nERRORS   MVC ERRMSGO,=CL79' ERRORS     CALL SYSTEM PROGRAMMER'\n         B SNDMAP\nLANY     MVC ERRMSGO,=CL79'         WRONG KEY  '\n         B SNDMAP\nLBIG     MVC ERRMSGO,=CL79'  ENTERED NUMBER TOO HIGH |'\n         B SNDMAP\nKRAJ     MVC PORUKA,=CL19'NORMAL END OF TASK '\n         EXEC CICS SEND FROM(PORUKA) ERASE NOEDF\n         EXEC CICS RETURN  NOEDF\nFREES    DS CL2\nIND      DS CL1\nPOM2     DS CL2\n         ORG POM2\nPOM2A    DS CL1\nPOM2B    DS CL1\n         ORG ,\nPOM2X    DS CL2\n         ORG POM2X\nPOM2XA   DS CL1\nPOM2XB   DS CL1\n         ORG POM2X\nPOM2P    DS PL2\n         ORG ,\nXPOM5    DS CL5\nPOM5     DS CL5\n         ORG POM5\nPOM5A    DS CL1\nPOM5B    DS CL1\nPOM5C    DS CL1\nPOM5D    DS CL1\nPOM5E    DS CL1\n         ORG ,\nPOM3     DS CL3\n         ORG POM3\nPOM3A    DS CL1\nPOM3B    DS CL1\nPOM3C    DS CL1\n         ORG POM3\nPOM3P    DS PL3\n         ORG ,\nPOMTOT   DS PL3\nPOM16    DS 0CL16\nPOMA     DS CL6\nPOMB     DS CL10\nPORUKA   DS CL19\nLINE     DS CL79\n         ORG LINE\nLINE1    DS CL6\nLINE2    DS CL9\nLINE3    DS CL10\nLINE5    DS CL10\nLINE7    DS CL10\nLINE8    DS CL4\nLINE9    DS CL10\nLINE10   DS CL4\nLINE11   DS CL10\nLINE12   DS CL2\n         ORG ,\nBLENK    DC CL79' '\nEDIT2    DC XL16'40404040404040404040404040202120'\nEDIT3    DC XL16'40404040404040404040402020202120'\nEDIT3A   DC XL16'40404040404040404040202021204B20'\nPOM6P    DS PL6\n         ORG POM6P\nPOM6PA   DS PL3\nPOM6PB   DS PL3\n         ORG ,\nPOMP6    DS PL6\n         ORG POMP6\nPOMP6A   DS PL3\nPOMP6B   DS PL3\n         ORG ,\nP100     DC PL3'100'\n* IMMEDIATE SUBTRACT 10 BYTES    2 X RDF + CIDF =2X3+4=10\nP512     DC PL3'502'\nP1024    DC PL3'1014'\nP1536    DC PL3'1526'\nP2048    DC PL3'2038'\nP2560    DC PL3'2550'\nP3072    DC PL3'3062'\nP3584    DC PL3'3574'\nP4096    DC PL3'4086'\nP4608    DC PL3'4598'\nP5120    DC PL3'5110'\nP5632    DC PL3'5622'\nP6144    DC PL3'6134'\nP6656    DC PL3'6646'\nP7168    DC PL3'7158'\nP7680    DC PL3'7670'\nP8192    DC PL3'8182'\nP10240   DC PL3'10230'\nP12288   DC PL3'12278'\nP14336   DC PL3'14326'\nP16384   DC PL3'16374'\nP18432   DC PL3'18422'\nP20480   DC PL3'20470'\nP22528   DC PL3'22518'\nP24576   DC PL3'24566'\nP26624   DC PL3'26614'\nP28672   DC PL3'28662'\nP30720   DC PL3'30710'\nP32768   DC PL3'32758'\n         END\n\n\nNEKVM5\n\nMAPSET   DFHMSD TYPE=&SYSPARM,MODE=INOUT,CTRL=(FREEKB,FRSET),          C\n               TIOAPFX=YES,STORAGE=AUTO\nNEKVM5   DFHMDI SIZE=(24,80)\nIME      DFHMDF POS=(1,1),LENGTH=7,INITIAL='NEKVM5',ATTRB=(ASKIP,FSET)\n         DFHMDF POS=(1,10),ATTRB=(ASKIP,BRT),                          C\n               LENGTH=69,                                              C\n               INITIAL='E S T I M A T E   D A T A   C O N T R O L  I N C\n               T E R V A L   S I Z E'\n         DFHMDF POS=(2,12),ATTRB=(ASKIP),                              C\n               LENGTH=76,                                              C\n               INITIAL='             FOR FIXED RECORD LENGTH ONLY'\nLINE4    DFHMDF POS=(4,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=21,                                              C\n               INITIAL='ENTER RECORD LENGTH :'\nLENGTH   DFHMDF POS=(4,23),                                            C\n               ATTRB=(UNPROT,BRT,NUM),                                 C\n               LENGTH=5\n         DFHMDF POS=(4,29),LENGTH=50\nLINE5    DFHMDF POS=(5,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=62,                                              C\n               INITIAL='% FREESPACE IN THE CI SIZE - KSDS ONLY    OTHERC\n               WISE ENTER  0 :'\nFREES    DFHMDF POS=(5,64),                                            C\n               ATTRB=(UNPROT,BRT,NUM),                                 C\n               LENGTH=2\n         DFHMDF POS=(5,67),LENGTH=7\nLINE6    DFHMDF POS=(6,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=67,                                              C\n               INITIAL='PUT  S(SEQUENTIAL PROCESSING) OR  M(DIRECT+SEQUC\n               ENTIAL PROCESSING) :'\nIND      DFHMDF POS=(6,69),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(6,71),LENGTH=8\nLINE7    DFHMDF POS=(7,1),                                             C\n               ATTRB=(PROT,ASKIP,DRK),                                 C\n               LENGTH=79,                                              C\n               INITIAL='                                               C\n                    LOST BYTES     LOST BYTES/'\nLINE8    DFHMDF POS=(8,1),                                             C\n               ATTRB=(PROT,ASKIP,DRK),                                 C\n               LENGTH=79,                                              C\n               INITIAL='CISIZE       RECORDS: TOTAL    FOR USE   RESERVC\n               E      PER CI      RECORDS TOTAL'\nLINE09   DFHMDF POS=(09,1),ATTRB=PROT,LENGTH=79\nLINE10   DFHMDF POS=(10,1),ATTRB=PROT,LENGTH=79\nLINE11   DFHMDF POS=(11,1),ATTRB=PROT,LENGTH=79\nLINE12   DFHMDF POS=(12,1),ATTRB=PROT,LENGTH=79\nLINE13   DFHMDF POS=(13,1),ATTRB=PROT,LENGTH=79\nLINE14   DFHMDF POS=(14,1),ATTRB=PROT,LENGTH=79\nLINE15   DFHMDF POS=(15,1),ATTRB=PROT,LENGTH=79\nLINE16   DFHMDF POS=(16,1),ATTRB=PROT,LENGTH=79\nLINE17   DFHMDF POS=(17,1),ATTRB=PROT,LENGTH=79\nLINE18   DFHMDF POS=(18,1),ATTRB=PROT,LENGTH=79\nLINE19   DFHMDF POS=(19,1),ATTRB=PROT,LENGTH=79\nLINE20   DFHMDF POS=(20,1),ATTRB=PROT,LENGTH=79\nLINE21   DFHMDF POS=(21,1),ATTRB=PROT,LENGTH=79\nLINE22   DFHMDF POS=(22,1),ATTRB=PROT,LENGTH=79\nLINE23   DFHMDF POS=(23,1),                                            C\n               ATTRB=(PROT,ASKIP,BRT),                                 C\n               LENGTH=79,                                              C\n               INITIAL='                           PF6,PF18 - CICS'\nERRMSG   DFHMDF POS=(24,1),LENGTH=79,ATTRB=(BRT,PROT)\n         DFHMSD TYPE=FINAL\n         END\n\n\nNenad Kuzmanovic\nArenaturist (Yugoslavia)                              c Nenad Kuzmanovic 1992\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A005A03": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x03\\xb8\\x03\\xb8\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 952, "newlines": 952, "modlines": 0, "user": "VSAMUPD"}, "text": "KSDS data component information\n\nThis is an Assembler program that will process the data\ncomponent of a KSDS either physically or logically. Among\nother information, the average length of all records processed\nwill be reported, as well as showing the fragmentation of\nspanned records (if any).\n\nVSAMDST  TITLE 'PROGRAM FOR PRINTING CONTROL INTERVAL AND OTHER STATS'\n         PRINT NOGEN\n         SPACE 1\n*        THIS PROGRAM WILL PRINT FOR EVERY CI, THE FOLLOWING DATA:\n*              FREE SPACE IN THE CI\n*              NUMBER OF LOGICAL RECORDS IN THE CI\n*              THE AVERAGE RECORD LENGTH OF THE RECORDS IN THE CI\n*              THE LONGEST RECORD LENGTH IN THE CI\n*              THE SHORTEST RECORD LENGTH IN THE CI\n         SPACE 1\n*        THIS PROGRAM WILL, ON REACHING THE END OF THE VSAM USAGE,\n*        PRINT THE FOLLOWING DATA:\n*              TOTAL FREE SPACE BYTES IN THE VSAM USAGE (THIS WILL\n*                  INCLUDE THE UNUSED BYTES IN CIS AS WELL AS THE\n*                  UNUSED CIS IN CAS)\n*              TOTAL NUMBER OF LOGICAL DATA RECORDS IN THE OBJECT\n*              AVERAGE RECORD LENGTH OF ALL LOGICAL DATA RECORDS IN\n*                  THE OBJECT\n*              THE LONGEST RECORD LENGTH IN THE OBJECT\n*              THE SHORTEST RECORD LENGTH IN THE OBJECT\n         SPACE 1\n*        SUGGESTED JCL - TO PROCESS THE DATA COMPONENT\n         SPACE 1\n*        //       EXEC PGM=VSAMDST\n*        //SYSUDUMP DD SYSOUT=*\n*        //SYSPRINT DD SYSOUT=*\n*        //VSAM     DD DSN=CLUSTER.NAME,DISP=SHR\n         SPACE 2\n*        THE PROGRAM MAY PROCESS THE CIS WITHIN A CA EITHER\n*        LOGICALLY OR PHYSICALLY.  THE SPECIFIC PROCESS IS\n*        CONTROLLED BY JOB STEP PARAMETER.  IF NO PARAMETER\n*        IS SPECIFIED, THE DEFAULT IS A LOGICAL PROCESS.\n*        SIMILARLY, IF THE INPUT OBJECT PERMITS SPANNED\n*        RECORDS, THE PROCESS IS FORCED TO LOGICAL AS THERE\n*        MAY BE LOGIC PROBLEMS WHEN SPANNED CIS ARE PROCESSED\n*        PHYSICALLY.\n*        FOR EXAMPLE:\n         SPACE 1\n*        //       EXEC PGM=VSAMDST,PARM=P    PHYSICAL\n         SPACE 1\n*        //       EXEC PGM=VSAMDST,PARM=L    LOGICAL\n         TITLE 'MACROS, DSECTS AND CONTROL BLOCKS USED'\n*        ABEND                          TO ABEND THE PROGRAM\n*        ACB                            ACCESS METHOD CONTROL BLOCK\n*        CLOSE                          CLOSE FILE(S)\n*        DCB                            DATA CONTROL BLOCK\n*        DCBD (IHADCB)                  DCB DSECT FOR MAPPING DCB\n*        EXLST                          VSAM EXIT LIST\n*        FREEMAIN                       RELEASE STORAGE\n*        FREEPOOL                       RELEASE BUFFER POOL\n*        GET - VSAM                     ACCESS A RECORD\n*        GETMAIN                        ACQUIRE STORAGE\n*        IDAAMB                         DSECT MAPPING THE AMB\n*        IDAAMBL                        DSECT MAPPING THE AMBL\n*        IDAAMDSB                       DSECT MAPPING THE AMDSB\n*        IEFJFCBN                       DSECT MAPPING THE JFCB\n*        IFGACB                         DSECT MAPPING THE ACB\n*        OPEN                           PREPARE FILE(S) FOR PROCESSING\n*        PUT - QSAM                     WRITE A RECORD\n*        RDJFCB                         READ SPECIFIC JFCB\n*        RPL                            VSAM REQUEST PARAMETER LIST\n*        SHOWCB                         OBTAIN DATA FROM A VSAM CB\n*        TESTCB                         TEST DATA WITHIN A VSAM CB\n*        WTO                            WRITE TO OPERATOR\n         SPACE 2\n*        REGISTER EQUATES\n         SPACE 1\nEditor's note: register equates go here.\n         TITLE 'PROGRAM CONTROL CODE'\n*        1.    SAVE CALLER'S REGISTERS\n*        2.    ESTABLISH CSECT ADDRESSABILITY\n*        3.    OBTAIN SAVE AREA\n*        4.    ESTABLISH HSA AND LSA CHAINS\n*        5.    PERFORM PROGRAM INITIALIZATION\n*        6.    PERFORM BULK OF PROGRAM PROCESSING\n*        7.    PERFORM PROGRAM TERMINATION\n*        8.    RESTORE CALLER'S SAVE AREA\n*        9.    FREE ACQUIRED SAVE AREA\n*        10.   RESTORE REGISTERS\n*        11.   EXIT PROGRAM\n*\n*        REGISTER USAGE\n*        0     MACROS\n*        1     MACROS - ADDRESS OF ACQUIRED SAVE AREA\n*        2     WORK - ADDRESS OF ACQUIRED SAVE AREA\n*        10    BRANCH AND SAVE RETURN ADDRESS\n*        11    PROGRAM CSECT BASE REGISTER - 1\n*        12    PROGRAM CSECT BASE REGISTER - 2\n*        13    SAVE AREA ADDRESS\n*        14    RETURN ADDRESS\n*        15    ENTRY POINT ADDRESS / CONDITION CODE\nVSAMDST  CSECT\n         STM   R14,R12,12(R13)          . SAVE CALLER'S REGISTERS\n         LR    R11,R15                  . LOAD 11 AS PROGRAM BASE\n         USING VSAMDST,R11,R12          . ESTABLISH ADDRESSABILITY\n         LA    R12,4095(,R11)           . FOR SECOND BASE AS WELL\n         LA    R12,1(,R12)\n         GETMAIN R,                     . GETMAIN FOR SAVE AREA        C\n               LV=72\n         ST    R13,4(,R1)               . BACKWARD SAVE AREA ->\n         ST    R1,8(,R13)               . FORWARD SAVE AREA ->\n         LR    R13,R1                   . 13 -> PROGRAM'S SAVE AREA\n         BAS   R10,INITIAL              . PERFORM INITIALIZATION\n         BAS   R10,PROCESS              . PERFORM MAIN PROCESSING\n         BAS   R10,TERMIN               . PERFORM PROGRAM TERMINATION\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . RELEASE ACQUIRED SAVE AREA   C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . RESTORE 14\n         SLR   R15,R15                  . 15 - ZERO (CONDITION CODE)\n         LM    R0,R12,20(R13)           . RESTORE 0 THROUGH 12\n         BR    R14                      . EXIT PROGRAM\n         TITLE 'PROGRAM INITIALIZATION'\nINITIAL  EQU   *\n*        1.    PROCESS JOB STEP PARAMETER\n*        2.    ISSUE READ JFCB\n*        3.    OPEN FILES AND CHECK OPEN\n*        4.    PERFORM VSAM INITIALIZATION\n*        5.    INITIALIZE DATA AREAS\n*\n*        REGISTER USAGE\n*        1     MACROS AND WORK\n*        2     ADDRESS OF DCB\n*        10    BRANCH AND SAVE RETURN ADDRESS\n*        15    RETURN CODE\n*\nB0001    EQU   *\n         ST    R10,BSAVE                . SAVE REGISTER 10\n*                                       . PROCESS JOB STEP PARAMETER\n         MVI   LOGICAL,ON               . DEFAULT TO LOGICAL PROCESS\n         L     R1,4(,R13)               . 1 -> CALLER'S SAVE AREA\n         L     R1,24(,R1)               . 1 -> PARAMETER LIST\n         L     R1,0(,R1)                . 1 -> PARAMETER\n         OC    0(2,R1),0(R1)            . Q. JOB STEP PARAMETER?\n         BZ    B0002                    . A. NO\n         CLI   2(R1),C'L'               . Q. \"L\" SPECIFIED?\n         BE    B0002                    . A. YES\n         MVI   LOGICAL,OFF              . INDICATE PHYSICAL PROCESS\nB0002    EQU   *\n*                                       . ISSUE READ JFCB FOR DSN\n         RDJFCB DUMMY                   . GO GET JFCB\n         LTR   R15,R15                  . Q. RDJFCB WORK?\n         BNZ   B0003                    . A. NO\n         MVC   TDSN,JFCBDSNM            . MOVE OUT DSN\nB0003    EQU   *\n*                                       . OPEN FILES\n         OPEN  (VSAM,,SYSPRINT,OUTPUT)\n         LTR   R15,R15                  . Q. OPENS OKAY\n         BZ    B0004                    . A. YES\n         LA    R2,SYSPRINT              . 2 -> SYSPRINT DCB\n         USING IHADCB,R2                . USE DSECT TO MAP DCB\n         TM    DCBOFLGS,DCBOFOPN        . Q. OPEN OF SYSPRINT OK?\n         BNO   B0005                    . A. NO - OPEN FAILED\n         DROP  R2                       . DCB DSECT NOT REQUIRED\n         LA    R2,VSAM                  . 2 -> VSAM ACB\n         USING IFGACB,R2                . USE DSECT TO MAP ACB\n         TM    ACBOFLGS,ACBOPEN         . Q. OPEN OF VSAM OK?\n         BNO   B0006                    . A. NO - OPEN FAILED\n         DROP  R2                       . ACB DSECT NOT REQUIRED\nB0004    EQU   *\n         BAS   R10,CHKVSAM              . PERFORM VSAM INITIALIZATION\n*                                       . INITIALIZE DATA AREAS\n         XC    TOTREC,TOTREC\n         XC    TOTBYTES,TOTBYTES\n         XC    SPANL,SPANL\n         MVC   SHORTREC,=H'-1'\n         XC    LONGREC,LONGREC\n         ZAP   TOTFSPC,=P'+0'\n         ZAP   #CIREAD,=P'+0'\n         ZAP   #LINE,=P'+60'\n         ZAP   #PAGE,=P'+1'\n         MVI   LEFT,OFF\n         MVI   SPAN,OFF\n         L     R10,BSAVE                . RESTORE 10\n         BR    R10                      . RETURN FROM WHENCE\n         TITLE 'PROGRAM INITIALIZATION FAILURES'\nB0005    EQU   *\n*                                       . OPEN FAILURE SYSPRINT\n         WTO   'OPEN FAILURE FOR FILE SYSPRINT',                       C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN OF SAVE AREA        C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,10                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         SPACE 2\nB0006    EQU   *\n*                                       . OPEN FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         WTO   'OPEN FAILURE FOR FILE VSAM',                           C\n               ROUTCDE=11\n*                                       . GET ACB ERROR CODE\n         SHOWCB ACB=VSAM,                                              C\n               AREA=OPENERR,                                           C\n               FIELDS=ERROR,                                           C\n               LENGTH=4\n         LM    R2,R3,VSAMERR            . LOAD REGISTERS\n         ABEND 100,                                                    C\n               DUMP\n         TITLE 'MAIN PROCESSING LOOP'\nPROCESS  EQU   *\n*        1.    IF LOGICAL PROCESS\n*              A.    DIRECT READ OF SEQUENCE SET RECORD\n*              B.    EXTRACT INDEX HEADER\n*              C.    ESTABLISH ADDRESSES WITHIN RECORD\n*              D.    DETERMINE CI ADDRESS OF DATA COMPONENT\n*                    CI\n*        2.    READ DATA COMPONENT CI\n*        3.    PERFORM DATA CI PROCESSING\n*        4.    IF LOGICAL PROCESS\n*              A.    ACCESS NEXT INDEX ENTRY\n*              B.    IF NO MORE INDEX ENTRIES IN CURRENT\n*                    INDEX RECORD\n*                    CHECK HORIZONTAL POINTER\n*                    IF BINARY ZEROS - END OF TASK\n*                    IF NOT BINARY ZEROS - READ NEXT LOGICAL\n*                    INDEX RECORD\n*        5.    IF NOT LOGICAL PROCESS, READ NEXT DATA CI\n*\n*        REGISTER USAGE\n*        1     MACROS AND WORK\n*        2     WORK\n*        3     WORK\n*        4     WORK\n*        7     CURRENT POSITION WITHIN INDEX RECORD\n*        8     ADDRESS OF HIGH-KEY IN CURRENT SECTION\n*        9     ADDRESS OF HIGH-KEY IN HIGHEST KEYED SECTION\n*        10    BRANCH AND SAVE RETURN ADDRESS\n*        14    MACROS - RETURN ADDRESS\n*        15    MACROS - ENTRY POINT ADDRESS, RETURN CODE\nC0001    EQU   *\n         ST    R10,CSAVE                . SAVE 10\n         CLI   LOGICAL,ON               . Q. LOGICAL PROCESS?\n         BNE   C0004                    . A. NO\nC0002    EQU   *\n         MVC   IXRBA,SSRBA              . POINT GETIX RBA TO SEQ. SET\n         GETIX RPL=IXRPL                . GET THE INDEX CI\n         LTR   R15,R15                  . Q. GET OKAY?\n         BNZ   C0007                    . A. NO\n         L     R7,@IXCI                 . 7 -> INDEX CI\n         MVC   IXHFORM,0(R7)            . PULL OUT INDEX HEADER\n         MVC   SSRBA,IXHHP              . SAVE HORIZONTAL POINTER\n         TR    IXHPTLS,PLTBL            . DETERMINE VERTICAL POINTER\n*                                       .   LENGTH\n         SLR   R2,R2                    . 2 - ZERO\n         IC    R2,IXHPTLS               . 2 - LENGTH OF VERTICAL PTR\n         ST    R2,PTLS                  . SAVE POINTER LENGTH\n         MVC   CARBA,IXHBRBA            . SAVE DATA COMPONENT CA RBA\n         LH    R8,IXHSEO                . 8 - DISP HIGH-KEY FIRST\n*                                       .   SECTION\n         AR    R8,R7                    . 8 -> HIGH-KEY FIRST SECTION\n         LH    R9,IXHLEO                . 9 - DISPLACEMENT HIGH-KEY\n         AR    R9,R7                    . 9 -> HIGHEST KEY IN INDEX CI\n         LH    R4,IXRDFDSP              . 4 - INDEX RDF DISPLACEMENT\n         AR    R7,R4                    . 7 -> INDEX RDF\nC0003    EQU   *\n         S     R7,PTLS                  . 7 -> VERTICAL POINTER\n         L     R4,PTLS                  . 4 - VERTICAL POINTER LENGTH\n         SLR   R2,R2                    . 2 - ZERO\n         EX    R4,ICM                   . LOAD POINTER INTO REGISTER\n         B     *+8                      . BRANCH ROUND EXECUTE\nICM      ICM   R2,1,0(R7)               . 2 - CI RELATIVE NUMBER\n         SRDA  R2,32(R0)                . 3 - CI RELATIVE NUMBER\n         M     R2,CISZ                  . 3 - CI DISPLACEMENT IN CA\n         A     R3,CARBA                 . 3 - CI'S RBA\n         ST    R3,PTRBA                 . SAVE CI'S RBA\n*                                       . COMMON CODE TO BOTH LOGICAL\n*                                       .   AND PHYSICAL PROCESSING\nC0004    EQU   *\n         GET   RPL=GETRPL               . GET THE NEXT CI\n         LTR   R15,R15                  . Q. GET ON VSAM OK?\n         BNZ   C0008                    . A. NO - GET FAILED\n         BAS   R10,DATAPROC             . PROCESS THE DATA COMPONENT\n*                                       .   CONTROL INTERVAL\n         CLI   LOGICAL,ON               . Q. LOGICAL PROCESS?\n         BNE   C0004                    . A. NO\n         BCTR  R7,R0                    . 7 -> LENGTH OF KEY\n         SLR   R2,R2                    . 2 - ZERO\n         IC    R2,0(,R7)                . 2 - LENGTH OF KEY\n         BCTR  R7,R0                    . 7 -> FRONT KEY COMP. COUNT\n         SLR   R7,R2                    . 7 -> START OF KEY\n         CR    R7,R8                    . Q. END OF SECTION?\n         BH    C0003                    . A. NO - PROCESS NEXT INDEX\n*                                       .   ENTRY\n         CR    R7,R9                    . Q. END OF KEYS?\n         BNH   C0005                    . A. YES - GET NEXT INDEX CI\n         SH    R7,=H'+2'                . 7 -> SECTION POINTER\n         ICM   R2,3,0(R7)               . 2 - OFFSET TO NEXT HIGH-KEY\n         SLR   R8,R2                    . 8 -> HIGH-KEY NEXT SECTION\n         B     C0003                    . PROCESS NEXT SECTION\nC0005    EQU   *\n*                                       . END OF INDEX CI PROCESS\n         OC    SSRBA,SSRBA              . Q. END OF SEQUENCE SET?\n         BNZ   C0002                    . A. NO - GET NEXT INDEX CI\nC0006    EQU   *\n         L     R10,CSAVE                . RESTORE 10\n         BR    R10                      . RETURN\n         TITLE 'MAIN PROGRAM PROCESSING FAILURES'\nC0007    EQU   *\n*                                       . GET FAILURE VSAM - INDEX\n         ST    R15,REG15                . SAVE 15\n         LA    R3,VSAM                  . 3 -> ACB\n         ST    R3,OPENERR               . SAVE\n         WTO   'GET FAILURE FOR FILE VSAM',                            C\n               ROUTCDE=11\n*                                       . GET RPL FEED BACK CODE\n         SHOWCB RPL=IXRPL,                                             C\n               AREA=RPLFDBK,                                           C\n               FIELDS=FDBK,                                            C\n               LENGTH=4\n         LM    R2,R4,VSAMERR            . 2 - 4 VSAM ERROR CODES\n         ABEND 101,                                                    C\n               DUMP\nC0008    EQU   *\n*                                       . GET FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         LA    R3,VSAM                  . 3 -> ACB\n         ST    R3,OPENERR               . SAVE\n         WTO   'GET FAILURE FOR FILE VSAM',                            C\n               ROUTCDE=11\n*                                       . GET RPL FEED BACK CODE\n         SHOWCB RPL=GETRPL,                                            C\n               AREA=RPLFDBK,                                           C\n               FIELDS=FDBK,                                            C\n               LENGTH=4\n         LM    R2,R4,VSAMERR            . 2 - 4 VSAM ERROR CODES\n         ABEND 102,                                                    C\n               DUMP\n         TITLE 'PROGRAM TERMINATION PROCESSING'\nTERMIN   EQU   *\n*        1.    OUTPUT ANY PARTIALLY COMPLETED PRINT LINE\n*        2.    FORMAT AND OUTPUT TOTAL LINE\n*        3.    CLOSE FILES\n*        4.    FREE BUFFERS\n*        REGISTER USAGE\n*        1     MACROS\n*        2     WORK\n*        3     WORK\n*        10    BRANCH AND SAVE RETURN ADDRESS\n*        14    MACROS - RETURN ADDRESS\n*        15    MACROS - ENTRY POINT\nD0001    EQU   *\n*                                       . CHECK FOR ANY LAST CI DATA\n         CLI   LEFT,ON                  . Q. LAST CI'S DATA TO BE\n*                                       .   OUTPUT?\n         BNE   D0002                    . A. NO\n         PUT   SYSPRINT,                                               C\n               LINEA\nD0002    EQU   *\n         MVC   CINUM2,MASK9             . EDIT AND OUTPUT TOTALS\n         ED    CINUM2,#CIREAD           . CIS READ\n         MVC   CIFSPC2,MASK9            . TOTAL FREE SPACE\n         ED    CIFSPC2,TOTFSPC+4\n         L     R2,TOTREC                . TOTAL NUMBER OF RECORDS\n         CVD   R2,WORKD\n         MVC   CIRECS2,MASK9\n         ED    CIRECS2,WORKD+3\n         LTR   R2,R2                    . Q. ANY RECORDS?\n         BZ    D0003                    . A. NO - NO AVERAGE\n         LH    R2,LONGREC               . LONGEST RECORD LENGTH\n         CVD   R2,WORKD\n         MVC   MAXREC2,MASK5\n         ED    MAXREC2,WORKD+5\n         LH    R2,SHORTREC              . SHORTEST RECORD LENGTH\n         CVD   R2,WORKD\n         MVC   MINREC2,MASK5\n         ED    MINREC2,WORKD+5\n         SLR   R2,R2                    . 2 - ZERO\n         L     R3,TOTBYTES              . 3 - TOTAL BYTES IN RECORDS\n         D     R2,TOTREC                . AVERAGE RECORD LENGTH\n         CVD   R3,WORKD\n         MVC   AVGREC2,MASK5\n         ED    AVGREC2,WORKD+5\nD0003    EQU   *\n         MVC   LINEBD,LINE2             . OUTPUT OBJECT TOTALS\n         PUT   SYSPRINT,                                               C\n               LINEB\n         CLOSE (VSAM,,SYSPRINT)         . CLOSE FILES\n         FREEPOOL SYSPRINT              . FREE BUFFER POOL\n         BR    R10                      . RETURN\n         TITLE 'VSAM INITIALIZATION PROCESSING'\nCHKVSAM  EQU   *\n*        1.    CHECK VSAM ORGANIZATION FOR KSDS - ONLY KSDS PROCESSED\n*        2.    DETERMINE IF SPANNED RECORDS PERMITTED - ONLY LOGICAL\n*              PROCESSING OF SPANNED OBJECTS\n*        3.    IF LOGICAL PROCESSING\n*              A.    DETERMINE INDEX COMPONENT CI SIZE\n*              B.    DETERMINE END OF INDEX RECORD\n*        4.    DETERMINE DATA COMPONENT CI SIZE\n*        5.    ACCESS ACB AND AMBL\n*        6.    IF LOGICAL PROCESSING\n*              A.    ACCESS INDEX AMB AND AMDSB\n*              B.    STORE SEQUENCE SET RBA\n*        7.    ACCESS DATA AMB AND AMDSB\n*        8.    DETERMINE VARIOUS DATA ELEMENTS\n*        9.    COMPUTE CA SIZE IN BYTES\n*        10.   IF NOT LOGICAL PROCESSING\n*              A.    MODIFY RPL TO SEQUENTIAL\n*\n*        REGISTER USAGE\n*        1     MACROS\n*        2     WORK\n*        3     WORK\n*        4     WORK\n*        5     WORK\n*        10    BRANCH AND SAVE RETURN ADDRESS\nE0001    EQU   *\n         TESTCB ACB=VSAM,               . Q. KSDS INPUT                C\n               ATRB=KSDS\n         BNE   E0005                    . A. NO\n         TESTCB ACB=VSAM,               . Q. SPANNED RECORDS PERMITTED?C\n               ATRB=SPAN\n         BNE   E0002                    . A. NO - CONTINUE\n         MVI   LOGICAL,ON               . A. YES - FORCE LOGICAL\nE0002    EQU   *\n         CLI   LOGICAL,ON               . Q. LOGICAL PROCESS?\n         BNE   E0003                    . A. NO\n         SHOWCB ACB=VSAM,               . DETERMINE CI SIZE FOR INDEX  C\n               AREA=CISZ,                                              C\n               FIELDS=CINV,                                            C\n               LENGTH=4,                                               C\n               OBJECT=INDEX\n         L     R2,CISZ                  . 2 - INDEX CI SIZE\n         SH    R2,=H'+7'                . SUBTRACT SEVEN (CIDF + RDF)\n         STH   R2,IXRDFDSP              . SAVE INDEX RDF DISPLACEMENT\nE0003    EQU   *\n         SHOWCB ACB=VSAM,                                              C\n               AREA=CISZ,                                              C\n               FIELDS=CINV,                                            C\n               LENGTH=4\n         L     R2,CISZ                  . 2 - CONTROL INTERVAL SIZE\n         CVD   R2,WORKD                 . CONVERT TO DECIMAL\n         MVC   TCISZ,MASK5              . OUTPUT CI SIZE\n         ED    TCISZ,WORKD+5\n*                                       . DETERMINE CIDF OFFSET\n         SH    R2,=H'4'                 . SUBTRACT FOUR FROM CI SIZE\n         ST    R2,CIDFDISP              . SAVE CIDF DISPLACEMENT\n*                                       . GET THE OTHER CATALOG MAIN-\n*                                       . TAINED DATA FROM THE ACCESS\n*                                       . METHOD DATA SET STATISTICS\n*                                       . BLOCK.\n         LA    R2,VSAM                  . 2 -> ACB\n         USING IFGACB,R2                . ADDRESSABILITY TO ACB DSECT\n         L     R3,ACBAMBL               . 2 -> AMBL\n         DROP  R2\n         USING IDAAMBL,R3               . ADDRESSABILITY TO AMBL DSECT\n         CLI   LOGICAL,ON               . Q. LOGICAL PROCESS?\n         BNE   E0004                    . A. NO\n         L     R2,AMBLIX                . 2 -> AMB FOR INDEX COMPONENT\n         USING IDAAMB,R2                . ADDRESSABILITY TO AMB DSECT\n         L     R2,AMBDSB                . 2 -> AMDSB FOR INDEX\n         DROP  R2\n         USING IDAAMDSB,R2              . ADDRESSABILITY TO AMDSB\n         MVC   SSRBA,AMDSSRBA           . SAVE SEQUENCE SET RBA\n         DROP  R2\nE0004    EQU   *\n         L     R3,AMBLDTA               . 3 -> AMB FOR DATA COMPONENT\n         DROP  R3\n         USING IDAAMB,R3                . ADDRESSABILITY TO AMB DSECT\n         L     R3,AMBDSB                . 3 -> AMDSB\n         DROP  R3\n         USING IDAAMDSB,R3              . ADDRESSABILITY TO AMDSB\n         LH    R2,AMDCIPCA              . CIS PER CA\n         CVD   R2,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   TCICA,MASK3\n         ED    TCICA,WORKD+6\n         LH    R2,AMDFSCA               . FREE CIS PER CA\n         CVD   R2,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   TCAFSPC,MASK3\n         ED    TCAFSPC,WORKD+6\n         L     R2,AMDFSCI               . FREE BYTES PER CI\n         CVD   R2,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   TCIFSPC,MASK5\n         ED    TCIFSPC,WORKD+5\n         SLR   R2,R2                    . 2 - ZERO\n         LA    R4,127                   . 4 - ONE HUNDRED TWENTY SEVEN\n         IC    R2,AMDPCTCA              . FREE SPACE % - CA\n         NR    R2,R4                    . MAKE POSITIVE\n         CVD   R2,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   TCAPERC,MASK3\n         ED    TCAPERC,WORKD+6\n         IC    R2,AMDPCTCI              . FREE SPACE % - CI\n         NR    R2,R4                    . MAKE POSITIVE\n         CVD   R2,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   TCIPERC,MASK3\n         ED    TCIPERC,WORKD+6\n         LH    R5,AMDCIPCA              . COMPUTE CA SIZE IN BYTES\n         DROP  R3\n         M     R4,CISZ                  . 5 - CA SIZE\n         ST    R5,CASZ                  . SAVE CA SIZE IN BYTES\n         CLI   LOGICAL,ON               . Q. LOGICAL PROCESS?\n         BER   R10                      . A. YES - RETURN\n         MODCB RPL=GETRPL,              . MODIFY RPL FOR SEQUENTIAL    C\n               OPTCD=SEQ\n         BR    R10                      . RETURN\n         TITLE 'VSAM INITAILIZATION PROCESSING FAILURES'\nE0005    EQU   *                        . NON KSDS INPUT\n         WTO   'ONLY KSDS PROCESSED BY THIS PROGRAM',                  C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> CURRENT SAVE AREA\n         L     R13,4(,R13)              . 13 -> PREVIOUS SAVE AREA\n         FREEMAIN R,                    . FREE SAVE AREA STORAGE       C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,20                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 THROUGH 12\n         BR    R14\n         TITLE 'DATA COMPONENT CI PROCESSING'\nDATAPROC EQU   *\n*        1.    DETERMINE THE RBA OF THE DATA COMPONENT CI\n*        2.    COMPUTE THE CA AND CI NUMBER OF THE CI\n*        3.    ACCESS THE CIDF\n*        4.    DETERMINE THE FREE SPACE VALUE\n*        5.    PROCESS RDFS IF ANY RECORDS IN CI\n*              A.    CHECK FOR AND PROCESS SPANNED RECORD\n*              B.    CHECK FOR AND PROCESS EQUI-LENGTH RECORDS\n*              C.    CHECK FOR AND PROCESS NON-EQUI-LENGTH RECORD(S)\n*        6.    FORMAT CI DATA\n*        7.    INCREMENT OBJECT TOTALS\n*        8.    CHECK FOR FULL PRINT LINE\n*              IF FULL, CHECK IF PAGE HEADINGS REQUIRED\n*        REGISTER USAGE\n*        1     MACROS\n*        2     WORK\n*        3     WORK\n*        4     CURRENT POSITION WITHIN DATA COMPONENT CI\n*        5     ADDRESS OF DATA COMPONENT CI\n*        6     ADDRESS OF BEGINNING OF FREE SPACE IN CI\n*        10    BRANCH AND SAVE RETURN ADDRESS\n*        14    MACROS - RETURN ADDRESS\n*        15    MACROS - ENTRY POINT ADDRESS\nF0001    EQU   *\n         ST    R10,FSAVE                . SAVE 10\n         SHOWCB RPL=GETRPL,             . DETERMINE RBA OF CI          C\n               AREA=CIRBA,                                             C\n               FIELDS=RBA,                                             C\n               LENGTH=4\n         SLR   R2,R2                    . 2 - ZERO\n         L     R3,CIRBA                 . 3 - RBA OF CI\n         D     R2,CASZ                  . DETERMINE CA NUMBER\n         LA    R3,1(,R3)                . INCREMENT CA NUMBER BY ONE\n         CVD   R3,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   CANUM,MASK5\n         ED    CANUM,WORKD+5\n         SRDA  R2,32(R0)                . 3 - CI DISPLACEMENT IN CA\n         D     R2,CISZ                  . DETERMINE CI NUMBER\n         LA    R3,1(,R3)                . INCREMENT CI NUMBER BY ONE\n         CVD   R3,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   CINUM,MASK5\n         ED    CINUM,WORKD+5\n         AP    #CIREAD,=P'+1'           . INCREMENT CIS READ\n         L     R5,@CI                   . 5 -> CI\n         L     R2,CIDFDISP              . 2 - CIDF DISPLACEMENT\n         LA    R4,0(R2,R5)              . 4 -> CIDF\n         USING CIDF,R4                  . DSECT ADDRESSABILITY\n         LH    R2,CIDFLL                . 2 - CI FREE SPACE\n         CVD   R2,WORKD                 . OUTPUT TO PRINT LINE\n         MVC   CIFSPC,MASK5\n         ED    CIFSPC,WORKD+5\n         AP    TOTFSPC,WORKD+5(3)       . INCREMENT TOTAL FREE SPACE\n         XC    #CIREC,#CIREC            . ZEROIZE CI ACCUMULATORS\n         XC    CIRECL,CIRECL\n         XC    CILREC,CILREC\n         MVC   CISREC,=H'-1'\n         LH    R2,CIDFOSET              . 2 - CI FREE SPACE OFFSET\n         DROP  R4\n         LTR   R2,R2                    . Q. CI FREE SPACE OFFSET ZERO?\n         BZ    F0007                    . A. YES - NO RECORDS OR RDFS\n         LA    R6,0(R2,R5)              . 6 -> LAST DATA BYTE IN CI\n         USING RDF,R4\nF0002    EQU   *\n         SH    R4,=H'+3'                . 4 -> RDF\n         CR    R4,R6                    . Q. LAST RDF PROCESSED?\n         BL    F0007                    . A. YES - EXIT RDF PROCESS\n         OC    RDFFLD,RDFFLD            . Q. RDF NULL?\n         BZ    F0007                    . A. YES - EXIT RDF PROCESS\n         MVC   RDFLEN,RDFBIN#           . MAKE SURE BINARY HALF-WORD\n*                                        .   IS ALIGNED\n         LH    R3,RDFLEN                . 3 - RECORD LENGTH\n         TM    RDFCF,RDFISPN            . Q. RDF FOR SPANNED RECORD?\n         BNZ   F0004                    . A. YES\n         CLC   RDFLEN,CILREC            . Q. LONGEST RECORD IN CI?\n         BNH   *+10                     . A. NO\n         MVC   CILREC,RDFLEN            . SAVE LONGEST RECORD LENGTH\n         CLC   RDFLEN,CISREC            . Q. SHORTEST RECORD IN CI?\n         BNL   *+10                     . A. NO\n         MVC   CISREC,RDFLEN            . SAVE SHORTEST RECORD LENGTH\n         TM    RDFCF,RDFPAIR            . Q. RIGHTMOST RDF OF A PAIR?\n         BZ    F0003                    . A. NO - ONE RECORD FOR RDF\n*                                       . PROCESS NON-SPANNED PAIRED\n*                                       .   RDFS\n         SH    R4,=H'+3'                . 4 -> LEFT RDF OF PAIR\n         MVC   H#REC,RDFBIN#            . NUMBER OF EQUI-LENGTH RECORDS\n         L     R2,#CIREC                . INCREMENT NUMBER OF RECORDS\n         AH    R2,H#REC                 .   IN CI\n         ST    R2,#CIREC\n         MH    R3,H#REC                 . TOTAL LENGTH OF RECORDS\n         A     R3,CIRECL                . INCREMENT NUMBER OF BYTES IN\n         ST    R3,CIRECL                .   RECORDS WITHIN CI\n         B     F0002                    . GO LOOK FOR MORE RDFS\nF0003    EQU   *                        . PROCESS NON-SPANNED, NON-\n*                                       .   PAIRED RDF\n         A     R3,CIRECL                . INCREMENT NUMBER OF BYTES IN\n         ST    R3,CIRECL                .   RECORDS WITHIN CI\n         L     R2,#CIREC                . INCREMENT NUMBER OF RECORDS\n         LA    R2,1(,R2)                .   IN CI BY ONE\n         ST    R2,#CIREC\n         B     F0002                    . GO LOOK FOR MORE RDFS\nF0004    EQU   *                        . PROCESS SPANNED RECORDS\n         TM    RDFCF,RDFLSPN            . Q. FIRST SEGMENT?\n         BO    F0005                    . A. NO - INTERMEDIATE OR LAST\n         MVI   SPAN,NOTLAST             . SET SPAN INDICATOR ON\n         XC    SPANL,SPANL              . ZEROIZE RECORD LENGTH\n         B     F0006                    . ACCUMULATE RECORD LENGTH\nF0005    EQU   *\n         TM    RDFCF,RDFISPN            . Q. INTERMEDIATE SEGMENT?\n         BO    F0006                    . A. YES - JUST ACCUMULATE\n         MVI   SPAN,LAST                . LAST SEGMENT INDICATOR\n         LA    R2,1                     . 2 - ONE\n         ST    R2,#CIREC                . ONE RECORD IN THIS CI\nF0006    EQU   *                        . ALL SPANNED SEGMENTS ARE\n*                                       .   ACCUMULATED HERE\n         L     R2,CIRECL\n         MVC   RDFLEN,RDFBIN#\n         AH    R2,RDFLEN                . INCREMENT BY SEGMENT LENGTH\n         ST    R2,CIRECL\n         L     R2,SPANL                 . SUM ALL SEGMENTS\n         AH    R2,RDFLEN\n         ST    R2,SPANL\n         MVC   CILREC,SPANL+2\n         MVC   CISREC,SPANL+2\n*                                       . IGNORE THE OTHER RDF FOR\n*                                       .   SPANNED RECORDS\nF0007    EQU   *                        . ALL RDFS PROCESSED\n         DROP  R4\n         L     R2,#CIREC                . OUTPUT RECORDS IN CI\n         CVD   R2,WORKD\n         MVC   CIRECS,MASK5\n         ED    CIRECS,WORKD+5\n         A     R2,TOTREC                . INCREMENT TOTAL RECORDS FOR\n         ST    R2,TOTREC                .   OBJECT\n         L     R2,CIRECL                . INCREMENT TOTAL BYTES USED\n         A     R2,TOTBYTES              .   BY RECORDS IN OBJECT\n         ST    R2,TOTBYTES\n         CLC   CILREC,LONGREC           . Q. LONGEST RECORD SO FAR?\n         BNH   *+10                     . A. NO\n         MVC   LONGREC,CILREC\n         CLI   SPAN,NOTLAST             . Q. FIRST OR INTERMEDIATE\n*                                       .   SEGMENT?\n         BE    F0008                    . A. YES\n         CLC   CISREC,SHORTREC          . Q. SHORTEST RECORD SO FAR?\n         BNL   *+10                     . A. NO\n         MVC   SHORTREC,CISREC\n*                                       . COMPUTE AVERAGE RECORD LENGTH\n*                                       . WITHIN THIS CI\n         CLI   SPAN,LAST                . Q. LAST SEGMENT OF SPANNED\n*                                       .   RECORD?\n         BE    F0009                    . A. YES\n         MVC   AVGREC,=6C' '            . INITIALIZE OUTPUT AREA\n         MVC   MAXREC,=6C' '\n         MVC   MINREC,=6C' '\n         L     R3,#CIREC                . 3 - NUMBER OF RECORDS\n         LTR   R3,R3                    . Q. ZERO RECORDS IN CI?\n         BZ    F0010                    . A. YES\n         SLR   R2,R2                    . 2 - ZERO\n         L     R3,CIRECL                . 3 - TOTAL BYTES USED\n         D     R2,#CIREC                . GET AVERAGE\n         CVD   R3,WORKD                 . CONVERT TO DECIMAL\n         MVC   AVGREC,MASK5             . OUTPUT TO REPORT LINE\n         ED    AVGREC,WORKD+5\n         LH    R2,CILREC                . LONGEST RECORD IN CI\n         CVD   R2,WORKD\n         MVC   MAXREC,MASK5\n         ED    MAXREC,WORKD+5\n         LH    R2,CISREC                . SHORTEST RECORD IN CI\n         CVD   R2,WORKD\n         MVC   MINREC,MASK5\n         ED    MINREC,WORKD+5\n         B     F0010                    . CHECK FOR OUTPUT\nF0008    EQU   *                        . NOT LAST SEGMENT OF SPANNED\n         MVC   AVGREC,=C' SPANS'        . OUTPUT SPANNED LITERAL\n         MVC   MAXREC,=6C' '\n         MVC   MINREC,=6C' '\n         B     F0010                    . CHECK FOR OUTPUT\nF0009    EQU   *                        . LAST SEGMENT OF SPANNED\n         L     R2,SPANL                 . OUTPUT LENGTH OF SPANNED\n         CVD   R2,WORKD                 .   RECORD\n         MVC   AVGREC,MASK5\n         ED    AVGREC,WORKD+5\n         MVC   MAXREC,AVGREC\n         MVC   MINREC,AVGREC\n         MVI   SPAN,OFF                 . RESET SPANNED INDICATOR\nF0010    EQU   *\n         CP    #LINE,=P'+57'            . Q. HEADINGS REQUIRED?\n         BL    F0011                    . A. NO\n         BAS   R10,HEADING\n         MVI   LEFT,ON                  . SET LEFT HAND SIDE ON\nF0011    EQU   *\n         CLI   LEFT,ON                  . Q. LEFT HAND SIDE ON?\n         BNE   F0012                    . A. NO - RIGHT\n         MVC   LINEA(66),LINE1          . OUTPUT LEFT-HAND SIDE OF\n         MVI   LEFT,C'0'                .   REPORT LINE AND SWITCH\n         B     F0013                    . EXIT\nF0012    EQU   *\n         MVC   LINEA+66(66),LINE1       . OUTPUT RIGHT-HAND SIDE OF\n         PUT   SYSPRINT,                .   REPORT AND PRINT IT        C\n               LINEA\n         AP    #LINE,=P'+1'             . INCREMENT LINES OUTPUT\n         MVI   LINEA,C' '               . RE-INITIALIZE OUTPUT LINE\n         MVC   LINEA+1(132),LINEA\n         MVI   LEFT,ON                  . SET LEFT-HAND SIDE ON\nF0013    EQU   *\n         L     R10,FSAVE                . RESTORE 10\n         BR    R10                      . RETURN\n         TITLE 'REPORT PAGE HEADING ROUTINE'\nHEADING  EQU   *\n*        1.    OUTPUT REPORT HEADINGS\n*        2.    INCREMENT PAGE NUMBER\n*        3.    RESET LINE ACCUMULATOR\n*        REGISTER USAGE\n*        1     MACROS\n*        10    BRANCH AND SAVE RETURN ADDRESS\n*        14    MACROS - RETURN ADDRESS\n*        15    MACROS - ENTRY POINT ADDRESS\nG0001    EQU   *\n         MVC   PAGEOUT,MASK5            . OUTPUT PAGE NUMBER\n         ED    PAGEOUT,#PAGE\n         PUT   SYSPRINT,                . OUTPUT HEADING LINE          C\n               TITLE\n         PUT   SYSPRINT,                . OUTPUT SUB-HEADING LINES     C\n               STITLE1\n         PUT   SYSPRINT,                                               C\n               STITLE2\n         PUT   SYSPRINT,                                               C\n               STITLE3\n         PUT   SYSPRINT,                                               C\n               STITLE4\n         AP    #PAGE,=P'+1'             . INCREMENT PAGE NUMBER\n         ZAP   #LINE,=P'+7'             . RESET LINE COUNTER\n         BR    R10                      . RETURN\n         TITLE 'DATA AREAS'\nWORKD    DS    D                        . DOUBLE WORD CVD WORK AREA\n#CIREC   DS    F                        . NUMBER OF RECORDS IN CI\n@CI      DS    F                        . ADDRESS OF DATA CI\n@IXCI    DS    F                        . ADDRESS OF INDEX CI\nBSAVE    DS    F                        . REGISTER SAVE AREA\nCARBA    DS    F                        . RBA OF DATA CA\nCASZ     DS    F                        . CA SIZE IN BYTES\nCIDFDISP DS    F                        . DISPLACEMENT OF CIDF\nCIRBA    DS    F                        . RBA OF DATA CI\nCIRECL   DS    F                        . LENGTH OF CURRENT RECORD\nCISZ     DS    F                        . DATA CI SIZE\nCSAVE    DS    F                        . REGISTER SAVE AREA\nFSAVE    DS    F                        . REGISTER SAVE AREA\nIXRBA    DS    F                        . RBA OF INDEX RECORD\nPTLS     DS    F                        . SEQ SET VERTICAL PTR LENGTH\nPTRBA    DS    F                        . RBA OF DATA CI FOR DIRECT\nSPANL    DS    F                        . LENGTH ACCUMULATOR FOR SPAN\nSSRBA    DS    F                        . SEQUENCE SET RECORD RBA\nTOTBYTES DS    F                        . TOTAL BYTES IN RECORDS\nTOTREC   DS    F                        . TOTAL RECORDS IN OBJECT\nVSAMERR  DS    0F                       . VSAM ERROR FIELDS\nREG15    DS    F\nOPENERR  DS    F\nRPLFDBK  DS    F\nCILREC   DS    H                        . LONGEST RECORD IN CI\nCISREC   DS    H                        . SHORTEST RECORD IN CI\nH#REC    DS    H                        . NUMBER OF EQUI-LENGTH RECORDS\nIXRDFDSP DS    H                        . INDEX RECORD RDF DISPLACEMENT\nLONGREC  DS    H                        . LONGEST RECORD LENGTH\nRDFLEN   DS    H                        . RECORD LENGTH FROM RDF\nSHORTREC DS    H                        . SHORTEST RECORD LENGTH\nTOTFSPC  DS    PL9                      . TOTAL FREE SPACE\n#CIREAD  DS    PL5                      . NUMBER OF CIS READ\n#LINE    DS    PL2                      . NUMBER OF LINES ON PAGE\n#PAGE    DS    PL3                      . NUMBER OF PAGE\nLEFT     DS    CL1                      . LEFT / RIGHT SWITCH\nON       EQU   X'01'                    . LOGICAL ON\nOFF      EQU   X'00'                    . LOGICAL OFF\nLOGICAL  DS    CL1                      . EXECUTION TIME PARAMETER\nSPAN     DS    CL1                      . SPANNED RECORD SWITCH\nLAST     EQU   X'02'                    . LAST SEGMENT VALUE\nNOTLAST  EQU   X'01'                    . FIRST OR INTERMEDIATE VALUE\n*                                       . EDIT MASKS\nMASK3    DC    X'40202120'\nMASK5    DC    X'402020202120'\nMASK9    DC    X'40202020202020202120'\n*                                       . VERTICAL PTR TRANSLATE TABLE\nPLTBL    DC    X'0001000200000003'\n*                                       . PRINT LINES\nTITLE    DC    CL15'1'\n         DC    CL49'ANALYSIS OF DATA COMPONENT CONTROL INTERVALS FOR '\nTDSN     DC    CL44' '\n         DC    CL15' '\n         DC    CL4'PAGE'\nPAGEOUT  DS    CL6\nSTITLE1  DC    CL25'0 CONTROL INTERVAL SIZE: '\nTCISZ    DS    CL6\n         DC    CL31'  FREE BYTES REQUESTED PER CI: '\nTCIFSPC  DS    CL6\n         DC    CL1' '\n         DC    CL24'  NUMBER OF CIS PER CA: '\nTCICA    DS    CL4\n         DC    CL29'  FREE CIS REQUESTED PER CA: '\n         DC    CL3' '\nTCAFSPC  DS    CL4\nSTITLE2  DC    CL31' '\n         DC    CL33'  FREE SPACE PERCENTAGE PER CI:  '\nTCIPERC  DS    CL4\n         DC    CL29' '\n         DC    CL32'  FREE SPACE PERCENTAGE PER CA: '\nTCAPERC  DS    CL4\nSTITLE3  DC    CL66'0                                                REC\n               CORD LENGTH    '\n         DC    CL67'                                                 REC\n               CORD LENGTH     '\nSTITLE4  DC    CL66'     CA #  CI #   FREE SPACE   # OF RECORDS    AVG C\n                  MAX    MIN  '\n         DC    CL67'     CA #  CI #   FREE SPACE   # OF RECORDS    AVG C\n                  MAX    MIN   '\nLINEA    DS    CL133\nLINEB    DC    CL40'0'\n         DC    CL26'TOTALS FOR OBJECT'\nLINEBD   DC    CL67' '\nLINE1    DC    CL3' '\nCANUM    DS    CL6\nCINUM    DS    CL6\n         DC    CL7' '\nCIFSPC   DS    CL6\n         DC    CL9' '\nCIRECS   DS    CL6\n         DC    CL1' '\nAVGREC   DS    CL6\n         DC    CL1' '\nMAXREC   DS    CL6\n         DC    CL1' '\nMINREC   DS    CL6\n         DC    CL2' '\nLINE2    DC    CL5' '\nCINUM2   DS    CL10\n         DC    CL3' '\nCIFSPC2  DS    CL10\n         DC    CL5' '\nCIRECS2  DS    CL10\n         DC    CL1' '\nAVGREC2  DS    CL6\n         DC    CL1' '\nMAXREC2  DS    CL6\n         DC    CL1' '\nMINREC2  DS    CL6\n         DC    CL3' '\n         DS    0F                       . FULL WORD ALIGNMENT\nIXHFORM  DS    0CL24                    . INDEX HEADER FORMAT\n         DS    CL3\nIXHPTLS  DS    CL1                      . VERTICAL PTR LENGTH\nIXHBRBA  DS    F                        . RBA OF ASSOCIATED DATA CA\nIXHHP    DS    F                        . HORIZONTAL POINTER\n         DS    CL8\nIXHLEO   DS    H                        . OFFSET OF LAST ENTRY\nIXHSEO   DS    H                        . OFFSET HIGH KEY FIRST SECTION\n         TITLE 'CONTROL BLOCKS'\nVSAM     ACB   AM=VSAM,                                                C\n               DDNAME=VSAM,                                            C\n               EXLST=EXITLIST,                                         C\n               MACRF=(ADR,CNV)\nEXITLIST EXLST EODAD=C0006\nGETRPL   RPL   ACB=VSAM,                                               C\n               AM=VSAM,                                                C\n               AREA=@CI,                                               C\n               AREALEN=4,                                              C\n               ARG=PTRBA,                                              C\n               OPTCD=(CNV,LOC,DIR)\nIXRPL    RPL   ACB=VSAM,                                               C\n               AM=VSAM,                                                C\n               AREA=@IXCI,                                             C\n               AREALEN=4,                                              C\n               ARG=IXRBA,                                              C\n               OPTCD=(CNV,LOC,DIR)\nSYSPRINT DCB   BLKSIZE=15428,                                          C\n               DDNAME=SYSPRINT,                                        C\n               DSORG=PS,                                               C\n               LRECL=133,                                              C\n               MACRF=PM,                                               C\n               RECFM=ABFS\nDUMMY    DCB   DDNAME=VSAM,                                            C\n               DSORG=PS,                                               C\n               EXLST=DCBEXIT,                                          C\n               MACRF=GM\n         DS    0F                       . FULL WORD ALIGN DCB EXIT\nDCBEXIT  EQU   *                        . DCB EXIT FOR JFCB\n         DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN\n         DCBD  DEVD=DA,                                                C\n               DSORG=PS\n         IFGACB\nIDAAMBL  DSECT\n         DS    XL52\nAMBLDTA  DS    F\nAMBLIX   DS    F\nIDAAMB   DSECT\n         DS    XL20\nAMBDSB   DS    F\nIDAAMDSB DSECT\n         DS    XL10\nAMDPCTCA DS    CL1\nAMDPCTCI DS    CL1\nAMDCIPCA DS    H\nAMDFSCA  DS    H\nAMDFSCI  DS    F\n         DS    XL12\nAMDSSRBA DS    F\nCIDF     DSECT\nCIDFOSET DS    H                        . FREE SPACE OFFSET\n*                                       . OR LEFT-MOST RDF OFFSET\nCIDFLL   DS    H                        . LENGTH OF FREE SPACE\nRDF      DSECT\nRDFFLD   DS    0CL3\nRDFCF    DS    C\nRDFPAIR  EQU   X'40'                    . RDF PART OF PAIR\nRDFFSPN  EQU   X'10'                    . FIRST SEGMENT - SPANNED\nRDFLSPN  EQU   X'20'                    . LAST SEGMENT - SPANNED\nRDFISPN  EQU   X'30'                    . INTERMEDIATE SEGMENT\nRDFNUMB  EQU   X'08'                    . BINARY NUMBER IS\n*                                       .   NUMBER OF EQUI-LENGTH REC\n*                                       .   OR UPDATE NO. OF SEGMENT\nRDFNORC  EQU   X'04'                    . RRDS - EMPTY SLOT\nRDFBIN#  DS    CL2                      . BINARY NUMBER\n         TITLE 'LITERALS AND TERMINATION'\nVSAMDST  CSECT                          . RE-ESTABLISH CSECT\n         LTORG\n         END\n\n\nDave Loveluck\nInstructor/Consultant (USA)                              c Dave Loveluck 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A005A04": {"ttr": 6408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x02\\x0e\\x02\\x0e\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 526, "newlines": 526, "modlines": 0, "user": "VSAMUPD"}, "text": "Displaying the status of CICS VSAM files\n\nThe following two CICS programs display the status of CICS\nVSAM files which use local shared resources. A common\ncause of poor response time or the reason why some\ntransactions appear to be 'hanging' is that they are waiting for a\nVSAM buffer or string. These programs enable the user to\ndisplay on-line the status of VSAM files, ie if they are waiting\nfor a buffer or string, how many strings are currently active for\neach file, the highest number of strings that were active, the\nnumber of times the file had to wait for a string or buffer, plus\nrelevant VSAM catalog information, CI/CA splits, extents,\nEXCPs, and DSORGs.\n\nThe programs are written in Assembler and invoked by a\ntransaction called QLSR. The program ITAS is called by\nQLSR to display active tasks.\n\n\nQLSR\n\nDFHEISTG DSECT ,\n* QLSR IS AN ON-LINE CICS TRANSACTION WHICH MAY BE USED TO DISPLAY\n* THE STATUS OF CICS VSAM FILES USING VSAM LOCAL SHARED RESOURCES\n* FOR TUNING AND PROBLEM DETERMINATION PURPOSES.\n* THE TRANSACTION DISPLAYS THE FOLLOWING INFORMATION FOR EACH FILE:\n* - IF THE FILE IS WAITING FOR A BUFFER, AND IF SO, HOW MANY\n* - THE HIGHEST NUMBER OF BUFFERS FOR WHICH THE FILE HAD TO WAIT\n* - THE NUMBER OF TIMES THE FILE WAITED FOR A BUFFER\n* - THE NUMBER OF STRINGS WHICH ARE CURRENTLY ACTIVE FOR THE FILE\n* - THE HIGHEST NUMBER OF STRINGS FOR WHICH THE FILE HAD TO WAIT\n* - THE NUMBER OF TIMES THE FILE WAITED FOR A STRING\n* - THE NUMBER OF STRINGS ALLOCATED TO THE FILE (STRNO= IN FCT)\n* - THE DATASET ORGANIZATION\n* - THE NUMBER OF I/O'S PERFORMED AGAINST THE FILE\n* - THE CONTROL INTERVAL SIZE\n* - THE NUMBER OF CI SPLITS, CA SPLITS AND EXTENTS (ON REQUEST)\n*\n* THE TRANSACTION IS ISSUED IN ONE OF THE FOLLOWING WAYS.\n* QLSR          : THE STATUS OF ALL CURRENTLY OPEN FILES IS DISPLAYED\n* QLSR *        : THE STATUS OF ALL VSAM FILES DEFINED IN THE FCT\n* QLSR EXCP     : ALL FILES WHICH HAVE ENCOUNTERED A WAIT-ON-BUFFER OR\n*               : A WAIT-ON-STRING CONDITION\n* QLSR ACTV     : ALL FILES WHICH CURRENTLY HAVE AN ACTIVE STRING, AND\n*               : A LIST OF ACTIVE TRANSACTIONS.\n* QLSR FILENAME : THE STATUS OF THE FILE 'FILENAME'\n* IF ',S' IS SPECIFIED AFTER THE TRANSACTION NAME OR ANY OF THE\n* OPERANDS THEN THE NUMBER OF CI/CA SPLITS AND EXTENTS IS DISPLAYED IN\n* PLACE OF THE BUFFER STATUS.\n*\n* PF AND CONTROL KEYS:\n* CLEAR      : EXIT THE TRANSACTION\n* ENTER      : DISPLAYS THE NEXT SCREEN OF DATA, IF ANY\n* PF12       : REFRESH CURRENT DISPLAY\n* PF10       : WHEN IN THE 'ACTV' DISPLAY, PF10 INVOKES THE CICS CEMT\n*            : TRANSACTION WITH THE 'I TAS' OPERAND. FROM HERE YOU MAY\n*            : PURGE A TRANSACTION YOU SUSPECT MAY BE CAUSING A PROBLEM\n*\n* NOTE : THIS TRANSACTION SHOULD HAVE A CICS SECURITY KEY EQUAL TO\n*        THAT OF THE CICS CEMT TRANSACTION, BECAUSE WHEN PF10 IS\n*        PRESSED WE LINK DIRECTLY TO THE CEMT PROGRAM, DFHEMTA, AND\n*        SO BYPASS TRANSACTION SECURITY KEY CHECKING.\n         DFHEISTG ,                     COPY CICS BOOKS\n         PRINT NOGEN,OFF\n         COPY  DFHCSADS                 CSA\n         COPY  DFHFCTDS                 FCT\n         COPY  DFHTCADS                 TCA\n         COPY  DFHTCTTE                 TCTTE\n         COPY  DFHTIOA                  TIO AREA\n         PRINT ON\nTRANSID  DS    CL4                      MAP SCREEN\nFILLER   DS    CL1\nDATASID  DS    CL7\n         DS    CL1\nSTATUSOP DS    CL1\nTCTTEAR  EQU   10                       TCT BASE REG\nTIOABAR  EQU   9                        TIO BASE REG\nFCTDSBAR EQU   5                        FCT BASE REG\nQLSR     CSECT ,\n         PRINT NOGEN\n         L     TCTTEAR,TCAFCAAA        ADDRESSABILITY\n         L     TIOABAR,TCTTEDA\n         MVC   DSIDSAVE(7),=CL7' '     CLEAR INTERNAL STORAGE AREAS\n         MVC   STATSOPT(1),=CL1' '\n         MVI   SWITCH,X'00'\n         LA    4,9                     MAX LENGTH OF OPERANDS\n         LA    5,DATASID               ADDRESS OF OPERAND\n         LA    6,DSIDSAVE              DATASET NAME HOLDING AREA\nGETDSN   CLI   0(5),C','               A COMMA ?\n         BE    GOTDSN                  YES, GOT DSN\n         CLI   0(5),X'00'              HEX 00, YES END OF INPUT\n         BE    GOTDSN\n         MVC   0(1,6),0(5)             NO, MOVE IN 1 CHAR\n         LA    5,1(5)                  BUMP\n         LA    6,1(6)\n         BCT   4,GETDSN                CHECK NEXT CHAR\n         DROP  9,10                    DROP TERMINAL IO ADDRESSABILITY\nGOTDSN   CLC   0(2,5),=CL2',S'         ',S' ENTERED ?\n         BNE   *+8                     NO\n         MVI   STATSOPT,C'S'           YES, TAKE A NOTE\n         MVC   HEADT2(6),=CL6'CURWBF'  INITALIZE HEADER LINE\n         MVC   HEADT3(6),=CL6'HIGWBF'\n         MVC   HEADT4(6),=CL6'TOTWBF'\n         EXEC  CICS HANDLE CONDITION END(EXIT) DSIDERR(NOTFND)\n         EXEC  CICS HANDLE AID PF12(RESHW) PF10(CALLCEMT) CLEAR(EXIT1)\n         EXEC  CICS IGNORE CONDITION LENGERR\n         EXEC  CICS ADDRESS CSA(5) ,   GET ADDRESS OF CSA\n         ST    5,CSAADR                SAVE IT\nRESET    MVC   DSID(7),DSIDSAVE        DATA SET NAME\n         LA    9,81                    R9 = CURRENT SCREEN BUF ADDR\n         MVC   LINEO+3(7),DSID         DATASET NAME TO OUTPUT LINE\n         L     5,CSAADR                CSA ADDRESS\n         USING DFHCSADS,5              ADDRESSABILITY\n         L     5,CSAFCTBA              FCT ADDRESS\n         ST    5,FCTADDR               SAVE IT\nSENDHDR0 CLI   STATSOPT,C'S'           ',S' SPECIFIED ?\n         BNE   SENDHDR                 NO\n         MVC   HEADT2(6),=CL6'CISPLT'  YES, CHANGE HEADER LINE\n         MVC   HEADT3(6),=CL6'CASPLT'\n         MVC   HEADT4(6),=CL6'EXTENT'\nSENDHDR  EXEC  CICS SEND FROM(HEADER) LENGTH(80) ERASE\nGOTCSAA  CLI   DSID,C' '               NO DSN GIVEN ?\n         BE    STFCTBR                 YES, DISPLAY ALL OPEN VSAM FILES\n         CLC   DSID(4),=CL4'EXCP'      EXCEPTIONS ONLY ?\n         BE    SETEXCPT                YES\n         CLC   DSID(4),=CL4'ACTV'      ACTIVE FILES ONLY ?\n         BE    SETACTV                 YES\n         CLI   DSID,C'*'               ALL FILES ?\n         BNE   GETFCTE                 NO, SCAN FCT FOR A GIVEN FILEID\n         OI    SWITCH,ALLFILES         YES, TAKE A NOTE\n         B     STFCTBR                 START FCT BROWSE\nSETACTV  OI    SWITCH,ACTVSTRS         SET ACTIVE FILES ONLY\n         EXEC  CICS HANDLE AID ENTER(RESHW) , CHANGE EFFECT OF ENTER\n         B     STFCTBR                 START FCT BROWSE\nSETEXCPT OI    SWITCH,EXCEPTS          SET EXCEPTIONS ONLY FLAG\n         OI    SWITCH,ALLFILES\nSTFCTBR  EXEC  CICS INQUIRE DATASET START ,  START FCT BROWSE\n         OI    SWITCH,BROWFCT                TAKE A NOTE\nNEXTFCTE BAL   7,GETNFCT               GET NEXT FCT ENTRY\nGETFCTE  TM    SWITCH,BROWFCT          BROWSING FCT ?\n         BO    *+8                     YES, SKIP NEXT INS\n         BAL   7,GETSTRGS              GET NO. OF STRING ALLOCATED\n         L     5,FCTADDR               FCT ADDRESS\n         USING DFHFCTDS,5              ADDRESSABILITY\nGETFCT   CLC   FCTDSID(7),DSID         IS THIS THE FILENAME REQUIRED?\n         BE    GOTFCTE                 YES\nNEXTFCT  CLC   0(8,5),=XL8'FF'         END OF FCT ?\n         BE    NOTFND\n         LH    7,FCTDSTEL              LENGTH OF THIS ENTRY\n         LTR   7,7                     LENGTH = 0 ?\n         BZ    NOTFND                  YES, DSN NOT FOUND\n         AR    5,7                     NO, POINT TO NEXT ENTRY\n         B     GETFCT                  GO CHECK IT\nGOTFCTE  LH    4,FCTDSCBW              NO. BUFFERS FILE IS WAITING FOR\n         ST    4,CURWBUF\n         LH    4,FCTDSHBW              HIGH NO. OF BUFFER WAITS\n         ST    4,HIGWBUF\n         L     4,FCTDSTBW              TOTAL NO. OF BUFFER WAITS\n         ST    4,TOTWBUF\n         L     4,FCTDSSRC              CI SIZE\n         ST    4,CISIZE\n         LH    4,FCTDSASC              ACTIVE STRING COUNT\n         ST    4,ACTVSTR\n         L     4,FCTDSTSW              COUNT OF WAIT ON STRING COND.\n         ST    4,TOTWSTR\n         LH    4,FCTDSHSW              HIGHEST COUNT OF WAIT ON STRING\n         ST    4,HIGWSTR\n         LA    5,FCTDSACB              ADDRESS OF VSAM ACB\n         ST    5,ACBADR\n         MVC   EXCPS(4),=F'0'          CLEAR EXCP WORK FIELD\n         ST    13,SAVE13               SAVE R13\n         LA    13,SAVEAREA             SAVE AREA FOR MACRO\n         SHOWCB ACB=(5),FIELDS=(NEXCP),  GET EXCP COUNT                C\n               LENGTH=4,AREA=EXCPS\n         TESTCB ACB=(5),OPENOBJ=PATH   IS FILE A PATH ENTRY ?\n         L     13,SAVE13               RESTORE R13\n         BE    NOCHECK                 YES, NO CI/CA STATS FOR A PATH\n         ST    13,SAVE13               SAVE R13\n         LA    13,SAVEAREA             SAVE AREA FOR MACRO\n         SHOWCB ACB=(5),FIELDS=(NEXCP,NCIS,NSSS,NEXT),                 C\n               LENGTH=16,AREA=EXCPS\n         L     13,SAVE13               RESTORE R13\n         TM    SWITCH,BROWFCT          BROWSING FCT ?\n         BO    NOCHECK                 YES, IGNORE RC (DATASET CLOSED)\n         LTR   15,15                   NO, DID SHOW WORK ?\n         BNZ   SHOWERR                 NO - ERROR\nNOCHECK  TM    SWITCH,EXCEPTS          EXCP OPERAND GIVEN ?\n         BNO   CHKIFACT                NO\n         CLC   CURWBUF(12),=XL12'00'   YES, ALL BUFFERS STATS 0 ?\n         BNE   CONVDATA                NO BUFFER EXCEPTION OCCURRED\n         CLC   HIGWSTR(8),=XL12'00'    ALL STRING STATS 0\n         BE    NEXTFCTE                YES, NO EXECPTIONS FOR THIS FILE\n         B     CONVDATA                NO, DISPLAY THIS FILE\nCHKIFACT TM    SWITCH,ACTVSTRS         ACTV OPERAND GIVEN ?\n         BNO   CONVDATA                NO, SHOW THIS FILE\n         CLC   ACTVSTR(4),=XL12'00'    YES, IS THE ACTIVE STRING CNT 0?\n         BE    NEXTFCTE                YES, IGNORE\nCONVDATA CLI   STATSOPT,C'S'           ',S' OPTION GIVEN ?\n         BNE   NOSTATS\n         MVC   CURWBUF(4),CISPLIT      YES, INSERT VALUES\n         MVC   HIGWBUF(4),CASPLIT\n         MVC   TOTWBUF(4),EXTENTS\n         MVI   CISPLIT,X'80'           CLEAR TO MINUS VALUE\n         MVC   CISPLIT+1(11),CISPLIT\n         MVC   HEADT2(6),=CL6'CISPLT'  CHANGE HEADER LINE\n         MVC   HEADT3(6),=CL6'CASPLT'\n         MVC   HEADT4(6),=CL6'EXTENT'\n*        CHANGE 7 WORDS TO PRINTABLE AND INSERT IN DISPLAY LINE\nNOSTATS  LA    4,7                     NO. OF WORDS TO CONVERT\n         LA    5,CURWBUF               FIRST WORD\n         LA    6,LINEO+10              ADDRESS IN OUTPUT LINE\nCONV     L     7,0(5)                  CONVERT TO PRINTABLE\n         LTR   7,7                     IS VALUE NEGATIVE ?\n         BM    NOTAPPL                 WHEN YES THEN WAS NOT SET\n         CVD   7,DWORD                 NO, CONVERT TO PRINTABLE\n         ED    MASK(10),DWORD+3\n         MVC   0(5,6),MASK+5           MOVE TO OUTPUT LINE\n         MVC   MASK(11),MASKS          RESTORE EDIT MASK\nBUMP     LA    5,4(5)                  NEXT WORD\n         LA    6,7(6)                  BUMP ADDRESS IN OUTPUT LINE\n         BCT   4,CONV                  DO IT 7 TIMES\n         B     SETDAORG\nNOTAPPL  MVC   0(5,6),=CL5'  N/A'      VALUE NOT SET (PATH OR CLOSED)\n         MVC   0(4,5),=XL4'00'         RE-INIT VALUE\n         B     BUMP\nSETDAORG MVC   2(4,6),DAORG            MOVE IN DATASET ORG\n         LA    6,7(6)                  BUMP\n         L     7,EXCPS                 NO. OF I/O'S\n         CLC   OSTAT,DFHVALUE(OPEN)    IS THE FILE OPEN ?\n         BE    CONVEXCP                YES\n         MVC   1(7,6),=CL7'CLOSED'     NO, SHOW IN DISPLAY\n         B     CONVCISZ\nCONVEXCP CVD   7,DWORD                 CONVERT EXCP COUNT TO PRINTABLE\n         ED    MASK(10),DWORD+3\n         MVC   0(7,6),MASK+3\n         MVC   MASK(11),MASKS\nCONVCISZ LA    6,7(6)                  CONVERT CISIZE TO PRINTABLE\n         L     7,CISIZE\n         CVD   7,DWORD\n         ED    MASK(10),DWORD+3\n         MVC   0(6,6),MASK+4\n         MVC   MASK(11),MASKS\n         MVC   LINEO+3(7),DSID         INSERT DATASET ID\n         CH    9,=H'1863'              SCREEN FULL ?\n         BL    SENDLINE                NO\n         MVC   L20(2),=H'20'           YES, WAIT FOR ENTER KEY\n         EXEC  CICS RECEIVE INTO(RBUF) LENGTH(L20)\n         EXEC  CICS SEND FROM(HEADER) LENGTH(80) ERASE\n         LA    9,81                    RESET BUFFER POS POINTER\nSENDLINE BAL   7,SETSBA                SET 3270 BUFFER ADDR CODE\n         EXEC  CICS SEND FROM(LINEO) LENGTH(80) CTLCHAR(WCC)\n         MVI   LINEO+3,C' '            CLEAR LINE\n         MVC   LINEO+4(75),LINEO+3\n         TM    SWITCH,BROWFCT          BROWSING FCT ?\n         BO    NEXTFCTE                YES, GET NEXT ENTRY\nEXIT     MVI   LINEO+1,C' '\n         MVC   LINEO+2(L'LINEO-2),LINEO+1\n         BAL   7,SETSBA\n         MVC   LINEO+3(10),ENDOFDAT\n         EXEC  CICS SEND FROM(LINEO) LENGTH(80) CTLCHAR(WCC)\n         TM    SWITCH,ACTVSTRS         DISPLAY ACIVE FILES ONLY ?\n         BNO   EXIT0                   NO, EXIT\n         LA    9,80(9)                 YES, BUMP SCREEN BUFFER ADDRESS\n         ST    9,STRTLINE              SAVE IN COMAREA\n* CALL PROGRAM ITAS TO DISPLAY ACTIVE TASKS\n         EXEC  CICS LINK PROGRAM('ITAS') COMMAREA(STRTLINE)            C\n               LENGTH(L4)\nEXIT0    EXEC  CICS RECEIVE INTO(RBUF) LENGTH(L20)\nEXIT1    EXEC  CICS SEND FROM(BLANKS) LENGTH(L1) ERASE\n         TM    SWITCH,BROWFCT          BROWSING FCT ?\n         BNO   LEAVE                   NO\n         EXEC  CICS INQUIRE DATASET END , * YES ISSUE END\nLEAVE    EXEC  CICS RETURN ,              * RETURN TO CICS\nGETNFCT  EXEC  CICS INQUIRE DATASET(DSID) NEXT OPENSTATUS(OSTAT)       C\n               STRINGS(STRINGS) TYPE(AM) ACCESSMETHOD(ACCMET)\n         MVC   DAORG(4),=CL4' '\n         CLC   ACCMET,DFHVALUE(VSAM)   IS THIS A VSAM DATASET ?\n         BNE   GETNFCT                 NO, IGNORE\n         CLC   OSTAT,DFHVALUE(OPEN)    IS IT OPEN ?\n         BE    GETAM                   YES, GET ACCESS METHOD\n         TM    SWITCH,ALLFILES         DISPLAY ANYWAY ?\n         BOR   7                       YES RETURN (CAN'T GET ACC METH)\n         B     GETNFCT                 NO, IGNORE\nGETAM    CLC   AM,DFHVALUE(KSDS)       KEY  SEQ DATASET ?\n         BNE   *+12                    NO\n         MVC   DAORG(4),=CL4'KSDS'\n         BR    7\n         CLC   AM,DFHVALUE(ESDS)       ENTRY SEQ DATASET ?\n         BNE   *+12\n         MVC   DAORG(4),=CL4'ESDS'\n         BR    7\n         CLC   AM,DFHVALUE(RRDS)       RELATIVE RECORD SEQ DATASET ?\n         BNE   *+12\n         MVC   DAORG(4),=CL4'RRDS'\n         BR    7\n         MVC   DAORG(4),=CL4'    '     DON'T KNOW THEN\n         BR    7\nRESHW    TM    SWITCH,BROWFCT          RESET (PF12 HAS BEEN PRESSED)\n         BNO   RESET\n         EXEC  CICS INQUIRE DATASET END\n         B     RESET\nGETSTRGS EXEC  CICS INQUIRE DATASET(DSID) STRINGS(STRINGS) TYPE(AM)    C\n               OPENSTATUS(OSTAT)\n         B     GETAM\nSETSBA   LR    6,9                     SCREEN BUFFER OFFSET\n         STC   6,ANSWER+1              CONVERT TO A 3270 SBA ORDER\n         SRL   6,6                                                      20\n         STC   6,ANSWER                                                 30\n         NI    ANSWER+1,X'3F'                                           40\n         TR    ANSWER(2),TAB                                            50\n         MVC   LINEO+1(2),ANSWER\n         LA    9,80(9)\n         BR    7                                                        80\nANSWER   DC    X'0000'                                                  20\nTAB      DC    X'40C1C2C3C4C5C6C7C8C94A4B'                              30\n         DC    X'4C4D4E4F50D1D2D3D4D5D6D7'                              40\n         DC    X'D8D95A5B5C5D5E5F6061E2E3'                              50\n         DC    X'E4E5E6E7E8E96A6B6C6D6E6F'                              60\n         DC    X'F0F1F2F3F4F5F6F7F8F97A'                                70\n         DC    X'7B7C7D7E7F'                                            80\n* LINK TO CICS CEMT TRANSACTION (PF10 KEY WAS PRESSED IN ACTV DISPLAY)\nCALLCEMT TM    SWITCH,BROWFCT          BROWSING FCT ?\n         BNO   LINKCEMT                YES, END BROWSE FIRST\n         EXEC  CICS INQUIRE DATASET END\nLINKCEMT EXEC  CICS LINK PROGRAM('DFHEMTA') COMMAREA(CEMTPARM)\n         B     RESET\nNOTFND   TM    SWITCH,BROWFCT\n         BO    EXIT\n         EXEC  CICS SEND FROM(NFND) LENGTH(80) ERASE\n         B     EXIT\nSHOWERR  EXEC  CICS SEND FROM(SERR) LENGTH(80) ERASE\n         B     EXIT\nNFND     DC    CL80'NOT FOUND'\nSERR     DC    CL80'SHOW ERROR/DATASET CLOSED'\nENDOFDAT DC    CL10'** END **'\nDWORD    DC    1D'0'                   WORK DWORD\nCURWBUF  DC    1F'0'                   CURRENT WAIT BUFFER COUNTER\nHIGWBUF  DC    1F'0'                   HIGHEST NO. OF WAIT ON BUF\nTOTWBUF  DC    1F'0'                   NO. OF WAIT ON BUFFER\nACTVSTR  DC    1F'0'                   NO. OF CURRENTLY ACTIVE STRINGS\nHIGWSTR  DC    1F'0'                   HIGHEST NO. OF CONCURRENT WAITS\nTOTWSTR  DC    1F'0'                   TOTAL NO. OF WAIT ON STRING\nSTRINGS  DC    1F'0'                   NO. STRINGS ALLOCATED\nDAORG    DC    CL4' '                  DATASET ORGANISATION\nEXCPS    DC    1F'0'                   I/O COUNT\nCISPLIT  DC    1F'0'                   NO. CI SPLITS\nCASPLIT  DC    1F'0'                   NO. CA SPLITS\nEXTENTS  DC    1F'0'                   NO. OF EXTENTS\nCISIZE   DC    1F'0'                   CI SIZE\nCSAADR   DC    1F'0'                   CSA ADDRESS\nFCTADDR  DC    1F'0'                   FCT ADDRESS\nACBADR   DC    1F'0'                   ACB ADDRESS\nOSTAT    DC    1F'0'                   OPEN STATUS\nAM       DC    1F'0'                   ACCESS METHOD\nACCMET   DC    1F'0'                      \"     \"\nSAVE13   DC    1F'0'                   SAVE AREAS\nSAVEAREA DC    18F'0'\nSTRTLINE DC    1F'0'                   COMMAREA FOR ITAS (SCRN BUF ADR)\nDSID     DC    CL8' '                  DATASET ID\nDSIDSAVE DC    CL8' '                     \"     \" HOLDER\nRBUF     DC    CL20' '                 REPLY BUFFER\nSTATSOPT DC    C' '                    OPTION INDICATOR\nL20      DC    AL2(20)                 LENGTHS\nL1       DC    AL2(1)\nL4       DC    AL2(4)\nBLANKS   DC    C' '\nWCC      DC    X'F1'                   WRITE CONTROL CHARACHER\nSWITCH   DC    X'00'\nBROWFCT  EQU   X'01'                   BROWSING FCT\nALLFILES EQU   X'02'                   DISPLAY ALL FILES\nEXCEPTS  EQU   X'04'                   EXECEPTIONS ONLY\nACTVSTRS EQU   X'08'                   ACTIVE FILES ONLY\nCEMTPARM DC    AL4(COMMADR)            COMMAREA FOR CEMT TRANS\n         DC    AL4(LCOMMAND)\n         DC    AL4(OPTBYADR)\n         DC    AL4(0)\n         DC    AL4(0)\n         DS    0H\nCOMMADR  DC    C'I TAS'                CEMT OPERAND\nLCOMMAND DC    H'5'                    OPERAND LENGTH\nOPTBYADR DC    X'80'                   RESPONSE IN BUFFER\nLINEO    DC    X'11C150',79C' '        OUTPUT LINE WITH SBA\nMASK     DC    X'4020202020202020212020',C'  '     EDIT MASKS\nMASKS    DC    X'4020202020202020212020',C'  '\nHEADER   DC    X'1DF0'\n         DC    CL80'FILENAME CURWBF HIGWBF TOTWBF ACTSTR HIGWST TOTWST C\n               STRNGS DAORG  EXCPS  CISIZE'\nHEADT2   EQU   HEADER+2+9\nHEADT3   EQU   HEADER+2+16\nHEADT4   EQU   HEADER+2+23\n         END   QLSR\n\n\nITAS\n\nDFHEISTG DSECT ,\n * THIS PROGRAM IS CALLED BY THE QLSR TRANSACTION WHEN IT IS DISPLAYING\n * THE ACTIVE FILE LIST. IT DISPLAYS A LIST OF TRANSACTIONS ON THE\n * SCREEN ALONG WITH THE ACTIVE FILE NAMES. THIS MAY HELP THE USER\n * TO DETERMINE WHICH FILES THE TRANSACTIONS ARE CURRENTLY USING.\n * THE PROGRAM CALLS THE CICS CEMT TRANSACTION WITH THE 'I TAS' OPERAND\n * AND AN OPTION BYTE IS SET SO THAT THE RESPONSE IS RETURNED TO A\n * BUFFER. THE RESPONSE IS THEN REFORMATED AND DISPLAYED.\n          PRINT NOGEN,OFF\n          DFHEISTG\n          PRINT ON\n ITAS     CSECT ,\n          PRINT NOGEN\n          L     5,DFHEICAP              ADDRESS OF COMMAREA\n          MVC   STRTLINE(4),0(5)        MOVE IN SCREEN BUFFER START ADR\n          MVC   PARMS(20),SPARMS        INITIALISE CEMT COMMAREA\n          MVC   OPTBYTE(1),=X'00'\n          MVC   COMMAND(5),=CL5'I TAS'\n          MVC   LCOMMAND(2),=H'5'\n          MVC   LREPLBUF(2),=H'2000'\n          MVC   L20(2),=H'20'           CALL CEMT\n          EXEC  CICS LINK PROGRAM('DFHEMTA') COMMAREA(PARMS) LENGTH(L20)\n          LH    6,REPLBUF+6             TOTAL LENGTH OF DATA\n          SH    6,=H'6'                 LESS 6 FOR HEADER\n          LH    4,REPLBUF+8             NO. LINES\n          LA    5,REPLBUF+12            REPLY DATA\n          L     9,STRTLINE              OFFSET ADDR ON SCREEN TO WRITE\n          MVC   LINEO+3(73),TASKHEAD    MOVE IN HEADER\n          B     SENDLINE                SEND IT\n          USING REPLDS,8                MAP OUPUT LINE\n SETUPLIN LA    8,LINEO+3               OUTPUT LINE ADDRESS\n          LA    10,3                    NO. OF TASKS PER LINE\n GETTASNR CLC   0(4,5),=CL4'TAS('       SCAN REPLY BUFF FOR 'TAS('\n          BE    GOTTASNR                GOT IT ?\n          LA    5,1(5)                  NO BUMP\n          BCT   6,GETTASNR              CONTINUE SCAN\n          B     SHOWTAS                 FORCE  REPLY BUFFER ,SHOW SCREEN\n GOTTASNR MVC   TASNRO(5),4(5)          MOVE IN TASKNO\n GETTRAN  CLC   0(4,5),=CL4'TRA('       SCAN FOR TRANS ID\n          BE    GOTTRAN\n          LA    5,1(5)\n          BCT   6,GETTRAN\n          B     SHOWTAS                 END OF REPLY BUF\n GOTTRAN  MVC   TRANO(4),4(5)           MOVE IN TRAN NAME\n          CLC   24(3,5),=CL3'TAS'       IS TASK ASSOCIATED WITH A TERM?\n          BNE   GETTERM                 YES\n          LA    5,10(5)                 NO, NO TERMINAL ID THEN\n          SH    6,=H'10'\n          B    GOTTERM\n GETTERM  CLC   0(4,5),=CL4'FAC('       SCAN FOR TERMINAL ID\n          BE    GOTTERM\n          LA    5,1(5)\n          BCT   6,GETTERM\n          B     SHOWTAS                 END OF REPLY BUF\n GOTTERM  MVC   TERMO(4),4(5)           MOVE IN TERMINAL ID\n          MVC   STATO(3),10(5)          MOVE IN TASK STATUS\n          MVC   ATTRIB(2),=X'1DF0'      SET ATTRIBUTE LOW INTENSITY\n          CLC   STATO(3),=CL3'ACT'      IS TASK ON THE ACTIVE CHAIN ?\n          BNE   *+10                    NO, SKIP NEXT INS\n          MVC   ATTRIB(2),=X'1DF8'      YES, HILIGHT THIS LINE\n          LA    8,26(8)                 BUMP LINE POSISTION\n          BCT   10,*+8                  DO 3 TIMES\n          B     SENDLINE                SEND A LINE\n NEXT     BCT   6,GETTASNR              DO TO END OF REPLY DATA\n          B     SHOWTAS                 END OF REPLY DATA\n EXIT     EXEC  CICS RETURN ,           RETURN TO CICS\n SENDLINE LR    11,6                    SAVE R6\n          BAL   7,SETSBA                SET 3270 SBA ORDER\n          LR    6,11                    RESTORE R6\n          EXEC  CICS SEND FROM(LINEO) LENGTH(80) CTLCHAR(WCC)\n          MVI   LINEO+3,C' '            CLEAR LINE\n          MVC   LINEO+4(75),LINEO+3\n          CH    9,=H'1861'              SCREEN FULL ?\n          BH    EXIT                    YES, EXIT\n          LTR   4,4                     ANY MORE LINES TO PROCESS ?\n          BZ    EXIT                    NO\n          BNP   EXIT                    NO\n          B     SETUPLIN                YES, GO PROCESS\n SETSBA   LR    6,9                     CONVERT SCREEN OFFSET >3270 SBA\n          STC   6,ANSWER+1\n          SRL   6,6\n          STC   6,ANSWER\n          NI    ANSWER+1,X'3F'\n          TR    ANSWER(2),TAB\n          MVC   LINEO+1(2),ANSWER\n          LA    9,80(9)\n          BR    7\n ANSWER   DC    X'0000'\n TAB      DC    X'40C1C2C3C4C5C6C7C8C94A4B'\n          DC    X'4C4D4E4F50D1D2D3D4D5D6D7'\n          DC    X'D8D95A5B5C5D5E5F6061E2E3'\n          DC    X'E4E5E6E7E8E96A6B6C6D6E6F'\n          DC    X'F0F1F2F3F4F5F6F7F8F97A'\n          DC    X'7B7C7D7E7F'\n SHOWTAS  SR    4,4                     FORCE END OF LINES\n          B     SENDLINE\n STRTLINE DC    1F'0'                   BUFFER OFFSET (FROM QLSR PROG)\n L4       DC    AL2(4)                  LENGTHS\n L20      DC    AL2(20)\n PARMS    DC    A(COMMAND)              CEMT COMMAREA\n          DC    A(LCOMMAND)\n          DC    A(OPTBYTE)\n          DC    A(REPLBUF)\n          DC    A(LREPLBUF)\n SPARMS   DC    A(COMMAND)              CEMT COMMAREA SAVE\n          DC    A(LCOMMAND)\n          DC    A(OPTBYTE)\n          DC    A(REPLBUF)\n          DC    A(LREPLBUF)\n WCC      DC    X'F1'                   WRITE CONTROL CHARACTER\n LINEO    DC    X'114040',CL79' '       DISPLAY LINE\n COMMAND  DC    CL5'I TAS'              CEMT OPERAND\n LCOMMAND DC    H'5'                    LENGTH\n OPTBYTE  DC    X'00'                   RETURN DATA TO BUFFER\n LREPLBUF DC    H'2000'                 CEMT REPLY BUFFER LENGTH\n          DS    0F\n REPLBUF  DC    2000C' '                CEMT REPLY BUFFER\n TASKHEAD DC    X'1DF0',CL73'TRAN  TASNO TERM STAT    TRAN  TASNO TERM SX\n                TAT    TRAN  TASNO TERM STAT'\n REPLDS   DSECT ,                       MAP OUTPUT LINE\n ATTRIB   DS    XL2                     SBA\n TRANO    DS    CL6                     TASK NO.\n TASNRO   DS    CL6                     TRANNAME\n TERMO    DS    CL6                     TERMINAL ID\n STATO    DS    CL6                     STATUS\n          END   ITAS\n\n\nRichard Keane\nSystems Programmer (Germany)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A005A05": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\t\\x01\\t\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 265, "newlines": 265, "modlines": 0, "user": "VSAMUPD"}, "text": "Analysing files in a VSAM catalog\n\nThis program, which runs in a VSE environment, was designed\nfor day-to-day tracking of certain conditions of VSAM files\nthat are resident in a catalog. It presumes that the files were\nwell defined in terms of CISIZEs and Free Space (for indexed\nfiles) when they were initially loaded. It detects only four types\nof problem:\n\no      The number of extents\no      CI and CA splits\no      File empty or not allocated\no      The percentage of utilization.\n\nThe input data is obtained by reading an IDCAMS LISTCAT\nALL output listing.\n\n\nCATANLZ JCL\n\n// JOB CATANLZ\n// DLBL IJSYSUC,'DESIRED.USERCAT',,VSAM\n// DLBL IJSYSLS,'CATANLZ.INPUT',,SD\n// EXTENT SYSLST,SYSWKx,,,inittrk,100\n   ASSGN SYSLST,DISK,VOL=SYSWKx,SHR\n// EXEC IDCAMS,SIZE=AUTO\n   LISTCAT ALL -\n     CATALOG(DESIRED.USERCAT)\n/*\n  CLOSE SYSLST,PRINTER\n// ASSGN SYS030,DISK,VOL=SYSWKx,SHR\n// DLBL DISK,'CATANLZ.INPUT'\n// EXTENT SYS030\n// ASSGN SYS030,DISK,VOL=SYSWKx,SHR\n// ASSGN SYS020,SYSLST\n// EXEC CATANLZ,SIZE=100K,PARM='USERCAT'\n/&\n\nThe program uses a parameter as a page-header identifier.\n\n\nCATANLZ PROGRAM\n\nCATANLZ  START 0\n         PRINT NOGEN\n         BALR  12,0\n         USING *,12\n         L     2,0(1)                  GET PARM ADDRESS AND\n         MVC   C01PARM,2(2)            MOVE CATALOG ID TO HEADER\n         COMRG                         GET COMM.REGION ADDRESS\n         MVC   C01DAT,0(1)             AND MOVE CURRENT DATE TO HEADER\n         GETIME                        GET THE TIME ALSO\n         ST    1,SAVR1                 AND EDIT IT\n         MVC   AX3,MASK3\n         ED    AX3,SAVR1\n         MVC   C01TIM,AX3+2\n         OPEN  DISK                    OPEN THE INPUT DATA FILE\n         OPEN  PRINT                   AND REPORT\nGETCLU   GET   DISK,REG                READ A RECORD\n         CLC   REG+66(9),=C'SPACE-MAP' FOUND END STATISTICS?\n         BE    FIM                     YES, DO FINAL PROCESSING\n         CLC   REG+1(7),=C'CLUSTER'    FOUND A CLUSTER?\n         BNE   GETCLU                  NO, CONTINUE LOOKING\n         MVC   D01CLU,REG+17           YES, GET ITS NAME\nGETCRE   GET   DISK,REG                LOOK FOR CREATION DATE\n         CLC   REG+37(8),=C'CREATION'  FOUND IT?\n         BNE   GETCRE                  NO, TRY ANOTHER\n         MVC   D01CRE,REG+55           YES, SAVE IT\nGETSPL   GET   DISK,REG                LOOK FOR CI-SPLITS\n         CLC   REG+37(9),=C'SPLITS-CI' FOUND IT?\n         BNE   GETSPL                  NO, CONTINUE LOOKING\n         MVC   CAMPO1,REG+49           YES, GET THE NUMBER\n         TR    CAMPO1,TRTAB            CHANGE '-'S TO ZEROS\n         LA    R04,D01OCR              GET MESSAGE AREA ADDR.\n         LA    R05,0                   AND ACTUAL MSG LENGTH\n         CLC   CAMPO1,=C'000000000000' HAS ANY\n         BNH   GETEXT                  NO, GO LOOKING EXTENT\n         MVC   D01SPLCI,CAMPO1+7       YES, GET THE NUMBER\n         MVC   0(7,R04),=C'CI-SPL '    MOVE MSG\n         LA    R05,7                   ADD MSG LENGTH\n         MVC   D01SPLTI,REG+44         AND SAY ITS A CISPLIT\nGETEXT   GET   DISK,REG                LOOK FOR NUMBER OF EXTENTS\n         CLC   REG+66(7),=C'EXTENTS'   FOUND IT?\n         BNE   GETEXT                  NO, CONTINUE LOOKING\n         MVC   D01EXT,REG+87           YES, GET THE NUMBER\n         TR    D01EXT,TRTAB            CHANGE '-'S TO ZEROS\n         CLC   D01EXT,=C'001'          MORE THAN ONE?\n         BNH   GETASP                  NO, GO GETTING CA-SPLITS\n         AR    R04,R05                 ADD MSG LENGTH\n         MVC   0(9,R04),=C'MANY-EXT '  TO MANY EXTENTS FOUND\n         LA    R05,9                   ADD MSG LENGTH\nGETASP   MVC   CAMPO1,REG+49           MOVE NUMBER OF CA-SPLITS\n         TR    CAMPO1,TRTAB            CHANGE '-'S TO ZEROS\n         CLC   CAMPO1,=C'000000000000' HAS ANY\n         BNH   GETHIA                  NO, GO GETTING HI-ALLOC RBA\n         MVC   D01SPLCA,CAMPO1+7       YES, GET THE NUMBER\n         AR    R04,R05                 ADD MSG LENGTH\n         MVC   0(7,R04),=C'CA-SPL '    MOVE MSG\n         LA    R05,7                   ADD MSG LENGTH\n         MVC   D01SPLTA,REG+44         AND SAY ITS A CASPLIT\nGETHIA   GET   DISK,REG                LOOK FOR HI-ALLOC RBA\n         CLC   REG+66(4),=C'HI-A'      FOUND IT?\n         BNE   GETHIA                  NO, CONTINUE LOOKING\n         MVC   CAMPO1,REG+78           YES, SAVE IT\n         TR    CAMPO1,TRTAB            CHANGE '-'S TO ZEROS\n         PACK  ALLOC,CAMPO1            ADDS TO\n         AP    TOTALL,ALLOC                 GRAND TOTAL\nGETHIU   GET   DISK,REG                LOOK FOR HI-USED RBA\n         CLC   REG+66(4),=C'HI-U'      FOUND IT?\n         BNE   GETHIU                  NO, CONTINUE LOOKING\n         MVC   CAMPO1,REG+78           YES, SAVE IT\n         TR    CAMPO1,TRTAB            CHANGES '-'S TO ZEROS\n         PACK  USED,CAMPO1             CONVERTS TO PACKED DECIMAL\n         AP    TOTUSE,USED             ADDS TO GRAND TOTAL\n         MP    USED,=P'1000'\n         CP    ALLOC,=P'0'             HAS ALLOCATION?\n         BH    ALLOCD                  YES, CALCULATE USAGE\n         AR    R04,R05                 ADDS PREVIOUS MSGS LENGTH\n         MVC   0(9,R04),=C'NO ALLOC '  MOVE WANING MESSAGE,\n         LA    R05,9                   ADDS THIS MSG LENGTH\n         B     GRAVA                   AND GO PRINTING A LINE\nALLOCD   DP    USED,ALLOC              CALCULATE USED %\n         MVC   AX1,MASK\n         ED    AX1,USED\n         MVC   D01PER,AX1+2            AND MOVE TO REPORT LINE\n         CLC   CAMPO1,=C'000000000000' IS FILE EMPTY?\n         BNE   GRAVA                   NO, PRINT THE LINE\n         AR    R04,R05                 ADDS MSG LENGTH\n         MVC   0(11,R04),=C'FILE EMPTY '  AND MOVE MESSAGE\nGRAVA    CP    CTLIN,=P'39'            IS HEADER TO BE PRINTED?\n         BL    LDET                    NO, PRINT THE LINE\n         AP    CTPAG,=P'1'             YES, ADDS A PAGE\n         MVC   AX2,MASK2\n         ED    AX2,CTPAG\n         MVC   C01PAG,AX2+3\n         PUT   PRINT,CAB01             PRINT HEADER LINES\n         PUT   PRINT,CAB02\n         ZAP   CTLIN,=P'0'             ZEROES LINE COUNTER\nLDET     PUT   PRINT,DET01             PRINTS DETAIL LINE\n         AP    CTLIN,=P'1'             ADDS TO LINE COUNTER\n         MVC   D01OCR,=CL22' '         CLEARS MESSAGE AREA\n         MVI   DET01,C' '              AND DETAIL LINE\n         MVC   DET01+1(132),DET01\n         B     GETCLU                  FIND ANOTHER CLUSTER\nFIM      EQU   *\n         GET   DISK,REG                LOOK FOR THE SPACE-MAP LINE\n         CLC   REG+66(9),=C'SPACE-MAP' FOUND IT?\n         BNE   FIM                     NO, CONTINUE LOOKING\n         MVI   CHAVE,C'*'              YES, DO FINAL STATISTICS\nFIMTOT   DP    TOTALL,=P'512'          CONVERTS TOTAL ALLOCATED AREA\n         UNPK  T01ALC,TOTALL(8)        TO 512 BYTE BLOCKS\n         OI    T01ALC+8,X'F0'\n         DP    TOTUSE,P'512'           CONVERTS TOTAL USED AREA\n         UNPK  T01USE,TOTUSE(8)        TO 512 BYTE BLOCKS\n         OI    T01USE+8,X'F0'\n         MVC   CAMPO1,REG+20\n         TR    CAMPO1,TRTAB\n         PACK  DATASP,CAMPO1\n         UNPK  T01SPA,DATASP\n         OI    T01SPA+8,X'F0'\n         CLI   CHAVE,C'*'\n         BNE   NAODSP\n         SP    DATASP,TOTAL(8)\n         UNPK  T01DIS,DATASP\n         OI    T01DIS+8,X'F0'\nNAODSP   PUT   PRINT,TOT01\n         CLOSE DISK\n         CLOSE PRINT\n         EOJ\n         LTORG\n*\nEditor's note: register equates go here.\n*\nCHAVE    DC    CL1' '\nCTLIN    DC    PL3'60'\nCTPAG    DC    PL3'0'\nREG      DS    CL121\nCAB01    DS    0CL133\n         DC    CL001'1'\n         DC    CL037'CATANLZ '\n         DC    CL025'ANALYSING CATALOG:       '\nC01PARM  DS    CL006\n         DC    CL010'    DATE  '\nC01DAT   DS    CL008\n         DC    CL002' '\nC01TIM   DS    CL008\n         DC    CL016' '\n         DC    CL005'PAGE '\nC01PAG   DS    CL003\n         DC    CL012' '\nCAB02    DS    0CL133\n         DC    CL001'0'\n         DC    CL044'CLUSTER'\n         DC    CL036'#OF EXT. CI/CA-SPLIT     PERCENT./. '\n         DC    CL038'    WARNING MESSAGES'\n         DC    CL014' CREAT.DATE'\nDET01    DS    0CL133\n         DC    CL001' '\nD01CLU   DS    CL044\n         DC    CL003' '\nD01EXT   DS    CL003\n         DC    CL002' '\nD01SPLTI DS    CL002\n         DC    CL001' '\nD01SPLCI DS    CL005\n         DC    CL001' '\nD01SPLTA DS    CL002\n         DC    CL001' '\nD01SPLCA DS    CL005\n         DC    CL005' '\nD01PER   DS    CL005\n         DC    CL005' '\nD01OCR   DC    CL032' '\n         DC    CL004' '\nD01CRE   DS    CL006\n         DC    CL006' '\nTOT01    DS    0CL133\n         DC    CL001'1'\n         DC    CL018'ALLOCATED BLOCKS ='\nT01ALC   DS    CL009\n         DC    CL022'         USED BLOCKS ='\nT01USE   DS    CL009\n         DC    CL024'  ALLOCATED DATA-SPACE ='\nT01SPA   DS    CL009\n         DC    CL022'    BLOCKS AVAILABLE ='\nT01DIS   DS    CL009\n         DC    CL008' '\nALLOC    DS    CL007\nUSED     DS    CL010\nTOTALL   DC    PL010'0'\nTOTUSE   DC    PL010'0'\nDATASP   DC    PL010'0'\nCAMPO1   DS    CL12\nMASK     DC    XL7'40202021206B20'\nMASK2    DC    XL6'402020202020'\nMASK3    DC    XL10'402120204B20204B2020'\nAX1      DS    CL07\nAX2      DS    CL06\nAX3      DS    CL10\nSAVR1    DS    F\nTRTAB    DC    96X'00'\n         DC    X'F0'\n         DC    143X'00'\n         DC    X'F0F1F2F3F4F5F6F7F8F9'\n         DC    6X'00'\nDISK     DTFSD BLKSIZE=121,                                            C\n               DEVADDR=SYS030,                                         C\n               EOFADDR=FIMTOT,                                         C\n               IOAREA1=BUF1,                                           C\n               RECFORM=FIXUNB,                                         C\n               TYPEFLE=INPUT,                                          C\n               WORKA=YES\nPRINT    DTFPR BLKSIZE=133,                                            C\n               CTLCHR=ASA,                                             C\n               DEVADDR=SYS020,                                         C\n               IOAREA1=BUF2,                                           C\n               RECFORM=FIXUNB,                                         C\n               WORKA=YES\nBUF1     DS    CL121\nBUF2     DS    CL133\n         END\n\nCleantes Alves Leite Jr\nSenior Systems Programmer (Brazil)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A005A06": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12Y\\x00\\xa4\\x00\\xa4\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:59:18", "lines": 164, "newlines": 164, "modlines": 0, "user": "VSAMUPD"}, "text": "Checking volume security\n\nWhen using RACF or a RACF-compatible product (including\nthe SAF interface), there is a potential security exposure when\nallocating new VSAM datasets or extending VSAM datasets on\nnew volumes. When the security call is performed, the volume\nserial number passed is not for the volume on which the\nallocation or extension is to take place. For VSAM datasets,\nthe volume serial number used is that of the disk containing the\ncatalog in which the VSAM dataset being allocated or extended\nis catalogued. This presents a problem to security systems such\nas CA-Top Secret when ICF VSAM user catalogs are\nprotected.\n\nConsider this scenario: datasets using the high-level qualifier\nTEST are catalogued in catalog ICFUCAT.VTEST01 on\nvolume TEST01. A TSO user wants to create a VSAM dataset\ncalled TEST.TESTFILE on volume TEST02, which the user\nhas full access to. When the security request is generated, the\nvolume for which CREATE ACCESS will be requested will be TEST01;\nthis is because MVS builds the RACHECK/RACROUTE parameter list to\nreflect TEST01 as the volume on which the dataset is to be\nallocated rather than TEST02 as the user requested. In order to\nallow this allocation, the security system must have a definition\nallowing the TSO CREATE ACCESS to volume TEST01, even though he\nwants to allocate his dataset on TEST02. This opens up the\npossiblity that the user could also allocate his VSAM datasets on\nTEST01, since he would have CREATE ACCESS to that volume. This\npresents a potential security breach if the user should not\nreally be allowed to create datasets on TEST01.\n\nIn order to remedy this security exposure, I have written a\nDADSM pre-processing exit. The standard name of the exit is\nrequired to be IGGPRE00 and its use is documented in the\nappropriate level of the MVS Data Facility Product (DFP)\nCustomization guide. The exit is passed a parameter list\ncontaining the function requested, as well as the addresses of\nthe UCB, JFCB, and DCB for the dataset in question. The\nbasic mechanics of the exit is to check that the request is for a\nnew allocation or extension to a dataset on a new volume. The\ndataset is checked for a DSORG of VSAM, and a RACROUTE\nmacro is issued to check the users authority to CREATE on the\nvolume requested. The DADSM exit is passed the actual\nvolume on which the user wishes to allocate his dataset rather\nthan the volume on which the user catalog resides. If the\nRACROUTE gives a return code of zero, the\nallocation/extension is allowed by the exit. If not, a return code\nof 8 is set by the exit to unconditionally reject the request and\nthis return code is also stored in the parameter list passed to\nIGGPRE00. This value will be used as the reason code in\nmessage IEF274I which indicates that the space request was\nrejected by the DADSM exit. One further note concerns the\nclass name parameter list (labelled CLASS) which is used by\nthe RACROUTE; the class name used is DASDVOLX, which\nis not a standard class and is in fact undocumented in CA-Top\nSecret manuals. Its name was given to me by the vendor after\ncalling about problems relating to using this exit. The\nparameter list consists of a one-byte field containing the length\nof the class name (X'08'), the class name itself (DASDVOLX),\nand finally a byte indicating the access level to be checked.\nAccess level X'10' has no meaning in standard RACF systems,\nit is used by CA-Top Secret to indicate CREATE ACCESS.\nAlthough this value can be placed in a register and used in the\nATTR= keyword of the RACROUTE/RACHECK macros, it\nwas recommended by the vendor to use the format coded in\nthis exit.\n\nThis version of the IGGPRE00 exit also performs some\nadditional security checking that is not done in any security\nproduct. If the volume on which the allocation will take place\nis mounted as a public volume, a check is done to ensure that\nthe dataset being allocated is temporary. A temporary dataset is\ndefined as one which has a system-generated temporary dataset\nname or one which is\ndeleted, either explicitly or implicitly, at job termination. This\ncheck is performed to disallow any users from using a specific\nvolume serial number to point to a public volume when they\nare trying to create datasets. This, in effect, will ensure that\nonly temporary datasets reside on public volumes.\n\nIGGPRE00 TITLE  'PRE ALLOCATION DADSM EXIT FOR SECURITY CHECKING OF VOLX\n               UMES FOR VSAM DATASETS'\nIGGPRE00 AMODE 31                 31-BIT ADDRESSING MODE\nIGGPRE00 RMODE ANY                31-BIT RESIDENCY MODE ALLOWED\n         REGS  ,                  MACRO TO PERFORM REGISTER EQUATES\nIGGPRE00 CSECT\n         SAVE  (14,12),,IGGPRE00-&SYSDATE\n         LR    R12,R15            LOAD R12 W/BASE ADDRESS\n         USING IGGPRE00,R12\n         LR    R2,R1              SAVE PARMS IN R2\n         GETMAIN RU,LV=WORKLEN    OBTAIN DYNAMIC STORAGE\n         ST    R13,4(,R1)         SET BACKWARD POINTER\n         ST    R1,8(,R13)         SET FORWARD POINTER\n         LR    R13,R1             SET R13 TO POINT TO OUR SAVE AREA\n         USING WORKAREA,R13\n         L     R3,CVTPTR          LOAD A(CVT)\n         USING CVT,R3\n         ICM   R3,15,CVTRAC       LOAD A(RACF CVT), IF ANY\n         BZ    ALLOCOK            IF NONE, ALLOW THE REQUEST\n         USING RCVT,R3\n         TM    RCVTSTAT,RCVTRNA   ELSE, IS RACF-NOT-ACTIVE BIT ON\n         BO    ALLOCOK            YES, GO ALLOW THE REQUEST\n         USING PREPL,R2\n         CLI   IEXFUNC,IEXALL     ELSE, IS IT ALLOCATION FUNCTION CODE\n         BE    CHKPUB             YES, GO CHECK FOR TYPE OF VOLUME\n         CLI   IEXFUNC,IEXEXT     ELSE, IS IT EXTEND FUNCTION CODE\n         BNE   ALLOCOK            NO, GO ALLOW THE REQUEST\n         CLI   IEXEXTCD,X'04'     ELSE, IS IT EXTEND DATASET ON NEW VOL\n         BNE   ALLOCOK            NO, GO ALLOW THE REQUEST\nCHKPUB   L     R4,IEXUCB          ELSE, LOAD A(UCB)\n         USING UCBOB,R4\n         L     R3,IEXPTR1         LOAD A(JFCB)--NOTE THE A(JFCB) IS\n*                                 ONLY VALID FOR ALLOCATE, EXTEND,\n*                                 AND PARTIAL RELEASE FUNCTION CODES.\n         USING INFMJFCB,R3\n         TM    UCBSTAB,UCBBPUB    IS THE VOLUME MOUNTED PUBLIC\n         BZ    CHKVSAM            NO, GO CHECK FOR VSAM\nCHKTEMP  TM    JFCBIND2,JFCTEMP   ELSE, IS IT A TEMPORARY DATASET\n         BZ    ALLOCNG            NO, GO DISALLOW THE REQUEST\n         B     ALLOCOK            ELSE, GO ALLOW THE REQUEST\nCHKVSAM  TM    JFCDSRG2,JFCORGAM  IS IT A VSAM DATASET\n         BNO   ALLOCOK            NO, GO ALLOW THE REQUEST\n         MVC   VOLUME,UCBVOLI     MOVE IN THE VOLSER\n         LA    R8,VOLUME          LOAD A(VOLUME) FOR RACROUTE\n         LA    R7,RACWK           LOAD A(WORKAREA) FOR RACROUTE\n         MVC   RACHKD(RACHKL),RACHK MOVE PLIST TO GETMAINED AREA\n         RACROUTE REQUEST=AUTH,ENTITY=((R8)),WORKA=(R7),MF=(E,RACHKD)\n         LTR   R15,R15            IS CREATE AUTHORITY ALLOWED FOR VOL\n         BZ    ALLOCOK            YES, GO ALLOW THE REQUEST\nALLOCNG  LA    R9,8               ELSE, SET RC = 8 TO CAUSE DADSM TO\n*                                 UNCONDITIONALLY REJECT THE REQUEST\n         STH   R9,IEXREASN        STORE AS REASON CODE FOR DADSM TO BE\n*                                 DISPLAYED IN MESSAGE IEF274I\n         B     RETURN             GO RETURN TO CALLER\nALLOCOK  LA    R9,0               SET ZERO RETURN CODE\nRETURN   LR    R1,R13             GET SAVEAREA ADDRESS\n         L     R13,4(,R13)        LOAD R13 W/A(CALLER SAVEAREA)\n         FREEMAIN RU,A=(1),LV=WORKLEN FREE STORAGE\n         LR    R15,R9             LOAD R15 WITH RETURN CODE\n         RETURN (14,12),RC=(15)   RETURN TO CALLER\n* CLASS CONTAINS CLASS NAME LENGTH/CLASS NAME/ACCESS LEVEL (CREATE)\nCLASS    DC    X'08',CL8'DASDVOLX',X'10'\nCLASSL   EQU   *-CLASS\nRACHK    RACROUTE CLASS=CLASS,REQUEST=AUTH,MF=L\nRACHKL   EQU   *-RACHK\n         LTORG\nWORKAREA DSECT\nSAVEAREA DS    18F           SAVE AREA FOR STD LINKAGE CONVENTIONS\nRACHKD   DS    XL(RACHKL)    AREA FOR RACROUTE CODE TO BE RE-ENTRANT\nVOLUME   DS    CL6           VOLUME SERIAL SAVE AREA\nRACWK    DS    CL512         WORK AREA FOR RACROUTE\nWORKLEN  EQU   *-WORKAREA    LENGTH OF GETMAIN'D WORK AREA\nPREPL    IECIEXPL DSECT=YES  DADSM EXIT PLIST\n         PRINT NOGEN\nUCB      DSECT               GENERATE DSECT FOR UCB\n         IEFUCBOB LIST=YES   UCB DSECT\nJFCB     DSECT               GENERATE DSECT FOR JFCB\n         IEFJFCBN LIST=YES   JFCB DSECT\n         CVT   DSECT=YES,LIST=NO CVT\n         ICHPRCVT            RACF CVT DSECT\n         END\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A005A07": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00l\\x00l\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 108, "newlines": 108, "modlines": 0, "user": "VSAMUPD"}, "text": "VSAM for VM users\n\nFor sites running VSE under VM it is possible to use the more\nuser-friendly facilities associated with CMS to develop and test\nVSE/VSAM programs before they go live.\n\nIn order to do this, a virtual machine must be created under\nVM. The directory entry for this virtual machine must contain\nMDISK statements for each VSAM volume used and must also\nLINK to the VSE system residence volume. Because the\nvolumes used for VSAM are effectively VSE disks, they\nrequire a VTOC. Initializing the disk space and installing the\nVTOC can be carried out using the DSF (Device Support\nFacilities) program.\n\nBefore VSAM can be used from VM it is necessary to SET\nDOS ON. This creates an environment similar to a VSE\npartition. It is necessary to include in the command the\nfilemode of the VSE system residence pack, for example V, in\norder to access system libraries etc. Also, to indicate that\nVSAM will be used, the VSAM option must be included with\nthe SET command. An example of the command is:\n\n      SET DOS ON V (VSAM\n\nIt does no harm to specify the command more than once. In \u00a8\norder to check whether DOS is on, the QUERY DOS command\ncan be issued.\n\nTo perform any VSAM-related task from CMS involves\nplacing the AMS commands and parameters in a file. The file\ncan have any filename, but must have a filetype of AMSERV.\nThe commands are executed by the Access Method Utility\n(AMSERV) program. This is achieved by entering:\n\n      AMSERV filename\n\nWhere filename is the name of the file containing the AMS\ncommands and parameters. AMSERV processes the commands\nand produces a report with the same filename as the original\nAMSERV file, and a filetype of LISTING.\n\nThe next task to be performed is the creation of the VSAM\nmaster catalog. The steps necessary to create the master catalog\nare:\n\n      ASSGN SYSCAT B\n\nThis is emulating VSE and assigns the system logical unit for\nthe master catalog to the filemode letter of the disk.\n\n      DLBL IJSYSCT B DSN VSAMCAT (SYSCAT PERM EXTENT\n\nThis creates a disk label for the master catalog. The system will\nrespond by asking for the starting track and total number of\ntracks. These are entered with a single space separating the two\nnumbers.\n\nThe master catalog can then be defined, for example:\n\nDEFINE MASTERCATALOG (-\n NAME (VSAMCAT) -\n VOL (VSAM01) -\n CYL (2) -\n FILE (IJSYSCT))\n\nThese commands are placed in the AMSERV file.\n\nOther VSAM entities such as space and clusters can be defined\nin a similar way, although space does not require an ASSGN or\nDLBL. The AMS REPRO command can be used to place\nrecords in files. This, again, requires the use of ASSGN and\nDLBL to describe the input file.\n\nBefore a user can make use of VSAM under VM it is necessary\nfor them to go through a number of steps. First they must\nACCess the VSAM disks and the VSE system residence\nvolume, eg:\n\n      ACC 123 V\n\nThey must then go into VSE emulation mode, ie:\n\n      SET DOS ON V (VSAM\n\nFinally, ASSGNs and DLBLs must be specified for the master\ncatalog and any clusters that have been defined, eg:\n\n      ASSGN SYSCAT B\n      DLBL IJSYSCT B DSN VSAMCAT ( SYSCAT PERM\n\nFor convenience, these commands are usually placed in an\nEXEC that can be started by a user, or included as part of their\nPROFILE EXEC.\n\nWhen the user has finished working with VSAM it is necessary\nto RELease the disks that have been accessed, terminate DOS\nmode, and remove the DLBLs. For example:\n\n      REL V\n      SET DOS OFF\n      DLBL IJSYSCT CLEAR\n\nThese commands are also usually run from an EXEC.\n\nJ Phillips\nConsultant (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A006A00I": {"ttr": 6920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 12, "newlines": 12, "modlines": 0, "user": "VSAMUPD"}, "text": "A006 - VSAM Update issue 6 July 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA006A01   Calculating read hit and write hit ratios\nA006A02   CICS VSAM files - testing definitions\nA006A03   KSDS index component information\nA006A04   Use of VBS in VSAM\nA006A05   Estimating VSAM buffer parameters\nA006A06   Mapping VSAM dataspaces on FBA devices\nA006A07   Catalog back-up process - revisited\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A006A01": {"ttr": 6922, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x02\\xc5\\x02\\xc5\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 709, "newlines": 709, "modlines": 0, "user": "VSAMUPD"}, "text": "Calculating read hit and write hit ratios\n\nWhen the 3990-3 cache controller was first installed, we could\nnot easily see the read hit ratios (and subsequently write hit\nfigures) for the various devices. After giving some thought to\nthe problem, I decided to make use of the IDCAMS program\nthat lists all the counts. Our peak hour is 10:30 to 11:30, which\nwas the period that I wanted to monitor.\n\nThe first step was to collect the data. This was achieved by\nwriting a program to read the output from IDCAMS, and\nextract and store the data. The program is automatically\ntriggered at 10:30 and 11:30, with the output being written to\nseparate datasets.\n\nThe second step was to process the two output files,\nperforming calculations to work out the appropriate ratios, and\nwrite the results to an output file, which was then stored on a\nSAS dataset for subsequent analysis.\n\nThe JCL for the run at the start of the period is given below.\n\n//job card\n//STEP1 EXEC PGM=IDCAMS\n//SYSPRINT DD DSN=&&FRODO,UNIT=3390,SPACE=(TRK,(2,2),RLSE),\n// DISP=(,PASS),\n// DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)\n//SYSIN    DD *\n   LISTDATA-\n   COUNTS-\n   VOLUME(volser)-\n   ALL-\n   UNIT(3390)\n/*\n//CACHE  EXEC PGM=TECJL40\n//STEPLIB DD loadlib\n//SYSUDUMP DD SYSOUT=X\n//SYSPRINT DD SYSOUT=X\n//SYSOUT   DD SYSOUT=X\n//PRINT23  DD DSN=start dataset,DISP=OLD\n//CARD01   DD DSN=&&FRODO,DISP=OLD\n// DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)\n\nThe JCL for the run at the end of the period is shown below,\nand includes the calculation and SAS steps.\n\n//job card\n//STEP1 EXEC PGM=IDCAMS\n//SYSPRINT DD DSN=&&FRODO,UNIT=WORK,SPACE=(TRK,(2,2),RLSE),\n// DISP=(,PASS),\n// DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)\n//SYSIN    DD *\n   LISTDATA-\n   COUNTS\n   VOLUME(volser)-\n   ALL-\n   UNIT(3390)\n/*\n//CACHE   EXEC PGM=TECJL40\n//STEPLIB  DD loadlib\n//SYSUDUMP DD SYSOUT=X\n//SYSPRINT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//PRINT23  DD DSN=end datset,DISP=OLD\n//CARD01   DD DSN=&&FRODO,DISP=OLD\n//CACHEP  EXEC PGM=TECJL41\n//STEPLIB  DD loadlib\n//SYSUDUMP DD SYSOUT=X\n//SYSPRINT DD SYSOUT=X\n//SYSOUT   DD SYSOUT=X\n//PRINT23  DD SYSOUT=8\n//PRINT26  DD SYSOUT=8\n//PRINT25  DD DISP=(,PASS),DSN=&&BILBO,\n// SPACE=(TRK,(5,5),RLSE),UNIT=WORK,\n// DCB=(RECFM=FB,LRECL=69,BLKSIZE=6900)\n//CARD01 DD  DISP=OLD,DSN=start dataset\n//CARD02 DD  DISP=OLD,DSN=end dataset\n//SASSTEP  EXEC SAS,OPTIONS='MARCO NODSNFERR'\n//WORK     DD UNIT=WORK,SPACE=(CYL,(5,5))\n//FT11F001 DD SYSOUT=*\n//FT12F001 DD SYSOUT=*\n//FT13F001 DD SYSOUT=*\n//FT14F001 DD SYSOUT=*\n//FT15F001 DD SYSOUT=*\n//FT16F001 DD SYSOUT=*\n//FT17F001 DD SYSOUT=*\n//FT18F001 DD SYSOUT=*\n//SORTWK01 DD SPACE=(CYL,(&SORT)),UNIT=WORK\n//SORTWK02 DD SPACE=(CYL,(&SORT)),UNIT=WORK\n//SORTWK03 DD SPACE=(CYL,(&SORT)),UNIT=WORK\n//SASE     DD DISP=OLD,DSN=sas data file\n//SASD     DD DISP=OLD,DSN=&&BILBO\n//SASLIB   DD DISP=SHR,DSN=saslib\n//SOURCLIB DD DISP=SHR,DSN=sas source lib\n//SYSIN    DD DSN=sas source pds\n\nThe extract program source was written in COBOL.\n\n IDENTIFICATION DIVISION.\n*************************\n PROGRAM-ID                 TECJL40.\n AUTHOR.                    JOHN LARRY.\n REMARKS                    READ IDCAMS OUTPUT FOR CACHE DATA.\n ENVIRONMENT DIVISION.\n**********************\n CONFIGURATION SECTION.\n SPECIAL-NAMES.\n     C01 IS TO-TOP-OF-PAGE.\n INPUT-OUTPUT SECTION.\n FILE-CONTROL.\n     SELECT B100-OUTFILE ASSIGN TO PRINT23.\n     SELECT A100-CARDFILE  ASSIGN TO CARD01.\n DATA DIVISION.\n***************\n FILE SECTION.\n FD  B100-OUTFILE\n     LABEL RECORDS ARE STANDARD\n     BLOCK CONTAINS 0 RECORDS.\n 01  B1-PRINTLINE1.\n     05 B1-DISK.\n        10 B1-X       PIC X.\n        10 FILLER     PIC XX.\n        10 B1-DATE.\n           15 B1-DATE-DD PIC XX.\n           15 B1-DATE-S1 PIC X.\n           15 B1-DATE-MM PIC XX.\n           15 B1-DATE-S2 PIC X.\n           15 B1-DATE-YY PIC XX.\n     05 FILLER        PIC XX.\n     05 B1-TOTREAD    PIC X(8).\n     05 FILLER        PIC X.\n     05 B1-TOTCACH    PIC X(8).\n     05 FILLER        PIC X.\n     05 B1-TOTWRIT    PIC X(8).\n     05 B1-ACTIVE     PIC X(11).\n     05 B1-TOT-FW     PIC X(8).\n     05 B1-FW-ACTIVE  PIC X(11).\n     05 FILLER        PIC X(11).\n FD  A100-CARDFILE\n     BLOCK CONTAINS 0 RECORDS\n     LABEL RECORDS ARE STANDARD.\n 01  A1-CARD-IN.\n     05 FILLER        PIC X.\n     05 A1-IDCAMS     PIC X(6).\n     05 FILLER        PIC X(82).\n     05 A1-DATE.\n        10 A1-DATE-MM PIC XX.\n        10 A1-DATE-S1 PIC X.\n        10 A1-DATE-DD PIC XX.\n        10 A1-DATE-S2 PIC X.\n        10 A1-DATE-YY PIC XX.\n     05 FILLER        PIC X(30).\n 01  A2-CARD-IN.\n     05 FILLER        PIC X.\n     05 FILLER        PIC X(20).\n     05 A2-VOLUME-LIT PIC X(6).\n     05 FILLER        PIC X.\n     05 A2-VOLUME     PIC X(6).\n     05 FILLER        PIC X(14).\n     05 A2-VOLUME-ID  PIC X(2).\n     05 FILLER        PIC X(83).\n 01  A3-CARD-IN.\n     05 FILLER        PIC X.\n     05 A3-TOTALS     PIC X(6).\n     05 FILLER        PIC X(15).\n     05 A3-TOT-READ   PIC X(8).\n     05 FILLER        PIC X(4).\n     05 A3-TOT-CREAD  PIC X(8).\n     05 FILLER        PIC X(4).\n     05 A3-TOT-WRITE  PIC X(8).\n     05 FILLER        PIC X(4).\n     05 A3-DASD-FW    PIC X(8).\n     05 FILLER        PIC X(67).\n 01  A4-CARD-IN.\n     05 FILLER        PIC X(109).\n 01  A5-CARD-IN.\n     05 FILLER        PIC X(19).\n     05 A5-CACH       PIC X(8).\n     05 FILLER        PIC X(9).\n     05 A5-ACTIVE     PIC X(11).\n     05 FILLER        PIC X(62).\n 01  A6-CARD-IN.\n     05 FILLER        PIC X(19).\n     05 A6-DFW        PIC X(16).\n     05 FILLER        PIC X(1).\n     05 A6-ACTIVE     PIC X(11).\n     05 FILLER        PIC X(62).\n WORKING-STORAGE SECTION.\n*************************\n 77  W-VERSION    PIC X(16)     VALUE  \"PROGRAM TECJL40\".\n 77  W-X                  PIC 9         VALUE 0.\n 01  W-DISK-ID.\n     05 W-VOLUME          PIC X(6).\n     05 FILLER            PIC XX        VALUE \" 7\".\n     05 W-VOLUME-ID       PIC XX.\n     05 FILLER            PIC X         VALUE \" \".\n     EJECT\n PROCEDURE DIVISION.\n********************\n 010M-MAINLINE SECTION.\n***********************\n     OPEN INPUT  A100-CARDFILE.\n     OPEN OUTPUT B100-OUTFILE.\n     MOVE SPACES TO B1-PRINTLINE1.\n     MOVE 0 TO W-X.\n     PERFORM 030D-READ.\n     CLOSE A100-CARDFILE\n           B100-OUTFILE.\n     STOP RUN.\n 010M-EXIT.\n     EXIT.\n 030D-READ SECTION.\n     READ A100-CARDFILE\n       AT END\n       GO TO 030D-READ-EXIT.\n     IF A1-IDCAMS = \"IDCAMS\"\n        IF W-X = 0\n            MOVE 1 TO W-X\n            MOVE A1-DATE-DD TO B1-DATE-DD\n            MOVE A1-DATE-MM TO B1-DATE-MM\n            MOVE A1-DATE-YY TO B1-DATE-YY\n            MOVE A1-DATE-S1 TO B1-DATE-S1\n            MOVE A1-DATE-S2 TO B1-DATE-S2\n            MOVE \"X\" TO B1-X\n            WRITE B1-PRINTLINE1\n            MOVE SPACES TO B1-PRINTLINE1.\n     IF A2-VOLUME-LIT = \"VOLUME\"\n        IF W-X NOT = 1\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 2 TO W-X\n            MOVE A2-VOLUME TO W-VOLUME\n            MOVE A2-VOLUME-ID TO W-VOLUME-ID\n            MOVE W-DISK-ID TO B1-DISK.\n     IF A3-TOTALS = \"TOTALS\"\n        IF W-X NOT = 2\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 3 TO W-X\n            MOVE A3-TOT-READ  TO B1-TOTREAD\n            MOVE A3-TOT-CREAD TO B1-TOTCACH\n            MOVE A3-TOT-WRITE TO B1-TOTWRIT\n            MOVE A3-DASD-FW   TO B1-TOT-FW\n            PERFORM 050D-EXAMINE.\n     IF A5-CACH = \"CACHING:\"\n        IF W-X NOT = 3\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 4 TO W-X\n            MOVE A5-ACTIVE TO B1-ACTIVE.\n     IF A6-DFW = \"DASD FAST WRITE:\"\n        IF W-X NOT = 4\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 1 TO W-X\n            MOVE A6-ACTIVE TO B1-FW-ACTIVE\n            WRITE B1-PRINTLINE1\n            MOVE SPACES TO B1-PRINTLINE1.\n     GO TO 030D-READ.\n 030D-READ-EXIT.\n     EXIT.\n 050D-EXAMINE.\n     EXAMINE B1-TOTREAD REPLACING LEADING SPACES BY ZERO.\n     EXAMINE B1-TOTCACH REPLAICNG LEADING SPACES BY ZERO.\n     EXAMINE B1-TOTWRIT REPLACING LEADING SPACES BY ZERO.\n     EXAMINE B1-TOT-FW  REPLACING LEADING SPACES BY ZERO.\n O50D-EXAMINE-EXIT.\n     EXIT.\n 999E-ABEND SECTION.\n     DISPLAY W-X A1-CARD-IN.\n     CALL \"X\".\n\nThe calculation step was also written in COBOL.\n\n IDENTIFICATION DIVISION.\n*************************\n PROGRAM-ID.                TECJL41.\n AUTHOR.                    JOHN LARRY.\n REMARKS                    CACHE RATIO CALCULATOR FROM 2\n                            FILES.\n ENVIRONMENT DIVISION.\n**********************\n CONFIGURATION SECTION.\n SPECIAL-NAMES\n     C01 IS TO-TOP-OF-PAGE.\n INPUT-OUTPUT SECTION.\n FILE-CONTROL.\n     SELECT B100-PRINTFILE ASSIGN TO PRINT23.\n     SELECT B300-DISKFILE  ASSIGN TO PRINT25.\n     SELECT B400-PRINTFILE ASSIGN TO PRINT26.\n     SELECT A100-CARDFILE  ASSIGN TO CARD01.\n     SELECT A200-CARDFILE  ASSIGN TO CARD02.\n DATA DIVISION.\n***************\n FILE SECTION.\n FD  B100-PRINTFILE\n     LABEL RECORDS ARE STANDARD.\n 01  P-PRINTLINE1.\n     05 P1-CC         PIC X.\n     05 P1-DISK       PIC X(11).\n     05 FILLER        PIC XXXX.\n     05 P1-RP-RATIO   PIC ZZZZZ.99BBBBBB.\n     05 P1-CACHE      PIC ZZZZZZZ.99BBBBBB.\n     05 FILLER        PIC X(7).\n     05 P1-RW-RATIO   PIC ZZZZZ.99BBBBBB.\n     05 FILLER        PIC X(5).\n     05 P1-ACTIVE     PIC X(11).\n     05 FILLER        PIC X(3).\n     05 P1-TOTREAD    PIC Z(10)9.\n     05 FILLER        PIC X(5).\n     05 P1-TOTCREAD   PIC Z(10)9.\n     05 FILLER        PIC X(5).\n     05 P1-TOTWRITE   PIC Z(10)9.\n     05 FILLER        PIC X(4).\n FD  B300-DISKFILE\n     LABEL RECORDS ARE STANDARD.\n 01  B3-LINE.\n     05 B3-DATE       PIC X(7).\n     05 B3-DISK.\n        10 B3-DISK-NAME PIC X(6).\n        10 FILLER       PIC X.\n        10 B3-DISK-NUM  PIC XXX.\n        10 FILLER       PIC X.\n     05 B3-RP         PIC 9V99.\n     05 B3-RH         PIC 9V99.\n     05 B3-RW         PIC 9(5)V99.\n     05 B3-DA         PIC X.\n     05 B3-TOT-READ   PIC 9(8).\n     05 B3-TOT-CACH   PIC 9(8).\n     05 B3-TOT-WRIT   PIC 9(8).\n     05 B3-SORT-IND   PIC X.\n     05 B3-FW-ACT     PIC X.\n     05 B3-FW-RATIO   PIC 9V99.\n     05 B3-TOT-FW     PIC 9(8).\n FD  B400-PRINTFILE\n     LABEL RECORDS ARE STANDARD.\n 01  P-PRINTLINE4.\n     05 P4-CC         PIC X.\n     05 P4-DISK       PIC X(11).\n     05 FILLER        PIC XXXX.\n     05 P4-FW-RATIO   PIC ZZZZZ.99BBBBBB.\n     05 P4-FW-WRITE   PIC ZZZZZZZ9.\n     05 FILLER        PIC X(13).\n     05 P4-TOT-WRITE  PIC ZZZZZZZ9.\n     05 FILLER        PIC X(11).\n     05 P4-ACTIVE     PIC X(11).\n     05 FILLER        PIC X(50).\n FD  A100-CARDFILE\n     BLOCK CONTAINS 0 RECORDS\n     LABEL RECORDS ARE STANDARD.\n 01  A1-CARD-IN.\n     05 A1-DISK.\n        10 A1-X       PIC X.\n        10 FILLER     PIC XX.\n        10 A1-DATE    PIC X(8).\n     05 FILLER        PIC XX.\n     05 A1-TOTREAD    PIC 9(8).\n     05 FILLER        PIC X.\n     05 A1-TOTCACH    PIC 9(8).\n     05 FILLER        PIC X.\n     05 A1-TOTWRIT    PIC 9(8).\n     05 A1-ACTIVE     PIC X(11).\n     05 A1-TOT-FW     PIC 9(8).\n     05 A1-FW-ACTIVE  PIC X(11).\n     05 FILLER        PIC X(11).\n FD  A200-CARDFILE\n     BLOCK CONTAINS 0 RECORDS\n     LABEL RECORDS ARE STANDARD.\n 01  A2-CARD-IN.\n     05 A2-DISK.\n        10 A2-X       PIC X.\n        10 FILLER     PIC XX.\n        10 A2-DATE    PIC X(8).\n     05 FILLER        PIC XX.\n     05 A2-TOTREAD    PIC 9(8).\n     05 FILLER        PIC X.\n     05 A2-TOTCACH    PIC 9(8).\n     05 FILLER        PIC X.\n     05 A2-TOTWRIT    PIC 9(8).\n     05 A2-ACTIVE     PIC X(11).\n     05 A2-TOT-FW     PIC 9(8).\n     05 A2-FW-ACTIVE  PIC X(11).\n     05 FILLER        PIC X(11).\n WORKING-STORAGE SECTION.\n*************************\n 77  W-VERSION            PIC X(16)  VALUE  \"PROGRAM TECJL41\".\n 77  W-DISKS              PIC S9999      COMP-3 VALUE ZERO.\n 77  W-DISKS-EX           PIC S9999      COMP-3 VALUE ZERO.\n 77  W-FW-DISKS           PIC S9999      COMP-3 VALUE ZERO.\n 77  W-TOT-READS          PIC S9(11)     COMP-3 VALUE ZERO.\n 77  W-TOT-FW-WRITES      PIC S9(11)     COMP-3 VALUE ZERO.\n 77  W-TOT-CACHE          PIC S9(11)     COMP-3 VALUE ZERO.\n 77  W-TOT-FW             PIC S9(11)     COMP-3 VALUE ZERO.\n 77  W-TOT-GRAND          PIC S9(11)V999 COMP-3 VALUE ZERO.\n 77  W-FW-TOT-GRAND       PIC S9(11)V999 COMP-3 VALUE ZERO.\n 77  W-ACC-RATIO          PIC S9(11)V999 COMP-3 VALUE ZERO.\n 77  W-ACC-RATIO-EX       PIC S9(11)V999 COMP-3 VALUE ZERO.\n 77  W-FW-ACC-RATIO       PIC S9(11)V999 COMP-3 VALUE ZERO.\n 77  W-TOT-RATIO          PIC S9(11)V999 COMP-3 VALUE ZERO.\n 77  W-FW-TOT-RATIO       PIC S9(11)V999 COMP-3 VALUE ZERO.\n 77  W1-TOTREAD           PIC 9(8).\n 77  W1-TOTCACH           PIC 9(8).\n 77  W1-TOTWRIT           PIC 9(8).\n 77  W1-TOTFW             PIC 9(8).\n 01  W-VARIABLES.\n     05 W-RP-RATIO     PIC 9V9999  COMP VALUE 0.\n     05 W-READ-RATIO   PIC 9V9999  COMP VALUE 0.\n     05 W-RW-RATIO     PIC 99V9999 COMP VALUE 0.\n     05 W-FW-RATIO     PIC 9V9999  COMP VALUE 0.\n     05 W-DATE.\n        10 W-DATE-DD      PIC XX.\n        10 W-DATE-MM      PIC XXX.\n        10 W-DATE-YY      PIC XX.\n 01  TITLE1.\n     05 FILLER            PIC X(40) VALUE \"1\".\n     05 FILLER            PIC X(43) VALUE\n     \" PEAK HOUR CACHE RATIOS FOR JOHN LARRY FOR \".\n     05 T-DATE.\n        10 T-DATE-DD      PIC XX.\n        10 FILLER         PIC X.\n        10 T-DATE-MM      PIC XX.\n        10 FILLER         PIC X.\n        10 T-DATE-YY      PIC XX.\n 01  TITLE1A.\n     05 FILLER            PIC X(11) VALUE \"0   DISKS\".\n     05 FILLER            PIC XXX.\n     05 FILLER            PIC X(16) VALUE \"READ PROPORTION \".\n     05 FILLER            PIC XX.\n     05 FILLER            PIC X(16) VALUE \" READ HIT RATIO\".\n     05 FILLER            PIC XX.\n     05 FILLER            PIC X(18) VALUE \" READ/WRITE RATIO\".\n     05 FILLER            PIC X(13).\n     05 FILLER            PIC X(18).\n              VALUE \"        TOTAL READ\".\n     05 FILLER            PIC X(2).\n     05 FILLER            PIC X(18) VALUE \" TOTAL CACHE READ\".\n     05 FILLER            PIC X(18) VALUE \" TOTAL WRITTEN\".\n 01  TITLE1B.\n     05 FILLER            PIC X(11) VALUE \"0    DISKS\".\n     05 FILLER            PIC XXX.\n     05 FILLER            PIC X(16) VALUE \"WRITE HITS \".\n     05 FILLER            PIC XX.\n     05 FILLER            PIC X(16) VALUE \" TOTAL DASD FW\".\n     05 FILLER            PIC XX.\n     05 FILLER            PIC X(18) VALUE \" TOTAL WRITTEN\".\n     05 FILLER            PIC X(13).\n 01  TOTAL1.\n     05 FILLER     PIC X(29) VALUE \"0READ HIT RATIO OF TOTALS\".\n     05 W-AVERAGE         PIC Z.99.\n 01  TOTAL2.\n     05 FILLER PIC X(29) VALUE \"0AVERAGE OF READ HIT RATIOS \".\n     05 W-AVERAGE2        PIC Z.99.\n     05 FILLER     PIC X(34) VALUE\n         \" (EXCLUDING VOLUMES < 1000 READS)\".\n 01  TOTAL3.\n     05 FILLER     PIC X(29) VALUE \"0NO OF ACTIVE DISKS \".\n     05 W-NO-DISKS        PIC ZZ9.\n 01  TOTAL4.\n     05 FILLER     PIC X(29) VALUE \"0DASD FW RATIO OF TOTALS\".\n     05 W-FW-AVERAGE      PIC Z.99.\n 01  TOTAL5.\n     05 FILLER     PIC X(29) VALUE \"0AVERAGE OF FW RATIOS \".\n     05 W-FW-AVERAGE2     PIC Z.99.\n 01  TOTAL6.\n     05 FILLER     PIC X(29) VALUE \"0NO OF FW ACTIVE DISKS \".\n     05 W-NO-FW-DISKS        PIC ZZ9.\n     EJECT\n PROCEDURE DIVISION.\n********************\n 010M-MAINLINE SECTION.\n***********************\n     OPEN INPUT  A100-CARDFILE\n                 A200-CARDFILE.\n     OPEN OUTPUT B100-PRINTFILE\n                 B300-DISKFILE\n                 B400-PRINTFILE.\n     READ A100-CARDFILE\n       AT END\n       CALL \"X\".\n     IF A1-X NOT = \"X\"\n       CALL \"X\".\n     READ A200-CARDFILE\n       AT END\n       CALL \"X\".\n     IF A2-X NOT = \"X\"\n       CALL \"X\".\n     MOVE A1-DATE TO T-DATE.\n     PERFORM 050D-SET-MONTH.\n     WRITE P-PRINTLINE1 FROM TITLE1  AFTER POSITIONING P1-CC.\n     WRITE P-PRINTLINE1 FROM TITLE1A AFTER POSITIONING P1-CC.\n     WRITE P-PRINTLINE4 FROM TITLE1  AFTER POSITIONING P4-CC.\n     WRITE P-PRINTLINE4 FROM TITLE1B AFTER POSITIONING P4-CC.\n     MOVE SPACES TO P-PRINTLINE1.\n     MOVE SPACES TO P-PRINTLINE4.\n     WRITE P-PRINTLINE1 AFTER POSITIONING P1-CC.\n     WRITE P-PRINTLINE4 AFTER POSITIONING P4-CC.\n     PERFORM 015D-READ THRU 015D-READ-EXIT.\n     COMPUTE W-TOT-GRAND = W-TOT-CACHE / W-TOT-READS.\n* EXCLUDE DISKS WITH LESS THAN 1000 READS\n     COMPUTE W-TOT-RATIO = (W-ACC-RATIO - W-ACC-RATIO-EX)\n                         / (W-DISKS - W-DISKS-EX).\n     IF W-TOT-FW-WRITES = 0\n         MOVE 0 TO W-FW-TOT-GRAND\n     ELSE\n         COMPUTE W-FW-TOT-GRAND = W-TOT-FW / W-TOT-FW-WRITES.\n     IF W-FW-DISKS = 0\n         MOVE 0 TO W-FW-TOT-RATIO\n     ELSE\n         COMPUTE W-FW-TOT-RATIO = W-FW-ACC-RATIO / W-FW-DISKS.\n     MOVE W-TOT-GRAND TO W-AVERAGE.\n     MOVE W-FW-TOT-GRAND TO W-FW-AVERAGE.\n     WRITE P-PRINTLINE1 FROM TOTAL1 AFTER POSITIONING P1-CC.\n     WRITE P-PRINTLINE4 FROM TOTAL4 AFTER POSITIONING P4-CC.\n     MOVE W-TOT-RATIO TO W-AVERAGE2.\n     MOVE W-FW-TOT-RATIO TO W-FW-AVERAGE2.\n     WRITE P-PRINTLINE1 FROM TOTAL2 AFTER POSITIONING P1-CC.\n     WRITE P-PRINTLINE4 FROM TOTAL5 AFTER POSITIONING P4-CC.\n     MOVE W-DISKS TO W-NO-DISKS.\n     MOVE W-FW-DISKS TO W-NO-FW-DISKS.\n     WRITE P-PRINTLINE1 FROM TOTAL3 AFTER POSITIONING P1-CC.\n     WRITE P-PRINTLINE4 FROM TOTAL6 AFTER POSITIONING P4-CC.\n     CLOSE A100-CARDFILE\n           A200-CARDFILE\n           B100-PRINTFILE\n           B300-DISKFILE\n           B400-PRINTFILE.\n     STOP RUN.\n 010M-EXIT.\n     EXIT.\n 015D-READ SECTION.\n     READ A100-CARDFILE\n       AT END\n       GO TO 015D-READ-EXIT.\n     READ A200-CARDFILE\n       AT END\n       GO TO 015D-READ-EXIT.\n     IF A1-DISK NOT = A2-DISK\n        DISPLAY \"FILE MISMATCH \" A1-DISK A2-DISK\n        CALL \"X\".\n     COMPUTE W1-TOTREAD = A2-TOTREAD - A1-TOTREAD.\n     COMPUTE W1-TOTWRIT = A2-TOTWRIT - A1-TOTWRIT.\n     COMPUTE W1-TOTCACH = A2-TOTCACH - A1-TOTCACH.\n     COMPUTE W1-TOTFW   = A2-TOT-FW  - A1-TOT-FW.\n     MOVE W1-TOTREAD TO P1-TOTREAD.\n     MOVE W1-TOTCACH TO P1-TOTCREAD.\n     MOVE W1-TOTWRIT TO P1-TOTWRITE.\n     IF W1-TOTREAD = 0 AND W1-TOTWRIT = 0\n         MOVE 0 TO W-RP-RATIO\n     ELSE\n          COMPUTE W-RP-RATIO = W1-TOTREAD\n                            / (W1-TOTREAD + W1-TOTWRIT).\n     IF W1-TOTWRIT = 0\n         MOVE 0 TO W-RW-RATIO\n     ELSE\n          COMPUTE W-RW-RATIO = W1-TOTREAD / W1-TOTWRIT.\n     IF W1-TOTREAD = 0\n         MOVE 0 TO W-READ-RATIO\n     ELSE\n         COMPUTE W-READ-RATIO = W1-TOTCACH / W1-TOTREAD.\n     IF W1-TOTWRIT = 0\n         MOVE 0 TO W-FW-RATIO\n     ELSE\n         COMPUTE W-FW-RATIO = W1-TOTFW /  W1-TOTWRIT.\n     MOVE A1-DISK TO P1-DISK.\n     MOVE A1-DISK TO P4-DISK.\n     IF (W1-TOTREAD NOT = 0 AND W1-TOTCACH NOT = 0)\n       AND A1-ACTIVE NOT = \"DEACTIVATED\"\n         COMPUTE W-ACC-RATIO = W-ACC-RATIO + W-READ-RATIO\n         ADD W1-TOTREAD TO W-TOT-READS\n         ADD W1-TOTCACH TO W-TOT-CACHE\n         ADD 1 TO W-DISKS.\n     IF (W1-TOTREAD < 1000 AND W1-TOTCACH NOT = 0)\n       AND A1-ACTIVE NOT = \"DEACTIVATED\"\n         COMPUTE W-ACC-RATIO-EX = W-ACC-RATIO-EX + W-READ-RATIO\n         ADD 1 TO W-DISKS-EX.\n     IF W1-TOTFW NOT = 0\n       AND A1-FW-ACTIVE NOT = \"DEACTIVATED\"\n         COMPUTE W-FW-ACC-RATIO = W-FW-ACC-RATIO + W-FW-RATIO\n         ADD W1-TOTFW TO W-TOT-FW\n         ADD W1-TOTWRIT TO W-TOT-FW-WRITES\n         ADD 1 TO W-FW-DISKS.\n     MOVE W-RP-RATIO TO P1-RP-RATIO.\n     MOVE W-RW-RATIO TO P1-RW-RATIO.\n     MOVE W-READ-RATIO TO P1-CACHE.\n     MOVE A1-ACTIVE TO P1-ACTIVE.\n     WRITE P-PRINTLINE1 AFTER POSITIONING P1-CC.\n     MOVE SPACES TO P-PRINTLINE1.\n     MOVE W-FW-RATIO TO P4-FW-RATIO.\n     MOVE W1-TOTFW TO P4-FW-WRITE.\n     MOVE W1-TOTWRIT TO P4-TOT-WRITE.\n     MOVE A1-FW-ACTIVE TO P4-ACTIVE.\n     WRITE P-PRINTLINE4 AFTER POSITIONING P4-CC.\n     MOVE SPACES TO P-PRINTLINE4.\n     MOVE W-DATE TO B3-DATE.\n     MOVE A1-DISK TO B3-DISK.\n     MOVE W-RP-RATIO TO B3-RP.\n     MOVE W-READ-RATIO TO B3-RH.\n     MOVE W-RW-RATIO TO B3-RW.\n     MOVE A1-ACTIVE TO B3-DA.\n* The following code assists in sorting the DASD devices into a\n* desired order based on the device number.\n    IF B3-DISK-NUM < \"700\"\n        MOVE \"2\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"71A\"\n           MOVE \"1\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"710\"\n           MOVE \"4\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"72A\"\n           MOVE \"3\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"720\"\n           MOVE \"6\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"73A\"\n           MOVE \"5\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"730\"\n           MOVE \"8\" TO B3-SORT-IND\n    ELSE\n       MOVE \"7\" TO B3-SORT-IND.\n    MOVE W1-TOTREAD TO B3-TOT-READ.\n    MOVE W1-TOTCACH TO B3-TOT-CACH.\n    MOVE W1-TOTWRIT TO B3-TOT-WRIT.\n    MOVE W1-TOTFW TO B3-TOT-FW.\n    MOVE W-FW-RATIO TO B3-FW-RATIO\n    MOVE A1-FW-ACTIVE TO B3-FW-ACT.\n    WRITE B3-LINE.\n    GO TO 015D-READ.\n015D-READ-EXIT.\n    EXIT.\n050D-SET-MONTH SECTION.\n    MOVE T-DATE-DD TO W-DATE-DD.\n    MOVE T-DATE-YY TO W-DATE-YY.\n    IF T-DATE-MM = 01\n        MOVE \"JAN\" TO W-DATE-MM.\n    IF T-DATE-MM = 02\n        MOVE \"FEB\" TO W-DATE-MM.\n    IF T-DATE-MM = 03\n        MOVE \"MAR\" TO W-DATE-MM.\n    IF T-DATE-MM = 04\n        MOVE \"APR\" TO W-DATE-MM.\n    IF T-DATE-MM = 05\n        MOVE \"MAY\" TO W-DATE-MM.\n    IF T-DATE-MM = 06\n        MOVE \"JUN\" TO W-DATE-MM.\n    IF T-DATE-MM = 07\n        MOVE \"JUL\" TO W-DATE-MM.\n    IF T-DATE-MM = 08\n        MOVE \"AUG\" TO W-DATE-MM.\n    IF T-DATE-MM = 09\n        MOVE \"SEP\" TO W-DATE-MM.\n    IF T-DATE-MM = 10\n        MOVE \"OCT\" TO W-DATE-MM.\n    IF T-DATE-MM = 11\n        MOVE \"NOV\" TO W-DATE-MM.\n    IF T-DATE-MM = 12\n        MOVE \"DEC\" TO W-DATE-MM.\n050D-SET-MONTH-EXIT.\n    EXIT.\n\nSAS code for the step that stores the data for later processing is\nshown below.\n\n* CACHEUPD - CACHE RATIO FILE UPDATE PROGRAM;\n* PRODUCTION CODE;\nTSO ALLOC F(SASE) DA(dataset for storing cache data) OLD; RUN;\nOPTIONS NOFMTERR;\nOPTIONS NOTEXT82;\nDATA CACHE;\nINFILE SASD;\nINPUT\n     @1   DATE DATE7.\n     @8   DISKNAME $6.\n     @15  DISKNUM  $3.\n     @19  READPROP 3.2\n     @22  READHIT  3.2\n     @25  READWRIT 7.2\n     @32  ACTIVE   $1.\n     @33  TOTREAD  8.\n     @41  TOTCACH  8.\n     @49  TOTWRIT  8.\n     @57  SORTIND  $1.\n     @58  FWACTIVE $1.\n     @59  FWRATIO  3.2\n     @62  TOTFW    8.\n     ;\nRUN;\nPROC SORT NODUP DATA = CACHE;\nBY DATE SORTIND DISKNUM;\nRUN;\nPROC SORT NODUP DATA = SASE.CACHERAT;\nBY DATE SORTIND DISKNUM;\nRUN;\nDATA SASE.CACHERAT;\nUPDATE SASE.CACHERAT (IN=ODSET)\n       WORK.CACHE (IN =IDSET) ;\nBY DATE SORTIND DISKNUM;\nOUTPUT SASE.CACHERAT;\nRUN;\nTSO FREE  F(SASE); RUN;\n\n\nJohn Larry\nPerformance Analyst\nZurich Insurance Company (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A006A02": {"ttr": 7177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\xc2\\x00\\xc2\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 194, "newlines": 194, "modlines": 0, "user": "VSAMUPD"}, "text": "CICS VSAM files - testing definitions\n\n\nINTRODUCTION\n\nThe task of defining VSAM files is highly complex and very\ndifficult because of the number of parameters available. The\nhigh number of parameters is necessary to give VSAM the\nflexibility to adapt to the requirements of a large number of end\nuser sites. An additional complication is that files often have to\nbe able to satisfy the demands of both on-line and batch\nenvironments.\n\nThe definition of a VSAM file is normally implemented using\nspecimens supplied by IBM, software suppliers, system\nanalysts, or VSAM experts, coupled with the experience of the\nindividual defining the VSAM file. Unfortunately, even then a\nfile can turn out to be poorly defined once it has been used for\na period of time, primarily because it is difficult to anticipate\nthe activity on the file after the initial loading.\n\nThis problem does not normally occur in batch environments\nbecause it is possible to carry out a large number of test runs\nand examine the impact of those tests on the file. The file can\nthen be redefined and the tests repeated allowing the definition\nof the file to be fine-tuned to provide the optimum\nperformance.\n\nSuppliers, such as Macro 4, with their VSAMTUNE product\nallow the activity of files to be monitored over a long period of\ntime and they provide recommendations for the VSAM\ndefinitions for both CICS and batch files. However, the cost of\nthese products is a major consideration for some organizations.\n\nThis article describes a very simple and cheap method of\nemulating CICS file activity to allow files to be tuned for\noptimum performance during the CICS on-line day.\n\n\nREQUIREMENTS\n\nAll organizations that have CICS systems containing critical\nVSAM files which are updated on-line should log update\nactivity to user journals. Furthermore, they should also have\ndisaster recovery plans that include the use of the user journals\nto allow forward recovery to be carried out on files in the event\nof the loss of a disk pack during the on-line day, or other such\ncatastrophes. Consequently there should be no changes\nrequired to a CICS system to allow this procedure to be utilized\nto emulate CICS file activity.\n\nAt many organizations, the disaster recovery plans are rarely\ntested. However, if this technique is used to assist in\ndetermining the preferred VSAM file definitions, any forward\nrecovery programs used will also be tested as an additional\nbonus.\n\nIt has already been stated that no changes should be required to\na CICS system to use this technique. However some sites\nmight not journal to user journals or have any programs on-site\nto allow forward recovery processing to take place. This might\nbe because the organization considers the data in the files to be\nnon-critical and therefore cannot justify the overhead of user\njournalling and the cost of a forward recovery program. In this\ncase, the organization should reconsider its requirements\nbecause several CICS experts consider user journalling and the\nability to carry out forward recovery essential.\n\nThe technique is basically very simple and only requires the\nfollowing steps to be carried out:\n\n1      Produce a back-up of the file to be tuned.\n\n2      Produce a LISTCAT, or the equivalent, of the file before\n      the start of the on-line day.\n\n3      Produce a LISTCAT of the file at the end of the on-line day.\n\n4      Secure the user journals used during the on-line day.\n\n5      Restore the file backed up in step 1 (with a new name for\n      the cluster, data, and index components - to avoid accidents!).\n\n6      Produce a LISTCAT of the loaded file.\n\n7      Run the forward recovery program against the loaded file\n      using the secured user journals in step 4.\n\n8      Produce a LISTCAT of the recovered file. Steps 7 and 8\n      will have generated a set of figures to allow future\n      comparisons to be made.\n\n9      Delete the recovered file.\n\n10      Produce a new VSAM definition for the file.\n\n11      Restore the file backed up in step 1 to the new definition.\n\n12      Produce a LISTCAT of the loaded file.\n\n13      Run the forward recovery program against the new VSAM\n      definition using the secured user journals in step 4.\n\n14      Produce a LISTCAT of the forward recovered file.\n\n15      Compare the forward recovery jobs in steps 7 and 13 (for\n      example note the amount of CPU used and the number of\n      EXCPs performed).\n\n16      Compare the LISTCATs produced in steps 8 and 14. (For\n      example note the number of Control Interval and Control\n      Area splits for both data and index, the number of EXCPs\n      for both data and index, and the number of index levels.)\n\n17      Repeat steps 9 through 16 until an optimized VSAM\n      definition has been produced which minimizes the number\n      of Control Interval and Control Area splits, the number of\n      EXCPs performed, and the number of index levels. There\n      might be other factors which other sites would prefer to optimize.\n\n\nAdditional Features of the Testing Procedures.\n\nIf necessary, the above procedure can be adapted to mimic the\non-line activity over a longer period, such as a week. This\nmight allow an organization to increase the time between\nlengthy re-organizations of files with the confidence of\nknowing that the file structures have been tested to last for that\nextended time period.\n\nSome organizations have products which journal batch activity\non VSAM files. In this case the technique described above can\nalso be used to optimize the structure of batch VSAM files\nwithout having to re-run whole batch suites, and resetting\ninternal and external indicators within that batch suite to allow\nrepeated runs to be allowed.\n\nIn both cases, batch and on-line files can be tuned, either\nindividually or together, in logically related groups.\n\nOther file access methods which support user journalling can\nalso be tested with the same technique with little change to the\nmethodology used.\n\n\nINTERPRETING THE RESULTS\n\nIt is also necessary to issue a word of caution. This technique\ncannot be used to represent on-line CICS activity. The only\nvalid conclusions which can be made relate to the structure of\nthe VSAM file. It is not possible to extrapolate a low CPU and\nlow EXCP count from the forward recovery job into the CICS\nenvironment. This is because the forward recovery job will be\nsingle threaded while CICS is a multitasking environment.\nHowever, good performance during the forward recovery\nprocessing might be indicative of better performance during on-\nline processing.\n\n\nCONCLUSION\n\nThe method described in this article can be used to fine tune\nVSAM files to optimize their performance within the CICS\nenvironment, and in some cases the batch environment as well.\nThe procedure described, if used correctly, can reduce the\nnumber of on-line Control Interval and Control Area splits\nwhich occur during the on-line day. The benefits can be\nobserved immediately because any reduction in the number of\nControl Area and Control Interval splits is going to improve the\non-line response times simply because the CICS transactions\nwill not be waiting for those events to occur. A further benefit\nwill manifest itself in the reduction in the number of wait on\nstrings, because these can occur when CICS is waiting for a\nControl Area or Control Interval split to occur. This will reduce\nthe chances of requests for files queuing up. A further benefit\nis that the amount of CPU used will be reduced, because\nControl Interval and Control Area splits are CPU intensive\noperations. The final benefit is that gains can be made by\noptimizing the Control Interval sizes, simply because it is the\nControl Interval size which determines the size of the buffers\nused. Selective tuning of the Control Interval size can\nmaximize the number of records in the Control Interval and\nreduce contention in LSR buffer pools, so that the chances of a\nsuccessful lookaside increases. It should be stressed that these\nbenefits are the standard benefits which can be obtained by\nmonitoring and carefully tuning the files. The advantage of\nusing the technique described to define VSAM files is that it\nallows VSAM files to be redefined with the confidence that the\nnew definition is suitable for the large and varied amount of\nactivity which will take place in the on-line environment.\n\nD F Clark\nCICS Systems Programmer\nNorwich Union Insurance Group (UK)                        c D F Clark 1992\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A006A03": {"ttr": 7426, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x04%\\x04%\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 1061, "newlines": 1061, "modlines": 0, "user": "VSAMUPD"}, "text": "KSDS index component information\n\nThis is an Assembler program that will process the index\ncomponent of a KSDS using GETIX macros. Among other\ninformation, the calculated minimum requirement for the index\ncomponent CI size is computed using the worst case key\ncompression found.\n\nThis program will print the following data for every section:\n\no      Section number - relative to one\n\no      Number of entries in the section\n\no      The average number of bytes per stored key\n\no      The maximum number of bytes per stored key\n\no      The minimum number of bytes per stored key.\n\nFor every sequence set CI, the following data will be printed:\n\no      Number of unused vertical pointers\n\no      Number of keys currently stored in the CI\n\no      Number of bytes of unused space in the CI\n\no      The average number of bytes per stored key\n\no      The maximum number of bytes per stored key\n\no      The minimum number of bytes per stored key.\n\nFor every index set CI, the following data will be printed:\n\no      Number of keys currently stored in the CI\n\no      Number of bytes of unused space in the CI\n\no      The average number of bytes per stored key\n\no      The maximum number of bytes per stored key\n\no      The minimum number of bytes per stored key.\n\nThis program will, on reaching the end of the sequence set or\nindex set records, print the following data for the sequence set:\n\no      Total number of keys stored (this will not always be equal\n      to the number of data CIs in use because limited index\n      maintenance is performed on deletion of data)\n\no      The average number of bytes per stored key\n\no      The maximum number of bytes per stored key\n\no      The minimum number of bytes per stored key.\n\nFor the index set the following data is printed:\n\no      The average number of bytes per stored key\n\no      The maximum number of bytes per stored key\n\no      The minimum number of bytes per stored key.\n\nThe program will compute a suggested index component size\nusing the value from the sequence set record with the largest\naverage number of bytes per key. Following the sequence set\ntotals, a message will be output indicating whether the actual\nand computed value of the index component CI sizes agree or\nnot. The computed value may vary with a change in actual\nvalue for a specific object.\n\nVSAMIST  TITLE 'PROGRAM FOR PRINTING CONTROL INTERVAL AND OTHER STATS'\n         PRINT NOGEN\n         SPACE 1\n*        SUGGESTED JCL\n         SPACE 1\n*        //        EXEC PGM=VSAMIST\n*        //STEPLIB   DD DSN=MY.LOAD,DISP=SHR\n*        //SYSUDUMP  DD SYSOUT=*\n*        //SYSPRINT  DD SYSOUT=*\n*        //VSAM      DD DSN=CLUSTER.NAME,DISP=SHR\n         TITLE 'MACROS, DSECTS AND CONTROL BLOCKS USED'\n*        ABEND                          TO ABEND THE PROGRAM\n*        ACB                            ACCESS METHOD CONTROL BLOCK\n*        CLOSE                          CLOSE FILE(S)\n*        DCB                            DATA CONTROL BLOCK\n*        DCBD (IHADCB)                  DCB DSECT FOR MAPPING DCB\n*        FREEMAIN                       RELEASE STORAGE\n*        FREEPOOL                       RELEASE BUFFER POOL\n*        GETIX                          GET A VSAM INDEX CI\n*        GETMAIN                        ACQUIRE STORAGE\n*        IDAAMB                         DSECT MAPPING THE AMB\n*        IDAAMBL                        DSECT MAPPING THE AMBL\n*        IDAAMDSB                       DSECT MAPPING THE AMDSB\n*        IEFJFCBN                       DSECT MAPPING THE JFCB\n*        IFGACB                         DSECT MAPPING THE ACB\n*        OPEN                           PREPARE FILE(S) FOR PROCESSING\n*        PUT - QSAM                     WRITE A RECORD\n*        RPL                            VSAM REQUEST PARAMETER LIST\n*        SHOWCB                         OBTAIN DATA FROM A VSAM CB\n*        TESTCB                         TEST DATA IN A VSAM CB\n*        WTO                            WRITE TO OPERATOR\n         SPACE 1\n*        REGISTER EQUATES\n         SPACE 1\n\nEditor's note: register equates go here.\n\n         TITLE 'PROGRAM MAIN LINE CODE'\n*        1.    PROGRAM INITIALIZATION\n*        2.    PERFORM INITIAL PROCESSING\n*        3.    PERFORM MAIN PROCESSING\n*        4.    PERFORM TERMINATION PROCESSING\n*        5.    PROGRAM TERMINATION\n*\n*        REGISTER USAGE\n*        0     USED BY MACROS\n*        1     USED BY MACROS\n*        2     WORK\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n*        11    PROGRAM BASE REGISTER #1\n*        12    PROGRAM BASE REGISTER #2\n*        13    ADDRESS OF SAVE AREA\n*        14    ADDRESS OF RETURN\n*        15    ENTRY POINT ADDRESS / RETURN CODE\n         SPACE 2\nVSAMIST  CSECT\n         STM   R14,R12,12(R13)          . SAVE CALLER'S REGISTERS\n         LR    R11,R15                  . 11 - PROGRAM BASE\n         USING VSAMIST,R11,R12          . ESTABLISH ADDRESSABILITY\n         LA    R12,4095(,R11)\n         LA    R12,1(,R12)\n         GETMAIN R,                     . ISSUE GETMAIN FOR SAVE AREA  C\n               LV=72\n         ST    R13,4(,R1)               . BACKWARD SAVE AREA ->\n         ST    R1,8(,R13)               . FORWARD SAVE AREA ->\n         LR    R13,R1                   . 13 -> SAVE AREA\n         BAS   R10,INITIAL              . INITIAL PROCESS\n         BAS   R10,PROCESS              . MAIN PROCESSING\n         BAS   R10,TERMIN               . TERMINATION PROCESSING\n         LR    R2,R13                   . 2 -> CURRENT SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN SAVE AREA           C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN\n         SLR   R15,R15                  . 15 - ZERO\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . EXIT\n         TITLE 'PROGRAM INITIALIZATION PROCESSING'\nINITIAL  EQU   *\n*\n*        1.    DO READ JFCB FOR VSAM CLUSTER NAME\n*        2.    OPEN FILES\n*        3.    CHECK OPENS\n*        4.    DETERMINE ATTRIBUTES OF VSAM OBJECT\n*        5.    ACCESS OBJECT'S INDEX AMDSB FOR RBAS\n*        6.    INITIALIZE DATA AREAS\n*\n*        REGISTER USAGE\n*        0     USED BY MACROS\n*        1     USED BY MACROS\n*        2     WORK\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n*        15    RETURN CODE\n         SPACE 2\nB0001    EQU   *\n*                                       . ISSUE READ JFCB FOR DSN\n         RDJFCB DUMMY                   . ISSUE READ JFCB\n         LTR   R15,R15                  . Q. RDJFCB OKAY?\n         BNZ   B0002                    . A. NO\n         MVC   DSNTITLE,JFCBDSNM        . MOVE OUT DSN\nB0002    EQU   *\n*                                       . OPEN FILES\n         OPEN  (VSAM,,SYSPRINT,OUTPUT)\n         LTR   R15,R15                  . Q. OPENS OKAY?\n         BZ    B0003                    . A. YES\n         LA    R2,SYSPRINT              . 2 -> SYSPRINT DCB\n         USING IHADCB,R2                . CHECK OPEN OF SYSPRINT\n         TM    DCBOFLGS,DCBOFOPN        . Q. OPEN OKAY?\n         BNO   B0008                    . A. NO - OPEN FAILED\n         DROP  R2                       . DCB DSECT NOT WANTED\n         LA    R2,VSAM                  . 2 -> VSAM ACB\n         USING IFGACB,R2                . CHECK OPEN OF VSAM\n         TM    ACBOFLGS,ACBOPEN         . Q. OPEN OKAY?\n         BNO   B0009                    . A. NO - ABEND\n         DROP  R2                       . ACB DSECT NOT WANTED\nB0003    EQU   *                        . CHECK FOR KSDS INPUT\n         TESTCB ACB=VSAM,                                              C\n               ATRB=KSDS                . Q. IS THIS A KSDS?\n         BNE   B0010                    . A. NO\n*                                       . DETERMINE INDEX OPTIONS\n         TESTCB ACB=VSAM,               . Q. SEQUENCE SET IMBEDDED?    C\n               ATRB=SSWD\n         BE    B0004                    . A. YES\n         MVC   IMBED,=C'NOIMBED'        . INDICATE NOT IMBEDDED\n         B     B0005\nB0004    EQU   *\n         MVC   IMBED,=C'IMBED  '        . INDICATE IMBEDDED\nB0005    EQU   *\n         TESTCB ACB=VSAM,               . Q. INDEX REPLICATED?         C\n               ATRB=REPL\n         BE    B0006                    . A. YES\n         MVC   REPL,=C'NOREPLICATE'     . INDICATE NOT REPLICATED\n         B     B0007\nB0006    EQU   *\n         MVC   REPL,=C'REPLICATE  '     . INDICATE REPLICATED\nB0007    EQU   *\n*                                       . DETERMINE INDEX CI SIZE,\n*                                       .   NUMBER OF LEVELS AND RDF\n*                                       .   DISPLACEMENT\n         SHOWCB ACB=VSAM,                                              C\n               AREA=CISZ,                                              C\n               FIELDS=(CINV,NIXL),                                     C\n               LENGTH=8,                                               C\n               OBJECT=INDEX\n         L     R2,CISZ                  . 2 - CI SIZE\n         SH    R2,=H'+7'                . SUBTRACT SEVEN FROM CI SIZE\n         STH   R2,RDFDISP               . SAVE RDF DISPLACEMENT\n         L     R2,CISZ                  . 2 - CI SIZE\n         CVD   R2,WORKD                 . PREPARE TO OUTPUT\n         MVC   TCISZ,MASK5\n         ED    TCISZ,WORKD+5\n         L     R2,INDXL                 . 2 - NUMBER OF INDEX LEVELS\n         CVD   R2,WORKD                 . PREPARE TO OUTPUT\n         MVC   TNIXL,MASK3\n         ED    TNIXL,WORKD+6\n*                                       . OBTAIN RBAS FROM AMDSB\n         LA    R2,VSAM                  . 2 -> ACB\n         USING IFGACB,R2                . MAP THE ACB\n         L     R2,ACBAMBL               . 2 -> AMBL\n         DROP  R2\n         USING IDAAMBL,R2               . MAP THE AMBL\n         L     R2,AMBLIX                . 2 -> AMB FOR INDEX COMPONENT\n         DROP  R2\n         USING IDAAMB,R2                . MAP THE AMB\n         L     R2,AMBDSB                . 2 -> AMDSB\n         DROP  R2\n         USING IDAAMDSB,R2              . MAP THE AMDSB\n         MVC   RBARPL,AMDSSRBA          . SEQUENCE SET RECORD RBA\n         MVC   RBASQSET,AMDSSRBA\n         MVC   RBAHLVL,AMDHLRBA         . HIGH-LEVEL RBA\n         LH    R2,AMDNEST               . 2 - ENTRIES PER SECTION\n         DROP  R2\n         CVD   R2,WORKD                 . CONVERT TO DECIMAL\n         MVC   TNEST,MASK3              . OUTPUT ENTRIES / SECTION\n         ED    TNEST,WORKD+6\n*                                       . INITIALIZE OTHER DATA AREAS\n         XC    KEYBYTES,KEYBYTES        . BYTES IN KEYS\n         XC    KEYNUMBR,KEYNUMBR        . NUMBER OF KEYS\n         MVI   LKEYDA,X'00'             . LONGEST KEY\n         MVI   SKEYDA,X'FF'             . SHORTEST KEY\n         ZAP   #CIREAD,=P'+0'           . CIS READ\n         ZAP   #LINE,=P'+60'            . LINES ON PAGE\n         ZAP   #PAGE,=P'+1'             . PAGE NUMBER\n         ZAP   SEC#,=P'+0'              . SECTION NUMBER\n         ZAP   SSAVGKEY,=P'+0'          . GREATEST AVERAGE KEY IN A CI\n         BR    R10                      . EXIT\n         TITLE 'ERROR ROUTINES - PROGRAM INITIALIZATION'\nB0008    EQU   *\n*                                       . OPEN FAILURE SYSPRINT\n         WTO   'OPEN FAILURE FOR FILE SYSPRINT',                       C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN FOR SAVE AREA       C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN\n         LA    R15,10                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . EXIT\n         SPACE 2\nB0009    EQU   *\n*                                       . OPEN FAILURE VSAM\n         ST    R15,REG15                . SAVE REGISTER 15\n         WTO   'OPEN FAILURE FOR FILE VSAM',                           C\n               ROUTCDE=11\n         SHOWCB ACB=VSAM,               . GET ACB ERROR CODE           *\n               AREA=OPENERR,                                           C\n               FIELDS=ERROR,                                           C\n               LENGTH=4\n         LM    R2,R3,VSAMERR            . 2 - 3 VSAM ERROR CODES\n         ABEND 100                      . ABEND\n         SPACE 2\nB0010    EQU   *\n*                                       . NON KSDS INPUT\n         WTO   'ONLY KSDS PROCESSED BY THIS PROGRAM',                  C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREE SAVE AREA               C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN\n         LA    R15,20                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         TITLE 'MAIN PROCESSING LOGIC OF PROGRAM'\nPROCESS  EQU   *\n*        1.    DIRECT GET FOR THE NEXT INDEX RECORD\n*        2.    PROCESS INDEX HEADER\n*        3.    PROCESS SEQUENCE SET RECORD\n*        4.    OUTPUT SEQUENCE SET TOTALS\n*        5.    PROCESS INDEX SET RECORD\n*        REGISTER USAGE\n*        0     USED BY MACROS\n*        1     USED BY MACROS\n*        2     WORK\n*        3     WORK\n*        4     ADDRESS OF CI READ\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n*        15    RETURN CODE\n         SPACE 2\nC0001    EQU   *\n         ST    R10,CSAVE                . SAVE CONTENT OF 10\nC0002    EQU   *\n         GETIX RPL=GETRPL               . GET THE INDEX CI\n         LTR   R15,R15                  . Q. GET OKAY?\n         BNZ   C0006                    . A. NO - GET FAILED\n*                                       . OUTPUT RBA OF INDEX RECORD\n         L     R2,RBARPL                . 2 - RBA OF CI\n         CVD   R2,WORKD\n         MVC   RBANUM,MASK9\n         ED    RBANUM,WORKD+3\n*                                       . PROCESS INDEX HEADER\n         L     R4,@CI                   . 4 -> CI\n         MVC   IXHFORM,0(R4)            . PULL INDEX HEADER\n         TR    IXHPTLS,PLTBL            . PROCESS VERTICAL POINTER\n         SLR   R2,R2                    .   SIZE\n         IC    R2,IXHPTLS               . 2 - SIZE OF VERTICAL POINTER\n         ST    R2,PTLS                  . SAVE POINTER LENGTH\n*                                       . DETERMINE PROCESSING\n         CLI   IXHLV,IXHSEQ             . Q. SEQUENCE SET RECORD?\n         BNE   C0004                    . A. NO\n         BAS   R10,SEQSET               . PROCESS SEQUENCE SET RECORD\n         OC    RBARPL,RBARPL            . Q. END OF SEQUENCE SET?\n         BNZ   C0002                    . A. NO\n*                                       . END OF SEQUENCE SET PROCESS\n         MVI   LINE1CI,C' '             . OUTPUT SEQUENCE SET TOTALS\n         MVC   LINE1CI+1(93),LINE1CI\n         MVC   LINE1CI(24),=C'0TOTALS FOR SEQUENCE SET'\n         L     R2,KEYNUMBR              . OUTPUT TOTAL KEYS IN SEQUENCE\n         CVD   R2,WORKD                 .   SET\n         MVC   PTRUSE,MASK5\n         ED    PTRUSE,WORKD+5\n         MVC   LINE1,LINE1CI\n         SLR   R2,R2                    . 2 - ZERO\n         IC    R2,LKEYDA                . OUTPUT LONGEST KEY IN\n         CVD   R2,WORKD                 .   SEQUENCE SET\n         MVC   MAXKEY,MASK3\n         ED    MAXKEY,WORKD+6\n         IC    R2,SKEYDA                . OUTPUT SHORTEST KEY IN\n         CVD   R2,WORKD                 .   SEQUENCE SET\n         MVC   MINKEY,MASK3\n         ED    MINKEY,WORKD+6\n         SLR   R2,R2                    . COMPUTE AVERAGE STORED KEY\n         L     R3,KEYBYTES              .   LENGTH\n         D     R2,KEYNUMBR\n         LTR   R2,R2                    . Q. REMAINDER ZERO?\n         BZ    C0003                    . A. YES\n         LA    R3,1(,R3)                . A. NO - INCREMENT AVG\nC0003    EQU   *\n         CVD   R3,WORKD\n         MVC   AVGKEY,MASK3\n         ED    AVGKEY,WORKD+6\n         BAS   R10,PRINTLN              . OUTPUT SEQUENCE SET TOTALS\n         MVI   LINE1CI,C' '             . RE-INITIALIZE OUTPUT LINE\n         MVC   LINE1CI+1(93),LINE1CI\n         MVI   LINE1CI,C'0'\n         BAS   R10,COMPICIS             . COMPUTE SUGGESTED INDEX\n*                                       .   COMPONENT CI SIZE\n         CLC   RBAHLVL,RBASQSET         . Q. HIGH-LEVEL RBA = SEQUENCE\n*                                       .   SET RBA?\n         BE    C0005                    . A. YES - NO INDEX SET\n*                                       . SET UP TO PROCESS INDEX SET\n         ZAP   #LINE,=P'+60'            . FORCE PAGE CHANGE\n         MVC   RBARPL,RBAHLVL           . HIGH-LEVEL RBA FOR GETIX\n         MVI   LEV#,X'00'               . INITIALIZE LEVEL NUMBER\n         XC    KEYNUMBR,KEYNUMBR        . INITIALIZE OTHER DATA\n         XC    KEYBYTES,KEYBYTES\n         MVI   LKEYDA,X'00'\n         MVI   SKEYDA,X'FF'\n         B     C0002                    . GO GET HIGH-LEVEL CI\n*                                       . INDEX SET PROCESSING\nC0004    EQU   *\n         BAS   R10,INDXSET              . PROCESS INDEX SET RECORD\n         CLI   LEV#,X'02'               . Q. LOWEST LEVEL INDEX SET?\n         BNE   C0002                    . A. NO - KEEP ON PROCESSING\n         OC    RBARPL,RBARPL            . Q. ANY MORE RECORDS?\n         BNZ   C0002                    . A. YES\nC0005    EQU   *\n         L     R10,CSAVE                . RESTORE 10\n         BR    R10                      . EXIT\n         TITLE 'ERROR ROUTINES - MAIN PROCESSING'\nC0006    EQU   *\n*                                       . GET FAILURE VSAM\n         ST    R15,REG15                . SAVE REGISTER 15\n         WTO   'GET FAILURE FOR FILE VSAM',                            C\n               ROUTCDE=11\n         SHOWCB RPL=GETRPL,             . GET RPL FEED BACK CODE       C\n               AREA=RPLFDBK,                                           C\n               FIELDS=FDBK,                                            C\n               LENGTH=4\n         LA    R3,VSAM                  . 3 -> ACB\n         LM    R2,R4,VSAMERR            . 2 - 4 VSAM ERROR CODES\n         ABEND 100                      . ABEND\n         TITLE 'END OF PROCESSING ROUTINE'\nTERMIN   EQU   *\n*        1.    CLOSE FILES\n*        2.    RELEASE BUFFER POOL\n*\n*        REGISTER USAGE\n*        0     USED BY MACROS\n*        1     USED BY MACROS\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n*        15    RETURN CODE\n         SPACE 2\nD0001    EQU   *\n         CLOSE (VSAM,,SYSPRINT)         . CLOSE FILES\n         FREEPOOL SYSPRINT              . RELEASE BUFFER POOL\n         BR    R10                      . EXIT\n         TITLE 'SEQUENCE SET PROCESSING'\nSEQSET   EQU   *\n*        1.    INCREMENT TOTALS\n*        2.    COMPUTE UNUSED VERTICAL POINTERS\n*        3.    PROCESS THE INDEX DATA\n*        4.    RETURN\n*\n*        REGISTER USAGE\n*        2     WORK\n*        3     WORK\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n         SPACE 2\nE0001    EQU   *\n         ST    R10,ESAVE                . SAVE 10\n         AP    #CIREAD,=P'+1'           . INCREMENT CIS READ\n         MVC   CINUM,MASK9              . OUTPUT CI NUMBER TO REPORT\n         ED    CINUM,#CIREAD\n*                                       . VERTICAL POINTER PROCESSING\n         MVC   HPTLS,IXHPTLS            . SAVE POINTER LENGTH\n         SLR   R2,R2                    . 2 - ZERO\n         LH    R3,IXHFSO                . 3 - FREE SPACE OFFSET\n         SH    R3,=H'+24'               . SUBTRACT LENGTH OF INDEX HDR\n*                                       . 3 - NUMBER OF BYTES IN PTRS\n         D     R2,PTLS                  . DIVIDE BY POINTER LENGTH\n         CVD   R3,WORKD                 . 3 - NUMBER OF UNUSED PTRS\n         MVC   PTRUNUSE,MASK5\n         ED    PTRUNUSE,WORKD+5\n         BAS   R10,CIPROC               . PROCESS THE INDEX DATA\n         CP    WORKD,SSAVGKEY           . Q. LONGEST AVG KEY SO FAR?\n         BNH   E0002                    . A. NO\n         MVC   SSAVGKEY,WORKD+4         . SAVE AVERAGE KEY LENGTH\nE0002    EQU   *\n         L     R10,ESAVE                . RESTORE 10\n         BR    R10                      . EXIT\n         TITLE 'INDEX SET RECORD PROCESSING'\nINDXSET  EQU   *\n*        1.    CHECK FOR CHANGE IN LEVEL\n*              IF CHANGE, DETERMINE RBA OF FIRST LOGICAL CI AT\n*              LOWER LEVEL\n*        2.    INCREMENT CI TOTAL\n*        3.    CHECK FOR END OF CIS AT CURRENT LEVEL\n*              IF AT END, CHECK LOWER LEVEL FOR SEQUENCE SET\n*              IF NOT SEQUENCE SET, GET SET TO CONTINUE\n*\n*        REGISTER USAGE\n*        2     WORK\n*        3     WORK\n*        4     ADDRESS OF INDEX CI\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n         SPACE 2\nF0001    EQU   *\n         ST    R10,FSAVE                . SAVE 10\n         CLC   LEV#,IXHLV               . Q. CHANGE IN INDEX LEVEL?\n         BE    F0002                    . A. NO\n         MVC   LEV#,IXHLV               . SAVE NEW INDEX LEVEL\n*                                       . DETERMINE RBA OF LOWER LEVEL\n         LH    R2,RDFDISP               . 2 - RDF DISPLACEMENT\n         LA    R2,0(R2,R4)              . 2 -> RDF\n         SH    R2,=H'+3'                . 2 -> VERTICAL POINTER\n*                                       . (3 BYTE VERTICAL POINTER)\n         SLR   R3,R3                    . 3 - ZERO\n         ICM   R3,7,0(R2)               . 3 - LOWER LEVEL CI NUMBER\n         M     R2,CISZ                  . 3 - RBA OF LOWER LEVEL CI\n         ST    R3,RBANXLVL              . SAVE RBA OF LOWER LEVEL CI\n         ZAP   #CIREAD,=P'+0'           . RESET CI ACCUMULATOR\nF0002    EQU   *\n*                                       . PROCESS\n         AP    #CIREAD,=P'+1'           . INCREMENT CIS AT THIS LEVEL\n         MVC   CINUM,MASK9              . OUTPUT CI NUMBER\n         ED    CINUM,#CIREAD\n         BAS   R10,CIPROC               . PROCESS THE INDEX DATA\n*                                       . END OF THIS LEVEL PROCESS\n         OC    RBARPL,RBARPL            . Q. NEXT CI RBA ZERO?\n         BNZ   F0003                    . A. NO\n         CLI   LEV#,X'02'               . Q. LOWEST LEVEL INDEX SET?\n         BE    F0003                    . A. YES - TERMINATE\n         MVC   RBARPL,RBANXLVL          . LOAD RPL FOR LOWER LEVEL\nF0003    EQU   *\n         L     R10,FSAVE                . RESTORE 10\n         BR    R10                      . EXIT\n         TITLE 'INDEX CONTROL INTERVAL INDEX ENTRY PROCESSING'\nCIPROC   EQU   *\n*        1.    PROCESS INDEX HEADER\n*        2.    PROCESS INDEX ENTRIES\n*        3.    PRINT RESULTS\n*\n*        REGISTER USAGE\n*        0     BCTR INSTRUCTIONS\n*        2     WORK\n*        3     WORK\n*        4     ADDRESS OF INDEX CI\n*        5     ADDRESS OF CONTROL INFORMATION - CURRENT SECTION\n*        6     ADDRESS OF CONTROL INFORMATION - HIGH-KEY SECTION\n*        7     ADDRESS OF CURRENT POSITION IN CI\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n         SPACE 2\nG0001    EQU   *\n         ST    R10,GSAVE                . SAVE 10\n*                                       . OUTPUT INDEX LEVEL\n         SLR   R2,R2                    . 2 - ZERO\n         IC    R2,IXHLV                 . 2 - INDEX LEVEL\n         CVD   R2,WORKD\n         MVC   RIXL,MASK3\n         ED    RIXL,WORKD+6\n*                                       . COMPUTE UNUSED SPACE\n         LH    R3,IXHFSO                . 3 - FREE SPACE OFFSET\n         LA    R2,0(R3,R4)              . 2 -> FREE SPACE\n         ST    R2,@FREE                 . SAVE ADDRESS OF FREE SPACE\n         LH    R3,IXHLEO                . 3 - DISPLACEMENT OF CONTROL\n*                                       .   INFORMATION IN LEFT-MOST\n*                                       .   INDEX ENTRY\n         LA    R2,1(R3,R4)              . 2 -> CONTROL INFORMATION\n*                                       .   LENGTH OF LEFT MOST KEY\n         SLR   R3,R3                    . 3 - ZERO\n         IC    R3,0(,R2)                . 3 - LENGTH OF LEFT MOST KEY\n         LA    R3,1(,R3)                . INCREMENT LENGTH BY ONE\n         SLR   R2,R3                    . 2 -> LEFT-MOST KEY\n         S     R2,@FREE                 . 2 - LENGTH OF UNUSED SPACE\n         CVD   R2,WORKD\n         MVC   UNUSEDSP,MASK5\n         ED    UNUSEDSP,WORKD+5\n*                                       . PROCESS INDEX ENTRIES\n         XC    CIKEYNUM,CIKEYNUM        . INITIALIZE CI ACCUMULATORS\n         XC    CIKEYBYT,CIKEYBYT\n         MVI   LKEYCI,X'00'\n         MVI   SKEYCI,X'FF'\n         XC    SCKEYNUM,SCKEYNUM        . INITIALIZE SECTION ACCUMS\n         XC    SCKEYBYT,SCKEYBYT\n         MVI   LKEYSC,X'00'\n         MVI   SKEYSC,X'FF'\n         ZAP   SEC#,=P'+1'\n         LH    R7,RDFDISP               . 7 - DISPLACEMENT OF RDF\n         LA    R7,0(R7,R4)              . 7 -> RDF\n         LH    R5,IXHSEO                . 5 - DISPLACEMENT OF HIGHEST\n*                                       .   INDEX ENTRY IN FIRST\n*                                       .   (RIGHT-MOST) SECTION\n         LA    R5,0(R5,R4)              . 5 -> END OF FIRST SECTION\n         LH    R6,IXHLEO                . 6 - DISPLACEMENT OF LAST\n*                                       .   INDEX ENTRY\n         LA    R6,0(R6,R4)              . 6 -> LAST INDEX ENTRY\n*        INDEX CI - SCENARIO\n*        --------------------------------------------------------\n*        *            *         *            *         *      *R*\n*        *            * LAST    *            *         *FIRST *D*\n*        *            * SECTION *            *         *SECT. *F*\n*        --------------------------------------------------------\n*        |             |                                |      |\n*        R4            R6                               R5     R7\n*\nG0002    EQU   *\n*                                       . PROCESS LOOP POINT\n         S     R7,PTLS                  . 7 -> VERTICAL PTR (IBPLP3)\n         BCTR  R7,R0                    . 7 -> LENGTH OF KEY (IBPFLPL)\n         SLR   R2,R2                    . 2 - ZERO\n         IC    R2,0(,R7)                . 2 - LENGTH OF KEY\n         ST    R2,CURKEYL               . SAVE KEY LENGTH\n         L     R2,SCKEYNUM              . INCREMENT KEYS IN SECTION\n         LA    R2,1(,R2)\n         ST    R2,SCKEYNUM\n         CLC   CURKEYL+3(1),SKEYSC      . Q. SHORTEST KEY IN SECTION?\n         BNL   *+10                     . A. NO\n         MVC   SKEYSC,CURKEYL+3         . UPDATE\n         CLC   CURKEYL+3(1),LKEYSC      . Q. LONGEST KEY IN SECTION?\n         BNH   *+10                     . A. NO\n         MVC   LKEYSC,CURKEYL+3         . UPDATE\n         L     R2,CURKEYL               . 2 - KEY LENGTH\n         A     R2,SCKEYBYT              . INCREMENT BYTES IN KEYS\n         ST    R2,SCKEYBYT              .   WITHIN THIS SECTION\n         BCTR  R7,R0                    . 7 -> FRONT KEY COMPRESSION\n*                                       .   COUNT (IBFLPF)\n         L     R2,CURKEYL               . 2 - KEY LENGTH\n         SR    R7,R2                    . 7 -> KEY\n         CR    R7,R5                    . Q. END OF SECTION?\n         BH    G0002                    . A. NO - LOOP ON\n*                                       . END OF SECTION - TOTALS\n         MVC   RSEC#,MASK5\n         ED    RSEC#,SEC#               . SECTION NUMBER\n         L     R2,SCKEYNUM              . 2 - NUMBER OF KEYS IN SECTION\n         CVD   R2,WORKD\n         MVC   RSECENT,MASK3\n         ED    RSECENT,WORKD+6\n         SLR   R2,R2                    . 2 - ZERO\n         IC    R2,LKEYSC                . 2 - LONGEST KEY IN SECTION\n         CVD   R2,WORKD\n         MVC   MAXKEY,MASK3\n         ED    MAXKEY,WORKD+6\n         IC    R2,SKEYSC                . 2 - SHORTEST KEY IN SECTION\n         CVD   R2,WORKD\n         MVC   MINKEY,MASK3\n         ED    MINKEY,WORKD+6\n*                                       . COMPUTE AVERAGE KEY LENGTH\n         SLR   R2,R2                    . 2 - ZERO\n         L     R3,SCKEYBYT              . 3 - TOTAL BYTES IN KEYS\n         D     R2,SCKEYNUM              . COMPUTE AVERAGE KEY LENGTH\n         LTR   R2,R2                    . Q. REMAINDER ZERO?\n         BZ    G0003                    . A. YES\n         LA    R3,1(,R3)                . A. NO - INCREMENT AVG\nG0003    EQU   *\n         CVD   R3,WORKD\n         MVC   AVGKEY,MASK3\n         ED    AVGKEY,WORKD+6\n         BAS   R10,PRINTLN              . OUTPUT SECTION DATA\n*                                       . UPDATE TOTALS FOR CI\n         L     R3,SCKEYNUM              . NUMBER OF KEYS\n         A     R3,CIKEYNUM\n         ST    R3,CIKEYNUM\n         L     R3,SCKEYBYT              . BYTES IN KEYS\n         A     R3,CIKEYBYT\n         ST    R3,CIKEYBYT\n         CLC   LKEYSC,LKEYCI            . Q. LONGEST KEY\n         BNH   *+10                     . A. NO\n         MVC   LKEYCI,LKEYSC\n         CLC   SKEYSC,SKEYCI            . Q. SHORTEST KEY\n         BNL   *+10                     . A. NO\n         MVC   SKEYCI,SKEYSC\n*                                       . RE-INITIALIZE SECTION ACCUMS\n         XC    SCKEYNUM,SCKEYNUM\n         XC    SCKEYBYT,SCKEYBYT\n         MVI   LKEYSC,X'00'\n         MVI   SKEYSC,X'FF'\n         AP    SEC#,=P'+1'              . INCREMENT SECTION NUMBER\n*                                       . PROCESS SECTION POINTER\n         CR    R7,R6                    . Q. END OF KEYS?\n         BNH   G0004                    . A. YES\n         SH    R7,=H'+2'                . 7 -> SECTION POINTER\n         ICM   R2,3,0(R7)               . 2 - OFFSET OF HIGH KEY IN\n*                                       .   NEXT SECTION\n         SLR   R5,R2                    . 5 -> HIGH KEY IN NEXT SECTION\n         B     G0002                    . PROCESS NEXT SECTION\nG0004    EQU   *\n*                                       . OUTPUT CI TOTALS\n         L     R2,CIKEYNUM              . 2 - NUMBER OF KEYS\n         CVD   R2,WORKD\n         MVC   PTRUSE,MASK5\n         ED    PTRUSE,WORKD+5\n         SLR   R2,R2                    . 2 - ZERO\n         IC    R2,LKEYCI                . 2 - LONGEST KEY\n         CVD   R2,WORKD\n         MVC   MAXKEY,MASK3\n         ED    MAXKEY,WORKD+6\n         IC    R2,SKEYCI                . 2 - SHORTEST KEY\n         CVD   R2,WORKD\n         MVC   MINKEY,MASK3\n         ED    MINKEY,WORKD+6\n         SLR   R2,R2                    . COMPUTE AVERAGE KEY LENGTH\n         L     R3,CIKEYBYT              . 3 - TOTAL BYTES IN KEYS\n         D     R2,CIKEYNUM              . 3 - AVERAGE KEY LENGTH\n         LTR   R2,R2                    . Q. REMAINDER ZERO?\n         BZ    G0005                    . A. YES\n         LA    R3,1(,R3)                . A. NO - INCREMENT AVG\nG0005    EQU   *\n         CVD   R3,WORKD\n         MVC   AVGKEY,MASK3\n         ED    AVGKEY,WORKD+6\n         MVC   LINE1,LINE1CI            . OUTPUT CI TOTALS\n         BAS   R10,PRINTLN\n         MVI   LINE1,C'0'               . RESET ASA CONTROL CHARACTER\n*                                       . INCREMENT TOTALS FOR LEVEL\n         L     R2,CIKEYNUM              . NUMBER OF KEYS\n         A     R2,KEYNUMBR\n         ST    R2,KEYNUMBR\n         L     R2,CIKEYBYT              . BYTES USED IN KEYS\n         A     R2,KEYBYTES\n         ST    R2,KEYBYTES\n         CLC   SKEYCI,SKEYDA            . Q. SHORTEST KEY SO FAR?\n         BNL   *+10                     . A. NO\n         MVC   SKEYDA,SKEYCI\n         CLC   LKEYCI,LKEYDA            . Q. LONGEST KEY SO FAR?\n         BNH   *+10                     . A. NO\n         MVC   LKEYDA,LKEYCI            . UPDATE\n*                                       . UPDATE RBA SPECIFIED IN RPL\n         MVC   RBARPL,IXHHP             . HORIZONTAL POINTER\n         L     R10,GSAVE                . RESTORE 10\n         BR    R10                      . EXIT\n         TITLE 'COMPUTE AND OUTPUT SUGGESTED INDEX COMPONENT CI SIZE'\nCOMPICIS EQU   *\n*        1.    COMPUTE SUGGESTED INDEX COMPONENT CI SIZE\n*        2.    COMPARE COMPUTED VALUE WITH ACTUAL\n*        3.    IF ACTUAL LESS, OUTPUT MESSAGE\n*        4.    IF ACTUAL GREATER, OUTPUT MESSAGE\n*\n*        FORMULAE USED:\n*        A.    INDEX CI SIZE >= 31\n*                             + (2 * NUMBER OF SECTIONS)\n*                             + (INDEX ENTRY LENGTH * DATA CI/CA)\n*              WHERE THE NUMBER OF SECTIONS IS THE NUMBER OF DATA\n*              COMPONENT CIS PER CA DIVIDED BY THE SQUARE ROOT OF\n*              THE NUMBER OF DATA COMPONENT CIS PER CA\n*\n*        B.    NEWTON-RAPHESON METHOD FOR SQUARE ROOT APPROXIMATION\n*                  1.   FIRST APPROXIMATION - HALF THE INTEGER\n*                  2.   BETTER APPROXIMATIONS\n*                       Y{I + 1} = Y{I} + ((( X / Y{I}) - Y{I}) / 2)\n*\n*                       WHERE X        IS THE NUMBER TO BE ROOTED\n*                             Y{I}     IS THE CURRENT APPROXIMATION\n*                             Y{I + 1} IS A BETTER APPROXIMATION\n*                       THE PROCESS TERMINATES WHEN THE CORRECTION\n*                       FACTOR IS LESS THAN ONE.  ALL VALUES USED\n*                       ARE INTEGERS\n*\n*        REGISTER USAGE\n*        2     WORK\n*        7     WORK\n*        8     WORK\n*        9     WORK\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n         SPACE 2\nH0001    EQU   *\n         STM   R7,R10,HSAVE             . SAVE REGISTERS\n         LA    R2,VSAM                  . 2 -> ACB\n         USING IFGACB,R2                . DSECT ADDRESSABILITY\n         L     R2,ACBAMBL               . 2 -> AMBL\n         DROP  R2\n         USING IDAAMBL,R2               . DSECT ADDRESSABILITY\n         L     R2,AMBLDTA               . 2 -> DATA COMPONENT AMB\n         DROP  R2\n         USING IDAAMB,R2                . DSECT ADDRESSABILITY\n         L     R2,AMBDSB                . 2 -> AMDSB\n         DROP  R2\n         USING IDAAMDSB,R2              . MAP THE AMDSB\n         LH    R2,AMDCIPCA              . 2 - CIS PER CA\n         DROP  R2\n         CVD   R2,WORKD                 . CONVERT TO DECIMAL\n         MVC   DCIPCA,WORKD+6           . SAVE\n*                                       . COMPUTE NUMBER OF SECTIONS\n*                                       .   DETERMINE SQUARE ROOT OF\n*                                       .   CI/CA - NEWTON-RAPHESON\n*                                       .   METHOD (INTEGERS ONLY)\n         LTR   R7,R2                    . 7 - CIS PER CA\n         BZ    H0004                    . EXIT IF ZERO!\n         CH    R7,=H'+1'                . Q. 1 CI PER CA? (IMPOSSIBLE)\n         BE    H0004                    . A. YES\nH0002    EQU   *                        . INITIAL APPROXIMATION\n         SRA   R7,1                     . DIVIDE BY TWO\n         LR    R9,R7                    . 9 - INITIAL APPROXIMATION\n         MR    R8,R7                    . SQUARE APPROXIMATION\n         LTR   R8,R8                    . Q. INITIAL APPROX. VALID?\n         BNZ   H0002                    . A. NO - HALF AGAIN\nH0003    EQU   *                        . COMPUTE CORRECTION FACTOR\n         SLR   R8,R8                    . 8 - ZERO\n         LR    R9,R2                    . 9 - CIS/CA\n         DR    R8,R7                    . DIVIDE BY PREVIOUS APPROX.\n         SR    R9,R7                    .   SUBTRACT PREVIOUS APPROX.\n         SRA   R9,1                     .   AND HALVE IT\n         AR    R7,R9                    . 7 - NEW APPROXIMATION\n         LPR   R8,R9                    . 8 - ABSOLUTE CORRECTION\n*                                       .   FACTOR\n         SRA   R8,1                     . Q. CORRECTION VALUE < TWO?\n         BNZ   H0003                    . A. NO\nH0004    EQU   *\n         CVD   R7,WORKD                 . CONVERT TO DECIMAL\n         ZAP   #SECTION,DCIPCA          . NUMBER OF CIS PER CA\n         DP    #SECTION,WORKD+6(2)      . DIVIDE BY ENTRIES PER SECTION\n         ZAP   WORKD,#SECTION(2)        . PICK UP QUOTIENT\n         MVC   #SECTION,WORKD+4         . SAVE NUMBER OF SECTIONS\n*                                       . COMPUTE INDEX CI REQUIREMENTS\n         ZAP   SUGCISZ,=P'+31'          . THIRTY ONE BYTES\n*                                       .   24 BYTE INDEX HEADER\n*                                       .   3 BYTE RDF\n*                                       .   4 BYTE CIDF\n         MP    #SECTION,=P'+2'          . SECTION OVERHEAD\n         AP    SUGCISZ,#SECTION         . ADD TO SUGGESTION\n*                                       . COMPUTE INDEX ENTRY SIZE\n         AP    SSAVGKEY,=P'+3'          . INCREMENT AVERAGE KEY BY\n*                                       .   1 BYTE FRONT DROP COUNT\n*                                       .   1 BYTE LEFT COUNT\n*                                       .   1 BYTE VERTICAL POINTER\n         CLI   HPTLS,IXHPTL1            . Q. ONE BYTE VERTICAL POINTER?\n         BE    H0005                    . A. YES\n         AP    SSAVGKEY,=P'+1'          . INCREMENT FOR 2 BYTE VERTICAL\n*                                       .   POINTER\nH0005    EQU   *\n         MP    SSAVGKEY,DCIPCA          . INDEX ENTRY REQUIREMENTS\n         AP    SUGCISZ,SSAVGKEY         . ADD TO SUGGESTION\n*                                       . COMPUTE INDEX CI SIZE\n         SP    SUGCISZ,=P'+1'           . DECREMENT SUGGESTION BY ONE\n         ZAP   WORKD,SUGCISZ            . PUT INTO WORK AREA\n         CVB   R2,WORKD                 . CONVERT TO BINARY\n         SRA   R2,9                     . DIVIDE BY 512\n         LA    R2,1(,R2)                . INCREMENT BY ONE\n         SLA   R2,9                     . MULTIPLY BY 512\n         CVD   R2,WORKD                 . CONVERT TO DECIMAL\n         MVC   SUGCISZ,WORKD+4          . SAVE SUGGESTED CI SIZE\n         L     R2,CISZ                  . 2 - ACTUAL CI SIZE\n         CVD   R2,WORKD                 . CONVERT TO DECIMAL\n         CP    WORKD,SUGCISZ            . Q. ACTUAL CI SIZE = COMPUTED?\n         BE    H0007                    . A. YES\n         MVC   ACISZ,MASK5              . OUTPUT EDIT MASKS\n         MVC   CCISZ,MASK5\n         ED    ACISZ,WORKD+5            . OUTPUT ACTUAL CI SIZE\n         ED    CCISZ,SUGCISZ+1          . OUTPUT COMPUTED CI SIZE\n         CP    SUGCISZ,=P'+8192'        . Q. SUGGESTED > 8192?\n         BNH   H0006                    . A. NO\n         MVC   OMAX,IMAXCI              . OUTPUT DISASTER\nH0006    EQU   *\n         MVC   LINE1,SUGLINE            . MOVE DETAIL LINE\n         B     H0008                    . COMMON OUTPUT\nH0007    EQU   *\n         MVC   UCISZ,MASK5              . OUTPUT EDIT MASK\n         ED    UCISZ,WORKD+5            . OUTPUT CI SIZE\n         MVC   LINE1,SATLINE            . MOVE DETAIL LINE\nH0008    EQU   *\n         BAS   R10,PRINTLN              . WRITE DETAIL\n         LM    R7,R10,HSAVE             . RESTORE REGISTERS\n         BR    R10                      . EXIT\n         TITLE 'PRINT ROUTINE FOR SYSPRINT'\nPRINTLN  EQU   *\n*        1.    CHECK LINE COUNT\n*              OUTPUT HEADINGS IF REQUIRED\n*        2.    OUTPUT PRINT LINE\n*        3.    RE-INITIALIZE PRINT LINE\n*\n*        REGISTER USAGE\n*        0     USED BY MACROS\n*        1     USED BY MACROS\n*        10    RETURN ADDRESS FOR BRANCH AND SAVE INSTRUCTIONS\n*        14    RETURN ADDRESS FOR BRANCH AND LINK INSTRUCTIONS\n*        15    PUT ROUTINE ENTRY ADDRESS\n         SPACE 2\nI0001    EQU   *\n         CP    #LINE,=P'+58'            . Q. HEADINGS REQUIRED?\n         BL    I0002                    . A. NO\n         MVC   PAGEOUT,MASK5            . OUTPUT PAGE NUMBER\n         ED    PAGEOUT,#PAGE\n         PUT   SYSPRINT,                . OUTPUT PAGE HEADINGS         C\n               TITLE\n         PUT   SYSPRINT,                                               C\n               STITLE1\n         PUT   SYSPRINT,                                               C\n               STITLE2\n         PUT   SYSPRINT,                                               C\n               STITLE3\n         AP    #PAGE,=P'+1'             . INCREMENT PAGE NUMBER\n         ZAP   #LINE,=P'+5'             . RESET LINE COUNTER\nI0002    EQU   *\n         PUT   SYSPRINT,                . OUTPUT PRINT LINE            C\n               LINE1\n         AP    #LINE,=P'+1'             . INCREMENT LINE COUNTER\n         CLI   LINE1,C'0'               . Q. DOUBLE LINE SPACING REQ.?\n         BNE   I0003                    . A. NO\n         AP    #LINE,=P'+1'\nI0003    EQU   *\n         MVI   LINE1,C' '               . RE-INITIALIZE OUTPUT LINE\n         MVC   LINE1+1(132),LINE1\n         BR    R10                      . EXIT\n         TITLE 'DATA AREAS'\nWORKD    DS    D                        . USED BY CVD INSTRUCTIONS\n@CI      DS    F                        . CI ADDRESS MODIFIED BY GETIX\n@FREE    DS    F                        . ADDRESS OF FREE SPACE IN CI\nCSAVE    DS    F                        . REGISTER SAVE AREA\nESAVE    DS    F                        . REGISTER SAVE AREA\nFSAVE    DS    F                        . REGISTER SAVE AREA\nGSAVE    DS    F                        . REGISTER SAVE AREA\nHSAVE    DS    4F                       . REGISTER SAVE AREA\nCIKEYBYT DS    F                        . NUMBER OF BYTES IN KEYS IN CI\nCIKEYNUM DS    F                        . NUMBER OF KEYS IN CI\nKEYBYTES DS    F                        . TOTAL NUMBER OF BYTES IN KEYS\nKEYNUMBR DS    F                        . TOTAL NUMBER OF KEYS\nSCKEYBYT DS    F                        . NUMBER OF BYTES IN KEYS IN\n*                                       .   SECTION\nSCKEYNUM DS    F                        . NUMBER OF KEYS IN SECTION\n*               . CISZ AND INDXL ARE USED IN THE SAME SHOWCB - MUST\n*               .   STAY ADJACENT\nCISZ     DS    F                        . INDEX COMPONENT CI SIZE\nINDXL    DS    F                        . NUMBER OF INDEX LEVELS\nCURKEYL  DS    F                        . LENGTH OF CURRENT KEY\nPTLS     DS    F                        . VERTICAL POINTER LENGTH\nRBAHLVL  DS    F                        . HIGH-LEVEL RBA\nRBANXLVL DS    F                        . RBA OF FIRST LOGICAL CI AT\n*                                       .   NEXT LOWER LEVEL\nRBARPL   DS    F                        . RBA SPECIFIED IN RPL MACRO\nRBASQSET DS    F                        . SEQUENCE SET RBA\n*               . THE VSAM ERROR FIELDS MUST STAY ADJACENT\nVSAMERR  DS    0F\nREG15    DS    F                        . REGISTER 15\nOPENERR  DS    F                        . ACB ERROR CODE\nRPLFDBK  DS    F                        . RPL FEED BACK CODE\nRDFDISP  DS    H                        . RDF DISPLACEMENT IN CI\n#CIREAD  DS    PL5                      . NUMBER OF CIS PROCESSED\n#LINE    DS    PL2                      . LINE COUNTER\n#PAGE    DS    PL3                      . PAGE ACCUMULATOR\n#SECTION DS    PL4                      . NUMBER OF SECTIONS\nDCIPCA   DS    PL2                      . DATA COMPONENT CI/CA\nSEC#     DS    PL3                      . SECTION NUMBER\nSSAVGKEY DS    PL4                      . LARGEST SEQUENCE SET AVERAGE\n*                                       .   KEY LENGTH\nSUGCISZ  DS    PL4                      . SUGGESTED CI SIZE\nHPTLS    DS    X                        . INDEX POINTER LENGTH\nLEV#     DS    X                        . INDEX LEVEL BEING PROCESSED\nLKEYCI   DS    X                        . LONGEST KEY - CI\nLKEYDA   DS    X                        . LONGEST KEY LENGTH\nLKEYSC   DS    X                        . LONGEST KEY - SECTION\nSKEYCI   DS    X                        . SHORTEST KEY - CI\nSKEYDA   DS    X                        . SHORTEST KEY LENGTH\nSKEYSC   DS    X                        . SHORTEST KEY - SECTION\nMASK3    DC    X'40202120'              . EDIT MASKS\nMASK5    DC    X'402020202120'\nMASK9    DC    X'40202020202020202120'\nPLTBL    DC    X'0001000200000003'      . POINTER LENGTH TRANSLATE\n*                                       .   TABLE\n         SPACE 2\n*                                       . INDEX RECORD HEADER\n         DS    0F                       . FULL-WORD ALIGN\nIXHFORM  DS    0CL24\nIXHLL    DS    H                        . LENGTH OF INDEX RECORD\nIXHFLPLN DS    X                        . LENGTH OF INDEX ENTRY CONTROL\n*                                       .   INFORMATION\nIXHPTLS  DS    X                        . LENGTH OF VERTICAL POINTER\nIXHPTL1  EQU   X'01'                    . ONE BYTE POINTER\nIXHPTL2  EQU   X'03'                    . TWO BYTE POINTER\nIXHPTL3  EQU   X'07'                    . THREE BYTE POINTER\nIXHBRBA  DS    F                        . RBA OF ASSOCIATED LOWER LEVEL\nIXHHP    DS    F                        . HORIZONTAL POINTER\nIXHXX    DS    F                        . RESERVED\nIXHLV    DS    X                        . LEVEL NUMBER OF RECORD\nIXHSEQ   EQU   X'01'                    . SEQUENCE SET RECORD\nIXHFLGS  DS    X                        . RESERVED\nIXHFSO   DS    H                        . DISPLACEMENT OF UNUSED SPACE\nIXHLEO   DS    H                        . DISPLACEMENT OF HIGH-KEY\n*                                       .   INDEX ENTRY CONTROL INFO.\nIXHSEO   DS    H                        . DISPLACEMENT OF HIGH-KEY\n*                                       .   INDEX ENTRY IN FIRST SEC.\n         SPACE 2\n*                                       . PRINT LINES\nTITLE    DC    CL15'1'\n         DC    CL50'ANALYSIS OF INDEX COMPONENT CONTROL INTERVALS FOR '\nDSNTITLE DC    CL44' '\n         DC    CL14' '\n         DC    CL4'PAGE'\nPAGEOUT  DS    CL6\nSTITLE1  DC    CL25'0 CONTROL INTERVAL SIZE: '\nTCISZ    DS    CL6\n         DC    CL26'  NUMBER OF INDEX LEVELS: '\nTNIXL    DS    CL4\n         DC    CL31'  NUMBER OF ENTRIES / SECTION: '\nTNEST    DS    CL4\n         DC    CL17'  INDEX OPTIONS: '\nIMBED    DS    CL7\n         DC    CL2' '\nREPL     DS    CL11\nSTITLE2  DC    CL133'0                       LOGICAL                   C\n                                          POINTERS             SECTION C\n                           KEY LENGTH    '\nSTITLE3  DC    CL133'   INDEX LEVEL         CI NUMBER          CI''S RBC\n               A       UNUSED SPACE      USED     UNUSED    NUMBER   ENC\n               TRIES      MAX    MIN    AVG'\nLINE1    DC    CL94' '\nRSEC#    DS    CL6\n         DC    CL6' '\nRSECENT  DS    CL4\n         DC    CL5' '\nMAXKEY   DS    CL4\n         DC    CL3' '\nMINKEY   DS    CL4\n         DC    CL3' '\nAVGKEY   DS    CL4\nLINE1CI  DC    CL6'0'\nRIXL     DS    CL4\n         DC    CL12' '\nCINUM    DS    CL10\n         DC    CL8' '\nRBANUM   DS    CL10\n         DC    CL9' '\nUNUSEDSP DS    CL6\n         DC    CL8' '\nPTRUSE   DS    CL6\n         DC    CL5' '\nPTRUNUSE DS    CL6\n         DC    CL4' '\nSUGLINE  DC    CL6'0'\n         DC    CL15'ACTUAL CI SIZE:'\nACISZ    DS    CL6\n         DC    CL24'    COMPUTED SUGGESTION:'\nCCISZ    DS    CL6\n         DC    CL1' '\nOMAX     DC    CL75' '\nSATLINE  DC    CL6'0'\n         DC    CL15'ACTUAL CI SIZE:'\nUCISZ    DS    CL6\n         DC    CL106' IS CONFIRMED BY COMPUTATION'\n         TITLE 'CONTROL BLOCKS AND DSECTS'\nVSAM     ACB   AM=VSAM,                                                C\n               DDNAME=VSAM,                                            C\n               MACRF=CNV\nGETRPL   RPL   ACB=VSAM,                                               C\n               AM=VSAM,                                                C\n               AREA=@CI,                                               C\n               AREALEN=4,                                              C\n               ARG=RBARPL,                                             C\n               OPTCD=(CNV,DIR,LOC)\nSYSPRINT DCB   BLKSIZE=15428,                                          C\n               DDNAME=SYSPRINT,                                        C\n               DSORG=PS,                                               C\n               LRECL=133,                                              C\n               MACRF=PM,                                               C\n               RECFM=ABFS\nDUMMY    DCB   DDNAME=VSAM,                                            C\n               DSORG=PS,                                               C\n               EXLST=DCBEXIT,                                          C\n               MACRF=GM\n         DS    0F                       . FULL WORD ALIGN DCB EXIT\nDCBEXIT  EQU   *\n         DC    X'87'                    . INDICATE RDJFCB\n         DC    AL3(INFMJFCB)            . ADDRESS OF JFCB MAPPING\n         IEFJFCBN\n         DCBD  DEVD=DA,                 . DCB DSECT                    C\n               DSORG=PS\n         IFGACB                         . ACB DSECT\nIDAAMBL  DSECT                          . AMBL DSECT\n         DS    XL52\nAMBLDTA  DS    F                        . -> DATA COMPONENT AMB\nAMBLIX   DS    F                        . -> INDEX COMPONENT AMB\nIDAAMB   DSECT                          . AMB DSECT\n         DS    XL20\nAMBDSB   DS    F                        . -> AMDSB\nIDAAMDSB DSECT                          . AMDSB DSECT\n         DS    XL4\nAMDNEST  DS    H                        . ENTRIES PER SECTION\n         DS    CL6\nAMDCIPCA DS    H                        . CIS PER CA\n         DS    XL14\nAMDHLRBA DS    F                        . HI-LEVEL RBA\nAMDSSRBA DS    F                        . SEQUENCE SET RBA\n         TITLE 'LITERALS AND TERMINATION'\nVSAMIST  CSECT                          . RE-ESTABLISH CSECT\nIMAXCI   DC    CL75'THE COMPUTED CI SIZE IS GREATER THAN THAT PERMITTEDC\n                - INCREASE DATA CI SIZE'\n         LTORG\n         END\n\n\nDave Loveluck\nInstructor/Consultant (USA)                              c Dave Loveluck 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A006A04": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 30, "newlines": 30, "modlines": 0, "user": "VSAMUPD"}, "text": "Use of VBS in VSAM\n\nWe have a large, variable blocked ESDS VSAM dataset that is\ncreated in batch for subsequent read-only access from our\nproduction CICS system (Version 1.7 under MVS/XA 2.2). It\nwas defined with a CISIZE of 6144 with a maximum logical\nrecord length of less than 6144.\n\nIt was determined that we would have to cater for the record\nsize being increased beyond 6144 and so decided to research\nthe use of variable block spanned record format. We found that\nwe could change the VSAM definition to use VBS without\nhaving to change any application programs on our CICS\nsystem. Potentially the maximum logical record size will be\n26,000 bytes.\n\nHaving changed the definition of the production file the next\ntime it was loaded we noticed that the disk space the file\noccupied was significantly less. The saving is in the order of\n12% on an original file size of 3,413 megabytes, a saving of\nover 700 cylinders on our 3380s.\n\nObviously this percentage of saving is unique to this file but a\nconversion from VB to VBS format, which is invisible to CICS\nand the application, will almost always make some saving.\n\nLaurie Lewis\nTechnical Support Manager\nThe Reader's Digest Association Ltd (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A006A05": {"ttr": 7691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x02L\\x02L\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 588, "newlines": 588, "modlines": 0, "user": "VSAMUPD"}, "text": "Estimating VSAM buffer parameters\n\nThe program and mapset with NEKZ give an on-line estimate\nof VSAM buffer parameters. This is a simple method of getting\nbuffer parameters for VSAM clusters using the CICS command\nlevel interpreter.\n\nYou have to enter your data CI size (and index CI size for\nKSDS), mode, string number (very useful for CICS), and\nnumber of index levels (KSDS only). The mode is the mode of\nprocessing, ie sequential, direct, or mixed. As a result you are\nshown sizes for bufferspaces, BUFND, and BUFNI.\n\nThe name of the transaction NEKZ, program NEKVP6, and\nmap NEKVM6 must be put in the CICS tables PPT and PCT.\nThe program has been tested and works with VSE/SP 2.1 and\nVSAM Release 3.\n\nFigures 1, 2, and 3 show the initial screen, an example of the\nentered parameters, and an estimation of CI size, respectively.\n\n\nNEKVP6\n\n         PRINT   NOGEN,ON\n* ON-LINE ASSEMBLER PROGRAM NEKVP6\n         MACRO\n&LABEL   NEKV6A  &P1,&P2\n         CLC &P1,=C'B'\n         BNE &LABEL\n         MVC CISIZED,=F'&P2'\n         MVC CISIZEI,=F'&P2'\n         MVC LINE,=CL79'FOR CLUSTER, DATA CISIZE = &P2,  INDEX CISIZE =C\n                &P2, PUT  '\n         B L00\n&LABEL   EQU *\n         MEND\n         MACRO\n&LABEL   NEKV6B  &P1,&P2\n         CLC &P1,=C'D'\n         BNE &LABEL\n         MVC CISIZED,=F'&P2'\n         MVC LINE,=CL79'FOR CLUSTER, DATA CISIZE = &P2,                C\n                     PUT  '\n         B L01\n&LABEL   EQU *\n         MEND\n         MACRO\n&LABEL   NEKV6C  &P1,&P2\n         CLC &P1,=C'I'\n         BNE &LABEL\n         MVC CISIZEI,=F'&P2'\n         MVC LINE+38(40),=CL40' INDEX CISIZE = &P2,  PUT   '\n         B L00\n&LABEL   EQU *\n         MEND\nDFHEISTG DSECT\n         COPY  NEKVM6\n         COPY  DFHBMSCA\nPROGRAM  DFHEIENT CODEREG=(2,3,4)\n         EXEC CICS HANDLE AID    ENTER(LENTER) PF6(KRAJ) PF18(KRAJ)    C\n                                               ANYKEY(LANY) NOEDF\n         EXEC CICS HANDLE CONDITION ERROR(ERRORS) NOEDF\nSNDMAP   MVC PAR05AL,=X'FFFF'   CURSOR HERE\n         MVC PAR05AO,=C' '\n         MVC PAR06AO,=C' '\n         MVC PAR07AO,=C' '\n         MVC PAR08AO,=C' '\n         MVC PAR09AO,=C' '\n         MVC PAR10AO,=C' '\n         MVC PAR11AO,=C' '\n         MVC PAR12AO,=C' '\n         MVC PAR13AO,=C' '\n         MVC PAR05BO,=C' '\n         MVC PAR06BO,=C' '\n         MVC PAR07BO,=C' '\n         MVC PAR08BO,=C' '\n         MVC PAR09BO,=C' '\n         MVC PAR10BO,=C' '\n         MVC PAR11BO,=C' '\n         MVC PAR12BO,=C' '\n         MVC PAR13BO,=C' '\n         MVC PAR05CO,=C' '\n         MVC PAR06CO,=C' '\n         MVC PAR07CO,=C' '\n         MVC PAR08CO,=C' '\n         MVC PAR09CO,=C' '\n         MVC PAR10CO,=C' '\n         MVC PAR11CO,=C' '\n         MVC PAR12CO,=C' '\n         EXEC CICS SEND MAP('NEKVM6') CURSOR ERASE NOEDF\n         EXEC CICS RECEIVE MAP('NEKVM6') NOEDF\nLENTER   EQU *\n         MVI LINE19A,DFHBMASB\n         MVI LINE20A,DFHBMASB\n         MVI LINE21A,DFHBMASB\n         MVI LINE22A,DFHBMASB\n         MVC MODE,MODEI\n         CLC MODE,=X'00'\n         BNE LP1\n         MVC MODE,MODEPOM\nLP1      MVC MODEO,MODE\n         MVC MODEPOM,MODE     SAVE MODE\n         MVC LEVEL,LEVELI\n         CLC LEVEL,=X'00'\n         BNE LP2\n         MVC LEVEL,LEVELPOM\nLP2      MVC LEVELO,LEVEL\n         MVC LEVELPOM,LEVEL    SAVE LEVEL\n         MVC STRNO,STRINGI\n         CLC STRNO,=X'00'\n         BNE LP3\n         MVC STRNO,STRNOPOM\nLP3      MVC STRINGO,STRNO\n         MVC STRNOPOM,STRNO   SAVE MODE\n         MVC CISIZED,=F'0'\n         MVC CISIZEI,=F'0'\n         MVC BUFFSP,=F'0'\nLL5      NEKV6A PAR05AI,512\nLL6      NEKV6A PAR06AI,1024\nLL7      NEKV6A PAR07AI,1536\nLL8      NEKV6A PAR08AI,2048\nLL9      NEKV6A PAR09AI,2560\nLL10     NEKV6A PAR10AI,3072\nLL11     NEKV6A PAR11AI,3584\nLL12     NEKV6A PAR12AI,4096\nLL13     NEKV6A PAR13AI,4608\nLL14     NEKV6A PAR05BI,5120\nLL15     NEKV6A PAR06BI,5632\nLL16     NEKV6A PAR07BI,6144\nLL17     NEKV6A PAR08BI,6656\nLL18     NEKV6A PAR09BI,7168\nLL19     NEKV6A PAR10BI,8192\nLL20     NEKV6A PAR11BI,10240\nLL21     NEKV6A PAR12BI,12228\nLL22     NEKV6A PAR13BI,14336\nLL23     NEKV6A PAR05CI,16384\nLL24     NEKV6A PAR06CI,18432\nLL25     NEKV6A PAR07CI,20480\nLL26     NEKV6A PAR08CI,22528\nLL27     NEKV6A PAR09CI,24576\nLL28     NEKV6A PAR10CI,26624\nLL29     NEKV6A PAR11CI,28672\nLL30     NEKV6A PAR12CI,30720\nLX5      NEKV6B PAR05AI,512\nLX6      NEKV6B PAR06AI,1024\nLX7      NEKV6B PAR07AI,1536\nLX8      NEKV6B PAR08AI,2048\nLX9      NEKV6B PAR09AI,2560\nLX10     NEKV6B PAR10AI,3072\nLX11     NEKV6B PAR11AI,3584\nLX12     NEKV6B PAR12AI,4096\nLX13     NEKV6B PAR13AI,4608\nLX14     NEKV6B PAR05BI,5120\nLX15     NEKV6B PAR06BI,5632\nLX16     NEKV6B PAR07BI,6144\nLX17     NEKV6B PAR08BI,6656\nLX18     NEKV6B PAR09BI,7168\nLX19     NEKV6B PAR10BI,8192\nLX20     NEKV6B PAR11BI,10240\nLX21     NEKV6B PAR12BI,12228\nLX22     NEKV6B PAR13BI,14336\nLX23     NEKV6B PAR05CI,16384\nLX24     NEKV6B PAR06CI,18432\nLX25     NEKV6B PAR07CI,20480\nLX26     NEKV6B PAR08CI,22528\nLX27     NEKV6B PAR09CI,24576\nLX28     NEKV6B PAR10CI,26624\nLX29     NEKV6B PAR11CI,28672\nLX30     NEKV6B PAR12CI,30720\n         B NOTDATA\nL01      EQU *\nLY5      NEKV6C PAR05AI,512\nLY6      NEKV6C PAR06AI,1024\nLY7      NEKV6C PAR07AI,1536\nLY8      NEKV6C PAR08AI,2048\nLY9      NEKV6C PAR09AI,2560\nLY10     NEKV6C PAR10AI,3072\nLY11     NEKV6C PAR11AI,3584\nLY12     NEKV6C PAR12AI,4096\nLY13     NEKV6C PAR13AI,4608\nLY14     NEKV6C PAR05BI,5120\nLY15     NEKV6C PAR06BI,5632\nLY16     NEKV6C PAR07BI,6144\nLY17     NEKV6C PAR08BI,6656\nLY18     NEKV6C PAR09BI,7168\nLY19     NEKV6C PAR10BI,8192\nL00      EQU *\n         CLC STRNO,=C'0'\n         BE LSTRING\n         CLC STRNO,=X'00'\n         BE LSTRING\n         MVC STRING+3(1),STRNO\n         NC STRING,=X'0000000F'\n         CLC LEVEL,=C'0'\n         BE LNOKSDS\n         MVC INDEX+3(1),LEVEL\n         NC  INDEX,=X'0000000F'\n         CLC CISIZEI,=X'00000000'\n         BE LNOKSDS\n         CLC LEVEL,=C'0'\n         BE  NOTDATA\n         CLC LEVEL,=X'00'\n         BE  NOTDATA\n* KSDS\n         CLC MODE,=C'S'\n         BNE LW1\n* KSDS, SEQUENTIAL\n* INDEX BUFFERS EQUAL STRING NUMBER\n         MVC BUFNI,STRING\n         MVC BUFND,F3\n         L R5,BUFND\n         A R5,STRING\n         ST R5,BUFND      BUFND HAS NUMBER\n         B LBUF\nLW1      CLC MODE,=C'D'\n         BNE LW2\n* KSDS DIRECT\n         MVC BUFNI,INDEX\n         L   R5,BUFNI\n         A   R5,STRING\n         S   R5,F1\n         ST  R5,BUFNI     BUFNI HAS NUMBER\n         MVC BUFND,STRING\n         L   R5,BUFND\n         A   R5,F1\n         ST  R5,BUFND     BUFND HAS NUMBER\n         B LBUF\n* KSDS, MIXED\nLW2      EQU *\n         MVC BUFNI,INDEX\n         L   R5,BUFNI\n         A   R5,STRING\n         S   R5,F1\n         ST  R5,BUFNI     BUFNI HAS NUMBER\n         MVC BUFND,F3\n         L R5,BUFND\n         A R5,STRING\n         ST R5,BUFND      BUFND HAS NUMBER\n         B LBUF\nLNOKSDS  EQU *\n         MVC BUFND,=F'5'\n         MVC BUFNI,=F'0'\n         B LBUF\nLBUF     EQU *\n         L   R5,BUFND\n         CVD R5,POM\n         MVC POM16,EDIT8\n         ED  POM16,POM\n         MVC BUFNDO,POMB\n         L   R5,BUFNI\n         CVD R5,POM\n         MVC POM16,EDIT8\n         ED  POM16,POM\n         MVC BUFNIO,POMB\n         L   R9,CISIZED\n         M   R8,BUFND\n         L   R7,CISIZEI\n         M   R6,BUFNI\n         AR  R9,R7\n         CVD R9,POM\n         MVC POM16,EDIT8\n         ED  POM16,POM\n         MVC BUFFSPO,POMB\n         MVC LINE19O,LINE\n         B SNDMAP\nERRORS   MVC ERRMSGO,=CL79' ERRORS     CALL SYSTEM PROGRAMMER'\n         B SNDMAP\nLSTRING  MVC ERRMSGO,=CL79' ENTER STRING NUMBER |              '\n         B SNDMAP\nLHINDEX  MVC ERRMSGO,=CL79' INDEX TOO HIGH. MAKE CLUSTER BETTER'\n         B SNDMAP\nLANY     MVC ERRMSGO,=CL79'         WRONG KEY  '\n         B SNDMAP\nNOTDATA  MVC ERRMSGO,=CL79'  ENTER CORRECT INPUT |   '\n         B SNDMAP\nKRAJ     MVC PORUKA,=CL19'NORMAL END OF TASK '\n         EXEC CICS SEND FROM(PORUKA) ERASE NOEDF\n         EXEC CICS RETURN  NOEDF\n         CNOP 0,8\nPOM      DS 2F\nINDEX    DS F\nSTRING   DS F\nBUFNI    DS F\nBUFND    DS F\nBUFFSP   DS F\nCISIZED  DS F\nCISIZEI  DS F\nF1       DC F'1'\n         CNOP 0,4\nF3       DC F'3'\nPOM16    DS 0CL16\nPOMA     DS CL6\nPOMB     DS CL10\nPORUKA   DS CL19\nLINE     DS CL79\nMODE     DS CL1\nMODEPOM  DS CL1\nLEVEL    DS CL1\nLEVELPOM DS CL1\nSTRNO    DS CL1\nSTRNOPOM DS CL1\nEDIT8    DC XL16'60202020202020202020202020202120'\nR5       EQU 5\nR6       EQU 6\nR7       EQU 7\nR8       EQU 8\nR9       EQU 9\n         END\n\n\nNEKVM6\n\nMAPSET   DFHMSD TYPE=&SYSPARM,MODE=INOUT,CTRL=(FREEKB,FRSET),          C\n               TIOAPFX=YES,STORAGE=AUTO\nNEKVM6   DFHMDI SIZE=(24,80)\nIME      DFHMDF POS=(1,1),LENGTH=7,INITIAL='NEKVM6',ATTRB=(ASKIP,FSET)\n         DFHMDF POS=(1,10),ATTRB=(ASKIP,BRT),                          C\n               LENGTH=69,                                              C\n               INITIAL='E S T I M A T E   V S A M   B U F F E R   P A RC\n                A M E T E R S '\nLINE3    DFHMDF POS=(3,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=79,                                              C\n               INITIAL='PUT  D  FOR DATA CISIZE,  I  INDEX CISIZE  OR  C\n               B  FOR THE SAME VALUE FOR BOTH:'\nIND05A   DFHMDF POS=(5,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='  512 : '\nPAR05A   DFHMDF POS=(5,10),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(5,12),LENGTH=1\nIND05B   DFHMDF POS=(5,21),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 5120 : '\nPAR05B   DFHMDF POS=(5,30),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(5,32),LENGTH=1\nIND05C   DFHMDF POS=(5,51),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='16384 : '\nPAR05C   DFHMDF POS=(5,60),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(5,62),LENGTH=1\nIND06A   DFHMDF POS=(6,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 1024 : '\nPAR06A   DFHMDF POS=(6,10),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(6,12),LENGTH=1\nIND06B   DFHMDF POS=(6,21),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 5632 : '\nPAR06B   DFHMDF POS=(6,30),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(6,32),LENGTH=1\nIND06C   DFHMDF POS=(6,51),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='18432 : '\nPAR06C   DFHMDF POS=(6,60),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(6,62),LENGTH=1\nIND07A   DFHMDF POS=(7,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 1536 : '\nPAR07A   DFHMDF POS=(7,10),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(7,12),LENGTH=1\nIND07B   DFHMDF POS=(7,21),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 6144 : '\nPAR07B   DFHMDF POS=(7,30),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(7,32),LENGTH=1\nIND07C   DFHMDF POS=(7,51),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='20480 : '\nPAR07C   DFHMDF POS=(7,60),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(7,62),LENGTH=1\nIND08A   DFHMDF POS=(8,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 2048 : '\nPAR08A   DFHMDF POS=(8,10),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(8,12),LENGTH=1\nIND08B   DFHMDF POS=(8,21),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 6656 : '\nPAR08B   DFHMDF POS=(8,30),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(8,32),LENGTH=1\nIND08C   DFHMDF POS=(8,51),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='22528 : '\nPAR08C   DFHMDF POS=(8,60),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(8,62),LENGTH=1\nIND09A   DFHMDF POS=(9,1),                                             C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 2560 : '\nPAR09A   DFHMDF POS=(9,10),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(9,12),LENGTH=1\nIND09B   DFHMDF POS=(9,21),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 7168 : '\nPAR09B   DFHMDF POS=(9,30),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(9,32),LENGTH=1\nIND09C   DFHMDF POS=(9,51),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='24576 : '\nPAR09C   DFHMDF POS=(9,60),                                            C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(9,62),LENGTH=1\nIND10A   DFHMDF POS=(10,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 3072 : '\nPAR10A   DFHMDF POS=(10,10),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(10,12),LENGTH=1\nIND10B   DFHMDF POS=(10,21),                                           C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 8192 : '\nPAR10B   DFHMDF POS=(10,30),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(10,32),LENGTH=1\nIND10C   DFHMDF POS=(10,51),                                           C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='26624 : '\nPAR10C   DFHMDF POS=(10,60),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(10,62),LENGTH=1\nIND11A   DFHMDF POS=(11,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 3584 : '\nPAR11A   DFHMDF POS=(11,10),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(11,12),LENGTH=1\nIND11B   DFHMDF POS=(11,21),                                           C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='10240 : '\nPAR11B   DFHMDF POS=(11,30),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(11,32),LENGTH=1\nIND11C   DFHMDF POS=(11,51),                                           C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='28672 : '\nPAR11C   DFHMDF POS=(11,60),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(11,62),LENGTH=1\nIND12A   DFHMDF POS=(12,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 4096 : '\nPAR12A   DFHMDF POS=(12,10),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(12,12),LENGTH=1\nIND12B   DFHMDF POS=(12,21),                                           C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='12228 : '\nPAR12B   DFHMDF POS=(12,30),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(12,32),LENGTH=1\nIND12C   DFHMDF POS=(12,51),                                           C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='30720 : '\nPAR12C   DFHMDF POS=(12,60),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(12,62),LENGTH=1\nIND13A   DFHMDF POS=(13,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL=' 4608 : '\nPAR13A   DFHMDF POS=(13,10),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(13,12),LENGTH=1\nIND13B   DFHMDF POS=(13,21),                                           C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=8,                                               C\n               INITIAL='14336 : '\nPAR13B   DFHMDF POS=(13,30),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(13,32),LENGTH=1\nIND15    DFHMDF POS=(15,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=40,                                              C\n               INITIAL='ENTER MODE OF PROCESSING VSAM CLUSTER : '\nMODE     DFHMDF POS=(15,42),                                           C\n               ATTRB=(UNPROT,BRT),                                     C\n               LENGTH=1\n         DFHMDF POS=(15,44),LENGTH=1\nIND16    DFHMDF POS=(16,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=65,                                              C\n               INITIAL='S FOR SEQUENTIAL, D FOR DIRECT, M FOR MIXED'\nIND17    DFHMDF POS=(17,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=40,                                              C\n               INITIAL='NUMBER OF INDEX LEVELS  ( KSDS ONLY)  : '\nLEVEL    DFHMDF POS=(17,42),                                           C\n               ATTRB=(UNPROT,NUM,BRT),                                 C\n               LENGTH=1\n         DFHMDF POS=(17,44),LENGTH=1\nIND18    DFHMDF POS=(18,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=40,                                              C\n               INITIAL='STRING NUMBER(STRNO). PUT 1 FOR BATCH : '\nSTRING   DFHMDF POS=(18,42),                                           C\n               ATTRB=(UNPROT,NUM,BRT),                                 C\n               LENGTH=1\n         DFHMDF POS=(18,44),LENGTH=1\nLINE19   DFHMDF POS=(19,1),ATTRB=(PROT,BRT),LENGTH=79\nLINE20   DFHMDF POS=(20,1),ATTRB=(PROT,DRK),LENGTH=21,                 C\n               INITIAL='        FOR BUFND  : '\nBUFND    DFHMDF POS=(20,23),                                           C\n               ATTRB=(PROT,BRT),                                       C\n               LENGTH=10\nLINE21   DFHMDF POS=(21,1),ATTRB=(PROT,DRK),LENGTH=21,                 C\n               INITIAL='        FOR BUFNI  : '\nBUFNI    DFHMDF POS=(21,23),                                           C\n               ATTRB=(PROT,BRT),                                       C\n               LENGTH=10\nLINE22   DFHMDF POS=(22,1),ATTRB=(PROT,DRK),LENGTH=21,                 C\n               INITIAL='        FOR BUFFSP : '\nBUFFSP   DFHMDF POS=(22,23),                                           C\n               ATTRB=(PROT,BRT),                                       C\n               LENGTH=10\nLINE23   DFHMDF POS=(23,1),                                            C\n               ATTRB=(PROT,ASKIP),                                     C\n               LENGTH=79,                                              C\n               INITIAL='                           PF6,PF18 - CICS'\nERRMSG   DFHMDF POS=(24,1),LENGTH=79,ATTRB=(BRT,PROT)\n         DFHMSD TYPE=FINAL\n         END\n\nNenad Kuzmanovic\nArenaturist (Yugoslavia)                                c Nenad Kuzmanovic 1992\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A006A06": {"ttr": 7945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\x1d\\x01\\x1d\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 285, "newlines": 285, "modlines": 0, "user": "VSAMUPD"}, "text": "Mapping VSAM dataspaces on FBA devices\n\nWhen reviewing VSAM dataspace consumption, I often find it\nuseful to review the space map that is part of the output from\nthe IDCAMS LISTCAT SPACE ALL command. This shows,\nin groupings of contiguous blocks, which blocks are in use and\nwhich are free. This not only helps to show the total amount\nstill free, but also the size of the areas that are still free, since\nthese are often fragmented within the dataspace.\n\nTo improve the information visually, I wrote the VSAMMAPS\nEXEC which converts the hexadecimal 'run length codes' in\nthe IDCAMS output into graphical characters, with each print\nposition representing 64 FBA blocks. (This is the minimum\nallocation value for our 9336 drives.) Please note that, for\nbrevity, the sample output in Figure 1 has been truncated on\nthe right and shortened in total length. The actual space map\nlines print 132 characters per line.\n\nTo create the input to the EXEC, submit an IDCAMS job that\nhas the LISTCAT SPACE ALL command, followed by the\nLISTCAT ALL command. Route the output to your CMS\nmachine. When it arrives, issue the CMS command READ\nVSAMMAPS INPUT A. This will create the necessary CMS\nfile, and will strip its carriage controls.\n\nRunning VSAMMAPS EXEC produces the print file\nVSAMMAPS OUTPUT A, which includes carriage controls.\nIn the space map, all print positions that represent used blocks\ndisplay as asterisks, and those that represent 'free' display as\nfull stops. The EXEC can be further customized to display\nsomething other than just asterisks for certain key files. The\nREXX variable clusterTab defines certain cluster name prefixes\nthat are to be represented by a single character. For example,\nany cluster beginning with the characters RECORDS.DLI will\ndisplay using an R in the space map, instead of just an *.\n\nAlthough this EXEC was written to handle FBA DASD, it\ncould be modified to support CKD instead. Whichever is\nchosen, VSAMMAPS enables anyone responsible for DASD\nplanning to produce an at-a-glance representation of their\ncurrent VSAM allocations.\n\n\nVSAMMAPS EXEC\n\n/* */\nnumeric digits(12)\nfin  = 'VSAMMAPS INPUT A'\nfout = 'VSAMMAPS OUTPUT A'\n/*------------------------------*/\n/* Parse LIST SPACE ALL info... */\n/*------------------------------*/\nsay 'Parsing LIST SPACE ALL...'\nvolcnt = 0\nendit = 'N'\ndo until rc \u00ac= 0 | endit = 'Y'\n   'EXECIO 1 DISKR' fin '0'\n   if rc = 0 then do\n      parse pull inrec\n      call Seek\n      end\n   end\n/*-------------------------------*/\n/* Print volume summary lines... */\n/*-------------------------------*/\nsay 'Printing Volume Summaries...'\norec = '1VSAMMAPS FOR' catnam 'ON' data(u) 'AT' time()\n'EXECIO 1 DISKW' fout '0 V 133 ( VAR OREC'\norec = '0VOLUME DS FILES TOT-BLOCK USE-BLOCK USE% FREE-BLOCK HIGH-FREE'\n'EXECIO 1 DISKW' fout '0 ( VAR OREC'\ndo i = 1 to volcnt\n   do j = 1 to DSPTOT.i\n      BLFRE.i.j = BLKTOT.i.j - BLKUSE.i.j\n      USEPCT.i.j = (BLKUSE.i.j / BLKTOT.i.j) * 100\n      RLCTOT.i.j = length(SPCMAP.i.j) / 8\n      if pos('.',(RLCTOT.i.j / 2)) > 0 then do\n         RLCTOT.i.j = RLCTOT.i.j + 1\n         SPCMAP.i.j = SPCMAP.i.j || '00000000'\n         end\n      HIFREE.i.j = 0\n      mappos = -7\n      do k = 2 to RLCTOT.i.j by 2\n         mappos = mappos + 16\n         freerlc = c2d(x2c(substr(SPCMAP.i.j,mappos,8)))\n         if freerlc > HIFREE.i.j then do\n            HIFREE.i.j = freerlc\n            end\n         end\n      orec = '0' || substr(VOLNAM.i.1,6) || ' '\n      orec = orec || format(j,2) || ' '\n      orec = orec || format(DSNTOT.i.j,5) || ' '\n      orec = orec || format(BLKTOT.i.j,9) || ' '\n      orec = orec || format(BLKUSE.i.j,9) || '  '\n      orec = orec || format(USEPCT.i.j,3,0) || '  '\n      orec = orec || format(BLKFRE.i.j,9) || ' '\n      orec = orec || format(HIFREE.i.j,9)\n      'EXECIO 1 DISKW' fout '0 ( VAR OREC'\n      end\n   end\n/*-----------------------------------------*/\n/* Build preliminary graphic space maps... */\n/*-----------------------------------------*/\nsay 'Building Preliminary Maps...'\ndo i = 1 to volcnt\n   do j = 1 to DSPTOT.i\n      mappos = -7\n      mapchr  = '*'\n      OMAP.i.j = ''\n      do k = 1 to RLCTOT.i.j\n\n         mappos = mappos + 8\n         rlc = c2d(x2c(substr(SPCMAP.i.j,mappos,8)))\n         if rlc > 0 then do\n            rlc2 = rlc / 64\n            OMAP.i.j = OMAP.i.j || substr(mapchr,1,rlc2,mapchr)\n            end\n         if mapchr = '*' then mapchr = '.'; else mapchr = '*'\n         end\n      end\n   end\n/*----------------------------------------*/\n/* table of important cluster prefixes... */\n/*----------------------------------------*/\nclusterTab =               'RECORDS.DLI R '\nclusterTab = clusterTab || 'COURSE.DLI C '\nclusterTab = clusterTab || 'STAFF.DLI S '\nclusterTab = clusterTab || 'BK. B '\nclusterTab = clusterTab || 'EZT. E '\nclusterTab = clusterTab || 'FINAID.SAFE A '\nclusterTab = clusterTab || 'IC. I '\nclusterTab = clusterTab || 'PROD.CICS P '\nclusterTab = clusterTab || 'SORT. Z '\nclusterTab = clusterTab || 'SQL Q '\nctwords = words(clusterTab)\n/*------------------------*/\n/* parse LIST ALL info... */\n/*------------------------*/\nsay 'Parsing LIST ALL...'\nuseit = 'N'\ndo until rc \u00ac= 0\n   'EXECIO 1 DISKR' fin '0'\n   if rc = 0 then do\n      parse pull inrec\n      call Seek2\n      end\n   end\n/*---------------------------*/\n/* Print final space maps... */\n/*---------------------------*/\nsay 'Printing Final Maps...'\ndo i = 1 to volcnt\n   do j = 1 to DSPTOT.i\n      orec = '0' || VOLNAM.i || ' ' || format(j,2) || ' SPACE MAP:'\n      'EXECIO 1 DISKW' fout '0 ( VAR OREC'\n      olines = length(OMAP.i.j) / 132\n      p = pos('.',olines)\n      if p > 0 then olines = substr(olines,1,(p-1)) + 1\n      mappos = -131\n      do k = 1 to olines\n         mappos = mappos + 132\n         orec = '0' || substr(OMAP.i.j,mappos,132)\n         'EXECIO 1 DISKW' fout '0 ( VAR OREC'\n         end\n      end\n   end\n/*--------------*/\n/* Terminate... */\n/*--------------*/\nexit 0\n/* Procedure to parse LIST SPACE ALL output ... */\nSeek:\nselect\n   when substr(inrec,1,8) = 'IDC0001I' then do\n        endit = 'Y'\n        xlast = 'END'\n        end\n   when substr(inrec,30,24) = 'LISTING FROM CATALOG -- ' then do\n        catnam = strip(substr(inrec,54,48))\n        xlast = 'CAT'\n        end\n   when substr(inrec,1,16) = 'VOLUME -------- ' then do\n        volcnt = volcnt + 1\n        VOLNAM.volcnt = substr(inrec,17,6)\n        DSPTOT.volcnt = 0\n        dspcnt = 0\n        xlast = 'VOL'\n        end\n   when substr(inrec,1,14) = '     DATASPACE' then do\n        dspcnt = dspcnt + 1\n        DSPTOT.volcnt = dspcnt\n        xlast = 'DSP'\n        end\n   when substr(inrec,1,15) = '       DATASETS' then do\n        inrec = translate(inrec,' ','-')\n        DSNTOT.volcnt.dspcnt = strip(substr(inrec,27,5))\n        dsncnt = 0\n        xlast = 'DSET'\n        end\n   when substr(inrec,1,19) = '       BLOCKS-TOTAL' then do\n        inrec = translate(inrec,' ','-')\n        BLKTOT.volcnt.dspcnt = strip(substr(inrec,20,12))\n        BLKBEG.volcnt.dspcnt = strip(substr(inrec.47,14))\n        BLKEND.volcnt.dspcnt = BLKBEG.volcnt.dspcnt + ,\n                               BLKTOT.volcnt.dspcnt - 1\n        SPCMAP.volcnt.dspcnt = strip(substr(inrec,86,34))\n        xlast = 'BTOT'\n        end\n   when substr(inrec,1,85) = ' ' & xlast = 'BTOT' then do\n        a = SPCMAP.volcnt.dspcnt\n        b = strip(substr(inrec,86,34))\n        SPCMAP.volcnt.dspcnt = a || b\n        end\n   when substr(inrec,1,18) = '       BLOCKS-USED' then do\n        inrec = translate(inrec,' ','-')\n        BLKUSE.volcnt.dspcnt = strip(substr(inrec,20,12))\n        xlast = 'BUSE'\n        end\n   when substr(inrec,1,16) = '         DSN----' then do\n        dsncnt = dsncnt + 1\n        DSNNAM.volcnt.dspcnt.dsncnt = strip(substr(inrec,17,48))\n        xlast = 'DSN'\n        end\n   otherwise do\n        xlast = 'JUNK'\n        end\n   end\nreturn\n/* Procedure to parse LIST ALL output ... */\nSeek2:\nselect\n   when substr(inrec,1,16) = 'CLUSTER ------- ' then do\n        useit = 'N'\n        clsnam = strip(substr(inrec,17,48))\n        do i = 1 to (ctwords - 1) by 2\n           z = word(clusterTab,i)\n           if z = substr(clsnam,1,length(z)) then do\n              chrsub = word(clusterTab,(i+1))\n              useit = 'Y'\n              leave i\n              end\n           end\n        xlast = 'CLS'\n        end\n   when useit = 'N' then do\n        nop\n        end\n   when substr(inrec,8,6) = 'VOLSER' then do\n        inrec = translate(inrec,' ','-')\n        volser = strip(substr(inrec,26,6))\n        xlast = 'VSER'\n        end\n   when substr(inrec,8,9) = 'LOW-BLOCK' then do\n        inrec = translate(inrec,' ','-')\n        lowblk = strip(substr(inrec,18,14))\n        xlast = 'LBLK'\n        end\n   when substr(inrec,8,10) = 'HIGH-BLOCK' then do\n        inrec = translate(inrec,' ','-')\n        hiblk = strip(substr(inrec,19,13))\n        totblk = hiblk - lowblk + 1\n        do i = 1 to volcnt\n           if VOLNAM.i = volser then do j = 1 to DSPTOT.i\n              if lowblk \u00ac< BLKBEG.i.j & hiblk \u00ac> BLKEND.i.j then do\n                 opos = lowblk / 64\n                 p = pos('.',opos)\n                 if p > 0 then opos = substr(opos,1,(p-1)) + 1\n                 ocnt = totblk / 64\n                 OMAP.i.j = overlay(chrsub,OMAP.i.j,opos,ocnt,chrsub)\n                 leave i\n                 end\n              end\n           end\n        xlast = 'HBLK'\n        end\n   otherwise do\n        xlast = 'JUNK'\n        end\n   end\nreturn\n\nLawrence Holder\nSenior Programmer/Analyst\nThe University of Tennessee at Martin (USA)                  c UTMCC 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A006A07": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12Y\\x00/\\x00.\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:59:38", "lines": 47, "newlines": 46, "modlines": 0, "user": "VSAMUPD"}, "text": "Catalog back-up process - revisited\n\nThe article Catalog back-up process in VSAM Update issue 5\n(April 1992) inspired me to add the following precautionary\nsteps which are important when doing maintenance to a\ncatalog.\n\nFor integrity reason, concurrent (update) access to an integrated\nuser catalog must be avoided when doing maintenance to a\ncatalog. The catalog should be locked using the IDCAMS\nALTER LOCK function, and unlocked after maintenance is\ndone so that normal operations can resume. The following is a\nsample JCL to lock and unlock a catalog,\n\n//LOCK      EXEC PGM = IDCAMS\n//SYSPRINT  DD SYSOUT= *\n//SYSIN     DD *\n   ALTER Catalog-Name LOCK CATALOG(Catalog-Name)\n\n//UNLOCK    EXEC PGM = IDCAMS\n//SYSPRINT  DD SYSOUT= *\n//SYSIN     DD *\n   ALTER Catalog-Name UNLOCK CATALOG(Catalog-Name)\n\nBefore we lock a catalog we need to be certain that at least one\nuser can access the catalog after it is locked, otherwise nobody\ncan access it. In our site we use RACF to control catalog\nfunction. The following RACF command shows how to\naccomplish the above task:\n\n      RDEFINE FACILITY IGG.CATLOCK UACC(NONE) OWNER(Owner-id)\n      PERMIT CLASS(FACILITY) IGG.CATLOCK ID(Cat-Admin) ACC(READ)\n      SETROPTS CLASSACT(FACILITY)\n\nThe RDEFINE command defines a RACF source profile name\nIGG.CATLOCK in class FACILITY with universal access\nNONE and assign Owner-id as the owner of the profile. The\nPERMIT command lets Cat-Admin access the catalog when the\ncatalog is locked, and the SETROPTS command activates the\nFACILITY class in RACF.\n\nI hope this will help other readers when doing catalog\nmaintenance in their shops.\n\nGunawan Lucas\nSystems Programmer (Indonesia)        c Gunawan Lucas 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A007A00I": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 14, "newlines": 14, "modlines": 0, "user": "VSAMUPD"}, "text": "A007 - VSAM Update issue 7 October 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA007A01   Printing keys from a KSDS\nA007A02   Automating catalog and VVDS error correction\nA007A03   Monitoring used space for VSAM datasets\nA007A04   VSAM volume dataset manipulation\nA007A05   An easy way to print VSAM file contents\nA007A06   Calculating read hit and write hit ratios - revisited\nA007A07   Load a KSDS or ESDS\nA007A08   REUSE and performance\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A007A01": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x02\\n\\x02\\n\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 522, "newlines": 522, "modlines": 0, "user": "VSAMUPD"}, "text": "Printing keys from a KSDS\n\nThis is an Assembler program that will process a KSDS and\nreport the physical CI and CA number for all keys processed.\nThis output may be useful in determining volatile key ranges.\n\nBy default, all the keys from the input object will be printed.\nTo print a range, an optional job step parameter must be\nprovided. The parameter specifies the start and stop record\nnumbers, expressed as 9-digit integers. The input object may\nnot contain spanned records because LOCATE mode\nprocessing is performed.\n\nVSAMKEYP TITLE 'PROGRAM FOR PRINTING RBA, CA #, CI # AND KEY'\n         PRINT NOGEN\n         SPACE 1\n*        SUGGESTED JCL - TO PRINT ALL KEYS (BY DEFAULT)\n         SPACE 1\n*        //       EXEC PGM=VSAMKEYP\n*        //SYSUDUMP DD SYSOUT=*\n*        //SYSPRINT DD SYSOUT=*\n*        //VSAM     DD DSN=CLUSTER.NAME,DISP=SHR\n         SPACE 1\n*        SUGGESTED JCL - TO PRINT A RANGE OF KEYS\n         SPACE 1\n*        //       EXEC PGM=VSAMKEYP,PARM='000000001000000010'\n*        //SYSUDUMP DD SYSOUT=*\n*        //SYSPRINT DD SYSOUT=*\n*        //VSAM     DD DSN=CLUSTER.NAME,DISP=SHR\n         SPACE 1\n*        THIS WILL CAUSE THE FIRST 10 KEYS FROM THE NAMED CLUSTER TO\n*        BE PRINTED.\n         TITLE 'MACROS, DSECTS AND CONTROL BLOCKS USED'\n*        ABEND                          ABEND THE PROGRAM\n*        ACB                            ACCESS METHOD CONTROL BLOCK\n*        CLOSE                          CLOSE FILE(S)\n*        DCB                            DATA CONTROL BLOCK\n*        DCBD (IHADCB)                  DCB DSECT MAPPING\n*        EXLST                          EXIT LIST\n*        FREEMAIN                       RELEASE STORAGE\n*        FREEPOOL                       RELEASE BUFFER POOL\n*        GET - VSAM                     ACCESS A RECORD\n*        GETMAIN                        ACQUIRE STORAGE\n*        IDAAMB                         AMB DSECT MAPPING\n*        IDAAMBL                        AMBL DSECT MAPPING\n*        IDAAMDSB                       AMDSB DSECT MAPPING\n*        IEFJFCBN                       JFCB MAPPING\n*        IFGACB                         ACB DSECT MAPPING\n*        OPEN                           PREPARE FILE(S) FOR PROCESSING\n*        PUT - QSAM                     WRITE A RECORD\n*        RDJFCB                         READ SPECIFIC JFCB\n*        RPL                            REQUEST PARAMETER LIST\n*        SHOWCB                         OBTAIN DATA FOR VSAM OBJECT\n*        TESTCB                         TEST A VSAM CONTROL BLOCK\n*        WTO                            WRITE TO OPERATOR\n         SPACE 2\n*        REGISTER EQUATES\n         SPACE 1\n\nEditor's note: register equates go here.\n\n         TITLE 'PROGRAM INITIALIZATION CODE'\n*        1.    PROGRAM PROLOG\n*        2.    PROCESS THE JOB STEP PARAMETER, IF PRESENT\n*        3.    PROGRAM INITIALIZATION\n*        4.    MAIN PROCESSING\n*        5.    PROGRAM TERMINATION\n*        6.    PROGRAM EPILOG\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        10                             . BRANCH AND SAVE\n*        12                             . CSECT BASE REGISTER\n*        13                             . -> SAVE AREA\n*        14                             . -> RETURN\n*        15                             . -> ENTRY POINT\n         SPACE 2\nVSAMKEYP CSECT\n         STM   R14,R12,12(R13)          . SAVE CALLER'S REGISTERS\n         LR    R12,R15                  . LOAD 12 AS PROGRAM BASE\n         USING VSAMKEYP,R12             . ESTABLISH ADDRESSABILITY\n         GETMAIN R,                     . GETMAIN FOR SAVE AREA        C\n               LV=72\n         ST    R13,4(,R1)               . BACKWARD SAVE AREA ->\n         ST    R1,8(,R13)               . FORWARD SAVE AREA ->\n         LR    R13,R1                   . 13 -> PROGRAM'S SAVE AREA\n         BAS   R10,JOBPARM              . PROCESS JOB STEP PARAMETER\n         BAS   R10,INITIAL              . PROGRAM INITIALIZATION\n         BAS   R10,PROCESS              . MAIN PROCESSING\n         BAS   R10,TERMIN               . TERMINATION PROCESSING\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN SAVE AREA           C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN\n         SLR   R15,R15                  . 15 - ZERO\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         TITLE 'CODE PROCESSING THE OPTIONAL JOB STEP PARAMETER'\n*        1.    ACCESS CALLER'S SAVE AREA\n*        2.    CHECK LENGTH OF JOB STEP PARAMETER\n*        3.    IF NO JOB STEP PARAMETER - DEFAULT TO ALL\n*        4.    IF JOB STEP PARAMETER PRESENT, EDIT FOR NUMERIC\n*        5.    IF JOB STEP PARAMETER NOT NUMERIC - DEFAULT TO ALL\n*        6.    SAVE RANGE OF LOGICAL RECORD NUMBERS TO PROCESS\n*\n*        REGISTER USAGE\n*        1                              . WORK\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nJOBPARM  EQU   *\n         MVI   PARM,OFF                 . SWITCH OFF PARAMETER SWITCH\n         L     R1,4(,R13)               . 1 -> CALLER'S SAVE AREA\n         L     R1,24(,R1)               . 1 -> ADDRESS OF PARAMETER\n         L     R1,0(,R1)                . 1 -> JOB STEP PARAMETER\n         OC    0(2,R1),0(R1)            . Q. PARAMETER PRESENT?\n         BZR   R10                      . A. NO - EXIT\n         MVC   TEST(18),ZEROS           . EDIT PARAMETER FOR NUMERIC\n         MVZ   TEST(18),2(R1)\n         CLC   TEST(18),ZEROS           . Q. ZONE BYTES ALL 'F'?\n         BNE   B0001                    . A. NO - ABEND\n         PACK  FROM#(5),2(9,R1)         . SAVE STARTING RECORD NUMBER\n         PACK  TO#(5),11(9,R1)          . SAVE ENDING RECORD NUMBER\n         MVI   PARM,ON                  . INDICATE VALID PARAMETER\n         BR    R10                      . EXIT\nB0001    EQU   *\n*                                       . NON-NUMERIC PARAMETER\n         WTO   'NON NUMERIC JOB STEP PARAMETER ENTERED',               C\n               ROUTCDE=11\n         ABEND 100,                                                    C\n               DUMP\n         TITLE 'CODE PROCESSING JFCB, FILE OPENS, ETC'\n*        1.    ISSUE READ JFCB\n*        2.    OPEN FILES AND CHECK OPENS\n*        3.    CHECK FOR NON-SPANNED KSDS BEING INPUT\n*        4.    ISSUE SHOWCB AND ACCESS VSAM CONTROL BLOCKS TO OBTAIN\n*              CI SIZE, KEY LENGTH, RELATIVE KEY POSITION\n*        5.    COMPUTE BYTES PER CA\n*        6.    INITIALIZE DATA AREAS\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . -> ACB\n*                                       . -> DCB\n*                                       . -> AMBL\n*                                       . -> AMB\n*                                       . -> AMDSB\n*                                       . COMPUTATION\n*        3                              . COMPUTATION\n*        4                              . KEY LENGTH\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nINITIAL  EQU   *\n         RDJFCB DUMMY                   . ISSUE RDJFCB\n         LTR   R15,R15                  . Q. RDJFCB SUCCESSFUL?\n         BNZ   C0001                    . A. NO\n         MVC   DSNTITLE,JFCBDSNM        . SAVE DSNAME\nC0001    EQU   *\n         OPEN  (VSAM,,SYSPRINT,OUTPUT)\n         LTR   R15,R15                  . Q. OPENS OKAY?\n         BZ    C0002                    . A. YES\n         USING IFGACB,R2                . ACB DSECT ADDRESSABILITY\n         LA    R2,VSAM                  . 2 -> VSAM ACB\n         TM    ACBOFLGS,ACBOPEN         . Q. VSAM OPEN OKAY?\n         BNO   C0003                    . A. NO\n         DROP  R2                       . DSECT NOT REQUIRED\n         USING IHADCB,R2                . DCB DSECT ADDRESSABILITY\n         LA    R2,SYSPRINT              . 2 -> SYSPRINT DCB\n         TM    DCBOFLGS,DCBOFOPN        . Q. SYSPRINT OPEN OKAY?\n         BNO   C0004                    . A. NO - OPEN FAILED\n         DROP  R2                       . DCB DSECT NOT REQUIRED\nC0002    EQU   *\n*                                       . CHECK FOR SPANNED RECORDS\n*                                       . BEING PERMITTED ON OBJECT\n*\n         TESTCB ACB=VSAM,               . Q. SPANNED RECORDS ALLOWED?  C\n               ATRB=SPAN\n         BE    C0005                    . A. YES - TERMINATE PROCESSING\n*                                       . DETERMINE TYPE OF OBJECT\n         TESTCB ACB=VSAM,               . Q. INPUT A KSDS?             C\n               ATRB=KSDS\n         BNE   C0006                    . A. NO - TERMINATE PROCESSING\n*                                       . DETERMINE KEY LENGTH,\n*                                       .   RELATIVE KEY POSITION AND\n*                                       .   CI SIZE FOR DATA COMPONENT\n         SHOWCB ACB=VSAM,                                              C\n               AREA=#KEY,                                              C\n               FIELDS=(KEYLEN,RKP,CINV),                               C\n               LENGTH=12\n*                                       . COMPUTE BYTES PER CA\n         LA    R2,VSAM                  . 2 -> ACB\n         USING IFGACB,R2                . DSECT ADDRESSABILITY\n         L     R2,ACBAMBL               . 2 -> AMBL\n         DROP  R2\n         USING IDAAMBL,R2               . DSECT ADDRESSABILITY\n         L     R2,AMBLDTA               . 2 -> DATA COMPONENT AMB\n         DROP  R2\n         USING IDAAMB,R2                . DSECT ADDRESSABILITY\n         L     R2,AMBDSB                . 2 -> AMDSB\n         DROP  R2\n         USING IDAAMDSB,R2              . DSECT ADDRESSABILITY\n         LH    R3,AMDCIPCA              . 3 - CIS PER CA\n         DROP  R2\n         M     R2,CISZ                  . MULTIPLY BY CI SIZE\n         ST    R3,CASZ                  . SAVE BYTES PER CA\n*                                       . INITIALIZE DATA FIELDS\n         MVI   OUTKEY,C' '              . OUTPUT KEY FIELD\n         MVC   OUTKEY+1(L'OUTKEY-1),OUTKEY\n         XC    OLDRBA,OLDRBA            . RBA SAVE AREA\n         ZAP   #PAGE,=P'+1'\n         ZAP   #LINE,=P'+60'\n         ZAP   #READ,=P'+0'\n         ZAP   #PRINT,=P'+0'\n*                                       . MAX OF 101 BYTES OF KEY IS\n*                                       .   PRINTED.  R4 USED FOR\n*                                       .   EXECUTED MOVE OF KEY\n         L     R4,#KEY                  . 4 - KEY LENGTH\n         BCTR  R4,R0                    . DECREMENT BY ONE\n         CH    R4,=H'+100'              . Q. KEY MORE THAN 101 BYTES?\n         BNHR  R10                      . A. NO - EXIT\n         LA    R4,100                   . MAXIMUM 101 BYTES ALLOWED\n         BR    R10                      . EXIT\n         TITLE 'INITIAL PROCESSING - ERRORS'\nC0003    EQU   *\n*                                       . OPEN FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         WTO   'OPEN FAILURE FOR FILE VSAM',                           C\n               ROUTCDE=11\n*\n         SHOWCB ACB=VSAM,               . OBTAIN ACB ERROR CODE        C\n               AREA=OPENERR,                                           C\n               FIELDS=ERROR,                                           C\n               LENGTH=4\n         LM    R2,R3,VSAMERR            . 2 - 3 VSAM ERROR CODES\n         ABEND 101,                     . ABEND THE TASK               C\n               DUMP\n         SPACE 2\nC0004    EQU   *\n*                                       . OPEN FAILURE SYSPRINT\n         WTO   'OPEN FAILURE FOR FILE SYSPRINT',                       C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN OF SAVE AREA        C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,10                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         SPACE 2\nC0005    EQU   *\n*                                       . ACB PERMITS SPANNED RECORDS\n         WTO   'OBJECT PERMITS SPANNED RECORDS',                       C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN OF SAVE AREA        C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,20                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         SPACE 2\nC0006    EQU   *\n*                                       . ONLY KSDS PERMITTED\n         WTO   'ONLY KSDS OBJECTS PERMITTED',  ,                       C\n               ROUTCDE=11\n         LR    R2,R13                   . 2 -> SAVE AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN OF SAVE AREA        C\n               A=(R2),                                                 C\n               LV=72\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,30                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         TITLE 'MAIN PROCESSING LOGIC OF PROGRAM'\n*        1.    GET THE NEXT LOGICAL RECORD\n*        2.    IF JOB STEP PARAMETER SPECIFIED, DETERMINE IF IN\n*              REQUIRED RANGE\n*        3.    DETERMINE THE RBA OF THE RECORD READ\n*        4.    CHECK FOR HEADING REQUIREMENTS\n*        5.    FORMAT AND OUTPUT DETAIL LINE\n*        6.    PROCESS NEXT RECORD\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . COMPUTATION\n*        3                              . COMPUTATION\n*        4                              . KEY LENGTH\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nPROCESS  EQU   *\n         ST    R10,DSAVE                . SAVE 10\nD0001    EQU   *\n         GET   RPL=GETRPL               . GET THE NEXT RECORD\n         LTR   R15,R15                  . Q. VSAM GET OKAY?\n         BNZ   D0005                    . A. NO - GET FAILED\n         AP    #READ,=P'+1'             . INCREMENT RECORDS READ\n         CLI   PARM,ON                  . Q. VALID JOB STEP PARAMETER?\n         BNE   D0002                    . A. NO - PRINT THE RECORD\n         CP    #READ,FROM#              . Q. BEFORE START OF RANGE?\n         BL    D0001                    . A. YES - READ NEXT RECORD\n         CP    #READ,TO#                . Q. BEYOND END OF RANGE?\n         BH    D0004                    . A. YES - TERMINATE PROCESSING\nD0002    EQU   *\n         SHOWCB RPL=GETRPL,             . DETERMINE RBA OF RECORD      C\n               AREA=RECRBA,                                            C\n               FIELDS=RBA,                                             C\n               LENGTH=4\n         CP    #LINE,=P'+57'            . Q. HEADINGS REQUIRED?\n         BL    D0003                    . A. NO\n         BAS   R10,HEADING              . OUTPUT HEADINGS\nD0003    EQU   *\n*                                       . FORMAT DETAIL LINE\n         MVC   OUTRBA,MASK9             . OUTPUT RBA\n         L     R3,RECRBA\n         CVD   R3,WORKD\n         ED    OUTRBA,WORKD+3\n         SLR   R2,R2                    . COMPUTE CA NUMBER\n         D     R2,CASZ\n         LA    R3,1(,R3)\n         MVC   OUTCA#,MASK5             . OUTPUT CA NUMBER\n         CVD   R3,WORKD\n         ED    OUTCA#,WORKD+5\n         SRDA  R2,32(R0)                . COMPUTE CI NUMBER\n         D     R2,CISZ\n         LA    R3,1(,R3)\n         MVC   OUTCI#,MASK5             . OUTPUT CI NUMBER\n         CVD   R3,WORKD\n         ED    OUTCI#,WORKD+5\n*                                       . CHECK FOR ASCENDING RBA\n         MVI   OUTSEQ,C' '              . INITIALIZE OUTPUT AREA\n         CLC   RECRBA,OLDRBA            . Q. ASCENDING RBA SEQUENCE?\n         BNL   *+8                      . A. YES\n         MVI   OUTSEQ,C'*'              . A. NO - INDICATE\n*                                       . FORMAT KEY VALUE\n         L     R2,@REC                  . 2 -> RECORD\n         L     R3,RKP                   . 3 - RELATIVE KEY POSITION\n         LA    R2,0(R3,R2)              . 2 -> KEY VALUE\n         EX    R4,MVC                   . MOVE KEY DATA\n         TR    OUTKEY,PRTBL             . MAKE PRINTABLE\n         PUT   SYSPRINT,                . OUTPUT DETAIL LINE           C\n               OUTLINE\n         AP    #LINE,=P'+1'             . INCREMENT LINE ACCUMULATOR\n         AP    #PRINT,=P'+1'            . INCREMENT PRINT ACCUMULATOR\n         B     D0001                    . PROCESS NEXT RECORD\nD0004    EQU   *\n         L     R10,DSAVE                . RESTORE 10\n         BR    R10                      . EXIT\nMVC      MVC   OUTKEY(0),0(R2)          . EXECUTED MOVE OF KEY VALUE\n         TITLE 'MAIN PROCESSING - ACCESS ERROR'\nD0005    EQU   *\n*                                       . GET FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         WTO   'GET FAILURE FOR FILE VSAM',                            C\n               ROUTCDE=11\n         SHOWCB RPL=GETRPL,             . OBTAIN RPL FEED BACK CODE    C\n               AREA=RPLFDBK,                                           C\n               FIELDS=FDBK,                                            C\n               LENGTH=4\n         LM    R2,R4,VSAMERR            . 2 - 4 VSAM ERROR CODES\n         ABEND 102,                     . ABEND THE TASK               C\n               DUMP\n         TITLE 'END OF PROCESSING ROUTINE'\n*        1.    OUTPUT TOTALS\n*        2.    CLOSE FILES\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nTERMIN   EQU   *\n         ST    R10,ESAVE                . SAVE 10\n         BAS   R10,HEADING\n         MVC   OUTPRNT,MASK9            . OUTPUT KEYS PRINTED\n         ED    OUTPRNT,#PRINT\n         PUT   SYSPRINT,                                               C\n               TOTLINE\n         CLOSE (VSAM,,SYSPRINT)         . CLOSE FILES\n         FREEPOOL SYSPRINT              . FREE BUFFER POOL\n         L     R10,ESAVE                . RESTORE 10\n         BR    R10                      . EXIT\n         TITLE 'REPORT PAGE HEADING ROUTINE'\nHEADING  EQU   *\n         SPACE 1\n*        1.    OUTPUT PAGE NUMBER\n*        2.    OUTPUT HEADING\n*        3.    OUTPUT SUB-HEADING\n*        4.    ADJUST ACCUMULATORS\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        10                             . BRANCH AND SAVE\n         SPACE 2\n         MVC   PAGEOUT,MASK5            . FORMAT PAGE NUMBER\n         ED    PAGEOUT,#PAGE\n         PUT   SYSPRINT,                . OUTPUT HEADINGS              C\n               TITLE\n         PUT   SYSPRINT,                                               C\n               STITLE1\n         AP    #PAGE,=P'+1'             . INCREMENT PAGE NUMBER\n         ZAP   #LINE,=P'+3'             . RESET LINES ON PAGE\n         BR    R10                      . EXIT\n         TITLE 'DATA AREAS'\nWORKD    DS    D                        . DOUBLE WORD FOR CVD\n@REC     DS    F                        . ADDRESS OF RECORD READ\nDSAVE    DS    F                        . REGISTER SAVE AREA\nESAVE    DS    F                        . REGISTER SAVE AREA\n#KEY     DS    F                        . KEY LENGTH - SHOWCB\nRKP      DS    F                        . RKP        - SHOWCB\nCISZ     DS    F                        . CI SIZE    - SHOWCB\nCASZ     DS    F                        . CA SIZE IN BYTES\nOLDRBA   DS    F                        . PREVIOUS RECORD'S RBA\nRECRBA   DS    F                        . RECORD'S RBA - SHOWCB\nVSAMERR  DS    0F                       . VSAM ERROR FIELDS\nREG15    DS    F                        . CONTENT OF R15\nOPENERR  DS    F                        . ACB ERROR CODE\nRPLFDBK  DS    F                        . RPL FEED BACK CODE\n#READ    DS    PL5                      . RECORDS READ ACCUMULATOR\n#PRINT   DS    PL5                      . RECORDS PRINTED ACCUMULATOR\nFROM#    DS    PL5                      . RANGE START\nTO#      DS    PL5                      . RANGE END\n#LINE    DS    PL2                      . LINES PRINTED ACCUMULATOR\n#PAGE    DS    PL3                      . PAGES PRINTED ACCUMULATOR\nPARM     DS    CL1                      . STEP PARAMETER SWITCH\nON       EQU   X'01'                    . LOGICAL ON\nOFF      EQU   X'00'                    . LOGICAL OFF\nTEST     DS    CL18                     . NUMERIC TEST WORK AREA\nZEROS    DC    18C'0'                   . NUMERIC TEST SEED VALUE\nMASK5    DC    XL6'402020202120'        . EDIT MASK\nMASK9    DC    XL10'40202020202020202120'\nTITLE    DC    CL23'1'\n         DC    CL42'RBA AND KEY CONTENT LISTING OF DATASET: '\nDSNTITLE DC    CL44' '\n         DC    CL11' '\n         DC    CL4'PAGE'\nPAGEOUT  DS    CL6\n         DC    CL3' '\nSTITLE1  DC    CL133'0        RBA        CA#   CI#   KEY'\nOUTLINE  DC    CL2' '\nOUTRBA   DS    CL10\n         DC    CL2' '\nOUTSEQ   DS    CL1\n         DC    CL2' '\nOUTCA#   DS    CL6\nOUTCI#   DS    CL6\n         DC    CL3' '\nOUTKEY   DS    CL101\nTOTLINE  DC    CL23'0   TOTAL KEYS PRINTED:'\nOUTPRNT  DS    CL10\n         DC    CL100' '\n         TITLE 'TRANSLATE TABLES'\nPRTBL    DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'404B4B4B4B4B4B4B4B4B4A4B4C4D4E4F'\n         DC    X'504B4B4B4B4B4B4B4B4B5A5B5C5D5E5F'\n         DC    X'60614B4B4B4B4B4B4B4B4B6B6C6D6E6F'\n         DC    X'4B4B4B4B4B4B4B4B4B4B7A7B7C7D7E7F'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4BC1C2C3C4C5C6C7C8C94B4B4B4B4B4B'\n         DC    X'4BD1D2D3D4D5D6D7D8D94B4B4B4B4B4B'\n         DC    X'4B4BE2E3E4E5E6E7E8E94B4B4B4B4B4B'\n         DC    X'F0F1F2F3F4F5F6F7F8F94B4B4B4B4B4B'\n         TITLE 'CONTROL BLOCKS'\nVSAM     ACB   AM=VSAM,                 . VSAM ACB                     C\n               DDNAME=VSAM,                                            C\n               EXLST=EXITLST,                                          C\n               MACRF=(KEY,SEQ)\nGETRPL   RPL   ACB=VSAM,                . RPL TO READ VSAM             C\n               AM=VSAM,                                                C\n               AREA=@REC,                                              C\n               AREALEN=4,                                              C\n               OPTCD=(KEY,SEQ,LOC)\nEXITLST  EXLST EODAD=D0004              . EXIT LIST FOR VSAM\nSYSPRINT DCB   BLKSIZE=15428,           . SYSPRINT DCB                 C\n               DDNAME=SYSPRINT,                                        C\n               DSORG=PS,                                               C\n               LRECL=133,                                              C\n               MACRF=PM,                                               C\n               RECFM=ABFS\nDUMMY    DCB   DDNAME=VSAM,             . DUMMY DCB FOR RDJFCB         C\n               DSORG=PS,                                               C\n               EXLST=DCBEXIT,                                          C\n               MACRF=GM\n         DS    0F                       . FULL WORD ALIGN DCB EXIT\nDCBEXIT  DC    X'87'                    . READ JFCB\n         DC    AL3(INFMJFCB)\n         IEFJFCBN                       . JFCB MAPPING\n         TITLE 'DUMMY SECTIONS'\n         DCBD  DEVD=DA,                 . DCB MAPPING DSECT            C\n               DSORG=PS\n         IFGACB                         . ACB MAPPING DSECT\nIDAAMBL  DSECT                          . AMBL MAPPING DSECT\n         DS    XL52\nAMBLDTA  DS    F\nIDAAMB   DSECT                          . AMB MAPPING DSECT\n         DS    XL20\nAMBDSB   DS    F\nIDAAMDSB DSECT                          . AMDSB MAPPING DSECT\n         DS    XL12\nAMDCIPCA DS    H\n         TITLE 'LITERALS AND TERMINATION'\nVSAMKEYP CSECT                          . RE-ESTABLISH CSECT\n         LTORG\n         END\n\nDave Loveluck\nInstructor/Consultant (USA)                         c Dave Loveluck 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A007A02": {"ttr": 8453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\xd8\\x01\\xd8\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 472, "newlines": 472, "modlines": 0, "user": "VSAMUPD"}, "text": "Automating catalog and VVDS error correction\n\nSomething many data centres tend to ignore, except when there\nis a critical problem, is routine error detection on VVDS and\nICF catalog structures. Since early detection of errors can lead\nto timely correction of system related problems, I decided to\ntake an aggressive approach to identifying errors on a\nscheduled basis. The facility used within MVS to determine\nerror situations is typically the DIAGNOSE command under\nIDCAMS. When an out-of-sync or illogical condition arises in\nor between a VVDS and catalog, the DIAGNOSE process can\nbe used to specifically identify what error condition exists and\nthen appropriate action can be taken. Problems with a VVDS\nor catalog can occur any number of ways. I have seen them\ncaused by items such as system bugs, system upgrades, system\ncrashes, and system programmer procedural errors. Regardless\nof how the problems occur, it is important that they are\nidentified and fixed, and their origin understood so that future\nproblems are avoided.\n\nAs mentioned, IDCAMS DIAGNOSE provides a way of\ndetermining what errors exist. To determine structures that are\ncandidates for analysis, it is necessary to know all catalogs,\nVVDSs, and accompanying relationships in the environment. I\nhad periodically taken the time to understand and code up\nDIAGNOSE jobs that matched our structures. However, I was\nconcerned that an ever changing environment would not be\nproperly analyzed without frequent and error-prone changes to\na fairly large jobstream. To avoid the time required to\nunderstand what needed analyzing, I wrote a program to\ndynamically determine the catalogs, VVDSs, and inter-\nrelationships in the environment, and in turn invoke\nDIAGNOSE on their behalf.\n\nThe Assembler program, called AUTODIAG, was written to\nretrieve data from IDCAMS LISTCAT and DCOLLECT which\nis used to determine the current catalog and VVDS structures.\nSince some problems are detected only by comparing\nstructures, DIAGNOSE offers the ability to compare entries\nbetween a catalog and a VVDS. This maximizes the\nopportunity to find corrupted information. AUTODIAG\nexploits comparison processing to its fullest by including a\nCOMPAREDS of all VVDSs in a catalog up to the first 99 - an\nIDCAMS limitation. Likewise, when AUTODIAG is\nprocessing a VVDS, the entire catalog structure is used in a\nCOMPAREDS. If a VVDS happens to not have an entry\npointing to a compared catalog, there is a simple warning\nmessage which can be ignored.\n\nDFSMS is active in my shop so a VVDS dataset exists on\nnearly all the volumes. In the pre-DFSMS environment, VVDS\nstructures were found only on volumes containing VSAM\ndatasets. DIAGNOSE is applicable to a VVDS in either\nsituation, but different relationships and checks take place. A\ngood discussion of what problems are detected and possible\nways to correct them can be found in the IBM manual related\nto catalog administration. Depending on your release of DFP,\nthe manual name may be either Catalog Administration Guide\nor Managing Catalogs.\n\nIn addition to providing the ability to interface with\nDIAGNOSE in a changing environment, I found it useful for\nAUTODIAG to determine what errors were new since the\nprevious run. After examining DIAGNOSE output a few times,\nit was evident that some situations were acceptable and\ncorrective action was never taken. One example was when a\ncatalog was removed from the system. Some VVDSs still\ncontained a reference to it. Since the message given to indicate\nthis situation was justified and acceptable, it was not worth\nrebuilding the VVDS to correct. However, the message\ncontinued to show up on each run. To permit a quick review of\nonly the most recent errors, AUTODIAG determines which\nmessages are new since the previous run and marks them with\na bar in the first column of the DIAGPRNT report. The\nDIAGPRNT report is constructed from a DIAGNOSE\nSYSPRINT of all requests, and should be used to recognize\nand correct error situations as you would with any DIAGNOSE\nreport.\n\nI decided to run AUTODIAG weekly. The idea was to run it\noften enough to detect problems before they got too far out of\ncontrol. The activity generated by AUTODIAG on the catalog\nand VVDS structures is best performed during periods of low\nsystem activity so minimal contention takes place. In my\nenvironment, with approximately 90 volumes and 11 catalogs\ncontaining 18,000 datasets to examine, the process takes about\n60 minutes. To follow the progress of the job, WTO messages\nare issued indicating which catalog or VVDS is being\nprocessed. As an indicator of which structures should be\nreviewed in the DIAGPRNT report, a WTO is issued for any\ncatalog or VVDS receiving a return code greater than 4 in the\nDIAGNOSE. A copy of the JCL required to run AUTODIAG\nalong with the code follows. Note that on the first run of this\njob the PRIOR DD should be DUMMY.\n\n\nJCL\n\n//STEP1    EXEC PGM=AUTODIAG\n//SYSOUT   DD   SYSOUT=*\n//LISTPRNT DD   SYSOUT=*\n//DIAGPRNT DD   SYSOUT=*\n//PRIOR    DD   DSN=SYS2.AUTODIAG.SAVE(0),DISP=SHR\n//CURRENT  DD   DSN=SYS2.AUTODIAG.SAVE(+1),DISP=(,CATLG,DELETE),\n//    SPACE=(CYL,(1,1))\n//SORTEDP  DD   UNIT=VIO,SPACE=(CYL,(10,1))\n//SORTEDC  DD   UNIT=VIO,SPACE=(CYL,(10,1))\n//SYSPRINT DD   UNIT=VIO,SPACE=(CYL,(10,1))\n//SYSIN    DD   UNIT=VIO,SPACE=(CYL,(10,1))\n//SORTIN   DD   UNIT=VIO,SPACE=(CYL,(10,1))\n//SORTOUT  DD   UNIT=VIO,SPACE=(CYL,(10,1))\n//DCOLLECT DD   UNIT=VIO,SPACE=(CYL,(10,1)),\n//  DCB=(LRECL=264,RECFM=VB,DSORG=PS)\n\n\nAUTODIAG PROGRAM\n\nR1       EQU   1                     IDCAMS AND GET WORK\nR2       EQU   2                     GETMAIN CHAIN\nR3       EQU   3                     WORK\nR6       EQU   6                     WORK\nR9       EQU   9                     DCOLLECT RECORD BASE\nR11      EQU   11                    BASE REG TWO\nR12      EQU   12                    BASE REG ONE\nR13      EQU   13                    SAVE AREA\nR14      EQU   14                    RETURN ADDRESS\nR15      EQU   15                    RETURN CODES\nAUTODIAG CSECT\n         STM   R14,R12,12(R13)       SAVE REGS\n         BALR  R12,0                 ESTABLISH ADDRESSABILITY\n         USING *,R12,R11             NEED TWO BASE REGS\n         LA    R11,4095(,R12)        SET UP\n         LA    R11,1(,R11)              BASE TWO\n         LA    R3,REGSAVE            ADDRESS OF OUR SAVE AREA\n         ST    R3,8(R13)             SAVE OUR ADDRESS\n         ST    R13,4(R3)             SAVE CALLING SAVE AREA\n         LR    R13,R3                LOAD OUR SAVE ADDRESS\n         OPEN  (SYSIN,(OUTPUT))      GET READY FOR LISTC OUTPUT\n         PUT   SYSIN,LISTCARD        PUT LISTC ALL OUT TO IDCAMS\n         OPEN  (LISTPRNT,(OUTPUT),CURRENT,(OUTPUT))\n         MVC   WTOCATL+24(6),=C'MASTER' INDICATE MASTER CATALOG\n         MVC   WTOLISTL+42(6),=C'MASTER'\nAUTODG01 WTO   MF=(E,WTOCATL)        TELL WHAT WE'RE PROCESSING\n         MVI   PRCESFLG,C'L'         SET PROCESS FLAG TO LISTCAT\n         MVI   WRITEFLG,C'Y'         SET WRITE FLAG TO YES\n         CLOSE SYSIN                 CLOSE SYSIN SO IDCAMS CAN READ\n         LA    R1,0                  PREPARE FOR IDCAMS LINK\n         LINK  EP=IDCAMS             CALL IDCAMS TO DO LISTCAT\n         LTR   R15,R15               ZERO RC FROM IDCAMS?\n         BZ    AUTODG03              IF YES, CONTINUE\n         WTO   MF=(E,WTOLISTL)       INDICATE NON ZERO RC\nAUTODG03 OPEN  (SYSIN,(OUTPUT),SYSPRINT)\n         ZAP   COMPDCNT,=P'0'        ZERO NUMBER OF COMPARES\nAUTODG05 GET   SYSPRINT              READ OUTPUT FROM IDCAMS LISTC\n         LH    R3,0(R1)              GET THE LENGTH\n         SH    R3,=H'5'              GET READY FOR SYSPRINT MOVE\n         LR    R6,R1                 HOLD RECORD ADDRESS\n         MVI   SAVEPRNT,X'40'        SPACE OUT THE SAVE AREA\n         MVC   SAVEPRNT+1(L'SAVEPRNT-1),SAVEPRNT\n         EX    R3,PRNTMOVE           MOVE THE SYSPRINT RECORD\n         PUT   LISTPRNT,SAVEPRNT     DISPLAY SYSPRINT\n         LA    R6,5(R6)              SKIP OVER LENGTH\n         CLC   0(7,R6),=C'USERCAT'   IS THIS A USERCAT ENTRY?\n         BE    AUTODG12              IF YES, WE WANT IT\n         CLC   0(7,R6),=C'CLUSTER'   IS THIS A CLUSTER ENTRY?\n         BE    AUTODG07              IF YES, WE WANT IT\n         CLI   MASTRFLG,C'1'         DID WE GET MASTER CAT YET?\n         BE    AUTODG05              IF YES, GET NEXT RECORD\n         CLC   53(7,R6),=C'CATALOG'  IS MASTER CATALOG HERE?\n         BNE   AUTODG05              IF NO, KEEP LOOKING\n         LA    R6,37(R6)             POINT TO CATALOG NAME\n         MVI   SAVEDSN,X'40'         SPACE OUT THE SAVE AREA\n         MVC   SAVEDSN+1(L'SAVEDSN-1),SAVEDSN\n         SH    R3,=H'54'             GET READY FOR DSN MOVE\n         EX    R3,DSNMOVE            SAVE MASTER CATALOG NAME\n         MVC   DIAGDSN(44),SAVEDSN   PUT MASTER CATALOG IN DIAGNOSE\n         MVI   MASTRFLG,C'1'         SET MASTER FOUND FLAG\n         B     AUTODG05              GO READ SYSPRINT\nAUTODG07 CLC   16(11,R6),=C'SYS1.VVDS.V' IS THIS A VVDS ENTRY?\n         BNE   AUTODG05              IF NOT, DON'T WANT IT\n         CP    COMPDCNT,=P'99'       HAVE WE ISSUED 99 COMPARES\n         BE    AUTODG05              IF YES, CAN'T HANDLE ANY MORE\n         AP    COMPDCNT,=P'1'        ADD 1 TO NUMBER OF COMPARES\n         CLI   WRITEFLG,C'Y'         DIAGNOSE CARD1 REQUIRED?\n         BNE   AUTODG09              IF NOT, SKIP IT\n         MVI   DIAGCONT,C'-'         SET UP CONTINUATION\n         PUT   SYSIN,DIAGCRD1        WRITE DIAGNOSE RECORD\n         PUT   SYSIN,DIAGCRD2        WRITE COMPAREDS RECORD\n         MVI   WRITEFLG,C'N'         INDICATE CARD1 NOT NEEDED\nAUTODG09 MVC   DIAGCDSN(17),16(R6)   SETUP DIAGNOSE COMPARE DSN\n         PUT   SYSIN,DIAGCRD3        WRITE COMPAREDS RECORD\n         B     AUTODG05              GO READ SYSPRINT\nAUTODG12 CLI   PHASEFLG,C'M'         STILL IN MASTER PHASE?\n         BNE   AUTODG05              IF NOT, BYPASS USERCAT INFO\n         GETMAIN R,LV=48             NEED 48 BYTES FOR CATALOG NAME\n         MVC   0(4,R1),GETMNQUE      SAVE PRIOR GETMAIN ADDRESS\n         MVI   SAVEDSN,X'40'         SPACE OUT THE SAVE AREA\n         MVC   SAVEDSN+1(L'SAVEDSN-1),SAVEDSN\n         SH    R3,=H'17'             GET READY FOR DSN MOVE\n         EX    R3,DSNMOVE            SAVE USERCATALOG NAME\n         MVC   4(44,R1),SAVEDSN      PUT CATALOG IN STORAGE\n         ST    R1,GETMNQUE           SAVE CURRENT GETMAIN ADDRESS\n         B     AUTODG05              GO READ SYSPRINT\nAUTODG15 MVC   SAVECDSN,DIAGDSN      SAVE NAME INTO CURRENT AREA\n         MVI   PRCESFLG,C'D'         INDICATE CATALOG DIAGNOSE\n         CLI   WRITEFLG,C'Y'         STILL WAITING FOR CARD1?\n         BNE   AUTODG17              IF NO, SKIP WRITE\n         MVI   DIAGCONT,C' '         NO NEED TO CONTINUE RECORD\n         PUT   SYSIN,DIAGCRD1        WRITE DIAGNOSE RECORD\n         B     AUTODG20              GO CLOSE SYSIN\nAUTODG17 PUT   SYSIN,DIAGCRD4        FINISH WITH RIGHT PAREN\nAUTODG20 CLOSE SYSIN                 CLOSE SYSIN SO IDCAMS CAN READ\n         LA    R1,0                  PREPARE FOR IDCAMS LINK\n         LINK  EP=IDCAMS             CALL IDCAMS\n         LA    R1,5                  PREPARE FOR < 5 COMPARE\n         CR    R15,R1                WAS RC < 5?\n         BL    AUTODG22              IF YES, THAT'S GOOD\n         MVC   WTODIAGL+38(44),DIAGDSN PLUG DSN INTO WTO\n         WTO   MF=(E,WTODIAGL)       INDICATE BAD RC\nAUTODG22 OPEN  (SYSIN,(OUTPUT),SYSPRINT)\nAUTODG24 GET   SYSPRINT              READ DIAGNOSE OUTPUT\n         LH    R3,0(R1)              GET THE LENGTH\n         SH    R3,=H'5'              GET READY FOR SYSPRINT MOVE\n         MVI   SAVEPRNT,X'40'        SPACE OUT THE SAVE AREA\n         MVC   SAVEPRNT+1(L'SAVEPRNT-1),SAVEPRNT\n         EX    R3,PRNTMOVE           MOVE THE SYSPRINT RECORD\n         MVC   SAVECPRT,SAVEPRNT     SAVE INTO CURRENT\n         AP    SAVECCNT,=P'1'        ADD 1 TO LINE POSITION\n         PUT   CURRENT,SAVCURNT      SAVE THE CURRENT DIAG INFO\n         B     AUTODG24              GO READ NEXT DIAGNOSE LINE\nAUTODG27 CLOSE SYSPRINT              NO MORE SYSPRINT, SO CLOSE\n         CLI   PRCESFLG,C'V'         ARE VVDS'S BEING PROCESSED?\n         BE    AUTODG38              IF YES, READ DCOLLECT INFO\n         CLI   PRCESFLG,C'L'         WAS THIS A LISTCAT PROCESS?\n         BE    AUTODG15              IF YES, DIAGNOSE IS NEXT\n         CLI   PHASEFLG,C'U'         IN USERCATALOG PHASE?\n         BE    AUTODG30              IF YES, GO PROCESS NEXT CATLG\n         L     R2,GETMNQUE           GET CHAIN START ADDRESS\n         MVI   PHASEFLG,C'U'         SET PHASE TO USERCATALOGS\n         MVC   LISTCAT,=C' CAT('     PREPARE TO GET\n         MVC   LISTRPRN,=C') '            ASSOCIATED\n         MVC   LISTVVDS,=C' LVL(SYS1.VVDS)'     VVDS'S\n         B     AUTODG32              READY FOR FIRST CATALOG\nAUTODG30 L     R2,0(R2)              LOAD NEXT ADDRESS IN CHAIN\nAUTODG32 LTR   R2,R2                 IF ZERO,\n         BZ    AUTODG34                  AT END OF CHAIN\n         LA    R3,4(R2)              POSTION TO CATALOG NAME\n         MVC   DIAGDSN(44),0(R3)     SAVE USERCATALOG FOR DIAGNOSE\n         MVC   LISTDSN(44),DIAGDSN   SAVE USERCATALOG FOR LISTC\n         MVC   WTOLISTL+42(44),LISTDSN PLUG CATALOG INTO ERROR MSG\n         PUT   SYSIN,LISTCARD        GIVE LISTCAT TO IDCAMS\n         MVC   WTOCATL+24(44),LISTDSN PLUG CATALOG INTO PROCESS MSG\n         B     AUTODG01              GO CALL IDCAMS\nAUTODG34 CLOSE LISTPRNT              NO MORE LIST PROCESSING\n         MVI   PRCESFLG,C'V'         INDICATE VVDS PROCESSING\n         MVC   DIAGTYPE,=C' VVDS  '  PREP FOR VVDS DIAGNOSE\n         MVI   DIAGCONT,C'-'         ALWAYS CONTINUE\n         OPEN  (SYSIN,(OUTPUT))      GET READY FOR DCOLLECT\n         PUT   SYSIN,DCOLCARD        PUT DCOLLECT OUT TO IDCAMS\n         CLOSE SYSIN                 CLOSE SYSIN FOR IDCAMS\n         WTO   '* DCOLLECT DATA RETRIEVAL IN PROGRESS *'\n         LA    R1,0                  PREPARE FOR IDCAMS LINK\n         LINK  EP=IDCAMS             CALL IDCAMS TO DO DCOLLECT\n         LTR   R15,R15               ZERO RC FROM IDCAMS DCOLLECT?\n         BZ    AUTODG36              IF YES, CONTINUE ON\n         WTO   '* WARNING - NON ZERO RC FROM DCOLLECT *'\nAUTODG36 OPEN  DCOLLECT              GET READY TO READ DCOLLECT\nAUTODG38 GET   DCOLLECT              READ OUTPUT FROM DCOLLECT\n         LA    R9,4(R1)              POINT TO RECORD\n         USING IDCDOUT,R9            ESTABLISH ADDRESSABILITY\n         CLI   DCURCTYP,C'D'         IS THIS A DATASET RECORD?\n         BNE   AUTODG38              IF NOT, DONT WANT IT\n         CLC   DCDDSNAM(10),=C'SYS1.VVDS.'  IS THIS A VVDS ENTRY?\n         BNE   AUTODG38              IF NOT, DON'T WANT IT\n         MVC   DIAGDSN(44),DCDDSNAM  SAVE THE VVDS FOR DIAGNOSE\n         MVC   SAVECDSN,DIAGDSN      SAVE THE VVDS FOR CURRENT\n         MVC   WTOVVDSL+21(44),DIAGDSN  PLUG VVDS NAME INTO WTO\n         WTO   MF=(E,WTOVVDSL)       INDICATE WHO PROCESSING\n         OPEN  (SYSIN,(OUTPUT))      GET READY FOR DIAGNOSE\n         PUT   SYSIN,DIAGCRD1        WRITE DIAGNOSE RECORD\n         PUT   SYSIN,DIAGCRD2        WRITE COMPAREDS RECORD\n         L     R2,GETMNQUE           GET CHAIN START ADDRESS\n         B     AUTODG42              READY FOR FIRST CATALOG\nAUTODG40 L     R2,0(R2)              LOAD NEXT ADDRESS IN CHAIN\nAUTODG42 LTR   R2,R2                 IF ZERO,\n         BZ    AUTODG17                  AT END OF CHAIN\n         LA    R3,4(R2)              POSTION TO CATALOG NAME\n         MVC   DIAGCDSN(44),0(R3)    USERCATALOG FOR COMPAREDS\n         PUT   SYSIN,DIAGCRD3        WRITE COMPARE CATALOG DSN\n         B     AUTODG40              GO GET NEXT CATALOG\nAUTODG45 WTO   '* COMPARISON OF CURRENT/PRIOR DIAGNOSE IN PROGRESS *'\n         CLOSE CURRENT               END OF CURRENT DIAGNOSING\n         OPEN  (PRIOR,,CURRENT,,SYSIN,(OUTPUT),SORTIN,(OUTPUT))\n         OPEN  (SORTEDC,(OUTPUT),SORTEDP,(OUTPUT))\n         MVI   PHASEFLG,C'P'         INDICATE PRIOR PROCESSING\nAUTODG50 GET   PRIOR,SAVCURNT        READ A PRIOR DIAGNOSE RECORD\n         PUT   SORTIN,SAVCURNT       PUT RECORD OUT TO SORT\n         B     AUTODG50              GO PROCESS NEXT RECORD\nAUTODG55 GET   CURRENT,SAVPRIOR      READ A CURRENT DIAGNOSE RECORD\n         PUT   SORTIN,SAVPRIOR       PUT RECORD OUT TO SORT\n         B     AUTODG55              GO PROCESS NEXT RECORD\nAUTODG57 CLOSE SORTIN                CLOSE SORTIN SO SORT CAN READ\n         LA    R1,POINTER            PREPARE FOR SORT\n         LINK  EP=SORT               CALL SORT\n         LTR   R15,R15               WAS SORT RC ZERO?\n         BZ    AUTODG62              IF YES, CONTINUE ON\n         WTO   '* WARNING - NON ZERO RC FROM SORT *'\n         B     AUTODG99              SHOULD NEVER HAVE A SORT PROBLEM\nAUTODG62 OPEN  SORTOUT               GET READY TO READ SORTED INFO\n         CLI   PHASEFLG,C'E'         CHECKING FOR NEW ERRORS PHASE?\n         BE    AUTODG90              IF YES, GO WRITE DIAGPRNT OUTPUT\nAUTODG65 GET   SORTOUT               READ A SORTED RECORD\n         MVC   SAVCURNT(181),0(R1)   SAVE THE SORTED RECORD\n         CLI   PHASEFLG,C'P'         PROCESSING PRIOR DIAGNOSE?\n         BE    AUTODG68              IF YES, GO WRITE PRIOR\n         PUT   SORTEDC,SAVCURNT      MUST BE CURRENT DIAGNOSE INFO\n         B     AUTODG65              GET ANOTHER RECORD\nAUTODG68 PUT   SORTEDP,SAVCURNT      WRITE OUT THE PRIOR DIAGNOSE\n         B     AUTODG65              GET ANOTHER RECORD\nAUTODG70 CLOSE SORTOUT               END OF SORTED INFO\n         CLI   PHASEFLG,C'C'         IS THIS THE CURRENT PHASE?\n         BE    AUTODG72              IF YES, GO COMPARE INFO\n         CLI   PHASEFLG,C'E'         IS THIS THE NEW ERRORS PHASE?\n         BE    AUTODG95              IF YES, TIME TO GET OUT\n         MVI   PHASEFLG,C'C'         INDICATE CURRENT PHASE\n         OPEN  (SORTIN,OUTPUT)       GET READY TO PUT RECORDS TO SORT\n         B     AUTODG55              GO PROCESS CURRENT DIAGNOSE INFO\nAUTODG72 CLOSE (SORTEDC,,SORTEDP)    CLOSE WORK FILES\n         OPEN  (SORTEDC,,SORTEDP,,SORTIN,(OUTPUT))\n         MVC   SAVPRIOR(3),=X'FFFFFF' HIGH VALUES IN CASE EMPTY\nAUTODG74 GET   SORTEDC,SAVCURNT      READ A SORTED CURRENT DIAG LINE\nAUTODG76 GET   SORTEDP,SAVPRIOR      READ A SORTED PRIOR DIAG LINE\nAUTODG78 CLC   SAVPRIOR(177),SAVCURNT COMPARE PRIOR LINE TO CURRENT\n         BE    AUTODG86              IF EQUAL, PROCESS NO CHANGE\n         BL    AUTODG76              IF LESS, READ NEXT PRIOR LINE\nAUTODG80 CLC   SAVCURNT+45(6),=C'IDCAMS' IS THIS A HEADER LINE?\n         BE    AUTODG82              IF YES, DON'T CARE IF CHANGED\n         MVI   SAVECCHG,C'|'         INDICATE CHANGE ON THIS LINE\n         B     AUTODG84              SKIP NO CHANGE\nAUTODG82 MVI   SAVECCHG,C' '         INDICATE NO CHANGE ON LINE\nAUTODG84 PUT   SORTIN,SAVCURNT       WRITE LINE OUT TO SORT\n         GET   SORTEDC,SAVCURNT      GET NEXT CURRENT DIAGNOSE LINE\n         B     AUTODG78              GO COMPARE\nAUTODG86 MVI   SAVECCHG,C' '         INDICATE NO CHANGE\n         PUT   SORTIN,SAVCURNT       WRITE LINE OUT TO SORT\n         B     AUTODG74              GO READ CURRENT AND PRIOR\nAUTODG88 CLOSE (SORTEDC,,SORTEDP)    END OF DIAGNOSE COMPARING\n         MVC   SORTPARM,SORTFLD      PREPARE TO SORT ORIGINAL ORDER\n         MVI   PHASEFLG,C'E'         INDICATE NEW ERRORS PROCESSING\n         B     AUTODG57              GO SORT\nAUTODG90 OPEN  (DIAGPRNT,(OUTPUT))   GET READY FOR DIAGNOSE PRINT\nAUTODG92 GET   SORTOUT               READ A CURRENT DIAGNOSE LINE\n         MVC   DIAGVFC(1),44(R1)     SAVE VERTICAL FORMAT CONTROL\n         MVC   DIAGCHG(1),180(R1)    SAVE CHANGE INDICATOR\n         MVC   DIAGPRT(132),45(R1)   SAVE ORIGINAL DIAGNOSE LINET\n         PUT   DIAGPRNT,DIAGLINE     WRITE OUT TO DIAGNOSE PRINT\n         B     AUTODG92              CONTINUE TILL END\nAUTODG95 CLOSE (DIAGPRNT,,SORTOUT)   CLOSE REMAINING OPEN FILES\nAUTODG99 LA    R15,0                 ZERO RC\n         L     R13,REGSAVE+4         RESTORE REGISTERS\n         ST    R15,16(R13)                  AND\n         LM    R14,R12,12(R13)                 GO\n         BR    R14                                HOME\n         LTORG\nDSNMOVE  MVC   SAVEDSN(0),16(R6)     MVC FOR DATASET NAME\nPRNTMOVE MVC   SAVEPRNT(0),4(R1)     MVC FOR SYSPRINT\nWTOCATL  WTO   'PROCESSING CATALOG:                                    C\n                              ',MF=L\nWTOVVDSL WTO   'PROCESSING VVDS:                                       C\n                              ',MF=L\nWTOLISTL WTO   '* WARNING - NON ZERO RC IN LISTCAT OF                  C\n                                          ',MF=L\nWTODIAGL WTO   '* WARNING - RC > 4 IN DIAGNOSE OF                      C\n                                      ',MF=L\nREGSAVE  DS    18F                   REGISTER SAVE AREA\nGETMNQUE DC    A(0)                  GETMAIN QUE ADDRESS\nPHASEFLG DC    C'M'                  PHASE IN PROGRESS FLAG\nMASTRFLG DC    C' '                  MASTER CATALOG REQUIRED FLAG\nWRITEFLG DC    C' '                  DIAGNOSE CARD REQUIRED FLAG\nPRCESFLG DC    C' '                  PROCESS IN PROGRESS FLAG\nSORTFLD  DC    CL33'178,3,PD,A)'     DIAGNOSE ORIGINAL ORDER SORT\nSAVEDSN  DS    CL44                  CATALOG NAME SAVE\nSAVEPRNT DS    CL133                 IDCAMS SYSPRINT SAVE\nDIAGLINE DS    0CL134                LINE TO OUTPUT TO DIAGPRNT\nDIAGVFC  DS    C                     VERTICAL FORMAT CONTROL\nDIAGCHG  DS    C                     LINE CHANGED INDICATOR\nDIAGPRT  DS    CL132                 ORIGINAL DIAGNOSE OUTPUT\nSAVPRIOR DS    CL181                 PRIOR DIAGNOSE SAVE\nSAVCURNT DS    0CL181                CURRENT DIAGNOSE SAVE\nSAVECDSN DS    CL44                  CURRENT DIAGNOSE DSN SAVE\nSAVECPRT DS    CL133                 CURRENT DIAGNOSE PRINT LINE\nSAVECCNT DC    PL3'0'                CURRENT DIAGNOSE LINE COUNT\nSAVECCHG DC    C' '                  CURRENT LINE CHANGED INDICATOR\nCOMPDCNT DC    PL3'0'                COUNT OF COMPARE DATASETS\nDIAGCRD1 DC    CL80' '               IDCAMS DIAGNOSE CARD1\n         ORG   DIAGCRD1\n         DC    C' DIAGNOSE'\nDIAGTYPE DC    C' ICFCAT'\n         DC    C' IDS('\nDIAGDSN  DS    CL44\n         DC    C') '\nDIAGCONT DC    C' '\n         ORG\nDIAGCRD2 DC    CL80' '               IDCAMS DIAGNOSE CARD2\n         ORG   DIAGCRD2\n         DC    C' COMPAREDS( -'\n         ORG\nDIAGCRD3 DC    CL80' '               IDCAMS DIAGNOSE CARD3\n         ORG   DIAGCRD3\n         DC    C' '\nDIAGCDSN DS    CL44\n         DC    C'  -'\n         ORG\nDIAGCRD4 DC    CL80' '               IDCAMS DIAGNOSE CARD4\n         ORG   DIAGCRD4\n         DC    C' )'\n         ORG\nLISTCARD DC    CL80' '               IDCAMS LISTC CARD\n         ORG   LISTCARD\n         DC    C' LISTC'\nLISTCAT  DS    CL5\nLISTDSN  DS    CL44\nLISTRPRN DS    CL2\nLISTVVDS DS    CL15\n         ORG\nDCOLCARD DC    CL80' '               IDCAMS DCOLLECT CARD\n         ORG   DCOLCARD\n         DC    C' DCOLLECT'\n         DC    C' OFILE(DCOLLECT)'\nDCOLVOL1 DC    C' VOLUME(*)'\n         DC    C' NOVOLUMEINFO'\n         ORG\n         CNOP  2,4\nBYTECNT  DC    Y(24)                 SORT PARAMETERS\n         DC    A(SORTBEG)\n         DC    A(SORTEND)\n         DC    A(RECBEG)\n         DC    A(RECEND)\n         DC    2F'0'\nPOINTER  DC    X'80'\n         DC    AL3(BYTECNT)\nSORTBEG  DC    C' SORT FIELDS=('\nSORTPARM DC    C'1,44,CH,A,45,133,CH,A,178,3,PD,A)'\nSORTEND  DC    C' '\nRECBEG   DC    C' RECORD TYPE=F,LENGTH=181'\nRECEND   DC    C' '\nDCOLLECT DCB   DDNAME=DCOLLECT,DSORG=PS,MACRF=GL,EODAD=AUTODG45\nPRIOR    DCB   DDNAME=PRIOR,DSORG=PS,MACRF=GM,EODAD=AUTODG57\nCURRENT  DCB   DDNAME=CURRENT,DSORG=PS,MACRF=(GM,PM),RECFM=FB,         C\n               LRECL=181,EODAD=AUTODG57\nSORTEDP  DCB   DDNAME=SORTEDP,DSORG=PS,MACRF=(GM,PM),RECFM=FB,         C\n               LRECL=181,EODAD=AUTODG80\nSORTEDC  DCB   DDNAME=SORTEDC,DSORG=PS,MACRF=(GM,PM),RECFM=FB,         C\n               LRECL=181,EODAD=AUTODG88\nDIAGPRNT DCB   DDNAME=DIAGPRNT,DSORG=PS,MACRF=PM,RECFM=FA,LRECL=133,   C\n               BLKSIZE=133\nLISTPRNT DCB   DDNAME=LISTPRNT,DSORG=PS,MACRF=PM,RECFM=FA,LRECL=133,   C\n               BLKSIZE=133\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=GL,EODAD=AUTODG27\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=PM,RECFM=F,LRECL=80,        C\n               BLKSIZE=80\nSORTOUT  DCB   DDNAME=SORTOUT,DSORG=PS,MACRF=GL,EODAD=AUTODG70,        C\n               LRECL=181\nSORTIN   DCB   DDNAME=SORTIN,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=181\n         IDCDOUT\n         END\n\n\nErnie Ishman\nSenior Systems Programmer\nGeisinger Systems Services (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A007A03": {"ttr": 8707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\xb2\\x01\\xb2\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 434, "newlines": 434, "modlines": 0, "user": "VSAMUPD"}, "text": "Monitoring used space for VSAM datasets\n\nMVS/DFP 3.2 provides a new AMS command, DCOLLECT,\nto collect dataset information, volume usage information, and\ninformation about datasets and storage controlled by a\nmigration utility. The output dataset created by DCOLLECT\ncan be used as input to SLR (Service Level Reporter), which\ncollects data in tables (like DASD_DSNSTAT,\nDASD_VOLSTAT etc) from which reports can be generated.\nThe records produced by DCOLLECT are described in DFP\n3.2 Access Method Services for ICF manual.\n\nThe Active Dataset Record (DCURCTYP = 'D') generated by\nthe above process contains the correct value of actually used\nspace only for non-VSAM and non-ISAM datasets. For VSAM\nand ISAM datasets this field (DCDUSESP) is set to zero.\nHence the report based on these records does not give a correct\nvalue of actual dataset utilization, especially if the installation\nhas got a large number of VSAM datasets.\n\nThe purpose of the accompanying program modules is to get\nthe actual utilization for VSAM datasets. There are two\nprograms:\n\no      VVDSREAD      This reads the VVDS to get actual space\n            utilization for VSAM datasets.\n\no      USEDSPCE      This updates the output of DCOLLECT\n            with the space utilization information\n            from VVDSREAD.\n\nVVDSREAD\n\nThis program accepts the volume names from SYSIN,\ndynamically allocates VVDS dataset (SYS1.VVDS.Vvolid),\nand reads the entire VVDS to get dataset space utilization\ninformation. The layout of a VVDS is shown in Figure 1.\n\nVVCR is the VSAM volume control record. It contains names\nof ICF catalogs having a VSAM component on this volume.\nVVR is the VSAM Volume Record. There is one for each\ndataset component residing on this volume. Figure 2 shows the\nlayout of a VVR, Figures 3 shows details of a VVR header\ncell, and Figure 4 shows details of the VVR volume component\ncell.\n\nType -      X'E9'  Header cell\n      X'23'  Volume component cell\n      HURBA  High Used Relative Byte Address\n      HARBA  High Allocated Relative Byte Address.\n\nExt Type -      X'00'  Contiguous extent\n      X'20'  Converted from VSAM to ICF catalog\n      X'40'  Extent not pre-formatted\n      X'80'  Sequence set track adjacent to Control Area\n      X'FF'  Candidate volume.\n\nIn the case of SMS-managed volumes, VVR entries exists for\nnon-VSAM datasets also (header type not X'E9'). These are to\nbe ignored.\n\nThe allocated and used tracks can be computed from the values\nof HURBA, HKRBA, blocksize, and blocks/track. Allocated\ntracks can also be computed by summing up the number of\ntracks per extent. The two values of allocated tracks are\ndifferent when an index is IMBEDDED along with the data\ncomponent. In such a case the actual used tracks can be\nobtained by:\n\n      USETRK(actual) = USETRK * ALOCTRK(actual) / ALOCTRK\n\nAlso the space utilization for an IMBEDDED index component\nis ignored because it is added to the data component.\n\n\nPROGRAM\n\n* PROGRAM TO READ VVDS TO GET THE VSAM DATASET SPACE ALLOCATION\n* AND USAGE INFORMATION\n* SHOULD BE LINK EDITED INTO AN APF AUTHORIZED LIBRARY\nVVDSREAD  CSECT\n          SAVE   (14,12)           SAVE REGS\n          LR     12,15             SET UP BASE REG\n          USING  VVDSREAD,12,11    ESTABLISH ADDRESSABILITY\n          LA     11,4095(12)\n          LA     11,1(11)          SET UP SECOND BASE REG\n          ST     13,SAVE+4         FORWARD POINTER\n          LA     10,SAVE\n          ST     10,8(13)          BACKWARD POINTER\n          LR     13,10             NEW SAVE AREA ADDRESS\n          OPEN   VOLFILE           FILE CONTAINING LIST OF VOLUMES\n          LTR    15,15\n          BNZ    OPNERR1\n          OPEN   (OUTFILE,(OUTPUT))\n          LTR    15,15             OK ?\n          BNZ    OPNERR2           OUTPUT OPEN ERROR\nNEXTVOL   GET    VOLFILE           READ ONE VOLID\n          MVC    $$VOLID(6),0(1)   MOVE VOLID TO VVDS NAME\n*  DYNAMICALLY ALLOCATE VVDS\n          LA     1,$$VVDS\n          DYNALLOC ,\n          LTR    15,15\n          L      3,$$VVDS\n          BNZ    ALOCERR           ERROR IN DYNAMIC ALLOCATION\n          OPEN   VVDSACB           OPEN RDO FILE\n          LTR    15,15             OPEN OK ?\n          BNZ    OPNERR3           OPEN ERROR QUIT\n          GET    RPL=VVDSRPL       READ VVCR AND SKIP IT\n          LTR    15,15\n          BNZ    CLOSE1            END OF DATA\nNEXTREC   GET    RPL=VVDSRPL\n          LTR    15,15             READ NOT OK\n          BNZ    CLOSE1            END OF DATA\n          LA     2,VVDSREC         ADDRESS OF RECORD\n          MVC    HWORD(2),VVDSREC  TAKE THE LENGTH FIELD\n          LH     3,HWORD           RECORD LENGTH\n          LA     2,2(2)            POINT 0 STARTING POINT OF RECORD\n          SH     3,=H'2'           REDUCE THE LENGTH\n          CLI    2(2),X'E9'        VSAM DATASET COMPONENT HEADER ?\n          BNE    NEXTREC           IF NOT SKIP IT\nNEXTCOMP  MVC    HWORD,0(2)        GET COMPONENT LENGTH\n          LH     4,HWORD\n          CLI    2(2),X'E9'        HEADER CELL\n          BE     HEADER\n          CLI    2(2),X'23'        VOLUME COMPONENT\n          BE     VOLCOMP\nSKIPIT    AR     2,4               POINT TO NEXT COMPONENT\n          SR     3,4               REMAINING LENGTH\n          BH     NEXTCOMP          PROCESS NEXT COMPONENT\nPRINTREC  PUT    OUTFILE,OUTREC    WRITE A RECORD\n          B      NEXTREC           GET NEXT VVDS RECORD\n*  PROCESS HEADER CELL HERE\nHEADER    MVC    OCOMPNT,=CL44' '  INITALIZE WITH SPACE\n          LA     6,9(2)            COMPONENT NAME\n          SLR    7,7\n          IC     7,8(2)            COMPONENT LENGTH\n          SH     7,=H'1'           REDUCE BY 1\n          LA     8,OCOMPNT         COMPONENT NAME\n          LR     9,7\n          MVCL   8,6               COMPONENT NAME TO OUTPUT REC\n          MVC    OVOLID,$$VOLID    VOLUME ID TO OUTPUT REC\n          B      SKIPIT            NOW SKIP THE REMAINING\n*  PROCESS VOLUME COMPONENT HERE\nVOLCOMP   CLI    25(2),X'80'        IS IT IMBEDDED PORTION OF INDEX\n          BE     NEXTREC               THEN SKIP THIS RECORD\n          CLI    25(2),X'C0'        IMBED WITH NO PRE FORMAT\n          BE     NEXTREC               THEN SKIP THIS ENTRY ALSO\n          MVC    FWORD,17(2)        GET  PHYSICAL BLOCK SIZE\n          L      8,FWORD\n          MVC    HWORD,21(2)        GET BLOCKS PER TRACK\n          LH     9,HWORD\n          MVC    FWORD(4),9(2)      HIGH USED RBA\n          L      7,FWORD\n          AR     7,8                ROUND TO NEXT BLOCK SIZE\n          SLR    6,6\n          S      7,=F'1'\n          DR     6,8                GET NO OF BLOCKS USED\n          SLR    6,6                IGNORE REMINDER ..\n          AR     7,9                ROUND TO TRACK BOUNDARY IF NOT\n          S      7,=F'1'\n          DR     6,9                GET TRACKS USED\n          ST     7,USETRK           USED TRACKS\n          MVC    FWORD(4),13(2)     HIGH ALLOCATED RBA\n          L      7,FWORD\n          AR     7,8                ROUND TO BLOCK BOUNDARY\n          SLR    6,6\n          S      7,=F'1'\n          DR     6,8                GET NO OF BLOCKS ALLOCATED\n          SLR    6,6                CLEAR THE REMINDER\n          AR     7,9                ROUND TO TRACK BOUNDARY\n          S      7,=F'1'            LESS 1\n          DR     6,9                GET TRACKS ALLLOCATED\n          ST     7,ALCTRK           ALLOCATED TRACKS\n          LA     2,42(2)            POINT TO EXTENT INFORMATION\n          SH     4,=H'42'           REMAINING LENGTH\n          SLR    5,5                INITIALISE ACTUAL TRACKS\nNEXTEXT   MVC    HWORD,10(2)        EXTENT LENGTH\n          AH     5,HWORD            ADD CURRENT EXTENT LENGTH\n          LA     2,20(2)            POINT TO NEXT EXT\n          SH     4,=H'20'           REMAINING LENGTH\n          BH     NEXTEXT            NEXT EXTENT\n          LR     7,5                ALLOCATED TRACKS\n*  HERE TRACKS CONVERTED TO KILOBYTES\n*  1 TRACK OF 3380 DASD = 1499 BLOCKS OF 32 BYTE UNITS .\n*  FOR OTHER TYPE OF DEVICES MODIFICATION IS NECESSARY\n          M      6,=F'1499'         TRACKS CAPACITY IN 32 BYTE UNITS\n          A      7,=F'16'           ROUNDING UP\n          D      6,=F'32'           GET SPACE IN KB\n          ST     7,OALOCKB          ALLOCATED KB\n          CLC    OCOMPNT(4),=CL4'PAGE'   IS IT A PAGE DATASET\n          BE     PAGE\n          L      7,USETRK\n          MR     6,5                USE TRACKS * ACTUAL ALLOCATED\n          D      6,ALCTRK           GET ACTUAL USED TRACKS\n          LTR    6,6                REMINDER ZERO\n          BZ     *+8\n          LA     7,1(7)             OTHERWISE INCREMENT QUOTIENT 1\n          M      6,=F'1499'         TRACKS CAPACITY IN 32 BYTE UNITS\n          A      7,=F'16'           ROUNDING UP\n          D      6,=F'32'           GET SPACE IN KB\n          ST     7,OUSEDKB          ALLOCATED KB\n          B      PRINTREC\n*  FOR PAGE DATASET VVDS CONTAINING USED SPACE .\n*   SET USED-SPACE SAME AS ALLOCATED-SPACE\nPAGE      MVC    OUSEDKB,OALOCKB    FOR PAGE DATSETS FULL USED\n          B      PRINTREC\nCLOSE1    CLOSE  VVDSACB\nDEALLOC   LA     1,$$VVDSU\n          DYNALLOC ,                NOW DEALLOCATE THE VVDS\n          LTR    15,15\n          BNZ    DALOCERR\n          B      NEXTVOL\nENDVOL    CLOSE  VOLFILE\n          CLOSE  OUTFILE\n          B      RETURN\nOPNERR1   WTO    '  ERROR IN OPENING VOLFILE ',ROUTCDE=(1,10),DESC=(6)\n          B      RETURN\nOPNERR2   WTO    '  ERROR IN OPENING OUTPUT  ',ROUTCDE=(1,10),DESC=(6)\n          B      RETURN\nOPNERR3   WTO    '  ERROR IN OPENING VVDS',ROUTCDE=(1,10),DESC=(6)\n          B      DEALLOC\nDALOCERR  WTO    '  ERROR IN DEALLOCATING VVDS',ROUTCDE=(1,10),DESC=(6)\n          B      NEXTVOL\n***  VVDS ALLOCATION ERROR\nALOCERR   CVD    15,DWORD\n          UNPK   RETCODE(2),DWORD+6(2)\n          OI     RETCODE+1,X'F0'\n          USING  S99RB,3\n          UNPK   ERRCODE,S99ERROR(3)\n          TR     ERRCODE,HEXTOCHR\n          MVI    ERRCODE+4,C' '\n          UNPK   INFCODE,S99INFO(3)\n          TR     INFCODE,HEXTOCHR\n          MVI    INFCODE+4,C' '\nWTO1      WTO    '                                                     C\n                                          ',ROUTCDE=(1,10),DESC=(6)\n** DYNALLOC ERROR MESSAGES\nALOCMSG   ORG    WTO1+8\n          DC     CL25'VVDS ALLOCATION ERROR RC='\nRETCODE   DC     CL3' ',CL15'ERROR CODE ='\nERRCODE   DC     CL5' ',CL15'INFO CODE ='\nINFCODE   DC     CL5' '\n          DC     CL12' '\n          ORG\nRETURN    L      13,4(13)\n          RETURN (14,12),RC=0\n*  FILE AND DATA DEFINTIONS\nVVDSACB   ACB    AM=VSAM,DDNAME=VVDS1,MACRF=(ADR,SEQ,IN)\nVVDSRPL   RPL    AM=VSAM,ACB=VVDSACB,AREA=VVDSREC,AREALEN=4089,        C\n               OPTCD=(ADR,SEQ,MVE)\nOUTFILE   DCB    DDNAME=OUTFILE,DSORG=PS,MACRF=(PM)\nVOLFILE   DCB    DDNAME=VOLIN,DSORG=PS,MACRF=(GL),EODAD=ENDVOL\n*  RECORD DEFINITIONS\nVVDSREC   DS    CL4089                  VVDS RECORD\n          DS    0F\nOUTREC    DS    0CL60                   OUTPUT RECORD\nOCOMPNT   DS    CL44                    COMPONENT  NAME\nOVOLID    DS    CL6                     VOLUME ID\nOALOCKB   DS    F                       ALLOCATED KILOBYTES\nOUSEDKB   DS    F                       USED KILOBYTES\nHWORD     DS    H\nFWORD     DS    F\nDWORD     DS    D\nALCTRK    DS    F                      ALLOCATED TRACKS - FROM RBA\nUSETRK    DS    F                      USED TRACKS      - FROM RBA\nSAVE      DS    18F\n*** DYNAMIC ALLOCATION PARAMETER FOR VVDS DATASET\n$$VVDS    DC   A(X'80000000'+$$VVDSA)\n$$VVDSA   DC   AL1(S99RBEND-S99RB,S99VRBAL,S99NOMNT,0)\n          DC   Y(0,0),A($$VVDSX,0,0)\n$$VVDSX   DC   A($$DSNAME1)             DATASET NAME\n          DC   A($$DDNAME1)             DDNAME\n          DC   A($$STAT1)\n          DC   A($$DISP1)\n          DC   A(X'80000000')\n*** DYNAMIC ALLOCATION TEXT UNITS\n$$DDNAME1 DC   Y(DALDDNAM,1,5),CL5'VVDS1'\n$$DSNAME1 DC   Y(DALDSNAM,1,17)\n          DC   CL11'SYS1.VVDS.V'\n$$VOLID   DC   CL6' '                    VOLUME ID\n$$STAT1   DC   Y(DALSTATS,1,1),X'08'\n$$DISP1   DC   Y(DALNDISP,1,1),X'08'\n*** DYNAMIC DEALLOCATION PARAMETER FOR VVDS DATASET\n$$VVDSU   DC   A(X'80000000'+$$VVDSUA)\n$$VDSUA   DC   AL1(S99RBEND-S99RB,S99VRBUN,0,0)\n          DC   Y(0,0),A($$VVDSUX,0,0)\n$$VVDSUX  DC   A($$DSNAME1)              DSNAME\n          DC   A($$DDNAME1)              DDNAME\n          DC   A($$DISP1)                DISPOSITION\n          DC   A(X'80000000')\nHEXTOCHR  EQU  *-C'0'\n          DC   C'0123456789ABCDEF'\n          IEFZB4D0\n          IEFZB4D2\n          END   VVDSREAD\n\n\nUSEDSPCE\n\nThis program reads the outputs of the DCOLLECT command\nand VVDSREAD, merges the used space information, and\ncreates a new file. This output dataset can be used as input to\nthe SLR collect job. A sample job stream is shown below.\n\n//DCOLLCT  JOB  (0),'XXXXXX',CLASS=A,MSGCLASS=X\n//*\n//DCOL   EXEC  PGM=IDCAMS\n//SYSPRINT  DD  SYSOUT=*\n//DCOUT    DD    DSN=&&DCOUT,DISP=(,PASS),UNIT=SYSDA,\n//         SPACE=(CYL,(1,1)),DSORG=PS,RECFM=VB,LRECL=264,BLKSIZE=23476\n//SYSIN    DD    *\n     DCOLLECT -\n           OUTFILE(DCOUT) -\n           VOLUME(*)\n/*\n//VVDS  EXEC PGM=VVDSREAD,COND=(0,NE)\n//OUTFILE DD DSN=&&VVDSOUT,SPACE=(CYL,(1,1)),UNIT=SYSDA,\n//  DCB=(RECFM=FB,LRECL=60,BLKSIZE=6000),DISP=(,PASS)\n//VOLIN   DD *\n ** List of volumes in the order of unit Number ..\n/*\n//USESP EXEC PGM=USEDSPAC,COND=(0,NE)\n//VVDS1   DD DSN=&&VVDSOUT,DISP=(OLD,DELETE)\n//DCOUT   DD DSN=&&DCOUT,DISP=(OLD,DELETE)\n//SLRIN   DD DSN=&&DCOUT1,DISP=(,PASS),UNIT=SYSDA,\n//   SPACE=(CYL,(1,1)),RECFM=VB,LRECL=264,BLKSIZE=23476\n//*\n//SLRCOL   EXEC PGM=DREMNBEB,PARM=UPDATE,REGION=6144K,COND=(0,NE)\n//LOAD        DSN=SLR.V3R2M0.SLRSAMP,disp=shr\n//OUT      DD SYSOUT=*\n//MAINFILE DD DISP=OLD,DSN=** Slr main database **\n//WORKFILE DD DISP=OLD,DSN=** Slr work file **\n//COLLOG   DD DSN=&&DCOUT1,DISP=(OLD,DELETE)\n//IN       DD *\n   COLLECT ALL LOGSOURCE(DFPX) BUF(10000K) DIA FILE(COLLOG)\n/*\n\n\nPROGRAM\n\n* PROGRAM TO UPDATE THE OUTPUT OF DCOLLECT COMMAND WITH THE SPACE\n* INFORMATION OBTAINED FROM VVDSREAD FOR VSAM DATASETS\nUSEDSPAC  CSECT\n          PRINT NOGEN\n          SAVE   (14,12)           SAVE REGS\n          LR     12,15             SET UP BASE REG\n          USING  USEDSPAC,12       ESTABLISH ADDRESSABILITY\n          ST     13,SAVE+4         FORWARD POINTER\n          LA     10,SAVE\n          ST     10,8(13)          BACKWARD POINTER\n          LR     13,10             NEW SAVE AREA ADDRESS\n          OPEN   DCOUT             FILE CONTAINING DCOLLECT OUTPUT\n          LTR    15,15\n          BNZ    ERROR1\n          OPEN   VVDSOUT           FILE CONTAINING OUTPUT OF VVDSREAD\n          LTR    15,15             OK ?\n          BMZ    ERROR2            OUTPUT OPEN ERROR\n          OPEN   (SLRIN,OUTPUT)    FILE FOR INPUT TO SLR\n          LTR    15,15             OK ?\n          BNZ    ERROR3            OUTPUT OPEN ERROR\nNEXTVV    GET    VVDSOUT           READ ONE VOLID\n          MVC    VVREC(60),0(1)    SAVE THE RECORD\nNEXTDC    GET    DCOUT\n          LA     2,DCOUT           DCB ADDRESS\n          USING  IHADCB,2          DUMMY SECTION\n          LH     5,DCBLRECL        RECORD LENGTH\n          LR     3,1               RECORD ADDRESS\n          USING  DCREC,3\n          CLI    DCRTYPE,C'D'      DATA COMPONENT\n          BNE    PUTREC            WRITE RECORD\n          CLC    VCOMPNT,DCCOMPNT  BOTH DATASET NAMES SAME\n          BNE    PUTREC            IF NOT SAME WRITE IT\n          CLC    VVOLID,DCVOLID    VOLUME ID'S SAME\n          BNE    PUTREC\n          MVC    DCUSEDKB,VUSEDKB  MOVE USED KB\n          LA     2,SLRIN\n          STH    5,DCBLRECL\n          PUT    SLRIN,DCREC\n          B      NEXTVV\nPUTREC    LA     2,SLRIN\n          STH    5,DCBLRECL\n          PUT    SLRIN,DCREC\n          B      NEXTDC\nVVDSEND   GET    DCOUT\n          LA     2,DCOUT\n          LH     5,DCBLRECL        RECORD LENGTH\n          LR     3,1               RECORD ADDRESS\n          LA     2,SLRIN\n          STH    5,DCBLRECL\n          DROP   2\n          PUT    SLRIN,DCREC\n          DROP   3\n          B      VVDSEND\nDCEND     CLOSE  DCOUT\n          CLOSE  VVDSOUT\n          CLOSE  SLRIN\n          B      RETURN\nERROR1    WTO    '  ERROR IN OPENING VVDSOUT',ROUTCDE=(1,10),DESC=(6)\n          B      RETURN\nERROR2    WTO    '  ERROR IN OPENING DCOUT   ',ROUTCDE=(1,10),DESC=(6)\n          B      RETURN\nERROR3    WTO    '  ERROR IN OPENING SLRIN   ',ROUTCDE=(1,10),DESC=(6)\n          B      RETURN\nRETURN    L      13,4(13)\n          RETURN (14,12),RC=0\nSLRIN     DCB    DDNAME=SLRIN,DSORG=PS,MACRF=(PM)\nVVDSOUT   DCB    DDNAME=VVDS1,DSORG=PS,MACRF=(GL),RECFM=FB,            C\n               EODAD=VVDSEND\nDCOUT     DCB    DDNAME=DCOUT,DSORG=PS,MACRF=(GL),RECFM=VB,            C\n               EODAD=DCEND\nSAVE      DS    18F\n          DS    0F\nVVREC     DS    0CL60\nVCOMPNT   DS    CL44                    COMPONENT  NAME\nVVOLID    DS    CL6                     VOLUME ID\nVALOCKB   DS    F                       ALLOCATED KB\nVUSEDKB   DS    F                       USED KB\nDCREC     DSECT                         DCOLLECT OUTPUT RECORD\n          DS    CL8\nDCRTYPE   DS    CL2                     RECORD TYPE\n          DS    CL18\nDCCOMPNT  DS    CL44                    COMPONENT NAME\n          DS    CL10\nDCVOLID   DS    CL6                     VOLUME ID\n          DS    CL8\nDCUSEDKB  DS    CL4                     SPACE USED IN KB\n          DS    CL164                   REMAINING SPACE\n          DCBD  DSORG=PS\n          END   USEDSPAC\n\nM V George\nSystems Programmer\nMinistry of Interior (Qatar)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A007A04": {"ttr": 8715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00n\\x00n\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:57", "lines": 110, "newlines": 110, "modlines": 0, "user": "VSAMUPD"}, "text": "VSAM volume dataset manipulation\n\nThe VSAM Volume Dataset (VVDS) is created to allow\nVSAM datasets to be managed when ICF catalogs are utilized.\nThese datasets are named SYSl.VVDS.Vvvvvvv, where the\nvvvvvv is the volume serial number of the DASD that they\nreside upon. Even though these datasets are prefixed SYSl they\ndo not have to be catalogued in the MVS master catalog.\nDuring a recent reorganization of our DASD system we found\nthat identifying the contents of the VVDS datasets and where\nthey are actually catalogued can be tricky. The suite of\nIDCAMS jobs presented in this article will allow you to\nidentify and manipulate VVDSs.\n\nThe first job can be used to identify which catalogs contain an\nentry for a VVDS. The job will produce a hexadecimal listing\nof the VVDS and to the right of this listing will appear the\nnames of the catalogs where the VVDS has had entries for\nVSAM datasets. The job should be amended to replace the\nvvvvvv with the volume serial number of the DASD on which\nthe VVDS being manipulated resides.\n\nYou can then run the second job to identify which datasets are\nassociated with this particular VVDS. This job should be\namended to include separate IDCAMS DIAGNOSE statements\nfor each catalog identified from the output of the previous job.\nA listing similar to the one in Figure 1 will be produced.\n\nWe recently had to delete several VVDSs from old volumes.\nTo ensure that all the relevant catalog entries were also deleted\nwe ran the third job. This job was run after we identified, by\nusing the first job, which catalogs contained VVDS entries.\nThen, using the second job, we ensured that all of the VVDSs\nwere empty. The third job deletes the VVDS entries from\nCATALOG.SYSA and CATALOG.SYSB in steps one and\ntwo. Step three is then used to delete the remaining entry in\nCATALOG.SYSC and the SCRATCH operand also deletes the\nempty VVDS. This ensures that all catalogs contain the correct\nentries. This job could be used to scratch only catalog entries if\nthe VVDS has already been deleted. This is achieved by using\nthe NOSCRATCH operand in all three steps.\n\n\nIDENTIFYING VVDS CATALOG ENTRIES\n\n//STSO1A    JOB    CLASS=A,MSGCLASS=H,MSGLEVEL=(1,1)\n//STEP1     EXEC   PGM=IDCAMS\n//SYSPRINT  DD     SYSOUT=*\n//AMSDUMP   DD     SYSOUT=*\n//DD1       DD     DSN=SYS1.VVDS.Vvvvvvv,DISP=SHR,AMP=AMORG,\n//          UNIT=3380,VOL=SER=vvvvvv\n//SYSIN DD *\n  PRINT INFILE(DD1) COUNT(1)\n/*\n\n\nIDENTIFYING RELATED DATASET ENTRIES\n\n//STSO1A    JOB   CLASS=A,MSGCLASS=H,MSGLEVEL=(1,1)\n//STEP1     EXEC  PGM=IDCAMS\n//SYSPRINT  DD    SYSOUT=*\n//AMSDUMP   DD    SYSOUT=*\n//DD1       DD    DSN=SYS1.VVDS.Vvvvvvv,DISP=SHR,AMP=AMORG\n//          UNIT=3380,VOL=SER=vvvvvv\n//SYSIN     DD    *\n  DIAGNOSE =\n  VVDS =\n  INFILE(DD1) =\n  INCLUDE =\n  (CAT(CATALOG.SYSB)) =\n  LIST\n/*\n\nNote: if more than one catalog was identified from the previous\njob output the DIAGNOSE statement must be repeated and the\ncatalog name changed to reflect the name of the identified\ncatalog. Do this for each catalog.\n\n\nDELETING VVDS ENTRIES AND VVDSS\n\n//STS01A    JOB   CLASS=A,MSGCLASS=H,MSGLEVEL=(1,1)\n//STEP1     EXEC  PGM=IDCAMS\n//STEPCAT   DD    DSN=CATALOG.SYSA,DISP=SHR\n//SYSPRINT  DD    SYSOUT=*\n//AMSDUMP   DD    SYSOUT=*\n//SYSIN     DD    *\n  DELETE SYS1.VVDS.VDEV013 NOSCRATCH\n\n/*\n//STEP2     EXEC  PGM=IDCAMS\n//STEPCAT   DD    DSN=CATALOG.SYSB,DISP=SHR\n//SYSPRINT  DD    SYSOUT=*\n//AMSDUMP   DD    SYSOUT=*\n//SYSIN     DD    *\n  DELETE SYS1.VVDS.VDEV013 NOSCRATCH\n\n/*\n//STEP3     EXEC  PGM=IDCAMS\n//STEPCAT   DD    DSN=CATALOG.SYSC,DISP=SHR\n//SYSPRINT  DD    SYSOUT=*\n//AMSDUMP   DD    SYSOUT=*\n//SYSIN     DD    *\n  DELETE SYS1.VVDS.VDEV013 SCRATCH\n\n/*\n\nJohn Bradley\nSenior Technical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A007A05": {"ttr": 8961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\xf5\\x00\\xf5\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 245, "newlines": 245, "modlines": 0, "user": "VSAMUPD"}, "text": "An easy way to print VSAM file contents\n\nThe main purpose of this VM EXEC is to simplify the use of\nthe AMSERV PRINT command. The PRVSAM EXEC may be\nused to print VSAM files from catalogs located in any virtual\nmachine in the system. VSE or CMS may be accessed, and\npossibly MVS too.\n\nFor a KSDS file, records may be retrieved by key (full or\npartial). If the key is not specified, the RECS TO BE\nSKIPPED field on the screen may be used to bypass the desired\nnumber of records from the beginning of the file.\n\nThe NUMBER OF RECS field specifies how many records\nwill be printed. The default values shown on the screen may be\nchanged to fit your installation's needs (lines 15 to 25 of the\nPRVSAM XEDIT).\n\nAn example of the screen is shown in Figure 1.\n\n\nPRVSAM EXEC\n\n/* PRVSAM EXEC: CALL PRVSAM XEDIT */\nINICIO:\nSET CMSTYPE HT\n'X PRVSAM TRASH A (PROFILE PRVSAM'\n'EXECIO * DISKR PRVSAM AMSERV A (FINIS STEM VAR.'\nIF RC > 3 THEN EXIT 12\nIF VAR.0 = 0 THEN EXIT 12\nRESP = WORD(VAR.1,1)\nIF RESP = 'AMSERV' THEN DO\n   'X PRVSAM LISTING A'\n   SIGNAL INICIO\n   END\n'ERASE PRVSAM AMSERV A'\nSET CMSTYPE RT\nEXIT 0\n\n\nPRVSAM XEDIT\n\n/* ----------------------------------------------------------------- */\n/*   PROGRAM TO CREATE A FILE NAMED \"PRVSAM LISTING A\" USING THE     */\n/*   AMSERV PROGRAM WITH OPTIONS SELECTED FROM A EASY TO USE         */\n/*   SCREEN                                                          */\n/* ----------------------------------------------------------------- */\nset cmstype ht\ninicio:\nMESSAGE = 'BRIGHT FIELDS ARE MANDATORY'\nreinicio:\n'erase prvsam amserv a'\nMAKEBUF\nPUSH ' PRINT INFILE(WORK1)'\n'EXECIO 1 DISKW PRVSAM AMSERV A 1 f 80 (FINIS'\nDROPBUF\nTABTELA.5.25 = 'VSEIPO'              /* DEFAULT VSE MACHINE           */\nTABTELA.6.25 = 'VSAM.MASTER.CATALOG' /* DEFAULT MASTER CATALOG        */\nTABTELA.7.25 = '350'                 /* DEFAULT MASTCAT ADDR          */\nTABTELA.7.46 = 'RVSEIPO'             /* DEFAULT MASTCAT ADDR PASW.    */\nTABTELA.8.25 = 'USER.CAT'            /* DEFAULT USER CATALOG          */\nTABTELA.9.25 = '352'                 /* DEFAULT USERCAT ADDR          */\nTABTELA.9.46 = 'RVSEIPO'             /* DEFAULT USERCAT ADDR PASW.    */\nTABTELA.10.25 = ''                   /* DEFAULT FOR FILE NAME         */\nTABTELA.11.25 = ''                   /* DEFAULT FOR KEY OF REC        */\nTABTELA.12.25 = '00000'              /* DEFAULT FOR NUMBER OF REC SKIP*/\nTABTELA.13.25 = '00000'              /* DEFAULT FOR NUMBER OF REC     */\nVSE      = LEFT(TABTELA.5.25,8)\nMASTER   = LEFT(TABTELA.6.25,36)\nMASTADDR = LEFT(TABTELA.7.25,3)\nMASTPSWD = LEFT(TABTELA.7.46,8)\nCAT      = LEFT(TABTELA.8.25,36)\nCATADDR  = LEFT(TABTELA.9.25,3)\nCATPSWD  = LEFT(TABTELA.9.46,8)\nARQUIVO  = LEFT(TABTELA.10.25,36)\nKEY      = LEFT(TABTELA.11.25,30)\nSKIP     = LEFT(TABTELA.12.25,5)\nNLRECS   = LEFT(TABTELA.13.25,5)\n'COMMAND SET PF01 A'\n'COMMAND SET PF03 QUIT'\n'COMMAND SET PF12 QUIT'\n'COMMAND SET CMDLINE OFF'\n'COMMAND SET MSGLINE OFF'\n'COMMAND SET CTLCHAR $ ESCAPE'\n'COMMAND SET CTLCHAR % PROTECT BLUE HIGH'\n'COMMAND SET CTLCHAR \" PROTECT BLUE NOHIGH'\n'COMMAND SET CTLCHAR @ NOPROTECT WHITE HIGH'\n'COMMAND SET CTLCHAR > NOPROTECT WHITE NOHIGH'\n'COMMAND SET CTLCHAR < NOPROTECT INVISIBLE'\nPH  = '$%'\nPN  = '$\"'\nNH  = '$@'\nNN  = '$>'\nNI  = '$<'\nTELA1:\n'COMMAND CURSOR SCREEN 5 25'\n  'COMMAND SET RESERVED 1 NOHIGH'  ,\n  '  =============================================='\n  'COMMAND SET RESERVED 2 NOHIGH'  ,\n  '   P R V S A M   -  SELECTIVE DUMP OF A VSAM FILE'\n  'COMMAND SET RESERVED 3 NOHIGH'  ,\n  '   ==============================================\n  'COMMAND SET RESERVED 4 NOHIGH'\n  'COMMAND SET RESERVED 5 HIGH'  ,\n  '   VSE MACHINE NAME...:'NN||VSE||PN  ,\n  '(MAY BE A CMS MACHINE THAT OWNS A VSAM CAT.)'\n  'COMMAND SET RESERVED 6 HIGH'  ,\n  '   MASTER CATALOG.....:'NN||MASTER||PN\n  'COMMAND SET RESERVED 7 HIGH'  ,\n  '   MAST.CAT ADDR......:'NN||MASTADDR||PN||,\n  '  READ PASSWORD:'NI||MASTPSWD||PN\n  'COMMAND SET RESERVED 8 HIGH'  ,\n  '   USER CATALOG.......:'NN||CAT||PN\n  'COMMAND SET RESERVED 9 HIGH'  ,\n  '   USER CAT. ADDR.....:'NN||CATADDR||PN||,\n  '  READ PASSWORD:'NI||CATPSWD||PN\n  'COMMAND SET RESERVED 10 HIGH' ,\n  '   FILE NAME..........:'NN||ARQUIVO||PN\n  'COMMAND SET RESERVED 11 NOHIGH' ,\n  '   KEY (FULL OR PART.):'NN||KEY||PN||,\n  '(DEFAULT=FROM BEGINNING)'\n  'COMMAND SET RESERVED 12 NOHIGH' ,\n  '   RECS TO BE SKIPPED.:'NN||SKIP||PN\n  'COMMAND SET RESERVED 13 NOHIGH' ,\n  '  NUMBER OF RECS......:'NN||NLRECS||PN ,\n  '                        (ZEROS=ALL RECS.)'\n  'COMMAND SET RESERVED 14 NOHIGH'\n  'COMMAND SET RESERVED 15 NOHIGH'\n  'COMMAND SET RESERVED 16 NOHIGH' ' 'PH MESSAGE PN\n  'COMMAND SET RESERVED 17 NOHIGH'\n  'COMMAND SET RESERVED 18 NOHIGH'\n  'COMMAND SET RESERVED 19 NOHIGH'\n  'COMMAND SET RESERVED 20 NOHIGH'\n  '                  ENTER   - CREATE \"PRVSAM LISTING A\"'\n  'COMMAND SET RESERVED 21 NOHIGH' ,\n  '                  PF1     - SPOOLS THE OUTPUT LISTING TO THE VIRTUAL'\n  'COMMAND SET RESERVED 22 NOHIGH' ,\n  '                             PRINTER, INSTEAD OF WRITING IT TO DISK'\n  'COMMAND SET RESERVED 23 NOHIGH' ,\n  '                  PF3/PF12 - QUIT'\n  'COMMAND SET RESERVED 24 NOHIGH'\n  'COMMAND READ ALL tag'\nnpars = queued()\nOPTION = ''\ndo k=1 to npars\n  PULL LINHA\n  I = WORD(LINHA,2)\n  J = WORD(LINHA,3)\n   IF WORD(LINHA,1) = 'PFK' & (I = 3 | I = 12) THEN DO\n     'QUIT'\n     EXIT\n     END\n  ELSE\n  IF WORD(LINHA,1) = 'PFK' & I = 1 THEN\n     OPTION = 'PRINT'\n  TABTELA.I.J = WORD(LINHA,4)\nend\nVSE      = LEFT(TABTELA.5.25,8)\nMASTER   = LEFT(TABTELA.6.25,36)\nMASTADDR = LEFT(TABTELA.7.25,3)\nMASTPSWD = LEFT(TABTELA.7.46,8)\nCAT      = LEFT(TABTELA.8.25,36)\nCATADDR  = LEFT(TABTELA.9.25,3)\nCATPSWD  = LEFT(TABTELA.9.46,8)\nARQUIVO  = LEFT(TABTELA.10.25,36)\nKEY      = LEFT(TABTELA.11.25,30)\nSKIP     = LEFT(TABTELA.12.25,5)\nNLRECS   = LEFT(TABTELA.13.25,5)\nNSKIP    = SKIP\nNRECS    = NLRECS\nIF SKIP   = 0 THEN NSKIP = ''\nIF NLRECS = 0 THEN NRECS = ''\nIF VSE = '' THEN DO\n   MESSAGE = 'VIRTUAL MACHINE TO BE LINKED NOT SPECIFIED'\n   SIGNAL TELA1\n   END\nIF MASTER = '' THEN DO\n   MESSAGE = 'MASTER CATALOG NAME NOT SPECIFIED'\n   SIGNAL TELA1\n   END\nIF MASTADDR = '' THEN DO\n   MESSAGE = 'MASTER CATALOG ADDRESS NOT SPECIFIED'\n   SIGNAL TELA1\n   END\nIF CAT = '' THEN DO\n   MESSAGE = 'USER CATALOG NAME NOT SPECIFIED'\n   SIGNAL TELA1\n   END\nIF CATADDR = '' THEN DO\n   MESSAGE = 'USER CATALOG ADDRESS NOT SPECIFIED'\n   SIGNAL TELA1\n   END\nIF ARQUIVO = '' THEN DO\n   MESSAGE = 'FILE NAME NOT SPECIFIED'\n   SIGNAL TELA1\n   END\nIF KEY \u00ac= '' & NSKIP \u00ac= '' THEN DO\n   MESSAGE = '\"SKIP\" AND \"KEY\" CANNOT BE BOTH SPECIFIED'\n   SIGNAL TELA1\n   END\nLINHA = ' PRINT INFILE(WORK1)'\nIF KEY   \u00ac= '' THEN LINHA = LINHA||' FROMKEY('||KEY||')'\nIF NSKIP \u00ac= '' THEN LINHA = LINHA||' SKIP('||SKIP||')'\nIF NRECS \u00ac= '' THEN LINHA = LINHA||' COUNT('||NLRECS||')'\n'EXECIO 1 DISKW PRVSAM AMSERV A 1 F 80 (FINIS VAR LINHA'\n'EXECIO 0 CP (STRING LINK' VSE MASTADDR MASTADDR 'RR' MASTPSWD\nIF RC <> 0 THEN DO\n   MESSAGE = 'MASTER CATALOG NOT LINKED, ADDRESS OR PASSWORD INCORRECT'\n   SIGNAL TELA1\n   END\n'EXECIO 0 CP (STRING LINK' VSE CATADDR CATADDR 'RR' CATPSWD\nIF RC <> 0 THEN DO\n   MESSAGE = 'USER CATALOG NOT LINKED, ADDRESS OR PASSWORD INCORRECT'\n   SIGNAL TELA1\n   END\n'SET DOS ON'\n'ACC' mastaddr 'G'\n'ACC' cataddr 'H'\n'ASSGN SYSCAT G'\n'ASSGN SYS010 G'\n'ASSGN SYS011 H'\n'DLBL IJSYSCT G DSN' master '(SYS010 VSAM)'\n'DLBL CATALOG H DSN' cat '(SYS011 VSAM)'\n'DLBL WORK1 H DSN' ARQUIVO '(SYS011 VSAM CAT CATALOG)'\n'SET DOS OFF'\n'AMSERV PRVSAM (' OPTION\nretcod=rc\nIF OPTION = 'PRINT' THEN DO\n   MESSAGE = 'AMSERV COMPLETED, RETURN CODE = ' RETCOD\n   SIGNAL REINICIO\n   END\nMAKEBUF\nPUSH 'AMSERV' RETCOD OPTION\n'EXECIO 1 DISKW PRVSAM AMSERV A 1 f 80 (FINIS'\nDROPBUF\n'REL G (DET'\n'REL H (DET'\n'quit'\nexit\n\n\nSergio de Oliveira Jurgensen\nSenior Systems Analyst\nSchlumberger Industrias (Brazil)             c Sergio de Oliveira Jurgensen 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A007A06": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x96\\x00\\x96\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 150, "newlines": 150, "modlines": 0, "user": "VSAMUPD"}, "text": "Calculating read hit and write hit ratios - revisited\n\nThe July issue of VSAM Update contained an article describing\nhow to calculate read and write hit ratios when a 3990-3 cache\ncontroller is installed. The author has modified the program\npublished to correct a bug in calculating the write hit ratios and\nto allow for more than one 3990-3 controller. The changes are\ngiven below - new or amended text is shown in italics.\n\n\nTECJL40\n\n IDENTIFICATION DIVISION.\n...\n 01  A3-CARD-IN.\n     05 FILLER        PIC X.\n     05 A3-TOTALS     PIC X(6).\n     05 FILLER        PIC X(15).\n     05 A3-TOT-READ   PIC X(8).\n     05 FILLER        PIC X(4).\n     05 A3-TOT-CREAD  PIC X(8).\n     05 FILLER        PIC X(4).\n     05 A3-TOT-WRITE  PIC X(8).\n     05 FILLER        PIC X(16).              <-----\n     05 A3-DASD-FW    PIC X(8).\n     05 FILLER        PIC X(55).              <-----\n...\n 01  A6-CARD-IN.\n     05 FILLER        PIC X(19).\n     05 A6-DFW        PIC X(16).\n     05 FILLER        PIC X(1).\n     05 A6-ACTIVE     PIC X(11).\n     05 FILLER        PIC X(62).\n 01  A7-CARD-IN.\n     05 FILLER        PIC X(26).\n     05 A7-SUBSYSTEM  PIC X(9).\n     05 FILLER        PIC X(6).\n     05 A7-SUBSYS-ID  PIC X(4).\n WORKING-STORAGE SECTION.\n*************************\n 77  W-VERSION    PIC X(16)     VALUE  \"PROGRAM TECJL40\".\n 77  W-X                  PIC 9         VALUE 0.\n 01  W-DISK-ID.\n     05 W-VOLUME          PIC X(6).\n     05 W_PREFIX          PIC XX.              <-----\n     05 W-VOLUME-ID       PIC XX.\n     05 FILLER            PIC X         VALUE \" \".\n     EJECT\n PROCEDURE DIVISION.\n********************\n 010M-MAINLINE SECTION.\n...\n     IF A2-VOLUME-LIT = \"VOLUME\"\n        IF W-X NOT = 1\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 2 TO W-X\n            MOVE A2-VOLUME TO W-VOLUME\n            MOVE A2-VOLUME-ID TO W-VOLUME-ID.         <-----\n            MOVE W-DISK-ID TO B1-DISK.                *DELETE THIS LINE*\n     IF A7-SUBSYSTEM = \"SUBSYSTEM\"\n        IF W-X NOT = 2\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 3 TO W-X\n            IF A7-SUBSYS-ID = \"0001\"\n                MOVE \" 7\" TO W-PREFIX\n                MOVE W-DISK-ID TO B1-DISK\n            ELSE\n                IF A7-SUBSYS-ID = \"0002\"\n                MOVE \" 9\" TO W-PREFIX\n                MOVE W-DISK-ID TO B1-DISK.\n     IF A3-TOTALS = \"TOTALS\"\n        IF W-X NOT = 3                       <-----\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 4 TO W-X                    <-----\n            MOVE A3-TOT-READ  TO B1-TOTREAD\n            MOVE A3-TOT-CREAD TO B1-TOTCACH\n            MOVE A3-TOT-WRITE TO B1-TOTWRIT\n            MOVE A3-DASD-FW   TO B1-TOT-FW\n            PERFORM 050D-EXAMINE.\n     IF A5-CACH = \"CACHING:\"\n        IF W-X NOT = 4                       <-----\n            PERFORM 999E-ABEND\n        ELSE\n            MOVE 5 TO W-X                    <-----\n            MOVE A5-ACTIVE TO B1-ACTIVE.\n     IF A6-DFW = \"DASD FAST WRITE:\"\n        IF W-X NOT = 5                       <-----\n...\n     CALL \"X\".\n\n\nTECJL41\n\n IDENTIFICATION DIVISION.\n...\n* The following code assists in sorting the DASD devices into a\n* desired order based on the device number.\n    IF B3-DISK-NUM < \"700\" AND B3-DISK-NUM NOT > \"709\"\n        MOVE \"A\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"70A\" AND B3-DISK-NUM NOT > \"70F\"\n           MOVE \"B\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"710\" AND B3-DISK-NUM NOT > \"719\"\n           MOVE \"C\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"71A\" AND B3-DISK-NUM NOT > \"71F\"\n           MOVE \"D\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"720\" AND B3-DISK-NUM NOT > \"729\"\n           MOVE \"E\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"72A\" AND B3-DISK-NUM NOT > \"72F\"\n           MOVE \"F\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"730\" AND B3-DISK-NUM NOT > \"739\"\n           MOVE \"G\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"73A\" AND B3-DISK-NUM NOT > \"73F\"\n           MOVE \"H\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"900\" AND B3-DISK-NUM NOT > \"909\"\n           MOVE \"I\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"90A\" AND B3-DISK-NUM NOT > \"90F\"\n           MOVE \"J\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"910\" AND B3-DISK-NUM NOT > \"919\"\n           MOVE \"K\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"91A\" AND B3-DISK-NUM NOT > \"91F\"\n           MOVE \"L\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"920\" AND B3-DISK-NUM NOT > \"929\"\n           MOVE \"M\" TO B3-SORT-IND\n    ELSE\n       IF B3-DISK-NUM < \"92A\" AND B3-DISK-NUM NOT > \"92F\"\n           MOVE \"N\" TO B3-SORT-IND\n    MOVE W1-TOTREAD TO B3-TOT-READ.\n...\n    EXIT.\n\n\nJohn Larry\nPerformance Analyst\nZurich Insurance Company (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A007A07": {"ttr": 8970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x03q\\x03q\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 881, "newlines": 881, "modlines": 0, "user": "VSAMUPD"}, "text": "Load a KSDS or ESDS\n\nThis is an Assembler program that may be used to load a\nKSDS or ESDS. The program is written to use the VSAM load\noption of RECOVERY. As a result, the load may be restarted\nshould there be a failure. The program will also report\nsecondary allocation, key compression, and other problems.\n\nThe program will operate either in initial load or resume load\nmode. Initial load mode occurs when the high-used RBA of the\nVSAM object is zero, resume load when the high-used RBA is\nnon-zero.\n\nWhen in initial load mode, the program will determine the\nfollowing:\n\no      Load option - speed or recovery\n\no      Number of records per CA.\n\nWhen in resume load mode, the program will determine the\nlast key (KSDS) or record (ESDS) that was loaded in the\nVSAM object. This is determined by positioning on the high-\nused-RBA and reading forwards. The input QSAM file is then\npositioned on a key that is not less than the VSAM high-key,\nor on an identical record for an ESDS. The load will resume\nfrom that point.\n\nThe program should use the temporary close option (TYPE=T)\nof the close macro when operating in initial load mode with\nRECOVERY enabled. SVC 23 is not very reliable, and is not\nused. Instead, after the first CA has been loaded, the VSAM\nobject is closed and re-opened. Should the load operation fail at\nthis point, VERIFY will correctly reset the high-used-RBA.\n\nThe current initial load with RECOVERY is not very\nsatisfactory because the VERIFY must perform a great deal of\nprocessing. As a result, the re-institution of the temporary close\nfollowing the loading of every data CA should be performed as\nsoon as the reliability of SVC 23 improves.\n\nVSAMLOAD TITLE 'SEMI-INTELLIGENT LOAD'\n         PRINT NOGEN\n*        PROGRAM ATTRIBUTES:\n*              REENTRANT\n*        SAMPLE JCL\n*              //LOAD   EXEC PGM=VSAMLOAD\n*              //QSAM     DD DSN=INPUT.QSAM,DISP=SHR,DCB=BUFNO=30\n*              //STEPLIB  DD DSN=MY.LOAD,DISP=SHR\n*              //SYSPRINT DD SYSOUT=*\n*              //VSAM     DD DSN=OUTPUT.VSAM,DISP=OLD,AMP='BUFND=43'\n         TITLE 'MACROS AND CONTROL BLOCKS USED'\n*        THE FOLLOWING MACROS ARE USED WITHIN THIS PROGRAM\n*\n*        ABEND                          TERMINATE TASK\n*        CLOSE                          TERMINATE FILE PROCESSING\n*        FREEMAIN                       RELEASE STORAGE\n*        FREEPOOL                       RELEASE BUFFER POOL\n*        GENCB                          GENERATE A CONTROL BLOCK\n*        GET                            RETRIEVE RECORD\n*        GETMAIN                        ACQUIRE STORAGE\n*        MODCB                          MODIFY A CONTROL BLOCK\n*        OPEN                           PREPARE FILE FOR PROCESSING\n*        POINT                          POSITION WITHIN FILE\n*        PUT                            OUTPUT RECORD\n*        SHOWCB                         SHOW CONTENT OF CONTROL BLOCK\n*        TESTCB                         TEST CONTENT OF CONTROL BLOCK\n*        WTO                            OUTPUT MESSAGE\n*\n*        THE FOLLOWING CONTROL BLOCKS ARE USED WITHIN THIS PROGRAM\n*        DCBD                           DCB MAPPING\n*        IDAAMB                         AMB MAPPING\n*        IDAAMBL                        AMBL MAPPING\n*        IDAAMDSB                       AMDSB MAPPING\n*        IFGACB                         ACB MAPPING\n*\n*        REGISTER USAGE - GENERAL\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . WORK\n*        3                              . WORK\n*                                       . -> CONTROL BLOCK\n*        4                              . -> CONTROL BLOCK\n*        5                              . -> CONTROL BLOCK\n*        6                              . WORK\n*        7                              . -> MESSAGE DETAIL\n*        8                              . -> INPUT RECORD\n*        9                              . -> PARAMETER WORK AREA\n*        10                             . -> BRANCH AND SAVE RETURN\n*        11                             . -> CSECT BASE\n*        12                             . -> CSECT BASE +4096\n*        13                             . -> SAVE AREA\n*        14                             . -> RETURN\n*        15                             . -> ENTRY POINT\n*                                       . RETURN CODE\n         TITLE 'CONTROL CODE'\n*        1.    PROGRAM PROLOG\n*        2.    PERFORM INITIALIZATION\n*        3.    PERFORM MAIN PROCESSING (IF NOT EOF ON QSAM)\n*        4.    PERFORM TERMINATION\n*        5.    PROGRAM EPILOG\n         SPACE 1\nVSAMLOAD CSECT\n         STM   R14,R12,12(R13)          . SAVE CALLER'S REGISTERS\n         LR    R11,R15                  . 11 -> EPA\n         LA    R12,4095(,R11)           . 12 -> EPA +4095\n         LA    R12,1(,R12)              . 12 -> EPA +4096\n         USING VSAMLOAD,R11,R12         . CSECT ADDRESSABILITY\n         LA    R2,DYNLEN                . 2 - LENGTH OF DYNAMIC AREA\n         GETMAIN RU,                    . ACQUIRE DYNAMIC AREA         C\n               LOC=BELOW,                                              C\n               LV=(R2)\n         ST    R1,8(,R13)               . SAVE LSA ->\n         ST    R13,4(,R1)               . SAVE HSA ->\n         LR    R13,R1                   . 13 -> DYNAMIC / SAVE AREA\n         USING DYNAREA,R13              . DSECT ADDRESSABILITY\n         BAS   R10,INITIAL              . PERFORM INITIALIZATION\n         CLI   EOF,ON                   . Q. EOF ON QSAM INPUT?\n         BE    A0001                    . A. YES\n         BAS   R10,PROCESS              . PERFORM MAIN PROCESS\nA0001    EQU   *\n         BAS   R10,TERMIN               . PERFORM TERMINATION\n         LR    R2,R13                   . 2 -> DYNAMIC AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         LA    R3,DYNLEN                . 3 - LENGTH OF DYNAMIC AREA\n         FREEMAIN RU,                   . RELEASE STORAGE              C\n               A=(R2),                                                 C\n               LV=(R3)\n         LM    R14,R12,12(R13)          . RESTORE CALLER'S REGISTERS\n         SLR   R15,R15                  . 15 - ZERO\n         BR    R14                      . RETURN\n         TITLE 'PROGRAM INITIALIZATION'\n*        1.    GENERATE ACB, EXIT LIST AND RPL\n*        2.    OPEN VSAM, OBTAIN DATA FROM CONTROL BLOCKS\n*              AND THROUGH SHOWCB AND TESTCB REQUESTS\n*        3.    CLOSE VSAM OBJECT\n*        4.    IF RECOVERY ENABLED, PERFORM LOCATE HIGH VSAM RECORD\n*        5.    MODIFY ACB AND RPL FOR KSDS OR ESDS\n*        6.    INITIALIZE DATA AREAS, OPEN ALL FILES AND CHECK OPEN\n*        7.    IF RECOVERY AND HIGH-USED RBA NON-ZERO, RE-POSITION QSAM\n*        8.    CHANGE QSAM EOD ADDRESS\n         SPACE 1\n*        REGISTERS USED\n*        0                              MACROS\n*        1                              MACROS\n*        2                              WORK\n*        3                              -> ACB\n*        4                              -> EXIT LIST\n*                                       -> RPL\n*                                       -> QSAM DCB\n*        5                              -> SYSPRINT DCB\n*        9                              -> PARAMETER WORK AREA\n*        10                             RETURN ADDRESS\n         SPACE 1\nINITIAL  EQU   *\n         ST    R10,BSAVE                . SAVE RETURN REGISTER\n         LA    R2,RPLLEN                . 2 - LENGTH OF LONGEST\n*                                       .   PARAMETER AREA\n         GETMAIN RU,                    . ACQUIRE PARAMETER STORAGE    C\n               LV=(R2)\n         LR    R9,R1                    . 9 -> ACQUIRED STORAGE\n         GENCB BLK=ACB,                 . GENERATE ACB                 C\n               AM=VSAM,                                                C\n               DDNAME=VSAM,                                            C\n               MACRF=(SEQ,OUT),                                        C\n               MF=(G,(R9))\n         ST    R1,@ACB                  . SAVE ACB ->\n         LR    R3,R1                    . 3 -> ACB\n         GENCB BLK=EXLST,               . GENERATE EXIT LIST           C\n               EODAD=E0005,                                            C\n               MF=(G,(R9))\n         ST    R1,@EXLST                . SAVE EXIT LIST ->\n         LR    R4,R1                    . 4 -> EXIT LIST\n         MODCB ACB=(R3),                . MODIFY ACB FOR EXIT LIST     C\n               EXLST=(R4),                                             C\n               MF=(G,(R9))\n         GENCB BLK=RPL,                 . GENERATE RPL                 C\n               ACB=(R3),                                               C\n               AM=VSAM,                                                C\n               OPTCD=(ADR,SEQ,MVE),                                    C\n               MF=(G,(R9),RPLLEN)\n         ST    R1,@RPL                  . SAVE RPL ->\n         MVC   DMAL(LOPEN1L),OPEN1L     . MOVE DMA LIST TO DYNAMIC\n         OPEN  ((R3),OUTPUT),           . OPEN VSAM ACB                C\n               MF=(E,DMAL)\n         B     *+4(R15)                 . BRANCH ON RETURN CODE\n         B     B0002                    . 0 - OPEN OKAY\n         B     B0001                    . 4 - OPEN WITH WARNINGS\n         B     B0010                    . 8 - OPEN FAILED\nB0001    EQU   *\n         LA    R2,ERRFLD                . 2 -> ACB ERROR AREA\n         SHOWCB ACB=(R3),               . DETERMINE ACB ERROR          C\n               AREA=(R2),                                              C\n               FIELDS=ERROR,                                           C\n               LENGTH=4,                                               C\n               MF=(G,(R9))\n         CLC   ERRFLD,=F'+118'          . Q. VERIFY OKAY?\n         BNE   B0010                    . A. NO - ABEND\nB0002    EQU   *\n         USING IFGACB,R3                . ACB DSECT ADDRESSABILITY\n         L     R2,ACBAMBL               . 2 -> AMB LIST\n         DROP  R3\n         USING IDAAMBL,R2               . AMB LIST DSECT ADDRESSABILITY\n         L     R2,AMBLDTA               . 2 -> AMB FOR DATA\n         DROP  R2\n         USING IDAAMB,R2                . AMB DSECT ADDRESSABILITY\n         MVC   DAMBFLG1,AMBFLG1         . SAVE FLAG\n         TM    DAMBFLG1,AMBSPEED        . Q. SPEED OPTION ENABLED?\n         BO    B0003                    . A. YES\n         L     R2,AMBDSB                . 2 -> AMDSB\n         DROP  R2\n         USING IDAAMDSB,R2              . AMDSB DSECT ADDRESSABILITY\n         MVC   DAMDCICA,AMDCIPCA        . SAVE CIS PER CA\n         MVC   DAMDFSCA,AMDFSCA         . SAVE CA FREE SPACE BYTES\n         MVC   DAMDFSCI,AMDFSCI         . SAVE CI FREE SPACE BYTES\n         DROP  R2\n         LA    R2,SHOWAREA              . 2 -> SHOWCB AREA\n         SHOWCB ACB=(R3),               . DETERMINE ACB DATA           C\n               AREA=(R2),                                              C\n               FIELDS=(CINV,ENDRBA,KEYLEN,LRECL,RKP),                  C\n               LENGTH=20,                                              C\n               MF=(G,(R9))\nB0003    EQU   *\n         MVI   OBJ,ESDS                 . DEFAULT TO ESDS\n         TESTCB ACB=(R3),               . Q. OBJECT AN ESDS?           C\n               ATRB=ESDS,                                              C\n               MF=(G,(R9))\n         BE    B0004                    . A. YES\n         MVI   OBJ,KSDS                 . FLAG AS KSDS\n         TESTCB ACB=(R3),               . Q. OBJECT A KSDS?            C\n               ATRB=KSDS,                                              C\n               MF=(G,(R9))\n         BNE   B0013                    . A. NO - ERROR\nB0004    EQU   *\n         CLOSE ((R3)),                  . CLOSE VSAM ACB               C\n               MF=(E,DMAL)\n         TM    DAMBFLG1,AMBSPEED        . Q. SPEED ENABLED?\n         BO    B0005                    . A. YES\n         BAS   R10,LASTVSAM             . LOCATE HIGH-RECORD ON VSAM\nB0005    EQU   *\n         L     R4,@RPL                  . 4 -> RPL\n         CLI   OBJ,ESDS                 . Q. ESDS OBJECT?\n         BE    B0006                    . A. YES\n         MODCB RPL=(R4),                . MODIFY RPL FOR KSDS          C\n               OPTCD=(KEY,SEQ),                                        C\n               MF=(G,(R9))\n         L     R3,@ACB                  . 3 -> ACB\n         MODCB ACB=(R3),                . MODIFY ACB FOR KSDS          C\n               MACRF=(KEY,SEQ,OUT),                                    C\n               MF=(G,(R9))\n         B     B0007                    . CONTINUE\nB0006    EQU   *\n         MODCB RPL=(R4),                . MODIFY RPL FOR ESDS          C\n               OPTCD=(ADR,SEQ),                                        C\n               MF=(G,(R9))\n         L     R3,@ACB                  . 3 -> ACB\n         MODCB ACB=(R3),                . MODIFY ACB FOR ESDS          C\n               MACRF=(ADR,SEQ,OUT),                                    C\n               MF=(G,(R9))\nB0007    EQU   *\n         ZAP   #RECREAD,=P'+0'          . INITIALIZE COUNTS\n         ZAP   #RECWRIT,=P'+0'\n         ZAP   #PAGE,=P'+0'\n         ZAP   #LINE,=P'+60'            . INITIALIZE LINE COUNTER\n         MVI   EOF,OFF                  . SET NOT-EOF ON QSAM\n         MVI   OUTLINE,C' '             . INITIALIZE REPORT LINE\n         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE\n         MVC   DCB1(LQSAMDCB),QSAMDCB   . MOVE QSAM DCB TO DYNAMIC\n         MVC   DCB2(LSYSDCB),SYSDCB     . MOVE SYSPRINT DCB TO DYNAMIC\n         L     R3,@ACB                  . 3 -> VSAM ACB\n         LA    R4,DCB1                  . 4 -> QSAM DCB\n         USING IHADCB,R4                . DCB DSECT ADDRESSABILITY\n         MVC   DCBEXIT+1(3),=AL3(OPENEXIT) . OPEN EXIT ADDRESS\n         MVI   DCBEXIT,X'85'            . OPEN EXIT AND END\n         LA    R2,DCBEXIT               . 2 -> DCB EXIT\n         ST    R2,DCBEXLST              . SAVE IN QSAM DCB\n         MVC   DMAL(LOPEN3L),OPEN3L     . DMA LIST TO DYNAMIC\n         LA    R5,DCB2                  . 5 -> SYSPRINT DCB\n         OPEN  ((R3),OUTPUT,(R4),,(R5),OUTPUT), . OPEN FILES           C\n               MF=(E,DMAL)\n         LTR   R15,R15                  . Q. OPEN OKAY?\n         BZ    B0008                    . A. YES\n         USING IFGACB,R3                . ACB DSECT ADDRESSABILITY\n         TM    ACBOFLGS,ACBOPEN         . Q. VSAM ACB OPEN?\n         BNO   B0010                    . A. NO\n         TM    DCBOFLGS,DCBOFOPN        . Q. QSAM DCB OPEN?\n         BNO   B0011                    . A. NO\n         DROP  R4\n         USING IHADCB,R5                . MAP SYSPRINT DCB\n         TM    DCBOFLGS,DCBOFOPN        . Q. SYSPRINT DCB OPEN?\n         BNO   B0012                    . A. NO\n         DROP  R5\nB0008    EQU   *\n         TM    DAMBFLG1,AMBSPEED        . Q. SPEED ENABLED?\n         BO    B0009                    . A. YES\n         OC    ENDRBA,ENDRBA            . Q. HI-USED RBA ZERO?\n         BZ    B0009                    . A. YES\n         BAS   R10,SKIPQSAM             . REPOSITION QSAM\nB0009    EQU   *\n         LA    R4,DCB1                  . 4 -> QSAM DCB\n         USING IHADCB,R4                . MAP QSAM DCB\n         MVC   DCBEODAD,=AL4(C0009)     . CHANGE QSAM EODAD ADDRESS\n         DROP  R4\n         L     R10,BSAVE                . RESTORE RETURN ADDRESS\n         BR    R10                      . RETURN\nB0010    EQU   *                        . VSAM OPEN FAIL\n         ST    R15,ERR15                . SAVE 15\n         WTO   MF=(E,WTO1L)             . OUTPUT MESSAGE\n         LA    R2,ERRFLD                . 2 -> ACB ERROR AREA\n         SHOWCB ACB=(R3),               . DETERMINE ACB ERROR          C\n               AREA=(R2),                                              C\n               FIELDS=ERROR,                                           C\n               LENGTH=4,                                               C\n               MF=(G,(R9))\n         LM    R2,R3,ERR15              . LOAD DATA INTO REGS\n         B     B0014                    . BRANCH TO ABEND\nB0011    EQU   *                        . QSAM OPEN FAIL\n         WTO   MF=(E,WTO2L)             . OUTPUT MESSAGE\n         B     B0014                    . BRANCH TO ABEND\nB0012    EQU   *                        . SYSPRINT OPEN FAIL\n         WTO   MF=(E,WTO3L)             . OUTPUT MESSAGE\n         B     B0014                    . BRANCH TO ABEND\nB0013    EQU   *                        . NOT KSDS OR ESDS\n         WTO   MF=(E,WTO4L)             . OUTPUT MESSAGE\nB0014    EQU   *                        . ABEND POINT\n         ABEND 400,                     . TERMINATE TASK               C\n               DUMP\n         TITLE 'MAIN PROGRAM PROCESSING'\n*        1.    READ QSAM RECORD, INCREMENT RECORDS READ\n*        2.    IF RECORD FORMAT VARIABLE, CHANGE RECORD LENGTH AND ->\n*        3.    MODIFY RPL DATA, AND PUT VSAM RECORD\n*        4.    CHECK RESULT OF PUT\n*        5.    IF INITIAL LOAD AND RECOVERY ENABLED, CHECK IF FIRST CA\n*              HAS BEEN LOADED.  ISSUE CLOSE AND OPEN OF VSAM AFTER\n*              FIRST CA LOADED.\n*        6.    CONTINUE UNTIL EOF ON QSAM\n         SPACE 1\n*        REGISTERS USED\n*        0                              MACROS\n*        1                              MACROS\n*        2                              WORK\n*        3                              -> RPL\n*        4                              -> QSAM DCB\n*        6                              PUT ACCUMULATOR\n*        7                              -> MESSAGE DETAIL\n*        8                              -> QSAM RECORD\n*        9                              -> PARAMETER WORK AREA\n*        10                             RETURN ADDRESS\n         SPACE 1\nPROCESS  EQU   *\n         ST    R10,CSAVE                . SAVE RETURN ADDRESS\n         USING IHADCB,R4                . MAP QSAM DCB\n         L     R3,@RPL                  . 3 -> RPL\n         SLR   R6,R6                    . 6 - ZERO\n         MVI   MSGSW,C'0'               . INITIALIZE MESSAGE FLAG\nC0001    EQU   *\n         GET   (R4)                     . GET A QSAM RECORD\n         AP    #RECREAD,=P'+1'          . INCREMENT RECORDS READ\n         LR    R8,R1                    . 8 -> INPUT RECORD\n         LH    R2,DCBLRECL              . 2 - LOGICAL RECORD LENGTH\n         TM    DCBRECFM,DCBRECV         . Q. VARIABLE FORMAT?\n         BNO   C0002                    . A. NO\n         SH    R2,=H'+4'                . DECREMENT LENGTH BY FOUR\n         LA    R8,4(,R8)                . 8 -> AFTER RDW\nC0002    EQU   *\n         MODCB RPL=(R3),                . MODIFY RPL                   C\n               AREA=(R8),               .   -> RECORD                  C\n               RECLEN=(R2),             .   - LENGTH OF RECORD         C\n               MF=(G,(R9))\n         PUT   RPL=(R3)                 . PUT TO VSAM\n         AP    #RECWRIT,=P'+1'          . INCREMENT RECORDS WRITTEN\n         ST    R15,ERR15                . SAVE 15\n         B     *+4(R15)                 . BRANCH ON RETURN CODE\n         B     C0003                    . 0 - CHECK RPL FEED BACK\n         B     C0006                    . 4 - STRING ERROR\n         B     C0007                    . 8 - LOGIC ERROR\n         B     C0008                    . 12 - PHYSICAL ERROR\nC0003    EQU   *\n         LA    R2,ERRFLD                . 2 -> RPL FEED BACK AREA\n         SHOWCB RPL=(R3),               . DETERMINE RPL FEED BACK      C\n               AREA=(R2),                                              C\n               FIELDS=FDBK,                                            C\n               LENGTH=4,                                               C\n               MF=(G,(R9))\n         L     R15,ERRFLD               . 15 - RPL FEED BACK\n         B     *+4(,R15)                . BRANCH ON FEED BACK\n         B     C0005                    . 0 - PUT SUCCESSFUL\n         B     C0004                    . 4 - SECONDARY ALLOCATION\n         B     C0004                    . 8 - DUPLICATE ALTERNATE INDEX\n         B     C0004                    . 12 - WRITE BUFFER\n         B     C0004                    . 16 - SEQUENCE SET CAPACITY\n         B     C0005                    . 20 - RESERVED\n         B     C0004                    . 24 - NO BUFFER WRITES\n         B     C0005                    . 28 - CI SPLIT INDICATOR\n         B     C0005                    . 32 - MARK BUFFER INVALID\n         B     C0005                    . RESERVED\n         B     C0005                    . RESERVED\nC0004    EQU   *\n         SRA   R15,2                    . DIVIDE 15 BY FOUR\n         BCTR  R15,R0                   . DECREMENT BY ONE\n         MH    R15,=H'+60'              . MULTIPLY BY SIXTY\n         LA    R7,RC0MSG                . 7 -> MESSAGE ARRAY\n         AR    R7,R15                   . 7 -> SPECIFIC MESSAGE\n         BAS   R10,PUTSYS               . OUTPUT MESSAGE\nC0005    EQU   *\n         OC    ENDRBA,ENDRBA            . Q. HI-USED RBA ZERO?\n         BNZ   C0001                    . A. NO\n         TM    DAMBFLG1,AMBSPEED        . Q. SPEED ENABLED?\n         BO    C0001                    . A. YES\n         LA    R6,1(,R6)                . INCREMENT 6 BY ONE\n         C     R6,RECPERCA              . Q. FIRST CA LOADED?\n         BNH   C0001                    . A. NO\n         L     R2,@ACB                  . 2 -> ACB\n         MVC   DMAL(LOPEN1L),OPEN1L     . MOVE DMA LIST TO DYNAMIC\n*              THE NEXT THREE STATEMENTS - CLOSE, OPEN, AND MVI\n*              ARE CODED DUE TO THE INCORRECT OPERATION OF SVC 23\n*              THESE SHOULD BE REPLACED BY\n*        CLOSE ((R2)),                  . TEMPORARILY CLOSE ACB        C\n               TYPE=T,                                                 C\n               MF=(E,DMAL)\n         CLOSE ((R2)),                  . CLOSE VSAM ACB               C\n               MF=(E,DMAL)\n         OPEN  ((R2),OUTPUT),           . OPEN VSAM ACB                C\n               MF=(E,DMAL)\n         MVI   DAMBFLG1,AMBSPEED        . FLAG SPEED ENABLED\n         LA    R6,1                     . 6 - ONE\n         LA    R7,TCMSG                 . 7 -> CLOSE MESSAGE\n         BAS   R10,PUTSYS               . OUTPUT MESSAGE\n         B     C0001                    . PROCESS NEXT QSAM RECORD\nC0006    EQU   *\n         LA    R7,RC4MSG                . 7 -> OUTPUT MESSAGE\n         BAS   R10,PUTSYS               . OUTPUT MESSAGE\n         B     C0010                    . TERMINATE\nC0007    EQU   *\n         LA    R7,RC8MSG                . 7 -> OUTPUT MESSAGE\n         BAS   R10,PUTSYS               . OUTPUT MESSAGE\n         B     C0010                    . TERMINATE\nC0008    EQU   *\n         LA    R7,RC12MSG               . 7 -> OUTPUT MESSAGE\n         BAS   R10,PUTSYS               . OUTPUT MESSAGE\n         B     C0010                    . TERMINATE\nC0009    EQU   *\n         DROP  R4\n         L     R10,CSAVE                . RESTORE RETURN ADDRESS\n         BR    R10                      . RETURN\nC0010    EQU   *\n         WTO   MF=(E,WTO7L)             . OUTPUT MESSAGE\n         LM    R2,R3,ERR15              . LOAD REGISTERS\n         ABEND 402,                     . TERMINATE PROGRAM            C\n               DUMP\n         TITLE 'PROGRAM TERMINATION'\n*        1.    RELEASE PARAMETER WORK STORAGE\n*        2.    OUTPUT END OF RUN MESSAGE\n*        3.    CLOSE FILES\n*        4.    FREE QSAM AND SYSPRINT BUFFER POOLS\n         SPACE 1\n*        REGISTERS USED\n*        0                              MACROS\n*        1                              MACROS\n*        3                              -> ACB\n*                                       WORK\n*        4                              -> QSAM DCB\n*        5                              -> SYSPRINT DCB\n*        9                              -> PARAMETER WORK AREA\n*        10                             RETURN ADDRESS\n         SPACE 1\nTERMIN   EQU   *\n         ST    R10,DSAVE                . SAVE RETURN ADDRESS\n         LA    R3,RPLLEN                . 3 - LENGTH OF LARGEST PARAM\n         FREEMAIN RU,                   . RELEASE STORAGE              C\n               A=(R9),                                                 C\n               LV=(R3)\n         LA    R7,LOADMSG               . 7 -> OUTPUT MESSAGE\n         MVI   MSGSW,C'E'               . SET MESSAGE FLAG\n         BAS   R10,PUTSYS               . OUTPUT MESSAGE\n         MVC   DMAL(LOPEN3L),OPEN3L     . MOVE DMA LIST TO DYNAMIC\n         L     R3,@ACB                  . 3 -> VSAM ACB\n         LA    R4,DCB1                  . 4 -> QSAM DCB\n         LA    R5,DCB2                  . 5 -> SYSPRINT DCB\n         CLOSE ((R3),,(R4),,(R5)),      . CLOSE FILES                  C\n               MF=(E,DMAL)\n         FREEPOOL (R4)                  . FREE QSAM BUFFER POOL\n         FREEPOOL (R5)                  . FREE SYSPRINT BUFFER POOL\n         L     R10,DSAVE                . RESTORE RETURN ADDRESS\n         BR    R10                      . EXIT\n         TITLE 'DETERMINE LAST RECORD OUTPUT TO VSAM'\n*        1.    EXIT IF HIGH-USED RBA ZERO\n*        2.    CALCULATE RECORDS PER CA\n*        3.    ACQUIRE STORAGE FOR VSAM RECORD\n*        4.    MODIFY ACB AND RPL FOR RBA ACCESS\n*        5.    OPEN ACB\n*        6.    POSITION ON CALCULATED RBA\n*        7.    READ FORWARDS UNTIL SEOF FOUND\n*        8.    CLOSE ACB\n         SPACE 1\n*        REGISTERS USED\n*        0                              MACROS\n*        1                              MACROS\n*        2                              WORK\n*        3                              WORK\n*                                       -> ACB\n*        4                              WORK\n*                                       -> RPL\n*        6                              -> RBA AREA\n*        8                              -> RECORD AREA\n*        9                              -> PARAMETER WORK AREA\n*        10                             RETURN ADDRESS\n         SPACE 1\nLASTVSAM EQU   *\n         OC    ENDRBA,ENDRBA            . Q. HI-USED RBA ZERO?\n         BNZ   E0002                    . A. NO\n         OC    DAMDFSCI,DAMDFSCI        . Q. CI FREE SPACE BYTES ZERO?\n         BNZ   E0001                    . A. NO\n         MVC   DAMDFSCI,=F'10'          . TEN UNUSABLE PER CI\nE0001    EQU   *\n         L     R2,CINV                  . 2 - CI SIZE\n         S     R2,DAMDFSCI              . DECREMENT BY CI FREE SPACE\n*                                       .   BYTES\n         SRDA  R2,32                    . SHIFT INTO 3\n         L     R4,LRECL                 . 4 - LOGICAL RECORD LENGTH\n         DR    R2,R4                    . DIVIDE USABLE CI BY RECORD\n*                                       .   LENGTH\n         LH    R4,DAMDCICA              . 4 - CIS PER CA\n         SH    R4,DAMDFSCA              . DECREMENT BY FREE CIS PER CA\n         MR    R2,R4                    . MULTIPLY BY RECORDS PER CI\n         ST    R3,RECPERCA              . SAVE RECORDS PER CA\nE0002    EQU   *\n         L     R2,LRECL                 . 2 - RECORD LENGTH\n         GETMAIN RU,                    . ACQUIRE STORAGE FOR RECORD   C\n               LOC=BELOW,                                              C\n               LV=(R2)\n         ST    R1,@REC                  . SAVE RECORD AREA ADDRESS\n         OC    ENDRBA,ENDRBA            . Q. HI-USED RBA ZERO?\n         BZ    E0006                    . A. YES\n         LH    R3,DAMDCICA              . 3 - CIS PER CA\n         M     R2,CINV                  . MULTIPLY BY CI SIZE\n         ST    R3,CASZ                  . SAVE BYTES PER CA\n         L     R3,@ACB                  . 3 -> VSAM ACB\n         MODCB ACB=(R3),                . MODIFY ACB FOR RBA ACCESS    C\n               MACRF=(IN,ADR,SEQ),                                     C\n               MF=(G,(R9))\n         L     R2,LRECL                 . 2 - LOGICAL RECORD LENGTH\n         L     R4,@RPL                  . 4 -> RPL\n         LA    R6,RBA                   . 6 -> RBA AREA\n         L     R8,@REC                  . 8 -> RECORD WORK AREA\n         MODCB RPL=(R4),                . MODIFY RPL                   C\n               AREA=(R8),                                              C\n               AREALEN=(R2),                                           C\n               ARG=(R6),                                               C\n               MF=(G,(R9))\n         OPEN  ((R3)),                  . OPEN VSAM ACB                C\n               MF=(E,DMAL)\n         LTR   R15,R15                  . Q. OPEN SUCCESSFUL?\n         BNZ   E0007                    . A. NO\n         L     R2,ENDRBA                . 2 - HI-USED RBA\n         S     R2,CASZ                  . DECREMENT BY BYTES PER CA\n         LTR   R2,R2                    . Q. RESULT POSITIVE?\n         BP    E0003                    . A. YES\n         SLR   R2,R2                    . 2 - ZERO\nE0003    EQU   *\n         ST    R2,RBA                   . SAVE IN RBA AREA\n         POINT RPL=(R4)                 . POSITION ON RBA\n         LTR   R15,R15                  . Q. POINT SUCCESSFUL?\n         BNZ   E0008                    . A. NO\nE0004    EQU   *\n         GET   RPL=(R4)                 . GET PHYSICAL RECORD\n         LTR   R15,R15                  . Q. GET SUCCESSFUL?\n         BNZ   E0009                    . A. NO\n         B     E0004                    . A. YES - GET NEXT\nE0005    EQU   *\n         CLOSE ((R3)),                  . CLOSE VSAM ACB               C\n               MF=(E,DMAL)\nE0006    EQU   *\n         BR    R10                      . RETURN\nE0007    EQU   *                        . VSAM OPEN FAILURE\n         ST    R15,ERR15                . SAVE RETURN CODE\n         WTO   MF=(E,WTO1L)             . OUTPUT MESSAGE\n         LA    R2,ERRFLD                . 2 -> ACB ERROR FIELD\n         SHOWCB ACB=(R3),               . DETERMINE ACB ERROR CODE     C\n               AREA=(R2),                                              C\n               FIELDS=ERROR,                                           C\n               LENGTH=4,                                               C\n               MF=(G,(R9))\n         B     E0011                    . BRANCH TO ABEND\nE0008    EQU   *                        . VSAM POINT FAILURE\n         ST    R15,ERR15                . SAVE RETURN CODE\n         WTO   MF=(E,WTO5L)             . OUTPUT MESSAGE\n         B     E0010                    . BRANCH TO RPL PROCESS\nE0009    EQU   *                        . VSAM GET FAILURE\n         ST    R15,ERR15                . SAVE RETURN CODE\n         WTO   MF=(E,WTO6L)             . OUTPUT MESSAGE\nE0010    EQU   *\n         LA    R2,ERRFLD                . 2 -> RPL FEED BACK AREA\n         SHOWCB RPL=(R4),               . DETERMINE RPL FEED BACK      C\n               AREA=(R2),                                              C\n               FIELDS=FDBK,                                            C\n               LENGTH=4,                                               C\n               MF=(G,(R9))\nE0011    EQU   *\n         LM    R2,R3,ERR15              . LOAD REGISTERS\n         ABEND 401,                     . TERMINATE TASK               C\n               DUMP\n         TITLE 'CODE REPOSITIONING INPUT QSAM FILE'\n*        1.    IF KSDS BEING PROCESSED, DETERMINE KEY LENGTH AND\n*              DISPLACEMENT IN LAST VSAM RECORD READ\n*        2.    READ QSAM RECORD AND INCREMENT RECORDS READ\n*        3.    IF KSDS BEING PROCESSED, COMPARE QSAM KEY AGAINST\n*              KEY IN LAST VSAM RECORD READ.  IF NOT LESS THAN, EXIT\n*        4.    IF ESDS BEING PROCESSED, COMPARE QSAM RECORD READ\n*              AGAINST LAST VSAM RECORD READ.  IF EQUAL, EXIT\n         SPACE 1\n*        REGISTERS USED\n*        0                              MACROS\n*        1                              MACROS\n*        2                              -> QSAM RECORD\n*        3                              RECORD LENGTH\n*        4                              -> QSAM DCB\n*        6                              -> VSAM KEY AREA (KSDS)\n*                                       -> VSAM RECORD AREA (ESDS)\n*        7                              KEY LENGTH (KSDS)\n*                                       RECORD LENGTH (ESDS)\n*                                       -> MESSAGE DETAIL\n*        10                             RETURN ADDRESS\n         SPACE 1\nSKIPQSAM EQU   *\n         ST    R10,GSAVE                . SAVE RETURN ADDRESS\n         CLI   OBJ,KSDS                 . Q. KSDS BEING PROCESSED?\n         BNE   F0001                    . A. NO\n         L     R6,@REC                  . 5 -> LAST VSAM RECORD\n         L     R7,KEYLEN                . 7 - KEY LENGTH\n         BCTR  R7,R0                    . DECREMENT FOR EXECUTE\n         L     R2,RKP                   . 2 - RELATIVE KEY POSITION\n         LA    R6,0(R2,R6)              . 6 -> KEY IN LAST VSAM RECORD\nF0001    EQU   *\n         GET   (4)                      . GET NEXT QSAM RECORD\n         AP    #RECREAD,=P'+1'          . INCREMENT RECORDS READ\n         CLI   OBJ,KSDS                 . Q. KSDS BEING PROCESSED?\n         BNE   F0002                    . A. NO\n         LA    R1,0(R2,R1)              . 1 -> KEY IN QSAM RECORD\n         EX    R7,CLC                   . Q. QSAM KEY >= VSAM KEY\n         BNL   F0004                    . A. YES\n         B     F0001                    . TRY NEXT QSAM\nF0002    EQU   *                        . ESDS COMPARISON\n         L     R6,@REC                  . 6 -> LAST VSAM RECORD\n         L     R7,LRECL                 . 7 - LOGICAL RECORD LENGTH\n         LR    R2,R1                    . 2 -> QSAM RECORD\n         LR    R3,R7                    . 3 - LOGICAL RECORD LENGTH\n         CLCL  R2,R6                    . Q. QSAM RECORD = VSAM RECORD?\n         BNE   F0001                    . A. NO - PROCESS NEXT QSAM\n         B     F0004                    . A. YES - EXIT\nF0003    EQU   *                        . QSAM EODAD\n         MVI   EOF,ON                   . FLAG END OF FILE\nF0004    EQU   *\n         LA    R7,SKIPMSG               . 7 -> OUTPUT MESSAGE\n         MVI   MSGSW,C'S'               . INITIALIZE MESSAGE FLAG\n         BAS   R10,PUTSYS               . OUTPUT MESSAGE\n         L     R10,GSAVE                . RESTORE RETURN ADDRESS\n         BR    R10                      . EXIT\nCLC      CLC   0(0,R1),0(R6)            . EXECUTED KEY COMPARE\n         TITLE 'REPORT OUTPUT ROUTINE'\n*        1.    IF HEADING LINE REQUIRED, OUTPUT HEADING\n*        2.    FORMAT AND OUTPUT MESSAGE DATA\n         SPACE 1\n*        REGISTERS USED\n*        0                              MACROS\n*        1                              MACROS\n*        2                              -> OUTPUT LINE\n*        8                              -> SYSPRINT DCB\n*        10                             RETURN ADDRESS\n         SPACE 1\nPUTSYS   EQU   *\n         LA    R2,OUTLINE               . 2 -> OUTPUT LINE\n         LA    R8,DCB2                  . 5 -> SYSPRINT DCB\n         CP    #LINE,=P'+58'            . Q. HEADINGS REQUIRED?\n         BL    G0001                    . A. NO\n         MVC   OUTLINE,HEAD1            . FORMAT HEADINGS\n         MVC   OUTLINE+PAGEOUT+4(L'MASK5),MASK5\n         AP    #PAGE,=P'+1'             . INCREMENT PAGE NUMBER\n         ED    OUTLINE+PAGEOUT+4(L'MASK5),#PAGE\n         PUT   (R8),                    . OUTPUT HEADING               C\n               (R2)\n         ZAP   #LINE,=P'+1'             . ZAP LINE COUNT\n         MVI   OUTLINE,C'0'             . CHANGE ASA CONTROL CHARACTER\n         MVI   OUTLINE+1,C' '           . SPACE FILL OUTPUT LINE\n         MVC   OUTLINE+2(L'OUTLINE-2),OUTLINE+1\nG0001    EQU   *\n         MVC   OUTMSG,0(R7)             . OUTPUT MESSAGE DETAIL\n         MVC   RECOUT,MASK9             . MOVE MASK\n         CLI   MSGSW,C'0'               . Q. MESSAGE FLAG ZERO?\n         BNE   G0002                    . A. NO\n         MVC   OUTLRR,=C'LAST RECORD READ:' . OUTPUT LITERAL\n         ED    RECOUT,#RECREAD          . OUTPUT RECORDS READ\n         B     G0004                    . CONTINUE\nG0002    EQU   *\n         MVI   OUTLRR,C' '              . SPACE-FILL LITERAL AREA\n         MVC   OUTLRR+1(L'OUTLRR-1),OUTLRR\n         CLI   MSGSW,C'S'               . Q. MESSAGE FLAG 'S'?\n         BNE   G0003                    . A. NO\n         ED    RECOUT,#RECREAD          . OUTPUT RECORDS READ\n         B     G0004                    . CONTINUE\nG0003    EQU   *\n         ED    RECOUT,#RECWRIT          . OUTPUT RECORDS WRITTEN\nG0004    EQU   *\n         PUT   (R5),                    . OUTPUT REPORT DETAIL         C\n               (R2)\n         AP    #LINE,=P'+1'             . INCREMENT LINES PRINTED\n         MVI   OUTLINE,C' '             . RESET ASA CONTROL CHARACTER\n         BR    R10                      . RETURN\n         TITLE 'QSAM DCB OPEN EXIT'\n*        1.    IF NOT VARIABLE SPANNED, EXIT\n*        2.    IF LRI ENABLED, EXIT\n*        3.    ENABLE LRI\n         SPACE 1\n*        REGISTERS USED\n*        4                              -> QSAM DCB\n*        14                             -> RETURN\n         SPACE 1\nOPENEXIT EQU   *\n         USING IHADCB,R4                . MAP QSAM DCB\n         TM    DCBRECFM,DCBRECV+DCBRECSB . Q. RECFM=SV?\n         BNOR  R14                      . A. NO - EXIT\n         TM    DCBBFTEK,DCBBFTA         . Q. BFTEK=A SPECIFIED?\n         BOR   R14                      . A. YES\n         OI    DCBBFTEK,DCBBFTA         . ENABLE BFTEK=A\n         DROP  R4\n         BR    R14                      . EXIT\n         TITLE 'DYNAMIC AREA DSECT'\nDYNAREA  DSECT\n         DS    18F                      . STANDARD OS SAVE AREA\n@ACB     DS    F                        . -> ACB\n@EXLST   DS    F                        . -> EXIT LIST\n@REC     DS    F                        . -> RECORD AREA\n@RPL     DS    F                        . -> RPL\nBSAVE    DS    F                        . REGISTER SAVE\nCASZ     DS    F                        . BYTES PER CA\nCSAVE    DS    F                        . REGISTER SAVE\nDAMDFSCI DS    F                        . FREE SPACE BYTES PER CI\nDAMDCICA DS    H                        . CIS PER CA\nDAMDFSCA DS    H                        . FREE SPACE CIS PER CA\nDCBEXIT  DS    F                        . DCB EXIT ->\nDCB1     DS    XL(LQSAMDCB)             . DYNAMIC DCB FOR QSAM\nDCB2     DS    XL(LSYSDCB)              . DYNAMIC DCB FOR SYSPRINT\n         DS    0F\nDMAL     DS    XL(LOPEN3L)              . DATA MANAGEMENT ADDRESS LIST\nDSAVE    DS    F                        . REGISTER SAVE\nGSAVE    DS    F                        . REGISTER SAVE\nRBA      DS    F                        . RBA WORK AREA\nRECPERCA DS    F                        . RECORDS PER CA\nERR15    DS    F                        . R15 SAVE AREA\nERRFLD   DS    F                        . ACB ERROR / RPL FEED BACK\nSHOWAREA DS    0F                       . SHOWCB AREA\nCINV     DS    F                        . CI SIZE\nENDRBA   DS    F                        . HI-USED RBA\nKEYLEN   DS    F                        . KEY LENGTH\nLRECL    DS    F                        . MAXIMUM RECORD LENGTH\nRKP      DS    F                        . RELATIVE KEY POSITION\nDAMBFLG1 DS    CL1                      . AMB FLAG 1 SAVE\nEOF      DS    CL1                      . QSAM EOF FLAG\nMSGSW    DS    CL1                      . MESSAGE FLAG\nOBJ      DS    CL1                      . OBJECT TYPE FLAG\nOUTLINE  DS    0CL121                   . OUTPUT REPORT LINE\n         DS    CL14\nOUTMSG   DS    CL60                     . MESSAGE AREA\n         DS    CL3\nOUTLRR   DS    CL17                     . LITERAL AREA\nRECOUT   DS    CL10                     . RECORD COUNT\n         DS    CL17\n#RECREAD DS    PL5                      . # RECORDS READ\n#RECWRIT DS    PL5                      . # RECORDS WRITTEN\n#LINE    DS    PL2                      . # LINES ON PAGE\n#PAGE    DS    PL3                      . # PAGES\nDYNLEN   EQU   *-DYNAREA                . LENGTH OF DYNAMIC AREA\n         TITLE 'IBM SUPPLIED DSECTS'\n         DCBD  DEVD=DA,                 . DCB MAPPING                  C\n               DSORG=PS\n         IFGACB                         . ACB MAPPING\nIDAAMB   DSECT                          . AMB MAPPING\n         DS    XL20\nAMBDSB   DS    F\n         DS    XL1\nAMBFLG1  DS    XL1\nAMBSPEED EQU   X'08'\nIDAAMBL  DSECT                          . AMBL MAPPING\n         DS    XL52\nAMBLDTA  DS    F\nIDAAMDSB DSECT                          . AMDSB MAPPING\n         DS    XL12\nAMDCIPCA DS    H\nAMDFSCA  DS    H\nAMDFSCI  DS    F\n         TITLE 'LIST FORM MACROS AND FORM CODE'\nVSAMLOAD CSECT\nOPEN1L   OPEN  (,),                     . OPEN ONE FILE                C\n               MF=L\nLOPEN1L  EQU   *-OPEN1L                 . LENGTH OF DMA LIST\nOPEN3L   OPEN  (,,,,,),                 . OPEN THREE FILES             C\n               MF=L\nLOPEN3L  EQU   *-OPEN3L                 . LENGTH OF DMA LIST\nWTO1L    WTO   'OPEN FAILED FOR VSAM',                                 C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO2L    WTO   'OPEN FAILED FOR QSAM',                                 C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO3L    WTO   'OPEN FAILED FOR SYSPRINT',                             C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO4L    WTO   'RRDS NOT PROCESSED',                                   C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO5L    WTO   'POINT FAILED FOR VSAM',                                C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO6L    WTO   'GET FAILED FOR VSAM',                                  C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO7L    WTO   'PUT FAILED FOR VSAM',                                  C\n               ROUTCDE=11,                                             C\n               MF=L\nQSAMDCB  DCB   DDNAME=QSAM,             . QSAM FORM DCB                C\n               DSORG=PS,                                               C\n               EODAD=F0003,                                            C\n               MACRF=GL\nLQSAMDCB EQU   *-QSAMDCB                . LENGTH OF DCB\nSYSDCB   DCB   BLKSIZE=11374,           . SYSPRINT FORM DCB            C\n               DDNAME=SYSPRINT,                                        C\n               DSORG=PS,                                               C\n               LRECL=121,                                              C\n               MACRF=PM,                                               C\n               RECFM=ABF\nLSYSDCB  EQU   *-SYSDCB\n         TITLE 'EQUATES, CONSTANTS AND LITERAL POOL'\nESDS     EQU   C'E'\nKSDS     EQU   C'K'\nON       EQU   X'01'\nOFF      EQU   X'00'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nMASK5    DC    XL6'402020202120'\nMASK9    DC    XL10'40202020202020202120'\nHEAD1    DC    CL105'1                                          VSAM LOC\n               AD                                                 PAGE'\nPAGEOUT  EQU   *-HEAD1\n         DC    CL16' '\nLOADMSG  DC    CL60'LOAD OPERATION COMPLETED - NUMBER OF RECORDS LOADEDC\n               :'\nRC0MSG   DC    CL60'SECONDARY ALLOCATION OR NEW VOLUME REQUIRED'\n         DC    CL60'DUPLICATE KEY CREATED IN ALTERNATE INDEX'\n         DC    CL60'WRITE BUFFER SUGGESTED'\n         DC    CL60'SEQUENCE SET RECORD CAPACITY PROBLEM - KEYS NOT COMC\n               PRESSING'\n         DC    CL60'RESERVED'\n         DC    CL60'NO BUFFER WRITES PERFORMED'\n         DC    CL60'CONTROL INTERVAL SPLIT INDICATOR DETECTED'\n         DC    CL60'MARK BUFFER INVALID'\nRC4MSG   DC    CL60'RPL ACTIVE FOR ANOTHER REQUEST'\nRC8MSG   DC    CL60'LOGIC ERROR OCCURRED DURING THE PUT OPERATION'\nRC12MSG  DC    CL60'PHYSICAL ERROR OCCURRED DURING THE PUT OPERATION'\nSKIPMSG  DC    CL60'LOAD OPERATION WAS RESTARTED - NUMBER OF RECORDS SKC\n               IPPED:'\nTCMSG    DC    CL60'TEMPORARY CLOSE ISSUED'\n         LTORG\n         END\n\nDave Loveluck\nInstructor/Consultant (USA)                        c Dave Loveluck 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A007A08": {"ttr": 9475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x17\\x00\\x17\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 23, "newlines": 23, "modlines": 0, "user": "VSAMUPD"}, "text": "REUSE and performance\n\nAlthough the REUSE parameter is not directly related to\nperformance, it can be used with performance-related\nparameters when the physical location of a dataset on a DASD\nis to be fixed.\n\nThe BINDDATA command can be used to put the index\ncomponent tracks in cache, when cache controllers are being\nused. There are many occasions when it is necessary to ensure\nthat the physical address of the index component on the DASD\ndoes not change. This can be achieved by using REUSE. The\nadvantage of doing this is that there is no need to delete or\nreallocate that particular cluster in order to reorganize it. When\nthe dataset is REPROed with the REUSE parameter, or when it\nis opened for OUTPUT by a COBOL program, all the old\nrecords are apparently deleted by automatically setting to zero\nthe HURBA (High Used Relative Byte Address) in the catalog.\nThe net effect is that the file appears to be newly allocated\nexcept that the physical location of the index and data\ncomponents on the DASD are exactly the same as before.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A008A00I": {"ttr": 9477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 14, "newlines": 14, "modlines": 0, "user": "VSAMUPD"}, "text": "A008 - VSAM Update issue 8 January 1993\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nA008A01   The right time to reorganize a VSAM KSDS\nA008A02   Performance and tuning experiences\nA008A03   Editing VSAM and long SAM files\nA008A04   Analysing variable length files\nA008A05   Synchronizing catalogs and CRAs\nA008A06   Buffers and performance\nA008A07   IDCAMS EXAMINE\nA008A08   Print records from a VSAM object\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A008A01": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x02\\xe5\\x02\\xe5\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 741, "newlines": 741, "modlines": 0, "user": "VSAMUPD"}, "text": "The right time to reorganize a VSAM KSDS\n\n\nTHE PROBLEM.\n\nAt our company we have a lot of VSAM KSDS files (about\n100), which need to be reorganized at different times. We\nspent a lot of time deciding on which day to reorganize the\ndifferent files. Unfortunately, the batch run, which caused the\nCI and CA splits to the KSDS file, sometimes ran on a\ndifferent day in the week from the day we ran the REORG, or\nthe CICS use of a KSDS file was moved to another day. The\nresult was that we did not reorganize the KSDS files at the\nright time, and wasted a lot of runtime and manpower. We\nwere also spending a lot of time reading output from\nLISTCAT, because we needed to know if a KSDS had more\nthan three data extents or more than two index levels. Finally\nwe had problems with files with no records. After we had\nreorganized a file with no records, we would try to open it for\nupdate in the next CICS run, and we would get an open error.\nWe could not open the file until we had done an init on the file.\nYou may ask why reorganize a file with no records. It is\nbecause we never knew when a file was empty.\n\n\nTHE SOLUTION.\n\nWe wrote a program which would check the following things:\n\n1      Is it a KSDS file?\n2      Are there more than 10 CI splits?\n3      Are there more than 5 CA splits?\n\nIf the answer to 1 is no, don't try to reorganize, RC = 03.\n\nIf the answer to 2 or 3 is yes, then reorganize the file, RC = 00.\n\nIf the answer to 2 or 3 is yes and there are no records in the\nfile, then delete/define and init the file, RC = 02.\n\nIf the answer to 2 or 3 is no, then EOJ, RC = 01.\n\nAfter reloading the data, check the following things:\n\n1      Are there more than 3 data extents.\n2      Are there more than 2 index levels.\n\nIf the answer to 1 and 2 is yes, then display information on the console.\n\nWe use the return code to check whether we have to build an\nAIX for the file.\n\nIt is possible to use a PARM parameter on the EXEC card. For\nexample:\n\no      PARM='O'      - don't reload data\no      PARM='F'      - force REORG\no      PARM='E'      - force only unload of data.\n\nFinally, we made it possible to remove the console messages\nby the UPSI-card (see program comments).\n\n\nTHE RESULT\n\nWe have one reorganize job that runs every day. It checks 100\nKSDS files, and if needed reorganizes them. The last jobstep in\nthe job is listlog. The only thing we have to look at to check\nour KSDS files is the output from listlog.\n\nWe saved a lot of runtime and man-hours. The best result is\nthat we now reorganize ours KSDS files at the right time.\nSavings are shown in Figure 1. The runtime for all the\nLISTCAT runs that get information about the KSDS files is not\nincluded in these figures. An example of the console output is\nshown in Figure 2.\n\n\nHINT AND TIPS\n\nHave only one copy of your VSAM definitions. Ours are kept\nin SLI-books.\n\nThe reason for the large BUFSP in the program is that, for read\nonly, we are able to read an entire CA with a single I/O so long\nas there is enough room in the VSAM buffer for the number of\nCIs per CA plus one CI. (You can use this information to\noptimize some of your other programs.)\n\nRemember the SPEED parameter in your VSAM definitions.\n\n\nSAMPLE JCL\n\n* $$ JOB JNM=ITTREOR,CLASS=0,DISP=H\n// JOB ITTREOR\n// PAUSE   * * *  MOUNT SCRATCH-TAPE ON X'390'  * * *\n// ON $RC > 3 GOTO ERRINFO\n// ASSGN SYS002,390\n* JOBSTEP ITTREOR  ITTEST.TEST\n// DLBL DSKIO,'ITTEST1.TEST',,VSAM,CAT=ITTEST\n// EXEC ITTREOR,SIZE=AUTO\n DELETE      (ITTEST1.TEST) PURGE              -\n             CATALOG(ITTEST.USER.CATALOG)\n DEFINE      CLUSTER                           -\n              (NAME(ITTEST1.TEST)              -\n              VOLUMES(TEST01)                  -\n              SPEED                            -\n              RECSZ(190 190)                   -\n              KEYS(9 0)                        -\n              SHR(2)                           -\n              IXD)                             -\n             DATA                              -\n              (NAME(ITTEST1.TEST.DATA)         -\n              TRK (15  15)                     -\n              CISZ (4096))                     -\n             INDEX                             -\n              (NAME(ITTEST1.TEST.INDEX))       -\n             CATALOG(ITTEST.USER.CATALOG)\n/*\n*\n* JOBSTEP ITTREOR  ITTEST2.TEST\n// DLBL DSKIO,'ITTEST2.TEST',,VSAM,CAT=ITTEST\n// EXEC ITTREOR,SIZE=AUTO\n* $$ SLI MEM=ITTEST2.V\n/*\n// IF $RC > 0 THEN\n// GOTO NITTEST2\n* $$ SLI MEM=ITTEST2A.V         Build alternate index for ITTEST2\n/. NITTEST2\n*\n* JOBSTEP ITTREOR  ITTEST3.TEST\n// DLBL DSKIO,'ITTEST3.TEST',,VSAM,CAT=ITTEST\n// EXEC ITTREOR,SIZE=AUTO\n* $$ SLI MEM=ITTEST3.V\n/*\n*\n// GOTO NORMEOJ\n*\n/. ERRINFO\n* E R R O R     E R R O R     E R R O R     E R R O R\n* CHECK OUTPUT,CORRECT AND RERUN THE JOB\n// PAUSE\n/. NORMEOJ\n// MTC RUN,SYS002\n*\n* JOBSTEP LISTLOG\n// EXEC LISTLOG\n/&\n* $$ EOJ\n\n\nPROGRAM\n\n         PRINT NOGEN\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2                        BASE.\nR3       EQU   3                        BASE.\nR4       EQU   4                        COMREG.\nR5       EQU   5                        BASE FOR RPL DSECT.\nR6       EQU   6                        WORK.\nR7       EQU   7                        BAL.\nR8       EQU   8                        WORK AREA FOR TAPE OUTPUT.\nR9       EQU   9                        REC LENGTH (CONSOLE)\nR10      EQU   10                       1. I/O AREA FOR TAPE.\nR11      EQU   11                       2. I/O AREA FOR TAPE.\nR12      EQU   12                       BASE FOR ACB DSECT.\nR13      EQU   13                       VSAM.\nR14      EQU   14                       VSAM/EXIT.\nR15      EQU   15\nITTREOR  CSECT\n         USING *,R2,R3                  USE R2,R3 AS BASE REG'S.\n         LR    R2,R15                   SET BASE REG FROM ENTRY ADDRESS\n         L     R3,BASER                 LOAD BASE R3\n         B     BEGIN                    SKIP CONSTANT\nBASER    DC    A(ITTREOR+4096)\nBEGIN    EQU   *\n         CR    R1,R15                   WAS A PARM PASSED ?\n         BE    NOPARM\n         L     R6,0(R1)                 LOAD ADDR OF POINTER\n         MVC   PARMTST,2(R6)            MOVE PARM TO PARMTST\nNOPARM   EQU   *\n         COMRG REG=R4                   POINT TO COMREG.\n         LA    R13,R13VSAM0             PUT SAVE AREA ADDR IN R13\n         USING IKQRPL,R5                SET UP BASE FOR VSAM RPL DSECT\n         LA    R5,SRPL10\n         USING IKQACB,R12               SET UP BASE FOR VSAM ACB DSECT\n         LA    R12,SACB1\n         OPEN  SACB1                    OPEN VSAM FILE.\n         LTR   R15,R15                  TEST FOR OPEN ERRORS\n         BNZ   ERRFINO\nOKOPEACB EQU   *\n         TESTCB AM=VSAM,ERET=ERRCLDO,ACB=(12),                         C\n               ATRB=KSDS                IS IT A KSDS FILE ?\n         BNE   NOTKSDS                  NO, GO AND TELL OPERATOR.\n         CLI   PARMTST,C'F'             DO WE WANT TO FORCE A REORG ?\n         BE    OKREOR                   YES, DROP CI/CA TEST.\n         CLI   PARMTST,C'E'             DO WE WANT TO FORCE EMPTY\n*                                       THE FILE ONLY ?\n         BE    OKREOR                   YES, DROP CI/CA TEST.\n         TESTCB AM=VSAM,ERET=ERRCLDO,ACB=(12),                         C\n               NCIS=10                  MORE THAN 10 CI-SPLIT IN FILE ?\n         BH    OKREOR\n         TESTCB AM=VSAM,ERET=ERRCLDO,ACB=(12),                         C\n               NSSS=5                   MORE THAN  5 CA-SPLIT IN FILE ?\n         BH    OKREOR\n         BAL   R7,ENDMSG\n         B     NOREOR\nOKREOR   EQU   *\n         SHOWCB AM=VSAM,ACB=(12),                                      C\n               FIELDS=(NLOGR,LRECL),                                   C\n               AREA=WSHOWCB,LENGTH=8\n         LTR   R15,R15                  TEST FOR SHOWCB ERRORS\n         BNZ   ERRCLDO                  ERROR.\n*\n         SR    R6,R6                    CLEAR R6.\n         LA    R7,2                     NUMBER OF VSAM BUFFERS.\n         M     R6,WLRECL                MULTIPLY NUMBER AND SIZE.\n         LR    R6,R7                    MOVE RESULT TO R6 AND,\n         LA    R7,8                     02 X 4 FOR VAR. LENGTH REC.\n         AR    R6,R7                    ADD 08 BYTES.\n         A     R6,TALENGT1              ADD THE LENGTH OF 2 X TAPE\n         A     R6,TALENGT1              I/O AREA. NOW WE HAVE THE\n*                                       GETVIS SIZE IN R6.\n*\n         GETVIS ADDRESS=STRTVIS,                                       C\n               LENGTH=(6)\n         LTR   R15,R15                  TEST FOR GETVIS ERRORS\n         BNZ   ERRCLDO                  ERROR.\n*\n**********************************************************************\n         L     R6,STRTVIS               LOAD START ADDR TO R6 (WORK).\n         L     R10,STRTVIS              LOAD START ADDR. TO R10 TAPE\n*                                       I/O AREA 1.\n         A     R6,TALENGT1              GET START ADDR FOR TAPE I/O\n*                                       AREA 2 AND\n         LR    R11,R6                   LOAD IT TO R11.\n         A     R6,TALENGT1              GET START ADDR FOR R0BUF1L\n         ST    R6,R0BUF1L               AND STORE IT.\n         AH    R6,VARPRE                GET START ADDR FOR R0BUF1\n         ST    R6,R0BUF1                AND STORE IT.\n         A     R6,WLRECL                GET START ADDR FOR R0BUF2L\n         ST    R6,R0BUF2L               AND STORE IT.\n         AH    R6,VARPRE                GET START ADDR FOR R0BUF2\n         ST    R6,R0BUF2                AND STORE IT.\n*                 MODIFY AREALEN ON A RPL                            *\n         L     R6,WLRECL                LOAD RECL TO R6.\n         MODCB AM=VSAM,RPL=(5),AREALEN=(6)\n         LTR   R15,R15                  TEST FOR MODCB ERRORS\n         BNZ   ERRCLDO                  ERROR.\n         CLC   WNLOGR,=F'0'             0 RECS IN FILE ?\n         BNE   OKREORT                  NO. REORG ON TAPE\n         CLOSE SACB1                    CLOSE VSAM FILE.\n         LTR   R15,R15                  TEST FOR CLOSE ERRORS\n         BNZ   ERRFINO                  ERROR.\n         B     FDELDEF                  GO TO IDCAMS DELETE/DEFINE\nOKREORT  EQU   *\n         TM    23(R4),B'10000000'       TEST UPSI-0\n         BNZ   MSGOP01D                 SET DROP MESSAGE\n         LA    R6,MSGOP01\n         LA    R9,L'MSGOP01-1\n         BAL   R7,PUTMSG0\nMSGOP01D EQU   *\n         OPEN  OUTTAPE\n         ZAP   TOUTRECP,P0              ZERO REC COUNTER FOR OUTPUT.\n         ZAP   TOUTEXP,P0               ZERO EXIT COUNTER FOR OUTPUT.\n         MVI   TSTEX,C'Y'               WE DON'T WANT EXCPAD ON THE 1.\n*                                       READ.\n         BAL   R7,USEBUF2               POINT BUFFER 2 DISK\n         GET   RPL=SRPL10               GET 1 REC 1 TIME\n         LTR   R15,R15                  TEST FOR READ ERRORS\n         BNZ   EOFOUT\n         BAL   R7,USEBUF2L              SAVE REC LENGTH BUF 2\nNXTDSK1I EQU   *\n         MVI   TSTEX,C'N'               NOW WE WANT EXCPAD.\n         BAL   R7,USEBUF1               POINT BUFFER 1 DISK\n         MVC   R0BUFWL,R0BUF2L          POINT BUFFER 2 TAPE\n         GET   RPL=SRPL10               GET 1 REC.\n         LTR   R15,R15                  TEST FOR READ ERRORS\n         BNZ   EOFOUT\n         BAL   R7,USEBUF1L              SAVE REC LENGTH BUF 1\n         CLI   TSTEX,C'Y'               TAPE WRITTEN ?\n         BE    NXTDSK2I                 YES, NEXT READ\n         MVC   R0BUFWL,R0BUF2L          POINT BUFFER 2 TAPE\n         BAL   R7,OTAPE                 NO, GO AND WRITE IT.\nNXTDSK2I EQU   *\n         MVI   TSTEX,C'N'               NOW WE WANT EXCPAD.\n         BAL   R7,USEBUF2               POINT BUFFER 2 DISK\n         MVC   R0BUFWL,R0BUF1L          POINT BUFFER 1 TAPE\n         GET   RPL=SRPL10               GET 1 REC.\n         LTR   R15,R15                  TEST FOR READ ERRORS\n         BNZ   EOFOUT\n         BAL   R7,USEBUF2L              SAVE REC LENGTH. BUF 2\n         CLI   TSTEX,C'Y'               TAPE WRITTEN ?\n         BE    NXTDSK1I                 YES, NEXT READ\n         MVC   R0BUFWL,R0BUF1L          POINT BUFFER 1 TAPE\n         BAL   R7,OTAPE                 NO, GO AND WRITE IT.\n         B     NXTDSK1I                 GO AND READ AGAIN\nEOFOUT   EQU   *\n         CLI   TSTEX,C'Y'               IS TAPE WRITTEN ?\n         BE    ENDPUT\n         BAL   R7,OTAPE\nENDPUT   EQU   *\n         TESTCB AM=VSAM,ERET=ERRCLDTO,RPL=(5),FDBK=4   TEST FOR  E O J\n         BE    EOJOUT\n         B     ERRCLDTO                 ERROR.\nEOJOUT   EQU   *\n         CLOSE OUTTAPE\n         CNTRL OUTTAPE,REW              REWIND OUTPUT TAPE\n         CLOSE SACB1\n         LTR   R15,R15                  TEST FOR CLOSE ERRORS\n         BNZ   ERRFINO                  ERROR.\n         TM    23(R4),B'01000000'       TEST UPSI-1\n         BNZ   MSG001OD                 SET DROP MESSAGE\n         UNPK  TOUTRECD,TOUTRECP\n         OI    TOUTRECD+8,X'F0'\n         MVC   MSG001O+20(9),TOUTRECD\n         LA    R6,MSG001O\n         LA    R9,L'MSG001O-1\n         BAL   R7,PUTMSG0\nMSG001OD EQU   *\n         TM    23(R4),B'00100000'       TEST UPSI-2\n         BNZ   MSG002OD                 SET DROP MESSAGE\n         UNPK  TOUTEXD,TOUTEXP\n         OI    TOUTEXD+8,X'F0'\n         MVC   MSG002O+32(9),TOUTEXD\n         LA    R6,MSG002O\n         LA    R9,L'MSG002O-1\n         BAL   R7,PUTMSG0\nMSG002OD EQU   *\nFDELDEF  EQU   *\n         TM    23(R4),B'10000000'       TEST UPSI-0\n         BNZ   MSGOP03D                 SET DROP MESSAGE\n         LA    R6,MSGOP03               TELL OPERATOR ABOUT IDCAMS,\n         LA    R9,L'MSGOP03-1           DELETE/DEFINE\n         BAL   R7,PUTMSG0\nMSGOP03D EQU   *\n         CDLOAD IDCAMS                  LOAD PH. IN GETVIS R1 => ENTRY\n         LTR   R15,R15                  LOAD SUCCESSFUL ?\n         BZ    LOADOK                   YES - NO ERROR\n         EOJ   RC=(R15)                  NO - END PROGRAM RC IN R15\nLOADOK   EQU   *\n         LA    R15,6(,R1)               R15 = ENTRY POINT PLUS 6\n         CALL  (15),(OPTION,DDNAME,PAGE,IOLIST) R15=ENTRY R1=>PARMLIST\n         LTR   R15,R15                  DELETE / DEFINE OK ?\n         BZ    TAPIN                    YES\n         EOJ   RC=(R15)                 NO - END PROGRAM RC IN R15\nTAPIN    EQU   *\n         CLI   PARMTST,C'O'             DO WE WANT TO EMPTY THE FILE\n         BE    NORMEOJ                  ONLY ?\n         CLI   PARMTST,C'E'             DO WE WANT TO FORCE A EMPTY OF\n         BE    NORMEOJ                  THE FILE ONLY ?\n         MODCB AM=VSAM,ACB=(12),                                       C\n               EXLST=SACBIEX\n         LTR   R15,R15                  TEST FOR MODCB ERRORS\n         BNZ   ERRCLTI                  ERROR.\n         OPEN  SACB1                    OPEN FILE FOR INPUT\n         LTR   R15,R15                  TEST FOR OPEN ERRORS\n         BNZ   ERRCLTI                  ERROR.\nTZEROREC EQU   *\n         CLC   WNLOGR,=F'0'             0 RECS IN FILE ?\n         BE    FILINT                   YES, GO AND INIT FILE.\n*\n*   OOO    BBBB     SSSS                WE HAVE LEARNED BY EXPERIENCE\n*  O   O   B   B   S                    THAT YOU CAN'T ALWAYS RELY ON\n*  O   O   BBBB     SSS                 THE INFORMATION IN NLOGR.\n*  O   O   B   B       S                BECAUSE OF THIS, WE WILL DO\n*   OOO    BBBB    SSSS                 OUR OWN TEST TOO.\n*\n         CP    TOUTRECP,P0              0 RECS ON TAPE ?\n         BE    FILINT                   YES, GO AND INIT FILE.\n         TM    23(R4),B'10000000'       TEST UPSI-0\n         BNZ   MSGOP02D                 SET DROP MESSAGE\n         LA    R6,MSGOP02\n         LA    R9,L'MSGOP02-1\n         BAL   R7,PUTMSG0\nMSGOP02D EQU   *\n         ZAP   TINRECP,P0               ZERO REC COUNTER FOR OUTPUT.\n         ZAP   TINEXP,P0                ZERO EXIT COUNTER FOR OUTPUT.\n         OPEN  INTAPE                   OPEN TAPE FOR INPUT\n         MVC   R0BUFWL,R0BUF1L          POINT BUFFER 1 TAPE\n         BAL   R7,ITAPE\nNXTDSK1O EQU   *\n         CLI   EOFTST,C'Y'              EOF ON TAPE ?\n         BE    EOJIN                    STOP\n         MVI   TSTEX,C'N'               NOW WE WANT EXCPAD.\n         BAL   R7,USEBUF1               POINT BUFFER 1 DISK\n         BAL   R7,LDB1RECL              GET REC LENGTH FROM BUF1\n         MVC   R0BUFWL,R0BUF2L          POINT BUFFER 2 TAPE\n         PUT   RPL=SRPL10               PUT 01 REC.\n         LTR   R15,R15                  TEST FOR WRITE ERRORS\n         BNZ   ERRCLDTI                 ERROR UNDER INPUT\n         AP    TINRECP,P1               ADD 01 TO REC COUNTER INPUT\n         CLI   TSTEX,C'Y'               TAPE READ ?\n         BE    NXTDSK2O                 YES, NEXT WRITE\n         BAL   R7,ITAPE                 NO, GO AND READ IT.\nNXTDSK2O EQU   *\n         CLI   EOFTST,C'Y'              EOF ON TAPE ?\n         BE    EOJIN                    STOP\n         MVI   TSTEX,C'N'               NOW WE WANT EXCPAD.\n         BAL   R7,USEBUF2               POINT BUFFER 2 DISK\n         BAL   R7,LDB2RECL              GET REC LENGTH FROM BUF2\n         MVC   R0BUFWL,R0BUF1L          POINT BUFFER 1 TAPE\n         PUT   RPL=SRPL10               PUT 01 REC.\n         LTR   R15,R15                  TEST FOR WRITE ERRORS\n         BNZ   ERRCLDTI                 ERROR UNDER INPUT\n         AP    TINRECP,P1               ADD 01 TO REC COUNTER INPUT\n         CLI   TSTEX,C'Y'               TAPE READ ?\n         BE    NXTDSK1O                 YES, NEXT WRITE.\n         BAL   R7,ITAPE                 NO, GO AND READ IT.\n         B     NXTDSK1O                 GO AND WRITE AGAIN.\nEOJIN    EQU   *\n         BAL   R7,ENDMSG\n         CLOSE SACB1\n         LTR   R15,R15                  TEST FOR CLOSE ERRORS\n         BNZ   ERRFINI                  ERROR.\n         TM    23(R4),B'01000000'       TEST UPSI-1\n         BNZ   MSG001ID                 SET DROP MESSAGE\n         UNPK  TINRECD,TINRECP\n         OI    TINRECD+8,X'F0'\n         MVC   MSG001I+19(9),TINRECD\n         LA    R6,MSG001I\n         LA    R9,L'MSG001I-1\n         BAL   R7,PUTMSG0\nMSG001ID EQU   *\n         TM    23(R4),B'00100000'       TEST UPSI-2\n         BNZ   MSG002ID                 SET DROP MESSAGE\n         UNPK  TINEXD,TINEXP\n         OI    TINEXD+8,X'F0'\n         MVC   MSG002I+31(9),TINEXD\n         LA    R6,MSG002I\n         LA    R9,L'MSG002I-1\n         BAL   R7,PUTMSG0\nMSG002ID EQU   *\nNORMEOJ  EOJ                            NORMAL  E O J\nERRCLDO  EQU   *\n         CLOSE SACB1\n         B     ERRFINO\nERRCLTO  EQU   *\n         CLOSE OUTTAPE\n         B     ERRFINO\nERRCLDTO EQU   *\n         CLOSE SACB1\n         CLOSE OUTTAPE\n         B     ERRFINO\nERRFINO  EQU   *\n         CNTRL OUTTAPE,REW               REWIND OUTPUT TAPE\n         LA    R15,9\n         EOJ   RC=(R15)\nERRCLDI  EQU   *\n         CLOSE SACB1\n         B     ERRFINI\nERRCLTI  EQU   *\n         CLOSE INTAPE\n         B     ERRFINI\nERRCLDTI EQU   *\n         CLOSE SACB1\n         CLOSE INTAPE\n         B     ERRFINI\nERRFINI  EQU   *\n         CNTRL INTAPE,REW               REWIND INPUT TAPE\n         LA    R15,10\n         EOJ   RC=(R15)\nFILINT   EQU   *\n         LA    R6,MSGOP04\n         LA    R9,L'MSGOP04-1\n         BAL   R7,PUTMSG0\n         L     R7,R0BUF1                LOAD ADDR ON RECORD FIELD\n         L     R6,WLRECL                LOAD LENGTH ON RECORD FIELD\n         BCTR  R6,0\n         EX    R6,INTREC                MAKE A LOW-VALUE RECORD.\n         L     R0,WLRECL                LOAD LENGTH ON RECORD\n         LA    R1,SRPL10\n         MODCB AM=VSAM,RPL=(1),RECLEN=(0)\n         LTR   R15,R15                  TEST FOR MODCB ERRORS\n         BNZ   ERRFINI                  ERROR.\n         BAL   R7,USEBUF1               POINT BUFFER 1 DISK\n         MVI   TSTEX,C'Y'               WE DON'T WANT EXCPAD.\n         PUT   RPL=SRPL10               PUT DUMMY REC.\n         LTR   R15,R15                  TEST FOR WRITE ERRORS\n         BNZ   ERRCLDI                  ERROR UNDER INIT.\n         CLOSE SACB1\n         LTR   R15,R15                  TEST FOR CLOSE ERRORS\n         BNZ   ERRFINI                  ERROR.\n         OPEN  SACB1\n         LTR   R15,R15                  TEST FOR OPEN ERRORS\n         BNZ   ERRFINI                  ERROR.\n         MODCB AM=VSAM,RPL=(5),                                        C\n               OPTCD=(KEY,SEQ,UPD,MVE)\n         LTR   R15,R15                  TEST FOR MODCB ERRORS\n         BNZ   ERRCLDI                  ERROR.\n         GET   RPL=SRPL10               GET DUMMY RECORD.\n         LTR   R15,R15                  TEST FOR GET ERROR.\n         BNZ   ERRCLDI                  ERROR.\n         ERASE RPL=SRPL10               DELETE DUMMY RECORD.\n         LTR   R15,R15                  TEST FOR DELETE ERROR.\n         BNZ   ERRCLDI                  ERROR.\n         CLOSE SACB1\n         LTR   R15,R15                  TEST FOR CLOSE ERRORS\n         BNZ   ERRFINI                  ERROR.\n         LA    R15,2                    TELL BY RETURN CODE, ABOUT\n         EOJ   RC=(R15)                 INIT OF VSAM FILE.\nINTREC   XC    0(0,R7),0(R7)\nENDMSG   EQU   *\n         ST    R7,SAVBALR7              SAVE R7\n         TESTCB AM=VSAM,ERET=ERRFINI,ACB=(12),OBJECT=DATA,             C\n               NEXT=3                   MORE THAN 3 EXTENTS FOR DATA ?\n         BNH   TSTINDXE\n         LA    R6,MSGOP06\n         LA    R9,L'MSGOP06-1\n         BAL   R7,PUTMSG0\nTSTINDXE EQU   *\n         TESTCB AM=VSAM,ERET=ERRFINI,ACB=(12),OBJECT=INDEX,            C\n               NEXT=2                   MORE THAN 2 EXTENTS FOR INDEX ?\n         BNH   TSTINDXL\n         LA    R6,MSGOP07\n         LA    R9,L'MSGOP07-1\n         BAL   R7,PUTMSG0\nTSTINDXL EQU   *\n         TESTCB AM=VSAM,ERET=ERRFINI,ACB=(12),OBJECT=INDEX,            C\n               NIXL=2                   MORE THAN 2 LEVELS IN INDEX ?\n         BNH   OKEXTENT\n         LA    R6,MSGOP08\n         LA    R9,L'MSGOP08-1\n         BAL   R7,PUTMSG0\nOKEXTENT EQU   *\n         L     R7,SAVBALR7              RESTORE R7\n         BR    R7                       GO BACK\nNOTKSDS  EQU   *\n         LA    R6,MSGOP05\n         LA    R9,L'MSGOP05-1\n         BAL   R7,PUTMSG0\n         BAL   R7,EMPTYIPT\n         CLOSE SACB1                    CLOSE VSAM FILE\n         LA    R15,3                    TELL BY RETURN CODE, ABOUT\n         EOJ   RC=(R15)                 NO KSDS VSAM FILE.\nNOREOR   EQU   *\n         BAL   R7,EMPTYIPT\n         CLOSE SACB1\n         LA    R15,1                    TELL BY RETURN CODE, ABOUT\n         EOJ   RC=(R15)                 NO REORG OF VSAM FILE.\nEMPTYIPT EQU   *\n         OPEN  SYSIPT                   OPEN SYSIPT\nGETIPT   GET   SYSIPT                   EMPTY SYSIPT\n         B     GETIPT\nCLOSEIPT CLOSE SYSIPT                   CLOSE SYSIPT\n         BR    R7                       GO BACK\nOTAPE    EQU   *\n         L     R8,R0BUFWL               GET 1 REC FROM BUFFER AND\n         PUT   OUTTAPE,(8)              PUT IT TO TAPE.\n         AP    TOUTRECP,P1              ADD 01 TO REC COUNTER OUTPUT\n         BR    R7                       GO BACK\nITAPE    EQU   *\n         L     R8,R0BUFWL               GET 1. REC FROM TAPE AND\n         GET   INTAPE,(8)               PUT IT TO BUFFER.\n         BR    R7                       GO BACK\n*                 MODIFY AREA ON A RPL                               *\nUSEBUF1  EQU   *\n         MVC   R0BUFW,R0BUF1            NOW WE USE BUFFER 1.\n         B     USEBUF\nUSEBUF2  EQU   *\n         MVC   R0BUFW,R0BUF2            NOW WE USE BUFFER 2.\nUSEBUF   EQU   *\n         L     R6,R0BUFW                LOAD ADDR FOR AREA FIELD\n         MODCB AM=VSAM,RPL=(5),AREA=(6)\n         LTR   R15,R15                  TEST FOR MODCB ERRORS\n         BNZ   ERRCLDI                  ERROR.\n         BR    R7                       GO BACK\n*                 SAVE RECORD LENGTH FROM RPL                        *\nUSEBUF1L EQU   *\n         MVC   R0BUFWL,R0BUF1L\n         B     USEBUFL\nUSEBUF2L EQU   *\n         MVC   R0BUFWL,R0BUF2L\nUSEBUFL  EQU   *\n         LA    R1,SRPL10\n         SHOWCB AM=VSAM,RPL=(1),RECLEN=(0)\n         LTR   R15,R15                  TEST FOR SHOWCB ERRORS\n         BNZ   ERRCLDTO                 ERROR.\n         AH    R0,VARPRE                ADD 4 BYTES FOR LENGTH FIELD\n         L     R6,R0BUFWL               LOAD ADDR FOR AREALEN FIELD\n         STH   R0,0(R6)                 SAVE NEW REC LENGTH\n         XC    2(2,R6),2(R6)            CLEAR RESERVED BYTES\n         BR    R7                       GO BACK\n*    GET RECORD LENGTH FROM BUFFER X FOR INPUT RPL                  *\nLDB1RECL EQU   *\n         MVC   R0BUFWL,R0BUF1L\n         B     LDBRECL\nLDB2RECL EQU   *\n         MVC   R0BUFWL,R0BUF2L\nLDBRECL  EQU   *\n         L     R6,R0BUFWL               LOAD ADDR FOR REC LENGTH\n         SR    R0,R0                    CLEAR R0.\n         LH    R0,0(,R6)                LOAD VALUE FOR REC LENGTH\n         SH    R0,VARPRE                SUBTRACT 4 BYTES FOR LENGTH\n*                                       FIELD.\n         LA    R1,SRPL10\n         MODCB AM=VSAM,RPL=(1),RECLEN=(0)\n         LTR   R15,R15                  TEST FOR MODCB ERRORS\n         BNZ   ERRCLDTI                 ERROR.\n         BR    R7                       GO BACK\n*                 E O F  F O R  I N P U T  T A P E                   *\nEOFIN    EQU   *\n         MVI   TSTEX,C'Y'               NOW WE DON'T WANT EXCPAD.\n         CLOSE INTAPE\n         CNTRL INTAPE,REW               REWIND INPUT TAPE\n         MVI   EOFTST,C'Y'              NOW WE HAVE EOF ON INPUT TAPE\n         BR    R7                       GO BACK\n*                 MESSAGE                                            *\nPUTMSG0  EQU   *\n         TM    23(R4),B'00000001'       TEST UPSI-7\n         BNZR  R7                       SET DROP MESSAGE\n         EX    R9,PUTMSGEX\n         LA    R9,10(,R9)               ADD 1 AND 9 TO R9.\n         PUT   MESSAG0                  TELL OPERATOR.\n         BR    R7\nPUTMSGEX MVC   MSGOUT02(0),0(R6)        MOVE MESSAGE TO OUTPUT\n*                 START EXIT EXCPAD. ( OUTPUT )                      *\nEXTAPOUT DS    0H\n         CLI   TSTEX,C'Y'               IS IT FIRST TIME ?\n         BE    NOEXITO                  NO, TAPE IS ALREADY WRITTEN.\n         STM   R1,R0,R1TR0SAV           SAVE REGS FOR MAIN PROGRAM.\n         AP    TOUTEXP,P1               ADD 1 TO EXIT COUNTER.\n         BAL   R7,OTAPE                 YES, GO AND WRITE TAPE.\n         MVI   TSTEX,C'Y'               TELL THAT WE HAVE BEEN HERE.\n         LM    R1,R0,R1TR0SAV           LOAD REGS FOR MAIN PROGRAM.\nNOEXITO  BR    R14                      RETURN TO MAIN PROGRAM.\n*                 START EXIT EXCPAD. ( INPUT )                       *\nEXTAPIN  DS    0H\n         CLI   TSTEX,C'Y'               IS IT FIRST TIME ?\n         BE    NOEXITI                  NO, TAPE IS ALREADY READ.\n         STM   R1,R0,R1TR0SAV           SAVE REGS FOR MAIN PROGRAM.\n         AP    TINEXP,P1                ADD 1 TO EXIT COUNTER.\n         BAL   R7,ITAPE                 YES, GO AND READ TAPE.\n         MVI   TSTEX,C'Y'               TELL THAT WE HAVE BEEN HERE.\n         LM    R1,R0,R1TR0SAV           LOAD REGS FOR MAIN PROGRAM.\nNOEXITI  BR    R14                      RETURN TO MAIN PROGRAM.\n*                  END  EXIT EXCPAD.                                 *\nSACB1    ACB   AM=VSAM,DDNAME=DSKIO,                                   C\n               BUFSP=655360,                                           C\n               EXLST=SACBOEX,                                          C\n               MACRF=(KEY,SEQ,OUT)\nSRPL10   RPL   AM=VSAM,ACB=SACB1,                                      C\n               RECLEN=VRECL0,                                          C\n               OPTCD=(KEY,SEQ,NUP,MVE)\nSACBOEX  EXLST EXCPAD=(EXTAPOUT,A)\nSACBIEX  EXLST EXCPAD=(EXTAPIN,A)\nOUTTAPE  DTFMT BLKSIZE=32767,                                          C\n               DEVADDR=SYS002,                                         C\n               ERROPT=ERRCLDTO,                                        C\n               ERREXT=YES,                                             C\n               FILABL=NO,                                              C\n               IOAREA1=(10),                                           C\n               IOAREA2=(11),                                           C\n               WORKA=YES,                                              C\n               RECFORM=VARBLK,                                         C\n               REWIND=NORWD,                                           C\n               TYPEFLE=OUTPUT\nINTAPE   DTFMT BLKSIZE=32767,                                          C\n               DEVADDR=SYS002,                                         C\n               ERROPT=ERRCLDTI,                                        C\n               EOFADDR=EOFIN,                                          C\n               ERREXT=YES,                                             C\n               FILABL=NO,                                              C\n               IOAREA1=(10),                                           C\n               IOAREA2=(11),                                           C\n               WORKA=YES,                                              C\n               RECFORM=VARBLK,                                         C\n               REWIND=NORWD,                                           C\n               TYPEFLE=INPUT\nMESSAG0  DTFCN DEVADDR=SYSLOG,                                         C\n               IOAREA1=MSGOUT0,                                        C\n               BLKSIZE=65,                                             C\n               RECFORM=UNDEF,                                          C\n               RECSIZE=(9),                                            C\n               TYPEFLE=OUTPUT\nSYSIPT   DTFCD DEVADDR=SYSIPT,                                         C\n               EOFADDR=CLOSEIPT,                                       C\n               IOAREA1=CARDIN,                                         C\n               BLKSIZE=80\nR13VSAM0 DS    18F                      SAVEAREA MAINLINE VSAM\nR1TR0SAV DS    16F                      SAVEAREA REGS IN EXCPAD\nSAVBALR7 DS    F                        SAVEAREA FOR R7 IN A DOUBLE BAL\nR0BUF1L  DS    F\nR0BUF1   DS    F\nR0BUF2L  DS    F\nR0BUF2   DS    F\nR0BUFWL  DS    F\nR0BUFW   DS    F\nSTRTVIS  DS    F                        START ADDR. OF GETVIS.\nWSHOWCB  DS    0F                       ONE REF. TO ALL SHOWCB FIELDS\nWNLOGR   DS    F                        ... 1. SHOWCB FIELD,\nWLRECL   DS    F                        ... 2. SHOWCB FIELD.\nTALENGT1 DC    F'32767'                 1 X TAPE IOAREA LENGTH.\nVRECL0   DS    F\nIOLIST   DC    F'0'                     IDCAMS PARM\nOPTION   DC    H'0'                     IDCAMS PARM\nDDNAME   DC    H'0'                     IDCAMS PARM\nPAGE     DC    H'0'                     IDCAMS PARM\nVARPRE   DC    H'4'                     VAR RECORD LENGTH PREFIX.\nMSGOUT0  DS    0CL65\nMSGOUT01 DC    CL7'ITTREOR'\nMSGOUTB  DC    CL2'  '\nMSGOUT02 DS    CL56\nMSG001O  DC    C'TOTAL RECORD''S OUT  XXXXXXXXX'\nMSG002O  DC    C'NUMBER OF TIME''S IN OUTPUT EXIT XXXXXXXXX'\nMSG001I  DC    C'TOTAL RECORD''S IN  XXXXXXXXX'\nMSG002I  DC    C'NUMBER OF TIME''S IN INPUT EXIT XXXXXXXXX'\nMSGOP01  DC    C'COPY FROM DISK TO TAPE'\nMSGOP02  DC    C'COPY FROM TAPE TO DISK'\nMSGOP03  DC    C'DELETE/DEFINE VSAM FILE'\nMSGOP04  DC    C'INIT VSAM FILE'\nMSGOP05  DC    C'DON''T TRY TO REORG A NON KSDS FILE'\nMSGOP06  DC    C'MORE THAN 3 EXTENTS FOR DATA'\nMSGOP07  DC    C'MORE THAN 2 EXTENTS FOR INDEX'\nMSGOP08  DC    C'MORE THAN 3 LEVELS FOR INDEX'\nTOUTEXD  DS    CL9                      REC COUNTER FOR OUTPUT EXIT.\nTOUTEXP  DS    PL5                      REC COUNTER FOR OUTPUT EXIT.\nTOUTRECD DS    CL9                      REC COUNTER FOR OUTPUT.\nTOUTRECP DS    PL5                      REC COUNTER FOR OUTPUT.\nTINEXD   DS    CL9                      REC COUNTER FOR INPUT EXIT.\nTINEXP   DS    PL5                      REC COUNTER FOR INPUT EXIT.\nTINRECD  DS    CL9                      REC COUNTER FOR INPUT.\nTINRECP  DS    PL5                      REC COUNTER FOR INPUT.\nP0       DC    PL1'0'\nP1       DC    PL1'1'\nPARMTST  DC    CL1' '              SAVE AREA FOR PARM FROM EXEC CARD\nEOFTST   DC    CL1'N'                   EOF TEST FOR INPUT.\nTSTEX    DS    CL1\nCARDIN   DS    CL80                     SYSIPT BUFFER\n         LTORG\n         IKQACB                         VSAM ACB DSECT\n         IKQRPL                         VSAM RPL DSECT\n         END\n\n\nIvan Tullberg\nSystems Programmer (Denmark)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A008A02": {"ttr": 9734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01S\\x01S\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 339, "newlines": 339, "modlines": 0, "user": "VSAMUPD"}, "text": "Performance and tuning experiences\n\n\nAPPLICATION OVERVIEW\n\nThe application under consideration is based on Dun &\nBradstreet's Millennium General Ledger Version 3. This\napplication runs on a 3090 500E under MVS/XA, and requires\n27GB of DASD space of which around 60% is occupied by\nVSAM files. At peak times, this application can require up to\n17 CPU-hours per day with over 5 million I/Os. Average usage\nper day in any month is currently around 7 CPU-hours with 2.5\nmillion I/Os.\n\n\nPERFORMANCE MANAGEMENT\n\nThe principal aim of performance management is to give the\nbest possible service to the customer. Performance\nmanagement establishes a framework within which you can\nlearn about and tune your application to deliver results as\nefficiently as possible.\n\nDuring an application's development phase, attention is\ngenerally focused on getting that application up and running.\nOnce it has been delivered into the production environment,\ndata and usage begin to grow, and the first signs that\nexpectations are not fully being met begin to appear. The\ncustomer may begin to raise concerns about aspects of the\napplication such as the service cost, the batch work elapsed\ntimes, the interactive response times, and so on. In order to\nminimize such concerns, a performance management strategy\nis needed which will enable them to be viewed objectively and\nhelp to identify areas where improvements can be made. This\nstrategy should also allow for these improvements to be\nmeasured. Having good performance management does not\nonly mean that the customer gets the best service possible, it\ncan also mean that the Data Centre machine resource is being\nused efficiently. This can avoid, or at least defer, the need to\nundertake costly upgrades.\n\nThere are four basic elements within performance management:\no      Monitor\no      Analysis\no      Action\no      Review.\n\nPerformance monitoring\n\nThe first stage in the management of an application's\nperformance is to measure what is happening. A number of\ntools can be used to measure and obtain performance statistics,\nand some of these are discussed below. The batch and\ninteractive measures consider the time and cost aspects of\ntransaction processing. The file measures consider the efficient\nuse of storage space, which can have an impact on both batch\nand interactive performance.\n\nAlthough other measures, such as network traffic across each\ncontroller, can also be beneficial, consideration of these\nmeasures is beyond the scope of this article.\n\nAttributes of batch and interactive work are collected by\nvarious system utilities, and their results can be found in a\nnumber of locations.\n\nJCL system messages provide a detailed analysis of each job.\nThis output can be used to assess the performance\ncharacteristics of each step of a batch job.\n\nProprietary facilities, such as Dun & Bradstreet's Multiple\nShared Resources management facility (MSR), which allows\nimprovements to VSAM I/O performance in batch programs\nusing Millennium I/O service modules, produces reports which\ncan assist in the performance assessment of a batch job.\n\nService Level Reporter (SLR) or SAS can be used to report on\npertinent details of interactive and batch work held in SMF,\nRMF, or SAS files. These reports should concentrate on CPU\ntime, I/O, elapsed time, and cost. Omegamon allows\nmonitoring of individual users in the interactive CICS\nenvironment and can be used to measure in detail the actions of\nparticularly high-spending users. This data can then be\nexamined to identify particularly expensive individual\ntransactions.\n\nLISTCATs or File-AID can be used to determine the condition\nof files (number of extents, CI/CA splits etc). The placement of\nfiles on each volume and the spare capacity on each disk can\nalso be monitored using File-AID.\n\nIn order to make performance monitoring an essentially clerical\nactivity, OPC/A has been used to schedule a number of daily\nand monthly reports. These reports are then examined by\nclerical staff who look for pre-defined characteristics. The\nreports themselves are generated by SAS. The daily reports\nprovide details of:\n\no      The previous day's batch work, including, for the General\n      Ledger application only, the job name, JES number, CPU\n      seconds, I/Os, elapsed minutes, and cost.\n\no      The previous day's use by each individual user, including,\n      for the General Ledger application only, their CPU and I/O\n      measures in CICS, TSO, and batch. A summary of each\n      cost centre using the application over the 24 hour period is\n      also included.\n\no      The previous day's use by each CICS transaction per hour,\n      including, for the General Ledger application only, the\n      number of tasks in each hour, the maximum and average\n      CPU time, response time, and I/O. A summary of usage by\n      CICS transactions over the 24 hour period is also included.\n\nAdditionally, Omegamon is used to report daily on CICS tasks\nthat use more than a specified amount of CPU usage.\n\nThe monthly reports provide details of each individual user, for\nthe General Ledger application only, and their spend in CICS,\nTSO, and batch. A summary of each cost centre using the\napplication over the period is also included.\n\nMeasurement analysis\n\nThe daily reports described above can be used to identify which\nbatch jobs are candidates for further examination. Initially, jobs\nexhibiting high resource usage or high cost should be targeted\nfor examination and possible tuning. Later, jobs with a high\nelapsed time should be targeted. Consideration should also be\ngiven to the frequency with which each job is run.\n\nThe analysis of the batch output JCL system messages can give\nguidance about the allocation of buffers for each dataset. This\ncan vary depending on how the program accesses the data.\n\nUsing the daily Omegamon report, 'expensive' CICS tasks can\nbe identified and reviewed to ensure that they are written in the\nmost efficient manner possible.\n\nLISTCATs or File-AID can be used periodically to identify file\ngrowth, splits, and other statistics. Measures can then be taken\nto reduce splits and keep data within the files' primary extents.\nRegular file reorganizations should be performed to assist this.\n\nFile-AID can be used to measure the free space on each volume\nto ensure that a sufficient allowance is available for anticipated\ndataset growth. The placement of datasets across the disk packs\ncan also be monitored. By monitoring the frequency of access\non each volume and dataset, possible file contention issues can\nbe detected.\n\nPerformance actions\n\nUsing the formulae given below, you can develop tabulations\nwhich give guidance on the allocation of buffers to VSAM\nfiles. Consideration must be given to the mode of access\n(sequential or random) each program employs to each dataset,\nbecause this can affect the choice of buffers. Allocating too\nmany buffers can lead to inefficiency caused by unnecessary\nbuffer management by the operating system, but this\ninefficiency is small in relation to that resulting from no\nbuffering at all.\n\nWhen using proprietary products such as those mentioned\nearlier, consideration must also be given to any guidelines\nprovided by the product supplier.\n\nIn addition to buffers, programs can also be examined for\ninefficiencies within their coding. Any found should be\nrectified.\n\nConsider what data is needed to meet a particular requirement;\nit may be beneficial to develop subsets of that data which will\nsatisfy the majority of jobs or tasks and occupy a smaller\nvolume.\n\nUnnecessary data should be archived or deleted. This results in\na smaller file, and can consequently improve performance and\nstorage problems.\n\nA periodic review of all the files should be undertaken to\nensure that they occupy their primary allocation of space.\nThose found not to do so should be redefined with sufficient\nprimary space.\n\nRegular file reorganizations should be run to reduce splits.\nReview file definitions in line with recommendations, and\namend as necessary. Set CI sizes to those recommended by the\npackage supplier, subject to your Data Centre constraints.\n\nYou should conduct periodic reviews of the spread of files\nacross the disks to ensure that file contention is minimized.\n\nFor VSAM datasets, it can be beneficial to use the IMBED\nparameter for KSDS files not on cached disks. Also consider\nusing the REPLICATE parameter on files used in the CICS\nsystem.\n\nFor sequential datasets, the use of correct blocking factors will\nresult in less DASD space being needed to store the same\nnumber of records in a dataset, and reduced batch processing\ntime because fewer blocks may need to be read or written.\n\nCalculations of VSAM buffer requirements\n\nIn order to calculate the VSAM buffer requirements for each\nVSAM file, use LISTCAT or another utility to determine the\nDATA CISIZE, INDEX CISIZE, DATA CIs per CA, TRKS\nper CA, INDEX REC-TOTAL and DATA HI-USED-RBA.\n\nThen, using these values, calculate the number of data and\nindex buffers required by each file for sequential and random\naccess using the formulae below.\n\nEstablish the datasets accessed and the method (sequential or\nrandom) used by each program in the application.\n\nThe buffers required can then be allocated to each dataset\naccording to the program access method established in the\nprogram/dataset cross reference tables.\n\nThe formulae you will need are as follows. For VSAM\nsequential access batch processing, the optimal number of\nindex buffers is 1, and the maximum data buffers is ((2 *\nDATA CI per TRK) + 3), where:\n\no      2 provides for the alternate buffer support.\n\no      'DATA CI per TRK' determines the number of buffers that\n      will provide for full track I/O.\n\no      3 provides the extra requirement to allow for VSAM\n      internal processing and for circumstances where CIs span\n      across tracks.\n\nFor VSAM random access batch processing, the optimal\nnumber of data buffers is 2, and the maximum index buffers is\n(1 + number of index dataset records), where:\n\no      1 allows for the single sequence set record in storage at any\n      one time.\n\no      Number of index dataset records = (INDEX REC-TOTAL\n      - number of sequence set records).\n\n      -      INDEX REC-TOTAL is the total number of index\n            records as shown by the TOTAL-RECORDS field in\n            the STATISTICS paragraph of the INDEX component\n            LISTCAT output.\n\n      -      number of sequence set records = (DATA HI-USED-\n            RBA/(DATA CISIZE * DATA CI/CA)).\n\n      -      DATA HI-USED RBA is the high-used RBA as shown\n            by the HIGH-USED-RBA field in the ALLOCATION\n            paragraph of the DATA component LISTCAT output.\n\n      -      DATA CISIZE is from the CISIZE field and DATA\n            CI/CA is from the CI/CA field in the ATTRIBUTES\n            paragraph of the DATA component LISTCAT output.\n\nExample tabulations\n\nSome example tabulations for tuning VSAM datasets are\nshown in Figures 1, 2, and 3.\n\nThe Figures and formulae give a first cut for tuning VSAM\ndatasets. The buffer allocations can be refined with reference to\nthe job statistics.\n\nPerformance review\n\nIt is important, wherever possible, to assess the likely impact\nof any change on the application. When applying new or\nchanged parameters, it may be worthwhile running the job or\ntask before and after the change and comparing the results.\nThis enables you to quantify the results of any actions, and use\nthe knowledge you gain to determine the value of progressing\nfurther with a particular course of action.\n\n\nINNOVATION ACCESS METHOD\n\nHaving tuned our VSAM-based application and obtained some\nimpressive results, our Technical Support section suggested we\ntry Innovation Data Processing's Innovation Access Method\n(IAM), which had been acquired initially for their internal use.\n\nThe IAM product documentation claims that IAM offers an\nalternative to using VSAM single index key sequential\ndatasets, providing advanced file structure, data compression,\nand automatic space release, and superiority over VSAM\nKSDS or ISAM processing for CICS and batch use; and IAM\nrequires no change to JCL, application programs or a CICS\nsystem.\n\nIf these claims were confirmed, using this product would\nreduce our file store requirement and, with less volume of data\nto back up, would decrease our back-up and job elapsed times,\nthus allowing more jobs to process in each job stream.\n\nA number of proving tests were devised, first to ensure that\nIAM would run in a Millennium environment, and second to\nmeasure the potential benefits of using IAM instead of, or\nalongside, VSAM.\n\nAfter examining the statistics collected, the claims made in the\nIAM documentation were compared with our findings:\n\no      IAM claims to cut terminal response and internal CICS\n      response times by 30% to 60%. We observed that the\n      CICS response times for IAM were 25% to 62% less than\n      those for the same CICS task performed on VSAM\n      datasets.\n\no      IAM claims to slash disk I/O by 50% to 90%. We\n      observed a decrease of 26% to 70% in file I/O, and a\n      decrease of 21% to 70% in job elapsed time when using\n      IAM compared with the same batch suite performed on\n      VSAM datasets.\n\no      IAM claims to take 20% to 40% less disk space than\n      VSAM. With IAM data compression, a further 20% to\n      50% reduction can be achieved. We achieved a reduction\n      of 34% to 78% in the space required by the IAM files\n      compared to that required by VSAM for the same data.\n      The overall saving across the files selected was about 70%.\n\no      IAM claims to require no changes to JCL, application\n      programs, or a CICS system. In practice, we found that we\n      had to recompile our 3GL programs without the MSR\n      buffer allocation function. We also had to switch off CICS\n      Local Shared Resource from those files converted to IAM.\n      These were relatively minor modifications, and, in general,\n      we found no problems running with IAM files.\n\nSteve Davies\nBritish Nuclear Fuels Ltd (UK)                  c BNFL 1993\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A008A03": {"ttr": 9985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\xb7\\x01\\xb7\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 439, "newlines": 439, "modlines": 0, "user": "VSAMUPD"}, "text": "Editing VSAM and long SAM files\n\nThe 'editing by wrap around' program enables us to edit PS\nand VSAM ESDS and KSDS datasets of any record length. If\nthe length of the record is greater than 9 and less than 256, the\nuser can select whether he wants to edit the record as a single\nline record or a wrapped record. The program is short and\ncontains some comments, so I will not describe it in detail.\n\nHowever, one deficiency in the program is that when editing\nKSDS, if you want to add a new record to the file, you must\ninsert the record in the key sequence. The program can be\nenhanced by adding a step to call DFSORT to sort the\nintermediate file before REPROing to the new KSDS.\n\nAnother problem occurs when using the program to edit VSAM\nfiles. In the EDBEEBOO program, when editing a VSAM file\nusing single line record format (ie without wrapping), the\nVSAM file is copied into a variable length file before editing\nand copied back to VSAM after editing. During the editing,\nusing the ISPF editor, all the trailing blanks are converted to\nnull characters. If the last field of the original file contains\nsome trailing blanks or allows blanks as valid values, it will be\ntruncated. When the VSAM file is used with COBOL\nprograms, errors can occur. I solve the problem by REPROing\nthe VSAM file into a fixed length file by amending the\nstatement at line 39. I change\n\n      IF ALLOCNEW(OFILE,DDOF,ULRECL,'V') = 0 THEN DO\n\nto\n\n      IF ALLOCNEW(OFILE,DDOF,ULRECL,'F') = 0 THEN DO\n\nHowever, all the records in the VSAM file after editing will be\nthe same length.\n\n\nEDBEEBOO EXEC\n\n/* REXX */\n/* TRACE ?R */\nARG IFILE TR\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISPEXEC \"VGET (ZUSER) SHARED\"\nWPLN = 50\nOPT    = 1\nIFILE = TRANSLATE(IFILE)\nIF LENGTH(IFILE) = 0 THEN DO\n  CUR    = \"CURSOR(DDD)\"\n  DDD    = \"\"\n  MSG    = \"\"\n  ADDRESS ISPEXEC \"DISPLAY PANEL(EDBEEB$P) \"MSG CUR\n  IF  RC > 8 THEN  SAY \"BEEBOO : DISPLAY PANEL FAILED\"\nEND\nIF LENGTH(IFILE) = 0 THEN DO\n  RETURN 8\nEND\nUNAME = TIME('S')\nTFILE = ZUSER\".SDBEEBOO.TFT\"UNAME\".TEMP\"\nVFILE = ZUSER\".VSBEEBOO.VFT\"UNAME\".TEMP\"\nOFILE = ZUSER\".SDBEEBOO.OFT\"UNAME\".TEMP\"\nDDIF = 'BEEBOOIF'\nDDTF = 'BEEBOOTF'\nDDOF = 'BEEBOOOF'\nIF ABBREV('TRACE',TR,1) THEN TRACE ?R\nIF VALDSN() \u00ac= 0 THEN RETURN\nSELECT\n  WHEN UDSORG = 'PO' & ULRECL > 9 & ULRECL < 256 & OPT = '1' &,\n       (URECFM = 'FB' | URECFM = 'VB' | URECFM = 'FBA') THEN\n    ADDRESS ISPEXEC \"EDIT DATASET(\"IFILE\")\"\n  WHEN UDSORG = 'PS' & ULRECL > 9 & ULRECL < 256 & OPT = '1' &,\n       (URECFM = 'FB' | URECFM = 'VB' | URECFM = 'FBA') THEN\n    ADDRESS ISPEXEC \"EDIT DATASET(\"IFILE\")\"\n  WHEN UDSORG = 'PS' | UDSORG = 'VS' | UDSORG = 'VK' THEN DO\n    ADDRESS TSO \"FREE FILE(\"DDIF\")\"\n    ADDRESS TSO \"ALLOC DATASET(\"IFILE\") FILE(\"DDIF\") OLD\"\n    IF RC = 0 THEN DO\n      IF ALLOCNEW(OFILE,DDOF,ULRECL,'V') = 0 THEN DO\n          EDITRC = 0\n          SELECT\n             WHEN UDSORG = 'VS' & ULRECL>9 & ULRECL<256 & OPT='1' THEN\n               CALL EDITVSAM\n             WHEN UDSORG = 'VK' & ULRECL>9 & ULRECL<256 & OPT='1' THEN\n               CALL EDITVSAM\n             OTHERWISE\n               CALL EDITABN\n          END\n          IF EDITRC = 0 THEN\n              CALL DELFILE OFILE DDOF\n          ELSE\n              SAY '******** IF YOUR ORIGINAL FILE IS CORRUPTED,',\n                  'THE FILE' OFILE 'MAY HELP YOU'\n      END\n      ADDRESS TSO \"FREE FILE(\"DDIF\")\"\n    END\n  END\n  OTHERWISE DO\n      SAY \" IN THIS RELEASE, \"\n      SAY \" ONLY SUPPORTS PS DATASETS OF FB/VB ORGANIZATION\"\n      SAY \"     AND     PO DATASETS OF FB/VB ORG. >9 & <256\"\n      SAY \"     AND     VS DATASETS \"\n      SAY \"     AND     VK DATASETS \"\n      SAY \" \"IFILE \" IS AN \"SYSDSORG \"DATASET\"\n      SAY \" AND HAS AN \"URECFM \"ORGANIZATION\"\n      RETURN 4\n  END\nEND\nRETURN\nEND\n/* PROCEDURE VALDSN :- GEN THE DATASET ATTRIBUTE                 */\nVALDSN:\nIF SYSDSN(IFILE) \u00ac= 'OK' THEN DO\n  SAY \"BEEBOO : DATASET \"IFILE\" DOES NOT EXIST\"\n  RETURN 4\nEND\nX=LISTDSI(IFILE \"DIRECTORY\")\nUKEYSTART = 0\nUKEYEND = 0\nSELECT\n  WHEN SYSREASON = 0 THEN DO\n     UDSORG = SYSDSORG\n     URECFM = SYSRECFM\n     ULRECL = SYSLRECL\n     IF URECFM = ' VB ' THEN ULRECL = ULRECL - 4\n  END\n  WHEN SYSREASON = 12 THEN DO\n     X=OUTTRAP(\"LINE.\")\n     ADDRESS TSO \"LISTC ENT(\"IFILE\") ALL\"\n     X=OUTTRAP(\"OFF\")\n     UDNAME = SUBSTR(LINE.8,17)\n     IF SUBSTR(LINE.9,8,5) = 'INDEX' THEN DO\n       UDSORG = 'VK'\n       UKEYSTART = GETWORD(LINE.20,31) + 1\n       UKEYEND = UKEYSTART + GETWORD(LINE.19,31) - 1\n       ULRECL = GETWORD(LINE.20,60)\n       UINAME = SUBSTR(LINE.9,17)\n     END\n     ELSE DO\n       UDSORG = 'VS'\n       ULRECL = GETWORD(LINE.19,60)\n     END\n     URECFM = 'FB'\n     END\n  OTHERWISE\n   DO\n     SAY \"BEEBOO : LISTDSI \"IFILE\" FAILED . . . \"\n     SAY \"BEEBOO : RETURN CODE = \"RC\n     SAY \"BEEBOO : REASON CODE = \"SYSREASON\n     RETURN 4\n   END\n END\nRETURN 0\nGETWORD: PROCEDURE\nARG LINE,ENDCOL\nSTCOL = ENDCOL\nDO WHILE SUBSTR(LINE,STCOL,1) \u00ac='-'\n   STCOL = STCOL - 1\nEND\nLEN = ENDCOL - STCOL\nSTCOL = STCOL + 1\nRETURN SUBSTR(LINE,STCOL,LEN)\n/* PROCEDURE EDITVSAM :- EDIT A VSAM WITH RECORD LENGTH > 9 & < 256 */\nEDITVSAM:\nIF REPRODS(DDIF,DDOF) = 0 THEN DO\n   ADDRESS ISPEXEC \"EDIT DATASET ( \"OFILE\" ) \",\n                 \" PROFILE(BEEBOON) MACRO(EDBEEBVM)\"\n   SELECT\n     WHEN RC = 4 THEN SAY \"BEEBOO : FILE NOT MODIFIED\"\n     WHEN RC = 0 THEN EDITRC = REPROVS (DDOF,DDIF)\n     OTHERWISE      SAY \"BEEBOO : EDIT TEMP FILE FAILED... RC =\"RC\n   END\nEND\nRETURN\n/* PROCEDURE EDITABN - EDIT A FILE WITH RECORD LENGTH > 255        */\nEDITABN:\nIF UDSORG = 'PS' THEN DO\n   IF BBEDIT(DDIF,DDOF) = 0 THEN EDITRC = REPRODS(DDOF,DDIF)\nEND\nELSE\nDO\n   IF REPRODS(DDIF,DDOF) = 0 THEN\n      IF BBEDIT(DDOF,DDOF) = 0 THEN EDITRC = REPROVS(DDOF,DDIF)\nEND\nRETURN\n/* PROCEDURE BBEDIT - CONVERT INDD, EDIT AND STORED AS OUTDD       */\nBBEDIT:\nARG INDD,OUTDD\nRETCODE = 4\nIF ALLOCNEW(TFILE,DDTF,WPLN+22,'F') = 0 THEN DO\n IF FORMAT1(INDD,DDTF) = 0 THEN DO\n    ADDRESS ISPEXEC \"EDIT DATASET(\"TFILE\")\",\n                 \" PROFILE(BEEBOO) MACRO(EDBEEBOM)\"\n    SELECT\n      WHEN RC = 4 THEN SAY \"BEEBOO : FILE NOT MODIFIED\"\n      WHEN RC = 0 THEN RETCODE = FORMAT2(DDTF,OUTDD)\n      OTHERWISE       SAY \"BEEBOO : EDIT TEMP FILE FAILED... RC =\"RC\n    END\n END\n CALL DELFILE TFILE DDTF\nEND\nRETURN RETCODE\n/* PROCEDURE ALLOCNEW */\nALLOCNEW: PROCEDURE\nARG DS,FILE,LRECL,FMT\nIF FMT = 'V' THEN LRECL = LRECL + 4\nBLKS = 6144%LRECL*LRECL\nIF FMT = 'V' THEN BLKS = BLKS + 4\nADDRESS TSO \"FREE FILE(\"FILE\")\"\nADDRESS TSO \"ALLOC DATASET(\"DS\") FILE(\"FILE\")\",\n    \"NEW CATALOG UNIT(DISK) TRACKS SPACE(10,10)\",\n    \"DSORG(PS) BLKSIZE(\"BLKS\") LRECL(\"LRECL\") RECFM(\"FMT\",B)\"\nSAY \"BEEBOO : ALLOCATE NEW DATASET \"DS FILE \"... RC = \"RC\nRETURN RC\n/* PROCEDURE DELFILE */\nDELFILE: PROCEDURE\nARG DS DD\n  ADDRESS TSO \"FREE FILE (\"DD\") DELETE\"\n  SAY \"BEEBOO : DELETE PILE \"DS\"  ...... RC = \"RC\nRETURN RC\n/* PROCEDURE REPRODS */\nREPRODS:\nARG IDD, ODD\nX=OUTTRAP (\"LINE.\")\nADDRESS TSO \"REPRO IFILE(\"IDD\") OFILE(\"ODD\")\"\nRETCODE = RC\nX=OUTTRAP (\"OFF\")\nIF POS (\"VSAM OPEN RETURN CODE IS 160\",LINE.2) > 0 THEN\nRETCODE = 0\nIF RETCODE \u00ac= 0 THEN SAY \"BEEBOO : REPRO FILE FAILED\"\nRETURN RETCODE\n/* PROCEDURE REPROVS */\nREPROVS:\nARG IDD,ODD\nSAY \"BEEBOO : DEFINE TEMP VSAM FILE\"\nADDRESS TSO \"DEFINE CLUSTER(NAME(\"VFILE\") MODEL (\"IFILE\") \"\nIF RC = 0 THEN DO\n  SAY \"BEEBOO : DELETE THE ORGINAL FILE\"\n  ADDRESS TSO \"DELETE \"IFILE;\n  IF RC = 0 THEN DO\n      SAY \"BEEBOO : DEFINE THE ORIGINAL FILE\"\n      IF UDSORG = 'VS' THEN\n        ADDRESS TSO \"DEFINE CLUSTER(NAME(\"IFILE\")\",\n                  \"MODEL(\"VFILE\"))\",\n                  \"DATA(NAME(\"UDNAME\"))\"\n      ELSE\n        ADDRESS TSO \"DEFINE CLUSTER(NAME(\"IFILE\")\" ,\n                  \"MODEL(\"VFILE\"))\",\n                  \"DATA (NAME(\"UDNAME\"))\",\n                  \"INDEX(NAME(\"UINAME\"))\"\n      IF RC = 0 THEN DO\n        SAY \"BEEBOO : COPY THE EDITING TEMP FILE INTO ORIGINAL FILE\"\n         X=OUTTRAP(\"LINE.\")\n        ADDRESS TSO \"REPRO IFILE(\"IDD\") ODS(\"IFILE\")\"\n        RETCODE = RC\n        X=OUTTRAP(\"OFF\")\n        IF UDSORG = 'VK' &,\n        POS(\"NUMBER OF RECORDS PROCESSED WAS 0\", LINE.1) > 0 THEN DO\n             SAY LINE. 1\n        END\n        SAY \"BEEBOO : DELETE TEMP VSAM FILE\"\n        ADDRESS TSO \"DELETE \"VFILE\n  END\nEND\nIF RETCODE \u00ac= 0 THEN SAY \"BEEBOO : REPRO FILE FAILED\"\nRETURN RETCODE\n/* PROCEDURE FORMAT1  CONVERT INDD TO OUTDD OF LENGTH 72           */\nFORMAT1:\nARG IDD,ODD\nLINE50.1 = ' < 'PAD(ULRECL,4)'>  <'PAD(UREYSTART,4)'-'PAD(UKEYEND,4)'>'\nK=1\nN = (ULRECL-1)%WPLN + 1\nBUFNO = 100\nREADPTR = 1\nADDRESS TSO \"EXECIO \"BUFNO\" DISKR \"IDD READPTR\" (STEM LINE.)\"\nSTOP=LINE.0\nIF STOP = 0 THEN DO\n  STOP = 1\n  LINE.1 = \"\"\n  LINE50.1 = LINE50.1\" NEW DATASET\"\nEND\nDO UNTIL STOP = 0\n SAY ' BEEBOO : PROCESSING RECORD ' READPTR\n DO J = 1 TO STOP\n     DO I = 1 TO N\n       K = K + 1\n       C1 = WPLN*(I-1)+1\n       C2 = WPLN*I\n       IF C2 > ULRECL THEN C2 = ULRECL\n       IF I = 1 THEN\n         LINE50.K = ,\n   '<'PAD(READPTR,6)'> <0001-'PAD(C2,4)'><'SUBSTR(LINE.J,1,WPLN) '>'\n       ELSE\n         LINE50 . K = ,\n     '<     > <'PAD(C1,4)'-'PAD(C2,4)'><'SUBSTR(LINE.J,C1,WPLN) '>'\n     END\n     READPTR = READPTR+1\n END\n K=K+1\n LINE50.K=\"\"\n \"EXECIO * DISKW \"ODD\" (STEM LINE50.)\"\n K = 0\n ADDRESS TSO \"EXECIO \"BUFNO\" DISKR \"IDD READPTR\" (STEM LINE.)\"\n STOP=LINE.0\nEND\nSAY ' BEEBOO : TOTAL PROCESSED RECORD ' READPTR - 1\nADDRESS TSO \"EXECIO 0 DISKR \"IDD\" (FINIS)\"\nADDRESS TSO \"EXECIO 0 DISKW \"ODD\" (FINIS)\"\nRETURN RC\nPAD:PROCEDURE\nARG NUM, DIGIT\nRETURN RIGHT(NUM,DIGIT,'0')\n/* PROCEDURE FORMAT2   CONVERT IDD OF LENGTH 72 TO OUTDD        */\nFORMAT2:\nARG IDD,ODD\nN = (ULRECL-1)%WPLN + 1\nBUFNO = N * 100\nK=BUFNO+1\nLINE.K = \"\"\nK = 1\nLINE.K = \"\"\nJ = 0\nREADPTR = 2\nWRITECOUNT = 0\nADDRESS TSO \"EXECIO 2 DISKR \"IDD \"1 (STEM LINE50.)\"\nIF LINE50.0 > 1 THEN DO\n  ADDRESS TSO \"EXECIO \"BUFNO\" DISKR \"IDD READPTR\" (STEM LINE50.)\"\n  DO UNTIL LINE50.0 = 0\n    DO I = 1 TO LINE50.0\n      IF J < N THEN\n        LINE.K = LINE.K\"\"SUBSTR(LINE50.I,22,WPLN)\n      ELSE DO\n        LINE.K = SUBSTR(LINE.K,1,ULRECL)\n        IF K = 100 THEN DO\n           WRITECOUNT = WRITECOUNT + K\n           \"EXECIO * DISKW \"ODD\" (STEM LINE.)\"\n           SAY ' BEEBOO : PROCESSED RECORD ' WRITECOUNT\n           K = 0\n        END\n        K = K + 1\n        J = 0\n        LINE . K = SUBSTR (LINE50.I,22,WPLN)\n      END\n      J=J+1\n    END\n    READPTR = READPTR + LINE50.0\n    ADDRESS TSO \"EXECIO \"BUFNO\" DISKR \"IDD READPTR\" (STEM LINE50.) \"\n  END\n  IF K > 0 THEN DO\n     WRITECOUNT = WRITECOUNT + K\n     LINE.K = SUBSTR(LINE.K,1,ULRECL)\n     K=K+1\n     LINE.K = \"\"\n     \"EXECIO * DISKW \"ODD\" (STEM LINE.)\"\n     SAY 'BEEBOO : TOTAL PROCESSED RECORD ' WRITECOUNT\n  END\nEND\nADDRESS TSO \"EXECIO 0 DISKR \"IDD\" (FINIS)\"\nIF WRITECOUNT > 0 THEN\n   ADDRESS TSO \"EXECIO 0 DISKW \"ODD\" (FINIS)\"\nELSE DO\n   ADDRESS TSO \"ALLOC DUMMY FILE(BEEBOODM) OLD\"\n   ADDRESS TSO \"REPRO IFILE(BEEBOODM) OFILE(\"ODD\")\"\n   ADDRESS TSO \"FREE FILE(BEEBOODM)\"\nEND\nRETURN RC\n\n\nEDBEEB$P PANEL\n\n)ATTR\n   % TYPE(TEXT)  INTENS(HIGH)\n   + TYPE(TEXT)  INTENS(LOW)\n   _ TYPE(INPUT) INTENS(HIGH)  CAPS(ON)   JUST(LEFT)\n)BODY\n%------------------EDIT BY RECORD WRAPPING-----------------------------\n%COMMAND ===>_ZCMD\n%\n+              <DSN>%===>_Z                                +\n+             OPTION%===>_Z+    ( 1, 2 )\n+        WRAP LENGTH%===>_Z  +  ( 10 - 230 )\n\n+ THIS APPLICATION IS DESIGNED TO OVERCOME THE LENGTH LIMITATION OF THE\n+ ISPF EDITOR, BY PRODUCING A WRAPPED DATASET OF THE INPUT <DSN> FOR\n+ EDITING.\n+     USE %OPTION 1+ TO HAVE FUNCTION PERFORMED IN FULL.\n+     USE %OPTION 2+ IF YOU WANT TO EDIT THE DATASET IN WRAPPED FORMAT, +\n+ EVEN IF YOU CAN EDIT THE DATASET IN NORMAL FORMAT.\n+  %TO SKIP THIS PANEL, TYPE THE FOLLOWING AND OPTION 1 WILL BE USED :+\n+        TSO EDBEEBOO datasetname\n+  %IN THIS RELEASE,+\n+   ONLY SUPPORTS PS DATASETS OF FB/VB ORGANIZATION\n+        AND PO DATASETS OF FB/VB ORG. >9 & <256 IN NON-WRAP FORMAT\n+        AND VS,VK DATASETS\n)INIT\n  .ZVARS = '(DDD OPT WPLN)'\n)PROC\n   VER (&DDD,NONBLANK,DSNAME)\n   VER (&OPT,NONBLANK,RANGE,1,2)\n   VER (&WPLN,NONBLANK,RANGE,10,230)\n   &TM = TRUNC(&DDD,1)\nIF (&TM = '''')\n   &TT = .TRAIL\n   &IFILE = TRUNC(&TT,'''')\nIF (&TM \u00ac= '''')\n   &IFILE = &DDD\n)END\n\n\nEDBEEBOM MACRO\n\n/* REXX */\nADDRESS ISREDIT 'MACRO'\nADDRESS ISPEXEC 'CONTROL ERRORS RETURN'\nADDRESS ISREDIT\n'AUTOSAVE = OFF PROMPT'\n'(MLEN) = DATA WIDTH'\n'BOUNDS = 22 'MLEN\n'NUM = OFF'\n'CAPS = ON'\n'TABSLINE = <21,*,22,->'\n'TABS = ON ALL'\nRETURN RC\n\n\nEDBEEBVM MACRO\n\n/* REXX */\nADDRESS ISREDIT 'MACRO'\nADDRESS ISPEXEC 'CONTROL ERRORS RETURN'\nADDRESS ISREDIT\n'AUTOSAVE = OFF PROMPT'\n'NUM = OFF'\n'CAPS = ON'\nRETURN RC\n\nFung Mang Hui\nAnalyst/Programmer (Hong Kong)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A008A04": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x01\\x1f\\x01\\x1f\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 287, "newlines": 287, "modlines": 0, "user": "VSAMUPD"}, "text": "Analysing variable length files\n\nI was recently involved in a tuning effort involving variable\nlength VSAM KSDS files. Although KSDS files are variable\nlength by definition, most tend to have fixed length records. In\ncases where the records are truly variable, it is important to\nknow the breakdown of various record lengths when tuning\nsuch attributes as CI SIZE and CI FREESPACE. For example,\nit probably wouldn't make sense to have a CI FREESPACE of\n10% with a 4096 CI SIZE if 95 percent of the variable length\nrecords are 500 bytes. On the other hand, if the maximum\nlength is 500 but 95% of the records are less than 50 bytes, a\nFREESPACE value of 10 might be very beneficial. To add to\nthe difficulty in tuning these types of files, I had some\nassociated with third-party software. In those cases, the nature\nof the file was not as well understood as it was with in-house\nwritten software. Thus, having an idea of record length\ndistribution would be a step in the right direction when trying\nto tune.\n\nI decided to write an Assembler program, called VSLRECL, to\nanalyse record lengths in a truly variable VSAM KSDS file.\nVSLRECL determines all record lengths along with the count\nand percentage of distribution associated with each length. It\nthen prints a listing with one line per length detected. A listing\nmight appear as follows:\n\n      LENGTH: 00100 COUNT: 0105000 PERCENT: 084\n      LENGTH: 00250 COUNT: 0015000 PERCENT: 012\n      LENGTH: 00275 COUNT: 0004990 PERCENT: 003\n      LENGTH: 00600 COUNT: 0000010 PERCENT: < 1\n      TOTAL NUMBER OF RECORDS IN FILE: 0125000\n\nThis report indicates there are four different record lengths\n(100, 250, 275, and 600) in a file. A majority of the 125,000\ntotal records are 100 bytes (84%). Using this information,\nvarious tuning changes can be made with some idea of what the\neffect will be. Percentages are trunc-ated to the nearest whole\ndigit, with those under one showing as '< 1'. The program\nutilizes deferred updates on the work file and the JCL sets data\nbuffers to 50 which optimizes the run time. The JCL also uses\nthe DFP Release 3 technique of defining temporary VSAM\nfiles. If this is not applicable to your shop, just predefine the\nVSAM work file.\n\n\nJCL\n\n//* THIS JOB CAN ANALYSE THE RECORD LENGTHS OF A VARIABLE LENGTH\n//* VSAM DATASET. FOR EACH LENGTH, ITS COUNT AND PERCENT ARE LISTED.\n//*\n//STEP1    EXEC PGM=VSLRECL\n//SYSOUT   DD   SYSOUT=*\n//WORKFILE DD   DSN=&&TEMP,DISP=(,DELETE),KEYLEN=4,\n//   KEYOFF=0,LRECL=8,SPACE=(CYL,(1,1)),RECORG=KS\n//*\n//*   CHANGE THE FOLLOWING DSN= TO THE DATASET BEING ANALYSED\n//*\n//CHEKFILE DD   DSN=VSAM.FILE.TO.ANALYZE,DISP=SHR,AMP=('BUFND=50')\n\n\nVSLRECL ASSEMBLER\n\nR1        EQU     1                     GETMAIN POINTER\nR5        EQU     5                     WORK\nR6        EQU     6                     WORK\nR7        EQU     7                     WORK\nR8        EQU     8                     WORK\nR9        EQU     9                     WORK\nR12       EQU     12\nR13       EQU     13                    PROGRAM BASE\nR14       EQU     14\nR15       EQU     15\nVSLRECL   CSECT\n          STM     R14,R12,12(R13)       SAVE\n          LA      R14,0(R13)                 CALLERS\n          BAL     R13,84(R15)                        REGISTERS\n          USING   *,R13\n          DS      18F                   SAVE AREA\n          ST      R14,4(R13)            SAVE ADDR OF CALLERS SAVE AREA\n          ST      R13,8(R14)            SAVE ADDR OF OUR SAVE AREA\n          OPEN    (SYSOUT,OUTPUT)       OPEN PRINT FILE\n*    INITIALIZE THE WORK FILE SO IT CAN BE OPENED FOR DIRECT UPDATE\n          BAL     R5,WRKOPEN            OPEN WORK FILE\n          BAL     R5,WRKPUT             WRITE WORK RECORD\n          BAL     R5,WRKCLOSE           CLOSE WORK FILE\n*    BUILD LOCAL SHARED POOL FOR DEFFERED UPDATES\n          BLDVRP  BUFFERS=(22528(10),512(20)),STRNO=2,TYPE=LSR\n          MODCB   ACB=WORKACB,MACRF=(DIR,LSR)  GET READY FOR UPDATES\n          MODCB   RPL=WORKRPL,OPTCD=(DIR,UPD)\n          BAL     R5,WRKOPEN            OPEN WORK FILE\n          BAL     R5,CHKOPEN            OPEN CHECK FILE\n*    DETERMINE MAXIMUM RECORD LENGTH OF FILE BEING PROCESSED\n          SHOWCB  ACB=CHEKACB,AREA=DISPLAY,FIELDS=LRECL,LENGTH=4\n          L       R7,LRECL              SAVE LRECL\n          GETMAIN R,LV=(R7)             GET LRECL AMOUNT OF STORAGE\n          LR      R6,R1                 SAVE STORAGE LOCATION\n          MODCB   RPL=CHEKRPL,AREA=(R6),AREALEN=(R7),RECLEN=(R7)\n          LA      R9,0                  ZERO REG 9\nGETCHEK   GET     RPL=CHEKRPL           READ NEXT CHECK RECORD\n          LTR     R15,R15               READ OK?\n          BNZ     CHKEND                IF NOT, CHECK FOR END\n          LA      R9,1(R9)              ADD 1 TO RECORD COUNT\n*    DETERMINE LENGTH OF RECORD JUST READ\n          SHOWCB  RPL=CHEKRPL,FIELDS=RECLEN,AREA=DISPLAY,LENGTH=4\n          MVC     WORKKEY(4),LRECL      SAVE RECORD LENGTH\n          GET     RPL=WORKRPL           READ WORK RECORD\n          LTR     R15,R15               READ OK?\n          BZ      ADDONE                IF YES, GO ADD 1\n*    DETERMINE WHY WORK READ DIDN'T WORK\n          SHOWCB  RPL=WORKRPL,FIELDS=FDBK,AREA=FDBKCDE,LENGTH=4\n          CLC     FDBKCDE+3(1),=X'10'   NOT FOUND?\n          BE      ITSNEW                IF YES, ITS A NEW RECORD\n          LA      R8,GETMSG2            PRIME ERROR MESSAGE\n          B       ISSUEMSG              UNEXPECTED FEEDBACK ON READ\nITSNEW    ZAP     WORKCNT,=P'1'         INITIALIZE TO 1\n          MODCB   RPL=WORKRPL,OPTCD=(NUP)  ALLOW PUT NO UPDATE\n          BAL     R5,WRKPUT             WRITE WORK RECORD\n          MODCB   RPL=WORKRPL,OPTCD=(UPD)  ALLOW PUT UPDATE\n          B       GETCHEK               GO GET NEXT CHECK RECORD\nADDONE    AP      WORKCNT,=P'1'         ADD 1 TO TOTAL\n          BAL     R5,WRKPUT             WRITE WORK RECORD\n          B       GETCHEK               GO GET NEXT CHECK RECORD\nSUMMARY   BAL     R5,CHKCLOSE           CLOSE CHECK FILE\n          BAL     R5,WRKCLOSE           CLOSE WORK FILE\n*    CHANGE WORK FILE FOR SEQUENTIAL PROCESSING NO UPDATES\n          MODCB   ACB=WORKACB,MACRF=(SEQ,IN,NSR) CHANGE TO INPUT\n          MODCB   RPL=WORKRPL,OPTCD=(SEQ,NUP) SEQUENTIAL NO UPDATE\n          BAL     R5,WRKOPEN            OPEN WORK FILE\n          CVD     R9,WKFLD7             CONVERT TOTAL RECORD COUNT\n          L       R9,WKFLD8             LOAD CONVERTED COUNT\n          BAL     R5,WRKGET             SKIP LOW VALUES WORK RECORD\nWORKLOOP  BAL     R5,WRKGET             READ NEXT WORK RECORD\n          L       R8,WORKKEY            LOAD KEY (RECORD LENGTH)\n          CVD     R8,WKFLD7             CONVERT RECORD LENGTH\n          UNPK    WKFLD1(5),WKFLD7      PREPARE FOR PRINT\n          OI      WKFLD1+4,X'F0'        MAKE LAST CHARACTER PRINTABLE\n          MVC     MSGLEN,WKFLD1         PUT LENGTH IN MESSAGE\n          UNPK    WKFLD2(7),WORKCNT     PREPARE TO PRINT COUNT\n          OI      WKFLD2+6,X'F0'        MAKE LAST CHARACTER PRINTABLE\n          MVC     MSGCNT,WKFLD2         PUT COUNT IN MESSAGE\n          ZAP     WKFLD4,=P'0'          INITIALIZE WORK FIELDS\n          ZAP     WKFLD7,=P'0'\n          ST      R9,WKFLD8             SAVE TOTAL RECORD COUNT\n          MVC     WKFLD6,WORKCNT        MULTIPLY RECORD\n          MP      WKFLD4,ONEHUND            COUNT BY 100\n          DP      WKFLD4,WKFLD8         DIVIDE BY TOTAL RECORDS\n          CP      WKFLD5,=P'0'          IS % < 1?\n          BE      LESSONE               IF YES, INDICATE SO\n          UNPK    WKFLD3(3),WKFLD5      PREPARE TO PRINT %\n          OI      WKFLD3+2,X'F0'        MAKE LAST CHARACTER PRINTABLE\n          MVC     MSGPCT,WKFLD3         PUT % IN MESSAGE\n          B       WRITEMSG              GO PRINT MESSAGE\nLESSONE   MVC     MSGPCT,=C'< 1'        INDICATE % IS LESS THAN 1\nWRITEMSG  PUT     SYSOUT,COUNTMSG       PRINT MESSAGE\n          B       WORKLOOP              GO PROCESS NEXT RECORD LENGTH\nPRNTTOTL  ST      R9,WORKCNT            STORE TOTAL COUNT\n          UNPK    WKFLD2(7),WORKCNT     PREPARE TO PRINT TOTAL\n          OI      WKFLD2+6,X'F0'        MAKE LAST CHARACTER PRINTABLE\n          MVC     MSGTOT,WKFLD2         PUT TOTAL IN MESSAGE\n          PUT     SYSOUT,TOTALMSG       PRINT TOTAL MESSAGE\n          CLOSE   (SYSOUT)              CLOSE SYSOUT\n          BAL     R5,WRKCLOSE           CLOSE WORK FILE\n          L       R13,4(R13)            RELOAD CALLERS SAVE AREA\n          LM      R14,R12,12(R13)       RELOAD CALLERS REGISTERS\n          LA      R15,0                 END WITH RETURN CODE 0\n          BR      R14                   GO BACK TO CALLER\n*    DETERMINE WHY CHECK READ DIDN'T WORK\nCHKEND    SHOWCB  RPL=CHEKRPL,FIELDS=FDBK,AREA=FDBKCDE,LENGTH=4\n          CLC     FDBKCDE+3(1),=X'04'   AT END?\n          BE      SUMMARY               IF YES, TIME TO SUMMARIZE\n          LA      R8,GETMSG1            PRIME ERROR MESSAGE\n          B       ISSUEMSG              UNEXPECTED FEEDBACK ON READ\n*    DETERMINE IF THIS IS END OF WORK FILE\nWRKEND    SHOWCB  RPL=WORKRPL,FIELDS=FDBK,AREA=FDBKCDE,LENGTH=4\n          CLC     FDBKCDE+3(1),=X'04'   AT END?\n          BE      PRNTTOTL              IF YES, GET OUT\n          LA      R8,GETMSG2            PRIME ERROR MESSAGE\n          B       WRKERROR              GO PRINT ERROR\nCHKOPEN   LA      R8,OPENMSG1           PRIME ERROR MESSAGE\n          OPEN    CHEKACB               OPEN CHEKFILE\n          LTR     R15,R15               OPEN OK?\n          BNZ     CHKERROR              IF NOT, TERMINATE\n          BR      R5\nCHKCLOSE  LA      R8,CLOSMSG1           PRIME ERROR MESSAGE\n          CLOSE   CHEKACB               CLOSE CHEKFILE\n          LTR     R15,R15               CLOSE OK?\n          BNZ     CHKERROR              IF NOT, TERMINATE\n          BR      R5\nWRKOPEN   LA      R8,OPENMSG2           PRIME ERROR MESSAGE\n          OPEN    WORKACB               OPEN WORKFILE\n          LTR     R15,R15               OPEN OK?\n          BNZ     WRKERROR              IF NOT, TERMINATE\n          BR      R5\nWRKCLOSE  LA      R8,CLOSMSG2           PRIME ERROR MESSAGE\n          CLOSE   WORKACB               CLOSE WORKFILE\n          LTR     R15,R15               CLOSE OK?\n          BNZ     WRKERROR              IF NOT, TERMINATE\n          BR      R5\nWRKGET    GET     RPL=WORKRPL           READ WORKFILE RECORD\n          LTR     R15,R15               READ OK?\n          BNZ     WRKEND                IF NOT, CHECK FOR END\n          BR      R5\nWRKPUT    LA      R8,PUTMSG PRIME ERROR MESSAGE\n          PUT     RPL=WORKRPL           WRITE WORKFILE RECORD\n          LTR     R15,R15               WRITE OK?\n          BNZ     WRKERROR              IF NOT, TERMINATE\n          BR      R5\nWRKERROR  ST      R15,RC                SAVE RETURN CODE\n*    RETRIEVE UNEXPECTED WORKFILE FEEDBACK CODE\n          SHOWCB  RPL=WORKRPL,FIELDS=FDBK,AREA=FDBKCDE,LENGTH=4\n          B       ISSUEMSG\nCHKERROR  ST      R15,RC                SAVE RETURN CODE\n*    RETRIEVE UNEXPECTED CHEKFILE FEEDBACK CODE\n          SHOWCB  RPL=CHEKRPL,FIELDS=FDBK,AREA=FDBKCDE,LENGTH=4\nISSUEMSG  PUT     SYSOUT,0(R8)          PRINT APPROPRIATE ERROR MSG\n          UNPK    WKFLD,FDBKCDE+2(3)    UNPACK THE FEEDBACK CODE\n          TR      WKFLD(3),TRTBL-C'0'   MAKE SURE ITS PRINTABLE\n          MVC     MSGCDE,WKFLD          PUT FEEDBACK INTO MESSAGE\n          PUT     SYSOUT,MSGFDBK        WRITE OUT THE FEEDBACK CODE\n          L       R13,4(R13)            RELOAD CALLERS SAVE AREA\n          LM      R14,R12,12(R13)       RELOAD CALLERS REGISTERS\n          L       R15,RC                LOAD RETURN CODE\n          BR      R14                   GO BACK TO CALLER\n          LTORG\nOPENMSG1  DC      CL80' * ERROR OPENING CHEKFILE *'\nOPENMSG2  DC      CL80' * ERROR OPENING WORKFILE *'\nPUTMSG    DC      CL80' * ERROR WRITING WORKFILE *'\nGETMSG1   DC      CL80' * ERROR READING CHEKFILE *'\nGETMSG2   DC      CL80' * ERROR READING WORKFILE *'\nERASEMSG  DC      CL80' * ERROR ERASING WORKFILE *'\nCLOSMSG1  DC      CL80' * ERROR CLOSING CHEKFILE *'\nCLOSMSG2  DC      CL80' * ERROR CLOSING WORKFILE *'\nDISPLAY   DS      0D\nLRECL     DS      F                     CHECKFILE RECORD LENGTH\nFDBKCDE   DS      F                     VSAM FEEDBACK CODE\nRC        DS      F                     UNEXPECTED RETURN CODE\nTRTBL     DC      C'0123456789ABCDE'\nONEHUND   DC      X'000100C'\nWORKREC   DS      0D                    WORK FILE RECORD\n          ORG     WORKREC\nWORKKEY   DC      X'00000000'           KEY (CHEKFILE RECORD LENGTH)\nWORKCNT   DC      X'00000000'           COUNT (CHEKFILE RECORD COUNT)\n          ORG\nWKFLD     DS      CL4                   VARIOUS WORK FIELDS\nWKFLD1    DS      CL5\nWKFLD2    DS      CL7\nWKFLD3    DS      CL3\nWKFLD4    DS      0D\nWKFLD5    DS      F\nWKFLD6    DS      F\nWKFLD7    DS      0D\nFILLER    DS      F\nWKFLD8    DS      F\nCOUNTMSG  DS      CL80' '               INDIVIDUAL COUNTS MESSAGE\n          ORG     COUNTMSG\n          DC      C' LENGTH: '\nMSGLEN    DS      CL5\n          DC      C' COUNT: '\nMSGCNT    DS      CL7\n          DC      C' PERCENT: '\nMSGPCT    DS      CL3\n          ORG\nTOTALMSG  DS      CL80' '               TOTAL MESSAGE\n          ORG     TOTALMSG\n          DC      C' TOTAL NUMBER OF RECORDS IN FILE: '\nMSGTOT    DS      CL7\n          ORG\nMSGFDBK   DS      CL80' '               FEEDBACK MESSAGE\n          ORG     MSGFDBK\n          DC      CL24' VSAM FEEDBACK CODE IS: '\nMSGCDE    DS      CL3\n          ORG\n          LTORG\nSYSOUT    DCB   BLKSIZE=80,LRECL=80,DDNAME=SYSOUT,DSORG=PS,MACRF=PM,   C\n               RECFM=F\nCHEKACB   ACB   MACRF=(KEY,SEQ,IN),DDNAME=CHEKFILE\nCHEKRPL   RPL   ACB=CHEKACB,OPTCD=(SEQ,LOC)\nWORKACB   ACB   MACRF=(KEY,SEQ,OUT,DFR),DDNAME=WORKFILE\nWORKRPL   RPL   ACB=WORKACB,OPTCD=(KEY,SEQ,NUP,SYN,MVE),RECLEN=8,      C\n               AREALEN=8,KEYLEN=4,ARG=WORKKEY,AM=VSAM,AREA=WORKREC\n          END\n\nErnie Ishman\nSenior Systems Programmer\nGeisinger System Services (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A008A05": {"ttr": 10245, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00#\\x00#\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 35, "newlines": 35, "modlines": 0, "user": "VSAMUPD"}, "text": "Synchronizing catalogs and CRAs\n\nThe RESETCAT job will allow you to synchronize the catalog\nwith the CRA on each volume. For example, the catalog\nCATTP01 owns 10 volumes (LYO007 to LYO010 ), and has\nbeen defined with the recoverable attribute. If you have a\nmulti-volume file, you will sometimes need to use the\nRESETCAT job, which will access the file. It can be useful,\nfor example, when you cannot delete a file with the attribute of\nIGNORE ERROR.\n\nAn example of the output is shown in Figure 1.\n\n\nRESETCAT JCL\n\n* $$ JOB JNM=RESETCAT,CLASS=6,DISP=D,PRI=5\n* $$ PRT CLASS=A\n// JOB RESETCAT DE CATTP01  (VSAM CATALOG)\n* * * * * * WARNING THIS JOB MAY DELETE ENTRIES IN THIS CATALOG FOR\n* * * * * * SYNCHRONIZATION *******\n// EXEC IDCAMS,SIZE=AUTO\n       RESETCAT-\n         CATALOG     (CATTP01) -\n         CRAVOLUMES( ( LYO007 ALL ) (LYO008 ALL) ( LYO009 ALL) -\n                     ( LYO010 ALL ) (LYO011 ALL) ( LYO012 ALL) -\n                     ( LYO013 ALL ) (LYO014 ALL) ( LYO015 ALL) -\n                     ( LYO016 ALL ) ) -\n          WORKCAT (CATWORK) -\n          WORKVOLUMES(LYO026 LYO027)\n/*\n/&\n* $$ EOJ\n\nClaude Dunand (France)                        c Claude Dunand 1993\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A008A06": {"ttr": 10247, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00D\\x00D\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 68, "newlines": 68, "modlines": 0, "user": "VSAMUPD"}, "text": "Buffers and performance\n\nThere are many VSAM files that perform badly. In many\ninstances, performance improvements can be brought about\nsimply by changing the buffer allocation. This article suggest\nways of improving VSAM performance.\n\nThe first choice that a programmer must make is which mode\nto use when accessing a VSAM file. The choices for a COBOL\nprogrammer are sequential, random, and dynamic. For\nsequential access, most buffers are allocated for data and one\nor two for the index. For random access, most buffers are\nallocated to the index, which is where most I/O is expected.\nFor dynamic access, most buffers are allocated for data in the\nsame way as for sequential. This is because dynamic access is\nthought to select a record randomly, and then access records\nsequentially from that point in the file. If a VSAM file is\nopened using dynamic and accessed randomly this will result in\na lot of unnecessary I/O to the index because there will not be\nenough buffers to keep the higher level indexes in memory.\nChanging the access to random and recompiling the program\ncan dramatically improve its performance.\n\nIf a program does have the wrong buffer allocation, the\nproblem can be overcome by using the AMP parameter in JCL.\nIf a file is effectively being accessed randomly but the COBOL\nprogram thinks it should be dynamic, extra buffer space can be\nallocated for higher level indexes by using the BUFNI\nparameter. It is also possible to specify data buffers with the\nAMP parameter, for example:\n\n      AMP=('BUFNI=4','BUFND=2/')\n\nThe default bufferspace for a KSDS is almost always too small.\nThe amount is one index CI and two data CIs. Poor\nperformance often results from using the default because extra\nI/O is being performed.\n\nFor sequential files, one index CI plus STRNO is usually\nenough. For data CIs, enough space to hold two tracks of data\nrecords is usually considered to be optimal. For random files,\ntwo data CIs are usually enough. For index CIs, enough space\nto hold index records equal to the number of index levels plus\none for each string is considered to be a good working target.\n\nBuffering cannot solve those problems that are caused by bad\nchoices for CI sizes in the first place. The size of an index CI\nmust be large enough to point to all the data CIs in a CA.\nFailure to choose the correct CI size is a common mistake.\n\nThe IMBED parameter is considered by many people to\nimprove performance. It replicates the sequence set on the top\ntrack of a cylinder. However, if the default bufferspace is used\nfor random processing, there is no performance advantage\nbecause the HDA has to repeatedly move to read the high level\nindexes and then move back to the sequence set cylinder.\n\nIn fact, the IMBED parameter offers no advantage to users of\n3380 and 3390 disks with cache memory. On a 3330, IMBED\nuses 3.3% of the dataspace, while on 3380s it uses 6.7% and\ncauses a degradation in performance. If cache is used, the\nsequence set will often remain in cache memory and so its\nrepetitive placement on the disk is unnecessary and can impair\nperformance.\n\nJ Phillips\nSenior Consultant (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A008A07": {"ttr": 10249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x00\\x9d\\x00\\x9d\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 157, "newlines": 157, "modlines": 0, "user": "VSAMUPD"}, "text": "IDCAMS EXAMINE\n\nThe IDCAMS EXAMINE command can be used to analyse the\nindex and data components of a KSDS to produce reports on\nthe structure of the individual components. The format of the\ncommand is presented below. We have found the command to\nbe useful in checking that our ICF user catalogs are not corrupt\nin any way, and also in providing us with statistics on each of\nthe user catalogs in the system. This job uses IDCAMS to list\nall the user catalogs relating to the system it is being executed\non, and then stores the associated output in a temporary\ndataset. This output is then used as input to the REXX EXEC,\nEXAMREXX. This EXEC builds a jobstream similar to that\npresented below. This jobstream is then input to the internal\nreader in STEP3 of the process below.\n\nThe jobstream that is built will issue the EXAMINE command\nfor each user catalog's index and data components. The source\nfor the EXAMREXX program is presented below.\n\nWe execute the program on a regular basis and by doing so we\ncan ensure that no structural errors are found on the catalogs\nand also obtain statistics on catalog activity, control intervals,\nand space usage. The output for a single catalog is presented in\nFigure 1.\n\nBy utilizing the REXX EXEC we have ensured that when we\nremove catalogs or add new ones the process requires no\namendment because the EXAMINE statements are built\ndynamically. Further modification to the initial jobstream could\nbe performed to add a final step that would process the output\nfrom EXAMINE and report automatically on structural errors\nor if the Free Space in a catalog had fallen below a certain\nlevel. We have not done this because we do not have too many\ncatalogs in our environment; however, if your Data Centre\nutilizes a lot of catalogs it may not be feasible to review the\noutput manually.\n\n\nFORMAT OF IDCAMS EXAMINE COMMAND\n\nEXAMINE   NAME(cluster) -\n          INDEXTEST|NOINDEXTEST -\n          DATATEST|NODATATEST -\n          ERRORLIMIT\n\nNote: ERRORLIMIT can be used to restrict the number of\noutput messages but continue with the test.\n\n\nJOBSTREAM TO EXAMINE USER CATALOGS\n\n//STS01A      JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=STS01\n//*      * THIS STEP EXAMINES ALL ICF CATALOGS FOR INDEX AND DATA    *\n//*      * STRUCTURAL ERRORS.                                        *\n//*      * STEP1 - LIST ALL USER CATALOGS FOR THIS SYSTEM.           *\n//*      * STEP2 - FORMAT THE OUTPUT FROM STEP1 USING A REXX EXEC.   *\n//*      * STEP3 - SUBMIT JOB BUILT BY REXX EXEC TO THE SYSTEM TO    *\n//*      *         PERFORM IDCAMS EXAMINES.                          *\n//STEP1       EXEC  PGM=IDCAMS,REGION=1M\n//SYSPRINT    DD    DSN=&&TEMP1,\n//            DISP=(NEW,PASS),\n//            DCB=(RECFM=FB,LRECL=121,BLKSIZE=12100,DSORG=PS),\n//            UNIT=WORK,\n//            SPACE=(CYL,1,RLSE)\n//SYSIN       DD    *\n  LISTC USERCATALOG\n/*\n//*\n//STEP2       EXEC  PGM=IRXJCL,PARM='EXAMREXX',COND=(0,LT),REGION=6M\n//REXXDDI     DD    DSN=&&TEMP1,DISP=(OLD,DELETE)\n//REXXDDO     DD    DSN=&&TEMP2,\n//            DISP=(NEW,PASS),\n//            UNIT=WORK,\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=80,DSORG=PS),\n//            SPACE=(TRK,5,RLSE)\n//SYSEXEC     DD    DSN=STS01.BD.REXX,DISP=SHR\n//*\n//STEP3       EXEC  PGM=ICEGENER\n//SYSPRINT    DD    SYSOUT=*\n//SYSIN       DD    DUMMY\n//SYSUT1      DD    DSN=&&TEMP2,DISP=(OLD,DELETE)\n//SYSUT2      DD    SYSOUT=(A,INTRDR)\n\n\nJOBSTREAM BUILT BY EXAMJOB PROCESS\n\n//STS01A   JOB   J.BRADLEY,CLASS=A,MSGCLASS=Q\n//STEP1    EXEC  PGM=IDCAMS\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n  EXAMINE -\n  NAME ( -\n  CATALOG.SYSONE ) -\n  INDEXTEST DATATEST\n  EXAMINE -\n  NAME ( -\n  CATALOG.SYSTWO ) -\n  INDEXTEST DATATEST\n/*\n\n\nSOURCE FOR EXAMREXX PROGRAM\n\n/* REXX */\n/*       * PURPOSE:      BUILD A JCL PROCESS TO EXAMINE ALL     *    */\n/*       *               USER CATALOGS IN THE SYSTEM.           *    */\n/*       * INITIALIZE CONSTANTS AND VARIABLES.                  *    */\nEOF = 'NO'\nVAR1 = ' EXAMINE -'\nVAR2 = ' NAME( -'\nVAR3 = ' ) -'\nVAR4 = ' INDEXTEST DATATEST'\n/*       * BUILD IDCAMS JCL AND OUTPUT TO TEMPORARY FILE.       *    */\nOUTELEM = '//STS01A    JOB    (SDTS),''J.BRADLEY'',CLASS=A,MSGCLASS=Q'\nPUSH OUTELEM\n\"EXECIO 1 DISKW REXXDDO\"\nOUTELEM = '//STEP1     EXEC   PGM=IDCAMS'\nPUSH OUTELEM\n\"EXECIO 1 DISKW REXXDDO\"\nOUTELEM = '//SYSPRINT  DD     SYSOUT=*'\nPUSH OUTELEM\n\"EXECIO 1 DISKW REXXDDO\"\nOUTELEM = '//SYSIN     DD     *'\nPUSH OUTELEM\n\"EXECIO 1 DISKW REXXDDO\"\n/*       * FORMAT LISTC USER CATALOG OUTPUT AND PUSH TO OUTPUT  *    */\n/*       * FILE AS INPUT CARDS.                                 *    */\nDO WHILE EOF = NO\n   \"EXECIO 1 DISKR REXXDDI\"\n   IF RC = 2 THEN EOF = 'YES'\n      ELSE\n      DO\n       PULL ELEMENT\n       IF SUBSTR(ELEMENT,15,17) = 'NUMBER OF ENTRIES' THEN EOF = 'YES'\n          ELSE\n           IF SUBSTR(ELEMENT,2,11) = 'USERCATALOG' THEN\n              DO\n               DSNAME = SUBSTR(ELEMENT,17,44)\n               PUSH VAR4\n               OUTELEM = STRIP(DSNAME,T)\n               OUTELEM = OUTELEM||VAR3\n               PUSH OUTELEM\n               PUSH VAR2\n               PUSH VAR1\n               \"EXECIO 4 DISKW REXXDDO\"\n              END\n      END\nEND\nOUTELEM = '/*'\nPUSH OUTELEM\n\"EXECIO 1 DISKW REXXDDO\"\n\nJohn Bradley\nSenior Technical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A008A08": {"ttr": 10253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x03\\x02\\xe0\\x02\\xe0\\x00\\x00\\xe5\\xe2\\xc1\\xd4\\xe4\\xd7\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:03:58", "lines": 736, "newlines": 736, "modlines": 0, "user": "VSAMUPD"}, "text": "Print records from a VSAM object\n\nThis is an Assembler program that prints the records from a\nVSAM object. The program prints using the over/under style\n(which I prefer to the IDCAMS PRINT DUMP option) - see\nFigure 1.\n\nBy default, all the records from the input object will be printed.\nTo print a range, an optional job step parameter must be\nprovided. The parameter specifies the start and stop record\nnumbers, expressed as nine-digit integers. The input object\nmay not contain spanned records because locate mode\nprocessing is performed.\n\nSuggested JCL to print all data component records (by default):\n\n//       EXEC PGM=VSAMRECP\n//SYSUDUMP DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//VSAM     DD DSN=CLUSTER.NAME,DISP=SHR\n\nTo print a specific component's records:\n\n//VSAM     DD DSN=CLUSTER.NAME.INDEX,DISP=SHR\n\nor:\n\n//VSAM     DD DSN=CLUSTER.NAME.DATA,DISP=SHR\n\nSuggested JCL to print a range of data component records:\n\n//       EXEC PGM=VSAMRECP,PARM='000000001000000010'\n//SYSUDUMP DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//VSAM     DD DSN=CLUSTER.NAME,DISP=SHR\n\nThis will cause the first 10 records from the data component of\nthe named cluster to be printed.\n\nThe program prints 100 bytes of data per 'pass'. The\ncalculation to determine the number of 'passes' required to\nprint the whole record is rather primitive, and relies on the\nlargest record not exceeding 1,000,000 bytes. The method is to\ndivide the record length by 101 and add 1. Any remainder\ngenerated is ignored ((length/101) + 1).\n\nThis works fine unless the record is greater than 10,000 bytes\nwhen an additional 1 must be added to the result ((length/101)\n+ 2).\n\nIf the record is greater than 1,000,000 bytes, an additional\nunitary incrementation must be performed ((length/101) + 3).\n\nThis will not happen, because this program utilizes locate mode\nprocessing. Therefore, the largest permitted record size is\n32,761 bytes because VSAM's largest CI size is 32,768 bytes.\n\nVSAMRECP TITLE 'PROGRAM FOR PRINTING VSAM RECORDS'\n         PRINT NOGEN\n         SPACE 1\n*        PROGRAM ATTRIBUTES: REENTRANT\n         TITLE 'MACROS, DSECTS AND CONTROL BLOCKS USED'\n*        ABEND                          ABEND THE PROGRAM\n*        CLOSE          MF=E            CLOSE FILE(S)\n*        DCB                            DATA CONTROL BLOCK\n*        DCBD (IHADCB)                  DCB DSECT MAPPING\n*        FREEMAIN                       RELEASE STORAGE\n*        FREEPOOL                       RELEASE BUFFER POOL\n*        GENCB          MF=G            GENERATE A VSAM CONTROL BLOCK\n*        GET - VSAM                     ACCESS A RECORD\n*        GETMAIN                        ACQUIRE STORAGE\n*        IEFJFCBN                       JFCB MAPPING\n*        IFGACB                         ACB DSECT MAPPING\n*        MODCB          MF=G            MODIFY A VSAM CONTROL BLOCK\n*        OPEN           MF=L/E          PREPARE FILE(S) FOR PROCESSING\n*        PUT - QSAM                     WRITE A RECORD\n*        RDJFCB         MF=E            READ SPECIFIC JFCB\n*        SHOWCB         MF=G            OBTAIN DATA FOR VSAM OBJECT\n*        TESTCB         MF=L/E          TEST A VSAM CONTROL BLOCK\n*        WTO            MF=L/E          WRITE TO OPERATOR\n         SPACE 2\n*        REGISTER EQUATES\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         TITLE 'PROGRAM INITIALIZATION CODE'\n*        1.    PROGRAM PROLOG\n*        2.    PROCESS THE JOB STEP PARAMETER, IF PRESENT\n*        3.    PERFORM PROGRAM INITIALIZATION\n*        4.    PERFORM MAIN PROGRAM PROCESSING\n*        5.    PERFORM PROGRAM TERMINATION PROCESSING\n*        6.    PROGRAM EPILOG\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . -> DYNAMIC AREA\n*        3                              . LENGTH OF DYNAMIC AREA\n*        10                             . BRANCH AND SAVE\n*        11                             . CSECT BASE REGISTER 1\n*        12                             . CSECT BASE REGISTER 2\n*        13                             . -> SAVE AREA\n*        14                             . -> RETURN\n*        15                             . -> ENTRY POINT\n         SPACE 2\nVSAMRECP CSECT\n         STM   R14,R12,12(R13)          . SAVE CALLER'S REGISTERS\n         LR    R11,R15                  . LOAD 11 AS PROGRAM BASE\n         USING VSAMRECP,R11,R12         . ESTABLISH ADDRESSABILITY\n         LA    R12,4095(,R11)           . ESTABLISH SECOND BASE\n         LA    R12,1(,R12)              .   REGISTER\n         LA    R3,WORKL                 . 3 - LENGTH OF DYNAMIC AREA\n         GETMAIN R,                     . GETMAIN FOR DYNAMIC AREA     C\n               LV=(R3)\n         ST    R13,4(,R1)               . BACKWARD SAVE AREA ->\n         ST    R1,8(,R13)               . FORWARD SAVE AREA ->\n         LR    R13,R1                   . 13 -> PROGRAM'S DYNAMIC AREA\n         USING WORKAREA,R13             . ESTABLISH ADDRESSABILITY\n         BAS   R10,JOBPARM              . PROCESS JOB STEP PARAMETER\n         BAS   R10,INITIAL              . PROGRAM INITIALIZATION\n         BAS   R10,MAINPROC             . MAIN PROCESSING LOGIC\n         BAS   R10,TERMIN               . PROGRAM TERMINATION\n         LA    R3,WORKL                 . 3 - LENGTH OF DYNAMIC AREA\n         LR    R2,R13                   . 2 -> DYNAMIC AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN DYNAMIC AREA        C\n               A=(R2),                                                 C\n               LV=(R3)\n         L     R14,12(,R13)             . 14 -> RETURN\n         SLR   R15,R15                  . 15 - ZERO\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         TITLE 'PROCESS OPTIONAL JOB STEP PARAMETER'\n*        1.    ACCESS JOB STEP PARAMETER\n*        2.    IF LENGTH ZERO, DEFAULT TO ALL RECORDS\n*        3.    IF LENGTH NON-ZERO, EDIT FOR NUMERIC DATA\n*        4.    IF NON-NUMERIC DATA ENTERED, ABEND\n*\n*        REGISTER USAGE\n*        1                              . WORK\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nJOBPARM  EQU   *\n         MVI   PARM,OFF                 . SWITCH OFF PARAMETER SWITCH\n         L     R1,4(,R13)               . 1 -> CALLER'S SAVE AREA\n         L     R1,24(,R1)               . 1 - CALLER'S REGISTER 1 VALUE\n         L     R1,0(,R1)                . 1 -> JOB STEP PARAMETER\n         OC    0(2,R1),0(R1)            . Q. PARAMETER PRESENT?\n         BZR   R10                      . A. NO - EXIT\n         MVC   TEST(18),ZEROS           . EDIT PARAMETER FOR NUMERIC\n         MVZ   TEST(18),2(R1)\n         CLC   TEST(18),ZEROS           . Q. ZONE BYTES ALL 'F'?\n         BNE   B0001                    . A. NO - ABEND\n         PACK  FROM#(5),2(9,R1)         . SAVE STARTING RECORD NUMBER\n         PACK  TO#(5),11(9,R1)          . SAVE ENDING RECORD NUMBER\n         MVI   PARM,ON                  . INDICATE VALID PARAMETER\n         BR    R10                      . EXIT\nB0001    EQU   *\n*                                       . NON-NUMERIC PARAMETER\n         WTO   MF=(E,WTO1)              . ISSUE WTO\n         ABEND 101,                                                    C\n               DUMP\n         TITLE 'PROGRAM INITIALIZATION LOGIC'\n*        1.    ISSUE READ JFCB FOR DSN OF INPUT FILE\n*        2.    INITIALIZE DATA AREAS\n*        3.    ACQUIRE STORAGE FOR A GENCB PARAMETER LIST\n*        4.    GENERATE AN ACB\n*        5.    GENERATE AN EXIT LIST\n*        6.    MODIFY THE ACB TO POINT TO THE EXIT LIST\n*        7.    OPEN THE FILES AND CHECK THE OPENS\n*        8.    DETERMINE IF SPANNED RECORDS ARE PERMITTED\n*        9.    DETERMINE OBJECT ORGANIZATION\n*        10.   IF OBJECT IS NOT AN ESDS, MODIFY ACB FOR KEYED\n*              ACCESS\n*        11.   IF OBJECT IS A KSDS, DETERMINE KEY LENGTH\n*        12.   IF OBJECT IS NOT AN ESDS, ACQUIRE STORAGE FOR KEY\n*        13.   GENERATE AN RPL\n*        14.   IF OBJECT IS AN ESDS, MODIFY THE RPL FOR ADDRESSED\n*              PROCESSING\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . -> JFCB\n*                                       . -> ACB\n*        3                              . -> DCB EXIT\n*                                       . -> EXIT LIST\n*                                       . KEY LENGTH\n*                                       . -> KEY LENGTH\n*                                       . -> RPL\n*        4                              . -> DCB\n*        5                              . -> RECORD ADDRESS\n*        6                              . LENGTH ADD. PARAMETER LIST\n*                                       . -> ADDITIONAL PARAMETER LIST\n*        9                              . LENGTH OF PARAMETER LIST\n*                                       . -> PARAMETER LIST\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nINITIAL  EQU   *\n         LA    R4,DDDCB                 . 4 -> DCB IN DYNAMIC AREA\n         USING IHADCB,R4                . USE DSECT MAPPING\n         MVC   DDDCB(DCBLEN),DUMMYDCB   . MOVE IN DUMMY DCB FOR JFCB\n         LA    R3,DCBEXIT               . 3 -> DCB EXIT LIST\n         LA    R2,INFMJFCB              . 2 -> JFCB MAPPING\n         ST    R2,0(,R3)                . SAVE IN DCB EXIT\n         MVI   0(R3),X'87'              . INITIALIZE HIGH-ORDER BYTE\n         ST    R3,DCBEXLST              . ZAP EXIT LIST IN DCB\n         MVI   DMAL,X'80'               . ZAP DATA MANAGEMENT ADDRESS\n         RDJFCB ((R4)),                 . ISSUE RDJFCB                 C\n               MF=(E,DMAL)\n         LTR   R15,R15                  . Q. RDJFCB SUCCESSFUL?\n         BNZ   C0001                    . A. NO\n         MVC   DSN,JFCBDSNM             . SAVE DSNAME\nC0001    EQU   *\n         ZAP   #PRINT,=P'+0'            . NUMBER OF RECORDS PRINTED\n         ZAP   #READ,=P'+0'             . NUMBER OF RECORDS READ\n         ZAP   #LINE,=P'+60'            . NUMBER OF LINES ON PAGE\n         ZAP   #PAGE,=P'+1'             . PAGE NUMBER\n         MVI   OUTLINE,C' '             . OUTPUT REPORT LINE\n         MVC   OUTLINE+1(132),OUTLINE\n         LA    R9,GENRPL                . 9 - LENGTH OF LONGEST\n*                                       .   PARAMETER LIST\n         GETMAIN R,                     . GET PARAMETER LIST STORAGE   C\n               LV=(R9)\n         LR    R9,R1                    . 9 -> PARAMETER LIST STORAGE\n         GENCB BLK=ACB,                 . GENERATE ACB                 C\n               AM=VSAM,                                                C\n               DDNAME=VSAM,                                            C\n               MACRF=(SEQ,IN),                                         C\n               MF=(G,(R9))\n         ST    R1,@ACB                  . SAVE ACB ADDRESS\n         GENCB BLK=EXLST,               . GENERATE EXIT LIST           C\n               AM=VSAM,                                                C\n               EODAD=D0007,                                            C\n               MF=(G,(R9))\n         ST    R1,@EXIT                 . SAVE EXIT LIST ADDRESS\n         L     R2,@ACB                  . 2 -> ACB\n         LR    R3,R1                    . 3 -> EXIT\n         MODCB ACB=(R2),                . MODIFY ACB TO INCLUDE EXIT   C\n               EXLST=(R3),                                             C\n               MF=(G,(R9))\n*                                       . OPEN FILES\n         MVC   DDDCB(DCBLEN),SYSPRINT   . MOVE DCB MASK INTO DYNAMIC\n         MVC   DMAL(8),OPEN             . ZAP DATA MANAGEMENT ADDRESS\n         OPEN  ((R2),,(R4),OUTPUT),                                    C\n               MF=(E,DMAL)\n         LTR   R15,R15                  . Q. OPENS OKAY?\n         BZ    C0002                    . A. YES\n         TM    DCBOFLGS,DCBOFOPN        . Q. SYSPRINT OPEN OKAY?\n         BNO   C0005                    . A. NO - OPEN FAILED\n         USING IFGACB,R2                . ACB DSECT ADDRESSABILITY\n         TM    ACBOFLGS,ACBOPEN         . Q. VSAM OPEN OKAY?\n         BNO   C0006                    . A. NO - OPEN FAILED\n         DROP  R2                       . ACB DSECT NOT REQUIRED\nC0002    EQU   *\n         TESTCB ACB=(R2),               . ESTABLISH SHARED PARAMETER   C\n               ATRB=SPAN,               .   LIST                       C\n               MF=(L,(R9))\n         TESTCB ACB=(R2),               . Q. SPANNED RECORDS ALLOWED?  C\n               MF=(E,(R9))\n         BE    C0007                    . A. YES - TERMINATE PROCESSING\n         MVI   OBJTYP,C'E'              . DEFAULT TO ESDS\n         LA    R3,4                     . DEFAULT KEY LENGTH 4 BYTES\n         ST    R3,#KEY\n         TESTCB ACB=(R2),               . Q. INPUT AN ESDS?            C\n               ATRB=ESDS,                                              C\n               MF=(E,(R9))\n         BE    C0003                    . A. YES\n         MVI   OBJTYP,C'R'\n         LA    R6,MODKEY                . 6 - LENGTH OF STORAGE\n         GETMAIN R,                     . GET STORAGE AREA FOR         C\n               LV=(R6)                  .   ADDITIONAL PARAMETER LIST\n         LR    R6,R1                    . 6 -> STORAGE AREA\n         MODCB ACB=(R2),                . ADD MACRF OF KEY FOR RRDS    C\n               MACRF=KEY,               .   AND KSDS                   C\n               MF=(G,(R6),MODKEY)\n         LA    R4,MODKEY                . 4 - LENGTH OF STORAGE\n         FREEMAIN R,                    . ADDITIONAL PARAMETER LIST    C\n               LV=(R4),                 .   NOT REQUIRED - RELEASE     C\n               A=(R6)\n         TESTCB ACB=(R2),               . Q. INPUT A RRDS?             C\n               ATRB=RRDS,                                              C\n               MF=(E,(R9))\n         BE    C0003                    . A. YES\n         MVI   OBJTYP,C'K'              . INPUT IS KSDS\n         LA    R3,#KEY                  . 3 -> KEY LENGTH AREA\n         SHOWCB ACB=(R2),               . DETERMINE KEY LENGTH         C\n               AREA=(R3),                                              C\n               FIELDS=KEYLEN,                                          C\n               LENGTH=4,                                               C\n               MF=(G,(R9))\n         L     R3,#KEY                  . 3 - KEY LENGTH\nC0003    EQU   *\n         GETMAIN R,                     . GETMAIN FOR KEY AREA         C\n               LV=(R3)\n         ST    R1,@KEY                  . SAVE ADDRESS OF KEY AREA\n         LA    R5,@REC                  . 5 -> RECORD ADDRESS\n         LR    R3,R1                    . 3 -> KEY AREA\n         GENCB BLK=RPL,                 . GENERATE RPL                 C\n               ACB=(R2),                                               C\n               AM=VSAM,                                                C\n               AREA=(R5),                                              C\n               AREALEN=4,                                              C\n               ARG=(R3),                                               C\n               OPTCD=(SEQ,LOC),                                        C\n               MF=(G,(R9),GENRPL)\n         ST    R1,@RPL                  . SAVE RPL ADDRESS\n         CLI   OBJTYP,C'E'              . Q. INPUT AN ESDS?\n         BNE   C0004                    . A. NO\n         LR    R3,R1                    . 3 -> RPL\n         MODCB RPL=(R3),                . ADD OPTCD OF RBA FOR ESDS    C\n               OPTCD=ADR,                                              C\n               MF=(G,(R9))\nC0004    EQU   *\n         LA    R3,GENRPL                . 3 - LENGTH OF STORAGE\n         FREEMAIN R,                    . RELEASE STORAGE USED FOR     C\n               A=(R9),                  .   PARAMETER LIST             C\n               LV=(R3)\n         BR    R10                      . EXIT\n         TITLE 'PROGRAM INITIALIZATION - ERRORS'\nC0005    EQU   *\n*                                       . OPEN FAILURE SYSPRINT\n         WTO   MF=(E,WTO2)              . ISSUE WTO\n         LA    R3,WORKL                 . 3 - LENGTH OF DYNAMIC AREA\n         LR    R2,R13                   . 2 -> DYNAMIC AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN OF DYNAMIC AREA     C\n               A=(R2),                                                 C\n               LV=(R3)\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,10                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         SPACE 2\nC0006    EQU   *\n*                                       . OPEN FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         WTO   MF=(E,WTO3)              . ISSUE WTO\n         L     R2,@ACB                  . 2 -> ACB\n         LA    R3,OPENERR               . 3 -> ERROR CODE\n         LA    R9,SHOWERR               . 9 - LENGTH OF PARAMETER LIST\n         GETMAIN R,                     . ACQUIRE PARAMETER LIST AREA  C\n               LV=(R9)\n         LR    R9,R1                    . 9 -> PARAMETER LIST STORAGE\n         SHOWCB ACB=(R2),               . OBTAIN ACB ERROR CODE        C\n               AREA=(R3),                                              C\n               FIELDS=ERROR,                                           C\n               LENGTH=4,                                               C\n               MF=(G,(R9),SHOWERR)\n         LM    R2,R4,VSAMERR            . 2 - 4 VSAM ERROR CODES\n         ABEND 102,                     . ABEND THE TASK               C\n               DUMP\nC0007    EQU   *\n*                                       . ACB PERMITS SPANNED RECORDS\n         WTO   MF=(E,WTO4)              . ISSUE WTO\n         LA    R3,WORKL                 . 3 - LENGTH OF DYNAMIC AREA\n         LR    R2,R13                   . 2 -> DYNAMIC AREA\n         L     R13,4(,R13)              . 13 -> CALLER'S SAVE AREA\n         FREEMAIN R,                    . FREEMAIN OF DYNAMIC AREA     C\n               A=(R2),                                                 C\n               LV=(R3)\n         L     R14,12(,R13)             . 14 -> RETURN ADDRESS\n         LA    R15,20                   . 15 - RETURN CODE\n         LM    R0,R12,20(R13)           . RESTORE 0 - 12\n         BR    R14                      . RETURN\n         TITLE 'MAIN PROCESSING LOGIC OF PROGRAM'\n*        1.    GET THE NEXT LOGICAL RECORD\n*        2.    IF JOB STEP PARAMETER SPECIFIED, DETERMINE IF IN\n*              REQUIRED RANGE\n*        3.    DETERMINE THE LENGTH OF THE RECORD READ\n*        4.    PREPARE RECORD HEADING LINE\n*        5.    COMPUTE NUMBER OF \"PASSES\" TO PRINT RECORD\n*        6.    CHECK IF PAGE HEADINGS REQUIRED\n*        7.    FORMAT PRINT LINES\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . -> RPL\n*                                       . COMPUTATIONS\n*                                       . CVD INSTRUCTIONS\n*        3                              . -> RECORD LENGTH\n*                                       . COMPUTATION\n*                                       . NUMBER OF PRINT \"PASSES\"\n*        4                              . LENGTH OF PARAMETER LIST\n*                                       . -> POSITION IN RECORD\n*        5                              . NUMBER OF BYTES OF RECORD\n*                                       .   STILL TO PRINT\n*        6                              . -> OUTPUT DCB\n*        7                              . BYTES TO OUTPUT THIS LINE\n*        8                              . START BYTE # FOR LINE\n*                                       . END BYTE # FOR LINE\n*        9                              . -> PARAMETER LIST\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nMAINPROC EQU   *\n         LA    R6,DDDCB                 . 6 -> DCB IN DYNAMIC AREA\nD0001    EQU   *\n         L     R2,@RPL                  . 2 -> RPL\n         GET   RPL=(R2)                 . GET THE NEXT RECORD\n         LTR   R15,R15                  . Q. VSAM GET OKAY?\n         BNZ   D0008                    . A. NO - GET FAILED\n         AP    #READ,=P'+1'             . INCREMENT RECORDS READ\n         CLI   PARM,ON                  . Q. VALID JOB STEP PARAMETER?\n         BNE   D0002                    . A. NO - PRINT THE RECORD\n         CP    #READ,FROM#              . Q. BEFORE START OF RANGE?\n         BL    D0001                    . A. YES - READ NEXT RECORD\n         CP    #READ,TO#                . Q. BEYOND END OF RANGE?\n         BH    D0007                    . A. YES - TERMINATE PROCESSING\nD0002    EQU   *\n         MVC   CONT,=9C' '              . INDICATE START OF RECORD\n         LA    R3,LRECL                 . 3 -> RECORD LENGTH\n         LA    R4,SHOWREC               . 4 - LENGTH OF PARAMETER LIST\n         GETMAIN R,                     . ACQUIRE PARAMETER LIST AREA  C\n               LV=(R4)\n         LR    R9,R1                    . 9 -> PARAMETER LIST\n         SHOWCB RPL=(R2),               . GET THE CURRENT LOGICAL      C\n               AREA=(R3),               .   RECORD LENGTH              C\n               FIELDS=RECLEN,                                          C\n               LENGTH=4,                                               C\n               MF=(G,(R9),SHOWREC)\n         FREEMAIN R,                    . RELEASE PARAMETER LIST AREA  C\n               A=(R9),                                                 C\n               LV=(R4)\n*                                       . COMPUTE NUMBER OF PRINT\n*                                       .   \"PASSES\"\n         L     R3,LRECL                 . 3 - RECORD LENGTH\n         LR    R5,R3                    . 5 - RECORD LENGTH\n         LA    R7,1                     . 7 - ONE\n         C     R3,=F'+10000'            . Q. RECORD LENGTH > 10000?\n         BNH   *+8                      . A. NO\n         LA    R7,2                     . 7 - TWO\n         SLR   R2,R2                    . 2 - ZERO\n         D     R2,=F'+101'              . DIVIDE RECORD SIZE BY 101\n         AR    R3,R7                    . INCREMENT QUOTIENT BY\n*                                       .   CONTENT OF 7\n         L     R4,@REC                  . 4 -> RECORD\n         LA    R8,1                     . 8 - FIRST BYTE\nD0003    EQU   *\n*                                       . DETERMINE IF A FULL PRINT\n*                                       .   LINE IS REQUIRED\n         LA    R7,100                   . 7 - ONE HUNDRED\n         CR    R7,R5                    . Q. PARTIAL PRINT LINE?\n         BNH   D0004                    . A. NO\n         LR    R7,R5                    . 7 - AMOUNT TO BE PRINTED\nD0004    EQU   *\n*                                       . PAGE HEADING PROCESS\n         CP    #LINE,=P'+57'            . Q. HEADINGS REQUIRED?\n         BL    D0005                    . A. NO - HEADINGS NOT REQUIRED\n         MVC   LINE,TITLE               . MOVE TITLE INTO DYNAMIC AREA\n         MVC   LINE+124(6),MASK5        . OUTPUT PAGE NUMBER EDIT MASK\n         ED    LINE+124(6),#PAGE\n         MVC   LINE+67(44),DSN          . OUTPUT DATA SET NAME\n         PUT   (R6),                    . OUTPUT HEADINGS              C\n               LINE\n         PUT   (R6),                                                   C\n               STITLE1\n         PUT   (R6),                                                   C\n               STITLE2\n         MVC   LINE,STITLE3             . FORMAT RECORD HEADING\n         L     R2,LRECL                 . 2 - RECORD LENGTH\n         CVD   R2,WORKD\n         MVC   LINE+41(6),MASK5\n         ED    LINE+41(6),WORKD+5\n         MVC   LINE+15(10),MASK9        . RECORD NUMBER\n         ED    LINE+15(10),#READ\n         MVC   LINE+53(9),CONT\n         PUT   (R6),                    . OUTPUT RECORD HEADING        C\n               LINE\n         MVC   CONT,=C'CONTINUED'       . INDICATE CONTINUATION\n*                                       .   FOR NEXT TIME POSSIBLY\n         AP    #PAGE,=P'+1'             . INCREMENT PAGE NUMBER\n         ZAP   #LINE,=P'+6'             . RESET LINE NUMBER\n         B     D0006\nD0005    EQU   *\n         CLI   CONT,C'C'                . Q. REC NUMBER TO BE OUTPUT?\n         BE    D0006                    . A. NO\n         MVC   LINE,STITLE3             . FORMAT RECORD HEADING\n         L     R2,LRECL                 . 2 - RECORD LENGTH\n         CVD   R2,WORKD\n         MVC   LINE+41(6),MASK5\n         ED    LINE+41(6),WORKD+5\n         MVC   LINE+15(10),MASK9        . RECORD NUMBER\n         ED    LINE+15(10),#READ\n         MVC   LINE+53(9),CONT\n         PUT   (R6),                    . OUTPUT RECORD NUMBER         C\n               LINE\n         MVC   CONT,=C'CONTINUED'\n         AP    #LINE,=P'+2'             . INCREMENT LINES OUTPUT\nD0006    EQU   *\n*                                       . FORMAT PRINT LINES\n         MVI   OUTLINE,C'0'             . SET ASA CONTROL CHARACTER\n         BCTR  R7,R0                    . DECREMENT 7 BY ONE\n         MVC   BYTES,=C'BYTES'          . OUTPUT BYTE RANGE BEING\n         MVC   TO,=C' TO '              .   PRINTED\n         CVD   R8,WORKD                 . START BYTE\n         MVC   OUTSBYTE,MASK5\n         ED    OUTSBYTE,WORKD+5\n         LA    R8,0(R7,R8)              . INCREMENT 8 BY 7\n         CVD   R8,WORKD                 . END BYTE\n         MVC   OUTEBYTE,MASK5\n         ED    OUTEBYTE,WORKD+5\n         LA    R8,1(,R8)                . INCREMENT 8 BY ONE\n         EX    R7,MVC                   . OUTPUT EBCDIC DATA\n         TR    OUTLINED,PRTBL           . MAKE PRINTABLE\n         PUT   (R6),                    . OUTPUT CHARACTER DATA        C\n               OUTLINE\n         MVI   OUTLINE,C' '             . RESET ASA CONTROL CHARACTER\n         MVC   OUTLINE+1(132),OUTLINE\n         EX    R7,MVC                   . PROCESS ZONE NIBBLES\n         EX    R7,NCZ\n         EX    R7,TRZ\n         PUT   (R6),                    . OUTPUT ZONE NIBBLES          C\n               OUTLINE\n         EX    R7,MVC                   . PROCESS NUMERIC NIBBLES\n         EX    R7,NCN\n         EX    R7,TRN\n         PUT   (R6),                    . OUTPUT NUMERIC NIBBLES       C\n               OUTLINE\n         MVI   OUTLINED,C' '            . RE-INITIALIZE OUTPUT LINE\n         MVC   OUTLINED+1(99),OUTLINED\n         AP    #LINE,=P'+4'             . INCREMENT LINES PRINTED\n         LA    R4,100(,R4)              . INDEX ALONG INPUT RECORD\n         SH    R5,=H'+100'              . DECREMENT WHAT IS LEFT TO\n*                                       .   PRINT IN RECORD\n         BCT   R3,D0003                 . OUTPUT REST OF RECORD\n         AP    #PRINT,=P'+1'            . INCREMENT RECORDS PRINTED\n         B     D0001                    . GO GET NEXT RECORD\nD0007    EQU   *\n         BR    R10                      . EXIT\n         TITLE 'MAIN PROCESSING - GET ERROR'\nD0008    EQU   *\n*                                       . GET FAILURE VSAM\n         ST    R15,REG15                . SAVE 15\n         WTO   MF=(E,WTO5)              . ISSUE WTO\n         L     R2,@RPL                  . 2 -> RPL\n         LA    R3,RPLFDBK               . 3 -> FEED BACK CODE\n         LA    R9,SHOWFDB               . 9 - LENGTH OF PARAMETER LIST\n         GETMAIN R,                     . ACQUIRE PARAMETER LIST AREA  C\n               LV=(R9)\n         LR    R9,R1                    . 9 -> PARAMETER LIST STORAGE\n         SHOWCB RPL=(R2),               . OBTAIN RPL FEED BACK CODE    C\n               AREA=(R3),                                              C\n               FIELDS=FDBK,                                            C\n               LENGTH=4,                                               C\n               MF=(G,(R9),SHOWFDB)\n         LM    R2,R4,VSAMERR            . 2 - 4 VSAM ERROR CODES\n         ABEND 103,                     . ABEND TASK                   C\n               DUMP\n         TITLE 'END OF PROCESSING ROUTINE'\n*        1.    OUTPUT TOTALS\n*        2.    CLOSE FILES\n*        3.    RELEASE BUFFER POOL\n*\n*        REGISTER USAGE\n*        0                              . MACROS\n*        1                              . MACROS\n*        2                              . -> STORAGE AREA\n*                                       . -> ACB\n*        3                              . LENGTH STORAGE AREA\n*        6                              . -> DCB\n*        10                             . BRANCH AND SAVE\n         SPACE 2\nTERMIN   EQU   *\n         MVC   LINE,STITLE4             . PROGRAM EOJ\n         MVC   LINE+17(10),MASK9        . OUTPUT RECORDS PRINTED\n         ED    LINE+17(10),#PRINT\n         PUT   (R6),                                                   C\n               LINE\n         L     R2,@KEY                  . 2 -> KEY STORAGE\n         L     R3,#KEY                  . 3 - LENGTH OF KEY STORAGE\n         FREEMAIN R,                    . FREE KEY STORAGE             C\n               A=(R2),                                                 C\n               LV=(R3)\n         L     R2,@ACB                  . 2 -> ACB\n         MVC   DMAL(8),OPEN             . ZAP DATA MANAGEMENT ADDRESS\n*                                       .   LIST\n         CLOSE ((R2),,(R6)),            . CLOSE FILES                  C\n               MF=(E,DMAL)\n         FREEPOOL (R6)                  . RELEASE BUFFER POOL\n         BR    R10\n         TITLE 'EXECUTED INSTRUCTIONS AND LIST FORM INSTRUCTIONS'\n*                                       . EXECUTED INSTRUCTIONS\nMVC      MVC   OUTLINED(0),0(R4)\nNCN      NC    OUTLINED(0),=100X'0F'\nNCZ      NC    OUTLINED(0),=100X'F0'\nTRN      TR    OUTLINED(0),NUMTBL\nTRZ      TR    OUTLINED(0),ZONETBL\n*                                       . LIST FORM INSTRUCTIONS\nOPEN     OPEN  (,,,),                                                  C\n               MF=L\nWTO1     WTO   'JOB STEP PARAMETER NOT NUMERIC',                       C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO2     WTO   'OPEN FAILURE FOR FILE SYSPRINT',                       C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO3     WTO   'OPEN FAILURE FOR FILE VSAM',                           C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO4     WTO   'OBJECT PERMITS SPANNED RECORDS',                       C\n               ROUTCDE=11,                                             C\n               MF=L\nWTO5     WTO   'GET FAILURE FOR FILE VSAM',                            C\n               ROUTCDE=11,                                             C\n               MF=L\n         TITLE 'DATA AREAS'\n*                                       . PRINT LINES\nTITLE    DC    CL21'1'\n         DC    CL46'HEXADECIMAL AND CHARACTER LISTING OF DATASET: '\n         DS    CL44\n         DC    CL9' '\n         DC    CL4'PAGE'\n         DS    CL6\n         DC    CL3' '\nSTITLE1  DC    CL33' '\n         DC    CL50'         1         2         3         4         5'\n         DC    CL50'         6         7         8         9         0'\nSTITLE2  DC    CL33' '\n         DC    CL50'12345678901234567890123456789012345678901234567890'\n         DC    CL50'12345678901234567890123456789012345678901234567890'\nSTITLE3  DC    CL15'0RECORD NUMBER '\n         DS    CL10\n         DC    CL16'    RECORD SIZE '\n         DS    CL6\n         DC    CL6' '\n         DS    CL9\n         DC    CL71' '\nSTITLE4  DC    CL17'-RECORDS PRINTED '\nRECOUT   DC    CL10' '\n         DC    CL106' '\nMASK5    DC    X'402020202120'          . EDIT MASK\nMASK9    DC    X'40202020202020202120'  . EDIT MASK\nZEROS    DC    18C'0'\n         TITLE 'TRANSLATE TABLES'\nNUMTBL   DC    C'0123456789ABCDEF'\nZONETBL  DC    C'0',15C'*',C'1',15C'*',C'2',15C'*',C'3',15C'*'\n         DC    C'4',15C'*',C'5',15C'*',C'6',15C'*',C'7',15C'*'\n         DC    C'8',15C'*',C'9',15C'*',C'A',15C'*',C'B',15C'*'\n         DC    C'C',15C'*',C'D',15C'*',C'E',15C'*',C'F',15C'*'\nPRTBL    DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'404B4B4B4B4B4B4B4B4B4A4B4C4D4E4F'\n         DC    X'504B4B4B4B4B4B4B4B4B5A5B5C5D5E5F'\n         DC    X'60614B4B4B4B4B4B4B4B4B6B6C6D6E6F'\n         DC    X'4B4B4B4B4B4B4B4B4B4B7A7B7C7D7E7F'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    X'4BC1C2C3C4C5C6C7C8C94B4B4B4B4B4B'\n         DC    X'4BD1D2D3D4D5D6D7D8D94B4B4B4B4B4B'\n         DC    X'4B4BE2E3E4E5E6E7E8E94B4B4B4B4B4B'\n         DC    X'F0F1F2F3F4F5F6F7F8F94B4B4B4B4B4B'\n         TITLE 'CONTROL BLOCKS'\nSYSPRINT DCB   BLKSIZE=15428,                                          C\n               DDNAME=SYSPRINT,                                        C\n               DSORG=PS,                                               C\n               LRECL=133,                                              C\n               MACRF=PM,                                               C\n               RECFM=ABFS\nDCBLEN   EQU   *-SYSPRINT               . LENGTH OF DCB\nDUMMYDCB DCB   DDNAME=VSAM,             . DUMMY DCB FOR RDJFCB         C\n               DSORG=PS,                                               C\n               MACRF=GM\n         TITLE 'DUMMY SECTIONS'\nWORKAREA DSECT                          . DYNAMIC AREA\n         DS    18F                      . STANDARD OS SAVE AREA\nWORKD    DS    D                        . USED FOR CVD INSTRUCTIONS\n@ACB     DS    F                        . ADDRESS OF ACB\n@EXIT    DS    F                        . ADDRESS OF EXIT LIST\n@KEY     DS    F                        . ADDRESS OF KEY AREA\n@REC     DS    F                        . ADDRESS OF RECORD READ\n@RPL     DS    F                        . ADDRESS OF RPL\n#KEY     DS    F                        . NUMBER OF BYTES IN KEY\nDCBEXIT  DS    F                        . DCB EXIT USED RDJFCB\nDMAL     DS    2F                       . DATA MANAGEMENT ADDRESS LIST\nLRECL    DS    F                        . LENGTH OF RECORD READ\nVSAMERR  DS    0F                       . VSAM ERROR AREA\nREG15    DS    F                        . CONTENT OF REGISTER 15\nOPENERR  DS    F                        . ACB ERROR CODE\nRPLFDBK  DS    F                        . RPL FEED BACK CODE\nOBJTYP   DS    C                        . TYPE OF OBJECT\nPARM     DS    C                        . JOB STEP PARAMETER INDICATOR\nON       EQU   X'01'                    . LOGICAL ON\nOFF      EQU   X'00'                    . LOGICAL OFF\n#READ    DS    PL5                      . NUMBER OF RECORDS READ\n#PRINT   DS    PL5                      . NUMBER OF RECORDS PRINTED\nFROM#    DS    PL5                      . START OF RANGE\nTO#      DS    PL5                      . END OF RANGE\n#LINE    DS    PL2                      . LINE COUNTER\n#PAGE    DS    PL3                      . PAGE COUNTER\nCONT     DS    CL9                      . RECORD CONTINUATION OVER PAGE\nTEST     DS    CL18                     . NUMERIC TEST WORK AREA\nDSN      DS    CL44                     . DATA SET NAME FROM JFCB\nLINE     DS    CL133                    . OUTPUT PRINT LINE - TITLES\nOUTLINE  DS    CL7                      . OUTPUT DATA LINE\nBYTES    DS    CL5\nOUTSBYTE DS    CL6\nTO       DS    CL4\nOUTEBYTE DS    CL6\n         DS    CL5\nOUTLINED DS    CL100\n         DS    0F\nDDDCB    DS    CL(DCBLEN)               . AREA FOR DCB\n         DS    0F\n         IEFJFCBN                       . JFCB MAPPING\nWORKL    EQU   *-WORKAREA               . LENGTH OF DYNAMIC AREA\n         DCBD  DEVD=DA,                 . DSECT MAPPING DCB            C\n               DSORG=PS\n         IFGACB                         . DSECT MAPPING ACB\n         TITLE 'LITERALS AND TERMINATION'\nVSAMRECP CSECT                          . RE-ESTABLISH CSECT\n         LTORG\n         END\n\n\nDave Loveluck\nInstructor/Consultant (USA)                        c Dave Loveluck 1993\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT945/FILE945.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT945", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}