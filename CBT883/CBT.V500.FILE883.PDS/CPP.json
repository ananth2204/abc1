{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "RACF", "INMTNODE": "JES2P390", "INMTUID": "ESA", "INMFTIME": "20121220175748000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 266240, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 255, "INMBLKSZ": 32760, "INMRECFM": "VB", "INMDIR": 1, "INMDSNAM": "ESA.PRJ.CBTHSM.CPP", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 266240, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 266240, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ESA.PRJ.CBTHSM.CPP": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32760, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\x03\\xb0\\x88\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0\\x88\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0\\x88\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"CASMIF": {"ttr": 203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x05\\x01\\x125_\\x01\\x125_\\x18P\\x03)\\x03#\\x00\\x00\\xd9\\xc1\\xc3\\xc6@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2012-12-20T00:00:00", "modifydate": "2012-12-20T18:50:05", "lines": 809, "newlines": 803, "modlines": 0, "user": "RACF"}, "text": "\n/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/casmif.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n#if  defined(OWN_STDIO) == 1\n#include \"stdio.hpp\"\n//#include \"crctable.hpp\"\n#include \"filesys.hpp\"\n#endif\n\n#include \"casmif.hpp\"\n#include \"mchain.hpp\"\n#include \"merror.hpp\"\n#include \"mvsbase.hpp\"\n#include \"mvstime.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0  //szm\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"msgmgr.hpp\"\n#ifndef OWN_STDIO\n#include <assert.h>\n#endif\n\nISIS_EXT_ASM unsigned int ASMIF(void *);\nstatic pMvsInterface  _mvsInterface\u00c4\u00dc = \u00e40,0,0,0,0,0,0,0\u00fc;\nstatic pcsul          _tcb\u00c4\u00dc         = \u00e40,0,0,0,0,0,0,0\u00fc;\n//szm20081215 zIIP\nbool MvsInterface::zIIP = getenv(\"ISIS_ZIIP_SUPPORT\")?true:false;\npcsul  MvsInterface::wlmEnclave = 0;\n//szm20081215 zIIP\n\n//ZA030610 always 8\nstatic int            MAX_TCB        = 8;\nstatic char CRITICAL_MAJOR\u00c4\u00dc = \"ASM__MVS\";\nstatic char CRITICAL_MINOR\u00c4\u00dc = \"ASM__MVS__CRITICAL\";\nstatic char MSG_MAJOR\u00c4\u00dc      = \"ASM__MSG\";\nstatic char MSG_MINOR\u00c4\u00dc      = \"OMSMSGMN\";\nstatic char ASM_MAJOR\u00c4\u00dc      = \"OMS     \";\nstatic char ASM_MSG\u00c4\u00dc        = \"ASM_MSG\";\nstatic char WAIT_MAJOR\u00c4\u00dc     = \"ASM_WAIT\";\nstatic char POST_MAJOR\u00c4\u00dc     = \"ASM_POST\";\n#ifndef sym_init\n#define sym_init -1\n#endif\n\n//20060418MessageTEXT * messagetext = NULL; //szm2041120\n\nstatic int _init_messagetext = initMessageText();\n\nint  GlobalTraceFlag = getenv(\"TRACE\") ? atoi(getenv(\"TRACE\")):0;\nint  GlobalCicsFlag  = 0;\nstatic char* MSGQ    = getenv(\"MSGQ\") ? getenv(\"MSGQ\"):\"SASO\";\nstatic int   MvsTimer_status = 0;\n\nstatic void btracef(const char * text)\n \u00e4\n printf(\" %s \u00d6n\",text);\n \u00fc\n\n\nstatic int CompareAndSwap(pcsul &p1,pcsul p2,void *p3)\n \u00e4\n // if ( p1 == *p3 ) *p3 = p2\n // else p1 = *p3\n return 1;\n \u00fc\n\n#if (MEM_SUPPORT)\n//\n//------------------------------------------------------------------------------\n//\n\nvoid * OwnRealloc(void *a, size_t size)\n \u00e4\n if ( size == 0 )\n  return NULL;\n else if ( a == NULL )\n  return (OwnMalloc(size));\n void * n = OwnMalloc(size);\n if ( NOT n ) return NULL;\n size_t oldsize =*((int *)a-2)-16;\n assert(oldsize > 0);\n if ( oldsize < size )\n  memcpy(n,a,oldsize);\n else\n  memcpy(n,a,size);\n OwnFree(a);\n return n;\n \u00fc\n#endif\n/*-----------------------------------------------------------------\nMvsInterface\n------------------------------------------------------------------*/\n\nvoid MvsInterface::trace(char * t)\n \u00e4\n if ( GlobalTraceFlag && file )\n  fprintf(file,\"%s\u00d6n\",t);\n \u00fc\n\nvoid MvsInterface::tracedump(char * t,void * bv,int  bl)\n \u00e4\n if ( GlobalTraceFlag )\n  \u00e4\n  if ( file )\n   fprintf(file,\"%s === %p\u00d6n\",t,bv);\n  char p\u00c4512\u00dc;\n  char * b = (char *)bv;\n  for(int o = 0;o<=bl;o+=16)\n   \u00e4\n   dump(p,o,b,bl);\n   fprintf(file,\"%s %s \u00d6n\",DatetoString(),p);\n   \u00fc\n  \u00fc\n \u00fc\n\nvoid MvsInterface::extractOper(char * text)\n \u00e4\n mvsSTRING s(text), p1, p2, st;\n s.parse(p1,\"=\",st,\" \",p2);\n while ( st.lengthOf() )\n  \u00e4\n  char* c = strchr((char *)st,'=');\n  if ( c )\n   *c = 0;\n  else\n   c = \" 1\";\n  if ( strcmp(st,\"TRACE\") == 0)\n   GlobalTraceFlag = atoi(getenv(\"TRACE\"));\n  s = p1+p2;\n  s.parse(p1,\" =\",st,\" \",p2);\n  \u00fc\n strcpy(text,s);\n \u00fc\n\n/*-----------------------------------------------------------------\nMvsStcInterface\n------------------------------------------------------------------*/\n\nchar * function_name_table\u00c4\u00dc  = \u00e4\n \"CLEANUP\",\n \"GETTOKEN\",\n \"CREATETOKEN\",\n \"DELETETOKEN\",\n \"ALLOCATEPAGES\",\n \"FREEPAGES\",\n \"ENQ\",\n \"DEQ\",\n \"SLEEP\",\n \"GETECB\",\n \"WAIT\",\n \"POST\",\n \"RESET\",\n \"SELECT\",\n \"CONNECTSHMEM\",\n \"DISCONNECTSHMEM\",\n \"OPER\",\n \"WTO\",\n \"MALLOC\",\n \"FREE\",\n \"SVC\",\n \"ATTCHMVS\",\n \"CLOCK\",\n \"TIMEUSED\",    //szm0050301\n \"TDUMP\",       //szm\n \"LOGGER\",\n \"VTOC\",\n \"SRB\",\n \"WLM\",\n \"OBTAIN\",\n \"TESTAUTH\",\n \"DIAGNOSE\",\n \"VSMLIST\",\n NULL\n \u00fc;\n\n\nMvsInterface::MvsInterface()\n \u00e4\n srb = false;\n jobname\u00c48\u00dc = programname\u00c48\u00dc = 0x00;\n if ( GlobalTraceFlag && NOT GlobalCicsFlag )\n  \u00e4\n  file  = fopen(\"SYSPRINT\",\"w\");\n  \u00fc\n else file = 0;\n CASMIF(sym_init);\n memcpy(jobname,pASM->asm_jobname,8);\n memcpy(programname,pASM->asm_programname,8);\n // TRACE(4,Msg(9503)<<\">MvsInterface\"<<jobname<<programname<<eol);\n \u00fc\n\nMvsInterface::\u00dfMvsInterface()\n \u00e4\n if ( file ) fclose(file);\n CASMIF(sym_cleanup);\n pASM = 0;\n TRACE(4,SMsg(9501)<<\"<MvsInterface\"<<eol);\n \u00fc\n\nint MvsInterface::TCPCALL(int      function,\n             void *   p0,void *   p1,void *   p2,void * p3,\n             void *   p4,void *   p5,void *   p6,void * p7)\n \u00e4\n CASMIF(function,p0,p1,p2,p3,\n  p4,p5,p6,p7);\n#if 0\n if ( rc == -1 )\n  \u00e4\n  CASMIF(sym_lasterror);\n  TRACE(1,Msg(9502)<<\">Socket errror\"<<int(rc)<<eol);\n  MsgEnq();\n  Msg(9511)<<function_name_table\u00c4function\u00dc\n  <<\" code:\"<<rc<<eol;\n  MsgDeq();\n  return -1;\n  \u00fc\n#endif\n return rc;\n \u00fc\n\nint MvsInterface::CASMIF(int      function,\n             void * p0,void * p1,void * p2,void *p3,\n             void * p4,void * p5,void * p6,void *p7)\n \u00e4\n if (function == sym_init)\n  \u00e4\n  pASM = (pasm)ASMIF(0);\n  assert(pASM);\n  pASM->asm_mvs = this;\n  \u00fc\n else\n  \u00e4\n  pASM->asm_function_code = char(function);\n  pASM->asm_parms\u00c40\u00dc= p0;\n  pASM->asm_parms\u00c41\u00dc= p1;\n  pASM->asm_parms\u00c42\u00dc= p2;\n  pASM->asm_parms\u00c43\u00dc= p3;\n  pASM->asm_parms\u00c44\u00dc= p4;\n  pASM->asm_parms\u00c45\u00dc= p5;\n  pASM->asm_parms\u00c46\u00dc= p6;\n  pASM->asm_parms\u00c47\u00dc= p7;\n  ASMIF(pASM);\n  rc = int(pASM->asm_rc);\n  reason = int(pASM->asm_reason);\n  //printf(\" RC:%d reason:%d  function:%s\\n\",rc,reason,function_name_table\u00c4function\u00dc);\n  //szm20030616 no check for ENQ/DEQ\n  if ( function NEQ sym_sleep &&  function NEQ sym_wait && function NEQ sym_attachmvs\n   && function NEQ sym_svc &&  function NEQ sym_clock && function NEQ sym_logger && function NEQ sym_wlm\n   && function NEQ sym_srb   // no check for SRB\n   &&function NEQ sym_obtain)\n   check(rc,function,\" CASMIF \");\n  else\n  \u00e4\n  //printf(\" RC:%d reason:%d  function:%s\\n\",rc,reason,function_name_table\u00c4function\u00dc);\n   return (rc);\n   \u00fc\n  \u00fc\n return (rc==0);\n \u00fc\nint MvsInterface::check(int r,char *function,char * action)\n \u00e4\n char hex\u00c49\u00dc;\n sprintf(hex,\"%8.8x\",reason);\n if ( GlobalTraceFlag == 4 )\n  TRACE(4,SMsg(9505)<<\" Checking \"<<rc<<hex<<function<<action<<eol);\n if ( r )\n  \u00e4\n  MsgEnq();\n  Msg(9510)<<function<<action<<r<<eol;\n  MsgDeq();\n  \u00fc\n return r;\n \u00fc\n\n\nint MvsInterface::check(int r,int function,char * action)\n \u00e4\n\n char hex\u00c49\u00dc;\n sprintf(hex,\"%8.8x\",reason);\n char hexrsn\u00c49\u00dc;\n sprintf(hexrsn,\"%8.8x\",pASM->asm_bpx1_rsncode);\n if ( GlobalTraceFlag == 4 )\n  TRACE(4,SMsg(9505)<<\" Checking \"<<int(rc)<<hex<<\n  function_name_table\u00c4function\u00dc<<action<<eol);\n if ( r )\n  \u00e4\n  switch(function)\n   \u00e4\n   case sym_select:      if ( r < 0 )\n    \u00e4\n    MsgEnq();\n    Msg(9510)<<function_name_table\u00c4function\u00dc<<\n     hex<<hexrsn<<eol;\n    MsgDeq();\n    \u00fc\n              break;\n   case sym_enq:         if ( r == -1 ) break;\n   case sym_wait:        if ( r == -1 ) break;\n   case sym_gettoken:    if ( r == 4 ) break;\n   case sym_deletetoken: if ( r == 4 ) break;\n   case sym_disconnectshmem: if ( r == 4 ) break;\n   case sym_vtoc:        if ( r ==4 ) break;\n   default:\n    MsgEnq();\n    Msg(9510)<<function_name_table\u00c4function\u00dc<<\n     r<<hex<<eol;\n    MsgDeq();\n   \u00fc\n  \u00fc\n return r;\n \u00fc\n\n\npcsul MvsInterface::GetTCB()\n \u00e4\n return (*(pcsul *)PSATOLD);\n \u00fc\n\npcsul MvsInterface::GetASCB()\n \u00e4\n return(*(pcsul *)PSAAOLD);\n \u00fc\n\nint MvsInterface::CheckASCB(pcsul ascb)\n \u00e4\n return(NOT (memcmp(\"ASCB\",(char *)ascb,4)));\n \u00fc\n\npcsul MvsInterface::GetToken(char * n)\n \u00e4\n TRACE(4,SMsg(9502)<<\">GetToken\"<<n<<eol);\n if ( n  &&  CASMIF(sym_gettoken,n,wt))\n  \u00e4\n  TRACEDUMP(4,SMsg(9501)<<\"<GetToken\"<<eol,(void *)wt,sizeof(*wt));\n  return ((pcsul)wt);\n  \u00fc\n return ((pcsul)NULL);\n \u00fc\n\npcsul MvsInterface::CreateToken(char *n,pcsul * v)\n \u00e4\n TRACE(4,SMsg(9502)<<\">CreateToken\"<<n<<eol);\n wt\u00c40\u00dc = v\u00c40\u00dc;\n wt\u00c41\u00dc = v\u00c41\u00dc;\n wt\u00c42\u00dc = v\u00c42\u00dc;\n wt\u00c43\u00dc = v\u00c43\u00dc;\n rc = 16;\n if ( n )\n  \u00e4\n  CASMIF(sym_createtoken,n,wt);\n  if ( rc == 4 )\n   \u00e4\n   CASMIF(sym_deletetoken,n);\n   CASMIF(sym_createtoken,n,wt);\n   \u00fc\n  \u00fc\n TRACEDUMP(4,SMsg(9501)<<\">CreateToken\"<<eol,(void *)wt,sizeof(*wt));\n return (rc==0);\n \u00fc\n\nvoid MvsInterface::DeleteToken(char *n)\n \u00e4\n TRACEDUMP(4,SMsg(9501)<<\">DeleteToken\"<<eol,(void *)n,strlen(n));\n CASMIF(sym_deletetoken,n);\n TRACE(4,SMsg(9501)<<\"<DeleteToken\"<<eol);\n \u00fc\n\n\nint MvsInterface::WaitEcb(pcsul  ms,\n             void * pecb0,void * pecb1,void * pecb2,void * pecb3)\n \u00e4\n TRACEDUMP(4,SMsg(9503)<<\">WaitEcb\"<<rc<<ms<<eol,pecb0,20);\n CASMIF(sym_wait,(void *)ms,pecb0,pecb1,pecb2,pecb3);\n TRACE(4,SMsg(9502)<<\"<WaitEcb\"<<rc<<eol);\n return rc;\n \u00fc\n\nint MvsInterface::PostEcb(void * pecb,pcsul code)\n \u00e4\n TRACE(3,SMsg(9502)<<\">PostEcb\"<<code<<eol);\n CASMIF(sym_post,pecb,(void *)code);\n TRACEDUMP(3,SMsg(9502)<<\"<PostEcb\"<<rc<<eol,pecb,20);\n return rc;\n \u00fc\n\nint MvsInterface::Enq(char * n,int ms)\n \u00e4\n TRACE(4,SMsg(9503)<<\">Enq\"<<n<<ms<<eol);\n CASMIF(sym_enq,ASM_MAJOR,n,(void *)strlen(n),(void *)ms);\n TRACE(4,SMsg(9502)<<\"<Enq\"<<rc<<eol);\n if ( rc == 0 ) return 1;\n else if ( rc < 0 ) return 0;\n else return -1;\n \u00fc\n\nint MvsInterface::Deq(char * n)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Deq\"<<n<<eol);\n CASMIF(sym_deq,ASM_MAJOR,n,(void *)strlen(n));\n TRACE(4,SMsg(9503)<<\"<Deq\"<<rc<<n<<eol);\n return (rc==0);\n \u00fc\n\n\nint MvsInterface::Svc(int n, void *p)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Svc\"<<n<<eol);\n CASMIF(sym_svc,(void *)n,(void *)p);\n TRACE(4,SMsg(9503)<<\"<Svc\"<<rc<<n<<eol);\n return (rc);\n \u00fc\n\nint MvsInterface::AttachMvs(const char * module,const char * parms)\n \u00e4\n size_t l_module= strlen(module);\n size_t l_parms = strlen(parms);\n TRACE(4,SMsg(9503)<<\">AttachMvs\"<<module<<parms<<eol);\n CASMIF(sym_attachmvs,(void *)&l_module,(void *)module,(void *)&l_parms,(void *)parms);\n TRACE(4,SMsg(9503)<<\"<AttachMvs\"<<rc<<module<<eol);\n return (rc);\n \u00fc\n\nvoid MvsInterface::Clock(void * stck)\n \u00e4\n CASMIF(sym_clock,stck);\n \u00fc\n\n//szm\nvoid MvsInterface::Timeused(void * time) //szm\n \u00e4\n CASMIF(sym_timeused,time);\n \u00fc\n\nlong long clock_mvs()\n \u00e4\n long long here;\n mvs()->Timeused(&here);\n return here;\n \u00fc\n//szm\n//szm\nint MvsInterface::Tdump(const char * n,const char *d,int dd = 0)\n \u00e4\n return (CASMIF(sym_tdump,(void *)n,(void *)d,(void *)dd));\n \u00fc\n\nint tdump(const char *n, const char *d,int dd)\n \u00e4\n return mvs()->Tdump(n,d,dd);\n \u00fc\n\n//szm20071005 get back reason code\nint mvsReasonCode()\n \u00e4\n return mvs()->getReasonCode();\n \u00fc\n//szm20071005 get back reason code\n\n\n//szm\n\n//szm20051118 LOGGER\n//szm\nint MvsInterface::LoggerOpen(const char * stream)\n \u00e4\n char zeros\u00c417\u00dc = \"\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\";\n char token\u00c417\u00dc = \"                \";\n memcpy(token,stream,(strlen(stream)<16?strlen(stream):16));\n pcsul  p =NULL;\n\n if (strcmp(stream,(const char *)(pASM->asm_streamname))==0)\n  \u00e4\n printf(\"token:%s\u00d6n\",token);\n  if (memcmp(pASM->asm_streamtoken,zeros,16)==0)\n   \u00e4\n   if (p=GetToken(token))\n    memcpy(pASM->asm_streamtoken,(char *)p,16);\n   else\n    if (CASMIF(sym_logger,(void *)0,(void *)stream,(void *)strlen(stream))==0)\n     CreateToken(token,(pcsul *)(pASM->asm_streamtoken));\n    else\n     return 0;\n   \u00fc\n  return 1;\n  \u00fc\n\n if (CASMIF(sym_logger,(void *)0,(void *)stream,(void *)strlen(stream))-0)\n \u00e4\n return 0;\n \u00fc\n CreateToken(token,(pcsul *)(pASM->asm_streamtoken));\n return 1;\n \u00fc\nint MvsInterface::Logger(const char * stream,size_t l)\n \u00e4\n return (CASMIF(sym_logger,(void *)1,(void *)stream,(void *)(l?l:strlen(stream)))==0);\n \u00fc\n//szm\nint MvsInterface::BrowseLogger(const char * & addr,size_t *  & length,int direction,int all,char * date_time)\n \u00e4\n  if (direction ==0) //szm\n   direction = 2;\n return (CASMIF(sym_logger,(void *)(direction),(void *)&addr,(void *)&length,(void *)all,(void *)date_time));\n \u00fc\n\n//szm\nint MvsInterface::LoggerClose()\n \u00e4\n //return (CASMIF(sym_logger,(void *)-1)); szm\n // never close the logger\n return 1;\n \u00fc\n//szm20051118 LOGGER\n//szm20051121 VTOC\nint MvsInterface::VtocOpen(const char * ddname,const char * mask,char *dscb)\n \u00e4\n char _mask\u00c446\u00dc;\n char _ddname\u00c49\u00dc;\n memcpy(_mask+1,mask,44);\n _mask\u00c445\u00dc = 0;\n if (strchr(_mask+1,' '))\n  *strchr(_mask+1,' ')= 0;\n _mask\u00c40\u00dc = strlen(_mask+1);\n memset(_ddname,' ',8);\n _ddname\u00c48\u00dc = 0;\n memcpy(_ddname,ddname,(strlen(ddname)<=8)?strlen(ddname):8);\n CASMIF(sym_vtoc,(void *)0,(void *)_ddname,(void *)_mask,(void *)dscb);\n return rc;\n \u00fc\nint MvsInterface::Vtoc(char * dscb)\n \u00e4\n CASMIF(sym_vtoc,(void *)1,(void *)0,(void *)0,(void *)dscb);\n return rc;\n \u00fc\nint MvsInterface::VtocClose()\n \u00e4\n return (CASMIF(sym_vtoc,(void *)-1));\n \u00fc\n//szm20051121 VTOC\n\n//szm\nint MvsInterface::initEnclave()\n  \u00e4\n \treturn wlmEnclave;\n  \u00fc\n\nint MvsInterface::Srb()\n \u00e4\n if (srb)\n  \u00e4\n CASMIF(sym_srb);\n srb = false;\n //printf(\" exit from SRB:%p %p srbFlag:%d\u00d6n\",pASM,this,pASM->asm_srb_mode);\n  \u00fc\n else\n  \u00e4\n  //printf(\" entry to SRB:%p %p srbFlag:%d\u00d6n\",pASM,this,pASM->asm_srb_mode);\n  srb = true;\n  CASMIF(sym_srb);\n  \u00fc\n return rc;\n \u00fc\n\n\nint MvsInterface::Wlm(const char * subsys,const char * subsysnm)\n \u00e4\n /*\n if (CASMIF(sym_wlm,(void *)subsys,(void *)subsysnm)|=0)\n  \u00e4\n  printf(\" WLM function:%8.8s rc:%d(%8.8x) rsn:%d(%8.8x)\u00d6n\",\n   pASM->asm_wlm_macro,pASM->asm_wlm_retcode,pASM->asm_wlm_retcode,\n   pASM->asm_wlm_rsncode,pASM->asm_wlm_rsncode);\n  return 8;\n  \u00fc\n */\n\n return 0;\n \u00fc\n\nint MvsInterface::Obtain(const char * dsn, const char * volser,char * dscb)\n\u00e4\n return (CASMIF(sym_obtain,(void *)dsn,(void *)volser,(void *)dscb));\n\u00fc\n\nint MvsInterface::Testauth()\n\u00e4\n return (CASMIF(sym_testauth));\n\u00fc\n\nint MvsInterface::Diagnose(int function,void * reply)\n\u00e4\n return(CASMIF(sym_diagnose,(void *)function,reply));\n\u00fc\n\n\nint MvsInterface::Vsmlist(void * ascb,void * address, int length )\n\u00e4\n return(CASMIF(sym_vsmlist,ascb,address,(void *)length));\n\u00fc\n\nvoid MvsInterface::Chap(pcsul t,int p)\n \u00e4\n TRACE(4,SMsg(9503)<<\">Chap\"<<t<<long(p)<<eol);\n#ifdef __SASC_\n CHAP(p,&t);\n#endif\n TRACE(4,SMsg(9501)<<\"<Chap\"<<eol);\n \u00fc\n\npcsul MvsInterface::Attach(char * pgm,char ** param,pcsul ecb)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Attach\"<<pgm<<eol);\n pcsul tcb = 0;\n *(pcsul *)ecb = 0;\n pcsul lparam\u00c416\u00dc;\n int i;\n for(i =0;i<16 && param\u00c4i\u00dc;i++)lparam\u00c4i\u00dc = (pcsul)(param\u00c4i\u00dc);\n lparam\u00c4i\u00dc = lparam\u00c4i\u00dc ] 0x80000000;\n check(rc,\"Attach\",\"ATTACH\");\n TRACE(4,SMsg(9501)<<\"<Attach\"<<eol);\n return tcb;\n \u00fc\n\nvoid MvsInterface::Detach(pcsul tcb)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Detach\"<<tcb<<eol);\n check(rc,\"Deatch\",\"DETACH\");\n TRACE(4,SMsg(9501)<<\"<Detach\"<<eol);\n \u00fc\n\nvoid MvsInterface::Sleep(int ms)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Sleep\"<<ms<<eol);\n if (ms) CASMIF(sym_sleep,(void *)ms);\n TRACE(4,SMsg(9501)<<\"<Sleep\"<<eol);\n \u00fc\n\nint MvsInterface::Oper(char *to,const size_t length)\n \u00e4\n TRACE(4,SMsg(9501)<<\">Oper\"<<eol);\n memset(to,0,length);\n CASMIF(sym_oper,(void *)to,(void *)length);\n if ( rc == 0 ) extractOper(to);\n TRACE(4,SMsg(9503)<<\"<Oper\"<<to<<rc<<eol);\n return rc;\n \u00fc\n\nvoid MvsInterface::Wto(const char *text,const int desc)\n \u00e4\n if ( text == 0 ) return;\n TRACE(4,SMsg(9502)<<\">Wto\"<<text<<eol);\n char  t\u00c4128\u00dc;\n memset(t,0,sizeof(t));\n strncpy(t,text,sizeof(t)-1);\n for(char * ct = t;*ct;ct++) if( *ct == '\u00d6n') *ct = ' ';\n CASMIF(sym_wto,(void *)t,(void *)strlen(t),(void *)desc);\n TRACE(4,SMsg(9501)<<\"<Wto\"<<eol);\n \u00fc\n\nvoid * MvsInterface::Malloc(size_t size)\n \u00e4\n void * a = 0;\n CASMIF(sym_malloc,(void *)size,(void *)&a);\n check(rc,\"Malloc\",\"MALLOC\");\n return a;\n \u00fc\n\nvoid  MvsInterface::Free(void * a)\n \u00e4\n CASMIF(sym_free,(void *)a);\n check(rc,\"Free\",\"FREE\");\n return ;\n \u00fc\n\n\nint MvsInterface::Select(pcsul numfds,\n             void *rfds,void *wfds,void *efds,void *time)\n \u00e4\n CASMIF(sym_select,(void *)numfds,rfds,wfds,efds,time);\n TRACE(4,SMsg(9502)<<\"<Select\"<<rc<<eol);\n return rc;\n \u00fc\n\n/*-----------------------------------------------------------------\nCOMMON functions\n------------------------------------------------------------------*/\n\nint isCics()\u00e4 return GlobalCicsFlag;\u00fc\n\n\nMvsInterface * getTcbUser()\n \u00e4\n pcsul  p = * (pcsul  * )PSATOLD;\n pasm pASM = ((pasm)*(pasm *)(p+TCBUSER));\n if (pASM)\n  return((MvsInterface *)(pASM->asm_mvs));\n else\n  return((MvsInterface * )NULL);\n \u00fc\n\n\nMvsInterface * mvs()\n \u00e4\n int i = 0;\n for(;i<MAX_TCB && _mvsInterface\u00c4i\u00dc;i++)\n  if (_tcb\u00c4i\u00dc == *(pcsul *)PSATOLD) break;\n assert(i<MAX_TCB);\n if (_mvsInterface\u00c4i\u00dc && _tcb\u00c4i\u00dc == *(pcsul *)PSATOLD)\n  return(_mvsInterface\u00c4i\u00dc);\n _tcb\u00c4i\u00dc = *(pcsul *)PSATOLD;\n return (_mvsInterface\u00c4i\u00dc = (MvsInterface*)new MvsInterface());\n \u00fc\n\nint MsgEnq()\n \u00e4\n int rc = 0;\n rc = ( ENQ(MSG_MAJOR,MSG_MINOR,E,8,STEP,NONE) == 0);\n return rc;\n \u00fc\n\nint MsgDeq()\n \u00e4\n int rc = 0;\n rc = ( DEQ(MSG_MAJOR,MSG_MINOR,8,STEP,NONE) == 0);\n return rc;\n \u00fc\n\n//KV\nSyncVar::SyncVar(pcsul w)\n \u00e4\n var  = 0;\n wait = w;\n ecb  = 0;\n \u00fc\n\nSyncVar::SyncVar(const SyncVar & v)\n \u00e4\n var  = v.var;\n wait = v.wait;\n ecb = 0;\n \u00fc\nSyncVar::\u00dfSyncVar()\n \u00e4\n if (ecb&WAITcode)\n  mvs()->PostEcb(&ecb,0);\n \u00fc\nSyncVar& SyncVar::operator=(pcsul t)\n \u00e4\n // printf(\" %p TCB %s %d\u00d6n\",*(pcsul *)PSATOLD,\">operator\",t);\n // btrace(&btracef);\n for(;;)\n  \u00e4\n  // if ( p1 == *p3 ) *p3 = p2\n  // else p1 = *p3\n  pcsul x = var;\n  if (CompareAndSwap(x,t,&var)==0)\n   break;\n  \u00fc\n mvs()->PostEcb(&ecb,t);\n //printf(\" %p TCB %s %p\u00d6n\",*(pcsul *)PSATOLD,\"<operator\",var);\n return(*this);\n \u00fc\n\nSyncVar::operator int()\n \u00e4\n //printf(\" %p TCB %s %p\u00d6n\",*(pcsul *)PSATOLD,\"init()\",var);\n return int(var);\n \u00fc\n\npcsul waitSyncVar(SyncVar &s)\n \u00e4\n //printf(\" %p TCB  %s %p\u00d6n\",*(pcsul *)PSATOLD,\">wait\",s.var);\n //szm20040624 avoid dumplicate wait on ECB's (S301)\n if (int(s.ecb)&0x80000000)\n  mvs()->Sleep(100);\n else\n  if (mvs()->WaitEcb(s.wait,&s.ecb) <0)\n   return (-1);\n // printf(\" %p TCB  %s %p\u00d6n\",*(pcsul *)PSATOLD,\"<wait\",s.var);\n return(s.var);\n \u00fc\npcsul waitSyncVars(SyncVar &s1,SyncVar &s2)\n \u00e4\n //printf(\" %p TCB %s %p %p\u00d6n\",*(pcsul *)PSATOLD,\">waits\",s1.var, s2.var);\n //szm20040624 avoid dumplicate wait on ECB's (S301)\n if (int(s1.ecb)&0x80000000 ]] int(s2.ecb)&0x80000000)\n  mvs()->Sleep(100);\n else\n  if\n   (mvs()->WaitEcb((s1.wait<s2.wait?s1.wait:s2.wait),&s1.ecb,&s2.ecb) < 0)\n   return (-1);\n //printf(\" %p TCB %s %p %p\u00d6n\",*(pcsul *)PSATOLD,\"<waits\",s1.var, s2.var);\n return(1);\n \u00fc\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EBCDICUT": {"ttr": 171, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/isislib/ebcdicut.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   Definitions for ascii/ebcdic conversion\n*******************************************************************************/\n#define ISIS_DONT_USE_PCSDLL\n#include \"isisdef.h\"\n// EBCDIC->ASCII table (273->850)\nextern const unsigned char isis_etoa\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x9F, 0x09, 0xB0, 0x7F,\n  0xB1, 0xB2, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0xB4, 0x0A, 0x08, 0xBA,\n  0x18, 0x19, 0xBB, 0xBC, 0x1C, 0x1D, 0x1E, 0x1F,\n  0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0x0A, 0x17, 0x1B,\n  0xC4, 0xC5, 0xC8, 0xC9, 0xCA, 0x05, 0x06, 0x07,\n  0xCB, 0xCC, 0x16, 0xCD, 0xCE, 0xD5, 0xD9, 0x04,\n  0xDA, 0xDB, 0xDC, 0xDF, 0x14, 0x15, 0xF2, 0x1A,\n  0x20, 0xFF, 0x83, 0x7B, 0x85, 0xA0, 0xC6, 0x86,\n  0x87, 0xA4, 0x8E, 0x2E, 0x3C, 0x28, 0x2B, 0x21,\n  0x26, 0x82, 0x88, 0x89, 0x8A, 0xA1, 0x8C, 0x8B,\n  0x8D, 0x7E, 0x9A, 0x24, 0x2A, 0x29, 0x3B, 0x5E,\n  0x2D, 0x2F, 0xB6, 0x5B, 0xB7, 0xB5, 0xC7, 0x8F,\n  0x80, 0xA5, 0x94, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,\n  0x9B, 0x90, 0xD2, 0xD3, 0xD4, 0xD6, 0xD7, 0xD8,\n  0xDE, 0x60, 0x3A, 0x23, 0xF5, 0x27, 0x3D, 0x22,\n  0x9D, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n  0x68, 0x69, 0xAE, 0xAF, 0xD0, 0xEC, 0xE7, 0xF1,\n  0xF8, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n  0x71, 0x72, 0xA6, 0xA7, 0x91, 0xF7, 0x92, 0xCF,\n  0xE6, 0xE1, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n  0x79, 0x7A, 0xAD, 0xA8, 0xD1, 0xED, 0xE8, 0xA9,\n  0xBD, 0x9C, 0xBE, 0xFA, 0xB8, 0x40, 0xF4, 0xAC,\n  0xAB, 0xF3, 0xAA, 0x7C, 0xEE, 0xF9, 0xEF, 0x9E,\n  0x84, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n  0x48, 0x49, 0xF0, 0x93, 0xDD, 0x95, 0xA2, 0xE4,\n  0x81, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n  0x51, 0x52, 0xFB, 0x96, 0x7D, 0x97, 0xA3, 0x98,\n  0x5C, 0xF6, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n  0x59, 0x5A, 0xFD, 0xE2, 0x5C, 0xE3, 0xE0, 0xE5,\n  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n  0x38, 0x39, 0xFC, 0xEA, 0x5D, 0xEB, 0xE9, 0xFE\n\u00fc ;\n\n// ASCII->EBCDIC table (850->273)\nextern const unsigned char isis_atoe\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n  0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,\n  0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,\n  0x40, 0x4F, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,\n  0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,\n  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n  0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,\n  0xB5, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n  0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,\n  0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n  0xE7, 0xE8, 0xE9, 0x63, 0xEC, 0xFC, 0x5F, 0x6D,\n  0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n  0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n  0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,\n  0xA7, 0xA8, 0xA9, 0x43, 0xBB, 0xDC, 0x59, 0x07,\n  0x68, 0xD0, 0x51, 0x42, 0xC0, 0x44, 0x47, 0x48,\n  0x52, 0x53, 0x54, 0x57, 0x56, 0x58, 0x4A, 0x67,\n  0x71, 0x9C, 0x9E, 0xCB, 0x6A, 0xCD, 0xDB, 0xDD,\n  0xDF, 0xE0, 0x5A, 0x70, 0xB1, 0x80, 0xBF, 0x04,\n  0x45, 0x55, 0xCE, 0xDE, 0x49, 0x69, 0x9A, 0x9B,\n  0xAB, 0xAF, 0xBA, 0xB8, 0xB7, 0xAA, 0x8A, 0x8B,\n  0x06, 0x08, 0x09, 0x0A, 0x14, 0x65, 0x62, 0x64,\n  0xB4, 0x15, 0x17, 0x1A, 0x1B, 0xB0, 0xB2, 0x20,\n  0x21, 0x22, 0x23, 0x24, 0x28, 0x29, 0x46, 0x66,\n  0x2A, 0x2B, 0x2C, 0x30, 0x31, 0x33, 0x34, 0x9F,\n  0x8C, 0xAC, 0x72, 0x73, 0x74, 0x35, 0x75, 0x76,\n  0x77, 0x36, 0x38, 0x39, 0x3A, 0xCC, 0x78, 0x3B,\n  0xEE, 0xA1, 0xEB, 0xED, 0xCF, 0xEF, 0xA0, 0x8E,\n  0xAE, 0xFE, 0xFB, 0xFD, 0x8D, 0xAD, 0xBC, 0xBE,\n  0xCA, 0x8F, 0x3E, 0xB9, 0xB6, 0x7C, 0xE1, 0x9D,\n  0x90, 0xBD, 0xB3, 0xDA, 0xFA, 0xEA, 0xFF, 0x41\n\u00fc ;\n\n// EBCDIC->ASCII table (273->ISO8859-1)\nextern const unsigned char isis_etoa_ISO8859_1\u00c4256\u00dc =\n\u00e4\n   0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F,\n   0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n   0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87,\n   0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,\n   0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B,\n   0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,\n   0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04,\n   0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,\n   0x20, 0xA0, 0xE2, 0x7B, 0xE0, 0xE1, 0xE3, 0xE5,\n   0xE7, 0xF1, 0xC4, 0x2E, 0x3C, 0x28, 0x2B, 0x21,\n   0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF,\n   0xEC, 0x7E, 0xDC, 0x24, 0x2A, 0x29, 0x3B, 0x5E,\n   0x2D, 0x2F, 0xC2, 0x5B, 0xC0, 0xC1, 0xC3, 0xC5,\n   0xC7, 0xD1, 0xF6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,\n   0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF,\n   0xCC, 0x60, 0x3A, 0x23, 0xA7, 0x27, 0x3D, 0x22,\n   0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n   0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,\n   0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n   0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,\n   0xB5, 0xDF, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n   0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,\n   0xA2, 0xA3, 0xA5, 0xB7, 0xA9, 0x40, 0xB6, 0xBC,\n   0xBD, 0xBE, 0xAC, 0x7C, 0xAF, 0xA8, 0xB4, 0xD7,\n   0xE4, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n   0x48, 0x49, 0xAD, 0xF4, 0xA6, 0xF2, 0xF3, 0xF5,\n   0xFC, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n   0x51, 0x52, 0xB9, 0xFB, 0x7D, 0xF9, 0xFA, 0xFF,\n   0xD6, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n   0x59, 0x5A, 0xB2, 0xD4, 0x5C, 0xD2, 0xD3, 0xD5,\n   0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n   0x38, 0x39, 0xB3, 0xDB, 0x5D, 0xD9, 0xDA, 0x9F\n\u00fc ;\n\n// ASCII->EBCDIC table (ISO8859-1->273)\nextern const unsigned char isis_atoe_ISO8859_1\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n  0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,\n  0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,\n  0x40, 0x4F, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,\n  0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,\n  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n  0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,\n  0xB5, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n  0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,\n  0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n  0xE7, 0xE8, 0xE9, 0x63, 0xEC, 0xFC, 0x5F, 0x6D,\n  0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n  0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n  0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,\n  0xA7, 0xA8, 0xA9, 0x43, 0xBB, 0xDC, 0x59, 0x07,\n  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17,\n  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,\n  0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08,\n  0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,\n  0x41, 0xAA, 0xB0, 0xB1, 0x9F, 0xB2, 0xCC, 0x7C,\n  0xBD, 0xB4, 0x9A, 0x8A, 0xBA, 0xCA, 0xAF, 0xBC,\n  0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3,\n  0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,\n  0x64, 0x65, 0x62, 0x66, 0x4A, 0x67, 0x9E, 0x68,\n  0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,\n  0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xE0, 0xBF,\n  0x80, 0xFD, 0xFE, 0xFB, 0x5A, 0xAD, 0xAE, 0xA1,\n  0x44, 0x45, 0x42, 0x46, 0xC0, 0x47, 0x9C, 0x48,\n  0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,\n  0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0x6A, 0xE1,\n  0x70, 0xDD, 0xDE, 0xDB, 0xD0, 0x8D, 0x8E, 0xDF\n\u00fc ;\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBENV": {"ttr": 177, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/jobenv.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#if defined(MU_STANDALONE) == 0\n#include \"isismisc.hpp\" //szm\n#endif\n#include \"jobenv.hpp\"\n#include \"msgmgr.hpp\"\n#include \"misc.hpp\"\n#include \"tiot1.hpp\"\n#include \"ikjrb.hpp\"\n#include \"ihacde.hpp\"\n#include \"psa.hpp\"\n#include \"tcbfix.hpp\"\n#include \"iezjscb.hpp\"\n#include \"ssib.hpp\"\n#include \"tiot1ds.hpp\"\n\nint JOBENV::debug = 0;\nchar * KEYWORD_DEBUG = \"DEBUG\";\nJOBENV * jobEnv = NULL;\n\n\nJOBENV::JOBENV(char * argv0)\n\u00e4\n  program        = argv0;\n\n  psa    *  psaP    = (psa *)NULL;\n  tcbfix *  tcbfixP = (tcbfix*)psaP->psatold;\n            tcbfixP = (tcbfix*)((char *)tcbfixP-sizeof(tcbfixP->tcbfrs));\n  tiot1ds *  tiot1P  = (tiot1ds*)tcbfixP->tcbtio;\n  iezjscb*  iezjscbP= (iezjscb*)((tcbfixP->tcbjscb._tcbjscbb)&0x00ffffff);\n  iezjscbP       = (iezjscb*)iezjscbP->jscbact;\n  ssib  *  ssibP = (ssib *)iezjscbP->jscbssib;\n\n\trbprfx * rbprfxP = (rbprfx *)tcbfixP->tcbrbp;\n\trbprfxP        = (rbprfx *)((char *)rbprfxP -64); //RB prefix 64 bytes\n\tint ok = 1;\n\twhile (ok&&(rbprfxP->xstab1&rbftp))\n\t\t\u00e4\n\t\t  if (rbprfxP->xstab2&rbtcbnxt)\n\t\t\t\tok = 0;\n\t\t\trbprfxP = (rbprfx *)(rbprfxP->xrblnka);\n\t\t\trbprfxP = (rbprfx *)((char *)rbprfxP -64); //RB prefix 64 bytes\n\t\t\u00fc\n\tif (ok)\n\t\t\u00e4\n\t\t cdentry * cdentryP = (cdentry *)(rbprfxP->rbcde1);\n\t\t programRb = mvsSTRING((char *)cdentryP->cdname,8);\n\t\t\u00fc\n\telse\n\t\tprogramRb = \"\";\n\n  jobName        = mvsSTRING((char *)tiot1P->tiocnjob,8);\n  stepName       = mvsSTRING((char *)tiot1P->tiocpstn,8);\n  procStepName   = mvsSTRING((char *)tiot1P->tiocpstn,8);\n  jobId          = mvsSTRING((char *)ssibP->ssibjbid,8);\n\n  jobName.strip();\n  jobId.strip();\n  stepName.strip();\n  procStepName.strip();\n  program.strip();\n\n  if (getenv(KEYWORD_DEBUG))\n    debug = atoi(getenv(KEYWORD_DEBUG));\n  else\n    debug = 0;\n\u00fc\n\nvoid JOBENV::print()\n\u00e4\n  Msg(400)<<jobName<<jobId<<program<<eol;\n\u00fc\n\nvoid JOBENV::Error(char *,JOBENV_ACTION a)\n\u00e4\n if (a == Abort)\n \u00e4\n    Msg(500)<<eol;\n    abort();\n \u00fc\n\n\u00fc\nint  JOBENV::DEBUG(int l,char* p0)\n\u00e4\n  if (l>debug) return 0;\n    Msg(101)<<p0<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,size_t p0)\n\u00e4\n  if (l>debug) return 0;\n    Msg(101)<<int(p0)<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1)\n\u00e4\n  if (l>debug) return 0;\n    Msg(102)<<p0<<p1<<eol;\n  return 1;\n\u00fc\n\n\nint  JOBENV::DEBUG(int l,char* p0,int p1)\n\u00e4\n  if (l>debug) return 0;\n    Msg(102)<<p0<<p1<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1,char* p2)\n\u00e4\n  if (l>debug) return 0;\n    Msg(103)<<p0<<p1<<p2<<eol;\n  return 1;\n\u00fc\n\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1,char* p2,char *p3)\n\u00e4\n  if (l>debug) return 0;\n    Msg(103)<<p0<<p1<<p2<<p3<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* t,char* d,int dl)\n\u00e4\n if (l>debug) return 0;\n dump(messagetext->getFILE()?messagetext->getFILE():stdout,t,d,dl);\n  return 1;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MCHAIN": {"ttr": 179, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/mchain.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include \"mchain.hpp\"\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <stdio.h>\n#ifndef MU_STANDALONE\n#include \"xfile.hpp\"\n#endif\n#endif\n\n/*--------------------------------------------------------------+\n| mCHAIN global class                                       |\n|                                                              |\n|                                                              |\n+--------------------------------------------------------------*/\n\nmCHAIN::\u00dfmCHAIN()\n\u00e4\n\tchainE * pa , * pp;\n\tpa = first;\n\twhile ( pa )\n\t\u00e4\n\t\tpp = pa;\n\t\tpa = pa->next;\n\t\tdelete pp;\n\t\u00fc\n\n\u00fc\n\nlong int mCHAIN::add(chainE * nc,chainE * c,long int code )\n\u00e4\n\tcounter++;\n\tif ( first == 0) first = last = nc ;\n\tif ( c )\n\t\u00e4\n\t\tif ( code < 0 )\n\t\t\u00e4\n\t\t\tif ( first == c)\n\t\t\t\u00e4\n\t\t\t\tfirst = nc ;\n\t\t\t\tnc->prev = NULL;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tnc ->prev = c->prev ;\n\t\t\tnc ->next = c ;\n\t\t\tc->prev = nc ;\n\t\t\tif ( nc->prev) nc->prev->next = nc ;\n\t\t\u00fc\n\t\telse if ( code > 0)\n\t\t\u00e4\n\t\t\tif ( last == c)\n\t\t\t\u00e4\n\t\t\t\tlast = nc ;\n\t\t\t\tnc->next = NULL;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tnc->next = c ->next ;\n\t\t\tnc->prev = c ;\n\t\t\tc->next = nc ;\n\t\t\tif ( nc->next) nc->next->prev = nc ;\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\tdelete \u00c4\u00dc c->chainEid ;\n\t\t\tc->chainEidl = nc->chainEidl;\n\t\t\tc ->chainEid = new char\u00c4nc->chainEidl+1\u00dc ;\n\t\t\tmemcpy(c->chainEid,nc->chainEid,c->chainEidl+1) ;\n\t\t\tcounter --;\n\t\t\u00fc\n\t\u00fc\n\treturn counter ;\n\u00fc\n\nlong int mCHAIN::del(chainE * c)\n\u00e4\n\tif ( c == first ) first = c->next ;\n\tif ( c == last ) last = c->prev ;\n\n\tif ( c->prev) c->prev->next = c->next ;\n\tif ( c->next) c->next->prev = c->prev ;\n\treturn --counter ;\n\u00fc\n\nvoid mCHAIN::swap(chainE * a , chainE * b)\n\u00e4\n\tif ( a->next NEQ b ]] b->prev NEQ a ]] a == 0 ]] b == 0)\n\t\treturn ;\n\n\tif ( first == a ) first = b ;\n\n\tif ( last == b) last = a ;\n\n\tif ( a->prev ) a->prev->next = b ;\n\tif ( b->next ) b->next->prev = a ;\n\n\tb->prev = a->prev ;\n\ta->next = b->next ;\n\tb->next = a;\n\ta->prev = b ;\n\u00fc\n\n\nchainE* mCHAIN::goNext()\n\u00e4\n\tif ( pgo )\n\t\tpgo = pgo->next;\n\treturn pgo;\n\n\u00fc\n\nchainE* mCHAIN::goPrev()\n\u00e4\n\tif ( pgo)\n\t\tpgo = pgo->prev;\n\treturn pgo;\n\u00fc\nchainE* mCHAIN::goFirst()\n\u00e4\n\tpgo = first;\n\treturn pgo;\n\u00fc\nchainE* mCHAIN::goLast()\n\u00e4\n\tpgo = last;\n\treturn pgo;\n\u00fc\n\nchainE* mCHAIN::go(int n)\n\u00e4\n\tpgo = first;\n\twhile ((--n)>0 && pgo)\n\t\u00e4\n\t\tpgo = pgo->next;\n\t\u00fc\n\treturn pgo;\n\u00fc\n\n\n\nchainE * mCHAIN::search(const char * id,size_t length)\n\u00e4\n\tif (length==0)\n\t\tlength=strlen(id);\n\tfor( chainE * c = first ; c ; c = c->next)\n\t\tif (id && length >= c->chainEidl && memcmp(id,c->chainEid,c->chainEidl) == 0) return c;\n\treturn 0;\n\u00fc\n\nchainE * mCHAIN::searchEQ(const char * id,size_t length)\n\u00e4\n\tif (length==0)\n\t\tlength=strlen(id);\n\tfor( chainE * c = first ; c ; c = c->next)\n\t\tif (id &&  strcmp(id,c->chainEid) == 0) return c;\n\treturn 0;\n\u00fc\n\nchainE * mCHAIN::search(const mvsSTRING & s)\n\u00e4\n\tint sl = s.lengthOf();\n\tfor(chainE * c = first; c ; c = c->next)\n\t\tif ( sl == c->chainEidl && memcmp((char*)s,c->chainEid,sl) == 0)\n\t\t\treturn c;\n\treturn 0;\n\u00fc\n\nvoid mCHAIN::sort(long int direction = 1)\n\u00e4\n\tlong int ind  = 1 ;\n\tchainE   * a ;\n\n\twhile(ind)\n\t\u00e4 ind = 0;\n\n\tfor(a = first ; a && a->next;)\n\t\u00e4\n\n\t\tif ( idcmp(a,a->next)*direction > 0)\n\t\t\u00e4 ind = 1;\n\t\tswap(a,a->next);\u00fc\n\t\ta = a->next ;\n\t\u00fc\n\t\u00fc\n\u00fc\n\nvoid mCHAIN::print_all_ids()\n\u00e4\n\tCHAINITER iter(*this);\n\tchainE * c ;\n\twhile ( (c = iter()) NEQ 0)\n\t\tputs(c->chainEid);\n\u00fc\n\n\nvoid mCHAIN::print()\n\u00e4\n\tCHAINITER iter(*this);\n\tchainE * c ;\n\twhile ( (c = iter()) NEQ 0)\n\t\tc->print();\n\u00fc\n\nlong int SORTEDmCHAIN::add(chainE *nc,chainE *,long int)\n\u00e4\n\tif ( first == 0)\u00e4counter = 1; first = last = nc ;\u00fc\n\telse\n\t\u00e4\n\t\tint comp;\n\t\tint h = counter;\n\t\tint l = 1;\n\t\tint m ;\n\t\tchainE * a;\n\t\twhile (h>l)\n\t\t\u00e4\n\t\t\tm = l+(h-l)/2;\n\t\t\ta = go(m);\n\t\t\tcomp = idcmp(nc,a);\n\t\t\tif ( comp > 0 )  l = m+1;\n\t\t\telse if ( comp < 0 ) h= m-1;\n\t\t\telse if ( comp == 0 )\n\t\t\t\treturn 0;\n\t\t\t// return mCHAIN::add(nc,a,int(unique));\n\t\t\u00fc\n\t\ta = go(l);\n\t\tcomp= idcmp(nc,a);\n\t\tif ( comp )\n\t\t\treturn mCHAIN::add(nc,a,comp?comp:unique);\n\t\telse return 0;\n\n\t\u00fc\n\treturn counter;\n\u00fc\n\n\nmHASH::mHASH(int h):mCHAIN()\n\u00e4\n\tpi = 0;\n\thash\t= h;\n\ttable =(chainE * *)malloc(h*sizeof(chainE *));\n\tmemset(table,0,h*sizeof(chainE *));\n\u00fc\n\nmHASH::\u00dfmHASH()\n\u00e4\n\tif (table)\n\t\u00e4\n\t\tfor(int i =0;i<hash;i++)\n\t\t\twhile(table\u00c4i\u00dc)\n\t\t\t\u00e4\n\t\t\t\tpgo = table\u00c4i\u00dc;\n\t\t\t\ttable\u00c4i\u00dc= table\u00c4i\u00dc->next;\n\t\t\t\tdelete pgo;\n\t\t\t\u00fc\n\t\t\tfree(table);\n\t\t\ttable = NULL;\n\t\u00fc\n\u00fc\n\nlong int mHASH::add(chainE * c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tif (table\u00c4i\u00dc)\n\t\u00e4\n\t\tc->next=table\u00c4i\u00dc;\n\t\tc->prev = NULL;\n\t\ttable\u00c4i\u00dc->prev=c;\n\t\ttable\u00c4i\u00dc = c;\n\t\u00fc\n\telse\n\t\ttable\u00c4i\u00dc = c;\n\treturn i;\n\u00fc\n\nchainE * mHASH::search(chainE *c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tchainE *n = table\u00c4i\u00dc;\n\twhile(n)\n\t\tif(idcmp(c,n)==0)\n\t\t\tbreak;\n\t\telse\n\t\t\tn = n->next;\n\treturn n;\n\u00fc\n\nlong int mHASH::del(chainE * c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tif (c->prev)\n\t\tc->prev->next = c->next;\n\tif (c->next)\n\t\tc->next->prev= c->prev;\n\tif (c==table\u00c4i\u00dc)\n\t\u00e4\n\t\tif (table\u00c4i\u00dc = c->next)\n\t\t\ttable\u00c4i\u00dc->prev = NULL;\n\t\u00fc\n\treturn i;\n\u00fc\n\nchainE * mHASH::next()\n\u00e4\n\tif (pgo)\n\t\tpgo = pgo->next;\n\tfor(;pgo==NULL&&pi<hash;pi++)\n\t\tpgo=table\u00c4pi\u00dc;\n\tif(pgo==NULL)\n\t\tpi = 0;\n\treturn pgo;\n\u00fc\n\nint idcmp(chainE * a, chainE * b)\n\u00e4\n\tint comp;\n\tif ( a == 0 && b == 0) return 0;\n\telse if ( a == 0) return -1;\n\telse if ( b == 0) return 1;\n\n\tif ( a->chainEidl == b->chainEidl)\n\t\treturn memcmp(a->chainEid,b->chainEid,a->chainEidl);\n\telse\n\t\tif ( a->chainEidl < b->chainEidl)\n\t\t\u00e4comp = memcmp(a->chainEid,b->chainEid,a->chainEidl); return comp?comp :-1;\u00fc\n\t\tcomp = memcmp(a->chainEid,b->chainEid,b->chainEidl);\n\t\treturn comp ? comp : +1;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MERROR": {"ttr": 181, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/merror.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include \"merror.hpp\"\n#include <assert.h>\n\n#ifndef mERRORP\n#define mERRORP mERROR *\n#endif\n\nmERRORPSTACK mErrorPStack(512);\n\nmERRORPSTACK::mERRORPSTACK(long int size)\n\u00e4\n   ip = 0; max = size;\n   sp = new mERRORP\u00c4size\u00dc ;\n\n\u00fc\n\nvoid mERRORPSTACK::push(mERRORP value)\n\u00e4\n  assert( ip < max);\n  sp\u00c4ip++\u00dc = value;\n\u00fc\n\nmERRORP mERRORPSTACK::examine()\n\u00e4\n   return( ip ? sp\u00c4ip-1\u00dc : (mERRORP ) 0 );\n\u00fc\n\nint mERRORPSTACK::callNextHandler(int)\n\u00e4\n//for(int i=ip-1;i>=0;i--)\n//if ( sp\u00c4i\u00dc && sp\u00c4i\u00dc->handler) return (sp\u00c4i\u00dc->handler)(code);\n  return 0;\n\u00fc\n\nmERRORP mERRORPSTACK::pop()\n\u00e4\n  if (ip>0) return sp\u00c4--ip\u00dc;\n  else return (mERRORP) 0 ;\n\n\u00fc\nvoid  mERRORPSTACK::reset()\n\n\u00e4\n  ip = 0;\n\u00fc\n\nmERRORPSTACK::\u00dfmERRORPSTACK()\n\u00e4\n delete \u00c4\u00dc sp;\n\u00fc\n\n\nint mERROR::max_rc = 0;\n\n\nmERROR::mERROR()\n\u00e4\n    err = 0;\n    handler =0;\n//  mErrorPStack.push(this);\n\u00fc\n\nmERROR::mERROR(int (*h)(int) )\n\u00e4\n     err = 0;\n     handler = h;\n//   mErrorPStack.push(this);\n\u00fc\n\n\nint mERROR::error(char *,ERROR_ACTION a)\n \u00e4\n  switch(a)\n    \u00e4\n     case Warning:\n    \t\t max_rc = 4;\n          return 0;\n       case Abort:\n          exit(8);\n       default:\n          exit(8);\n    \u00fc\n    return 0;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MISC": {"ttr": 175, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/misc.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n//#include \"pcsdll.hpp\"\n#ifdef    OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include \"mvsbase.hpp\"\n#if defined(MU_STANDALONE) == 0\n#include \"ebcdicut.hpp\"\n#else\n#include \"mvsebcdi.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"mvsbase.hpp\"\n#ifdef CALL_PROJECT\n#include \"project.hpp\"\n#endif\n\n//#if defined(ISIS_PF_MI) == 1 && defined(ISIS_DEBUG) == 1 //szm20050316 debug flag, off from stdio\n#if (defined(ISIS_PF_MI) == 1 ]] defined(ISIS_PF_MU) == 1) && defined(ISIS_DEBUG) == 1 //szm20050316 debug flag, off from stdio\nint _isis_pf_mi_debug = 1;\n#endif\n#if defined(ISIS_PF_HOST) ]] defined (ISIS_PF_MU)\n  #if defined(OWN_STDIO) == 0\n      #include <assert.h>\n  #endif\n  #include <ctype.h>\n  #include <regex.h>\n  #include <locale.h>\n  #include <sys/time.h> //ZA040225\n  #include \"casmif.hpp\" //ENQ DEQ\n  #include <unistd.h>\n#endif\n\n#ifndef MU_STANDALONE\n#include \"systems.hpp\" //KV20040915 for stricmp\n#else\n#include <strings.h>\n#ifndef stricmp\n    #define stricmp strcmpi\n#endif\n#ifndef strcmpi\n#define strcmpi strcasecmp\n#endif\n#define MVSBatch() 1\n#endif\n\n#define UKEY_MAJOR \"STRTUKEY\"\n#define UKEY_MINOR \"ISIS_UKEY\"\nstatic unsigned char tUK\u00c4\u00dc =\n     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\u00d6\n         \"0123456789#$\"\u00d6\n         \"abcdefghijklmnopqrstuvwxyz\";\n\n\nvoid formatTime(char * to,int l,char * format)\n\u00e4\n   time_t t;\n   struct tm * tmp;\n   time(&t);\n   tmp = localtime(&t);\n   strftime(to,l-1,format,tmp);\n\u00fc\n\nchar *strrev(char *s)  //szm\n\u00e4\n    if (s==NULL]]strlen(s)==0) return s;\n    char c;\n    int i , j;\n    for(i =0, j =strlen(s)-1; i<j;i++,j--)\n    \u00e4\n      c    =  s\u00c4i\u00dc;\n      s\u00c4i\u00dc =  s\u00c4j\u00dc;\n      s\u00c4j\u00dc = c;\n    \u00fc\n    return(s);\n\u00fc\n\n\nunsigned long cvb(unsigned long f , unsigned long length)\n \u00e4\n  unsigned long r = 0;\n    unsigned long m = 1;\n    for(int i = 0;f && i<length;i++)\n    \u00e4\n     r += (f&0x0000000fL)*m;\n       m *= 10;\n       f = f>>4;\n    \u00fc\n    return r;\n\u00fc\n\n\nunsigned long cvd(unsigned long f)\n\u00e4\n unsigned long r = 0;\n   for ( int i = 0;f && i<8;i++)\n   \u00e4\n    r ]= ((f%10)<<(i*4));\n      f = f/10;\n   \u00fc\n   return r;\n\u00fc\n\n\n//KV20050725 dump functions moved to isislib/isismisc.cpp\n//SZM20050810 If it is CICSAPPL , there is no isismisc\n//SZM20090629 If standalone  , there is no isismisc\n//#if defined(ISIS_PF_MU) == 0 ]] defined(MU_STANDALONE) == 0\n#if defined(CICSAPPL)   ]] defined(MU_STANDALONE)\nint dump(FILE * dumpf,char * id,void * from,int l)\n\u00e4\n    return (dump(dumpf,id,(char *)from,l));\n\u00fc\nint dump(FILE *f,char * id,char * p,int l)\n\u00e4\n    int i , o;\n    fprintf(f,\"%s\u00d6n\u00d6n\",id);\n\n    for(o = 0;o <((l/16)+1)*16;o+=16)\n    \u00e4\n        fprintf(f,\"%4.4lx:\",o);\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n            \u00e4\n                fprintf(f,\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n                if (i%4 == 3) fprintf(f,\" \");\n\n            \u00fc\n\n            else\n            \u00e4\n                if ( i%4 == 3) fprintf(f,\" \");\n                fprintf(f,\" \");\n            \u00fc\n        \u00fc\n        fprintf(f,\" \");\n\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n                fprintf(f,\"%c\",i_isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n            else fprintf(f,\" \");\n        \u00fc\n        fprintf(f,\" \");\n\n        // print ebcdic -> ascii  converted chars on ascii platforms,\n        //        ascii -> ebcdic converted chars on ebcdic platforms\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n            \u00e4\n#if ' ' == 0x20\n                char c=etoa(p\u00c4i\u00dc);\n#else\n                char c=atoe(p\u00c4i\u00dc);\n#endif\n                fprintf(f,\"%c\",i_isprint(c) ? c : '.');\n            \u00fc\n        \u00fc\n        fprintf(f,\"\u00d6n\");\n    \u00fc\n    return l;\n\u00fc\n\nint dump(char *f,int o,char * p,int l)\n\u00e4\n    int i;\n\n    sprintf(f,\"%4.4lx:\",o);\n    f+=strlen(f);\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l )\n        \u00e4\n            sprintf(f,\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n            f+=strlen(f);\n            if (i%4 == 3)\n            \u00e4\n                sprintf(f,\" \");f+=strlen(f);\n            \u00fc\n\n        \u00fc\n\n        else\n        \u00e4\n            if ( i%4 == 3)\n            \u00e4\n                sprintf(f,\" \"); f+=strlen(f);\n            \u00fc\n            sprintf(f,\" \");f+=strlen(f);\n        \u00fc\n    \u00fc\n    sprintf(f,\" \");\n    f+=strlen(f);\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l )\n            sprintf(f,\"%c\",i_isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n        else sprintf(f,\" \");\n        f+=strlen(f);\n    \u00fc\n    sprintf(f,\" \");\n    f+=strlen(f);\n\n    // print ebcdic -> ascii  converted chars on ascii platforms,\n    //        ascii -> ebcdic converted chars on ebcdic platforms\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l ) \u00e4\n#if ' ' == 0x20\n            char c=etoa(p\u00c4i\u00dc);\n#else\n            char c=atoe(p\u00c4i\u00dc);\n#endif\n            sprintf(f,\"%c\",i_isprint(c) ? c : '.');\n            f+=strlen(f);\n        \u00fc\n    \u00fc\n    sprintf(f,\"\u00d6n\");\n\n    return l;\n\u00fc\n\n\nlong toInt(unsigned char  * p, int l)\n\u00e4\n    char  t\u00c44\u00dc;\n    memset(t,'\u00d600',4);\n    if ( l > 4) l =l%4;\n    int i;\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n    for(i=3;l;l--,i--) t\u00c4i\u00dc = p\u00c4l-1\u00dc;\n    return int(*(int *)t);\n#else\n    int ll = l;\n    for(i=0;l;i++,l--) t\u00c4i\u00dc = p\u00c4l-1\u00dc;\n    if( ll == 1) return int(*(UCHAR*)t) ;\n    else if ( ll == 2) return short(*(short*)t);\n    else  return long(*(long *)t);\n#endif\n\u00fc\n\nlong toInt(char  * p, int l)\n  \u00e4\n  return(toInt((unsigned char *)p,l));\n  \u00fc\n\n\nint fromInt(char  * to,long v,unsigned int  l)\n  \u00e4\n  return fromInt(to,v,int(l));\n  \u00fc\n\nint fromInt(char  * to,long v,int l )\n\u00e4\n\n //assert(l<=sizeof( long)); ?????\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n    memcpy(to,((char * )&v)+(sizeof( int)-l),l);\n#else\n    char * t = (char *)&v;\n    for(int i = l;i;i--)to\u00c4i-1\u00dc = *(t++);\n#endif\n    return (l>=sizeof(long));\n\u00fc\n\nint Char2Hex(char * c)\n\u00e4\n   int v = 0;\n   for(int i = 2;i; i--)\n   \u00e4    v<<=4;\n      if ( *c >= '0' && *c <= '9' ) v += *c-'0';\n      else if ( *c >= 'A' && *c <= 'F' ) v += *c-'A'+10;\n      else if ( *c >= 'a' && *c <= 'f' ) v += *c-'a'+10;\n      c++;\n   \u00fc\n   return v;\n\u00fc\n\nchar * Hex2Char(char c)\n\u00e4\n   static char r\u00c43\u00dc;\n   memset(r,null,sizeof(r));\n   int v = (c&0xf0)>>4;\n   if ( v >= 0 && v <= 9 ) r\u00c40\u00dc = char('0'+v);\n   else r\u00c40\u00dc = char('A'+v-10);\n   v = (c&0x0f);\n   if ( v >= 0 && v <= 9 ) r\u00c41\u00dc = char('0'+v);\n   else r\u00c41\u00dc = char('A'+v-10);   return r;\n\u00fc\n\nint isnull(char * s,int l)\n\u00e4\n if ( l == 0 ) l = int(strlen(s));\n for(l;l>0;l--)if ( s\u00c4l-1\u00dc  ) return 0;\n return 1;\n\u00fc\n\nint roundToInt(double f)\n\u00e4\n   double w;\n   if ( modf(f,&w) >= 0.5 ) return (int(f)+1);\n   else return int(f);\n\u00fc\n\n\nstatic char ts\u00c430\u00dc;\nchar  * getTimeStemp()\n\u00e4\n\n  formatTime(ts,sizeof(ts),\"%Y:%m:%d %H:%M:%S\");\n  return ts;\n\u00fc\n\nstatic char *days\u00c47\u00dc  =\u00e4 \"Mon\", \"Tue\", \"Wen\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"\u00fc;\nstatic char *ldays\u00c47\u00dc =\u00e4 \"Monday\",\n             \"Tuesday\",\n             \"Wednesday\",\n             \"Thursday\",\n             \"Friday\",\n             \"Saturday\",\n             \"Sunday\" \u00fc;\nstatic char *month\u00c412\u00dc = \u00e4 \"Jan\", \"Feb\", \"Mar\",\n             \"Apr\", \"May\", \"Jun\",\n             \"Jul\", \"Aug\", \"Sep\",\n             \"Oct\", \"Nov\", \"Dec\"\u00fc;\n\nint DatetoTm(tm & t, char * st)\n\u00e4\n  char * term = \",:- \";\n  char * c;\n  char * day = strtok(st,term);\n\n  int i = 0;\n  for(i = 7;i;i--)if ( stricmp(days\u00c4i-1\u00dc,day) == 0 ) break;\n  if ( i == 0 )\n   for(i = 7;i;i--)if (strcmp(ldays\u00c4i-1\u00dc,day) == 0 ) break;\n\n  t.tm_wday = i-1;\n\n  c = strtok(0,term);\n  if ( isdigit(*c) )\n  \u00e4\n    t.tm_mday = atoi(c);\n    c = strtok(0,term);\n    for( i = 12;i;i--) if ( stricmp(month\u00c4i-1\u00dc,c) == 0 ) break ;\n    t.tm_mon = i;\n    i = atoi(strtok(0,term));\n    t.tm_year = i>1900? i-1900 : i;\n    t.tm_hour = atoi(strtok(0,term));\n    t.tm_min = atoi(strtok(0,term));\n    t.tm_sec = atoi(strtok(0,term));\n    t.tm_yday = 0;\n   \u00fc\n   else\n   \u00e4\n    for( i = 12;i;i--) if ( stricmp(month\u00c4i-1\u00dc,c) == 0 ) break ;\n    t.tm_mon = i;\n    t.tm_mday = atoi(strtok(0,term));\n    t.tm_hour = atoi(strtok(0,term));\n    t.tm_min = atoi(strtok(0,term));\n    t.tm_sec = atoi(strtok(0,term));\n    t.tm_year = atoi(strtok(0,term));    t.tm_yday = 0;\n  \u00fc\n  return 0;\n\u00fc\n\nchar * DatetoString()\n\u00e4\n  static char dmvsSTRING\u00c464\u00dc;\n  time_t now;\n  time(&now);\n  strcpy(dmvsSTRING,asctime(gmtime(&now)));\n  strcpy(dmvsSTRING+strlen(dmvsSTRING)-1,\" GMT\");\n  return dmvsSTRING;\n\u00fc\n\nchar * DatetoString(tm t,char * st)\n\u00e4\n  strcpy(st,asctime(&t));\n  strcpy(st+strlen(st)-1,\" GMT\");\n  return st;\u00fc\n#endif\n//#endif //ifndef ISIS_PF_MU\n\n static char dateInIBM\u00c413\u00dc;\n\n void formatIBMTime(char * to,int l,char * format)\n\u00e4\n   time_t t;\n   struct tm * tmp;\n   time(&t);\n   tmp = localtime(&t);\n   strftime(to,l-1,format,tmp);\n\u00fc\n\n char * DatetoIBM(char * from)\n \u00e4\n   memset(dateInIBM,0,sizeof(dateInIBM));\n   char today\u00c412\u00dc;\n   if ( from == NULL)\n   \u00e4\n      from = today;\n      formatIBMTime(today,sizeof(today),\"%d.%m.%Y\");\n   \u00fc\n   int mv\u00c412\u00dc = \u00e4 31,28,31,30,31,30,31,31,30,31,30,31\u00fc;\n   mvsSTRING d, m, y;\n   mvsSTRING date(from);\n   date.parse(d,\".\",m,\".\",y);\n   int id = atoi(d);\n   int im = atoi(m);\n   int iy = atoi(y);\n   if ( id > 31 ]] im < 1 ]] im > 12 )\n     return (char *)NULL;\n\n   int leapyear ;\n   if ((iy%4) ]] ((iy%100) == 0  && (iy%400))) leapyear = 0 ;\n     else leapyear = 1;\n   int dd = 0;\n   for(int i = 0;i < (im-1);i++)dd += mv\u00c4i\u00dc;\n   if ( leapyear && im > 2) dd++;\n   dd +=id;\n   if (iy < 100) iy += 2000;\n   sprintf(dateInIBM,\"%d     \",iy*1000+dd);\n   return (dateInIBM);\n \u00fc\n\nvoid getUniqueKEY(char * t)\n\u00e4\n\n\n  char _dummy=0, stck\u00c49\u00dc;\n\n  mvs()->Clock(stck); //szm\n  int  i, w1 , w2;\n  _dummy = 0;\n\n  w1 = *(int *)(stck-1);\n  w2 = *(int *)(stck+3);\n  for (i = 0;i<5;i++)\n  \u00e4\n  t\u00c4i\u00dc = tUK\u00c4w1&0x1f\u00dc; w1 = w1>>5;\n  \u00fc\n  for (i = 5;i<10;i++)\n  \u00e4\n  t\u00c4i\u00dc = tUK\u00c4w2&0x1f\u00dc; w2 = w2>>5;\n  \u00fc\n  t\u00c410\u00dc = _dummy;\n\n\u00fc\n\nvoid getUniqueLongKEY(char * t)\n\u00e4\n  char _dummy, stck\u00c49\u00dc;\n\n  mvs()->Clock(stck); //szm\n  int w1 = *(int *)(stck);\n  int w2 = *(int *)(stck+4);\n  sprintf(t,\"%8.8x%8.8x\",w1,w2);\n  t\u00c416\u00dc = 0;\n\u00fc\n\n\n//KV20040824 still needed?\n//char * StrTok(char * mvsSTRING,char * termtokens)\n//\u00e4\n//  char * c = strtok(mvsSTRING,termtokens);\n//  return ( c ? c :\"\");\n//\u00fc\n\nint strcmpiList(const char * comp,const char *list\u00c4\u00dc)\n\u00e4\n   for (int i = 0;list\u00c4i\u00dc;i++)\n   if ( stricmp(comp,list\u00c4i\u00dc) == 0)\n   return 0;\n   return 1;\n\u00fc\n\nint strcmpiList(const char * comp,const char *list\u00c4\u00dc,int & i)\n\u00e4\n   for ( i = 0;list\u00c4i\u00dc;i++)\n   if ( stricmp(comp,list\u00c4i\u00dc) == 0)\n    return 0;\n   return 1;\n\u00fc\n\n//KV20040825 strnicmp replaced by strnicmp\n#if 0\nint strnicmp(const char * s1,const char * s2,int l)\n\u00e4\n   for(int i = 0; i<l; i++)\n   if ( tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc) )\n   return (tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc));\n   return 0;\n\u00fc\n#endif\n\nint stcpma(char * mvsSTRING ,const char * pattern)\n\u00e4\n   regex_t    preg;\n   size_t     nmatch = 1;\n   regmatch_t pmatch\u00c41\u00dc;\n   int rc = 0;\n   if ( strlen(pattern) == 0 ]] strcmp(pattern,\"*\") == 0)\n    return 1;\n   //char patt\u00c416\u00dc;\n   char patt\u00c4512\u00dc; //ZA060607 for VSAM\n   char * p = patt;\n   int j = strlen(pattern);\n   int k = j - 1; //index of last nonzero char\n\tbool usepattern = false;//ToDo36320\n   for(int i = 0;i<=j;i++)\n   \u00e4\n   \t  char c = pattern\u00c4i\u00dc;\n      if (c == '*' ]] c == '?')\n\t\t\u00e4\n          *p++= '.';\n\t\t\tusepattern = true; //ToDo36320\n\t\t\u00fc\n      else if (c == '.' ]] c == '$')\n      \u00e4\n      \tif (i < k) //not last char\n      \t\u00e4\n      \t\t*p++= '\u00d6xe0'; // backslash\n      \t\t*p++= c; //no special character\n      \t\u00fc\n      \telse\n      \t    *p++= c; //last char, remains special\n      \u00fc\n        else\n        *p++ = c;\n   \u00fc\n\tif (usepattern)//ToDo36320\n\t\u00e4\n   if (regcomp(&preg,patt,REG_EXTENDED))\n    return 0;\n   else\n   \u00e4\n    rc = NOT regexec(&preg,mvsSTRING, nmatch, pmatch, 0);\n      regfree(&preg);\n      return rc;\n   \u00fc\n\u00fc\n\telse //ToDo36320\n\t\u00e4\n\t\tchar * copy = strdup(mvsSTRING);\n\t\tif (strchr(copy,' '))\n\t\t\t* strchr(copy,' ') = 0;\n\t\tint rc = | strcmp(copy,pattern);\n\t\tfree(copy);\n\t\treturn (rc);//ToDo36320\n\t\u00fc\n\u00fc\n\nmvsSTRING makemvsSTRING(char * s,int l)\n\u00e4\n for(l--;l;l--)\n if ( s\u00c4l-1\u00dc NEQ ' ')  break;\n s\u00c4l\u00dc = null;\n return mvsSTRING(s);\n\u00fc\nchar * StrDup(char * o)\n\u00e4\n  char * rs =(char *)0;\n  if ( o == (char *)0 ) return rs;\n  rs = new char\u00c4strlen(o)+1\u00dc;\n  strcpy(rs,o);\n  return rs;\n\u00fc\n\n#ifndef ISIS_PF_MU\n#if defined(CICSAPPL)\nchar bit_rotate(unsigned char from)\n \u00e4\n static unsigned char rtab\u00c4256\u00dc =\n \u00e4\n    0x00, 0x80, 0x40, 0xc0, 0x20, 0xA0, 0x60, 0xe0,\n    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,  // 0x00 bis 0x0f\n    0x08, 0x88, 0x48, 0xc8, 0x28, 0xA8, 0x68, 0xe8,\n    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,  // 0x10 bis 0x1f\n    0x04, 0x84, 0x44, 0xc4, 0x24, 0xA4, 0x64, 0xe4,\n    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,  // 0x20 bis 0x2f\n    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xAc, 0x6c, 0xec,\n    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,  // 0x30 bis 0x3f\n    0x02, 0x82, 0x42, 0xc2, 0x22, 0xA2, 0x62, 0xe2,\n    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,  // 0x40 bis 0x4f\n    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xAa, 0x6a, 0xea,\n    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,  // 0x50 bis 0x5f\n    0x06, 0x86, 0x46, 0xc6, 0x26, 0xA6, 0x66, 0xe6,\n    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,  // 0x60 bis 0x6f\n    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xAe, 0x6e, 0xee,\n    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,  // 0x70 bis 0x7f\n    0x01, 0x81, 0x41, 0xc1, 0x21, 0xA1, 0x61, 0xe1,\n    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,  // 0x80 bis 0x8f\n    0x09, 0x89, 0x49, 0xc9, 0x29, 0xA9, 0x69, 0xe9,\n    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,  // 0x90 bis 0x9f\n    0x05, 0x85, 0x45, 0xc5, 0x25, 0xA5, 0x65, 0xe5,\n    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,  // 0xa0 bis 0xaf\n    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xAd, 0x6d, 0xed,\n    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,  // 0xb0 bis 0xbf\n    0x03, 0x83, 0x43, 0xc3, 0x23, 0xA3, 0x63, 0xe3,\n    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,  // 0xc0 bis 0xcf\n    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xAb, 0x6b, 0xeb,\n    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,  // 0xd0 bis 0xdf\n    0x07, 0x87, 0x47, 0xc7, 0x27, 0xA7, 0x67, 0xe7,\n    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,  // 0xe0 bis 0xef\n    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xAf, 0x6f, 0xef,\n    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,  // 0xf0 bis 0xff\n \u00fc;\n   return rtab\u00c4from\u00dc;\n\u00fc\n#endif\n#endif //ifndef ISIS_PF_MU\n\n/*\nvoid swab(char *source, char *target,int len) //ZA030918 Metacode needs it\n\u00e4\n   int ii;\n   for (ii=0; ii<len; ii=ii+2)\n   \u00e4\n      target\u00c4ii\u00dc = source\u00c4ii+1\u00dc;\n      target\u00c4ii+1\u00dc = source\u00c4ii\u00dc;\n   \u00fc\n   if(ungerade(len))\n   \u00e4 target\u00c4len\u00dc=source\u00c4len\u00dc;\n     target\u00c4len+1\u00dc='\u00d60'; \u00fc\n   else target\u00c4len\u00dc = '\u00d60';\n   return;\n\u00fc\n*/\n\n\nvoid swab(char *source, char *target,int len) //ZA030924 Metacode needs it\n\u00e4\n   int ii;\n   for (ii=0; ii<len-1; ii=ii+2)\n   \u00e4\n      target\u00c4ii\u00dc = source\u00c4ii+1\u00dc;\n      target\u00c4ii+1\u00dc = source\u00c4ii\u00dc;\n   \u00fc\n   return;\n\u00fc\n\n/*\nunsigned int ungerade(int len)\n\u00e4\n   if (len%2) return TRUE;\n      else return FALSE;\n\u00fc\n*/\n\n#ifndef __TEST__\n#define __TEST__ 1\n#endif\n\nchar __test__ = __TEST__ ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGMGR": {"ttr": 185, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/msgmgr.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#ifdef ISIS_PF_MU\n#pragma csect(CODE,\"msgmgrmC\")\n#pragma csect(STATIC,\"msgmgrmS\")\n#pragma csect(TEST,\"msgmgrmT\")\n#endif\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n//#include \"iqvprj.hpp\"\n#endif\n#include \"mvsbase.hpp\"\n#include \"casmif.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"msgmgr.hpp\"\n#ifdef PANEL_ID\n#include \"panel.hpp\"\n#include \"cicbase.hpp\"\n#endif\n#include <dll.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n\nnamespace isis_ns_mvs\n\t\u00e4\n\t//KV20040216 protection exception in pas dll\n\t//???MessageTEXT * messagetext   = new MessageTEXT();\n\tMessageTEXT * messagetext   = 0;\n\tExternalTEXT * externaltext = 0;  //szm\n\t/*--------------------------------------------------------------+\n\n\tMSGE rouines                                                 ]\n\t+--------------------------------------------------------------*/\n\n\n\n//#define ERROR_BUFF 512 szm\n#define ERROR_BUFF 4096\n\tstatic char g_ebb\u00c4 ERROR_BUFF \u00dc;\n\tstatic char g_ebb_flag = 0;\n\n\n\tvoid * TEXTVER();\n\tMSGE * tCHARp(char * c ,int l)\n\t\t\u00e4 return new MSGE(c,l);\u00fc\n\tMSGE * tINT(int i,int l )\n\t\t\u00e4 return new MSGE(i,l); \u00fc\n\tMSGE * tSHORT(int i,int l )\n\t\t\u00e4 return new MSGE(i, l);\u00fc\n\tMSGE * tmvsSTRING( mvsSTRING & s,int l )\n\t\t\u00e4 return new MSGE(s,l); \u00fc\n\tMSGE * tHEX(int i ,int  l  )\n\t\t\u00e4 return new MSGE(i,l,msgfx);\u00fc\n\tMSGE * tHEX(char * c, int l)\n\t\t\u00e4 return new MSGE(c,l,msgfx);\u00fc\n\n\tMSGE::MSGE():length(0), type(msgundef),to(NULL)\u00e4\u00fc\nMSGE::MSGE(int i,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmint = i;length = l; type = msgint;form = f;\n\t\u00fc\nMSGE::MSGE(short s,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmshort = s; length = l; type = msgshort;form = f;\n\t\u00fc\nMSGE::MSGE(char * c,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmcharp = c; if ( l == 0) l = int(strlen(c)); length = l;\n\ttype = msgcharp;\n\tform = f;\n\t\u00fc\nMSGE::MSGE(const mvsSTRING &s,int l,MSGEForm f):to(NULL)\n\t\u00e4\n\tmmvsSTRING = new mvsSTRING(s);\n\tif ( l == 0) l = int(mvsSTRING(s).lengthOf());\n\tlength = l;\n\ttype = msgmvsSTRING;\n\tform = f;\n\t\u00fc\nMSGE:: MSGE(char c):to(NULL)\n\t\u00e4\n\tmchar = c;\n\tlength = 1;\n\ttype = msgchar;\n\tform = msgfc;\n\t\u00fc\n\n\n\n\n/*--------------------------------------------------------------+\n]                                                               ]\n]  MSGE format                                                  ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\nchar * MSGE::format()\n\t\u00e4\n\tchar * f;\n\tto = new char\u00c42*length+1\u00dc;//szm20050907 heap demage in uprun\n\n\n\tswitch(form)\n\t\t\u00e4\n\t\tcase msgfc: f = \"%c\";\n\t\t\tbreak;\n\t\tcase msgfd: f = \"%*d\";\n\t\t\tbreak;\n\t\tcase msgfs: f = \"%*s\";\n\t\t\tbreak;\n\t\tcase msgfx: f = \"x\u00d6\"%0*x\u00d6\"\";\n\t\t\tbreak;\n\t\t\u00fc\n\n\tswitch ( type)\n\t\t\u00e4\n\t\tcase msgshort:sprintf(to,f,length,mshort);\n\t\t\tbreak;\n\t\tcase msgint  :sprintf(to,f,length,mint);\n\t\t\tbreak;\n\t\tcase msgcharp:sprintf(to,f,length,mcharp);\n\t\t\tbreak;\n\t\tcase msgmvsSTRING: sprintf(to,f,length,(char * )(*mmvsSTRING));\n\t\t\tbreak;\n\t\tcase msgchar: sprintf(to,f,mchar);\n\t\t\tbreak;\n\t\t\u00fc\n\treturn to;\n\t\u00fc\n\n\n/*--------------------------------------------------------------+\n]                                                               ]\n]  TEXT class                                                   ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\nstatic TEXTENTRY Textvector\u00c4\u00dc =\n\t\u00e4\n#define  MESSAGE_TEXT\n#define t( a , b ) \u00e4 a , b \u00fc ,\n#include \"msgtext.hpp\"\n#undef t\n#undef   MESSAGE_TEXT\n\t\t\u00e40,0\u00fc\n\t\u00fc;\n\nint initMessageText()\n\n\t\t\u00e4\n\t\tif (messagetext==NULL)\n\t\t\tmessagetext = new MessageTEXT();\n\t\treturn 0;\n\t\t\u00fc\n\nMessageTEXT::MessageTEXT(char * fn ,char * logstream)\n\t\u00e4\n\tif ( fn)\n\t\t\u00e4\n\t\tmsgfilename = new char\u00c4strlen(fn)+1\u00dc;\n\t\tstrcpy(msgfilename,fn);\n\t\t\u00fc\n\telse msgfilename = 0;\n\tonlylogger = false;\n\tlogger = false; //szm20060410 init logger\n\tif (logstream)\n\t\t\u00e4\n\t\tif (mvs()->LoggerOpen(logstream))\n\t\t\tlogger = true;\n\t\telse\n\t\t\tlogger = false;\n\t\t\u00fc\n\tmsgfile = NULL; //szm\n\tvector = Textvector;\n\tprintfv = 0;\n\ttimestemp = 1;\n\t\u00fc\n\nvoid MessageTEXT::setFileName(char * fn)\n\t\u00e4\n\tif ( fn)\n\t\t\u00e4\n\t\tmsgfilename = new char\u00c4strlen(fn)+1\u00dc;\n\t\tstrcpy(msgfilename,fn);\n\t\t\u00fc\n\telse msgfilename = 0;\n\t\u00fc\n\nvoid MessageTEXT::setLogger(const char *logstream)\n\t\u00e4\n\tif (logstream)\n\t\t\u00e4\n\t\tif (mvs()->LoggerOpen(logstream))\n\t\t\tlogger = true;\n\t\telse\n\t\t\tlogger = false;\n\t\t\u00fc\n\t\u00fc\n\nMessageTEXT::\u00dfMessageTEXT()\n\t\u00e4\n\tif (msgfile) fclose(msgfile); //szm\n\tif (logger)  mvs()->LoggerClose();\n\tlogger = false;\n\tdelete \u00c4\u00dc msgfilename;\n\t\u00fc\n\nchar * MessageTEXT::getText(int i)\n\t\u00e4\n\t// printf(\"Message %d \u00d6n\",i);\n\n\tTEXTENTRY * te = Textvector;\n\twhile (te->t && (te->i > 0)  )\n\t\t\u00e4\n\t\tif ( te->i == i )\n\t\t\t\u00e4\n\t\t\t//      printf(\"%s\u00d6n\",te->t);\n\t\t\treturn te->t;\n\t\t\t\u00fc\n\t\tte++;\n\t\t\u00fc\n\t// printf(\"Undefined message %d\u00d6n\",i );\n\tsprintf(deflt,\"Undefined message %d\u00d6n\",i );\n\treturn deflt;\n\n\t\u00fc\n\nint MessageTEXT::copyText(int i,char * to,int l)\n\t\u00e4\n\tchar   tm\u00c4ERROR_BUFF\u00dc;\n\tchar * from = getText(i);\n\tif (messagetext->getTimeStempFlag() )\n\t\t\u00e4\n\t\tchar tt\u00c432\u00dc;\n\t\tchar fm\u00c4\u00dc = \"%Y:%m:%d %H:%M:%S \";\n\t\tformatTime(tt,sizeof(tt),fm);\n\t\tstrcpy(tm,tt);\n\t\tstrcat(tm,from);\n\t\tfrom = tm;\n\t\t\u00fc\n\n\tint lf = strlen(from);\n\tif ( lf <= l)\n\t\tstrcpy(to,from);\n\telse\n\t\t\u00e4\n\t\tmemcpy(to,from,l-1);\n\t\tto\u00c4l-1\u00dc  = null;\n\t\t\u00fc\n\treturn ( l -lf );\n\t\u00fc\n\nchar * MessageTEXT::print(char * t)\n\t\u00e4\n\tif (|onlylogger)\n\t\t\u00e4\n\t\tif ( msgfilename)\n\t\t\t\u00e4\n\t\t\tif (msgfile == NULL)\n\t\t\t\tmsgfile = fopen(msgfilename,\"wt,type=record\"); //szm\n\t\t\tif (msgfile)\n\t\t\t\t\u00e4\n\n\t\t\t\t//fprintf(msgfile,\"%s\u00d6n\",t); szm\n\t\t\t\tfputs(t,msgfile);\n\t\t\t\tfflush(msgfile);\n\t\t\t\t//fclose(msgfile); //szm\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\tif ( printfv ) printfv(t);\n\t\telse\n\t\t\tputs(t);\n\t\t\u00fc\n\tif (logger)\n\t\tmvs()->Logger(t);\n\treturn t;\n\t\u00fc\n\nvoid MessageTEXT::setNumber(int n)\n\t\u00e4\n\tnumber = n;\n\tvi = 0;\n\tfor (int i=0;i<8;i++)v\u00c4i\u00dc = 0;\n\t\u00fc\n\n\nMessageTEXT&  MessageTEXT::operator<<(int i)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tINT(i);\n\treturn * this;\n\t\u00fc\n#if 0   //szm\nMessageTEXT&  MessageTEXT::operator<<(short i)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tSHORT(i);\n\treturn * this;\n\t\u00fc\n#endif\nMessageTEXT&  MessageTEXT::operator<<(char *c)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tCHARp(c);\n\treturn * this;\n\t\u00fc\n\nMessageTEXT&  MessageTEXT::operator<<(const mvsSTRING& s)\n\t\u00e4\n\tmvsSTRING temp = s;\n\tv\u00c4vi++\u00dc = tmvsSTRING(temp);\n\treturn * this;\n\t\u00fc\n\nMessageTEXT&  MessageTEXT::operator<<(void * p)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tHEX((char *)p,8);\n\treturn * this;\n\t\u00fc\nchar * MessageTEXT::operator<<(const EOL eol)\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tint i;\n\tmemset(ebb,null,sizeof(ebb));\n\tcopyText(number,format,ERROR_BUFF);\n\n\tfor(i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = v\u00c4i\u00dc;\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);              break;\n\t\t\u00fc\n\n\tprint(ebb);\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\n\t\tif ( v\u00c4i\u00dc )\n\t\t\t\u00e4 delete v\u00c4i\u00dc ; v\u00c4i\u00dc = 0;\u00fc\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->err(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn g_ebb;\n\t\u00fc\n\n\n/*--------------------------------------------------------------+\n]  Text formatting                                              ]\n]                                                               ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\n\n\nMessageTEXT& Err(int number)\n\t\u00e4\n\tif (messagetext==NULL)\n\t\tmessagetext = new MessageTEXT();\n\tmessagetext->setNumber(number);\n\treturn (*messagetext);\n\t\u00fc\nMessageTEXT& Msg(int number)\n\t\u00e4\n\tif (messagetext==NULL)\n\t\tmessagetext = new MessageTEXT();\n\tmessagetext->setNumber(number);\n\treturn (*messagetext);\n\t\u00fc\n\nint   Error(int number , ...   )\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tMSGE *mv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tmemset(ebb,null,sizeof(ebb));\n\tva_list ap;\n\tva_start(ap, number);\n\n\tmessagetext->copyText(number,format,ERROR_BUFF);\n\n\tint i;\n\tfor(i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tmv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = (MSGE *)(va_arg(ap,void *));\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\tmv \u00c4i\u00dc = msge;\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);               break;\n\t\t\u00fc\n\n\tmessagetext->print(ebb);\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tif ( mv\u00c4i\u00dc ) delete mv\u00c4i\u00dc ;\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->err(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn 0;\n\t\u00fc\n\n\nchar *  Message(int number , ...   )\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tMSGE *mv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tmemset(ebb,null,sizeof(ebb));\n\tva_list ap;\n\tva_start(ap, number);\n\n\tmessagetext->copyText(number,format,ERROR_BUFF);\n\n\tint i;\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tmv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = (MSGE *)(va_arg(ap,void *));\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\tmv \u00c4i\u00dc = msge;\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);               break;\n\t\t\u00fc\n\n\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tif ( mv\u00c4i\u00dc ) delete mv\u00c4i\u00dc ;\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->log(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn g_ebb;\n\t\u00fc\n\n\nchar * getErrorText()\n\t\u00e4\n\tif ( g_ebb_flag == 0 ) return 0;\n\tg_ebb_flag = 0;\n\tif (messagetext->getTimeStempFlag()) return g_ebb+19;\n\telse return g_ebb ;\n\t\u00fc\n\nchar * getMessageText()\n\t\u00e4\n\tif (messagetext->getTimeStempFlag()) return g_ebb+19;\n\telse return g_ebb ;\n\t\u00fc\n\nExternalTEXT::ExternalTEXT(char * name ):language('E')\n\t\u00e4init(name);\u00fc\nExternalTEXT::ExternalTEXT(char * name, char lang ):language(lang)\n\t\u00e4init(name);\u00fc\n\nvoid ExternalTEXT::init(char * name)\n\t\u00e4\n\tmodulname\u00c40\u00dc = language==' ' ? 'E':language;\n\tstrcpy(modulname+1,name);\n\tdllhandle * handle = dllload(modulname);\n\t//fp = (void *(*)())dllqueryfn(handle,\"_dynamn\");\n\tfp = (EXT_C_fp)dllqueryfn(handle,\"_dynamn\");\n\tif (fp == 0)\n\t\t\u00e4\n\t\tchar _b\u00c4128\u00dc;\n\t\tsprintf(_b,\"unable to load the '%s' text module \u00d6n handle:%p function:%p d\u00d6n\",modulname,handle,fp);\n\t\tputs(_b);\n\t\tabort();\n\t\t\u00fc\n\ttext = fp();\n\t\u00fc\n\nint ExternalTEXT::MSGTEXT(int id, char * buff,int len)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\t\u00e4 if ( id == atoi(etp->cid) )\n\t\t\t\u00e4\n\t\t\tstrncpy(buff,*(etp->ett),len-1);\n\t\t\t*(buff+len-1) = 0;\n\t\t\treturn 1;\n\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t*buff = 0;\n\t\treturn 0;\n\t\u00fc\n\nchar * ExternalTEXT::HelpText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn *(etp->ett);\n\treturn 0;\n\t\u00fc\n\nselection* ExternalTEXT::SelectionText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn (selection *)(etp->ett);\n\treturn 0;\n\t\u00fc\n\nentry * ExternalTEXT::EntryText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn (entry *)(etp->ett);\n\treturn 0;\n\t\u00fc\n\n\t\u00fc //namespace isis_ns_mvs\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGTEXT": {"ttr": 173, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/msgtext.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\nt(9001,\"IQW9001E the program '%s' called from '%s' ended with %s\")\nt(9002,\"IQW9002E the received line  length %s is too long for the scanner\")\nt(9003,\"IQW9003E invalid HTTP header record: '%s'\")\nt(9004,\"IQW9004E the request header format is invalid '%s'\")\nt(9005,\"IQW9005E unable to load the '%s' program\")\nt(9006,\"IQW9006E unable to open '%s' file for '%s' HTML\")\nt(9007,\"IQW9007E unable to open cache-list: '%s'\")\nt(9008,\"IQW9008E internal variable access error '%s'\")\nt(9010,\"IQW9010E service unvaliable '%s'\")\nt(9011,\"IQW9011E bad request for '%s'\")\nt(9012,\"IQW9012E unable to processs '%s' request\")\nt(9020,\"IQW9020E invalid query '%s'\")\nt(9021,\"IQW9021E Error from DB/2:'%s'\")\nt(9022,\"IQW9022E Nothing selected\")\nt(9024,\"IQW9024E Nothing selected\")\nt(9025,\"IQW9025E inavlid skeleton '%s'\")\nt(9050,\"IQW9050E invalid multpart/form-data format:%s\")\nt(9051,\"IQW9051E invalid entry in multipart/form-data:%s\")\nt(9052,\"IQW9052E invalid content type:%s\")\nt(9053,\"IQW9053E boundary missing\")\nt(9054,\"IQW9054E invalid AFP input data\")\nt(9091,\" %s\")\nt(9092,\" %s %s\")\nt(9093,\" %s %s %s\")\nt(9120,\"IQW9120E invalid URL entry '%s' in '%s' URL\")\nt(9121,\"IQW9121E logic error for '%s' in '%s' URL\")\nt(9122,\"IQW9122E unable to open '%s'\")\nt(9123,\"IQW9123E unable to get '%s' skeleton HTML\")\nt(9124,\"IQW9124E unable to get'%s' directory\")\nt(9125,\"IQW9125E unable toget '%s' from catalog\")\nt(9126,\"IQW9126E invalid URL '%s'\")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSBASE": {"ttr": 189, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/mvsbase.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#ifndef MU_STANDALONE\n#include \"pcsdll.hpp\"\n#include \"systems.hpp\" //szm\n#else\n\t#ifndef stricmp\n    #define stricmp strcmpi\n\t#endif\n\t#ifndef strcmpi\n\t\t#define strcmpi strcasecmp\n\t#endif\n\t#define MVSBatch() 1\n\t#ifndef PCS_MAX_PATH\n\t\t#define PCS_MAX_PATH 1024\n\t#endif\n#endif\n\n#include \"mvsbase.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0 //szm\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#ifdef CALL_TAG\n#include \"pphctags.hpp\"\n#endif\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <assert.h>\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <strings.h>\n#include <ctype.h>\n#include <new.h>\n\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n\n#include \"ibmdebug.hpp\"\n#if defined(ISIS_PF_MI) ]] defined (ISIS_PF_MU)\n#include <ctest.h>\n#endif\n#endif\n\n#define MVSBASE  0\nchar mvsSTRING::parseSepCh=0 ; //szm20061218 mvsSTRING parse escape ch is null|||||||\n\nmvsSTRING nullstring(\"\"); //szm\n\n//KV20050203 why not for ms,mu ??\n//#if defined(ISIS_PF_MS)==0 && defined(ISIS_PF_MU)==0\nvoid * memcpyp(void * target , const void * source, size_t tsize, size_t ssize, int pad)\n\t\u00e4\n\tif ( target == 0 ]] source == 0 ]] tsize <= 0) return NULL;\n\tif( tsize<=ssize)\n\t\tmemcpy(target,source,tsize);\n\telse\n\t\t\u00e4\n\t\tmemcpy(target,source,ssize);\n\t\tfor(;ssize<tsize;ssize++) *((char *)target+ssize) = char(pad);\n\t\t\u00fc\n\treturn target;\n\t\u00fc\n\nstatic const char * SAS_HFS = \"hfs\";\nstatic const char * IBM_HFS = \"///\";\nstatic const char * SAS_DSN = \"dsn\";\nstatic const char * IBM_DSN = \"//\";\nstatic const char * SAS_DDN = \"ddn\";\nstatic const char * IBM_DDN  = \"dd\";\nstatic const char * IBM_DDN_SLASH = \"//dd\";\nstatic const char * _MEM     = \"mem\"; //szm0040909\nstatic const char * IBM_OMS  = \"oms\"; //szm20080215 ToDo 17339\nstatic const char * IBM_HTTP = \"http\"; //szm\nstatic const char * IBM_HTTPS = \"https\"; //szm\n\n\ngenOpenNameType genOpenType(const char *name)\n\t\u00e4\n\tchar  nm\u00c4256\u00dc;\n\tchar  np\u00c4256\u00dc;\n\tchar  pf\u00c432\u00dc;\n\tmemset(pf,0,sizeof(pf));\n\tgenOpenNameType t = ont_unknown;\n\n\tif (name == 0 ]] strlen(name) > sizeof(nm))\n\t\treturn(t);\n\n\tstrcpy(np,name);\n\tchar * n = (char *)np;\n\tchar * c = NULL;\n\tif ((c = strchr(n,int(':'))) NEQ NULL)\n\t\t\u00e4\n\t\t*c = 0;\n\t\tstrcpy(pf,n);\n\t\tn  =  c+1;\n\t\t\u00fc\n\tif (stricmp(pf,IBM_OMS))  //szm20080215 ToDo 17339\n\t\t\u00e4                       //szm20080215 ToDo 17339\n\t\tif (stricmp(pf,SAS_HFS) == 0) t = sas_hfs;\n\t\telse if (stricmp(pf,_MEM) == 0) t = ont_mem;   //szm0040909\n\t\telse if (stricmp(pf,IBM_DDN) == 0 ]] stricmp(pf,IBM_DDN_SLASH) == 0) t = ibm_ddn;\n\t\telse  if (stricmp(pf,SAS_DDN) == 0) t = sas_ddn;\n\t\telse if (stricmp(pf,SAS_DSN) == 0) t = sas_dsn;\n    else if (stricmp(pf,IBM_HTTP) == 0]]stricmp(pf,IBM_HTTPS) == 0) t = ibm_hfs; //szm\n\t\telse\n\t\t\t\u00e4\n      if (strncasecmp   (np,IBM_HFS,strlen(IBM_HFS)) == 0 ]] (np\u00c40\u00dc == '/' && np\u00c41\u00dc-'/') ]](np\u00c40\u00dc == '.' && np\u00c41\u00dc=='/'))//szm\n\t\t\t\tt = ibm_hfs;\n\t\t\telse if (strncasecmp   (np,IBM_DSN,strlen(IBM_DSN)) == 0) t = ibm_dsn;\n\t\t\t//KV20050419 in mvsbatch execution dataset names and ddnames don't need prefix\n\t\t\t// in unix execution such names are interpreted as unix file names\n\t\t\telse if(MVSBatch())\n\t\t\t\t\u00e4\n\t\t\t\tif (*n == '\"' ]] *n =='\u00d6'') t = ibm_dsn;\n\t\t\t\telse if (strchr(n,'(') && (strchr(n,'(')-n) <= 8 ) t = ont_ddn;\n\t\t\t\telse if (strchr(n,'.')) t = ont_dsn;\n\t\t\t\telse if (strlen(n) <= 8) t = ont_ddn;\n\t\t\t\telse if (strlen(n) <=18 && strchr(n,'(') && strchr(n,')')) t = ont_ddn;\n\t\t\t\telse\n\t\t\t\t\tt = ont_unknown;\n\t\t\t\t\u00fc\n\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\tt=ibm_hfs;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc //szm20080215 ToDo 17339\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) //ZA030711\n\t//  HOST_IBM_TRACE_sd(name,t);\n#endif\n\treturn t;\n\t\u00fc\n\n\n//KV20060329 buffer nm to avoid static variable\nchar * onlyMemberName(const char * n, char* nm)\n\t\u00e4\n\tmvsSTRING s(n), p0, p1, p2;\n\ts.parse(p0,\"(\",p1,\")\",p2);\n\tstrcpy(nm,(char *)(p1));\n\treturn nm;\n\t\u00fc\n\n//KV20060329 buffer nm to avoid static variable\nchar * stripMemberName(const char * n, char* nm)\n\t\u00e4\n\tmvsSTRING s(n), p0, p1, p2;\n\ts.parse(p0,\"(\",p1,\")\",p2);\n\tstrcpy(nm,(char *)(p0+p2));\n\treturn nm;\n\t\u00fc\n\n//KV20060329 buffer nm to avoid static variable\nISIS_EXT_C\nchar * genOpenName(const char *name,char *nm)\n\t\u00e4\n\tchar  np\u00c4256\u00dc;\n\tchar  pf\u00c432\u00dc;\n\tmemset(pf,0,sizeof(pf));\n\tgenOpenNameType t = ont_unknown;\n\n\tif (name == 0 ]] strlen(name) > PCS_MAX_PATH-1)\n\t\treturn(\"??invalid name??\");\n\n\tif (*name-'\"' && *name-'\u00d6'')\n\t\t\u00e4\n\t\tstrcpy(np,name);\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tstrcpy(np,name+1);\n\t\t//KV20030714: avoid deleting ending qoutes for //'datat.set.name'\n\t\tif (np\u00c4strlen(np)-1\u00dc == '\"' ]] np\u00c4strlen(np)-1\u00dc == '\u00d6'')\n\t\t\tnp\u00c4strlen(np)-1\u00dc  = 0;\n\t\t\u00fc\n\tfor(int i =strlen(np)-1;i>=0&&np\u00c4i\u00dc==' ';i--)np\u00c4i\u00dc=0;\n\tt = genOpenType(np);\n\n\tchar * n = (char *)np;\n\tchar * c = NULL;\n\tif ((c = strchr(n,int(':'))) NEQ NULL)\n\t\t\u00e4\n\t\t*c = 0;\n\t\tstrcpy(pf,n);\n\t\tn  =  c+1;\n\t\t\u00fc\n\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) // IBM or UNIX (not SAS)szm20031030\n\tif (strcmp(\"(*)\",n+strlen(n)-3)==0) //szm 20100628 zOS 1.11 fopen difference\n\t\t*(n+strlen(n)-3) = 0;       //szm 20100628 zOS 1.11 fopen difference\n\tswitch(t)\n\t\t\u00e4\n\t\tcase ont_mem:         //szm0040909\n\t\t\tsprintf(nm,\"mem:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_dsn:\n\t\t\tif (*(n+2) - '\u00d6'')\n\t\t\t\tsprintf(nm,\"//'%s'\",n+2);\n\t\t\telse\n\t\t\t\tstrcpy(nm,n);\n\t\t\tbreak;\n\t\tcase sas_dsn:\n\t\tcase ont_dsn:\n\t\t\tif (*n - '\u00d6'')\n\t\t\t\tsprintf(nm,\"//'%s'\",n);\n\t\t\telse\n\t\t\t\tsprintf(nm,\"//%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_ddn:\n\t\tcase sas_ddn:\n\t\tcase ont_ddn:\n\t\t\tsprintf(nm,\"//dd:%s\",n);\n\t\t\tbreak;\n\t\tcase sas_hfs:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_hfs:\n\t\tcase ont_unknown:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\t\u00fc\n#else\n\tswitch(t)\n\t\t\u00e4\n\t\tcase ont_mem:         //szm0040909\n\t\t\tsprintf(nm,\"mem:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_dsn:\n\t\tcase sas_dsn:\n\t\tcase ont_dsn:\n\t\t\tsprintf(nm,\"dsn:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_ddn:\n\t\tcase sas_ddn:\n\t\tcase ont_ddn:\n\t\t\tsprintf(nm,\"ddn:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_hfs:\n\t\t\tsprintf(nm,\"hfs:%s\",nm+3);\n\t\t\tbreak;\n\t\tcase sas_hfs:\n\t\t\tsprintf(nm,\"hfs:%s\",n);\n\t\t\tbreak;\n\t\tcase ont_unknown:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\t\u00fc\n#endif\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n\tHOST_IBM_TRACE_sss(name,nm,n);\n#endif\n\treturn (nm);\n\t\u00fc\n\nUSHORT  Ushort(int i)\n\t\u00e4 return ((unsigned short)i);\u00fc\nUSHORT  Ushort(short s)\n\t\u00e4 return ((unsigned short)s);\u00fc\nUSHORT  Ushort(char c)\n\t\u00e4 return ((unsigned short)c);\u00fc\n\n\n/*--------------------------------------------------------------+\n]  mvsSTRING global class                                          ]\n]                                                               ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n/*\nFORMAT F_alcu(aLEFT,cUPPER);\nFORMAT F_alcw(aLEFT,cWORD);\nFORMAT F_arcu(aRIGHT,cUPPER);\n*/\n\nmvsSTRING::mvsSTRING()\n\t\u00e4\n\tst.l = 1;\n\tst.c = new char\u00c41\u00dc;\n\tst.type = str::_VALID;\n\tst.ltype = str::VARIABLE;\n\t*st.c = null;\u00fc\nmvsSTRING::mvsSTRING(const char * y)\n\t\u00e4\n\tchar * x = (y ? (char *) y : \"\");\n\tst.l = (long int ) strlen(x);\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tst.type = str::_VALID;\n\tst.ltype = str::VARIABLE;\n\tstrcpy(st.c,x);\n\t\u00fc\nmvsSTRING::mvsSTRING(const mvsSTRING & x )\n\t\u00e4\n\tst.l = x.st.l;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tst.type = x.st.type ;\n\tst.ltype = x.st.ltype ;\n\tmemcpy(st.c,x.st.c,st.l+1);\n\t\u00fc\nmvsSTRING::mvsSTRING(const char * y,long int xl )\n\t\u00e4\n\tchar * x = y ? (char *) y : \"\";\n\tst.l = xl;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tif ( memchr(x,xl+1,0) ) st.type = str::_INVALID ;\n\telse     \u00e4  st.type = str::_VALID ; st.c\u00c4st.l\u00dc = 0; \u00fc\n\tmemcpy(st.c,x,xl);\n\t\u00fc\nmvsSTRING::mvsSTRING(const char def ,const long int xl )\n\t\u00e4\n\tst.ltype = str::FIX ;\n\tst.type  = str::_VALID;\n\tst.l = xl;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tmemset(st.c,def,st.l);\n\tst.c\u00c4st.l\u00dc = 0;\n\t\u00fc\nmvsSTRING::\u00dfmvsSTRING()\n\t\u00e4\n\tif ( st.c) delete \u00c4\u00dc st.c;\n\tif ( st.lls) delete \u00c4\u00dc st.lls;\n\t\u00fc\n\nmvsSTRING& mvsSTRING::operator=(const char * y )\n\t\u00e4\n\tchar * x = (y ? (char *)y : \"\");\n\tif ( x NEQ st.c)\n\t\t\u00e4 if ( st.ltype == str::VARIABLE )\n\t\t\u00e4\n\t\tchar * sv = st.c;\n\t\tst.l = (long int ) strlen(x);\n\t\tst.c = new char \u00c4st.l+1\u00dc;\n\t\tstrcpy(st.c,x);\n\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\tdelete \u00c4\u00dc sv;\n\t\tst.type = str::_VALID;\n\t\t\u00fc\n\t\telse\n\t\t\t\u00e4\n\t\t\tlong int l =(strlen(x)<= st.l ? strlen(x) : st.l);\n\t\t\tmemcpy(st.c,x,l);\n\t\t\tmemset(st.c+l,' ',st.l-l);\n\t\t\u00fc\n\t\t\u00fc\n\treturn * this ;\n\t\u00fc\nmvsSTRING& mvsSTRING::operator=(const mvsSTRING &x)\n\t\u00e4\n\tif (x.st.c NEQ st.c)\n\t\tif (st.ltype == str::VARIABLE )\n\t\t\t\u00e4\n\t\t\tchar * sv = st.c;\n\t\t\tst.l = x.st.l;\n\t\t\tst.c = new char\u00c4st.l+1\u00dc;\n\t\t\tmemcpy(st.c,x.st.c,st.l+1);\n\t\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\t\tdelete \u00c4\u00dc sv ;\n\t\t\t//   st.type = x.st.type;     don't assign fix type\n\t\t\t\u00fc\n\t\telse\n\t\t\t\u00e4\n\t\t\tst.ltype =str::FIX ;\n\t\t\tlong int l =(x.st.l<= st.l ? x.st.l : st.l);\n\t\t\tmemcpy(st.c,x.st.c,l);\n\t\t\tmemset(st.c+l,' ',st.l-l);\n\t\t\t\u00fc\n\t\treturn * this;\n\t\u00fc\n\nmvsSTRING & mvsSTRING::operator=(const sLL & s)\n\t\u00e4\n\tchar * sv = st.c;\n\tst.ltype = str::VARIABLE;\n\tst.l = s.getLength();\n\tst.c = new char\u00c4st.l\u00dc;\n\tmemcpy(st.c,s.getStart(),st.l);\n\tdelete \u00c4\u00dc sv;\n\treturn *this;\n\t\u00fc\n\nlong int operator==(const mvsSTRING & x, const mvsSTRING &y)\n\t\u00e4\n\tif (x.st.type == str::_VALID && y.st.type == str::_VALID)\n\t\treturn (strcmp(x.st.c,y.st.c) == 0);\n\telse if ( x.st.l == y.st.l)\n\t\treturn( memcmp(x.st.c,y.st.c,x.st.l) == 0 );\n\telse return 0;\n\t\u00fc\nlong int operator |=(const mvsSTRING & x, const mvsSTRING &y)\n\t\u00e4\n\treturn ( NOT( x == y) );\n\t\u00fc\n\nmvsSTRING operator+(const mvsSTRING& s1, const mvsSTRING& s2)\n\t\u00e4\n\tmvsSTRING r = s1;\n\tr+=s2;\n\treturn r;\n\t\u00fc\n/*\nmvsSTRING mvsSTRING::operator+(const mvsSTRING & x)\n\u00e4\nif ( &x == 0) return * this;\nmvsSTRING r;\nr.st.l = st.l + x.st.l;\nr.st.c = new char \u00c4 r.st.l+1\u00dc;\nmemcpy(r.st.c,st.c,st.l);\nmemcpy(r.st.c+st.l,x.st.c,x.st.l+1);\nif (st.type == str::_VALID && x.st.type == str::_VALID)\nr.st.type = str::_VALID ;\nelse r.st.type = str::_INVALID ;\nreturn r;\n\u00fc\n*/\n\nmvsSTRING& mvsSTRING::operator+=(const mvsSTRING& x )\n\t\u00e4\n\tif ( &x == 0 ) return * this;\n\tif ( st.ltype == str::VARIABLE )\n\t\t\u00e4\n\t\tchar * save = st.c;\n\t\tlong int savel = st.l;\n\t\tst.l += x.st.l;\n\t\tst.c  = new char \u00c4st.l+1\u00dc;\n\t\tmemcpy(st.c,save,savel);\n\t\tmemcpy(st.c+savel,x.st.c,x.st.l+1);\n\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\tdelete \u00c4\u00dc save;\n\t\tif ( st.type NEQ str::_VALID ]] x.st.type NEQ str::_VALID)\n\t\t\tst.type = str::_INVALID ;\n\t\t\u00fc\n\telse perror(\" unable to add to a fix mvsSTRING\");\n\treturn * this ;\n\t\u00fc\n\nchar& mvsSTRING::operator\u00c4\u00dc(int index)\n\t\u00e4\n\tif ( index < 0 ]] index > st.l)\n\t\t\u00e4perror(\" _INVALID index for \u00c4\u00dc operator \"); return st.c\u00c40\u00dc;\u00fc;\n\treturn st.c\u00c4index\u00dc;\n\t\u00fc\n\nchar& mvsSTRING::byte(int index)\n\t\u00e4\n\tif ( index < 0 ]] index > st.l)\n\t\t\u00e4perror(\" _INVALID index for \u00c4\u00dc operator \"); return st.c\u00c40\u00dc;\u00fc;\n\treturn st.c\u00c4index\u00dc;\n\t\u00fc\n\n\nmvsSTRING mvsSTRING::operator()(const long int o,  long int l = 1 )\n\t\u00e4\n\tif ( o < 0 ]] o+l > st.l ]]  l < 0 )\n\t\t\u00e4perror(\" _INVALID STRING operation\");return * this ;\u00fc\n\treturn mvsSTRING((const char *)(st.c+o),l);\n\t\u00fc\n\nvoid mvsSTRING::operator<<(long int l)\n\t\u00e4\n\tif ( l <= 0 ]] l >= st.l) return ;\n\tchar * c = st.c;\n\tfor(long int i = 0;i<st.l;i++)\n\t\tif (i+l<st.l)\n\t\t\t\u00e4*(c+i) = *(c+i+l); *(c+i+l) = ' ';\u00fc\n\t\telse *(c+i) = ' ';\n\t\treturn ;\n\t\u00fc\n\nvoid mvsSTRING::operator>>(long int l)\n\t\u00e4\n\tif ( l <= 0 ]] l >= st.l) return ;\n\tchar * c = st.c;\n\tfor(long int i = st.l-1;i;i--)\n\t\tif (i-l>=0)\n\t\t\t\u00e4*(c+i)= *(c+i-l); *(c+i-l) = ' '; \u00fc\n\t\telse *(c+i) = ' ';\n\t\treturn ;\n\t\u00fc\n\nlong int mvsSTRING::hashcode()\n\t\u00e4\n\tlong int r = 0;\n\tfor (long int i = st.l ;i;i--)\n\t\tr = (r<<1) \u00ac (st.c\u00c4i\u00dc) ;\n\treturn (r<0 ? -r:r);\n\t\u00fc\nchar * mvsSTRING::nameOf()\n\t\u00e4\n\treturn \"mvsSTRING\" ;\n\t\u00fc\n\n/*\nlong int    mvsSTRING::lengthOf()\n\u00e4\nreturn st.l;\n\u00fc;\n*/\n\nvoid mvsSTRING::changeAll(char f,char t)\n\t\u00e4\n\tfor(char * c =st.c;*c;c++) if ( *c == f) *c = t;\n\t\u00fc\n\nvoid mvsSTRING::align(ALIGNTYPE falign)\n\t\u00e4\n\tlong int i , is , iz ;\n\tif ( st.type NEQ str::_VALID ) return ;\n\tswitch(falign)\n\t\t\u00e4\n\t\tcase aLEFT  :\n\t\t\tfor( i =0;i<st.l;i++)\n\t\t\t\tif (st.c\u00c4i\u00dc NEQ ' ') break ;\n\t\t\t*this<<i;\n\t\t\tbreak ;\n\t\tcase aRIGHT :\n\t\t\tfor( i=st.l-1;i;i--)\n\t\t\t\tif (st.c\u00c4i\u00dc NEQ ' ') break ;\n\t\t\t*this>>(st.l-1-i);\n\t\t\tbreak ;\n\t\tcase aCENTER:\n\t\t\tfor( is =0;is<st.l;is++)\n\t\t\t\tif (st.c\u00c4is\u00dc NEQ ' ') break ;\n\t\t\tfor( iz=st.l-1;iz;iz--)\n\t\t\t\tif (st.c\u00c4iz\u00dc NEQ ' ') break ;\n\t\t\tif ( is >= iz ) break ;\n\t\t\ti = (st.l-(iz-is))/2;\n\t\t\tif (i < is ) *this<<(is-i);\n\t\t\telse if( i>is) *this>>(i-is);\n\t\t\tbreak ;\n\t\tcase aASIS   :\n\t\tdefault :\n\t\t\treturn ;\n\t\t\u00fc\n\t\u00fc\nvoid mvsSTRING::caps(CAPSTYPE fcaps)\n\t\u00e4\n\tlong int i = st.l-1;\n\tif ( i <0 ]] st.type NEQ str::_VALID ) return ;\n\tlong int flag = 1;\n\tswitch(fcaps)\n\t\t\u00e4\n\t\tcase cUPPER :\n\t\t\twhile (i+1) st.c\u00c4i\u00dc = (char )toupper(st.c\u00c4i--\u00dc);\n\t\t\tbreak ;\n\t\tcase cLOWER :\n\t\t\twhile (i+1) st.c\u00c4i\u00dc = (char )tolower(st.c\u00c4i--\u00dc);\n\t\t\tbreak ;\n\t\tcase cWORD:\n\t\t\tfor(i=0;i<st.l;i++)\n\t\t\t\t\u00e4 if ( st.c\u00c4i\u00dc == ' ' ) flag = 1 ;\n\t\t\t\telse if (flag) \u00e4 flag = 0; st.c\u00c4i\u00dc =(char ) toupper(st.c\u00c4i\u00dc);\u00fc\n\t\t\t\telse st.c\u00c4i\u00dc = (char )tolower(st.c\u00c4i\u00dc); \u00fc\n\t\t\tbreak ;\n\t\tcase cASIS   :\n\t\tdefault :\n\t\t\treturn ;\n\t\t\u00fc\n\t\u00fc\n\nmvsSTRING& mvsSTRING::strip()\n\t\u00e4\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n\tchar linefeed = '\u00d6x15';\n\tchar horizontaltab = '\u00d6x05';\n#else\n\tchar linefeed  = '\u00d6x0a';\n\tchar horizontaltab = '\u00d6x09';\n#endif\n\tlong int is , iz ;\n\tif ( st.type NEQ str::_VALID ]]\n\t\tst.ltype == str::FIX ) return *this;\n\tfor( is =0;is<st.l;is++)\n\t\tif (st.c\u00c4is\u00dc NEQ ' ') break ;\n\tfor( iz=st.l-1;iz;iz--)\n\t\tif (st.c\u00c4iz\u00dc NEQ ' ' && st.c\u00c4iz\u00dc NEQ linefeed && st.c\u00c4iz\u00dc NEQ horizontaltab) break ;\n\tif ( is > iz ) *this = \"\";\n\telse \u00e4 st.c\u00c4iz+1\u00dc = 0; st.ltype = str::VARIABLE ;\n\tif (is) *this = (char *)&(st.c\u00c4is\u00dc);\n\telse\n\t\t\u00e4\n\t\tchar * temp = new char\u00c4strlen(st.c)+1\u00dc;\n\t\tstrcpy(temp,st.c);\n\t\t* this = temp ;\n\t\tdelete \u00c4\u00dc temp;\n\t\t\u00fc\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nint mvsSTRING::isEmpty()\n\t\u00e4\n\tif ( st.l == 0 ) return 1;\n\tmvsSTRING t = *this;\n\tt.st.ltype = str::VARIABLE;\n\tt.strip();\n\tif ( t.lengthOf() == 0) return 1;\n\treturn 0;\n\t\u00fc\n\nmvsSTRING& mvsSTRING::stripmvsSTRING()\n\t\u00e4\n\tst.ltype = str::VARIABLE;\n\tstrip();\n\treturn *this;\n\t\u00fc\nvoid mvsSTRING::parse(mvsSTRING& s , char c, mvsSTRING &rest )\n\t\u00e4\n\n\tchar *p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff=|off;\n\t\tif (|off&&st.c\u00c4i\u00dc==c)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\tif ( p ) \u00e4 *p = '\u00d6x00'; rest = p+1; s = st.c ; *p = c; \u00fc\n\telse\n\t\t\u00e4\n\t\ts = st.c;\n\t\trest = \"\";\n\t\t\u00fc\n\n\t\u00fc\nvoid mvsSTRING::parse(mvsSTRING& s , char * c, mvsSTRING & rest)\n\t\u00e4\n\tchar * p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff=|off;\n\t\tif (|off&&memcmp(st.c+i,c,strlen(c))==0)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\n\tif ( p)\n\t\t\u00e4\n\t\t//KV20051205 if s==*this or rest == *this then st.c might be deleted in assignment operator\n\t\t// -> p must not be used after assignment\n\t\tmvsSTRING tmp(st.c,p-st.c);\n\t\trest = p+strlen(c);\n\t\ts = tmp;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\ts = *this;\n\t\trest = \"\";\n\t\t\u00fc\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING& s1,char c1, mvsSTRING& s2, char c2,mvsSTRING& rest)\n\t\u00e4\n\tmvsSTRING re;\n\tchar * p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff|=off;\n\t\tif (|off&&st.c\u00c4i\u00dc==c1)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\n\tif (p)\n\t\t\u00e4\n\t\tparse(s1,c1,re);\n\n\t\tre.parse(s2,c2,rest);\n\t\t\u00fc\n\telse \u00e4 s1 = st.c; s2 = \"\"; rest = \"\"; \u00fc\n\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3);\n\t\t\u00fc\n\ts10 = s1;\n\ts20 = s2;\n\ts30 = s3;\n\n\t\u00fc\n\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tstrip();\n\tparse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.strip();\n\t\trest.parse(s2,c2,s3);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\n\t\u00fc\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30,\n\t\t\t\t\t\t\t\t\t\t\tchar * c3, mvsSTRING&s40)\n\t\u00e4\n\tparse(s10,c1,s20,c2,s30,c3,s40);\n\t\u00fc\n\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30,\n\t\t\t\t\t\t\t\t\t\t\tchar * c3, mvsSTRING&s40,\n\t\t\t\t\t\t\t\t\t\t\tchar * c4, mvsSTRING&s50)\n\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tmvsSTRING s4 = \"\";\n\tmvsSTRING s5 = \"\";\n\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3,c3,s4,c4,s5);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\ts40 = s4.strip();\n  s50 = s5.strip();\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s30, char * c3, mvsSTRING&s40)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tmvsSTRING s4 = \"\";\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3,c3,s4);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\ts40 = s4.strip();\n\t\u00fc\n\nvoid mvsSTRING::dump(const char * f,int l)\n\t\u00e4\n#if 0\n\tchar * use = \"mvsSTRING\";\n\t// if ( 0 ) //( __test__ )\n\t// ::dump((FILE *)f,use,st.c,st.l);\n\tchar _d\u00c41024\u00dc;\n\tsprintf(_d,\" File:%s Line:%d %s: %*s (%d %d %d) \u00d6n\",f,l,use,st.l,st.c,st.l,st.ltype,st.type);\n\tputs(_d);\n#endif\n\t\u00fc\n\nmvsSTRING& mvsSTRING::format(FORMAT * f)\n\t\u00e4\n\tcaps(f->fcaps);\n\talign(f->falign);\n\treturn * this ;\n\t\u00fc\n\nchar * mvsSTRING::getLlmvsSTRING()\n\t\u00e4\n\tst.lls = new char\u00c4st.l+2\u00dc;\n\t*(short*)st.lls = short(st.l);\n\tmemcpy(st.lls+2,st.c,st.l);\n\treturn st.lls;\n\t\u00fc\n\n\n\n\n#if 0\n\nmvsSTRING patternchng(mvsSTRING  input,char *  mask,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING  (*f)(mvsSTRING ))\n\t\u00e4\n\tchar * mv\u00c432\u00dc;\n\tlong int mflag = 1, mi = 0 ;\n\tlong int ml = strlen(mask);\n\tlong int i  , j ;\n\n\tfor(i=0;i<ml;i++)\n\t\t\u00e4  if ( *(mask+i) == '*' )\n\t\t\u00e4 *(mask+i ) = 0 ;\n\tmv\u00c4mi++\u00dc   = 0 ;\n\tmflag = 1;\n\t\t\u00fc\n\t\telse\n\t\t\tif (mflag)\n\t\t\t\t\u00e4 mflag = 0;\n\tmv\u00c4mi++\u00dc = mask+i ; \u00fc\n\t\t\u00fc\n\n\n\tlong int start = 0, stop = 0, offset = 0;\n\tmvsSTRING outputstr(\" \",0);\n\tmvsSTRING r = input ;\n\tchar * s ;\n\n\n\tfor(i=0;i<strlen(input);i++)\n\t\t\u00e4\n\t\tfor(j=0;j<mi;j++)\n\t\t\tif ( j == 0)\n\t\t\t\t\u00e4 if ( mv\u00c40\u00dc == 0)\n\t\t\t\t\u00e4 start = i ;  stop = strlen(input) ; \u00fc\n\t\t\t\telse if ( ( s = strstr(((char *)input)+i,mv\u00c40\u00dc) ) NEQ 0)\n\t\t\t\t\t\u00e4 start  = s - (char *)input ;  stop= start+strlen(mv\u00c40\u00dc);\n\t\toffset =stop-start ; \u00fc\n\t\t\t\telse \u00e4 stop = 0 ;break; \u00fc\n\t\t\t\t\u00fc\n\t\t\telse\n\n\t\t\t\t\u00e4\n\t\t\t\tif (  mv\u00c4j\u00dc == 0 ) \u00e4 stop =  strlen(input) ; continue ;\u00fc\n\n\t\t\t\telse if ( ( s = strstr((char *)input+start+offset,mv\u00c4j\u00dc)) NEQ 0 )\n\t\t\t\t\tstop = s-input+strlen(mv\u00c4j\u00dc);\n\t\t\t\telse \u00e4 stop = 0; break;\u00fc\n\t\t\t\t\u00fc\n\n\n\n\n\n\t\t\tif ( start < stop)\n\n\t\t\t\t\u00e4  outputstr  = outputstr + input(i,start-i);\n\t\t\tmvsSTRING t((char *)input+start,stop-start);\n\t\t\tr = input+stop;\n\t\t\toutputstr = outputstr + f(t) ;\n\t\t\ti =stop ;\n\t\t\tstart = stop = offset = 0;\n\t\t\t\t\u00fc\n\t\t\u00fc\n\toutputstr = outputstr+r;\n\treturn outputstr ;\n\n\t\u00fc\n#endif\n\n\n//#include <stdlib.h>\n\n\n\nsLLType  sLLTypeTable\u00c4\u00dc = \u00e4 sLLt0, sLLt1, sLLt2, sLLt3, sLLt4, sLLt0\u00fc;\n\n// Construtors:\n// default output\n//\n\n\nsLL::sLL(sLLType st , sLLUsage su,int l):mERROR()\n\t\u00e4\n\ttype = st;\n\tusage = su;\n\tstatus = sLLOk;\n\tallocl = 0;\n\n\tbase = child = (sLL*)0;\n\tllength = int(type);\n\n\tif ( usage NEQ sLLinput )\n\t\t\u00e4\n\t\tallocl = l;\n\t\tstart = new char \u00c4l\u00dc;\n\t\tstoredl = offset = llength;\n\t\tcursor = start+offset;\n\t\tlength = l;\n\t\tfromInt(start,length,llength);\n\t\t\u00fc\n\t\u00fc\n\n//\n// From a base sLL\n//\n\nsLL ::sLL (sLL  * b,int o,sLLType st):mERROR()\n\t\u00e4\n\tinit(b,o,st);\n\t\u00fc\n\n//\n// From a base SLL with offset\n//\n\nsLL::sLL(sLL * b,char  * s,\n\t\t\t\t sLLType st):mERROR()\n\t\u00e4\n\tinit(b,s-(b->start),st);\n\t\u00fc\n\n//\n// From a mvsSTRING\n//\n\nsLL ::sLL (char  * s,sLLType  st):mERROR()\n\t\u00e4\n\tallocl = 0;\n\tusage = sLLinput ;\n\ttype = st;\n\tstatus = sLLOk;\n\n\tbase = child =(sLL*)0;\n\tstoredl = llength = offset = int(st);\n\n\tlength = int(toInt(s,llength));\n\tstart = s;\n\tcursor = start+offset;\n\n\t\u00fc\n\nsLL :: sLL(char  * s, int ix):mERROR()\n\t\u00e4\n\tsLLType st = sLLTypeTable\u00c4ix\u00dc;\n\tusage = sLLinput ;\n\ttype = st;\n\tstatus = sLLOk;\n\n\tbase = child =(sLL*)0;\n\tstoredl =  llength = offset = int(st);\n\n\tlength = int(toInt(s,llength));\n\tstart = s;\n\tcursor = start+offset;\n\t\u00fc\n\n//\n// Copy constructor\n//\n\nsLL ::sLL (const sLL & f):mERROR()\n\t\u00e4\n\tallocl = f.allocl;\n\ttype   = f.type;\n\tusage  = f.usage;\n\tstatus = f.status;\n\n\tif ( usage NEQ sLLinput)\n\t\tstart = new char \u00c4f.allocl\u00dc;\n\telse\n\t\tstart = new char \u00c4f.length\u00dc;\n\n\tlength = f.length;\n\toffset = f.offset;\n\tllength = f.llength;\n\tstoredl = f.storedl;\n\tbase = NULL ;\n\tcursor = start+(f.cursor-f.start);\n\tmemcpy(start,f.start,length);\n\t\u00fc\n\n// Destructor\n\nsLL::\u00dfsLL()\n\t\u00e4\n\tif ( allocl ) delete \u00c4\u00dc start;\n\t\u00fc\n\n//\n// Assignemnt operator\n//\n\nsLL & sLL ::operator=(sLL  & from)\n\t\u00e4\n\tif ( &from == this ) return *this;\n\n\tif (allocl )\n\t\t\u00e4\n\t\tdelete \u00c4\u00dc start ;\n\t\t\u00fc\n\terr = from.err;\n\tallocl = from.allocl ? from.allocl : from.length;\n\tstart = new char \u00c4allocl\u00dc;\n\tlength = from.length;\n\n\tusage = from.usage;\n\ttype  = from.type;\n\tstatus = from.status;\n\tllength = from.llength;\n\toffset = from.offset;\n\tstoredl= from.storedl;\n\tcursor = start+(from.cursor-from.start);\n\n\tbase = from.base;\n\tchild = from.child;\n\n\tmemcpy(start,from.start,length);\n\treturn * this;\n\t\u00fc\n\nsLL::operator int()\n\t\u00e4\n\tif ( status == sLLOk && NOT iserror() )\n\t\t\u00e4\n\t\tif (usage == sLLinput) return  getRemainderLength() ;\n\t\telse return storeOk(1);\n\t\t\u00fc\n\n\telse\n\t\treturn 0;\n\t\u00fc\n\nchar  & sLL::operator\u00c4\u00dc(int o)\n\t\u00e4\n\tif ( offset < length )\n\t\treturn start\u00c4o\u00dc;\n\n\tstatus = sLLOf; markerror();\n\treturn dummy;\n\t\u00fc\n\n//\n// Iterate on base - child structure\n//\n\nsLL *sLL::iterate(sLLType st,int resetf)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tif ( resetf ) resetCursor();\n\tchild = new sLL(this,cursor,st);\n\tif (child->iserror()) return NULL;\n\treturn child;\n\t\u00fc\n\n//\n// Get back the next child\n//\n\nsLL  *sLL ::next()\n\t\u00e4\n\n\tif ( child == 0 ]] iserror() )\n\t\treturn (sLL *)0;\n\tint    l  = child->getFullLength();\n\tdelete child;\n\n\tif ( goCursor(l+type) )\n\t\t\u00e4\n\t\tcursor-=type;\n\t\tchild = new sLL(this,cursor,type);\n\t\treturn child;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tchild = 0;\n\t\treturn NULL;\n\t\t\u00fc\n\t\u00fc\nvoid sLL::remove(sLL& o)\n\t\u00e4\n\n\tsLL s(type,sLLoutputVar,storedl);\n\tsLL * si = iterate(type);\n\twhile ( si )\n\t\t\u00e4\n\t\tif ( si->getStart() NEQ o.getStart() )\n\t\t\ts<<(*si);\n\t\tsi = next();\n\t\t\u00fc\n\t*this = s;\n\t\u00fc\n\n// Get info\n\n\nsLL   * sLL ::getBase()\u00e4 return base;\u00fc\nint     sLL ::getOffset()\u00e4 return offset;\u00fc\nint     sLL ::getFullLength()\u00e4 return length;\u00fc\nint     sLL ::getStoredLength()\u00e4 return storedl;\u00fc\nint     sLL ::getRemainderLength()\n\t\u00e4 if (status == sLLOk )\n\treturn (length - (cursor - start) ) ;\nreturn 0;\n\t\u00fc\nchar  * sLL ::getCursor()\u00e4 return cursor;\u00fc\nsLL   * sLL ::getChild()\u00e4 return child;\u00fc\nvoid    sLL ::setBase(sLL *b)\u00e4 base = b;\u00fc\nvoid    sLL ::setChild(sLL *c)\u00e4 child = c;\u00fc\nvoid    sLL ::setUsage(sLLUsage u)\n\t\u00e4\n\tif ( u == usage ) return;\n\n\tif ( u == sLLinput )\n\t\t\u00e4\n\t\tsetLength();\n\t\tlength = storedl;\n\t\tresetCursor();\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tcursor = start+length;\n\t\t\u00fc\n\tstatus = sLLOk;\n\tclearerror();\n\tusage = u;\n\t\u00fc\n// Cursor\n\nvoid sLL::resetCursor()\n\t\u00e4\n\tstatus = sLLOk;\n\tclearerror();\n\tcursor = start+llength;\n\tif ( usage NEQ sLLinput ) setLength();\n\n\t\u00fc\n\nchar  * sLL::goCursor(int v)\n\t\u00e4\n\tchar * c = cursor+v;\n\tif ( iserror() ]] status NEQ sLLOk ) return 0;\n\tif ( (c-start) <= length && (c-start ) >= llength )\n\t\t\u00e4\n\t\tcursor = c;\n\t\tif ( usage NEQ sLLinput) setLength();\n\t\treturn cursor ;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tstatus = sLLUf;\n\t\tcursor = start +length;\n\t\tmarkerror();\n\t\treturn 0;\n\t\t\u00fc\n\t\u00fc\n\nvoid sLL::setLength()\n\t\u00e4\n\tstoredl = cursor-start;\n\tfromInt(start,cursor-start,int(type));\n\t\u00fc\n\nsLL& sLL::operator >>(int& i)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ti = int(toInt(cursor,sizeof(int)));\n\tgoCursor(sizeof( int));\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(unsigned short& s )\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts =(unsigned short) toInt(cursor,sizeof(short));\n\tgoCursor(sizeof(short));\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(short& s )\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = short(toInt(cursor,sizeof(short)));\n\tgoCursor(sizeof(short));\n\treturn *this;\n\t\u00fc\n\n\nsLL& sLL::operator>>(char  & c)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tc = *cursor;\n\tgoCursor(1);\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator >>(char * & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts =  cursor;\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator>>(mvsSTRING & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = mvsSTRING(cursor,getRemainderLength());\n\tgoCursor(getRemainderLength());\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator >>(sLL& s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tsLL ns(cursor,s.type);\n\ts = ns;\n\tgoCursor(s.length);\n\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator>>(INT3 & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = int(toInt(cursor,3));\n\tgoCursor(3);\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(sLLskip & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tgoCursor(int(s));\n\treturn *this;\n\n\t\u00fc\n\nsLL& sLL::operator<<(int i)\n\t\u00e4\n\tif ( storeOk(sizeof(int)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,i,sizeof(i));\n\t\tgoCursor(sizeof(int));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(short i)\n\t\u00e4\n\tif ( storeOk(sizeof(short)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,i,sizeof(i));\n\t\tgoCursor(sizeof(short));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(unsigned short i)\n\t\u00e4\n\tif ( storeOk(sizeof(short)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,short(i),sizeof(i));\n\t\tgoCursor(sizeof(short));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(char  c)\n\t\u00e4\n\tif (storeOk(1))\n\t\t\u00e4\n\t\t*cursor=c;\n\t\tgoCursor(1);\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(char  * str)\n\t\u00e4\n\tint l = strlen(str);\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,str,l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(mvsSTRING & s)\n\t\u00e4\n\tint l = s.lengthOf();\n\tif (storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,(char *)(s),l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\nsLL& sLL::operator<<(sLL & s)\n\t\u00e4\n\tint l = s.getLength();\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,s.getStart(),l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(INT3& i)\n\t\u00e4\n\tif (storeOk(3)  )\n\t\t\u00e4\n\t\tfromInt(cursor,int(i),3);\n\t\tgoCursor(3);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(sLLskip& s)\n\t\u00e4\n\tif ( storeOk(int(s))  )\n\t\t\u00e4\n\t\tmemset(cursor,null,int(s));\n\t\tgoCursor(int(s));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::store(char  * p,int l)\n\t\u00e4\n\tif ( l <= 0 ) return *this;\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,p,l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\n//szm20050629\nmvsSTRING sLL::getString()\n\t\u00e4\n\tif ( *(getCursor()+getRemainderLength()) == '\u00d6x00' )\n\t\tstring = getCursor();\n\telse\n\t\t\u00e4\n\t\tchar * c = new char\u00c4getRemainderLength()+1\u00dc;\n\t\tc\u00c4getRemainderLength()\u00dc = null;\n\t\tmemcpy(c,getCursor(),getRemainderLength());\n\t\tstring = c;\n\t\tdelete \u00c4\u00dc c;\n\t\t\u00fc\n\treturn string;\n\t\u00fc\n//szm\n\n//\n// Utilies\n//\n\nvoid sLL::init(sLL * b,int o,sLLType st)\n\t\u00e4\n\ttype  = st;\n\tusage = sLLinput;\n\tstatus = sLLOk;\n\tallocl = 0;\n\tbase  = b;\n\tchild = 0;\n\tstart = (b->start)+o;\n\n\toffset = llength = int(st);\n\tcursor = start+offset;\n\tb->setChild(this);\n\tif ( usage == sLLinput  ]] b  )\n\t\tstoredl = length = int(toInt (start,llength));\n\telse\n\t\tstoredl = length = llength ;\n\t\u00fc\n\nint sLL::storeOk(int l)\n\t\u00e4\n#if defined(OWN_STDIO) == 0\n\tassert ( l >= 0 );\n#endif\n\tint r;\n\tif ( usage == sLLinput )\n\t\t\u00e4\n\t\tcursor = start+length;\n\t\tusage = sLLoutputVar;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tr = allocl -(cursor-start);\n\t\tif ( r >= l ) return 1;\n\t\tif ( usage == sLLoutput )\n\t\t\t\u00e4\n\t\t\tstatus = sLLOf;\n\t\t\treturn 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\tr =l+(cursor-start);\n\tchar * n = new char \u00c4r\u00dc;\n\n\tint o = cursor-start;\n\tmemcpy(n,start,o);\n\tif ( allocl )\n\t\tdelete \u00c4\u00dc start;\n\tlength = allocl = r;\n\tstart = n;\n\tcursor = n+o;\n\treturn 1;\n\t\u00fc\n\n//\n//\n//\n\nvoid sLL::dump(const char *f,int ln)\n\t\u00e4\n#if 0\n\tchar * use = (usage == sLLinput) ? \"Input\" : \"Output\" ;\n\tint l   = (usage == sLLinput) ? length : storedl;\n\tchar b\u00c41024\u00dc;\n\tsprintf(b,\" File:%s Line:%d %s %d \u00d6n\",f,ln,use,l\n\t\t);\n\tputs(b);\n\tstring.dump(f,ln);\n#endif\n\t\u00fc\n\n\nint sLL::write(void * f)\n\t\u00e4\n\treturn fwrite(start,1,getLength(),(FILE *)f);\n\t\u00fc\n\nsLL * readsLL(void* f,sLLType t)\n\t\u00e4\n\tint l;\n\tchar lx\u00c44\u00dc;\n\n\tif ( fread(lx,1,int(t),(FILE *)f) )\n\t\t\u00e4\n\n\t\tl = int(toInt(lx,int(t)));\n\t\tchar * b = new char \u00c4l\u00dc;\n\t\tmemcpy(b,lx,int(t));\n\t\tsLL * ret = NULL;\n\t\tif ( fread(b+int(t),1,l-int(t),(FILE *)f) )\n\t\t\t\u00e4\n\t\t\tsLL buff(b,t);\n\t\t\tret = new sLL(buff);\n\t\t\t\u00fc\n\t\tdelete \u00c4\u00dcb;\n\t\treturn ret;\n\n\t\t\u00fc\n\telse return NULL;\n\t\u00fc\n\n//--------------------------------------------------------------------\n//--------------------------------------------------------------------\n//--------------------------------------------------------------------\n\n/*\nsLLTag class fix type sLLt2 ( two bytes length)\nshort code\n...\n*/\n\nvoid sLLTag::init(short c )\n\t\u00e4\n\t//printf(\"code :%d\u00d6n\",c);\n\tcode = c ;\n\tsearchcode = 0;\n#ifdef CALL_TAG\n\tname = TagCatalog\u00c4code\u00dc ?(char *)(TagCatalog\u00c4code\u00dc->name) :  \"???\";\n#endif\n\t//  printf(\"%s\u00d6n\",name);\n\t\u00fc\n\nsLLTag::sLLTag():sLL(sLLt2,sLLoutputVar)\n\t\u00e4\n\tinit(0);\n\t(*this)<<short(0);\n\t\u00fc\n\nsLLTag::sLLTag(short c)\n#ifdef CALL_TAG\n:sLL(sLLt2,sLLoutputVar,TagCatalog\u00c4c\u00dc->maxlength+5)\n#endif\n\t\u00e4\n\tinit(c);\n\t(*this)<<c;\n\t\u00fc\n\nsLLTag::sLLTag(char * s):sLL(s)\n\t\u00e4\n\t(*this)>>code;\n\tinit(code);\n\t\u00fc\n\nsLLTag::sLLTag(const sLLTag & s):sLL(s)\n\t\u00e4\n\tcode = s.code;\n\tname = s.name;\n\tsearchcode = s.searchcode;\n\t\u00fc\n\nsLLTag::sLLTag(sLL * b,char  * s):sLL(b,s,sLLt2)\n\t\u00e4\n\t(*this)>>code;\n\tinit(code);\n\t\u00fc\n\nsLLTag& sLLTag::operator=(sLLTag&  from)\n\t\u00e4\n\n\tif ( &from == this ) return *this;\n\tthis->sLL::operator=(from);\n\tcode   = from.code;\n\tname   = from.name;\n\tsearchcode = from.searchcode;\n\treturn *this;\n\t\u00fc\n\nsLLTag * sLLTag::search(short c)\n\t\u00e4\n\tsLLTag * s ;\n\tsetUsage(sLLinput);\n\tif ( c )\n\t\t\u00e4\n\t\tsearchcode = c;\n\t\tresetCursor();\n\t\ts = iterate();\n\t\t\u00fc\n\telse s = next();\n\twhile( s && searchcode NEQ s->getCode() )\n\t\t\u00e4\n\t\ts = next();\n\t\t\u00fc\n\n\tstatus = sLLOk;\n\tclearerror();\n\treturn (s);\n\t\u00fc\n\nsLLTag * sLLTag::update(sLLTag & f )\n\t\u00e4\n\n\tsLLTag * s = search(f.code);\n\tif ( s )\n\t\t\u00e4\n\t\tremove(*s);\n\t\t\u00fc\n\t(*this)<<f;\n\treturn s;\n\t\u00fc\n\nvoid sLLTag::resetCursor()\n\t\u00e4\n\tsLL::resetCursor();\n\tgoCursor(sizeof(short));\n\t\u00fc\n\n\nvoid sLLTag::remove(sLLTag& o)\n\t\u00e4\n\n\tsLLTag s(code);\n\tresetCursor();\n\tsLLTag * si = iterate();\n\twhile ( si )\n\t\t\u00e4\n\t\tif ( si->getStart() NEQ o.getStart() )\n\t\t\ts<<(*si);\n\t\tsi = next();\n\t\t\u00fc\n\t*this = s;\n\t\u00fc\n\n\nsLLTag *sLLTag::iterate()\n\t\u00e4\n\n\tchild = new sLLTag(this,cursor);\n\tif (child->iserror()) return NULL;\n\t//child->dump(__FILE__,__LINE__);\n\treturn ((sLLTag *)child);\n\t\u00fc\n\n//\n// Get back the next child\n//\n\nsLLTag * sLLTag::next()\n\t\u00e4\n\n\tif ( child == 0 ]] iserror() )\n\t\treturn (sLLTag *)0;\n\tint l  = child->getFullLength();\n\tdelete child;\n\n\tif ( goCursor(l+type) )\n\t\t\u00e4\n\t\tcursor-=type;\n\t\tchild = new sLLTag(this,cursor);\n\t\t//child->dump(__FILE__,__LINE__);\n\t\treturn ((sLLTag *)child);\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tchild = 0;\n\t\treturn NULL;\n\t\t\u00fc\n\t\u00fc\n\nvoid sLLTag::dump(const char *f,int ln)\n\t\u00e4\n#if 0\n\tchar b\u00c41024\u00dc;\n\tsprintf(b,\" File:%s Line:%d Name:%s Code:%d \u00d6n\",f,ln,name,code);\n\tputs(b);\n\tsLL::dump(\"\",0);\n#endif\n\t\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSHSMX": {"ttr": 183, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#pragma runopts(PLIST(OS))\n//#pragma runopts(PLIST(OS),POSIX(ON))\n\n#include \"isisdef.h\"\n#include \"versinfo.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <dynit.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <strings.h>\n#include <string.h>\n#include <errno.h>\n#define _ISOC99_SOURCE 1\n#include <math.h>\n#define _OPEN_SYS_DIR_EXT\n#include <dirent.h>\n\n#include \"arcmck.hpp\"\n#include \"arcmcd.hpp\"\n#include \"f1dscb.hpp\"\ntypedef struct dscb f1dscb;\ntypedef struct arcmcd * arcmcdP;\ntypedef struct arcmck * arcmckP;\n\nstruct arcmdext\n\t\u00e4\n\tf1dscb * dscb;\n\tchar * * volser;\n\tvoid *   input;\n\tint  *   rc;\n\t\u00fc;\ntypedef arcmdext * arcmdextP;\n\nstruct arcmmext\n\t\u00e4\n\tarcmcdP * mcdp;\n\tint *  since;\n\tint *  flags;\n\tint *  rc;\n\t\u00fc;\ntypedef arcmmext * arcmmextP;\n\n#include \"msgmgr.hpp\"\n#include \"mvsbase.hpp\"\n#include \"misc.hpp\"\n#include \"casmif.hpp\"\n#include \"jobenv.hpp\"\n#include \"mchain.hpp\"\n\n#define RECALL_EXIT\t\t\t\"ARCRSTR\"\n#define ML2SYNC_PROGRAM \"ML2SYNC\"\n#define DSN_MIGRATION_EXIT\t\"ARCMDSN\"\n#define GEN_MIGRATION_EXIT  \"ARCMGEN\"\n#define MAKESPACE_CALL  \"MAKESPC\"\n#define MVSHSMX_MAJOR   \"ISISARCX\" //major name\nstatic char buff\u00c432768\u00dc;\nstatic const char * ml2dirParm =\"//DD:EXITPARM\";\nstatic bool  traceFlag = false;\nstruct _parm\n\t\u00e4\n\tchar * key;\n\tchar * value;\n\tint    valueI;\n\t\u00fc;\n\ntypedef struct _parm parm;\nparm _parms\u00c4\u00dc = \u00e4\n\t\u00e4\"unit\",\"3390\"\u00fc,\n\t\u00e4\"ml2dir\",\"/mntbin/linuxcompile/miklos/invalid\"\u00fc, //root -> ml2dir\n\t\u00e4\"delta\",NULL,1\u00fc,\n\t\u00e4\"lrecl\",NULL,2048\u00fc,\n\t\u00e4\"blksize\",NULL,18432\u00fc,\n\t\u00e4\"dynallocrc\",NULL,0x448\u00fc,\n\t\u00e4\"logger\",NULL\u00fc,\n\t\u00e4\"devtype\",NULL,0x20\u00fc,\n\t\u00e4\"ml2vol\",\"RES279\"\u00fc,\n\t\u00e4\"ml2mask\",\"DFHSM.HMIG.**\"\u00fc,\n\t\u00e4\"remove\",NULL,0\u00fc,                               //remove=0 -> remove=1\n\t\u00e4\"trace\",NULL,0\u00fc,\n  \u00e4\"mcds\",\"//DD:MIGCAT\"\u00fc,\n\t\u00e4NULL\u00fc\n\t\u00fc;\n\nenum parmEnum\n\t\u00e4\n\tunit,\n\tml2dir,\n\tdelta,\n\tlrecl,\n\tblksize,\n\tdynallocrc,\n\tlogger,\n\tdevtype,\n\tml2vol,\n\tml2mask,\n\tokToRemove,\n  trace,\n  mcds\n\t\u00fc;\n\nclass parms\n\t\u00e4\n\tpublic:\n\t\tparms()\n\t\t\t\u00e4\n\t\t\tFILE * f = fopen(ml2dirParm,\"r\");\n\t\t\tif (f==NULL)\n\t\t\t\t\u00e4\n\t\t\t\tMsg(6001)<<ml2dirParm<<strerror(errno)<<eol;\n\t\t\t\texit(8);\n\t\t\t\t\u00fc\n\t\t\twhile(fgets(buff,1024,f))\n\t\t\t\t\u00e4\n\t\t\t\tif (strchr(buff,'\u00d6n'))\n\t\t\t\t\t*strchr(buff,'\u00d6n') = 0;\n\t\t\t\tmvsSTRING record(buff), key, value;\n\t\t\t\trecord.parse(key,\"=\",value);\n\t\t\t\tkey.strip();\n\t\t\t\tvalue.strip();\n\t\t\t\t//Msg(6002)<<buff<<eol;\n\t\t\t\tbool ok =false;\n\t\t\t\tfor(int i =0;|ok&&i<=int(trace);i++)\n\t\t\t\t\tif (strcasecmp(_parms\u00c4i\u00dc.key,key)==0)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t_parms\u00c4i\u00dc.value  = strdup(value);\n\t\t\t\t\t\t_parms\u00c4i\u00dc.valueI = atoi(value);\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\tif (|ok)\n\t\t\t\t\t\tMsg(6003)<<key<<eol;\n\t\t\t\t\u00fc\n\t\t\tfclose(f);\n\t\t\t\u00fc\n\t\tchar * operator\u00c4\u00dc(parmEnum e)\n\t\t\t\u00e4\n\t\t\treturn _parms\u00c4int(e)\u00dc.value;\n\t\t\t\u00fc\n\t\tint operator()(parmEnum e)\n\t\t\t\u00e4\n\t\t\treturn _parms\u00c4int(e)\u00dc.valueI;\n\t\t\t\u00fc\n\t\t\u00dfparms()\u00e4\u00fc\n\t\u00fc;\n\nstatic int callDynalloc(__dyn_t * d)\n\t\u00e4\n\tint rc = dynalloc(d);\n\tif (traceFlag)\n\t\tprintf(\" <After dynalloc> rc:%d %x %x, dsn:%s ddn:%s\u00d6n\",\n\t\trc,d->__errcode,\n\t\td->__infocode,\n\t\td->__dsname,\n\t\td->__ddname);\n\tif (rc )\n\t\tMsg(6004)<<d->__dsname<<rc<<tHEX(d->__errcode)<<tHEX(d->__infocode)<<eol;\n\treturn rc;\n\t\u00fc\n\nstatic int makespace(parms &);\nstatic int ml2sync(parms &);\nenum cleanUpAction\n\t\u00e4\n\tAbort,\n\tExit8,\n\tExit0,\n\tReturn8,\n\tReturn0\n\t\u00fc;\nstatic FILE * nullfile = 0;\nstatic int cleanUp(cleanUpAction a,char * t,FILE * & f0 = nullfile,FILE * & f1 = nullfile,__dyn_t * ip = NULL,char * enqMinor = NULL)\n\t\u00e4\n\tif (f0)\n\t\t\u00e4\n\t\tfclose(f0);\n\t\tf0 = NULL;\n\t\t\u00fc\n\tif (f1)\n\t\t\u00e4\n\t\tfclose(f1);\n\t\tf1 = NULL;\n\t\t\u00fc\n\tif (ip)\n\t\tdynfree(ip);\n\tif (enqMinor)\n\t\tDEQ(MVSHSMX_MAJOR,enqMinor,6,STEP,NONE);\n\tswitch(a)\n\t\t\u00e4\n\t\tcase Abort:\n\t\t\tif (traceFlag)\n\t\t\t\tprintf(\" <Abort> %s\u00d6n\",t);\n\t\t\tabort();\n\t\tcase Exit8:\n\t\t\tif (traceFlag)\n\t\t\t\tprintf(\" <Exit8> %s\u00d6n\",t);\n\t\t\texit(8);\n\t\tcase Exit0:\n\t\t\tif (traceFlag)\n\t\t\t\tprintf(\" <Exit0> %s\u00d6n\",t);\n\t\t\texit(0);\n\t\tcase Return8:\n\t\t\tif (traceFlag)\n\t\t\t\tprintf(\" <Return8> %s\u00d6n\",t);\n\t\t\treturn 8;\n\t\tcase Return0:\n\t\tdefault:\n\t\t\tif (traceFlag)\n\t\t\t\tprintf(\" <Return0> %s\u00d6n\",t);\n\t\t\u00fc\n\treturn 0;\n\t\u00fc\n\nint main()\n\t\u00e4\n\n\tconst static char *version=ISIS_VERSION;\n\tconst static char *compileDate=ISIS_VERSION_DATE; // MW 20021104 __DATE__; //MF 20020419\n\n\tvoid * * R1 = __osplist;\n\tjobEnv = new JOBENV(\"????????\");\n\tarcmcdP mcd = arcmcdP(*R1);\n\t/*\n\tif (|(memcmp((char *)jobEnv->programRb,RECALL_EXIT,7)==0&&(int(mcd->mcdflgs)&(mcdfmig+mcdml2)))\n\t&&\n\tmemcmp((char *)jobEnv->programRb,MIGRATION_EXIT,7)) //migrate to ML2 and migvol devtype == x'20'\n\treturn 0;\n\t*/\n\tint rc = 0;\n\t__dyn_t ip;\n\n\tsetenv(\"_EDC_ADD_ERRNO2\",\"1\",1);\n\tmessagetext = new MessageTEXT();\n\tchar *program=(char *)jobEnv->programRb;\n\tparms p;\n\n\tif (strlen(p\u00c4logger\u00dc))\n\t\tmessagetext->setOnlyLogger(p\u00c4logger\u00dc);\n\ttraceFlag=(p(trace)==1);\n\tif (traceFlag)\n\t\tprintf(\" <Program> program:%s programRb:%s %s  CompileDate:%s Version:%s\u00d6n\",\n\t\t(char *)jobEnv->program,(char *)jobEnv->programRb,program,compileDate,version);\n\tif (traceFlag)\n\t\tprintf(\" <Logger>%s\u00d6n\",p\u00c4logger\u00dc);\n\n\tif (memcmp(program,DSN_MIGRATION_EXIT,7)==0]]memcmp(program,GEN_MIGRATION_EXIT,7)==0)\n\t\t\u00e4\n\t\tmakespace(p);\n\t\tarcmdextP md = (arcmdextP)R1;\n\t\tif (traceFlag)\n\t\t\tprintf(\"<ARCMxEXT> %44.44s %c \u00d6n\",(char *)(md->dscb->ds1dsnam),(char)md->dscb->ds1fmtid);\n\n\t\tif ((char)md->dscb->ds1fmtid == '1') //  it is an f1dscb , so we are in MD exit\n\t\t\t\u00e4\n\t\t\tif (strchr((char *)md->dscb->ds1dsnam,' '))\n\t\t\t\t*strchr((char *)md->dscb->ds1dsnam,' ')= 0;\n\t\t\tmd->dscb->ds1volsq\u00c40\u00dc = 0;\n\t\t\tMsg(6029)<<(char *)(md->dscb->ds1dsnam)<<(char *)(md->dscb->ds1dssn)<<eol;\n\t\t\t*(md->rc)=0;\n\t\t\t\u00fc\n\t\telse\n\t\t\t\u00e4\n\t\t\tarcmmextP mm = (arcmmextP)R1;\n\t\t\tif (traceFlag)\n\t\t\t\tprintf(\"<ARCMMEXT> %44.44s %44.44s %d %x\u00d6n\",(char *)((*(mm->mcdp))->mck),(char *)((*(mm->mcdp))->mcdmcanm),*(mm->since),*(mm->flags));\n\n\t\t\tif (strchr((char *)((*(mm->mcdp))->mck),' '))\n\t\t\t\t* strchr((char *)((*(mm->mcdp))->mck),' ') = 0;\n\t\t\tif (strchr((char *)((*(mm->mcdp))->mcdmcanm),' '))\n\t\t\t\t*\tstrchr((char *)((*(mm->mcdp))->mcdmcanm),' ') = 0;\n\t\t\tMsg(6031)<<\t(char *)((*(mm->mcdp))->mck)<<(char *)((*(mm->mcdp))->mcdmcanm)<<*(mm->since)<<eol;\n\t\t\t*(mm->rc) = 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\telse\n\t\tif (memcmp(program,MAKESPACE_CALL,7)==0)\n\t\t\t\u00e4\n\t\t\tmakespace(p);\n\t\t\t\u00fc\n\t\telse\n\t\t\tif (memcmp(program,RECALL_EXIT,7)==0)\n\t\t\t\t\u00e4\n\t\t\t\tif (traceFlag)\n\t\t\t\t\tprintf(\" <Flags> %x %x\u00d6n\",mcd->mcdflgs,mcd->mcdflag3);\n\t\t\t\tif (int(mcd->mcdflgs)&(mcdfmig+mcdml2) &&\n\t\t\t\t\tmcd->mcdflag3==p(devtype)) //migrate to ML2 and migvol devtype == x'20'\n\t\t\t\t\t\u00e4\n\t\t\t\t\tMsg(6030)<<(char *)mcd->mck<<eol;\n\t\t\t\t\t//makespace(p); commented out for RECALL\n\t\t\t\t\tdyninit(&ip);\n\t\t\t\t\tchar path\u00c41024\u00dc;\n\t\t\t\t\tsprintf(path,\"%s/%44.44s\",p\u00c4ml2dir\u00dc,mcd->mcdmcanm);\n\t\t\t\t\tif (strchr(path,' '))\n\t\t\t\t\t\t*strchr(path,' ') = 0;\n\t\t\t\t\tif (traceFlag)\n\t\t\t\t\t\tprintf(\" <Using path> Path:%s\u00d6n\",path);\n\n\t\t\t\t\tstruct stat info;\n\t\t\t\t\tif (stat(path, &info) == 0)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tint size2k = info.st_size/2048;\n\t\t\t\t\t\tif (abs(size2k-mcd->mcdcsz)<=p(delta))\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tFILE * input = fopen(path,\"rb,noseek\");\n\t\t\t\t\t\t\tif (input==NULL)\n\t\t\t\t\t\t\t\tcleanUp(Exit8,Msg(6006)<<path<<strerror(errno)<<eol);\n\t\t\t\t\t\t\tdyninit(&ip);\n\n\t\t\t\t\t\t\tchar  ddname\u00c49\u00dc = \"????????\";\n\t\t\t\t\t\t\tip.__ddname = ddname;\n\t\t\t\t\t\t\tip.__dsname = (char *)mcd->mcdmcanm;\n\t\t\t\t\t\t\tip.__unit = p\u00c4unit\u00dc;\n\t\t\t\t\t\t\tip.__volser = (char *)mcd->mcdvsn;\n\t\t\t\t\t\t\tip.__status=__DISP_NEW;\n\t\t\t\t\t\t\tip.__normdisp=__DISP_KEEP;\n\t\t\t\t\t\t\tip.__recfm=_FBS_;\n\t\t\t\t\t\t\tip.__lrecl=p(lrecl);\n\t\t\t\t\t\t\tip.__blksize=p(blksize);\n\t\t\t\t\t\t\tip.__avgblk = ip.__blksize;\n\t\t\t\t\t\t\tip.__primary = mcd->mcdcsz/(ip.__blksize/ip.__lrecl)+1;\n\t\t\t\t\t\t\tip.__secondary = ip.__primary;\n\n\t\t\t\t\t\t\tint count2k = 0;\n\t\t\t\t\t\t\tif (callDynalloc(&ip)==0)\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tchar dd\u00c418\u00dc;\n\t\t\t\t\t\t\t\tsprintf(dd,\"//DD:%8.8s\",ddname);\n\t\t\t\t\t\t\t\tchar mode\u00c4128\u00dc;\n\t\t\t\t\t\t\t\tsprintf(mode,\"wb,recfm=fbs,lrecl=%d,blksize=%d,noseek\",p(lrecl),p(blksize));\n\t\t\t\t\t\t\t\tif (traceFlag)\n\t\t\t\t\t\t\t\t\tprintf(\" <Before open>%s %s \u00d6n\",dd,mode);\n\t\t\t\t\t\t\t\tFILE * output = fopen(dd,mode);\n\t\t\t\t\t\t\t\tif (output==NULL)\n\t\t\t\t\t\t\t\t\tcleanUp(Return8,Msg(6006)<<ddname<<strerror(errno)<<eol,input,nullfile,&ip);\n\n\t\t\t\t\t\t\t\tint recl    = p(lrecl);\n\t\t\t\t\t\t\t\tmemset(buff,0,recl);\n\t\t\t\t\t\t\t\trc = fread(buff,1,recl,input);\n\t\t\t\t\t\t\t\tif (rc<=0)\n\t\t\t\t\t\t\t\t\tcleanUp(Return8,Msg(6011)<<path<<rc<<strerror(errno)<<eol,input,output,&ip);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tdo\u00e4\n\t\t\t\t\t\t\t\t\t\trc = fwrite(buff,1,rc,output);\n\t\t\t\t\t\t\t\t\t\tmemset(buff,0,recl);\n\t\t\t\t\t\t\t\t\t\tcount2k++;\n\t\t\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\twhile\n\t\t\t\t\t\t\t\t\t((rc=fread(buff,1,recl,input))>0);\n\t\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\tfclose(input);\n\t\t\t\t\t\t\t\tfclose(output);\n\t\t\t\t\t\t\t\tdynfree(&ip);\n\t\t\t\t\t\t\t\tif (p(okToRemove))\n\t\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tif (traceFlag)\n\t\t\t\t\t\t\t\t\t\tprintf(\" <Remove> remove %s\u00d6n\",path);\n\t\t\t\t\t\t\t\t\tif (remove(path))\n\t\t\t\t\t\t\t\t\t\tMsg(6026)<<path<<strerror(errno)<<eol;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tMsg(6027)<<path<<eol;\n\t\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tif (ip.__errcode==p(dynallocrc))\n\t\t\t\t\t\t\t\t\tcleanUp(Return0,Msg(6005)<<(char *)mcd->mck<<(char *)mcd->mcdmcanm<<(char *)mcd->mcdvsn<<eol);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\treturn 8;\n\t\t\t\t\t\t\t\t\u00fc\n\n\n\t\t\t\t\t\t\tif(count2k-mcd->mcdcsz)\n\t\t\t\t\t\t\t\tMsg(6007)<<count2k<<mcd->mcdcsz<<eol;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tMsg(6008)<<(char *)mcd->mck<<(char *)mcd->mcdmcanm<<(char *)mcd->mcdvsn<<mcd->mcdcsz<<eol;\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tMsg(6009)<<mcd->mcdmcanm<<mcd->mcdcsz<<size2k<<eol;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\telse\n\t\t\t\t\t\tcleanUp(Return8,Msg(6010)<<path<<strerror(errno)<<eol);\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n      else\n        if (memcmp(program,ML2SYNC_PROGRAM,7)==0)\n          return(ml2sync(p));\n\t\t\treturn 0;\n\t\u00fc\n\nstatic int makespace(parms & p)\n\t\u00e4\n\tmvsSTRING v(p\u00c4ml2vol\u00dc), vol;\n\tv.parse(vol,\",\",v);\n\n\twhile(strlen(vol))\n\t\t\u00e4\n\t\tif (strlen(vol)-6)\n\t\t\treturn(cleanUp(Return8,Msg(6020)<<v<<eol));\n\n\t\tif (traceFlag)\n\t\t\tprintf(\" <makespace> volume %s \u00d6n\",(char *)vol);\n\t\tint enqRc = ENQ(MVSHSMX_MAJOR ,vol,E,6,STEP,NONE);\n\t\tif (enqRc == 0)\n\t\t\u00e4\n\t\tif (traceFlag)\n\t\t\tprintf(\" <makespace> ENQ %s\u00d6n\",(char *)vol);\n\t\t__dyn_t ip;\n\t\tdyninit(&ip);\n\t\tchar vtocix\u00c4128\u00dc;\n\t\tsprintf(vtocix,\"SYS1.VTOCIX.%6.6s\",(char *)vol);\n\t\tchar  ddname\u00c49\u00dc = \"????????\";\n\t\tip.__ddname = ddname;\n\t\tip.__unit = p\u00c4unit\u00dc;\n\t\tip.__volser = (char *)vol;\n\t\tip.__status=__DISP_SHR;\n\t\tip.__normdisp=__DISP_KEEP;\n\t\tip.__dsname = vtocix;\n\n\t\tif (callDynalloc(&ip))\n\t\t\tMsg(6021)<<(char *)vol<<eol;\n\t\telse\n\t\t\t\u00e4\n\t\t\tf1dscb mydscb;\n\t\t\tmemset(&mydscb,0,sizeof(f1dscb));\n\t\t\tint vtocrc = mvs()->VtocOpen(ddname,p\u00c4ml2mask\u00dc,(char *)&mydscb);\n\t\t\tif (vtocrc<=4) //szm20051220 loop at DELETE error\n      do\n\t\t\t\t\u00e4\n\t\t\t\tif (strchr((char *)mydscb.ds1dsnam,' '))\n\t\t\t\t\t*strchr((char *)mydscb.ds1dsnam,' ')= 0;\n\t\t\t\tmydscb.ds1volsq\u00c40\u00dc = 0;\n\t\t\t\tif (traceFlag)\n\t\t\t\t\tprintf(\" <makespace> selected %s\u00d6n\",mydscb.ds1dsnam);\n\t\t\t\tif (memcmp((char *)vol,mydscb.ds1dssn,6))\n\t\t\t\t\t\u00e4\n\t\t\t\t\tif(vtocrc==0)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tcleanUp(Return8,Msg(6022)<<mydscb.ds1dssn<<(char *)vol<<mydscb.ds1dssn<<eol,nullfile,nullfile,NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\telse\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tcleanUp(Return0,Msg(6028)<<p\u00c4ml2mask\u00dc<<(char *)vol<<eol,nullfile,nullfile,NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\u00fc\n\t\t\t\t__dyn_t ip;\n\t\t\t\tdyninit(&ip);\n\t\t\t\tchar  ddname\u00c49\u00dc = \"????????\";\n\t\t\t\tip.__ddname = ddname;\n\t\t\t\tip.__dsname = (char *)mydscb.ds1dsnam;\n\t\t\t\tip.__unit = p\u00c4unit\u00dc;\n\t\t\t\tip.__volser = (char *)vol;\n\t\t\t\tip.__status=__DISP_OLD; //__DISP_SHR\n\t\t\t\tip.__normdisp=__DISP_KEEP;\n\t\t\t\tif (callDynalloc(&ip))\n\t\t\t\t\tMsg(6023)<<(char *)mydscb.ds1dsnam<<(char *)vol<<eol;\n\t\t\t\telse\n\t\t\t\t\t\u00e4\n\t\t\t\t\tchar dd\u00c418\u00dc;\n\t\t\t\t\tsprintf(dd,\"//DD:%s\",ddname);\n\t\t\t\t\tFILE * output = NULL;\n\t\t\t\t\tFILE * input = fopen(dd,\"rb,noseek\");\n\t\t\t\t\tif (input==NULL)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tcleanUp(Return8,Msg(6006)<<ddname<<strerror(errno)<<eol,nullfile,nullfile,&ip);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\tif (traceFlag)\n\t\t\t\t\t\tprintf(\" <makespace> input allocated to %s and opened as %s\u00d6n\",dd);\n\t\t\t\t\tchar path\u00c41024\u00dc;\n\t\t\t\t\tsprintf(path,\"%s/%s\",p\u00c4ml2dir\u00dc,mydscb.ds1dsnam);\n\t\t\t\t\tmode_t mode =  S_IRUSR ] S_IWUSR ] S_IXUSR ]\n\t\t\t\t\t\tS_IRGRP ] S_IWGRP ] S_IXGRP ]\n\t\t\t\t\t\tS_IROTH ] S_IWOTH ] S_IXOTH;\n\t\t\t\t\tint flag = O_WRONLY+O_CREAT;\n\t\t\t\t\tif (traceFlag)\n\t\t\t\t\t\tprintf(\" <makespace> flag:%x mode:%x\u00d6n\",flag,mode);\n\t\t\t\t\tint file = open(path,flag,mode);\n\t\t\t\t\tif (file ==  -1)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tcleanUp(Return8,Msg(6006)<<path<<strerror(errno)<<eol,input,nullfile,&ip);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\tif (traceFlag)\n\t\t\t\t\t\tprintf(\" <makespace> file:%s \u00d6n\",file);\n\n\t\t\t\t\t//chmod(path,mode);\n\t\t\t\t\t//file = open(path,flag,mode);\n\t\t\t\t\tif ((output = fdopen(file,\"wb,noseek\")) == NULL)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tcleanUp(Return8,Msg(6006)<<path<<strerror(errno)<<eol,input,nullfile,&ip);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\u00fc\n\n\t\t\t\t\tint count2k =0;\n\t\t\t\t\twhile(fread(buff,1,p(lrecl),input)==p(lrecl))\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tif (fwrite(buff,1,p(lrecl),output)-p(lrecl))\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tcleanUp(Return8,Msg(6024)<<path<<strerror(errno)<<eol,input,output,&ip);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcount2k++;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\tMsg(6025)<<(char *)mydscb.ds1dsnam<<path<<count2k<<eol;\n\t\t\t\t\tfclose(input);\n\t\t\t\t\tinput = NULL;\n\t\t\t\t\tfclose(output);\n\t\t\t\t\toutput = NULL;\n\t\t\t\t\tif (p(okToRemove))\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\tif (traceFlag)\n\t\t\t\t\t\t\tprintf(\" <makespace> remove %s\u00d6n\",dd);\n\t\t\t\t\t\tif (remove(dd))\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tcleanUp(Return8,Msg(6026)<<dd<<strerror(errno)<<eol,input,output,&ip);\n\t\t\t\t\t\t\t//continue;\n\t\t\t\t\t\t\tbreak; //szm20080205 abend after 2008:02:04 01:23:52 ARC6026E remove/delete error for //DD:SYS09916\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tMsg(6027)<<(char *)mydscb.ds1dsnam<<eol;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\tdynfree(&ip);\n\t\t\t\t\t\u00fc\n\t\t\t\tif (vtocrc==4)\n\t\t\t\t\tbreak;\n\t\t\t\t\u00fc\n\t\t\t\twhile((vtocrc= mvs()->Vtoc((char *)&mydscb))<=4); //szm20051220 loop at DELETE error\n\n\t\t\tif (traceFlag)\n\t\t\t\tprintf(\" <makespace> CloseVtoc %s\u00d6n\",vtocix);\n\t\t\tmvs()->VtocClose();\n\t\t\tdynfree(&ip);\n\t\t\t\u00fc\n\t\tif (traceFlag)\n\t\t\tprintf(\" <makespace> DEQ %s\u00d6n\",(char *)vol);\n\t\tDEQ(MVSHSMX_MAJOR ,vol,6,STEP,NONE);\n\t\t\u00fc\n\t\telse\n\t\t\tMsg(6056)<<enqRc<<eol;\n\t\tv.parse(vol,\",\",v);\n\t\t\u00fc\n\treturn 0;\n\t\u00fc\n\n\nvoid print_amrc(char * fb=NULL)\n  \u00e4\n  __amrc_type currErr = *__amrc;\n  if (fb)\n    \u00e4\n    sprintf(fb,\"R15 value   = %d\",currErr.__code.__feedback.__rc);\n    fb+=strlen(fb);\n    sprintf(fb,\"Reason code = %d\",currErr.__code.__feedback.__fdbk);\n    fb+=strlen(fb);\n    sprintf(fb,\"RBA         = %d\",currErr.__RBA);\n    fb+=strlen(fb);\n    sprintf(fb,\"Last op     = %d\u00d6n\",currErr.__last_op);\n    \u00fc\n  else\n    \u00e4\n    printf(\"R15 value   = %d\",currErr.__code.__feedback.__rc);\n    printf(\"Reason code = %d\",currErr.__code.__feedback.__fdbk);\n    printf(\"RBA         = %d\",currErr.__RBA);\n    printf(\"Last op     = %d\u00d6n\",currErr.__last_op);\n    \u00fc\n  return;\n  \u00fc\n\nfldata_t  * fattr(FILE *f)\n  \u00e4\n  static char fn\u00c41024\u00dc;\n  static fldata_t ft;\n  if (fldata(f,fn,&ft) == 0)\n    return &ft;\n  else\n    print_amrc();\n  return NULL;\n  \u00fc\n\n\nstatic int ml2sync(parms & p)\n  \u00e4\n  char * ml2prefix = \"DFHSM.HMIG.\";\n  FILE * mcdsF = fopen(p\u00c4mcds\u00dc,\"rb,type=record\");\n  fldata_t * fldataP = NULL;\n  if (mcdsF==NULL]](fldataP=fattr(mcdsF))==NULL)\n    return(cleanUp(Return8,Msg(6050)<<p\u00c4mcds\u00dc<<strerror(errno)<<eol));\n  Msg(6052)<<fldataP->__dsname<<fldataP->__vsamRKP<<fldataP->__vsamkeylen<<eol;\n  SORTEDmCHAIN mig;\n  char b\u00c432768\u00dc;\n  arcmcdP mcdP = (arcmcdP)b;\n  arcmckP mckP = (arcmckP)b;\n  size_t len = 0;\n  int count = 0;\n  int dircount = 0;\n  int removecount = 0;\n  while((len=fread(b,1,32768,mcdsF))>0)\n    \u00e4\n    //if (traceFlag)\n    //  dump(stdout,\"<mcds record>\",b,sizeof(struct arcmcd));\n    if (mckP->mcktype>0x40&&                      //dsn type\n      mckP->mchtype==0x00&&                     //dataset entry type\n      ((unsigned short)mcdP->mcdflgs&mcdfasn)&&  //valid migrated dataset\n      ((unsigned short)mcdP->mcdflgs&&mcdml2))   //on ML2 volume\n      \u00e4\n      if (strchr((char *)(mcdP->mcdmcanm),' '))\n        *strchr((char *)(mcdP->mcdmcanm),' ') = 0;\n      mig.add(new chainE((char *)mcdP->mcdmcanm));\n      count++;\n      if (traceFlag)\n        printf(\"<mig entry>%s from:%44.44s\u00d6n\",mcdP->mcdmcanm,mcdP->mck);\n      \u00fc\n    \u00fc\n  fclose(mcdsF);\n  Msg(6051)<<count<<eol;\n  Msg(6055)<<p\u00c4ml2dir\u00dc<<eol;\n  struct stat info;\n  if (stat(p\u00c4ml2dir\u00dc,&info)==NULL && S_ISDIR(info.st_mode))\n    \u00e4\n\n    DIR * dir = opendir(p\u00c4ml2dir\u00dc);\n    if (dir)\n      \u00e4\n      struct dirent * ent = NULL;\n      while((ent=__readdir2(dir,&info)))\n        \u00e4\n        dircount++;\n        char fullName\u00c41024\u00dc;\n        if (memcmp(ent->d_name,ml2prefix,strlen(ml2prefix)))\n          continue;\n        sprintf(fullName,\"%s/%s\",p\u00c4ml2dir\u00dc,ent->d_name);\n        if (traceFlag)\n          printf(\"<ML2 ent>%s full:%s\u00d6n\",ent->d_name,fullName);\n        if (stat(fullName,&info)==NULL && S_ISREG(info.st_mode))\n          \u00e4\n          if (mig.search(mvsSTRING(ent->d_name))==NULL)\n            \u00e4\n            removecount++;\n            if (traceFlag)\n              printf(\" <Remove> remove %s (as:%s)\u00d6n\",fullName,ent->d_name);\n\n            if (p(okToRemove))\n              \u00e4\n              if (remove(fullName))\n                Msg(6026)<<fullName<<strerror(errno)<<eol;\n              else\n                Msg(6027)<<fullName<<eol;\n              \u00fc\n            \u00fc\n          \u00fc\n        \u00fc\n      \u00fc\n    else\n      return(cleanUp(Return8,Msg(6053)<<p\u00c4ml2dir\u00dc<<strerror(errno)<<eol));\n    \u00fc\n  else\n    return(cleanUp(Return8,Msg(6053)<<p\u00c4ml2dir\u00dc<<strerror(errno)<<eol));\n  Msg(6054)<<count<<dircount<<removecount<<eol;\n  return 0;\n  \u00fc\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT883/CBT.V500.FILE883.PDS/CPP.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT883/CBT.V500.FILE883.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}